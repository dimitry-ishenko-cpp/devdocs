<h1>Active Record Query Interface</h1>
<div class="_simple"> <p>This guide covers different ways to retrieve data from the database using Active Record.</p>
<p>After reading this guide, you will know:</p> <ul> <li>How to find records using a variety of methods and conditions.</li> <li>How to specify the order, retrieved attributes, grouping, and other properties of the found records.</li> <li>How to use eager loading to reduce the number of database queries needed for data retrieval.</li> <li>How to use dynamic finder methods.</li> <li>How to use method chaining to use multiple Active Record methods together.</li> <li>How to check for the existence of particular records.</li> <li>How to perform various calculations on Active Record models.</li> <li>How to run EXPLAIN on relations.</li> </ul>  <h2 class="chapter">  Chapters </h2> <ol class="chapters"> <li><a href="#what-is-the-active-record-query-interface-questionmark">What is the Active Record Query Interface?</a></li> <li>
<a href="#retrieving-objects-from-the-database">Retrieving Objects from the Database</a> <ul> <li><a href="#retrieving-a-single-object">Retrieving a Single Object</a></li> <li><a href="#retrieving-multiple-objects-in-batches">Retrieving Multiple Objects in Batches</a></li> </ul>
</li> <li>
<a href="#conditions">Conditions</a> <ul> <li><a href="#pure-string-conditions">Pure String Conditions</a></li> <li><a href="#array-conditions">Array Conditions</a></li> <li><a href="#hash-conditions">Hash Conditions</a></li> <li><a href="#not-conditions">NOT Conditions</a></li> <li><a href="#or-conditions">OR Conditions</a></li> <li><a href="#and-conditions">AND Conditions</a></li> </ul>
</li> <li><a href="#ordering">Ordering</a></li> <li><a href="#selecting-specific-fields">Selecting Specific Fields</a></li> <li><a href="#limit-and-offset">Limit and Offset</a></li> <li>
<a href="#grouping">Grouping</a> <ul> <li><a href="#total-of-grouped-items">Total of Grouped Items</a></li> <li><a href="#having-conditions">HAVING Conditions</a></li> </ul>
</li> <li>
<a href="#overriding-conditions">Overriding Conditions</a> <ul> <li><a href="#unscope"><code>unscope</code></a></li> <li><a href="#only"><code>only</code></a></li> <li><a href="#reselect"><code>reselect</code></a></li> <li><a href="#reorder"><code>reorder</code></a></li> <li><a href="#reverse-order"><code>reverse_order</code></a></li> <li><a href="#rewhere"><code>rewhere</code></a></li> <li><a href="#regroup"><code>regroup</code></a></li> </ul>
</li> <li><a href="#null-relation">Null Relation</a></li> <li><a href="#readonly-objects">Readonly Objects</a></li> <li>
<a href="#locking-records-for-update">Locking Records for Update</a> <ul> <li><a href="#optimistic-locking">Optimistic Locking</a></li> <li><a href="#pessimistic-locking">Pessimistic Locking</a></li> </ul>
</li> <li>
<a href="#joining-tables">Joining Tables</a> <ul> <li><a href="#joins"><code>joins</code></a></li> <li><a href="#left-outer-joins"><code>left_outer_joins</code></a></li> <li><a href="#where-associated-and-where-missing"><code>where.associated</code> and <code>where.missing</code></a></li> </ul>
</li> <li>
<a href="#eager-loading-associations">Eager Loading Associations</a> <ul> <li><a href="#n-1-queries-problem">N + 1 Queries Problem</a></li> <li><a href="#includes"><code>includes</code></a></li> <li><a href="#preload"><code>preload</code></a></li> <li><a href="#eager-load"><code>eager_load</code></a></li> <li><a href="#strict-loading"><code>strict_loading</code></a></li> <li><a href="#strict-loading-bang"><code>strict_loading!</code></a></li> <li><a href="#strict-loading-option-on-an-association"><code>strict_loading</code> option on an association</a></li> </ul>
</li> <li>
<a href="#scopes">Scopes</a> <ul> <li><a href="#passing-in-arguments">Passing in Arguments</a></li> <li><a href="#using-conditionals">Using Conditionals</a></li> <li><a href="#applying-a-default-scope">Applying a Default Scope</a></li> <li><a href="#merging-of-scopes">Merging of Scopes</a></li> <li><a href="#removing-all-scoping">Removing All Scoping</a></li> </ul>
</li> <li><a href="#dynamic-finders">Dynamic Finders</a></li> <li><a href="#enums">Enums</a></li> <li>
<a href="#understanding-method-chaining">Understanding Method Chaining</a> <ul> <li><a href="#retrieving-filtered-data-from-multiple-tables">Retrieving Filtered Data from Multiple Tables</a></li> <li><a href="#retrieving-specific-data-from-multiple-tables">Retrieving Specific Data from Multiple Tables</a></li> </ul>
</li> <li>
<a href="#find-or-build-a-new-object">Find or Build a New Object</a> <ul> <li><a href="#find-or-create-by"><code>find_or_create_by</code></a></li> <li><a href="#find-or-create-by-bang"><code>find_or_create_by!</code></a></li> <li><a href="#find-or-initialize-by"><code>find_or_initialize_by</code></a></li> </ul>
</li> <li>
<a href="#finding-by-sql">Finding by SQL</a> <ul> <li><a href="#select-all"><code>select_all</code></a></li> <li><a href="#pluck"><code>pluck</code></a></li> <li><a href="#pick"><code>pick</code></a></li> <li><a href="#ids"><code>ids</code></a></li> </ul>
</li> <li><a href="#existence-of-objects">Existence of Objects</a></li> <li>
<a href="#calculations">Calculations</a> <ul> <li><a href="#count"><code>count</code></a></li> <li><a href="#average"><code>average</code></a></li> <li><a href="#minimum"><code>minimum</code></a></li> <li><a href="#maximum"><code>maximum</code></a></li> <li><a href="#sum"><code>sum</code></a></li> </ul>
</li> <li>
<a href="#running-explain">Running EXPLAIN</a> <ul> <li><a href="#explain-options">Explain Options</a></li> <li><a href="#interpreting-explain">Interpreting EXPLAIN</a></li> </ul>
</li> </ol>  <hr>  <h1 id="what-is-the-active-record-query-interface-questionmark"><a class="anchorlink" href="#what-is-the-active-record-query-interface-questionmark"><span>1</span> What is the Active Record Query Interface?</a></h1>
<p>If you're used to using raw SQL to find database records, then you will generally find that there are better ways to carry out the same operations in Rails. Active Record insulates you from the need to use SQL in most cases.</p>
<p>Active Record will perform queries on the database for you and is compatible with most database systems, including MySQL, MariaDB, PostgreSQL, and SQLite. Regardless of which database system you're using, the Active Record method format will always be the same.</p>
<p>Code examples throughout this guide will refer to one or more of the following models:</p>
<div class="interstitial info"><p>All of the following models use <code>id</code> as the primary key, unless specified otherwise.</p></div>
<div class="interstitial code"> <pre data-language="ruby">class Author &lt; ApplicationRecord
  has_many :books, -&gt; { order(year_published: :desc) }
end</pre> <button class="clipboard-button" data-clipboard-text="class Author &lt; ApplicationRecord
  has_many :books, -&gt; { order(year_published: :desc) }
end
">Copy</button> </div> <div class="interstitial code"> <pre data-language="ruby">class Book &lt; ApplicationRecord
  belongs_to :supplier
  belongs_to :author
  has_many :reviews
  has_and_belongs_to_many :orders, join_table: 'books_orders'

  scope :in_print, -&gt; { where(out_of_print: false) }
  scope :out_of_print, -&gt; { where(out_of_print: true) }
  scope :old, -&gt; { where(year_published: ...50.years.ago.year) }
  scope :out_of_print_and_expensive, -&gt; { out_of_print.where('price &gt; 500') }
  scope :costs_more_than, -&gt;(amount) { where('price &gt; ?', amount) }
end</pre> <button class="clipboard-button" data-clipboard-text="class Book &lt; ApplicationRecord
  belongs_to :supplier
  belongs_to :author
  has_many :reviews
  has_and_belongs_to_many :orders, join_table: 'books_orders'

  scope :in_print, -&gt; { where(out_of_print: false) }
  scope :out_of_print, -&gt; { where(out_of_print: true) }
  scope :old, -&gt; { where(year_published: ...50.years.ago.year) }
  scope :out_of_print_and_expensive, -&gt; { out_of_print.where('price &gt; 500') }
  scope :costs_more_than, -&gt;(amount) { where('price &gt; ?', amount) }
end
">Copy</button> </div> <div class="interstitial code"> <pre data-language="ruby">class Customer &lt; ApplicationRecord
  has_many :orders
  has_many :reviews
end</pre> <button class="clipboard-button" data-clipboard-text="class Customer &lt; ApplicationRecord
  has_many :orders
  has_many :reviews
end
">Copy</button> </div> <div class="interstitial code"> <pre data-language="ruby">class Order &lt; ApplicationRecord
  belongs_to :customer
  has_and_belongs_to_many :books, join_table: 'books_orders'

  enum :status, [:shipped, :being_packed, :complete, :cancelled]

  scope :created_before, -&gt;(time) { where(created_at: ...time) }
end</pre> <button class="clipboard-button" data-clipboard-text="class Order &lt; ApplicationRecord
  belongs_to :customer
  has_and_belongs_to_many :books, join_table: 'books_orders'

  enum :status, [:shipped, :being_packed, :complete, :cancelled]

  scope :created_before, -&gt;(time) { where(created_at: ...time) }
end
">Copy</button> </div> <div class="interstitial code"> <pre data-language="ruby">class Review &lt; ApplicationRecord
  belongs_to :customer
  belongs_to :book

  enum :state, [:not_reviewed, :published, :hidden]
end</pre> <button class="clipboard-button" data-clipboard-text="class Review &lt; ApplicationRecord
  belongs_to :customer
  belongs_to :book

  enum :state, [:not_reviewed, :published, :hidden]
end
">Copy</button> </div> <div class="interstitial code"> <pre data-language="ruby">class Supplier &lt; ApplicationRecord
  has_many :books
  has_many :authors, through: :books
end</pre> <button class="clipboard-button" data-clipboard-text="class Supplier &lt; ApplicationRecord
  has_many :books
  has_many :authors, through: :books
end
">Copy</button> </div> 
<h1 id="retrieving-objects-from-the-database"><a class="anchorlink" href="#retrieving-objects-from-the-database"><span>2</span> Retrieving Objects from the Database</a></h1>
<p>To retrieve objects from the database, Active Record provides several finder methods. Each finder method allows you to pass arguments into it to perform certain queries on your database without writing raw SQL.</p>
<p>The methods are:</p> <ul> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-annotate"><code>annotate</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/FinderMethods.html#method-i-find"><code>find</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-create_with"><code>create_with</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-distinct"><code>distinct</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-eager_load"><code>eager_load</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-extending"><code>extending</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-extract_associated"><code>extract_associated</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-from"><code>from</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-group"><code>group</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-having"><code>having</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-includes"><code>includes</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-joins"><code>joins</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-left_outer_joins"><code>left_outer_joins</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-limit"><code>limit</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-lock"><code>lock</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-none"><code>none</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-offset"><code>offset</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-optimizer_hints"><code>optimizer_hints</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-order"><code>order</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-preload"><code>preload</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-readonly"><code>readonly</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-references"><code>references</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-reorder"><code>reorder</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-reselect"><code>reselect</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-regroup"><code>regroup</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-reverse_order"><code>reverse_order</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-select"><code>select</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-where"><code>where</code></a></li> </ul> <p>Finder methods that return a collection, such as <code>where</code> and <code>group</code>, return an instance of <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Relation.html"><code>ActiveRecord::Relation</code></a>. Methods that find a single entity, such as <code>find</code> and <code>first</code>, return a single instance of the model.</p>
<p>The primary operation of <code>Model.find(options)</code> can be summarized as:</p> <ul> <li>Convert the supplied options to an equivalent SQL query.</li> <li>Fire the SQL query and retrieve the corresponding results from the database.</li> <li>Instantiate the equivalent Ruby object of the appropriate model for every resulting row.</li> <li>Run <code>after_find</code> and then <code>after_initialize</code> callbacks, if any.</li> </ul> <h2 id="retrieving-a-single-object"><a class="anchorlink" href="#retrieving-a-single-object"><span>2.1</span> Retrieving a Single Object</a></h2>
<p>Active Record provides several different ways of retrieving a single object.</p>
<h3 id="find"><a class="anchorlink" href="#find"><span>2.1.1</span> <code>find</code></a></h3>
<p>Using the <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/FinderMethods.html#method-i-find"><code>find</code></a> method, you can retrieve the object corresponding to the specified <em>primary key</em> that matches any supplied options. For example:</p>
<div class="interstitial code"> <pre data-language="irb"># Find the customer with primary key (id) 10.
irb&gt; customer = Customer.find(10)
=&gt; #&lt;Customer id: 10, first_name: "Ryan"&gt;</pre> <button class="clipboard-button" data-clipboard-text="customer = Customer.find(10)
">Copy</button> </div> <p>The SQL equivalent of the above is:</p>
<div class="interstitial code"> <pre data-language="sql">SELECT * FROM customers WHERE (customers.id = 10) LIMIT 1</pre> <button class="clipboard-button" data-clipboard-text="SELECT * FROM customers WHERE (customers.id = 10) LIMIT 1
">Copy</button> </div> <p>The <code>find</code> method will raise an <code>ActiveRecord::RecordNotFound</code> exception if no matching record is found.</p>
<p>You can also use this method to query for multiple objects. Call the <code>find</code> method and pass in an array of primary keys. The return will be an array containing all of the matching records for the supplied <em>primary keys</em>. For example:</p>
<div class="interstitial code"> <pre data-language="irb"># Find the customers with primary keys 1 and 10.
irb&gt; customers = Customer.find([1, 10]) # OR Customer.find(1, 10)
=&gt; [#&lt;Customer id: 1, first_name: "Lifo"&gt;, #&lt;Customer id: 10, first_name: "Ryan"&gt;]</pre> <button class="clipboard-button" data-clipboard-text="customers = Customer.find([1, 10]) # OR Customer.find(1, 10)
">Copy</button> </div> <p>The SQL equivalent of the above is:</p>
<div class="interstitial code"> <pre data-language="sql">SELECT * FROM customers WHERE (customers.id IN (1,10))</pre> <button class="clipboard-button" data-clipboard-text="SELECT * FROM customers WHERE (customers.id IN (1,10))
">Copy</button> </div> <div class="interstitial warning"><p>The <code>find</code> method will raise an <code>ActiveRecord::RecordNotFound</code> exception unless a matching record is found for <strong>all</strong> of the supplied primary keys.</p></div>
<p>If your table uses a composite primary key, you'll need to pass find an array to find a single item. For instance, if customers were defined with <code>[:store_id, :id]</code> as a primary key:</p>
<div class="interstitial code"> <pre data-language="irb"># Find the customer with store_id 3 and id 17
irb&gt; customers = Customer.find([3, 17])
=&gt; #&lt;Customer store_id: 3, id: 17, first_name: "Magda"&gt;</pre> <button class="clipboard-button" data-clipboard-text="customers = Customer.find([3, 17])
">Copy</button> </div> <p>The SQL equivalent of the above is:</p>
<div class="interstitial code"> <pre data-language="sql">SELECT * FROM customers WHERE store_id = 3 AND id = 17</pre> <button class="clipboard-button" data-clipboard-text="SELECT * FROM customers WHERE store_id = 3 AND id = 17
">Copy</button> </div> <p>To find multiple customers with composite IDs, you would pass an array of arrays:</p>
<div class="interstitial code"> <pre data-language="irb"># Find the customers with primary keys [1, 8] and [7, 15].
irb&gt; customers = Customer.find([[1, 8], [7, 15]]) # OR Customer.find([1, 8], [7, 15])
=&gt; [#&lt;Customer store_id: 1, id: 8, first_name: "Pat"&gt;, #&lt;Customer store_id: 7, id: 15, first_name: "Chris"&gt;]</pre> <button class="clipboard-button" data-clipboard-text="customers = Customer.find([[1, 8], [7, 15]]) # OR Customer.find([1, 8], [7, 15])
">Copy</button> </div> <p>The SQL equivalent of the above is:</p>
<div class="interstitial code"> <pre data-language="sql">SELECT * FROM customers WHERE (store_id = 1 AND id = 8 OR store_id = 7 AND id = 15)</pre> <button class="clipboard-button" data-clipboard-text="SELECT * FROM customers WHERE (store_id = 1 AND id = 8 OR store_id = 7 AND id = 15)
">Copy</button> </div> <h3 id="take"><a class="anchorlink" href="#take"><span>2.1.2</span> <code>take</code></a></h3>
<p>The <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/FinderMethods.html#method-i-take"><code>take</code></a> method retrieves a record without any implicit ordering. For example:</p>
<div class="interstitial code"> <pre data-language="irb">irb&gt; customer = Customer.take
=&gt; #&lt;Customer id: 1, first_name: "Lifo"&gt;</pre> <button class="clipboard-button" data-clipboard-text="customer = Customer.take
">Copy</button> </div> <p>The SQL equivalent of the above is:</p>
<div class="interstitial code"> <pre data-language="sql">SELECT * FROM customers LIMIT 1</pre> <button class="clipboard-button" data-clipboard-text="SELECT * FROM customers LIMIT 1
">Copy</button> </div> <p>The <code>take</code> method returns <code>nil</code> if no record is found and no exception will be raised.</p>
<p>You can pass in a numerical argument to the <code>take</code> method to return up to that number of results. For example</p>
<div class="interstitial code"> <pre data-language="irb">irb&gt; customers = Customer.take(2)
=&gt; [#&lt;Customer id: 1, first_name: "Lifo"&gt;, #&lt;Customer id: 220, first_name: "Sara"&gt;]</pre> <button class="clipboard-button" data-clipboard-text="customers = Customer.take(2)
">Copy</button> </div> <p>The SQL equivalent of the above is:</p>
<div class="interstitial code"> <pre data-language="sql">SELECT * FROM customers LIMIT 2</pre> <button class="clipboard-button" data-clipboard-text="SELECT * FROM customers LIMIT 2
">Copy</button> </div> <p>The <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/FinderMethods.html#method-i-take-21"><code>take!</code></a> method behaves exactly like <code>take</code>, except that it will raise <code>ActiveRecord::RecordNotFound</code> if no matching record is found.</p>
<div class="interstitial info"><p>The retrieved record may vary depending on the database engine.</p></div>
<h3 id="first"><a class="anchorlink" href="#first"><span>2.1.3</span> <code>first</code></a></h3>
<p>The <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/FinderMethods.html#method-i-first"><code>first</code></a> method finds the first record ordered by primary key (default). For example:</p>
<div class="interstitial code"> <pre data-language="irb">irb&gt; customer = Customer.first
=&gt; #&lt;Customer id: 1, first_name: "Lifo"&gt;</pre> <button class="clipboard-button" data-clipboard-text="customer = Customer.first
">Copy</button> </div> <p>The SQL equivalent of the above is:</p>
<div class="interstitial code"> <pre data-language="sql">SELECT * FROM customers ORDER BY customers.id ASC LIMIT 1</pre> <button class="clipboard-button" data-clipboard-text="SELECT * FROM customers ORDER BY customers.id ASC LIMIT 1
">Copy</button> </div> <p>The <code>first</code> method returns <code>nil</code> if no matching record is found and no exception will be raised.</p>
<p>If your <a href="active_record_querying.html#applying-a-default-scope">default scope</a> contains an order method, <code>first</code> will return the first record according to this ordering.</p>
<p>You can pass in a numerical argument to the <code>first</code> method to return up to that number of results. For example</p>
<div class="interstitial code"> <pre data-language="irb">irb&gt; customers = Customer.first(3)
=&gt; [#&lt;Customer id: 1, first_name: "Lifo"&gt;, #&lt;Customer id: 2, first_name: "Fifo"&gt;, #&lt;Customer id: 3, first_name: "Filo"&gt;]</pre> <button class="clipboard-button" data-clipboard-text="customers = Customer.first(3)
">Copy</button> </div> <p>The SQL equivalent of the above is:</p>
<div class="interstitial code"> <pre data-language="sql">SELECT * FROM customers ORDER BY customers.id ASC LIMIT 3</pre> <button class="clipboard-button" data-clipboard-text="SELECT * FROM customers ORDER BY customers.id ASC LIMIT 3
">Copy</button> </div> <p>Models with composite primary keys will use the full composite primary key for ordering. For instance, if customers were defined with <code>[:store_id, :id]</code> as a primary key:</p>
<div class="interstitial code"> <pre data-language="irb">irb&gt; customer = Customer.first
=&gt; #&lt;Customer id: 2, store_id: 1, first_name: "Lifo"&gt;</pre> <button class="clipboard-button" data-clipboard-text="customer = Customer.first
">Copy</button> </div> <p>The SQL equivalent of the above is:</p>
<div class="interstitial code"> <pre data-language="sql">SELECT * FROM customers ORDER BY customers.store_id ASC, customers.id ASC LIMIT 1</pre> <button class="clipboard-button" data-clipboard-text="SELECT * FROM customers ORDER BY customers.store_id ASC, customers.id ASC LIMIT 1
">Copy</button> </div> <p>On a collection that is ordered using <code>order</code>, <code>first</code> will return the first record ordered by the specified attribute for <code>order</code>.</p>
<div class="interstitial code"> <pre data-language="irb">irb&gt; customer = Customer.order(:first_name).first
=&gt; #&lt;Customer id: 2, first_name: "Fifo"&gt;</pre> <button class="clipboard-button" data-clipboard-text="customer = Customer.order(:first_name).first
">Copy</button> </div> <p>The SQL equivalent of the above is:</p>
<div class="interstitial code"> <pre data-language="sql">SELECT * FROM customers ORDER BY customers.first_name ASC LIMIT 1</pre> <button class="clipboard-button" data-clipboard-text="SELECT * FROM customers ORDER BY customers.first_name ASC LIMIT 1
">Copy</button> </div> <p>The <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/FinderMethods.html#method-i-first-21"><code>first!</code></a> method behaves exactly like <code>first</code>, except that it will raise <code>ActiveRecord::RecordNotFound</code> if no matching record is found.</p>
<h3 id="last"><a class="anchorlink" href="#last"><span>2.1.4</span> <code>last</code></a></h3>
<p>The <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/FinderMethods.html#method-i-last"><code>last</code></a> method finds the last record ordered by primary key (default). For example:</p>
<div class="interstitial code"> <pre data-language="irb">irb&gt; customer = Customer.last
=&gt; #&lt;Customer id: 221, first_name: "Russel"&gt;</pre> <button class="clipboard-button" data-clipboard-text="customer = Customer.last
">Copy</button> </div> <p>The SQL equivalent of the above is:</p>
<div class="interstitial code"> <pre data-language="sql">SELECT * FROM customers ORDER BY customers.id DESC LIMIT 1</pre> <button class="clipboard-button" data-clipboard-text="SELECT * FROM customers ORDER BY customers.id DESC LIMIT 1
">Copy</button> </div> <p>The <code>last</code> method returns <code>nil</code> if no matching record is found and no exception will be raised.</p>
<p>Models with composite primary keys will use the full composite primary key for ordering. For instance, if customers were defined with <code>[:store_id, :id]</code> as a primary key:</p>
<div class="interstitial code"> <pre data-language="irb">irb&gt; customer = Customer.last
=&gt; #&lt;Customer id: 221, store_id: 1, first_name: "Lifo"&gt;</pre> <button class="clipboard-button" data-clipboard-text="customer = Customer.last
">Copy</button> </div> <p>The SQL equivalent of the above is:</p>
<div class="interstitial code"> <pre data-language="sql">SELECT * FROM customers ORDER BY customers.store_id DESC, customers.id DESC LIMIT 1</pre> <button class="clipboard-button" data-clipboard-text="SELECT * FROM customers ORDER BY customers.store_id DESC, customers.id DESC LIMIT 1
">Copy</button> </div> <p>If your <a href="active_record_querying.html#applying-a-default-scope">default scope</a> contains an order method, <code>last</code> will return the last record according to this ordering.</p>
<p>You can pass in a numerical argument to the <code>last</code> method to return up to that number of results. For example</p>
<div class="interstitial code"> <pre data-language="irb">irb&gt; customers = Customer.last(3)
=&gt; [#&lt;Customer id: 219, first_name: "James"&gt;, #&lt;Customer id: 220, first_name: "Sara"&gt;, #&lt;Customer id: 221, first_name: "Russel"&gt;]</pre> <button class="clipboard-button" data-clipboard-text="customers = Customer.last(3)
">Copy</button> </div> <p>The SQL equivalent of the above is:</p>
<div class="interstitial code"> <pre data-language="sql">SELECT * FROM customers ORDER BY customers.id DESC LIMIT 3</pre> <button class="clipboard-button" data-clipboard-text="SELECT * FROM customers ORDER BY customers.id DESC LIMIT 3
">Copy</button> </div> <p>On a collection that is ordered using <code>order</code>, <code>last</code> will return the last record ordered by the specified attribute for <code>order</code>.</p>
<div class="interstitial code"> <pre data-language="irb">irb&gt; customer = Customer.order(:first_name).last
=&gt; #&lt;Customer id: 220, first_name: "Sara"&gt;</pre> <button class="clipboard-button" data-clipboard-text="customer = Customer.order(:first_name).last
">Copy</button> </div> <p>The SQL equivalent of the above is:</p>
<div class="interstitial code"> <pre data-language="sql">SELECT * FROM customers ORDER BY customers.first_name DESC LIMIT 1</pre> <button class="clipboard-button" data-clipboard-text="SELECT * FROM customers ORDER BY customers.first_name DESC LIMIT 1
">Copy</button> </div> <p>The <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/FinderMethods.html#method-i-last-21"><code>last!</code></a> method behaves exactly like <code>last</code>, except that it will raise <code>ActiveRecord::RecordNotFound</code> if no matching record is found.</p>
<h3 id="find-by"><a class="anchorlink" href="#find-by"><span>2.1.5</span> <code>find_by</code></a></h3>
<p>The <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/FinderMethods.html#method-i-find_by"><code>find_by</code></a> method finds the first record matching some conditions. For example:</p>
<div class="interstitial code"> <pre data-language="irb">irb&gt; Customer.find_by first_name: 'Lifo'
=&gt; #&lt;Customer id: 1, first_name: "Lifo"&gt;

irb&gt; Customer.find_by first_name: 'Jon'
=&gt; nil</pre> <button class="clipboard-button" data-clipboard-text="Customer.find_by first_name: 'Lifo'
Customer.find_by first_name: 'Jon'
">Copy</button> </div> <p>It is equivalent to writing:</p>
<div class="interstitial code"> <pre data-language="ruby">Customer.where(first_name: 'Lifo').take</pre> <button class="clipboard-button" data-clipboard-text="Customer.where(first_name: 'Lifo').take
">Copy</button> </div> <p>The SQL equivalent of the above is:</p>
<div class="interstitial code"> <pre data-language="sql">SELECT * FROM customers WHERE (customers.first_name = 'Lifo') LIMIT 1</pre> <button class="clipboard-button" data-clipboard-text="SELECT * FROM customers WHERE (customers.first_name = 'Lifo') LIMIT 1
">Copy</button> </div> <p>Note that there is no <code>ORDER BY</code> in the above SQL. If your <code>find_by</code> conditions can match multiple records, you should <a href="#ordering">apply an order</a> to guarantee a deterministic result.</p>
<p>The <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/FinderMethods.html#method-i-find_by-21"><code>find_by!</code></a> method behaves exactly like <code>find_by</code>, except that it will raise <code>ActiveRecord::RecordNotFound</code> if no matching record is found. For example:</p>
<div class="interstitial code"> <pre data-language="irb">irb&gt; Customer.find_by! first_name: 'does not exist'
ActiveRecord::RecordNotFound</pre> <button class="clipboard-button" data-clipboard-text="Customer.find_by! first_name: 'does not exist'
">Copy</button> </div> <p>This is equivalent to writing:</p>
<div class="interstitial code"> <pre data-language="ruby">Customer.where(first_name: 'does not exist').take!</pre> <button class="clipboard-button" data-clipboard-text="Customer.where(first_name: 'does not exist').take!
">Copy</button> </div> <h4 id="conditions-with-id"><a class="anchorlink" href="#conditions-with-id"><span>2.1.5.1</span> Conditions with <code>:id</code></a></h4>
<p>When specifying conditions on methods like <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/FinderMethods.html#method-i-find_by"><code>find_by</code></a> and <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-where"><code>where</code></a>, the use of <code>id</code> will match against an <code>:id</code> attribute on the model. This is different from <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/FinderMethods.html#method-i-find"><code>find</code></a>, where the ID passed in should be a primary key value.</p>
<p>Take caution when using <code>find_by(id:)</code> on models where <code>:id</code> is not the primary key, such as composite primary key models. For example, if customers were defined with <code>[:store_id, :id]</code> as a primary key:</p>
<div class="interstitial code"> <pre data-language="irb">irb&gt; customer = Customer.last
=&gt; #&lt;Customer id: 10, store_id: 5, first_name: "Joe"&gt;
irb&gt; Customer.find_by(id: customer.id) # Customer.find_by(id: [5, 10])
=&gt; #&lt;Customer id: 5, store_id: 3, first_name: "Bob"&gt;</pre> <button class="clipboard-button" data-clipboard-text="customer = Customer.last
Customer.find_by(id: customer.id) # Customer.find_by(id: [5, 10])
">Copy</button> </div> <p>Here, we might intend to search for a single record with the composite primary key <code>[5, 10]</code>, but Active Record will search for a record with an <code>:id</code> column of <em>either</em> 5 or 10, and may return the wrong record.</p>
<div class="interstitial info"><p>The <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/ModelSchema.html#method-i-id_value"><code>id_value</code></a> method can be used to fetch the value of the <code>:id</code> column for a record, for use in finder methods such as <code>find_by</code> and <code>where</code>. See example below:</p></div>
<div class="interstitial code"> <pre data-language="irb">irb&gt; customer = Customer.last
=&gt; #&lt;Customer id: 10, store_id: 5, first_name: "Joe"&gt;
irb&gt; Customer.find_by(id: customer.id_value) # Customer.find_by(id: 10)
=&gt; #&lt;Customer id: 10, store_id: 5, first_name: "Joe"&gt;</pre> <button class="clipboard-button" data-clipboard-text="customer = Customer.last
Customer.find_by(id: customer.id_value) # Customer.find_by(id: 10)
">Copy</button> </div> <h2 id="retrieving-multiple-objects-in-batches"><a class="anchorlink" href="#retrieving-multiple-objects-in-batches"><span>2.2</span> Retrieving Multiple Objects in Batches</a></h2>
<p>We often need to iterate over a large set of records, as when we send a newsletter to a large set of customers, or when we export data.</p>
<p>This may appear straightforward:</p>
<div class="interstitial code"> <pre data-language="ruby"># This may consume too much memory if the table is big.
Customer.all.each do |customer|
  NewsMailer.weekly(customer).deliver_now
end</pre> <button class="clipboard-button" data-clipboard-text="# This may consume too much memory if the table is big.
Customer.all.each do |customer|
  NewsMailer.weekly(customer).deliver_now
end
">Copy</button> </div> <p>But this approach becomes increasingly impractical as the table size increases, since <code>Customer.all.each</code> instructs Active Record to fetch <em>the entire table</em> in a single pass, build a model object per row, and then keep the entire array of model objects in memory. Indeed, if we have a large number of records, the entire collection may exceed the amount of memory available.</p>
<p>Rails provides two methods that address this problem by dividing records into memory-friendly batches for processing. The first method, <code>find_each</code>, retrieves a batch of records and then yields <em>each</em> record to the block individually as a model. The second method, <code>find_in_batches</code>, retrieves a batch of records and then yields <em>the entire batch</em> to the block as an array of models.</p>
<div class="interstitial info"><p>The <code>find_each</code> and <code>find_in_batches</code> methods are intended for use in the batch processing of a large number of records that wouldn't fit in memory all at once. If you just need to loop over a thousand records the regular find methods are the preferred option.</p></div>
<h3 id="find-each"><a class="anchorlink" href="#find-each"><span>2.2.1</span> <code>find_each</code></a></h3>
<p>The <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Batches.html#method-i-find_each"><code>find_each</code></a> method retrieves records in batches and then yields <em>each</em> one to the block. In the following example, <code>find_each</code> retrieves customers in batches of 1000 and yields them to the block one by one:</p>
<div class="interstitial code"> <pre data-language="ruby">Customer.find_each do |customer|
  NewsMailer.weekly(customer).deliver_now
end</pre> <button class="clipboard-button" data-clipboard-text="Customer.find_each do |customer|
  NewsMailer.weekly(customer).deliver_now
end
">Copy</button> </div> <p>This process is repeated, fetching more batches as needed, until all of the records have been processed.</p>
<p><code>find_each</code> works on model classes, as seen above, and also on relations:</p>
<div class="interstitial code"> <pre data-language="ruby">Customer.where(weekly_subscriber: true).find_each do |customer|
  NewsMailer.weekly(customer).deliver_now
end</pre> <button class="clipboard-button" data-clipboard-text="Customer.where(weekly_subscriber: true).find_each do |customer|
  NewsMailer.weekly(customer).deliver_now
end
">Copy</button> </div> <p>as long as they have no ordering, since the method needs to force an order internally to iterate.</p>
<p>If an order is present in the receiver the behavior depends on the flag <a href="configuring.html#config-active-record-error-on-ignored-order"><code>config.active_record.error_on_ignored_order</code></a>. If true, <code>ArgumentError</code> is raised, otherwise the order is ignored and a warning issued, which is the default. This can be overridden with the option <code>:error_on_ignore</code>, explained below.</p>
<h4 id="options-for-find-each"><a class="anchorlink" href="#options-for-find-each"><span>2.2.1.1</span> Options for <code>find_each</code></a></h4>
<p><strong><code>:batch_size</code></strong></p>
<p>The <code>:batch_size</code> option allows you to specify the number of records to be retrieved in each batch, before being passed individually to the block. For example, to retrieve records in batches of 5000:</p>
<div class="interstitial code"> <pre data-language="ruby">Customer.find_each(batch_size: 5000) do |customer|
  NewsMailer.weekly(customer).deliver_now
end</pre> <button class="clipboard-button" data-clipboard-text="Customer.find_each(batch_size: 5000) do |customer|
  NewsMailer.weekly(customer).deliver_now
end
">Copy</button> </div> <p><strong><code>:start</code></strong></p>
<p>By default, records are fetched in ascending order of the primary key. The <code>:start</code> option allows you to configure the first ID of the sequence whenever the lowest ID is not the one you need. This would be useful, for example, if you wanted to resume an interrupted batch process, provided you saved the last processed ID as a checkpoint.</p>
<p>For example, to send newsletters only to customers with the primary key starting from 2000:</p>
<div class="interstitial code"> <pre data-language="ruby">Customer.find_each(start: 2000) do |customer|
  NewsMailer.weekly(customer).deliver_now
end</pre> <button class="clipboard-button" data-clipboard-text="Customer.find_each(start: 2000) do |customer|
  NewsMailer.weekly(customer).deliver_now
end
">Copy</button> </div> <p><strong><code>:finish</code></strong></p>
<p>Similar to the <code>:start</code> option, <code>:finish</code> allows you to configure the last ID of the sequence whenever the highest ID is not the one you need. This would be useful, for example, if you wanted to run a batch process using a subset of records based on <code>:start</code> and <code>:finish</code>.</p>
<p>For example, to send newsletters only to customers with the primary key starting from 2000 up to 10000:</p>
<div class="interstitial code"> <pre data-language="ruby">Customer.find_each(start: 2000, finish: 10000) do |customer|
  NewsMailer.weekly(customer).deliver_now
end</pre> <button class="clipboard-button" data-clipboard-text="Customer.find_each(start: 2000, finish: 10000) do |customer|
  NewsMailer.weekly(customer).deliver_now
end
">Copy</button> </div> <p>Another example would be if you wanted multiple workers handling the same processing queue. You could have each worker handle 10000 records by setting the appropriate <code>:start</code> and <code>:finish</code> options on each worker.</p>
<p><strong><code>:error_on_ignore</code></strong></p>
<p>Overrides the application config to specify if an error should be raised when an order is present in the relation.</p>
<p><strong><code>:order</code></strong></p>
<p>Specifies the primary key order (can be <code>:asc</code> or <code>:desc</code>). Defaults to <code>:asc</code>.</p>
<div class="interstitial code"> <pre data-language="ruby">Customer.find_each(order: :desc) do |customer|
  NewsMailer.weekly(customer).deliver_now
end</pre> <button class="clipboard-button" data-clipboard-text="Customer.find_each(order: :desc) do |customer|
  NewsMailer.weekly(customer).deliver_now
end
">Copy</button> </div> <h3 id="find-in-batches"><a class="anchorlink" href="#find-in-batches"><span>2.2.2</span> <code>find_in_batches</code></a></h3>
<p>The <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Batches.html#method-i-find_in_batches"><code>find_in_batches</code></a> method is similar to <code>find_each</code>, since both retrieve batches of records. The difference is that <code>find_in_batches</code> yields <em>batches</em> to the block as an array of models, instead of individually. The following example will yield to the supplied block an array of up to 1000 customers at a time, with the final block containing any remaining customers:</p>
<div class="interstitial code"> <pre data-language="ruby"># Give add_customers an array of 1000 customers at a time.
Customer.find_in_batches do |customers|
  export.add_customers(customers)
end</pre> <button class="clipboard-button" data-clipboard-text="# Give add_customers an array of 1000 customers at a time.
Customer.find_in_batches do |customers|
  export.add_customers(customers)
end
">Copy</button> </div> <p><code>find_in_batches</code> works on model classes, as seen above, and also on relations:</p>
<div class="interstitial code"> <pre data-language="ruby"># Give add_customers an array of 1000 recently active customers at a time.
Customer.recently_active.find_in_batches do |customers|
  export.add_customers(customers)
end</pre> <button class="clipboard-button" data-clipboard-text="# Give add_customers an array of 1000 recently active customers at a time.
Customer.recently_active.find_in_batches do |customers|
  export.add_customers(customers)
end
">Copy</button> </div> <p>as long as they have no ordering, since the method needs to force an order internally to iterate.</p>
<h4 id="options-for-find-in-batches"><a class="anchorlink" href="#options-for-find-in-batches"><span>2.2.2.1</span> Options for <code>find_in_batches</code></a></h4>
<p>The <code>find_in_batches</code> method accepts the same options as <code>find_each</code>:</p>
<p><strong><code>:batch_size</code></strong></p>
<p>Just like for <code>find_each</code>, <code>batch_size</code> establishes how many records will be retrieved in each group. For example, retrieving batches of 2500 records can be specified as:</p>
<div class="interstitial code"> <pre data-language="ruby">Customer.find_in_batches(batch_size: 2500) do |customers|
  export.add_customers(customers)
end</pre> <button class="clipboard-button" data-clipboard-text="Customer.find_in_batches(batch_size: 2500) do |customers|
  export.add_customers(customers)
end
">Copy</button> </div> <p><strong><code>:start</code></strong></p>
<p>The <code>start</code> option allows specifying the beginning ID from where records will be selected. As mentioned before, by default records are fetched in ascending order of the primary key. For example, to retrieve customers starting on ID: 5000 in batches of 2500 records, the following code can be used:</p>
<div class="interstitial code"> <pre data-language="ruby">Customer.find_in_batches(batch_size: 2500, start: 5000) do |customers|
  export.add_customers(customers)
end</pre> <button class="clipboard-button" data-clipboard-text="Customer.find_in_batches(batch_size: 2500, start: 5000) do |customers|
  export.add_customers(customers)
end
">Copy</button> </div> <p><strong><code>:finish</code></strong></p>
<p>The <code>finish</code> option allows specifying the ending ID of the records to be retrieved. The code below shows the case of retrieving customers in batches, up to the customer with ID: 7000:</p>
<div class="interstitial code"> <pre data-language="ruby">Customer.find_in_batches(finish: 7000) do |customers|
  export.add_customers(customers)
end</pre> <button class="clipboard-button" data-clipboard-text="Customer.find_in_batches(finish: 7000) do |customers|
  export.add_customers(customers)
end
">Copy</button> </div> <p><strong><code>:error_on_ignore</code></strong></p>
<p>The <code>error_on_ignore</code> option overrides the application config to specify if an error should be raised when a specific order is present in the relation.</p>
<h1 id="conditions"><a class="anchorlink" href="#conditions"><span>3</span> Conditions</a></h1>
<p>The <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-where"><code>where</code></a> method allows you to specify conditions to limit the records returned, representing the <code>WHERE</code>-part of the SQL statement. Conditions can either be specified as a string, array, or hash.</p>
<h2 id="pure-string-conditions"><a class="anchorlink" href="#pure-string-conditions"><span>3.1</span> Pure String Conditions</a></h2>
<p>If you'd like to add conditions to your find, you could just specify them in there, just like <code>Book.where("title = 'Introduction to Algorithms'")</code>. This will find all books where the <code>title</code> field value is 'Introduction to Algorithms'.</p>
<div class="interstitial warning"><p>Building your own conditions as pure strings can leave you vulnerable to SQL injection exploits. For example, <code>Book.where("title LIKE '%#{params[:title]}%'")</code> is not safe. See the next section for the preferred way to handle conditions using an array.</p></div>
<h2 id="array-conditions"><a class="anchorlink" href="#array-conditions"><span>3.2</span> Array Conditions</a></h2>
<p>Now what if that title could vary, say as an argument from somewhere? The find would then take the form:</p>
<div class="interstitial code"> <pre data-language="ruby">Book.where("title = ?", params[:title])</pre> <button class="clipboard-button" data-clipboard-text='Book.where("title = ?", params[:title])
'>Copy</button> </div> <p>Active Record will take the first argument as the conditions string and any additional arguments will replace the question marks <code>(?)</code> in it.</p>
<p>If you want to specify multiple conditions:</p>
<div class="interstitial code"> <pre data-language="ruby">Book.where("title = ? AND out_of_print = ?", params[:title], false)</pre> <button class="clipboard-button" data-clipboard-text='Book.where("title = ? AND out_of_print = ?", params[:title], false)
'>Copy</button> </div> <p>In this example, the first question mark will be replaced with the value in <code>params[:title]</code> and the second will be replaced with the SQL representation of <code>false</code>, which depends on the adapter.</p>
<p>This code is highly preferable:</p>
<div class="interstitial code"> <pre data-language="ruby">Book.where("title = ?", params[:title])</pre> <button class="clipboard-button" data-clipboard-text='Book.where("title = ?", params[:title])
'>Copy</button> </div> <p>to this code:</p>
<div class="interstitial code"> <pre data-language="ruby">Book.where("title = #{params[:title]}")</pre> <button class="clipboard-button" data-clipboard-text='Book.where("title = #{params[:title]}")
'>Copy</button> </div> <p>because of argument safety. Putting the variable directly into the conditions string will pass the variable to the database <strong>as-is</strong>. This means that it will be an unescaped variable directly from a user who may have malicious intent. If you do this, you put your entire database at risk because once a user finds out they can exploit your database they can do just about anything to it. Never ever put your arguments directly inside the conditions string.</p>
<div class="interstitial info"><p>For more information on the dangers of SQL injection, see the <a href="security.html#sql-injection">Ruby on Rails Security Guide</a>.</p></div>
<h3 id="placeholder-conditions"><a class="anchorlink" href="#placeholder-conditions"><span>3.2.1</span> Placeholder Conditions</a></h3>
<p>Similar to the <code>(?)</code> replacement style of params, you can also specify keys in your conditions string along with a corresponding keys/values hash:</p>
<div class="interstitial code"> <pre data-language="ruby">Book.where("created_at &gt;= :start_date AND created_at &lt;= :end_date",
  { start_date: params[:start_date], end_date: params[:end_date] })</pre> <button class="clipboard-button" data-clipboard-text='Book.where("created_at &gt;= :start_date AND created_at &lt;= :end_date",
  { start_date: params[:start_date], end_date: params[:end_date] })
'>Copy</button> </div> <p>This makes for clearer readability if you have a large number of variable conditions.</p>
<h3 id="conditions-that-use-like"><a class="anchorlink" href="#conditions-that-use-like"><span>3.2.2</span> Conditions That Use <code>LIKE</code></a></h3>
<p>Although condition arguments are automatically escaped to prevent SQL injection, SQL <code>LIKE</code> wildcards (i.e., <code>%</code> and <code>_</code>) are <strong>not</strong> escaped. This may cause unexpected behavior if an unsanitized value is used in an argument. For example:</p>
<div class="interstitial code"> <pre data-language="ruby">Book.where("title LIKE ?", params[:title] + "%")</pre> <button class="clipboard-button" data-clipboard-text='Book.where("title LIKE ?", params[:title] + "%")
'>Copy</button> </div> <p>In the above code, the intent is to match titles that start with a user-specified string. However, any occurrences of <code>%</code> or <code>_</code> in <code>params[:title]</code> will be treated as wildcards, leading to surprising query results. In some circumstances, this may also prevent the database from using an intended index, leading to a much slower query.</p>
<p>To avoid these problems, use <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Sanitization/ClassMethods.html#method-i-sanitize_sql_like"><code>sanitize_sql_like</code></a> to escape wildcard characters in the relevant portion of the argument:</p>
<div class="interstitial code"> <pre data-language="ruby">Book.where("title LIKE ?",
  Book.sanitize_sql_like(params[:title]) + "%")</pre> <button class="clipboard-button" data-clipboard-text='Book.where("title LIKE ?",
  Book.sanitize_sql_like(params[:title]) + "%")
'>Copy</button> </div> <h2 id="hash-conditions"><a class="anchorlink" href="#hash-conditions"><span>3.3</span> Hash Conditions</a></h2>
<p>Active Record also allows you to pass in hash conditions which can increase the readability of your conditions syntax. With hash conditions, you pass in a hash with keys of the fields you want qualified and the values of how you want to qualify them:</p>
<div class="interstitial note"><p>Only equality, range, and subset checking are possible with Hash conditions.</p></div>
<h3 id="equality-conditions"><a class="anchorlink" href="#equality-conditions"><span>3.3.1</span> Equality Conditions</a></h3>
<div class="interstitial code"> <pre data-language="ruby">Book.where(out_of_print: true)</pre> <button class="clipboard-button" data-clipboard-text="Book.where(out_of_print: true)
">Copy</button> </div> <p>This will generate SQL like this:</p>
<div class="interstitial code"> <pre data-language="sql">SELECT * FROM books WHERE (books.out_of_print = 1)</pre> <button class="clipboard-button" data-clipboard-text="SELECT * FROM books WHERE (books.out_of_print = 1)
">Copy</button> </div> <p>The field name can also be a string:</p>
<div class="interstitial code"> <pre data-language="ruby">Book.where('out_of_print' =&gt; true)</pre> <button class="clipboard-button" data-clipboard-text="Book.where('out_of_print' =&gt; true)
">Copy</button> </div> <p>In the case of a belongs_to relationship, an association key can be used to specify the model if an Active Record object is used as the value. This method works with polymorphic relationships as well.</p>
<div class="interstitial code"> <pre data-language="ruby">author = Author.first
Book.where(author: author)
Author.joins(:books).where(books: { author: author })</pre> <button class="clipboard-button" data-clipboard-text="author = Author.first
Book.where(author: author)
Author.joins(:books).where(books: { author: author })
">Copy</button> </div> <p>Hash conditions may also be specified in a tuple-like syntax, where the key is an array of columns and the value is an array of tuples:</p>
<div class="interstitial code"> <pre data-language="ruby">Book.where([:author_id, :id] =&gt; [[15, 1], [15, 2]])</pre> <button class="clipboard-button" data-clipboard-text="Book.where([:author_id, :id] =&gt; [[15, 1], [15, 2]])
">Copy</button> </div> <p>This syntax can be useful for querying relations where the table uses a composite primary key:</p>
<div class="interstitial code"> <pre data-language="ruby">class Book &lt; ApplicationRecord
  self.primary_key = [:author_id, :id]
end

Book.where(Book.primary_key =&gt; [[2, 1], [3, 1]])</pre> <button class="clipboard-button" data-clipboard-text="class Book &lt; ApplicationRecord
  self.primary_key = [:author_id, :id]
end

Book.where(Book.primary_key =&gt; [[2, 1], [3, 1]])
">Copy</button> </div> <h3 id="range-conditions"><a class="anchorlink" href="#range-conditions"><span>3.3.2</span> Range Conditions</a></h3>
<div class="interstitial code"> <pre data-language="ruby">Book.where(created_at: (Time.now.midnight - 1.day)..Time.now.midnight)</pre> <button class="clipboard-button" data-clipboard-text="Book.where(created_at: (Time.now.midnight - 1.day)..Time.now.midnight)
">Copy</button> </div> <p>This will find all books created yesterday by using a <code>BETWEEN</code> SQL statement:</p>
<div class="interstitial code"> <pre data-language="sql">SELECT * FROM books WHERE (books.created_at BETWEEN '2008-12-21 00:00:00' AND '2008-12-22 00:00:00')</pre> <button class="clipboard-button" data-clipboard-text="SELECT * FROM books WHERE (books.created_at BETWEEN '2008-12-21 00:00:00' AND '2008-12-22 00:00:00')
">Copy</button> </div> <p>This demonstrates a shorter syntax for the examples in <a href="#array-conditions">Array Conditions</a></p>
<p>Beginless and endless ranges are supported and can be used to build less/greater than conditions.</p>
<div class="interstitial code"> <pre data-language="ruby">Book.where(created_at: (Time.now.midnight - 1.day)..)</pre> <button class="clipboard-button" data-clipboard-text="Book.where(created_at: (Time.now.midnight - 1.day)..)
">Copy</button> </div> <p>This would generate SQL like:</p>
<div class="interstitial code"> <pre data-language="sql">SELECT * FROM books WHERE books.created_at &gt;= '2008-12-21 00:00:00'</pre> <button class="clipboard-button" data-clipboard-text="SELECT * FROM books WHERE books.created_at &gt;= '2008-12-21 00:00:00'
">Copy</button> </div> <h3 id="subset-conditions"><a class="anchorlink" href="#subset-conditions"><span>3.3.3</span> Subset Conditions</a></h3>
<p>If you want to find records using the <code>IN</code> expression you can pass an array to the conditions hash:</p>
<div class="interstitial code"> <pre data-language="ruby">Customer.where(orders_count: [1, 3, 5])</pre> <button class="clipboard-button" data-clipboard-text="Customer.where(orders_count: [1, 3, 5])
">Copy</button> </div> <p>This code will generate SQL like this:</p>
<div class="interstitial code"> <pre data-language="sql">SELECT * FROM customers WHERE (customers.orders_count IN (1,3,5))</pre> <button class="clipboard-button" data-clipboard-text="SELECT * FROM customers WHERE (customers.orders_count IN (1,3,5))
">Copy</button> </div> <h2 id="not-conditions"><a class="anchorlink" href="#not-conditions"><span>3.4</span> NOT Conditions</a></h2>
<p><code>NOT</code> SQL queries can be built by <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/QueryMethods/WhereChain.html#method-i-not"><code>where.not</code></a>:</p>
<div class="interstitial code"> <pre data-language="ruby">Customer.where.not(orders_count: [1, 3, 5])</pre> <button class="clipboard-button" data-clipboard-text="Customer.where.not(orders_count: [1, 3, 5])
">Copy</button> </div> <p>In other words, this query can be generated by calling <code>where</code> with no argument, then immediately chain with <code>not</code> passing <code>where</code> conditions. This will generate SQL like this:</p>
<div class="interstitial code"> <pre data-language="sql">SELECT * FROM customers WHERE (customers.orders_count NOT IN (1,3,5))</pre> <button class="clipboard-button" data-clipboard-text="SELECT * FROM customers WHERE (customers.orders_count NOT IN (1,3,5))
">Copy</button> </div> <p>If a query has a hash condition with non-nil values on a nullable column, the records that have <code>nil</code> values on the nullable column won't be returned. For example:</p>
<div class="interstitial code"> <pre data-language="ruby">Customer.create!(nullable_country: nil)
Customer.where.not(nullable_country: "UK")
# =&gt; []

# But
Customer.create!(nullable_country: "UK")
Customer.where.not(nullable_country: nil)
# =&gt; [#&lt;Customer id: 2, nullable_country: "UK"&gt;]</pre> <button class="clipboard-button" data-clipboard-text='Customer.create!(nullable_country: nil)
Customer.where.not(nullable_country: "UK")
# =&gt; []

# But
Customer.create!(nullable_country: "UK")
Customer.where.not(nullable_country: nil)
# =&gt; [#&lt;Customer id: 2, nullable_country: "UK"&gt;]
'>Copy</button> </div> <h2 id="or-conditions"><a class="anchorlink" href="#or-conditions"><span>3.5</span> OR Conditions</a></h2>
<p><code>OR</code> conditions between two relations can be built by calling <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-or"><code>or</code></a> on the first relation, and passing the second one as an argument.</p>
<div class="interstitial code"> <pre data-language="ruby">Customer.where(last_name: 'Smith').or(Customer.where(orders_count: [1, 3, 5]))</pre> <button class="clipboard-button" data-clipboard-text="Customer.where(last_name: 'Smith').or(Customer.where(orders_count: [1, 3, 5]))
">Copy</button> </div> <div class="interstitial code"> <pre data-language="sql">SELECT * FROM customers WHERE (customers.last_name = 'Smith' OR customers.orders_count IN (1,3,5))</pre> <button class="clipboard-button" data-clipboard-text="SELECT * FROM customers WHERE (customers.last_name = 'Smith' OR customers.orders_count IN (1,3,5))
">Copy</button> </div> <h2 id="and-conditions"><a class="anchorlink" href="#and-conditions"><span>3.6</span> AND Conditions</a></h2>
<p><code>AND</code> conditions can be built by chaining <code>where</code> conditions.</p>
<div class="interstitial code"> <pre data-language="ruby">Customer.where(last_name: 'Smith').where(orders_count: [1, 3, 5])</pre> <button class="clipboard-button" data-clipboard-text="Customer.where(last_name: 'Smith').where(orders_count: [1, 3, 5])
">Copy</button> </div> <div class="interstitial code"> <pre data-language="sql">SELECT * FROM customers WHERE customers.last_name = 'Smith' AND customers.orders_count IN (1,3,5)</pre> <button class="clipboard-button" data-clipboard-text="SELECT * FROM customers WHERE customers.last_name = 'Smith' AND customers.orders_count IN (1,3,5)
">Copy</button> </div> <p><code>AND</code> conditions for the logical intersection between relations can be built by calling <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-and"><code>and</code></a> on the first relation, and passing the second one as an argument.</p>
<div class="interstitial code"> <pre data-language="ruby">Customer.where(id: [1, 2]).and(Customer.where(id: [2, 3]))</pre> <button class="clipboard-button" data-clipboard-text="Customer.where(id: [1, 2]).and(Customer.where(id: [2, 3]))
">Copy</button> </div> <div class="interstitial code"> <pre data-language="sql">SELECT * FROM customers WHERE (customers.id IN (1, 2) AND customers.id IN (2, 3))</pre> <button class="clipboard-button" data-clipboard-text="SELECT * FROM customers WHERE (customers.id IN (1, 2) AND customers.id IN (2, 3))
">Copy</button> </div> <h1 id="ordering"><a class="anchorlink" href="#ordering"><span>4</span> Ordering</a></h1>
<p>To retrieve records from the database in a specific order, you can use the <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-order"><code>order</code></a> method.</p>
<p>For example, if you're getting a set of records and want to order them in ascending order by the <code>created_at</code> field in your table:</p>
<div class="interstitial code"> <pre data-language="ruby">Book.order(:created_at)
# OR
Book.order("created_at")</pre> <button class="clipboard-button" data-clipboard-text='Book.order(:created_at)
# OR
Book.order("created_at")
'>Copy</button> </div> <p>You could specify <code>ASC</code> or <code>DESC</code> as well:</p>
<div class="interstitial code"> <pre data-language="ruby">Book.order(created_at: :desc)
# OR
Book.order(created_at: :asc)
# OR
Book.order("created_at DESC")
# OR
Book.order("created_at ASC")</pre> <button class="clipboard-button" data-clipboard-text='Book.order(created_at: :desc)
# OR
Book.order(created_at: :asc)
# OR
Book.order("created_at DESC")
# OR
Book.order("created_at ASC")
'>Copy</button> </div> <p>Or ordering by multiple fields:</p>
<div class="interstitial code"> <pre data-language="ruby">Book.order(title: :asc, created_at: :desc)
# OR
Book.order(:title, created_at: :desc)
# OR
Book.order("title ASC, created_at DESC")
# OR
Book.order("title ASC", "created_at DESC")</pre> <button class="clipboard-button" data-clipboard-text='Book.order(title: :asc, created_at: :desc)
# OR
Book.order(:title, created_at: :desc)
# OR
Book.order("title ASC, created_at DESC")
# OR
Book.order("title ASC", "created_at DESC")
'>Copy</button> </div> <p>If you want to call <code>order</code> multiple times, subsequent orders will be appended to the first:</p>
<div class="interstitial code"> <pre data-language="irb">irb&gt; Book.order("title ASC").order("created_at DESC")
SELECT * FROM books ORDER BY title ASC, created_at DESC</pre> <button class="clipboard-button" data-clipboard-text='Book.order("title ASC").order("created_at DESC")
'>Copy</button> </div> <p>You can also order from a joined table</p>
<div class="interstitial code"> <pre data-language="ruby">Book.includes(:author).order(books: { print_year: :desc }, authors: { name: :asc })
# OR
Book.includes(:author).order('books.print_year desc', 'authors.name asc')</pre> <button class="clipboard-button" data-clipboard-text="Book.includes(:author).order(books: { print_year: :desc }, authors: { name: :asc })
# OR
Book.includes(:author).order('books.print_year desc', 'authors.name asc')
">Copy</button> </div> <div class="interstitial warning"><p>In most database systems, on selecting fields with <code>distinct</code> from a result set using methods like <code>select</code>, <code>pluck</code> and <code>ids</code>; the <code>order</code> method will raise an <code>ActiveRecord::StatementInvalid</code> exception unless the field(s) used in <code>order</code> clause are included in the select list. See the next section for selecting fields from the result set.</p></div>
<h1 id="selecting-specific-fields"><a class="anchorlink" href="#selecting-specific-fields"><span>5</span> Selecting Specific Fields</a></h1>
<p>By default, <code>Model.find</code> selects all the fields from the result set using <code>select *</code>.</p>
<p>To select only a subset of fields from the result set, you can specify the subset via the <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-select"><code>select</code></a> method.</p>
<p>For example, to select only <code>isbn</code> and <code>out_of_print</code> columns:</p>
<div class="interstitial code"> <pre data-language="ruby">Book.select(:isbn, :out_of_print)
# OR
Book.select("isbn, out_of_print")</pre> <button class="clipboard-button" data-clipboard-text='Book.select(:isbn, :out_of_print)
# OR
Book.select("isbn, out_of_print")
'>Copy</button> </div> <p>The SQL query used by this find call will be somewhat like:</p>
<div class="interstitial code"> <pre data-language="sql">SELECT isbn, out_of_print FROM books</pre> <button class="clipboard-button" data-clipboard-text="SELECT isbn, out_of_print FROM books
">Copy</button> </div> <p>Be careful because this also means you're initializing a model object with only the fields that you've selected. If you attempt to access a field that is not in the initialized record you'll receive:</p>
<div class="interstitial code"> <pre data-language="plaintext">ActiveModel::MissingAttributeError: missing attribute '&lt;attribute&gt;' for Book</pre> <button class="clipboard-button" data-clipboard-text="ActiveModel::MissingAttributeError: missing attribute '&lt;attribute&gt;' for Book
">Copy</button> </div> <p>Where <code>&lt;attribute&gt;</code> is the attribute you asked for. The <code>id</code> method will not raise the <code>ActiveRecord::MissingAttributeError</code>, so just be careful when working with associations because they need the <code>id</code> method to function properly.</p>
<p>If you would like to only grab a single record per unique value in a certain field, you can use <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-distinct"><code>distinct</code></a>:</p>
<div class="interstitial code"> <pre data-language="ruby">Customer.select(:last_name).distinct</pre> <button class="clipboard-button" data-clipboard-text="Customer.select(:last_name).distinct
">Copy</button> </div> <p>This would generate SQL like:</p>
<div class="interstitial code"> <pre data-language="sql">SELECT DISTINCT last_name FROM customers</pre> <button class="clipboard-button" data-clipboard-text="SELECT DISTINCT last_name FROM customers
">Copy</button> </div> <p>You can also remove the uniqueness constraint:</p>
<div class="interstitial code"> <pre data-language="ruby"># Returns unique last_names
query = Customer.select(:last_name).distinct

# Returns all last_names, even if there are duplicates
query.distinct(false)</pre> <button class="clipboard-button" data-clipboard-text="# Returns unique last_names
query = Customer.select(:last_name).distinct

# Returns all last_names, even if there are duplicates
query.distinct(false)
">Copy</button> </div> <h1 id="limit-and-offset"><a class="anchorlink" href="#limit-and-offset"><span>6</span> Limit and Offset</a></h1>
<p>To apply <code>LIMIT</code> to the SQL fired by the <code>Model.find</code>, you can specify the <code>LIMIT</code> using <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-limit"><code>limit</code></a> and <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-offset"><code>offset</code></a> methods on the relation.</p>
<p>You can use <code>limit</code> to specify the number of records to be retrieved, and use <code>offset</code> to specify the number of records to skip before starting to return the records. For example</p>
<div class="interstitial code"> <pre data-language="ruby">Customer.limit(5)</pre> <button class="clipboard-button" data-clipboard-text="Customer.limit(5)
">Copy</button> </div> <p>will return a maximum of 5 customers and because it specifies no offset it will return the first 5 in the table. The SQL it executes looks like this:</p>
<div class="interstitial code"> <pre data-language="sql">SELECT * FROM customers LIMIT 5</pre> <button class="clipboard-button" data-clipboard-text="SELECT * FROM customers LIMIT 5
">Copy</button> </div> <p>Adding <code>offset</code> to that</p>
<div class="interstitial code"> <pre data-language="ruby">Customer.limit(5).offset(30)</pre> <button class="clipboard-button" data-clipboard-text="Customer.limit(5).offset(30)
">Copy</button> </div> <p>will return instead a maximum of 5 customers beginning with the 31st. The SQL looks like:</p>
<div class="interstitial code"> <pre data-language="sql">SELECT * FROM customers LIMIT 5 OFFSET 30</pre> <button class="clipboard-button" data-clipboard-text="SELECT * FROM customers LIMIT 5 OFFSET 30
">Copy</button> </div> <h1 id="grouping"><a class="anchorlink" href="#grouping"><span>7</span> Grouping</a></h1>
<p>To apply a <code>GROUP BY</code> clause to the SQL fired by the finder, you can use the <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-group"><code>group</code></a> method.</p>
<p>For example, if you want to find a collection of the dates on which orders were created:</p>
<div class="interstitial code"> <pre data-language="ruby">Order.select("created_at").group("created_at")</pre> <button class="clipboard-button" data-clipboard-text='Order.select("created_at").group("created_at")
'>Copy</button> </div> <p>And this will give you a single <code>Order</code> object for each date where there are orders in the database.</p>
<p>The SQL that would be executed would be something like this:</p>
<div class="interstitial code"> <pre data-language="sql">SELECT created_at
FROM orders
GROUP BY created_at</pre> <button class="clipboard-button" data-clipboard-text="SELECT created_at
FROM orders
GROUP BY created_at
">Copy</button> </div> <h2 id="total-of-grouped-items"><a class="anchorlink" href="#total-of-grouped-items"><span>7.1</span> Total of Grouped Items</a></h2>
<p>To get the total of grouped items on a single query, call <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Calculations.html#method-i-count"><code>count</code></a> after the <code>group</code>.</p>
<div class="interstitial code"> <pre data-language="irb">irb&gt; Order.group(:status).count
=&gt; {"being_packed"=&gt;7, "shipped"=&gt;12}</pre> <button class="clipboard-button" data-clipboard-text="Order.group(:status).count
">Copy</button> </div> <p>The SQL that would be executed would be something like this:</p>
<div class="interstitial code"> <pre data-language="sql">SELECT COUNT (*) AS count_all, status AS status
FROM orders
GROUP BY status</pre> <button class="clipboard-button" data-clipboard-text="SELECT COUNT (*) AS count_all, status AS status
FROM orders
GROUP BY status
">Copy</button> </div> <h2 id="having-conditions"><a class="anchorlink" href="#having-conditions"><span>7.2</span> HAVING Conditions</a></h2>
<p>SQL uses the <code>HAVING</code> clause to specify conditions on the <code>GROUP BY</code> fields. You can add the <code>HAVING</code> clause to the SQL fired by the <code>Model.find</code> by adding the <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-having"><code>having</code></a> method to the find.</p>
<p>For example:</p>
<div class="interstitial code"> <pre data-language="ruby">Order.select("created_at as ordered_date, sum(total) as total_price").
  group("created_at").having("sum(total) &gt; ?", 200)</pre> <button class="clipboard-button" data-clipboard-text='Order.select("created_at as ordered_date, sum(total) as total_price").
  group("created_at").having("sum(total) &gt; ?", 200)
'>Copy</button> </div> <p>The SQL that would be executed would be something like this:</p>
<div class="interstitial code"> <pre data-language="sql">SELECT created_at as ordered_date, sum(total) as total_price
FROM orders
GROUP BY created_at
HAVING sum(total) &gt; 200</pre> <button class="clipboard-button" data-clipboard-text="SELECT created_at as ordered_date, sum(total) as total_price
FROM orders
GROUP BY created_at
HAVING sum(total) &gt; 200
">Copy</button> </div> <p>This returns the date and total price for each order object, grouped by the day they were ordered and where the total is more than $200.</p>
<p>You would access the <code>total_price</code> for each order object returned like this:</p>
<div class="interstitial code"> <pre data-language="ruby">big_orders = Order.select("created_at, sum(total) as total_price")
                  .group("created_at")
                  .having("sum(total) &gt; ?", 200)

big_orders[0].total_price
# Returns the total price for the first Order object</pre> <button class="clipboard-button" data-clipboard-text='big_orders = Order.select("created_at, sum(total) as total_price")
                  .group("created_at")
                  .having("sum(total) &gt; ?", 200)

big_orders[0].total_price
# Returns the total price for the first Order object
'>Copy</button> </div> <h1 id="overriding-conditions"><a class="anchorlink" href="#overriding-conditions"><span>8</span> Overriding Conditions</a></h1>
<h2 id="unscope"><a class="anchorlink" href="#unscope"><span>8.1</span> <code>unscope</code></a></h2>
<p>You can specify certain conditions to be removed using the <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-unscope"><code>unscope</code></a> method. For example:</p>
<div class="interstitial code"> <pre data-language="ruby">Book.where('id &gt; 100').limit(20).order('id desc').unscope(:order)</pre> <button class="clipboard-button" data-clipboard-text="Book.where('id &gt; 100').limit(20).order('id desc').unscope(:order)
">Copy</button> </div> <p>The SQL that would be executed:</p>
<div class="interstitial code"> <pre data-language="sql">SELECT * FROM books WHERE id &gt; 100 LIMIT 20

-- Original query without `unscope`
SELECT * FROM books WHERE id &gt; 100 ORDER BY id desc LIMIT 20</pre> <button class="clipboard-button" data-clipboard-text="SELECT * FROM books WHERE id &gt; 100 LIMIT 20

-- Original query without `unscope`
SELECT * FROM books WHERE id &gt; 100 ORDER BY id desc LIMIT 20
">Copy</button> </div> <p>You can also unscope specific <code>where</code> clauses. For example, this will remove <code>id</code> condition from the where clause:</p>
<div class="interstitial code"> <pre data-language="ruby">Book.where(id: 10, out_of_print: false).unscope(where: :id)
# SELECT books.* FROM books WHERE out_of_print = 0</pre> <button class="clipboard-button" data-clipboard-text="Book.where(id: 10, out_of_print: false).unscope(where: :id)
# SELECT books.* FROM books WHERE out_of_print = 0
">Copy</button> </div> <p>A relation which has used <code>unscope</code> will affect any relation into which it is merged:</p>
<div class="interstitial code"> <pre data-language="ruby">Book.order('id desc').merge(Book.unscope(:order))
# SELECT books.* FROM books</pre> <button class="clipboard-button" data-clipboard-text="Book.order('id desc').merge(Book.unscope(:order))
# SELECT books.* FROM books
">Copy</button> </div> <h2 id="only"><a class="anchorlink" href="#only"><span>8.2</span> <code>only</code></a></h2>
<p>You can also override conditions using the <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/SpawnMethods.html#method-i-only"><code>only</code></a> method. For example:</p>
<div class="interstitial code"> <pre data-language="ruby">Book.where('id &gt; 10').limit(20).order('id desc').only(:order, :where)</pre> <button class="clipboard-button" data-clipboard-text="Book.where('id &gt; 10').limit(20).order('id desc').only(:order, :where)
">Copy</button> </div> <p>The SQL that would be executed:</p>
<div class="interstitial code"> <pre data-language="sql">SELECT * FROM books WHERE id &gt; 10 ORDER BY id DESC

-- Original query without `only`
SELECT * FROM books WHERE id &gt; 10 ORDER BY id DESC LIMIT 20</pre> <button class="clipboard-button" data-clipboard-text="SELECT * FROM books WHERE id &gt; 10 ORDER BY id DESC

-- Original query without `only`
SELECT * FROM books WHERE id &gt; 10 ORDER BY id DESC LIMIT 20
">Copy</button> </div> <h2 id="reselect"><a class="anchorlink" href="#reselect"><span>8.3</span> <code>reselect</code></a></h2>
<p>The <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-reselect"><code>reselect</code></a> method overrides an existing select statement. For example:</p>
<div class="interstitial code"> <pre data-language="ruby">Book.select(:title, :isbn).reselect(:created_at)</pre> <button class="clipboard-button" data-clipboard-text="Book.select(:title, :isbn).reselect(:created_at)
">Copy</button> </div> <p>The SQL that would be executed:</p>
<div class="interstitial code"> <pre data-language="sql">SELECT books.created_at FROM books</pre> <button class="clipboard-button" data-clipboard-text="SELECT books.created_at FROM books
">Copy</button> </div> <p>Compare this to the case where the <code>reselect</code> clause is not used:</p>
<div class="interstitial code"> <pre data-language="ruby">Book.select(:title, :isbn).select(:created_at)</pre> <button class="clipboard-button" data-clipboard-text="Book.select(:title, :isbn).select(:created_at)
">Copy</button> </div> <p>the SQL executed would be:</p>
<div class="interstitial code"> <pre data-language="sql">SELECT books.title, books.isbn, books.created_at FROM books</pre> <button class="clipboard-button" data-clipboard-text="SELECT books.title, books.isbn, books.created_at FROM books
">Copy</button> </div> <h2 id="reorder"><a class="anchorlink" href="#reorder"><span>8.4</span> <code>reorder</code></a></h2>
<p>The <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-reorder"><code>reorder</code></a> method overrides the default scope order. For example if the class definition includes this:</p>
<div class="interstitial code"> <pre data-language="ruby">class Author &lt; ApplicationRecord
  has_many :books, -&gt; { order(year_published: :desc) }
end</pre> <button class="clipboard-button" data-clipboard-text="class Author &lt; ApplicationRecord
  has_many :books, -&gt; { order(year_published: :desc) }
end
">Copy</button> </div> <p>And you execute this:</p>
<div class="interstitial code"> <pre data-language="ruby">Author.find(10).books</pre> <button class="clipboard-button" data-clipboard-text="Author.find(10).books
">Copy</button> </div> <p>The SQL that would be executed:</p>
<div class="interstitial code"> <pre data-language="sql">SELECT * FROM authors WHERE id = 10 LIMIT 1
SELECT * FROM books WHERE author_id = 10 ORDER BY year_published DESC</pre> <button class="clipboard-button" data-clipboard-text="SELECT * FROM authors WHERE id = 10 LIMIT 1
SELECT * FROM books WHERE author_id = 10 ORDER BY year_published DESC
">Copy</button> </div> <p>You can using the <code>reorder</code> clause to specify a different way to order the books:</p>
<div class="interstitial code"> <pre data-language="ruby">Author.find(10).books.reorder('year_published ASC')</pre> <button class="clipboard-button" data-clipboard-text="Author.find(10).books.reorder('year_published ASC')
">Copy</button> </div> <p>The SQL that would be executed:</p>
<div class="interstitial code"> <pre data-language="sql">SELECT * FROM authors WHERE id = 10 LIMIT 1
SELECT * FROM books WHERE author_id = 10 ORDER BY year_published ASC</pre> <button class="clipboard-button" data-clipboard-text="SELECT * FROM authors WHERE id = 10 LIMIT 1
SELECT * FROM books WHERE author_id = 10 ORDER BY year_published ASC
">Copy</button> </div> <h2 id="reverse-order"><a class="anchorlink" href="#reverse-order"><span>8.5</span> <code>reverse_order</code></a></h2>
<p>The <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-reverse_order"><code>reverse_order</code></a> method reverses the ordering clause if specified.</p>
<div class="interstitial code"> <pre data-language="ruby">Book.where("author_id &gt; 10").order(:year_published).reverse_order</pre> <button class="clipboard-button" data-clipboard-text='Book.where("author_id &gt; 10").order(:year_published).reverse_order
'>Copy</button> </div> <p>The SQL that would be executed:</p>
<div class="interstitial code"> <pre data-language="sql">SELECT * FROM books WHERE author_id &gt; 10 ORDER BY year_published DESC</pre> <button class="clipboard-button" data-clipboard-text="SELECT * FROM books WHERE author_id &gt; 10 ORDER BY year_published DESC
">Copy</button> </div> <p>If no ordering clause is specified in the query, the <code>reverse_order</code> orders by the primary key in reverse order.</p>
<div class="interstitial code"> <pre data-language="ruby">Book.where("author_id &gt; 10").reverse_order</pre> <button class="clipboard-button" data-clipboard-text='Book.where("author_id &gt; 10").reverse_order
'>Copy</button> </div> <p>The SQL that would be executed:</p>
<div class="interstitial code"> <pre data-language="sql">SELECT * FROM books WHERE author_id &gt; 10 ORDER BY books.id DESC</pre> <button class="clipboard-button" data-clipboard-text="SELECT * FROM books WHERE author_id &gt; 10 ORDER BY books.id DESC
">Copy</button> </div> <p>The <code>reverse_order</code> method accepts <strong>no</strong> arguments.</p>
<h2 id="rewhere"><a class="anchorlink" href="#rewhere"><span>8.6</span> <code>rewhere</code></a></h2>
<p>The <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-rewhere"><code>rewhere</code></a> method overrides an existing, named <code>where</code> condition. For example:</p>
<div class="interstitial code"> <pre data-language="ruby">Book.where(out_of_print: true).rewhere(out_of_print: false)</pre> <button class="clipboard-button" data-clipboard-text="Book.where(out_of_print: true).rewhere(out_of_print: false)
">Copy</button> </div> <p>The SQL that would be executed:</p>
<div class="interstitial code"> <pre data-language="sql">SELECT * FROM books WHERE out_of_print = 0</pre> <button class="clipboard-button" data-clipboard-text="SELECT * FROM books WHERE out_of_print = 0
">Copy</button> </div> <p>If the <code>rewhere</code> clause is not used, the where clauses are ANDed together:</p>
<div class="interstitial code"> <pre data-language="ruby">Book.where(out_of_print: true).where(out_of_print: false)</pre> <button class="clipboard-button" data-clipboard-text="Book.where(out_of_print: true).where(out_of_print: false)
">Copy</button> </div> <p>the SQL executed would be:</p>
<div class="interstitial code"> <pre data-language="sql">SELECT * FROM books WHERE out_of_print = 1 AND out_of_print = 0</pre> <button class="clipboard-button" data-clipboard-text="SELECT * FROM books WHERE out_of_print = 1 AND out_of_print = 0
">Copy</button> </div> <h2 id="regroup"><a class="anchorlink" href="#regroup"><span>8.7</span> <code>regroup</code></a></h2>
<p>The <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-regroup"><code>regroup</code></a> method overrides an existing, named <code>group</code> condition. For example:</p>
<div class="interstitial code"> <pre data-language="ruby">Book.group(:author).regroup(:id)</pre> <button class="clipboard-button" data-clipboard-text="Book.group(:author).regroup(:id)
">Copy</button> </div> <p>The SQL that would be executed:</p>
<div class="interstitial code"> <pre data-language="sql">SELECT * FROM books GROUP BY id</pre> <button class="clipboard-button" data-clipboard-text="SELECT * FROM books GROUP BY id
">Copy</button> </div> <p>If the <code>regroup</code> clause is not used, the group clauses are combined together:</p>
<div class="interstitial code"> <pre data-language="ruby">Book.group(:author).group(:id)</pre> <button class="clipboard-button" data-clipboard-text="Book.group(:author).group(:id)
">Copy</button> </div> <p>the SQL executed would be:</p>
<div class="interstitial code"> <pre data-language="sql">SELECT * FROM books GROUP BY author, id</pre> <button class="clipboard-button" data-clipboard-text="SELECT * FROM books GROUP BY author, id
">Copy</button> </div> <h1 id="null-relation"><a class="anchorlink" href="#null-relation"><span>9</span> Null Relation</a></h1>
<p>The <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-none"><code>none</code></a> method returns a chainable relation with no records. Any subsequent conditions chained to the returned relation will continue generating empty relations. This is useful in scenarios where you need a chainable response to a method or a scope that could return zero results.</p>
<div class="interstitial code"> <pre data-language="ruby">Book.none # returns an empty Relation and fires no queries.</pre> <button class="clipboard-button" data-clipboard-text="Book.none # returns an empty Relation and fires no queries.
">Copy</button> </div> <div class="interstitial code"> <pre data-language="ruby"># The highlighted_reviews method below is expected to always return a Relation.
Book.first.highlighted_reviews.average(:rating)
# =&gt; Returns average rating of a book

class Book
  # Returns reviews if there are at least 5,
  # else consider this as non-reviewed book
  def highlighted_reviews
    if reviews.count &gt; 5
      reviews
    else
      Review.none # Does not meet minimum threshold yet
    end
  end
end</pre> <button class="clipboard-button" data-clipboard-text="# The highlighted_reviews method below is expected to always return a Relation.
Book.first.highlighted_reviews.average(:rating)
# =&gt; Returns average rating of a book

class Book
  # Returns reviews if there are at least 5,
  # else consider this as non-reviewed book
  def highlighted_reviews
    if reviews.count &gt; 5
      reviews
    else
      Review.none # Does not meet minimum threshold yet
    end
  end
end
">Copy</button> </div> <h1 id="readonly-objects"><a class="anchorlink" href="#readonly-objects"><span>10</span> Readonly Objects</a></h1>
<p>Active Record provides the <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-readonly"><code>readonly</code></a> method on a relation to explicitly disallow modification of any of the returned objects. Any attempt to alter a readonly record will not succeed, raising an <code>ActiveRecord::ReadOnlyRecord</code> exception.</p>
<div class="interstitial code"> <pre data-language="ruby">customer = Customer.readonly.first
customer.visits += 1
customer.save # Raises an ActiveRecord::ReadOnlyRecord</pre> <button class="clipboard-button" data-clipboard-text="customer = Customer.readonly.first
customer.visits += 1
customer.save # Raises an ActiveRecord::ReadOnlyRecord
">Copy</button> </div> <p>As <code>customer</code> is explicitly set to be a readonly object, the above code will raise an <code>ActiveRecord::ReadOnlyRecord</code> exception when calling <code>customer.save</code> with an updated value of <em>visits</em>.</p>
<h1 id="locking-records-for-update"><a class="anchorlink" href="#locking-records-for-update"><span>11</span> Locking Records for Update</a></h1>
<p>Locking is helpful for preventing race conditions when updating records in the database and ensuring atomic updates.</p>
<p>Active Record provides two locking mechanisms:</p> <ul> <li>Optimistic Locking</li> <li>Pessimistic Locking</li> </ul> <h2 id="optimistic-locking"><a class="anchorlink" href="#optimistic-locking"><span>11.1</span> Optimistic Locking</a></h2>
<p>Optimistic locking allows multiple users to access the same record for edits, and assumes a minimum of conflicts with the data. It does this by checking whether another process has made changes to a record since it was opened. An <code>ActiveRecord::StaleObjectError</code> exception is thrown if that has occurred and the update is ignored.</p>
<p><strong>Optimistic locking column</strong></p>
<p>In order to use optimistic locking, the table needs to have a column called <code>lock_version</code> of type integer. Each time the record is updated, Active Record increments the <code>lock_version</code> column. If an update request is made with a lower value in the <code>lock_version</code> field than is currently in the <code>lock_version</code> column in the database, the update request will fail with an <code>ActiveRecord::StaleObjectError</code>.</p>
<p>For example:</p>
<div class="interstitial code"> <pre data-language="ruby">c1 = Customer.find(1)
c2 = Customer.find(1)

c1.first_name = "Sandra"
c1.save

c2.first_name = "Michael"
c2.save # Raises an ActiveRecord::StaleObjectError</pre> <button class="clipboard-button" data-clipboard-text='c1 = Customer.find(1)
c2 = Customer.find(1)

c1.first_name = "Sandra"
c1.save

c2.first_name = "Michael"
c2.save # Raises an ActiveRecord::StaleObjectError
'>Copy</button> </div> <p>You're then responsible for dealing with the conflict by rescuing the exception and either rolling back, merging, or otherwise apply the business logic needed to resolve the conflict.</p>
<p>This behavior can be turned off by setting <code>ActiveRecord::Base.lock_optimistically = false</code>.</p>
<p>To override the name of the <code>lock_version</code> column, <code>ActiveRecord::Base</code> provides a class attribute called <code>locking_column</code>:</p>
<div class="interstitial code"> <pre data-language="ruby">class Customer &lt; ApplicationRecord
  self.locking_column = :lock_customer_column
end</pre> <button class="clipboard-button" data-clipboard-text="class Customer &lt; ApplicationRecord
  self.locking_column = :lock_customer_column
end
">Copy</button> </div> <h2 id="pessimistic-locking"><a class="anchorlink" href="#pessimistic-locking"><span>11.2</span> Pessimistic Locking</a></h2>
<p>Pessimistic locking uses a locking mechanism provided by the underlying database. Using <code>lock</code> when building a relation obtains an exclusive lock on the selected rows. Relations using <code>lock</code> are usually wrapped inside a transaction for preventing deadlock conditions.</p>
<p>For example:</p>
<div class="interstitial code"> <pre data-language="ruby">Book.transaction do
  book = Book.lock.first
  book.title = 'Algorithms, second edition'
  book.save!
end</pre> <button class="clipboard-button" data-clipboard-text="Book.transaction do
  book = Book.lock.first
  book.title = 'Algorithms, second edition'
  book.save!
end
">Copy</button> </div> <p>The above session produces the following SQL for a MySQL backend:</p>
<div class="interstitial code"> <pre data-language="sql">SQL (0.2ms)   BEGIN
Book Load (0.3ms)   SELECT * FROM books LIMIT 1 FOR UPDATE
Book Update (0.4ms)   UPDATE books SET updated_at = '2009-02-07 18:05:56', title = 'Algorithms, second edition' WHERE id = 1
SQL (0.8ms)   COMMIT</pre> <button class="clipboard-button" data-clipboard-text="SQL (0.2ms)   BEGIN
Book Load (0.3ms)   SELECT * FROM books LIMIT 1 FOR UPDATE
Book Update (0.4ms)   UPDATE books SET updated_at = '2009-02-07 18:05:56', title = 'Algorithms, second edition' WHERE id = 1
SQL (0.8ms)   COMMIT
">Copy</button> </div> <p>You can also pass raw SQL to the <code>lock</code> method for allowing different types of locks. For example, MySQL has an expression called <code>LOCK IN SHARE MODE</code> where you can lock a record but still allow other queries to read it. To specify this expression just pass it in as the lock option:</p>
<div class="interstitial code"> <pre data-language="ruby">Book.transaction do
  book = Book.lock("LOCK IN SHARE MODE").find(1)
  book.increment!(:views)
end</pre> <button class="clipboard-button" data-clipboard-text='Book.transaction do
  book = Book.lock("LOCK IN SHARE MODE").find(1)
  book.increment!(:views)
end
'>Copy</button> </div> <div class="interstitial note"><p>Note that your database must support the raw SQL, that you pass in to the <code>lock</code> method.</p></div>
<p>If you already have an instance of your model, you can start a transaction and acquire the lock in one go using the following code:</p>
<div class="interstitial code"> <pre data-language="ruby">book = Book.first
book.with_lock do
  # This block is called within a transaction,
  # book is already locked.
  book.increment!(:views)
end</pre> <button class="clipboard-button" data-clipboard-text="book = Book.first
book.with_lock do
  # This block is called within a transaction,
  # book is already locked.
  book.increment!(:views)
end
">Copy</button> </div> <h1 id="joining-tables"><a class="anchorlink" href="#joining-tables"><span>12</span> Joining Tables</a></h1>
<p>Active Record provides two finder methods for specifying <code>JOIN</code> clauses on the resulting SQL: <code>joins</code> and <code>left_outer_joins</code>. While <code>joins</code> should be used for <code>INNER JOIN</code> or custom queries, <code>left_outer_joins</code> is used for queries using <code>LEFT OUTER JOIN</code>.</p>
<h2 id="joins"><a class="anchorlink" href="#joins"><span>12.1</span> <code>joins</code></a></h2>
<p>There are multiple ways to use the <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-joins"><code>joins</code></a> method.</p>
<h3 id="using-a-string-sql-fragment"><a class="anchorlink" href="#using-a-string-sql-fragment"><span>12.1.1</span> Using a String SQL Fragment</a></h3>
<p>You can just supply the raw SQL specifying the <code>JOIN</code> clause to <code>joins</code>:</p>
<div class="interstitial code"> <pre data-language="ruby">Author.joins("INNER JOIN books ON books.author_id = authors.id AND books.out_of_print = FALSE")</pre> <button class="clipboard-button" data-clipboard-text='Author.joins("INNER JOIN books ON books.author_id = authors.id AND books.out_of_print = FALSE")
'>Copy</button> </div> <p>This will result in the following SQL:</p>
<div class="interstitial code"> <pre data-language="sql">SELECT authors.* FROM authors INNER JOIN books ON books.author_id = authors.id AND books.out_of_print = FALSE</pre> <button class="clipboard-button" data-clipboard-text="SELECT authors.* FROM authors INNER JOIN books ON books.author_id = authors.id AND books.out_of_print = FALSE
">Copy</button> </div> <h3 id="using-array-hash-of-named-associations"><a class="anchorlink" href="#using-array-hash-of-named-associations"><span>12.1.2</span> Using Array/Hash of Named Associations</a></h3>
<p>Active Record lets you use the names of the <a href="association_basics.html">associations</a> defined on the model as a shortcut for specifying <code>JOIN</code> clauses for those associations when using the <code>joins</code> method.</p>
<p>All of the following will produce the expected join queries using <code>INNER JOIN</code>:</p>
<h4 id="joining-a-single-association"><a class="anchorlink" href="#joining-a-single-association"><span>12.1.2.1</span> Joining a Single Association</a></h4>
<div class="interstitial code"> <pre data-language="ruby">Book.joins(:reviews)</pre> <button class="clipboard-button" data-clipboard-text="Book.joins(:reviews)
">Copy</button> </div> <p>This produces:</p>
<div class="interstitial code"> <pre data-language="sql">SELECT books.* FROM books
  INNER JOIN reviews ON reviews.book_id = books.id</pre> <button class="clipboard-button" data-clipboard-text="SELECT books.* FROM books
  INNER JOIN reviews ON reviews.book_id = books.id
">Copy</button> </div> <p>Or, in English: "return a Book object for all books with reviews". Note that you will see duplicate books if a book has more than one review. If you want unique books, you can use <code>Book.joins(:reviews).distinct</code>.</p>
<h3 id="joining-multiple-associations"><a class="anchorlink" href="#joining-multiple-associations"><span>12.1.3</span> Joining Multiple Associations</a></h3>
<div class="interstitial code"> <pre data-language="ruby">Book.joins(:author, :reviews)</pre> <button class="clipboard-button" data-clipboard-text="Book.joins(:author, :reviews)
">Copy</button> </div> <p>This produces:</p>
<div class="interstitial code"> <pre data-language="sql">SELECT books.* FROM books
  INNER JOIN authors ON authors.id = books.author_id
  INNER JOIN reviews ON reviews.book_id = books.id</pre> <button class="clipboard-button" data-clipboard-text="SELECT books.* FROM books
  INNER JOIN authors ON authors.id = books.author_id
  INNER JOIN reviews ON reviews.book_id = books.id
">Copy</button> </div> <p>Or, in English: "return all books that have an author and at least one review". Note again that books with multiple reviews will show up multiple times.</p>
<h4 id="joining-nested-associations-single-level"><a class="anchorlink" href="#joining-nested-associations-single-level"><span>12.1.3.1</span> Joining Nested Associations (Single Level)</a></h4>
<div class="interstitial code"> <pre data-language="ruby">Book.joins(reviews: :customer)</pre> <button class="clipboard-button" data-clipboard-text="Book.joins(reviews: :customer)
">Copy</button> </div> <p>This produces:</p>
<div class="interstitial code"> <pre data-language="sql">SELECT books.* FROM books
  INNER JOIN reviews ON reviews.book_id = books.id
  INNER JOIN customers ON customers.id = reviews.customer_id</pre> <button class="clipboard-button" data-clipboard-text="SELECT books.* FROM books
  INNER JOIN reviews ON reviews.book_id = books.id
  INNER JOIN customers ON customers.id = reviews.customer_id
">Copy</button> </div> <p>Or, in English: "return all books that have a review by a customer."</p>
<h4 id="joining-nested-associations-multiple-level"><a class="anchorlink" href="#joining-nested-associations-multiple-level"><span>12.1.3.2</span> Joining Nested Associations (Multiple Level)</a></h4>
<div class="interstitial code"> <pre data-language="ruby">Author.joins(books: [{ reviews: { customer: :orders } }, :supplier])</pre> <button class="clipboard-button" data-clipboard-text="Author.joins(books: [{ reviews: { customer: :orders } }, :supplier])
">Copy</button> </div> <p>This produces:</p>
<div class="interstitial code"> <pre data-language="sql">SELECT authors.* FROM authors
  INNER JOIN books ON books.author_id = authors.id
  INNER JOIN reviews ON reviews.book_id = books.id
  INNER JOIN customers ON customers.id = reviews.customer_id
  INNER JOIN orders ON orders.customer_id = customers.id
INNER JOIN suppliers ON suppliers.id = books.supplier_id</pre> <button class="clipboard-button" data-clipboard-text="SELECT authors.* FROM authors
  INNER JOIN books ON books.author_id = authors.id
  INNER JOIN reviews ON reviews.book_id = books.id
  INNER JOIN customers ON customers.id = reviews.customer_id
  INNER JOIN orders ON orders.customer_id = customers.id
INNER JOIN suppliers ON suppliers.id = books.supplier_id
">Copy</button> </div> <p>Or, in English: "return all authors that have books with reviews <em>and</em> have been ordered by a customer, and the suppliers for those books."</p>
<h3 id="specifying-conditions-on-the-joined-tables"><a class="anchorlink" href="#specifying-conditions-on-the-joined-tables"><span>12.1.4</span> Specifying Conditions on the Joined Tables</a></h3>
<p>You can specify conditions on the joined tables using the regular <a href="#array-conditions">Array</a> and <a href="#pure-string-conditions">String</a> conditions. <a href="#hash-conditions">Hash conditions</a> provide a special syntax for specifying conditions for the joined tables:</p>
<div class="interstitial code"> <pre data-language="ruby">time_range = (Time.now.midnight - 1.day)..Time.now.midnight
Customer.joins(:orders).where('orders.created_at' =&gt; time_range).distinct</pre> <button class="clipboard-button" data-clipboard-text="time_range = (Time.now.midnight - 1.day)..Time.now.midnight
Customer.joins(:orders).where('orders.created_at' =&gt; time_range).distinct
">Copy</button> </div> <p>This will find all customers who have orders that were created yesterday, using a <code>BETWEEN</code> SQL expression to compare <code>created_at</code>.</p>
<p>An alternative and cleaner syntax is to nest the hash conditions:</p>
<div class="interstitial code"> <pre data-language="ruby">time_range = (Time.now.midnight - 1.day)..Time.now.midnight
Customer.joins(:orders).where(orders: { created_at: time_range }).distinct</pre> <button class="clipboard-button" data-clipboard-text="time_range = (Time.now.midnight - 1.day)..Time.now.midnight
Customer.joins(:orders).where(orders: { created_at: time_range }).distinct
">Copy</button> </div> <p>For more advanced conditions or to reuse an existing named scope, <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/SpawnMethods.html#method-i-merge"><code>merge</code></a> may be used. First, let's add a new named scope to the <code>Order</code> model:</p>
<div class="interstitial code"> <pre data-language="ruby">class Order &lt; ApplicationRecord
  belongs_to :customer

  scope :created_in_time_range, -&gt;(time_range) {
    where(created_at: time_range)
  }
end</pre> <button class="clipboard-button" data-clipboard-text="class Order &lt; ApplicationRecord
  belongs_to :customer

  scope :created_in_time_range, -&gt;(time_range) {
    where(created_at: time_range)
  }
end
">Copy</button> </div> <p>Now we can use <code>merge</code> to merge in the <code>created_in_time_range</code> scope:</p>
<div class="interstitial code"> <pre data-language="ruby">time_range = (Time.now.midnight - 1.day)..Time.now.midnight
Customer.joins(:orders).merge(Order.created_in_time_range(time_range)).distinct</pre> <button class="clipboard-button" data-clipboard-text="time_range = (Time.now.midnight - 1.day)..Time.now.midnight
Customer.joins(:orders).merge(Order.created_in_time_range(time_range)).distinct
">Copy</button> </div> <p>This will find all customers who have orders that were created yesterday, again using a <code>BETWEEN</code> SQL expression.</p>
<h2 id="left-outer-joins"><a class="anchorlink" href="#left-outer-joins"><span>12.2</span> <code>left_outer_joins</code></a></h2>
<p>If you want to select a set of records whether or not they have associated records you can use the <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-left_outer_joins"><code>left_outer_joins</code></a> method.</p>
<div class="interstitial code"> <pre data-language="ruby">Customer.left_outer_joins(:reviews).distinct.select('customers.*, COUNT(reviews.*) AS reviews_count').group('customers.id')</pre> <button class="clipboard-button" data-clipboard-text="Customer.left_outer_joins(:reviews).distinct.select('customers.*, COUNT(reviews.*) AS reviews_count').group('customers.id')
">Copy</button> </div> <p>Which produces:</p>
<div class="interstitial code"> <pre data-language="sql">SELECT DISTINCT customers.*, COUNT(reviews.*) AS reviews_count FROM customers
LEFT OUTER JOIN reviews ON reviews.customer_id = customers.id GROUP BY customers.id</pre> <button class="clipboard-button" data-clipboard-text="SELECT DISTINCT customers.*, COUNT(reviews.*) AS reviews_count FROM customers
LEFT OUTER JOIN reviews ON reviews.customer_id = customers.id GROUP BY customers.id
">Copy</button> </div> <p>Which means: "return all customers with their count of reviews, whether or not they have any reviews at all"</p>
<h2 id="where-associated-and-where-missing"><a class="anchorlink" href="#where-associated-and-where-missing"><span>12.3</span> <code>where.associated</code> and <code>where.missing</code></a></h2>
<p>The <code>associated</code> and <code>missing</code> query methods let you select a set of records based on the presence or absence of an association.</p>
<p>To use <code>where.associated</code>:</p>
<div class="interstitial code"> <pre data-language="ruby">Customer.where.associated(:reviews)</pre> <button class="clipboard-button" data-clipboard-text="Customer.where.associated(:reviews)
">Copy</button> </div> <p>Produces:</p>
<div class="interstitial code"> <pre data-language="sql">SELECT customers.* FROM customers
INNER JOIN reviews ON reviews.customer_id = customers.id
WHERE reviews.id IS NOT NULL</pre> <button class="clipboard-button" data-clipboard-text="SELECT customers.* FROM customers
INNER JOIN reviews ON reviews.customer_id = customers.id
WHERE reviews.id IS NOT NULL
">Copy</button> </div> <p>Which means "return all customers that have made at least one review".</p>
<p>To use <code>where.missing</code>:</p>
<div class="interstitial code"> <pre data-language="ruby">Customer.where.missing(:reviews)</pre> <button class="clipboard-button" data-clipboard-text="Customer.where.missing(:reviews)
">Copy</button> </div> <p>Produces:</p>
<div class="interstitial code"> <pre data-language="sql">SELECT customers.* FROM customers
LEFT OUTER JOIN reviews ON reviews.customer_id = customers.id
WHERE reviews.id IS NULL</pre> <button class="clipboard-button" data-clipboard-text="SELECT customers.* FROM customers
LEFT OUTER JOIN reviews ON reviews.customer_id = customers.id
WHERE reviews.id IS NULL
">Copy</button> </div> <p>Which means "return all customers that have not made any reviews".</p>
<h1 id="eager-loading-associations"><a class="anchorlink" href="#eager-loading-associations"><span>13</span> Eager Loading Associations</a></h1>
<p>Eager loading is the mechanism for loading the associated records of the objects returned by <code>Model.find</code> using as few queries as possible.</p>
<h2 id="n-1-queries-problem"><a class="anchorlink" href="#n-1-queries-problem"><span>13.1</span> N + 1 Queries Problem</a></h2>
<p>Consider the following code, which finds 10 books and prints their authors' last_name:</p>
<div class="interstitial code"> <pre data-language="ruby">books = Book.limit(10)

books.each do |book|
  puts book.author.last_name
end</pre> <button class="clipboard-button" data-clipboard-text="books = Book.limit(10)

books.each do |book|
  puts book.author.last_name
end
">Copy</button> </div> <p>This code looks fine at the first sight. But the problem lies within the total number of queries executed. The above code executes 1 (to find 10 books) + 10 (one per each book to load the author) = <strong>11</strong> queries in total.</p>
<h3 id="solution-to-n-1-queries-problem"><a class="anchorlink" href="#solution-to-n-1-queries-problem"><span>13.1.1</span> Solution to N + 1 Queries Problem</a></h3>
<p>Active Record lets you specify in advance all the associations that are going to be loaded.</p>
<p>The methods are:</p> <ul> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-includes"><code>includes</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-preload"><code>preload</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-eager_load"><code>eager_load</code></a></li> </ul> <h2 id="includes"><a class="anchorlink" href="#includes"><span>13.2</span> <code>includes</code></a></h2>
<p>With <code>includes</code>, Active Record ensures that all of the specified associations are loaded using the minimum possible number of queries.</p>
<p>Revisiting the above case using the <code>includes</code> method, we could rewrite <code>Book.limit(10)</code> to eager load authors:</p>
<div class="interstitial code"> <pre data-language="ruby">books = Book.includes(:author).limit(10)

books.each do |book|
  puts book.author.last_name
end</pre> <button class="clipboard-button" data-clipboard-text="books = Book.includes(:author).limit(10)

books.each do |book|
  puts book.author.last_name
end
">Copy</button> </div> <p>The above code will execute just <strong>2</strong> queries, as opposed to the <strong>11</strong> queries from the original case:</p>
<div class="interstitial code"> <pre data-language="sql">SELECT books.* FROM books LIMIT 10
SELECT authors.* FROM authors
  WHERE authors.id IN (1,2,3,4,5,6,7,8,9,10)</pre> <button class="clipboard-button" data-clipboard-text="SELECT books.* FROM books LIMIT 10
SELECT authors.* FROM authors
  WHERE authors.id IN (1,2,3,4,5,6,7,8,9,10)
">Copy</button> </div> <h3 id="eager-loading-multiple-associations"><a class="anchorlink" href="#eager-loading-multiple-associations"><span>13.2.1</span> Eager Loading Multiple Associations</a></h3>
<p>Active Record lets you eager load any number of associations with a single <code>Model.find</code> call by using an array, hash, or a nested hash of array/hash with the <code>includes</code> method.</p>
<h4 id="array-of-multiple-associations"><a class="anchorlink" href="#array-of-multiple-associations"><span>13.2.1.1</span> Array of Multiple Associations</a></h4>
<div class="interstitial code"> <pre data-language="ruby">Customer.includes(:orders, :reviews)</pre> <button class="clipboard-button" data-clipboard-text="Customer.includes(:orders, :reviews)
">Copy</button> </div> <p>This loads all the customers and the associated orders and reviews for each.</p>
<h4 id="nested-associations-hash"><a class="anchorlink" href="#nested-associations-hash"><span>13.2.1.2</span> Nested Associations Hash</a></h4>
<div class="interstitial code"> <pre data-language="ruby">Customer.includes(orders: { books: [:supplier, :author] }).find(1)</pre> <button class="clipboard-button" data-clipboard-text="Customer.includes(orders: { books: [:supplier, :author] }).find(1)
">Copy</button> </div> <p>This will find the customer with id 1 and eager load all of the associated orders for it, the books for all of the orders, and the author and supplier for each of the books.</p>
<h3 id="specifying-conditions-on-eager-loaded-associations"><a class="anchorlink" href="#specifying-conditions-on-eager-loaded-associations"><span>13.2.2</span> Specifying Conditions on Eager Loaded Associations</a></h3>
<p>Even though Active Record lets you specify conditions on the eager loaded associations just like <code>joins</code>, the recommended way is to use <a href="#joining-tables">joins</a> instead.</p>
<p>However if you must do this, you may use <code>where</code> as you would normally.</p>
<div class="interstitial code"> <pre data-language="ruby">Author.includes(:books).where(books: { out_of_print: true })</pre> <button class="clipboard-button" data-clipboard-text="Author.includes(:books).where(books: { out_of_print: true })
">Copy</button> </div> <p>This would generate a query which contains a <code>LEFT OUTER JOIN</code> whereas the <code>joins</code> method would generate one using the <code>INNER JOIN</code> function instead.</p>
<div class="interstitial code"> <pre data-language="sql">SELECT authors.id AS t0_r0, ... books.updated_at AS t1_r5 FROM authors LEFT OUTER JOIN books ON books.author_id = authors.id WHERE (books.out_of_print = 1)</pre> <button class="clipboard-button" data-clipboard-text="  SELECT authors.id AS t0_r0, ... books.updated_at AS t1_r5 FROM authors LEFT OUTER JOIN books ON books.author_id = authors.id WHERE (books.out_of_print = 1)
">Copy</button> </div> <p>If there was no <code>where</code> condition, this would generate the normal set of two queries.</p>
<div class="interstitial note"><p>Using <code>where</code> like this will only work when you pass it a Hash. For SQL-fragments you need to use <code>references</code> to force joined tables:</p></div>
<div class="interstitial code"> <pre data-language="ruby">Author.includes(:books).where("books.out_of_print = true").references(:books)</pre> <button class="clipboard-button" data-clipboard-text='Author.includes(:books).where("books.out_of_print = true").references(:books)
'>Copy</button> </div> <p>If, in the case of this <code>includes</code> query, there were no books for any authors, all the authors would still be loaded. By using <code>joins</code> (an INNER JOIN), the join conditions <strong>must</strong> match, otherwise no records will be returned.</p>
<div class="interstitial note"><p>If an association is eager loaded as part of a join, any fields from a custom select clause will not be present on the loaded models. This is because it is ambiguous whether they should appear on the parent record, or the child.</p></div>
<h2 id="preload"><a class="anchorlink" href="#preload"><span>13.3</span> <code>preload</code></a></h2>
<p>With <code>preload</code>, Active Record loads each specified association using one query per association.</p>
<p>Revisiting the N + 1 queries problem, we could rewrite <code>Book.limit(10)</code> to preload authors:</p>
<div class="interstitial code"> <pre data-language="ruby">books = Book.preload(:author).limit(10)

books.each do |book|
  puts book.author.last_name
end</pre> <button class="clipboard-button" data-clipboard-text="books = Book.preload(:author).limit(10)

books.each do |book|
  puts book.author.last_name
end
">Copy</button> </div> <p>The above code will execute just <strong>2</strong> queries, as opposed to the <strong>11</strong> queries from the original case:</p>
<div class="interstitial code"> <pre data-language="sql">SELECT books.* FROM books LIMIT 10
SELECT authors.* FROM authors
  WHERE authors.id IN (1,2,3,4,5,6,7,8,9,10)</pre> <button class="clipboard-button" data-clipboard-text="SELECT books.* FROM books LIMIT 10
SELECT authors.* FROM authors
  WHERE authors.id IN (1,2,3,4,5,6,7,8,9,10)
">Copy</button> </div> <div class="interstitial note"><p>The <code>preload</code> method uses an array, hash, or a nested hash of array/hash in the same way as the <code>includes</code> method to load any number of associations with a single <code>Model.find</code> call. However, unlike the <code>includes</code> method, it is not possible to specify conditions for preloaded associations.</p></div>
<h2 id="eager-load"><a class="anchorlink" href="#eager-load"><span>13.4</span> <code>eager_load</code></a></h2>
<p>With <code>eager_load</code>, Active Record loads all specified associations using a <code>LEFT OUTER JOIN</code>.</p>
<p>Revisiting the case where N + 1 was occurred using the <code>eager_load</code> method, we could rewrite <code>Book.limit(10)</code> to authors:</p>
<div class="interstitial code"> <pre data-language="ruby">books = Book.eager_load(:author).limit(10)

books.each do |book|
  puts book.author.last_name
end</pre> <button class="clipboard-button" data-clipboard-text="books = Book.eager_load(:author).limit(10)

books.each do |book|
  puts book.author.last_name
end
">Copy</button> </div> <p>The above code will execute just <strong>1</strong> query, as opposed to the <strong>11</strong> queries from the original case:</p>
<div class="interstitial code"> <pre data-language="sql">SELECT "books"."id" AS t0_r0, "books"."title" AS t0_r1, ... FROM "books"
  LEFT OUTER JOIN "authors" ON "authors"."id" = "books"."author_id"
  LIMIT 10</pre> <button class="clipboard-button" data-clipboard-text='SELECT "books"."id" AS t0_r0, "books"."title" AS t0_r1, ... FROM "books"
  LEFT OUTER JOIN "authors" ON "authors"."id" = "books"."author_id"
  LIMIT 10
'>Copy</button> </div> <div class="interstitial note"><p>The <code>eager_load</code> method uses an array, hash, or a nested hash of array/hash in the same way as the <code>includes</code> method to load any number of associations with a single <code>Model.find</code> call. Also, like the <code>includes</code> method, you can specify conditions for eager loaded associations.</p></div>
<h2 id="strict-loading"><a class="anchorlink" href="#strict-loading"><span>13.5</span> <code>strict_loading</code></a></h2>
<p>Eager loading can prevent N + 1 queries but you might still be lazy loading some associations. To make sure no associations are lazy loaded you can enable <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-strict_loading"><code>strict_loading</code></a>.</p>
<p>By enabling strict loading mode on a relation, an <code>ActiveRecord::StrictLoadingViolationError</code> will be raised if the record tries to lazily load any association:</p>
<div class="interstitial code"> <pre data-language="ruby">user = User.strict_loading.first
user.address.city # raises an ActiveRecord::StrictLoadingViolationError
user.comments.to_a # raises an ActiveRecord::StrictLoadingViolationError</pre> <button class="clipboard-button" data-clipboard-text="user = User.strict_loading.first
user.address.city # raises an ActiveRecord::StrictLoadingViolationError
user.comments.to_a # raises an ActiveRecord::StrictLoadingViolationError
">Copy</button> </div> <p>To enable for all relations, change the <a href="configuring.html#config-active-record-strict-loading-by-default"><code>config.active_record.strict_loading_by_default</code></a> flag to <code>true</code>.</p>
<p>To send violations to the logger instead, change <a href="configuring.html#config-active-record-action-on-strict-loading-violation"><code>config.active_record.action_on_strict_loading_violation</code></a> to <code>:log</code>.</p>
<h2 id="strict-loading-bang"><a class="anchorlink" href="#strict-loading-bang"><span>13.6</span> <code>strict_loading!</code></a></h2>
<p>We can also enable strict loading on the record itself by calling <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Core.html#method-i-strict_loading-21"><code>strict_loading!</code></a>:</p>
<div class="interstitial code"> <pre data-language="ruby">user = User.first
user.strict_loading!
user.address.city # raises an ActiveRecord::StrictLoadingViolationError
user.comments.to_a # raises an ActiveRecord::StrictLoadingViolationError</pre> <button class="clipboard-button" data-clipboard-text="user = User.first
user.strict_loading!
user.address.city # raises an ActiveRecord::StrictLoadingViolationError
user.comments.to_a # raises an ActiveRecord::StrictLoadingViolationError
">Copy</button> </div> <p><code>strict_loading!</code> also takes a <code>:mode</code> argument. Setting it to <code>:n_plus_one_only</code> will only raise an error if an association that will lead to an N + 1 query is lazily loaded:</p>
<div class="interstitial code"> <pre data-language="ruby">user.strict_loading!(mode: :n_plus_one_only)
user.address.city # =&gt; "Tatooine"
user.comments.to_a # =&gt; [#&lt;Comment:0x00...]
user.comments.first.likes.to_a # raises an ActiveRecord::StrictLoadingViolationError</pre> <button class="clipboard-button" data-clipboard-text='user.strict_loading!(mode: :n_plus_one_only)
user.address.city # =&gt; "Tatooine"
user.comments.to_a # =&gt; [#&lt;Comment:0x00...]
user.comments.first.likes.to_a # raises an ActiveRecord::StrictLoadingViolationError
'>Copy</button> </div> <h2 id="strict-loading-option-on-an-association"><a class="anchorlink" href="#strict-loading-option-on-an-association"><span>13.7</span> <code>strict_loading</code> option on an association</a></h2>
<p>We can also enable strict loading for a single association by providing the <code>strict_loading</code> option:</p>
<div class="interstitial code"> <pre data-language="ruby">class Author &lt; ApplicationRecord
  has_many :books, strict_loading: true
end</pre> <button class="clipboard-button" data-clipboard-text="class Author &lt; ApplicationRecord
  has_many :books, strict_loading: true
end
">Copy</button> </div> <h1 id="scopes"><a class="anchorlink" href="#scopes"><span>14</span> Scopes</a></h1>
<p>Scoping allows you to specify commonly-used queries which can be referenced as method calls on the association objects or models. With these scopes, you can use every method previously covered such as <code>where</code>, <code>joins</code> and <code>includes</code>. All scope bodies should return an <code>ActiveRecord::Relation</code> or <code>nil</code> to allow for further methods (such as other scopes) to be called on it.</p>
<p>To define a simple scope, we use the <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Scoping/Named/ClassMethods.html#method-i-scope"><code>scope</code></a> method inside the class, passing the query that we'd like to run when this scope is called:</p>
<div class="interstitial code"> <pre data-language="ruby">class Book &lt; ApplicationRecord
  scope :out_of_print, -&gt; { where(out_of_print: true) }
end</pre> <button class="clipboard-button" data-clipboard-text="class Book &lt; ApplicationRecord
  scope :out_of_print, -&gt; { where(out_of_print: true) }
end
">Copy</button> </div> <p>To call this <code>out_of_print</code> scope we can call it on either the class:</p>
<div class="interstitial code"> <pre data-language="irb">irb&gt; Book.out_of_print
=&gt; #&lt;ActiveRecord::Relation&gt; # all out of print books</pre> <button class="clipboard-button" data-clipboard-text="Book.out_of_print
">Copy</button> </div> <p>Or on an association consisting of <code>Book</code> objects:</p>
<div class="interstitial code"> <pre data-language="irb">irb&gt; author = Author.first
irb&gt; author.books.out_of_print
=&gt; #&lt;ActiveRecord::Relation&gt; # all out of print books by `author`</pre> <button class="clipboard-button" data-clipboard-text="author = Author.first
author.books.out_of_print
">Copy</button> </div> <p>Scopes are also chainable within scopes:</p>
<div class="interstitial code"> <pre data-language="ruby">class Book &lt; ApplicationRecord
  scope :out_of_print, -&gt; { where(out_of_print: true) }
  scope :out_of_print_and_expensive, -&gt; { out_of_print.where("price &gt; 500") }
end</pre> <button class="clipboard-button" data-clipboard-text='class Book &lt; ApplicationRecord
  scope :out_of_print, -&gt; { where(out_of_print: true) }
  scope :out_of_print_and_expensive, -&gt; { out_of_print.where("price &gt; 500") }
end
'>Copy</button> </div> <h2 id="passing-in-arguments"><a class="anchorlink" href="#passing-in-arguments"><span>14.1</span> Passing in Arguments</a></h2>
<p>Your scope can take arguments:</p>
<div class="interstitial code"> <pre data-language="ruby">class Book &lt; ApplicationRecord
  scope :costs_more_than, -&gt;(amount) { where("price &gt; ?", amount) }
end</pre> <button class="clipboard-button" data-clipboard-text='class Book &lt; ApplicationRecord
  scope :costs_more_than, -&gt;(amount) { where("price &gt; ?", amount) }
end
'>Copy</button> </div> <p>Call the scope as if it were a class method:</p>
<div class="interstitial code"> <pre data-language="irb">irb&gt; Book.costs_more_than(100.10)</pre> <button class="clipboard-button" data-clipboard-text="Book.costs_more_than(100.10)
">Copy</button> </div> <p>However, this is just duplicating the functionality that would be provided to you by a class method.</p>
<div class="interstitial code"> <pre data-language="ruby">class Book &lt; ApplicationRecord
  def self.costs_more_than(amount)
    where("price &gt; ?", amount)
  end
end</pre> <button class="clipboard-button" data-clipboard-text='class Book &lt; ApplicationRecord
  def self.costs_more_than(amount)
    where("price &gt; ?", amount)
  end
end
'>Copy</button> </div> <p>These methods will still be accessible on the association objects:</p>
<div class="interstitial code"> <pre data-language="irb">irb&gt; author.books.costs_more_than(100.10)</pre> <button class="clipboard-button" data-clipboard-text="author.books.costs_more_than(100.10)
">Copy</button> </div> <h2 id="using-conditionals"><a class="anchorlink" href="#using-conditionals"><span>14.2</span> Using Conditionals</a></h2>
<p>Your scope can utilize conditionals:</p>
<div class="interstitial code"> <pre data-language="ruby">class Order &lt; ApplicationRecord
  scope :created_before, -&gt;(time) { where(created_at: ...time) if time.present? }
end</pre> <button class="clipboard-button" data-clipboard-text="class Order &lt; ApplicationRecord
  scope :created_before, -&gt;(time) { where(created_at: ...time) if time.present? }
end
">Copy</button> </div> <p>Like the other examples, this will behave similarly to a class method.</p>
<div class="interstitial code"> <pre data-language="ruby">class Order &lt; ApplicationRecord
  def self.created_before(time)
    where(created_at: ...time) if time.present?
  end
end</pre> <button class="clipboard-button" data-clipboard-text="class Order &lt; ApplicationRecord
  def self.created_before(time)
    where(created_at: ...time) if time.present?
  end
end
">Copy</button> </div> <p>However, there is one important caveat: A scope will always return an <code>ActiveRecord::Relation</code> object, even if the conditional evaluates to <code>false</code>, whereas a class method, will return <code>nil</code>. This can cause <code>NoMethodError</code> when chaining class methods with conditionals, if any of the conditionals return <code>false</code>.</p>
<h2 id="applying-a-default-scope"><a class="anchorlink" href="#applying-a-default-scope"><span>14.3</span> Applying a Default Scope</a></h2>
<p>If we wish for a scope to be applied across all queries to the model we can use the <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Scoping/Default/ClassMethods.html#method-i-default_scope"><code>default_scope</code></a> method within the model itself.</p>
<div class="interstitial code"> <pre data-language="ruby">class Book &lt; ApplicationRecord
  default_scope { where(out_of_print: false) }
end</pre> <button class="clipboard-button" data-clipboard-text="class Book &lt; ApplicationRecord
  default_scope { where(out_of_print: false) }
end
">Copy</button> </div> <p>When queries are executed on this model, the SQL query will now look something like this:</p>
<div class="interstitial code"> <pre data-language="sql">SELECT * FROM books WHERE (out_of_print = false)</pre> <button class="clipboard-button" data-clipboard-text="SELECT * FROM books WHERE (out_of_print = false)
">Copy</button> </div> <p>If you need to do more complex things with a default scope, you can alternatively define it as a class method:</p>
<div class="interstitial code"> <pre data-language="ruby">class Book &lt; ApplicationRecord
  def self.default_scope
    # Should return an ActiveRecord::Relation.
  end
end</pre> <button class="clipboard-button" data-clipboard-text="class Book &lt; ApplicationRecord
  def self.default_scope
    # Should return an ActiveRecord::Relation.
  end
end
">Copy</button> </div> <div class="interstitial note"><p>The <code>default_scope</code> is also applied while creating/building a record when the scope arguments are given as a <code>Hash</code>. It is not applied while updating a record. E.g.:</p></div>
<div class="interstitial code"> <pre data-language="ruby">class Book &lt; ApplicationRecord
  default_scope { where(out_of_print: false) }
end</pre> <button class="clipboard-button" data-clipboard-text="class Book &lt; ApplicationRecord
  default_scope { where(out_of_print: false) }
end
">Copy</button> </div> <div class="interstitial code"> <pre data-language="irb">irb&gt; Book.new
=&gt; #&lt;Book id: nil, out_of_print: false&gt;
irb&gt; Book.unscoped.new
=&gt; #&lt;Book id: nil, out_of_print: nil&gt;</pre> <button class="clipboard-button" data-clipboard-text="Book.new
Book.unscoped.new
">Copy</button> </div> <p>Be aware that, when given in the <code>Array</code> format, <code>default_scope</code> query arguments cannot be converted to a <code>Hash</code> for default attribute assignment. E.g.:</p>
<div class="interstitial code"> <pre data-language="ruby">class Book &lt; ApplicationRecord
  default_scope { where("out_of_print = ?", false) }
end</pre> <button class="clipboard-button" data-clipboard-text='class Book &lt; ApplicationRecord
  default_scope { where("out_of_print = ?", false) }
end
'>Copy</button> </div> <div class="interstitial code"> <pre data-language="irb">irb&gt; Book.new
=&gt; #&lt;Book id: nil, out_of_print: nil&gt;</pre> <button class="clipboard-button" data-clipboard-text="Book.new
">Copy</button> </div> <h2 id="merging-of-scopes"><a class="anchorlink" href="#merging-of-scopes"><span>14.4</span> Merging of Scopes</a></h2>
<p>Just like <code>where</code> clauses, scopes are merged using <code>AND</code> conditions.</p>
<div class="interstitial code"> <pre data-language="ruby">class Book &lt; ApplicationRecord
  scope :in_print, -&gt; { where(out_of_print: false) }
  scope :out_of_print, -&gt; { where(out_of_print: true) }

  scope :recent, -&gt; { where(year_published: 50.years.ago.year..) }
  scope :old, -&gt; { where(year_published: ...50.years.ago.year) }
end</pre> <button class="clipboard-button" data-clipboard-text="class Book &lt; ApplicationRecord
  scope :in_print, -&gt; { where(out_of_print: false) }
  scope :out_of_print, -&gt; { where(out_of_print: true) }

  scope :recent, -&gt; { where(year_published: 50.years.ago.year..) }
  scope :old, -&gt; { where(year_published: ...50.years.ago.year) }
end
">Copy</button> </div> <div class="interstitial code"> <pre data-language="irb">irb&gt; Book.out_of_print.old
SELECT books.* FROM books WHERE books.out_of_print = 'true' AND books.year_published &lt; 1969</pre> <button class="clipboard-button" data-clipboard-text="Book.out_of_print.old
">Copy</button> </div> <p>We can mix and match <code>scope</code> and <code>where</code> conditions and the final SQL will have all conditions joined with <code>AND</code>.</p>
<div class="interstitial code"> <pre data-language="irb">irb&gt; Book.in_print.where(price: ...100)
SELECT books.* FROM books WHERE books.out_of_print = 'false' AND books.price &lt; 100</pre> <button class="clipboard-button" data-clipboard-text="Book.in_print.where(price: ...100)
">Copy</button> </div> <p>If we do want the last <code>where</code> clause to win then <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/SpawnMethods.html#method-i-merge"><code>merge</code></a> can be used.</p>
<div class="interstitial code"> <pre data-language="irb">irb&gt; Book.in_print.merge(Book.out_of_print)
SELECT books.* FROM books WHERE books.out_of_print = true</pre> <button class="clipboard-button" data-clipboard-text="Book.in_print.merge(Book.out_of_print)
">Copy</button> </div> <p>One important caveat is that <code>default_scope</code> will be prepended in <code>scope</code> and <code>where</code> conditions.</p>
<div class="interstitial code"> <pre data-language="ruby">class Book &lt; ApplicationRecord
  default_scope { where(year_published: 50.years.ago.year..) }

  scope :in_print, -&gt; { where(out_of_print: false) }
  scope :out_of_print, -&gt; { where(out_of_print: true) }
end</pre> <button class="clipboard-button" data-clipboard-text="class Book &lt; ApplicationRecord
  default_scope { where(year_published: 50.years.ago.year..) }

  scope :in_print, -&gt; { where(out_of_print: false) }
  scope :out_of_print, -&gt; { where(out_of_print: true) }
end
">Copy</button> </div> <div class="interstitial code"> <pre data-language="irb">irb&gt; Book.all
SELECT books.* FROM books WHERE (year_published &gt;= 1969)

irb&gt; Book.in_print
SELECT books.* FROM books WHERE (year_published &gt;= 1969) AND books.out_of_print = false

irb&gt; Book.where('price &gt; 50')
SELECT books.* FROM books WHERE (year_published &gt;= 1969) AND (price &gt; 50)</pre> <button class="clipboard-button" data-clipboard-text="Book.all
Book.in_print
Book.where('price &gt; 50')
">Copy</button> </div> <p>As you can see above the <code>default_scope</code> is being merged in both <code>scope</code> and <code>where</code> conditions.</p>
<h2 id="removing-all-scoping"><a class="anchorlink" href="#removing-all-scoping"><span>14.5</span> Removing All Scoping</a></h2>
<p>If we wish to remove scoping for any reason we can use the <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Scoping/Default/ClassMethods.html#method-i-unscoped"><code>unscoped</code></a> method. This is especially useful if a <code>default_scope</code> is specified in the model and should not be applied for this particular query.</p>
<div class="interstitial code"> <pre data-language="ruby">Book.unscoped.load</pre> <button class="clipboard-button" data-clipboard-text="Book.unscoped.load
">Copy</button> </div> <p>This method removes all scoping and will do a normal query on the table.</p>
<div class="interstitial code"> <pre data-language="irb">irb&gt; Book.unscoped.all
SELECT books.* FROM books

irb&gt; Book.where(out_of_print: true).unscoped.all
SELECT books.* FROM books</pre> <button class="clipboard-button" data-clipboard-text="Book.unscoped.all
Book.where(out_of_print: true).unscoped.all
">Copy</button> </div> <p><code>unscoped</code> can also accept a block:</p>
<div class="interstitial code"> <pre data-language="irb">irb&gt; Book.unscoped { Book.out_of_print }
SELECT books.* FROM books WHERE books.out_of_print = true</pre> <button class="clipboard-button" data-clipboard-text="Book.unscoped { Book.out_of_print }
">Copy</button> </div> <h1 id="dynamic-finders"><a class="anchorlink" href="#dynamic-finders"><span>15</span> Dynamic Finders</a></h1>
<p>For every field (also known as an attribute) you define in your table, Active Record provides a finder method. If you have a field called <code>first_name</code> on your <code>Customer</code> model for example, you get the instance method <code>find_by_first_name</code> for free from Active Record. If you also have a <code>locked</code> field on the <code>Customer</code> model, you also get <code>find_by_locked</code> method.</p>
<p>You can specify an exclamation point (<code>!</code>) on the end of the dynamic finders to get them to raise an <code>ActiveRecord::RecordNotFound</code> error if they do not return any records, like <code>Customer.find_by_first_name!("Ryan")</code></p>
<p>If you want to find both by <code>first_name</code> and <code>orders_count</code>, you can chain these finders together by simply typing "<code>and</code>" between the fields. For example, <code>Customer.find_by_first_name_and_orders_count("Ryan", 5)</code>.</p>
<h1 id="enums"><a class="anchorlink" href="#enums"><span>16</span> Enums</a></h1>
<p>An enum lets you define an Array of values for an attribute and refer to them by name. The actual value stored in the database is an integer that has been mapped to one of the values.</p>
<p>Declaring an enum will:</p> <ul> <li>Create scopes that can be used to find all objects that have or do not have one of the enum values</li> <li>Create an instance method that can be used to determine if an object has a particular value for the enum</li> <li>Create an instance method that can be used to change the enum value of an object</li> </ul> <p>for all possible values of an enum.</p>
<p>For example, given this <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Enum.html#method-i-enum"><code>enum</code></a> declaration:</p>
<div class="interstitial code"> <pre data-language="ruby">class Order &lt; ApplicationRecord
  enum :status, [:shipped, :being_packaged, :complete, :cancelled]
end</pre> <button class="clipboard-button" data-clipboard-text="class Order &lt; ApplicationRecord
  enum :status, [:shipped, :being_packaged, :complete, :cancelled]
end
">Copy</button> </div> <p>These <a href="#scopes">scopes</a> are created automatically and can be used to find all objects with or without a particular value for <code>status</code>:</p>
<div class="interstitial code"> <pre data-language="irb">irb&gt; Order.shipped
=&gt; #&lt;ActiveRecord::Relation&gt; # all orders with status == :shipped
irb&gt; Order.not_shipped
=&gt; #&lt;ActiveRecord::Relation&gt; # all orders with status != :shipped</pre> <button class="clipboard-button" data-clipboard-text="Order.shipped
Order.not_shipped
">Copy</button> </div> <p>These instance methods are created automatically and query whether the model has that value for the <code>status</code> enum:</p>
<div class="interstitial code"> <pre data-language="irb">irb&gt; order = Order.shipped.first
irb&gt; order.shipped?
=&gt; true
irb&gt; order.complete?
=&gt; false</pre> <button class="clipboard-button" data-clipboard-text="order = Order.shipped.first
order.shipped?
order.complete?
">Copy</button> </div> <p>These instance methods are created automatically and will first update the value of <code>status</code> to the named value and then query whether or not the status has been successfully set to the value:</p>
<div class="interstitial code"> <pre data-language="irb">irb&gt; order = Order.first
irb&gt; order.shipped!
UPDATE "orders" SET "status" = ?, "updated_at" = ? WHERE "orders"."id" = ?  [["status", 0], ["updated_at", "2019-01-24 07:13:08.524320"], ["id", 1]]
=&gt; true</pre> <button class="clipboard-button" data-clipboard-text="order = Order.first
order.shipped!
">Copy</button> </div> <p>Full documentation about enums can be found <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Enum.html">here</a>.</p>
<h1 id="understanding-method-chaining"><a class="anchorlink" href="#understanding-method-chaining"><span>17</span> Understanding Method Chaining</a></h1>
<p>The Active Record pattern implements <a href="https://en.wikipedia.org/wiki/Method_chaining">Method Chaining</a>, which allow us to use multiple Active Record methods together in a simple and straightforward way.</p>
<p>You can chain methods in a statement when the previous method called returns an <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Relation.html"><code>ActiveRecord::Relation</code></a>, like <code>all</code>, <code>where</code>, and <code>joins</code>. Methods that return a single object (see <a href="#retrieving-a-single-object">Retrieving a Single Object Section</a>) have to be at the end of the statement.</p>
<p>There are some examples below. This guide won't cover all the possibilities, just a few as examples. When an Active Record method is called, the query is not immediately generated and sent to the database. The query is sent only when the data is actually needed. So each example below generates a single query.</p>
<h2 id="retrieving-filtered-data-from-multiple-tables"><a class="anchorlink" href="#retrieving-filtered-data-from-multiple-tables"><span>17.1</span> Retrieving Filtered Data from Multiple Tables</a></h2>
<div class="interstitial code"> <pre data-language="ruby">Customer
  .select('customers.id, customers.last_name, reviews.body')
  .joins(:reviews)
  .where('reviews.created_at &gt; ?', 1.week.ago)</pre> <button class="clipboard-button" data-clipboard-text="Customer
  .select('customers.id, customers.last_name, reviews.body')
  .joins(:reviews)
  .where('reviews.created_at &gt; ?', 1.week.ago)
">Copy</button> </div> <p>The result should be something like this:</p>
<div class="interstitial code"> <pre data-language="sql">SELECT customers.id, customers.last_name, reviews.body
FROM customers
INNER JOIN reviews
  ON reviews.customer_id = customers.id
WHERE (reviews.created_at &gt; '2019-01-08')</pre> <button class="clipboard-button" data-clipboard-text="SELECT customers.id, customers.last_name, reviews.body
FROM customers
INNER JOIN reviews
  ON reviews.customer_id = customers.id
WHERE (reviews.created_at &gt; '2019-01-08')
">Copy</button> </div> <h2 id="retrieving-specific-data-from-multiple-tables"><a class="anchorlink" href="#retrieving-specific-data-from-multiple-tables"><span>17.2</span> Retrieving Specific Data from Multiple Tables</a></h2>
<div class="interstitial code"> <pre data-language="ruby">Book
  .select('books.id, books.title, authors.first_name')
  .joins(:author)
  .find_by(title: 'Abstraction and Specification in Program Development')</pre> <button class="clipboard-button" data-clipboard-text="Book
  .select('books.id, books.title, authors.first_name')
  .joins(:author)
  .find_by(title: 'Abstraction and Specification in Program Development')
">Copy</button> </div> <p>The above should generate:</p>
<div class="interstitial code"> <pre data-language="sql">SELECT books.id, books.title, authors.first_name
FROM books
INNER JOIN authors
  ON authors.id = books.author_id
WHERE books.title = $1 [["title", "Abstraction and Specification in Program Development"]]
LIMIT 1</pre> <button class="clipboard-button" data-clipboard-text='SELECT books.id, books.title, authors.first_name
FROM books
INNER JOIN authors
  ON authors.id = books.author_id
WHERE books.title = $1 [["title", "Abstraction and Specification in Program Development"]]
LIMIT 1
'>Copy</button> </div> <div class="interstitial note"><p>Note that if a query matches multiple records, <code>find_by</code> will fetch only the first one and ignore the others (see the <code>LIMIT 1</code> statement above).</p></div>
<h1 id="find-or-build-a-new-object"><a class="anchorlink" href="#find-or-build-a-new-object"><span>18</span> Find or Build a New Object</a></h1>
<p>It's common that you need to find a record or create it if it doesn't exist. You can do that with the <code>find_or_create_by</code> and <code>find_or_create_by!</code> methods.</p>
<h2 id="find-or-create-by"><a class="anchorlink" href="#find-or-create-by"><span>18.1</span> <code>find_or_create_by</code></a></h2>
<p>The <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Relation.html#method-i-find_or_create_by"><code>find_or_create_by</code></a> method checks whether a record with the specified attributes exists. If it doesn't, then <code>create</code> is called. Let's see an example.</p>
<p>Suppose you want to find a customer named "Andy", and if there's none, create one. You can do so by running:</p>
<div class="interstitial code"> <pre data-language="irb">irb&gt; Customer.find_or_create_by(first_name: 'Andy')
=&gt; #&lt;Customer id: 5, first_name: "Andy", last_name: nil, title: nil, visits: 0, orders_count: nil, lock_version: 0, created_at: "2019-01-17 07:06:45", updated_at: "2019-01-17 07:06:45"&gt;</pre> <button class="clipboard-button" data-clipboard-text="Customer.find_or_create_by(first_name: 'Andy')
">Copy</button> </div> <p>The SQL generated by this method looks like this:</p>
<div class="interstitial code"> <pre data-language="sql">SELECT * FROM customers WHERE (customers.first_name = 'Andy') LIMIT 1
BEGIN
INSERT INTO customers (created_at, first_name, locked, orders_count, updated_at) VALUES ('2011-08-30 05:22:57', 'Andy', 1, NULL, '2011-08-30 05:22:57')
COMMIT</pre> <button class="clipboard-button" data-clipboard-text="SELECT * FROM customers WHERE (customers.first_name = 'Andy') LIMIT 1
BEGIN
INSERT INTO customers (created_at, first_name, locked, orders_count, updated_at) VALUES ('2011-08-30 05:22:57', 'Andy', 1, NULL, '2011-08-30 05:22:57')
COMMIT
">Copy</button> </div> <p><code>find_or_create_by</code> returns either the record that already exists or the new record. In our case, we didn't already have a customer named Andy so the record is created and returned.</p>
<p>The new record might not be saved to the database; that depends on whether validations passed or not (just like <code>create</code>).</p>
<p>Suppose we want to set the 'locked' attribute to <code>false</code> if we're creating a new record, but we don't want to include it in the query. So we want to find the customer named "Andy", or if that customer doesn't exist, create a customer named "Andy" which is not locked.</p>
<p>We can achieve this in two ways. The first is to use <code>create_with</code>:</p>
<div class="interstitial code"> <pre data-language="ruby">Customer.create_with(locked: false).find_or_create_by(first_name: 'Andy')</pre> <button class="clipboard-button" data-clipboard-text="Customer.create_with(locked: false).find_or_create_by(first_name: 'Andy')
">Copy</button> </div> <p>The second way is using a block:</p>
<div class="interstitial code"> <pre data-language="ruby">Customer.find_or_create_by(first_name: 'Andy') do |c|
  c.locked = false
end</pre> <button class="clipboard-button" data-clipboard-text="Customer.find_or_create_by(first_name: 'Andy') do |c|
  c.locked = false
end
">Copy</button> </div> <p>The block will only be executed if the customer is being created. The second time we run this code, the block will be ignored.</p>
<h2 id="find-or-create-by-bang"><a class="anchorlink" href="#find-or-create-by-bang"><span>18.2</span> <code>find_or_create_by!</code></a></h2>
<p>You can also use <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Relation.html#method-i-find_or_create_by-21"><code>find_or_create_by!</code></a> to raise an exception if the new record is invalid. Validations are not covered on this guide, but let's assume for a moment that you temporarily add</p>
<div class="interstitial code"> <pre data-language="ruby">validates :orders_count, presence: true</pre> <button class="clipboard-button" data-clipboard-text="validates :orders_count, presence: true
">Copy</button> </div> <p>to your <code>Customer</code> model. If you try to create a new <code>Customer</code> without passing an <code>orders_count</code>, the record will be invalid and an exception will be raised:</p>
<div class="interstitial code"> <pre data-language="irb">irb&gt; Customer.find_or_create_by!(first_name: 'Andy')
ActiveRecord::RecordInvalid: Validation failed: Orders count can't be blank</pre> <button class="clipboard-button" data-clipboard-text="Customer.find_or_create_by!(first_name: 'Andy')
">Copy</button> </div> <h2 id="find-or-initialize-by"><a class="anchorlink" href="#find-or-initialize-by"><span>18.3</span> <code>find_or_initialize_by</code></a></h2>
<p>The <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Relation.html#method-i-find_or_initialize_by"><code>find_or_initialize_by</code></a> method will work just like <code>find_or_create_by</code> but it will call <code>new</code> instead of <code>create</code>. This means that a new model instance will be created in memory but won't be saved to the database. Continuing with the <code>find_or_create_by</code> example, we now want the customer named 'Nina':</p>
<div class="interstitial code"> <pre data-language="irb">irb&gt; nina = Customer.find_or_initialize_by(first_name: 'Nina')
=&gt; #&lt;Customer id: nil, first_name: "Nina", orders_count: 0, locked: true, created_at: "2011-08-30 06:09:27", updated_at: "2011-08-30 06:09:27"&gt;

irb&gt; nina.persisted?
=&gt; false

irb&gt; nina.new_record?
=&gt; true</pre> <button class="clipboard-button" data-clipboard-text="nina = Customer.find_or_initialize_by(first_name: 'Nina')
nina.persisted?
nina.new_record?
">Copy</button> </div> <p>Because the object is not yet stored in the database, the SQL generated looks like this:</p>
<div class="interstitial code"> <pre data-language="sql">SELECT * FROM customers WHERE (customers.first_name = 'Nina') LIMIT 1</pre> <button class="clipboard-button" data-clipboard-text="SELECT * FROM customers WHERE (customers.first_name = 'Nina') LIMIT 1
">Copy</button> </div> <p>When you want to save it to the database, just call <code>save</code>:</p>
<div class="interstitial code"> <pre data-language="irb">irb&gt; nina.save
=&gt; true</pre> <button class="clipboard-button" data-clipboard-text="nina.save
">Copy</button> </div> <h1 id="finding-by-sql"><a class="anchorlink" href="#finding-by-sql"><span>19</span> Finding by SQL</a></h1>
<p>If you'd like to use your own SQL to find records in a table you can use <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Querying.html#method-i-find_by_sql"><code>find_by_sql</code></a>. The <code>find_by_sql</code> method will return an array of objects even if the underlying query returns just a single record. For example you could run this query:</p>
<div class="interstitial code"> <pre data-language="irb">irb&gt; Customer.find_by_sql("SELECT * FROM customers INNER JOIN orders ON customers.id = orders.customer_id ORDER BY customers.created_at desc")
=&gt; [#&lt;Customer id: 1, first_name: "Lucas" ...&gt;, #&lt;Customer id: 2, first_name: "Jan" ...&gt;, ...]</pre> <button class="clipboard-button" data-clipboard-text='Customer.find_by_sql("SELECT * FROM customers INNER JOIN orders ON customers.id = orders.customer_id ORDER BY customers.created_at desc")
'>Copy</button> </div> <p><code>find_by_sql</code> provides you with a simple way of making custom calls to the database and retrieving instantiated objects.</p>
<h2 id="select-all"><a class="anchorlink" href="#select-all"><span>19.1</span> <code>select_all</code></a></h2>
<p><code>find_by_sql</code> has a close relative called <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/DatabaseStatements.html#method-i-select_all"><code>connection.select_all</code></a>. <code>select_all</code> will retrieve objects from the database using custom SQL just like <code>find_by_sql</code> but will not instantiate them. This method will return an instance of <code>ActiveRecord::Result</code> class and calling <code>to_a</code> on this object would return you an array of hashes where each hash indicates a record.</p>
<div class="interstitial code"> <pre data-language="irb">irb&gt; Customer.connection.select_all("SELECT first_name, created_at FROM customers WHERE id = '1'").to_a
=&gt; [{"first_name"=&gt;"Rafael", "created_at"=&gt;"2012-11-10 23:23:45.281189"}, {"first_name"=&gt;"Eileen", "created_at"=&gt;"2013-12-09 11:22:35.221282"}]</pre> <button class="clipboard-button" data-clipboard-text="Customer.connection.select_all(&quot;SELECT first_name, created_at FROM customers WHERE id = '1'&quot;).to_a
">Copy</button> </div> <h2 id="pluck"><a class="anchorlink" href="#pluck"><span>19.2</span> <code>pluck</code></a></h2>
<p><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Calculations.html#method-i-pluck"><code>pluck</code></a> can be used to pick the value(s) from the named column(s) in the current relation. It accepts a list of column names as an argument and returns an array of values of the specified columns with the corresponding data type.</p>
<div class="interstitial code"> <pre data-language="irb">irb&gt; Book.where(out_of_print: true).pluck(:id)
SELECT id FROM books WHERE out_of_print = true
=&gt; [1, 2, 3]

irb&gt; Order.distinct.pluck(:status)
SELECT DISTINCT status FROM orders
=&gt; ["shipped", "being_packed", "cancelled"]

irb&gt; Customer.pluck(:id, :first_name)
SELECT customers.id, customers.first_name FROM customers
=&gt; [[1, "David"], [2, "Fran"], [3, "Jose"]]</pre> <button class="clipboard-button" data-clipboard-text="Book.where(out_of_print: true).pluck(:id)
Order.distinct.pluck(:status)
Customer.pluck(:id, :first_name)
">Copy</button> </div> <p><code>pluck</code> makes it possible to replace code like:</p>
<div class="interstitial code"> <pre data-language="ruby">Customer.select(:id).map { |c| c.id }
# or
Customer.select(:id).map(&amp;:id)
# or
Customer.select(:id, :first_name).map { |c| [c.id, c.first_name] }</pre> <button class="clipboard-button" data-clipboard-text="Customer.select(:id).map { |c| c.id }
# or
Customer.select(:id).map(&amp;:id)
# or
Customer.select(:id, :first_name).map { |c| [c.id, c.first_name] }
">Copy</button> </div> <p>with:</p>
<div class="interstitial code"> <pre data-language="ruby">Customer.pluck(:id)
# or
Customer.pluck(:id, :first_name)</pre> <button class="clipboard-button" data-clipboard-text="Customer.pluck(:id)
# or
Customer.pluck(:id, :first_name)
">Copy</button> </div> <p>Unlike <code>select</code>, <code>pluck</code> directly converts a database result into a Ruby <code>Array</code>, without constructing <code>ActiveRecord</code> objects. This can mean better performance for a large or frequently-run query. However, any model method overrides will not be available. For example:</p>
<div class="interstitial code"> <pre data-language="ruby">class Customer &lt; ApplicationRecord
  def name
    "I am #{first_name}"
  end
end</pre> <button class="clipboard-button" data-clipboard-text='class Customer &lt; ApplicationRecord
  def name
    "I am #{first_name}"
  end
end
'>Copy</button> </div> <div class="interstitial code"> <pre data-language="irb">irb&gt; Customer.select(:first_name).map &amp;:name
=&gt; ["I am David", "I am Jeremy", "I am Jose"]

irb&gt; Customer.pluck(:first_name)
=&gt; ["David", "Jeremy", "Jose"]</pre> <button class="clipboard-button" data-clipboard-text="Customer.select(:first_name).map &amp;:name
Customer.pluck(:first_name)
">Copy</button> </div> <p>You are not limited to querying fields from a single table, you can query multiple tables as well.</p>
<div class="interstitial code"> <pre data-language="irb">irb&gt; Order.joins(:customer, :books).pluck("orders.created_at, customers.email, books.title")</pre> <button class="clipboard-button" data-clipboard-text='Order.joins(:customer, :books).pluck("orders.created_at, customers.email, books.title")
'>Copy</button> </div> <p>Furthermore, unlike <code>select</code> and other <code>Relation</code> scopes, <code>pluck</code> triggers an immediate query, and thus cannot be chained with any further scopes, although it can work with scopes already constructed earlier:</p>
<div class="interstitial code"> <pre data-language="irb">irb&gt; Customer.pluck(:first_name).limit(1)
NoMethodError: undefined method `limit' for #&lt;Array:0x007ff34d3ad6d8&gt;

irb&gt; Customer.limit(1).pluck(:first_name)
=&gt; ["David"]</pre> <button class="clipboard-button" data-clipboard-text="Customer.pluck(:first_name).limit(1)
Customer.limit(1).pluck(:first_name)
">Copy</button> </div> <div class="interstitial note"><p>You should also know that using <code>pluck</code> will trigger eager loading if the relation object contains include values, even if the eager loading is not necessary for the query. For example:</p></div>
<div class="interstitial code"> <pre data-language="irb">irb&gt; assoc = Customer.includes(:reviews)
irb&gt; assoc.pluck(:id)
SELECT "customers"."id" FROM "customers" LEFT OUTER JOIN "reviews" ON "reviews"."id" = "customers"."review_id"</pre> <button class="clipboard-button" data-clipboard-text="assoc = Customer.includes(:reviews)
assoc.pluck(:id)
">Copy</button> </div> <p>One way to avoid this is to <code>unscope</code> the includes:</p>
<div class="interstitial code"> <pre data-language="irb">irb&gt; assoc.unscope(:includes).pluck(:id)</pre> <button class="clipboard-button" data-clipboard-text="assoc.unscope(:includes).pluck(:id)
">Copy</button> </div> <h2 id="pick"><a class="anchorlink" href="#pick"><span>19.3</span> <code>pick</code></a></h2>
<p><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Calculations.html#method-i-pick"><code>pick</code></a> can be used to pick the value(s) from the named column(s) in the current relation. It accepts a list of column names as an argument and returns the first row of the specified column values ​​with corresponding data type. <code>pick</code> is a short-hand for <code>relation.limit(1).pluck(*column_names).first</code>, which is primarily useful when you already have a relation that is limited to one row.</p>
<p><code>pick</code> makes it possible to replace code like:</p>
<div class="interstitial code"> <pre data-language="ruby">Customer.where(id: 1).pluck(:id).first</pre> <button class="clipboard-button" data-clipboard-text="Customer.where(id: 1).pluck(:id).first
">Copy</button> </div> <p>with:</p>
<div class="interstitial code"> <pre data-language="ruby">Customer.where(id: 1).pick(:id)</pre> <button class="clipboard-button" data-clipboard-text="Customer.where(id: 1).pick(:id)
">Copy</button> </div> <h2 id="ids"><a class="anchorlink" href="#ids"><span>19.4</span> <code>ids</code></a></h2>
<p><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Calculations.html#method-i-ids"><code>ids</code></a> can be used to pluck all the IDs for the relation using the table's primary key.</p>
<div class="interstitial code"> <pre data-language="irb">irb&gt; Customer.ids
SELECT id FROM customers</pre> <button class="clipboard-button" data-clipboard-text="Customer.ids
">Copy</button> </div> <div class="interstitial code"> <pre data-language="ruby">class Customer &lt; ApplicationRecord
  self.primary_key = "customer_id"
end</pre> <button class="clipboard-button" data-clipboard-text='class Customer &lt; ApplicationRecord
  self.primary_key = "customer_id"
end
'>Copy</button> </div> <div class="interstitial code"> <pre data-language="irb">irb&gt; Customer.ids
SELECT customer_id FROM customers</pre> <button class="clipboard-button" data-clipboard-text="Customer.ids
">Copy</button> </div> <h1 id="existence-of-objects"><a class="anchorlink" href="#existence-of-objects"><span>20</span> Existence of Objects</a></h1>
<p>If you simply want to check for the existence of the object there's a method called <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/FinderMethods.html#method-i-exists-3F"><code>exists?</code></a>. This method will query the database using the same query as <code>find</code>, but instead of returning an object or collection of objects it will return either <code>true</code> or <code>false</code>.</p>
<div class="interstitial code"> <pre data-language="ruby">Customer.exists?(1)</pre> <button class="clipboard-button" data-clipboard-text="Customer.exists?(1)
">Copy</button> </div> <p>The <code>exists?</code> method also takes multiple values, but the catch is that it will return <code>true</code> if any one of those records exists.</p>
<div class="interstitial code"> <pre data-language="ruby">Customer.exists?(id: [1, 2, 3])
# or
Customer.exists?(first_name: ['Jane', 'Sergei'])</pre> <button class="clipboard-button" data-clipboard-text="Customer.exists?(id: [1, 2, 3])
# or
Customer.exists?(first_name: ['Jane', 'Sergei'])
">Copy</button> </div> <p>It's even possible to use <code>exists?</code> without any arguments on a model or a relation.</p>
<div class="interstitial code"> <pre data-language="ruby">Customer.where(first_name: 'Ryan').exists?</pre> <button class="clipboard-button" data-clipboard-text="Customer.where(first_name: 'Ryan').exists?
">Copy</button> </div> <p>The above returns <code>true</code> if there is at least one customer with the <code>first_name</code> 'Ryan' and <code>false</code> otherwise.</p>
<div class="interstitial code"> <pre data-language="ruby">Customer.exists?</pre> <button class="clipboard-button" data-clipboard-text="Customer.exists?
">Copy</button> </div> <p>The above returns <code>false</code> if the <code>customers</code> table is empty and <code>true</code> otherwise.</p>
<p>You can also use <code>any?</code> and <code>many?</code> to check for existence on a model or relation. <code>many?</code> will use SQL <code>count</code> to determine if the item exists.</p>
<div class="interstitial code"> <pre data-language="ruby"># via a model
Order.any?
# SELECT 1 FROM orders LIMIT 1
Order.many?
# SELECT COUNT(*) FROM (SELECT 1 FROM orders LIMIT 2)

# via a named scope
Order.shipped.any?
# SELECT 1 FROM orders WHERE orders.status = 0 LIMIT 1
Order.shipped.many?
# SELECT COUNT(*) FROM (SELECT 1 FROM orders WHERE orders.status = 0 LIMIT 2)

# via a relation
Book.where(out_of_print: true).any?
Book.where(out_of_print: true).many?

# via an association
Customer.first.orders.any?
Customer.first.orders.many?</pre> <button class="clipboard-button" data-clipboard-text="# via a model
Order.any?
# SELECT 1 FROM orders LIMIT 1
Order.many?
# SELECT COUNT(*) FROM (SELECT 1 FROM orders LIMIT 2)

# via a named scope
Order.shipped.any?
# SELECT 1 FROM orders WHERE orders.status = 0 LIMIT 1
Order.shipped.many?
# SELECT COUNT(*) FROM (SELECT 1 FROM orders WHERE orders.status = 0 LIMIT 2)

# via a relation
Book.where(out_of_print: true).any?
Book.where(out_of_print: true).many?

# via an association
Customer.first.orders.any?
Customer.first.orders.many?
">Copy</button> </div> <h1 id="calculations"><a class="anchorlink" href="#calculations"><span>21</span> Calculations</a></h1>
<p>This section uses <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Calculations.html#method-i-count"><code>count</code></a> as an example method in this preamble, but the options described apply to all sub-sections.</p>
<p>All calculation methods work directly on a model:</p>
<div class="interstitial code"> <pre data-language="irb">irb&gt; Customer.count
SELECT COUNT(*) FROM customers</pre> <button class="clipboard-button" data-clipboard-text="Customer.count
">Copy</button> </div> <p>Or on a relation:</p>
<div class="interstitial code"> <pre data-language="irb">irb&gt; Customer.where(first_name: 'Ryan').count
SELECT COUNT(*) FROM customers WHERE (first_name = 'Ryan')</pre> <button class="clipboard-button" data-clipboard-text="Customer.where(first_name: 'Ryan').count
">Copy</button> </div> <p>You can also use various finder methods on a relation for performing complex calculations:</p>
<div class="interstitial code"> <pre data-language="irb">irb&gt; Customer.includes("orders").where(first_name: 'Ryan', orders: { status: 'shipped' }).count</pre> <button class="clipboard-button" data-clipboard-text="Customer.includes(&quot;orders&quot;).where(first_name: 'Ryan', orders: { status: 'shipped' }).count
">Copy</button> </div> <p>Which will execute:</p>
<div class="interstitial code"> <pre data-language="sql">SELECT COUNT(DISTINCT customers.id) FROM customers
  LEFT OUTER JOIN orders ON orders.customer_id = customers.id
  WHERE (customers.first_name = 'Ryan' AND orders.status = 0)</pre> <button class="clipboard-button" data-clipboard-text="SELECT COUNT(DISTINCT customers.id) FROM customers
  LEFT OUTER JOIN orders ON orders.customer_id = customers.id
  WHERE (customers.first_name = 'Ryan' AND orders.status = 0)
">Copy</button> </div> <p>assuming that Order has <code>enum status: [ :shipped, :being_packed, :cancelled ]</code>.</p>
<h2 id="count"><a class="anchorlink" href="#count"><span>21.1</span> <code>count</code></a></h2>
<p>If you want to see how many records are in your model's table you could call <code>Customer.count</code> and that will return the number. If you want to be more specific and find all the customers with a title present in the database you can use <code>Customer.count(:title)</code>.</p>
<p>For options, please see the parent section, <a href="#calculations">Calculations</a>.</p>
<h2 id="average"><a class="anchorlink" href="#average"><span>21.2</span> <code>average</code></a></h2>
<p>If you want to see the average of a certain number in one of your tables you can call the <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Calculations.html#method-i-average"><code>average</code></a> method on the class that relates to the table. This method call will look something like this:</p>
<div class="interstitial code"> <pre data-language="ruby">Order.average("subtotal")</pre> <button class="clipboard-button" data-clipboard-text='Order.average("subtotal")
'>Copy</button> </div> <p>This will return a number (possibly a floating-point number such as 3.14159265) representing the average value in the field.</p>
<p>For options, please see the parent section, <a href="#calculations">Calculations</a>.</p>
<h2 id="minimum"><a class="anchorlink" href="#minimum"><span>21.3</span> <code>minimum</code></a></h2>
<p>If you want to find the minimum value of a field in your table you can call the <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Calculations.html#method-i-minimum"><code>minimum</code></a> method on the class that relates to the table. This method call will look something like this:</p>
<div class="interstitial code"> <pre data-language="ruby">Order.minimum("subtotal")</pre> <button class="clipboard-button" data-clipboard-text='Order.minimum("subtotal")
'>Copy</button> </div> <p>For options, please see the parent section, <a href="#calculations">Calculations</a>.</p>
<h2 id="maximum"><a class="anchorlink" href="#maximum"><span>21.4</span> <code>maximum</code></a></h2>
<p>If you want to find the maximum value of a field in your table you can call the <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Calculations.html#method-i-maximum"><code>maximum</code></a> method on the class that relates to the table. This method call will look something like this:</p>
<div class="interstitial code"> <pre data-language="ruby">Order.maximum("subtotal")</pre> <button class="clipboard-button" data-clipboard-text='Order.maximum("subtotal")
'>Copy</button> </div> <p>For options, please see the parent section, <a href="#calculations">Calculations</a>.</p>
<h2 id="sum"><a class="anchorlink" href="#sum"><span>21.5</span> <code>sum</code></a></h2>
<p>If you want to find the sum of a field for all records in your table you can call the <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Calculations.html#method-i-sum"><code>sum</code></a> method on the class that relates to the table. This method call will look something like this:</p>
<div class="interstitial code"> <pre data-language="ruby">Order.sum("subtotal")</pre> <button class="clipboard-button" data-clipboard-text='Order.sum("subtotal")
'>Copy</button> </div> <p>For options, please see the parent section, <a href="#calculations">Calculations</a>.</p>
<h1 id="running-explain"><a class="anchorlink" href="#running-explain"><span>22</span> Running EXPLAIN</a></h1>
<p>You can run <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Relation.html#method-i-explain"><code>explain</code></a> on a relation. EXPLAIN output varies for each database.</p>
<p>For example, running:</p>
<div class="interstitial code"> <pre data-language="ruby">Customer.where(id: 1).joins(:orders).explain</pre> <button class="clipboard-button" data-clipboard-text="Customer.where(id: 1).joins(:orders).explain
">Copy</button> </div> <p>may yield this for MySQL and MariaDB:</p>
<div class="interstitial code"> <pre data-language="sql">EXPLAIN SELECT `customers`.* FROM `customers` INNER JOIN `orders` ON `orders`.`customer_id` = `customers`.`id` WHERE `customers`.`id` = 1
+----+-------------+------------+-------+---------------+
| id | select_type | table      | type  | possible_keys |
+----+-------------+------------+-------+---------------+
|  1 | SIMPLE      | customers  | const | PRIMARY       |
|  1 | SIMPLE      | orders     | ALL   | NULL          |
+----+-------------+------------+-------+---------------+
+---------+---------+-------+------+-------------+
| key     | key_len | ref   | rows | Extra       |
+---------+---------+-------+------+-------------+
| PRIMARY | 4       | const |    1 |             |
| NULL    | NULL    | NULL  |    1 | Using where |
+---------+---------+-------+------+-------------+

2 rows in set (0.00 sec)</pre> <button class="clipboard-button" data-clipboard-text="EXPLAIN SELECT `customers`.* FROM `customers` INNER JOIN `orders` ON `orders`.`customer_id` = `customers`.`id` WHERE `customers`.`id` = 1
+----+-------------+------------+-------+---------------+
| id | select_type | table      | type  | possible_keys |
+----+-------------+------------+-------+---------------+
|  1 | SIMPLE      | customers  | const | PRIMARY       |
|  1 | SIMPLE      | orders     | ALL   | NULL          |
+----+-------------+------------+-------+---------------+
+---------+---------+-------+------+-------------+
| key     | key_len | ref   | rows | Extra       |
+---------+---------+-------+------+-------------+
| PRIMARY | 4       | const |    1 |             |
| NULL    | NULL    | NULL  |    1 | Using where |
+---------+---------+-------+------+-------------+

2 rows in set (0.00 sec)
">Copy</button> </div> <p>Active Record performs a pretty printing that emulates that of the corresponding database shell. So, the same query running with the PostgreSQL adapter would yield instead:</p>
<div class="interstitial code"> <pre data-language="sql">EXPLAIN SELECT "customers".* FROM "customers" INNER JOIN "orders" ON "orders"."customer_id" = "customers"."id" WHERE "customers"."id" = $1 [["id", 1]]
                                  QUERY PLAN
------------------------------------------------------------------------------
 Nested Loop  (cost=4.33..20.85 rows=4 width=164)
    -&gt;  Index Scan using customers_pkey on customers  (cost=0.15..8.17 rows=1 width=164)
          Index Cond: (id = '1'::bigint)
    -&gt;  Bitmap Heap Scan on orders  (cost=4.18..12.64 rows=4 width=8)
          Recheck Cond: (customer_id = '1'::bigint)
          -&gt;  Bitmap Index Scan on index_orders_on_customer_id  (cost=0.00..4.18 rows=4 width=0)
                Index Cond: (customer_id = '1'::bigint)
(7 rows)</pre> <button class="clipboard-button" data-clipboard-text="EXPLAIN SELECT &quot;customers&quot;.* FROM &quot;customers&quot; INNER JOIN &quot;orders&quot; ON &quot;orders&quot;.&quot;customer_id&quot; = &quot;customers&quot;.&quot;id&quot; WHERE &quot;customers&quot;.&quot;id&quot; = $1 [[&quot;id&quot;, 1]]
                                  QUERY PLAN
------------------------------------------------------------------------------
 Nested Loop  (cost=4.33..20.85 rows=4 width=164)
    -&gt;  Index Scan using customers_pkey on customers  (cost=0.15..8.17 rows=1 width=164)
          Index Cond: (id = '1'::bigint)
    -&gt;  Bitmap Heap Scan on orders  (cost=4.18..12.64 rows=4 width=8)
          Recheck Cond: (customer_id = '1'::bigint)
          -&gt;  Bitmap Index Scan on index_orders_on_customer_id  (cost=0.00..4.18 rows=4 width=0)
                Index Cond: (customer_id = '1'::bigint)
(7 rows)
">Copy</button> </div> <p>Eager loading may trigger more than one query under the hood, and some queries may need the results of previous ones. Because of that, <code>explain</code> actually executes the query, and then asks for the query plans. For example, running:</p>
<div class="interstitial code"> <pre data-language="ruby">Customer.where(id: 1).includes(:orders).explain</pre> <button class="clipboard-button" data-clipboard-text="Customer.where(id: 1).includes(:orders).explain
">Copy</button> </div> <p>may yield this for MySQL and MariaDB:</p>
<div class="interstitial code"> <pre data-language="sql">EXPLAIN SELECT `customers`.* FROM `customers`  WHERE `customers`.`id` = 1
+----+-------------+-----------+-------+---------------+
| id | select_type | table     | type  | possible_keys |
+----+-------------+-----------+-------+---------------+
|  1 | SIMPLE      | customers | const | PRIMARY       |
+----+-------------+-----------+-------+---------------+
+---------+---------+-------+------+-------+
| key     | key_len | ref   | rows | Extra |
+---------+---------+-------+------+-------+
| PRIMARY | 4       | const |    1 |       |
+---------+---------+-------+------+-------+

1 row in set (0.00 sec)

EXPLAIN SELECT `orders`.* FROM `orders`  WHERE `orders`.`customer_id` IN (1)
+----+-------------+--------+------+---------------+
| id | select_type | table  | type | possible_keys |
+----+-------------+--------+------+---------------+
|  1 | SIMPLE      | orders | ALL  | NULL          |
+----+-------------+--------+------+---------------+
+------+---------+------+------+-------------+
| key  | key_len | ref  | rows | Extra       |
+------+---------+------+------+-------------+
| NULL | NULL    | NULL |    1 | Using where |
+------+---------+------+------+-------------+


1 row in set (0.00 sec)</pre> <button class="clipboard-button" data-clipboard-text="EXPLAIN SELECT `customers`.* FROM `customers`  WHERE `customers`.`id` = 1
+----+-------------+-----------+-------+---------------+
| id | select_type | table     | type  | possible_keys |
+----+-------------+-----------+-------+---------------+
|  1 | SIMPLE      | customers | const | PRIMARY       |
+----+-------------+-----------+-------+---------------+
+---------+---------+-------+------+-------+
| key     | key_len | ref   | rows | Extra |
+---------+---------+-------+------+-------+
| PRIMARY | 4       | const |    1 |       |
+---------+---------+-------+------+-------+

1 row in set (0.00 sec)

EXPLAIN SELECT `orders`.* FROM `orders`  WHERE `orders`.`customer_id` IN (1)
+----+-------------+--------+------+---------------+
| id | select_type | table  | type | possible_keys |
+----+-------------+--------+------+---------------+
|  1 | SIMPLE      | orders | ALL  | NULL          |
+----+-------------+--------+------+---------------+
+------+---------+------+------+-------------+
| key  | key_len | ref  | rows | Extra       |
+------+---------+------+------+-------------+
| NULL | NULL    | NULL |    1 | Using where |
+------+---------+------+------+-------------+


1 row in set (0.00 sec)
">Copy</button> </div> <p>and may yield this for PostgreSQL:</p>
<div class="interstitial code"> <pre data-language="sql">Customer Load (0.3ms)  SELECT "customers".* FROM "customers" WHERE "customers"."id" = $1  [["id", 1]]
  Order Load (0.3ms)  SELECT "orders".* FROM "orders" WHERE "orders"."customer_id" = $1  [["customer_id", 1]]
=&gt; EXPLAIN SELECT "customers".* FROM "customers" WHERE "customers"."id" = $1 [["id", 1]]
                                    QUERY PLAN
----------------------------------------------------------------------------------
 Index Scan using customers_pkey on customers  (cost=0.15..8.17 rows=1 width=164)
   Index Cond: (id = '1'::bigint)
(2 rows)</pre> <button class="clipboard-button" data-clipboard-text="  Customer Load (0.3ms)  SELECT &quot;customers&quot;.* FROM &quot;customers&quot; WHERE &quot;customers&quot;.&quot;id&quot; = $1  [[&quot;id&quot;, 1]]
  Order Load (0.3ms)  SELECT &quot;orders&quot;.* FROM &quot;orders&quot; WHERE &quot;orders&quot;.&quot;customer_id&quot; = $1  [[&quot;customer_id&quot;, 1]]
=&gt; EXPLAIN SELECT &quot;customers&quot;.* FROM &quot;customers&quot; WHERE &quot;customers&quot;.&quot;id&quot; = $1 [[&quot;id&quot;, 1]]
                                    QUERY PLAN
----------------------------------------------------------------------------------
 Index Scan using customers_pkey on customers  (cost=0.15..8.17 rows=1 width=164)
   Index Cond: (id = '1'::bigint)
(2 rows)
">Copy</button> </div> <h2 id="explain-options"><a class="anchorlink" href="#explain-options"><span>22.1</span> Explain Options</a></h2>
<p>For databases and adapters which support them (currently PostgreSQL, MySQL, and MariaDB), options can be passed to provide deeper analysis.</p>
<p>Using PostgreSQL, the following:</p>
<div class="interstitial code"> <pre data-language="ruby">Customer.where(id: 1).joins(:orders).explain(:analyze, :verbose)</pre> <button class="clipboard-button" data-clipboard-text="Customer.where(id: 1).joins(:orders).explain(:analyze, :verbose)
">Copy</button> </div> <p>yields:</p>
<div class="interstitial code"> <pre data-language="sql">EXPLAIN (ANALYZE, VERBOSE) SELECT "shop_accounts".* FROM "shop_accounts" INNER JOIN "customers" ON "customers"."id" = "shop_accounts"."customer_id" WHERE "shop_accounts"."id" = $1 [["id", 1]]
                                                                   QUERY PLAN
------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop  (cost=0.30..16.37 rows=1 width=24) (actual time=0.003..0.004 rows=0 loops=1)
   Output: shop_accounts.id, shop_accounts.customer_id, shop_accounts.customer_carrier_id
   Inner Unique: true
   -&gt;  Index Scan using shop_accounts_pkey on public.shop_accounts  (cost=0.15..8.17 rows=1 width=24) (actual time=0.003..0.003 rows=0 loops=1)
         Output: shop_accounts.id, shop_accounts.customer_id, shop_accounts.customer_carrier_id
         Index Cond: (shop_accounts.id = '1'::bigint)
   -&gt;  Index Only Scan using customers_pkey on public.customers  (cost=0.15..8.17 rows=1 width=8) (never executed)
         Output: customers.id
         Index Cond: (customers.id = shop_accounts.customer_id)
         Heap Fetches: 0
 Planning Time: 0.063 ms
 Execution Time: 0.011 ms
(12 rows)</pre> <button class="clipboard-button" data-clipboard-text="EXPLAIN (ANALYZE, VERBOSE) SELECT &quot;shop_accounts&quot;.* FROM &quot;shop_accounts&quot; INNER JOIN &quot;customers&quot; ON &quot;customers&quot;.&quot;id&quot; = &quot;shop_accounts&quot;.&quot;customer_id&quot; WHERE &quot;shop_accounts&quot;.&quot;id&quot; = $1 [[&quot;id&quot;, 1]]
                                                                   QUERY PLAN
------------------------------------------------------------------------------------------------------------------------------------------------
 Nested Loop  (cost=0.30..16.37 rows=1 width=24) (actual time=0.003..0.004 rows=0 loops=1)
   Output: shop_accounts.id, shop_accounts.customer_id, shop_accounts.customer_carrier_id
   Inner Unique: true
   -&gt;  Index Scan using shop_accounts_pkey on public.shop_accounts  (cost=0.15..8.17 rows=1 width=24) (actual time=0.003..0.003 rows=0 loops=1)
         Output: shop_accounts.id, shop_accounts.customer_id, shop_accounts.customer_carrier_id
         Index Cond: (shop_accounts.id = '1'::bigint)
   -&gt;  Index Only Scan using customers_pkey on public.customers  (cost=0.15..8.17 rows=1 width=8) (never executed)
         Output: customers.id
         Index Cond: (customers.id = shop_accounts.customer_id)
         Heap Fetches: 0
 Planning Time: 0.063 ms
 Execution Time: 0.011 ms
(12 rows)
">Copy</button> </div> <p>Using MySQL or MariaDB, the following:</p>
<div class="interstitial code"> <pre data-language="ruby">Customer.where(id: 1).joins(:orders).explain(:analyze)</pre> <button class="clipboard-button" data-clipboard-text="Customer.where(id: 1).joins(:orders).explain(:analyze)
">Copy</button> </div> <p>yields:</p>
<div class="interstitial code"> <pre data-language="sql">ANALYZE SELECT `shop_accounts`.* FROM `shop_accounts` INNER JOIN `customers` ON `customers`.`id` = `shop_accounts`.`customer_id` WHERE `shop_accounts`.`id` = 1
+----+-------------+-------+------+---------------+------+---------+------+------+--------+----------+------------+--------------------------------+
| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | r_rows | filtered | r_filtered | Extra                          |
+----+-------------+-------+------+---------------+------+---------+------+------+--------+----------+------------+--------------------------------+
|  1 | SIMPLE      | NULL  | NULL | NULL          | NULL | NULL    | NULL | NULL | NULL   | NULL     | NULL       | no matching row in const table |
+----+-------------+-------+------+---------------+------+---------+------+------+--------+----------+------------+--------------------------------+
1 row in set (0.00 sec)</pre> <button class="clipboard-button" data-clipboard-text="ANALYZE SELECT `shop_accounts`.* FROM `shop_accounts` INNER JOIN `customers` ON `customers`.`id` = `shop_accounts`.`customer_id` WHERE `shop_accounts`.`id` = 1
+----+-------------+-------+------+---------------+------+---------+------+------+--------+----------+------------+--------------------------------+
| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | r_rows | filtered | r_filtered | Extra                          |
+----+-------------+-------+------+---------------+------+---------+------+------+--------+----------+------------+--------------------------------+
|  1 | SIMPLE      | NULL  | NULL | NULL          | NULL | NULL    | NULL | NULL | NULL   | NULL     | NULL       | no matching row in const table |
+----+-------------+-------+------+---------------+------+---------+------+------+--------+----------+------------+--------------------------------+
1 row in set (0.00 sec)
">Copy</button> </div> <div class="interstitial note"><p>EXPLAIN and ANALYZE options vary across MySQL and MariaDB versions. (<a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html">MySQL 5.7</a>, <a href="https://dev.mysql.com/doc/refman/8.0/en/explain.html">MySQL 8.0</a>, <a href="https://mariadb.com/kb/en/analyze-and-explain-statements/">MariaDB</a>)</p></div>
<h2 id="interpreting-explain"><a class="anchorlink" href="#interpreting-explain"><span>22.2</span> Interpreting EXPLAIN</a></h2>
<p>Interpretation of the output of EXPLAIN is beyond the scope of this guide. The following pointers may be helpful:</p> <ul> <li><p>SQLite3: <a href="https://www.sqlite.org/eqp.html">EXPLAIN QUERY PLAN</a></p></li> <li><p>MySQL: <a href="https://dev.mysql.com/doc/refman/en/explain-output.html">EXPLAIN Output Format</a></p></li> <li><p>MariaDB: <a href="https://mariadb.com/kb/en/mariadb/explain/">EXPLAIN</a></p></li> <li><p>PostgreSQL: <a href="https://www.postgresql.org/docs/current/static/using-explain.html">Using EXPLAIN</a></p></li> </ul> <hr> <h2>Feedback</h2> <p> You're encouraged to help improve the quality of this guide. </p> <p> Please contribute if you see any typos or factual errors. To get started, you can read our <a href="https://edgeguides.rubyonrails.org/contributing_to_ruby_on_rails.html#contributing-to-the-rails-documentation">documentation contributions</a> section. </p> <p> You may also find incomplete content or stuff that is not up to date. Please do add any missing documentation for main. Make sure to check <a href="https://edgeguides.rubyonrails.org">Edge Guides</a> first to verify if the issues are already fixed or not on the main branch. Check the <span>Ruby on Rails Guides Guidelines</span> for style and conventions. </p> <p> If for whatever reason you spot something to fix but cannot patch it yourself, please <a href="https://github.com/rails/rails/issues">open an issue</a>. </p> <p>And last but not least, any kind of discussion regarding Ruby on Rails documentation is very welcome on the <a href="https://discuss.rubyonrails.org/c/rubyonrails-docs">official Ruby on Rails Forum</a>. </p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2004&ndash;2021 David Heinemeier Hansson<br>Licensed under the Creative Commons Attribution-ShareAlike 4.0 International License.<br>
    
  </p>
</div>
