<h1>Active Record Migrations</h1>
<div class="_simple"> <p>Migrations are a feature of Active Record that allows you to evolve your database schema over time. Rather than write schema modifications in pure SQL, migrations allow you to use a Ruby Domain Specific Language (DSL) to describe changes to your tables.</p>
<p>After reading this guide, you will know:</p> <ul> <li>Which generators you can use to create migrations.</li> <li>Which methods Active Record provides to manipulate your database.</li> <li>How to change existing migrations and update your schema.</li> <li>How migrations relate to <code>schema.rb</code>.</li> <li>How to maintain referential integrity.</li> </ul>  <h2 class="chapter">  Chapters </h2> <ol class="chapters"> <li><a href="#migration-overview">Migration Overview</a></li> <li>
<a href="#generating-migration-files">Generating Migration Files</a> <ul> <li><a href="#creating-a-standalone-migration">Creating a Standalone Migration</a></li> <li><a href="#creating-a-new-table">Creating a New Table</a></li> <li><a href="#adding-columns">Adding Columns</a></li> <li><a href="#removing-columns">Removing Columns</a></li> <li><a href="#creating-associations">Creating Associations</a></li> <li><a href="#other-generators-that-create-migrations">Other Generators that Create Migrations</a></li> <li><a href="#passing-modifiers">Passing Modifiers</a></li> </ul>
</li> <li>
<a href="#updating-migrations">Updating Migrations</a> <ul> <li><a href="#creating-a-table">Creating a Table</a></li> <li><a href="#creating-a-join-table">Creating a Join Table</a></li> <li><a href="#changing-tables">Changing Tables</a></li> <li><a href="#changing-columns">Changing Columns</a></li> <li><a href="#column-modifiers">Column Modifiers</a></li> <li><a href="#references">References</a></li> <li><a href="#foreign-keys">Foreign Keys</a></li> <li><a href="#composite-primary-keys">Composite Primary Keys</a></li> <li><a href="#execute-sql">Execute SQL</a></li> <li><a href="#using-the-change-method">Using the <code>change</code> Method</a></li> <li><a href="#using-reversible">Using <code>reversible</code></a></li> <li><a href="#using-the-up-down-methods">Using the <code>up</code>/<code>down</code> Methods</a></li> <li><a href="#throwing-an-error-to-prevent-reverts">Throwing an error to prevent reverts</a></li> <li><a href="#reverting-previous-migrations">Reverting Previous Migrations</a></li> </ul>
</li> <li>
<a href="#running-migrations">Running Migrations</a> <ul> <li><a href="#rolling-back">Rolling Back</a></li> <li><a href="#setting-up-the-database">Setting Up the Database</a></li> <li><a href="#preparing-the-database">Preparing the Database</a></li> <li><a href="#resetting-the-database">Resetting the Database</a></li> <li><a href="#running-specific-migrations">Running Specific Migrations</a></li> <li><a href="#running-migrations-in-different-environments">Running Migrations in Different Environments</a></li> <li><a href="#changing-the-output-of-running-migrations">Changing the Output of Running Migrations</a></li> <li><a href="#rails-migration-version-control">Rails Migration Version Control</a></li> </ul>
</li> <li><a href="#changing-existing-migrations">Changing Existing Migrations</a></li> <li>
<a href="#schema-dumping-and-you">Schema Dumping and You</a> <ul> <li><a href="#what-are-schema-files-for-questionmark">What are Schema Files for?</a></li> <li><a href="#types-of-schema-dumps">Types of Schema Dumps</a></li> <li><a href="#schema-dumps-and-source-control">Schema Dumps and Source Control</a></li> </ul>
</li> <li><a href="#active-record-and-referential-integrity">Active Record and Referential Integrity</a></li> <li><a href="#migrations-and-seed-data">Migrations and Seed Data</a></li> <li>
<a href="#old-migrations">Old Migrations</a> <ul> <li><a href="#migrations-from-engines">Migrations from Engines</a></li> </ul>
</li> <li>
<a href="#miscellaneous">Miscellaneous</a> <ul> <li><a href="#using-uuids-instead-of-ids-for-primary-keys">Using UUIDs instead of IDs for Primary Keys</a></li> <li><a href="#data-migrations">Data Migrations</a></li> </ul>
</li> </ol>  <hr>  <h1 id="migration-overview"><a class="anchorlink" href="#migration-overview"><span>1</span> Migration Overview</a></h1>
<p>Migrations are a convenient way to <a href="https://en.wikipedia.org/wiki/Schema_migration">evolve your database schema over time</a> in a reproducible way. They use a Ruby <a href="https://en.wikipedia.org/wiki/Domain-specific_language">DSL</a> so that you don't have to write <a href="https://en.wikipedia.org/wiki/SQL">SQL</a> by hand, allowing your schema and changes to be database independent. We recommend that you read the guides for <a href="active_record_basics.html">Active Record Basics</a> and the <a href="association_basics.html">Active Record Associations</a> to learn more about some of the concepts mentioned here.</p>
<p>You can think of each migration as being a new 'version' of the database. A schema starts off with nothing in it, and each migration modifies it to add or remove tables, columns, or indexes. Active Record knows how to update your schema along this timeline, bringing it from whatever point it is in the history to the latest version. Read more about <a href="#rails-migration-version-control">how Rails knows which migration in the timeline to run</a>.</p>
<p>Active Record updates your <code>db/schema.rb</code> file to match the up-to-date structure of your database. Here's an example of a migration:</p>
<div class="interstitial code"> <pre data-language="ruby"># db/migrate/20240502100843_create_products.rb
class CreateProducts &lt; ActiveRecord::Migration[7.2]
  def change
    create_table :products do |t|
      t.string :name
      t.text :description

      t.timestamps
    end
  end
end</pre> <button class="clipboard-button" data-clipboard-text="class CreateProducts &lt; ActiveRecord::Migration[7.2]
  def change
    create_table :products do |t|
      t.string :name
      t.text :description

      t.timestamps
    end
  end
end
">Copy</button> </div> <p>This migration adds a table called <code>products</code> with a string column called <code>name</code> and a text column called <code>description</code>. A primary key column called <code>id</code> will also be added implicitly, as it's the default primary key for all Active Record models. The <code>timestamps</code> macro adds two columns, <code>created_at</code> and <code>updated_at</code>. These special columns are automatically managed by Active Record if they exist.</p>
<div class="interstitial code"> <pre data-language="ruby"># db/schema.rb
ActiveRecord::Schema[7.2].define(version: 2024_05_02_100843) do
  # These are extensions that must be enabled in order to support this database
  enable_extension "plpgsql"

  create_table "products", force: :cascade do |t|
    t.string "name"
    t.text "description"
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
  end
end</pre> <button class="clipboard-button" data-clipboard-text='ActiveRecord::Schema[7.2].define(version: 2024_05_02_100843) do
  # These are extensions that must be enabled in order to support this database
  enable_extension "plpgsql"

  create_table "products", force: :cascade do |t|
    t.string "name"
    t.text "description"
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
  end
end
'>Copy</button> </div> <p>We define the change that we want to happen moving forward in time. Before this migration is run, there will be no table. After it is run, the table will exist. Active Record knows how to reverse this migration as well; if we roll this migration back, it will remove the table. Read more about rolling back migrations in the <a href="#rolling-back">Rolling Back section</a>.</p>
<p>After defining the change that we want to occur moving forward in time, it's essential to consider the reversibility of the migration. While Active Record can manage the forward progression of the migration, ensuring the creation of the table, the concept of reversibility becomes crucial. With reversible migrations, not only does the migration create the table when applied, but it also enables smooth rollback functionality. In case of reverting the migration above, Active Record intelligently handles the removal of the table, maintaining database consistency throughout the process. See the <a href="#using-reversible">Reversing Migrations section</a> for more details.</p>
<h1 id="generating-migration-files"><a class="anchorlink" href="#generating-migration-files"><span>2</span> Generating Migration Files</a></h1>
<h2 id="creating-a-standalone-migration"><a class="anchorlink" href="#creating-a-standalone-migration"><span>2.1</span> Creating a Standalone Migration</a></h2>
<p>Migrations are stored as files in the <code>db/migrate</code> directory, one for each migration class.</p>
<p>The name of the file is of the form <code>YYYYMMDDHHMMSS_create_products.rb</code>, it contains a UTC timestamp identifying the migration followed by an underscore followed by the name of the migration. The name of the migration class (CamelCased version) should match the latter part of the file name.</p>
<p>For example, <code>20240502100843_create_products.rb</code> should define class <code>CreateProducts</code> and <code>20240502101659_add_details_to_products.rb</code> should define class <code>AddDetailsToProducts</code>. Rails uses this timestamp to determine which migration should be run and in what order, so if you're copying a migration from another application or generating a file yourself, be aware of its position in the order. You can read more about how the timestamps are used in the <a href="#rails-migration-version-control">Rails Migration Version Control section</a>.</p>
<p>When generating a migration, Active Record automatically prepends the current timestamp to the file name of the migration. For example, running the command below will create an empty migration file whereby the filename is made up of a timestamp prepended to the underscored name of the migration.</p>
<div class="interstitial code"> <pre data-language="console">$ bin/rails generate migration AddPartNumberToProducts</pre> <button class="clipboard-button" data-clipboard-text="bin/rails generate migration AddPartNumberToProducts
">Copy</button> </div> <div class="interstitial code"> <pre data-language="ruby"># db/migrate/20240502101659_add_part_number_to_products.rb
class AddPartNumberToProducts &lt; ActiveRecord::Migration[7.2]
  def change
  end
end</pre> <button class="clipboard-button" data-clipboard-text="class AddPartNumberToProducts &lt; ActiveRecord::Migration[7.2]
  def change
  end
end
">Copy</button> </div> <p>The generator can do much more than prepend a timestamp to the file name. Based on naming conventions and additional (optional) arguments it can also start fleshing out the migration.</p>
<p>The following sections will cover the various ways you can create migrations based on conventions and additional arguments.</p>
<h2 id="creating-a-new-table"><a class="anchorlink" href="#creating-a-new-table"><span>2.2</span> Creating a New Table</a></h2>
<p>When you want to create a new table in your database, you can use a migration with the format "CreateXXX" followed by a list of column names and types. This will generate a migration file that sets up the table with the specified columns.</p>
<div class="interstitial code"> <pre data-language="console">$ bin/rails generate migration CreateProducts name:string part_number:string</pre> <button class="clipboard-button" data-clipboard-text="bin/rails generate migration CreateProducts name:string part_number:string
">Copy</button> </div> <p>generates</p>
<div class="interstitial code"> <pre data-language="ruby">class CreateProducts &lt; ActiveRecord::Migration[7.2]
  def change
    create_table :products do |t|
      t.string :name
      t.string :part_number

      t.timestamps
    end
  end
end</pre> <button class="clipboard-button" data-clipboard-text="class CreateProducts &lt; ActiveRecord::Migration[7.2]
  def change
    create_table :products do |t|
      t.string :name
      t.string :part_number

      t.timestamps
    end
  end
end
">Copy</button> </div> <p>The generated file with its contents is just a starting point, and you can add or remove from it as you see fit by editing the <code>db/migrate/YYYYMMDDHHMMSS_create_products.rb</code> file.</p>
<h2 id="adding-columns"><a class="anchorlink" href="#adding-columns"><span>2.3</span> Adding Columns</a></h2>
<p>When you want to add a new column to an existing table in your database, you can use a migration with the format "AddColumnToTable" followed by a list of column names and types. This will generate a migration file containing the appropriate <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html#method-i-add_column"><code>add_column</code></a> statements.</p>
<div class="interstitial code"> <pre data-language="console">$ bin/rails generate migration AddPartNumberToProducts part_number:string</pre> <button class="clipboard-button" data-clipboard-text="bin/rails generate migration AddPartNumberToProducts part_number:string
">Copy</button> </div> <p>This will generate the following migration:</p>
<div class="interstitial code"> <pre data-language="ruby">class AddPartNumberToProducts &lt; ActiveRecord::Migration[7.2]
  def change
    add_column :products, :part_number, :string
  end
end</pre> <button class="clipboard-button" data-clipboard-text="class AddPartNumberToProducts &lt; ActiveRecord::Migration[7.2]
  def change
    add_column :products, :part_number, :string
  end
end
">Copy</button> </div> <p>If you'd like to add an index on the new column, you can do that as well.</p>
<div class="interstitial code"> <pre data-language="console">$ bin/rails generate migration AddPartNumberToProducts part_number:string:index</pre> <button class="clipboard-button" data-clipboard-text="bin/rails generate migration AddPartNumberToProducts part_number:string:index
">Copy</button> </div> <p>This will generate the appropriate <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html#method-i-add_column"><code>add_column</code></a> and <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html#method-i-add_index"><code>add_index</code></a> statements:</p>
<div class="interstitial code"> <pre data-language="ruby">class AddPartNumberToProducts &lt; ActiveRecord::Migration[7.2]
  def change
    add_column :products, :part_number, :string
    add_index :products, :part_number
  end
end</pre> <button class="clipboard-button" data-clipboard-text="class AddPartNumberToProducts &lt; ActiveRecord::Migration[7.2]
  def change
    add_column :products, :part_number, :string
    add_index :products, :part_number
  end
end
">Copy</button> </div> <p>You are <strong>not</strong> limited to one magically generated column. For example:</p>
<div class="interstitial code"> <pre data-language="console">$ bin/rails generate migration AddDetailsToProducts part_number:string price:decimal</pre> <button class="clipboard-button" data-clipboard-text="bin/rails generate migration AddDetailsToProducts part_number:string price:decimal
">Copy</button> </div> <p>This will generate a schema migration which adds two additional columns to the <code>products</code> table.</p>
<div class="interstitial code"> <pre data-language="ruby">class AddDetailsToProducts &lt; ActiveRecord::Migration[7.2]
  def change
    add_column :products, :part_number, :string
    add_column :products, :price, :decimal
  end
end</pre> <button class="clipboard-button" data-clipboard-text="class AddDetailsToProducts &lt; ActiveRecord::Migration[7.2]
  def change
    add_column :products, :part_number, :string
    add_column :products, :price, :decimal
  end
end
">Copy</button> </div> <h2 id="removing-columns"><a class="anchorlink" href="#removing-columns"><span>2.4</span> Removing Columns</a></h2>
<p>Similarly, if the migration name is of the form "RemoveColumnFromTable" and is followed by a list of column names and types then a migration containing the appropriate <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html#method-i-remove_column"><code>remove_column</code></a> statements will be created.</p>
<div class="interstitial code"> <pre data-language="console">$ bin/rails generate migration RemovePartNumberFromProducts part_number:string</pre> <button class="clipboard-button" data-clipboard-text="bin/rails generate migration RemovePartNumberFromProducts part_number:string
">Copy</button> </div> <p>This will generate the appropriate <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html#method-i-remove_column"><code>remove_column</code></a> statements:</p>
<div class="interstitial code"> <pre data-language="ruby">class RemovePartNumberFromProducts &lt; ActiveRecord::Migration[7.2]
  def change
    remove_column :products, :part_number, :string
  end
end</pre> <button class="clipboard-button" data-clipboard-text="class RemovePartNumberFromProducts &lt; ActiveRecord::Migration[7.2]
  def change
    remove_column :products, :part_number, :string
  end
end
">Copy</button> </div> <h2 id="creating-associations"><a class="anchorlink" href="#creating-associations"><span>2.5</span> Creating Associations</a></h2>
<p>Active Record associations are used to define relationships between different models in your application, allowing them to interact with each other through their relationships and making it easier to work with related data. To learn more about associations, you can refer to the <a href="association_basics.html">Association Basics guide</a>.</p>
<p>One common use case for associations is creating foreign key references between tables. The generator accepts column types such as <code>references</code> to facilitate this process. <a href="#references">References</a> are a shorthand for creating columns, indexes, foreign keys, or even polymorphic association columns.</p>
<p>For example,</p>
<div class="interstitial code"> <pre data-language="console">$ bin/rails generate migration AddUserRefToProducts user:references</pre> <button class="clipboard-button" data-clipboard-text="bin/rails generate migration AddUserRefToProducts user:references
">Copy</button> </div> <p>generates the following <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html#method-i-add_reference"><code>add_reference</code></a> call:</p>
<div class="interstitial code"> <pre data-language="ruby">class AddUserRefToProducts &lt; ActiveRecord::Migration[7.2]
  def change
    add_reference :products, :user, null: false, foreign_key: true
  end
end</pre> <button class="clipboard-button" data-clipboard-text="class AddUserRefToProducts &lt; ActiveRecord::Migration[7.2]
  def change
    add_reference :products, :user, null: false, foreign_key: true
  end
end
">Copy</button> </div> <p>The above migration creates a foreign key called <code>user_id</code> in the <code>products</code> table, where <code>user_id</code> is a reference to the <code>id</code> column in the <code>users</code> table. It also creates an index for the <code>user_id</code> column. The schema looks as follows:</p>
<div class="interstitial code"> <pre data-language="ruby">create_table "products", force: :cascade do |t|
    t.bigint "user_id", null: false
    t.index ["user_id"], name: "index_products_on_user_id"
  end</pre> <button class="clipboard-button" data-clipboard-text='  create_table "products", force: :cascade do |t|
    t.bigint "user_id", null: false
    t.index ["user_id"], name: "index_products_on_user_id"
  end
'>Copy</button> </div> <p><code>belongs_to</code> is an alias of <code>references</code>, so the above could be alternatively written as:</p>
<div class="interstitial code"> <pre data-language="console">$ bin/rails generate migration AddUserRefToProducts user:belongs_to</pre> <button class="clipboard-button" data-clipboard-text="bin/rails generate migration AddUserRefToProducts user:belongs_to
">Copy</button> </div> <p>generating a migration and schema that is the same as above.</p>
<p>There is also a generator which will produce join tables if <code>JoinTable</code> is part of the name:</p>
<div class="interstitial code"> <pre data-language="console">$ bin/rails generate migration CreateJoinTableUserProduct user product</pre> <button class="clipboard-button" data-clipboard-text="bin/rails generate migration CreateJoinTableUserProduct user product
">Copy</button> </div> <p>will produce the following migration:</p>
<div class="interstitial code"> <pre data-language="ruby">class CreateJoinTableUserProduct &lt; ActiveRecord::Migration[7.2]
  def change
    create_join_table :users, :products do |t|
      # t.index [:user_id, :product_id]
      # t.index [:product_id, :user_id]
    end
  end
end</pre> <button class="clipboard-button" data-clipboard-text="class CreateJoinTableUserProduct &lt; ActiveRecord::Migration[7.2]
  def change
    create_join_table :users, :products do |t|
      # t.index [:user_id, :product_id]
      # t.index [:product_id, :user_id]
    end
  end
end
">Copy</button> </div> <h2 id="other-generators-that-create-migrations"><a class="anchorlink" href="#other-generators-that-create-migrations"><span>2.6</span> Other Generators that Create Migrations</a></h2>
<p>In addition to the <code>migration</code> generator, the <code>model</code>, <code>resource</code>, and <code>scaffold</code> generators will create migrations appropriate for adding a new model. This migration will already contain instructions for creating the relevant table. If you tell Rails what columns you want, then statements for adding these columns will also be created. For example, running:</p>
<div class="interstitial code"> <pre data-language="console">$ bin/rails generate model Product name:string description:text</pre> <button class="clipboard-button" data-clipboard-text="bin/rails generate model Product name:string description:text
">Copy</button> </div> <p>This will create a migration that looks like this:</p>
<div class="interstitial code"> <pre data-language="ruby">class CreateProducts &lt; ActiveRecord::Migration[7.2]
  def change
    create_table :products do |t|
      t.string :name
      t.text :description

      t.timestamps
    end
  end
end</pre> <button class="clipboard-button" data-clipboard-text="class CreateProducts &lt; ActiveRecord::Migration[7.2]
  def change
    create_table :products do |t|
      t.string :name
      t.text :description

      t.timestamps
    end
  end
end
">Copy</button> </div> <p>You can append as many column name/type pairs as you want.</p>
<h2 id="passing-modifiers"><a class="anchorlink" href="#passing-modifiers"><span>2.7</span> Passing Modifiers</a></h2>
<p>When generating migrations, you can pass commonly used <a href="#column-modifiers">type modifiers</a> directly on the command line. These modifiers, enclosed by curly braces and following the field type, allow you to tailor the characteristics of your database columns without needing to manually edit the migration file afterward.</p>
<p>For instance, running:</p>
<div class="interstitial code"> <pre data-language="console">$ bin/rails generate migration AddDetailsToProducts 'price:decimal{5,2}' supplier:references{polymorphic}</pre> <button class="clipboard-button" data-clipboard-text="bin/rails generate migration AddDetailsToProducts 'price:decimal{5,2}' supplier:references{polymorphic}
">Copy</button> </div> <p>will produce a migration that looks like this</p>
<div class="interstitial code"> <pre data-language="ruby">class AddDetailsToProducts &lt; ActiveRecord::Migration[7.2]
  def change
    add_column :products, :price, :decimal, precision: 5, scale: 2
    add_reference :products, :supplier, polymorphic: true
  end
end</pre> <button class="clipboard-button" data-clipboard-text="class AddDetailsToProducts &lt; ActiveRecord::Migration[7.2]
  def change
    add_column :products, :price, :decimal, precision: 5, scale: 2
    add_reference :products, :supplier, polymorphic: true
  end
end
">Copy</button> </div> <div class="interstitial info"><p>For further help with generators, run <code>bin/rails generate --help</code>. Alternatively, you can also run <code>bin/rails generate model --help</code> or <code>bin/rails
generate migration --help</code> for help with specific generators.</p></div>
<h1 id="updating-migrations"><a class="anchorlink" href="#updating-migrations"><span>3</span> Updating Migrations</a></h1>
<p>Once you have created your migration file using one of the generators from the above <a href="#generating-migration-files">section</a>, you can update the generated migration file in the <code>db/migrate</code> folder to define further changes you want to make to your database schema.</p>
<h2 id="creating-a-table"><a class="anchorlink" href="#creating-a-table"><span>3.1</span> Creating a Table</a></h2>
<p>The <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html#method-i-create_table"><code>create_table</code></a> method is one of the most fundamental migration type, but most of the time, will be generated for you from using a model, resource, or scaffold generator. A typical use would be</p>
<div class="interstitial code"> <pre data-language="ruby">create_table :products do |t|
  t.string :name
end</pre> <button class="clipboard-button" data-clipboard-text="create_table :products do |t|
  t.string :name
end
">Copy</button> </div> <p>This method creates a <code>products</code> table with a column called <code>name</code>.</p>
<h3 id="associations"><a class="anchorlink" href="#associations"><span>3.1.1</span> Associations</a></h3>
<p>If you're creating a table for a model that has an association, you can use the <code>:references</code> type to create the appropriate column type. For example:</p>
<div class="interstitial code"> <pre data-language="ruby">create_table :products do |t|
  t.references :category
end</pre> <button class="clipboard-button" data-clipboard-text="create_table :products do |t|
  t.references :category
end
">Copy</button> </div> <p>This will create a <code>category_id</code> column. Alternatively, you can use <code>belongs_to</code> as an alias for <code>references</code>:</p>
<div class="interstitial code"> <pre data-language="ruby">create_table :products do |t|
  t.belongs_to :category
end</pre> <button class="clipboard-button" data-clipboard-text="create_table :products do |t|
  t.belongs_to :category
end
">Copy</button> </div> <p>You can also specify the column type and index creation using the <a href="association_basics.html#polymorphic-associations"><code>:polymorphic</code></a> option:</p>
<div class="interstitial code"> <pre data-language="ruby">create_table :taggings do |t|
  t.references :taggable, polymorphic: true
end</pre> <button class="clipboard-button" data-clipboard-text="create_table :taggings do |t|
  t.references :taggable, polymorphic: true
end
">Copy</button> </div> <p>This will create <code>taggable_id</code>, <code>taggable_type</code> columns and the appropriate indexes.</p>
<h3 id="primary-keys"><a class="anchorlink" href="#primary-keys"><span>3.1.2</span> Primary Keys</a></h3>
<p>By default, <code>create_table</code> will implicitly create a primary key called <code>id</code> for you. You can change the name of the column with the <code>:primary_key</code> option, like below:</p>
<div class="interstitial code"> <pre data-language="ruby">class CreateUsers &lt; ActiveRecord::Migration[7.2]
  def change
    create_table :users, primary_key: "user_id" do |t|
      t.string :username
      t.string :email
      t.timestamps
    end
  end
end</pre> <button class="clipboard-button" data-clipboard-text='class CreateUsers &lt; ActiveRecord::Migration[7.2]
  def change
    create_table :users, primary_key: "user_id" do |t|
      t.string :username
      t.string :email
      t.timestamps
    end
  end
end
'>Copy</button> </div> <p>This will yield the following schema:</p>
<div class="interstitial code"> <pre data-language="ruby">create_table "users", primary_key: "user_id", force: :cascade do |t|
  t.string "username"
  t.string "email"
  t.datetime "created_at", precision: 6, null: false
  t.datetime "updated_at", precision: 6, null: false
end</pre> <button class="clipboard-button" data-clipboard-text='create_table "users", primary_key: "user_id", force: :cascade do |t|
  t.string "username"
  t.string "email"
  t.datetime "created_at", precision: 6, null: false
  t.datetime "updated_at", precision: 6, null: false
end
'>Copy</button> </div> <p>You can also pass an array to <code>:primary_key</code> for a composite primary key. Read more about <a href="active_record_composite_primary_keys.html">composite primary keys</a>.</p>
<div class="interstitial code"> <pre data-language="ruby">class CreateUsers &lt; ActiveRecord::Migration[7.2]
  def change
    create_table :users, primary_key: [:id, :name] do |t|
      t.string :name
      t.string :email
      t.timestamps
    end
  end
end</pre> <button class="clipboard-button" data-clipboard-text="class CreateUsers &lt; ActiveRecord::Migration[7.2]
  def change
    create_table :users, primary_key: [:id, :name] do |t|
      t.string :name
      t.string :email
      t.timestamps
    end
  end
end
">Copy</button> </div> <p>If you don't want a primary key at all, you can pass the option <code>id: false</code>.</p>
<div class="interstitial code"> <pre data-language="ruby">class CreateUsers &lt; ActiveRecord::Migration[7.2]
  def change
    create_table :users, id: false do |t|
      t.string :username
      t.string :email
      t.timestamps
    end
  end
end</pre> <button class="clipboard-button" data-clipboard-text="class CreateUsers &lt; ActiveRecord::Migration[7.2]
  def change
    create_table :users, id: false do |t|
      t.string :username
      t.string :email
      t.timestamps
    end
  end
end
">Copy</button> </div> <h3 id="database-options"><a class="anchorlink" href="#database-options"><span>3.1.3</span> Database Options</a></h3>
<p>If you need to pass database-specific options you can place an SQL fragment in the <code>:options</code> option. For example:</p>
<div class="interstitial code"> <pre data-language="ruby">create_table :products, options: "ENGINE=BLACKHOLE" do |t|
  t.string :name, null: false
end</pre> <button class="clipboard-button" data-clipboard-text='create_table :products, options: "ENGINE=BLACKHOLE" do |t|
  t.string :name, null: false
end
'>Copy</button> </div> <p>This will append <code>ENGINE=BLACKHOLE</code> to the SQL statement used to create the table.</p>
<p>An index can be created on the columns created within the <code>create_table</code> block by passing <code>index: true</code> or an options hash to the <code>:index</code> option:</p>
<div class="interstitial code"> <pre data-language="ruby">create_table :users do |t|
  t.string :name, index: true
  t.string :email, index: { unique: true, name: 'unique_emails' }
end</pre> <button class="clipboard-button" data-clipboard-text="create_table :users do |t|
  t.string :name, index: true
  t.string :email, index: { unique: true, name: 'unique_emails' }
end
">Copy</button> </div> <h3 id="comments"><a class="anchorlink" href="#comments"><span>3.1.4</span> Comments</a></h3>
<p>You can pass the <code>:comment</code> option with any description for the table that will be stored in the database itself and can be viewed with database administration tools, such as MySQL Workbench or PgAdmin III. Comments can help team members to better understand the data model and to generate documentation in applications with large databases. Currently only the MySQL and PostgreSQL adapters support comments.</p>
<div class="interstitial code"> <pre data-language="ruby">class AddDetailsToProducts &lt; ActiveRecord::Migration[7.2]
  def change
    add_column :products, :price, :decimal, precision: 8, scale: 2, comment: "The price of the product in USD"
    add_column :products, :stock_quantity, :integer, comment: "The current stock quantity of the product"
  end
end</pre> <button class="clipboard-button" data-clipboard-text='class AddDetailsToProducts &lt; ActiveRecord::Migration[7.2]
  def change
    add_column :products, :price, :decimal, precision: 8, scale: 2, comment: "The price of the product in USD"
    add_column :products, :stock_quantity, :integer, comment: "The current stock quantity of the product"
  end
end
'>Copy</button> </div> <h2 id="creating-a-join-table"><a class="anchorlink" href="#creating-a-join-table"><span>3.2</span> Creating a Join Table</a></h2>
<p>The migration method <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html#method-i-create_join_table"><code>create_join_table</code></a> creates an <a href="association_basics.html#the-has-and-belongs-to-many-association">HABTM (has and belongs to many)</a> join table. A typical use would be:</p>
<div class="interstitial code"> <pre data-language="ruby">create_join_table :products, :categories</pre> <button class="clipboard-button" data-clipboard-text="create_join_table :products, :categories
">Copy</button> </div> <p>This migration will create a <code>categories_products</code> table with two columns called <code>category_id</code> and <code>product_id</code>.</p>
<p>These columns have the option <code>:null</code> set to <code>false</code> by default, meaning that you <strong>must</strong> provide a value in order to save a record to this table. This can be overridden by specifying the <code>:column_options</code> option:</p>
<div class="interstitial code"> <pre data-language="ruby">create_join_table :products, :categories, column_options: { null: true }</pre> <button class="clipboard-button" data-clipboard-text="create_join_table :products, :categories, column_options: { null: true }
">Copy</button> </div> <p>By default, the name of the join table comes from the union of the first two arguments provided to create_join_table, in alphabetical order. In this case, the table would be named <code>categories_products</code>.</p>
<p>To customize the name of the table, provide a <code>:table_name</code> option:</p>
<div class="interstitial code"> <pre data-language="ruby">create_join_table :products, :categories, table_name: :categorization</pre> <button class="clipboard-button" data-clipboard-text="create_join_table :products, :categories, table_name: :categorization
">Copy</button> </div> <p>This creates a join table with the name <code>categorization</code>.</p>
<p>Also, <code>create_join_table</code> accepts a block, which you can use to add indices (which are not created by default) or any additional columns you so choose.</p>
<div class="interstitial code"> <pre data-language="ruby">create_join_table :products, :categories do |t|
  t.index :product_id
  t.index :category_id
end</pre> <button class="clipboard-button" data-clipboard-text="create_join_table :products, :categories do |t|
  t.index :product_id
  t.index :category_id
end
">Copy</button> </div> <h2 id="changing-tables"><a class="anchorlink" href="#changing-tables"><span>3.3</span> Changing Tables</a></h2>
<p>If you want to change an existing table in place, there is <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html#method-i-change_table"><code>change_table</code></a>.</p>
<p>It is used in a similar fashion to <code>create_table</code> but the object yielded inside the block has access to a number of special functions, for example:</p>
<div class="interstitial code"> <pre data-language="ruby">change_table :products do |t|
  t.remove :description, :name
  t.string :part_number
  t.index :part_number
  t.rename :upccode, :upc_code
end</pre> <button class="clipboard-button" data-clipboard-text="change_table :products do |t|
  t.remove :description, :name
  t.string :part_number
  t.index :part_number
  t.rename :upccode, :upc_code
end
">Copy</button> </div> <p>This migration will remove the <code>description</code> and <code>name</code> columns, create a new string column called <code>part_number</code> and add an index on it. Finally, it renames the <code>upccode</code> column to <code>upc_code</code>.</p>
<h2 id="changing-columns"><a class="anchorlink" href="#changing-columns"><span>3.4</span> Changing Columns</a></h2>
<p>Similar to the <code>remove_column</code> and <code>add_column</code> methods we covered <a href="#adding-columns">earlier</a>, Rails also provides the <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html#method-i-change_column"><code>change_column</code></a> migration method.</p>
<div class="interstitial code"> <pre data-language="ruby">change_column :products, :part_number, :text</pre> <button class="clipboard-button" data-clipboard-text="change_column :products, :part_number, :text
">Copy</button> </div> <p>This changes the column <code>part_number</code> on products table to be a <code>:text</code> field.</p>
<div class="interstitial note"><p>The <code>change_column</code> command is <strong>irreversible</strong>. To ensure your migration can be safely reverted, you will need to provide your own <code>reversible</code> migration. See the <a href="#using-reversible">Reversible Migrations section</a> for more details.</p></div>
<p>Besides <code>change_column</code>, the <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html#method-i-change_column_null"><code>change_column_null</code></a> and <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html#method-i-change_column_default"><code>change_column_default</code></a> methods are used to change a null constraint and default values of a column.</p>
<div class="interstitial code"> <pre data-language="ruby">change_column_default :products, :approved, from: true, to: false</pre> <button class="clipboard-button" data-clipboard-text="change_column_default :products, :approved, from: true, to: false
">Copy</button> </div> <p>This changes the default value of the <code>:approved</code> field from true to false. This change will only be applied to future records, any existing records do not change. Use <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html#method-i-change_column_default"><code>change_column_default</code></a> to change a null constraint.</p>
<div class="interstitial code"> <pre data-language="ruby">change_column_null :products, :name, false</pre> <button class="clipboard-button" data-clipboard-text="change_column_null :products, :name, false
">Copy</button> </div> <p>This sets <code>:name</code> field on products to a <code>NOT NULL</code> column. This change applies to existing records as well, so you need to make sure all existing records have a <code>:name</code> that is <code>NOT NULL</code>.</p>
<p>Setting the null constraint to <code>true</code> implies that column will accept a null value, otherwise the <code>NOT NULL</code> constraint is applied and a value must be passed in order to persist the record to the database.</p>
<div class="interstitial note"><p>You could also write the above <code>change_column_default</code> migration as <code>change_column_default :products, :approved, false</code>, but unlike the previous example, this would make your migration irreversible.</p></div>
<h2 id="column-modifiers"><a class="anchorlink" href="#column-modifiers"><span>3.5</span> Column Modifiers</a></h2>
<p>Column modifiers can be applied when creating or changing a column:</p> <ul> <li>
<code>comment</code> Adds a comment for the column.</li> <li>
<code>collation</code> Specifies the collation for a <code>string</code> or <code>text</code> column.</li> <li>
<code>default</code> Allows to set a default value on the column. Note that if you are using a dynamic value (such as a date), the default will only be calculated the first time (i.e. on the date the migration is applied). Use <code>nil</code> for <code>NULL</code>.</li> <li>
<code>limit</code> Sets the maximum number of characters for a <code>string</code> column and the maximum number of bytes for <code>text/binary/integer</code> columns.</li> <li>
<code>null</code> Allows or disallows <code>NULL</code> values in the column.</li> <li>
<code>precision</code> Specifies the precision for <code>decimal/numeric/datetime/time</code> columns.</li> <li>
<code>scale</code> Specifies the scale for the <code>decimal</code> and <code>numeric</code> columns, representing the number of digits after the decimal point.</li> </ul> <div class="interstitial note"><p>For <code>add_column</code> or <code>change_column</code> there is no option for adding indexes. They need to be added separately using <code>add_index</code>.</p></div>
<p>Some adapters may support additional options; see the adapter specific API docs for further information.</p>
<div class="interstitial note"><p><code>null</code> and <code>default</code> cannot be specified via command line when generating migrations.</p></div>
<h2 id="references"><a class="anchorlink" href="#references"><span>3.6</span> References</a></h2>
<p>The <code>add_reference</code> method allows the creation of an appropriately named column acting as the connection between one or more associations.</p>
<div class="interstitial code"> <pre data-language="ruby">add_reference :users, :role</pre> <button class="clipboard-button" data-clipboard-text="add_reference :users, :role
">Copy</button> </div> <p>This migration will create a foreign key column called <code>role_id</code> in the users table. <code>role_id</code> is a reference to the <code>id</code> column in the <code>roles</code> table. In addition, it creates an index for the <code>role_id</code> column, unless it is explicitly told not to do so with the <code>index: false</code> option.</p>
<div class="interstitial info"><p>See also the <a href="association_basics.html">Active Record Associations</a> guide to learn more.</p></div>
<p>The method <code>add_belongs_to</code> is an alias of <code>add_reference</code>.</p>
<div class="interstitial code"> <pre data-language="ruby">add_belongs_to :taggings, :taggable, polymorphic: true</pre> <button class="clipboard-button" data-clipboard-text="add_belongs_to :taggings, :taggable, polymorphic: true
">Copy</button> </div> <p>The polymorphic option will create two columns on the taggings table which can be used for polymorphic associations: <code>taggable_type</code> and <code>taggable_id</code>.</p>
<div class="interstitial info"><p>See this guide to learn more about <a href="association_basics.html#polymorphic-associations">polymorphic associations</a>.</p></div>
<p>A foreign key can be created with the <code>foreign_key</code> option.</p>
<div class="interstitial code"> <pre data-language="ruby">add_reference :users, :role, foreign_key: true</pre> <button class="clipboard-button" data-clipboard-text="add_reference :users, :role, foreign_key: true
">Copy</button> </div> <p>For more <code>add_reference</code> options, visit the <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html#method-i-add_reference">API documentation</a>.</p>
<p>References can also be removed:</p>
<div class="interstitial code"> <pre data-language="ruby">remove_reference :products, :user, foreign_key: true, index: false</pre> <button class="clipboard-button" data-clipboard-text="remove_reference :products, :user, foreign_key: true, index: false
">Copy</button> </div> <h2 id="foreign-keys"><a class="anchorlink" href="#foreign-keys"><span>3.7</span> Foreign Keys</a></h2>
<p>While it's not required, you might want to add foreign key constraints to <a href="#active-record-and-referential-integrity">guarantee referential integrity</a>.</p>
<div class="interstitial code"> <pre data-language="ruby">add_foreign_key :articles, :authors</pre> <button class="clipboard-button" data-clipboard-text="add_foreign_key :articles, :authors
">Copy</button> </div> <p>The <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html#method-i-add_foreign_key"><code>add_foreign_key</code></a> call adds a new constraint to the <code>articles</code> table. The constraint guarantees that a row in the <code>authors</code> table exists where the <code>id</code> column matches the <code>articles.author_id</code> to ensure all reviewers listed in the articles table are valid authors listed in the authors table.</p>
<div class="interstitial note"><p>When using <code>references</code> in a migration, you are creating a new column in the table and you'll have the option to add a foreign key using <code>foreign_key:
true</code> to that column. However, if you want to add a foreign key to an existing column, you can use <code>add_foreign_key</code>.</p></div>
<p>If the column name of the table to which we're adding the foreign key cannot be derived from the table with the referenced primary key then you can use the <code>:column</code> option to specify the column name. Additionally, you can use the <code>:primary_key</code> option if the referenced primary key is not <code>:id</code>.</p>
<p>For example, to add a foreign key on <code>articles.reviewer</code> referencing <code>authors.email</code>:</p>
<div class="interstitial code"> <pre data-language="ruby">add_foreign_key :articles, :authors, column: :reviewer, primary_key: :email</pre> <button class="clipboard-button" data-clipboard-text="add_foreign_key :articles, :authors, column: :reviewer, primary_key: :email
">Copy</button> </div> <p>This will add a constraint to the <code>articles</code> table that guarantees a row in the <code>authors</code> table exists where the <code>email</code> column matches the <code>articles.reviewer</code> field.</p>
<p>Several other options such as <code>name</code>, <code>on_delete</code>, <code>if_not_exists</code>, <code>validate</code>, and <code>deferrable</code> are supported by <code>add_foreign_key</code>.</p>
<p>Foreign keys can also be removed using <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html#method-i-remove_foreign_key"><code>remove_foreign_key</code></a>:</p>
<div class="interstitial code"> <pre data-language="ruby"># let Active Record figure out the column name
remove_foreign_key :accounts, :branches

# remove foreign key for a specific column
remove_foreign_key :accounts, column: :owner_id</pre> <button class="clipboard-button" data-clipboard-text="# let Active Record figure out the column name
remove_foreign_key :accounts, :branches

# remove foreign key for a specific column
remove_foreign_key :accounts, column: :owner_id
">Copy</button> </div> <div class="interstitial note"><p>Active Record only supports single column foreign keys. <code>execute</code> and <code>structure.sql</code> are required to use composite foreign keys. See <a href="#schema-dumping-and-you">Schema Dumping and You</a>.</p></div>
<h2 id="composite-primary-keys"><a class="anchorlink" href="#composite-primary-keys"><span>3.8</span> Composite Primary Keys</a></h2>
<p>Sometimes a single column's value isn't enough to uniquely identify every row of a table, but a combination of two or more columns <em>does</em> uniquely identify it. This can be the case when using a legacy database schema without a single <code>id</code> column as a primary key, or when altering schemas for sharding or multitenancy.</p>
<p>You can create a table with a composite primary key by passing the <code>:primary_key</code> option to <code>create_table</code> with an array value:</p>
<div class="interstitial code"> <pre data-language="ruby">class CreateProducts &lt; ActiveRecord::Migration[7.2]
  def change
    create_table :products, primary_key: [:customer_id, :product_sku] do |t|
      t.integer :customer_id
      t.string :product_sku
      t.text :description
    end
  end
end</pre> <button class="clipboard-button" data-clipboard-text="class CreateProducts &lt; ActiveRecord::Migration[7.2]
  def change
    create_table :products, primary_key: [:customer_id, :product_sku] do |t|
      t.integer :customer_id
      t.string :product_sku
      t.text :description
    end
  end
end
">Copy</button> </div> <div class="interstitial info"><p>Tables with composite primary keys require passing array values rather than integer IDs to many methods. See also the <a href="active_record_composite_primary_keys.html">Active Record Composite Primary Keys</a> guide to learn more.</p></div>
<h2 id="execute-sql"><a class="anchorlink" href="#execute-sql"><span>3.9</span> Execute SQL</a></h2>
<p>If the helpers provided by Active Record aren't enough, you can use the <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/DatabaseStatements.html#method-i-execute"><code>execute</code></a> method to execute SQL commands. For example,</p>
<div class="interstitial code"> <pre data-language="ruby">class UpdateProductPrices &lt; ActiveRecord::Migration[7.2]
  def up
    execute "UPDATE products SET price = 'free'"
  end

  def down
    execute "UPDATE products SET price = 'original_price' WHERE price = 'free';"
  end
end</pre> <button class="clipboard-button" data-clipboard-text="class UpdateProductPrices &lt; ActiveRecord::Migration[7.2]
  def up
    execute &quot;UPDATE products SET price = 'free'&quot;
  end

  def down
    execute &quot;UPDATE products SET price = 'original_price' WHERE price = 'free';&quot;
  end
end
">Copy</button> </div> <p>In this example, we're updating the <code>price</code> column of the products table to 'free' for all records.</p>
<div class="interstitial warning"><p>Modifying data directly in migrations should be approached with caution. Consider if this is the best approach for your use case, and be aware of potential drawbacks such as increased complexity and maintenance overhead, risks to data integrity and database portability. See the <a href="#data-migrations">Data Migrations documentation</a> for more details.</p></div>
<p>For more details and examples of individual methods, check the API documentation.</p>
<p>In particular the documentation for <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html"><code>ActiveRecord::ConnectionAdapters::SchemaStatements</code></a>, which provides the methods available in the <code>change</code>, <code>up</code> and <code>down</code> methods.</p>
<p>For methods available regarding the object yielded by <code>create_table</code>, see <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/TableDefinition.html"><code>ActiveRecord::ConnectionAdapters::TableDefinition</code></a>.</p>
<p>And for the object yielded by <code>change_table</code>, see <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/Table.html"><code>ActiveRecord::ConnectionAdapters::Table</code></a>.</p>
<h2 id="using-the-change-method"><a class="anchorlink" href="#using-the-change-method"><span>3.10</span> Using the <code>change</code> Method</a></h2>
<p>The <code>change</code> method is the primary way of writing migrations. It works for the majority of cases in which Active Record knows how to reverse a migration's actions automatically. Below are some of the actions that <code>change</code> supports:</p> <ul> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html#method-i-add_check_constraint"><code>add_check_constraint</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html#method-i-add_column"><code>add_column</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html#method-i-add_foreign_key"><code>add_foreign_key</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html#method-i-add_index"><code>add_index</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html#method-i-add_reference"><code>add_reference</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html#method-i-add_timestamps"><code>add_timestamps</code></a></li> <li>
<a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html#method-i-change_column_comment"><code>change_column_comment</code></a> (must supply <code>:from</code> and <code>:to</code> options)</li> <li>
<a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html#method-i-change_column_default"><code>change_column_default</code></a> (must supply <code>:from</code> and <code>:to</code> options)</li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html#method-i-change_column_null"><code>change_column_null</code></a></li> <li>
<a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html#method-i-change_table_comment"><code>change_table_comment</code></a> (must supply <code>:from</code> and <code>:to</code> options)</li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html#method-i-create_join_table"><code>create_join_table</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html#method-i-create_table"><code>create_table</code></a></li> <li><code>disable_extension</code></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html#method-i-drop_join_table"><code>drop_join_table</code></a></li> <li>
<a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html#method-i-drop_table"><code>drop_table</code></a> (must supply table creation options and block)</li> <li><code>enable_extension</code></li> <li>
<a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html#method-i-remove_check_constraint"><code>remove_check_constraint</code></a> (must supply original constraint expression)</li> <li>
<a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html#method-i-remove_column"><code>remove_column</code></a> (must supply original type and column options)</li> <li>
<a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html#method-i-remove_columns"><code>remove_columns</code></a> (must supply original type and column options)</li> <li>
<a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html#method-i-remove_foreign_key"><code>remove_foreign_key</code></a> (must supply other table and original options)</li> <li>
<a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html#method-i-remove_index"><code>remove_index</code></a> (must supply columns and original options)</li> <li>
<a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html#method-i-remove_reference"><code>remove_reference</code></a> (must supply original options)</li> <li>
<a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html#method-i-remove_timestamps"><code>remove_timestamps</code></a> (must supply original options)</li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html#method-i-rename_column"><code>rename_column</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html#method-i-rename_index"><code>rename_index</code></a></li> <li><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html#method-i-rename_table"><code>rename_table</code></a></li> </ul> <p><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html#method-i-change_table"><code>change_table</code></a> is also reversible, as long as the block only calls reversible operations like the ones listed above.</p>
<p>If you need to use any other methods, you should use <code>reversible</code> or write the <code>up</code> and <code>down</code> methods instead of using the <code>change</code> method.</p>
<h2 id="using-reversible"><a class="anchorlink" href="#using-reversible"><span>3.11</span> Using <code>reversible</code></a></h2>
<p>If you'd like for a migration to do something that Active Record doesn't know how to reverse, then you can use <code>reversible</code> to specify what to do when running a migration and what else to do when reverting it.</p>
<div class="interstitial code"> <pre data-language="ruby">class ChangeProductsPrice &lt; ActiveRecord::Migration[7.2]
  def change
    reversible do |direction|
      change_table :products do |t|
        direction.up   { t.change :price, :string }
        direction.down { t.change :price, :integer }
      end
    end
  end
end</pre> <button class="clipboard-button" data-clipboard-text="class ChangeProductsPrice &lt; ActiveRecord::Migration[7.2]
  def change
    reversible do |direction|
      change_table :products do |t|
        direction.up   { t.change :price, :string }
        direction.down { t.change :price, :integer }
      end
    end
  end
end
">Copy</button> </div> <p>This migration will change the type of the <code>price</code> column to a string, or back to an integer when the migration is reverted. Notice the block being passed to <code>direction.up</code> and <code>direction.down</code> respectively.</p>
<p>Alternatively, you can use <code>up</code> and <code>down</code> instead of <code>change</code>:</p>
<div class="interstitial code"> <pre data-language="ruby">class ChangeProductsPrice &lt; ActiveRecord::Migration[7.2]
  def up
    change_table :products do |t|
      t.change :price, :string
    end
  end

  def down
    change_table :products do |t|
      t.change :price, :integer
    end
  end
end</pre> <button class="clipboard-button" data-clipboard-text="class ChangeProductsPrice &lt; ActiveRecord::Migration[7.2]
  def up
    change_table :products do |t|
      t.change :price, :string
    end
  end

  def down
    change_table :products do |t|
      t.change :price, :integer
    end
  end
end
">Copy</button> </div> <p>Additionally, <code>reversible</code> is useful when executing raw SQL queries or performing database operations that do not have a direct equivalent in ActiveRecord methods. You can use <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Migration.html#method-i-reversible"><code>reversible</code></a> to specify what to do when running a migration and what else to do when reverting it. For example:</p>
<div class="interstitial code"> <pre data-language="ruby">class ExampleMigration &lt; ActiveRecord::Migration[7.2]
  def change
    create_table :distributors do |t|
      t.string :zipcode
    end

    reversible do |direction|
      direction.up do
        # create a distributors view
        execute &lt;&lt;-SQL
          CREATE VIEW distributors_view AS
          SELECT id, zipcode
          FROM distributors;
        SQL
      end
      direction.down do
        execute &lt;&lt;-SQL
          DROP VIEW distributors_view;
        SQL
      end
    end

    add_column :users, :address, :string
  end
end</pre> <button class="clipboard-button" data-clipboard-text="class ExampleMigration &lt; ActiveRecord::Migration[7.2]
  def change
    create_table :distributors do |t|
      t.string :zipcode
    end

    reversible do |direction|
      direction.up do
        # create a distributors view
        execute &lt;&lt;-SQL
          CREATE VIEW distributors_view AS
          SELECT id, zipcode
          FROM distributors;
        SQL
      end
      direction.down do
        execute &lt;&lt;-SQL
          DROP VIEW distributors_view;
        SQL
      end
    end

    add_column :users, :address, :string
  end
end
">Copy</button> </div> <p>Using <code>reversible</code> will ensure that the instructions are executed in the right order too. If the previous example migration is reverted, the <code>down</code> block will be run after the <code>users.address</code> column is removed and before the <code>distributors</code> table is dropped.</p>
<h2 id="using-the-up-down-methods"><a class="anchorlink" href="#using-the-up-down-methods"><span>3.12</span> Using the <code>up</code>/<code>down</code> Methods</a></h2>
<p>You can also use the old style of migration using <code>up</code> and <code>down</code> methods instead of the <code>change</code> method.</p>
<p>The <code>up</code> method should describe the transformation you'd like to make to your schema, and the <code>down</code> method of your migration should revert the transformations done by the <code>up</code> method. In other words, the database schema should be unchanged if you do an <code>up</code> followed by a <code>down</code>.</p>
<p>For example, if you create a table in the <code>up</code> method, you should drop it in the <code>down</code> method. It is wise to perform the transformations in precisely the reverse order they were made in the <code>up</code> method. The example in the <code>reversible</code> section is equivalent to:</p>
<div class="interstitial code"> <pre data-language="ruby">class ExampleMigration &lt; ActiveRecord::Migration[7.2]
  def up
    create_table :distributors do |t|
      t.string :zipcode
    end

    # create a distributors view
    execute &lt;&lt;-SQL
      CREATE VIEW distributors_view AS
      SELECT id, zipcode
      FROM distributors;
    SQL

    add_column :users, :address, :string
  end

  def down
    remove_column :users, :address

    execute &lt;&lt;-SQL
      DROP VIEW distributors_view;
    SQL

    drop_table :distributors
  end
end</pre> <button class="clipboard-button" data-clipboard-text="class ExampleMigration &lt; ActiveRecord::Migration[7.2]
  def up
    create_table :distributors do |t|
      t.string :zipcode
    end

    # create a distributors view
    execute &lt;&lt;-SQL
      CREATE VIEW distributors_view AS
      SELECT id, zipcode
      FROM distributors;
    SQL

    add_column :users, :address, :string
  end

  def down
    remove_column :users, :address

    execute &lt;&lt;-SQL
      DROP VIEW distributors_view;
    SQL

    drop_table :distributors
  end
end
">Copy</button> </div> <h2 id="throwing-an-error-to-prevent-reverts"><a class="anchorlink" href="#throwing-an-error-to-prevent-reverts"><span>3.13</span> Throwing an error to prevent reverts</a></h2>
<p>Sometimes your migration will do something which is just plain irreversible; for example, it might destroy some data.</p>
<p>In such cases, you can raise <code>ActiveRecord::IrreversibleMigration</code> in your <code>down</code> block.</p>
<div class="interstitial code"> <pre data-language="ruby">class IrreversibleMigrationExample &lt; ActiveRecord::Migration[7.2]
  def up
    drop_table :example_table
  end

  def down
    raise ActiveRecord::IrreversibleMigration, "This migration cannot be reverted because it destroys data."
  end
end</pre> <button class="clipboard-button" data-clipboard-text='class IrreversibleMigrationExample &lt; ActiveRecord::Migration[7.2]
  def up
    drop_table :example_table
  end

  def down
    raise ActiveRecord::IrreversibleMigration, "This migration cannot be reverted because it destroys data."
  end
end
'>Copy</button> </div> <p>If someone tries to revert your migration, an error message will be displayed saying that it can't be done.</p>
<h2 id="reverting-previous-migrations"><a class="anchorlink" href="#reverting-previous-migrations"><span>3.14</span> Reverting Previous Migrations</a></h2>
<p>You can use Active Record's ability to rollback migrations using the <a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Migration.html#method-i-revert"><code>revert</code></a> method:</p>
<div class="interstitial code"> <pre data-language="ruby">require_relative "20121212123456_example_migration"

class FixupExampleMigration &lt; ActiveRecord::Migration[7.2]
  def change
    revert ExampleMigration

    create_table(:apples) do |t|
      t.string :variety
    end
  end
end</pre> <button class="clipboard-button" data-clipboard-text='require_relative "20121212123456_example_migration"

class FixupExampleMigration &lt; ActiveRecord::Migration[7.2]
  def change
    revert ExampleMigration

    create_table(:apples) do |t|
      t.string :variety
    end
  end
end
'>Copy</button> </div> <p>The <code>revert</code> method also accepts a block of instructions to reverse. This could be useful to revert selected parts of previous migrations.</p>
<p>For example, let's imagine that <code>ExampleMigration</code> is committed and it is later decided that a Distributors view is no longer needed.</p>
<div class="interstitial code"> <pre data-language="ruby">class DontUseDistributorsViewMigration &lt; ActiveRecord::Migration[7.2]
  def change
    revert do
      # copy-pasted code from ExampleMigration
      create_table :distributors do |t|
        t.string :zipcode
      end

      reversible do |direction|
        direction.up do
          # create a distributors view
          execute &lt;&lt;-SQL
            CREATE VIEW distributors_view AS
            SELECT id, zipcode
            FROM distributors;
          SQL
        end
        direction.down do
          execute &lt;&lt;-SQL
            DROP VIEW distributors_view;
          SQL
        end
      end

      # The rest of the migration was ok
    end
  end
end</pre> <button class="clipboard-button" data-clipboard-text="class DontUseDistributorsViewMigration &lt; ActiveRecord::Migration[7.2]
  def change
    revert do
      # copy-pasted code from ExampleMigration
      create_table :distributors do |t|
        t.string :zipcode
      end

      reversible do |direction|
        direction.up do
          # create a distributors view
          execute &lt;&lt;-SQL
            CREATE VIEW distributors_view AS
            SELECT id, zipcode
            FROM distributors;
          SQL
        end
        direction.down do
          execute &lt;&lt;-SQL
            DROP VIEW distributors_view;
          SQL
        end
      end

      # The rest of the migration was ok
    end
  end
end
">Copy</button> </div> <p>The same migration could also have been written without using <code>revert</code> but this would have involved a few more steps:</p> <ol> <li>Reverse the order of <code>create_table</code> and <code>reversible</code>.</li> <li>Replace <code>create_table</code> with <code>drop_table</code>.</li> <li>Finally, replace <code>up</code> with <code>down</code> and vice-versa.</li> </ol> <p>This is all taken care of by <code>revert</code>.</p>
<h1 id="running-migrations"><a class="anchorlink" href="#running-migrations"><span>4</span> Running Migrations</a></h1>
<p>Rails provides a set of commands to run certain sets of migrations.</p>
<p>The very first migration related rails command you will use will probably be <code>bin/rails db:migrate</code>. In its most basic form it just runs the <code>change</code> or <code>up</code> method for all the migrations that have not yet been run. If there are no such migrations, it exits. It will run these migrations in order based on the date of the migration.</p>
<p>Note that running the <code>db:migrate</code> command also invokes the <code>db:schema:dump</code> command, which will update your <code>db/schema.rb</code> file to match the structure of your database.</p>
<p>If you specify a target version, Active Record will run the required migrations (change, up, down) until it has reached the specified version. The version is the numerical prefix on the migration's filename. For example, to migrate to version 20240428000000 run:</p>
<div class="interstitial code"> <pre data-language="console">$ bin/rails db:migrate VERSION=20240428000000</pre> <button class="clipboard-button" data-clipboard-text="bin/rails db:migrate VERSION=20240428000000
">Copy</button> </div> <p>If version 20240428000000 is greater than the current version (i.e., it is migrating upwards), this will run the <code>change</code> (or <code>up</code>) method on all migrations up to and including 20240428000000, and will not execute any later migrations. If migrating downwards, this will run the <code>down</code> method on all the migrations down to, but not including, 20240428000000.</p>
<h2 id="rolling-back"><a class="anchorlink" href="#rolling-back"><span>4.1</span> Rolling Back</a></h2>
<p>A common task is to rollback the last migration. For example, if you made a mistake in it and wish to correct it. Rather than tracking down the version number associated with the previous migration you can run:</p>
<div class="interstitial code"> <pre data-language="console">$ bin/rails db:rollback</pre> <button class="clipboard-button" data-clipboard-text="bin/rails db:rollback
">Copy</button> </div> <p>This will rollback the latest migration, either by reverting the <code>change</code> method or by running the <code>down</code> method. If you need to undo several migrations you can provide a <code>STEP</code> parameter:</p>
<div class="interstitial code"> <pre data-language="console">$ bin/rails db:rollback STEP=3</pre> <button class="clipboard-button" data-clipboard-text="bin/rails db:rollback STEP=3
">Copy</button> </div> <p>The last 3 migrations will be reverted.</p>
<p>In some cases where you modify a local migration and would like to rollback that specific migration before migrating back up again, you can use the <code>db:migrate:redo</code> command. As with the <code>db:rollback</code> command, you can use the <code>STEP</code> parameter if you need to go more than one version back, for example:</p>
<div class="interstitial code"> <pre data-language="console">$ bin/rails db:migrate:redo STEP=3</pre> <button class="clipboard-button" data-clipboard-text="bin/rails db:migrate:redo STEP=3
">Copy</button> </div> <div class="interstitial note"><p>You could get the same result using <code>db:migrate</code>. However, these are there for convenience so that you do not need to explicitly specify the version to migrate to.</p></div>
<h3 id="transactions"><a class="anchorlink" href="#transactions"><span>4.1.1</span> Transactions</a></h3>
<p>In databases that support DDL transactions, changing the schema in a single transaction, each migration is wrapped in a transaction.</p>
<div class="interstitial info"><p>A transaction ensures that if a migration fails partway through, any changes that were successfully applied are rolled back, maintaining database consistency. This means that either all operations within the transaction are executed successfully, or none of them are, preventing the database from being left in an inconsistent state if an error occurs during the transaction.</p></div>
<p>If the database does not support DDL transactions with statements that change the schema, then when a migration fails, the parts of it that have succeeded will not be rolled back. You will have to rollback the changes manually.</p>
<p>There are queries that you cant execute inside a transaction though, and for these situations you can turn the automatic transactions off with <code>disable_ddl_transaction!</code>:</p>
<div class="interstitial code"> <pre data-language="ruby">class ChangeEnum &lt; ActiveRecord::Migration[7.2]
  disable_ddl_transaction!

  def up
    execute "ALTER TYPE model_size ADD VALUE 'new_value'"
  end
end</pre> <button class="clipboard-button" data-clipboard-text="class ChangeEnum &lt; ActiveRecord::Migration[7.2]
  disable_ddl_transaction!

  def up
    execute &quot;ALTER TYPE model_size ADD VALUE 'new_value'&quot;
  end
end
">Copy</button> </div> <div class="interstitial note"><p>Remember that you can still open your own transactions, even if you are in a Migration with self.disable_ddl_transaction!.</p></div>
<h2 id="setting-up-the-database"><a class="anchorlink" href="#setting-up-the-database"><span>4.2</span> Setting Up the Database</a></h2>
<p>The <code>bin/rails db:setup</code> command will create the database, load the schema, and initialize it with the seed data.</p>
<h2 id="preparing-the-database"><a class="anchorlink" href="#preparing-the-database"><span>4.3</span> Preparing the Database</a></h2>
<p>The <code>bin/rails db:prepare</code> command is similar to <code>bin/rails db:setup</code>, but it operates idempotently, so it can safely be called several times, but it will only perform the necessary tasks once.</p> <ul> <li>If the database has not been created yet, the command will run as the <code>bin/rails db:setup</code> does.</li> <li>If the database exists but the tables have not been created, the command will load the schema, run any pending migrations, dump the updated schema, and finally load the seed data. See the <a href="#migrations-and-seed-data">Seeding Data documentation</a> for more details.</li> <li>If both the database and tables exist but the seed data has not been loaded, the command will only load the seed data.</li> <li>If the database, tables, and seed data are all in place, the command will do nothing.</li> </ul> <div class="interstitial note"><p>Once the database, tables, and seed data are all established, the command will not try to reload the seed data, even if the previously loaded seed data or the existing seed file have been altered or deleted. To reload the seed data, you can manually run <code>bin/rails db:seed</code>.</p></div>
<h2 id="resetting-the-database"><a class="anchorlink" href="#resetting-the-database"><span>4.4</span> Resetting the Database</a></h2>
<p>The <code>bin/rails db:reset</code> command will drop the database and set it up again. This is functionally equivalent to <code>bin/rails db:drop db:setup</code>.</p>
<div class="interstitial note"><p>This is not the same as running all the migrations. It will only use the contents of the current <code>db/schema.rb</code> or <code>db/structure.sql</code> file. If a migration can't be rolled back, <code>bin/rails db:reset</code> may not help you. To find out more about dumping the schema see <a href="#schema-dumping-and-you">Schema Dumping and You</a> section.</p></div>
<h2 id="running-specific-migrations"><a class="anchorlink" href="#running-specific-migrations"><span>4.5</span> Running Specific Migrations</a></h2>
<p>If you need to run a specific migration up or down, the <code>db:migrate:up</code> and <code>db:migrate:down</code> commands will do that. Just specify the appropriate version and the corresponding migration will have its <code>change</code>, <code>up</code> or <code>down</code> method invoked, for example:</p>
<div class="interstitial code"> <pre data-language="console">$ bin/rails db:migrate:up VERSION=20240428000000</pre> <button class="clipboard-button" data-clipboard-text="bin/rails db:migrate:up VERSION=20240428000000
">Copy</button> </div> <p>By running this command the <code>change</code> method (or the <code>up</code> method) will be executed for the migration with the version "20240428000000".</p>
<p>First, this command will check whether the migration exists and if it has already been performed and if so, it will do nothing.</p>
<p>If the version specified does not exist, Rails will throw an exception.</p>
<div class="interstitial code"> <pre data-language="console">$ bin/rails db:migrate VERSION=00000000000000
rails aborted!
ActiveRecord::UnknownMigrationVersionError:

No migration with version number 00000000000000.</pre> <button class="clipboard-button" data-clipboard-text="bin/rails db:migrate VERSION=00000000000000
">Copy</button> </div> <h2 id="running-migrations-in-different-environments"><a class="anchorlink" href="#running-migrations-in-different-environments"><span>4.6</span> Running Migrations in Different Environments</a></h2>
<p>By default running <code>bin/rails db:migrate</code> will run in the <code>development</code> environment.</p>
<p>To run migrations against another environment you can specify it using the <code>RAILS_ENV</code> environment variable while running the command. For example to run migrations against the <code>test</code> environment you could run:</p>
<div class="interstitial code"> <pre data-language="console">$ bin/rails db:migrate RAILS_ENV=test</pre> <button class="clipboard-button" data-clipboard-text="bin/rails db:migrate RAILS_ENV=test
">Copy</button> </div> <h2 id="changing-the-output-of-running-migrations"><a class="anchorlink" href="#changing-the-output-of-running-migrations"><span>4.7</span> Changing the Output of Running Migrations</a></h2>
<p>By default migrations tell you exactly what they're doing and how long it took. A migration creating a table and adding an index might produce output like this</p>
<div class="interstitial code"> <pre data-language="plaintext">==  CreateProducts: migrating =================================================
-- create_table(:products)
   -&gt; 0.0028s
==  CreateProducts: migrated (0.0028s) ========================================</pre> <button class="clipboard-button" data-clipboard-text="==  CreateProducts: migrating =================================================
-- create_table(:products)
   -&gt; 0.0028s
==  CreateProducts: migrated (0.0028s) ========================================
">Copy</button> </div> <p>Several methods are provided in migrations that allow you to control all this:</p> <table>
<thead> <tr> <th>Method</th> <th>Purpose</th> </tr> </thead>
<tbody> <tr> <td><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Migration.html#method-i-suppress_messages"><code>suppress_messages</code></a></td> <td>Takes a block as an argument and suppresses any output generated by the block.</td> </tr> <tr> <td><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Migration.html#method-i-say"><code>say</code></a></td> <td>Takes a message argument and outputs it as is. A second boolean argument can be passed to specify whether to indent or not.</td> </tr> <tr> <td><a href="https://edgeapi.rubyonrails.org/classes/ActiveRecord/Migration.html#method-i-say_with_time"><code>say_with_time</code></a></td> <td>Outputs text along with how long it took to run its block. If the block returns an integer it assumes it is the number of rows affected.</td> </tr> </tbody>
</table> <p>For example, take the following migration:</p>
<div class="interstitial code"> <pre data-language="ruby">class CreateProducts &lt; ActiveRecord::Migration[7.2]
  def change
    suppress_messages do
      create_table :products do |t|
        t.string :name
        t.text :description
        t.timestamps
      end
    end

    say "Created a table"

    suppress_messages { add_index :products, :name }
    say "and an index!", true

    say_with_time 'Waiting for a while' do
      sleep 10
      250
    end
  end
end</pre> <button class="clipboard-button" data-clipboard-text="class CreateProducts &lt; ActiveRecord::Migration[7.2]
  def change
    suppress_messages do
      create_table :products do |t|
        t.string :name
        t.text :description
        t.timestamps
      end
    end

    say &quot;Created a table&quot;

    suppress_messages { add_index :products, :name }
    say &quot;and an index!&quot;, true

    say_with_time 'Waiting for a while' do
      sleep 10
      250
    end
  end
end
">Copy</button> </div> <p>This will generate the following output:</p>
<div class="interstitial code"> <pre data-language="plaintext">==  CreateProducts: migrating =================================================
-- Created a table
   -&gt; and an index!
-- Waiting for a while
   -&gt; 10.0013s
   -&gt; 250 rows
==  CreateProducts: migrated (10.0054s) =======================================</pre> <button class="clipboard-button" data-clipboard-text="==  CreateProducts: migrating =================================================
-- Created a table
   -&gt; and an index!
-- Waiting for a while
   -&gt; 10.0013s
   -&gt; 250 rows
==  CreateProducts: migrated (10.0054s) =======================================
">Copy</button> </div> <p>If you want Active Record to not output anything, then running <code>bin/rails
db:migrate VERBOSE=false</code> will suppress all output.</p>
<h2 id="rails-migration-version-control"><a class="anchorlink" href="#rails-migration-version-control"><span>4.8</span> Rails Migration Version Control</a></h2>
<p>Rails keeps track of which migrations have been run through the <code>schema_migrations</code> table in the database. When you run a migration, Rails inserts a row into the <code>schema_migrations</code> table with the version number of the migration, stored in the <code>version</code> column. This allows Rails to determine which migrations have already been applied to the database.</p>
<p>For example, if you have a migration file named 20240428000000_create_users.rb, Rails will extract the version number (20240428000000) from the filename and insert it into the schema_migrations table after the migration has been successfully executed.</p>
<p>You can view the contents of the schema_migrations table directly in your database management tool or by using Rails console:</p>
<div class="interstitial code"> <pre data-language="irb">rails dbconsole</pre> <button class="clipboard-button" data-clipboard-text="">Copy</button> </div> <p>Then, within the database console, you can query the schema_migrations table:</p>
<div class="interstitial code"> <pre data-language="sql">SELECT * FROM schema_migrations;</pre> <button class="clipboard-button" data-clipboard-text="SELECT * FROM schema_migrations;
">Copy</button> </div> <p>This will show you a list of all migration version numbers that have been applied to the database. Rails uses this information to determine which migrations need to be run when you run rails db:migrate or rails db:migrate:up commands.</p>
<h1 id="changing-existing-migrations"><a class="anchorlink" href="#changing-existing-migrations"><span>5</span> Changing Existing Migrations</a></h1>
<p>Occasionally you will make a mistake when writing a migration. If you have already run the migration, then you cannot just edit the migration and run the migration again: Rails thinks it has already run the migration and so will do nothing when you run <code>bin/rails db:migrate</code>. You must rollback the migration (for example with <code>bin/rails db:rollback</code>), edit your migration, and then run <code>bin/rails db:migrate</code> to run the corrected version.</p>
<p>In general, editing existing migrations that have been already committed to source control is not a good idea. You will be creating extra work for yourself and your co-workers and cause major headaches if the existing version of the migration has already been run on production machines. Instead, you should write a new migration that performs the changes you require.</p>
<p>However, editing a freshly generated migration that has not yet been committed to source control (or, more generally, has not been propagated beyond your development machine) is common.</p>
<p>The <code>revert</code> method can be helpful when writing a new migration to undo previous migrations in whole or in part (see <a href="#reverting-previous-migrations">Reverting Previous Migrations</a> above).</p>
<h1 id="schema-dumping-and-you"><a class="anchorlink" href="#schema-dumping-and-you"><span>6</span> Schema Dumping and You</a></h1>
<h2 id="what-are-schema-files-for-questionmark"><a class="anchorlink" href="#what-are-schema-files-for-questionmark"><span>6.1</span> What are Schema Files for?</a></h2>
<p>Migrations, mighty as they may be, are not the authoritative source for your database schema. <strong>Your database remains the source of truth.</strong></p>
<p>By default, Rails generates <code>db/schema.rb</code> which attempts to capture the current state of your database schema.</p>
<p>It tends to be faster and less error prone to create a new instance of your application's database by loading the schema file via <code>bin/rails db:schema:load</code> than it is to replay the entire migration history. <a href="#old-migrations">Old migrations</a> may fail to apply correctly if those migrations use changing external dependencies or rely on application code which evolves separately from your migrations.</p>
<div class="interstitial info"><p>Schema files are also useful if you want a quick look at what attributes an Active Record object has. This information is not in the model's code and is frequently spread across several migrations, but the information is nicely summed up in the schema file.</p></div>
<h2 id="types-of-schema-dumps"><a class="anchorlink" href="#types-of-schema-dumps"><span>6.2</span> Types of Schema Dumps</a></h2>
<p>The format of the schema dump generated by Rails is controlled by the <a href="configuring.html#config-active-record-schema-format"><code>config.active_record.schema_format</code></a> setting defined in <code>config/application.rb</code>. By default, the format is <code>:ruby</code>, or alternatively can be set to <code>:sql</code>.</p>
<h3 id="using-the-default-ruby-schema"><a class="anchorlink" href="#using-the-default-ruby-schema"><span>6.2.1</span> Using the default <code>:ruby</code> schema</a></h3>
<p>When <code>:ruby</code> is selected, then the schema is stored in <code>db/schema.rb</code>. If you look at this file you'll find that it looks an awful lot like one very big migration:</p>
<div class="interstitial code"> <pre data-language="ruby">ActiveRecord::Schema[7.2].define(version: 2008_09_06_171750) do
  create_table "authors", force: true do |t|
    t.string   "name"
    t.datetime "created_at"
    t.datetime "updated_at"
  end

  create_table "products", force: true do |t|
    t.string   "name"
    t.text     "description"
    t.datetime "created_at"
    t.datetime "updated_at"
    t.string   "part_number"
  end
end</pre> <button class="clipboard-button" data-clipboard-text='ActiveRecord::Schema[7.2].define(version: 2008_09_06_171750) do
  create_table "authors", force: true do |t|
    t.string   "name"
    t.datetime "created_at"
    t.datetime "updated_at"
  end

  create_table "products", force: true do |t|
    t.string   "name"
    t.text     "description"
    t.datetime "created_at"
    t.datetime "updated_at"
    t.string   "part_number"
  end
end
'>Copy</button> </div> <p>In many ways this is exactly what it is. This file is created by inspecting the database and expressing its structure using <code>create_table</code>, <code>add_index</code>, and so on.</p>
<h3 id="using-the-sql-schema-dumper"><a class="anchorlink" href="#using-the-sql-schema-dumper"><span>6.2.2</span> Using the <code>:sql</code> schema dumper</a></h3>
<p>However, <code>db/schema.rb</code> cannot express everything your database may support such as triggers, sequences, stored procedures, etc.</p>
<p>While migrations may use <code>execute</code> to create database constructs that are not supported by the Ruby migration DSL, these constructs may not be able to be reconstituted by the schema dumper.</p>
<p>If you are using features like these, you should set the schema format to <code>:sql</code> in order to get an accurate schema file that is useful to create new database instances.</p>
<p>When the schema format is set to <code>:sql</code>, the database structure will be dumped using a tool specific to the database into <code>db/structure.sql</code>. For example, for PostgreSQL, the <code>pg_dump</code> utility is used. For MySQL and MariaDB, this file will contain the output of <code>SHOW CREATE TABLE</code> for the various tables.</p>
<p>To load the schema from <code>db/structure.sql</code>, run <code>bin/rails db:schema:load</code>. Loading this file is done by executing the SQL statements it contains. By definition, this will create a perfect copy of the database's structure.</p>
<h2 id="schema-dumps-and-source-control"><a class="anchorlink" href="#schema-dumps-and-source-control"><span>6.3</span> Schema Dumps and Source Control</a></h2>
<p>Because schema files are commonly used to create new databases, it is strongly recommended that you check your schema file into source control.</p>
<p>Merge conflicts can occur in your schema file when two branches modify schema. To resolve these conflicts run <code>bin/rails db:migrate</code> to regenerate the schema file.</p>
<div class="interstitial info"><p>Newly generated Rails apps will already have the migrations folder included in the git tree, so all you have to do is be sure to add any new migrations you add and commit them.</p></div>
<h1 id="active-record-and-referential-integrity"><a class="anchorlink" href="#active-record-and-referential-integrity"><span>7</span> Active Record and Referential Integrity</a></h1>
<p>The Active Record pattern suggests that intelligence should primarily reside in your models rather than in the database. Consequently, features like triggers or constraints, which delegate some of that intelligence back into the database, are not always favored.</p>
<p>Validations such as <code>validates :foreign_key, uniqueness: true</code> are one way in which models can enforce data integrity. The <code>:dependent</code> option on associations allows models to automatically destroy child objects when the parent is destroyed. Like anything which operates at the application level, these cannot guarantee referential integrity and so some people augment them with <a href="#foreign-keys">foreign key constraints</a> in the database.</p>
<p>In practice, foreign key constraints and unique indexes are generally considered safer when enforced at the database level. Although Active Record does not provide direct support for working with these database-level features, you can still use the execute method to run arbitrary SQL commands.</p>
<p>It's worth emphasizing that while the Active Record pattern emphasizes keeping intelligence within models, neglecting to implement foreign keys and unique constraints at the database level can potentially lead to integrity issues. Therefore, it's advisable to complement the AR pattern with database-level constraints where appropriate. These constraints should have their counterparts explicitly defined in your code using associations and validations to ensure data integrity across both application and database layers.</p>
<h1 id="migrations-and-seed-data"><a class="anchorlink" href="#migrations-and-seed-data"><span>8</span> Migrations and Seed Data</a></h1>
<p>The main purpose of the Rails migration feature is to issue commands that modify the schema using a consistent process. Migrations can also be used to add or modify data. This is useful in an existing database that can't be destroyed and recreated, such as a production database.</p>
<div class="interstitial code"> <pre data-language="ruby">class AddInitialProducts &lt; ActiveRecord::Migration[7.2]
  def up
    5.times do |i|
      Product.create(name: "Product ##{i}", description: "A product.")
    end
  end

  def down
    Product.delete_all
  end
end</pre> <button class="clipboard-button" data-clipboard-text='class AddInitialProducts &lt; ActiveRecord::Migration[7.2]
  def up
    5.times do |i|
      Product.create(name: "Product ##{i}", description: "A product.")
    end
  end

  def down
    Product.delete_all
  end
end
'>Copy</button> </div> <p>To add initial data after a database is created, Rails has a built-in 'seeds' feature that speeds up the process. This is especially useful when reloading the database frequently in development and test environments, or when setting up initial data for production.</p>
<p>To get started with this feature, open up <code>db/seeds.rb</code> and add some Ruby code, then run <code>bin/rails db:seed</code>.</p>
<div class="interstitial note"><p>The code here should be idempotent so that it can be executed at any point in every environment.</p></div>
<div class="interstitial code"> <pre data-language="ruby">["Action", "Comedy", "Drama", "Horror"].each do |genre_name|
  MovieGenre.find_or_create_by!(name: genre_name)
end</pre> <button class="clipboard-button" data-clipboard-text='["Action", "Comedy", "Drama", "Horror"].each do |genre_name|
  MovieGenre.find_or_create_by!(name: genre_name)
end
'>Copy</button> </div> <p>This is generally a much cleaner way to set up the database of a blank application.</p>
<h1 id="old-migrations"><a class="anchorlink" href="#old-migrations"><span>9</span> Old Migrations</a></h1>
<p>The <code>db/schema.rb</code> or <code>db/structure.sql</code> is a snapshot of the current state of your database and is the authoritative source for rebuilding that database. This makes it possible to delete or prune old migration files.</p>
<p>When you delete migration files in the <code>db/migrate/</code> directory, any environment where <code>bin/rails db:migrate</code> was run when those files still existed will hold a reference to the migration timestamp specific to them inside an internal Rails database table named <code>schema_migrations</code>. You can read more about this in the <a href="#rails-migration-version-control">Rails Migration Version Control section</a>.</p>
<p>If you run the <code>bin/rails db:migrate:status</code> command, which displays the status (up or down) of each migration, you should see <code>********** NO FILE **********</code> displayed next to any deleted migration file which was once executed on a specific environment but can no longer be found in the <code>db/migrate/</code> directory.</p>
<h2 id="migrations-from-engines"><a class="anchorlink" href="#migrations-from-engines"><span>9.1</span> Migrations from Engines</a></h2>
<p>When dealing with migrations from <a href="engines.html">Engines</a>, there's a caveat to consider. Rake tasks to install migrations from engines are idempotent, meaning they will have the same result no matter how many times they are called. Migrations present in the parent application due to a previous installation are skipped, and missing ones are copied with a new leading timestamp. If you deleted old engine migrations and ran the install task again, you'd get new files with new timestamps, and <code>db:migrate</code> would attempt to run them again.</p>
<p>Thus, you generally want to preserve migrations coming from engines. They have a special comment like this:</p>
<div class="interstitial code"> <pre data-language="ruby"># This migration comes from blorgh (originally 20210621082949)</pre> <button class="clipboard-button" data-clipboard-text="# This migration comes from blorgh (originally 20210621082949)
">Copy</button> </div> <h1 id="miscellaneous"><a class="anchorlink" href="#miscellaneous"><span>10</span> Miscellaneous</a></h1>
<h2 id="using-uuids-instead-of-ids-for-primary-keys"><a class="anchorlink" href="#using-uuids-instead-of-ids-for-primary-keys"><span>10.1</span> Using UUIDs instead of IDs for Primary Keys</a></h2>
<p>By default, Rails uses auto-incrementing integers as primary keys for database records. However, there are scenarios where using Universally Unique Identifiers (UUIDs) as primary keys can be advantageous, especially in distributed systems or when integration with external services is necessary. UUIDs provide a globally unique identifier without relying on a centralized authority for generating IDs.</p>
<h3 id="enabling-uuids-in-rails"><a class="anchorlink" href="#enabling-uuids-in-rails"><span>10.1.1</span> Enabling UUIDs in Rails</a></h3>
<p>Before using UUIDs in your Rails application, you'll need to ensure that your database supports storing them. Additionally, you may need to configure your database adapter to work with UUIDs.</p>
<div class="interstitial note"><p>If you are using a version of PostgreSQL prior to 13, you may still need to enable the pgcrypto extension to access the <code>gen_random_uuid()</code> function.</p></div> <ol> <li>
<p>Rails Configuration</p>
<p>In your Rails application configuration file (<code>config/application.rb</code>), add the following line to configure Rails to generate UUIDs as primary keys by default:</p>
<div class="interstitial code"> <pre data-language="ruby">config.generators do |g|
  g.orm :active_record, primary_key_type: :uuid
end</pre> <button class="clipboard-button" data-clipboard-text="config.generators do |g|
  g.orm :active_record, primary_key_type: :uuid
end
">Copy</button> </div> <p>This setting instructs Rails to use UUIDs as the default primary key type for ActiveRecord models.</p>
</li> <li>
<p>Adding References with UUIDs:</p>
<p>When creating associations between models using references, ensure that you specify the data type as :uuid to maintain consistency with the primary key type. For example:</p>
<div class="interstitial code"> <pre data-language="ruby">create_table :posts, id: :uuid do |t|
  t.references :author, type: :uuid, foreign_key: true
  # Other columns...
  t.timestamps
end</pre> <button class="clipboard-button" data-clipboard-text="create_table :posts, id: :uuid do |t|
  t.references :author, type: :uuid, foreign_key: true
  # Other columns...
  t.timestamps
end
">Copy</button> </div> <p>In this example, the <code>author_id</code> column in the posts table references the <code>id</code> column of the authors table. By explicitly setting the type to <code>:uuid</code>, you ensure that the foreign key column matches the data type of the primary key it references. Adjust the syntax accordingly for other associations and databases.</p>
</li> <li>
<p>Migration Changes</p>
<p>When generating migrations for your models, you'll notice that it specifies the id to be of type <code>uuid:</code></p>
<div class="interstitial code"> <pre data-language="console">$ bin/rails g migration CreateAuthors</pre> <button class="clipboard-button" data-clipboard-text="">Copy</button> </div> <div class="interstitial code"> <pre data-language="ruby">class CreateAuthors &lt; ActiveRecord::Migration[7.2]
  def change
    create_table :authors, id: :uuid do |t|
      t.timestamps
    end
  end
end</pre> <button class="clipboard-button" data-clipboard-text="class CreateAuthors &lt; ActiveRecord::Migration[7.2]
  def change
    create_table :authors, id: :uuid do |t|
      t.timestamps
    end
  end
end
">Copy</button> </div> <p>which results in the following schema:</p>
<div class="interstitial code"> <pre data-language="ruby">create_table "authors", id: :uuid, default: -&gt; { "gen_random_uuid()" }, force: :cascade do |t|
  t.datetime "created_at", precision: 6, null: false
  t.datetime "updated_at", precision: 6, null: false
end</pre> <button class="clipboard-button" data-clipboard-text='create_table "authors", id: :uuid, default: -&gt; { "gen_random_uuid()" }, force: :cascade do |t|
  t.datetime "created_at", precision: 6, null: false
  t.datetime "updated_at", precision: 6, null: false
end
'>Copy</button> </div> <p>In this migration, the <code>id</code> column is defined as a UUID primary key with a default value generated by the <code>gen_random_uuid()</code> function.</p>
</li> </ol> <p>UUIDs are guaranteed to be globally unique across different systems, making them suitable for distributed architectures. They also simplify integration with external systems or APIs by providing a unique identifier that doesn't rely on centralized ID generation, and unlike auto-incrementing integers, UUIDs don't expose information about the total number of records in a table, which can be beneficial for security purposes.</p>
<p>However, UUIDs can also impact performance due to their size and are harder to index. UUIDs will have worse performance for writes and reads compared with integer primary keys and foreign keys.</p>
<div class="interstitial note"><p>Therefore, it's essential to evaluate the trade-offs and consider the specific requirements of your application before deciding to use UUIDs as primary keys.</p></div>
<h2 id="data-migrations"><a class="anchorlink" href="#data-migrations"><span>10.2</span> Data Migrations</a></h2>
<p>Data migrations involve transforming or moving data within your database. In Rails, it is generally not advised to perform data migrations using migration files. Heres why:</p> <ul> <li>
<strong>Separation of Concerns</strong>: Schema changes and data changes have different lifecycles and purposes. Schema changes alter the structure of your database, while data changes alter the content.</li> <li>
<strong>Rollback Complexity</strong>: Data migrations can be hard to rollback safely and predictably.</li> <li>
<strong>Performance</strong>: Data migrations can take a long time to run and may lock your tables, affecting application performance and availability.</li> </ul> <p>Instead, consider using the <a href="https://github.com/Shopify/maintenance_tasks"><code>maintenance_tasks</code></a> gem. This gem provides a framework for creating and managing data migrations and other maintenance tasks in a way that is safe and easy to manage without interfering with schema migrations.</p> <hr> <h2>Feedback</h2> <p> You're encouraged to help improve the quality of this guide. </p> <p> Please contribute if you see any typos or factual errors. To get started, you can read our <a href="https://edgeguides.rubyonrails.org/contributing_to_ruby_on_rails.html#contributing-to-the-rails-documentation">documentation contributions</a> section. </p> <p> You may also find incomplete content or stuff that is not up to date. Please do add any missing documentation for main. Make sure to check <a href="https://edgeguides.rubyonrails.org">Edge Guides</a> first to verify if the issues are already fixed or not on the main branch. Check the <span>Ruby on Rails Guides Guidelines</span> for style and conventions. </p> <p> If for whatever reason you spot something to fix but cannot patch it yourself, please <a href="https://github.com/rails/rails/issues">open an issue</a>. </p> <p>And last but not least, any kind of discussion regarding Ruby on Rails documentation is very welcome on the <a href="https://discuss.rubyonrails.org/c/rubyonrails-docs">official Ruby on Rails Forum</a>. </p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2004&ndash;2021 David Heinemeier Hansson<br>Licensed under the Creative Commons Attribution-ShareAlike 4.0 International License.<br>
    
  </p>
</div>
