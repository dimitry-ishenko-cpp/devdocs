<h1>Getting Started with Engines</h1>
<div class="_simple"> <p>In this guide you will learn about engines and how they can be used to provide additional functionality to their host applications through a clean and very easy-to-use interface.</p>
<p>After reading this guide, you will know:</p> <ul> <li>What makes an engine.</li> <li>How to generate an engine.</li> <li>How to build features for the engine.</li> <li>How to hook the engine into an application.</li> <li>How to override engine functionality in the application.</li> <li>How to avoid loading Rails frameworks with Load and Configuration Hooks.</li> </ul>  <h2 class="chapter">  Chapters </h2> <ol class="chapters"> <li><a href="#what-are-engines-questionmark">What are Engines?</a></li> <li>
<a href="#generating-an-engine">Generating an Engine</a> <ul> <li><a href="#inside-an-engine">Inside an Engine</a></li> </ul>
</li> <li>
<a href="#providing-engine-functionality">Providing Engine Functionality</a> <ul> <li><a href="#generating-an-article-resource">Generating an Article Resource</a></li> <li><a href="#generating-a-comments-resource">Generating a Comments Resource</a></li> </ul>
</li> <li>
<a href="#hooking-into-an-application">Hooking Into an Application</a> <ul> <li><a href="#mounting-the-engine">Mounting the Engine</a></li> <li><a href="#engine-setup">Engine Setup</a></li> <li><a href="#using-a-class-provided-by-the-application">Using a Class Provided by the Application</a></li> <li><a href="#configuring-an-engine">Configuring an Engine</a></li> </ul>
</li> <li>
<a href="#testing-an-engine">Testing an Engine</a> <ul> <li><a href="#functional-tests">Functional Tests</a></li> </ul>
</li> <li>
<a href="#improving-engine-functionality">Improving Engine Functionality</a> <ul> <li><a href="#overriding-models-and-controllers">Overriding Models and Controllers</a></li> <li><a href="#autoloading-and-engines">Autoloading and Engines</a></li> <li><a href="#overriding-views">Overriding Views</a></li> <li><a href="#routes">Routes</a></li> <li><a href="#assets">Assets</a></li> <li><a href="#separate-assets-and-precompiling">Separate Assets and Precompiling</a></li> <li><a href="#other-gem-dependencies">Other Gem Dependencies</a></li> </ul>
</li> </ol>  <hr>  <h1 id="what-are-engines-questionmark"><a class="anchorlink" href="#what-are-engines-questionmark"><span>1</span> What are Engines?</a></h1>
<p>Engines can be considered miniature applications that provide functionality to their host applications. A Rails application is actually just a "supercharged" engine, with the <code>Rails::Application</code> class inheriting a lot of its behavior from <code>Rails::Engine</code>.</p>
<p>Therefore, engines and applications can be thought of as almost the same thing, just with subtle differences, as you'll see throughout this guide. Engines and applications also share a common structure.</p>
<p>Engines are also closely related to plugins. The two share a common <code>lib</code> directory structure, and are both generated using the <code>rails plugin new</code> generator. The difference is that an engine is considered a "full plugin" by Rails (as indicated by the <code>--full</code> option that's passed to the generator command). We'll actually be using the <code>--mountable</code> option here, which includes all the features of <code>--full</code>, and then some. This guide will refer to these "full plugins" simply as "engines" throughout. An engine <strong>can</strong> be a plugin, and a plugin <strong>can</strong> be an engine.</p>
<p>The engine that will be created in this guide will be called "blorgh". This engine will provide blogging functionality to its host applications, allowing for new articles and comments to be created. At the beginning of this guide, you will be working solely within the engine itself, but in later sections you'll see how to hook it into an application.</p>
<p>Engines can also be isolated from their host applications. This means that an application is able to have a path provided by a routing helper such as <code>articles_path</code> and use an engine that also provides a path also called <code>articles_path</code>, and the two would not clash. Along with this, controllers, models and table names are also namespaced. You'll see how to do this later in this guide.</p>
<p>It's important to keep in mind at all times that the application should <strong>always</strong> take precedence over its engines. An application is the object that has final say in what goes on in its environment. The engine should only be enhancing it, rather than changing it drastically.</p>
<p>To see demonstrations of other engines, check out <a href="https://github.com/plataformatec/devise">Devise</a>, an engine that provides authentication for its parent applications, or <a href="https://github.com/thredded/thredded">Thredded</a>, an engine that provides forum functionality. There's also <a href="https://github.com/spree/spree">Spree</a> which provides an e-commerce platform, and <a href="https://github.com/refinery/refinerycms">Refinery CMS</a>, a CMS engine.</p>
<p>Finally, engines would not have been possible without the work of James Adam, Piotr Sarnacki, the Rails Core Team, and a number of other people. If you ever meet them, don't forget to say thanks!</p>
<h1 id="generating-an-engine"><a class="anchorlink" href="#generating-an-engine"><span>2</span> Generating an Engine</a></h1>
<p>To generate an engine, you will need to run the plugin generator and pass it options as appropriate to the need. For the "blorgh" example, you will need to create a "mountable" engine, running this command in a terminal:</p>
<div class="interstitial code"> <pre data-language="console">$ rails plugin new blorgh --mountable</pre> <button class="clipboard-button" data-clipboard-text="rails plugin new blorgh --mountable
">Copy</button> </div> <p>The full list of options for the plugin generator may be seen by typing:</p>
<div class="interstitial code"> <pre data-language="console">$ rails plugin --help</pre> <button class="clipboard-button" data-clipboard-text="rails plugin --help
">Copy</button> </div> <p>The <code>--mountable</code> option tells the generator that you want to create a "mountable" and namespace-isolated engine. This generator will provide the same skeleton structure as would the <code>--full</code> option. The <code>--full</code> option tells the generator that you want to create an engine, including a skeleton structure that provides the following:</p> <ul> <li>An <code>app</code> directory tree</li> <li>
<p>A <code>config/routes.rb</code> file:</p>
<div class="interstitial code"> <pre data-language="ruby">Rails.application.routes.draw do
end</pre> <button class="clipboard-button" data-clipboard-text="Rails.application.routes.draw do
end
">Copy</button> </div>
</li> <li>
<p>A file at <code>lib/blorgh/engine.rb</code>, which is identical in function to a standard Rails application's <code>config/application.rb</code> file:</p>
<div class="interstitial code"> <pre data-language="ruby">module Blorgh
  class Engine &lt; ::Rails::Engine
  end
end</pre> <button class="clipboard-button" data-clipboard-text="module Blorgh
  class Engine &lt; ::Rails::Engine
  end
end
">Copy</button> </div>
</li> </ul> <p>The <code>--mountable</code> option will add to the <code>--full</code> option:</p> <ul> <li>Asset manifest files (<code>blorgh_manifest.js</code> and <code>application.css</code>)</li> <li>A namespaced <code>ApplicationController</code> stub</li> <li>A namespaced <code>ApplicationHelper</code> stub</li> <li>A layout view template for the engine</li> <li>
<p>Namespace isolation to <code>config/routes.rb</code>:</p>
<div class="interstitial code"> <pre data-language="ruby">Blorgh::Engine.routes.draw do
end</pre> <button class="clipboard-button" data-clipboard-text="Blorgh::Engine.routes.draw do
end
">Copy</button> </div>
</li> <li>
<p>Namespace isolation to <code>lib/blorgh/engine.rb</code>:</p>
<div class="interstitial code"> <pre data-language="ruby">module Blorgh
  class Engine &lt; ::Rails::Engine
    isolate_namespace Blorgh
  end
end</pre> <button class="clipboard-button" data-clipboard-text="module Blorgh
  class Engine &lt; ::Rails::Engine
    isolate_namespace Blorgh
  end
end
">Copy</button> </div>
</li> </ul> <p>Additionally, the <code>--mountable</code> option tells the generator to mount the engine inside the dummy testing application located at <code>test/dummy</code> by adding the following to the dummy application's routes file at <code>test/dummy/config/routes.rb</code>:</p>
<div class="interstitial code"> <pre data-language="ruby">mount Blorgh::Engine =&gt; "/blorgh"</pre> <button class="clipboard-button" data-clipboard-text='mount Blorgh::Engine =&gt; "/blorgh"
'>Copy</button> </div> <h2 id="inside-an-engine"><a class="anchorlink" href="#inside-an-engine"><span>2.1</span> Inside an Engine</a></h2>
<h3 id="critical-files"><a class="anchorlink" href="#critical-files"><span>2.1.1</span> Critical Files</a></h3>
<p>At the root of this brand new engine's directory lives a <code>blorgh.gemspec</code> file. When you include the engine into an application later on, you will do so with this line in the Rails application's <code>Gemfile</code>:</p>
<div class="interstitial code"> <pre data-language="ruby">gem "blorgh", path: "engines/blorgh"</pre> <button class="clipboard-button" data-clipboard-text='gem "blorgh", path: "engines/blorgh"
'>Copy</button> </div> <p>Don't forget to run <code>bundle install</code> as usual. By specifying it as a gem within the <code>Gemfile</code>, Bundler will load it as such, parsing this <code>blorgh.gemspec</code> file and requiring a file within the <code>lib</code> directory called <code>lib/blorgh.rb</code>. This file requires the <code>blorgh/engine.rb</code> file (located at <code>lib/blorgh/engine.rb</code>) and defines a base module called <code>Blorgh</code>.</p>
<div class="interstitial code"> <pre data-language="ruby">require "blorgh/engine"

module Blorgh
end</pre> <button class="clipboard-button" data-clipboard-text='require "blorgh/engine"

module Blorgh
end
'>Copy</button> </div> <div class="interstitial info"><p>Some engines choose to use this file to put global configuration options for their engine. It's a relatively good idea, so if you want to offer configuration options, the file where your engine's <code>module</code> is defined is perfect for that. Place the methods inside the module and you'll be good to go.</p></div>
<p>Within <code>lib/blorgh/engine.rb</code> is the base class for the engine:</p>
<div class="interstitial code"> <pre data-language="ruby">module Blorgh
  class Engine &lt; ::Rails::Engine
    isolate_namespace Blorgh
  end
end</pre> <button class="clipboard-button" data-clipboard-text="module Blorgh
  class Engine &lt; ::Rails::Engine
    isolate_namespace Blorgh
  end
end
">Copy</button> </div> <p>By inheriting from the <code>Rails::Engine</code> class, this gem notifies Rails that there's an engine at the specified path, and will correctly mount the engine inside the application, performing tasks such as adding the <code>app</code> directory of the engine to the load path for models, mailers, controllers, and views.</p>
<p>The <code>isolate_namespace</code> method here deserves special notice. This call is responsible for isolating the controllers, models, routes, and other things into their own namespace, away from similar components inside the application. Without this, there is a possibility that the engine's components could "leak" into the application, causing unwanted disruption, or that important engine components could be overridden by similarly named things within the application. One of the examples of such conflicts is helpers. Without calling <code>isolate_namespace</code>, the engine's helpers would be included in an application's controllers.</p>
<div class="interstitial note"><p>It is <strong>highly</strong> recommended that the <code>isolate_namespace</code> line be left within the <code>Engine</code> class definition. Without it, classes generated in an engine <strong>may</strong> conflict with an application.</p></div>
<p>What this isolation of the namespace means is that a model generated by a call to <code>bin/rails generate model</code>, such as <code>bin/rails generate model article</code>, won't be called <code>Article</code>, but instead be namespaced and called <code>Blorgh::Article</code>. In addition, the table for the model is namespaced, becoming <code>blorgh_articles</code>, rather than simply <code>articles</code>. Similar to the model namespacing, a controller called <code>ArticlesController</code> becomes <code>Blorgh::ArticlesController</code> and the views for that controller will not be at <code>app/views/articles</code>, but <code>app/views/blorgh/articles</code> instead. Mailers, jobs and helpers are namespaced as well.</p>
<p>Finally, routes will also be isolated within the engine. This is one of the most important parts about namespacing, and is discussed later in the <a href="#routes">Routes</a> section of this guide.</p>
<h3 id="app-directory"><a class="anchorlink" href="#app-directory"><span>2.1.2</span> <code>app</code> Directory</a></h3>
<p>Inside the <code>app</code> directory are the standard <code>assets</code>, <code>controllers</code>, <code>helpers</code>, <code>jobs</code>, <code>mailers</code>, <code>models</code>, and <code>views</code> directories that you should be familiar with from an application. We'll look more into models in a future section, when we're writing the engine.</p>
<p>Within the <code>app/assets</code> directory, there are the <code>images</code> and <code>stylesheets</code> directories which, again, you should be familiar with due to their similarity to an application. One difference here, however, is that each directory contains a sub-directory with the engine name. Because this engine is going to be namespaced, its assets should be too.</p>
<p>Within the <code>app/controllers</code> directory there is a <code>blorgh</code> directory that contains a file called <code>application_controller.rb</code>. This file will provide any common functionality for the controllers of the engine. The <code>blorgh</code> directory is where the other controllers for the engine will go. By placing them within this namespaced directory, you prevent them from possibly clashing with identically-named controllers within other engines or even within the application.</p>
<div class="interstitial note"><p>The <code>ApplicationController</code> class inside an engine is named just like a Rails application in order to make it easier for you to convert your applications into engines.</p></div>
<p>Just like for <code>app/controllers</code>, you will find a <code>blorgh</code> subdirectory under the <code>app/helpers</code>, <code>app/jobs</code>, <code>app/mailers</code> and <code>app/models</code> directories containing the associated <code>application_*.rb</code> file for gathering common functionalities. By placing your files under this subdirectory and namespacing your objects, you prevent them from possibly clashing with identically-named elements within other engines or even within the application.</p>
<p>Lastly, the <code>app/views</code> directory contains a <code>layouts</code> folder, which contains a file at <code>blorgh/application.html.erb</code>. This file allows you to specify a layout for the engine. If this engine is to be used as a stand-alone engine, then you would add any customization to its layout in this file, rather than the application's <code>app/views/layouts/application.html.erb</code> file.</p>
<p>If you don't want to force a layout on to users of the engine, then you can delete this file and reference a different layout in the controllers of your engine.</p>
<h3 id="bin-directory"><a class="anchorlink" href="#bin-directory"><span>2.1.3</span> <code>bin</code> Directory</a></h3>
<p>This directory contains one file, <code>bin/rails</code>, which enables you to use the <code>rails</code> sub-commands and generators just like you would within an application. This means that you will be able to generate new controllers and models for this engine very easily by running commands like this:</p>
<div class="interstitial code"> <pre data-language="console">$ bin/rails generate model</pre> <button class="clipboard-button" data-clipboard-text="bin/rails generate model
">Copy</button> </div> <p>Keep in mind, of course, that anything generated with these commands inside of an engine that has <code>isolate_namespace</code> in the <code>Engine</code> class will be namespaced.</p>
<h3 id="test-directory"><a class="anchorlink" href="#test-directory"><span>2.1.4</span> <code>test</code> Directory</a></h3>
<p>The <code>test</code> directory is where tests for the engine will go. To test the engine, there is a cut-down version of a Rails application embedded within it at <code>test/dummy</code>. This application will mount the engine in the <code>test/dummy/config/routes.rb</code> file:</p>
<div class="interstitial code"> <pre data-language="ruby">Rails.application.routes.draw do
  mount Blorgh::Engine =&gt; "/blorgh"
end</pre> <button class="clipboard-button" data-clipboard-text='Rails.application.routes.draw do
  mount Blorgh::Engine =&gt; "/blorgh"
end
'>Copy</button> </div> <p>This line mounts the engine at the path <code>/blorgh</code>, which will make it accessible through the application only at that path.</p>
<p>Inside the test directory there is the <code>test/integration</code> directory, where integration tests for the engine should be placed. Other directories can be created in the <code>test</code> directory as well. For example, you may wish to create a <code>test/models</code> directory for your model tests.</p>
<h1 id="providing-engine-functionality"><a class="anchorlink" href="#providing-engine-functionality"><span>3</span> Providing Engine Functionality</a></h1>
<p>The engine that this guide covers provides submitting articles and commenting functionality and follows a similar thread to the <a href="getting_started.html">Getting Started Guide</a>, with some new twists.</p>
<div class="interstitial note"><p>For this section, make sure to run the commands in the root of the <code>blorgh</code> engine's directory.</p></div>
<h2 id="generating-an-article-resource"><a class="anchorlink" href="#generating-an-article-resource"><span>3.1</span> Generating an Article Resource</a></h2>
<p>The first thing to generate for a blog engine is the <code>Article</code> model and related controller. To quickly generate this, you can use the Rails scaffold generator.</p>
<div class="interstitial code"> <pre data-language="console">$ bin/rails generate scaffold article title:string text:text</pre> <button class="clipboard-button" data-clipboard-text="bin/rails generate scaffold article title:string text:text
">Copy</button> </div> <p>This command will output this information:</p>
<div class="interstitial code"> <pre data-language="plaintext">invoke  active_record
create    db/migrate/[timestamp]_create_blorgh_articles.rb
create    app/models/blorgh/article.rb
invoke    test_unit
create      test/models/blorgh/article_test.rb
create      test/fixtures/blorgh/articles.yml
invoke  resource_route
 route    resources :articles
invoke  scaffold_controller
create    app/controllers/blorgh/articles_controller.rb
invoke    erb
create      app/views/blorgh/articles
create      app/views/blorgh/articles/index.html.erb
create      app/views/blorgh/articles/edit.html.erb
create      app/views/blorgh/articles/show.html.erb
create      app/views/blorgh/articles/new.html.erb
create      app/views/blorgh/articles/_form.html.erb
create      app/views/blorgh/articles/_article.html.erb
invoke    resource_route
invoke    test_unit
create      test/controllers/blorgh/articles_controller_test.rb
create      test/system/blorgh/articles_test.rb
invoke    helper
create      app/helpers/blorgh/articles_helper.rb
invoke      test_unit</pre> <button class="clipboard-button" data-clipboard-text="invoke  active_record
create    db/migrate/[timestamp]_create_blorgh_articles.rb
create    app/models/blorgh/article.rb
invoke    test_unit
create      test/models/blorgh/article_test.rb
create      test/fixtures/blorgh/articles.yml
invoke  resource_route
 route    resources :articles
invoke  scaffold_controller
create    app/controllers/blorgh/articles_controller.rb
invoke    erb
create      app/views/blorgh/articles
create      app/views/blorgh/articles/index.html.erb
create      app/views/blorgh/articles/edit.html.erb
create      app/views/blorgh/articles/show.html.erb
create      app/views/blorgh/articles/new.html.erb
create      app/views/blorgh/articles/_form.html.erb
create      app/views/blorgh/articles/_article.html.erb
invoke    resource_route
invoke    test_unit
create      test/controllers/blorgh/articles_controller_test.rb
create      test/system/blorgh/articles_test.rb
invoke    helper
create      app/helpers/blorgh/articles_helper.rb
invoke      test_unit
">Copy</button> </div> <p>The first thing that the scaffold generator does is invoke the <code>active_record</code> generator, which generates a migration and a model for the resource. Note here, however, that the migration is called <code>create_blorgh_articles</code> rather than the usual <code>create_articles</code>. This is due to the <code>isolate_namespace</code> method called in the <code>Blorgh::Engine</code> class's definition. The model here is also namespaced, being placed at <code>app/models/blorgh/article.rb</code> rather than <code>app/models/article.rb</code> due to the <code>isolate_namespace</code> call within the <code>Engine</code> class.</p>
<p>Next, the <code>test_unit</code> generator is invoked for this model, generating a model test at <code>test/models/blorgh/article_test.rb</code> (rather than <code>test/models/article_test.rb</code>) and a fixture at <code>test/fixtures/blorgh/articles.yml</code> (rather than <code>test/fixtures/articles.yml</code>).</p>
<p>After that, a line for the resource is inserted into the <code>config/routes.rb</code> file for the engine. This line is simply <code>resources :articles</code>, turning the <code>config/routes.rb</code> file for the engine into this:</p>
<div class="interstitial code"> <pre data-language="ruby">Blorgh::Engine.routes.draw do
  resources :articles
end</pre> <button class="clipboard-button" data-clipboard-text="Blorgh::Engine.routes.draw do
  resources :articles
end
">Copy</button> </div> <p>Note here that the routes are drawn upon the <code>Blorgh::Engine</code> object rather than the <code>YourApp::Application</code> class. This is so that the engine routes are confined to the engine itself and can be mounted at a specific point as shown in the <a href="#test-directory">test directory</a> section. It also causes the engine's routes to be isolated from those routes that are within the application. The <a href="#routes">Routes</a> section of this guide describes it in detail.</p>
<p>Next, the <code>scaffold_controller</code> generator is invoked, generating a controller called <code>Blorgh::ArticlesController</code> (at <code>app/controllers/blorgh/articles_controller.rb</code>) and its related views at <code>app/views/blorgh/articles</code>. This generator also generates tests for the controller (<code>test/controllers/blorgh/articles_controller_test.rb</code> and <code>test/system/blorgh/articles_test.rb</code>) and a helper (<code>app/helpers/blorgh/articles_helper.rb</code>).</p>
<p>Everything this generator has created is neatly namespaced. The controller's class is defined within the <code>Blorgh</code> module:</p>
<div class="interstitial code"> <pre data-language="ruby">module Blorgh
  class ArticlesController &lt; ApplicationController
    # ...
  end
end</pre> <button class="clipboard-button" data-clipboard-text="module Blorgh
  class ArticlesController &lt; ApplicationController
    # ...
  end
end
">Copy</button> </div> <div class="interstitial note"><p>The <code>ArticlesController</code> class inherits from <code>Blorgh::ApplicationController</code>, not the application's <code>ApplicationController</code>.</p></div>
<p>The helper inside <code>app/helpers/blorgh/articles_helper.rb</code> is also namespaced:</p>
<div class="interstitial code"> <pre data-language="ruby">module Blorgh
  module ArticlesHelper
    # ...
  end
end</pre> <button class="clipboard-button" data-clipboard-text="module Blorgh
  module ArticlesHelper
    # ...
  end
end
">Copy</button> </div> <p>This helps prevent conflicts with any other engine or application that may have an article resource as well.</p>
<p>You can see what the engine has so far by running <code>bin/rails db:migrate</code> at the root of our engine to run the migration generated by the scaffold generator, and then running <code>bin/rails server</code> in <code>test/dummy</code>. When you open <code>http://localhost:3000/blorgh/articles</code> you will see the default scaffold that has been generated. Click around! You've just generated your first engine's first functions.</p>
<p>If you'd rather play around in the console, <code>bin/rails console</code> will also work just like a Rails application. Remember: the <code>Article</code> model is namespaced, so to reference it you must call it as <code>Blorgh::Article</code>.</p>
<div class="interstitial code"> <pre data-language="irb">irb&gt; Blorgh::Article.find(1)
=&gt; #&lt;Blorgh::Article id: 1 ...&gt;</pre> <button class="clipboard-button" data-clipboard-text="Blorgh::Article.find(1)
">Copy</button> </div> <p>One final thing is that the <code>articles</code> resource for this engine should be the root of the engine. Whenever someone goes to the root path where the engine is mounted, they should be shown a list of articles. This can be made to happen if this line is inserted into the <code>config/routes.rb</code> file inside the engine:</p>
<div class="interstitial code"> <pre data-language="ruby">root to: "articles#index"</pre> <button class="clipboard-button" data-clipboard-text='root to: "articles#index"
'>Copy</button> </div> <p>Now people will only need to go to the root of the engine to see all the articles, rather than visiting <code>/articles</code>. This means that instead of <code>http://localhost:3000/blorgh/articles</code>, you only need to go to <code>http://localhost:3000/blorgh</code> now.</p>
<h2 id="generating-a-comments-resource"><a class="anchorlink" href="#generating-a-comments-resource"><span>3.2</span> Generating a Comments Resource</a></h2>
<p>Now that the engine can create new articles, it only makes sense to add commenting functionality as well. To do this, you'll need to generate a comment model, a comment controller, and then modify the articles scaffold to display comments and allow people to create new ones.</p>
<p>From the engine root, run the model generator. Tell it to generate a <code>Comment</code> model, with the related table having two columns: an <code>article_id</code> integer and <code>text</code> text column.</p>
<div class="interstitial code"> <pre data-language="console">$ bin/rails generate model Comment article_id:integer text:text</pre> <button class="clipboard-button" data-clipboard-text="bin/rails generate model Comment article_id:integer text:text
">Copy</button> </div> <p>This will output the following:</p>
<div class="interstitial code"> <pre data-language="plaintext">invoke  active_record
create    db/migrate/[timestamp]_create_blorgh_comments.rb
create    app/models/blorgh/comment.rb
invoke    test_unit
create      test/models/blorgh/comment_test.rb
create      test/fixtures/blorgh/comments.yml</pre> <button class="clipboard-button" data-clipboard-text="invoke  active_record
create    db/migrate/[timestamp]_create_blorgh_comments.rb
create    app/models/blorgh/comment.rb
invoke    test_unit
create      test/models/blorgh/comment_test.rb
create      test/fixtures/blorgh/comments.yml
">Copy</button> </div> <p>This generator call will generate just the necessary model files it needs, namespacing the files under a <code>blorgh</code> directory and creating a model class called <code>Blorgh::Comment</code>. Now run the migration to create our blorgh_comments table:</p>
<div class="interstitial code"> <pre data-language="console">$ bin/rails db:migrate</pre> <button class="clipboard-button" data-clipboard-text="bin/rails db:migrate
">Copy</button> </div> <p>To show the comments on an article, edit <code>app/views/blorgh/articles/show.html.erb</code> and add this line before the "Edit" link:</p>
<div class="interstitial code"> <pre data-language="erb">&lt;h3&gt;Comments&lt;/h3&gt;
&lt;%= render @article.comments %&gt;</pre> <button class="clipboard-button" data-clipboard-text="&lt;h3&gt;Comments&lt;/h3&gt;
&lt;%= render @article.comments %&gt;
">Copy</button> </div> <p>This line will require there to be a <code>has_many</code> association for comments defined on the <code>Blorgh::Article</code> model, which there isn't right now. To define one, open <code>app/models/blorgh/article.rb</code> and add this line into the model:</p>
<div class="interstitial code"> <pre data-language="ruby">has_many :comments</pre> <button class="clipboard-button" data-clipboard-text="has_many :comments
">Copy</button> </div> <p>Turning the model into this:</p>
<div class="interstitial code"> <pre data-language="ruby">module Blorgh
  class Article &lt; ApplicationRecord
    has_many :comments
  end
end</pre> <button class="clipboard-button" data-clipboard-text="module Blorgh
  class Article &lt; ApplicationRecord
    has_many :comments
  end
end
">Copy</button> </div> <div class="interstitial note"><p>Because the <code>has_many</code> is defined inside a class that is inside the <code>Blorgh</code> module, Rails will know that you want to use the <code>Blorgh::Comment</code> model for these objects, so there's no need to specify that using the <code>:class_name</code> option here.</p></div>
<p>Next, there needs to be a form so that comments can be created on an article. To add this, put this line underneath the call to <code>render @article.comments</code> in <code>app/views/blorgh/articles/show.html.erb</code>:</p>
<div class="interstitial code"> <pre data-language="erb">&lt;%= render "blorgh/comments/form" %&gt;</pre> <button class="clipboard-button" data-clipboard-text='&lt;%= render "blorgh/comments/form" %&gt;
'>Copy</button> </div> <p>Next, the partial that this line will render needs to exist. Create a new directory at <code>app/views/blorgh/comments</code> and in it a new file called <code>_form.html.erb</code> which has this content to create the required partial:</p>
<div class="interstitial code"> <pre data-language="erb">&lt;h3&gt;New comment&lt;/h3&gt;
&lt;%= form_with model: [@article, @article.comments.build] do |form| %&gt;
  &lt;p&gt;
    &lt;%= form.label :text %&gt;&lt;br&gt;
    &lt;%= form.text_area :text %&gt;
  &lt;/p&gt;
  &lt;%= form.submit %&gt;
&lt;% end %&gt;</pre> <button class="clipboard-button" data-clipboard-text="&lt;h3&gt;New comment&lt;/h3&gt;
&lt;%= form_with model: [@article, @article.comments.build] do |form| %&gt;
  &lt;p&gt;
    &lt;%= form.label :text %&gt;&lt;br&gt;
    &lt;%= form.text_area :text %&gt;
  &lt;/p&gt;
  &lt;%= form.submit %&gt;
&lt;% end %&gt;
">Copy</button> </div> <p>When this form is submitted, it is going to attempt to perform a <code>POST</code> request to a route of <code>/articles/:article_id/comments</code> within the engine. This route doesn't exist at the moment, but can be created by changing the <code>resources :articles</code> line inside <code>config/routes.rb</code> into these lines:</p>
<div class="interstitial code"> <pre data-language="ruby">resources :articles do
  resources :comments
end</pre> <button class="clipboard-button" data-clipboard-text="resources :articles do
  resources :comments
end
">Copy</button> </div> <p>This creates a nested route for the comments, which is what the form requires.</p>
<p>The route now exists, but the controller that this route goes to does not. To create it, run this command from the engine root:</p>
<div class="interstitial code"> <pre data-language="console">$ bin/rails generate controller comments</pre> <button class="clipboard-button" data-clipboard-text="bin/rails generate controller comments
">Copy</button> </div> <p>This will generate the following things:</p>
<div class="interstitial code"> <pre data-language="plaintext">create  app/controllers/blorgh/comments_controller.rb
invoke  erb
 exist    app/views/blorgh/comments
invoke  test_unit
create    test/controllers/blorgh/comments_controller_test.rb
invoke  helper
create    app/helpers/blorgh/comments_helper.rb
invoke    test_unit</pre> <button class="clipboard-button" data-clipboard-text="create  app/controllers/blorgh/comments_controller.rb
invoke  erb
 exist    app/views/blorgh/comments
invoke  test_unit
create    test/controllers/blorgh/comments_controller_test.rb
invoke  helper
create    app/helpers/blorgh/comments_helper.rb
invoke    test_unit
">Copy</button> </div> <p>The form will be making a <code>POST</code> request to <code>/articles/:article_id/comments</code>, which will correspond with the <code>create</code> action in <code>Blorgh::CommentsController</code>. This action needs to be created, which can be done by putting the following lines inside the class definition in <code>app/controllers/blorgh/comments_controller.rb</code>:</p>
<div class="interstitial code"> <pre data-language="ruby">def create
  @article = Article.find(params[:article_id])
  @comment = @article.comments.create(comment_params)
  flash[:notice] = "Comment has been created!"
  redirect_to articles_path
end

private
  def comment_params
    params.require(:comment).permit(:text)
  end</pre> <button class="clipboard-button" data-clipboard-text='def create
  @article = Article.find(params[:article_id])
  @comment = @article.comments.create(comment_params)
  flash[:notice] = "Comment has been created!"
  redirect_to articles_path
end

private
  def comment_params
    params.require(:comment).permit(:text)
  end
'>Copy</button> </div> <p>This is the final step required to get the new comment form working. Displaying the comments, however, is not quite right yet. If you were to create a comment right now, you would see this error:</p>
<div class="interstitial code"> <pre data-language="plaintext">Missing partial blorgh/comments/_comment with {:handlers=&gt;[:erb, :builder],
:formats=&gt;[:html], :locale=&gt;[:en, :en]}. Searched in:   *
"/Users/ryan/Sites/side_projects/blorgh/test/dummy/app/views"   *
"/Users/ryan/Sites/side_projects/blorgh/app/views"</pre> <button class="clipboard-button" data-clipboard-text='Missing partial blorgh/comments/_comment with {:handlers=&gt;[:erb, :builder],
:formats=&gt;[:html], :locale=&gt;[:en, :en]}. Searched in:   *
"/Users/ryan/Sites/side_projects/blorgh/test/dummy/app/views"   *
"/Users/ryan/Sites/side_projects/blorgh/app/views"
'>Copy</button> </div> <p>The engine is unable to find the partial required for rendering the comments. Rails looks first in the application's (<code>test/dummy</code>) <code>app/views</code> directory and then in the engine's <code>app/views</code> directory. When it can't find it, it will throw this error. The engine knows to look for <code>blorgh/comments/_comment</code> because the model object it is receiving is from the <code>Blorgh::Comment</code> class.</p>
<p>This partial will be responsible for rendering just the comment text, for now. Create a new file at <code>app/views/blorgh/comments/_comment.html.erb</code> and put this line inside it:</p>
<div class="interstitial code"> <pre data-language="erb">&lt;%= comment_counter + 1 %&gt;. &lt;%= comment.text %&gt;</pre> <button class="clipboard-button" data-clipboard-text="&lt;%= comment_counter + 1 %&gt;. &lt;%= comment.text %&gt;
">Copy</button> </div> <p>The <code>comment_counter</code> local variable is given to us by the <code>&lt;%= render
@article.comments %&gt;</code> call, which will define it automatically and increment the counter as it iterates through each comment. It's used in this example to display a small number next to each comment when it's created.</p>
<p>That completes the comment function of the blogging engine. Now it's time to use it within an application.</p>
<h1 id="hooking-into-an-application"><a class="anchorlink" href="#hooking-into-an-application"><span>4</span> Hooking Into an Application</a></h1>
<p>Using an engine within an application is very easy. This section covers how to mount the engine into an application and the initial setup required, as well as linking the engine to a <code>User</code> class provided by the application to provide ownership for articles and comments within the engine.</p>
<h2 id="mounting-the-engine"><a class="anchorlink" href="#mounting-the-engine"><span>4.1</span> Mounting the Engine</a></h2>
<p>First, the engine needs to be specified inside the application's <code>Gemfile</code>. If there isn't an application handy to test this out in, generate one using the <code>rails new</code> command outside of the engine directory like this:</p>
<div class="interstitial code"> <pre data-language="console">$ rails new unicorn</pre> <button class="clipboard-button" data-clipboard-text="rails new unicorn
">Copy</button> </div> <p>Usually, specifying the engine inside the <code>Gemfile</code> would be done by specifying it as a normal, everyday gem.</p>
<div class="interstitial code"> <pre data-language="ruby">gem "devise"</pre> <button class="clipboard-button" data-clipboard-text='gem "devise"
'>Copy</button> </div> <p>However, because you are developing the <code>blorgh</code> engine on your local machine, you will need to specify the <code>:path</code> option in your <code>Gemfile</code>:</p>
<div class="interstitial code"> <pre data-language="ruby">gem "blorgh", path: "engines/blorgh"</pre> <button class="clipboard-button" data-clipboard-text='gem "blorgh", path: "engines/blorgh"
'>Copy</button> </div> <p>Then run <code>bundle</code> to install the gem.</p>
<p>As described earlier, by placing the gem in the <code>Gemfile</code> it will be loaded when Rails is loaded. It will first require <code>lib/blorgh.rb</code> from the engine, then <code>lib/blorgh/engine.rb</code>, which is the file that defines the major pieces of functionality for the engine.</p>
<p>To make the engine's functionality accessible from within an application, it needs to be mounted in that application's <code>config/routes.rb</code> file:</p>
<div class="interstitial code"> <pre data-language="ruby">mount Blorgh::Engine, at: "/blog"</pre> <button class="clipboard-button" data-clipboard-text='mount Blorgh::Engine, at: "/blog"
'>Copy</button> </div> <p>This line will mount the engine at <code>/blog</code> in the application. Making it accessible at <code>http://localhost:3000/blog</code> when the application runs with <code>bin/rails
server</code>.</p>
<div class="interstitial note"><p>Other engines, such as Devise, handle this a little differently by making you specify custom helpers (such as <code>devise_for</code>) in the routes. These helpers do exactly the same thing, mounting pieces of the engines's functionality at a pre-defined path which may be customizable.</p></div>
<h2 id="engine-setup"><a class="anchorlink" href="#engine-setup"><span>4.2</span> Engine Setup</a></h2>
<p>The engine contains migrations for the <code>blorgh_articles</code> and <code>blorgh_comments</code> table which need to be created in the application's database so that the engine's models can query them correctly. To copy these migrations into the application run the following command from the application's root:</p>
<div class="interstitial code"> <pre data-language="console">$ bin/rails blorgh:install:migrations</pre> <button class="clipboard-button" data-clipboard-text="bin/rails blorgh:install:migrations
">Copy</button> </div> <p>If you have multiple engines that need migrations copied over, use <code>railties:install:migrations</code> instead:</p>
<div class="interstitial code"> <pre data-language="console">$ bin/rails railties:install:migrations</pre> <button class="clipboard-button" data-clipboard-text="bin/rails railties:install:migrations
">Copy</button> </div> <p>You can specify a custom path in the source engine for the migrations by specifying MIGRATIONS_PATH.</p>
<div class="interstitial code"> <pre data-language="console">$ bin/rails railties:install:migrations MIGRATIONS_PATH=db_blourgh</pre> <button class="clipboard-button" data-clipboard-text="bin/rails railties:install:migrations MIGRATIONS_PATH=db_blourgh
">Copy</button> </div> <p>If you have multiple databases you can also specify the target database by specifying DATABASE.</p>
<div class="interstitial code"> <pre data-language="console">$ bin/rails railties:install:migrations DATABASE=animals</pre> <button class="clipboard-button" data-clipboard-text="bin/rails railties:install:migrations DATABASE=animals
">Copy</button> </div> <p>This command, when run for the first time, will copy over all the migrations from the engine. When run the next time, it will only copy over migrations that haven't been copied over already. The first run for this command will output something such as this:</p>
<div class="interstitial code"> <pre data-language="plaintext">Copied migration [timestamp_1]_create_blorgh_articles.blorgh.rb from blorgh
Copied migration [timestamp_2]_create_blorgh_comments.blorgh.rb from blorgh</pre> <button class="clipboard-button" data-clipboard-text="Copied migration [timestamp_1]_create_blorgh_articles.blorgh.rb from blorgh
Copied migration [timestamp_2]_create_blorgh_comments.blorgh.rb from blorgh
">Copy</button> </div> <p>The first timestamp (<code>[timestamp_1]</code>) will be the current time, and the second timestamp (<code>[timestamp_2]</code>) will be the current time plus a second. The reason for this is so that the migrations for the engine are run after any existing migrations in the application.</p>
<p>To run these migrations within the context of the application, simply run <code>bin/rails
db:migrate</code>. When accessing the engine through <code>http://localhost:3000/blog</code>, the articles will be empty. This is because the table created inside the application is different from the one created within the engine. Go ahead, play around with the newly mounted engine. You'll find that it's the same as when it was only an engine.</p>
<p>If you would like to run migrations only from one engine, you can do it by specifying <code>SCOPE</code>:</p>
<div class="interstitial code"> <pre data-language="console">$ bin/rails db:migrate SCOPE=blorgh</pre> <button class="clipboard-button" data-clipboard-text="bin/rails db:migrate SCOPE=blorgh
">Copy</button> </div> <p>This may be useful if you want to revert engine's migrations before removing it. To revert all migrations from blorgh engine you can run code such as:</p>
<div class="interstitial code"> <pre data-language="console">$ bin/rails db:migrate SCOPE=blorgh VERSION=0</pre> <button class="clipboard-button" data-clipboard-text="bin/rails db:migrate SCOPE=blorgh VERSION=0
">Copy</button> </div> <h2 id="using-a-class-provided-by-the-application"><a class="anchorlink" href="#using-a-class-provided-by-the-application"><span>4.3</span> Using a Class Provided by the Application</a></h2>
<h3 id="using-a-model-provided-by-the-application"><a class="anchorlink" href="#using-a-model-provided-by-the-application"><span>4.3.1</span> Using a Model Provided by the Application</a></h3>
<p>When an engine is created, it may want to use specific classes from an application to provide links between the pieces of the engine and the pieces of the application. In the case of the <code>blorgh</code> engine, making articles and comments have authors would make a lot of sense.</p>
<p>A typical application might have a <code>User</code> class that would be used to represent authors for an article or a comment. But there could be a case where the application calls this class something different, such as <code>Person</code>. For this reason, the engine should not hardcode associations specifically for a <code>User</code> class.</p>
<p>To keep it simple in this case, the application will have a class called <code>User</code> that represents the users of the application (we'll get into making this configurable further on). It can be generated using this command inside the application:</p>
<div class="interstitial code"> <pre data-language="console">$ bin/rails generate model user name:string</pre> <button class="clipboard-button" data-clipboard-text="bin/rails generate model user name:string
">Copy</button> </div> <p>The <code>bin/rails db:migrate</code> command needs to be run here to ensure that our application has the <code>users</code> table for future use.</p>
<p>Also, to keep it simple, the articles form will have a new text field called <code>author_name</code>, where users can elect to put their name. The engine will then take this name and either create a new <code>User</code> object from it, or find one that already has that name. The engine will then associate the article with the found or created <code>User</code> object.</p>
<p>First, the <code>author_name</code> text field needs to be added to the <code>app/views/blorgh/articles/_form.html.erb</code> partial inside the engine. This can be added above the <code>title</code> field with this code:</p>
<div class="interstitial code"> <pre data-language="erb">&lt;div class="field"&gt;
  &lt;%= form.label :author_name %&gt;&lt;br&gt;
  &lt;%= form.text_field :author_name %&gt;
&lt;/div&gt;</pre> <button class="clipboard-button" data-clipboard-text='&lt;div class="field"&gt;
  &lt;%= form.label :author_name %&gt;&lt;br&gt;
  &lt;%= form.text_field :author_name %&gt;
&lt;/div&gt;
'>Copy</button> </div> <p>Next, we need to update our <code>Blorgh::ArticlesController#article_params</code> method to permit the new form parameter:</p>
<div class="interstitial code"> <pre data-language="ruby">def article_params
  params.require(:article).permit(:title, :text, :author_name)
end</pre> <button class="clipboard-button" data-clipboard-text="def article_params
  params.require(:article).permit(:title, :text, :author_name)
end
">Copy</button> </div> <p>The <code>Blorgh::Article</code> model should then have some code to convert the <code>author_name</code> field into an actual <code>User</code> object and associate it as that article's <code>author</code> before the article is saved. It will also need to have an <code>attr_accessor</code> set up for this field, so that the setter and getter methods are defined for it.</p>
<p>To do all this, you'll need to add the <code>attr_accessor</code> for <code>author_name</code>, the association for the author and the <code>before_validation</code> call into <code>app/models/blorgh/article.rb</code>. The <code>author</code> association will be hard-coded to the <code>User</code> class for the time being.</p>
<div class="interstitial code"> <pre data-language="ruby">attr_accessor :author_name
belongs_to :author, class_name: "User"

before_validation :set_author

private
  def set_author
    self.author = User.find_or_create_by(name: author_name)
  end</pre> <button class="clipboard-button" data-clipboard-text='attr_accessor :author_name
belongs_to :author, class_name: "User"

before_validation :set_author

private
  def set_author
    self.author = User.find_or_create_by(name: author_name)
  end
'>Copy</button> </div> <p>By representing the <code>author</code> association's object with the <code>User</code> class, a link is established between the engine and the application. There needs to be a way of associating the records in the <code>blorgh_articles</code> table with the records in the <code>users</code> table. Because the association is called <code>author</code>, there should be an <code>author_id</code> column added to the <code>blorgh_articles</code> table.</p>
<p>To generate this new column, run this command within the engine:</p>
<div class="interstitial code"> <pre data-language="console">$ bin/rails generate migration add_author_id_to_blorgh_articles author_id:integer</pre> <button class="clipboard-button" data-clipboard-text="bin/rails generate migration add_author_id_to_blorgh_articles author_id:integer
">Copy</button> </div> <div class="interstitial note"><p>Due to the migration's name and the column specification after it, Rails will automatically know that you want to add a column to a specific table and write that into the migration for you. You don't need to tell it any more than this.</p></div>
<p>This migration will need to be run on the application. To do that, it must first be copied using this command:</p>
<div class="interstitial code"> <pre data-language="console">$ bin/rails blorgh:install:migrations</pre> <button class="clipboard-button" data-clipboard-text="bin/rails blorgh:install:migrations
">Copy</button> </div> <p>Notice that only <em>one</em> migration was copied over here. This is because the first two migrations were copied over the first time this command was run.</p>
<div class="interstitial code"> <pre data-language="plaintext">NOTE Migration [timestamp]_create_blorgh_articles.blorgh.rb from blorgh has been skipped. Migration with the same name already exists.
NOTE Migration [timestamp]_create_blorgh_comments.blorgh.rb from blorgh has been skipped. Migration with the same name already exists.
Copied migration [timestamp]_add_author_id_to_blorgh_articles.blorgh.rb from blorgh</pre> <button class="clipboard-button" data-clipboard-text="NOTE Migration [timestamp]_create_blorgh_articles.blorgh.rb from blorgh has been skipped. Migration with the same name already exists.
NOTE Migration [timestamp]_create_blorgh_comments.blorgh.rb from blorgh has been skipped. Migration with the same name already exists.
Copied migration [timestamp]_add_author_id_to_blorgh_articles.blorgh.rb from blorgh
">Copy</button> </div> <p>Run the migration using:</p>
<div class="interstitial code"> <pre data-language="console">$ bin/rails db:migrate</pre> <button class="clipboard-button" data-clipboard-text="bin/rails db:migrate
">Copy</button> </div> <p>Now with all the pieces in place, an action will take place that will associate an author - represented by a record in the <code>users</code> table - with an article, represented by the <code>blorgh_articles</code> table from the engine.</p>
<p>Finally, the author's name should be displayed on the article's page. Add this code above the "Title" output inside <code>app/views/blorgh/articles/_article.html.erb</code>:</p>
<div class="interstitial code"> <pre data-language="erb">&lt;p&gt;
  &lt;strong&gt;Author:&lt;/strong&gt;
  &lt;%= article.author.name %&gt;
&lt;/p&gt;</pre> <button class="clipboard-button" data-clipboard-text="&lt;p&gt;
  &lt;strong&gt;Author:&lt;/strong&gt;
  &lt;%= article.author.name %&gt;
&lt;/p&gt;
">Copy</button> </div> <h3 id="using-a-controller-provided-by-the-application"><a class="anchorlink" href="#using-a-controller-provided-by-the-application"><span>4.3.2</span> Using a Controller Provided by the Application</a></h3>
<p>Because Rails controllers generally share code for things like authentication and accessing session variables, they inherit from <code>ApplicationController</code> by default. Rails engines, however are scoped to run independently from the main application, so each engine gets a scoped <code>ApplicationController</code>. This namespace prevents code collisions, but often engine controllers need to access methods in the main application's <code>ApplicationController</code>. An easy way to provide this access is to change the engine's scoped <code>ApplicationController</code> to inherit from the main application's <code>ApplicationController</code>. For our Blorgh engine this would be done by changing <code>app/controllers/blorgh/application_controller.rb</code> to look like:</p>
<div class="interstitial code"> <pre data-language="ruby">module Blorgh
  class ApplicationController &lt; ::ApplicationController
  end
end</pre> <button class="clipboard-button" data-clipboard-text="module Blorgh
  class ApplicationController &lt; ::ApplicationController
  end
end
">Copy</button> </div> <p>By default, the engine's controllers inherit from <code>Blorgh::ApplicationController</code>. So, after making this change they will have access to the main application's <code>ApplicationController</code>, as though they were part of the main application.</p>
<p>This change does require that the engine is run from a Rails application that has an <code>ApplicationController</code>.</p>
<h2 id="configuring-an-engine"><a class="anchorlink" href="#configuring-an-engine"><span>4.4</span> Configuring an Engine</a></h2>
<p>This section covers how to make the <code>User</code> class configurable, followed by general configuration tips for the engine.</p>
<h3 id="setting-configuration-settings-in-the-application"><a class="anchorlink" href="#setting-configuration-settings-in-the-application"><span>4.4.1</span> Setting Configuration Settings in the Application</a></h3>
<p>The next step is to make the class that represents a <code>User</code> in the application customizable for the engine. This is because that class may not always be <code>User</code>, as previously explained. To make this setting customizable, the engine will have a configuration setting called <code>author_class</code> that will be used to specify which class represents users inside the application.</p>
<p>To define this configuration setting, you should use a <code>mattr_accessor</code> inside the <code>Blorgh</code> module for the engine. Add this line to <code>lib/blorgh.rb</code> inside the engine:</p>
<div class="interstitial code"> <pre data-language="ruby">mattr_accessor :author_class</pre> <button class="clipboard-button" data-clipboard-text="mattr_accessor :author_class
">Copy</button> </div> <p>This method works like its siblings, <code>attr_accessor</code> and <code>cattr_accessor</code>, but provides a setter and getter method on the module with the specified name. To use it, it must be referenced using <code>Blorgh.author_class</code>.</p>
<p>The next step is to switch the <code>Blorgh::Article</code> model over to this new setting. Change the <code>belongs_to</code> association inside this model (<code>app/models/blorgh/article.rb</code>) to this:</p>
<div class="interstitial code"> <pre data-language="ruby">belongs_to :author, class_name: Blorgh.author_class</pre> <button class="clipboard-button" data-clipboard-text="belongs_to :author, class_name: Blorgh.author_class
">Copy</button> </div> <p>The <code>set_author</code> method in the <code>Blorgh::Article</code> model should also use this class:</p>
<div class="interstitial code"> <pre data-language="ruby">self.author = Blorgh.author_class.constantize.find_or_create_by(name: author_name)</pre> <button class="clipboard-button" data-clipboard-text="self.author = Blorgh.author_class.constantize.find_or_create_by(name: author_name)
">Copy</button> </div> <p>To save having to call <code>constantize</code> on the <code>author_class</code> result all the time, you could instead just override the <code>author_class</code> getter method inside the <code>Blorgh</code> module in the <code>lib/blorgh.rb</code> file to always call <code>constantize</code> on the saved value before returning the result:</p>
<div class="interstitial code"> <pre data-language="ruby">def self.author_class
  @@author_class.constantize
end</pre> <button class="clipboard-button" data-clipboard-text="def self.author_class
  @@author_class.constantize
end
">Copy</button> </div> <p>This would then turn the above code for <code>set_author</code> into this:</p>
<div class="interstitial code"> <pre data-language="ruby">self.author = Blorgh.author_class.find_or_create_by(name: author_name)</pre> <button class="clipboard-button" data-clipboard-text="self.author = Blorgh.author_class.find_or_create_by(name: author_name)
">Copy</button> </div> <p>Resulting in something a little shorter, and more implicit in its behavior. The <code>author_class</code> method should always return a <code>Class</code> object.</p>
<p>Since we changed the <code>author_class</code> method to return a <code>Class</code> instead of a <code>String</code>, we must also modify our <code>belongs_to</code> definition in the <code>Blorgh::Article</code> model:</p>
<div class="interstitial code"> <pre data-language="ruby">belongs_to :author, class_name: Blorgh.author_class.to_s</pre> <button class="clipboard-button" data-clipboard-text="belongs_to :author, class_name: Blorgh.author_class.to_s
">Copy</button> </div> <p>To set this configuration setting within the application, an initializer should be used. By using an initializer, the configuration will be set up before the application starts and calls the engine's models, which may depend on this configuration setting existing.</p>
<p>Create a new initializer at <code>config/initializers/blorgh.rb</code> inside the application where the <code>blorgh</code> engine is installed and put this content in it:</p>
<div class="interstitial code"> <pre data-language="ruby">Blorgh.author_class = "User"</pre> <button class="clipboard-button" data-clipboard-text='Blorgh.author_class = "User"
'>Copy</button> </div> <div class="interstitial warning"><p>It's very important here to use the <code>String</code> version of the class, rather than the class itself. If you were to use the class, Rails would attempt to load that class and then reference the related table. This could lead to problems if the table didn't already exist. Therefore, a <code>String</code> should be used and then converted to a class using <code>constantize</code> in the engine later on.</p></div>
<p>Go ahead and try to create a new article. You will see that it works exactly in the same way as before, except this time the engine is using the configuration setting in <code>config/initializers/blorgh.rb</code> to learn what the class is.</p>
<p>There are now no strict dependencies on what the class is, only what the API for the class must be. The engine simply requires this class to define a <code>find_or_create_by</code> method which returns an object of that class, to be associated with an article when it's created. This object, of course, should have some sort of identifier by which it can be referenced.</p>
<h3 id="general-engine-configuration"><a class="anchorlink" href="#general-engine-configuration"><span>4.4.2</span> General Engine Configuration</a></h3>
<p>Within an engine, there may come a time where you wish to use things such as initializers, internationalization, or other configuration options. The great news is that these things are entirely possible, because a Rails engine shares much the same functionality as a Rails application. In fact, a Rails application's functionality is actually a superset of what is provided by engines!</p>
<p>If you wish to use an initializer - code that should run before the engine is loaded - the place for it is the <code>config/initializers</code> folder. This directory's functionality is explained in the <a href="configuring.html#initializers">Initializers section</a> of the Configuring guide, and works precisely the same way as the <code>config/initializers</code> directory inside an application. The same thing goes if you want to use a standard initializer.</p>
<p>For locales, simply place the locale files in the <code>config/locales</code> directory, just like you would in an application.</p>
<h1 id="testing-an-engine"><a class="anchorlink" href="#testing-an-engine"><span>5</span> Testing an Engine</a></h1>
<p>When an engine is generated, there is a smaller dummy application created inside it at <code>test/dummy</code>. This application is used as a mounting point for the engine, to make testing the engine extremely simple. You may extend this application by generating controllers, models, or views from within the directory, and then use those to test your engine.</p>
<p>The <code>test</code> directory should be treated like a typical Rails testing environment, allowing for unit, functional, and integration tests.</p>
<h2 id="functional-tests"><a class="anchorlink" href="#functional-tests"><span>5.1</span> Functional Tests</a></h2>
<p>A matter worth taking into consideration when writing functional tests is that the tests are going to be running on an application - the <code>test/dummy</code> application - rather than your engine. This is due to the setup of the testing environment; an engine needs an application as a host for testing its main functionality, especially controllers. This means that if you were to make a typical <code>GET</code> to a controller in a controller's functional test like this:</p>
<div class="interstitial code"> <pre data-language="ruby">module Blorgh
  class FooControllerTest &lt; ActionDispatch::IntegrationTest
    include Engine.routes.url_helpers

    def test_index
      get foos_url
      # ...
    end
  end
end</pre> <button class="clipboard-button" data-clipboard-text="module Blorgh
  class FooControllerTest &lt; ActionDispatch::IntegrationTest
    include Engine.routes.url_helpers

    def test_index
      get foos_url
      # ...
    end
  end
end
">Copy</button> </div> <p>It may not function correctly. This is because the application doesn't know how to route these requests to the engine unless you explicitly tell it <strong>how</strong>. To do this, you must set the <code>@routes</code> instance variable to the engine's route set in your setup code:</p>
<div class="interstitial code"> <pre data-language="ruby">module Blorgh
  class FooControllerTest &lt; ActionDispatch::IntegrationTest
    include Engine.routes.url_helpers

    setup do
      @routes = Engine.routes
    end

    def test_index
      get foos_url
      # ...
    end
  end
end</pre> <button class="clipboard-button" data-clipboard-text="module Blorgh
  class FooControllerTest &lt; ActionDispatch::IntegrationTest
    include Engine.routes.url_helpers

    setup do
      @routes = Engine.routes
    end

    def test_index
      get foos_url
      # ...
    end
  end
end
">Copy</button> </div> <p>This tells the application that you still want to perform a <code>GET</code> request to the <code>index</code> action of this controller, but you want to use the engine's route to get there, rather than the application's one.</p>
<p>This also ensures that the engine's URL helpers will work as expected in your tests.</p>
<h1 id="improving-engine-functionality"><a class="anchorlink" href="#improving-engine-functionality"><span>6</span> Improving Engine Functionality</a></h1>
<p>This section explains how to add and/or override engine MVC functionality in the main Rails application.</p>
<h2 id="overriding-models-and-controllers"><a class="anchorlink" href="#overriding-models-and-controllers"><span>6.1</span> Overriding Models and Controllers</a></h2>
<p>Engine models and controllers can be reopened by the parent application to extend or decorate them.</p>
<p>Overrides may be organized in a dedicated directory <code>app/overrides</code>, ignored by the autoloader, and preloaded in a <code>to_prepare</code> callback:</p>
<div class="interstitial code"> <pre data-language="ruby"># config/application.rb
module MyApp
  class Application &lt; Rails::Application
    # ...

    overrides = "#{Rails.root}/app/overrides"
    Rails.autoloaders.main.ignore(overrides)

    config.to_prepare do
      Dir.glob("#{overrides}/**/*_override.rb").sort.each do |override|
        load override
      end
    end
  end
end</pre> <button class="clipboard-button" data-clipboard-text='module MyApp
  class Application &lt; Rails::Application
    # ...

    overrides = "#{Rails.root}/app/overrides"
    Rails.autoloaders.main.ignore(overrides)

    config.to_prepare do
      Dir.glob("#{overrides}/**/*_override.rb").sort.each do |override|
        load override
      end
    end
  end
end
'>Copy</button> </div> <h3 id="reopening-existing-classes-using-class-eval"><a class="anchorlink" href="#reopening-existing-classes-using-class-eval"><span>6.1.1</span> Reopening Existing Classes Using <code>class_eval</code></a></h3>
<p>For example, in order to override the engine model</p>
<div class="interstitial code"> <pre data-language="ruby"># Blorgh/app/models/blorgh/article.rb
module Blorgh
  class Article &lt; ApplicationRecord
    # ...
  end
end</pre> <button class="clipboard-button" data-clipboard-text="# Blorgh/app/models/blorgh/article.rb
module Blorgh
  class Article &lt; ApplicationRecord
    # ...
  end
end
">Copy</button> </div> <p>you just create a file that <em>reopens</em> that class:</p>
<div class="interstitial code"> <pre data-language="ruby"># MyApp/app/overrides/models/blorgh/article_override.rb
Blorgh::Article.class_eval do
  # ...
end</pre> <button class="clipboard-button" data-clipboard-text="# MyApp/app/overrides/models/blorgh/article_override.rb
Blorgh::Article.class_eval do
  # ...
end
">Copy</button> </div> <p>It is very important that the override <em>reopens</em> the class or module. Using the <code>class</code> or <code>module</code> keywords would define them if they were not already in memory, which would be incorrect because the definition lives in the engine. Using <code>class_eval</code> as shown above ensures you are reopening.</p>
<h3 id="reopening-existing-classes-using-activesupport-concern"><a class="anchorlink" href="#reopening-existing-classes-using-activesupport-concern"><span>6.1.2</span> Reopening Existing Classes Using ActiveSupport::Concern</a></h3>
<p>Using <code>Class#class_eval</code> is great for simple adjustments, but for more complex class modifications, you might want to consider using <a href="https://edgeapi.rubyonrails.org/classes/ActiveSupport/Concern.html"><code>ActiveSupport::Concern</code></a>. ActiveSupport::Concern manages load order of interlinked dependent modules and classes at run time allowing you to significantly modularize your code.</p>
<p><strong>Adding</strong> <code>Article#time_since_created</code> and <strong>Overriding</strong> <code>Article#summary</code>:</p>
<div class="interstitial code"> <pre data-language="ruby"># MyApp/app/models/blorgh/article.rb

class Blorgh::Article &lt; ApplicationRecord
  include Blorgh::Concerns::Models::Article

  def time_since_created
    Time.current - created_at
  end

  def summary
    "#{title} - #{truncate(text)}"
  end
end</pre> <button class="clipboard-button" data-clipboard-text='# MyApp/app/models/blorgh/article.rb

class Blorgh::Article &lt; ApplicationRecord
  include Blorgh::Concerns::Models::Article

  def time_since_created
    Time.current - created_at
  end

  def summary
    "#{title} - #{truncate(text)}"
  end
end
'>Copy</button> </div> <div class="interstitial code"> <pre data-language="ruby"># Blorgh/app/models/blorgh/article.rb
module Blorgh
  class Article &lt; ApplicationRecord
    include Blorgh::Concerns::Models::Article
  end
end</pre> <button class="clipboard-button" data-clipboard-text="# Blorgh/app/models/blorgh/article.rb
module Blorgh
  class Article &lt; ApplicationRecord
    include Blorgh::Concerns::Models::Article
  end
end
">Copy</button> </div> <div class="interstitial code"> <pre data-language="ruby"># Blorgh/lib/concerns/models/article.rb

module Blorgh::Concerns::Models::Article
  extend ActiveSupport::Concern

  # `included do` causes the block to be evaluated in the context
  # in which the module is included (i.e. Blorgh::Article),
  # rather than in the module itself.
  included do
    attr_accessor :author_name
    belongs_to :author, class_name: "User"

    before_validation :set_author

    private
      def set_author
        self.author = User.find_or_create_by(name: author_name)
      end
  end

  def summary
    "#{title}"
  end

  module ClassMethods
    def some_class_method
      'some class method string'
    end
  end
end</pre> <button class="clipboard-button" data-clipboard-text="# Blorgh/lib/concerns/models/article.rb

module Blorgh::Concerns::Models::Article
  extend ActiveSupport::Concern

  # `included do` causes the block to be evaluated in the context
  # in which the module is included (i.e. Blorgh::Article),
  # rather than in the module itself.
  included do
    attr_accessor :author_name
    belongs_to :author, class_name: &quot;User&quot;

    before_validation :set_author

    private
      def set_author
        self.author = User.find_or_create_by(name: author_name)
      end
  end

  def summary
    &quot;#{title}&quot;
  end

  module ClassMethods
    def some_class_method
      'some class method string'
    end
  end
end
">Copy</button> </div> <h2 id="autoloading-and-engines"><a class="anchorlink" href="#autoloading-and-engines"><span>6.2</span> Autoloading and Engines</a></h2>
<p>Please check the <a href="autoloading_and_reloading_constants.html#autoloading-and-engines">Autoloading and Reloading Constants</a> guide for more information about autoloading and engines.</p>
<h2 id="overriding-views"><a class="anchorlink" href="#overriding-views"><span>6.3</span> Overriding Views</a></h2>
<p>When Rails looks for a view to render, it will first look in the <code>app/views</code> directory of the application. If it cannot find the view there, it will check in the <code>app/views</code> directories of all engines that have this directory.</p>
<p>When the application is asked to render the view for <code>Blorgh::ArticlesController</code>'s index action, it will first look for the path <code>app/views/blorgh/articles/index.html.erb</code> within the application. If it cannot find it, it will look inside the engine.</p>
<p>You can override this view in the application by simply creating a new file at <code>app/views/blorgh/articles/index.html.erb</code>. Then you can completely change what this view would normally output.</p>
<p>Try this now by creating a new file at <code>app/views/blorgh/articles/index.html.erb</code> and put this content in it:</p>
<div class="interstitial code"> <pre data-language="erb">&lt;h1&gt;Articles&lt;/h1&gt;
&lt;%= link_to "New Article", new_article_path %&gt;
&lt;% @articles.each do |article| %&gt;
  &lt;h2&gt;&lt;%= article.title %&gt;&lt;/h2&gt;
  &lt;small&gt;By &lt;%= article.author %&gt;&lt;/small&gt;
  &lt;%= simple_format(article.text) %&gt;
  &lt;hr&gt;
&lt;% end %&gt;</pre> <button class="clipboard-button" data-clipboard-text='&lt;h1&gt;Articles&lt;/h1&gt;
&lt;%= link_to "New Article", new_article_path %&gt;
&lt;% @articles.each do |article| %&gt;
  &lt;h2&gt;&lt;%= article.title %&gt;&lt;/h2&gt;
  &lt;small&gt;By &lt;%= article.author %&gt;&lt;/small&gt;
  &lt;%= simple_format(article.text) %&gt;
  &lt;hr&gt;
&lt;% end %&gt;
'>Copy</button> </div> <h2 id="routes"><a class="anchorlink" href="#routes"><span>6.4</span> Routes</a></h2>
<p>Routes inside an engine are isolated from the application by default. This is done by the <code>isolate_namespace</code> call inside the <code>Engine</code> class. This essentially means that the application and its engines can have identically named routes and they will not clash.</p>
<p>Routes inside an engine are drawn on the <code>Engine</code> class within <code>config/routes.rb</code>, like this:</p>
<div class="interstitial code"> <pre data-language="ruby">Blorgh::Engine.routes.draw do
  resources :articles
end</pre> <button class="clipboard-button" data-clipboard-text="Blorgh::Engine.routes.draw do
  resources :articles
end
">Copy</button> </div> <p>By having isolated routes such as this, if you wish to link to an area of an engine from within an application, you will need to use the engine's routing proxy method. Calls to normal routing methods such as <code>articles_path</code> may end up going to undesired locations if both the application and the engine have such a helper defined.</p>
<p>For instance, the following example would go to the application's <code>articles_path</code> if that template was rendered from the application, or the engine's <code>articles_path</code> if it was rendered from the engine:</p>
<div class="interstitial code"> <pre data-language="erb">&lt;%= link_to "Blog articles", articles_path %&gt;</pre> <button class="clipboard-button" data-clipboard-text='&lt;%= link_to "Blog articles", articles_path %&gt;
'>Copy</button> </div> <p>To make this route always use the engine's <code>articles_path</code> routing helper method, we must call the method on the routing proxy method that shares the same name as the engine.</p>
<div class="interstitial code"> <pre data-language="erb">&lt;%= link_to "Blog articles", blorgh.articles_path %&gt;</pre> <button class="clipboard-button" data-clipboard-text='&lt;%= link_to "Blog articles", blorgh.articles_path %&gt;
'>Copy</button> </div> <p>If you wish to reference the application inside the engine in a similar way, use the <code>main_app</code> helper:</p>
<div class="interstitial code"> <pre data-language="erb">&lt;%= link_to "Home", main_app.root_path %&gt;</pre> <button class="clipboard-button" data-clipboard-text='&lt;%= link_to "Home", main_app.root_path %&gt;
'>Copy</button> </div> <p>If you were to use this inside an engine, it would <strong>always</strong> go to the application's root. If you were to leave off the <code>main_app</code> "routing proxy" method call, it could potentially go to the engine's or application's root, depending on where it was called from.</p>
<p>If a template rendered from within an engine attempts to use one of the application's routing helper methods, it may result in an undefined method call. If you encounter such an issue, ensure that you're not attempting to call the application's routing methods without the <code>main_app</code> prefix from within the engine.</p>
<h2 id="assets"><a class="anchorlink" href="#assets"><span>6.5</span> Assets</a></h2>
<p>Assets within an engine work in an identical way to a full application. Because the engine class inherits from <code>Rails::Engine</code>, the application will know to look up assets in the engine's <code>app/assets</code> and <code>lib/assets</code> directories.</p>
<p>Like all of the other components of an engine, the assets should be namespaced. This means that if you have an asset called <code>style.css</code>, it should be placed at <code>app/assets/stylesheets/[engine name]/style.css</code>, rather than <code>app/assets/stylesheets/style.css</code>. If this asset isn't namespaced, there is a possibility that the host application could have an asset named identically, in which case the application's asset would take precedence and the engine's one would be ignored.</p>
<p>Imagine that you did have an asset located at <code>app/assets/stylesheets/blorgh/style.css</code>. To include this asset inside an application, just use <code>stylesheet_link_tag</code> and reference the asset as if it were inside the engine:</p>
<div class="interstitial code"> <pre data-language="erb">&lt;%= stylesheet_link_tag "blorgh/style.css" %&gt;</pre> <button class="clipboard-button" data-clipboard-text='&lt;%= stylesheet_link_tag "blorgh/style.css" %&gt;
'>Copy</button> </div> <p>You can also specify these assets as dependencies of other assets using Asset Pipeline require statements in processed files:</p>
<div class="interstitial code"> <pre data-language="css">/*
 *= require blorgh/style
 */</pre> <button class="clipboard-button" data-clipboard-text="/*
 *= require blorgh/style
 */
">Copy</button> </div> <div class="interstitial info"><p>Remember that in order to use languages like Sass or CoffeeScript, you should add the relevant library to your engine's <code>.gemspec</code>.</p></div>
<h2 id="separate-assets-and-precompiling"><a class="anchorlink" href="#separate-assets-and-precompiling"><span>6.6</span> Separate Assets and Precompiling</a></h2>
<p>There are some situations where your engine's assets are not required by the host application. For example, say that you've created an admin functionality that only exists for your engine. In this case, the host application doesn't need to require <code>admin.css</code> or <code>admin.js</code>. Only the gem's admin layout needs these assets. It doesn't make sense for the host app to include <code>"blorgh/admin.css"</code> in its stylesheets. In this situation, you should explicitly define these assets for precompilation. This tells Sprockets to add your engine assets when <code>bin/rails assets:precompile</code> is triggered.</p>
<p>You can define assets for precompilation in <code>engine.rb</code>:</p>
<div class="interstitial code"> <pre data-language="ruby">initializer "blorgh.assets.precompile" do |app|
  app.config.assets.precompile += %w( admin.js admin.css )
end</pre> <button class="clipboard-button" data-clipboard-text='initializer "blorgh.assets.precompile" do |app|
  app.config.assets.precompile += %w( admin.js admin.css )
end
'>Copy</button> </div> <p>For more information, read the <a href="asset_pipeline.html">Asset Pipeline guide</a>.</p>
<h2 id="other-gem-dependencies"><a class="anchorlink" href="#other-gem-dependencies"><span>6.7</span> Other Gem Dependencies</a></h2>
<p>Gem dependencies inside an engine should be specified inside the <code>.gemspec</code> file at the root of the engine. The reason is that the engine may be installed as a gem. If dependencies were to be specified inside the <code>Gemfile</code>, these would not be recognized by a traditional gem install and so they would not be installed, causing the engine to malfunction.</p>
<p>To specify a dependency that should be installed with the engine during a traditional <code>gem install</code>, specify it inside the <code>Gem::Specification</code> block inside the <code>.gemspec</code> file in the engine:</p>
<div class="interstitial code"> <pre data-language="ruby">s.add_dependency "moo"</pre> <button class="clipboard-button" data-clipboard-text='s.add_dependency "moo"
'>Copy</button> </div> <p>To specify a dependency that should only be installed as a development dependency of the application, specify it like this:</p>
<div class="interstitial code"> <pre data-language="ruby">s.add_development_dependency "moo"</pre> <button class="clipboard-button" data-clipboard-text='s.add_development_dependency "moo"
'>Copy</button> </div> <p>Both kinds of dependencies will be installed when <code>bundle install</code> is run inside of the application. The development dependencies for the gem will only be used when the development and tests for the engine are running.</p>
<p>Note that if you want to immediately require dependencies when the engine is required, you should require them before the engine's initialization. For example:</p>
<div class="interstitial code"> <pre data-language="ruby">require "other_engine/engine"
require "yet_another_engine/engine"

module MyEngine
  class Engine &lt; ::Rails::Engine
  end
end</pre> <button class="clipboard-button" data-clipboard-text='require "other_engine/engine"
require "yet_another_engine/engine"

module MyEngine
  class Engine &lt; ::Rails::Engine
  end
end
'>Copy</button> </div> <hr> <h2>Feedback</h2> <p> You're encouraged to help improve the quality of this guide. </p> <p> Please contribute if you see any typos or factual errors. To get started, you can read our <a href="https://edgeguides.rubyonrails.org/contributing_to_ruby_on_rails.html#contributing-to-the-rails-documentation">documentation contributions</a> section. </p> <p> You may also find incomplete content or stuff that is not up to date. Please do add any missing documentation for main. Make sure to check <a href="https://edgeguides.rubyonrails.org">Edge Guides</a> first to verify if the issues are already fixed or not on the main branch. Check the <span>Ruby on Rails Guides Guidelines</span> for style and conventions. </p> <p> If for whatever reason you spot something to fix but cannot patch it yourself, please <a href="https://github.com/rails/rails/issues">open an issue</a>. </p> <p>And last but not least, any kind of discussion regarding Ruby on Rails documentation is very welcome on the <a href="https://discuss.rubyonrails.org/c/rubyonrails-docs">official Ruby on Rails Forum</a>. </p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2004&ndash;2021 David Heinemeier Hansson<br>Licensed under the Creative Commons Attribution-ShareAlike 4.0 International License.<br>
    
  </p>
</div>
