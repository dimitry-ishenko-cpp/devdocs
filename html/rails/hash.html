<h1 id="class-Hash" class="class"> class Hash </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent"><a href="object.html">Object</a></dd>
</dl>  <section id="5Buntitled-5D" class="documentation-section"> <section id="public-class-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-from_trusted_xml"> <span class="method-name">from_trusted_xml</span><span class="method-args">(xml)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="from_trusted_xml-source"> <pre class="ruby" data-language="ruby"># File activesupport/lib/active_support/core_ext/hash/conversions.rb, line 133
def from_trusted_xml(xml)
  from_xml xml, []
end</pre> </div> <p>Builds a <a href="hash.html"><code>Hash</code></a> from XML just like <code>Hash.from_xml</code>, but also allows <span><code>Symbol</code></span> and YAML.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-from_xml"> <span class="method-name">from_xml</span><span class="method-args">(xml, disallowed_types = nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="from_xml-source"> <pre class="ruby" data-language="ruby"># File activesupport/lib/active_support/core_ext/hash/conversions.rb, line 128
def from_xml(xml, disallowed_types = nil)
  ActiveSupport::XMLConverter.new(xml, disallowed_types).to_h
end</pre> </div> <p>Returns a <a href="hash.html"><code>Hash</code></a> containing a collection of pairs when the key is the node name and the value is its content</p> <pre class="ruby" data-language="ruby">xml = &lt;&lt;-XML
  &lt;?xml version="1.0" encoding="UTF-8"?&gt;
    &lt;hash&gt;
      &lt;foo type="integer"&gt;1&lt;/foo&gt;
      &lt;bar type="integer"&gt;2&lt;/bar&gt;
    &lt;/hash&gt;
XML

hash = Hash.from_xml(xml)
# =&gt; {"hash"=&gt;{"foo"=&gt;1, "bar"=&gt;2}}
</pre> <p><code>DisallowedType</code> is raised if the XML contains attributes with <code>type="yaml"</code> or <code>type="symbol"</code>. Use <code>Hash.from_trusted_xml</code> to parse this XML.</p> <p>Custom <code>disallowed_types</code> can also be passed in the form of an array.</p> <pre class="ruby" data-language="ruby">xml = &lt;&lt;-XML
  &lt;?xml version="1.0" encoding="UTF-8"?&gt;
    &lt;hash&gt;
      &lt;foo type="integer"&gt;1&lt;/foo&gt;
      &lt;bar type="string"&gt;"David"&lt;/bar&gt;
    &lt;/hash&gt;
XML

hash = Hash.from_xml(xml, ['integer'])
# =&gt; ActiveSupport::XMLConverter::DisallowedType: Disallowed type attribute: "integer"
</pre> <p>Note that passing custom disallowed types will override the default types, which are <span><code>Symbol</code></span> and YAML.</p>  </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-assert_valid_keys"> <span class="method-name">assert_valid_keys</span><span class="method-args">(*valid_keys)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="assert_valid_keys-source"> <pre class="ruby" data-language="ruby"># File activesupport/lib/active_support/core_ext/hash/keys.rb, line 48
def assert_valid_keys(*valid_keys)
  valid_keys.flatten!
  each_key do |k|
    unless valid_keys.include?(k)
      raise ArgumentError.new("Unknown key: #{k.inspect}. Valid keys are: #{valid_keys.map(&amp;:inspect).join(', ')}")
    end
  end
end</pre> </div> <p>Validates all keys in a hash match <code>*valid_keys</code>, raising <code>ArgumentError</code> on a mismatch.</p> <p>Note that keys are treated differently than <a href="activesupport/hashwithindifferentaccess.html"><code>HashWithIndifferentAccess</code></a>, meaning that string and symbol keys will not match.</p> <pre class="ruby" data-language="ruby">{ name: 'Rob', years: '28' }.assert_valid_keys(:name, :age) # =&gt; raises "ArgumentError: Unknown key: :years. Valid keys are: :name, :age"
{ name: 'Rob', age: '28' }.assert_valid_keys('name', 'age') # =&gt; raises "ArgumentError: Unknown key: :name. Valid keys are: 'name', 'age'"
{ name: 'Rob', age: '28' }.assert_valid_keys(:name, :age)   # =&gt; passes, raises nothing
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-compact_blank-21"> <span class="method-name">compact_blank!</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="compact_blank-21-source"> <pre class="ruby" data-language="ruby"># File activesupport/lib/active_support/core_ext/enumerable.rb, line 227
def compact_blank!
  # use delete_if rather than reject! because it always returns self even if nothing changed
  delete_if { |_k, v| v.blank? }
end</pre> </div> <p>Removes all blank values from the <code>Hash</code> in place and returns self. Uses <a href="object.html#method-i-blank-3F"><code>Object#blank?</code></a> for determining if a value is blank.</p> <pre class="ruby" data-language="ruby">h = { a: "", b: 1, c: nil, d: [], e: false, f: true }
h.compact_blank!
# =&gt; { b: 1, f: true }
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-deep_dup"> <span class="method-name">deep_dup</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="deep_dup-source"> <pre class="ruby" data-language="ruby"># File activesupport/lib/active_support/core_ext/object/deep_dup.rb, line 43
def deep_dup
  hash = dup
  each_pair do |key, value|
    if ::String === key || ::Symbol === key
      hash[key] = value.deep_dup
    else
      hash.delete(key)
      hash[key.deep_dup] = value.deep_dup
    end
  end
  hash
end</pre> </div> <p>Returns a deep copy of hash.</p> <pre class="ruby" data-language="ruby">hash = { a: { b: 'b' } }
dup  = hash.deep_dup
dup[:a][:c] = 'c'

hash[:a][:c] # =&gt; nil
dup[:a][:c]  # =&gt; "c"
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-deep_merge"> <span class="method-callseq"> deep_merge(other_hash, &amp;block) </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="deep_merge-source"> <pre class="c" data-language="c"># File activesupport/lib/active_support/core_ext/hash/deep_merge.rb, line 9
  </pre> </div> <p>Returns a new hash with <code>self</code> and <code>other_hash</code> merged recursively.</p> <pre class="ruby" data-language="ruby">h1 = { a: true, b: { c: [1, 2, 3] } }
h2 = { a: false, b: { x: [3, 4, 5] } }

h1.deep_merge(h2) # =&gt; { a: false, b: { c: [1, 2, 3], x: [3, 4, 5] } }
</pre> <p>Like with Hash#merge in the standard library, a block can be provided to merge values:</p> <pre class="ruby" data-language="ruby">h1 = { a: 100, b: 200, c: { c1: 100 } }
h2 = { b: 250, c: { c1: 200 } }
h1.deep_merge(h2) { |key, this_val, other_val| this_val + other_val }
# =&gt; { a: 100, b: 450, c: { c1: 300 } }
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-deep_stringify_keys"> <span class="method-name">deep_stringify_keys</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="deep_stringify_keys-source"> <pre class="ruby" data-language="ruby"># File activesupport/lib/active_support/core_ext/hash/keys.rb, line 84
def deep_stringify_keys
  deep_transform_keys { |k| Symbol === k ? k.name : k.to_s }
end</pre> </div> <p>Returns a new hash with all keys converted to strings. This includes the keys from the root hash and from all nested hashes and arrays.</p> <pre class="ruby" data-language="ruby">hash = { person: { name: 'Rob', age: '28' } }

hash.deep_stringify_keys
# =&gt; {"person"=&gt;{"name"=&gt;"Rob", "age"=&gt;"28"}}
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-deep_stringify_keys-21"> <span class="method-name">deep_stringify_keys!</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="deep_stringify_keys-21-source"> <pre class="ruby" data-language="ruby"># File activesupport/lib/active_support/core_ext/hash/keys.rb, line 91
def deep_stringify_keys!
  deep_transform_keys! { |k| Symbol === k ? k.name : k.to_s }
end</pre> </div> <p>Destructively converts all keys to strings. This includes the keys from the root hash and from all nested hashes and arrays.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-deep_symbolize_keys"> <span class="method-name">deep_symbolize_keys</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="deep_symbolize_keys-source"> <pre class="ruby" data-language="ruby"># File activesupport/lib/active_support/core_ext/hash/keys.rb, line 103
def deep_symbolize_keys
  deep_transform_keys { |key| key.to_sym rescue key }
end</pre> </div> <p>Returns a new hash with all keys converted to symbols, as long as they respond to <code>to_sym</code>. This includes the keys from the root hash and from all nested hashes and arrays.</p> <pre class="ruby" data-language="ruby">hash = { 'person' =&gt; { 'name' =&gt; 'Rob', 'age' =&gt; '28' } }

hash.deep_symbolize_keys
# =&gt; {:person=&gt;{:name=&gt;"Rob", :age=&gt;"28"}}
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-deep_symbolize_keys-21"> <span class="method-name">deep_symbolize_keys!</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="deep_symbolize_keys-21-source"> <pre class="ruby" data-language="ruby"># File activesupport/lib/active_support/core_ext/hash/keys.rb, line 110
def deep_symbolize_keys!
  deep_transform_keys! { |key| key.to_sym rescue key }
end</pre> </div> <p>Destructively converts all keys to symbols, as long as they respond to <code>to_sym</code>. This includes the keys from the root hash and from all nested hashes and arrays.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-deep_transform_keys"> <span class="method-name">deep_transform_keys</span><span class="method-args">(&amp;block)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="deep_transform_keys-source"> <pre class="ruby" data-language="ruby"># File activesupport/lib/active_support/core_ext/hash/keys.rb, line 65
def deep_transform_keys(&amp;block)
  _deep_transform_keys_in_object(self, &amp;block)
end</pre> </div> <p>Returns a new hash with all keys converted by the block operation. This includes the keys from the root hash and from all nested hashes and arrays.</p> <pre class="ruby" data-language="ruby">hash = { person: { name: 'Rob', age: '28' } }

hash.deep_transform_keys{ |key| key.to_s.upcase }
# =&gt; {"PERSON"=&gt;{"NAME"=&gt;"Rob", "AGE"=&gt;"28"}}
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-deep_transform_keys-21"> <span class="method-name">deep_transform_keys!</span><span class="method-args">(&amp;block)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="deep_transform_keys-21-source"> <pre class="ruby" data-language="ruby"># File activesupport/lib/active_support/core_ext/hash/keys.rb, line 72
def deep_transform_keys!(&amp;block)
  _deep_transform_keys_in_object!(self, &amp;block)
end</pre> </div> <p>Destructively converts all keys by using the block operation. This includes the keys from the root hash and from all nested hashes and arrays.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-deep_transform_values"> <span class="method-name">deep_transform_values</span><span class="method-args">(&amp;block)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="deep_transform_values-source"> <pre class="ruby" data-language="ruby"># File activesupport/lib/active_support/core_ext/hash/deep_transform_values.rb, line 12
def deep_transform_values(&amp;block)
  _deep_transform_values_in_object(self, &amp;block)
end</pre> </div> <p>Returns a new hash with all values converted by the block operation. This includes the values from the root hash and from all nested hashes and arrays.</p> <pre class="ruby" data-language="ruby">hash = { person: { name: 'Rob', age: '28' } }

hash.deep_transform_values{ |value| value.to_s.upcase }
# =&gt; {person: {name: "ROB", age: "28"}}
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-deep_transform_values-21"> <span class="method-name">deep_transform_values!</span><span class="method-args">(&amp;block)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="deep_transform_values-21-source"> <pre class="ruby" data-language="ruby"># File activesupport/lib/active_support/core_ext/hash/deep_transform_values.rb, line 19
def deep_transform_values!(&amp;block)
  _deep_transform_values_in_object!(self, &amp;block)
end</pre> </div> <p>Destructively converts all values by using the block operation. This includes the values from the root hash and from all nested hashes and arrays.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-except"> <span class="method-name">except</span><span class="method-args">(*keys)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="except-source"> <pre class="ruby" data-language="ruby"># File activesupport/lib/active_support/core_ext/hash/except.rb, line 12
def except(*keys)
  slice(*self.keys - keys)
end</pre> </div> <p>Returns a hash that includes everything except given keys.</p> <pre class="ruby" data-language="ruby">hash = { a: true, b: false, c: nil }
hash.except(:c)     # =&gt; { a: true, b: false }
hash.except(:a, :b) # =&gt; { c: nil }
hash                # =&gt; { a: true, b: false, c: nil }
</pre> <p>This is useful for limiting a set of parameters to everything but a few known toggles:</p> <pre class="ruby" data-language="ruby">@person.update(params[:person].except(:admin))
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-except-21"> <span class="method-name">except!</span><span class="method-args">(*keys)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="except-21-source"> <pre class="ruby" data-language="ruby"># File activesupport/lib/active_support/core_ext/hash/except.rb, line 20
def except!(*keys)
  keys.each { |key| delete(key) }
  self
end</pre> </div> <p>Removes the given keys from hash and returns it.</p> <pre class="ruby" data-language="ruby">hash = { a: true, b: false, c: nil }
hash.except!(:c) # =&gt; { a: true, b: false }
hash             # =&gt; { a: true, b: false }
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-extract-21"> <span class="method-name">extract!</span><span class="method-args">(*keys)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="extract-21-source"> <pre class="ruby" data-language="ruby"># File activesupport/lib/active_support/core_ext/hash/slice.rb, line 24
def extract!(*keys)
  keys.each_with_object(self.class.new) { |key, result| result[key] = delete(key) if has_key?(key) }
end</pre> </div> <p>Removes and returns the key/value pairs matching the given keys.</p> <pre class="ruby" data-language="ruby">hash = { a: 1, b: 2, c: 3, d: 4 }
hash.extract!(:a, :b) # =&gt; {:a=&gt;1, :b=&gt;2}
hash                  # =&gt; {:c=&gt;3, :d=&gt;4}
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-extractable_options-3F"> <span class="method-name">extractable_options?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="extractable_options-3F-source"> <pre class="ruby" data-language="ruby"># File activesupport/lib/active_support/core_ext/array/extract_options.rb, line 9
def extractable_options?
  instance_of?(Hash)
end</pre> </div> <p>By default, only instances of <a href="hash.html"><code>Hash</code></a> itself are extractable. Subclasses of <a href="hash.html"><code>Hash</code></a> may implement this method and return true to declare themselves as extractable. If a <a href="hash.html"><code>Hash</code></a> is extractable, <a href="array.html#method-i-extract_options-21"><code>Array#extract_options!</code></a> pops it from the <a href="array.html"><code>Array</code></a> when it is the last element of the <a href="array.html"><code>Array</code></a>.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-nested_under_indifferent_access"> <span class="method-name">nested_under_indifferent_access</span><span class="method-args">()</span> </div> </div> <div class="method-description"> <p>Called when object is nested under an object that receives <a href="hash.html#method-i-with_indifferent_access"><code>with_indifferent_access</code></a>. This method will be called on the current object by the enclosing object and is aliased to <a href="hash.html#method-i-with_indifferent_access"><code>with_indifferent_access</code></a> by default. Subclasses of <a href="hash.html"><code>Hash</code></a> may override this method to return <code>self</code> if converting to an <a href="activesupport/hashwithindifferentaccess.html"><code>ActiveSupport::HashWithIndifferentAccess</code></a> would not be desirable.</p> <pre class="ruby" data-language="ruby">b = { b: 1 }
{ a: b }.with_indifferent_access['a'] # calls b.nested_under_indifferent_access
# =&gt; {"b"=&gt;1}
</pre> </div> <div class="aliases"> Alias for: <a href="hash.html#method-i-with_indifferent_access">with_indifferent_access</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-reverse_merge"> <span class="method-name">reverse_merge</span><span class="method-args">(other_hash)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="reverse_merge-source"> <pre class="ruby" data-language="ruby"># File activesupport/lib/active_support/core_ext/hash/reverse_merge.rb, line 14
def reverse_merge(other_hash)
  other_hash.merge(self)
end</pre> </div> <p>Merges the caller into <code>other_hash</code>. For example,</p> <pre class="ruby" data-language="ruby">options = options.reverse_merge(size: 25, velocity: 10)
</pre> <p>is equivalent to</p> <pre class="ruby" data-language="ruby">options = { size: 25, velocity: 10 }.merge(options)
</pre> <p>This is particularly useful for initializing an options hash with default values.</p>  </div> <div class="aliases"> Also aliased as: <a href="hash.html#method-i-with_defaults">with_defaults</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-reverse_merge-21"> <span class="method-name">reverse_merge!</span><span class="method-args">(other_hash)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="reverse_merge-21-source"> <pre class="ruby" data-language="ruby"># File activesupport/lib/active_support/core_ext/hash/reverse_merge.rb, line 20
def reverse_merge!(other_hash)
  replace(reverse_merge(other_hash))
end</pre> </div> <p>Destructive <code>reverse_merge</code>.</p>  </div> <div class="aliases"> Also aliased as: <a href="hash.html#method-i-reverse_update">reverse_update</a>, <a href="hash.html#method-i-with_defaults-21">with_defaults!</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-reverse_update"> <span class="method-name">reverse_update</span><span class="method-args">(other_hash)</span> </div> </div>  <div class="aliases"> Alias for: <a href="hash.html#method-i-reverse_merge-21">reverse_merge!</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-slice-21"> <span class="method-name">slice!</span><span class="method-args">(*keys)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="slice-21-source"> <pre class="ruby" data-language="ruby"># File activesupport/lib/active_support/core_ext/hash/slice.rb, line 10
def slice!(*keys)
  omit = slice(*self.keys - keys)
  hash = slice(*keys)
  hash.default      = default
  hash.default_proc = default_proc if default_proc
  replace(hash)
  omit
end</pre> </div> <p>Replaces the hash with only the given keys. Returns a hash containing the removed key/value pairs.</p> <pre class="ruby" data-language="ruby">hash = { a: 1, b: 2, c: 3, d: 4 }
hash.slice!(:a, :b)  # =&gt; {:c=&gt;3, :d=&gt;4}
hash                 # =&gt; {:a=&gt;1, :b=&gt;2}
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-stringify_keys"> <span class="method-name">stringify_keys</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="stringify_keys-source"> <pre class="ruby" data-language="ruby"># File activesupport/lib/active_support/core_ext/hash/keys.rb, line 10
def stringify_keys
  transform_keys { |k| Symbol === k ? k.name : k.to_s }
end</pre> </div> <p>Returns a new hash with all keys converted to strings.</p> <pre class="ruby" data-language="ruby">hash = { name: 'Rob', age: '28' }

hash.stringify_keys
# =&gt; {"name"=&gt;"Rob", "age"=&gt;"28"}
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-stringify_keys-21"> <span class="method-name">stringify_keys!</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="stringify_keys-21-source"> <pre class="ruby" data-language="ruby"># File activesupport/lib/active_support/core_ext/hash/keys.rb, line 16
def stringify_keys!
  transform_keys! { |k| Symbol === k ? k.name : k.to_s }
end</pre> </div> <p>Destructively converts all keys to strings. Same as <code>stringify_keys</code>, but modifies <code>self</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-symbolize_keys"> <span class="method-name">symbolize_keys</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="symbolize_keys-source"> <pre class="ruby" data-language="ruby"># File activesupport/lib/active_support/core_ext/hash/keys.rb, line 27
def symbolize_keys
  transform_keys { |key| key.to_sym rescue key }
end</pre> </div> <p>Returns a new hash with all keys converted to symbols, as long as they respond to <code>to_sym</code>.</p> <pre class="ruby" data-language="ruby">hash = { 'name' =&gt; 'Rob', 'age' =&gt; '28' }

hash.symbolize_keys
# =&gt; {:name=&gt;"Rob", :age=&gt;"28"}
</pre>  </div> <div class="aliases"> Also aliased as: <a href="hash.html#method-i-to_options">to_options</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-symbolize_keys-21"> <span class="method-name">symbolize_keys!</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="symbolize_keys-21-source"> <pre class="ruby" data-language="ruby"># File activesupport/lib/active_support/core_ext/hash/keys.rb, line 34
def symbolize_keys!
  transform_keys! { |key| key.to_sym rescue key }
end</pre> </div> <p>Destructively converts all keys to symbols, as long as they respond to <code>to_sym</code>. Same as <code>symbolize_keys</code>, but modifies <code>self</code>.</p>  </div> <div class="aliases"> Also aliased as: <a href="hash.html#method-i-to_options-21">to_options!</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-to_options"> <span class="method-name">to_options</span><span class="method-args">()</span> </div> </div>  <div class="aliases"> Alias for: <a href="hash.html#method-i-symbolize_keys">symbolize_keys</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-to_options-21"> <span class="method-name">to_options!</span><span class="method-args">()</span> </div> </div>  <div class="aliases"> Alias for: <a href="hash.html#method-i-symbolize_keys-21">symbolize_keys!</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-to_param"> <span class="method-name">to_param</span><span class="method-args">(namespace = nil)</span> </div> </div>  <div class="aliases"> Alias for: <a href="hash.html#method-i-to_query">to_query</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-to_query"> <span class="method-name">to_query</span><span class="method-args">(namespace = nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="to_query-source"> <pre class="ruby" data-language="ruby"># File activesupport/lib/active_support/core_ext/object/to_query.rb, line 75
def to_query(namespace = nil)
  query = filter_map do |key, value|
    unless (value.is_a?(Hash) || value.is_a?(Array)) &amp;&amp; value.empty?
      value.to_query(namespace ? "#{namespace}[#{key}]" : key)
    end
  end

  query.sort! unless namespace.to_s.include?("[]")
  query.join("&amp;")
end</pre> </div> <p>Returns a string representation of the receiver suitable for use as a URL query string:</p> <pre class="ruby" data-language="ruby">{name: 'David', nationality: 'Danish'}.to_query
# =&gt; "name=David&amp;nationality=Danish"
</pre> <p>An optional namespace can be passed to enclose key names:</p> <pre class="ruby" data-language="ruby">{name: 'David', nationality: 'Danish'}.to_query('user')
# =&gt; "user%5Bname%5D=David&amp;user%5Bnationality%5D=Danish"
</pre> <p>The string pairs “key=value” that conform the query string are sorted lexicographically in ascending order.</p>  </div> <div class="aliases"> Also aliased as: <a href="hash.html#method-i-to_param">to_param</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-to_xml"> <span class="method-name">to_xml</span><span class="method-args">(options = {}) { |builder| ... }</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="to_xml-source"> <pre class="ruby" data-language="ruby"># File activesupport/lib/active_support/core_ext/hash/conversions.rb, line 74
def to_xml(options = {})
  require "active_support/builder" unless defined?(Builder::XmlMarkup)

  options = options.dup
  options[:indent]  ||= 2
  options[:root]    ||= "hash"
  options[:builder] ||= Builder::XmlMarkup.new(indent: options[:indent])

  builder = options[:builder]
  builder.instruct! unless options.delete(:skip_instruct)

  root = ActiveSupport::XmlMini.rename_key(options[:root].to_s, options)

  builder.tag!(root) do
    each { |key, value| ActiveSupport::XmlMini.to_tag(key, value, options) }
    yield builder if block_given?
  end
end</pre> </div> <p>Returns a string containing an XML representation of its receiver:</p> <pre class="ruby" data-language="ruby">{ foo: 1, bar: 2 }.to_xml
# =&gt;
# &lt;?xml version="1.0" encoding="UTF-8"?&gt;
# &lt;hash&gt;
#   &lt;foo type="integer"&gt;1&lt;/foo&gt;
#   &lt;bar type="integer"&gt;2&lt;/bar&gt;
# &lt;/hash&gt;
</pre> <p>To do so, the method loops over the pairs and builds nodes that depend on the <em>values</em>. Given a pair <code>key</code>, <code>value</code>:</p> <ul>
<li> <p>If <code>value</code> is a hash there’s a recursive call with <code>key</code> as <code>:root</code>.</p> </li>
<li> <p>If <code>value</code> is an array there’s a recursive call with <code>key</code> as <code>:root</code>, and <code>key</code> singularized as <code>:children</code>.</p> </li>
<li> <p>If <code>value</code> is a callable object it must expect one or two arguments. Depending on the arity, the callable is invoked with the <code>options</code> hash as first argument with <code>key</code> as <code>:root</code>, and <code>key</code> singularized as second argument. The callable can add nodes by using <code>options[:builder]</code>.</p> <pre class="ruby" data-language="ruby">{foo: lambda { |options, key| options[:builder].b(key) }}.to_xml
# =&gt; "&lt;b&gt;foo&lt;/b&gt;"
</pre> </li>
<li> <p>If <code>value</code> responds to <code>to_xml</code> the method is invoked with <code>key</code> as <code>:root</code>.</p> <pre class="ruby" data-language="ruby">class Foo
  def to_xml(options)
    options[:builder].bar 'fooing!'
  end
end

{ foo: Foo.new }.to_xml(skip_instruct: true)
# =&gt;
# &lt;hash&gt;
#   &lt;bar&gt;fooing!&lt;/bar&gt;
# &lt;/hash&gt;
</pre> </li>
<li> <p>Otherwise, a node with <code>key</code> as tag is created with a string representation of <code>value</code> as text node. If <code>value</code> is <code>nil</code> an attribute “nil” set to “true” is added. Unless the option <code>:skip_types</code> exists and is true, an attribute “type” is added as well according to the following mapping:</p> <pre class="ruby" data-language="ruby">XML_TYPE_NAMES = {
  "Symbol"     =&gt; "symbol",
  "Integer"    =&gt; "integer",
  "BigDecimal" =&gt; "decimal",
  "Float"      =&gt; "float",
  "TrueClass"  =&gt; "boolean",
  "FalseClass" =&gt; "boolean",
  "Date"       =&gt; "date",
  "DateTime"   =&gt; "dateTime",
  "Time"       =&gt; "dateTime"
}
</pre> </li>
</ul> <p>By default the root node is “hash”, but that’s configurable via the <code>:root</code> option.</p> <p>The default XML builder is a fresh instance of <code>Builder::XmlMarkup</code>. You can configure your own builder with the <code>:builder</code> option. The method also accepts options like <code>:dasherize</code> and friends, they are forwarded to the builder.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-with_defaults"> <span class="method-name">with_defaults</span><span class="method-args">(other_hash)</span> </div> </div>  <div class="aliases"> Alias for: <a href="hash.html#method-i-reverse_merge">reverse_merge</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-with_defaults-21"> <span class="method-name">with_defaults!</span><span class="method-args">(other_hash)</span> </div> </div>  <div class="aliases"> Alias for: <a href="hash.html#method-i-reverse_merge-21">reverse_merge!</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-with_indifferent_access"> <span class="method-name">with_indifferent_access</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="with_indifferent_access-source"> <pre class="ruby" data-language="ruby"># File activesupport/lib/active_support/core_ext/hash/indifferent_access.rb, line 9
def with_indifferent_access
  ActiveSupport::HashWithIndifferentAccess.new(self)
end</pre> </div> <p>Returns an <a href="activesupport/hashwithindifferentaccess.html"><code>ActiveSupport::HashWithIndifferentAccess</code></a> out of its receiver:</p> <pre class="ruby" data-language="ruby">{ a: 1 }.with_indifferent_access['a'] # =&gt; 1
</pre>  </div> <div class="aliases"> Also aliased as: <a href="hash.html#method-i-nested_under_indifferent_access">nested_under_indifferent_access</a> </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2004&ndash;2021 David Heinemeier Hansson<br>Licensed under the MIT License.<br>
    
  </p>
</div>
