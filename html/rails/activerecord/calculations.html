<h1 id="module-ActiveRecord::Calculations" class="module"> module ActiveRecord::Calculations </h1> <section class="description"> <h1 id="module-ActiveRecord::Calculations-label-Active+Record+Calculations">Active Record Calculations</h1> </section> <section id="5Buntitled-5D" class="documentation-section"> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-async_average"> <span class="method-name">async_average</span><span class="method-args">(column_name)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="async_average-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation/calculations.rb, line 122
def async_average(column_name)
  async.average(column_name)
end</pre> </div> <p>Same as <a href="calculations.html#method-i-average"><code>average</code></a>, but performs the query asynchronously and returns an <a href="promise.html"><code>ActiveRecord::Promise</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-async_count"> <span class="method-name">async_count</span><span class="method-args">(column_name = nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="async_count-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation/calculations.rb, line 108
def async_count(column_name = nil)
  async.count(column_name)
end</pre> </div> <p>Same as <a href="calculations.html#method-i-count"><code>count</code></a>, but performs the query asynchronously and returns an <a href="promise.html"><code>ActiveRecord::Promise</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-async_ids"> <span class="method-name">async_ids</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="async_ids-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation/calculations.rb, line 405
def async_ids
  async.ids
end</pre> </div> <p>Same as <a href="calculations.html#method-i-ids"><code>ids</code></a>, but performs the query asynchronously and returns an <a href="promise.html"><code>ActiveRecord::Promise</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-async_maximum"> <span class="method-name">async_maximum</span><span class="method-args">(column_name)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="async_maximum-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation/calculations.rb, line 152
def async_maximum(column_name)
  async.maximum(column_name)
end</pre> </div> <p>Same as <a href="calculations.html#method-i-maximum"><code>maximum</code></a>, but performs the query asynchronously and returns an <a href="promise.html"><code>ActiveRecord::Promise</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-async_minimum"> <span class="method-name">async_minimum</span><span class="method-args">(column_name)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="async_minimum-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation/calculations.rb, line 137
def async_minimum(column_name)
  async.minimum(column_name)
end</pre> </div> <p>Same as <a href="calculations.html#method-i-minimum"><code>minimum</code></a>, but performs the query asynchronously and returns an <a href="promise.html"><code>ActiveRecord::Promise</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-async_pick"> <span class="method-name">async_pick</span><span class="method-args">(*column_names)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="async_pick-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation/calculations.rb, line 359
def async_pick(*column_names)
  async.pick(*column_names)
end</pre> </div> <p>Same as <a href="calculations.html#method-i-pick"><code>pick</code></a>, but performs the query asynchronously and returns an <a href="promise.html"><code>ActiveRecord::Promise</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-async_pluck"> <span class="method-name">async_pluck</span><span class="method-args">(*column_names)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="async_pluck-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation/calculations.rb, line 330
def async_pluck(*column_names)
  async.pluck(*column_names)
end</pre> </div> <p>Same as <a href="calculations.html#method-i-pluck"><code>pluck</code></a>, but performs the query asynchronously and returns an <a href="promise.html"><code>ActiveRecord::Promise</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-async_sum"> <span class="method-name">async_sum</span><span class="method-args">(identity_or_column = nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="async_sum-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation/calculations.rb, line 182
def async_sum(identity_or_column = nil)
  async.sum(identity_or_column)
end</pre> </div> <p>Same as <a href="calculations.html#method-i-sum"><code>sum</code></a>, but performs the query asynchronously and returns an <a href="promise.html"><code>ActiveRecord::Promise</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-average"> <span class="method-name">average</span><span class="method-args">(column_name)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="average-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation/calculations.rb, line 116
def average(column_name)
  calculate(:average, column_name)
end</pre> </div> <p>Calculates the average value on a given column. Returns <code>nil</code> if there’s no row. See <a href="calculations.html#method-i-calculate"><code>calculate</code></a> for examples with options.</p> <pre class="ruby" data-language="ruby">Person.average(:age) # =&gt; 35.8
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-calculate"> <span class="method-name">calculate</span><span class="method-args">(operation, column_name)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="calculate-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation/calculations.rb, line 217
def calculate(operation, column_name)
  operation = operation.to_s.downcase

  if @none
    case operation
    when "count", "sum"
      result = group_values.any? ? Hash.new : 0
      return @async ? Promise::Complete.new(result) : result
    when "average", "minimum", "maximum"
      result = group_values.any? ? Hash.new : nil
      return @async ? Promise::Complete.new(result) : result
    end
  end

  if has_include?(column_name)
    relation = apply_join_dependency

    if operation == "count"
      unless distinct_value || distinct_select?(column_name || select_for_count)
        relation.distinct!
        relation.select_values = Array(klass.primary_key || table[Arel.star])
      end
      # PostgreSQL: ORDER BY expressions must appear in SELECT list when using DISTINCT
      relation.order_values = [] if group_values.empty?
    end

    relation.calculate(operation, column_name)
  else
    perform_calculation(operation, column_name)
  end
end</pre> </div> <p>This calculates aggregate values in the given column. Methods for <a href="calculations.html#method-i-count"><code>count</code></a>, <a href="calculations.html#method-i-sum"><code>sum</code></a>, <a href="calculations.html#method-i-average"><code>average</code></a>, <a href="calculations.html#method-i-minimum"><code>minimum</code></a>, and <a href="calculations.html#method-i-maximum"><code>maximum</code></a> have been added as shortcuts.</p> <pre class="ruby" data-language="ruby">Person.calculate(:count, :all) # The same as Person.count
Person.average(:age) # SELECT AVG(age) FROM people...

# Selects the minimum age for any family without any minors
Person.group(:last_name).having("min(age) &gt; 17").minimum(:age)

Person.sum("2 * age")
</pre> <p>There are two basic forms of output:</p> <ul>
<li> <p>Single aggregate value: The single value is type cast to <a href="../integer.html"><code>Integer</code></a> for COUNT, <span><code>Float</code></span> for AVG, and the given column’s type for everything else.</p> </li>
<li> <p>Grouped values: This returns an ordered hash of the values and groups them. It takes either a column name, or the name of a belongs_to association.</p> <pre>values = Person.group('last_name').maximum(:age)
puts values["Drake"]
# =&gt; 43

drake  = Family.find_by(last_name: 'Drake')
values = Person.group(:family).maximum(:age) # Person belongs_to :family
puts values[drake]
# =&gt; 43

values.each do |family, max_age|
  ...
end</pre> </li>
</ul>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-count"> <span class="method-name">count</span><span class="method-args">(column_name = nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="count-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation/calculations.rb, line 94
def count(column_name = nil)
  if block_given?
    unless column_name.nil?
      raise ArgumentError, "Column name argument is not supported when a block is passed."
    end

    super()
  else
    calculate(:count, column_name)
  end
end</pre> </div> <p>Count the records.</p> <pre class="ruby" data-language="ruby">Person.count
# =&gt; the total count of all people

Person.count(:age)
# =&gt; returns the total count of all people whose age is present in database

Person.count(:all)
# =&gt; performs a COUNT(*) (:all is an alias for '*')

Person.distinct.count(:age)
# =&gt; counts the number of different age values
</pre> <p>If <a href="calculations.html#method-i-count"><code>count</code></a> is used with <a href="querymethods.html#method-i-group">Relation#group</a>, it returns a <a href="../hash.html"><code>Hash</code></a> whose keys represent the aggregated column, and the values are the respective amounts:</p> <pre class="ruby" data-language="ruby">Person.group(:city).count
# =&gt; { 'Rome' =&gt; 5, 'Paris' =&gt; 3 }
</pre> <p>If <a href="calculations.html#method-i-count"><code>count</code></a> is used with <a href="querymethods.html#method-i-group">Relation#group</a> for multiple columns, it returns a <a href="../hash.html"><code>Hash</code></a> whose keys are an array containing the individual values of each column and the value of each key would be the <a href="calculations.html#method-i-count"><code>count</code></a>.</p> <pre class="ruby" data-language="ruby">Article.group(:status, :category).count
# =&gt;  {["draft", "business"]=&gt;10, ["draft", "technology"]=&gt;4, ["published", "technology"]=&gt;2}
</pre> <p>If <a href="calculations.html#method-i-count"><code>count</code></a> is used with <a href="querymethods.html#method-i-select">Relation#select</a>, it will count the selected columns:</p> <pre class="ruby" data-language="ruby">Person.select(:age).count
# =&gt; counts the number of different age values
</pre> <p>Note: not all valid <a href="querymethods.html#method-i-select">Relation#select</a> expressions are valid <a href="calculations.html#method-i-count"><code>count</code></a> expressions. The specifics differ between databases. In invalid cases, an error from the database is thrown.</p> <p>When given a block, loads all records in the relation, if the relation hasn’t been loaded yet. Calls the block with each record in the relation. Returns the number of records for which the block returns a truthy value.</p> <pre class="ruby" data-language="ruby">Person.count { |person| person.age &gt; 21 }
# =&gt; counts the number of people older that 21
</pre> <p>Note: If there are a lot of records in the relation, loading all records could result in performance issues.</p> <div class="method-calls-super"> Calls superclass method </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-ids"> <span class="method-name">ids</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="ids-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation/calculations.rb, line 367
def ids
  primary_key_array = Array(primary_key)

  if loaded?
    result = records.map do |record|
      if primary_key_array.one?
        record._read_attribute(primary_key_array.first)
      else
        primary_key_array.map { |column| record._read_attribute(column) }
      end
    end
    return @async ? Promise::Complete.new(result) : result
  end

  if has_include?(primary_key)
    relation = apply_join_dependency.group(*primary_key_array)
    return relation.ids
  end

  columns = arel_columns(primary_key_array)
  relation = spawn
  relation.select_values = columns

  result = if relation.where_clause.contradiction?
    ActiveRecord::Result.empty
  else
    skip_query_cache_if_necessary do
      klass.with_connection do |c|
        c.select_all(relation, "#{klass.name} Ids", async: @async)
      end
    end
  end

  result.then { |result| type_cast_pluck_values(result, columns) }
end</pre> </div> <p>Returns the base model’s ID’s for the relation using the table’s primary key</p> <pre class="ruby" data-language="ruby">Person.ids # SELECT people.id FROM people
Person.joins(:company).ids # SELECT people.id FROM people INNER JOIN companies ON companies.id = people.company_id
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-maximum"> <span class="method-name">maximum</span><span class="method-args">(column_name)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="maximum-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation/calculations.rb, line 146
def maximum(column_name)
  calculate(:maximum, column_name)
end</pre> </div> <p>Calculates the maximum value on a given column. The value is returned with the same data type of the column, or <code>nil</code> if there’s no row. See <a href="calculations.html#method-i-calculate"><code>calculate</code></a> for examples with options.</p> <pre class="ruby" data-language="ruby">Person.maximum(:age) # =&gt; 93
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-minimum"> <span class="method-name">minimum</span><span class="method-args">(column_name)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="minimum-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation/calculations.rb, line 131
def minimum(column_name)
  calculate(:minimum, column_name)
end</pre> </div> <p>Calculates the minimum value on a given column. The value is returned with the same data type of the column, or <code>nil</code> if there’s no row. See <a href="calculations.html#method-i-calculate"><code>calculate</code></a> for examples with options.</p> <pre class="ruby" data-language="ruby">Person.minimum(:age) # =&gt; 7
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-pick"> <span class="method-name">pick</span><span class="method-args">(*column_names)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="pick-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation/calculations.rb, line 348
def pick(*column_names)
  if loaded? &amp;&amp; all_attributes?(column_names)
    result = records.pick(*column_names)
    return @async ? Promise::Complete.new(result) : result
  end

  limit(1).pluck(*column_names).then(&amp;:first)
end</pre> </div> <p>Pick the value(s) from the named column(s) in the current relation. This is short-hand for <code>relation.limit(1).pluck(*column_names).first</code>, and is primarily useful when you have a relation that’s already narrowed down to a single row.</p> <p>Just like <a href="calculations.html#method-i-pluck"><code>pluck</code></a>, <a href="calculations.html#method-i-pick"><code>pick</code></a> will only load the actual value, not the entire record object, so it’s also more efficient. The value is, again like with pluck, typecast by the column type.</p> <pre class="ruby" data-language="ruby">Person.where(id: 1).pick(:name)
# SELECT people.name FROM people WHERE id = 1 LIMIT 1
# =&gt; 'David'

Person.where(id: 1).pick(:name, :email_address)
# SELECT people.name, people.email_address FROM people WHERE id = 1 LIMIT 1
# =&gt; [ 'David', 'david@loudthinking.com' ]
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-pluck"> <span class="method-name">pluck</span><span class="method-args">(*column_names)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="pluck-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation/calculations.rb, line 287
def pluck(*column_names)
  if @none
    if @async
      return Promise::Complete.new([])
    else
      return []
    end
  end

  if loaded? &amp;&amp; all_attributes?(column_names)
    result = records.pluck(*column_names)
    if @async
      return Promise::Complete.new(result)
    else
      return result
    end
  end

  if has_include?(column_names.first)
    relation = apply_join_dependency
    relation.pluck(*column_names)
  else
    klass.disallow_raw_sql!(flattened_args(column_names))
    columns = arel_columns(column_names)
    relation = spawn
    relation.select_values = columns
    result = skip_query_cache_if_necessary do
      if where_clause.contradiction?
        ActiveRecord::Result.empty(async: @async)
      else
        klass.with_connection do |c|
          c.select_all(relation.arel, "#{klass.name} Pluck", async: @async)
        end
      end
    end
    result.then do |result|
      type_cast_pluck_values(result, columns)
    end
  end
end</pre> </div> <p>Use <a href="calculations.html#method-i-pluck"><code>pluck</code></a> as a shortcut to select one or more attributes without loading an entire record object per row.</p> <pre class="ruby" data-language="ruby">Person.pluck(:name)
</pre> <p>instead of</p> <pre class="ruby" data-language="ruby">Person.all.map(&amp;:name)
</pre> <p>Pluck returns an <a href="../array.html"><code>Array</code></a> of attribute values type-casted to match the plucked column names, if they can be deduced. Plucking an SQL fragment returns <a href="../string.html"><code>String</code></a> values by default.</p> <pre class="ruby" data-language="ruby">Person.pluck(:name)
# SELECT people.name FROM people
# =&gt; ['David', 'Jeremy', 'Jose']

Person.pluck(:id, :name)
# SELECT people.id, people.name FROM people
# =&gt; [[1, 'David'], [2, 'Jeremy'], [3, 'Jose']]

Person.distinct.pluck(:role)
# SELECT DISTINCT role FROM people
# =&gt; ['admin', 'member', 'guest']

Person.where(age: 21).limit(5).pluck(:id)
# SELECT people.id FROM people WHERE people.age = 21 LIMIT 5
# =&gt; [2, 3]

Comment.joins(:person).pluck(:id, person: [:id])
# SELECT comments.id, people.id FROM comments INNER JOIN people on comments.person_id = people.id
# =&gt; [[1, 2], [2, 2]]

Person.pluck(Arel.sql('DATEDIFF(updated_at, created_at)'))
# SELECT DATEDIFF(updated_at, created_at) FROM people
# =&gt; ['0', '27761', '173']
</pre> <p>See also <a href="calculations.html#method-i-ids"><code>ids</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-sum"> <span class="method-name">sum</span><span class="method-args">(initial_value_or_column = 0, &amp;block)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="sum-source"> <pre class="ruby" data-language="ruby"># File activerecord/lib/active_record/relation/calculations.rb, line 172
def sum(initial_value_or_column = 0, &amp;block)
  if block_given?
    map(&amp;block).sum(initial_value_or_column)
  else
    calculate(:sum, initial_value_or_column)
  end
end</pre> </div> <p>Calculates the sum of values on a given column. The value is returned with the same data type of the column, <code>0</code> if there’s no row. See <a href="calculations.html#method-i-calculate"><code>calculate</code></a> for examples with options.</p> <pre class="ruby" data-language="ruby">Person.sum(:age) # =&gt; 4562
</pre> <p>When given a block, loads all records in the relation, if the relation hasn’t been loaded yet. Calls the block with each record in the relation. Returns the sum of <code>initial_value_or_column</code> and the block return values:</p> <pre class="ruby" data-language="ruby">Person.sum { |person| person.age } # =&gt; 4562
Person.sum(1000) { |person| person.age } # =&gt; 5562
</pre> <p>Note: If there are a lot of records in the relation, loading all records could result in performance issues.</p>  </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2004&ndash;2021 David Heinemeier Hansson<br>Licensed under the MIT License.<br>
    
  </p>
</div>
