<h1>Fixtures</h1> <p>A test usually follows the “Arrange, Act, Assert” structure: <strong>arranging</strong> all necessary preconditions and inputs (the so-called <em>test fixture</em>), <strong>acting</strong> on the object under test, and <strong>asserting</strong> that the expected results have occurred.</p> <div class="admonition-arrange-expect-act admonition"> <p class="admonition-title">Arrange, Expect, Act</p> <p>When you expect an action to raise an exception or when you verify the communication between collaborating objects using mock objects then the test usually follows the “Arrange, Expect, Act” structure.</p> </div> <p>Sometimes the <em>test fixture</em> is made up of a single object, sometimes it is a more complex object graph, for instance. The amount of code needed to set it up will grow accordingly. The actual content of the test gets lost in the noise of setting up the test fixture. This problem gets even worse when you write several tests with similar test fixtures.</p> <p>PHPUnit supports the reuse of setup code between tests. Before a test method is run, a template method named <code class="docutils literal notranslate"><span class="pre">setUp()</span></code> is invoked: this is where you can create your test fixture. Once the test method has finished running, whether it succeeded or failed, another template method named <code class="docutils literal notranslate"><span class="pre">tearDown()</span></code> is invoked: this is where you can clean up the objects against which you tested.</p> <div class="literal-block-wrapper docutils container" id="fixtures-examples-exampletest-php"> <div class="code-block-caption">
<span class="caption-number">Example 5.1 </span><span class="caption-text">Example of a test class that uses setUp() and tearDown()</span><a class="headerlink" href="#fixtures-examples-exampletest-php" title="Permalink to this code"></a>
</div> <div class="highlight-php notranslate">
<div class="highlight"><pre class="highlight" data-language="php"><span class="o">&lt;?</span><span class="nx">php</span> <span class="k">declare</span><span class="p">(</span><span class="nx">strict_types</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">namespace</span> <span class="nx">example</span><span class="p">;</span>

<span class="k">use</span> <span class="nx">PHPUnit\Framework\TestCase</span><span class="p">;</span>

<span class="k">final</span> <span class="k">class</span> <span class="nc">ExampleTest</span> <span class="k">extends</span> <span class="nx">TestCase</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="o">?</span><span class="nx">Example</span> <span class="nv">$example</span><span class="p">;</span>

    <span class="k">public</span> <span class="k">function</span> <span class="nf">testSomething</span><span class="p">()</span><span class="o">:</span> <span class="nx">void</span>
    <span class="p">{</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">assertSame</span><span class="p">(</span>
            <span class="s1">'the-result'</span><span class="p">,</span>
            <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">example</span><span class="o">-&gt;</span><span class="na">doSomething</span><span class="p">()</span>
        <span class="p">);</span>
    <span class="p">}</span>

    <span class="k">protected</span> <span class="k">function</span> <span class="nf">setUp</span><span class="p">()</span><span class="o">:</span> <span class="nx">void</span>
    <span class="p">{</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">example</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Example</span><span class="p">(</span>
            <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">createStub</span><span class="p">(</span><span class="nx">Collaborator</span><span class="o">::</span><span class="na">class</span><span class="p">)</span>
        <span class="p">);</span>
    <span class="p">}</span>

    <span class="k">protected</span> <span class="k">function</span> <span class="nf">tearDown</span><span class="p">()</span><span class="o">:</span> <span class="nx">void</span>
    <span class="p">{</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">example</span> <span class="o">=</span> <span class="k">null</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div> </div> </div> <p>The <code class="docutils literal notranslate"><span class="pre">setUp()</span></code> and <code class="docutils literal notranslate"><span class="pre">tearDown()</span></code> template methods are run once for each test method (and on fresh instances) of the test case class.</p> <p>One problem with the <code class="docutils literal notranslate"><span class="pre">setUp()</span></code> and <code class="docutils literal notranslate"><span class="pre">tearDown()</span></code> template methods is that they are called even for tests that do not use the test fixture managed by these methods, in the example shown above the <code class="docutils literal notranslate"><span class="pre">$this-&gt;example</span></code> property.</p> <p>Another problem can occur when inheritance comes into play:</p> <div class="literal-block-wrapper docutils container" id="fixtures-examples-mytestcase-php"> <div class="code-block-caption">
<span class="caption-number">Example 5.2 </span><span class="caption-text">Example of an abstract test case class with a setUp() method</span><a class="headerlink" href="#fixtures-examples-mytestcase-php" title="Permalink to this code"></a>
</div> <div class="highlight-php notranslate">
<div class="highlight"><pre class="highlight" data-language="php"><span class="o">&lt;?</span><span class="nx">php</span> <span class="k">declare</span><span class="p">(</span><span class="nx">strict_types</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">use</span> <span class="nx">PHPUnit\Framework\TestCase</span><span class="p">;</span>

<span class="k">abstract</span> <span class="k">class</span> <span class="nc">MyTestCase</span> <span class="k">extends</span> <span class="nx">TestCase</span>
<span class="p">{</span>
    <span class="k">protected</span> <span class="k">function</span> <span class="nf">setUp</span><span class="p">()</span><span class="o">:</span> <span class="nx">void</span>
    <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div> </div> </div> <div class="literal-block-wrapper docutils container" id="fixtures-examples-exampletest2-php"> <div class="code-block-caption">
<span class="caption-number">Example 5.3 </span><span class="caption-text">Example of a concrete test case class that extends an abstract test case class with a setUp() method</span><a class="headerlink" href="#fixtures-examples-exampletest2-php" title="Permalink to this code"></a>
</div> <div class="highlight-php notranslate">
<div class="highlight"><pre class="highlight" data-language="php"><span class="o">&lt;?</span><span class="nx">php</span> <span class="k">declare</span><span class="p">(</span><span class="nx">strict_types</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">namespace</span> <span class="nx">example</span><span class="p">;</span>

<span class="k">use</span> <span class="nx">PHPUnit\Framework\TestCase</span><span class="p">;</span>

<span class="k">final</span> <span class="k">class</span> <span class="nc">ExampleTest</span> <span class="k">extends</span> <span class="nx">MyTestCase</span>
<span class="p">{</span>
    <span class="k">protected</span> <span class="k">function</span> <span class="nf">setUp</span><span class="p">()</span><span class="o">:</span> <span class="nx">void</span>
    <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div> </div> </div> <p>If we forget to call <code class="docutils literal notranslate"><span class="pre">parent::setUp()</span></code> when implementing <code class="docutils literal notranslate"><span class="pre">ExampleTest::setUp()</span></code>, the functionality provided by <code class="docutils literal notranslate"><span class="pre">MyTestCase</span></code> will not work. To reduce this risk, the <a class="reference internal" href="attributes.html#appendixes-attributes"><span class="std std-ref">attributes</span></a> <code class="docutils literal notranslate"><span class="pre">PHPUnit\Framework\Attributes\Before</span></code> and <code class="docutils literal notranslate"><span class="pre">PHPUnit\Framework\Attributes\After</span></code> are available. With these, multiple methods can be configured to be called before and after a test, respectively.</p> <section id="more-setup-than-teardown"> <h2>More setUp() than tearDown()<a class="headerlink" href="#more-setup-than-teardown" title="Permalink to this heading"></a>
</h2> <p><code class="docutils literal notranslate"><span class="pre">setUp()</span></code> and <code class="docutils literal notranslate"><span class="pre">tearDown()</span></code> are nicely symmetrical in theory, but not in practice. In practice, you only need to implement <code class="docutils literal notranslate"><span class="pre">tearDown()</span></code> if you have allocated external resources such as files or sockets in <code class="docutils literal notranslate"><span class="pre">setUp()</span></code>. Unless you create large object graphs in your <code class="docutils literal notranslate"><span class="pre">setUp()</span></code> and store them in properties of the test object, you can generally ignore <code class="docutils literal notranslate"><span class="pre">tearDown()</span></code>.</p> <p>However, if you create large object graphs in your <code class="docutils literal notranslate"><span class="pre">setUp()</span></code> and store them in properties of the test object, you may want to <code class="docutils literal notranslate"><span class="pre">unset()</span></code> the variables holding those objects in your <code class="docutils literal notranslate"><span class="pre">tearDown()</span></code> so that they can be garbage collected sooner.</p> <p>Objects created within <code class="docutils literal notranslate"><span class="pre">setUp()</span></code> (or test methods) that are stored in properties of the test object are only automatically garbage collected at the end of the PHP process that runs PHPUnit.</p> </section> <section id="sharing-fixture"> <h2>Sharing Fixture<a class="headerlink" href="#sharing-fixture" title="Permalink to this heading"></a>
</h2> <p>There are few good reasons to share fixtures between tests, but in most cases the need to share a fixture between tests stems from an unresolved design problem.</p> <p>A good example of a fixture that makes sense to share across several tests is a database connection: you log into the database once and reuse the database connection instead of creating a new connection for each test. This makes your tests run faster.</p> <p>The <code class="docutils literal notranslate"><span class="pre">setUpBeforeClass()</span></code> and <code class="docutils literal notranslate"><span class="pre">tearDownAfterClass()</span></code> template methods are called before the first test of the test case class is run and after the last test of the test case class is run, respectively.</p> <div class="admonition-do-not-use-assertions-in-setupbeforeclass-or-teardownafterclass admonition"> <p class="admonition-title">Do not use assertions in <code class="docutils literal notranslate"><span class="pre">setUpBeforeClass()</span></code> or <code class="docutils literal notranslate"><span class="pre">tearDownAfterClass()</span></code></p> <p>Please note that using assertions in <code class="docutils literal notranslate"><span class="pre">setUpBeforeClass()</span></code> or <code class="docutils literal notranslate"><span class="pre">tearDownAfterClass()</span></code> methods leads to undefined behavior. The only reason why using assertions in these template methods does not lead to an error being emitted by the test runner is that we want to avoid the runtime overhead of determining whether an assertion method is called from these template methods.</p> </div> <p><a class="reference internal" href="#fixtures-sharing-fixture-examples-databasetest-php"><span class="std std-numref">Example 5.4</span></a> uses the <code class="docutils literal notranslate"><span class="pre">setUpBeforeClass()</span></code> and <code class="docutils literal notranslate"><span class="pre">tearDownAfterClass()</span></code> template methods to connect to the database before the test case class’ first test and to disconnect from the database after the last test of the test case, respectively.</p> <div class="literal-block-wrapper docutils container" id="fixtures-sharing-fixture-examples-databasetest-php"> <div class="code-block-caption">
<span class="caption-number">Example 5.4 </span><span class="caption-text">Sharing fixture between the tests of a test suite</span><a class="headerlink" href="#fixtures-sharing-fixture-examples-databasetest-php" title="Permalink to this code"></a>
</div> <div class="highlight-php notranslate">
<div class="highlight"><pre class="highlight" data-language="php"><span class="o">&lt;?</span><span class="nx">php</span> <span class="k">declare</span><span class="p">(</span><span class="nx">strict_types</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
<span class="k">use</span> <span class="nx">PHPUnit\Framework\TestCase</span><span class="p">;</span>

<span class="k">final</span> <span class="k">class</span> <span class="nc">DatabaseTest</span> <span class="k">extends</span> <span class="nx">TestCase</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">static</span> <span class="nv">$dbh</span><span class="p">;</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">function</span> <span class="nf">setUpBeforeClass</span><span class="p">()</span><span class="o">:</span> <span class="nx">void</span>
    <span class="p">{</span>
        <span class="nx">self</span><span class="o">::</span><span class="nv">$dbh</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">PDO</span><span class="p">(</span><span class="s1">'sqlite::memory:'</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">function</span> <span class="nf">tearDownAfterClass</span><span class="p">()</span><span class="o">:</span> <span class="nx">void</span>
    <span class="p">{</span>
        <span class="nx">self</span><span class="o">::</span><span class="nv">$dbh</span> <span class="o">=</span> <span class="k">null</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div> </div> </div> <p>It cannot be emphasized enough that sharing fixtures between tests reduces the value of the tests. The underlying design problem is that objects are not loosely coupled. You will achieve better results solving the underlying design problem and then writing tests using stubs (see <a class="reference internal" href="test-doubles.html#test-doubles"><span class="std std-ref">Test Doubles</span></a>), than by creating dependencies between tests at runtime and ignoring the opportunity to improve your design.</p> </section> <section id="global-state"> <h2>Global State<a class="headerlink" href="#global-state" title="Permalink to this heading"></a>
</h2> <p><a class="reference external" href="http://googletesting.blogspot.com/2008/05/tott-using-dependancy-injection-to.html">It is hard to test code that uses singletons.</a> The same is true for code that uses global variables. Typically, the code you want to test is coupled strongly with a global variable and you cannot control its creation. An additional problem is the fact that one test’s change to a global variable might break another test.</p> <p>In PHP, global variables work like this:</p> <ul class="simple"> <li><p>A global variable <code class="docutils literal notranslate"><span class="pre">$foo</span> <span class="pre">=</span> <span class="pre">'bar';</span></code> is stored as <code class="docutils literal notranslate"><span class="pre">$GLOBALS['foo']</span> <span class="pre">=</span> <span class="pre">'bar';</span></code>.</p></li> <li><p>The <code class="docutils literal notranslate"><span class="pre">$GLOBALS</span></code> variable is a so-called <em>super-global</em> variable.</p></li> <li><p>Super-global variables are built-in variables that are always available in all scopes.</p></li> <li><p>In the scope of a function or method, you may access the global variable <code class="docutils literal notranslate"><span class="pre">$foo</span></code> by either directly accessing <code class="docutils literal notranslate"><span class="pre">$GLOBALS['foo']</span></code> or by using <code class="docutils literal notranslate"><span class="pre">global</span> <span class="pre">$foo;</span></code> to create a local variable with a reference to the global variable.</p></li> </ul> <p>Besides global variables, static properties of classes are also part of the global state.</p> <p>PHPUnit can optionally run your tests in a way where changes to global and super-global variables (<code class="docutils literal notranslate"><span class="pre">$GLOBALS</span></code>, <code class="docutils literal notranslate"><span class="pre">$_ENV</span></code>, <code class="docutils literal notranslate"><span class="pre">$_POST</span></code>, <code class="docutils literal notranslate"><span class="pre">$_GET</span></code>, <code class="docutils literal notranslate"><span class="pre">$_COOKIE</span></code>, <code class="docutils literal notranslate"><span class="pre">$_SERVER</span></code>, <code class="docutils literal notranslate"><span class="pre">$_FILES</span></code>, <code class="docutils literal notranslate"><span class="pre">$_REQUEST</span></code>) do not affect other tests. You can activate this behaviour by using the <code class="docutils literal notranslate"><span class="pre">--globals-backup</span></code> option or by setting <code class="docutils literal notranslate"><span class="pre">backupGlobals="true"</span></code> in the XML configuration file.</p> <p>By using the <code class="docutils literal notranslate"><span class="pre">--static-backup</span></code> option or setting <code class="docutils literal notranslate"><span class="pre">backupStaticProperties="true"</span></code> in the XML configuration file, this isolation can be extended to static properties of classes.</p> <div class="admonition-note admonition"> <p class="admonition-title">Note</p> <p>The backup and restore operations for global variables and static class properties use <code class="docutils literal notranslate"><span class="pre">serialize()</span></code> and <code class="docutils literal notranslate"><span class="pre">unserialize()</span></code>.</p> <p>Objects of some classes (e.g., <code class="docutils literal notranslate"><span class="pre">PDO</span></code>) cannot be serialized and the backup operation will break when such an object is stored e.g. in the <code class="docutils literal notranslate"><span class="pre">$GLOBALS</span></code> array.</p> </div> <p>The <code class="docutils literal notranslate"><span class="pre">PHPUnit\Framework\Attributes\BackupGlobals</span></code> attribute can be used to control the backup and restore operations for global variables.</p> <p>The <code class="docutils literal notranslate"><span class="pre">PHPUnit\Framework\Attributes\ExcludeGlobalVariableFromBackup</span></code> attribute can be used to exclude specific global variables from the backup and restore operations for global variables.</p> <p>The <code class="docutils literal notranslate"><span class="pre">PHPUnit\Framework\Attributes\BackupStaticProperties</span></code> attribute can be used to control the backup and restore operations for static properties of classes. This affects all static properties in all declared classes before each test and restore them afterwards. All classes that are declared at the time a test starts are processed, not only the test class itself. It only applies to static class properties, not static variables within functions.</p> <p>The <code class="docutils literal notranslate"><span class="pre">PHPUnit\Framework\Attributes\ExcludeStaticPropertyFromBackup</span></code> attribute can be used to exclude specific static properties from the backup and restore operations for static properties.</p> <div class="admonition-note admonition"> <p class="admonition-title">Note</p> <p>The backup operation for static properties of classes is performed before a test method, but only if it is enabled. If a static value was changed by a previously executed test that did not have <code class="docutils literal notranslate"><span class="pre">BackupStaticProperties(true)</span></code>, then that value will be backed up and restored — not the originally declared default value.</p> <p>The same applies to static properties of classes that were newly loaded/declared within a test. They cannot be reset to their originally declared default value after the test, since that value is unknown. Whichever value is set will leak into subsequent tests.</p> </div> <p>For unit tests, it is recommended to explicitly reset the values of static properties under test in your <code class="docutils literal notranslate"><span class="pre">setUp()</span></code> code instead (and ideally also <code class="docutils literal notranslate"><span class="pre">tearDown()</span></code>, so as to not affect subsequently executed tests).</p> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2025 Sebastian Bergmann<br>Licensed under the Creative Commons Attribution 3.0 Unported License.<br>
    <a href="https://docs.phpunit.de/en/12.0/fixtures.html" class="_attribution-link">https://docs.phpunit.de/en/12.0/fixtures.html</a>
  </p>
</div>
