<h1 id="doc-your-first-2d-game-the-main-game-scene">The main game scene</h1> <p>Now it's time to bring everything we did together into a playable game scene.</p> <p>Create a new scene and add a <a href="../../classes/class_node.html#class-node"><span class="std std-ref">Node</span></a> named <code>Main</code>. (The reason we are using Node instead of Node2D is because this node will be a container for handling game logic. It does not require 2D functionality itself.)</p> <p>Click the <strong>Instance</strong> button (represented by a chain link icon) and select your saved <code>Player.tscn</code>.</p> <img alt="../../_images/instance_scene.png" src="https://docs.godotengine.org/en/3.5/_images/instance_scene.png"> <p>Now, add the following nodes as children of <code>Main</code>, and name them as shown (values are in seconds):</p> <ul class="simple"> <li>
<a href="../../classes/class_timer.html#class-timer"><span class="std std-ref">Timer</span></a> (named <code>MobTimer</code>) - to control how often mobs spawn</li> <li>
<a href="../../classes/class_timer.html#class-timer"><span class="std std-ref">Timer</span></a> (named <code>ScoreTimer</code>) - to increment the score every second</li> <li>
<a href="../../classes/class_timer.html#class-timer"><span class="std std-ref">Timer</span></a> (named <code>StartTimer</code>) - to give a delay before starting</li> <li>
<a href="../../classes/class_position2d.html#class-position2d"><span class="std std-ref">Position2D</span></a> (named <code>StartPosition</code>) - to indicate the player's start position</li> </ul> <p>Set the <code>Wait Time</code> property of each of the <code>Timer</code> nodes as follows:</p> <ul class="simple"> <li>
<code>MobTimer</code>: <code>0.5</code>
</li> <li>
<code>ScoreTimer</code>: <code>1</code>
</li> <li>
<code>StartTimer</code>: <code>2</code>
</li> </ul> <p>In addition, set the <code>One Shot</code> property of <code>StartTimer</code> to "On" and set <code>Position</code> of the <code>StartPosition</code> node to <code>(240, 450)</code>.</p> <section id="spawning-mobs"> <h2>Spawning mobs</h2> <p>The Main node will be spawning new mobs, and we want them to appear at a random location on the edge of the screen. Add a <a href="../../classes/class_path2d.html#class-path2d"><span class="std std-ref">Path2D</span></a> node named <code>MobPath</code> as a child of <code>Main</code>. When you select <code>Path2D</code>, you will see some new buttons at the top of the editor:</p> <img alt="../../_images/path2d_buttons.png" src="https://docs.godotengine.org/en/3.5/_images/path2d_buttons.png"> <p>Select the middle one ("Add Point") and draw the path by clicking to add the points at the corners shown. To have the points snap to the grid, make sure "Use Grid Snap" and "Use Snap" are both selected. These options can be found to the left of the "Lock" button, appearing as a magnet next to some dots and intersecting lines, respectively.</p> <img alt="../../_images/grid_snap_button.png" src="https://docs.godotengine.org/en/3.5/_images/grid_snap_button.png"> <div class="admonition important"> <p class="admonition-title">Important</p> <p>Draw the path in <em>clockwise</em> order, or your mobs will spawn pointing <em>outwards</em> instead of <em>inwards</em>!</p> </div> <img alt="../../_images/draw_path2d.gif" src="https://docs.godotengine.org/en/3.5/_images/draw_path2d.gif"> <p>After placing point <code>4</code> in the image, click the "Close Curve" button and your curve will be complete.</p> <p>Now that the path is defined, add a <a href="../../classes/class_pathfollow2d.html#class-pathfollow2d"><span class="std std-ref">PathFollow2D</span></a> node as a child of <code>MobPath</code> and name it <code>MobSpawnLocation</code>. This node will automatically rotate and follow the path as it moves, so we can use it to select a random position and direction along the path.</p> <p>Your scene should look like this:</p> <img alt="../../_images/main_scene_nodes.png" src="https://docs.godotengine.org/en/3.5/_images/main_scene_nodes.png"> </section> <section id="main-script"> <h2>Main script</h2> <p>Add a script to <code>Main</code>. At the top of the script, we use <code>export
(PackedScene)</code> to allow us to choose the Mob scene we want to instance.</p> <div class="sphinx-tabs docutils container"> <div aria-label="Tabbed content" class="closeable" role="tablist">
<button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" class="sphinx-tabs-tab code-tab group-tab" id="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button><button aria-controls="panel-0-QyM=" aria-selected="false" class="sphinx-tabs-tab code-tab group-tab" id="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button><button aria-controls="panel-0-Qysr" aria-selected="false" class="sphinx-tabs-tab code-tab group-tab" id="tab-0-Qysr" name="Qysr" role="tab" tabindex="-1">C++</button>
</div>
<div aria-labelledby="tab-0-R0RTY3JpcHQ=" class="sphinx-tabs-panel code-tab group-tab" id="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
<pre data-language="gdscript">extends Node

export(PackedScene) var mob_scene
var score
</pre> </div>
<div aria-labelledby="tab-0-QyM=" class="sphinx-tabs-panel code-tab group-tab" hidden="true" id="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
<pre data-language="csharp">public class Main : Node
{
    // Don't forget to rebuild the project so the editor knows about the new export variable.

#pragma warning disable 649
    // We assign this in the editor, so we don't need the warning about not being assigned.
    [Export]
    public PackedScene MobScene;
#pragma warning restore 649

    public int Score;
}
</pre> </div>
<div aria-labelledby="tab-0-Qysr" class="sphinx-tabs-panel code-tab group-tab" hidden="true" id="panel-0-Qysr" name="Qysr" role="tabpanel" tabindex="0">
<pre data-language="cpp">// Copy `player.gdns` to `main.gdns` and replace `Player` with `Main`.
// Attach the `main.gdns` file to the Main node.

// Create two files `main.cpp` and `main.hpp` next to `entry.cpp` in `src`.
// This code goes in `main.hpp`. We also define the methods we'll be using here.
#ifndef MAIN_H
#define MAIN_H

#include &lt;AudioStreamPlayer.hpp&gt;
#include &lt;CanvasLayer.hpp&gt;
#include &lt;Godot.hpp&gt;
#include &lt;Node.hpp&gt;
#include &lt;PackedScene.hpp&gt;
#include &lt;PathFollow2D.hpp&gt;
#include &lt;RandomNumberGenerator.hpp&gt;
#include &lt;Timer.hpp&gt;

#include "hud.hpp"
#include "player.hpp"

class Main : public godot::Node {
    GODOT_CLASS(Main, godot::Node)

    int score;
    HUD *_hud;
    Player *_player;
    godot::Node2D *_start_position;
    godot::PathFollow2D *_mob_spawn_location;
    godot::Timer *_mob_timer;
    godot::Timer *_score_timer;
    godot::Timer *_start_timer;
    godot::AudioStreamPlayer *_music;
    godot::AudioStreamPlayer *_death_sound;
    godot::Ref&lt;godot::RandomNumberGenerator&gt; _random;

public:
    godot::Ref&lt;godot::PackedScene&gt; mob_scene;

    void _init() {}
    void _ready();
    void game_over();
    void new_game();
    void _on_MobTimer_timeout();
    void _on_ScoreTimer_timeout();
    void _on_StartTimer_timeout();

    static void _register_methods();
};

#endif // MAIN_H
</pre> </div>
</div> <p>We also add a call to <code>randomize()</code> here so that the random number generator generates different random numbers each time the game is run:</p> <div class="sphinx-tabs docutils container"> <div aria-label="Tabbed content" class="closeable" role="tablist">
<button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" class="sphinx-tabs-tab code-tab group-tab" id="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button><button aria-controls="panel-1-QyM=" aria-selected="false" class="sphinx-tabs-tab code-tab group-tab" id="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button><button aria-controls="panel-1-Qysr" aria-selected="false" class="sphinx-tabs-tab code-tab group-tab" id="tab-1-Qysr" name="Qysr" role="tab" tabindex="-1">C++</button>
</div>
<div aria-labelledby="tab-1-R0RTY3JpcHQ=" class="sphinx-tabs-panel code-tab group-tab" id="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
<pre data-language="gdscript">func _ready():
    randomize()
</pre> </div>
<div aria-labelledby="tab-1-QyM=" class="sphinx-tabs-panel code-tab group-tab" hidden="true" id="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
<pre data-language="csharp">public override void _Ready()
{
    GD.Randomize();
}
</pre> </div>
<div aria-labelledby="tab-1-Qysr" class="sphinx-tabs-panel code-tab group-tab" hidden="true" id="panel-1-Qysr" name="Qysr" role="tabpanel" tabindex="0">
<pre data-language="cpp">// This code goes in `main.cpp`.
#include "main.hpp"

#include &lt;SceneTree.hpp&gt;

#include "mob.hpp"

void Main::_ready() {
    _hud = get_node&lt;HUD&gt;("HUD");
    _player = get_node&lt;Player&gt;("Player");
    _start_position = get_node&lt;godot::Node2D&gt;("StartPosition");
    _mob_spawn_location = get_node&lt;godot::PathFollow2D&gt;("MobPath/MobSpawnLocation");
    _mob_timer = get_node&lt;godot::Timer&gt;("MobTimer");
    _score_timer = get_node&lt;godot::Timer&gt;("ScoreTimer");
    _start_timer = get_node&lt;godot::Timer&gt;("StartTimer");
    // Uncomment these after adding the nodes in the "Sound effects" section of "Finishing up".
    //_music = get_node&lt;godot::AudioStreamPlayer&gt;("Music");
    //_death_sound = get_node&lt;godot::AudioStreamPlayer&gt;("DeathSound");
    _random = (godot::Ref&lt;godot::RandomNumberGenerator&gt;)godot::RandomNumberGenerator::_new();
    _random-&gt;randomize();
}
</pre> </div>
</div> <p>Click the <code>Main</code> node and you will see the <code>Mob Scene</code> property in the Inspector under "Script Variables".</p> <p>You can assign this property's value in two ways:</p> <ul class="simple"> <li>Drag <code>Mob.tscn</code> from the "FileSystem" dock and drop it in the <strong>Mob Scene</strong> property.</li> <li>Click the down arrow next to "[empty]" and choose "Load". Select <code>Mob.tscn</code>.</li> </ul> <p>Next, select the <code>Player</code> node in the Scene dock, and access the Node dock on the sidebar. Make sure to have the Signals tab selected in the Node dock.</p> <p>You should see a list of the signals for the <code>Player</code> node. Find and double-click the <code>hit</code> signal in the list (or right-click it and select "Connect..."). This will open the signal connection dialog. We want to make a new function named <code>game_over</code>, which will handle what needs to happen when a game ends. Type "game_over" in the "Receiver Method" box at the bottom of the signal connection dialog and click "Connect". Add the following code to the new function, as well as a <code>new_game</code> function that will set everything up for a new game:</p> <div class="sphinx-tabs docutils container"> <div aria-label="Tabbed content" class="closeable" role="tablist">
<button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" class="sphinx-tabs-tab code-tab group-tab" id="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button><button aria-controls="panel-2-QyM=" aria-selected="false" class="sphinx-tabs-tab code-tab group-tab" id="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button><button aria-controls="panel-2-Qysr" aria-selected="false" class="sphinx-tabs-tab code-tab group-tab" id="tab-2-Qysr" name="Qysr" role="tab" tabindex="-1">C++</button>
</div>
<div aria-labelledby="tab-2-R0RTY3JpcHQ=" class="sphinx-tabs-panel code-tab group-tab" id="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
<pre data-language="gdscript">func game_over():
    $ScoreTimer.stop()
    $MobTimer.stop()

func new_game():
    score = 0
    $Player.start($StartPosition.position)
    $StartTimer.start()
</pre> </div>
<div aria-labelledby="tab-2-QyM=" class="sphinx-tabs-panel code-tab group-tab" hidden="true" id="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
<pre data-language="csharp">public void GameOver()
{
    GetNode&lt;Timer&gt;("MobTimer").Stop();
    GetNode&lt;Timer&gt;("ScoreTimer").Stop();
}

public void NewGame()
{
    Score = 0;

    var player = GetNode&lt;Player&gt;("Player");
    var startPosition = GetNode&lt;Position2D&gt;("StartPosition");
    player.Start(startPosition.Position);

    GetNode&lt;Timer&gt;("StartTimer").Start();
}
</pre> </div>
<div aria-labelledby="tab-2-Qysr" class="sphinx-tabs-panel code-tab group-tab" hidden="true" id="panel-2-Qysr" name="Qysr" role="tabpanel" tabindex="0">
<pre data-language="cpp">// This code goes in `main.cpp`.
void Main::game_over() {
    _score_timer-&gt;stop();
    _mob_timer-&gt;stop();
}

void Main::new_game() {
    score = 0;
    _player-&gt;start(_start_position-&gt;get_position());
    _start_timer-&gt;start();
}
</pre> </div>
</div> <p>Now connect the <code>timeout()</code> signal of each of the Timer nodes (<code>StartTimer</code>, <code>ScoreTimer</code> , and <code>MobTimer</code>) to the main script. <code>StartTimer</code> will start the other two timers. <code>ScoreTimer</code> will increment the score by 1.</p> <div class="sphinx-tabs docutils container"> <div aria-label="Tabbed content" class="closeable" role="tablist">
<button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" class="sphinx-tabs-tab code-tab group-tab" id="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button><button aria-controls="panel-3-QyM=" aria-selected="false" class="sphinx-tabs-tab code-tab group-tab" id="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button><button aria-controls="panel-3-Qysr" aria-selected="false" class="sphinx-tabs-tab code-tab group-tab" id="tab-3-Qysr" name="Qysr" role="tab" tabindex="-1">C++</button>
</div>
<div aria-labelledby="tab-3-R0RTY3JpcHQ=" class="sphinx-tabs-panel code-tab group-tab" id="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
<pre data-language="gdscript">func _on_ScoreTimer_timeout():
    score += 1

func _on_StartTimer_timeout():
    $MobTimer.start()
    $ScoreTimer.start()
</pre> </div>
<div aria-labelledby="tab-3-QyM=" class="sphinx-tabs-panel code-tab group-tab" hidden="true" id="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
<pre data-language="csharp">public void OnScoreTimerTimeout()
{
    Score++;
}

public void OnStartTimerTimeout()
{
    GetNode&lt;Timer&gt;("MobTimer").Start();
    GetNode&lt;Timer&gt;("ScoreTimer").Start();
}
</pre> </div>
<div aria-labelledby="tab-3-Qysr" class="sphinx-tabs-panel code-tab group-tab" hidden="true" id="panel-3-Qysr" name="Qysr" role="tabpanel" tabindex="0">
<pre data-language="cpp">// This code goes in `main.cpp`.
void Main::_on_ScoreTimer_timeout() {
    score += 1;
}

void Main::_on_StartTimer_timeout() {
    _mob_timer-&gt;start();
    _score_timer-&gt;start();
}

// Also add this to register all methods and the mob scene property.
void Main::_register_methods() {
    godot::register_method("_ready", &amp;Main::_ready);
    godot::register_method("game_over", &amp;Main::game_over);
    godot::register_method("new_game", &amp;Main::new_game);
    godot::register_method("_on_MobTimer_timeout", &amp;Main::_on_MobTimer_timeout);
    godot::register_method("_on_ScoreTimer_timeout", &amp;Main::_on_ScoreTimer_timeout);
    godot::register_method("_on_StartTimer_timeout", &amp;Main::_on_StartTimer_timeout);
    godot::register_property("mob_scene", &amp;Main::mob_scene, (godot::Ref&lt;godot::PackedScene&gt;)nullptr);
}
</pre> </div>
</div> <p>In <code>_on_MobTimer_timeout()</code>, we will create a mob instance, pick a random starting location along the <code>Path2D</code>, and set the mob in motion. The <code>PathFollow2D</code> node will automatically rotate as it follows the path, so we will use that to select the mob's direction as well as its position. When we spawn a mob, we'll pick a random value between <code>150.0</code> and <code>250.0</code> for how fast each mob will move (it would be boring if they were all moving at the same speed).</p> <p>Note that a new instance must be added to the scene using <code>add_child()</code>.</p> <div class="sphinx-tabs docutils container"> <div aria-label="Tabbed content" class="closeable" role="tablist">
<button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" class="sphinx-tabs-tab code-tab group-tab" id="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button><button aria-controls="panel-4-QyM=" aria-selected="false" class="sphinx-tabs-tab code-tab group-tab" id="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button><button aria-controls="panel-4-Qysr" aria-selected="false" class="sphinx-tabs-tab code-tab group-tab" id="tab-4-Qysr" name="Qysr" role="tab" tabindex="-1">C++</button>
</div>
<div aria-labelledby="tab-4-R0RTY3JpcHQ=" class="sphinx-tabs-panel code-tab group-tab" id="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
<pre data-language="gdscript">func _on_MobTimer_timeout():
    # Create a new instance of the Mob scene.
    var mob = mob_scene.instance()

    # Choose a random location on Path2D.
    var mob_spawn_location = get_node("MobPath/MobSpawnLocation")
    mob_spawn_location.offset = randi()

    # Set the mob's direction perpendicular to the path direction.
    var direction = mob_spawn_location.rotation + PI / 2

    # Set the mob's position to a random location.
    mob.position = mob_spawn_location.position

    # Add some randomness to the direction.
    direction += rand_range(-PI / 4, PI / 4)
    mob.rotation = direction

    # Choose the velocity for the mob.
    var velocity = Vector2(rand_range(150.0, 250.0), 0.0)
    mob.linear_velocity = velocity.rotated(direction)

    # Spawn the mob by adding it to the Main scene.
    add_child(mob)
</pre> </div>
<div aria-labelledby="tab-4-QyM=" class="sphinx-tabs-panel code-tab group-tab" hidden="true" id="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
<pre data-language="csharp">public void OnMobTimerTimeout()
{
    // Note: Normally it is best to use explicit types rather than the `var`
    // keyword. However, var is acceptable to use here because the types are
    // obviously Mob and PathFollow2D, since they appear later on the line.

    // Create a new instance of the Mob scene.
    var mob = (Mob)MobScene.Instance();

    // Choose a random location on Path2D.
    var mobSpawnLocation = GetNode&lt;PathFollow2D&gt;("MobPath/MobSpawnLocation");
    mobSpawnLocation.Offset = GD.Randi();

    // Set the mob's direction perpendicular to the path direction.
    float direction = mobSpawnLocation.Rotation + Mathf.Pi / 2;

    // Set the mob's position to a random location.
    mob.Position = mobSpawnLocation.Position;

    // Add some randomness to the direction.
    direction += (float)GD.RandRange(-Mathf.Pi / 4, Mathf.Pi / 4);
    mob.Rotation = direction;

    // Choose the velocity.
    var velocity = new Vector2((float)GD.RandRange(150.0, 250.0), 0);
    mob.LinearVelocity = velocity.Rotated(direction);

    // Spawn the mob by adding it to the Main scene.
    AddChild(mob);
}
</pre> </div>
<div aria-labelledby="tab-4-Qysr" class="sphinx-tabs-panel code-tab group-tab" hidden="true" id="panel-4-Qysr" name="Qysr" role="tabpanel" tabindex="0">
<pre data-language="cpp">// This code goes in `main.cpp`.
void Main::_on_MobTimer_timeout() {
    // Create a new instance of the Mob scene.
    godot::Node *mob = mob_scene-&gt;instance();

    // Choose a random location on Path2D.
    _mob_spawn_location-&gt;set_offset((real_t)_random-&gt;randi());

    // Set the mob's direction perpendicular to the path direction.
    real_t direction = _mob_spawn_location-&gt;get_rotation() + (real_t)Math_PI / 2;

    // Set the mob's position to a random location.
    mob-&gt;set("position", _mob_spawn_location-&gt;get_position());

    // Add some randomness to the direction.
    direction += _random-&gt;randf_range((real_t)-Math_PI / 4, (real_t)Math_PI / 4);
    mob-&gt;set("rotation", direction);

    // Choose the velocity for the mob.
    godot::Vector2 velocity = godot::Vector2(_random-&gt;randf_range(150.0, 250.0), 0.0);
    mob-&gt;set("linear_velocity", velocity.rotated(direction));

    // Spawn the mob by adding it to the Main scene.
    add_child(mob);
}
</pre> </div>
</div> <div class="admonition important"> <p class="admonition-title">Important</p> <p>Why <code>PI</code>? In functions requiring angles, Godot uses <em>radians</em>, not degrees. Pi represents a half turn in radians, about <code>3.1415</code> (there is also <code>TAU</code> which is equal to <code>2 * PI</code>). If you're more comfortable working with degrees, you'll need to use the <code>deg2rad()</code> and <code>rad2deg()</code> functions to convert between the two.</p> </div> </section> <section id="testing-the-scene"> <h2>Testing the scene</h2> <p>Let's test the scene to make sure everything is working. Add this <code>new_game</code> call to <code>_ready()</code>:</p> <div class="sphinx-tabs docutils container"> <div aria-label="Tabbed content" class="closeable" role="tablist">
<button aria-controls="panel-5-R0RTY3JpcHQ=" aria-selected="true" class="sphinx-tabs-tab code-tab group-tab" id="tab-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button><button aria-controls="panel-5-QyM=" aria-selected="false" class="sphinx-tabs-tab code-tab group-tab" id="tab-5-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button><button aria-controls="panel-5-Qysr" aria-selected="false" class="sphinx-tabs-tab code-tab group-tab" id="tab-5-Qysr" name="Qysr" role="tab" tabindex="-1">C++</button>
</div>
<div aria-labelledby="tab-5-R0RTY3JpcHQ=" class="sphinx-tabs-panel code-tab group-tab" id="panel-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
<pre data-language="gdscript">func _ready():
    randomize()
    new_game()
</pre> </div>
<div aria-labelledby="tab-5-QyM=" class="sphinx-tabs-panel code-tab group-tab" hidden="true" id="panel-5-QyM=" name="QyM=" role="tabpanel" tabindex="0">
<pre data-language="csharp">public override void _Ready()
{
    NewGame();
}
</pre> </div>
<div aria-labelledby="tab-5-Qysr" class="sphinx-tabs-panel code-tab group-tab" hidden="true" id="panel-5-Qysr" name="Qysr" role="tabpanel" tabindex="0">
<pre data-language="cpp">// This code goes in `main.cpp`.
void Main::_ready() {
    new_game();
}
</pre> </div>
</div> <p>Let's also assign <code>Main</code> as our "Main Scene" - the one that runs automatically when the game launches. Press the "Play" button and select <code>Main.tscn</code> when prompted.</p> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>If you had already set another scene as the "Main Scene", you can right click <code>Main.tscn</code> in the FileSystem dock and select "Set As Main Scene".</p> </div> <p>You should be able to move the player around, see mobs spawning, and see the player disappear when hit by a mob.</p> <p>When you're sure everything is working, remove the call to <code>new_game()</code> from <code>_ready()</code>.</p> <p>What's our game lacking? Some user interface. In the next lesson, we'll add a title screen and display the player's score.</p> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2014&ndash;2022 Juan Linietsky, Ariel Manzur and the Godot community<br>Licensed under the Creative Commons Attribution Unported License v3.0.<br>
    <a href="https://docs.godotengine.org/en/3.5/getting_started/first_2d_game/05.the_main_game_scene.html" class="_attribution-link">https://docs.godotengine.org/en/3.5/getting_started/first_2d_game/05.the_main_game_scene.html</a>
  </p>
</div>
