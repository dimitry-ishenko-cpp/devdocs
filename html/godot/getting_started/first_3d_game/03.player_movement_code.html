<h1 id="doc-first-3d-game-player-movement">Moving the player with code</h1> <p>It's time to code! We're going to use the input actions we created in the last part to move the character.</p> <p>Right-click the <em>Player</em> node and select <em>Attach Script</em> to add a new script to it. In the popup, set the <em>Template</em> to <em>Empty</em> before pressing the <em>Create</em> button.</p> <p><img alt="image0" src="https://docs.godotengine.org/en/3.5/_images/01.attach_script_to_player.png"></p> <p>Let's start with the class's properties. We're going to define a movement speed, a fall acceleration representing gravity, and a velocity we'll use to move the character.</p> <div class="sphinx-tabs docutils container"> <div aria-label="Tabbed content" class="closeable" role="tablist">
<button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" class="sphinx-tabs-tab code-tab group-tab" id="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button><button aria-controls="panel-0-QyM=" aria-selected="false" class="sphinx-tabs-tab code-tab group-tab" id="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
</div>
<div aria-labelledby="tab-0-R0RTY3JpcHQ=" class="sphinx-tabs-panel code-tab group-tab" id="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
<pre data-language="gdscript">extends KinematicBody

# How fast the player moves in meters per second.
export var speed = 14
# The downward acceleration when in the air, in meters per second squared.
export var fall_acceleration = 75

var velocity = Vector3.ZERO
</pre> </div>
<div aria-labelledby="tab-0-QyM=" class="sphinx-tabs-panel code-tab group-tab" hidden="true" id="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
<pre data-language="csharp">public class Player : KinematicBody
{
    // Don't forget to rebuild the project so the editor knows about the new export variable.

    // How fast the player moves in meters per second.
    [Export]
    public int Speed = 14;
    // The downward acceleration when in the air, in meters per second squared.
    [Export]
    public int FallAcceleration = 75;

    private Vector3 _velocity = Vector3.Zero;
}
</pre> </div>
</div> <p>These are common properties for a moving body. The <code>velocity</code> is a 3D vector combining a speed with a direction. Here, we define it as a property because we want to update and reuse its value across frames.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The values are quite different from 2D code because distances are in meters. While in 2D, a thousand units (pixels) may only correspond to half of your screen's width, in 3D, it's a kilometer.</p> </div> <p>Let's code the movement now. We start by calculating the input direction vector using the global <code>Input</code> object, in <code>_physics_process()</code>.</p> <div class="sphinx-tabs docutils container"> <div aria-label="Tabbed content" class="closeable" role="tablist">
<button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" class="sphinx-tabs-tab code-tab group-tab" id="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button><button aria-controls="panel-1-QyM=" aria-selected="false" class="sphinx-tabs-tab code-tab group-tab" id="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
</div>
<div aria-labelledby="tab-1-R0RTY3JpcHQ=" class="sphinx-tabs-panel code-tab group-tab" id="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
<pre data-language="gdscript">func _physics_process(delta):
    # We create a local variable to store the input direction.
    var direction = Vector3.ZERO

    # We check for each move input and update the direction accordingly.
    if Input.is_action_pressed("move_right"):
        direction.x += 1
    if Input.is_action_pressed("move_left"):
        direction.x -= 1
    if Input.is_action_pressed("move_back"):
        # Notice how we are working with the vector's x and z axes.
        # In 3D, the XZ plane is the ground plane.
        direction.z += 1
    if Input.is_action_pressed("move_forward"):
        direction.z -= 1
</pre> </div>
<div aria-labelledby="tab-1-QyM=" class="sphinx-tabs-panel code-tab group-tab" hidden="true" id="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
<pre data-language="csharp">public override void _PhysicsProcess(float delta)
{
    // We create a local variable to store the input direction.
    var direction = Vector3.Zero;

    // We check for each move input and update the direction accordingly
    if (Input.IsActionPressed("move_right"))
    {
        direction.x += 1f;
    }
    if (Input.IsActionPressed("move_left"))
    {
        direction.x -= 1f;
    }
    if (Input.IsActionPressed("move_back"))
    {
        // Notice how we are working with the vector's x and z axes.
        // In 3D, the XZ plane is the ground plane.
        direction.z += 1f;
    }
    if (Input.IsActionPressed("move_forward"))
    {
        direction.z -= 1f;
    }
}
</pre> </div>
</div> <p>Here, we're going to make all calculations using the <code>_physics_process()</code> virtual function. Like <code>_process()</code>, it allows you to update the node every frame, but it's designed specifically for physics-related code like moving a kinematic or rigid body.</p> <div class="admonition seealso"> <p class="admonition-title">See also</p> <p>To learn more about the difference between <code>_process()</code> and <code>_physics_process()</code>, see <a href="https://docs.godotengine.org/en/3.5/tutorials/scripting/idle_and_physics_processing.html#doc-idle-and-physics-processing"><span class="std std-ref">Idle and Physics Processing</span></a>.</p> </div> <p>We start by initializing a <code>direction</code> variable to <code>Vector3.ZERO</code>. Then, we check if the player is pressing one or more of the <code>move_*</code> inputs and update the vector's <code>x</code> and <code>z</code> components accordingly. These correspond to the ground plane's axes.</p> <p>These four conditions give us eight possibilities and eight possible directions.</p> <p>In case the player presses, say, both W and D simultaneously, the vector will have a length of about <code>1.4</code>. But if they press a single key, it will have a length of <code>1</code>. We want the vector's length to be consistent. To do so, we can call its <code>normalize()</code> method.</p> <div class="sphinx-tabs docutils container"> <div aria-label="Tabbed content" class="closeable" role="tablist">
<button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" class="sphinx-tabs-tab code-tab group-tab" id="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button><button aria-controls="panel-2-QyM=" aria-selected="false" class="sphinx-tabs-tab code-tab group-tab" id="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
</div>
<div aria-labelledby="tab-2-R0RTY3JpcHQ=" class="sphinx-tabs-panel code-tab group-tab" id="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
<pre data-language="gdscript">#func _physics_process(delta):
    #...

    if direction != Vector3.ZERO:
        direction = direction.normalized()
        $Pivot.look_at(translation + direction, Vector3.UP)
</pre> </div>
<div aria-labelledby="tab-2-QyM=" class="sphinx-tabs-panel code-tab group-tab" hidden="true" id="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
<pre data-language="csharp">public override void _PhysicsProcess(float delta)
{
    // ...

    if (direction != Vector3.Zero)
    {
        direction = direction.Normalized();
        GetNode&lt;Spatial&gt;("Pivot").LookAt(Translation + direction, Vector3.Up);
    }
}
</pre> </div>
</div> <p>Here, we only normalize the vector if the direction has a length greater than zero, which means the player is pressing a direction key.</p> <p>In this case, we also get the <em>Pivot</em> node and call its <code>look_at()</code> method. This method takes a position in space to look at in global coordinates and the up direction. In this case, we can use the <code>Vector3.UP</code> constant.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>A node's local coordinates, like <code>translation</code>, are relative to their parent. Global coordinates are relative to the world's main axes you can see in the viewport instead.</p> </div> <p>In 3D, the property that contains a node's position is <code>translation</code>. By adding the <code>direction</code> to it, we get a position to look at that's one meter away from the <em>Player</em>.</p> <p>Then, we update the velocity. We have to calculate the ground velocity and the fall speed separately. Be sure to go back one tab so the lines are inside the <code>_physics_process()</code> function but outside the condition we just wrote.</p> <div class="sphinx-tabs docutils container"> <div aria-label="Tabbed content" class="closeable" role="tablist">
<button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" class="sphinx-tabs-tab code-tab group-tab" id="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button><button aria-controls="panel-3-QyM=" aria-selected="false" class="sphinx-tabs-tab code-tab group-tab" id="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
</div>
<div aria-labelledby="tab-3-R0RTY3JpcHQ=" class="sphinx-tabs-panel code-tab group-tab" id="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
<pre data-language="gdscript">func _physics_process(delta):
    #...
    if direction != Vector3.ZERO:
        #...

    # Ground velocity
    velocity.x = direction.x * speed
    velocity.z = direction.z * speed
    # Vertical velocity
    velocity.y -= fall_acceleration * delta
    # Moving the character
    velocity = move_and_slide(velocity, Vector3.UP)
</pre> </div>
<div aria-labelledby="tab-3-QyM=" class="sphinx-tabs-panel code-tab group-tab" hidden="true" id="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
<pre data-language="csharp">public override void _PhysicsProcess(float delta)
{
    // ...

    // Ground velocity
    _velocity.x = direction.x * Speed;
    _velocity.z = direction.z * Speed;
    // Vertical velocity
    _velocity.y -= FallAcceleration * delta;
    // Moving the character
    _velocity = MoveAndSlide(_velocity, Vector3.Up);
}
</pre> </div>
</div> <p>For the vertical velocity, we subtract the fall acceleration multiplied by the delta time every frame. Notice the use of the <code>-=</code> operator, which is a shorthand for <code>variable = variable - ...</code>.</p> <p>This line of code will cause our character to fall in every frame. This may seem strange if it's already on the floor. But we have to do this for the character to collide with the ground every frame.</p> <p>The physics engine can only detect interactions with walls, the floor, or other bodies during a given frame if movement and collisions happen. We will use this property later to code the jump.</p> <p>On the last line, we call <code>KinematicBody.move_and_slide()</code>. It's a powerful method of the <code>KinematicBody</code> class that allows you to move a character smoothly. If it hits a wall midway through a motion, the engine will try to smooth it out for you.</p> <p>The function takes two parameters: our velocity and the up direction. It moves the character and returns a leftover velocity after applying collisions. When hitting the floor or a wall, the function will reduce or reset the speed in that direction from you. In our case, storing the function's returned value prevents the character from accumulating vertical momentum, which could otherwise get so big the character would move through the ground slab after a while.</p> <p>And that's all the code you need to move the character on the floor.</p> <p>Here is the complete <code>Player.gd</code> code for reference.</p> <div class="sphinx-tabs docutils container"> <div aria-label="Tabbed content" class="closeable" role="tablist">
<button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" class="sphinx-tabs-tab code-tab group-tab" id="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button><button aria-controls="panel-4-QyM=" aria-selected="false" class="sphinx-tabs-tab code-tab group-tab" id="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
</div>
<div aria-labelledby="tab-4-R0RTY3JpcHQ=" class="sphinx-tabs-panel code-tab group-tab" id="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
<pre data-language="gdscript">extends KinematicBody

# How fast the player moves in meters per second.
export var speed = 14
# The downward acceleration when in the air, in meters per second squared.
export var fall_acceleration = 75

var velocity = Vector3.ZERO


func _physics_process(delta):
    var direction = Vector3.ZERO

    if Input.is_action_pressed("move_right"):
        direction.x += 1
    if Input.is_action_pressed("move_left"):
        direction.x -= 1
    if Input.is_action_pressed("move_back"):
        direction.z += 1
    if Input.is_action_pressed("move_forward"):
        direction.z -= 1

    if direction != Vector3.ZERO:
        direction = direction.normalized()
        $Pivot.look_at(translation + direction, Vector3.UP)

    velocity.x = direction.x * speed
    velocity.z = direction.z * speed
    velocity.y -= fall_acceleration * delta
    velocity = move_and_slide(velocity, Vector3.UP)
</pre> </div>
<div aria-labelledby="tab-4-QyM=" class="sphinx-tabs-panel code-tab group-tab" hidden="true" id="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
<pre data-language="csharp">public class Player : KinematicBody
{
    // How fast the player moves in meters per second.
    [Export]
    public int Speed = 14;
    // The downward acceleration when in the air, in meters per second squared.
    [Export]
    public int FallAcceleration = 75;

    private Vector3 _velocity = Vector3.Zero;

    public override void _PhysicsProcess(float delta)
    {
        // We create a local variable to store the input direction.
        var direction = Vector3.Zero;

        // We check for each move input and update the direction accordingly
        if (Input.IsActionPressed("move_right"))
        {
            direction.x += 1f;
        }
        if (Input.IsActionPressed("move_left"))
        {
            direction.x -= 1f;
        }
        if (Input.IsActionPressed("move_back"))
        {
            // Notice how we are working with the vector's x and z axes.
            // In 3D, the XZ plane is the ground plane.
            direction.z += 1f;
        }
        if (Input.IsActionPressed("move_forward"))
        {
            direction.z -= 1f;
        }

        if (direction != Vector3.Zero)
        {
            direction = direction.Normalized();
            GetNode&lt;Spatial&gt;("Pivot").LookAt(Translation + direction, Vector3.Up);
        }

        // Ground velocity
        _velocity.x = direction.x * Speed;
        _velocity.z = direction.z * Speed;
        // Vertical velocity
        _velocity.y -= FallAcceleration * delta;
        // Moving the character
        _velocity = MoveAndSlide(_velocity, Vector3.Up);
    }
}
</pre> </div>
</div> <section id="testing-our-player-s-movement"> <h2>Testing our player's movement</h2> <p>We're going to put our player in the <em>Main</em> scene to test it. To do so, we need to instantiate the player and then add a camera. Unlike in 2D, in 3D, you won't see anything if your viewport doesn't have a camera pointing at something.</p> <p>Save your <em>Player</em> scene and open the <em>Main</em> scene. You can click on the <em>Main</em> tab at the top of the editor to do so.</p> <p><img alt="image1" src="https://docs.godotengine.org/en/3.5/_images/02.clicking_main_tab.png"></p> <p>If you closed the scene before, head to the <em>FileSystem</em> dock and double-click <code>Main.tscn</code> to re-open it.</p> <p>To instantiate the <em>Player</em>, right-click on the <em>Main</em> node and select <em>Instance Child Scene</em>.</p> <p><img alt="image2" src="https://docs.godotengine.org/en/3.5/_images/03.instance_child_scene.png"></p> <p>In the popup, double-click <em>Player.tscn</em>. The character should appear in the center of the viewport.</p> <section id="adding-a-camera"> <h3>Adding a camera</h3> <p>Let's add the camera next. Like we did with our <em>Player</em>'s <em>Pivot</em>, we're going to create a basic rig. Right-click on the <em>Main</em> node again and select <em>Add Child Node</em> this time. Create a new <em>Position3D</em>, name it <em>CameraPivot</em>, and add a <em>Camera</em> node as a child of it. Your scene tree should look like this.</p> <p><img alt="image3" src="https://docs.godotengine.org/en/3.5/_images/04.scene_tree_with_camera.png"></p> <p>Notice the <em>Preview</em> checkbox that appears in the top-left when you have the <em>Camera</em> selected. You can click it to preview the in-game camera projection.</p> <p><img alt="image4" src="https://docs.godotengine.org/en/3.5/_images/05.camera_preview_checkbox.png"></p> <p>We're going to use the <em>Pivot</em> to rotate the camera as if it was on a crane. Let's first split the 3D view to be able to freely navigate the scene and see what the camera sees.</p> <p>In the toolbar right above the viewport, click on <em>View</em>, then <em>2 Viewports</em>. You can also press <kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">Ctrl</kbd> + <kbd class="kbd docutils literal notranslate">2</kbd></kbd> (<kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">Cmd</kbd> + <kbd class="kbd docutils literal notranslate">2</kbd></kbd> on macOS).</p> <p><img alt="image5" src="https://docs.godotengine.org/en/3.5/_images/06.two_viewports.png"></p> <p>On the bottom view, select the <em>Camera</em> and turn on camera preview by clicking the checkbox.</p> <p><img alt="image6" src="https://docs.godotengine.org/en/3.5/_images/07.camera_preview_checkbox.png"></p> <p>In the top view, move the camera about <code>19</code> units on the Z axis (the blue one).</p> <p><img alt="image7" src="https://docs.godotengine.org/en/3.5/_images/08.camera_moved.png"></p> <p>Here's where the magic happens. Select the <em>CameraPivot</em> and rotate it <code>45</code> degrees around the X axis (using the red circle). You'll see the camera move as if it was attached to a crane.</p> <p><img alt="image8" src="https://docs.godotengine.org/en/3.5/_images/09.camera_rotated.png"></p> <p>You can run the scene by pressing <kbd class="kbd docutils literal notranslate">F6</kbd> and press the arrow keys to move the character.</p> <p><img alt="image9" src="https://docs.godotengine.org/en/3.5/_images/10.camera_perspective.png"></p> <p>We can see some empty space around the character due to the perspective projection. In this game, we're going to use an orthographic projection instead to better frame the gameplay area and make it easier for the player to read distances.</p> <p>Select the <em>Camera</em> again and in the <em>Inspector</em>, set the <em>Projection</em> to <em>Orthogonal</em> and the <em>Size</em> to <code>19</code>. The character should now look flatter and the ground should fill the background.</p> <p><img alt="image10" src="https://docs.godotengine.org/en/3.5/_images/11.camera_orthographic.png"></p> <p>With that, we have both player movement and the view in place. Next, we will work on the monsters.</p> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2014&ndash;2022 Juan Linietsky, Ariel Manzur and the Godot community<br>Licensed under the Creative Commons Attribution Unported License v3.0.<br>
    <a href="https://docs.godotengine.org/en/3.5/getting_started/first_3d_game/03.player_movement_code.html" class="_attribution-link">https://docs.godotengine.org/en/3.5/getting_started/first_3d_game/03.player_movement_code.html</a>
  </p>
</div>
