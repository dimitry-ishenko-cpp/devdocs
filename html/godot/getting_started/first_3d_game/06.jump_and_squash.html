<h1 id="doc-first-3d-game-jumping-and-squashing-monsters">Jumping and squashing monsters</h1> <p>In this part, we'll add the ability to jump, to squash the monsters. In the next lesson, we'll make the player die when a monster hits them on the ground.</p> <p>First, we have to change a few settings related to physics interactions. Enter the world of <a href="https://docs.godotengine.org/en/3.5/tutorials/physics/physics_introduction.html#doc-physics-introduction-collision-layers-and-masks"><span class="std std-ref">physics layers</span></a>.</p> <section id="controlling-physics-interactions"> <h2>Controlling physics interactions</h2> <p>Physics bodies have access to two complementary properties: layers and masks. Layers define on which physics layer(s) an object is.</p> <p>Masks control the layers that a body will listen to and detect. This affects collision detection. When you want two bodies to interact, you need at least one to have a mask corresponding to the other.</p> <p>If that's confusing, don't worry, we'll see three examples in a second.</p> <p>The important point is that you can use layers and masks to filter physics interactions, control performance, and remove the need for extra conditions in your code.</p> <p>By default, all physics bodies and areas are set to both layer and mask <code>0</code>. This means they all collide with each other.</p> <p>Physics layers are represented by numbers, but we can give them names to keep track of what's what.</p> <section id="setting-layer-names"> <h3>Setting layer names</h3> <p>Let's give our physics layers a name. Go to <em>Project -&gt; Project Settings</em>.</p> <p><img alt="image0" src="https://docs.godotengine.org/en/3.5/_images/02.project_settings1.png"></p> <p>In the left menu, navigate down to <em>Layer Names -&gt; 3D Physics</em>. You can see a list of layers with a field next to each of them on the right. You can set their names there. Name the first three layers <em>player</em>, <em>enemies</em>, and <em>world</em>, respectively.</p> <p><img alt="image1" src="https://docs.godotengine.org/en/3.5/_images/03.physics_layers.png"></p> <p>Now, we can assign them to our physics nodes.</p> </section> <section id="assigning-layers-and-masks"> <h3>Assigning layers and masks</h3> <p>In the <em>Main</em> scene, select the <em>Ground</em> node. In the <em>Inspector</em>, expand the <em>Collision</em> section. There, you can see the node's layers and masks as a grid of buttons.</p> <p><img alt="image2" src="https://docs.godotengine.org/en/3.5/_images/04.default_physics_properties.png"></p> <p>The ground is part of the world, so we want it to be part of the third layer. Click the lit button to toggle off the first <em>Layer</em> and toggle on the third one. Then, toggle off the <em>Mask</em> by clicking on it.</p> <p><img alt="image3" src="https://docs.godotengine.org/en/3.5/_images/05.toggle_layer_and_mask.png"></p> <p>As I mentioned above, the <em>Mask</em> property allows a node to listen to interaction with other physics objects, but we don't need it to have collisions. The <em>Ground</em> doesn't need to listen to anything; it's just there to prevent creatures from falling.</p> <p>Note that you can click the "..." button on the right side of the properties to see a list of named checkboxes.</p> <p><img alt="image4" src="https://docs.godotengine.org/en/3.5/_images/06.named_checkboxes.png"></p> <p>Next up are the <em>Player</em> and the <em>Mob</em>. Open <code>Player.tscn</code> by double-clicking the file in the <em>FileSystem</em> dock.</p> <p>Select the <em>Player</em> node and set its <em>Collision -&gt; Mask</em> to both "enemies" and "world". You can leave the default <em>Layer</em> property as the first layer is the "player" one.</p> <p><img alt="image5" src="https://docs.godotengine.org/en/3.5/_images/07.player_physics_mask.png"></p> <p>Then, open the <em>Mob</em> scene by double-clicking on <code>Mob.tscn</code> and select the <em>Mob</em> node.</p> <p>Set its <em>Collision -&gt; Layer</em> to "enemies" and unset its <em>Collision -&gt; Mask</em>, leaving the mask empty.</p> <p><img alt="image6" src="https://docs.godotengine.org/en/3.5/_images/08.mob_physics_mask.png"></p> <p>These settings mean the monsters will move through one another. If you want the monsters to collide with and slide against each other, turn on the "enemies" mask.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The mobs don't need to mask the "world" layer because they only move on the XZ plane. We don't apply any gravity to them by design.</p> </div> </section> </section> <section id="jumping"> <h2>Jumping</h2> <p>The jumping mechanic itself requires only two lines of code. Open the <em>Player</em> script. We need a value to control the jump's strength and update <code>_physics_process()</code> to code the jump.</p> <p>After the line that defines <code>fall_acceleration</code>, at the top of the script, add the <code>jump_impulse</code>.</p> <div class="sphinx-tabs docutils container"> <div aria-label="Tabbed content" class="closeable" role="tablist">
<button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" class="sphinx-tabs-tab code-tab group-tab" id="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button><button aria-controls="panel-0-QyM=" aria-selected="false" class="sphinx-tabs-tab code-tab group-tab" id="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
</div>
<div aria-labelledby="tab-0-R0RTY3JpcHQ=" class="sphinx-tabs-panel code-tab group-tab" id="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
<pre data-language="gdscript">#...
# Vertical impulse applied to the character upon jumping in meters per second.
export var jump_impulse = 20
</pre> </div>
<div aria-labelledby="tab-0-QyM=" class="sphinx-tabs-panel code-tab group-tab" hidden="true" id="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
<pre data-language="csharp">// Don't forget to rebuild the project so the editor knows about the new export variable.

// ...
// Vertical impulse applied to the character upon jumping in meters per second.
[Export]
public int JumpImpulse = 20;
</pre> </div>
</div> <p>Inside <code>_physics_process()</code>, add the following code before the line where we called <code>move_and_slide()</code>.</p> <div class="sphinx-tabs docutils container"> <div aria-label="Tabbed content" class="closeable" role="tablist">
<button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" class="sphinx-tabs-tab code-tab group-tab" id="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button><button aria-controls="panel-1-QyM=" aria-selected="false" class="sphinx-tabs-tab code-tab group-tab" id="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
</div>
<div aria-labelledby="tab-1-R0RTY3JpcHQ=" class="sphinx-tabs-panel code-tab group-tab" id="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
<pre data-language="gdscript">func _physics_process(delta):
    #...

    # Jumping.
    if is_on_floor() and Input.is_action_just_pressed("jump"):
        velocity.y += jump_impulse

    #...
</pre> </div>
<div aria-labelledby="tab-1-QyM=" class="sphinx-tabs-panel code-tab group-tab" hidden="true" id="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
<pre data-language="csharp">public override void _PhysicsProcess(float delta)
{
    // ...

    // Jumping.
    if (IsOnFloor() &amp;&amp; Input.IsActionJustPressed("jump"))
    {
        _velocity.y += JumpImpulse;
    }

    // ...
}
</pre> </div>
</div> <p>That's all you need to jump!</p> <p>The <code>is_on_floor()</code> method is a tool from the <code>KinematicBody</code> class. It returns <code>true</code> if the body collided with the floor in this frame. That's why we apply gravity to the <em>Player</em>: so we collide with the floor instead of floating over it like the monsters.</p> <p>If the character is on the floor and the player presses "jump", we instantly give them a lot of vertical speed. In games, you really want controls to be responsive and giving instant speed boosts like these, while unrealistic, feel great.</p> <p>Notice that the Y axis is positive upwards. That's unlike 2D, where the Y axis is positive downward.</p> </section> <section id="squashing-monsters"> <h2>Squashing monsters</h2> <p>Let's add the squash mechanic next. We're going to make the character bounce over monsters and kill them at the same time.</p> <p>We need to detect collisions with a monster and to differentiate them from collisions with the floor. To do so, we can use Godot's <a href="https://docs.godotengine.org/en/3.5/tutorials/scripting/groups.html#doc-groups"><span class="std std-ref">group</span></a> tagging feature.</p> <p>Open the scene <code>Mob.tscn</code> again and select the <em>Mob</em> node. Go to the <em>Node</em> dock on the right to see a list of signals. The <em>Node</em> dock has two tabs: <em>Signals</em>, which you've already used, and <em>Groups</em>, which allows you to assign tags to nodes.</p> <p>Click on it to reveal a field where you can write a tag name. Enter "mob" in the field and click the <em>Add</em> button.</p> <p><img alt="image7" src="https://docs.godotengine.org/en/3.5/_images/09.groups_tab.png"></p> <p>An icon appears in the <em>Scene</em> dock to indicate the node is part of at least one group.</p> <p><img alt="image8" src="https://docs.godotengine.org/en/3.5/_images/10.group_scene_icon.png"></p> <p>We can now use the group from the code to distinguish collisions with monsters from collisions with the floor.</p> <section id="coding-the-squash-mechanic"> <h3>Coding the squash mechanic</h3> <p>Head back to the <em>Player</em> script to code the squash and bounce.</p> <p>At the top of the script, we need another property, <code>bounce_impulse</code>. When squashing an enemy, we don't necessarily want the character to go as high up as when jumping.</p> <div class="sphinx-tabs docutils container"> <div aria-label="Tabbed content" class="closeable" role="tablist">
<button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" class="sphinx-tabs-tab code-tab group-tab" id="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button><button aria-controls="panel-2-QyM=" aria-selected="false" class="sphinx-tabs-tab code-tab group-tab" id="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
</div>
<div aria-labelledby="tab-2-R0RTY3JpcHQ=" class="sphinx-tabs-panel code-tab group-tab" id="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
<pre data-language="gdscript"># Vertical impulse applied to the character upon bouncing over a mob in
# meters per second.
export var bounce_impulse = 16
</pre> </div>
<div aria-labelledby="tab-2-QyM=" class="sphinx-tabs-panel code-tab group-tab" hidden="true" id="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
<pre data-language="csharp">// Don't forget to rebuild the project so the editor knows about the new export variable.

// Vertical impulse applied to the character upon bouncing over a mob in meters per second.
[Export]
public int BounceImpulse = 16;
</pre> </div>
</div> <p>Then, at the bottom of <code>_physics_process()</code>, add the following loop. With <code>move_and_slide()</code>, Godot makes the body move sometimes multiple times in a row to smooth out the character's motion. So we have to loop over all collisions that may have happened.</p> <p>In every iteration of the loop, we check if we landed on a mob. If so, we kill it and bounce.</p> <p>With this code, if no collisions occurred on a given frame, the loop won't run.</p> <div class="sphinx-tabs docutils container"> <div aria-label="Tabbed content" class="closeable" role="tablist">
<button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" class="sphinx-tabs-tab code-tab group-tab" id="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button><button aria-controls="panel-3-QyM=" aria-selected="false" class="sphinx-tabs-tab code-tab group-tab" id="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
</div>
<div aria-labelledby="tab-3-R0RTY3JpcHQ=" class="sphinx-tabs-panel code-tab group-tab" id="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
<pre data-language="gdscript">func _physics_process(delta):
    #...
    for index in range(get_slide_count()):
        # We check every collision that occurred this frame.
        var collision = get_slide_collision(index)
        # If we collide with a monster...
        if collision.collider.is_in_group("mob"):
            var mob = collision.collider
            # ...we check that we are hitting it from above.
            if Vector3.UP.dot(collision.normal) &gt; 0.1:
                # If so, we squash it and bounce.
                mob.squash()
                velocity.y = bounce_impulse
</pre> </div>
<div aria-labelledby="tab-3-QyM=" class="sphinx-tabs-panel code-tab group-tab" hidden="true" id="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
<pre data-language="csharp">public override void _PhysicsProcess(float delta)
{
    // ...

    for (int index = 0; index &lt; GetSlideCount(); index++)
    {
        // We check every collision that occurred this frame.
        KinematicCollision collision = GetSlideCollision(index);
        // If we collide with a monster...
        if (collision.Collider is Mob mob &amp;&amp; mob.IsInGroup("mob"))
        {
            // ...we check that we are hitting it from above.
            if (Vector3.Up.Dot(collision.Normal) &gt; 0.1f)
            {
                // If so, we squash it and bounce.
                mob.Squash();
                _velocity.y = BounceImpulse;
            }
        }
    }
}
</pre> </div>
<p>That's a lot of new functions. Here's some more information about them.</p> </div> <p>The functions <code>get_slide_count()</code> and <code>get_slide_collision()</code> both come from the <a href="../../classes/class_kinematicbody.html#class-kinematicbody"><span class="std std-ref">KinematicBody</span></a> class and are related to <code>move_and_slide()</code>.</p> <p><code>get_slide_collision()</code> returns a <a href="../../classes/class_kinematiccollision.html#class-kinematiccollision"><span class="std std-ref">KinematicCollision</span></a> object that holds information about where and how the collision occurred. For example, we use its <code>collider</code> property to check if we collided with a "mob" by calling <code>is_in_group()</code> on it: <code>collision.collider.is_in_group("mob")</code>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The method <code>is_in_group()</code> is available on every <a href="../../classes/class_node.html#class-node"><span class="std std-ref">Node</span></a>.</p> </div> <p>To check that we are landing on the monster, we use the vector dot product: <code>Vector3.UP.dot(collision.normal) &gt; 0.1</code>. The collision normal is a 3D vector that is perpendicular to the plane where the collision occurred. The dot product allows us to compare it to the up direction.</p> <p>With dot products, when the result is greater than <code>0</code>, the two vectors are at an angle of fewer than 90 degrees. A value higher than <code>0.1</code> tells us that we are roughly above the monster.</p> <p>We are calling one undefined function, <code>mob.squash()</code>. We have to add it to the Mob class.</p> <p>Open the script <code>Mob.gd</code> by double-clicking on it in the <em>FileSystem</em> dock. At the top of the script, we want to define a new signal named <code>squashed</code>. And at the bottom, you can add the squash function, where we emit the signal and destroy the mob.</p> <div class="sphinx-tabs docutils container"> <div aria-label="Tabbed content" class="closeable" role="tablist">
<button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" class="sphinx-tabs-tab code-tab group-tab" id="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button><button aria-controls="panel-4-QyM=" aria-selected="false" class="sphinx-tabs-tab code-tab group-tab" id="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
</div>
<div aria-labelledby="tab-4-R0RTY3JpcHQ=" class="sphinx-tabs-panel code-tab group-tab" id="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
<pre data-language="gdscript"># Emitted when the player jumped on the mob.
signal squashed

# ...


func squash():
    emit_signal("squashed")
    queue_free()
</pre> </div>
<div aria-labelledby="tab-4-QyM=" class="sphinx-tabs-panel code-tab group-tab" hidden="true" id="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
<pre data-language="csharp">// Don't forget to rebuild the project so the editor knows about the new signal.

// Emitted when the played jumped on the mob.
[Signal]
public delegate void Squashed();

// ...

public void Squash()
{
    EmitSignal(nameof(Squashed));
    QueueFree();
}
</pre> </div>
</div> <p>We will use the signal to add points to the score in the next lesson.</p> <p>With that, you should be able to kill monsters by jumping on them. You can press <kbd class="kbd docutils literal notranslate">F5</kbd> to try the game and set <code>Main.tscn</code> as your project's main scene.</p> <p>However, the player won't die yet. We'll work on that in the next part.</p> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2014&ndash;2022 Juan Linietsky, Ariel Manzur and the Godot community<br>Licensed under the Creative Commons Attribution Unported License v3.0.<br>
    <a href="https://docs.godotengine.org/en/3.5/getting_started/first_3d_game/06.jump_and_squash.html" class="_attribution-link">https://docs.godotengine.org/en/3.5/getting_started/first_3d_game/06.jump_and_squash.html</a>
  </p>
</div>
