<h1 id="class-crypto">Crypto</h1> <p><strong>Inherits:</strong> <a href="class_reference.html#class-reference"><span class="std std-ref">Reference</span></a> <strong>&lt;</strong> <a href="class_object.html#class-object"><span class="std std-ref">Object</span></a></p> <p>Access to advanced cryptographic functionalities.</p> <section id="description"> <h2>Description</h2> <p>The Crypto class allows you to access some more advanced cryptographic functionalities in Godot.</p> <p>For now, this includes generating cryptographically secure random bytes, RSA keys and self-signed X509 certificates generation, asymmetric key encryption/decryption, and signing/verification.</p> <pre data-language="gdscript">extends Node

var crypto = Crypto.new()
var key = CryptoKey.new()
var cert = X509Certificate.new()

func _ready():
    # Generate new RSA key.
    key = crypto.generate_rsa(4096)
    # Generate new self-signed certificate with the given key.
    cert = crypto.generate_self_signed_certificate(key, "CN=mydomain.com,O=My Game Company,C=IT")
    # Save key and certificate in the user folder.
    key.save("user://generated.key")
    cert.save("user://generated.crt")
    # Encryption
    var data = "Some data"
    var encrypted = crypto.encrypt(key, data.to_utf8())
    # Decryption
    var decrypted = crypto.decrypt(key, encrypted)
    # Signing
    var signature = crypto.sign(HashingContext.HASH_SHA256, data.sha256_buffer(), key)
    # Verifying
    var verified = crypto.verify(HashingContext.HASH_SHA256, data.sha256_buffer(), signature, key)
    # Checks
    assert(verified)
    assert(data.to_utf8() == decrypted)
</pre> <p><strong>Note:</strong> Not available in HTML5 exports.</p> </section> <section id="methods"> <h2>Methods</h2> <table class="docutils align-default">   <tr>
<td><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a></p></td> <td><p><a href="#class-crypto-method-constant-time-compare"><span class="std std-ref">constant_time_compare</span></a> <strong>(</strong> <a href="class_poolbytearray.html#class-poolbytearray"><span class="std std-ref">PoolByteArray</span></a> trusted, <a href="class_poolbytearray.html#class-poolbytearray"><span class="std std-ref">PoolByteArray</span></a> received <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_poolbytearray.html#class-poolbytearray"><span class="std std-ref">PoolByteArray</span></a></p></td> <td><p><a href="#class-crypto-method-decrypt"><span class="std std-ref">decrypt</span></a> <strong>(</strong> <a href="class_cryptokey.html#class-cryptokey"><span class="std std-ref">CryptoKey</span></a> key, <a href="class_poolbytearray.html#class-poolbytearray"><span class="std std-ref">PoolByteArray</span></a> ciphertext <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_poolbytearray.html#class-poolbytearray"><span class="std std-ref">PoolByteArray</span></a></p></td> <td><p><a href="#class-crypto-method-encrypt"><span class="std std-ref">encrypt</span></a> <strong>(</strong> <a href="class_cryptokey.html#class-cryptokey"><span class="std std-ref">CryptoKey</span></a> key, <a href="class_poolbytearray.html#class-poolbytearray"><span class="std std-ref">PoolByteArray</span></a> plaintext <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_poolbytearray.html#class-poolbytearray"><span class="std std-ref">PoolByteArray</span></a></p></td> <td><p><a href="#class-crypto-method-generate-random-bytes"><span class="std std-ref">generate_random_bytes</span></a> <strong>(</strong> <a href="class_int.html#class-int"><span class="std std-ref">int</span></a> size <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_cryptokey.html#class-cryptokey"><span class="std std-ref">CryptoKey</span></a></p></td> <td><p><a href="#class-crypto-method-generate-rsa"><span class="std std-ref">generate_rsa</span></a> <strong>(</strong> <a href="class_int.html#class-int"><span class="std std-ref">int</span></a> size <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_x509certificate.html#class-x509certificate"><span class="std std-ref">X509Certificate</span></a></p></td> <td><p><a href="#class-crypto-method-generate-self-signed-certificate"><span class="std std-ref">generate_self_signed_certificate</span></a> <strong>(</strong> <a href="class_cryptokey.html#class-cryptokey"><span class="std std-ref">CryptoKey</span></a> key, <a href="class_string.html#class-string"><span class="std std-ref">String</span></a> issuer_name="CN=myserver,O=myorganisation,C=IT", <a href="class_string.html#class-string"><span class="std std-ref">String</span></a> not_before="20140101000000", <a href="class_string.html#class-string"><span class="std std-ref">String</span></a> not_after="20340101000000" <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_poolbytearray.html#class-poolbytearray"><span class="std std-ref">PoolByteArray</span></a></p></td> <td><p><a href="#class-crypto-method-hmac-digest"><span class="std std-ref">hmac_digest</span></a> <strong>(</strong> <a href="class_hashingcontext.html#enum-hashingcontext-hashtype"><span class="std std-ref">HashType</span></a> hash_type, <a href="class_poolbytearray.html#class-poolbytearray"><span class="std std-ref">PoolByteArray</span></a> key, <a href="class_poolbytearray.html#class-poolbytearray"><span class="std std-ref">PoolByteArray</span></a> msg <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_poolbytearray.html#class-poolbytearray"><span class="std std-ref">PoolByteArray</span></a></p></td> <td><p><a href="#class-crypto-method-sign"><span class="std std-ref">sign</span></a> <strong>(</strong> <a href="class_hashingcontext.html#enum-hashingcontext-hashtype"><span class="std std-ref">HashType</span></a> hash_type, <a href="class_poolbytearray.html#class-poolbytearray"><span class="std std-ref">PoolByteArray</span></a> hash, <a href="class_cryptokey.html#class-cryptokey"><span class="std std-ref">CryptoKey</span></a> key <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a></p></td> <td><p><a href="#class-crypto-method-verify"><span class="std std-ref">verify</span></a> <strong>(</strong> <a href="class_hashingcontext.html#enum-hashingcontext-hashtype"><span class="std std-ref">HashType</span></a> hash_type, <a href="class_poolbytearray.html#class-poolbytearray"><span class="std std-ref">PoolByteArray</span></a> hash, <a href="class_poolbytearray.html#class-poolbytearray"><span class="std std-ref">PoolByteArray</span></a> signature, <a href="class_cryptokey.html#class-cryptokey"><span class="std std-ref">CryptoKey</span></a> key <strong>)</strong></p></td> </tr>  </table> </section> <section id="method-descriptions"> <h2>Method Descriptions</h2> <h3 id="class-crypto-method-constant-time-compare"><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> constant_time_compare ( <a href="class_poolbytearray.html#class-poolbytearray"><span class="std std-ref">PoolByteArray</span></a> trusted, <a href="class_poolbytearray.html#class-poolbytearray"><span class="std std-ref">PoolByteArray</span></a> received )</p></h3> <p>Compares two <a href="class_poolbytearray.html#class-poolbytearray"><span class="std std-ref">PoolByteArray</span></a>s for equality without leaking timing information in order to prevent timing attacks.</p> <p>See <a href="https://paragonie.com/blog/2015/11/preventing-timing-attacks-on-string-comparison-with-double-hmac-strategy">this blog post</a> for more information.</p>  <h3 id="class-crypto-method-decrypt"><p><a href="class_poolbytearray.html#class-poolbytearray"><span class="std std-ref">PoolByteArray</span></a> decrypt ( <a href="class_cryptokey.html#class-cryptokey"><span class="std std-ref">CryptoKey</span></a> key, <a href="class_poolbytearray.html#class-poolbytearray"><span class="std std-ref">PoolByteArray</span></a> ciphertext )</p></h3> <p>Decrypt the given <code>ciphertext</code> with the provided private <code>key</code>.</p> <p><strong>Note:</strong> The maximum size of accepted ciphertext is limited by the key size.</p>  <h3 id="class-crypto-method-encrypt"><p><a href="class_poolbytearray.html#class-poolbytearray"><span class="std std-ref">PoolByteArray</span></a> encrypt ( <a href="class_cryptokey.html#class-cryptokey"><span class="std std-ref">CryptoKey</span></a> key, <a href="class_poolbytearray.html#class-poolbytearray"><span class="std std-ref">PoolByteArray</span></a> plaintext )</p></h3> <p>Encrypt the given <code>plaintext</code> with the provided public <code>key</code>.</p> <p><strong>Note:</strong> The maximum size of accepted plaintext is limited by the key size.</p>  <h3 id="class-crypto-method-generate-random-bytes"><p><a href="class_poolbytearray.html#class-poolbytearray"><span class="std std-ref">PoolByteArray</span></a> generate_random_bytes ( <a href="class_int.html#class-int"><span class="std std-ref">int</span></a> size )</p></h3> <p>Generates a <a href="class_poolbytearray.html#class-poolbytearray"><span class="std std-ref">PoolByteArray</span></a> of cryptographically secure random bytes with given <code>size</code>.</p>  <h3 id="class-crypto-method-generate-rsa"><p><a href="class_cryptokey.html#class-cryptokey"><span class="std std-ref">CryptoKey</span></a> generate_rsa ( <a href="class_int.html#class-int"><span class="std std-ref">int</span></a> size )</p></h3> <p>Generates an RSA <a href="class_cryptokey.html#class-cryptokey"><span class="std std-ref">CryptoKey</span></a> that can be used for creating self-signed certificates and passed to <a href="class_streampeerssl.html#class-streampeerssl-method-accept-stream"><span class="std std-ref">StreamPeerSSL.accept_stream</span></a>.</p>  <h3 id="class-crypto-method-generate-self-signed-certificate"><p><a href="class_x509certificate.html#class-x509certificate"><span class="std std-ref">X509Certificate</span></a> generate_self_signed_certificate ( <a href="class_cryptokey.html#class-cryptokey"><span class="std std-ref">CryptoKey</span></a> key, <a href="class_string.html#class-string"><span class="std std-ref">String</span></a> issuer_name="CN=myserver,O=myorganisation,C=IT", <a href="class_string.html#class-string"><span class="std std-ref">String</span></a> not_before="20140101000000", <a href="class_string.html#class-string"><span class="std std-ref">String</span></a> not_after="20340101000000" )</p></h3> <p>Generates a self-signed <a href="class_x509certificate.html#class-x509certificate"><span class="std std-ref">X509Certificate</span></a> from the given <a href="class_cryptokey.html#class-cryptokey"><span class="std std-ref">CryptoKey</span></a> and <code>issuer_name</code>. The certificate validity will be defined by <code>not_before</code> and <code>not_after</code> (first valid date and last valid date). The <code>issuer_name</code> must contain at least "CN=" (common name, i.e. the domain name), "O=" (organization, i.e. your company name), "C=" (country, i.e. 2 lettered ISO-3166 code of the country the organization is based in).</p> <p>A small example to generate an RSA key and a X509 self-signed certificate.</p> <pre data-language="gdscript">var crypto = Crypto.new()
# Generate 4096 bits RSA key.
var key = crypto.generate_rsa(4096)
# Generate self-signed certificate using the given key.
var cert = crypto.generate_self_signed_certificate(key, "CN=example.com,O=A Game Company,C=IT")
</pre>  <h3 id="class-crypto-method-hmac-digest"><p><a href="class_poolbytearray.html#class-poolbytearray"><span class="std std-ref">PoolByteArray</span></a> hmac_digest ( <a href="class_hashingcontext.html#enum-hashingcontext-hashtype"><span class="std std-ref">HashType</span></a> hash_type, <a href="class_poolbytearray.html#class-poolbytearray"><span class="std std-ref">PoolByteArray</span></a> key, <a href="class_poolbytearray.html#class-poolbytearray"><span class="std std-ref">PoolByteArray</span></a> msg )</p></h3> <p>Generates an <a href="https://en.wikipedia.org/wiki/HMAC">HMAC</a> digest of <code>msg</code> using <code>key</code>. The <code>hash_type</code> parameter is the hashing algorithm that is used for the inner and outer hashes.</p> <p>Currently, only <a href="class_hashingcontext.html#class-hashingcontext-constant-hash-sha256"><span class="std std-ref">HashingContext.HASH_SHA256</span></a> and <a href="class_hashingcontext.html#class-hashingcontext-constant-hash-sha1"><span class="std std-ref">HashingContext.HASH_SHA1</span></a> are supported.</p>  <h3 id="class-crypto-method-sign"><p><a href="class_poolbytearray.html#class-poolbytearray"><span class="std std-ref">PoolByteArray</span></a> sign ( <a href="class_hashingcontext.html#enum-hashingcontext-hashtype"><span class="std std-ref">HashType</span></a> hash_type, <a href="class_poolbytearray.html#class-poolbytearray"><span class="std std-ref">PoolByteArray</span></a> hash, <a href="class_cryptokey.html#class-cryptokey"><span class="std std-ref">CryptoKey</span></a> key )</p></h3> <p>Sign a given <code>hash</code> of type <code>hash_type</code> with the provided private <code>key</code>.</p>  <h3 id="class-crypto-method-verify"><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> verify ( <a href="class_hashingcontext.html#enum-hashingcontext-hashtype"><span class="std std-ref">HashType</span></a> hash_type, <a href="class_poolbytearray.html#class-poolbytearray"><span class="std std-ref">PoolByteArray</span></a> hash, <a href="class_poolbytearray.html#class-poolbytearray"><span class="std std-ref">PoolByteArray</span></a> signature, <a href="class_cryptokey.html#class-cryptokey"><span class="std std-ref">CryptoKey</span></a> key )</p></h3> <p>Verify that a given <code>signature</code> for <code>hash</code> of type <code>hash_type</code> against the provided public <code>key</code>.</p> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2014&ndash;2022 Juan Linietsky, Ariel Manzur, Godot Engine contributors<br>Licensed under the MIT License.<br>
    <a href="https://docs.godotengine.org/en/3.5/classes/class_crypto.html" class="_attribution-link">https://docs.godotengine.org/en/3.5/classes/class_crypto.html</a>
  </p>
</div>
