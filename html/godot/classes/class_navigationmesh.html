<section id="navigationmesh"> <h1 id="class-navigationmesh">NavigationMesh</h1> <p><strong>Inherits:</strong> <a href="class_resource.html#class-resource"><span class="std std-ref">Resource</span></a> <strong>&lt;</strong> <a href="class_refcounted.html#class-refcounted"><span class="std std-ref">RefCounted</span></a> <strong>&lt;</strong> <a href="class_object.html#class-object"><span class="std std-ref">Object</span></a></p> <p>A navigation mesh that defines traversable areas and obstacles.</p> <section class="classref-introduction-group" id="description"> <h2>Description</h2> <p>A navigation mesh is a collection of polygons that define which areas of an environment are traversable to aid agents in pathfinding through complicated spaces.</p> </section> <section class="classref-introduction-group" id="tutorials"> <h2>Tutorials</h2> <ul class="simple"> <li><a href="https://docs.godotengine.org/en/4.2/tutorials/navigation/navigation_using_navigationmeshes.html"><span class="doc">Using NavigationMeshes</span></a></li> <li><a href="https://godotengine.org/asset-library/asset/124">3D Navmesh Demo</a></li> </ul> </section> <section class="classref-reftable-group" id="properties"> <h2>Properties</h2> <table class="colwidths-auto docutils align-default">  <tr>
<td><p><a href="class_float.html#class-float"><span class="std std-ref">float</span></a></p></td> <td><p><a href="#class-navigationmesh-property-agent-height"><span class="std std-ref">agent_height</span></a></p></td> <td><p><code>1.5</code></p></td> </tr> <tr>
<td><p><a href="class_float.html#class-float"><span class="std std-ref">float</span></a></p></td> <td><p><a href="#class-navigationmesh-property-agent-max-climb"><span class="std std-ref">agent_max_climb</span></a></p></td> <td><p><code>0.25</code></p></td> </tr> <tr>
<td><p><a href="class_float.html#class-float"><span class="std std-ref">float</span></a></p></td> <td><p><a href="#class-navigationmesh-property-agent-max-slope"><span class="std std-ref">agent_max_slope</span></a></p></td> <td><p><code>45.0</code></p></td> </tr> <tr>
<td><p><a href="class_float.html#class-float"><span class="std std-ref">float</span></a></p></td> <td><p><a href="#class-navigationmesh-property-agent-radius"><span class="std std-ref">agent_radius</span></a></p></td> <td><p><code>0.5</code></p></td> </tr> <tr>
<td><p><a href="class_float.html#class-float"><span class="std std-ref">float</span></a></p></td> <td><p><a href="#class-navigationmesh-property-cell-height"><span class="std std-ref">cell_height</span></a></p></td> <td><p><code>0.25</code></p></td> </tr> <tr>
<td><p><a href="class_float.html#class-float"><span class="std std-ref">float</span></a></p></td> <td><p><a href="#class-navigationmesh-property-cell-size"><span class="std std-ref">cell_size</span></a></p></td> <td><p><code>0.25</code></p></td> </tr> <tr>
<td><p><a href="class_float.html#class-float"><span class="std std-ref">float</span></a></p></td> <td><p><a href="#class-navigationmesh-property-detail-sample-distance"><span class="std std-ref">detail_sample_distance</span></a></p></td> <td><p><code>6.0</code></p></td> </tr> <tr>
<td><p><a href="class_float.html#class-float"><span class="std std-ref">float</span></a></p></td> <td><p><a href="#class-navigationmesh-property-detail-sample-max-error"><span class="std std-ref">detail_sample_max_error</span></a></p></td> <td><p><code>1.0</code></p></td> </tr> <tr>
<td><p><a href="class_float.html#class-float"><span class="std std-ref">float</span></a></p></td> <td><p><a href="#class-navigationmesh-property-edge-max-error"><span class="std std-ref">edge_max_error</span></a></p></td> <td><p><code>1.3</code></p></td> </tr> <tr>
<td><p><a href="class_float.html#class-float"><span class="std std-ref">float</span></a></p></td> <td><p><a href="#class-navigationmesh-property-edge-max-length"><span class="std std-ref">edge_max_length</span></a></p></td> <td><p><code>0.0</code></p></td> </tr> <tr>
<td><p><a href="class_aabb.html#class-aabb"><span class="std std-ref">AABB</span></a></p></td> <td><p><a href="#class-navigationmesh-property-filter-baking-aabb"><span class="std std-ref">filter_baking_aabb</span></a></p></td> <td><p><code>AABB(0, 0, 0, 0, 0, 0)</code></p></td> </tr> <tr>
<td><p><a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a></p></td> <td><p><a href="#class-navigationmesh-property-filter-baking-aabb-offset"><span class="std std-ref">filter_baking_aabb_offset</span></a></p></td> <td><p><code>Vector3(0, 0, 0)</code></p></td> </tr> <tr>
<td><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a></p></td> <td><p><a href="#class-navigationmesh-property-filter-ledge-spans"><span class="std std-ref">filter_ledge_spans</span></a></p></td> <td><p><code>false</code></p></td> </tr> <tr>
<td><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a></p></td> <td><p><a href="#class-navigationmesh-property-filter-low-hanging-obstacles"><span class="std std-ref">filter_low_hanging_obstacles</span></a></p></td> <td><p><code>false</code></p></td> </tr> <tr>
<td><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a></p></td> <td><p><a href="#class-navigationmesh-property-filter-walkable-low-height-spans"><span class="std std-ref">filter_walkable_low_height_spans</span></a></p></td> <td><p><code>false</code></p></td> </tr> <tr>
<td><p><a href="class_int.html#class-int"><span class="std std-ref">int</span></a></p></td> <td><p><a href="#class-navigationmesh-property-geometry-collision-mask"><span class="std std-ref">geometry_collision_mask</span></a></p></td> <td><p><code>4294967295</code></p></td> </tr> <tr>
<td><p><a href="#enum-navigationmesh-parsedgeometrytype"><span class="std std-ref">ParsedGeometryType</span></a></p></td> <td><p><a href="#class-navigationmesh-property-geometry-parsed-geometry-type"><span class="std std-ref">geometry_parsed_geometry_type</span></a></p></td> <td><p><code>0</code></p></td> </tr> <tr>
<td><p><a href="#enum-navigationmesh-sourcegeometrymode"><span class="std std-ref">SourceGeometryMode</span></a></p></td> <td><p><a href="#class-navigationmesh-property-geometry-source-geometry-mode"><span class="std std-ref">geometry_source_geometry_mode</span></a></p></td> <td><p><code>0</code></p></td> </tr> <tr>
<td><p><a href="class_stringname.html#class-stringname"><span class="std std-ref">StringName</span></a></p></td> <td><p><a href="#class-navigationmesh-property-geometry-source-group-name"><span class="std std-ref">geometry_source_group_name</span></a></p></td> <td><p><code>&amp;"navigation_mesh_source_group"</code></p></td> </tr> <tr>
<td><p><a href="class_float.html#class-float"><span class="std std-ref">float</span></a></p></td> <td><p><a href="#class-navigationmesh-property-region-merge-size"><span class="std std-ref">region_merge_size</span></a></p></td> <td><p><code>20.0</code></p></td> </tr> <tr>
<td><p><a href="class_float.html#class-float"><span class="std std-ref">float</span></a></p></td> <td><p><a href="#class-navigationmesh-property-region-min-size"><span class="std std-ref">region_min_size</span></a></p></td> <td><p><code>2.0</code></p></td> </tr> <tr>
<td><p><a href="#enum-navigationmesh-samplepartitiontype"><span class="std std-ref">SamplePartitionType</span></a></p></td> <td><p><a href="#class-navigationmesh-property-sample-partition-type"><span class="std std-ref">sample_partition_type</span></a></p></td> <td><p><code>0</code></p></td> </tr> <tr>
<td><p><a href="class_float.html#class-float"><span class="std std-ref">float</span></a></p></td> <td><p><a href="#class-navigationmesh-property-vertices-per-polygon"><span class="std std-ref">vertices_per_polygon</span></a></p></td> <td><p><code>6.0</code></p></td> </tr>  </table> </section> <section class="classref-reftable-group" id="methods"> <h2>Methods</h2> <table class="colwidths-auto docutils align-default">  <tr>
<td><p>void</p></td> <td><p><a href="#class-navigationmesh-method-add-polygon"><span class="std std-ref">add_polygon</span></a> <strong>(</strong> <a href="class_packedint32array.html#class-packedint32array"><span class="std std-ref">PackedInt32Array</span></a> polygon <strong>)</strong></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-navigationmesh-method-clear"><span class="std std-ref">clear</span></a> <strong>(</strong> <strong>)</strong></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-navigationmesh-method-clear-polygons"><span class="std std-ref">clear_polygons</span></a> <strong>(</strong> <strong>)</strong></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-navigationmesh-method-create-from-mesh"><span class="std std-ref">create_from_mesh</span></a> <strong>(</strong> <a href="class_mesh.html#class-mesh"><span class="std std-ref">Mesh</span></a> mesh <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a></p></td> <td><p><a href="#class-navigationmesh-method-get-collision-mask-value"><span class="std std-ref">get_collision_mask_value</span></a> <strong>(</strong> <a href="class_int.html#class-int"><span class="std std-ref">int</span></a> layer_number <strong>)</strong> <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr></p></td> </tr> <tr>
<td><p><a href="class_packedint32array.html#class-packedint32array"><span class="std std-ref">PackedInt32Array</span></a></p></td> <td><p><a href="#class-navigationmesh-method-get-polygon"><span class="std std-ref">get_polygon</span></a> <strong>(</strong> <a href="class_int.html#class-int"><span class="std std-ref">int</span></a> idx <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_int.html#class-int"><span class="std std-ref">int</span></a></p></td> <td><p><a href="#class-navigationmesh-method-get-polygon-count"><span class="std std-ref">get_polygon_count</span></a> <strong>(</strong> <strong>)</strong> <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr></p></td> </tr> <tr>
<td><p><a href="class_packedvector3array.html#class-packedvector3array"><span class="std std-ref">PackedVector3Array</span></a></p></td> <td><p><a href="#class-navigationmesh-method-get-vertices"><span class="std std-ref">get_vertices</span></a> <strong>(</strong> <strong>)</strong> <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-navigationmesh-method-set-collision-mask-value"><span class="std std-ref">set_collision_mask_value</span></a> <strong>(</strong> <a href="class_int.html#class-int"><span class="std std-ref">int</span></a> layer_number, <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> value <strong>)</strong></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-navigationmesh-method-set-vertices"><span class="std std-ref">set_vertices</span></a> <strong>(</strong> <a href="class_packedvector3array.html#class-packedvector3array"><span class="std std-ref">PackedVector3Array</span></a> vertices <strong>)</strong></p></td> </tr>  </table> </section>  <section class="classref-descriptions-group" id="enumerations"> <h2>Enumerations</h2> <h3 id="enum-navigationmesh-samplepartitiontype">enum SamplePartitionType:</h3> <h3 id="class-navigationmesh-constant-sample-partition-watershed">
<a href="#enum-navigationmesh-samplepartitiontype"><span class="std std-ref">SamplePartitionType</span></a> SAMPLE_PARTITION_WATERSHED = <code>0</code>
</h3> <p>Watershed partitioning. Generally the best choice if you precompute the navigation mesh, use this if you have large open areas.</p> <h3 id="class-navigationmesh-constant-sample-partition-monotone">
<a href="#enum-navigationmesh-samplepartitiontype"><span class="std std-ref">SamplePartitionType</span></a> SAMPLE_PARTITION_MONOTONE = <code>1</code>
</h3> <p>Monotone partitioning. Use this if you want fast navigation mesh generation.</p> <h3 id="class-navigationmesh-constant-sample-partition-layers">
<a href="#enum-navigationmesh-samplepartitiontype"><span class="std std-ref">SamplePartitionType</span></a> SAMPLE_PARTITION_LAYERS = <code>2</code>
</h3> <p>Layer partitioning. Good choice to use for tiled navigation mesh with medium and small sized tiles.</p> <h3 id="class-navigationmesh-constant-sample-partition-max">
<a href="#enum-navigationmesh-samplepartitiontype"><span class="std std-ref">SamplePartitionType</span></a> SAMPLE_PARTITION_MAX = <code>3</code>
</h3> <p>Represents the size of the <a href="#enum-navigationmesh-samplepartitiontype"><span class="std std-ref">SamplePartitionType</span></a> enum.</p>  <h3 id="enum-navigationmesh-parsedgeometrytype">enum ParsedGeometryType:</h3> <h3 id="class-navigationmesh-constant-parsed-geometry-mesh-instances">
<a href="#enum-navigationmesh-parsedgeometrytype"><span class="std std-ref">ParsedGeometryType</span></a> PARSED_GEOMETRY_MESH_INSTANCES = <code>0</code>
</h3> <p>Parses mesh instances as geometry. This includes <a href="class_meshinstance3d.html#class-meshinstance3d"><span class="std std-ref">MeshInstance3D</span></a>, <a href="class_csgshape3d.html#class-csgshape3d"><span class="std std-ref">CSGShape3D</span></a>, and <a href="class_gridmap.html#class-gridmap"><span class="std std-ref">GridMap</span></a> nodes.</p> <h3 id="class-navigationmesh-constant-parsed-geometry-static-colliders">
<a href="#enum-navigationmesh-parsedgeometrytype"><span class="std std-ref">ParsedGeometryType</span></a> PARSED_GEOMETRY_STATIC_COLLIDERS = <code>1</code>
</h3> <p>Parses <a href="class_staticbody3d.html#class-staticbody3d"><span class="std std-ref">StaticBody3D</span></a> colliders as geometry. The collider should be in any of the layers specified by <a href="#class-navigationmesh-property-geometry-collision-mask"><span class="std std-ref">geometry_collision_mask</span></a>.</p> <h3 id="class-navigationmesh-constant-parsed-geometry-both">
<a href="#enum-navigationmesh-parsedgeometrytype"><span class="std std-ref">ParsedGeometryType</span></a> PARSED_GEOMETRY_BOTH = <code>2</code>
</h3> <p>Both <a href="#class-navigationmesh-constant-parsed-geometry-mesh-instances"><span class="std std-ref">PARSED_GEOMETRY_MESH_INSTANCES</span></a> and <a href="#class-navigationmesh-constant-parsed-geometry-static-colliders"><span class="std std-ref">PARSED_GEOMETRY_STATIC_COLLIDERS</span></a>.</p> <h3 id="class-navigationmesh-constant-parsed-geometry-max">
<a href="#enum-navigationmesh-parsedgeometrytype"><span class="std std-ref">ParsedGeometryType</span></a> PARSED_GEOMETRY_MAX = <code>3</code>
</h3> <p>Represents the size of the <a href="#enum-navigationmesh-parsedgeometrytype"><span class="std std-ref">ParsedGeometryType</span></a> enum.</p>  <h3 id="enum-navigationmesh-sourcegeometrymode">enum SourceGeometryMode:</h3> <h3 id="class-navigationmesh-constant-source-geometry-root-node-children">
<a href="#enum-navigationmesh-sourcegeometrymode"><span class="std std-ref">SourceGeometryMode</span></a> SOURCE_GEOMETRY_ROOT_NODE_CHILDREN = <code>0</code>
</h3> <p>Scans the child nodes of the root node recursively for geometry.</p> <h3 id="class-navigationmesh-constant-source-geometry-groups-with-children">
<a href="#enum-navigationmesh-sourcegeometrymode"><span class="std std-ref">SourceGeometryMode</span></a> SOURCE_GEOMETRY_GROUPS_WITH_CHILDREN = <code>1</code>
</h3> <p>Scans nodes in a group and their child nodes recursively for geometry. The group is specified by <a href="#class-navigationmesh-property-geometry-source-group-name"><span class="std std-ref">geometry_source_group_name</span></a>.</p> <h3 id="class-navigationmesh-constant-source-geometry-groups-explicit">
<a href="#enum-navigationmesh-sourcegeometrymode"><span class="std std-ref">SourceGeometryMode</span></a> SOURCE_GEOMETRY_GROUPS_EXPLICIT = <code>2</code>
</h3> <p>Uses nodes in a group for geometry. The group is specified by <a href="#class-navigationmesh-property-geometry-source-group-name"><span class="std std-ref">geometry_source_group_name</span></a>.</p> <h3 id="class-navigationmesh-constant-source-geometry-max">
<a href="#enum-navigationmesh-sourcegeometrymode"><span class="std std-ref">SourceGeometryMode</span></a> SOURCE_GEOMETRY_MAX = <code>3</code>
</h3> <p>Represents the size of the <a href="#enum-navigationmesh-sourcegeometrymode"><span class="std std-ref">SourceGeometryMode</span></a> enum.</p> </section>  <section class="classref-descriptions-group" id="property-descriptions"> <h2>Property Descriptions</h2> <h3 id="class-navigationmesh-property-agent-height">
<a href="class_float.html#class-float"><span class="std std-ref">float</span></a> agent_height = <code>1.5</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_agent_height</strong> <strong>(</strong> <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> value <strong>)</strong>
</li> <li>
<a href="class_float.html#class-float"><span class="std std-ref">float</span></a> <strong>get_agent_height</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>The minimum floor to ceiling height that will still allow the floor area to be considered walkable.</p> <p><strong>Note:</strong> While baking, this value will be rounded up to the nearest multiple of <a href="#class-navigationmesh-property-cell-height"><span class="std std-ref">cell_height</span></a>.</p>  <h3 id="class-navigationmesh-property-agent-max-climb">
<a href="class_float.html#class-float"><span class="std std-ref">float</span></a> agent_max_climb = <code>0.25</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_agent_max_climb</strong> <strong>(</strong> <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> value <strong>)</strong>
</li> <li>
<a href="class_float.html#class-float"><span class="std std-ref">float</span></a> <strong>get_agent_max_climb</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>The minimum ledge height that is considered to still be traversable.</p> <p><strong>Note:</strong> While baking, this value will be rounded down to the nearest multiple of <a href="#class-navigationmesh-property-cell-height"><span class="std std-ref">cell_height</span></a>.</p>  <h3 id="class-navigationmesh-property-agent-max-slope">
<a href="class_float.html#class-float"><span class="std std-ref">float</span></a> agent_max_slope = <code>45.0</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_agent_max_slope</strong> <strong>(</strong> <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> value <strong>)</strong>
</li> <li>
<a href="class_float.html#class-float"><span class="std std-ref">float</span></a> <strong>get_agent_max_slope</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>The maximum slope that is considered walkable, in degrees.</p>  <h3 id="class-navigationmesh-property-agent-radius">
<a href="class_float.html#class-float"><span class="std std-ref">float</span></a> agent_radius = <code>0.5</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_agent_radius</strong> <strong>(</strong> <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> value <strong>)</strong>
</li> <li>
<a href="class_float.html#class-float"><span class="std std-ref">float</span></a> <strong>get_agent_radius</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>The distance to erode/shrink the walkable area of the heightfield away from obstructions.</p> <p><strong>Note:</strong> While baking, this value will be rounded up to the nearest multiple of <a href="#class-navigationmesh-property-cell-size"><span class="std std-ref">cell_size</span></a>.</p>  <h3 id="class-navigationmesh-property-cell-height">
<a href="class_float.html#class-float"><span class="std std-ref">float</span></a> cell_height = <code>0.25</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_cell_height</strong> <strong>(</strong> <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> value <strong>)</strong>
</li> <li>
<a href="class_float.html#class-float"><span class="std std-ref">float</span></a> <strong>get_cell_height</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>The cell height used to rasterize the navigation mesh vertices on the Y axis. Must match with the cell height on the navigation map.</p>  <h3 id="class-navigationmesh-property-cell-size">
<a href="class_float.html#class-float"><span class="std std-ref">float</span></a> cell_size = <code>0.25</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_cell_size</strong> <strong>(</strong> <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> value <strong>)</strong>
</li> <li>
<a href="class_float.html#class-float"><span class="std std-ref">float</span></a> <strong>get_cell_size</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>The cell size used to rasterize the navigation mesh vertices on the XZ plane. Must match with the cell size on the navigation map.</p>  <h3 id="class-navigationmesh-property-detail-sample-distance">
<a href="class_float.html#class-float"><span class="std std-ref">float</span></a> detail_sample_distance = <code>6.0</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_detail_sample_distance</strong> <strong>(</strong> <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> value <strong>)</strong>
</li> <li>
<a href="class_float.html#class-float"><span class="std std-ref">float</span></a> <strong>get_detail_sample_distance</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>The sampling distance to use when generating the detail mesh, in cell unit.</p>  <h3 id="class-navigationmesh-property-detail-sample-max-error">
<a href="class_float.html#class-float"><span class="std std-ref">float</span></a> detail_sample_max_error = <code>1.0</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_detail_sample_max_error</strong> <strong>(</strong> <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> value <strong>)</strong>
</li> <li>
<a href="class_float.html#class-float"><span class="std std-ref">float</span></a> <strong>get_detail_sample_max_error</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>The maximum distance the detail mesh surface should deviate from heightfield, in cell unit.</p>  <h3 id="class-navigationmesh-property-edge-max-error">
<a href="class_float.html#class-float"><span class="std std-ref">float</span></a> edge_max_error = <code>1.3</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_edge_max_error</strong> <strong>(</strong> <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> value <strong>)</strong>
</li> <li>
<a href="class_float.html#class-float"><span class="std std-ref">float</span></a> <strong>get_edge_max_error</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>The maximum distance a simplified contour's border edges should deviate the original raw contour.</p>  <h3 id="class-navigationmesh-property-edge-max-length">
<a href="class_float.html#class-float"><span class="std std-ref">float</span></a> edge_max_length = <code>0.0</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_edge_max_length</strong> <strong>(</strong> <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> value <strong>)</strong>
</li> <li>
<a href="class_float.html#class-float"><span class="std std-ref">float</span></a> <strong>get_edge_max_length</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>The maximum allowed length for contour edges along the border of the mesh. A value of <code>0.0</code> disables this feature.</p> <p><strong>Note:</strong> While baking, this value will be rounded up to the nearest multiple of <a href="#class-navigationmesh-property-cell-size"><span class="std std-ref">cell_size</span></a>.</p>  <h3 id="class-navigationmesh-property-filter-baking-aabb">
<a href="class_aabb.html#class-aabb"><span class="std std-ref">AABB</span></a> filter_baking_aabb = <code>AABB(0, 0, 0, 0, 0, 0)</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_filter_baking_aabb</strong> <strong>(</strong> <a href="class_aabb.html#class-aabb"><span class="std std-ref">AABB</span></a> value <strong>)</strong>
</li> <li>
<a href="class_aabb.html#class-aabb"><span class="std std-ref">AABB</span></a> <strong>get_filter_baking_aabb</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>If the baking <a href="class_aabb.html#class-aabb"><span class="std std-ref">AABB</span></a> has a volume the navigation mesh baking will be restricted to its enclosing area.</p>  <h3 id="class-navigationmesh-property-filter-baking-aabb-offset">
<a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> filter_baking_aabb_offset = <code>Vector3(0, 0, 0)</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_filter_baking_aabb_offset</strong> <strong>(</strong> <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> value <strong>)</strong>
</li> <li>
<a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> <strong>get_filter_baking_aabb_offset</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>The position offset applied to the <a href="#class-navigationmesh-property-filter-baking-aabb"><span class="std std-ref">filter_baking_aabb</span></a> <a href="class_aabb.html#class-aabb"><span class="std std-ref">AABB</span></a>.</p>  <h3 id="class-navigationmesh-property-filter-ledge-spans">
<a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> filter_ledge_spans = <code>false</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_filter_ledge_spans</strong> <strong>(</strong> <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> value <strong>)</strong>
</li> <li>
<a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> <strong>get_filter_ledge_spans</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>If <code>true</code>, marks spans that are ledges as non-walkable.</p>  <h3 id="class-navigationmesh-property-filter-low-hanging-obstacles">
<a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> filter_low_hanging_obstacles = <code>false</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_filter_low_hanging_obstacles</strong> <strong>(</strong> <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> value <strong>)</strong>
</li> <li>
<a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> <strong>get_filter_low_hanging_obstacles</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>If <code>true</code>, marks non-walkable spans as walkable if their maximum is within <a href="#class-navigationmesh-property-agent-max-climb"><span class="std std-ref">agent_max_climb</span></a> of a walkable neighbor.</p>  <h3 id="class-navigationmesh-property-filter-walkable-low-height-spans">
<a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> filter_walkable_low_height_spans = <code>false</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_filter_walkable_low_height_spans</strong> <strong>(</strong> <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> value <strong>)</strong>
</li> <li>
<a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> <strong>get_filter_walkable_low_height_spans</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>If <code>true</code>, marks walkable spans as not walkable if the clearance above the span is less than <a href="#class-navigationmesh-property-agent-height"><span class="std std-ref">agent_height</span></a>.</p>  <h3 id="class-navigationmesh-property-geometry-collision-mask">
<a href="class_int.html#class-int"><span class="std std-ref">int</span></a> geometry_collision_mask = <code>4294967295</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_collision_mask</strong> <strong>(</strong> <a href="class_int.html#class-int"><span class="std std-ref">int</span></a> value <strong>)</strong>
</li> <li>
<a href="class_int.html#class-int"><span class="std std-ref">int</span></a> <strong>get_collision_mask</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>The physics layers to scan for static colliders.</p> <p>Only used when <a href="#class-navigationmesh-property-geometry-parsed-geometry-type"><span class="std std-ref">geometry_parsed_geometry_type</span></a> is <a href="#class-navigationmesh-constant-parsed-geometry-static-colliders"><span class="std std-ref">PARSED_GEOMETRY_STATIC_COLLIDERS</span></a> or <a href="#class-navigationmesh-constant-parsed-geometry-both"><span class="std std-ref">PARSED_GEOMETRY_BOTH</span></a>.</p>  <h3 id="class-navigationmesh-property-geometry-parsed-geometry-type">
<a href="#enum-navigationmesh-parsedgeometrytype"><span class="std std-ref">ParsedGeometryType</span></a> geometry_parsed_geometry_type = <code>0</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_parsed_geometry_type</strong> <strong>(</strong> <a href="#enum-navigationmesh-parsedgeometrytype"><span class="std std-ref">ParsedGeometryType</span></a> value <strong>)</strong>
</li> <li>
<a href="#enum-navigationmesh-parsedgeometrytype"><span class="std std-ref">ParsedGeometryType</span></a> <strong>get_parsed_geometry_type</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>Determines which type of nodes will be parsed as geometry. See <a href="#enum-navigationmesh-parsedgeometrytype"><span class="std std-ref">ParsedGeometryType</span></a> for possible values.</p>  <h3 id="class-navigationmesh-property-geometry-source-geometry-mode">
<a href="#enum-navigationmesh-sourcegeometrymode"><span class="std std-ref">SourceGeometryMode</span></a> geometry_source_geometry_mode = <code>0</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_source_geometry_mode</strong> <strong>(</strong> <a href="#enum-navigationmesh-sourcegeometrymode"><span class="std std-ref">SourceGeometryMode</span></a> value <strong>)</strong>
</li> <li>
<a href="#enum-navigationmesh-sourcegeometrymode"><span class="std std-ref">SourceGeometryMode</span></a> <strong>get_source_geometry_mode</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>The source of the geometry used when baking. See <a href="#enum-navigationmesh-sourcegeometrymode"><span class="std std-ref">SourceGeometryMode</span></a> for possible values.</p>  <h3 id="class-navigationmesh-property-geometry-source-group-name">
<a href="class_stringname.html#class-stringname"><span class="std std-ref">StringName</span></a> geometry_source_group_name = <code>&amp;"navigation_mesh_source_group"</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_source_group_name</strong> <strong>(</strong> <a href="class_stringname.html#class-stringname"><span class="std std-ref">StringName</span></a> value <strong>)</strong>
</li> <li>
<a href="class_stringname.html#class-stringname"><span class="std std-ref">StringName</span></a> <strong>get_source_group_name</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>The name of the group to scan for geometry.</p> <p>Only used when <a href="#class-navigationmesh-property-geometry-source-geometry-mode"><span class="std std-ref">geometry_source_geometry_mode</span></a> is <a href="#class-navigationmesh-constant-source-geometry-groups-with-children"><span class="std std-ref">SOURCE_GEOMETRY_GROUPS_WITH_CHILDREN</span></a> or <a href="#class-navigationmesh-constant-source-geometry-groups-explicit"><span class="std std-ref">SOURCE_GEOMETRY_GROUPS_EXPLICIT</span></a>.</p>  <h3 id="class-navigationmesh-property-region-merge-size">
<a href="class_float.html#class-float"><span class="std std-ref">float</span></a> region_merge_size = <code>20.0</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_region_merge_size</strong> <strong>(</strong> <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> value <strong>)</strong>
</li> <li>
<a href="class_float.html#class-float"><span class="std std-ref">float</span></a> <strong>get_region_merge_size</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>Any regions with a size smaller than this will be merged with larger regions if possible.</p> <p><strong>Note:</strong> This value will be squared to calculate the number of cells. For example, a value of 20 will set the number of cells to 400.</p>  <h3 id="class-navigationmesh-property-region-min-size">
<a href="class_float.html#class-float"><span class="std std-ref">float</span></a> region_min_size = <code>2.0</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_region_min_size</strong> <strong>(</strong> <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> value <strong>)</strong>
</li> <li>
<a href="class_float.html#class-float"><span class="std std-ref">float</span></a> <strong>get_region_min_size</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>The minimum size of a region for it to be created.</p> <p><strong>Note:</strong> This value will be squared to calculate the minimum number of cells allowed to form isolated island areas. For example, a value of 8 will set the number of cells to 64.</p>  <h3 id="class-navigationmesh-property-sample-partition-type">
<a href="#enum-navigationmesh-samplepartitiontype"><span class="std std-ref">SamplePartitionType</span></a> sample_partition_type = <code>0</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_sample_partition_type</strong> <strong>(</strong> <a href="#enum-navigationmesh-samplepartitiontype"><span class="std std-ref">SamplePartitionType</span></a> value <strong>)</strong>
</li> <li>
<a href="#enum-navigationmesh-samplepartitiontype"><span class="std std-ref">SamplePartitionType</span></a> <strong>get_sample_partition_type</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>Partitioning algorithm for creating the navigation mesh polys. See <a href="#enum-navigationmesh-samplepartitiontype"><span class="std std-ref">SamplePartitionType</span></a> for possible values.</p>  <h3 id="class-navigationmesh-property-vertices-per-polygon">
<a href="class_float.html#class-float"><span class="std std-ref">float</span></a> vertices_per_polygon = <code>6.0</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_vertices_per_polygon</strong> <strong>(</strong> <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> value <strong>)</strong>
</li> <li>
<a href="class_float.html#class-float"><span class="std std-ref">float</span></a> <strong>get_vertices_per_polygon</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>The maximum number of vertices allowed for polygons generated during the contour to polygon conversion process.</p> </section>  <section class="classref-descriptions-group" id="method-descriptions"> <h2>Method Descriptions</h2> <h3 id="class-navigationmesh-method-add-polygon">void add_polygon ( <a href="class_packedint32array.html#class-packedint32array"><span class="std std-ref">PackedInt32Array</span></a> polygon )</h3> <p>Adds a polygon using the indices of the vertices you get when calling <a href="#class-navigationmesh-method-get-vertices"><span class="std std-ref">get_vertices</span></a>.</p>  <h3 id="class-navigationmesh-method-clear">void clear ( )</h3> <p>Clears the internal arrays for vertices and polygon indices.</p>  <h3 id="class-navigationmesh-method-clear-polygons">void clear_polygons ( )</h3> <p>Clears the array of polygons, but it doesn't clear the array of vertices.</p>  <h3 id="class-navigationmesh-method-create-from-mesh">void create_from_mesh ( <a href="class_mesh.html#class-mesh"><span class="std std-ref">Mesh</span></a> mesh )</h3> <p>Initializes the navigation mesh by setting the vertices and indices according to a <a href="class_mesh.html#class-mesh"><span class="std std-ref">Mesh</span></a>.</p> <p><strong>Note:</strong> The given <code>mesh</code> must be of type <a href="class_mesh.html#class-mesh-constant-primitive-triangles"><span class="std std-ref">Mesh.PRIMITIVE_TRIANGLES</span></a> and have an index array.</p>  <h3 id="class-navigationmesh-method-get-collision-mask-value">
<a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> get_collision_mask_value ( <a href="class_int.html#class-int"><span class="std std-ref">int</span></a> layer_number ) <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr>
</h3> <p>Returns whether or not the specified layer of the <a href="#class-navigationmesh-property-geometry-collision-mask"><span class="std std-ref">geometry_collision_mask</span></a> is enabled, given a <code>layer_number</code> between 1 and 32.</p>  <h3 id="class-navigationmesh-method-get-polygon">
<a href="class_packedint32array.html#class-packedint32array"><span class="std std-ref">PackedInt32Array</span></a> get_polygon ( <a href="class_int.html#class-int"><span class="std std-ref">int</span></a> idx )</h3> <p>Returns a <a href="class_packedint32array.html#class-packedint32array"><span class="std std-ref">PackedInt32Array</span></a> containing the indices of the vertices of a created polygon.</p>  <h3 id="class-navigationmesh-method-get-polygon-count">
<a href="class_int.html#class-int"><span class="std std-ref">int</span></a> get_polygon_count ( ) <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr>
</h3> <p>Returns the number of polygons in the navigation mesh.</p>  <h3 id="class-navigationmesh-method-get-vertices">
<a href="class_packedvector3array.html#class-packedvector3array"><span class="std std-ref">PackedVector3Array</span></a> get_vertices ( ) <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr>
</h3> <p>Returns a <a href="class_packedvector3array.html#class-packedvector3array"><span class="std std-ref">PackedVector3Array</span></a> containing all the vertices being used to create the polygons.</p>  <h3 id="class-navigationmesh-method-set-collision-mask-value">void set_collision_mask_value ( <a href="class_int.html#class-int"><span class="std std-ref">int</span></a> layer_number, <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> value )</h3> <p>Based on <code>value</code>, enables or disables the specified layer in the <a href="#class-navigationmesh-property-geometry-collision-mask"><span class="std std-ref">geometry_collision_mask</span></a>, given a <code>layer_number</code> between 1 and 32.</p>  <h3 id="class-navigationmesh-method-set-vertices">void set_vertices ( <a href="class_packedvector3array.html#class-packedvector3array"><span class="std std-ref">PackedVector3Array</span></a> vertices )</h3> <p>Sets the vertices that can be then indexed to create polygons with the <a href="#class-navigationmesh-method-add-polygon"><span class="std std-ref">add_polygon</span></a> method.</p> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2014&ndash;present Juan Linietsky, Ariel Manzur and the Godot community<br>Licensed under the Creative Commons Attribution Unported License v3.0.<br>
    <a href="https://docs.godotengine.org/en/4.2/classes/class_navigationmesh.html" class="_attribution-link">https://docs.godotengine.org/en/4.2/classes/class_navigationmesh.html</a>
  </p>
</div>
