<section id="canvaslayer"> <h1 id="class-canvaslayer">CanvasLayer</h1> <p><strong>Inherits:</strong> <a href="class_node.html#class-node"><span class="std std-ref">Node</span></a> <strong>&lt;</strong> <a href="class_object.html#class-object"><span class="std std-ref">Object</span></a></p> <p><strong>Inherited By:</strong> <a href="class_parallaxbackground.html#class-parallaxbackground"><span class="std std-ref">ParallaxBackground</span></a></p> <p>A node used for independent rendering of objects within a 2D scene.</p> <section class="classref-introduction-group" id="description"> <h2>Description</h2> <p><a href="class_canvasitem.html#class-canvasitem"><span class="std std-ref">CanvasItem</span></a>-derived nodes that are direct or indirect children of a <strong>CanvasLayer</strong> will be drawn in that layer. The layer is a numeric index that defines the draw order. The default 2D scene renders with index <code>0</code>, so a <strong>CanvasLayer</strong> with index <code>-1</code> will be drawn below, and a <strong>CanvasLayer</strong> with index <code>1</code> will be drawn above. This order will hold regardless of the <a href="class_canvasitem.html#class-canvasitem-property-z-index"><span class="std std-ref">CanvasItem.z_index</span></a> of the nodes within each layer.</p> <p><strong>CanvasLayer</strong>s can be hidden and they can also optionally follow the viewport. This makes them useful for HUDs like health bar overlays (on layers <code>1</code> and higher) or backgrounds (on layers <code>-1</code> and lower).</p> <p><strong>Note:</strong> Embedded <a href="class_window.html#class-window"><span class="std std-ref">Window</span></a>s are placed on layer <code>1024</code>. <a href="class_canvasitem.html#class-canvasitem"><span class="std std-ref">CanvasItem</span></a>s on layers <code>1025</code> and higher appear in front of embedded windows.</p> <p><strong>Note:</strong> Each <strong>CanvasLayer</strong> is drawn on one specific <a href="class_viewport.html#class-viewport"><span class="std std-ref">Viewport</span></a> and cannot be shared between multiple <a href="class_viewport.html#class-viewport"><span class="std std-ref">Viewport</span></a>s, see <a href="#class-canvaslayer-property-custom-viewport"><span class="std std-ref">custom_viewport</span></a>. When using multiple <a href="class_viewport.html#class-viewport"><span class="std std-ref">Viewport</span></a>s, for example in a split-screen game, you need create an individual <strong>CanvasLayer</strong> for each <a href="class_viewport.html#class-viewport"><span class="std std-ref">Viewport</span></a> you want it to be drawn on.</p> </section> <section class="classref-introduction-group" id="tutorials"> <h2>Tutorials</h2> <ul class="simple"> <li><a href="https://docs.godotengine.org/en/4.2/tutorials/2d/2d_transforms.html"><span class="doc">Viewport and canvas transforms</span></a></li> <li><a href="https://docs.godotengine.org/en/4.2/tutorials/2d/canvas_layers.html"><span class="doc">Canvas layers</span></a></li> <li><a href="https://godotengine.org/asset-library/asset/515">2D Dodge The Creeps Demo</a></li> </ul> </section> <section class="classref-reftable-group" id="properties"> <h2>Properties</h2> <table class="colwidths-auto docutils align-default">  <tr>
<td><p><a href="class_node.html#class-node"><span class="std std-ref">Node</span></a></p></td> <td><p><a href="#class-canvaslayer-property-custom-viewport"><span class="std std-ref">custom_viewport</span></a></p></td> <td></td> </tr> <tr>
<td><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a></p></td> <td><p><a href="#class-canvaslayer-property-follow-viewport-enabled"><span class="std std-ref">follow_viewport_enabled</span></a></p></td> <td><p><code>false</code></p></td> </tr> <tr>
<td><p><a href="class_float.html#class-float"><span class="std std-ref">float</span></a></p></td> <td><p><a href="#class-canvaslayer-property-follow-viewport-scale"><span class="std std-ref">follow_viewport_scale</span></a></p></td> <td><p><code>1.0</code></p></td> </tr> <tr>
<td><p><a href="class_int.html#class-int"><span class="std std-ref">int</span></a></p></td> <td><p><a href="#class-canvaslayer-property-layer"><span class="std std-ref">layer</span></a></p></td> <td><p><code>1</code></p></td> </tr> <tr>
<td><p><a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a></p></td> <td><p><a href="#class-canvaslayer-property-offset"><span class="std std-ref">offset</span></a></p></td> <td><p><code>Vector2(0, 0)</code></p></td> </tr> <tr>
<td><p><a href="class_float.html#class-float"><span class="std std-ref">float</span></a></p></td> <td><p><a href="#class-canvaslayer-property-rotation"><span class="std std-ref">rotation</span></a></p></td> <td><p><code>0.0</code></p></td> </tr> <tr>
<td><p><a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a></p></td> <td><p><a href="#class-canvaslayer-property-scale"><span class="std std-ref">scale</span></a></p></td> <td><p><code>Vector2(1, 1)</code></p></td> </tr> <tr>
<td><p><a href="class_transform2d.html#class-transform2d"><span class="std std-ref">Transform2D</span></a></p></td> <td><p><a href="#class-canvaslayer-property-transform"><span class="std std-ref">transform</span></a></p></td> <td><p><code>Transform2D(1, 0, 0, 1, 0, 0)</code></p></td> </tr> <tr>
<td><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a></p></td> <td><p><a href="#class-canvaslayer-property-visible"><span class="std std-ref">visible</span></a></p></td> <td><p><code>true</code></p></td> </tr>  </table> </section> <section class="classref-reftable-group" id="methods"> <h2>Methods</h2> <table class="colwidths-auto docutils align-default">  <tr>
<td><p><a href="class_rid.html#class-rid"><span class="std std-ref">RID</span></a></p></td> <td><p><a href="#class-canvaslayer-method-get-canvas"><span class="std std-ref">get_canvas</span></a> <strong>(</strong> <strong>)</strong> <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr></p></td> </tr> <tr>
<td><p><a href="class_transform2d.html#class-transform2d"><span class="std std-ref">Transform2D</span></a></p></td> <td><p><a href="#class-canvaslayer-method-get-final-transform"><span class="std std-ref">get_final_transform</span></a> <strong>(</strong> <strong>)</strong> <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-canvaslayer-method-hide"><span class="std std-ref">hide</span></a> <strong>(</strong> <strong>)</strong></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-canvaslayer-method-show"><span class="std std-ref">show</span></a> <strong>(</strong> <strong>)</strong></p></td> </tr>  </table> </section>  <section class="classref-descriptions-group" id="signals"> <h2>Signals</h2> <h3 id="class-canvaslayer-signal-visibility-changed">visibility_changed ( )</h3> <p>Emitted when visibility of the layer is changed. See <a href="#class-canvaslayer-property-visible"><span class="std std-ref">visible</span></a>.</p> </section>  <section class="classref-descriptions-group" id="property-descriptions"> <h2>Property Descriptions</h2> <h3 id="class-canvaslayer-property-custom-viewport">
<a href="class_node.html#class-node"><span class="std std-ref">Node</span></a> custom_viewport</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_custom_viewport</strong> <strong>(</strong> <a href="class_node.html#class-node"><span class="std std-ref">Node</span></a> value <strong>)</strong>
</li> <li>
<a href="class_node.html#class-node"><span class="std std-ref">Node</span></a> <strong>get_custom_viewport</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>The custom <a href="class_viewport.html#class-viewport"><span class="std std-ref">Viewport</span></a> node assigned to the <strong>CanvasLayer</strong>. If <code>null</code>, uses the default viewport instead.</p>  <h3 id="class-canvaslayer-property-follow-viewport-enabled">
<a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> follow_viewport_enabled = <code>false</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_follow_viewport</strong> <strong>(</strong> <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> value <strong>)</strong>
</li> <li>
<a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> <strong>is_following_viewport</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>If enabled, the <strong>CanvasLayer</strong> will use the viewport's transform, so it will move when camera moves instead of being anchored in a fixed position on the screen.</p> <p>Together with <a href="#class-canvaslayer-property-follow-viewport-scale"><span class="std std-ref">follow_viewport_scale</span></a> it can be used for a pseudo 3D effect.</p>  <h3 id="class-canvaslayer-property-follow-viewport-scale">
<a href="class_float.html#class-float"><span class="std std-ref">float</span></a> follow_viewport_scale = <code>1.0</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_follow_viewport_scale</strong> <strong>(</strong> <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> value <strong>)</strong>
</li> <li>
<a href="class_float.html#class-float"><span class="std std-ref">float</span></a> <strong>get_follow_viewport_scale</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>Scales the layer when using <a href="#class-canvaslayer-property-follow-viewport-enabled"><span class="std std-ref">follow_viewport_enabled</span></a>. Layers moving into the foreground should have increasing scales, while layers moving into the background should have decreasing scales.</p>  <h3 id="class-canvaslayer-property-layer">
<a href="class_int.html#class-int"><span class="std std-ref">int</span></a> layer = <code>1</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_layer</strong> <strong>(</strong> <a href="class_int.html#class-int"><span class="std std-ref">int</span></a> value <strong>)</strong>
</li> <li>
<a href="class_int.html#class-int"><span class="std std-ref">int</span></a> <strong>get_layer</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>Layer index for draw order. Lower values are drawn behind higher values.</p> <p><strong>Note:</strong> If multiple CanvasLayers have the same layer index, <a href="class_canvasitem.html#class-canvasitem"><span class="std std-ref">CanvasItem</span></a> children of one CanvasLayer are drawn behind the <a href="class_canvasitem.html#class-canvasitem"><span class="std std-ref">CanvasItem</span></a> children of the other CanvasLayer. Which CanvasLayer is drawn in front is non-deterministic.</p>  <h3 id="class-canvaslayer-property-offset">
<a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> offset = <code>Vector2(0, 0)</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_offset</strong> <strong>(</strong> <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> value <strong>)</strong>
</li> <li>
<a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> <strong>get_offset</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>The layer's base offset.</p>  <h3 id="class-canvaslayer-property-rotation">
<a href="class_float.html#class-float"><span class="std std-ref">float</span></a> rotation = <code>0.0</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_rotation</strong> <strong>(</strong> <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> value <strong>)</strong>
</li> <li>
<a href="class_float.html#class-float"><span class="std std-ref">float</span></a> <strong>get_rotation</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>The layer's rotation in radians.</p>  <h3 id="class-canvaslayer-property-scale">
<a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> scale = <code>Vector2(1, 1)</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_scale</strong> <strong>(</strong> <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> value <strong>)</strong>
</li> <li>
<a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> <strong>get_scale</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>The layer's scale.</p>  <h3 id="class-canvaslayer-property-transform">
<a href="class_transform2d.html#class-transform2d"><span class="std std-ref">Transform2D</span></a> transform = <code>Transform2D(1, 0, 0, 1, 0, 0)</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_transform</strong> <strong>(</strong> <a href="class_transform2d.html#class-transform2d"><span class="std std-ref">Transform2D</span></a> value <strong>)</strong>
</li> <li>
<a href="class_transform2d.html#class-transform2d"><span class="std std-ref">Transform2D</span></a> <strong>get_transform</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>The layer's transform.</p>  <h3 id="class-canvaslayer-property-visible">
<a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> visible = <code>true</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_visible</strong> <strong>(</strong> <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> value <strong>)</strong>
</li> <li>
<a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> <strong>is_visible</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>If <code>false</code>, any <a href="class_canvasitem.html#class-canvasitem"><span class="std std-ref">CanvasItem</span></a> under this <strong>CanvasLayer</strong> will be hidden.</p> <p>Unlike <a href="class_canvasitem.html#class-canvasitem-property-visible"><span class="std std-ref">CanvasItem.visible</span></a>, visibility of a <strong>CanvasLayer</strong> isn't propagated to underlying layers.</p> </section>  <section class="classref-descriptions-group" id="method-descriptions"> <h2>Method Descriptions</h2> <h3 id="class-canvaslayer-method-get-canvas">
<a href="class_rid.html#class-rid"><span class="std std-ref">RID</span></a> get_canvas ( ) <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr>
</h3> <p>Returns the RID of the canvas used by this layer.</p>  <h3 id="class-canvaslayer-method-get-final-transform">
<a href="class_transform2d.html#class-transform2d"><span class="std std-ref">Transform2D</span></a> get_final_transform ( ) <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr>
</h3> <p>Returns the transform from the <strong>CanvasLayer</strong>s coordinate system to the <a href="class_viewport.html#class-viewport"><span class="std std-ref">Viewport</span></a>s coordinate system.</p>  <h3 id="class-canvaslayer-method-hide">void hide ( )</h3> <p>Hides any <a href="class_canvasitem.html#class-canvasitem"><span class="std std-ref">CanvasItem</span></a> under this <strong>CanvasLayer</strong>. This is equivalent to setting <a href="#class-canvaslayer-property-visible"><span class="std std-ref">visible</span></a> to <code>false</code>.</p>  <h3 id="class-canvaslayer-method-show">void show ( )</h3> <p>Shows any <a href="class_canvasitem.html#class-canvasitem"><span class="std std-ref">CanvasItem</span></a> under this <strong>CanvasLayer</strong>. This is equivalent to setting <a href="#class-canvaslayer-property-visible"><span class="std std-ref">visible</span></a> to <code>true</code>.</p> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2014&ndash;present Juan Linietsky, Ariel Manzur and the Godot community<br>Licensed under the Creative Commons Attribution Unported License v3.0.<br>
    <a href="https://docs.godotengine.org/en/4.2/classes/class_canvaslayer.html" class="_attribution-link">https://docs.godotengine.org/en/4.2/classes/class_canvaslayer.html</a>
  </p>
</div>
