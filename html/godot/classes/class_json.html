<section id="json"> <h1 id="class-json">JSON</h1> <p><strong>Inherits:</strong> <a href="class_resource.html#class-resource"><span class="std std-ref">Resource</span></a> <strong>&lt;</strong> <a href="class_refcounted.html#class-refcounted"><span class="std std-ref">RefCounted</span></a> <strong>&lt;</strong> <a href="class_object.html#class-object"><span class="std std-ref">Object</span></a></p> <p>Helper class for creating and parsing JSON data.</p> <section class="classref-introduction-group" id="description"> <h2>Description</h2> <p>The <strong>JSON</strong> enables all data types to be converted to and from a JSON string. This useful for serializing data to save to a file or send over the network.</p> <p><a href="#class-json-method-stringify"><span class="std std-ref">stringify</span></a> is used to convert any data type into a JSON string.</p> <p><a href="#class-json-method-parse"><span class="std std-ref">parse</span></a> is used to convert any existing JSON data into a <a href="class_variant.html#class-variant"><span class="std std-ref">Variant</span></a> that can be used within Godot. If successfully parsed, use <a href="#class-json-property-data"><span class="std std-ref">data</span></a> to retrieve the <a href="class_variant.html#class-variant"><span class="std std-ref">Variant</span></a>, and use <code>typeof</code> to check if the Variant's type is what you expect. JSON Objects are converted into a <a href="class_dictionary.html#class-dictionary"><span class="std std-ref">Dictionary</span></a>, but JSON data can be used to store <a href="class_array.html#class-array"><span class="std std-ref">Array</span></a>s, numbers, <a href="class_string.html#class-string"><span class="std std-ref">String</span></a>s and even just a boolean.</p> <p><strong>Example</strong></p> <pre data-language="gdscript">var data_to_send = ["a", "b", "c"]
var json_string = JSON.stringify(data_to_send)
# Save data
# ...
# Retrieve data
var json = JSON.new()
var error = json.parse(json_string)
if error == OK:
    var data_received = json.data
    if typeof(data_received) == TYPE_ARRAY:
        print(data_received) # Prints array
    else:
        print("Unexpected data")
else:
    print("JSON Parse Error: ", json.get_error_message(), " in ", json_string, " at line ", json.get_error_line())
</pre> <p>Alternatively, you can parse string using the static <a href="#class-json-method-parse-string"><span class="std std-ref">parse_string</span></a> method, but it doesn't allow to handle errors.</p> <pre data-language="gdscript">var data = JSON.parse_string(json_string) # Returns null if parsing failed.
</pre> <p><strong>Note:</strong> Both parse methods do not fully comply with the JSON specification:</p> <ul class="simple"> <li>Trailing commas in arrays or objects are ignored, instead of causing a parser error.</li> <li>New line and tab characters are accepted in string literals, and are treated like their corresponding escape sequences <code>\n</code> and <code>\t</code>.</li> <li>Numbers are parsed using <a href="class_string.html#class-string-method-to-float"><span class="std std-ref">String.to_float</span></a> which is generally more lax than the JSON specification.</li> <li>Certain errors, such as invalid Unicode sequences, do not cause a parser error. Instead, the string is cleansed and an error is logged to the console.</li> </ul> </section> <section class="classref-reftable-group" id="properties"> <h2>Properties</h2> <table class="colwidths-auto docutils align-default">  <tr>
<td><p><a href="class_variant.html#class-variant"><span class="std std-ref">Variant</span></a></p></td> <td><p><a href="#class-json-property-data"><span class="std std-ref">data</span></a></p></td> <td><p><code>null</code></p></td> </tr>  </table> </section> <section class="classref-reftable-group" id="methods"> <h2>Methods</h2> <table class="colwidths-auto docutils align-default">  <tr>
<td><p><a href="class_int.html#class-int"><span class="std std-ref">int</span></a></p></td> <td><p><a href="#class-json-method-get-error-line"><span class="std std-ref">get_error_line</span></a> <strong>(</strong> <strong>)</strong> <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr></p></td> </tr> <tr>
<td><p><a href="class_string.html#class-string"><span class="std std-ref">String</span></a></p></td> <td><p><a href="#class-json-method-get-error-message"><span class="std std-ref">get_error_message</span></a> <strong>(</strong> <strong>)</strong> <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr></p></td> </tr> <tr>
<td><p><a href="class_string.html#class-string"><span class="std std-ref">String</span></a></p></td> <td><p><a href="#class-json-method-get-parsed-text"><span class="std std-ref">get_parsed_text</span></a> <strong>(</strong> <strong>)</strong> <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr></p></td> </tr> <tr>
<td><p><a href="class_%40globalscope.html#enum-globalscope-error"><span class="std std-ref">Error</span></a></p></td> <td><p><a href="#class-json-method-parse"><span class="std std-ref">parse</span></a> <strong>(</strong> <a href="class_string.html#class-string"><span class="std std-ref">String</span></a> json_text, <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> keep_text=false <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_variant.html#class-variant"><span class="std std-ref">Variant</span></a></p></td> <td><p><a href="#class-json-method-parse-string"><span class="std std-ref">parse_string</span></a> <strong>(</strong> <a href="class_string.html#class-string"><span class="std std-ref">String</span></a> json_string <strong>)</strong> <abbr title="This method doesn't need an instance to be called, so it can be called directly using the class name.">static</abbr></p></td> </tr> <tr>
<td><p><a href="class_string.html#class-string"><span class="std std-ref">String</span></a></p></td> <td><p><a href="#class-json-method-stringify"><span class="std std-ref">stringify</span></a> <strong>(</strong> <a href="class_variant.html#class-variant"><span class="std std-ref">Variant</span></a> data, <a href="class_string.html#class-string"><span class="std std-ref">String</span></a> indent="", <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> sort_keys=true, <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> full_precision=false <strong>)</strong> <abbr title="This method doesn't need an instance to be called, so it can be called directly using the class name.">static</abbr></p></td> </tr>  </table> </section>  <section class="classref-descriptions-group" id="property-descriptions"> <h2>Property Descriptions</h2> <h3 id="class-json-property-data">
<a href="class_variant.html#class-variant"><span class="std std-ref">Variant</span></a> data = <code>null</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_data</strong> <strong>(</strong> <a href="class_variant.html#class-variant"><span class="std std-ref">Variant</span></a> value <strong>)</strong>
</li> <li>
<a href="class_variant.html#class-variant"><span class="std std-ref">Variant</span></a> <strong>get_data</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>Contains the parsed JSON data in <a href="class_variant.html#class-variant"><span class="std std-ref">Variant</span></a> form.</p> </section>  <section class="classref-descriptions-group" id="method-descriptions"> <h2>Method Descriptions</h2> <h3 id="class-json-method-get-error-line">
<a href="class_int.html#class-int"><span class="std std-ref">int</span></a> get_error_line ( ) <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr>
</h3> <p>Returns <code>0</code> if the last call to <a href="#class-json-method-parse"><span class="std std-ref">parse</span></a> was successful, or the line number where the parse failed.</p>  <h3 id="class-json-method-get-error-message">
<a href="class_string.html#class-string"><span class="std std-ref">String</span></a> get_error_message ( ) <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr>
</h3> <p>Returns an empty string if the last call to <a href="#class-json-method-parse"><span class="std std-ref">parse</span></a> was successful, or the error message if it failed.</p>  <h3 id="class-json-method-get-parsed-text">
<a href="class_string.html#class-string"><span class="std std-ref">String</span></a> get_parsed_text ( ) <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr>
</h3> <p>Return the text parsed by <a href="#class-json-method-parse"><span class="std std-ref">parse</span></a> as long as the function is instructed to keep it.</p>  <h3 id="class-json-method-parse">
<a href="class_%40globalscope.html#enum-globalscope-error"><span class="std std-ref">Error</span></a> parse ( <a href="class_string.html#class-string"><span class="std std-ref">String</span></a> json_text, <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> keep_text=false )</h3> <p>Attempts to parse the <code>json_text</code> provided.</p> <p>Returns an <a href="class_%40globalscope.html#enum-globalscope-error"><span class="std std-ref">Error</span></a>. If the parse was successful, it returns <a href="class_%40globalscope.html#class-globalscope-constant-ok"><span class="std std-ref">@GlobalScope.OK</span></a> and the result can be retrieved using <a href="#class-json-property-data"><span class="std std-ref">data</span></a>. If unsuccessful, use <a href="#class-json-method-get-error-line"><span class="std std-ref">get_error_line</span></a> and <a href="#class-json-method-get-error-message"><span class="std std-ref">get_error_message</span></a> for identifying the source of the failure.</p> <p>Non-static variant of <a href="#class-json-method-parse-string"><span class="std std-ref">parse_string</span></a>, if you want custom error handling.</p> <p>The optional <code>keep_text</code> argument instructs the parser to keep a copy of the original text. This text can be obtained later by using the <a href="#class-json-method-get-parsed-text"><span class="std std-ref">get_parsed_text</span></a> function and is used when saving the resource (instead of generating new text from <a href="#class-json-property-data"><span class="std std-ref">data</span></a>).</p>  <h3 id="class-json-method-parse-string">
<a href="class_variant.html#class-variant"><span class="std std-ref">Variant</span></a> parse_string ( <a href="class_string.html#class-string"><span class="std std-ref">String</span></a> json_string ) <abbr title="This method doesn't need an instance to be called, so it can be called directly using the class name.">static</abbr>
</h3> <p>Attempts to parse the <code>json_string</code> provided and returns the parsed data. Returns <code>null</code> if parse failed.</p>  <h3 id="class-json-method-stringify">
<a href="class_string.html#class-string"><span class="std std-ref">String</span></a> stringify ( <a href="class_variant.html#class-variant"><span class="std std-ref">Variant</span></a> data, <a href="class_string.html#class-string"><span class="std std-ref">String</span></a> indent="", <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> sort_keys=true, <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> full_precision=false ) <abbr title="This method doesn't need an instance to be called, so it can be called directly using the class name.">static</abbr>
</h3> <p>Converts a <a href="class_variant.html#class-variant"><span class="std std-ref">Variant</span></a> var to JSON text and returns the result. Useful for serializing data to store or send over the network.</p> <p><strong>Note:</strong> The JSON specification does not define integer or float types, but only a <em>number</em> type. Therefore, converting a Variant to JSON text will convert all numerical values to <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> types.</p> <p><strong>Note:</strong> If <code>full_precision</code> is <code>true</code>, when stringifying floats, the unreliable digits are stringified in addition to the reliable digits to guarantee exact decoding.</p> <p>The <code>indent</code> parameter controls if and how something is indented, the string used for this parameter will be used where there should be an indent in the output, even spaces like <code>"   "</code> will work. <code>\t</code> and <code>\n</code> can also be used for a tab indent, or to make a newline for each indent respectively.</p> <p><strong>Example output:</strong></p> <pre data-language="gdscript">## JSON.stringify(my_dictionary)
{"name":"my_dictionary","version":"1.0.0","entities":[{"name":"entity_0","value":"value_0"},{"name":"entity_1","value":"value_1"}]}

## JSON.stringify(my_dictionary, "\t")
{
    "name": "my_dictionary",
    "version": "1.0.0",
    "entities": [
        {
            "name": "entity_0",
            "value": "value_0"
        },
        {
            "name": "entity_1",
            "value": "value_1"
        }
    ]
}

## JSON.stringify(my_dictionary, "...")
{
..."name": "my_dictionary",
..."version": "1.0.0",
..."entities": [
......{
........."name": "entity_0",
........."value": "value_0"
......},
......{
........."name": "entity_1",
........."value": "value_1"
......}
...]
}
</pre> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2014&ndash;present Juan Linietsky, Ariel Manzur and the Godot community<br>Licensed under the Creative Commons Attribution Unported License v3.0.<br>
    <a href="https://docs.godotengine.org/en/4.2/classes/class_json.html" class="_attribution-link">https://docs.godotengine.org/en/4.2/classes/class_json.html</a>
  </p>
</div>
