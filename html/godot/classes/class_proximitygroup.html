<h1 id="class-proximitygroup">ProximityGroup</h1> <p><strong>Inherits:</strong> <a href="class_spatial.html#class-spatial"><span class="std std-ref">Spatial</span></a> <strong>&lt;</strong> <a href="class_node.html#class-node"><span class="std std-ref">Node</span></a> <strong>&lt;</strong> <a href="class_object.html#class-object"><span class="std std-ref">Object</span></a></p> <p>General-purpose 3D proximity detection node.</p> <section id="description"> <h2>Description</h2> <p>General-purpose proximity detection node. <code>ProximityGroup</code> can be used for <em>approximate</em> distance checks, which are faster than exact distance checks using <a href="class_vector3.html#class-vector3-method-distance-to"><span class="std std-ref">Vector3.distance_to</span></a> or <a href="class_vector3.html#class-vector3-method-distance-squared-to"><span class="std std-ref">Vector3.distance_squared_to</span></a>.</p> <p><code>ProximityGroup</code> nodes are automatically grouped together, as long as they share the same <a href="#class-proximitygroup-property-group-name"><span class="std std-ref">group_name</span></a> and intersect with each other. By calling the <a href="#class-proximitygroup-method-broadcast"><span class="std std-ref">broadcast</span></a>, you can invoke a specified method with various parameters to all intersecting members.</p> <p><code>ProximityGroup</code> is cuboid-shaped and consists of a cluster of <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> coordinates. The coordinates are automatically calculated by calling <a href="#class-proximitygroup-property-grid-radius"><span class="std std-ref">grid_radius</span></a>. To allow <code>ProximityGroup</code> to find its peers (and perform automatic grouping), you need to define its <a href="#class-proximitygroup-property-group-name"><span class="std std-ref">group_name</span></a> to a non-empty <a href="class_string.html#class-string"><span class="std std-ref">String</span></a>. As soon as this object's shape intersects with another <code>ProximityGroup</code> object' shape, and both share the same <a href="#class-proximitygroup-property-group-name"><span class="std std-ref">group_name</span></a>, they will belong together for as long as they intersect.</p> <p>Since <code>ProximityGroup</code> doesn't rely the physics engine, you don't need to add any other node as a child (unlike <a href="class_physicsbody.html#class-physicsbody"><span class="std std-ref">PhysicsBody</span></a>).</p> <p>The <code>ProximityGroup</code> uses the <a href="class_scenetree.html#class-scenetree"><span class="std std-ref">SceneTree</span></a> groups in the background by calling the method <a href="class_node.html#class-node-method-add-to-group"><span class="std std-ref">Node.add_to_group</span></a> internally. The <a href="class_scenetree.html#class-scenetree"><span class="std std-ref">SceneTree</span></a> group names are constructed by combining the <a href="#class-proximitygroup-property-group-name"><span class="std std-ref">group_name</span></a> with its coordinates, which are calculated using the <a href="#class-proximitygroup-property-grid-radius"><span class="std std-ref">grid_radius</span></a> you defined beforehand.</p> <p><strong>Example:</strong> A <code>ProximityGroup</code> node named <code>"PlanetEarth"</code> at position <code>Vector3(6, 6, 6)</code> with a <a href="#class-proximitygroup-property-group-name"><span class="std std-ref">group_name</span></a> set to <code>"planets"</code> and a <a href="#class-proximitygroup-property-grid-radius"><span class="std std-ref">grid_radius</span></a> of <code>Vector3(1, 2, 3)</code> will create the following <a href="class_scenetree.html#class-scenetree"><span class="std std-ref">SceneTree</span></a> group names:</p> <pre data-language="gdscript">- "planets|5|4|3"
- "planets|5|4|4"
- "planets|5|4|5"
- "planets|5|4|6"
- "planets|5|4|7"
- "planets|5|4|8"
- "planets|5|4|9"
- ...
</pre> <p>If there is another <code>ProximityGroup</code> named <code>"PlanetMars"</code> with group name <code>"planets"</code>, and one of its coordinates is <code>Vector3(5, 4, 7)</code>, it would normally create the <a href="class_scenetree.html#class-scenetree"><span class="std std-ref">SceneTree</span></a> group called <code>"planets|5|4|7"</code>. However, since this group name already exists, this <code>ProximityGroup</code> object will be <em>added</em> to the existing one. <code>"PlanetEarth"</code> is already in this group. As long as both nodes don't change their transform and stop intersecting (or exit the scene tree), they are grouped together. As long as this intersection exists, any call to <a href="#class-proximitygroup-method-broadcast"><span class="std std-ref">broadcast</span></a> will affect <em>both</em> <code>ProximityGroup</code> nodes.</p> <p>There are 3 caveats to keep in mind when using <code>ProximityGroup</code>:</p> <ul class="simple"> <li>The larger the grid radius, the more coordinates and the more <a href="class_scenetree.html#class-scenetree"><span class="std std-ref">SceneTree</span></a> groups are created. This can have a performance impact if too many groups are created.</li> <li>If the <code>ProximityGroup</code> node is transformed in any way (or is removed from the scene tree), the groupings will have to be recalculated. This can also have a performance impact.</li> <li>If your <a href="#class-proximitygroup-property-grid-radius"><span class="std std-ref">grid_radius</span></a> is smaller than <code>Vector3(1, 1, 1)</code>, it will be rounded up to <code>Vector3(1, 1, 1)</code>. Therefore, small grid radius values may lead to unwanted groupings.</li> </ul> <p><strong>Note:</strong> <code>ProximityGroup</code> will be removed in Godot 4.0 in favor of more effective and faster <a href="class_visibilitynotifier.html#class-visibilitynotifier"><span class="std std-ref">VisibilityNotifier</span></a> functionality. For most use cases, <a href="class_vector3.html#class-vector3-method-distance-to"><span class="std std-ref">Vector3.distance_to</span></a> or <a href="class_vector3.html#class-vector3-method-distance-squared-to"><span class="std std-ref">Vector3.distance_squared_to</span></a> are fast enough too, especially if you call them less often using a <a href="class_timer.html#class-timer"><span class="std std-ref">Timer</span></a> node.</p> </section> <section id="properties"> <h2>Properties</h2> <table class="docutils align-default">   <tr>
<td><p><a href="#enum-proximitygroup-dispatchmode"><span class="std std-ref">DispatchMode</span></a></p></td> <td><p><a href="#class-proximitygroup-property-dispatch-mode"><span class="std std-ref">dispatch_mode</span></a></p></td> <td><p><code>0</code></p></td> </tr> <tr>
<td><p><a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a></p></td> <td><p><a href="#class-proximitygroup-property-grid-radius"><span class="std std-ref">grid_radius</span></a></p></td> <td><p><code>Vector3( 1, 1, 1 )</code></p></td> </tr> <tr>
<td><p><a href="class_string.html#class-string"><span class="std std-ref">String</span></a></p></td> <td><p><a href="#class-proximitygroup-property-group-name"><span class="std std-ref">group_name</span></a></p></td> <td><p><code>""</code></p></td> </tr>  </table> </section> <section id="methods"> <h2>Methods</h2> <table class="docutils align-default">   <tr>
<td><p>void</p></td> <td><p><a href="#class-proximitygroup-method-broadcast"><span class="std std-ref">broadcast</span></a> <strong>(</strong> <a href="class_string.html#class-string"><span class="std std-ref">String</span></a> method, <a href="class_variant.html#class-variant"><span class="std std-ref">Variant</span></a> parameters <strong>)</strong></p></td> </tr>  </table> </section> <section id="signals"> <h2>Signals</h2> <h3 id="class-proximitygroup-signal-broadcast"><p>broadcast ( <a href="class_string.html#class-string"><span class="std std-ref">String</span></a> method, <a href="class_array.html#class-array"><span class="std std-ref">Array</span></a> parameters )</p></h3> <p>Emitted when the user calls the <a href="#class-proximitygroup-method-broadcast"><span class="std std-ref">broadcast</span></a> method and has set <a href="#class-proximitygroup-property-dispatch-mode"><span class="std std-ref">dispatch_mode</span></a> to <a href="#class-proximitygroup-constant-mode-signal"><span class="std std-ref">MODE_SIGNAL</span></a>.</p> <p>The given method and its parameters are passed on to the listeners who connected to this signal of this object, as well as any <code>ProximityGroup</code> node this node is grouped together with.</p> <p><strong>Note:</strong> This signal is <em>not</em> emitted by default, as the default <a href="#class-proximitygroup-property-dispatch-mode"><span class="std std-ref">dispatch_mode</span></a> is <a href="#class-proximitygroup-constant-mode-proxy"><span class="std std-ref">MODE_PROXY</span></a>.</p> </section> <section id="enumerations"> <h2>Enumerations</h2> <p id="class-proximitygroup-constant-mode-signal">enum <strong id="enum-proximitygroup-dispatchmode">DispatchMode</strong>:</p> <ul class="simple"> <li>
<strong>MODE_PROXY</strong> = <strong>0</strong> --- This <code>ProximityGroup</code>'s parent will be target of <a href="#class-proximitygroup-method-broadcast"><span class="std std-ref">broadcast</span></a>.</li> <li>
<strong>MODE_SIGNAL</strong> = <strong>1</strong> --- This <code>ProximityGroup</code> will emit the <a href="#class-proximitygroup-signal-broadcast"><span class="std std-ref">broadcast</span></a> <em>signal</em> when calling the <a href="#class-proximitygroup-method-broadcast"><span class="std std-ref">broadcast</span></a> <em>method</em>.</li> </ul> </section> <section id="property-descriptions"> <h2>Property Descriptions</h2> <h3 id="class-proximitygroup-property-dispatch-mode"><p><a href="#enum-proximitygroup-dispatchmode"><span class="std std-ref">DispatchMode</span></a> dispatch_mode</p></h3> <table class="docutils align-default">   <tr>
<td><p><em>Default</em></p></td> <td><p><code>0</code></p></td> </tr> <tr>
<td><p><em>Setter</em></p></td> <td><p>set_dispatch_mode(value)</p></td> </tr> <tr>
<td><p><em>Getter</em></p></td> <td><p>get_dispatch_mode()</p></td> </tr>  </table> <p>Specifies which node gets contacted on a call of method <a href="#class-proximitygroup-method-broadcast"><span class="std std-ref">broadcast</span></a>.</p>  <h3 id="class-proximitygroup-property-grid-radius"><p><a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> grid_radius</p></h3> <table class="docutils align-default">   <tr>
<td><p><em>Default</em></p></td> <td><p><code>Vector3( 1, 1, 1 )</code></p></td> </tr> <tr>
<td><p><em>Setter</em></p></td> <td><p>set_grid_radius(value)</p></td> </tr> <tr>
<td><p><em>Getter</em></p></td> <td><p>get_grid_radius()</p></td> </tr>  </table> <p>The size of the space in 3D units. This also sets the amount of coordinates required to calculate whether two <code>ProximityGroup</code> nodes are intersecting or not. Smaller <a href="#class-proximitygroup-property-grid-radius"><span class="std std-ref">grid_radius</span></a> values can be used for more precise proximity checks at the cost of performance, since more groups will be created.</p>  <h3 id="class-proximitygroup-property-group-name"><p><a href="class_string.html#class-string"><span class="std std-ref">String</span></a> group_name</p></h3> <table class="docutils align-default">   <tr>
<td><p><em>Default</em></p></td> <td><p><code>""</code></p></td> </tr> <tr>
<td><p><em>Setter</em></p></td> <td><p>set_group_name(value)</p></td> </tr> <tr>
<td><p><em>Getter</em></p></td> <td><p>get_group_name()</p></td> </tr>  </table> <p>Specify the common group name, to let other <code>ProximityGroup</code> nodes know, if they should be auto-grouped with this node in case they intersect with each other.</p> <p>For example, if you have a <code>ProximityGroup</code> node named <code>"Earth"</code> and another called <code>"Mars"</code>, with both nodes having <code>"planet"</code> as their <a href="#class-proximitygroup-property-group-name"><span class="std std-ref">group_name</span></a>. Give both planets a significantly larger <a href="#class-proximitygroup-property-grid-radius"><span class="std std-ref">grid_radius</span></a> than their actual radius, position them close enough and they'll be automatically grouped.</p> </section> <section id="method-descriptions"> <h2>Method Descriptions</h2> <h3 id="class-proximitygroup-method-broadcast"><p>void broadcast ( <a href="class_string.html#class-string"><span class="std std-ref">String</span></a> method, <a href="class_variant.html#class-variant"><span class="std std-ref">Variant</span></a> parameters )</p></h3> <p>Calls on all intersecting <code>ProximityGroup</code> the given method and parameters.</p> <p>If the <a href="#class-proximitygroup-property-dispatch-mode"><span class="std std-ref">dispatch_mode</span></a> is set to <a href="#class-proximitygroup-constant-mode-proxy"><span class="std std-ref">MODE_PROXY</span></a> (the default), all calls are delegated to their respective parent <a href="class_node.html#class-node"><span class="std std-ref">Node</span></a>.</p> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2014&ndash;2022 Juan Linietsky, Ariel Manzur, Godot Engine contributors<br>Licensed under the MIT License.<br>
    <a href="https://docs.godotengine.org/en/3.5/classes/class_proximitygroup.html" class="_attribution-link">https://docs.godotengine.org/en/3.5/classes/class_proximitygroup.html</a>
  </p>
</div>
