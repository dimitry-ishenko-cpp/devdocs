<section id="fastnoiselite"> <h1 id="class-fastnoiselite">FastNoiseLite</h1> <p><strong>Inherits:</strong> <a href="class_noise.html#class-noise"><span class="std std-ref">Noise</span></a> <strong>&lt;</strong> <a href="class_resource.html#class-resource"><span class="std std-ref">Resource</span></a> <strong>&lt;</strong> <a href="class_refcounted.html#class-refcounted"><span class="std std-ref">RefCounted</span></a> <strong>&lt;</strong> <a href="class_object.html#class-object"><span class="std std-ref">Object</span></a></p> <p>Generates noise using the FastNoiseLite library.</p> <section class="classref-introduction-group" id="description"> <h2>Description</h2> <p>This class generates noise using the FastNoiseLite library, which is a collection of several noise algorithms including Cellular, Perlin, Value, and more.</p> <p>Most generated noise values are in the range of <code>[-1, 1]</code>, but not always. Some of the cellular noise algorithms return results above <code>1</code>.</p> </section> <section class="classref-reftable-group" id="properties"> <h2>Properties</h2> <table class="colwidths-auto docutils align-default">  <tr>
<td><p><a href="#enum-fastnoiselite-cellulardistancefunction"><span class="std std-ref">CellularDistanceFunction</span></a></p></td> <td><p><a href="#class-fastnoiselite-property-cellular-distance-function"><span class="std std-ref">cellular_distance_function</span></a></p></td> <td><p><code>0</code></p></td> </tr> <tr>
<td><p><a href="class_float.html#class-float"><span class="std std-ref">float</span></a></p></td> <td><p><a href="#class-fastnoiselite-property-cellular-jitter"><span class="std std-ref">cellular_jitter</span></a></p></td> <td><p><code>1.0</code></p></td> </tr> <tr>
<td><p><a href="#enum-fastnoiselite-cellularreturntype"><span class="std std-ref">CellularReturnType</span></a></p></td> <td><p><a href="#class-fastnoiselite-property-cellular-return-type"><span class="std std-ref">cellular_return_type</span></a></p></td> <td><p><code>1</code></p></td> </tr> <tr>
<td><p><a href="class_float.html#class-float"><span class="std std-ref">float</span></a></p></td> <td><p><a href="#class-fastnoiselite-property-domain-warp-amplitude"><span class="std std-ref">domain_warp_amplitude</span></a></p></td> <td><p><code>30.0</code></p></td> </tr> <tr>
<td><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a></p></td> <td><p><a href="#class-fastnoiselite-property-domain-warp-enabled"><span class="std std-ref">domain_warp_enabled</span></a></p></td> <td><p><code>false</code></p></td> </tr> <tr>
<td><p><a href="class_float.html#class-float"><span class="std std-ref">float</span></a></p></td> <td><p><a href="#class-fastnoiselite-property-domain-warp-fractal-gain"><span class="std std-ref">domain_warp_fractal_gain</span></a></p></td> <td><p><code>0.5</code></p></td> </tr> <tr>
<td><p><a href="class_float.html#class-float"><span class="std std-ref">float</span></a></p></td> <td><p><a href="#class-fastnoiselite-property-domain-warp-fractal-lacunarity"><span class="std std-ref">domain_warp_fractal_lacunarity</span></a></p></td> <td><p><code>6.0</code></p></td> </tr> <tr>
<td><p><a href="class_int.html#class-int"><span class="std std-ref">int</span></a></p></td> <td><p><a href="#class-fastnoiselite-property-domain-warp-fractal-octaves"><span class="std std-ref">domain_warp_fractal_octaves</span></a></p></td> <td><p><code>5</code></p></td> </tr> <tr>
<td><p><a href="#enum-fastnoiselite-domainwarpfractaltype"><span class="std std-ref">DomainWarpFractalType</span></a></p></td> <td><p><a href="#class-fastnoiselite-property-domain-warp-fractal-type"><span class="std std-ref">domain_warp_fractal_type</span></a></p></td> <td><p><code>1</code></p></td> </tr> <tr>
<td><p><a href="class_float.html#class-float"><span class="std std-ref">float</span></a></p></td> <td><p><a href="#class-fastnoiselite-property-domain-warp-frequency"><span class="std std-ref">domain_warp_frequency</span></a></p></td> <td><p><code>0.05</code></p></td> </tr> <tr>
<td><p><a href="#enum-fastnoiselite-domainwarptype"><span class="std std-ref">DomainWarpType</span></a></p></td> <td><p><a href="#class-fastnoiselite-property-domain-warp-type"><span class="std std-ref">domain_warp_type</span></a></p></td> <td><p><code>0</code></p></td> </tr> <tr>
<td><p><a href="class_float.html#class-float"><span class="std std-ref">float</span></a></p></td> <td><p><a href="#class-fastnoiselite-property-fractal-gain"><span class="std std-ref">fractal_gain</span></a></p></td> <td><p><code>0.5</code></p></td> </tr> <tr>
<td><p><a href="class_float.html#class-float"><span class="std std-ref">float</span></a></p></td> <td><p><a href="#class-fastnoiselite-property-fractal-lacunarity"><span class="std std-ref">fractal_lacunarity</span></a></p></td> <td><p><code>2.0</code></p></td> </tr> <tr>
<td><p><a href="class_int.html#class-int"><span class="std std-ref">int</span></a></p></td> <td><p><a href="#class-fastnoiselite-property-fractal-octaves"><span class="std std-ref">fractal_octaves</span></a></p></td> <td><p><code>5</code></p></td> </tr> <tr>
<td><p><a href="class_float.html#class-float"><span class="std std-ref">float</span></a></p></td> <td><p><a href="#class-fastnoiselite-property-fractal-ping-pong-strength"><span class="std std-ref">fractal_ping_pong_strength</span></a></p></td> <td><p><code>2.0</code></p></td> </tr> <tr>
<td><p><a href="#enum-fastnoiselite-fractaltype"><span class="std std-ref">FractalType</span></a></p></td> <td><p><a href="#class-fastnoiselite-property-fractal-type"><span class="std std-ref">fractal_type</span></a></p></td> <td><p><code>1</code></p></td> </tr> <tr>
<td><p><a href="class_float.html#class-float"><span class="std std-ref">float</span></a></p></td> <td><p><a href="#class-fastnoiselite-property-fractal-weighted-strength"><span class="std std-ref">fractal_weighted_strength</span></a></p></td> <td><p><code>0.0</code></p></td> </tr> <tr>
<td><p><a href="class_float.html#class-float"><span class="std std-ref">float</span></a></p></td> <td><p><a href="#class-fastnoiselite-property-frequency"><span class="std std-ref">frequency</span></a></p></td> <td><p><code>0.01</code></p></td> </tr> <tr>
<td><p><a href="#enum-fastnoiselite-noisetype"><span class="std std-ref">NoiseType</span></a></p></td> <td><p><a href="#class-fastnoiselite-property-noise-type"><span class="std std-ref">noise_type</span></a></p></td> <td><p><code>1</code></p></td> </tr> <tr>
<td><p><a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a></p></td> <td><p><a href="#class-fastnoiselite-property-offset"><span class="std std-ref">offset</span></a></p></td> <td><p><code>Vector3(0, 0, 0)</code></p></td> </tr> <tr>
<td><p><a href="class_int.html#class-int"><span class="std std-ref">int</span></a></p></td> <td><p><a href="#class-fastnoiselite-property-seed"><span class="std std-ref">seed</span></a></p></td> <td><p><code>0</code></p></td> </tr>  </table> </section>  <section class="classref-descriptions-group" id="enumerations"> <h2>Enumerations</h2> <h3 id="enum-fastnoiselite-noisetype">enum NoiseType:</h3> <h3 id="class-fastnoiselite-constant-type-value">
<a href="#enum-fastnoiselite-noisetype"><span class="std std-ref">NoiseType</span></a> TYPE_VALUE = <code>5</code>
</h3> <p>A lattice of points are assigned random values then interpolated based on neighboring values.</p> <h3 id="class-fastnoiselite-constant-type-value-cubic">
<a href="#enum-fastnoiselite-noisetype"><span class="std std-ref">NoiseType</span></a> TYPE_VALUE_CUBIC = <code>4</code>
</h3> <p>Similar to Value noise, but slower. Has more variance in peaks and valleys.</p> <p>Cubic noise can be used to avoid certain artifacts when using value noise to create a bumpmap. In general, you should always use this mode if the value noise is being used for a heightmap or bumpmap.</p> <h3 id="class-fastnoiselite-constant-type-perlin">
<a href="#enum-fastnoiselite-noisetype"><span class="std std-ref">NoiseType</span></a> TYPE_PERLIN = <code>3</code>
</h3> <p>A lattice of random gradients. Their dot products are interpolated to obtain values in between the lattices.</p> <h3 id="class-fastnoiselite-constant-type-cellular">
<a href="#enum-fastnoiselite-noisetype"><span class="std std-ref">NoiseType</span></a> TYPE_CELLULAR = <code>2</code>
</h3> <p>Cellular includes both Worley noise and Voronoi diagrams which creates various regions of the same value.</p> <h3 id="class-fastnoiselite-constant-type-simplex">
<a href="#enum-fastnoiselite-noisetype"><span class="std std-ref">NoiseType</span></a> TYPE_SIMPLEX = <code>0</code>
</h3> <p>As opposed to <a href="#class-fastnoiselite-constant-type-perlin"><span class="std std-ref">TYPE_PERLIN</span></a>, gradients exist in a simplex lattice rather than a grid lattice, avoiding directional artifacts.</p> <h3 id="class-fastnoiselite-constant-type-simplex-smooth">
<a href="#enum-fastnoiselite-noisetype"><span class="std std-ref">NoiseType</span></a> TYPE_SIMPLEX_SMOOTH = <code>1</code>
</h3> <p>Modified, higher quality version of <a href="#class-fastnoiselite-constant-type-simplex"><span class="std std-ref">TYPE_SIMPLEX</span></a>, but slower.</p>  <h3 id="enum-fastnoiselite-fractaltype">enum FractalType:</h3> <h3 id="class-fastnoiselite-constant-fractal-none">
<a href="#enum-fastnoiselite-fractaltype"><span class="std std-ref">FractalType</span></a> FRACTAL_NONE = <code>0</code>
</h3> <p>No fractal noise.</p> <h3 id="class-fastnoiselite-constant-fractal-fbm">
<a href="#enum-fastnoiselite-fractaltype"><span class="std std-ref">FractalType</span></a> FRACTAL_FBM = <code>1</code>
</h3> <p>Method using Fractional Brownian Motion to combine octaves into a fractal.</p> <h3 id="class-fastnoiselite-constant-fractal-ridged">
<a href="#enum-fastnoiselite-fractaltype"><span class="std std-ref">FractalType</span></a> FRACTAL_RIDGED = <code>2</code>
</h3> <p>Method of combining octaves into a fractal resulting in a "ridged" look.</p> <h3 id="class-fastnoiselite-constant-fractal-ping-pong">
<a href="#enum-fastnoiselite-fractaltype"><span class="std std-ref">FractalType</span></a> FRACTAL_PING_PONG = <code>3</code>
</h3> <p>Method of combining octaves into a fractal with a ping pong effect.</p>  <h3 id="enum-fastnoiselite-cellulardistancefunction">enum CellularDistanceFunction:</h3> <h3 id="class-fastnoiselite-constant-distance-euclidean">
<a href="#enum-fastnoiselite-cellulardistancefunction"><span class="std std-ref">CellularDistanceFunction</span></a> DISTANCE_EUCLIDEAN = <code>0</code>
</h3> <p>Euclidean distance to the nearest point.</p> <h3 id="class-fastnoiselite-constant-distance-euclidean-squared">
<a href="#enum-fastnoiselite-cellulardistancefunction"><span class="std std-ref">CellularDistanceFunction</span></a> DISTANCE_EUCLIDEAN_SQUARED = <code>1</code>
</h3> <p>Squared Euclidean distance to the nearest point.</p> <h3 id="class-fastnoiselite-constant-distance-manhattan">
<a href="#enum-fastnoiselite-cellulardistancefunction"><span class="std std-ref">CellularDistanceFunction</span></a> DISTANCE_MANHATTAN = <code>2</code>
</h3> <p>Manhattan distance (taxicab metric) to the nearest point.</p> <h3 id="class-fastnoiselite-constant-distance-hybrid">
<a href="#enum-fastnoiselite-cellulardistancefunction"><span class="std std-ref">CellularDistanceFunction</span></a> DISTANCE_HYBRID = <code>3</code>
</h3> <p>Blend of <a href="#class-fastnoiselite-constant-distance-euclidean"><span class="std std-ref">DISTANCE_EUCLIDEAN</span></a> and <a href="#class-fastnoiselite-constant-distance-manhattan"><span class="std std-ref">DISTANCE_MANHATTAN</span></a> to give curved cell boundaries</p>  <h3 id="enum-fastnoiselite-cellularreturntype">enum CellularReturnType:</h3> <h3 id="class-fastnoiselite-constant-return-cell-value">
<a href="#enum-fastnoiselite-cellularreturntype"><span class="std std-ref">CellularReturnType</span></a> RETURN_CELL_VALUE = <code>0</code>
</h3> <p>The cellular distance function will return the same value for all points within a cell.</p> <h3 id="class-fastnoiselite-constant-return-distance">
<a href="#enum-fastnoiselite-cellularreturntype"><span class="std std-ref">CellularReturnType</span></a> RETURN_DISTANCE = <code>1</code>
</h3> <p>The cellular distance function will return a value determined by the distance to the nearest point.</p> <h3 id="class-fastnoiselite-constant-return-distance2">
<a href="#enum-fastnoiselite-cellularreturntype"><span class="std std-ref">CellularReturnType</span></a> RETURN_DISTANCE2 = <code>2</code>
</h3> <p>The cellular distance function returns the distance to the second-nearest point.</p> <h3 id="class-fastnoiselite-constant-return-distance2-add">
<a href="#enum-fastnoiselite-cellularreturntype"><span class="std std-ref">CellularReturnType</span></a> RETURN_DISTANCE2_ADD = <code>3</code>
</h3> <p>The distance to the nearest point is added to the distance to the second-nearest point.</p> <h3 id="class-fastnoiselite-constant-return-distance2-sub">
<a href="#enum-fastnoiselite-cellularreturntype"><span class="std std-ref">CellularReturnType</span></a> RETURN_DISTANCE2_SUB = <code>4</code>
</h3> <p>The distance to the nearest point is subtracted from the distance to the second-nearest point.</p> <h3 id="class-fastnoiselite-constant-return-distance2-mul">
<a href="#enum-fastnoiselite-cellularreturntype"><span class="std std-ref">CellularReturnType</span></a> RETURN_DISTANCE2_MUL = <code>5</code>
</h3> <p>The distance to the nearest point is multiplied with the distance to the second-nearest point.</p> <h3 id="class-fastnoiselite-constant-return-distance2-div">
<a href="#enum-fastnoiselite-cellularreturntype"><span class="std std-ref">CellularReturnType</span></a> RETURN_DISTANCE2_DIV = <code>6</code>
</h3> <p>The distance to the nearest point is divided by the distance to the second-nearest point.</p>  <h3 id="enum-fastnoiselite-domainwarptype">enum DomainWarpType:</h3> <h3 id="class-fastnoiselite-constant-domain-warp-simplex">
<a href="#enum-fastnoiselite-domainwarptype"><span class="std std-ref">DomainWarpType</span></a> DOMAIN_WARP_SIMPLEX = <code>0</code>
</h3> <p>The domain is warped using the simplex noise algorithm.</p> <h3 id="class-fastnoiselite-constant-domain-warp-simplex-reduced">
<a href="#enum-fastnoiselite-domainwarptype"><span class="std std-ref">DomainWarpType</span></a> DOMAIN_WARP_SIMPLEX_REDUCED = <code>1</code>
</h3> <p>The domain is warped using a simplified version of the simplex noise algorithm.</p> <h3 id="class-fastnoiselite-constant-domain-warp-basic-grid">
<a href="#enum-fastnoiselite-domainwarptype"><span class="std std-ref">DomainWarpType</span></a> DOMAIN_WARP_BASIC_GRID = <code>2</code>
</h3> <p>The domain is warped using a simple noise grid (not as smooth as the other methods, but more performant).</p>  <h3 id="enum-fastnoiselite-domainwarpfractaltype">enum DomainWarpFractalType:</h3> <h3 id="class-fastnoiselite-constant-domain-warp-fractal-none">
<a href="#enum-fastnoiselite-domainwarpfractaltype"><span class="std std-ref">DomainWarpFractalType</span></a> DOMAIN_WARP_FRACTAL_NONE = <code>0</code>
</h3> <p>No fractal noise for warping the space.</p> <h3 id="class-fastnoiselite-constant-domain-warp-fractal-progressive">
<a href="#enum-fastnoiselite-domainwarpfractaltype"><span class="std std-ref">DomainWarpFractalType</span></a> DOMAIN_WARP_FRACTAL_PROGRESSIVE = <code>1</code>
</h3> <p>Warping the space progressively, octave for octave, resulting in a more "liquified" distortion.</p> <h3 id="class-fastnoiselite-constant-domain-warp-fractal-independent">
<a href="#enum-fastnoiselite-domainwarpfractaltype"><span class="std std-ref">DomainWarpFractalType</span></a> DOMAIN_WARP_FRACTAL_INDEPENDENT = <code>2</code>
</h3> <p>Warping the space independently for each octave, resulting in a more chaotic distortion.</p> </section>  <section class="classref-descriptions-group" id="property-descriptions"> <h2>Property Descriptions</h2> <h3 id="class-fastnoiselite-property-cellular-distance-function">
<a href="#enum-fastnoiselite-cellulardistancefunction"><span class="std std-ref">CellularDistanceFunction</span></a> cellular_distance_function = <code>0</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_cellular_distance_function</strong> <strong>(</strong> <a href="#enum-fastnoiselite-cellulardistancefunction"><span class="std std-ref">CellularDistanceFunction</span></a> value <strong>)</strong>
</li> <li>
<a href="#enum-fastnoiselite-cellulardistancefunction"><span class="std std-ref">CellularDistanceFunction</span></a> <strong>get_cellular_distance_function</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>Determines how the distance to the nearest/second-nearest point is computed. See <a href="#enum-fastnoiselite-cellulardistancefunction"><span class="std std-ref">CellularDistanceFunction</span></a> for options.</p>  <h3 id="class-fastnoiselite-property-cellular-jitter">
<a href="class_float.html#class-float"><span class="std std-ref">float</span></a> cellular_jitter = <code>1.0</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_cellular_jitter</strong> <strong>(</strong> <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> value <strong>)</strong>
</li> <li>
<a href="class_float.html#class-float"><span class="std std-ref">float</span></a> <strong>get_cellular_jitter</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>Maximum distance a point can move off of its grid position. Set to <code>0</code> for an even grid.</p>  <h3 id="class-fastnoiselite-property-cellular-return-type">
<a href="#enum-fastnoiselite-cellularreturntype"><span class="std std-ref">CellularReturnType</span></a> cellular_return_type = <code>1</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_cellular_return_type</strong> <strong>(</strong> <a href="#enum-fastnoiselite-cellularreturntype"><span class="std std-ref">CellularReturnType</span></a> value <strong>)</strong>
</li> <li>
<a href="#enum-fastnoiselite-cellularreturntype"><span class="std std-ref">CellularReturnType</span></a> <strong>get_cellular_return_type</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>Return type from cellular noise calculations. See <a href="#enum-fastnoiselite-cellularreturntype"><span class="std std-ref">CellularReturnType</span></a>.</p>  <h3 id="class-fastnoiselite-property-domain-warp-amplitude">
<a href="class_float.html#class-float"><span class="std std-ref">float</span></a> domain_warp_amplitude = <code>30.0</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_domain_warp_amplitude</strong> <strong>(</strong> <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> value <strong>)</strong>
</li> <li>
<a href="class_float.html#class-float"><span class="std std-ref">float</span></a> <strong>get_domain_warp_amplitude</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>Sets the maximum warp distance from the origin.</p>  <h3 id="class-fastnoiselite-property-domain-warp-enabled">
<a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> domain_warp_enabled = <code>false</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_domain_warp_enabled</strong> <strong>(</strong> <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> value <strong>)</strong>
</li> <li>
<a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> <strong>is_domain_warp_enabled</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>If enabled, another FastNoiseLite instance is used to warp the space, resulting in a distortion of the noise.</p>  <h3 id="class-fastnoiselite-property-domain-warp-fractal-gain">
<a href="class_float.html#class-float"><span class="std std-ref">float</span></a> domain_warp_fractal_gain = <code>0.5</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_domain_warp_fractal_gain</strong> <strong>(</strong> <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> value <strong>)</strong>
</li> <li>
<a href="class_float.html#class-float"><span class="std std-ref">float</span></a> <strong>get_domain_warp_fractal_gain</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>Determines the strength of each subsequent layer of the noise which is used to warp the space.</p> <p>A low value places more emphasis on the lower frequency base layers, while a high value puts more emphasis on the higher frequency layers.</p>  <h3 id="class-fastnoiselite-property-domain-warp-fractal-lacunarity">
<a href="class_float.html#class-float"><span class="std std-ref">float</span></a> domain_warp_fractal_lacunarity = <code>6.0</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_domain_warp_fractal_lacunarity</strong> <strong>(</strong> <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> value <strong>)</strong>
</li> <li>
<a href="class_float.html#class-float"><span class="std std-ref">float</span></a> <strong>get_domain_warp_fractal_lacunarity</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>Octave lacunarity of the fractal noise which warps the space. Increasing this value results in higher octaves producing noise with finer details and a rougher appearance.</p>  <h3 id="class-fastnoiselite-property-domain-warp-fractal-octaves">
<a href="class_int.html#class-int"><span class="std std-ref">int</span></a> domain_warp_fractal_octaves = <code>5</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_domain_warp_fractal_octaves</strong> <strong>(</strong> <a href="class_int.html#class-int"><span class="std std-ref">int</span></a> value <strong>)</strong>
</li> <li>
<a href="class_int.html#class-int"><span class="std std-ref">int</span></a> <strong>get_domain_warp_fractal_octaves</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>The number of noise layers that are sampled to get the final value for the fractal noise which warps the space.</p>  <h3 id="class-fastnoiselite-property-domain-warp-fractal-type">
<a href="#enum-fastnoiselite-domainwarpfractaltype"><span class="std std-ref">DomainWarpFractalType</span></a> domain_warp_fractal_type = <code>1</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_domain_warp_fractal_type</strong> <strong>(</strong> <a href="#enum-fastnoiselite-domainwarpfractaltype"><span class="std std-ref">DomainWarpFractalType</span></a> value <strong>)</strong>
</li> <li>
<a href="#enum-fastnoiselite-domainwarpfractaltype"><span class="std std-ref">DomainWarpFractalType</span></a> <strong>get_domain_warp_fractal_type</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>The method for combining octaves into a fractal which is used to warp the space. See <a href="#enum-fastnoiselite-domainwarpfractaltype"><span class="std std-ref">DomainWarpFractalType</span></a>.</p>  <h3 id="class-fastnoiselite-property-domain-warp-frequency">
<a href="class_float.html#class-float"><span class="std std-ref">float</span></a> domain_warp_frequency = <code>0.05</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_domain_warp_frequency</strong> <strong>(</strong> <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> value <strong>)</strong>
</li> <li>
<a href="class_float.html#class-float"><span class="std std-ref">float</span></a> <strong>get_domain_warp_frequency</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>Frequency of the noise which warps the space. Low frequency results in smooth noise while high frequency results in rougher, more granular noise.</p>  <h3 id="class-fastnoiselite-property-domain-warp-type">
<a href="#enum-fastnoiselite-domainwarptype"><span class="std std-ref">DomainWarpType</span></a> domain_warp_type = <code>0</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_domain_warp_type</strong> <strong>(</strong> <a href="#enum-fastnoiselite-domainwarptype"><span class="std std-ref">DomainWarpType</span></a> value <strong>)</strong>
</li> <li>
<a href="#enum-fastnoiselite-domainwarptype"><span class="std std-ref">DomainWarpType</span></a> <strong>get_domain_warp_type</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>Sets the warp algorithm. See <a href="#enum-fastnoiselite-domainwarptype"><span class="std std-ref">DomainWarpType</span></a>.</p>  <h3 id="class-fastnoiselite-property-fractal-gain">
<a href="class_float.html#class-float"><span class="std std-ref">float</span></a> fractal_gain = <code>0.5</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_fractal_gain</strong> <strong>(</strong> <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> value <strong>)</strong>
</li> <li>
<a href="class_float.html#class-float"><span class="std std-ref">float</span></a> <strong>get_fractal_gain</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>Determines the strength of each subsequent layer of noise in fractal noise.</p> <p>A low value places more emphasis on the lower frequency base layers, while a high value puts more emphasis on the higher frequency layers.</p>  <h3 id="class-fastnoiselite-property-fractal-lacunarity">
<a href="class_float.html#class-float"><span class="std std-ref">float</span></a> fractal_lacunarity = <code>2.0</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_fractal_lacunarity</strong> <strong>(</strong> <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> value <strong>)</strong>
</li> <li>
<a href="class_float.html#class-float"><span class="std std-ref">float</span></a> <strong>get_fractal_lacunarity</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>Frequency multiplier between subsequent octaves. Increasing this value results in higher octaves producing noise with finer details and a rougher appearance.</p>  <h3 id="class-fastnoiselite-property-fractal-octaves">
<a href="class_int.html#class-int"><span class="std std-ref">int</span></a> fractal_octaves = <code>5</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_fractal_octaves</strong> <strong>(</strong> <a href="class_int.html#class-int"><span class="std std-ref">int</span></a> value <strong>)</strong>
</li> <li>
<a href="class_int.html#class-int"><span class="std std-ref">int</span></a> <strong>get_fractal_octaves</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>The number of noise layers that are sampled to get the final value for fractal noise types.</p>  <h3 id="class-fastnoiselite-property-fractal-ping-pong-strength">
<a href="class_float.html#class-float"><span class="std std-ref">float</span></a> fractal_ping_pong_strength = <code>2.0</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_fractal_ping_pong_strength</strong> <strong>(</strong> <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> value <strong>)</strong>
</li> <li>
<a href="class_float.html#class-float"><span class="std std-ref">float</span></a> <strong>get_fractal_ping_pong_strength</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>Sets the strength of the fractal ping pong type.</p>  <h3 id="class-fastnoiselite-property-fractal-type">
<a href="#enum-fastnoiselite-fractaltype"><span class="std std-ref">FractalType</span></a> fractal_type = <code>1</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_fractal_type</strong> <strong>(</strong> <a href="#enum-fastnoiselite-fractaltype"><span class="std std-ref">FractalType</span></a> value <strong>)</strong>
</li> <li>
<a href="#enum-fastnoiselite-fractaltype"><span class="std std-ref">FractalType</span></a> <strong>get_fractal_type</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>The method for combining octaves into a fractal. See <a href="#enum-fastnoiselite-fractaltype"><span class="std std-ref">FractalType</span></a>.</p>  <h3 id="class-fastnoiselite-property-fractal-weighted-strength">
<a href="class_float.html#class-float"><span class="std std-ref">float</span></a> fractal_weighted_strength = <code>0.0</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_fractal_weighted_strength</strong> <strong>(</strong> <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> value <strong>)</strong>
</li> <li>
<a href="class_float.html#class-float"><span class="std std-ref">float</span></a> <strong>get_fractal_weighted_strength</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>Higher weighting means higher octaves have less impact if lower octaves have a large impact.</p>  <h3 id="class-fastnoiselite-property-frequency">
<a href="class_float.html#class-float"><span class="std std-ref">float</span></a> frequency = <code>0.01</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_frequency</strong> <strong>(</strong> <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> value <strong>)</strong>
</li> <li>
<a href="class_float.html#class-float"><span class="std std-ref">float</span></a> <strong>get_frequency</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>The frequency for all noise types. Low frequency results in smooth noise while high frequency results in rougher, more granular noise.</p>  <h3 id="class-fastnoiselite-property-noise-type">
<a href="#enum-fastnoiselite-noisetype"><span class="std std-ref">NoiseType</span></a> noise_type = <code>1</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_noise_type</strong> <strong>(</strong> <a href="#enum-fastnoiselite-noisetype"><span class="std std-ref">NoiseType</span></a> value <strong>)</strong>
</li> <li>
<a href="#enum-fastnoiselite-noisetype"><span class="std std-ref">NoiseType</span></a> <strong>get_noise_type</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>The noise algorithm used. See <a href="#enum-fastnoiselite-noisetype"><span class="std std-ref">NoiseType</span></a>.</p>  <h3 id="class-fastnoiselite-property-offset">
<a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> offset = <code>Vector3(0, 0, 0)</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_offset</strong> <strong>(</strong> <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> value <strong>)</strong>
</li> <li>
<a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> <strong>get_offset</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>Translate the noise input coordinates by the given <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a>.</p>  <h3 id="class-fastnoiselite-property-seed">
<a href="class_int.html#class-int"><span class="std std-ref">int</span></a> seed = <code>0</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_seed</strong> <strong>(</strong> <a href="class_int.html#class-int"><span class="std std-ref">int</span></a> value <strong>)</strong>
</li> <li>
<a href="class_int.html#class-int"><span class="std std-ref">int</span></a> <strong>get_seed</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>The random number seed for all noise types.</p> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2014&ndash;present Juan Linietsky, Ariel Manzur and the Godot community<br>Licensed under the Creative Commons Attribution Unported License v3.0.<br>
    <a href="https://docs.godotengine.org/en/4.2/classes/class_fastnoiselite.html" class="_attribution-link">https://docs.godotengine.org/en/4.2/classes/class_fastnoiselite.html</a>
  </p>
</div>
