<h1 id="class-geometry">Geometry</h1> <p><strong>Inherits:</strong> <a href="class_object.html#class-object"><span class="std std-ref">Object</span></a></p> <p>Helper node to calculate generic geometry operations.</p> <section id="description"> <h2>Description</h2> <p>Geometry provides users with a set of helper functions to create geometric shapes, compute intersections between shapes, and process various other geometric operations.</p> </section> <section id="methods"> <h2>Methods</h2> <table class="docutils align-default">   <tr>
<td><p><a href="class_array.html#class-array"><span class="std std-ref">Array</span></a></p></td> <td><p><a href="#class-geometry-method-build-box-planes"><span class="std std-ref">build_box_planes</span></a> <strong>(</strong> <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> extents <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_array.html#class-array"><span class="std std-ref">Array</span></a></p></td> <td><p><a href="#class-geometry-method-build-capsule-planes"><span class="std std-ref">build_capsule_planes</span></a> <strong>(</strong> <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> radius, <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> height, <a href="class_int.html#class-int"><span class="std std-ref">int</span></a> sides, <a href="class_int.html#class-int"><span class="std std-ref">int</span></a> lats, Vector3.Axis axis=2 <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_array.html#class-array"><span class="std std-ref">Array</span></a></p></td> <td><p><a href="#class-geometry-method-build-cylinder-planes"><span class="std std-ref">build_cylinder_planes</span></a> <strong>(</strong> <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> radius, <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> height, <a href="class_int.html#class-int"><span class="std std-ref">int</span></a> sides, Vector3.Axis axis=2 <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_poolvector3array.html#class-poolvector3array"><span class="std std-ref">PoolVector3Array</span></a></p></td> <td><p><a href="#class-geometry-method-clip-polygon"><span class="std std-ref">clip_polygon</span></a> <strong>(</strong> <a href="class_poolvector3array.html#class-poolvector3array"><span class="std std-ref">PoolVector3Array</span></a> points, <a href="class_plane.html#class-plane"><span class="std std-ref">Plane</span></a> plane <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_array.html#class-array"><span class="std std-ref">Array</span></a></p></td> <td><p><a href="#class-geometry-method-clip-polygons-2d"><span class="std std-ref">clip_polygons_2d</span></a> <strong>(</strong> <a href="class_poolvector2array.html#class-poolvector2array"><span class="std std-ref">PoolVector2Array</span></a> polygon_a, <a href="class_poolvector2array.html#class-poolvector2array"><span class="std std-ref">PoolVector2Array</span></a> polygon_b <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_array.html#class-array"><span class="std std-ref">Array</span></a></p></td> <td><p><a href="#class-geometry-method-clip-polyline-with-polygon-2d"><span class="std std-ref">clip_polyline_with_polygon_2d</span></a> <strong>(</strong> <a href="class_poolvector2array.html#class-poolvector2array"><span class="std std-ref">PoolVector2Array</span></a> polyline, <a href="class_poolvector2array.html#class-poolvector2array"><span class="std std-ref">PoolVector2Array</span></a> polygon <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_poolvector2array.html#class-poolvector2array"><span class="std std-ref">PoolVector2Array</span></a></p></td> <td><p><a href="#class-geometry-method-convex-hull-2d"><span class="std std-ref">convex_hull_2d</span></a> <strong>(</strong> <a href="class_poolvector2array.html#class-poolvector2array"><span class="std std-ref">PoolVector2Array</span></a> points <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_array.html#class-array"><span class="std std-ref">Array</span></a></p></td> <td><p><a href="#class-geometry-method-exclude-polygons-2d"><span class="std std-ref">exclude_polygons_2d</span></a> <strong>(</strong> <a href="class_poolvector2array.html#class-poolvector2array"><span class="std std-ref">PoolVector2Array</span></a> polygon_a, <a href="class_poolvector2array.html#class-poolvector2array"><span class="std std-ref">PoolVector2Array</span></a> polygon_b <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a></p></td> <td><p><a href="#class-geometry-method-get-closest-point-to-segment"><span class="std std-ref">get_closest_point_to_segment</span></a> <strong>(</strong> <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> point, <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> s1, <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> s2 <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a></p></td> <td><p><a href="#class-geometry-method-get-closest-point-to-segment-2d"><span class="std std-ref">get_closest_point_to_segment_2d</span></a> <strong>(</strong> <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> point, <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> s1, <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> s2 <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a></p></td> <td><p><a href="#class-geometry-method-get-closest-point-to-segment-uncapped"><span class="std std-ref">get_closest_point_to_segment_uncapped</span></a> <strong>(</strong> <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> point, <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> s1, <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> s2 <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a></p></td> <td><p><a href="#class-geometry-method-get-closest-point-to-segment-uncapped-2d"><span class="std std-ref">get_closest_point_to_segment_uncapped_2d</span></a> <strong>(</strong> <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> point, <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> s1, <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> s2 <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_poolvector3array.html#class-poolvector3array"><span class="std std-ref">PoolVector3Array</span></a></p></td> <td><p><a href="#class-geometry-method-get-closest-points-between-segments"><span class="std std-ref">get_closest_points_between_segments</span></a> <strong>(</strong> <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> p1, <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> p2, <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> q1, <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> q2 <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_poolvector2array.html#class-poolvector2array"><span class="std std-ref">PoolVector2Array</span></a></p></td> <td><p><a href="#class-geometry-method-get-closest-points-between-segments-2d"><span class="std std-ref">get_closest_points_between_segments_2d</span></a> <strong>(</strong> <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> p1, <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> q1, <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> p2, <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> q2 <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_int.html#class-int"><span class="std std-ref">int</span></a></p></td> <td><p><a href="#class-geometry-method-get-uv84-normal-bit"><span class="std std-ref">get_uv84_normal_bit</span></a> <strong>(</strong> <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> normal <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_array.html#class-array"><span class="std std-ref">Array</span></a></p></td> <td><p><a href="#class-geometry-method-intersect-polygons-2d"><span class="std std-ref">intersect_polygons_2d</span></a> <strong>(</strong> <a href="class_poolvector2array.html#class-poolvector2array"><span class="std std-ref">PoolVector2Array</span></a> polygon_a, <a href="class_poolvector2array.html#class-poolvector2array"><span class="std std-ref">PoolVector2Array</span></a> polygon_b <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_array.html#class-array"><span class="std std-ref">Array</span></a></p></td> <td><p><a href="#class-geometry-method-intersect-polyline-with-polygon-2d"><span class="std std-ref">intersect_polyline_with_polygon_2d</span></a> <strong>(</strong> <a href="class_poolvector2array.html#class-poolvector2array"><span class="std std-ref">PoolVector2Array</span></a> polyline, <a href="class_poolvector2array.html#class-poolvector2array"><span class="std std-ref">PoolVector2Array</span></a> polygon <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a></p></td> <td><p><a href="#class-geometry-method-is-point-in-circle"><span class="std std-ref">is_point_in_circle</span></a> <strong>(</strong> <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> point, <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> circle_position, <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> circle_radius <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a></p></td> <td><p><a href="#class-geometry-method-is-point-in-polygon"><span class="std std-ref">is_point_in_polygon</span></a> <strong>(</strong> <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> point, <a href="class_poolvector2array.html#class-poolvector2array"><span class="std std-ref">PoolVector2Array</span></a> polygon <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a></p></td> <td><p><a href="#class-geometry-method-is-polygon-clockwise"><span class="std std-ref">is_polygon_clockwise</span></a> <strong>(</strong> <a href="class_poolvector2array.html#class-poolvector2array"><span class="std std-ref">PoolVector2Array</span></a> polygon <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_variant.html#class-variant"><span class="std std-ref">Variant</span></a></p></td> <td><p><a href="#class-geometry-method-line-intersects-line-2d"><span class="std std-ref">line_intersects_line_2d</span></a> <strong>(</strong> <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> from_a, <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> dir_a, <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> from_b, <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> dir_b <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_dictionary.html#class-dictionary"><span class="std std-ref">Dictionary</span></a></p></td> <td><p><a href="#class-geometry-method-make-atlas"><span class="std std-ref">make_atlas</span></a> <strong>(</strong> <a href="class_poolvector2array.html#class-poolvector2array"><span class="std std-ref">PoolVector2Array</span></a> sizes <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_array.html#class-array"><span class="std std-ref">Array</span></a></p></td> <td><p><a href="#class-geometry-method-merge-polygons-2d"><span class="std std-ref">merge_polygons_2d</span></a> <strong>(</strong> <a href="class_poolvector2array.html#class-poolvector2array"><span class="std std-ref">PoolVector2Array</span></a> polygon_a, <a href="class_poolvector2array.html#class-poolvector2array"><span class="std std-ref">PoolVector2Array</span></a> polygon_b <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_array.html#class-array"><span class="std std-ref">Array</span></a></p></td> <td><p><a href="#class-geometry-method-offset-polygon-2d"><span class="std std-ref">offset_polygon_2d</span></a> <strong>(</strong> <a href="class_poolvector2array.html#class-poolvector2array"><span class="std std-ref">PoolVector2Array</span></a> polygon, <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> delta, <a href="#enum-geometry-polyjointype"><span class="std std-ref">PolyJoinType</span></a> join_type=0 <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_array.html#class-array"><span class="std std-ref">Array</span></a></p></td> <td><p><a href="#class-geometry-method-offset-polyline-2d"><span class="std std-ref">offset_polyline_2d</span></a> <strong>(</strong> <a href="class_poolvector2array.html#class-poolvector2array"><span class="std std-ref">PoolVector2Array</span></a> polyline, <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> delta, <a href="#enum-geometry-polyjointype"><span class="std std-ref">PolyJoinType</span></a> join_type=0, <a href="#enum-geometry-polyendtype"><span class="std std-ref">PolyEndType</span></a> end_type=3 <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a></p></td> <td><p><a href="#class-geometry-method-point-is-inside-triangle"><span class="std std-ref">point_is_inside_triangle</span></a> <strong>(</strong> <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> point, <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> a, <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> b, <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> c <strong>)</strong> <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr></p></td> </tr> <tr>
<td><p><a href="class_variant.html#class-variant"><span class="std std-ref">Variant</span></a></p></td> <td><p><a href="#class-geometry-method-ray-intersects-triangle"><span class="std std-ref">ray_intersects_triangle</span></a> <strong>(</strong> <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> from, <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> dir, <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> a, <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> b, <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> c <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_float.html#class-float"><span class="std std-ref">float</span></a></p></td> <td><p><a href="#class-geometry-method-segment-intersects-circle"><span class="std std-ref">segment_intersects_circle</span></a> <strong>(</strong> <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> segment_from, <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> segment_to, <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> circle_position, <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> circle_radius <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_poolvector3array.html#class-poolvector3array"><span class="std std-ref">PoolVector3Array</span></a></p></td> <td><p><a href="#class-geometry-method-segment-intersects-convex"><span class="std std-ref">segment_intersects_convex</span></a> <strong>(</strong> <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> from, <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> to, <a href="class_array.html#class-array"><span class="std std-ref">Array</span></a> planes <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_poolvector3array.html#class-poolvector3array"><span class="std std-ref">PoolVector3Array</span></a></p></td> <td><p><a href="#class-geometry-method-segment-intersects-cylinder"><span class="std std-ref">segment_intersects_cylinder</span></a> <strong>(</strong> <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> from, <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> to, <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> height, <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> radius <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_variant.html#class-variant"><span class="std std-ref">Variant</span></a></p></td> <td><p><a href="#class-geometry-method-segment-intersects-segment-2d"><span class="std std-ref">segment_intersects_segment_2d</span></a> <strong>(</strong> <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> from_a, <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> to_a, <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> from_b, <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> to_b <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_poolvector3array.html#class-poolvector3array"><span class="std std-ref">PoolVector3Array</span></a></p></td> <td><p><a href="#class-geometry-method-segment-intersects-sphere"><span class="std std-ref">segment_intersects_sphere</span></a> <strong>(</strong> <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> from, <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> to, <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> sphere_position, <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> sphere_radius <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_variant.html#class-variant"><span class="std std-ref">Variant</span></a></p></td> <td><p><a href="#class-geometry-method-segment-intersects-triangle"><span class="std std-ref">segment_intersects_triangle</span></a> <strong>(</strong> <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> from, <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> to, <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> a, <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> b, <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> c <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_poolintarray.html#class-poolintarray"><span class="std std-ref">PoolIntArray</span></a></p></td> <td><p><a href="#class-geometry-method-triangulate-delaunay-2d"><span class="std std-ref">triangulate_delaunay_2d</span></a> <strong>(</strong> <a href="class_poolvector2array.html#class-poolvector2array"><span class="std std-ref">PoolVector2Array</span></a> points <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_poolintarray.html#class-poolintarray"><span class="std std-ref">PoolIntArray</span></a></p></td> <td><p><a href="#class-geometry-method-triangulate-polygon"><span class="std std-ref">triangulate_polygon</span></a> <strong>(</strong> <a href="class_poolvector2array.html#class-poolvector2array"><span class="std std-ref">PoolVector2Array</span></a> polygon <strong>)</strong></p></td> </tr>  </table> </section> <section id="enumerations"> <h2>Enumerations</h2> <p id="class-geometry-constant-operation-xor">enum <strong id="enum-geometry-polybooleanoperation">PolyBooleanOperation</strong>:</p> <ul class="simple"> <li>
<strong>OPERATION_UNION</strong> = <strong>0</strong> --- Create regions where either subject or clip polygons (or both) are filled.</li> <li>
<strong>OPERATION_DIFFERENCE</strong> = <strong>1</strong> --- Create regions where subject polygons are filled except where clip polygons are filled.</li> <li>
<strong>OPERATION_INTERSECTION</strong> = <strong>2</strong> --- Create regions where both subject and clip polygons are filled.</li> <li>
<strong>OPERATION_XOR</strong> = <strong>3</strong> --- Create regions where either subject or clip polygons are filled but not where both are filled.</li> </ul>  <p id="class-geometry-constant-join-miter">enum <strong id="enum-geometry-polyjointype">PolyJoinType</strong>:</p> <ul class="simple"> <li>
<strong>JOIN_SQUARE</strong> = <strong>0</strong> --- Squaring is applied uniformally at all convex edge joins at <code>1 * delta</code>.</li> <li>
<strong>JOIN_ROUND</strong> = <strong>1</strong> --- While flattened paths can never perfectly trace an arc, they are approximated by a series of arc chords.</li> <li>
<strong>JOIN_MITER</strong> = <strong>2</strong> --- There's a necessary limit to mitered joins since offsetting edges that join at very acute angles will produce excessively long and narrow "spikes". For any given edge join, when miter offsetting would exceed that maximum distance, "square" joining is applied.</li> </ul>  <p id="class-geometry-constant-end-round">enum <strong id="enum-geometry-polyendtype">PolyEndType</strong>:</p> <ul class="simple"> <li>
<strong>END_POLYGON</strong> = <strong>0</strong> --- Endpoints are joined using the <a href="#enum-geometry-polyjointype"><span class="std std-ref">PolyJoinType</span></a> value and the path filled as a polygon.</li> <li>
<strong>END_JOINED</strong> = <strong>1</strong> --- Endpoints are joined using the <a href="#enum-geometry-polyjointype"><span class="std std-ref">PolyJoinType</span></a> value and the path filled as a polyline.</li> <li>
<strong>END_BUTT</strong> = <strong>2</strong> --- Endpoints are squared off with no extension.</li> <li>
<strong>END_SQUARE</strong> = <strong>3</strong> --- Endpoints are squared off and extended by <code>delta</code> units.</li> <li>
<strong>END_ROUND</strong> = <strong>4</strong> --- Endpoints are rounded off and extended by <code>delta</code> units.</li> </ul> </section> <section id="method-descriptions"> <h2>Method Descriptions</h2> <h3 id="class-geometry-method-build-box-planes"><p><a href="class_array.html#class-array"><span class="std std-ref">Array</span></a> build_box_planes ( <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> extents )</p></h3> <p>Returns an array with 6 <a href="class_plane.html#class-plane"><span class="std std-ref">Plane</span></a>s that describe the sides of a box centered at the origin. The box size is defined by <code>extents</code>, which represents one (positive) corner of the box (i.e. half its actual size).</p>  <h3 id="class-geometry-method-build-capsule-planes"><p><a href="class_array.html#class-array"><span class="std std-ref">Array</span></a> build_capsule_planes ( <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> radius, <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> height, <a href="class_int.html#class-int"><span class="std std-ref">int</span></a> sides, <a href="class_int.html#class-int"><span class="std std-ref">int</span></a> lats, Vector3.Axis axis=2 )</p></h3> <p>Returns an array of <a href="class_plane.html#class-plane"><span class="std std-ref">Plane</span></a>s closely bounding a faceted capsule centered at the origin with radius <code>radius</code> and height <code>height</code>. The parameter <code>sides</code> defines how many planes will be generated for the side part of the capsule, whereas <code>lats</code> gives the number of latitudinal steps at the bottom and top of the capsule. The parameter <code>axis</code> describes the axis along which the capsule is oriented (0 for X, 1 for Y, 2 for Z).</p>  <h3 id="class-geometry-method-build-cylinder-planes"><p><a href="class_array.html#class-array"><span class="std std-ref">Array</span></a> build_cylinder_planes ( <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> radius, <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> height, <a href="class_int.html#class-int"><span class="std std-ref">int</span></a> sides, Vector3.Axis axis=2 )</p></h3> <p>Returns an array of <a href="class_plane.html#class-plane"><span class="std std-ref">Plane</span></a>s closely bounding a faceted cylinder centered at the origin with radius <code>radius</code> and height <code>height</code>. The parameter <code>sides</code> defines how many planes will be generated for the round part of the cylinder. The parameter <code>axis</code> describes the axis along which the cylinder is oriented (0 for X, 1 for Y, 2 for Z).</p>  <h3 id="class-geometry-method-clip-polygon"><p><a href="class_poolvector3array.html#class-poolvector3array"><span class="std std-ref">PoolVector3Array</span></a> clip_polygon ( <a href="class_poolvector3array.html#class-poolvector3array"><span class="std std-ref">PoolVector3Array</span></a> points, <a href="class_plane.html#class-plane"><span class="std std-ref">Plane</span></a> plane )</p></h3> <p>Clips the polygon defined by the points in <code>points</code> against the <code>plane</code> and returns the points of the clipped polygon.</p>  <h3 id="class-geometry-method-clip-polygons-2d"><p><a href="class_array.html#class-array"><span class="std std-ref">Array</span></a> clip_polygons_2d ( <a href="class_poolvector2array.html#class-poolvector2array"><span class="std std-ref">PoolVector2Array</span></a> polygon_a, <a href="class_poolvector2array.html#class-poolvector2array"><span class="std std-ref">PoolVector2Array</span></a> polygon_b )</p></h3> <p>Clips <code>polygon_a</code> against <code>polygon_b</code> and returns an array of clipped polygons. This performs <a href="#class-geometry-constant-operation-difference"><span class="std std-ref">OPERATION_DIFFERENCE</span></a> between polygons. Returns an empty array if <code>polygon_b</code> completely overlaps <code>polygon_a</code>.</p> <p>If <code>polygon_b</code> is enclosed by <code>polygon_a</code>, returns an outer polygon (boundary) and inner polygon (hole) which could be distinguished by calling <a href="#class-geometry-method-is-polygon-clockwise"><span class="std std-ref">is_polygon_clockwise</span></a>.</p>  <h3 id="class-geometry-method-clip-polyline-with-polygon-2d"><p><a href="class_array.html#class-array"><span class="std std-ref">Array</span></a> clip_polyline_with_polygon_2d ( <a href="class_poolvector2array.html#class-poolvector2array"><span class="std std-ref">PoolVector2Array</span></a> polyline, <a href="class_poolvector2array.html#class-poolvector2array"><span class="std std-ref">PoolVector2Array</span></a> polygon )</p></h3> <p>Clips <code>polyline</code> against <code>polygon</code> and returns an array of clipped polylines. This performs <a href="#class-geometry-constant-operation-difference"><span class="std std-ref">OPERATION_DIFFERENCE</span></a> between the polyline and the polygon. This operation can be thought of as cutting a line with a closed shape.</p>  <h3 id="class-geometry-method-convex-hull-2d"><p><a href="class_poolvector2array.html#class-poolvector2array"><span class="std std-ref">PoolVector2Array</span></a> convex_hull_2d ( <a href="class_poolvector2array.html#class-poolvector2array"><span class="std std-ref">PoolVector2Array</span></a> points )</p></h3> <p>Given an array of <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a>s, returns the convex hull as a list of points in counterclockwise order. The last point is the same as the first one.</p>  <h3 id="class-geometry-method-exclude-polygons-2d"><p><a href="class_array.html#class-array"><span class="std std-ref">Array</span></a> exclude_polygons_2d ( <a href="class_poolvector2array.html#class-poolvector2array"><span class="std std-ref">PoolVector2Array</span></a> polygon_a, <a href="class_poolvector2array.html#class-poolvector2array"><span class="std std-ref">PoolVector2Array</span></a> polygon_b )</p></h3> <p>Mutually excludes common area defined by intersection of <code>polygon_a</code> and <code>polygon_b</code> (see <a href="#class-geometry-method-intersect-polygons-2d"><span class="std std-ref">intersect_polygons_2d</span></a>) and returns an array of excluded polygons. This performs <a href="#class-geometry-constant-operation-xor"><span class="std std-ref">OPERATION_XOR</span></a> between polygons. In other words, returns all but common area between polygons.</p> <p>The operation may result in an outer polygon (boundary) and inner polygon (hole) produced which could be distinguished by calling <a href="#class-geometry-method-is-polygon-clockwise"><span class="std std-ref">is_polygon_clockwise</span></a>.</p>  <h3 id="class-geometry-method-get-closest-point-to-segment"><p><a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> get_closest_point_to_segment ( <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> point, <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> s1, <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> s2 )</p></h3> <p>Returns the 3D point on the 3D segment (<code>s1</code>, <code>s2</code>) that is closest to <code>point</code>. The returned point will always be inside the specified segment.</p>  <h3 id="class-geometry-method-get-closest-point-to-segment-2d"><p><a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> get_closest_point_to_segment_2d ( <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> point, <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> s1, <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> s2 )</p></h3> <p>Returns the 2D point on the 2D segment (<code>s1</code>, <code>s2</code>) that is closest to <code>point</code>. The returned point will always be inside the specified segment.</p>  <h3 id="class-geometry-method-get-closest-point-to-segment-uncapped"><p><a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> get_closest_point_to_segment_uncapped ( <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> point, <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> s1, <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> s2 )</p></h3> <p>Returns the 3D point on the 3D line defined by (<code>s1</code>, <code>s2</code>) that is closest to <code>point</code>. The returned point can be inside the segment (<code>s1</code>, <code>s2</code>) or outside of it, i.e. somewhere on the line extending from the segment.</p>  <h3 id="class-geometry-method-get-closest-point-to-segment-uncapped-2d"><p><a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> get_closest_point_to_segment_uncapped_2d ( <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> point, <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> s1, <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> s2 )</p></h3> <p>Returns the 2D point on the 2D line defined by (<code>s1</code>, <code>s2</code>) that is closest to <code>point</code>. The returned point can be inside the segment (<code>s1</code>, <code>s2</code>) or outside of it, i.e. somewhere on the line extending from the segment.</p>  <h3 id="class-geometry-method-get-closest-points-between-segments"><p><a href="class_poolvector3array.html#class-poolvector3array"><span class="std std-ref">PoolVector3Array</span></a> get_closest_points_between_segments ( <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> p1, <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> p2, <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> q1, <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> q2 )</p></h3> <p>Given the two 3D segments (<code>p1</code>, <code>p2</code>) and (<code>q1</code>, <code>q2</code>), finds those two points on the two segments that are closest to each other. Returns a <a href="class_poolvector3array.html#class-poolvector3array"><span class="std std-ref">PoolVector3Array</span></a> that contains this point on (<code>p1</code>, <code>p2</code>) as well the accompanying point on (<code>q1</code>, <code>q2</code>).</p>  <h3 id="class-geometry-method-get-closest-points-between-segments-2d"><p><a href="class_poolvector2array.html#class-poolvector2array"><span class="std std-ref">PoolVector2Array</span></a> get_closest_points_between_segments_2d ( <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> p1, <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> q1, <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> p2, <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> q2 )</p></h3> <p>Given the two 2D segments (<code>p1</code>, <code>q1</code>) and (<code>p2</code>, <code>q2</code>), finds those two points on the two segments that are closest to each other. Returns a <a href="class_poolvector2array.html#class-poolvector2array"><span class="std std-ref">PoolVector2Array</span></a> that contains this point on (<code>p1</code>, <code>q1</code>) as well the accompanying point on (<code>p2</code>, <code>q2</code>).</p>  <h3 id="class-geometry-method-get-uv84-normal-bit"><p><a href="class_int.html#class-int"><span class="std std-ref">int</span></a> get_uv84_normal_bit ( <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> normal )</p></h3> <p>Used internally by the engine.</p>  <h3 id="class-geometry-method-intersect-polygons-2d"><p><a href="class_array.html#class-array"><span class="std std-ref">Array</span></a> intersect_polygons_2d ( <a href="class_poolvector2array.html#class-poolvector2array"><span class="std std-ref">PoolVector2Array</span></a> polygon_a, <a href="class_poolvector2array.html#class-poolvector2array"><span class="std std-ref">PoolVector2Array</span></a> polygon_b )</p></h3> <p>Intersects <code>polygon_a</code> with <code>polygon_b</code> and returns an array of intersected polygons. This performs <a href="#class-geometry-constant-operation-intersection"><span class="std std-ref">OPERATION_INTERSECTION</span></a> between polygons. In other words, returns common area shared by polygons. Returns an empty array if no intersection occurs.</p> <p>The operation may result in an outer polygon (boundary) and inner polygon (hole) produced which could be distinguished by calling <a href="#class-geometry-method-is-polygon-clockwise"><span class="std std-ref">is_polygon_clockwise</span></a>.</p>  <h3 id="class-geometry-method-intersect-polyline-with-polygon-2d"><p><a href="class_array.html#class-array"><span class="std std-ref">Array</span></a> intersect_polyline_with_polygon_2d ( <a href="class_poolvector2array.html#class-poolvector2array"><span class="std std-ref">PoolVector2Array</span></a> polyline, <a href="class_poolvector2array.html#class-poolvector2array"><span class="std std-ref">PoolVector2Array</span></a> polygon )</p></h3> <p>Intersects <code>polyline</code> with <code>polygon</code> and returns an array of intersected polylines. This performs <a href="#class-geometry-constant-operation-intersection"><span class="std std-ref">OPERATION_INTERSECTION</span></a> between the polyline and the polygon. This operation can be thought of as chopping a line with a closed shape.</p>  <h3 id="class-geometry-method-is-point-in-circle"><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> is_point_in_circle ( <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> point, <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> circle_position, <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> circle_radius )</p></h3> <p>Returns <code>true</code> if <code>point</code> is inside the circle or if it's located exactly <em>on</em> the circle's boundary, otherwise returns <code>false</code>.</p>  <h3 id="class-geometry-method-is-point-in-polygon"><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> is_point_in_polygon ( <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> point, <a href="class_poolvector2array.html#class-poolvector2array"><span class="std std-ref">PoolVector2Array</span></a> polygon )</p></h3> <p>Returns <code>true</code> if <code>point</code> is inside <code>polygon</code> or if it's located exactly <em>on</em> polygon's boundary, otherwise returns <code>false</code>.</p>  <h3 id="class-geometry-method-is-polygon-clockwise"><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> is_polygon_clockwise ( <a href="class_poolvector2array.html#class-poolvector2array"><span class="std std-ref">PoolVector2Array</span></a> polygon )</p></h3> <p>Returns <code>true</code> if <code>polygon</code>'s vertices are ordered in clockwise order, otherwise returns <code>false</code>.</p>  <h3 id="class-geometry-method-line-intersects-line-2d"><p><a href="class_variant.html#class-variant"><span class="std std-ref">Variant</span></a> line_intersects_line_2d ( <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> from_a, <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> dir_a, <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> from_b, <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> dir_b )</p></h3> <p>Checks if the two lines (<code>from_a</code>, <code>dir_a</code>) and (<code>from_b</code>, <code>dir_b</code>) intersect. If yes, return the point of intersection as <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a>. If no intersection takes place, returns <code>null</code>.</p> <p><strong>Note:</strong> The lines are specified using direction vectors, not end points.</p>  <h3 id="class-geometry-method-make-atlas"><p><a href="class_dictionary.html#class-dictionary"><span class="std std-ref">Dictionary</span></a> make_atlas ( <a href="class_poolvector2array.html#class-poolvector2array"><span class="std std-ref">PoolVector2Array</span></a> sizes )</p></h3> <p>Given an array of <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a>s representing tiles, builds an atlas. The returned dictionary has two keys: <code>points</code> is an array of <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> that specifies the positions of each tile, <code>size</code> contains the overall size of the whole atlas as <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a>.</p>  <h3 id="class-geometry-method-merge-polygons-2d"><p><a href="class_array.html#class-array"><span class="std std-ref">Array</span></a> merge_polygons_2d ( <a href="class_poolvector2array.html#class-poolvector2array"><span class="std std-ref">PoolVector2Array</span></a> polygon_a, <a href="class_poolvector2array.html#class-poolvector2array"><span class="std std-ref">PoolVector2Array</span></a> polygon_b )</p></h3> <p>Merges (combines) <code>polygon_a</code> and <code>polygon_b</code> and returns an array of merged polygons. This performs <a href="#class-geometry-constant-operation-union"><span class="std std-ref">OPERATION_UNION</span></a> between polygons.</p> <p>The operation may result in an outer polygon (boundary) and multiple inner polygons (holes) produced which could be distinguished by calling <a href="#class-geometry-method-is-polygon-clockwise"><span class="std std-ref">is_polygon_clockwise</span></a>.</p>  <h3 id="class-geometry-method-offset-polygon-2d"><p><a href="class_array.html#class-array"><span class="std std-ref">Array</span></a> offset_polygon_2d ( <a href="class_poolvector2array.html#class-poolvector2array"><span class="std std-ref">PoolVector2Array</span></a> polygon, <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> delta, <a href="#enum-geometry-polyjointype"><span class="std std-ref">PolyJoinType</span></a> join_type=0 )</p></h3> <p>Inflates or deflates <code>polygon</code> by <code>delta</code> units (pixels). If <code>delta</code> is positive, makes the polygon grow outward. If <code>delta</code> is negative, shrinks the polygon inward. Returns an array of polygons because inflating/deflating may result in multiple discrete polygons. Returns an empty array if <code>delta</code> is negative and the absolute value of it approximately exceeds the minimum bounding rectangle dimensions of the polygon.</p> <p>Each polygon's vertices will be rounded as determined by <code>join_type</code>, see <a href="#enum-geometry-polyjointype"><span class="std std-ref">PolyJoinType</span></a>.</p> <p>The operation may result in an outer polygon (boundary) and inner polygon (hole) produced which could be distinguished by calling <a href="#class-geometry-method-is-polygon-clockwise"><span class="std std-ref">is_polygon_clockwise</span></a>.</p> <p><strong>Note:</strong> To translate the polygon's vertices specifically, use the <a href="class_transform2d.html#class-transform2d-method-xform"><span class="std std-ref">Transform2D.xform</span></a> method:</p> <pre data-language="gdscript">var polygon = PoolVector2Array([Vector2(0, 0), Vector2(100, 0), Vector2(100, 100), Vector2(0, 100)])
var offset = Vector2(50, 50)
polygon = Transform2D(0, offset).xform(polygon)
print(polygon) # prints [Vector2(50, 50), Vector2(150, 50), Vector2(150, 150), Vector2(50, 150)]
</pre>  <h3 id="class-geometry-method-offset-polyline-2d"><p><a href="class_array.html#class-array"><span class="std std-ref">Array</span></a> offset_polyline_2d ( <a href="class_poolvector2array.html#class-poolvector2array"><span class="std std-ref">PoolVector2Array</span></a> polyline, <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> delta, <a href="#enum-geometry-polyjointype"><span class="std std-ref">PolyJoinType</span></a> join_type=0, <a href="#enum-geometry-polyendtype"><span class="std std-ref">PolyEndType</span></a> end_type=3 )</p></h3> <p>Inflates or deflates <code>polyline</code> by <code>delta</code> units (pixels), producing polygons. If <code>delta</code> is positive, makes the polyline grow outward. Returns an array of polygons because inflating/deflating may result in multiple discrete polygons. If <code>delta</code> is negative, returns an empty array.</p> <p>Each polygon's vertices will be rounded as determined by <code>join_type</code>, see <a href="#enum-geometry-polyjointype"><span class="std std-ref">PolyJoinType</span></a>.</p> <p>Each polygon's endpoints will be rounded as determined by <code>end_type</code>, see <a href="#enum-geometry-polyendtype"><span class="std std-ref">PolyEndType</span></a>.</p> <p>The operation may result in an outer polygon (boundary) and inner polygon (hole) produced which could be distinguished by calling <a href="#class-geometry-method-is-polygon-clockwise"><span class="std std-ref">is_polygon_clockwise</span></a>.</p>  <h3 id="class-geometry-method-point-is-inside-triangle"><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> point_is_inside_triangle ( <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> point, <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> a, <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> b, <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> c ) <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr></p></h3> <p>Returns if <code>point</code> is inside the triangle specified by <code>a</code>, <code>b</code> and <code>c</code>.</p>  <h3 id="class-geometry-method-ray-intersects-triangle"><p><a href="class_variant.html#class-variant"><span class="std std-ref">Variant</span></a> ray_intersects_triangle ( <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> from, <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> dir, <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> a, <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> b, <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> c )</p></h3> <p>Tests if the 3D ray starting at <code>from</code> with the direction of <code>dir</code> intersects the triangle specified by <code>a</code>, <code>b</code> and <code>c</code>. If yes, returns the point of intersection as <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a>. If no intersection takes place, an empty <a href="class_variant.html#class-variant"><span class="std std-ref">Variant</span></a> is returned.</p>  <h3 id="class-geometry-method-segment-intersects-circle"><p><a href="class_float.html#class-float"><span class="std std-ref">float</span></a> segment_intersects_circle ( <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> segment_from, <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> segment_to, <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> circle_position, <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> circle_radius )</p></h3> <p>Given the 2D segment (<code>segment_from</code>, <code>segment_to</code>), returns the position on the segment (as a number between 0 and 1) at which the segment hits the circle that is located at position <code>circle_position</code> and has radius <code>circle_radius</code>. If the segment does not intersect the circle, -1 is returned (this is also the case if the line extending the segment would intersect the circle, but the segment does not).</p>  <h3 id="class-geometry-method-segment-intersects-convex"><p><a href="class_poolvector3array.html#class-poolvector3array"><span class="std std-ref">PoolVector3Array</span></a> segment_intersects_convex ( <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> from, <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> to, <a href="class_array.html#class-array"><span class="std std-ref">Array</span></a> planes )</p></h3> <p>Given a convex hull defined though the <a href="class_plane.html#class-plane"><span class="std std-ref">Plane</span></a>s in the array <code>planes</code>, tests if the segment (<code>from</code>, <code>to</code>) intersects with that hull. If an intersection is found, returns a <a href="class_poolvector3array.html#class-poolvector3array"><span class="std std-ref">PoolVector3Array</span></a> containing the point the intersection and the hull's normal. If no intersecion is found, an the returned array is empty.</p>  <h3 id="class-geometry-method-segment-intersects-cylinder"><p><a href="class_poolvector3array.html#class-poolvector3array"><span class="std std-ref">PoolVector3Array</span></a> segment_intersects_cylinder ( <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> from, <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> to, <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> height, <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> radius )</p></h3> <p>Checks if the segment (<code>from</code>, <code>to</code>) intersects the cylinder with height <code>height</code> that is centered at the origin and has radius <code>radius</code>. If no, returns an empty <a href="class_poolvector3array.html#class-poolvector3array"><span class="std std-ref">PoolVector3Array</span></a>. If an intersection takes place, the returned array contains the point of intersection and the cylinder's normal at the point of intersection.</p>  <h3 id="class-geometry-method-segment-intersects-segment-2d"><p><a href="class_variant.html#class-variant"><span class="std std-ref">Variant</span></a> segment_intersects_segment_2d ( <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> from_a, <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> to_a, <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> from_b, <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> to_b )</p></h3> <p>Checks if the two segments (<code>from_a</code>, <code>to_a</code>) and (<code>from_b</code>, <code>to_b</code>) intersect. If yes, return the point of intersection as <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a>. If no intersection takes place, returns <code>null</code>.</p>  <h3 id="class-geometry-method-segment-intersects-sphere"><p><a href="class_poolvector3array.html#class-poolvector3array"><span class="std std-ref">PoolVector3Array</span></a> segment_intersects_sphere ( <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> from, <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> to, <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> sphere_position, <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> sphere_radius )</p></h3> <p>Checks if the segment (<code>from</code>, <code>to</code>) intersects the sphere that is located at <code>sphere_position</code> and has radius <code>sphere_radius</code>. If no, returns an empty <a href="class_poolvector3array.html#class-poolvector3array"><span class="std std-ref">PoolVector3Array</span></a>. If yes, returns a <a href="class_poolvector3array.html#class-poolvector3array"><span class="std std-ref">PoolVector3Array</span></a> containing the point of intersection and the sphere's normal at the point of intersection.</p>  <h3 id="class-geometry-method-segment-intersects-triangle"><p><a href="class_variant.html#class-variant"><span class="std std-ref">Variant</span></a> segment_intersects_triangle ( <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> from, <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> to, <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> a, <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> b, <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> c )</p></h3> <p>Tests if the segment (<code>from</code>, <code>to</code>) intersects the triangle <code>a</code>, <code>b</code>, <code>c</code>. If yes, returns the point of intersection as <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a>. If no intersection takes place, an empty <a href="class_variant.html#class-variant"><span class="std std-ref">Variant</span></a> is returned.</p>  <h3 id="class-geometry-method-triangulate-delaunay-2d"><p><a href="class_poolintarray.html#class-poolintarray"><span class="std std-ref">PoolIntArray</span></a> triangulate_delaunay_2d ( <a href="class_poolvector2array.html#class-poolvector2array"><span class="std std-ref">PoolVector2Array</span></a> points )</p></h3> <p>Triangulates the area specified by discrete set of <code>points</code> such that no point is inside the circumcircle of any resulting triangle. Returns a <a href="class_poolintarray.html#class-poolintarray"><span class="std std-ref">PoolIntArray</span></a> where each triangle consists of three consecutive point indices into <code>points</code> (i.e. the returned array will have <code>n * 3</code> elements, with <code>n</code> being the number of found triangles). If the triangulation did not succeed, an empty <a href="class_poolintarray.html#class-poolintarray"><span class="std std-ref">PoolIntArray</span></a> is returned.</p>  <h3 id="class-geometry-method-triangulate-polygon"><p><a href="class_poolintarray.html#class-poolintarray"><span class="std std-ref">PoolIntArray</span></a> triangulate_polygon ( <a href="class_poolvector2array.html#class-poolvector2array"><span class="std std-ref">PoolVector2Array</span></a> polygon )</p></h3> <p>Triangulates the polygon specified by the points in <code>polygon</code>. Returns a <a href="class_poolintarray.html#class-poolintarray"><span class="std std-ref">PoolIntArray</span></a> where each triangle consists of three consecutive point indices into <code>polygon</code> (i.e. the returned array will have <code>n * 3</code> elements, with <code>n</code> being the number of found triangles). Output triangles will always be counter clockwise, and the contour will be flipped if it's clockwise. If the triangulation did not succeed, an empty <a href="class_poolintarray.html#class-poolintarray"><span class="std std-ref">PoolIntArray</span></a> is returned.</p> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2014&ndash;2022 Juan Linietsky, Ariel Manzur, Godot Engine contributors<br>Licensed under the MIT License.<br>
    <a href="https://docs.godotengine.org/en/3.5/classes/class_geometry.html" class="_attribution-link">https://docs.godotengine.org/en/3.5/classes/class_geometry.html</a>
  </p>
</div>
