<section id="timer"> <h1 id="class-timer">Timer</h1> <p><strong>Inherits:</strong> <a href="class_node.html#class-node"><span class="std std-ref">Node</span></a> <strong>&lt;</strong> <a href="class_object.html#class-object"><span class="std std-ref">Object</span></a></p> <p>A countdown timer.</p> <section class="classref-introduction-group" id="description"> <h2>Description</h2> <p>Counts down a specified interval and emits a signal on reaching 0. Can be set to repeat or "one-shot" mode.</p> <p><strong>Note:</strong> Timers are affected by <a href="class_engine.html#class-engine-property-time-scale"><span class="std std-ref">Engine.time_scale</span></a>, a higher scale means quicker timeouts, and vice versa.</p> <p><strong>Note:</strong> To create a one-shot timer without instantiating a node, use <a href="class_scenetree.html#class-scenetree-method-create-timer"><span class="std std-ref">SceneTree.create_timer</span></a>.</p> </section> <section class="classref-introduction-group" id="tutorials"> <h2>Tutorials</h2> <ul class="simple"> <li><a href="https://godotengine.org/asset-library/asset/515">2D Dodge The Creeps Demo</a></li> </ul> </section> <section class="classref-reftable-group" id="properties"> <h2>Properties</h2> <table class="colwidths-auto docutils align-default">  <tr>
<td><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a></p></td> <td><p><a href="#class-timer-property-autostart"><span class="std std-ref">autostart</span></a></p></td> <td><p><code>false</code></p></td> </tr> <tr>
<td><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a></p></td> <td><p><a href="#class-timer-property-one-shot"><span class="std std-ref">one_shot</span></a></p></td> <td><p><code>false</code></p></td> </tr> <tr>
<td><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a></p></td> <td><p><a href="#class-timer-property-paused"><span class="std std-ref">paused</span></a></p></td> <td></td> </tr> <tr>
<td><p><a href="#enum-timer-timerprocesscallback"><span class="std std-ref">TimerProcessCallback</span></a></p></td> <td><p><a href="#class-timer-property-process-callback"><span class="std std-ref">process_callback</span></a></p></td> <td><p><code>1</code></p></td> </tr> <tr>
<td><p><a href="class_float.html#class-float"><span class="std std-ref">float</span></a></p></td> <td><p><a href="#class-timer-property-time-left"><span class="std std-ref">time_left</span></a></p></td> <td></td> </tr> <tr>
<td><p><a href="class_float.html#class-float"><span class="std std-ref">float</span></a></p></td> <td><p><a href="#class-timer-property-wait-time"><span class="std std-ref">wait_time</span></a></p></td> <td><p><code>1.0</code></p></td> </tr>  </table> </section> <section class="classref-reftable-group" id="methods"> <h2>Methods</h2> <table class="colwidths-auto docutils align-default">  <tr>
<td><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a></p></td> <td><p><a href="#class-timer-method-is-stopped"><span class="std std-ref">is_stopped</span></a> <strong>(</strong> <strong>)</strong> <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-timer-method-start"><span class="std std-ref">start</span></a> <strong>(</strong> <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> time_sec=-1 <strong>)</strong></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-timer-method-stop"><span class="std std-ref">stop</span></a> <strong>(</strong> <strong>)</strong></p></td> </tr>  </table> </section>  <section class="classref-descriptions-group" id="signals"> <h2>Signals</h2> <h3 id="class-timer-signal-timeout">timeout ( )</h3> <p>Emitted when the timer reaches 0.</p> </section>  <section class="classref-descriptions-group" id="enumerations"> <h2>Enumerations</h2> <h3 id="enum-timer-timerprocesscallback">enum TimerProcessCallback:</h3> <h3 id="class-timer-constant-timer-process-physics">
<a href="#enum-timer-timerprocesscallback"><span class="std std-ref">TimerProcessCallback</span></a> TIMER_PROCESS_PHYSICS = <code>0</code>
</h3> <p>Update the timer during physics frames (see <a href="class_node.html#class-node-constant-notification-internal-physics-process"><span class="std std-ref">Node.NOTIFICATION_INTERNAL_PHYSICS_PROCESS</span></a>).</p> <h3 id="class-timer-constant-timer-process-idle">
<a href="#enum-timer-timerprocesscallback"><span class="std std-ref">TimerProcessCallback</span></a> TIMER_PROCESS_IDLE = <code>1</code>
</h3> <p>Update the timer during process frames (see <a href="class_node.html#class-node-constant-notification-internal-process"><span class="std std-ref">Node.NOTIFICATION_INTERNAL_PROCESS</span></a>).</p> </section>  <section class="classref-descriptions-group" id="property-descriptions"> <h2>Property Descriptions</h2> <h3 id="class-timer-property-autostart">
<a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> autostart = <code>false</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_autostart</strong> <strong>(</strong> <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> value <strong>)</strong>
</li> <li>
<a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> <strong>has_autostart</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>If <code>true</code>, the timer will automatically start when entering the scene tree.</p> <p><strong>Note:</strong> This property is automatically set to <code>false</code> after the timer enters the scene tree and starts.</p>  <h3 id="class-timer-property-one-shot">
<a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> one_shot = <code>false</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_one_shot</strong> <strong>(</strong> <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> value <strong>)</strong>
</li> <li>
<a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> <strong>is_one_shot</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>If <code>true</code>, the timer will stop when reaching 0. If <code>false</code>, it will restart.</p>  <h3 id="class-timer-property-paused">
<a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> paused</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_paused</strong> <strong>(</strong> <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> value <strong>)</strong>
</li> <li>
<a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> <strong>is_paused</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>If <code>true</code>, the timer is paused and will not process until it is unpaused again, even if <a href="#class-timer-method-start"><span class="std std-ref">start</span></a> is called.</p>  <h3 id="class-timer-property-process-callback">
<a href="#enum-timer-timerprocesscallback"><span class="std std-ref">TimerProcessCallback</span></a> process_callback = <code>1</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_timer_process_callback</strong> <strong>(</strong> <a href="#enum-timer-timerprocesscallback"><span class="std std-ref">TimerProcessCallback</span></a> value <strong>)</strong>
</li> <li>
<a href="#enum-timer-timerprocesscallback"><span class="std std-ref">TimerProcessCallback</span></a> <strong>get_timer_process_callback</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>Processing callback. See <a href="#enum-timer-timerprocesscallback"><span class="std std-ref">TimerProcessCallback</span></a>.</p>  <h3 id="class-timer-property-time-left">
<a href="class_float.html#class-float"><span class="std std-ref">float</span></a> time_left</h3> <ul class="classref-property-setget simple"> <li>
<a href="class_float.html#class-float"><span class="std std-ref">float</span></a> <strong>get_time_left</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>The timer's remaining time in seconds. Returns 0 if the timer is inactive.</p> <p><strong>Note:</strong> This value is read-only and cannot be set. It is based on <a href="#class-timer-property-wait-time"><span class="std std-ref">wait_time</span></a>, which can be set using <a href="#class-timer-method-start"><span class="std std-ref">start</span></a>.</p>  <h3 id="class-timer-property-wait-time">
<a href="class_float.html#class-float"><span class="std std-ref">float</span></a> wait_time = <code>1.0</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_wait_time</strong> <strong>(</strong> <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> value <strong>)</strong>
</li> <li>
<a href="class_float.html#class-float"><span class="std std-ref">float</span></a> <strong>get_wait_time</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>The wait time in seconds.</p> <p><strong>Note:</strong> Timers can only emit once per rendered frame at most (or once per physics frame if <a href="#class-timer-property-process-callback"><span class="std std-ref">process_callback</span></a> is <a href="#class-timer-constant-timer-process-physics"><span class="std std-ref">TIMER_PROCESS_PHYSICS</span></a>). This means very low wait times (lower than 0.05 seconds) will behave in significantly different ways depending on the rendered framerate. For very low wait times, it is recommended to use a process loop in a script instead of using a Timer node. Timers are affected by <a href="class_engine.html#class-engine-property-time-scale"><span class="std std-ref">Engine.time_scale</span></a>, a higher scale means quicker timeouts, and vice versa.</p> </section>  <section class="classref-descriptions-group" id="method-descriptions"> <h2>Method Descriptions</h2> <h3 id="class-timer-method-is-stopped">
<a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> is_stopped ( ) <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr>
</h3> <p>Returns <code>true</code> if the timer is stopped.</p>  <h3 id="class-timer-method-start">void start ( <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> time_sec=-1 )</h3> <p>Starts the timer. Sets <a href="#class-timer-property-wait-time"><span class="std std-ref">wait_time</span></a> to <code>time_sec</code> if <code>time_sec &gt; 0</code>. This also resets the remaining time to <a href="#class-timer-property-wait-time"><span class="std std-ref">wait_time</span></a>.</p> <p><strong>Note:</strong> This method will not resume a paused timer. See <a href="#class-timer-property-paused"><span class="std std-ref">paused</span></a>.</p>  <h3 id="class-timer-method-stop">void stop ( )</h3> <p>Stops the timer.</p> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2014&ndash;present Juan Linietsky, Ariel Manzur and the Godot community<br>Licensed under the Creative Commons Attribution Unported License v3.0.<br>
    <a href="https://docs.godotengine.org/en/4.2/classes/class_timer.html" class="_attribution-link">https://docs.godotengine.org/en/4.2/classes/class_timer.html</a>
  </p>
</div>
