<section id="node"> <h1 id="class-node">Node</h1> <p><strong>Inherits:</strong> <a href="class_object.html#class-object"><span class="std std-ref">Object</span></a></p> <p><strong>Inherited By:</strong> <a href="class_animationmixer.html#class-animationmixer"><span class="std std-ref">AnimationMixer</span></a>, <a href="class_audiostreamplayer.html#class-audiostreamplayer"><span class="std std-ref">AudioStreamPlayer</span></a>, <a href="class_canvasitem.html#class-canvasitem"><span class="std std-ref">CanvasItem</span></a>, <a href="class_canvaslayer.html#class-canvaslayer"><span class="std std-ref">CanvasLayer</span></a>, <a href="class_editorfilesystem.html#class-editorfilesystem"><span class="std std-ref">EditorFileSystem</span></a>, <a href="class_editorplugin.html#class-editorplugin"><span class="std std-ref">EditorPlugin</span></a>, <a href="class_editorresourcepreview.html#class-editorresourcepreview"><span class="std std-ref">EditorResourcePreview</span></a>, <a href="class_httprequest.html#class-httprequest"><span class="std std-ref">HTTPRequest</span></a>, <a href="class_instanceplaceholder.html#class-instanceplaceholder"><span class="std std-ref">InstancePlaceholder</span></a>, <a href="class_missingnode.html#class-missingnode"><span class="std std-ref">MissingNode</span></a>, <a href="class_multiplayerspawner.html#class-multiplayerspawner"><span class="std std-ref">MultiplayerSpawner</span></a>, <a href="class_multiplayersynchronizer.html#class-multiplayersynchronizer"><span class="std std-ref">MultiplayerSynchronizer</span></a>, <a href="class_navigationagent2d.html#class-navigationagent2d"><span class="std std-ref">NavigationAgent2D</span></a>, <a href="class_navigationagent3d.html#class-navigationagent3d"><span class="std std-ref">NavigationAgent3D</span></a>, <a href="class_node3d.html#class-node3d"><span class="std std-ref">Node3D</span></a>, <a href="class_resourcepreloader.html#class-resourcepreloader"><span class="std std-ref">ResourcePreloader</span></a>, <a href="class_shaderglobalsoverride.html#class-shaderglobalsoverride"><span class="std std-ref">ShaderGlobalsOverride</span></a>, <a href="class_skeletonik3d.html#class-skeletonik3d"><span class="std std-ref">SkeletonIK3D</span></a>, <a href="class_timer.html#class-timer"><span class="std std-ref">Timer</span></a>, <a href="class_viewport.html#class-viewport"><span class="std std-ref">Viewport</span></a>, <a href="class_worldenvironment.html#class-worldenvironment"><span class="std std-ref">WorldEnvironment</span></a></p> <p>Base class for all scene objects.</p> <section class="classref-introduction-group" id="description"> <h2>Description</h2> <p>Nodes are Godot's building blocks. They can be assigned as the child of another node, resulting in a tree arrangement. A given node can contain any number of nodes as children with the requirement that all siblings (direct children of a node) should have unique names.</p> <p>A tree of nodes is called a <em>scene</em>. Scenes can be saved to the disk and then instantiated into other scenes. This allows for very high flexibility in the architecture and data model of Godot projects.</p> <p><strong>Scene tree:</strong> The <a href="class_scenetree.html#class-scenetree"><span class="std std-ref">SceneTree</span></a> contains the active tree of nodes. When a node is added to the scene tree, it receives the <a href="#class-node-constant-notification-enter-tree"><span class="std std-ref">NOTIFICATION_ENTER_TREE</span></a> notification and its <a href="#class-node-private-method-enter-tree"><span class="std std-ref">_enter_tree</span></a> callback is triggered. Child nodes are always added <em>after</em> their parent node, i.e. the <a href="#class-node-private-method-enter-tree"><span class="std std-ref">_enter_tree</span></a> callback of a parent node will be triggered before its child's.</p> <p>Once all nodes have been added in the scene tree, they receive the <a href="#class-node-constant-notification-ready"><span class="std std-ref">NOTIFICATION_READY</span></a> notification and their respective <a href="#class-node-private-method-ready"><span class="std std-ref">_ready</span></a> callbacks are triggered. For groups of nodes, the <a href="#class-node-private-method-ready"><span class="std std-ref">_ready</span></a> callback is called in reverse order, starting with the children and moving up to the parent nodes.</p> <p>This means that when adding a node to the scene tree, the following order will be used for the callbacks: <a href="#class-node-private-method-enter-tree"><span class="std std-ref">_enter_tree</span></a> of the parent, <a href="#class-node-private-method-enter-tree"><span class="std std-ref">_enter_tree</span></a> of the children, <a href="#class-node-private-method-ready"><span class="std std-ref">_ready</span></a> of the children and finally <a href="#class-node-private-method-ready"><span class="std std-ref">_ready</span></a> of the parent (recursively for the entire scene tree).</p> <p><strong>Processing:</strong> Nodes can override the "process" state, so that they receive a callback on each frame requesting them to process (do something). Normal processing (callback <a href="#class-node-private-method-process"><span class="std std-ref">_process</span></a>, toggled with <a href="#class-node-method-set-process"><span class="std std-ref">set_process</span></a>) happens as fast as possible and is dependent on the frame rate, so the processing time <em>delta</em> (in seconds) is passed as an argument. Physics processing (callback <a href="#class-node-private-method-physics-process"><span class="std std-ref">_physics_process</span></a>, toggled with <a href="#class-node-method-set-physics-process"><span class="std std-ref">set_physics_process</span></a>) happens a fixed number of times per second (60 by default) and is useful for code related to the physics engine.</p> <p>Nodes can also process input events. When present, the <a href="#class-node-private-method-input"><span class="std std-ref">_input</span></a> function will be called for each input that the program receives. In many cases, this can be overkill (unless used for simple projects), and the <a href="#class-node-private-method-unhandled-input"><span class="std std-ref">_unhandled_input</span></a> function might be preferred; it is called when the input event was not handled by anyone else (typically, GUI <a href="class_control.html#class-control"><span class="std std-ref">Control</span></a> nodes), ensuring that the node only receives the events that were meant for it.</p> <p>To keep track of the scene hierarchy (especially when instantiating scenes into other scenes), an "owner" can be set for the node with the <a href="#class-node-property-owner"><span class="std std-ref">owner</span></a> property. This keeps track of who instantiated what. This is mostly useful when writing editors and tools, though.</p> <p>Finally, when a node is freed with <a href="class_object.html#class-object-method-free"><span class="std std-ref">Object.free</span></a> or <a href="#class-node-method-queue-free"><span class="std std-ref">queue_free</span></a>, it will also free all its children.</p> <p><strong>Groups:</strong> Nodes can be added to as many groups as you want to be easy to manage, you could create groups like "enemies" or "collectables" for example, depending on your game. See <a href="#class-node-method-add-to-group"><span class="std std-ref">add_to_group</span></a>, <a href="#class-node-method-is-in-group"><span class="std std-ref">is_in_group</span></a> and <a href="#class-node-method-remove-from-group"><span class="std std-ref">remove_from_group</span></a>. You can then retrieve all nodes in these groups, iterate them and even call methods on groups via the methods on <a href="class_scenetree.html#class-scenetree"><span class="std std-ref">SceneTree</span></a>.</p> <p><strong>Networking with nodes:</strong> After connecting to a server (or making one, see <a href="class_enetmultiplayerpeer.html#class-enetmultiplayerpeer"><span class="std std-ref">ENetMultiplayerPeer</span></a>), it is possible to use the built-in RPC (remote procedure call) system to communicate over the network. By calling <a href="#class-node-method-rpc"><span class="std std-ref">rpc</span></a> with a method name, it will be called locally and in all connected peers (peers = clients and the server that accepts connections). To identify which node receives the RPC call, Godot will use its <a href="class_nodepath.html#class-nodepath"><span class="std std-ref">NodePath</span></a> (make sure node names are the same on all peers). Also, take a look at the high-level networking tutorial and corresponding demos.</p> <p><strong>Note:</strong> The <code>script</code> property is part of the <a href="class_object.html#class-object"><span class="std std-ref">Object</span></a> class, not <strong>Node</strong>. It isn't exposed like most properties but does have a setter and getter (see <a href="class_object.html#class-object-method-set-script"><span class="std std-ref">Object.set_script</span></a> and <a href="class_object.html#class-object-method-get-script"><span class="std std-ref">Object.get_script</span></a>).</p> </section> <section class="classref-introduction-group" id="tutorials"> <h2>Tutorials</h2> <ul class="simple"> <li><a href="../getting_started/step_by_step/nodes_and_scenes.html"><span class="doc">Nodes and scenes</span></a></li> <li><a href="https://github.com/godotengine/godot-demo-projects/">All Demos</a></li> </ul> </section> <section class="classref-reftable-group" id="properties"> <h2>Properties</h2> <table class="colwidths-auto docutils align-default">  <tr>
<td><p><a href="class_string.html#class-string"><span class="std std-ref">String</span></a></p></td> <td><p><a href="#class-node-property-editor-description"><span class="std std-ref">editor_description</span></a></p></td> <td><p><code>""</code></p></td> </tr> <tr>
<td><p><a href="class_multiplayerapi.html#class-multiplayerapi"><span class="std std-ref">MultiplayerAPI</span></a></p></td> <td><p><a href="#class-node-property-multiplayer"><span class="std std-ref">multiplayer</span></a></p></td> <td></td> </tr> <tr>
<td><p><a href="class_stringname.html#class-stringname"><span class="std std-ref">StringName</span></a></p></td> <td><p><a href="#class-node-property-name"><span class="std std-ref">name</span></a></p></td> <td></td> </tr> <tr>
<td><p><a href="#class-node"><span class="std std-ref">Node</span></a></p></td> <td><p><a href="#class-node-property-owner"><span class="std std-ref">owner</span></a></p></td> <td></td> </tr> <tr>
<td><p><a href="#enum-node-processmode"><span class="std std-ref">ProcessMode</span></a></p></td> <td><p><a href="#class-node-property-process-mode"><span class="std std-ref">process_mode</span></a></p></td> <td><p><code>0</code></p></td> </tr> <tr>
<td><p><a href="class_int.html#class-int"><span class="std std-ref">int</span></a></p></td> <td><p><a href="#class-node-property-process-physics-priority"><span class="std std-ref">process_physics_priority</span></a></p></td> <td><p><code>0</code></p></td> </tr> <tr>
<td><p><a href="class_int.html#class-int"><span class="std std-ref">int</span></a></p></td> <td><p><a href="#class-node-property-process-priority"><span class="std std-ref">process_priority</span></a></p></td> <td><p><code>0</code></p></td> </tr> <tr>
<td><p><a href="#enum-node-processthreadgroup"><span class="std std-ref">ProcessThreadGroup</span></a></p></td> <td><p><a href="#class-node-property-process-thread-group"><span class="std std-ref">process_thread_group</span></a></p></td> <td><p><code>0</code></p></td> </tr> <tr>
<td><p><a href="class_int.html#class-int"><span class="std std-ref">int</span></a></p></td> <td><p><a href="#class-node-property-process-thread-group-order"><span class="std std-ref">process_thread_group_order</span></a></p></td> <td></td> </tr> <tr>
<td><p><abbr title="This value is an integer composed as a bitmask of the following flags.">BitField</abbr>&lt;<a href="#enum-node-processthreadmessages"><span class="std std-ref">ProcessThreadMessages</span></a>&gt;</p></td> <td><p><a href="#class-node-property-process-thread-messages"><span class="std std-ref">process_thread_messages</span></a></p></td> <td></td> </tr> <tr>
<td><p><a href="class_string.html#class-string"><span class="std std-ref">String</span></a></p></td> <td><p><a href="#class-node-property-scene-file-path"><span class="std std-ref">scene_file_path</span></a></p></td> <td></td> </tr> <tr>
<td><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a></p></td> <td><p><a href="#class-node-property-unique-name-in-owner"><span class="std std-ref">unique_name_in_owner</span></a></p></td> <td><p><code>false</code></p></td> </tr>  </table> </section> <section class="classref-reftable-group" id="methods"> <h2>Methods</h2> <table class="colwidths-auto docutils align-default">  <tr>
<td><p>void</p></td> <td><p><a href="#class-node-private-method-enter-tree"><span class="std std-ref">_enter_tree</span></a> <strong>(</strong> <strong>)</strong> <abbr title="This method should typically be overridden by the user to have any effect.">virtual</abbr></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-node-private-method-exit-tree"><span class="std std-ref">_exit_tree</span></a> <strong>(</strong> <strong>)</strong> <abbr title="This method should typically be overridden by the user to have any effect.">virtual</abbr></p></td> </tr> <tr>
<td><p><a href="class_packedstringarray.html#class-packedstringarray"><span class="std std-ref">PackedStringArray</span></a></p></td> <td><p><a href="#class-node-private-method-get-configuration-warnings"><span class="std std-ref">_get_configuration_warnings</span></a> <strong>(</strong> <strong>)</strong> <abbr title="This method should typically be overridden by the user to have any effect.">virtual</abbr> <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-node-private-method-input"><span class="std std-ref">_input</span></a> <strong>(</strong> <a href="class_inputevent.html#class-inputevent"><span class="std std-ref">InputEvent</span></a> event <strong>)</strong> <abbr title="This method should typically be overridden by the user to have any effect.">virtual</abbr></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-node-private-method-physics-process"><span class="std std-ref">_physics_process</span></a> <strong>(</strong> <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> delta <strong>)</strong> <abbr title="This method should typically be overridden by the user to have any effect.">virtual</abbr></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-node-private-method-process"><span class="std std-ref">_process</span></a> <strong>(</strong> <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> delta <strong>)</strong> <abbr title="This method should typically be overridden by the user to have any effect.">virtual</abbr></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-node-private-method-ready"><span class="std std-ref">_ready</span></a> <strong>(</strong> <strong>)</strong> <abbr title="This method should typically be overridden by the user to have any effect.">virtual</abbr></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-node-private-method-shortcut-input"><span class="std std-ref">_shortcut_input</span></a> <strong>(</strong> <a href="class_inputevent.html#class-inputevent"><span class="std std-ref">InputEvent</span></a> event <strong>)</strong> <abbr title="This method should typically be overridden by the user to have any effect.">virtual</abbr></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-node-private-method-unhandled-input"><span class="std std-ref">_unhandled_input</span></a> <strong>(</strong> <a href="class_inputevent.html#class-inputevent"><span class="std std-ref">InputEvent</span></a> event <strong>)</strong> <abbr title="This method should typically be overridden by the user to have any effect.">virtual</abbr></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-node-private-method-unhandled-key-input"><span class="std std-ref">_unhandled_key_input</span></a> <strong>(</strong> <a href="class_inputevent.html#class-inputevent"><span class="std std-ref">InputEvent</span></a> event <strong>)</strong> <abbr title="This method should typically be overridden by the user to have any effect.">virtual</abbr></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-node-method-add-child"><span class="std std-ref">add_child</span></a> <strong>(</strong> <a href="#class-node"><span class="std std-ref">Node</span></a> node, <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> force_readable_name=false, <a href="#enum-node-internalmode"><span class="std std-ref">InternalMode</span></a> internal=0 <strong>)</strong></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-node-method-add-sibling"><span class="std std-ref">add_sibling</span></a> <strong>(</strong> <a href="#class-node"><span class="std std-ref">Node</span></a> sibling, <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> force_readable_name=false <strong>)</strong></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-node-method-add-to-group"><span class="std std-ref">add_to_group</span></a> <strong>(</strong> <a href="class_stringname.html#class-stringname"><span class="std std-ref">StringName</span></a> group, <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> persistent=false <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_variant.html#class-variant"><span class="std std-ref">Variant</span></a></p></td> <td><p><a href="#class-node-method-call-deferred-thread-group"><span class="std std-ref">call_deferred_thread_group</span></a> <strong>(</strong> <a href="class_stringname.html#class-stringname"><span class="std std-ref">StringName</span></a> method, ... <strong>)</strong> <abbr title="This method accepts any number of arguments after the ones described here.">vararg</abbr></p></td> </tr> <tr>
<td><p><a href="class_variant.html#class-variant"><span class="std std-ref">Variant</span></a></p></td> <td><p><a href="#class-node-method-call-thread-safe"><span class="std std-ref">call_thread_safe</span></a> <strong>(</strong> <a href="class_stringname.html#class-stringname"><span class="std std-ref">StringName</span></a> method, ... <strong>)</strong> <abbr title="This method accepts any number of arguments after the ones described here.">vararg</abbr></p></td> </tr> <tr>
<td><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a></p></td> <td><p><a href="#class-node-method-can-process"><span class="std std-ref">can_process</span></a> <strong>(</strong> <strong>)</strong> <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr></p></td> </tr> <tr>
<td><p><a href="class_tween.html#class-tween"><span class="std std-ref">Tween</span></a></p></td> <td><p><a href="#class-node-method-create-tween"><span class="std std-ref">create_tween</span></a> <strong>(</strong> <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="#class-node"><span class="std std-ref">Node</span></a></p></td> <td><p><a href="#class-node-method-duplicate"><span class="std std-ref">duplicate</span></a> <strong>(</strong> <a href="class_int.html#class-int"><span class="std std-ref">int</span></a> flags=15 <strong>)</strong> <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr></p></td> </tr> <tr>
<td><p><a href="#class-node"><span class="std std-ref">Node</span></a></p></td> <td><p><a href="#class-node-method-find-child"><span class="std std-ref">find_child</span></a> <strong>(</strong> <a href="class_string.html#class-string"><span class="std std-ref">String</span></a> pattern, <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> recursive=true, <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> owned=true <strong>)</strong> <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr></p></td> </tr> <tr>
<td><p><a href="#class-node"><span class="std std-ref">Node[]</span></a></p></td> <td><p><a href="#class-node-method-find-children"><span class="std std-ref">find_children</span></a> <strong>(</strong> <a href="class_string.html#class-string"><span class="std std-ref">String</span></a> pattern, <a href="class_string.html#class-string"><span class="std std-ref">String</span></a> type="", <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> recursive=true, <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> owned=true <strong>)</strong> <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr></p></td> </tr> <tr>
<td><p><a href="#class-node"><span class="std std-ref">Node</span></a></p></td> <td><p><a href="#class-node-method-find-parent"><span class="std std-ref">find_parent</span></a> <strong>(</strong> <a href="class_string.html#class-string"><span class="std std-ref">String</span></a> pattern <strong>)</strong> <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr></p></td> </tr> <tr>
<td><p><a href="#class-node"><span class="std std-ref">Node</span></a></p></td> <td><p><a href="#class-node-method-get-child"><span class="std std-ref">get_child</span></a> <strong>(</strong> <a href="class_int.html#class-int"><span class="std std-ref">int</span></a> idx, <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> include_internal=false <strong>)</strong> <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr></p></td> </tr> <tr>
<td><p><a href="class_int.html#class-int"><span class="std std-ref">int</span></a></p></td> <td><p><a href="#class-node-method-get-child-count"><span class="std std-ref">get_child_count</span></a> <strong>(</strong> <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> include_internal=false <strong>)</strong> <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr></p></td> </tr> <tr>
<td><p><a href="#class-node"><span class="std std-ref">Node[]</span></a></p></td> <td><p><a href="#class-node-method-get-children"><span class="std std-ref">get_children</span></a> <strong>(</strong> <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> include_internal=false <strong>)</strong> <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr></p></td> </tr> <tr>
<td><p><a href="class_stringname.html#class-stringname"><span class="std std-ref">StringName[]</span></a></p></td> <td><p><a href="#class-node-method-get-groups"><span class="std std-ref">get_groups</span></a> <strong>(</strong> <strong>)</strong> <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr></p></td> </tr> <tr>
<td><p><a href="class_int.html#class-int"><span class="std std-ref">int</span></a></p></td> <td><p><a href="#class-node-method-get-index"><span class="std std-ref">get_index</span></a> <strong>(</strong> <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> include_internal=false <strong>)</strong> <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr></p></td> </tr> <tr>
<td><p><a href="class_window.html#class-window"><span class="std std-ref">Window</span></a></p></td> <td><p><a href="#class-node-method-get-last-exclusive-window"><span class="std std-ref">get_last_exclusive_window</span></a> <strong>(</strong> <strong>)</strong> <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr></p></td> </tr> <tr>
<td><p><a href="class_int.html#class-int"><span class="std std-ref">int</span></a></p></td> <td><p><a href="#class-node-method-get-multiplayer-authority"><span class="std std-ref">get_multiplayer_authority</span></a> <strong>(</strong> <strong>)</strong> <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr></p></td> </tr> <tr>
<td><p><a href="#class-node"><span class="std std-ref">Node</span></a></p></td> <td><p><a href="#class-node-method-get-node"><span class="std std-ref">get_node</span></a> <strong>(</strong> <a href="class_nodepath.html#class-nodepath"><span class="std std-ref">NodePath</span></a> path <strong>)</strong> <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr></p></td> </tr> <tr>
<td><p><a href="class_array.html#class-array"><span class="std std-ref">Array</span></a></p></td> <td><p><a href="#class-node-method-get-node-and-resource"><span class="std std-ref">get_node_and_resource</span></a> <strong>(</strong> <a href="class_nodepath.html#class-nodepath"><span class="std std-ref">NodePath</span></a> path <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="#class-node"><span class="std std-ref">Node</span></a></p></td> <td><p><a href="#class-node-method-get-node-or-null"><span class="std std-ref">get_node_or_null</span></a> <strong>(</strong> <a href="class_nodepath.html#class-nodepath"><span class="std std-ref">NodePath</span></a> path <strong>)</strong> <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr></p></td> </tr> <tr>
<td><p><a href="#class-node"><span class="std std-ref">Node</span></a></p></td> <td><p><a href="#class-node-method-get-parent"><span class="std std-ref">get_parent</span></a> <strong>(</strong> <strong>)</strong> <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr></p></td> </tr> <tr>
<td><p><a href="class_nodepath.html#class-nodepath"><span class="std std-ref">NodePath</span></a></p></td> <td><p><a href="#class-node-method-get-path"><span class="std std-ref">get_path</span></a> <strong>(</strong> <strong>)</strong> <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr></p></td> </tr> <tr>
<td><p><a href="class_nodepath.html#class-nodepath"><span class="std std-ref">NodePath</span></a></p></td> <td><p><a href="#class-node-method-get-path-to"><span class="std std-ref">get_path_to</span></a> <strong>(</strong> <a href="#class-node"><span class="std std-ref">Node</span></a> node, <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> use_unique_path=false <strong>)</strong> <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr></p></td> </tr> <tr>
<td><p><a href="class_float.html#class-float"><span class="std std-ref">float</span></a></p></td> <td><p><a href="#class-node-method-get-physics-process-delta-time"><span class="std std-ref">get_physics_process_delta_time</span></a> <strong>(</strong> <strong>)</strong> <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr></p></td> </tr> <tr>
<td><p><a href="class_float.html#class-float"><span class="std std-ref">float</span></a></p></td> <td><p><a href="#class-node-method-get-process-delta-time"><span class="std std-ref">get_process_delta_time</span></a> <strong>(</strong> <strong>)</strong> <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr></p></td> </tr> <tr>
<td><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a></p></td> <td><p><a href="#class-node-method-get-scene-instance-load-placeholder"><span class="std std-ref">get_scene_instance_load_placeholder</span></a> <strong>(</strong> <strong>)</strong> <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr></p></td> </tr> <tr>
<td><p><a href="class_scenetree.html#class-scenetree"><span class="std std-ref">SceneTree</span></a></p></td> <td><p><a href="#class-node-method-get-tree"><span class="std std-ref">get_tree</span></a> <strong>(</strong> <strong>)</strong> <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr></p></td> </tr> <tr>
<td><p><a href="class_string.html#class-string"><span class="std std-ref">String</span></a></p></td> <td><p><a href="#class-node-method-get-tree-string"><span class="std std-ref">get_tree_string</span></a> <strong>(</strong> <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_string.html#class-string"><span class="std std-ref">String</span></a></p></td> <td><p><a href="#class-node-method-get-tree-string-pretty"><span class="std std-ref">get_tree_string_pretty</span></a> <strong>(</strong> <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_viewport.html#class-viewport"><span class="std std-ref">Viewport</span></a></p></td> <td><p><a href="#class-node-method-get-viewport"><span class="std std-ref">get_viewport</span></a> <strong>(</strong> <strong>)</strong> <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr></p></td> </tr> <tr>
<td><p><a href="class_window.html#class-window"><span class="std std-ref">Window</span></a></p></td> <td><p><a href="#class-node-method-get-window"><span class="std std-ref">get_window</span></a> <strong>(</strong> <strong>)</strong> <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr></p></td> </tr> <tr>
<td><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a></p></td> <td><p><a href="#class-node-method-has-node"><span class="std std-ref">has_node</span></a> <strong>(</strong> <a href="class_nodepath.html#class-nodepath"><span class="std std-ref">NodePath</span></a> path <strong>)</strong> <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr></p></td> </tr> <tr>
<td><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a></p></td> <td><p><a href="#class-node-method-has-node-and-resource"><span class="std std-ref">has_node_and_resource</span></a> <strong>(</strong> <a href="class_nodepath.html#class-nodepath"><span class="std std-ref">NodePath</span></a> path <strong>)</strong> <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr></p></td> </tr> <tr>
<td><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a></p></td> <td><p><a href="#class-node-method-is-ancestor-of"><span class="std std-ref">is_ancestor_of</span></a> <strong>(</strong> <a href="#class-node"><span class="std std-ref">Node</span></a> node <strong>)</strong> <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr></p></td> </tr> <tr>
<td><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a></p></td> <td><p><a href="#class-node-method-is-displayed-folded"><span class="std std-ref">is_displayed_folded</span></a> <strong>(</strong> <strong>)</strong> <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr></p></td> </tr> <tr>
<td><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a></p></td> <td><p><a href="#class-node-method-is-editable-instance"><span class="std std-ref">is_editable_instance</span></a> <strong>(</strong> <a href="#class-node"><span class="std std-ref">Node</span></a> node <strong>)</strong> <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr></p></td> </tr> <tr>
<td><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a></p></td> <td><p><a href="#class-node-method-is-greater-than"><span class="std std-ref">is_greater_than</span></a> <strong>(</strong> <a href="#class-node"><span class="std std-ref">Node</span></a> node <strong>)</strong> <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr></p></td> </tr> <tr>
<td><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a></p></td> <td><p><a href="#class-node-method-is-in-group"><span class="std std-ref">is_in_group</span></a> <strong>(</strong> <a href="class_stringname.html#class-stringname"><span class="std std-ref">StringName</span></a> group <strong>)</strong> <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr></p></td> </tr> <tr>
<td><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a></p></td> <td><p><a href="#class-node-method-is-inside-tree"><span class="std std-ref">is_inside_tree</span></a> <strong>(</strong> <strong>)</strong> <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr></p></td> </tr> <tr>
<td><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a></p></td> <td><p><a href="#class-node-method-is-multiplayer-authority"><span class="std std-ref">is_multiplayer_authority</span></a> <strong>(</strong> <strong>)</strong> <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr></p></td> </tr> <tr>
<td><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a></p></td> <td><p><a href="#class-node-method-is-node-ready"><span class="std std-ref">is_node_ready</span></a> <strong>(</strong> <strong>)</strong> <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr></p></td> </tr> <tr>
<td><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a></p></td> <td><p><a href="#class-node-method-is-physics-processing"><span class="std std-ref">is_physics_processing</span></a> <strong>(</strong> <strong>)</strong> <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr></p></td> </tr> <tr>
<td><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a></p></td> <td><p><a href="#class-node-method-is-physics-processing-internal"><span class="std std-ref">is_physics_processing_internal</span></a> <strong>(</strong> <strong>)</strong> <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr></p></td> </tr> <tr>
<td><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a></p></td> <td><p><a href="#class-node-method-is-processing"><span class="std std-ref">is_processing</span></a> <strong>(</strong> <strong>)</strong> <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr></p></td> </tr> <tr>
<td><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a></p></td> <td><p><a href="#class-node-method-is-processing-input"><span class="std std-ref">is_processing_input</span></a> <strong>(</strong> <strong>)</strong> <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr></p></td> </tr> <tr>
<td><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a></p></td> <td><p><a href="#class-node-method-is-processing-internal"><span class="std std-ref">is_processing_internal</span></a> <strong>(</strong> <strong>)</strong> <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr></p></td> </tr> <tr>
<td><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a></p></td> <td><p><a href="#class-node-method-is-processing-shortcut-input"><span class="std std-ref">is_processing_shortcut_input</span></a> <strong>(</strong> <strong>)</strong> <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr></p></td> </tr> <tr>
<td><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a></p></td> <td><p><a href="#class-node-method-is-processing-unhandled-input"><span class="std std-ref">is_processing_unhandled_input</span></a> <strong>(</strong> <strong>)</strong> <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr></p></td> </tr> <tr>
<td><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a></p></td> <td><p><a href="#class-node-method-is-processing-unhandled-key-input"><span class="std std-ref">is_processing_unhandled_key_input</span></a> <strong>(</strong> <strong>)</strong> <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-node-method-move-child"><span class="std std-ref">move_child</span></a> <strong>(</strong> <a href="#class-node"><span class="std std-ref">Node</span></a> child_node, <a href="class_int.html#class-int"><span class="std std-ref">int</span></a> to_index <strong>)</strong></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-node-method-notify-deferred-thread-group"><span class="std std-ref">notify_deferred_thread_group</span></a> <strong>(</strong> <a href="class_int.html#class-int"><span class="std std-ref">int</span></a> what <strong>)</strong></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-node-method-notify-thread-safe"><span class="std std-ref">notify_thread_safe</span></a> <strong>(</strong> <a href="class_int.html#class-int"><span class="std std-ref">int</span></a> what <strong>)</strong></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-node-method-print-orphan-nodes"><span class="std std-ref">print_orphan_nodes</span></a> <strong>(</strong> <strong>)</strong> <abbr title="This method doesn't need an instance to be called, so it can be called directly using the class name.">static</abbr></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-node-method-print-tree"><span class="std std-ref">print_tree</span></a> <strong>(</strong> <strong>)</strong></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-node-method-print-tree-pretty"><span class="std std-ref">print_tree_pretty</span></a> <strong>(</strong> <strong>)</strong></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-node-method-propagate-call"><span class="std std-ref">propagate_call</span></a> <strong>(</strong> <a href="class_stringname.html#class-stringname"><span class="std std-ref">StringName</span></a> method, <a href="class_array.html#class-array"><span class="std std-ref">Array</span></a> args=[], <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> parent_first=false <strong>)</strong></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-node-method-propagate-notification"><span class="std std-ref">propagate_notification</span></a> <strong>(</strong> <a href="class_int.html#class-int"><span class="std std-ref">int</span></a> what <strong>)</strong></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-node-method-queue-free"><span class="std std-ref">queue_free</span></a> <strong>(</strong> <strong>)</strong></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-node-method-remove-child"><span class="std std-ref">remove_child</span></a> <strong>(</strong> <a href="#class-node"><span class="std std-ref">Node</span></a> node <strong>)</strong></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-node-method-remove-from-group"><span class="std std-ref">remove_from_group</span></a> <strong>(</strong> <a href="class_stringname.html#class-stringname"><span class="std std-ref">StringName</span></a> group <strong>)</strong></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-node-method-reparent"><span class="std std-ref">reparent</span></a> <strong>(</strong> <a href="#class-node"><span class="std std-ref">Node</span></a> new_parent, <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> keep_global_transform=true <strong>)</strong></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-node-method-replace-by"><span class="std std-ref">replace_by</span></a> <strong>(</strong> <a href="#class-node"><span class="std std-ref">Node</span></a> node, <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> keep_groups=false <strong>)</strong></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-node-method-request-ready"><span class="std std-ref">request_ready</span></a> <strong>(</strong> <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_%40globalscope.html#enum-globalscope-error"><span class="std std-ref">Error</span></a></p></td> <td><p><a href="#class-node-method-rpc"><span class="std std-ref">rpc</span></a> <strong>(</strong> <a href="class_stringname.html#class-stringname"><span class="std std-ref">StringName</span></a> method, ... <strong>)</strong> <abbr title="This method accepts any number of arguments after the ones described here.">vararg</abbr></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-node-method-rpc-config"><span class="std std-ref">rpc_config</span></a> <strong>(</strong> <a href="class_stringname.html#class-stringname"><span class="std std-ref">StringName</span></a> method, <a href="class_variant.html#class-variant"><span class="std std-ref">Variant</span></a> config <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_%40globalscope.html#enum-globalscope-error"><span class="std std-ref">Error</span></a></p></td> <td><p><a href="#class-node-method-rpc-id"><span class="std std-ref">rpc_id</span></a> <strong>(</strong> <a href="class_int.html#class-int"><span class="std std-ref">int</span></a> peer_id, <a href="class_stringname.html#class-stringname"><span class="std std-ref">StringName</span></a> method, ... <strong>)</strong> <abbr title="This method accepts any number of arguments after the ones described here.">vararg</abbr></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-node-method-set-deferred-thread-group"><span class="std std-ref">set_deferred_thread_group</span></a> <strong>(</strong> <a href="class_stringname.html#class-stringname"><span class="std std-ref">StringName</span></a> property, <a href="class_variant.html#class-variant"><span class="std std-ref">Variant</span></a> value <strong>)</strong></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-node-method-set-display-folded"><span class="std std-ref">set_display_folded</span></a> <strong>(</strong> <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> fold <strong>)</strong></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-node-method-set-editable-instance"><span class="std std-ref">set_editable_instance</span></a> <strong>(</strong> <a href="#class-node"><span class="std std-ref">Node</span></a> node, <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> is_editable <strong>)</strong></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-node-method-set-multiplayer-authority"><span class="std std-ref">set_multiplayer_authority</span></a> <strong>(</strong> <a href="class_int.html#class-int"><span class="std std-ref">int</span></a> id, <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> recursive=true <strong>)</strong></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-node-method-set-physics-process"><span class="std std-ref">set_physics_process</span></a> <strong>(</strong> <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> enable <strong>)</strong></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-node-method-set-physics-process-internal"><span class="std std-ref">set_physics_process_internal</span></a> <strong>(</strong> <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> enable <strong>)</strong></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-node-method-set-process"><span class="std std-ref">set_process</span></a> <strong>(</strong> <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> enable <strong>)</strong></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-node-method-set-process-input"><span class="std std-ref">set_process_input</span></a> <strong>(</strong> <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> enable <strong>)</strong></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-node-method-set-process-internal"><span class="std std-ref">set_process_internal</span></a> <strong>(</strong> <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> enable <strong>)</strong></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-node-method-set-process-shortcut-input"><span class="std std-ref">set_process_shortcut_input</span></a> <strong>(</strong> <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> enable <strong>)</strong></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-node-method-set-process-unhandled-input"><span class="std std-ref">set_process_unhandled_input</span></a> <strong>(</strong> <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> enable <strong>)</strong></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-node-method-set-process-unhandled-key-input"><span class="std std-ref">set_process_unhandled_key_input</span></a> <strong>(</strong> <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> enable <strong>)</strong></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-node-method-set-scene-instance-load-placeholder"><span class="std std-ref">set_scene_instance_load_placeholder</span></a> <strong>(</strong> <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> load_placeholder <strong>)</strong></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-node-method-set-thread-safe"><span class="std std-ref">set_thread_safe</span></a> <strong>(</strong> <a href="class_stringname.html#class-stringname"><span class="std std-ref">StringName</span></a> property, <a href="class_variant.html#class-variant"><span class="std std-ref">Variant</span></a> value <strong>)</strong></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-node-method-update-configuration-warnings"><span class="std std-ref">update_configuration_warnings</span></a> <strong>(</strong> <strong>)</strong></p></td> </tr>  </table> </section>  <section class="classref-descriptions-group" id="signals"> <h2>Signals</h2> <h3 id="class-node-signal-child-entered-tree">child_entered_tree ( <a href="#class-node"><span class="std std-ref">Node</span></a> node )</h3> <p>Emitted when the child <code>node</code> enters the <a href="class_scenetree.html#class-scenetree"><span class="std std-ref">SceneTree</span></a>, usually because this node entered the tree (see <a href="#class-node-signal-tree-entered"><span class="std std-ref">tree_entered</span></a>), or <a href="#class-node-method-add-child"><span class="std std-ref">add_child</span></a> has been called.</p> <p>This signal is emitted <em>after</em> the child node's own <a href="#class-node-constant-notification-enter-tree"><span class="std std-ref">NOTIFICATION_ENTER_TREE</span></a> and <a href="#class-node-signal-tree-entered"><span class="std std-ref">tree_entered</span></a>.</p>  <h3 id="class-node-signal-child-exiting-tree">child_exiting_tree ( <a href="#class-node"><span class="std std-ref">Node</span></a> node )</h3> <p>Emitted when the child <code>node</code> is about to exit the <a href="class_scenetree.html#class-scenetree"><span class="std std-ref">SceneTree</span></a>, usually because this node is exiting the tree (see <a href="#class-node-signal-tree-exiting"><span class="std std-ref">tree_exiting</span></a>), or because the child <code>node</code> is being removed or freed.</p> <p>When this signal is received, the child <code>node</code> is still accessible inside the tree. This signal is emitted <em>after</em> the child node's own <a href="#class-node-signal-tree-exiting"><span class="std std-ref">tree_exiting</span></a> and <a href="#class-node-constant-notification-exit-tree"><span class="std std-ref">NOTIFICATION_EXIT_TREE</span></a>.</p>  <h3 id="class-node-signal-child-order-changed">child_order_changed ( )</h3> <p>Emitted when the list of children is changed. This happens when child nodes are added, moved or removed.</p>  <h3 id="class-node-signal-ready">ready ( )</h3> <p>Emitted when the node is considered ready, after <a href="#class-node-private-method-ready"><span class="std std-ref">_ready</span></a> is called.</p>  <h3 id="class-node-signal-renamed">renamed ( )</h3> <p>Emitted when the node's <a href="#class-node-property-name"><span class="std std-ref">name</span></a> is changed, if the node is inside the tree.</p>  <h3 id="class-node-signal-replacing-by">replacing_by ( <a href="#class-node"><span class="std std-ref">Node</span></a> node )</h3> <p>Emitted when this node is being replaced by the <code>node</code>, see <a href="#class-node-method-replace-by"><span class="std std-ref">replace_by</span></a>.</p> <p>This signal is emitted <em>after</em> <code>node</code> has been added as a child of the original parent node, but <em>before</em> all original child nodes have been reparented to <code>node</code>.</p>  <h3 id="class-node-signal-tree-entered">tree_entered ( )</h3> <p>Emitted when the node enters the tree.</p> <p>This signal is emitted <em>after</em> the related <a href="#class-node-constant-notification-enter-tree"><span class="std std-ref">NOTIFICATION_ENTER_TREE</span></a> notification.</p>  <h3 id="class-node-signal-tree-exited">tree_exited ( )</h3> <p>Emitted after the node exits the tree and is no longer active.</p> <p>This signal is emitted <em>after</em> the related <a href="#class-node-constant-notification-exit-tree"><span class="std std-ref">NOTIFICATION_EXIT_TREE</span></a> notification.</p>  <h3 id="class-node-signal-tree-exiting">tree_exiting ( )</h3> <p>Emitted when the node is just about to exit the tree. The node is still valid. As such, this is the right place for de-initialization (or a "destructor", if you will).</p> <p>This signal is emitted <em>after</em> the node's <a href="#class-node-private-method-exit-tree"><span class="std std-ref">_exit_tree</span></a>, and <em>before</em> the related <a href="#class-node-constant-notification-exit-tree"><span class="std std-ref">NOTIFICATION_EXIT_TREE</span></a>.</p> </section>  <section class="classref-descriptions-group" id="enumerations"> <h2>Enumerations</h2> <h3 id="enum-node-processmode">enum ProcessMode:</h3> <h3 id="class-node-constant-process-mode-inherit">
<a href="#enum-node-processmode"><span class="std std-ref">ProcessMode</span></a> PROCESS_MODE_INHERIT = <code>0</code>
</h3> <p>Inherits <a href="#class-node-property-process-mode"><span class="std std-ref">process_mode</span></a> from the node's parent. For the root node, it is equivalent to <a href="#class-node-constant-process-mode-pausable"><span class="std std-ref">PROCESS_MODE_PAUSABLE</span></a>. This is the default for any newly created node.</p> <h3 id="class-node-constant-process-mode-pausable">
<a href="#enum-node-processmode"><span class="std std-ref">ProcessMode</span></a> PROCESS_MODE_PAUSABLE = <code>1</code>
</h3> <p>Stops processing when <a href="class_scenetree.html#class-scenetree-property-paused"><span class="std std-ref">SceneTree.paused</span></a> is <code>true</code>. This is the inverse of <a href="#class-node-constant-process-mode-when-paused"><span class="std std-ref">PROCESS_MODE_WHEN_PAUSED</span></a>.</p> <h3 id="class-node-constant-process-mode-when-paused">
<a href="#enum-node-processmode"><span class="std std-ref">ProcessMode</span></a> PROCESS_MODE_WHEN_PAUSED = <code>2</code>
</h3> <p>Process <strong>only</strong> when <a href="class_scenetree.html#class-scenetree-property-paused"><span class="std std-ref">SceneTree.paused</span></a> is <code>true</code>. This is the inverse of <a href="#class-node-constant-process-mode-pausable"><span class="std std-ref">PROCESS_MODE_PAUSABLE</span></a>.</p> <h3 id="class-node-constant-process-mode-always">
<a href="#enum-node-processmode"><span class="std std-ref">ProcessMode</span></a> PROCESS_MODE_ALWAYS = <code>3</code>
</h3> <p>Always process. Keeps processing, ignoring <a href="class_scenetree.html#class-scenetree-property-paused"><span class="std std-ref">SceneTree.paused</span></a>. This is the inverse of <a href="#class-node-constant-process-mode-disabled"><span class="std std-ref">PROCESS_MODE_DISABLED</span></a>.</p> <h3 id="class-node-constant-process-mode-disabled">
<a href="#enum-node-processmode"><span class="std std-ref">ProcessMode</span></a> PROCESS_MODE_DISABLED = <code>4</code>
</h3> <p>Never process. Completely disables processing, ignoring <a href="class_scenetree.html#class-scenetree-property-paused"><span class="std std-ref">SceneTree.paused</span></a>. This is the inverse of <a href="#class-node-constant-process-mode-always"><span class="std std-ref">PROCESS_MODE_ALWAYS</span></a>.</p>  <h3 id="enum-node-processthreadgroup">enum ProcessThreadGroup:</h3> <h3 id="class-node-constant-process-thread-group-inherit">
<a href="#enum-node-processthreadgroup"><span class="std std-ref">ProcessThreadGroup</span></a> PROCESS_THREAD_GROUP_INHERIT = <code>0</code>
</h3> <p>Process this node based on the thread group mode of the first parent (or grandparent) node that has a thread group mode that is not inherit. See <a href="#class-node-property-process-thread-group"><span class="std std-ref">process_thread_group</span></a> for more information.</p> <h3 id="class-node-constant-process-thread-group-main-thread">
<a href="#enum-node-processthreadgroup"><span class="std std-ref">ProcessThreadGroup</span></a> PROCESS_THREAD_GROUP_MAIN_THREAD = <code>1</code>
</h3> <p>Process this node (and child nodes set to inherit) on the main thread. See <a href="#class-node-property-process-thread-group"><span class="std std-ref">process_thread_group</span></a> for more information.</p> <h3 id="class-node-constant-process-thread-group-sub-thread">
<a href="#enum-node-processthreadgroup"><span class="std std-ref">ProcessThreadGroup</span></a> PROCESS_THREAD_GROUP_SUB_THREAD = <code>2</code>
</h3> <p>Process this node (and child nodes set to inherit) on a sub-thread. See <a href="#class-node-property-process-thread-group"><span class="std std-ref">process_thread_group</span></a> for more information.</p>  <h3 id="enum-node-processthreadmessages">flags ProcessThreadMessages:</h3> <h3 id="class-node-constant-flag-process-thread-messages">
<a href="#enum-node-processthreadmessages"><span class="std std-ref">ProcessThreadMessages</span></a> FLAG_PROCESS_THREAD_MESSAGES = <code>1</code>
</h3> <h3 id="class-node-constant-flag-process-thread-messages-physics">
<a href="#enum-node-processthreadmessages"><span class="std std-ref">ProcessThreadMessages</span></a> FLAG_PROCESS_THREAD_MESSAGES_PHYSICS = <code>2</code>
</h3> <h3 id="class-node-constant-flag-process-thread-messages-all">
<a href="#enum-node-processthreadmessages"><span class="std std-ref">ProcessThreadMessages</span></a> FLAG_PROCESS_THREAD_MESSAGES_ALL = <code>3</code>
</h3>  <h3 id="enum-node-duplicateflags">enum DuplicateFlags:</h3> <h3 id="class-node-constant-duplicate-signals">
<a href="#enum-node-duplicateflags"><span class="std std-ref">DuplicateFlags</span></a> DUPLICATE_SIGNALS = <code>1</code>
</h3> <p>Duplicate the node's signal connections.</p> <h3 id="class-node-constant-duplicate-groups">
<a href="#enum-node-duplicateflags"><span class="std std-ref">DuplicateFlags</span></a> DUPLICATE_GROUPS = <code>2</code>
</h3> <p>Duplicate the node's groups.</p> <h3 id="class-node-constant-duplicate-scripts">
<a href="#enum-node-duplicateflags"><span class="std std-ref">DuplicateFlags</span></a> DUPLICATE_SCRIPTS = <code>4</code>
</h3> <p>Duplicate the node's script (including the ancestor's script, if combined with <a href="#class-node-constant-duplicate-use-instantiation"><span class="std std-ref">DUPLICATE_USE_INSTANTIATION</span></a>).</p> <h3 id="class-node-constant-duplicate-use-instantiation">
<a href="#enum-node-duplicateflags"><span class="std std-ref">DuplicateFlags</span></a> DUPLICATE_USE_INSTANTIATION = <code>8</code>
</h3> <p>Duplicate using <a href="class_packedscene.html#class-packedscene-method-instantiate"><span class="std std-ref">PackedScene.instantiate</span></a>. If the node comes from a scene saved on disk, re-uses <a href="class_packedscene.html#class-packedscene-method-instantiate"><span class="std std-ref">PackedScene.instantiate</span></a> as the base for the duplicated node and its children.</p>  <h3 id="enum-node-internalmode">enum InternalMode:</h3> <h3 id="class-node-constant-internal-mode-disabled">
<a href="#enum-node-internalmode"><span class="std std-ref">InternalMode</span></a> INTERNAL_MODE_DISABLED = <code>0</code>
</h3> <p>The node will not be internal.</p> <h3 id="class-node-constant-internal-mode-front">
<a href="#enum-node-internalmode"><span class="std std-ref">InternalMode</span></a> INTERNAL_MODE_FRONT = <code>1</code>
</h3> <p>The node will be placed at the beginning of the parent's children, before any non-internal sibling.</p> <h3 id="class-node-constant-internal-mode-back">
<a href="#enum-node-internalmode"><span class="std std-ref">InternalMode</span></a> INTERNAL_MODE_BACK = <code>2</code>
</h3> <p>The node will be placed at the end of the parent's children, after any non-internal sibling.</p> </section>  <section class="classref-descriptions-group" id="constants"> <h2>Constants</h2> <h3 id="class-node-constant-notification-enter-tree">NOTIFICATION_ENTER_TREE = <code>10</code>
</h3> <p>Notification received when the node enters a <a href="class_scenetree.html#class-scenetree"><span class="std std-ref">SceneTree</span></a>. See <a href="#class-node-private-method-enter-tree"><span class="std std-ref">_enter_tree</span></a>.</p> <p>This notification is received <em>before</em> the related <a href="#class-node-signal-tree-entered"><span class="std std-ref">tree_entered</span></a> signal.</p> <h3 id="class-node-constant-notification-exit-tree">NOTIFICATION_EXIT_TREE = <code>11</code>
</h3> <p>Notification received when the node is about to exit a <a href="class_scenetree.html#class-scenetree"><span class="std std-ref">SceneTree</span></a>. See <a href="#class-node-private-method-exit-tree"><span class="std std-ref">_exit_tree</span></a>.</p> <p>This notification is received <em>after</em> the related <a href="#class-node-signal-tree-exiting"><span class="std std-ref">tree_exiting</span></a> signal.</p> <h3 id="class-node-constant-notification-moved-in-parent">NOTIFICATION_MOVED_IN_PARENT = <code>12</code>
</h3> <p><em>Deprecated.</em> This notification is no longer emitted. Use <a href="#class-node-constant-notification-child-order-changed"><span class="std std-ref">NOTIFICATION_CHILD_ORDER_CHANGED</span></a> instead.</p> <h3 id="class-node-constant-notification-ready">NOTIFICATION_READY = <code>13</code>
</h3> <p>Notification received when the node is ready. See <a href="#class-node-private-method-ready"><span class="std std-ref">_ready</span></a>.</p> <h3 id="class-node-constant-notification-paused">NOTIFICATION_PAUSED = <code>14</code>
</h3> <p>Notification received when the node is paused. See <a href="#class-node-property-process-mode"><span class="std std-ref">process_mode</span></a>.</p> <h3 id="class-node-constant-notification-unpaused">NOTIFICATION_UNPAUSED = <code>15</code>
</h3> <p>Notification received when the node is unpaused. See <a href="#class-node-property-process-mode"><span class="std std-ref">process_mode</span></a>.</p> <h3 id="class-node-constant-notification-physics-process">NOTIFICATION_PHYSICS_PROCESS = <code>16</code>
</h3> <p>Notification received from the tree every physics frame when <a href="#class-node-method-is-physics-processing"><span class="std std-ref">is_physics_processing</span></a> returns <code>true</code>. See <a href="#class-node-private-method-physics-process"><span class="std std-ref">_physics_process</span></a>.</p> <h3 id="class-node-constant-notification-process">NOTIFICATION_PROCESS = <code>17</code>
</h3> <p>Notification received from the tree every rendered frame when <a href="#class-node-method-is-processing"><span class="std std-ref">is_processing</span></a> returns <code>true</code>. See <a href="#class-node-private-method-process"><span class="std std-ref">_process</span></a>.</p> <h3 id="class-node-constant-notification-parented">NOTIFICATION_PARENTED = <code>18</code>
</h3> <p>Notification received when the node is set as a child of another node (see <a href="#class-node-method-add-child"><span class="std std-ref">add_child</span></a> and <a href="#class-node-method-add-sibling"><span class="std std-ref">add_sibling</span></a>).</p> <p><strong>Note:</strong> This does <em>not</em> mean that the node entered the <a href="class_scenetree.html#class-scenetree"><span class="std std-ref">SceneTree</span></a>.</p> <h3 id="class-node-constant-notification-unparented">NOTIFICATION_UNPARENTED = <code>19</code>
</h3> <p>Notification received when the parent node calls <a href="#class-node-method-remove-child"><span class="std std-ref">remove_child</span></a> on this node.</p> <p><strong>Note:</strong> This does <em>not</em> mean that the node exited the <a href="class_scenetree.html#class-scenetree"><span class="std std-ref">SceneTree</span></a>.</p> <h3 id="class-node-constant-notification-scene-instantiated">NOTIFICATION_SCENE_INSTANTIATED = <code>20</code>
</h3> <p>Notification received <em>only</em> by the newly instantiated scene root node, when <a href="class_packedscene.html#class-packedscene-method-instantiate"><span class="std std-ref">PackedScene.instantiate</span></a> is completed.</p> <h3 id="class-node-constant-notification-drag-begin">NOTIFICATION_DRAG_BEGIN = <code>21</code>
</h3> <p>Notification received when a drag operation begins. All nodes receive this notification, not only the dragged one.</p> <p>Can be triggered either by dragging a <a href="class_control.html#class-control"><span class="std std-ref">Control</span></a> that provides drag data (see <a href="class_control.html#class-control-private-method-get-drag-data"><span class="std std-ref">Control._get_drag_data</span></a>) or using <a href="class_control.html#class-control-method-force-drag"><span class="std std-ref">Control.force_drag</span></a>.</p> <p>Use <a href="class_viewport.html#class-viewport-method-gui-get-drag-data"><span class="std std-ref">Viewport.gui_get_drag_data</span></a> to get the dragged data.</p> <h3 id="class-node-constant-notification-drag-end">NOTIFICATION_DRAG_END = <code>22</code>
</h3> <p>Notification received when a drag operation ends.</p> <p>Use <a href="class_viewport.html#class-viewport-method-gui-is-drag-successful"><span class="std std-ref">Viewport.gui_is_drag_successful</span></a> to check if the drag succeeded.</p> <h3 id="class-node-constant-notification-path-renamed">NOTIFICATION_PATH_RENAMED = <code>23</code>
</h3> <p>Notification received when the node's <a href="#class-node-property-name"><span class="std std-ref">name</span></a> or one of its ancestors' <a href="#class-node-property-name"><span class="std std-ref">name</span></a> is changed. This notification is <em>not</em> received when the node is removed from the <a href="class_scenetree.html#class-scenetree"><span class="std std-ref">SceneTree</span></a>.</p> <h3 id="class-node-constant-notification-child-order-changed">NOTIFICATION_CHILD_ORDER_CHANGED = <code>24</code>
</h3> <p>Notification received when the list of children is changed. This happens when child nodes are added, moved or removed.</p> <h3 id="class-node-constant-notification-internal-process">NOTIFICATION_INTERNAL_PROCESS = <code>25</code>
</h3> <p>Notification received from the tree every rendered frame when <a href="#class-node-method-is-processing-internal"><span class="std std-ref">is_processing_internal</span></a> returns <code>true</code>.</p> <h3 id="class-node-constant-notification-internal-physics-process">NOTIFICATION_INTERNAL_PHYSICS_PROCESS = <code>26</code>
</h3> <p>Notification received from the tree every physics frame when <a href="#class-node-method-is-physics-processing-internal"><span class="std std-ref">is_physics_processing_internal</span></a> returns <code>true</code>.</p> <h3 id="class-node-constant-notification-post-enter-tree">NOTIFICATION_POST_ENTER_TREE = <code>27</code>
</h3> <p>Notification received when the node enters the tree, just before <a href="#class-node-constant-notification-ready"><span class="std std-ref">NOTIFICATION_READY</span></a> may be received. Unlike the latter, it is sent every time the node enters tree, not just once.</p> <h3 id="class-node-constant-notification-disabled">NOTIFICATION_DISABLED = <code>28</code>
</h3> <p>Notification received when the node is disabled. See <a href="#class-node-constant-process-mode-disabled"><span class="std std-ref">PROCESS_MODE_DISABLED</span></a>.</p> <h3 id="class-node-constant-notification-enabled">NOTIFICATION_ENABLED = <code>29</code>
</h3> <p>Notification received when the node is enabled again after being disabled. See <a href="#class-node-constant-process-mode-disabled"><span class="std std-ref">PROCESS_MODE_DISABLED</span></a>.</p> <h3 id="class-node-constant-notification-editor-pre-save">NOTIFICATION_EDITOR_PRE_SAVE = <code>9001</code>
</h3> <p>Notification received right before the scene with the node is saved in the editor. This notification is only sent in the Godot editor and will not occur in exported projects.</p> <h3 id="class-node-constant-notification-editor-post-save">NOTIFICATION_EDITOR_POST_SAVE = <code>9002</code>
</h3> <p>Notification received right after the scene with the node is saved in the editor. This notification is only sent in the Godot editor and will not occur in exported projects.</p> <h3 id="class-node-constant-notification-wm-mouse-enter">NOTIFICATION_WM_MOUSE_ENTER = <code>1002</code>
</h3> <p>Notification received when the mouse enters the window.</p> <p>Implemented for embedded windows and on desktop and web platforms.</p> <h3 id="class-node-constant-notification-wm-mouse-exit">NOTIFICATION_WM_MOUSE_EXIT = <code>1003</code>
</h3> <p>Notification received when the mouse leaves the window.</p> <p>Implemented for embedded windows and on desktop and web platforms.</p> <h3 id="class-node-constant-notification-wm-window-focus-in">NOTIFICATION_WM_WINDOW_FOCUS_IN = <code>1004</code>
</h3> <p>Notification received from the OS when the node's <a href="class_window.html#class-window"><span class="std std-ref">Window</span></a> ancestor is focused. This may be a change of focus between two windows of the same engine instance, or from the OS desktop or a third-party application to a window of the game (in which case <a href="#class-node-constant-notification-application-focus-in"><span class="std std-ref">NOTIFICATION_APPLICATION_FOCUS_IN</span></a> is also received).</p> <p>A <a href="class_window.html#class-window"><span class="std std-ref">Window</span></a> node receives this notification when it is focused.</p> <h3 id="class-node-constant-notification-wm-window-focus-out">NOTIFICATION_WM_WINDOW_FOCUS_OUT = <code>1005</code>
</h3> <p>Notification received from the OS when the node's <a href="class_window.html#class-window"><span class="std std-ref">Window</span></a> ancestor is defocused. This may be a change of focus between two windows of the same engine instance, or from a window of the game to the OS desktop or a third-party application (in which case <a href="#class-node-constant-notification-application-focus-out"><span class="std std-ref">NOTIFICATION_APPLICATION_FOCUS_OUT</span></a> is also received).</p> <p>A <a href="class_window.html#class-window"><span class="std std-ref">Window</span></a> node receives this notification when it is defocused.</p> <h3 id="class-node-constant-notification-wm-close-request">NOTIFICATION_WM_CLOSE_REQUEST = <code>1006</code>
</h3> <p>Notification received from the OS when a close request is sent (e.g. closing the window with a "Close" button or <kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">Alt</kbd> + <kbd class="kbd docutils literal notranslate">F4</kbd></kbd>).</p> <p>Implemented on desktop platforms.</p> <h3 id="class-node-constant-notification-wm-go-back-request">NOTIFICATION_WM_GO_BACK_REQUEST = <code>1007</code>
</h3> <p>Notification received from the OS when a go back request is sent (e.g. pressing the "Back" button on Android).</p> <p>Implemented only on iOS.</p> <h3 id="class-node-constant-notification-wm-size-changed">NOTIFICATION_WM_SIZE_CHANGED = <code>1008</code>
</h3> <p>Notification received when the window is resized.</p> <p><strong>Note:</strong> Only the resized <a href="class_window.html#class-window"><span class="std std-ref">Window</span></a> node receives this notification, and it's not propagated to the child nodes.</p> <h3 id="class-node-constant-notification-wm-dpi-change">NOTIFICATION_WM_DPI_CHANGE = <code>1009</code>
</h3> <p>Notification received from the OS when the screen's dots per inch (DPI) scale is changed. Only implemented on macOS.</p> <h3 id="class-node-constant-notification-vp-mouse-enter">NOTIFICATION_VP_MOUSE_ENTER = <code>1010</code>
</h3> <p>Notification received when the mouse cursor enters the <a href="class_viewport.html#class-viewport"><span class="std std-ref">Viewport</span></a>'s visible area, that is not occluded behind other <a href="class_control.html#class-control"><span class="std std-ref">Control</span></a>s or <a href="class_window.html#class-window"><span class="std std-ref">Window</span></a>s, provided its <a href="class_viewport.html#class-viewport-property-gui-disable-input"><span class="std std-ref">Viewport.gui_disable_input</span></a> is <code>false</code> and regardless if it's currently focused or not.</p> <h3 id="class-node-constant-notification-vp-mouse-exit">NOTIFICATION_VP_MOUSE_EXIT = <code>1011</code>
</h3> <p>Notification received when the mouse cursor leaves the <a href="class_viewport.html#class-viewport"><span class="std std-ref">Viewport</span></a>'s visible area, that is not occluded behind other <a href="class_control.html#class-control"><span class="std std-ref">Control</span></a>s or <a href="class_window.html#class-window"><span class="std std-ref">Window</span></a>s, provided its <a href="class_viewport.html#class-viewport-property-gui-disable-input"><span class="std std-ref">Viewport.gui_disable_input</span></a> is <code>false</code> and regardless if it's currently focused or not.</p> <h3 id="class-node-constant-notification-os-memory-warning">NOTIFICATION_OS_MEMORY_WARNING = <code>2009</code>
</h3> <p>Notification received from the OS when the application is exceeding its allocated memory.</p> <p>Implemented only on iOS.</p> <h3 id="class-node-constant-notification-translation-changed">NOTIFICATION_TRANSLATION_CHANGED = <code>2010</code>
</h3> <p>Notification received when translations may have changed. Can be triggered by the user changing the locale. Can be used to respond to language changes, for example to change the UI strings on the fly. Useful when working with the built-in translation support, like <a href="class_object.html#class-object-method-tr"><span class="std std-ref">Object.tr</span></a>.</p> <h3 id="class-node-constant-notification-wm-about">NOTIFICATION_WM_ABOUT = <code>2011</code>
</h3> <p>Notification received from the OS when a request for "About" information is sent.</p> <p>Implemented only on macOS.</p> <h3 id="class-node-constant-notification-crash">NOTIFICATION_CRASH = <code>2012</code>
</h3> <p>Notification received from Godot's crash handler when the engine is about to crash.</p> <p>Implemented on desktop platforms, if the crash handler is enabled.</p> <h3 id="class-node-constant-notification-os-ime-update">NOTIFICATION_OS_IME_UPDATE = <code>2013</code>
</h3> <p>Notification received from the OS when an update of the Input Method Engine occurs (e.g. change of IME cursor position or composition string).</p> <p>Implemented only on macOS.</p> <h3 id="class-node-constant-notification-application-resumed">NOTIFICATION_APPLICATION_RESUMED = <code>2014</code>
</h3> <p>Notification received from the OS when the application is resumed.</p> <p>Implemented only on Android.</p> <h3 id="class-node-constant-notification-application-paused">NOTIFICATION_APPLICATION_PAUSED = <code>2015</code>
</h3> <p>Notification received from the OS when the application is paused.</p> <p>Implemented only on Android.</p> <h3 id="class-node-constant-notification-application-focus-in">NOTIFICATION_APPLICATION_FOCUS_IN = <code>2016</code>
</h3> <p>Notification received from the OS when the application is focused, i.e. when changing the focus from the OS desktop or a third-party application to any open window of the Godot instance.</p> <p>Implemented on desktop platforms.</p> <h3 id="class-node-constant-notification-application-focus-out">NOTIFICATION_APPLICATION_FOCUS_OUT = <code>2017</code>
</h3> <p>Notification received from the OS when the application is defocused, i.e. when changing the focus from any open window of the Godot instance to the OS desktop or a third-party application.</p> <p>Implemented on desktop platforms.</p> <h3 id="class-node-constant-notification-text-server-changed">NOTIFICATION_TEXT_SERVER_CHANGED = <code>2018</code>
</h3> <p>Notification received when the <a href="class_textserver.html#class-textserver"><span class="std std-ref">TextServer</span></a> is changed.</p> </section>  <section class="classref-descriptions-group" id="property-descriptions"> <h2>Property Descriptions</h2> <h3 id="class-node-property-editor-description">
<a href="class_string.html#class-string"><span class="std std-ref">String</span></a> editor_description = <code>""</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_editor_description</strong> <strong>(</strong> <a href="class_string.html#class-string"><span class="std std-ref">String</span></a> value <strong>)</strong>
</li> <li>
<a href="class_string.html#class-string"><span class="std std-ref">String</span></a> <strong>get_editor_description</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>An optional description to the node. It will be displayed as a tooltip when hovering over the node in the editor's Scene dock.</p>  <h3 id="class-node-property-multiplayer">
<a href="class_multiplayerapi.html#class-multiplayerapi"><span class="std std-ref">MultiplayerAPI</span></a> multiplayer</h3> <ul class="classref-property-setget simple"> <li>
<a href="class_multiplayerapi.html#class-multiplayerapi"><span class="std std-ref">MultiplayerAPI</span></a> <strong>get_multiplayer</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>The <a href="class_multiplayerapi.html#class-multiplayerapi"><span class="std std-ref">MultiplayerAPI</span></a> instance associated with this node. See <a href="class_scenetree.html#class-scenetree-method-get-multiplayer"><span class="std std-ref">SceneTree.get_multiplayer</span></a>.</p> <p><strong>Note:</strong> Renaming the node, or moving it in the tree, will not move the <a href="class_multiplayerapi.html#class-multiplayerapi"><span class="std std-ref">MultiplayerAPI</span></a> to the new path, you will have to update this manually.</p>  <h3 id="class-node-property-name">
<a href="class_stringname.html#class-stringname"><span class="std std-ref">StringName</span></a> name</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_name</strong> <strong>(</strong> <a href="class_stringname.html#class-stringname"><span class="std std-ref">StringName</span></a> value <strong>)</strong>
</li> <li>
<a href="class_stringname.html#class-stringname"><span class="std std-ref">StringName</span></a> <strong>get_name</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>The name of the node. This name must be unique among the siblings (other child nodes from the same parent). When set to an existing sibling's name, the node is automatically renamed.</p> <p><strong>Note:</strong> When changing the name, the following characters will be removed: (<code>.</code> <code>:</code> <code>@</code> <code>/</code> <code>"</code> <code>%</code>). In particular, the <code>@</code> character is reserved for auto-generated names. See also <a href="class_string.html#class-string-method-validate-node-name"><span class="std std-ref">String.validate_node_name</span></a>.</p>  <h3 id="class-node-property-owner">
<a href="#class-node"><span class="std std-ref">Node</span></a> owner</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_owner</strong> <strong>(</strong> <a href="#class-node"><span class="std std-ref">Node</span></a> value <strong>)</strong>
</li> <li>
<a href="#class-node"><span class="std std-ref">Node</span></a> <strong>get_owner</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>The owner of this node. The owner must be an ancestor of this node. When packing the owner node in a <a href="class_packedscene.html#class-packedscene"><span class="std std-ref">PackedScene</span></a>, all the nodes it owns are also saved with it.</p> <p><strong>Note:</strong> In the editor, nodes not owned by the scene root are usually not displayed in the Scene dock, and will <strong>not</strong> be saved. To prevent this, remember to set the owner after calling <a href="#class-node-method-add-child"><span class="std std-ref">add_child</span></a>. See also (see <a href="#class-node-property-unique-name-in-owner"><span class="std std-ref">unique_name_in_owner</span></a>)</p>  <h3 id="class-node-property-process-mode">
<a href="#enum-node-processmode"><span class="std std-ref">ProcessMode</span></a> process_mode = <code>0</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_process_mode</strong> <strong>(</strong> <a href="#enum-node-processmode"><span class="std std-ref">ProcessMode</span></a> value <strong>)</strong>
</li> <li>
<a href="#enum-node-processmode"><span class="std std-ref">ProcessMode</span></a> <strong>get_process_mode</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>The node's processing behavior (see <a href="#enum-node-processmode"><span class="std std-ref">ProcessMode</span></a>). To check if the node is able to process, with the current mode and <a href="class_scenetree.html#class-scenetree-property-paused"><span class="std std-ref">SceneTree.paused</span></a>, use <a href="#class-node-method-can-process"><span class="std std-ref">can_process</span></a>.</p>  <h3 id="class-node-property-process-physics-priority">
<a href="class_int.html#class-int"><span class="std std-ref">int</span></a> process_physics_priority = <code>0</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_physics_process_priority</strong> <strong>(</strong> <a href="class_int.html#class-int"><span class="std std-ref">int</span></a> value <strong>)</strong>
</li> <li>
<a href="class_int.html#class-int"><span class="std std-ref">int</span></a> <strong>get_physics_process_priority</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>Similar to <a href="#class-node-property-process-priority"><span class="std std-ref">process_priority</span></a> but for <a href="#class-node-constant-notification-physics-process"><span class="std std-ref">NOTIFICATION_PHYSICS_PROCESS</span></a>, <a href="#class-node-private-method-physics-process"><span class="std std-ref">_physics_process</span></a> or the internal version.</p>  <h3 id="class-node-property-process-priority">
<a href="class_int.html#class-int"><span class="std std-ref">int</span></a> process_priority = <code>0</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_process_priority</strong> <strong>(</strong> <a href="class_int.html#class-int"><span class="std std-ref">int</span></a> value <strong>)</strong>
</li> <li>
<a href="class_int.html#class-int"><span class="std std-ref">int</span></a> <strong>get_process_priority</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>The node's execution order of the process callbacks (<a href="#class-node-private-method-process"><span class="std std-ref">_process</span></a>, <a href="#class-node-private-method-physics-process"><span class="std std-ref">_physics_process</span></a>, and internal processing). Nodes whose priority value is <em>lower</em> call their process callbacks first, regardless of tree order.</p>  <h3 id="class-node-property-process-thread-group">
<a href="#enum-node-processthreadgroup"><span class="std std-ref">ProcessThreadGroup</span></a> process_thread_group = <code>0</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_process_thread_group</strong> <strong>(</strong> <a href="#enum-node-processthreadgroup"><span class="std std-ref">ProcessThreadGroup</span></a> value <strong>)</strong>
</li> <li>
<a href="#enum-node-processthreadgroup"><span class="std std-ref">ProcessThreadGroup</span></a> <strong>get_process_thread_group</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>Set the process thread group for this node (basically, whether it receives <a href="#class-node-constant-notification-process"><span class="std std-ref">NOTIFICATION_PROCESS</span></a>, <a href="#class-node-constant-notification-physics-process"><span class="std std-ref">NOTIFICATION_PHYSICS_PROCESS</span></a>, <a href="#class-node-private-method-process"><span class="std std-ref">_process</span></a> or <a href="#class-node-private-method-physics-process"><span class="std std-ref">_physics_process</span></a> (and the internal versions) on the main thread or in a sub-thread.</p> <p>By default, the thread group is <a href="#class-node-constant-process-thread-group-inherit"><span class="std std-ref">PROCESS_THREAD_GROUP_INHERIT</span></a>, which means that this node belongs to the same thread group as the parent node. The thread groups means that nodes in a specific thread group will process together, separate to other thread groups (depending on <a href="#class-node-property-process-thread-group-order"><span class="std std-ref">process_thread_group_order</span></a>). If the value is set is <a href="#class-node-constant-process-thread-group-sub-thread"><span class="std std-ref">PROCESS_THREAD_GROUP_SUB_THREAD</span></a>, this thread group will occur on a sub thread (not the main thread), otherwise if set to <a href="#class-node-constant-process-thread-group-main-thread"><span class="std std-ref">PROCESS_THREAD_GROUP_MAIN_THREAD</span></a> it will process on the main thread. If there is not a parent or grandparent node set to something other than inherit, the node will belong to the <em>default thread group</em>. This default group will process on the main thread and its group order is 0.</p> <p>During processing in a sub-thread, accessing most functions in nodes outside the thread group is forbidden (and it will result in an error in debug mode). Use <a href="class_object.html#class-object-method-call-deferred"><span class="std std-ref">Object.call_deferred</span></a>, <a href="#class-node-method-call-thread-safe"><span class="std std-ref">call_thread_safe</span></a>, <a href="#class-node-method-call-deferred-thread-group"><span class="std std-ref">call_deferred_thread_group</span></a> and the likes in order to communicate from the thread groups to the main thread (or to other thread groups).</p> <p>To better understand process thread groups, the idea is that any node set to any other value than <a href="#class-node-constant-process-thread-group-inherit"><span class="std std-ref">PROCESS_THREAD_GROUP_INHERIT</span></a> will include any child (and grandchild) nodes set to inherit into its process thread group. This means that the processing of all the nodes in the group will happen together, at the same time as the node including them.</p>  <h3 id="class-node-property-process-thread-group-order">
<a href="class_int.html#class-int"><span class="std std-ref">int</span></a> process_thread_group_order</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_process_thread_group_order</strong> <strong>(</strong> <a href="class_int.html#class-int"><span class="std std-ref">int</span></a> value <strong>)</strong>
</li> <li>
<a href="class_int.html#class-int"><span class="std std-ref">int</span></a> <strong>get_process_thread_group_order</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>Change the process thread group order. Groups with a lesser order will process before groups with a greater order. This is useful when a large amount of nodes process in sub thread and, afterwards, another group wants to collect their result in the main thread, as an example.</p>  <h3 id="class-node-property-process-thread-messages">
<abbr title="This value is an integer composed as a bitmask of the following flags.">BitField</abbr>&lt;<a href="#enum-node-processthreadmessages"><span class="std std-ref">ProcessThreadMessages</span></a>&gt; process_thread_messages</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_process_thread_messages</strong> <strong>(</strong> <abbr title="This value is an integer composed as a bitmask of the following flags.">BitField</abbr>&lt;<a href="#enum-node-processthreadmessages"><span class="std std-ref">ProcessThreadMessages</span></a>&gt; value <strong>)</strong>
</li> <li>
<abbr title="This value is an integer composed as a bitmask of the following flags.">BitField</abbr>&lt;<a href="#enum-node-processthreadmessages"><span class="std std-ref">ProcessThreadMessages</span></a>&gt; <strong>get_process_thread_messages</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>Set whether the current thread group will process messages (calls to <a href="#class-node-method-call-deferred-thread-group"><span class="std std-ref">call_deferred_thread_group</span></a> on threads, and whether it wants to receive them during regular process or physics process callbacks.</p>  <h3 id="class-node-property-scene-file-path">
<a href="class_string.html#class-string"><span class="std std-ref">String</span></a> scene_file_path</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_scene_file_path</strong> <strong>(</strong> <a href="class_string.html#class-string"><span class="std std-ref">String</span></a> value <strong>)</strong>
</li> <li>
<a href="class_string.html#class-string"><span class="std std-ref">String</span></a> <strong>get_scene_file_path</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>The original scene's file path, if the node has been instantiated from a <a href="class_packedscene.html#class-packedscene"><span class="std std-ref">PackedScene</span></a> file. Only scene root nodes contains this.</p>  <h3 id="class-node-property-unique-name-in-owner">
<a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> unique_name_in_owner = <code>false</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_unique_name_in_owner</strong> <strong>(</strong> <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> value <strong>)</strong>
</li> <li>
<a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> <strong>is_unique_name_in_owner</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>If <code>true</code>, the node can be accessed from any node sharing the same <a href="#class-node-property-owner"><span class="std std-ref">owner</span></a> or from the <a href="#class-node-property-owner"><span class="std std-ref">owner</span></a> itself, with special <code>%Name</code> syntax in <a href="#class-node-method-get-node"><span class="std std-ref">get_node</span></a>.</p> <p><strong>Note:</strong> If another node with the same <a href="#class-node-property-owner"><span class="std std-ref">owner</span></a> shares the same <a href="#class-node-property-name"><span class="std std-ref">name</span></a> as this node, the other node will no longer be accessible as unique.</p> </section>  <section class="classref-descriptions-group" id="method-descriptions"> <h2>Method Descriptions</h2> <h3 id="class-node-private-method-enter-tree">void _enter_tree ( ) <abbr title="This method should typically be overridden by the user to have any effect.">virtual</abbr>
</h3> <p>Called when the node enters the <a href="class_scenetree.html#class-scenetree"><span class="std std-ref">SceneTree</span></a> (e.g. upon instantiating, scene changing, or after calling <a href="#class-node-method-add-child"><span class="std std-ref">add_child</span></a> in a script). If the node has children, its <a href="#class-node-private-method-enter-tree"><span class="std std-ref">_enter_tree</span></a> callback will be called first, and then that of the children.</p> <p>Corresponds to the <a href="#class-node-constant-notification-enter-tree"><span class="std std-ref">NOTIFICATION_ENTER_TREE</span></a> notification in <a href="class_object.html#class-object-private-method-notification"><span class="std std-ref">Object._notification</span></a>.</p>  <h3 id="class-node-private-method-exit-tree">void _exit_tree ( ) <abbr title="This method should typically be overridden by the user to have any effect.">virtual</abbr>
</h3> <p>Called when the node is about to leave the <a href="class_scenetree.html#class-scenetree"><span class="std std-ref">SceneTree</span></a> (e.g. upon freeing, scene changing, or after calling <a href="#class-node-method-remove-child"><span class="std std-ref">remove_child</span></a> in a script). If the node has children, its <a href="#class-node-private-method-exit-tree"><span class="std std-ref">_exit_tree</span></a> callback will be called last, after all its children have left the tree.</p> <p>Corresponds to the <a href="#class-node-constant-notification-exit-tree"><span class="std std-ref">NOTIFICATION_EXIT_TREE</span></a> notification in <a href="class_object.html#class-object-private-method-notification"><span class="std std-ref">Object._notification</span></a> and signal <a href="#class-node-signal-tree-exiting"><span class="std std-ref">tree_exiting</span></a>. To get notified when the node has already left the active tree, connect to the <a href="#class-node-signal-tree-exited"><span class="std std-ref">tree_exited</span></a>.</p>  <h3 id="class-node-private-method-get-configuration-warnings">
<a href="class_packedstringarray.html#class-packedstringarray"><span class="std std-ref">PackedStringArray</span></a> _get_configuration_warnings ( ) <abbr title="This method should typically be overridden by the user to have any effect.">virtual</abbr> <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr>
</h3> <p>The elements in the array returned from this method are displayed as warnings in the Scene dock if the script that overrides it is a <code>tool</code> script.</p> <p>Returning an empty array produces no warnings.</p> <p>Call <a href="#class-node-method-update-configuration-warnings"><span class="std std-ref">update_configuration_warnings</span></a> when the warnings need to be updated for this node.</p> <pre data-language="gdscript">@export var energy = 0:
    set(value):
        energy = value
        update_configuration_warnings()

func _get_configuration_warnings():
    if energy &lt; 0:
        return ["Energy must be 0 or greater."]
    else:
        return []
</pre>  <h3 id="class-node-private-method-input">void _input ( <a href="class_inputevent.html#class-inputevent"><span class="std std-ref">InputEvent</span></a> event ) <abbr title="This method should typically be overridden by the user to have any effect.">virtual</abbr>
</h3> <p>Called when there is an input event. The input event propagates up through the node tree until a node consumes it.</p> <p>It is only called if input processing is enabled, which is done automatically if this method is overridden, and can be toggled with <a href="#class-node-method-set-process-input"><span class="std std-ref">set_process_input</span></a>.</p> <p>To consume the input event and stop it propagating further to other nodes, <a href="class_viewport.html#class-viewport-method-set-input-as-handled"><span class="std std-ref">Viewport.set_input_as_handled</span></a> can be called.</p> <p>For gameplay input, <a href="#class-node-private-method-unhandled-input"><span class="std std-ref">_unhandled_input</span></a> and <a href="#class-node-private-method-unhandled-key-input"><span class="std std-ref">_unhandled_key_input</span></a> are usually a better fit as they allow the GUI to intercept the events first.</p> <p><strong>Note:</strong> This method is only called if the node is present in the scene tree (i.e. if it's not an orphan).</p>  <h3 id="class-node-private-method-physics-process">void _physics_process ( <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> delta ) <abbr title="This method should typically be overridden by the user to have any effect.">virtual</abbr>
</h3> <p>Called during the physics processing step of the main loop. Physics processing means that the frame rate is synced to the physics, i.e. the <code>delta</code> variable should be constant. <code>delta</code> is in seconds.</p> <p>It is only called if physics processing is enabled, which is done automatically if this method is overridden, and can be toggled with <a href="#class-node-method-set-physics-process"><span class="std std-ref">set_physics_process</span></a>.</p> <p>Corresponds to the <a href="#class-node-constant-notification-physics-process"><span class="std std-ref">NOTIFICATION_PHYSICS_PROCESS</span></a> notification in <a href="class_object.html#class-object-private-method-notification"><span class="std std-ref">Object._notification</span></a>.</p> <p><strong>Note:</strong> This method is only called if the node is present in the scene tree (i.e. if it's not an orphan).</p>  <h3 id="class-node-private-method-process">void _process ( <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> delta ) <abbr title="This method should typically be overridden by the user to have any effect.">virtual</abbr>
</h3> <p>Called during the processing step of the main loop. Processing happens at every frame and as fast as possible, so the <code>delta</code> time since the previous frame is not constant. <code>delta</code> is in seconds.</p> <p>It is only called if processing is enabled, which is done automatically if this method is overridden, and can be toggled with <a href="#class-node-method-set-process"><span class="std std-ref">set_process</span></a>.</p> <p>Corresponds to the <a href="#class-node-constant-notification-process"><span class="std std-ref">NOTIFICATION_PROCESS</span></a> notification in <a href="class_object.html#class-object-private-method-notification"><span class="std std-ref">Object._notification</span></a>.</p> <p><strong>Note:</strong> This method is only called if the node is present in the scene tree (i.e. if it's not an orphan).</p>  <h3 id="class-node-private-method-ready">void _ready ( ) <abbr title="This method should typically be overridden by the user to have any effect.">virtual</abbr>
</h3> <p>Called when the node is "ready", i.e. when both the node and its children have entered the scene tree. If the node has children, their <a href="#class-node-private-method-ready"><span class="std std-ref">_ready</span></a> callbacks get triggered first, and the parent node will receive the ready notification afterwards.</p> <p>Corresponds to the <a href="#class-node-constant-notification-ready"><span class="std std-ref">NOTIFICATION_READY</span></a> notification in <a href="class_object.html#class-object-private-method-notification"><span class="std std-ref">Object._notification</span></a>. See also the <code>@onready</code> annotation for variables.</p> <p>Usually used for initialization. For even earlier initialization, <a href="class_object.html#class-object-private-method-init"><span class="std std-ref">Object._init</span></a> may be used. See also <a href="#class-node-private-method-enter-tree"><span class="std std-ref">_enter_tree</span></a>.</p> <p><strong>Note:</strong> This method may be called only once for each node. After removing a node from the scene tree and adding it again, <a href="#class-node-private-method-ready"><span class="std std-ref">_ready</span></a> will <strong>not</strong> be called a second time. This can be bypassed by requesting another call with <a href="#class-node-method-request-ready"><span class="std std-ref">request_ready</span></a>, which may be called anywhere before adding the node again.</p>  <h3 id="class-node-private-method-shortcut-input">void _shortcut_input ( <a href="class_inputevent.html#class-inputevent"><span class="std std-ref">InputEvent</span></a> event ) <abbr title="This method should typically be overridden by the user to have any effect.">virtual</abbr>
</h3> <p>Called when an <a href="class_inputeventkey.html#class-inputeventkey"><span class="std std-ref">InputEventKey</span></a>, <a href="class_inputeventshortcut.html#class-inputeventshortcut"><span class="std std-ref">InputEventShortcut</span></a>, or <a href="class_inputeventjoypadbutton.html#class-inputeventjoypadbutton"><span class="std std-ref">InputEventJoypadButton</span></a> hasn't been consumed by <a href="#class-node-private-method-input"><span class="std std-ref">_input</span></a> or any GUI <a href="class_control.html#class-control"><span class="std std-ref">Control</span></a> item. It is called before <a href="#class-node-private-method-unhandled-key-input"><span class="std std-ref">_unhandled_key_input</span></a> and <a href="#class-node-private-method-unhandled-input"><span class="std std-ref">_unhandled_input</span></a>. The input event propagates up through the node tree until a node consumes it.</p> <p>It is only called if shortcut processing is enabled, which is done automatically if this method is overridden, and can be toggled with <a href="#class-node-method-set-process-shortcut-input"><span class="std std-ref">set_process_shortcut_input</span></a>.</p> <p>To consume the input event and stop it propagating further to other nodes, <a href="class_viewport.html#class-viewport-method-set-input-as-handled"><span class="std std-ref">Viewport.set_input_as_handled</span></a> can be called.</p> <p>This method can be used to handle shortcuts. For generic GUI events, use <a href="#class-node-private-method-input"><span class="std std-ref">_input</span></a> instead. Gameplay events should usually be handled with either <a href="#class-node-private-method-unhandled-input"><span class="std std-ref">_unhandled_input</span></a> or <a href="#class-node-private-method-unhandled-key-input"><span class="std std-ref">_unhandled_key_input</span></a>.</p> <p><strong>Note:</strong> This method is only called if the node is present in the scene tree (i.e. if it's not orphan).</p>  <h3 id="class-node-private-method-unhandled-input">void _unhandled_input ( <a href="class_inputevent.html#class-inputevent"><span class="std std-ref">InputEvent</span></a> event ) <abbr title="This method should typically be overridden by the user to have any effect.">virtual</abbr>
</h3> <p>Called when an <a href="class_inputevent.html#class-inputevent"><span class="std std-ref">InputEvent</span></a> hasn't been consumed by <a href="#class-node-private-method-input"><span class="std std-ref">_input</span></a> or any GUI <a href="class_control.html#class-control"><span class="std std-ref">Control</span></a> item. It is called after <a href="#class-node-private-method-shortcut-input"><span class="std std-ref">_shortcut_input</span></a> and after <a href="#class-node-private-method-unhandled-key-input"><span class="std std-ref">_unhandled_key_input</span></a>. The input event propagates up through the node tree until a node consumes it.</p> <p>It is only called if unhandled input processing is enabled, which is done automatically if this method is overridden, and can be toggled with <a href="#class-node-method-set-process-unhandled-input"><span class="std std-ref">set_process_unhandled_input</span></a>.</p> <p>To consume the input event and stop it propagating further to other nodes, <a href="class_viewport.html#class-viewport-method-set-input-as-handled"><span class="std std-ref">Viewport.set_input_as_handled</span></a> can be called.</p> <p>For gameplay input, this method is usually a better fit than <a href="#class-node-private-method-input"><span class="std std-ref">_input</span></a>, as GUI events need a higher priority. For keyboard shortcuts, consider using <a href="#class-node-private-method-shortcut-input"><span class="std std-ref">_shortcut_input</span></a> instead, as it is called before this method. Finally, to handle keyboard events, consider using <a href="#class-node-private-method-unhandled-key-input"><span class="std std-ref">_unhandled_key_input</span></a> for performance reasons.</p> <p><strong>Note:</strong> This method is only called if the node is present in the scene tree (i.e. if it's not an orphan).</p>  <h3 id="class-node-private-method-unhandled-key-input">void _unhandled_key_input ( <a href="class_inputevent.html#class-inputevent"><span class="std std-ref">InputEvent</span></a> event ) <abbr title="This method should typically be overridden by the user to have any effect.">virtual</abbr>
</h3> <p>Called when an <a href="class_inputeventkey.html#class-inputeventkey"><span class="std std-ref">InputEventKey</span></a> hasn't been consumed by <a href="#class-node-private-method-input"><span class="std std-ref">_input</span></a> or any GUI <a href="class_control.html#class-control"><span class="std std-ref">Control</span></a> item. It is called after <a href="#class-node-private-method-shortcut-input"><span class="std std-ref">_shortcut_input</span></a> but before <a href="#class-node-private-method-unhandled-input"><span class="std std-ref">_unhandled_input</span></a>. The input event propagates up through the node tree until a node consumes it.</p> <p>It is only called if unhandled key input processing is enabled, which is done automatically if this method is overridden, and can be toggled with <a href="#class-node-method-set-process-unhandled-key-input"><span class="std std-ref">set_process_unhandled_key_input</span></a>.</p> <p>To consume the input event and stop it propagating further to other nodes, <a href="class_viewport.html#class-viewport-method-set-input-as-handled"><span class="std std-ref">Viewport.set_input_as_handled</span></a> can be called.</p> <p>This method can be used to handle Unicode character input with <kbd class="kbd docutils literal notranslate">Alt</kbd>, <kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">Alt</kbd> + <kbd class="kbd docutils literal notranslate">Ctrl</kbd></kbd>, and <kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">Alt</kbd> + <kbd class="kbd docutils literal notranslate">Shift</kbd></kbd> modifiers, after shortcuts were handled.</p> <p>For gameplay input, this and <a href="#class-node-private-method-unhandled-input"><span class="std std-ref">_unhandled_input</span></a> are usually a better fit than <a href="#class-node-private-method-input"><span class="std std-ref">_input</span></a>, as GUI events should be handled first. This method also performs better than <a href="#class-node-private-method-unhandled-input"><span class="std std-ref">_unhandled_input</span></a>, since unrelated events such as <a href="class_inputeventmousemotion.html#class-inputeventmousemotion"><span class="std std-ref">InputEventMouseMotion</span></a> are automatically filtered. For shortcuts, consider using <a href="#class-node-private-method-shortcut-input"><span class="std std-ref">_shortcut_input</span></a> instead.</p> <p><strong>Note:</strong> This method is only called if the node is present in the scene tree (i.e. if it's not an orphan).</p>  <h3 id="class-node-method-add-child">void add_child ( <a href="#class-node"><span class="std std-ref">Node</span></a> node, <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> force_readable_name=false, <a href="#enum-node-internalmode"><span class="std std-ref">InternalMode</span></a> internal=0 )</h3> <p>Adds a child <code>node</code>. Nodes can have any number of children, but every child must have a unique name. Child nodes are automatically deleted when the parent node is deleted, so an entire scene can be removed by deleting its topmost node.</p> <p>If <code>force_readable_name</code> is <code>true</code>, improves the readability of the added <code>node</code>. If not named, the <code>node</code> is renamed to its type, and if it shares <a href="#class-node-property-name"><span class="std std-ref">name</span></a> with a sibling, a number is suffixed more appropriately. This operation is very slow. As such, it is recommended leaving this to <code>false</code>, which assigns a dummy name featuring <code>@</code> in both situations.</p> <p>If <code>internal</code> is different than <a href="#class-node-constant-internal-mode-disabled"><span class="std std-ref">INTERNAL_MODE_DISABLED</span></a>, the child will be added as internal node. These nodes are ignored by methods like <a href="#class-node-method-get-children"><span class="std std-ref">get_children</span></a>, unless their parameter <code>include_internal</code> is <code>true</code>. The intended usage is to hide the internal nodes from the user, so the user won't accidentally delete or modify them. Used by some GUI nodes, e.g. <a href="class_colorpicker.html#class-colorpicker"><span class="std std-ref">ColorPicker</span></a>. See <a href="#enum-node-internalmode"><span class="std std-ref">InternalMode</span></a> for available modes.</p> <p><strong>Note:</strong> If <code>node</code> already has a parent, this method will fail. Use <a href="#class-node-method-remove-child"><span class="std std-ref">remove_child</span></a> first to remove <code>node</code> from its current parent. For example:</p> <div class="sphinx-tabs docutils container"> <strong>GDScript</strong><pre data-language="gdscript">var child_node = get_child(0)
if child_node.get_parent():
    child_node.get_parent().remove_child(child_node)
add_child(child_node)
</pre> <strong>C#</strong><pre data-language="csharp">Node childNode = GetChild(0);
if (childNode.GetParent() != null)
{
    childNode.GetParent().RemoveChild(childNode);
}
AddChild(childNode);
</pre> </div> <p>If you need the child node to be added below a specific node in the list of children, use <a href="#class-node-method-add-sibling"><span class="std std-ref">add_sibling</span></a> instead of this method.</p> <p><strong>Note:</strong> If you want a child to be persisted to a <a href="class_packedscene.html#class-packedscene"><span class="std std-ref">PackedScene</span></a>, you must set <a href="#class-node-property-owner"><span class="std std-ref">owner</span></a> in addition to calling <a href="#class-node-method-add-child"><span class="std std-ref">add_child</span></a>. This is typically relevant for <a href="https://docs.godotengine.org/en/4.2/tutorials/plugins/running_code_in_the_editor.html"><span class="doc">tool scripts</span></a> and <a href="https://docs.godotengine.org/en/4.2/tutorials/plugins/editor/index.html"><span class="doc">editor plugins</span></a>. If <a href="#class-node-method-add-child"><span class="std std-ref">add_child</span></a> is called without setting <a href="#class-node-property-owner"><span class="std std-ref">owner</span></a>, the newly added <strong>Node</strong> will not be visible in the scene tree, though it will be visible in the 2D/3D view.</p>  <h3 id="class-node-method-add-sibling">void add_sibling ( <a href="#class-node"><span class="std std-ref">Node</span></a> sibling, <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> force_readable_name=false )</h3> <p>Adds a <code>sibling</code> node to this node's parent, and moves the added sibling right below this node.</p> <p>If <code>force_readable_name</code> is <code>true</code>, improves the readability of the added <code>sibling</code>. If not named, the <code>sibling</code> is renamed to its type, and if it shares <a href="#class-node-property-name"><span class="std std-ref">name</span></a> with a sibling, a number is suffixed more appropriately. This operation is very slow. As such, it is recommended leaving this to <code>false</code>, which assigns a dummy name featuring <code>@</code> in both situations.</p> <p>Use <a href="#class-node-method-add-child"><span class="std std-ref">add_child</span></a> instead of this method if you don't need the child node to be added below a specific node in the list of children.</p> <p><strong>Note:</strong> If this node is internal, the added sibling will be internal too (see <a href="#class-node-method-add-child"><span class="std std-ref">add_child</span></a>'s <code>internal</code> parameter).</p>  <h3 id="class-node-method-add-to-group">void add_to_group ( <a href="class_stringname.html#class-stringname"><span class="std std-ref">StringName</span></a> group, <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> persistent=false )</h3> <p>Adds the node to the <code>group</code>. Groups can be helpful to organize a subset of nodes, for example <code>"enemies"</code> or <code>"collectables"</code>. See notes in the description, and the group methods in <a href="class_scenetree.html#class-scenetree"><span class="std std-ref">SceneTree</span></a>.</p> <p>If <code>persistent</code> is <code>true</code>, the group will be stored when saved inside a <a href="class_packedscene.html#class-packedscene"><span class="std std-ref">PackedScene</span></a>. All groups created and displayed in the Node dock are persistent.</p> <p><strong>Note:</strong> To improve performance, the order of group names is <em>not</em> guaranteed and may vary between project runs. Therefore, do not rely on the group order.</p> <p><strong>Note:</strong> <a href="class_scenetree.html#class-scenetree"><span class="std std-ref">SceneTree</span></a>'s group methods will <em>not</em> work on this node if not inside the tree (see <a href="#class-node-method-is-inside-tree"><span class="std std-ref">is_inside_tree</span></a>).</p>  <h3 id="class-node-method-call-deferred-thread-group">
<a href="class_variant.html#class-variant"><span class="std std-ref">Variant</span></a> call_deferred_thread_group ( <a href="class_stringname.html#class-stringname"><span class="std std-ref">StringName</span></a> method, ... ) <abbr title="This method accepts any number of arguments after the ones described here.">vararg</abbr>
</h3> <p>This function is similar to <a href="class_object.html#class-object-method-call-deferred"><span class="std std-ref">Object.call_deferred</span></a> except that the call will take place when the node thread group is processed. If the node thread group processes in sub-threads, then the call will be done on that thread, right before <a href="#class-node-constant-notification-process"><span class="std std-ref">NOTIFICATION_PROCESS</span></a> or <a href="#class-node-constant-notification-physics-process"><span class="std std-ref">NOTIFICATION_PHYSICS_PROCESS</span></a>, the <a href="#class-node-private-method-process"><span class="std std-ref">_process</span></a> or <a href="#class-node-private-method-physics-process"><span class="std std-ref">_physics_process</span></a> or their internal versions are called.</p>  <h3 id="class-node-method-call-thread-safe">
<a href="class_variant.html#class-variant"><span class="std std-ref">Variant</span></a> call_thread_safe ( <a href="class_stringname.html#class-stringname"><span class="std std-ref">StringName</span></a> method, ... ) <abbr title="This method accepts any number of arguments after the ones described here.">vararg</abbr>
</h3> <p>This function ensures that the calling of this function will succeed, no matter whether it's being done from a thread or not. If called from a thread that is not allowed to call the function, the call will become deferred. Otherwise, the call will go through directly.</p>  <h3 id="class-node-method-can-process">
<a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> can_process ( ) <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr>
</h3> <p>Returns <code>true</code> if the node can receive processing notifications and input callbacks (<a href="#class-node-constant-notification-process"><span class="std std-ref">NOTIFICATION_PROCESS</span></a>, <a href="#class-node-private-method-input"><span class="std std-ref">_input</span></a>, etc) from the <a href="class_scenetree.html#class-scenetree"><span class="std std-ref">SceneTree</span></a> and <a href="class_viewport.html#class-viewport"><span class="std std-ref">Viewport</span></a>. The value depends on both the current <a href="#class-node-property-process-mode"><span class="std std-ref">process_mode</span></a> and <a href="class_scenetree.html#class-scenetree-property-paused"><span class="std std-ref">SceneTree.paused</span></a>. Returns <code>false</code> if the node is not inside the tree.</p>  <h3 id="class-node-method-create-tween">
<a href="class_tween.html#class-tween"><span class="std std-ref">Tween</span></a> create_tween ( )</h3> <p>Creates a new <a href="class_tween.html#class-tween"><span class="std std-ref">Tween</span></a> and binds it to this node. Fails if the node is not inside the tree.</p> <p>This is the equivalent of doing:</p> <div class="sphinx-tabs docutils container"> <strong>GDScript</strong><pre data-language="gdscript">get_tree().create_tween().bind_node(self)
</pre> <strong>C#</strong><pre data-language="csharp">GetTree().CreateTween().BindNode(this);
</pre> </div> <p>The Tween will start automatically on the next process frame or physics frame (depending on <a href="class_tween.html#enum-tween-tweenprocessmode"><span class="std std-ref">TweenProcessMode</span></a>).</p>  <h3 id="class-node-method-duplicate">
<a href="#class-node"><span class="std std-ref">Node</span></a> duplicate ( <a href="class_int.html#class-int"><span class="std std-ref">int</span></a> flags=15 ) <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr>
</h3> <p>Duplicates the node, returning a new node with all of its properties, signals and groups copied from the original. The behavior can be tweaked through the <code>flags</code> (see <a href="#enum-node-duplicateflags"><span class="std std-ref">DuplicateFlags</span></a>).</p> <p><strong>Note:</strong> For nodes with a <a href="class_script.html#class-script"><span class="std std-ref">Script</span></a> attached, if <a href="class_object.html#class-object-private-method-init"><span class="std std-ref">Object._init</span></a> has been defined with required parameters, the duplicated node will not have a <a href="class_script.html#class-script"><span class="std std-ref">Script</span></a>.</p>  <h3 id="class-node-method-find-child">
<a href="#class-node"><span class="std std-ref">Node</span></a> find_child ( <a href="class_string.html#class-string"><span class="std std-ref">String</span></a> pattern, <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> recursive=true, <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> owned=true ) <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr>
</h3> <p>Finds the first descendant of this node whose <a href="#class-node-property-name"><span class="std std-ref">name</span></a> matches <code>pattern</code>, returning <code>null</code> if no match is found. The matching is done against node names, <em>not</em> their paths, through <a href="class_string.html#class-string-method-match"><span class="std std-ref">String.match</span></a>. As such, it is case-sensitive, <code>"*"</code> matches zero or more characters, and <code>"?"</code> matches any single character.</p> <p>If <code>recursive</code> is <code>false</code>, only this node's direct children are checked. Nodes are checked in tree order, so this node's first direct child is checked first, then its own direct children, etc., before moving to the second direct child, and so on. Internal children are also included in the search (see <code>internal</code> parameter in <a href="#class-node-method-add-child"><span class="std std-ref">add_child</span></a>).</p> <p>If <code>owned</code> is <code>true</code>, only descendants with a valid <a href="#class-node-property-owner"><span class="std std-ref">owner</span></a> node are checked.</p> <p><strong>Note:</strong> This method can be very slow. Consider storing a reference to the found node in a variable. Alternatively, use <a href="#class-node-method-get-node"><span class="std std-ref">get_node</span></a> with unique names (see <a href="#class-node-property-unique-name-in-owner"><span class="std std-ref">unique_name_in_owner</span></a>).</p> <p><strong>Note:</strong> To find all descendant nodes matching a pattern or a class type, see <a href="#class-node-method-find-children"><span class="std std-ref">find_children</span></a>.</p>  <h3 id="class-node-method-find-children">
<a href="#class-node"><span class="std std-ref">Node[]</span></a> find_children ( <a href="class_string.html#class-string"><span class="std std-ref">String</span></a> pattern, <a href="class_string.html#class-string"><span class="std std-ref">String</span></a> type="", <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> recursive=true, <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> owned=true ) <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr>
</h3> <p>Finds all descendants of this node whose names match <code>pattern</code>, returning an empty <a href="class_array.html#class-array"><span class="std std-ref">Array</span></a> if no match is found. The matching is done against node names, <em>not</em> their paths, through <a href="class_string.html#class-string-method-match"><span class="std std-ref">String.match</span></a>. As such, it is case-sensitive, <code>"*"</code> matches zero or more characters, and <code>"?"</code> matches any single character.</p> <p>If <code>type</code> is not empty, only ancestors inheriting from <code>type</code> are included (see <a href="class_object.html#class-object-method-is-class"><span class="std std-ref">Object.is_class</span></a>).</p> <p>If <code>recursive</code> is <code>false</code>, only this node's direct children are checked. Nodes are checked in tree order, so this node's first direct child is checked first, then its own direct children, etc., before moving to the second direct child, and so on. Internal children are also included in the search (see <code>internal</code> parameter in <a href="#class-node-method-add-child"><span class="std std-ref">add_child</span></a>).</p> <p>If <code>owned</code> is <code>true</code>, only descendants with a valid <a href="#class-node-property-owner"><span class="std std-ref">owner</span></a> node are checked.</p> <p><strong>Note:</strong> This method can be very slow. Consider storing references to the found nodes in a variable.</p> <p><strong>Note:</strong> To find a single descendant node matching a pattern, see <a href="#class-node-method-find-child"><span class="std std-ref">find_child</span></a>.</p>  <h3 id="class-node-method-find-parent">
<a href="#class-node"><span class="std std-ref">Node</span></a> find_parent ( <a href="class_string.html#class-string"><span class="std std-ref">String</span></a> pattern ) <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr>
</h3> <p>Finds the first ancestor of this node whose <a href="#class-node-property-name"><span class="std std-ref">name</span></a> matches <code>pattern</code>, returning <code>null</code> if no match is found. The matching is done through <a href="class_string.html#class-string-method-match"><span class="std std-ref">String.match</span></a>. As such, it is case-sensitive, <code>"*"</code> matches zero or more characters, and <code>"?"</code> matches any single character. See also <a href="#class-node-method-find-child"><span class="std std-ref">find_child</span></a> and <a href="#class-node-method-find-children"><span class="std std-ref">find_children</span></a>.</p> <p><strong>Note:</strong> As this method walks upwards in the scene tree, it can be slow in large, deeply nested nodes. Consider storing a reference to the found node in a variable. Alternatively, use <a href="#class-node-method-get-node"><span class="std std-ref">get_node</span></a> with unique names (see <a href="#class-node-property-unique-name-in-owner"><span class="std std-ref">unique_name_in_owner</span></a>).</p>  <h3 id="class-node-method-get-child">
<a href="#class-node"><span class="std std-ref">Node</span></a> get_child ( <a href="class_int.html#class-int"><span class="std std-ref">int</span></a> idx, <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> include_internal=false ) <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr>
</h3> <p>Fetches a child node by its index. Each child node has an index relative its siblings (see <a href="#class-node-method-get-index"><span class="std std-ref">get_index</span></a>). The first child is at index 0. Negative values can also be used to start from the end of the list. This method can be used in combination with <a href="#class-node-method-get-child-count"><span class="std std-ref">get_child_count</span></a> to iterate over this node's children. If no child exists at the given index, this method returns <code>null</code> and an error is generated.</p> <p>If <code>include_internal</code> is <code>false</code>, internal children are ignored (see <a href="#class-node-method-add-child"><span class="std std-ref">add_child</span></a>'s <code>internal</code> parameter).</p> <pre data-language="gdscript"># Assuming the following are children of this node, in order:
# First, Middle, Last.

var a = get_child(0).name  # a is "First"
var b = get_child(1).name  # b is "Middle"
var b = get_child(2).name  # b is "Last"
var c = get_child(-1).name # c is "Last"
</pre> <p><strong>Note:</strong> To fetch a node by <a href="class_nodepath.html#class-nodepath"><span class="std std-ref">NodePath</span></a>, use <a href="#class-node-method-get-node"><span class="std std-ref">get_node</span></a>.</p>  <h3 id="class-node-method-get-child-count">
<a href="class_int.html#class-int"><span class="std std-ref">int</span></a> get_child_count ( <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> include_internal=false ) <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr>
</h3> <p>Returns the number of children of this node.</p> <p>If <code>include_internal</code> is <code>false</code>, internal children are not counted (see <a href="#class-node-method-add-child"><span class="std std-ref">add_child</span></a>'s <code>internal</code> parameter).</p>  <h3 id="class-node-method-get-children">
<a href="#class-node"><span class="std std-ref">Node[]</span></a> get_children ( <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> include_internal=false ) <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr>
</h3> <p>Returns all children of this node inside an <a href="class_array.html#class-array"><span class="std std-ref">Array</span></a>.</p> <p>If <code>include_internal</code> is <code>false</code>, excludes internal children from the returned array (see <a href="#class-node-method-add-child"><span class="std std-ref">add_child</span></a>'s <code>internal</code> parameter).</p>  <h3 id="class-node-method-get-groups">
<a href="class_stringname.html#class-stringname"><span class="std std-ref">StringName[]</span></a> get_groups ( ) <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr>
</h3> <p>Returns an <a href="class_array.html#class-array"><span class="std std-ref">Array</span></a> of group names that the node has been added to.</p> <p><strong>Note:</strong> To improve performance, the order of group names is <em>not</em> guaranteed and may vary between project runs. Therefore, do not rely on the group order.</p> <p><strong>Note:</strong> This method may also return some group names starting with an underscore (<code>_</code>). These are internally used by the engine. To avoid conflicts, do not use custom groups starting with underscores. To exclude internal groups, see the following code snippet:</p> <div class="sphinx-tabs docutils container"> <strong>GDScript</strong><pre data-language="gdscript"># Stores the node's non-internal groups only (as an array of StringNames).
var non_internal_groups = []
for group in get_groups():
    if not str(group).begins_with("_"):
        non_internal_groups.push_back(group)
</pre> <strong>C#</strong><pre data-language="csharp">// Stores the node's non-internal groups only (as a List of StringNames).
List&lt;string&gt; nonInternalGroups = new List&lt;string&gt;();
foreach (string group in GetGroups())
{
    if (!group.BeginsWith("_"))
        nonInternalGroups.Add(group);
}
</pre> </div>  <h3 id="class-node-method-get-index">
<a href="class_int.html#class-int"><span class="std std-ref">int</span></a> get_index ( <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> include_internal=false ) <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr>
</h3> <p>Returns this node's order among its siblings. The first node's index is <code>0</code>. See also <a href="#class-node-method-get-child"><span class="std std-ref">get_child</span></a>.</p> <p>If <code>include_internal</code> is <code>false</code>, returns the index ignoring internal children. The first, non-internal child will have an index of <code>0</code> (see <a href="#class-node-method-add-child"><span class="std std-ref">add_child</span></a>'s <code>internal</code> parameter).</p>  <h3 id="class-node-method-get-last-exclusive-window">
<a href="class_window.html#class-window"><span class="std std-ref">Window</span></a> get_last_exclusive_window ( ) <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr>
</h3> <p>Returns the <a href="class_window.html#class-window"><span class="std std-ref">Window</span></a> that contains this node, or the last exclusive child in a chain of windows starting with the one that contains this node.</p>  <h3 id="class-node-method-get-multiplayer-authority">
<a href="class_int.html#class-int"><span class="std std-ref">int</span></a> get_multiplayer_authority ( ) <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr>
</h3> <p>Returns the peer ID of the multiplayer authority for this node. See <a href="#class-node-method-set-multiplayer-authority"><span class="std std-ref">set_multiplayer_authority</span></a>.</p>  <h3 id="class-node-method-get-node">
<a href="#class-node"><span class="std std-ref">Node</span></a> get_node ( <a href="class_nodepath.html#class-nodepath"><span class="std std-ref">NodePath</span></a> path ) <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr>
</h3> <p>Fetches a node. The <a href="class_nodepath.html#class-nodepath"><span class="std std-ref">NodePath</span></a> can either be a relative path (from this node), or an absolute path (from the <a href="class_scenetree.html#class-scenetree-property-root"><span class="std std-ref">SceneTree.root</span></a>) to a node. If <code>path</code> does not point to a valid node, generates an error and returns <code>null</code>. Attempts to access methods on the return value will result in an <em>"Attempt to call &lt;method&gt; on a null instance."</em> error.</p> <p><strong>Note:</strong> Fetching by absolute path only works when the node is inside the scene tree (see <a href="#class-node-method-is-inside-tree"><span class="std std-ref">is_inside_tree</span></a>).</p> <p><strong>Example:</strong> Assume this method is called from the Character node, inside the following tree:</p> <pre data-language="gdscript">root
   Character (you are here!)
     Sword
     Backpack
        Dagger
   MyGame
   Swamp
      Alligator
      Mosquito
      Goblin
</pre> <p>The following calls will return a valid node:</p> <div class="sphinx-tabs docutils container"> <strong>GDScript</strong><pre data-language="gdscript">get_node("Sword")
get_node("Backpack/Dagger")
get_node("../Swamp/Alligator")
get_node("/root/MyGame")
</pre> <strong>C#</strong><pre data-language="csharp">GetNode("Sword");
GetNode("Backpack/Dagger");
GetNode("../Swamp/Alligator");
GetNode("/root/MyGame");
</pre> </div>  <h3 id="class-node-method-get-node-and-resource">
<a href="class_array.html#class-array"><span class="std std-ref">Array</span></a> get_node_and_resource ( <a href="class_nodepath.html#class-nodepath"><span class="std std-ref">NodePath</span></a> path )</h3> <p>Fetches a node and its most nested resource as specified by the <a href="class_nodepath.html#class-nodepath"><span class="std std-ref">NodePath</span></a>'s subname. Returns an <a href="class_array.html#class-array"><span class="std std-ref">Array</span></a> of size <code>3</code> where:</p> <ul class="simple"> <li>Element <code>0</code> is the <strong>Node</strong>, or <code>null</code> if not found;</li> <li>Element <code>1</code> is the subname's last nested <a href="class_resource.html#class-resource"><span class="std std-ref">Resource</span></a>, or <code>null</code> if not found;</li> <li>Element <code>2</code> is the remaining <a href="class_nodepath.html#class-nodepath"><span class="std std-ref">NodePath</span></a>, referring to an existing, non-<a href="class_resource.html#class-resource"><span class="std std-ref">Resource</span></a> property (see <a href="class_object.html#class-object-method-get-indexed"><span class="std std-ref">Object.get_indexed</span></a>).</li> </ul> <p><strong>Example:</strong> Assume that the child's <a href="class_sprite2d.html#class-sprite2d-property-texture"><span class="std std-ref">Sprite2D.texture</span></a> has been assigned a <a href="class_atlastexture.html#class-atlastexture"><span class="std std-ref">AtlasTexture</span></a>:</p> <div class="sphinx-tabs docutils container"> <strong>GDScript</strong><pre data-language="gdscript">var a = get_node_and_resource("Area2D/Sprite2D")
print(a[0].name) # Prints Sprite2D
print(a[1])      # Prints &lt;null&gt;
print(a[2])      # Prints ^""

var b = get_node_and_resource("Area2D/Sprite2D:texture:atlas")
print(b[0].name)        # Prints Sprite2D
print(b[1].get_class()) # Prints AtlasTexture
print(b[2])             # Prints ^""

var c = get_node_and_resource("Area2D/Sprite2D:texture:atlas:region")
print(c[0].name)        # Prints Sprite2D
print(c[1].get_class()) # Prints AtlasTexture
print(c[2])             # Prints ^":region"
</pre> <strong>C#</strong><pre data-language="csharp">var a = GetNodeAndResource(NodePath("Area2D/Sprite2D"));
GD.Print(a[0].Name); // Prints Sprite2D
GD.Print(a[1]);      // Prints &lt;null&gt;
GD.Print(a[2]);      // Prints ^"

var b = GetNodeAndResource(NodePath("Area2D/Sprite2D:texture:atlas"));
GD.Print(b[0].name);        // Prints Sprite2D
GD.Print(b[1].get_class()); // Prints AtlasTexture
GD.Print(b[2]);             // Prints ^""

var c = GetNodeAndResource(NodePath("Area2D/Sprite2D:texture:atlas:region"));
GD.Print(c[0].name);        // Prints Sprite2D
GD.Print(c[1].get_class()); // Prints AtlasTexture
GD.Print(c[2]);             // Prints ^":region"
</pre> </div>  <h3 id="class-node-method-get-node-or-null">
<a href="#class-node"><span class="std std-ref">Node</span></a> get_node_or_null ( <a href="class_nodepath.html#class-nodepath"><span class="std std-ref">NodePath</span></a> path ) <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr>
</h3> <p>Fetches a node by <a href="class_nodepath.html#class-nodepath"><span class="std std-ref">NodePath</span></a>. Similar to <a href="#class-node-method-get-node"><span class="std std-ref">get_node</span></a>, but does not generate an error if <code>path</code> does not point to a valid node.</p>  <h3 id="class-node-method-get-parent">
<a href="#class-node"><span class="std std-ref">Node</span></a> get_parent ( ) <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr>
</h3> <p>Returns this node's parent node, or <code>null</code> if the node doesn't have a parent.</p>  <h3 id="class-node-method-get-path">
<a href="class_nodepath.html#class-nodepath"><span class="std std-ref">NodePath</span></a> get_path ( ) <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr>
</h3> <p>Returns the node's absolute path, relative to the <a href="class_scenetree.html#class-scenetree-property-root"><span class="std std-ref">SceneTree.root</span></a>. If the node is not inside the scene tree, this method fails and returns an empty <a href="class_nodepath.html#class-nodepath"><span class="std std-ref">NodePath</span></a>.</p>  <h3 id="class-node-method-get-path-to">
<a href="class_nodepath.html#class-nodepath"><span class="std std-ref">NodePath</span></a> get_path_to ( <a href="#class-node"><span class="std std-ref">Node</span></a> node, <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> use_unique_path=false ) <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr>
</h3> <p>Returns the relative <a href="class_nodepath.html#class-nodepath"><span class="std std-ref">NodePath</span></a> from this node to the specified <code>node</code>. Both nodes must be in the same <a href="class_scenetree.html#class-scenetree"><span class="std std-ref">SceneTree</span></a>, otherwise this method fails and returns an empty <a href="class_nodepath.html#class-nodepath"><span class="std std-ref">NodePath</span></a>.</p> <p>If <code>use_unique_path</code> is <code>true</code>, returns the shortest path accounting for this node's unique name (see <a href="#class-node-property-unique-name-in-owner"><span class="std std-ref">unique_name_in_owner</span></a>).</p> <p><strong>Note:</strong> If you get a relative path which starts from a unique node, the path may be longer than a normal relative path, due to the addition of the unique node's name.</p>  <h3 id="class-node-method-get-physics-process-delta-time">
<a href="class_float.html#class-float"><span class="std std-ref">float</span></a> get_physics_process_delta_time ( ) <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr>
</h3> <p>Returns the time elapsed (in seconds) since the last physics callback. This value is identical to <a href="#class-node-private-method-physics-process"><span class="std std-ref">_physics_process</span></a>'s <code>delta</code> parameter, and is often consistent at run-time, unless <a href="class_engine.html#class-engine-property-physics-ticks-per-second"><span class="std std-ref">Engine.physics_ticks_per_second</span></a> is changed. See also <a href="#class-node-constant-notification-physics-process"><span class="std std-ref">NOTIFICATION_PHYSICS_PROCESS</span></a>.</p>  <h3 id="class-node-method-get-process-delta-time">
<a href="class_float.html#class-float"><span class="std std-ref">float</span></a> get_process_delta_time ( ) <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr>
</h3> <p>Returns the time elapsed (in seconds) since the last process callback. This value is identical to <a href="#class-node-private-method-process"><span class="std std-ref">_process</span></a>'s <code>delta</code> parameter, and may vary from frame to frame. See also <a href="#class-node-constant-notification-process"><span class="std std-ref">NOTIFICATION_PROCESS</span></a>.</p>  <h3 id="class-node-method-get-scene-instance-load-placeholder">
<a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> get_scene_instance_load_placeholder ( ) <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr>
</h3> <p>Returns <code>true</code> if this node is an instance load placeholder. See <a href="class_instanceplaceholder.html#class-instanceplaceholder"><span class="std std-ref">InstancePlaceholder</span></a> and <a href="#class-node-method-set-scene-instance-load-placeholder"><span class="std std-ref">set_scene_instance_load_placeholder</span></a>.</p>  <h3 id="class-node-method-get-tree">
<a href="class_scenetree.html#class-scenetree"><span class="std std-ref">SceneTree</span></a> get_tree ( ) <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr>
</h3> <p>Returns the <a href="class_scenetree.html#class-scenetree"><span class="std std-ref">SceneTree</span></a> that contains this node. If this node is not inside the tree, generates an error and returns <code>null</code>. See also <a href="#class-node-method-is-inside-tree"><span class="std std-ref">is_inside_tree</span></a>.</p>  <h3 id="class-node-method-get-tree-string">
<a href="class_string.html#class-string"><span class="std std-ref">String</span></a> get_tree_string ( )</h3> <p>Returns the tree as a <a href="class_string.html#class-string"><span class="std std-ref">String</span></a>. Used mainly for debugging purposes. This version displays the path relative to the current node, and is good for copy/pasting into the <a href="#class-node-method-get-node"><span class="std std-ref">get_node</span></a> function. It also can be used in game UI/UX.</p> <p><strong>Example output:</strong></p> <pre data-language="gdscript">TheGame
TheGame/Menu
TheGame/Menu/Label
TheGame/Menu/Camera2D
TheGame/SplashScreen
TheGame/SplashScreen/Camera2D
</pre>  <h3 id="class-node-method-get-tree-string-pretty">
<a href="class_string.html#class-string"><span class="std std-ref">String</span></a> get_tree_string_pretty ( )</h3> <p>Similar to <a href="#class-node-method-get-tree-string"><span class="std std-ref">get_tree_string</span></a>, this returns the tree as a <a href="class_string.html#class-string"><span class="std std-ref">String</span></a>. This version displays a more graphical representation similar to what is displayed in the Scene Dock. It is useful for inspecting larger trees.</p> <p><strong>Example output:</strong></p> <pre data-language="gdscript">TheGame
   Menu
     Label
     Camera2D
   SplashScreen
      Camera2D
</pre>  <h3 id="class-node-method-get-viewport">
<a href="class_viewport.html#class-viewport"><span class="std std-ref">Viewport</span></a> get_viewport ( ) <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr>
</h3> <p>Returns the node's closest <a href="class_viewport.html#class-viewport"><span class="std std-ref">Viewport</span></a> ancestor, if the node is inside the tree. Otherwise, returns <code>null</code>.</p>  <h3 id="class-node-method-get-window">
<a href="class_window.html#class-window"><span class="std std-ref">Window</span></a> get_window ( ) <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr>
</h3> <p>Returns the <a href="class_window.html#class-window"><span class="std std-ref">Window</span></a> that contains this node. If the node is in the main window, this is equivalent to getting the root node (<code>get_tree().get_root()</code>).</p>  <h3 id="class-node-method-has-node">
<a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> has_node ( <a href="class_nodepath.html#class-nodepath"><span class="std std-ref">NodePath</span></a> path ) <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr>
</h3> <p>Returns <code>true</code> if the <code>path</code> points to a valid node. See also <a href="#class-node-method-get-node"><span class="std std-ref">get_node</span></a>.</p>  <h3 id="class-node-method-has-node-and-resource">
<a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> has_node_and_resource ( <a href="class_nodepath.html#class-nodepath"><span class="std std-ref">NodePath</span></a> path ) <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr>
</h3> <p>Returns <code>true</code> if <code>path</code> points to a valid node and its subnames point to a valid <a href="class_resource.html#class-resource"><span class="std std-ref">Resource</span></a>, e.g. <code>Area2D/CollisionShape2D:shape</code>. Properties that are not <a href="class_resource.html#class-resource"><span class="std std-ref">Resource</span></a> types (such as nodes or other <a href="class_variant.html#class-variant"><span class="std std-ref">Variant</span></a> types) are not considered. See also <a href="#class-node-method-get-node-and-resource"><span class="std std-ref">get_node_and_resource</span></a>.</p>  <h3 id="class-node-method-is-ancestor-of">
<a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> is_ancestor_of ( <a href="#class-node"><span class="std std-ref">Node</span></a> node ) <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr>
</h3> <p>Returns <code>true</code> if the given <code>node</code> is a direct or indirect child of this node.</p>  <h3 id="class-node-method-is-displayed-folded">
<a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> is_displayed_folded ( ) <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr>
</h3> <p>Returns <code>true</code> if the node is folded (collapsed) in the Scene dock. This method is intended to be used in editor plugins and tools. See also <a href="#class-node-method-set-display-folded"><span class="std std-ref">set_display_folded</span></a>.</p>  <h3 id="class-node-method-is-editable-instance">
<a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> is_editable_instance ( <a href="#class-node"><span class="std std-ref">Node</span></a> node ) <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr>
</h3> <p>Returns <code>true</code> if <code>node</code> has editable children enabled relative to this node. This method is intended to be used in editor plugins and tools. See also <a href="#class-node-method-set-editable-instance"><span class="std std-ref">set_editable_instance</span></a>.</p>  <h3 id="class-node-method-is-greater-than">
<a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> is_greater_than ( <a href="#class-node"><span class="std std-ref">Node</span></a> node ) <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr>
</h3> <p>Returns <code>true</code> if the given <code>node</code> occurs later in the scene hierarchy than this node. A node occurring later is usually processed last.</p>  <h3 id="class-node-method-is-in-group">
<a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> is_in_group ( <a href="class_stringname.html#class-stringname"><span class="std std-ref">StringName</span></a> group ) <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr>
</h3> <p>Returns <code>true</code> if this node has been added to the given <code>group</code>. See <a href="#class-node-method-add-to-group"><span class="std std-ref">add_to_group</span></a> and <a href="#class-node-method-remove-from-group"><span class="std std-ref">remove_from_group</span></a>. See also notes in the description, and the <a href="class_scenetree.html#class-scenetree"><span class="std std-ref">SceneTree</span></a>'s group methods.</p>  <h3 id="class-node-method-is-inside-tree">
<a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> is_inside_tree ( ) <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr>
</h3> <p>Returns <code>true</code> if this node is currently inside a <a href="class_scenetree.html#class-scenetree"><span class="std std-ref">SceneTree</span></a>. See also <a href="#class-node-method-get-tree"><span class="std std-ref">get_tree</span></a>.</p>  <h3 id="class-node-method-is-multiplayer-authority">
<a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> is_multiplayer_authority ( ) <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr>
</h3> <p>Returns <code>true</code> if the local system is the multiplayer authority of this node.</p>  <h3 id="class-node-method-is-node-ready">
<a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> is_node_ready ( ) <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr>
</h3> <p>Returns <code>true</code> if the node is ready, i.e. it's inside scene tree and all its children are initialized.</p> <p><a href="#class-node-method-request-ready"><span class="std std-ref">request_ready</span></a> resets it back to <code>false</code>.</p>  <h3 id="class-node-method-is-physics-processing">
<a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> is_physics_processing ( ) <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr>
</h3> <p>Returns <code>true</code> if physics processing is enabled (see <a href="#class-node-method-set-physics-process"><span class="std std-ref">set_physics_process</span></a>).</p>  <h3 id="class-node-method-is-physics-processing-internal">
<a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> is_physics_processing_internal ( ) <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr>
</h3> <p>Returns <code>true</code> if internal physics processing is enabled (see <a href="#class-node-method-set-physics-process-internal"><span class="std std-ref">set_physics_process_internal</span></a>).</p>  <h3 id="class-node-method-is-processing">
<a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> is_processing ( ) <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr>
</h3> <p>Returns <code>true</code> if processing is enabled (see <a href="#class-node-method-set-process"><span class="std std-ref">set_process</span></a>).</p>  <h3 id="class-node-method-is-processing-input">
<a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> is_processing_input ( ) <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr>
</h3> <p>Returns <code>true</code> if the node is processing input (see <a href="#class-node-method-set-process-input"><span class="std std-ref">set_process_input</span></a>).</p>  <h3 id="class-node-method-is-processing-internal">
<a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> is_processing_internal ( ) <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr>
</h3> <p>Returns <code>true</code> if internal processing is enabled (see <a href="#class-node-method-set-process-internal"><span class="std std-ref">set_process_internal</span></a>).</p>  <h3 id="class-node-method-is-processing-shortcut-input">
<a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> is_processing_shortcut_input ( ) <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr>
</h3> <p>Returns <code>true</code> if the node is processing shortcuts (see <a href="#class-node-method-set-process-shortcut-input"><span class="std std-ref">set_process_shortcut_input</span></a>).</p>  <h3 id="class-node-method-is-processing-unhandled-input">
<a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> is_processing_unhandled_input ( ) <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr>
</h3> <p>Returns <code>true</code> if the node is processing unhandled input (see <a href="#class-node-method-set-process-unhandled-input"><span class="std std-ref">set_process_unhandled_input</span></a>).</p>  <h3 id="class-node-method-is-processing-unhandled-key-input">
<a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> is_processing_unhandled_key_input ( ) <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr>
</h3> <p>Returns <code>true</code> if the node is processing unhandled key input (see <a href="#class-node-method-set-process-unhandled-key-input"><span class="std std-ref">set_process_unhandled_key_input</span></a>).</p>  <h3 id="class-node-method-move-child">void move_child ( <a href="#class-node"><span class="std std-ref">Node</span></a> child_node, <a href="class_int.html#class-int"><span class="std std-ref">int</span></a> to_index )</h3> <p>Moves <code>child_node</code> to the given index. A node's index is the order among its siblings. If <code>to_index</code> is negative, the index is counted from the end of the list. See also <a href="#class-node-method-get-child"><span class="std std-ref">get_child</span></a> and <a href="#class-node-method-get-index"><span class="std std-ref">get_index</span></a>.</p> <p><strong>Note:</strong> The processing order of several engine callbacks (<a href="#class-node-private-method-ready"><span class="std std-ref">_ready</span></a>, <a href="#class-node-private-method-process"><span class="std std-ref">_process</span></a>, etc.) and notifications sent through <a href="#class-node-method-propagate-notification"><span class="std std-ref">propagate_notification</span></a> is affected by tree order. <a href="class_canvasitem.html#class-canvasitem"><span class="std std-ref">CanvasItem</span></a> nodes are also rendered in tree order. See also <a href="#class-node-property-process-priority"><span class="std std-ref">process_priority</span></a>.</p>  <h3 id="class-node-method-notify-deferred-thread-group">void notify_deferred_thread_group ( <a href="class_int.html#class-int"><span class="std std-ref">int</span></a> what )</h3> <p>Similar to <a href="#class-node-method-call-deferred-thread-group"><span class="std std-ref">call_deferred_thread_group</span></a>, but for notifications.</p>  <h3 id="class-node-method-notify-thread-safe">void notify_thread_safe ( <a href="class_int.html#class-int"><span class="std std-ref">int</span></a> what )</h3> <p>Similar to <a href="#class-node-method-call-thread-safe"><span class="std std-ref">call_thread_safe</span></a>, but for notifications.</p>  <h3 id="class-node-method-print-orphan-nodes">void print_orphan_nodes ( ) <abbr title="This method doesn't need an instance to be called, so it can be called directly using the class name.">static</abbr>
</h3> <p>Prints all orphan nodes (nodes outside the <a href="class_scenetree.html#class-scenetree"><span class="std std-ref">SceneTree</span></a>). Useful for debugging.</p> <p><strong>Note:</strong> This method only works in debug builds. Does nothing in a project exported in release mode.</p>  <h3 id="class-node-method-print-tree">void print_tree ( )</h3> <p>Prints the node and its children to the console, recursively. The node does not have to be inside the tree. This method outputs <a href="class_nodepath.html#class-nodepath"><span class="std std-ref">NodePath</span></a>s relative to this node, and is good for copy/pasting into <a href="#class-node-method-get-node"><span class="std std-ref">get_node</span></a>. See also <a href="#class-node-method-print-tree-pretty"><span class="std std-ref">print_tree_pretty</span></a>.</p> <p><strong>Example output:</strong></p> <pre data-language="gdscript">.
Menu
Menu/Label
Menu/Camera2D
SplashScreen
SplashScreen/Camera2D
</pre>  <h3 id="class-node-method-print-tree-pretty">void print_tree_pretty ( )</h3> <p>Prints the node and its children to the console, recursively. The node does not have to be inside the tree. Similar to <a href="#class-node-method-print-tree"><span class="std std-ref">print_tree</span></a>, but the graphical representation looks like what is displayed in the editor's Scene dock. It is useful for inspecting larger trees.</p> <p><strong>Example output:</strong></p> <pre data-language="gdscript">TheGame
   Menu
     Label
     Camera2D
   SplashScreen
      Camera2D
</pre>  <h3 id="class-node-method-propagate-call">void propagate_call ( <a href="class_stringname.html#class-stringname"><span class="std std-ref">StringName</span></a> method, <a href="class_array.html#class-array"><span class="std std-ref">Array</span></a> args=[], <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> parent_first=false )</h3> <p>Calls the given <code>method</code> name, passing <code>args</code> as arguments, on this node and all of its children, recursively.</p> <p>If <code>parent_first</code> is <code>true</code>, the method is called on this node first, then on all of its children. If <code>false</code>, the children's methods are called first.</p>  <h3 id="class-node-method-propagate-notification">void propagate_notification ( <a href="class_int.html#class-int"><span class="std std-ref">int</span></a> what )</h3> <p>Calls <a href="class_object.html#class-object-method-notification"><span class="std std-ref">Object.notification</span></a> with <code>what</code> on this node and all of its children, recursively.</p>  <h3 id="class-node-method-queue-free">void queue_free ( )</h3> <p>Queues this node to be deleted at the end of the current frame. When deleted, all of its children are deleted as well, and all references to the node and its children become invalid.</p> <p>Unlike with <a href="class_object.html#class-object-method-free"><span class="std std-ref">Object.free</span></a>, the node is not deleted instantly, and it can still be accessed before deletion. It is also safe to call <a href="#class-node-method-queue-free"><span class="std std-ref">queue_free</span></a> multiple times. Use <a href="class_object.html#class-object-method-is-queued-for-deletion"><span class="std std-ref">Object.is_queued_for_deletion</span></a> to check if the node will be deleted at the end of the frame.</p> <p><strong>Note:</strong> The node will only be freed after all other deferred calls are finished. Using this method is not always the same as calling <a href="class_object.html#class-object-method-free"><span class="std std-ref">Object.free</span></a> through <a href="class_object.html#class-object-method-call-deferred"><span class="std std-ref">Object.call_deferred</span></a>.</p>  <h3 id="class-node-method-remove-child">void remove_child ( <a href="#class-node"><span class="std std-ref">Node</span></a> node )</h3> <p>Removes a child <code>node</code>. The <code>node</code>, along with its children, are <strong>not</strong> deleted. To delete a node, see <a href="#class-node-method-queue-free"><span class="std std-ref">queue_free</span></a>.</p> <p><strong>Note:</strong> When this node is inside the tree, this method sets the <a href="#class-node-property-owner"><span class="std std-ref">owner</span></a> of the removed <code>node</code> (or its descendants) to <code>null</code>, if their <a href="#class-node-property-owner"><span class="std std-ref">owner</span></a> is no longer an ancestor (see <a href="#class-node-method-is-ancestor-of"><span class="std std-ref">is_ancestor_of</span></a>).</p>  <h3 id="class-node-method-remove-from-group">void remove_from_group ( <a href="class_stringname.html#class-stringname"><span class="std std-ref">StringName</span></a> group )</h3> <p>Removes the node from the given <code>group</code>. Does nothing if the node is not in the <code>group</code>. See also notes in the description, and the <a href="class_scenetree.html#class-scenetree"><span class="std std-ref">SceneTree</span></a>'s group methods.</p>  <h3 id="class-node-method-reparent">void reparent ( <a href="#class-node"><span class="std std-ref">Node</span></a> new_parent, <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> keep_global_transform=true )</h3> <p>Changes the parent of this <strong>Node</strong> to the <code>new_parent</code>. The node needs to already have a parent.</p> <p>If <code>keep_global_transform</code> is <code>true</code>, the node's global transform will be preserved if supported. <a href="class_node2d.html#class-node2d"><span class="std std-ref">Node2D</span></a>, <a href="class_node3d.html#class-node3d"><span class="std std-ref">Node3D</span></a> and <a href="class_control.html#class-control"><span class="std std-ref">Control</span></a> support this argument (but <a href="class_control.html#class-control"><span class="std std-ref">Control</span></a> keeps only position).</p>  <h3 id="class-node-method-replace-by">void replace_by ( <a href="#class-node"><span class="std std-ref">Node</span></a> node, <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> keep_groups=false )</h3> <p>Replaces this node by the given <code>node</code>. All children of this node are moved to <code>node</code>.</p> <p>If <code>keep_groups</code> is <code>true</code>, the <code>node</code> is added to the same groups that the replaced node is in (see <a href="#class-node-method-add-to-group"><span class="std std-ref">add_to_group</span></a>).</p> <p><strong>Warning:</strong> The replaced node is removed from the tree, but it is <strong>not</strong> deleted. To prevent memory leaks, store a reference to the node in a variable, or use <a href="class_object.html#class-object-method-free"><span class="std std-ref">Object.free</span></a>.</p>  <h3 id="class-node-method-request-ready">void request_ready ( )</h3> <p>Requests <a href="#class-node-private-method-ready"><span class="std std-ref">_ready</span></a> to be called again the next time the node enters the tree. Does <strong>not</strong> immediately call <a href="#class-node-private-method-ready"><span class="std std-ref">_ready</span></a>.</p> <p><strong>Note:</strong> This method only affects the current node. If the node's children also need to request ready, this method needs to be called for each one of them. When the node and its children enter the tree again, the order of <a href="#class-node-private-method-ready"><span class="std std-ref">_ready</span></a> callbacks will be the same as normal.</p>  <h3 id="class-node-method-rpc">
<a href="class_%40globalscope.html#enum-globalscope-error"><span class="std std-ref">Error</span></a> rpc ( <a href="class_stringname.html#class-stringname"><span class="std std-ref">StringName</span></a> method, ... ) <abbr title="This method accepts any number of arguments after the ones described here.">vararg</abbr>
</h3> <p>Sends a remote procedure call request for the given <code>method</code> to peers on the network (and locally), sending additional arguments to the method called by the RPC. The call request will only be received by nodes with the same <a href="class_nodepath.html#class-nodepath"><span class="std std-ref">NodePath</span></a>, including the exact same <a href="#class-node-property-name"><span class="std std-ref">name</span></a>. Behavior depends on the RPC configuration for the given <code>method</code> (see <a href="#class-node-method-rpc-config"><span class="std std-ref">rpc_config</span></a> and <a href="class_%40gdscript.html#class-gdscript-annotation-rpc"><span class="std std-ref">@GDScript.@rpc</span></a>). By default, methods are not exposed to RPCs.</p> <p>May return <a href="class_%40globalscope.html#class-globalscope-constant-ok"><span class="std std-ref">@GlobalScope.OK</span></a> if the call is successful, <a href="class_%40globalscope.html#class-globalscope-constant-err-invalid-parameter"><span class="std std-ref">@GlobalScope.ERR_INVALID_PARAMETER</span></a> if the arguments passed in the <code>method</code> do not match, <a href="class_%40globalscope.html#class-globalscope-constant-err-unconfigured"><span class="std std-ref">@GlobalScope.ERR_UNCONFIGURED</span></a> if the node's <a href="#class-node-property-multiplayer"><span class="std std-ref">multiplayer</span></a> cannot be fetched (such as when the node is not inside the tree), <a href="class_%40globalscope.html#class-globalscope-constant-err-connection-error"><span class="std std-ref">@GlobalScope.ERR_CONNECTION_ERROR</span></a> if <a href="#class-node-property-multiplayer"><span class="std std-ref">multiplayer</span></a>'s connection is not available.</p> <p><strong>Note:</strong> You can only safely use RPCs on clients after you received the <a href="class_multiplayerapi.html#class-multiplayerapi-signal-connected-to-server"><span class="std std-ref">MultiplayerAPI.connected_to_server</span></a> signal from the <a href="class_multiplayerapi.html#class-multiplayerapi"><span class="std std-ref">MultiplayerAPI</span></a>. You also need to keep track of the connection state, either by the <a href="class_multiplayerapi.html#class-multiplayerapi"><span class="std std-ref">MultiplayerAPI</span></a> signals like <a href="class_multiplayerapi.html#class-multiplayerapi-signal-server-disconnected"><span class="std std-ref">MultiplayerAPI.server_disconnected</span></a> or by checking (<code>get_multiplayer().peer.get_connection_status() == CONNECTION_CONNECTED</code>).</p>  <h3 id="class-node-method-rpc-config">void rpc_config ( <a href="class_stringname.html#class-stringname"><span class="std std-ref">StringName</span></a> method, <a href="class_variant.html#class-variant"><span class="std std-ref">Variant</span></a> config )</h3> <p>Changes the RPC configuration for the given <code>method</code>. <code>config</code> should either be <code>null</code> to disable the feature (as by default), or a <a href="class_dictionary.html#class-dictionary"><span class="std std-ref">Dictionary</span></a> containing the following entries:</p> <ul class="simple"> <li>
<code>rpc_mode</code>: see <a href="class_multiplayerapi.html#enum-multiplayerapi-rpcmode"><span class="std std-ref">RPCMode</span></a>;</li> <li>
<code>transfer_mode</code>: see <a href="class_multiplayerpeer.html#enum-multiplayerpeer-transfermode"><span class="std std-ref">TransferMode</span></a>;</li> <li>
<code>call_local</code>: if <code>true</code>, the method will also be called locally;</li> <li>
<code>channel</code>: an <a href="class_int.html#class-int"><span class="std std-ref">int</span></a> representing the channel to send the RPC on.</li> </ul> <p><strong>Note:</strong> In GDScript, this method corresponds to the <a href="class_%40gdscript.html#class-gdscript-annotation-rpc"><span class="std std-ref">@GDScript.@rpc</span></a> annotation, with various parameters passed (<code>@rpc(any)</code>, <code>@rpc(authority)</code>...). See also the <a href="https://docs.godotengine.org/en/4.2/tutorials/networking/high_level_multiplayer.html"><span class="doc">high-level multiplayer</span></a> tutorial.</p>  <h3 id="class-node-method-rpc-id">
<a href="class_%40globalscope.html#enum-globalscope-error"><span class="std std-ref">Error</span></a> rpc_id ( <a href="class_int.html#class-int"><span class="std std-ref">int</span></a> peer_id, <a href="class_stringname.html#class-stringname"><span class="std std-ref">StringName</span></a> method, ... ) <abbr title="This method accepts any number of arguments after the ones described here.">vararg</abbr>
</h3> <p>Sends a <a href="#class-node-method-rpc"><span class="std std-ref">rpc</span></a> to a specific peer identified by <code>peer_id</code> (see <a href="class_multiplayerpeer.html#class-multiplayerpeer-method-set-target-peer"><span class="std std-ref">MultiplayerPeer.set_target_peer</span></a>).</p> <p>May return <a href="class_%40globalscope.html#class-globalscope-constant-ok"><span class="std std-ref">@GlobalScope.OK</span></a> if the call is successful, <a href="class_%40globalscope.html#class-globalscope-constant-err-invalid-parameter"><span class="std std-ref">@GlobalScope.ERR_INVALID_PARAMETER</span></a> if the arguments passed in the <code>method</code> do not match, <a href="class_%40globalscope.html#class-globalscope-constant-err-unconfigured"><span class="std std-ref">@GlobalScope.ERR_UNCONFIGURED</span></a> if the node's <a href="#class-node-property-multiplayer"><span class="std std-ref">multiplayer</span></a> cannot be fetched (such as when the node is not inside the tree), <a href="class_%40globalscope.html#class-globalscope-constant-err-connection-error"><span class="std std-ref">@GlobalScope.ERR_CONNECTION_ERROR</span></a> if <a href="#class-node-property-multiplayer"><span class="std std-ref">multiplayer</span></a>'s connection is not available.</p>  <h3 id="class-node-method-set-deferred-thread-group">void set_deferred_thread_group ( <a href="class_stringname.html#class-stringname"><span class="std std-ref">StringName</span></a> property, <a href="class_variant.html#class-variant"><span class="std std-ref">Variant</span></a> value )</h3> <p>Similar to <a href="#class-node-method-call-deferred-thread-group"><span class="std std-ref">call_deferred_thread_group</span></a>, but for setting properties.</p>  <h3 id="class-node-method-set-display-folded">void set_display_folded ( <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> fold )</h3> <p>If set to <code>true</code>, the node appears folded in the Scene dock. As a result, all of its children are hidden. This method is intended to be used in editor plugins and tools, but it also works in release builds. See also <a href="#class-node-method-is-displayed-folded"><span class="std std-ref">is_displayed_folded</span></a>.</p>  <h3 id="class-node-method-set-editable-instance">void set_editable_instance ( <a href="#class-node"><span class="std std-ref">Node</span></a> node, <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> is_editable )</h3> <p>Set to <code>true</code> to allow all nodes owned by <code>node</code> to be available, and editable, in the Scene dock, even if their <a href="#class-node-property-owner"><span class="std std-ref">owner</span></a> is not the scene root. This method is intended to be used in editor plugins and tools, but it also works in release builds. See also <a href="#class-node-method-is-editable-instance"><span class="std std-ref">is_editable_instance</span></a>.</p>  <h3 id="class-node-method-set-multiplayer-authority">void set_multiplayer_authority ( <a href="class_int.html#class-int"><span class="std std-ref">int</span></a> id, <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> recursive=true )</h3> <p>Sets the node's multiplayer authority to the peer with the given peer <code>id</code>. The multiplayer authority is the peer that has authority over the node on the network. Defaults to peer ID 1 (the server). Useful in conjunction with <a href="#class-node-method-rpc-config"><span class="std std-ref">rpc_config</span></a> and the <a href="class_multiplayerapi.html#class-multiplayerapi"><span class="std std-ref">MultiplayerAPI</span></a>.</p> <p>If <code>recursive</code> is <code>true</code>, the given peer is recursively set as the authority for all children of this node.</p> <p><strong>Warning:</strong> This does <strong>not</strong> automatically replicate the new authority to other peers. It is the developer's responsibility to do so. You may replicate the new authority's information using <a href="class_multiplayerspawner.html#class-multiplayerspawner-property-spawn-function"><span class="std std-ref">MultiplayerSpawner.spawn_function</span></a>, an RPC, or a <a href="class_multiplayersynchronizer.html#class-multiplayersynchronizer"><span class="std std-ref">MultiplayerSynchronizer</span></a>. Furthermore, the parent's authority does <strong>not</strong> propagate to newly added children.</p>  <h3 id="class-node-method-set-physics-process">void set_physics_process ( <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> enable )</h3> <p>If set to <code>true</code>, enables physics (fixed framerate) processing. When a node is being processed, it will receive a <a href="#class-node-constant-notification-physics-process"><span class="std std-ref">NOTIFICATION_PHYSICS_PROCESS</span></a> at a fixed (usually 60 FPS, see <a href="class_engine.html#class-engine-property-physics-ticks-per-second"><span class="std std-ref">Engine.physics_ticks_per_second</span></a> to change) interval (and the <a href="#class-node-private-method-physics-process"><span class="std std-ref">_physics_process</span></a> callback will be called if exists). Enabled automatically if <a href="#class-node-private-method-physics-process"><span class="std std-ref">_physics_process</span></a> is overridden.</p>  <h3 id="class-node-method-set-physics-process-internal">void set_physics_process_internal ( <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> enable )</h3> <p>If set to <code>true</code>, enables internal physics for this node. Internal physics processing happens in isolation from the normal <a href="#class-node-private-method-physics-process"><span class="std std-ref">_physics_process</span></a> calls and is used by some nodes internally to guarantee proper functioning even if the node is paused or physics processing is disabled for scripting (<a href="#class-node-method-set-physics-process"><span class="std std-ref">set_physics_process</span></a>).</p> <p><strong>Warning:</strong> Built-in nodes rely on internal processing for their internal logic. Disabling it is unsafe and may lead to unexpected behavior. Use this method if you know what you are doing.</p>  <h3 id="class-node-method-set-process">void set_process ( <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> enable )</h3> <p>If set to <code>true</code>, enables processing. When a node is being processed, it will receive a <a href="#class-node-constant-notification-process"><span class="std std-ref">NOTIFICATION_PROCESS</span></a> on every drawn frame (and the <a href="#class-node-private-method-process"><span class="std std-ref">_process</span></a> callback will be called if exists). Enabled automatically if <a href="#class-node-private-method-process"><span class="std std-ref">_process</span></a> is overridden.</p>  <h3 id="class-node-method-set-process-input">void set_process_input ( <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> enable )</h3> <p>If set to <code>true</code>, enables input processing. This is not required for GUI controls! Enabled automatically if <a href="#class-node-private-method-input"><span class="std std-ref">_input</span></a> is overridden.</p>  <h3 id="class-node-method-set-process-internal">void set_process_internal ( <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> enable )</h3> <p>If set to <code>true</code>, enables internal processing for this node. Internal processing happens in isolation from the normal <a href="#class-node-private-method-process"><span class="std std-ref">_process</span></a> calls and is used by some nodes internally to guarantee proper functioning even if the node is paused or processing is disabled for scripting (<a href="#class-node-method-set-process"><span class="std std-ref">set_process</span></a>).</p> <p><strong>Warning:</strong> Built-in nodes rely on internal processing for their internal logic. Disabling it is unsafe and may lead to unexpected behavior. Use this method if you know what you are doing.</p>  <h3 id="class-node-method-set-process-shortcut-input">void set_process_shortcut_input ( <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> enable )</h3> <p>If set to <code>true</code>, enables shortcut processing for this node. Enabled automatically if <a href="#class-node-private-method-shortcut-input"><span class="std std-ref">_shortcut_input</span></a> is overridden.</p>  <h3 id="class-node-method-set-process-unhandled-input">void set_process_unhandled_input ( <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> enable )</h3> <p>If set to <code>true</code>, enables unhandled input processing. This is not required for GUI controls! It enables the node to receive all input that was not previously handled (usually by a <a href="class_control.html#class-control"><span class="std std-ref">Control</span></a>). Enabled automatically if <a href="#class-node-private-method-unhandled-input"><span class="std std-ref">_unhandled_input</span></a> is overridden.</p>  <h3 id="class-node-method-set-process-unhandled-key-input">void set_process_unhandled_key_input ( <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> enable )</h3> <p>If set to <code>true</code>, enables unhandled key input processing. Enabled automatically if <a href="#class-node-private-method-unhandled-key-input"><span class="std std-ref">_unhandled_key_input</span></a> is overridden.</p>  <h3 id="class-node-method-set-scene-instance-load-placeholder">void set_scene_instance_load_placeholder ( <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> load_placeholder )</h3> <p>If set to <code>true</code>, the node becomes a <a href="class_instanceplaceholder.html#class-instanceplaceholder"><span class="std std-ref">InstancePlaceholder</span></a> when packed and instantiated from a <a href="class_packedscene.html#class-packedscene"><span class="std std-ref">PackedScene</span></a>. See also <a href="#class-node-method-get-scene-instance-load-placeholder"><span class="std std-ref">get_scene_instance_load_placeholder</span></a>.</p>  <h3 id="class-node-method-set-thread-safe">void set_thread_safe ( <a href="class_stringname.html#class-stringname"><span class="std std-ref">StringName</span></a> property, <a href="class_variant.html#class-variant"><span class="std std-ref">Variant</span></a> value )</h3> <p>Similar to <a href="#class-node-method-call-thread-safe"><span class="std std-ref">call_thread_safe</span></a>, but for setting properties.</p>  <h3 id="class-node-method-update-configuration-warnings">void update_configuration_warnings ( )</h3> <p>Refreshes the warnings displayed for this node in the Scene dock. Use <a href="#class-node-private-method-get-configuration-warnings"><span class="std std-ref">_get_configuration_warnings</span></a> to customize the warning messages to display.</p> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2014&ndash;present Juan Linietsky, Ariel Manzur and the Godot community<br>Licensed under the Creative Commons Attribution Unported License v3.0.<br>
    <a href="https://docs.godotengine.org/en/4.2/classes/class_node.html" class="_attribution-link">https://docs.godotengine.org/en/4.2/classes/class_node.html</a>
  </p>
</div>
