<section id="audiostreamwav"> <h1 id="class-audiostreamwav">AudioStreamWAV</h1> <p><strong>Inherits:</strong> <a href="class_audiostream.html#class-audiostream"><span class="std std-ref">AudioStream</span></a> <strong>&lt;</strong> <a href="class_resource.html#class-resource"><span class="std std-ref">Resource</span></a> <strong>&lt;</strong> <a href="class_refcounted.html#class-refcounted"><span class="std std-ref">RefCounted</span></a> <strong>&lt;</strong> <a href="class_object.html#class-object"><span class="std std-ref">Object</span></a></p> <p>Stores audio data loaded from WAV files.</p> <section class="classref-introduction-group" id="description"> <h2>Description</h2> <p>AudioStreamWAV stores sound samples loaded from WAV files. To play the stored sound, use an <a href="class_audiostreamplayer.html#class-audiostreamplayer"><span class="std std-ref">AudioStreamPlayer</span></a> (for non-positional audio) or <a href="class_audiostreamplayer2d.html#class-audiostreamplayer2d"><span class="std std-ref">AudioStreamPlayer2D</span></a>/<a href="class_audiostreamplayer3d.html#class-audiostreamplayer3d"><span class="std std-ref">AudioStreamPlayer3D</span></a> (for positional audio). The sound can be looped.</p> <p>This class can also be used to store dynamically-generated PCM audio data. See also <a href="class_audiostreamgenerator.html#class-audiostreamgenerator"><span class="std std-ref">AudioStreamGenerator</span></a> for procedural audio generation.</p> </section> <section class="classref-introduction-group" id="tutorials"> <h2>Tutorials</h2> <ul class="simple"> <li><a href="https://docs.godotengine.org/en/4.2/tutorials/io/runtime_file_loading_and_saving.html"><span class="doc">Runtime file loading and saving</span></a></li> </ul> </section> <section class="classref-reftable-group" id="properties"> <h2>Properties</h2> <table class="colwidths-auto docutils align-default">  <tr>
<td><p><a href="class_packedbytearray.html#class-packedbytearray"><span class="std std-ref">PackedByteArray</span></a></p></td> <td><p><a href="#class-audiostreamwav-property-data"><span class="std std-ref">data</span></a></p></td> <td><p><code>PackedByteArray()</code></p></td> </tr> <tr>
<td><p><a href="#enum-audiostreamwav-format"><span class="std std-ref">Format</span></a></p></td> <td><p><a href="#class-audiostreamwav-property-format"><span class="std std-ref">format</span></a></p></td> <td><p><code>0</code></p></td> </tr> <tr>
<td><p><a href="class_int.html#class-int"><span class="std std-ref">int</span></a></p></td> <td><p><a href="#class-audiostreamwav-property-loop-begin"><span class="std std-ref">loop_begin</span></a></p></td> <td><p><code>0</code></p></td> </tr> <tr>
<td><p><a href="class_int.html#class-int"><span class="std std-ref">int</span></a></p></td> <td><p><a href="#class-audiostreamwav-property-loop-end"><span class="std std-ref">loop_end</span></a></p></td> <td><p><code>0</code></p></td> </tr> <tr>
<td><p><a href="#enum-audiostreamwav-loopmode"><span class="std std-ref">LoopMode</span></a></p></td> <td><p><a href="#class-audiostreamwav-property-loop-mode"><span class="std std-ref">loop_mode</span></a></p></td> <td><p><code>0</code></p></td> </tr> <tr>
<td><p><a href="class_int.html#class-int"><span class="std std-ref">int</span></a></p></td> <td><p><a href="#class-audiostreamwav-property-mix-rate"><span class="std std-ref">mix_rate</span></a></p></td> <td><p><code>44100</code></p></td> </tr> <tr>
<td><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a></p></td> <td><p><a href="#class-audiostreamwav-property-stereo"><span class="std std-ref">stereo</span></a></p></td> <td><p><code>false</code></p></td> </tr>  </table> </section> <section class="classref-reftable-group" id="methods"> <h2>Methods</h2> <table class="colwidths-auto docutils align-default">  <tr>
<td><p><a href="class_%40globalscope.html#enum-globalscope-error"><span class="std std-ref">Error</span></a></p></td> <td><p><a href="#class-audiostreamwav-method-save-to-wav"><span class="std std-ref">save_to_wav</span></a> <strong>(</strong> <a href="class_string.html#class-string"><span class="std std-ref">String</span></a> path <strong>)</strong></p></td> </tr>  </table> </section>  <section class="classref-descriptions-group" id="enumerations"> <h2>Enumerations</h2> <h3 id="enum-audiostreamwav-format">enum Format:</h3> <h3 id="class-audiostreamwav-constant-format-8-bits">
<a href="#enum-audiostreamwav-format"><span class="std std-ref">Format</span></a> FORMAT_8_BITS = <code>0</code>
</h3> <p>8-bit audio codec.</p> <h3 id="class-audiostreamwav-constant-format-16-bits">
<a href="#enum-audiostreamwav-format"><span class="std std-ref">Format</span></a> FORMAT_16_BITS = <code>1</code>
</h3> <p>16-bit audio codec.</p> <h3 id="class-audiostreamwav-constant-format-ima-adpcm">
<a href="#enum-audiostreamwav-format"><span class="std std-ref">Format</span></a> FORMAT_IMA_ADPCM = <code>2</code>
</h3> <p>Audio is compressed using IMA ADPCM.</p>  <h3 id="enum-audiostreamwav-loopmode">enum LoopMode:</h3> <h3 id="class-audiostreamwav-constant-loop-disabled">
<a href="#enum-audiostreamwav-loopmode"><span class="std std-ref">LoopMode</span></a> LOOP_DISABLED = <code>0</code>
</h3> <p>Audio does not loop.</p> <h3 id="class-audiostreamwav-constant-loop-forward">
<a href="#enum-audiostreamwav-loopmode"><span class="std std-ref">LoopMode</span></a> LOOP_FORWARD = <code>1</code>
</h3> <p>Audio loops the data between <a href="#class-audiostreamwav-property-loop-begin"><span class="std std-ref">loop_begin</span></a> and <a href="#class-audiostreamwav-property-loop-end"><span class="std std-ref">loop_end</span></a>, playing forward only.</p> <h3 id="class-audiostreamwav-constant-loop-pingpong">
<a href="#enum-audiostreamwav-loopmode"><span class="std std-ref">LoopMode</span></a> LOOP_PINGPONG = <code>2</code>
</h3> <p>Audio loops the data between <a href="#class-audiostreamwav-property-loop-begin"><span class="std std-ref">loop_begin</span></a> and <a href="#class-audiostreamwav-property-loop-end"><span class="std std-ref">loop_end</span></a>, playing back and forth.</p> <h3 id="class-audiostreamwav-constant-loop-backward">
<a href="#enum-audiostreamwav-loopmode"><span class="std std-ref">LoopMode</span></a> LOOP_BACKWARD = <code>3</code>
</h3> <p>Audio loops the data between <a href="#class-audiostreamwav-property-loop-begin"><span class="std std-ref">loop_begin</span></a> and <a href="#class-audiostreamwav-property-loop-end"><span class="std std-ref">loop_end</span></a>, playing backward only.</p> </section>  <section class="classref-descriptions-group" id="property-descriptions"> <h2>Property Descriptions</h2> <h3 id="class-audiostreamwav-property-data">
<a href="class_packedbytearray.html#class-packedbytearray"><span class="std std-ref">PackedByteArray</span></a> data = <code>PackedByteArray()</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_data</strong> <strong>(</strong> <a href="class_packedbytearray.html#class-packedbytearray"><span class="std std-ref">PackedByteArray</span></a> value <strong>)</strong>
</li> <li>
<a href="class_packedbytearray.html#class-packedbytearray"><span class="std std-ref">PackedByteArray</span></a> <strong>get_data</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>Contains the audio data in bytes.</p> <p><strong>Note:</strong> This property expects signed PCM8 data. To convert unsigned PCM8 to signed PCM8, subtract 128 from each byte.</p>  <h3 id="class-audiostreamwav-property-format">
<a href="#enum-audiostreamwav-format"><span class="std std-ref">Format</span></a> format = <code>0</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_format</strong> <strong>(</strong> <a href="#enum-audiostreamwav-format"><span class="std std-ref">Format</span></a> value <strong>)</strong>
</li> <li>
<a href="#enum-audiostreamwav-format"><span class="std std-ref">Format</span></a> <strong>get_format</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>Audio format. See <a href="#enum-audiostreamwav-format"><span class="std std-ref">Format</span></a> constants for values.</p>  <h3 id="class-audiostreamwav-property-loop-begin">
<a href="class_int.html#class-int"><span class="std std-ref">int</span></a> loop_begin = <code>0</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_loop_begin</strong> <strong>(</strong> <a href="class_int.html#class-int"><span class="std std-ref">int</span></a> value <strong>)</strong>
</li> <li>
<a href="class_int.html#class-int"><span class="std std-ref">int</span></a> <strong>get_loop_begin</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>The loop start point (in number of samples, relative to the beginning of the sample). This information will be imported automatically from the WAV file if present.</p>  <h3 id="class-audiostreamwav-property-loop-end">
<a href="class_int.html#class-int"><span class="std std-ref">int</span></a> loop_end = <code>0</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_loop_end</strong> <strong>(</strong> <a href="class_int.html#class-int"><span class="std std-ref">int</span></a> value <strong>)</strong>
</li> <li>
<a href="class_int.html#class-int"><span class="std std-ref">int</span></a> <strong>get_loop_end</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>The loop end point (in number of samples, relative to the beginning of the sample). This information will be imported automatically from the WAV file if present.</p>  <h3 id="class-audiostreamwav-property-loop-mode">
<a href="#enum-audiostreamwav-loopmode"><span class="std std-ref">LoopMode</span></a> loop_mode = <code>0</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_loop_mode</strong> <strong>(</strong> <a href="#enum-audiostreamwav-loopmode"><span class="std std-ref">LoopMode</span></a> value <strong>)</strong>
</li> <li>
<a href="#enum-audiostreamwav-loopmode"><span class="std std-ref">LoopMode</span></a> <strong>get_loop_mode</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>The loop mode. This information will be imported automatically from the WAV file if present. See <a href="#enum-audiostreamwav-loopmode"><span class="std std-ref">LoopMode</span></a> constants for values.</p>  <h3 id="class-audiostreamwav-property-mix-rate">
<a href="class_int.html#class-int"><span class="std std-ref">int</span></a> mix_rate = <code>44100</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_mix_rate</strong> <strong>(</strong> <a href="class_int.html#class-int"><span class="std std-ref">int</span></a> value <strong>)</strong>
</li> <li>
<a href="class_int.html#class-int"><span class="std std-ref">int</span></a> <strong>get_mix_rate</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>The sample rate for mixing this audio. Higher values require more storage space, but result in better quality.</p> <p>In games, common sample rates in use are <code>11025</code>, <code>16000</code>, <code>22050</code>, <code>32000</code>, <code>44100</code>, and <code>48000</code>.</p> <p>According to the <a href="https://en.wikipedia.org/wiki/Nyquist%E2%80%93Shannon_sampling_theorem">Nyquist-Shannon sampling theorem</a>, there is no quality difference to human hearing when going past 40,000 Hz (since most humans can only hear up to ~20,000 Hz, often less). If you are using lower-pitched sounds such as voices, lower sample rates such as <code>32000</code> or <code>22050</code> may be usable with no loss in quality.</p>  <h3 id="class-audiostreamwav-property-stereo">
<a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> stereo = <code>false</code>
</h3> <ul class="classref-property-setget simple"> <li>void <strong>set_stereo</strong> <strong>(</strong> <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> value <strong>)</strong>
</li> <li>
<a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> <strong>is_stereo</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>If <code>true</code>, audio is stereo.</p> </section>  <section class="classref-descriptions-group" id="method-descriptions"> <h2>Method Descriptions</h2> <h3 id="class-audiostreamwav-method-save-to-wav">
<a href="class_%40globalscope.html#enum-globalscope-error"><span class="std std-ref">Error</span></a> save_to_wav ( <a href="class_string.html#class-string"><span class="std std-ref">String</span></a> path )</h3> <p>Saves the AudioStreamWAV as a WAV file to <code>path</code>. Samples with IMA ADPCM format can't be saved.</p> <p><strong>Note:</strong> A <code>.wav</code> extension is automatically appended to <code>path</code> if it is missing.</p> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2014&ndash;present Juan Linietsky, Ariel Manzur and the Godot community<br>Licensed under the Creative Commons Attribution Unported License v3.0.<br>
    <a href="https://docs.godotengine.org/en/4.2/classes/class_audiostreamwav.html" class="_attribution-link">https://docs.godotengine.org/en/4.2/classes/class_audiostreamwav.html</a>
  </p>
</div>
