<h1>Eigen::FullPivHouseholderQR</h1>      <div>  <div>
<h3>template&lt;typename _MatrixType&gt;<br> class Eigen::FullPivHouseholderQR&lt; _MatrixType &gt;</h3> <p>Householder rank-revealing QR decomposition of a matrix with full pivoting. </p> <dl>
<dt>Template Parameters</dt>
<dd> <table> <tr>
<td>_MatrixType</td>
<td>the type of the matrix of which we are computing the QR decomposition</td>
</tr> </table> </dd> </dl> <p>This class performs a rank-revealing QR decomposition of a matrix <b>A</b> into matrices <b>P</b>, <b>P'</b>, <b>Q</b> and <b>R</b> such that </p>
<p> \[ \mathbf{P} \, \mathbf{A} \, \mathbf{P}' = \mathbf{Q} \, \mathbf{R} \] </p> <p> by using Householder transformations. Here, <b>P</b> and <b>P'</b> are permutation matrices, <b>Q</b> a unitary matrix and <b>R</b> an upper triangular matrix.</p> <p>This decomposition performs a very prudent full pivoting in order to be rank-revealing and achieve optimal numerical stability. The trade-off is that it is slower than <a href="classeigen_1_1householderqr.html" title="Householder QR decomposition of a matrix.">HouseholderQR</a> and <a href="classeigen_1_1colpivhouseholderqr.html" title="Householder rank-revealing QR decomposition of a matrix with column-pivoting.">ColPivHouseholderQR</a>.</p> <p>This class supports the <a href="group__inplacedecomposition.html">inplace decomposition </a> mechanism.</p> <dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1matrixbase.html#a863bc0e06b641a089508eabec6835ab2">MatrixBase::fullPivHouseholderQr()</a> </dd>
</dl> </div> <div id="dynsection-0-summary" style="display:block;"> </div> <div id="dynsection-0-content" style="display:none;"> <div><img src="data:image/png;base64,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" border="0" usemap="#aEigen_1_1FullPivHouseholderQR_3_01__MatrixType_01_4_inherit__map" alt="Inheritance graph"></div> <map name="aEigen_1_1FullPivHouseholderQR_3_01__MatrixType_01_4_inherit__map" id="aEigen_1_1FullPivHouseholderQR_3_01__MatrixType_01_4_inherit__map"> <area shape="rect" title="Householder rank-revealing QR decomposition of a matrix with full pivoting." alt="" coords="5,549,211,993"> <area shape="rect" href="classEigen_1_1SolverBase.html.html" title=" " alt="" coords="17,292,199,501"> <area shape="rect" href="structEigen_1_1EigenBase.html.html" title=" " alt="" coords="11,5,205,244"> </map> </div> <table> <tr><td colspan="2"></td></tr> <tr>
<td align="right" valign="top">MatrixType::RealScalar </td>
<td valign="bottom">
<a href="classeigen_1_1fullpivhouseholderqr.html#a1029e1ccc70bb8669043c5775e7f3b75">absDeterminant</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">const <a href="classeigen_1_1permutationmatrix.html">PermutationType</a> &amp; </td>
<td valign="bottom">
<a href="classeigen_1_1fullpivhouseholderqr.html#abeda6d91e196c13d4dd8b7542fef3e17">colsPermutation</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename InputType &gt; </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1fullpivhouseholderqr.html">FullPivHouseholderQR</a>&lt; MatrixType &gt; &amp; </td>
<td valign="bottom">
<a href="classeigen_1_1fullpivhouseholderqr.html#a3745d70b826c12d33b8d34f26a5c96e7">compute</a> (const <a href="structeigen_1_1eigenbase.html">EigenBase</a>&lt; InputType &gt; &amp;matrix)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a href="structeigen_1_1eigenbase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> </td>
<td valign="bottom">
<a href="classeigen_1_1fullpivhouseholderqr.html#a3b5fe5edc66acc01c45b16e728470aa0">dimensionOfKernel</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top"> </td>
<td valign="bottom">
<a href="classeigen_1_1fullpivhouseholderqr.html#aeb14b4c1eef33128207b40a00bd0bd08">FullPivHouseholderQR</a> ()</td>
</tr> <tr>
<td> </td>
<td>Default Constructor. <a href="classeigen_1_1fullpivhouseholderqr.html#aeb14b4c1eef33128207b40a00bd0bd08">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename InputType &gt; </td></tr> <tr>
<td align="right" valign="top"> </td>
<td valign="bottom">
<a href="classeigen_1_1fullpivhouseholderqr.html#aeeace3abca6b215025e94c3e098b0a97">FullPivHouseholderQR</a> (const <a href="structeigen_1_1eigenbase.html">EigenBase</a>&lt; InputType &gt; &amp;matrix)</td>
</tr> <tr>
<td> </td>
<td>Constructs a QR factorization from a given matrix. <a href="classeigen_1_1fullpivhouseholderqr.html#aeeace3abca6b215025e94c3e098b0a97">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename InputType &gt; </td></tr> <tr>
<td align="right" valign="top"> </td>
<td valign="bottom">
<a href="classeigen_1_1fullpivhouseholderqr.html#ac9bdb4f7fa77c1aa16f238592c248e70">FullPivHouseholderQR</a> (<a href="structeigen_1_1eigenbase.html">EigenBase</a>&lt; InputType &gt; &amp;matrix)</td>
</tr> <tr>
<td> </td>
<td>Constructs a QR factorization from a given matrix. <a href="classeigen_1_1fullpivhouseholderqr.html#ac9bdb4f7fa77c1aa16f238592c248e70">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top"> </td>
<td valign="bottom">
<a href="classeigen_1_1fullpivhouseholderqr.html#abf722e1dc7241a5d6f76460ef0c87821">FullPivHouseholderQR</a> (<a href="structeigen_1_1eigenbase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> rows, <a href="structeigen_1_1eigenbase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> cols)</td>
</tr> <tr>
<td> </td>
<td>Default Constructor with memory preallocation. <a href="classeigen_1_1fullpivhouseholderqr.html#abf722e1dc7241a5d6f76460ef0c87821">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">const HCoeffsType &amp; </td>
<td valign="bottom">
<a href="classeigen_1_1fullpivhouseholderqr.html#a874fcd822871010f7961d9e94f1767e4">hCoeffs</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">const <a href="classeigen_1_1inverse.html">Inverse</a>&lt; <a href="classeigen_1_1fullpivhouseholderqr.html">FullPivHouseholderQR</a> &gt; </td>
<td valign="bottom">
<a href="classeigen_1_1fullpivhouseholderqr.html#a352ce66397af06da214ddde343cec6f5">inverse</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">bool </td>
<td valign="bottom">
<a href="classeigen_1_1fullpivhouseholderqr.html#a6776788011026b0f63192485a59deaed">isInjective</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">bool </td>
<td valign="bottom">
<a href="classeigen_1_1fullpivhouseholderqr.html#aeb1d779ec22ec68a5a28d4235db02ec1">isInvertible</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">bool </td>
<td valign="bottom">
<a href="classeigen_1_1fullpivhouseholderqr.html#aa3593db4708ce9079b0bdf219b99f57e">isSurjective</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">MatrixType::RealScalar </td>
<td valign="bottom">
<a href="classeigen_1_1fullpivhouseholderqr.html#aafde38918912c9b562f44b0fc3b22589">logAbsDeterminant</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">MatrixQReturnType </td>
<td valign="bottom">
<a href="classeigen_1_1fullpivhouseholderqr.html#ad26dd2d3c002939771d2375e4e051c28">matrixQ</a> (void) const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">const MatrixType &amp; </td>
<td valign="bottom">
<a href="classeigen_1_1fullpivhouseholderqr.html#a9c16411e5d8f1fc634a5797018d5aa3e">matrixQR</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">RealScalar </td>
<td valign="bottom">
<a href="classeigen_1_1fullpivhouseholderqr.html#a7887506237a3bf912aebc9aaa8edacec">maxPivot</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a href="structeigen_1_1eigenbase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> </td>
<td valign="bottom">
<a href="classeigen_1_1fullpivhouseholderqr.html#af1e4d04824084a964c1a6e51db68376f">nonzeroPivots</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a href="structeigen_1_1eigenbase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> </td>
<td valign="bottom">
<a href="classeigen_1_1fullpivhouseholderqr.html#aeae555220f46477818ccc94aca2de770">rank</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">const <a href="classeigen_1_1matrix.html">IntDiagSizeVectorType</a> &amp; </td>
<td valign="bottom">
<a href="classeigen_1_1fullpivhouseholderqr.html#abebbfc0ca6e3dd285a0ad0c907abb093">rowsTranspositions</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1fullpivhouseholderqr.html">FullPivHouseholderQR</a> &amp; </td>
<td valign="bottom">
<a href="classeigen_1_1fullpivhouseholderqr.html#a92277e572bf98245891015d12dd2b602">setThreshold</a> (const RealScalar &amp;<a href="classeigen_1_1fullpivhouseholderqr.html#af7f6ac15ca19c2b9e45dc3eaae58c201">threshold</a>)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1fullpivhouseholderqr.html">FullPivHouseholderQR</a> &amp; </td>
<td valign="bottom">
<a href="classeigen_1_1fullpivhouseholderqr.html#aaea4bf3dd145e0cddb16e364cca9d887">setThreshold</a> (Default_t)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename Rhs &gt; </td></tr> <tr>
<td align="right" valign="top">const <a href="classeigen_1_1solve.html">Solve</a>&lt; <a href="classeigen_1_1fullpivhouseholderqr.html">FullPivHouseholderQR</a>, Rhs &gt; </td>
<td valign="bottom">
<a href="classeigen_1_1fullpivhouseholderqr.html#a6f1b0a116c78e642e3d2a100a29d1a4a">solve</a> (const <a href="classeigen_1_1matrixbase.html">MatrixBase</a>&lt; Rhs &gt; &amp;b) const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">RealScalar </td>
<td valign="bottom">
<a href="classeigen_1_1fullpivhouseholderqr.html#af7f6ac15ca19c2b9e45dc3eaae58c201">threshold</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classEigen_1_1SolverBase')">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJAQMAAADaX5RTAAAABlBMVEVHcEx6k8V3LoYxAAAAAXRSTlMAQObYZgAAABxJREFUCNdj4GBg4GFg4GNg4AeiBhDJBxbhYAAADMkA8rytjikAAAAASUVORK5CYII=" alt="-"> Public Member Functions inherited from <a href="classeigen_1_1solverbase.html">Eigen::SolverBase&lt; FullPivHouseholderQR&lt; _MatrixType &gt; &gt;</a>
</td></tr> <tr>
<td align="right" valign="top">AdjointReturnType </td>
<td valign="bottom">
<a href="classeigen_1_1solverbase.html#a05a3686a89888681c8e0c2bcab6d1ce5">adjoint</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1fullpivhouseholderqr.html">FullPivHouseholderQR</a>&lt; _MatrixType &gt; &amp; </td>
<td valign="bottom">
<a href="classeigen_1_1solverbase.html#a1fbabe7f12bcbfba3b9a448b1f5e46fa">derived</a> ()</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">const <a href="classeigen_1_1fullpivhouseholderqr.html">FullPivHouseholderQR</a>&lt; _MatrixType &gt; &amp; </td>
<td valign="bottom">
<a href="classeigen_1_1solverbase.html#afd4f3f1c57b7594b96a7e30f2974ea2e">derived</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">const <a href="classeigen_1_1solve.html">Solve</a>&lt; <a href="classeigen_1_1fullpivhouseholderqr.html">FullPivHouseholderQR</a>&lt; _MatrixType &gt;, Rhs &gt; </td>
<td valign="bottom">
<a href="classeigen_1_1solverbase.html#a7fd647d110487799205df6f99547879d">solve</a> (const <a href="classeigen_1_1matrixbase.html">MatrixBase</a>&lt; Rhs &gt; &amp;b) const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top"> </td>
<td valign="bottom">
<a href="classeigen_1_1solverbase.html#a4d5e5baddfba3790ab1a5f247dcc4dc1">SolverBase</a> ()</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1diagonal.html">ConstTransposeReturnType</a> </td>
<td valign="bottom">
<a href="classeigen_1_1solverbase.html#a732e75b5132bb4db3775916927b0e86c">transpose</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2" onclick="javascript:toggleInherit('pub_methods_structEigen_1_1EigenBase')">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJAQMAAADaX5RTAAAABlBMVEVHcEx6k8V3LoYxAAAAAXRSTlMAQObYZgAAABxJREFUCNdj4GBg4GFg4GNg4AeiBhDJBxbhYAAADMkA8rytjikAAAAASUVORK5CYII=" alt="-"> Public Member Functions inherited from <a href="structeigen_1_1eigenbase.html">Eigen::EigenBase&lt; Derived &gt;</a>
</td></tr> <tr>
<td align="right" valign="top">EIGEN_CONSTEXPR <a href="structeigen_1_1eigenbase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> </td>
<td valign="bottom">
<a href="structeigen_1_1eigenbase.html#a2d768a9877f5f69f49432d447b552bfe">cols</a> () const EIGEN_NOEXCEPT</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">Derived &amp; </td>
<td valign="bottom">
<a href="structeigen_1_1eigenbase.html#a1fbabe7f12bcbfba3b9a448b1f5e46fa">derived</a> ()</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">const Derived &amp; </td>
<td valign="bottom">
<a href="structeigen_1_1eigenbase.html#afd4f3f1c57b7594b96a7e30f2974ea2e">derived</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">EIGEN_CONSTEXPR <a href="structeigen_1_1eigenbase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> </td>
<td valign="bottom">
<a href="structeigen_1_1eigenbase.html#ac22eb0695d00edd7d4a3b2d0a98b81c2">rows</a> () const EIGEN_NOEXCEPT</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">EIGEN_CONSTEXPR <a href="structeigen_1_1eigenbase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> </td>
<td valign="bottom">
<a href="structeigen_1_1eigenbase.html#ae106171b6fefd3f7af108a8283de36c9">size</a> () const EIGEN_NOEXCEPT</td>
</tr> <tr><td colspan="2"> </td></tr> </table>
<table> <tr><td colspan="2"></td></tr> <tr><td colspan="2" onclick="javascript:toggleInherit('pub_types_structEigen_1_1EigenBase')">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJAQMAAADaX5RTAAAABlBMVEVHcEx6k8V3LoYxAAAAAXRSTlMAQObYZgAAABxJREFUCNdj4GBg4GFg4GNg4AeiBhDJBxbhYAAADMkA8rytjikAAAAASUVORK5CYII=" alt="-"> Public Types inherited from <a href="structeigen_1_1eigenbase.html">Eigen::EigenBase&lt; Derived &gt;</a>
</td></tr> <tr>
<td align="right" valign="top">typedef <a href="namespaceeigen.html#a62e77e0933482dafde8fe197d9a2cfde">Eigen::Index</a> </td>
<td valign="bottom"><a href="structeigen_1_1eigenbase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a></td>
</tr> <tr>
<td> </td>
<td>The interface type of indices. <a href="structeigen_1_1eigenbase.html#a554f30542cc2316add4b1ea0a492ff02">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> </table>  <a id="aeb14b4c1eef33128207b40a00bd0bd08"></a> <h2>FullPivHouseholderQR() <span>[1/4]</span>
</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="classeigen_1_1fullpivhouseholderqr.html">Eigen::FullPivHouseholderQR</a>&lt; _MatrixType &gt;::<a href="classeigen_1_1fullpivhouseholderqr.html">FullPivHouseholderQR</a> </td> <td>(</td> <td></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>Default Constructor. </p> <p>The default constructor is useful in cases in which the user intends to perform decompositions via FullPivHouseholderQR::compute(const MatrixType&amp;). </p> </div> </div> <a id="abf722e1dc7241a5d6f76460ef0c87821"></a> <h2>FullPivHouseholderQR() <span>[2/4]</span>
</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="classeigen_1_1fullpivhouseholderqr.html">Eigen::FullPivHouseholderQR</a>&lt; _MatrixType &gt;::<a href="classeigen_1_1fullpivhouseholderqr.html">FullPivHouseholderQR</a> </td> <td>(</td> <td>
<a href="structeigen_1_1eigenbase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> </td> <td>
<em>rows</em>, </td> </tr> <tr> <td></td> <td></td> <td>
<a href="structeigen_1_1eigenbase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> </td> <td>
<em>cols</em> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>Default Constructor with memory preallocation. </p> <p>Like the default constructor but with preallocation of the internal data according to the specified problem <em>size</em>. </p>
<dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1fullpivhouseholderqr.html#aeb14b4c1eef33128207b40a00bd0bd08" title="Default Constructor.">FullPivHouseholderQR()</a> </dd>
</dl> </div> </div> <a id="aeeace3abca6b215025e94c3e098b0a97"></a> <h2>FullPivHouseholderQR() <span>[3/4]</span>
</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <div> template&lt;typename InputType &gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="classeigen_1_1fullpivhouseholderqr.html">Eigen::FullPivHouseholderQR</a>&lt; _MatrixType &gt;::<a href="classeigen_1_1fullpivhouseholderqr.html">FullPivHouseholderQR</a> </td> <td>(</td> <td>const <a href="structeigen_1_1eigenbase.html">EigenBase</a>&lt; InputType &gt; &amp; </td> <td><em>matrix</em></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span><span>explicit</span></span> </td> </tr> </table> </div>
<div> <p>Constructs a QR factorization from a given matrix. </p> <p>This constructor computes the QR factorization of the matrix <em>matrix</em> by calling the method compute(). It is a short cut for:</p> <pre data-language="cpp">FullPivHouseholderQR&lt;MatrixType&gt; qr(matrix.rows(), matrix.cols());
qr.compute(matrix);
</pre>
<dl>
<dt>See also</dt>
<dd>compute() </dd>
</dl> </div> </div> <a id="ac9bdb4f7fa77c1aa16f238592c248e70"></a> <h2>FullPivHouseholderQR() <span>[4/4]</span>
</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <div> template&lt;typename InputType &gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="classeigen_1_1fullpivhouseholderqr.html">Eigen::FullPivHouseholderQR</a>&lt; _MatrixType &gt;::<a href="classeigen_1_1fullpivhouseholderqr.html">FullPivHouseholderQR</a> </td> <td>(</td> <td>
<a href="structeigen_1_1eigenbase.html">EigenBase</a>&lt; InputType &gt; &amp; </td> <td><em>matrix</em></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span><span>explicit</span></span> </td> </tr> </table> </div>
<div> <p>Constructs a QR factorization from a given matrix. </p> <p>This overloaded constructor is provided for <a href="group__inplacedecomposition.html">inplace decomposition </a> when <code>MatrixType</code> is a <a href="classeigen_1_1ref.html" title="A matrix or vector expression mapping an existing expression.">Eigen::Ref</a>.</p> <dl>
<dt>See also</dt>
<dd>FullPivHouseholderQR(const EigenBase&amp;) </dd>
</dl> </div> </div>  <a id="a1029e1ccc70bb8669043c5775e7f3b75"></a> <h2>absDeterminant()</h2> <div> <div> <div> template&lt;typename MatrixType &gt; </div> <table> <tr> <td>MatrixType::RealScalar <a href="classeigen_1_1fullpivhouseholderqr.html">Eigen::FullPivHouseholderQR</a>&lt; MatrixType &gt;::absDeterminant</td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>the absolute value of the determinant of the matrix of which *this is the QR decomposition. It has only linear complexity (that is, O(n) where n is the dimension of the square matrix) as the QR decomposition has already been computed.</dd>
</dl> <dl>
<dt>Note</dt>
<dd>This is only for square matrices.</dd>
</dl> <dl>
<dt>Warning</dt>
<dd>a determinant can be very big or small, so for matrices of large enough dimension, there is a risk of overflow/underflow. One way to work around that is to use <a href="classeigen_1_1fullpivhouseholderqr.html#aafde38918912c9b562f44b0fc3b22589">logAbsDeterminant()</a> instead.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1fullpivhouseholderqr.html#aafde38918912c9b562f44b0fc3b22589">logAbsDeterminant()</a>, <a href="classeigen_1_1matrixbase.html#a7ad8f77004bb956b603bb43fd2e3c061">MatrixBase::determinant()</a> </dd>
</dl> </div> </div> <a id="abeda6d91e196c13d4dd8b7542fef3e17"></a> <h2>colsPermutation()</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="classeigen_1_1permutationmatrix.html">PermutationType</a>&amp; <a href="classeigen_1_1fullpivhouseholderqr.html">Eigen::FullPivHouseholderQR</a>&lt; _MatrixType &gt;::colsPermutation </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>a const reference to the column permutation matrix </dd>
</dl> </div> </div> <a id="a3745d70b826c12d33b8d34f26a5c96e7"></a> <h2>compute()</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <div> template&lt;typename InputType &gt; </div> <table> <tr> <td>
<a href="classeigen_1_1fullpivhouseholderqr.html">FullPivHouseholderQR</a>&lt;MatrixType&gt;&amp; <a href="classeigen_1_1fullpivhouseholderqr.html">Eigen::FullPivHouseholderQR</a>&lt; _MatrixType &gt;::compute </td> <td>(</td> <td>const <a href="structeigen_1_1eigenbase.html">EigenBase</a>&lt; InputType &gt; &amp; </td> <td><em>matrix</em></td>
<td>)</td> <td></td> </tr> </table> </div>
<div> <p>Performs the QR factorization of the given matrix <em>matrix</em>. The result of the factorization is stored into <code>*this</code>, and a reference to <code>*this</code> is returned.</p> <dl>
<dt>See also</dt>
<dd>class <a href="classeigen_1_1fullpivhouseholderqr.html" title="Householder rank-revealing QR decomposition of a matrix with full pivoting.">FullPivHouseholderQR</a>, FullPivHouseholderQR(const MatrixType&amp;) </dd>
</dl> </div> </div> <a id="a3b5fe5edc66acc01c45b16e728470aa0"></a> <h2>dimensionOfKernel()</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="structeigen_1_1eigenbase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> <a href="classeigen_1_1fullpivhouseholderqr.html">Eigen::FullPivHouseholderQR</a>&lt; _MatrixType &gt;::dimensionOfKernel </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>the dimension of the kernel of the matrix of which *this is the QR decomposition.</dd>
</dl> <dl>
<dt>Note</dt>
<dd>This method has to determine which pivots should be considered nonzero. For that, it uses the threshold value that you can control by calling <a href="classeigen_1_1fullpivhouseholderqr.html#a92277e572bf98245891015d12dd2b602">setThreshold(const RealScalar&amp;)</a>. </dd>
</dl> </div> </div> <a id="a874fcd822871010f7961d9e94f1767e4"></a> <h2>hCoeffs()</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>const HCoeffsType&amp; <a href="classeigen_1_1fullpivhouseholderqr.html">Eigen::FullPivHouseholderQR</a>&lt; _MatrixType &gt;::hCoeffs </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>a const reference to the vector of Householder coefficients used to represent the factor <code>Q</code>.</dd>
</dl> <p>For advanced uses only. </p> </div> </div> <a id="a352ce66397af06da214ddde343cec6f5"></a> <h2>inverse()</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="classeigen_1_1inverse.html">Inverse</a>&lt;<a href="classeigen_1_1fullpivhouseholderqr.html">FullPivHouseholderQR</a>&gt; <a href="classeigen_1_1fullpivhouseholderqr.html">Eigen::FullPivHouseholderQR</a>&lt; _MatrixType &gt;::inverse </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>the inverse of the matrix of which *this is the QR decomposition.</dd>
</dl> <dl>
<dt>Note</dt>
<dd>If this matrix is not invertible, the returned matrix has undefined coefficients. Use <a href="classeigen_1_1fullpivhouseholderqr.html#aeb1d779ec22ec68a5a28d4235db02ec1">isInvertible()</a> to first determine whether this matrix is invertible. </dd>
</dl> </div> </div> <a id="a6776788011026b0f63192485a59deaed"></a> <h2>isInjective()</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>bool <a href="classeigen_1_1fullpivhouseholderqr.html">Eigen::FullPivHouseholderQR</a>&lt; _MatrixType &gt;::isInjective </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>true if the matrix of which *this is the QR decomposition represents an injective linear map, i.e. has trivial kernel; false otherwise.</dd>
</dl> <dl>
<dt>Note</dt>
<dd>This method has to determine which pivots should be considered nonzero. For that, it uses the threshold value that you can control by calling <a href="classeigen_1_1fullpivhouseholderqr.html#a92277e572bf98245891015d12dd2b602">setThreshold(const RealScalar&amp;)</a>. </dd>
</dl> </div> </div> <a id="aeb1d779ec22ec68a5a28d4235db02ec1"></a> <h2>isInvertible()</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>bool <a href="classeigen_1_1fullpivhouseholderqr.html">Eigen::FullPivHouseholderQR</a>&lt; _MatrixType &gt;::isInvertible </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>true if the matrix of which *this is the QR decomposition is invertible.</dd>
</dl> <dl>
<dt>Note</dt>
<dd>This method has to determine which pivots should be considered nonzero. For that, it uses the threshold value that you can control by calling <a href="classeigen_1_1fullpivhouseholderqr.html#a92277e572bf98245891015d12dd2b602">setThreshold(const RealScalar&amp;)</a>. </dd>
</dl> </div> </div> <a id="aa3593db4708ce9079b0bdf219b99f57e"></a> <h2>isSurjective()</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>bool <a href="classeigen_1_1fullpivhouseholderqr.html">Eigen::FullPivHouseholderQR</a>&lt; _MatrixType &gt;::isSurjective </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>true if the matrix of which *this is the QR decomposition represents a surjective linear map; false otherwise.</dd>
</dl> <dl>
<dt>Note</dt>
<dd>This method has to determine which pivots should be considered nonzero. For that, it uses the threshold value that you can control by calling <a href="classeigen_1_1fullpivhouseholderqr.html#a92277e572bf98245891015d12dd2b602">setThreshold(const RealScalar&amp;)</a>. </dd>
</dl> </div> </div> <a id="aafde38918912c9b562f44b0fc3b22589"></a> <h2>logAbsDeterminant()</h2> <div> <div> <div> template&lt;typename MatrixType &gt; </div> <table> <tr> <td>MatrixType::RealScalar <a href="classeigen_1_1fullpivhouseholderqr.html">Eigen::FullPivHouseholderQR</a>&lt; MatrixType &gt;::logAbsDeterminant</td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>the natural log of the absolute value of the determinant of the matrix of which *this is the QR decomposition. It has only linear complexity (that is, O(n) where n is the dimension of the square matrix) as the QR decomposition has already been computed.</dd>
</dl> <dl>
<dt>Note</dt>
<dd>This is only for square matrices.</dd> <dd> This method is useful to work around the risk of overflow/underflow that's inherent to determinant computation.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1fullpivhouseholderqr.html#a1029e1ccc70bb8669043c5775e7f3b75">absDeterminant()</a>, <a href="classeigen_1_1matrixbase.html#a7ad8f77004bb956b603bb43fd2e3c061">MatrixBase::determinant()</a> </dd>
</dl> </div> </div> <a id="ad26dd2d3c002939771d2375e4e051c28"></a> <h2>matrixQ()</h2> <div> <div> <div> template&lt;typename MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="classeigen_1_1fullpivhouseholderqr.html">FullPivHouseholderQR</a>&lt; MatrixType &gt;::MatrixQReturnType <a href="classeigen_1_1fullpivhouseholderqr.html">Eigen::FullPivHouseholderQR</a>&lt; MatrixType &gt;::matrixQ </td> <td>(</td> <td>void </td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>Expression object representing the matrix Q </dd>
</dl> </div> </div> <a id="a9c16411e5d8f1fc634a5797018d5aa3e"></a> <h2>matrixQR()</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>const MatrixType&amp; <a href="classeigen_1_1fullpivhouseholderqr.html">Eigen::FullPivHouseholderQR</a>&lt; _MatrixType &gt;::matrixQR </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>a reference to the matrix where the Householder QR decomposition is stored </dd>
</dl> </div> </div> <a id="a7887506237a3bf912aebc9aaa8edacec"></a> <h2>maxPivot()</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>RealScalar <a href="classeigen_1_1fullpivhouseholderqr.html">Eigen::FullPivHouseholderQR</a>&lt; _MatrixType &gt;::maxPivot </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>the absolute value of the biggest pivot, i.e. the biggest diagonal coefficient of U. </dd>
</dl> </div> </div> <a id="af1e4d04824084a964c1a6e51db68376f"></a> <h2>nonzeroPivots()</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="structeigen_1_1eigenbase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> <a href="classeigen_1_1fullpivhouseholderqr.html">Eigen::FullPivHouseholderQR</a>&lt; _MatrixType &gt;::nonzeroPivots </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>the number of nonzero pivots in the QR decomposition. Here nonzero is meant in the exact sense, not in a fuzzy sense. So that notion isn't really intrinsically interesting, but it is still useful when implementing algorithms.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1fullpivhouseholderqr.html#aeae555220f46477818ccc94aca2de770">rank()</a> </dd>
</dl> </div> </div> <a id="aeae555220f46477818ccc94aca2de770"></a> <h2>rank()</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="structeigen_1_1eigenbase.html#a554f30542cc2316add4b1ea0a492ff02">Index</a> <a href="classeigen_1_1fullpivhouseholderqr.html">Eigen::FullPivHouseholderQR</a>&lt; _MatrixType &gt;::rank </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>the rank of the matrix of which *this is the QR decomposition.</dd>
</dl> <dl>
<dt>Note</dt>
<dd>This method has to determine which pivots should be considered nonzero. For that, it uses the threshold value that you can control by calling <a href="classeigen_1_1fullpivhouseholderqr.html#a92277e572bf98245891015d12dd2b602">setThreshold(const RealScalar&amp;)</a>. </dd>
</dl> </div> </div> <a id="abebbfc0ca6e3dd285a0ad0c907abb093"></a> <h2>rowsTranspositions()</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="classeigen_1_1matrix.html">IntDiagSizeVectorType</a>&amp; <a href="classeigen_1_1fullpivhouseholderqr.html">Eigen::FullPivHouseholderQR</a>&lt; _MatrixType &gt;::rowsTranspositions </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>a const reference to the vector of indices representing the rows transpositions </dd>
</dl> </div> </div> <a id="a92277e572bf98245891015d12dd2b602"></a> <h2>setThreshold() <span>[1/2]</span>
</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="classeigen_1_1fullpivhouseholderqr.html">FullPivHouseholderQR</a>&amp; <a href="classeigen_1_1fullpivhouseholderqr.html">Eigen::FullPivHouseholderQR</a>&lt; _MatrixType &gt;::setThreshold </td> <td>(</td> <td>const RealScalar &amp; </td> <td><em>threshold</em></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>Allows to prescribe a threshold to be used by certain methods, such as <a href="classeigen_1_1fullpivhouseholderqr.html#aeae555220f46477818ccc94aca2de770">rank()</a>, who need to determine when pivots are to be considered nonzero. This is not used for the QR decomposition itself.</p> <p>When it needs to get the threshold value, <a href="namespaceeigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> calls <a href="classeigen_1_1fullpivhouseholderqr.html#af7f6ac15ca19c2b9e45dc3eaae58c201">threshold()</a>. By default, this uses a formula to automatically determine a reasonable threshold. Once you have called the present method <a href="classeigen_1_1fullpivhouseholderqr.html#a92277e572bf98245891015d12dd2b602">setThreshold(const RealScalar&amp;)</a>, your value is used instead.</p> <dl>
<dt>Parameters</dt>
<dd> <table> <tr>
<td>threshold</td>
<td>The new value to use as the threshold.</td>
</tr> </table> </dd> </dl> <p>A pivot will be considered nonzero if its absolute value is strictly greater than \( \vert pivot \vert \leqslant threshold \times \vert maxpivot \vert \) where maxpivot is the biggest pivot.</p> <p>If you want to come back to the default behavior, call <a href="classeigen_1_1fullpivhouseholderqr.html#aaea4bf3dd145e0cddb16e364cca9d887">setThreshold(Default_t)</a> </p> </div> </div> <a id="aaea4bf3dd145e0cddb16e364cca9d887"></a> <h2>setThreshold() <span>[2/2]</span>
</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="classeigen_1_1fullpivhouseholderqr.html">FullPivHouseholderQR</a>&amp; <a href="classeigen_1_1fullpivhouseholderqr.html">Eigen::FullPivHouseholderQR</a>&lt; _MatrixType &gt;::setThreshold </td> <td>(</td> <td>Default_t </td> <td></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>Allows to come back to the default behavior, letting <a href="namespaceeigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> use its default formula for determining the threshold.</p> <p>You should pass the special object Eigen::Default as parameter here. </p>
<pre data-language="cpp">qr.setThreshold(Eigen::Default); 
</pre>
<p>See the documentation of <a href="classeigen_1_1fullpivhouseholderqr.html#a92277e572bf98245891015d12dd2b602">setThreshold(const RealScalar&amp;)</a>. </p> </div> </div> <a id="a6f1b0a116c78e642e3d2a100a29d1a4a"></a> <h2>solve()</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <div> template&lt;typename Rhs &gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="classeigen_1_1solve.html">Solve</a>&lt;<a href="classeigen_1_1fullpivhouseholderqr.html">FullPivHouseholderQR</a>, Rhs&gt; <a href="classeigen_1_1fullpivhouseholderqr.html">Eigen::FullPivHouseholderQR</a>&lt; _MatrixType &gt;::solve </td> <td>(</td> <td>const <a href="classeigen_1_1matrixbase.html">MatrixBase</a>&lt; Rhs &gt; &amp; </td> <td><em>b</em></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>This method finds a solution x to the equation Ax=b, where A is the matrix of which <code>*this</code> is the QR decomposition.</p> <dl>
<dt>Parameters</dt>
<dd> <table> <tr>
<td>b</td>
<td>the right-hand-side of the equation to solve.</td>
</tr> </table> </dd> </dl> <dl>
<dt>Returns</dt>
<dd>the exact or least-square solution if the rank is greater or equal to the number of columns of A, and an arbitrary solution otherwise.</dd>
</dl> <p>This method just tries to find as good a solution as possible. If you want to check whether a solution exists or if it is accurate, just call this function to get a result and then compute the error of this result, or use <a href="classeigen_1_1densebase.html#ae8443357b808cd393be1b51974213f9c">MatrixBase::isApprox()</a> directly, for instance like this:</p>
<pre data-language="cpp"><span>bool</span> a_solution_exists = (A*result).isApprox(b, precision); 
</pre>
<p> This method avoids dividing by zero, so that the non-existence of a solution doesn't by itself mean that you'll get <code>inf</code> or <code>nan</code> values.</p> <p>If there exists more than one solution, this method will arbitrarily choose one.</p> <p>Example: </p>
<pre data-language="cpp">Matrix3f m = <a href="classeigen_1_1densebase.html#ae814abb451b48ed872819192dc188c19">Matrix3f::Random</a>();
Matrix3f y = <a href="classeigen_1_1densebase.html#ae814abb451b48ed872819192dc188c19">Matrix3f::Random</a>();
cout &lt;&lt; <span>"Here is the matrix m:"</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;
cout &lt;&lt; <span>"Here is the matrix y:"</span> &lt;&lt; endl &lt;&lt; y &lt;&lt; endl;
Matrix3f x;
x = m.fullPivHouseholderQr().solve(y);
assert(y.isApprox(m*x));
cout &lt;&lt; <span>"Here is a solution x to the equation mx=y:"</span> &lt;&lt; endl &lt;&lt; x &lt;&lt; endl;</pre>
<p> Output: </p>
<pre>Here is the matrix m:
  0.68  0.597  -0.33
-0.211  0.823  0.536
 0.566 -0.605 -0.444
Here is the matrix y:
  0.108   -0.27   0.832
-0.0452  0.0268   0.271
  0.258   0.904   0.435
Here is a solution x to the equation mx=y:
 0.609   2.68   1.67
-0.231  -1.57 0.0713
  0.51   3.51   1.05
</pre> </div> </div> <a id="af7f6ac15ca19c2b9e45dc3eaae58c201"></a> <h2>threshold()</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>RealScalar <a href="classeigen_1_1fullpivhouseholderqr.html">Eigen::FullPivHouseholderQR</a>&lt; _MatrixType &gt;::threshold </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>Returns the threshold that will be used by certain methods such as <a href="classeigen_1_1fullpivhouseholderqr.html#aeae555220f46477818ccc94aca2de770">rank()</a>.</p> <p>See the documentation of <a href="classeigen_1_1fullpivhouseholderqr.html#a92277e572bf98245891015d12dd2b602">setThreshold(const RealScalar&amp;)</a>. </p> </div> </div> <hr>The documentation for this class was generated from the following file:<ul> <li><a href="https://eigen.tuxfamily.org/dox/FullPivHouseholderQR_8h_source.html">FullPivHouseholderQR.h</a></li> </ul> </div> <div class="_attribution">
  <p class="_attribution-p">
    &copy; Eigen.<br>Licensed under the MPL2 License.<br>
    <a href="https://eigen.tuxfamily.org/dox/classEigen_1_1FullPivHouseholderQR.html" class="_attribution-link">https://eigen.tuxfamily.org/dox/classEigen_1_1FullPivHouseholderQR.html</a>
  </p>
</div>
