<h1>Eigen::EigenSolver</h1>      <div>  <div>
<h3>template&lt;typename _MatrixType&gt;<br> class Eigen::EigenSolver&lt; _MatrixType &gt;</h3> <p>Computes eigenvalues and eigenvectors of general matrices. </p> <p>This is defined in the Eigenvalues module.</p>
<pre data-language="cpp"><span>#include &lt;Eigen/Eigenvalues&gt;</span> 
</pre>
<dl>
<dt>Template Parameters</dt>
<dd> <table> <tr>
<td>_MatrixType</td>
<td>the type of the matrix of which we are computing the eigendecomposition; this is expected to be an instantiation of the <a href="classeigen_1_1matrix.html" title="The matrix class, also used for vectors and row-vectors.">Matrix</a> class template. Currently, only real matrices are supported.</td>
</tr> </table> </dd> </dl> <p>The eigenvalues and eigenvectors of a matrix \( A \) are scalars \( \lambda \) and vectors \( v \) such that \( Av = \lambda v \). If \( D \) is a diagonal matrix with the eigenvalues on the diagonal, and \( V \) is a matrix with the eigenvectors as its columns, then \( A V = V D \). The matrix \( V \) is almost always invertible, in which case we have \( A = V D V^{-1} \). This is called the eigendecomposition.</p> <p>The eigenvalues and eigenvectors of a matrix may be complex, even when the matrix is real. However, we can choose real matrices \( V \) and \( D \) satisfying \( A V = V D \), just like the eigendecomposition, if the matrix \( D \) is not required to be diagonal, but if it is allowed to have blocks of the form </p>
<p> \[ \begin{bmatrix} u &amp; v \\ -v &amp; u \end{bmatrix} \] </p> <p> (where \( u \) and \( v \) are real numbers) on the diagonal. These blocks correspond to complex eigenvalue pairs \( u \pm iv \). We call this variant of the eigendecomposition the pseudo-eigendecomposition.</p> <p>Call the function <a href="classeigen_1_1eigensolver.html#a38d032b75b3e75640e3db42e7ab20c24" title="Computes eigendecomposition of given matrix.">compute()</a> to compute the eigenvalues and eigenvectors of a given matrix. Alternatively, you can use the EigenSolver(const MatrixType&amp;, bool) constructor which computes the eigenvalues and eigenvectors at construction time. Once the eigenvalue and eigenvectors are computed, they can be retrieved with the <a href="classeigen_1_1eigensolver.html#a114189009e42f5e03372a7a3dfa33b97" title="Returns the eigenvalues of given matrix.">eigenvalues()</a> and <a href="classeigen_1_1eigensolver.html#a66288022802172e3ee059283b26201d7" title="Returns the eigenvectors of given matrix.">eigenvectors()</a> functions. The <a href="classeigen_1_1eigensolver.html#a4979eafe0aeef06b19ada7fa5e19db17" title="Returns the block-diagonal matrix in the pseudo-eigendecomposition.">pseudoEigenvalueMatrix()</a> and <a href="classeigen_1_1eigensolver.html#a4e796226f06e1f7347cf03a38755a155" title="Returns the pseudo-eigenvectors of given matrix.">pseudoEigenvectors()</a> methods allow the construction of the pseudo-eigendecomposition.</p> <p>The documentation for EigenSolver(const MatrixType&amp;, bool) contains an example of the typical use of this class.</p> <dl>
<dt>Note</dt>
<dd>The implementation is adapted from <a href="http://math.nist.gov/javanumerics/jama/">JAMA</a> (public domain). Their code is based on EISPACK.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1matrixbase.html#a30430fa3d5b4e74d312fd4f502ac984d" title="Computes the eigenvalues of a matrix.">MatrixBase::eigenvalues()</a>, class <a href="classeigen_1_1complexeigensolver.html" title="Computes eigenvalues and eigenvectors of general complex matrices.">ComplexEigenSolver</a>, class <a href="classeigen_1_1selfadjointeigensolver.html" title="Computes eigenvalues and eigenvectors of selfadjoint matrices.">SelfAdjointEigenSolver</a> </dd>
</dl> </div>
<table> <tr><td colspan="2"></td></tr> <tr>
<td align="right" valign="top">typedef std::complex&lt; RealScalar &gt; </td>
<td valign="bottom"><a href="classeigen_1_1eigensolver.html#a4d0b2a773357d0a6ec98e026f04002ed">ComplexScalar</a></td>
</tr> <tr>
<td> </td>
<td>Complex scalar type for <a href="classeigen_1_1eigensolver.html#a83acd180404ddaac8a678fa65a6b632b" title="Synonym for the template parameter _MatrixType.">MatrixType</a>. <a href="classeigen_1_1eigensolver.html#a4d0b2a773357d0a6ec98e026f04002ed">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">typedef <a href="classeigen_1_1matrix.html">Matrix</a>&lt; <a href="classeigen_1_1eigensolver.html#a4d0b2a773357d0a6ec98e026f04002ed">ComplexScalar</a>, ColsAtCompileTime, 1, Options &amp;~<a href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13a77c993a8d9f6efe5c1159fb2ab07dd4f">RowMajor</a>, MaxColsAtCompileTime, 1 &gt; </td>
<td valign="bottom"><a href="classeigen_1_1eigensolver.html#adc446bcb60572758fa64515f2825db62">EigenvalueType</a></td>
</tr> <tr>
<td> </td>
<td>Type for vector of eigenvalues as returned by <a href="classeigen_1_1eigensolver.html#a114189009e42f5e03372a7a3dfa33b97" title="Returns the eigenvalues of given matrix.">eigenvalues()</a>. <a href="classeigen_1_1eigensolver.html#adc446bcb60572758fa64515f2825db62">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">typedef <a href="classeigen_1_1matrix.html">Matrix</a>&lt; <a href="classeigen_1_1eigensolver.html#a4d0b2a773357d0a6ec98e026f04002ed">ComplexScalar</a>, RowsAtCompileTime, ColsAtCompileTime, Options, MaxRowsAtCompileTime, MaxColsAtCompileTime &gt; </td>
<td valign="bottom"><a href="classeigen_1_1eigensolver.html#aa140354e2f7d5ce34c6488c39e19f2c2">EigenvectorsType</a></td>
</tr> <tr>
<td> </td>
<td>Type for matrix of eigenvectors as returned by <a href="classeigen_1_1eigensolver.html#a66288022802172e3ee059283b26201d7" title="Returns the eigenvectors of given matrix.">eigenvectors()</a>. <a href="classeigen_1_1eigensolver.html#aa140354e2f7d5ce34c6488c39e19f2c2">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">typedef <a href="namespaceeigen.html#a62e77e0933482dafde8fe197d9a2cfde">Eigen::Index</a> </td>
<td valign="bottom"><a href="classeigen_1_1eigensolver.html#a5bff6a6bc0efac67d52c60c2c3deb9ee">Index</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a id="a83acd180404ddaac8a678fa65a6b632b"></a> typedef _MatrixType </td>
<td valign="bottom"><a href="classeigen_1_1eigensolver.html#a83acd180404ddaac8a678fa65a6b632b">MatrixType</a></td>
</tr> <tr>
<td> </td>
<td>Synonym for the template parameter <code>_MatrixType</code>. <br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a id="a017d49fe0d59874b70a2fcf35e5aa373"></a> typedef MatrixType::Scalar </td>
<td valign="bottom"><a href="classeigen_1_1eigensolver.html#a017d49fe0d59874b70a2fcf35e5aa373">Scalar</a></td>
</tr> <tr>
<td> </td>
<td>Scalar type for matrices of type <a href="classeigen_1_1eigensolver.html#a83acd180404ddaac8a678fa65a6b632b" title="Synonym for the template parameter _MatrixType.">MatrixType</a>. <br>
</td>
</tr> <tr><td colspan="2"> </td></tr> </table>
<table> <tr><td colspan="2"></td></tr> <tr><td colspan="2">template&lt;typename InputType &gt; </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1eigensolver.html">EigenSolver</a> &amp; </td>
<td valign="bottom">
<a href="classeigen_1_1eigensolver.html#a38d032b75b3e75640e3db42e7ab20c24">compute</a> (const <a href="structeigen_1_1eigenbase.html">EigenBase</a>&lt; InputType &gt; &amp;matrix, bool computeEigenvectors=true)</td>
</tr> <tr>
<td> </td>
<td>Computes eigendecomposition of given matrix. <a href="classeigen_1_1eigensolver.html#a38d032b75b3e75640e3db42e7ab20c24">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top"> </td>
<td valign="bottom">
<a href="classeigen_1_1eigensolver.html#a3af22d721a6401365881b2ef252d26aa">EigenSolver</a> ()</td>
</tr> <tr>
<td> </td>
<td>Default constructor. <a href="classeigen_1_1eigensolver.html#a3af22d721a6401365881b2ef252d26aa">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename InputType &gt; </td></tr> <tr>
<td align="right" valign="top"> </td>
<td valign="bottom">
<a href="classeigen_1_1eigensolver.html#a7e8ab3d89ea525af5f27f1a8e805fae1">EigenSolver</a> (const <a href="structeigen_1_1eigenbase.html">EigenBase</a>&lt; InputType &gt; &amp;matrix, bool computeEigenvectors=true)</td>
</tr> <tr>
<td> </td>
<td>Constructor; computes eigendecomposition of given matrix. <a href="classeigen_1_1eigensolver.html#a7e8ab3d89ea525af5f27f1a8e805fae1">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top"> </td>
<td valign="bottom">
<a href="classeigen_1_1eigensolver.html#aa4edf56ecc178b277b75c13a2ca1089f">EigenSolver</a> (<a href="classeigen_1_1eigensolver.html#a5bff6a6bc0efac67d52c60c2c3deb9ee">Index</a> size)</td>
</tr> <tr>
<td> </td>
<td>Default constructor with memory preallocation. <a href="classeigen_1_1eigensolver.html#aa4edf56ecc178b277b75c13a2ca1089f">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">const <a href="classeigen_1_1eigensolver.html#adc446bcb60572758fa64515f2825db62">EigenvalueType</a> &amp; </td>
<td valign="bottom">
<a href="classeigen_1_1eigensolver.html#a114189009e42f5e03372a7a3dfa33b97">eigenvalues</a> () const</td>
</tr> <tr>
<td> </td>
<td>Returns the eigenvalues of given matrix. <a href="classeigen_1_1eigensolver.html#a114189009e42f5e03372a7a3dfa33b97">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1eigensolver.html#aa140354e2f7d5ce34c6488c39e19f2c2">EigenvectorsType</a> </td>
<td valign="bottom">
<a href="classeigen_1_1eigensolver.html#a66288022802172e3ee059283b26201d7">eigenvectors</a> () const</td>
</tr> <tr>
<td> </td>
<td>Returns the eigenvectors of given matrix. <a href="classeigen_1_1eigensolver.html#a66288022802172e3ee059283b26201d7">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a id="aa7668af4bcb47cd92cfe10640589d88f"></a> <a href="classeigen_1_1eigensolver.html#a5bff6a6bc0efac67d52c60c2c3deb9ee">Index</a> </td>
<td valign="bottom">
<a href="classeigen_1_1eigensolver.html#aa7668af4bcb47cd92cfe10640589d88f">getMaxIterations</a> ()</td>
</tr> <tr>
<td> </td>
<td>Returns the maximum number of iterations. <br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a href="group__enums.html#ga85fad7b87587764e5cf6b513a9e0ee5e">ComputationInfo</a> </td>
<td valign="bottom">
<a href="classeigen_1_1eigensolver.html#ac4af54fadc33abcdd1778c87bfbf005b">info</a> () const</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1eigensolver.html#a83acd180404ddaac8a678fa65a6b632b">MatrixType</a> </td>
<td valign="bottom">
<a href="classeigen_1_1eigensolver.html#a4979eafe0aeef06b19ada7fa5e19db17">pseudoEigenvalueMatrix</a> () const</td>
</tr> <tr>
<td> </td>
<td>Returns the block-diagonal matrix in the pseudo-eigendecomposition. <a href="classeigen_1_1eigensolver.html#a4979eafe0aeef06b19ada7fa5e19db17">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">const <a href="classeigen_1_1eigensolver.html#a83acd180404ddaac8a678fa65a6b632b">MatrixType</a> &amp; </td>
<td valign="bottom">
<a href="classeigen_1_1eigensolver.html#a4e796226f06e1f7347cf03a38755a155">pseudoEigenvectors</a> () const</td>
</tr> <tr>
<td> </td>
<td>Returns the pseudo-eigenvectors of given matrix. <a href="classeigen_1_1eigensolver.html#a4e796226f06e1f7347cf03a38755a155">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a id="a6cff220aadfd8d8c1366b915ddefd164"></a> <a href="classeigen_1_1eigensolver.html">EigenSolver</a> &amp; </td>
<td valign="bottom">
<a href="classeigen_1_1eigensolver.html#a6cff220aadfd8d8c1366b915ddefd164">setMaxIterations</a> (<a href="classeigen_1_1eigensolver.html#a5bff6a6bc0efac67d52c60c2c3deb9ee">Index</a> maxIters)</td>
</tr> <tr>
<td> </td>
<td>Sets the maximum number of iterations allowed. <br>
</td>
</tr> <tr><td colspan="2"> </td></tr> </table>  <a id="a4d0b2a773357d0a6ec98e026f04002ed"></a> <h2>ComplexScalar</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td>typedef std::complex&lt;RealScalar&gt; <a href="classeigen_1_1eigensolver.html">Eigen::EigenSolver</a>&lt; _MatrixType &gt;::<a href="classeigen_1_1eigensolver.html#a4d0b2a773357d0a6ec98e026f04002ed">ComplexScalar</a>
</td> </tr> </table> </div>
<div> <p>Complex scalar type for <a href="classeigen_1_1eigensolver.html#a83acd180404ddaac8a678fa65a6b632b" title="Synonym for the template parameter _MatrixType.">MatrixType</a>. </p> <p>This is <code>std::complex&lt;Scalar&gt;</code> if <a href="classeigen_1_1eigensolver.html#a017d49fe0d59874b70a2fcf35e5aa373" title="Scalar type for matrices of type MatrixType.">Scalar</a> is real (e.g., <code>float</code> or <code>double</code>) and just <code>Scalar</code> if <a href="classeigen_1_1eigensolver.html#a017d49fe0d59874b70a2fcf35e5aa373" title="Scalar type for matrices of type MatrixType.">Scalar</a> is complex. </p> </div> </div> <a id="adc446bcb60572758fa64515f2825db62"></a> <h2>EigenvalueType</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td>typedef <a href="classeigen_1_1matrix.html">Matrix</a>&lt;<a href="classeigen_1_1eigensolver.html#a4d0b2a773357d0a6ec98e026f04002ed">ComplexScalar</a>, ColsAtCompileTime, 1, Options &amp; ~<a href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13a77c993a8d9f6efe5c1159fb2ab07dd4f">RowMajor</a>, MaxColsAtCompileTime, 1&gt; <a href="classeigen_1_1eigensolver.html">Eigen::EigenSolver</a>&lt; _MatrixType &gt;::<a href="classeigen_1_1eigensolver.html#adc446bcb60572758fa64515f2825db62">EigenvalueType</a>
</td> </tr> </table> </div>
<div> <p>Type for vector of eigenvalues as returned by <a href="classeigen_1_1eigensolver.html#a114189009e42f5e03372a7a3dfa33b97" title="Returns the eigenvalues of given matrix.">eigenvalues()</a>. </p> <p>This is a column vector with entries of type <a href="classeigen_1_1eigensolver.html#a4d0b2a773357d0a6ec98e026f04002ed" title="Complex scalar type for MatrixType.">ComplexScalar</a>. The length of the vector is the size of <a href="classeigen_1_1eigensolver.html#a83acd180404ddaac8a678fa65a6b632b" title="Synonym for the template parameter _MatrixType.">MatrixType</a>. </p> </div> </div> <a id="aa140354e2f7d5ce34c6488c39e19f2c2"></a> <h2>EigenvectorsType</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td>typedef <a href="classeigen_1_1matrix.html">Matrix</a>&lt;<a href="classeigen_1_1eigensolver.html#a4d0b2a773357d0a6ec98e026f04002ed">ComplexScalar</a>, RowsAtCompileTime, ColsAtCompileTime, Options, MaxRowsAtCompileTime, MaxColsAtCompileTime&gt; <a href="classeigen_1_1eigensolver.html">Eigen::EigenSolver</a>&lt; _MatrixType &gt;::<a href="classeigen_1_1eigensolver.html#aa140354e2f7d5ce34c6488c39e19f2c2">EigenvectorsType</a>
</td> </tr> </table> </div>
<div> <p>Type for matrix of eigenvectors as returned by <a href="classeigen_1_1eigensolver.html#a66288022802172e3ee059283b26201d7" title="Returns the eigenvectors of given matrix.">eigenvectors()</a>. </p> <p>This is a square matrix with entries of type <a href="classeigen_1_1eigensolver.html#a4d0b2a773357d0a6ec98e026f04002ed" title="Complex scalar type for MatrixType.">ComplexScalar</a>. The size is the same as the size of <a href="classeigen_1_1eigensolver.html#a83acd180404ddaac8a678fa65a6b632b" title="Synonym for the template parameter _MatrixType.">MatrixType</a>. </p> </div> </div> <a id="a5bff6a6bc0efac67d52c60c2c3deb9ee"></a> <h2>Index</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td>typedef <a href="namespaceeigen.html#a62e77e0933482dafde8fe197d9a2cfde">Eigen::Index</a> <a href="classeigen_1_1eigensolver.html">Eigen::EigenSolver</a>&lt; _MatrixType &gt;::<a href="classeigen_1_1eigensolver.html#a5bff6a6bc0efac67d52c60c2c3deb9ee">Index</a>
</td> </tr> </table> </div>
<div> <dl>
<dt><b><a href="deprecated.html#_deprecated000014">Deprecated:</a></b></dt>
<dd>since <a href="namespaceeigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> 3.3 </dd>
</dl> </div> </div>  <a id="a3af22d721a6401365881b2ef252d26aa"></a> <h2>EigenSolver() <span>[1/3]</span>
</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="classeigen_1_1eigensolver.html">Eigen::EigenSolver</a>&lt; _MatrixType &gt;::<a href="classeigen_1_1eigensolver.html">EigenSolver</a> </td> <td>(</td> <td></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>Default constructor. </p> <p>The default constructor is useful in cases in which the user intends to perform decompositions via EigenSolver::compute(const MatrixType&amp;, bool).</p> <dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1eigensolver.html#a38d032b75b3e75640e3db42e7ab20c24" title="Computes eigendecomposition of given matrix.">compute()</a> for an example. </dd>
</dl> </div> </div> <a id="aa4edf56ecc178b277b75c13a2ca1089f"></a> <h2>EigenSolver() <span>[2/3]</span>
</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="classeigen_1_1eigensolver.html">Eigen::EigenSolver</a>&lt; _MatrixType &gt;::<a href="classeigen_1_1eigensolver.html">EigenSolver</a> </td> <td>(</td> <td>
<a href="classeigen_1_1eigensolver.html#a5bff6a6bc0efac67d52c60c2c3deb9ee">Index</a> </td> <td><em>size</em></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span><span>explicit</span></span> </td> </tr> </table> </div>
<div> <p>Default constructor with memory preallocation. </p> <p>Like the default constructor but with preallocation of the internal data according to the specified problem <em>size</em>. </p>
<dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1eigensolver.html#a3af22d721a6401365881b2ef252d26aa" title="Default constructor.">EigenSolver()</a> </dd>
</dl> </div> </div> <a id="a7e8ab3d89ea525af5f27f1a8e805fae1"></a> <h2>EigenSolver() <span>[3/3]</span>
</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <div> template&lt;typename InputType &gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="classeigen_1_1eigensolver.html">Eigen::EigenSolver</a>&lt; _MatrixType &gt;::<a href="classeigen_1_1eigensolver.html">EigenSolver</a> </td> <td>(</td> <td>const <a href="structeigen_1_1eigenbase.html">EigenBase</a>&lt; InputType &gt; &amp; </td> <td>
<em>matrix</em>, </td> </tr> <tr> <td></td> <td></td> <td>bool </td> <td>
<em>computeEigenvectors</em> = <code>true</code> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </td> <td> <span><span>inline</span><span>explicit</span></span> </td> </tr> </table> </div>
<div> <p>Constructor; computes eigendecomposition of given matrix. </p> <dl>
<dt>Parameters</dt>
<dd> <table> <tr>
<td>[in]</td>
<td>matrix</td>
<td>Square matrix whose eigendecomposition is to be computed. </td>
</tr> <tr>
<td>[in]</td>
<td>computeEigenvectors</td>
<td>If true, both the eigenvectors and the eigenvalues are computed; if false, only the eigenvalues are computed.</td>
</tr> </table> </dd> </dl> <p>This constructor calls <a href="classeigen_1_1eigensolver.html#a38d032b75b3e75640e3db42e7ab20c24" title="Computes eigendecomposition of given matrix.">compute()</a> to compute the eigenvalues and eigenvectors.</p> <p>Example: </p>
<pre data-language="cpp">MatrixXd A = <a href="classeigen_1_1densebase.html#ae814abb451b48ed872819192dc188c19">MatrixXd::Random</a>(6,6);
cout &lt;&lt; <span>"Here is a random 6x6 matrix, A:"</span> &lt;&lt; endl &lt;&lt; A &lt;&lt; endl &lt;&lt; endl;
 
EigenSolver&lt;MatrixXd&gt; es(A);
cout &lt;&lt; <span>"The eigenvalues of A are:"</span> &lt;&lt; endl &lt;&lt; es.eigenvalues() &lt;&lt; endl;
cout &lt;&lt; <span>"The matrix of eigenvectors, V, is:"</span> &lt;&lt; endl &lt;&lt; es.eigenvectors() &lt;&lt; endl &lt;&lt; endl;
 
complex&lt;double&gt; lambda = es.eigenvalues()[0];
cout &lt;&lt; <span>"Consider the first eigenvalue, lambda = "</span> &lt;&lt; lambda &lt;&lt; endl;
VectorXcd v = es.eigenvectors().col(0);
cout &lt;&lt; <span>"If v is the corresponding eigenvector, then lambda * v = "</span> &lt;&lt; endl &lt;&lt; lambda * v &lt;&lt; endl;
cout &lt;&lt; <span>"... and A * v = "</span> &lt;&lt; endl &lt;&lt; A.cast&lt;complex&lt;double&gt; &gt;() * v &lt;&lt; endl &lt;&lt; endl;
 
MatrixXcd D = es.eigenvalues().asDiagonal();
MatrixXcd V = es.eigenvectors();
cout &lt;&lt; <span>"Finally, V * D * V^(-1) = "</span> &lt;&lt; endl &lt;&lt; V * D * V.inverse() &lt;&lt; endl;</pre>
<p> Output: </p>
<pre>Here is a random 6x6 matrix, A:
   0.68   -0.33   -0.27  -0.717  -0.687  0.0259
 -0.211   0.536  0.0268   0.214  -0.198   0.678
  0.566  -0.444   0.904  -0.967   -0.74   0.225
  0.597   0.108   0.832  -0.514  -0.782  -0.408
  0.823 -0.0452   0.271  -0.726   0.998   0.275
 -0.605   0.258   0.435   0.608  -0.563  0.0486

The eigenvalues of A are:
  (0.049,1.06)
 (0.049,-1.06)
     (0.967,0)
     (0.353,0)
 (0.618,0.129)
(0.618,-0.129)
The matrix of eigenvectors, V, is:
 (-0.292,-0.454)   (-0.292,0.454)      (-0.0607,0)       (-0.733,0)    (0.59,-0.121)     (0.59,0.121)
  (0.134,-0.104)    (0.134,0.104)       (-0.799,0)        (0.136,0)    (0.334,0.368)   (0.334,-0.368)
  (-0.422,-0.18)    (-0.422,0.18)        (0.192,0)       (0.0563,0)  (-0.335,-0.143)   (-0.335,0.143)
 (-0.589,0.0274) (-0.589,-0.0274)      (-0.0788,0)       (-0.627,0)   (0.322,-0.155)    (0.322,0.155)
  (-0.248,0.132)  (-0.248,-0.132)        (0.401,0)        (0.218,0) (-0.335,-0.0761)  (-0.335,0.0761)
    (0.105,0.18)    (0.105,-0.18)       (-0.392,0)     (-0.00564,0)  (-0.0324,0.103) (-0.0324,-0.103)

Consider the first eigenvalue, lambda = (0.049,1.06)
If v is the corresponding eigenvector, then lambda * v = 
  (0.466,-0.331)
   (0.117,0.137)
   (0.17,-0.456)
(-0.0578,-0.622)
 (-0.152,-0.256)
   (-0.186,0.12)
... and A * v = 
  (0.466,-0.331)
   (0.117,0.137)
   (0.17,-0.456)
(-0.0578,-0.622)
 (-0.152,-0.256)
   (-0.186,0.12)

Finally, V * D * V^(-1) = 
   (0.68,-4.44e-16)   (-0.33,-5.55e-17)   (-0.27,-1.11e-16)  (-0.717,-4.44e-16)   (-0.687,8.88e-16)          (0.0259,0)
  (-0.211,2.22e-16)    (0.536,1.91e-17)          (0.0268,0)           (0.214,0)   (-0.198,1.33e-15)           (0.678,0)
   (0.566,2.22e-16)  (-0.444,-1.53e-16)   (0.904,-2.22e-16)  (-0.967,-1.11e-16)    (-0.74,4.44e-16)    (0.225,2.22e-16)
  (0.597,-2.22e-16)   (0.108,-2.78e-16)   (0.832,-2.22e-16)  (-0.514,-1.11e-16)          (-0.782,0)  (-0.408,-2.22e-16)
  (0.823,-2.22e-16) (-0.0452,-1.67e-16)           (0.271,0)   (-0.726,1.11e-16)   (0.998,-8.88e-16)    (0.275,4.44e-16)
  (-0.605,2.91e-16)   (0.258,-6.94e-18)   (0.435,-6.94e-17)    (0.608,1.39e-17)   (-0.563,5.27e-16)   (0.0486,7.11e-17)
</pre>
<dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1eigensolver.html#a38d032b75b3e75640e3db42e7ab20c24" title="Computes eigendecomposition of given matrix.">compute()</a> </dd>
</dl> </div> </div>  <a id="a38d032b75b3e75640e3db42e7ab20c24"></a> <h2>compute()</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <div> template&lt;typename InputType &gt; </div> <table> <tr> <td>
<a href="classeigen_1_1eigensolver.html">EigenSolver</a>&amp; <a href="classeigen_1_1eigensolver.html">Eigen::EigenSolver</a>&lt; _MatrixType &gt;::compute </td> <td>(</td> <td>const <a href="structeigen_1_1eigenbase.html">EigenBase</a>&lt; InputType &gt; &amp; </td> <td>
<em>matrix</em>, </td> </tr> <tr> <td></td> <td></td> <td>bool </td> <td>
<em>computeEigenvectors</em> = <code>true</code> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </div>
<div> <p>Computes eigendecomposition of given matrix. </p> <dl>
<dt>Parameters</dt>
<dd> <table> <tr>
<td>[in]</td>
<td>matrix</td>
<td>Square matrix whose eigendecomposition is to be computed. </td>
</tr> <tr>
<td>[in]</td>
<td>computeEigenvectors</td>
<td>If true, both the eigenvectors and the eigenvalues are computed; if false, only the eigenvalues are computed. </td>
</tr> </table> </dd> </dl> <dl>
<dt>Returns</dt>
<dd>Reference to <code>*this</code> </dd>
</dl> <p>This function computes the eigenvalues of the real matrix <code>matrix</code>. The <a href="classeigen_1_1eigensolver.html#a114189009e42f5e03372a7a3dfa33b97" title="Returns the eigenvalues of given matrix.">eigenvalues()</a> function can be used to retrieve them. If <code>computeEigenvectors</code> is true, then the eigenvectors are also computed and can be retrieved by calling <a href="classeigen_1_1eigensolver.html#a66288022802172e3ee059283b26201d7" title="Returns the eigenvectors of given matrix.">eigenvectors()</a>.</p> <p>The matrix is first reduced to real Schur form using the <a href="classeigen_1_1realschur.html" title="Performs a real Schur decomposition of a square matrix.">RealSchur</a> class. The Schur decomposition is then used to compute the eigenvalues and eigenvectors.</p> <p>The cost of the computation is dominated by the cost of the Schur decomposition, which is very approximately \( 25n^3 \) (where \( n \) is the size of the matrix) if <code>computeEigenvectors</code> is true, and \( 10n^3 \) if <code>computeEigenvectors</code> is false.</p> <p>This method reuses of the allocated data in the <a href="classeigen_1_1eigensolver.html" title="Computes eigenvalues and eigenvectors of general matrices.">EigenSolver</a> object.</p> <p>Example: </p>
<pre data-language="cpp">EigenSolver&lt;MatrixXf&gt; es;
MatrixXf A = <a href="classeigen_1_1densebase.html#ae814abb451b48ed872819192dc188c19">MatrixXf::Random</a>(4,4);
es.compute(A, <span>/* computeEigenvectors = */</span> <span>false</span>);
cout &lt;&lt; <span>"The eigenvalues of A are: "</span> &lt;&lt; es.eigenvalues().transpose() &lt;&lt; endl;
es.compute(A + <a href="classeigen_1_1matrixbase.html#a98bb9a0f705c6dfde85b0bfff31bf88f">MatrixXf::Identity</a>(4,4), <span>false</span>); <span>// re-use es to compute eigenvalues of A+I</span>
cout &lt;&lt; <span>"The eigenvalues of A+I are: "</span> &lt;&lt; es.eigenvalues().transpose() &lt;&lt; endl;</pre>
<p> Output: </p>
<pre>The eigenvalues of A are:    (0.755,0.528)   (0.755,-0.528)  (-0.323,0.0965) (-0.323,-0.0965)
The eigenvalues of A+I are:    (1.75,0.528)   (1.75,-0.528)  (0.677,0.0965) (0.677,-0.0965)
</pre> </div> </div> <a id="a114189009e42f5e03372a7a3dfa33b97"></a> <h2>eigenvalues()</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="classeigen_1_1eigensolver.html#adc446bcb60572758fa64515f2825db62">EigenvalueType</a>&amp; <a href="classeigen_1_1eigensolver.html">Eigen::EigenSolver</a>&lt; _MatrixType &gt;::eigenvalues </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>Returns the eigenvalues of given matrix. </p> <dl>
<dt>Returns</dt>
<dd>A const reference to the column vector containing the eigenvalues.</dd>
</dl> <dl>
<dt>Precondition</dt>
<dd>Either the constructor EigenSolver(const MatrixType&amp;,bool) or the member function compute(const MatrixType&amp;, bool) has been called before.</dd>
</dl> <p>The eigenvalues are repeated according to their algebraic multiplicity, so there are as many eigenvalues as rows in the matrix. The eigenvalues are not sorted in any particular order.</p> <p>Example: </p>
<pre data-language="cpp">MatrixXd ones = <a href="classeigen_1_1densebase.html#a2755cb4023f7376880523626a8e05101">MatrixXd::Ones</a>(3,3);
EigenSolver&lt;MatrixXd&gt; es(ones, <span>false</span>);
cout &lt;&lt; <span>"The eigenvalues of the 3x3 matrix of ones are:"</span> 
     &lt;&lt; endl &lt;&lt; es.eigenvalues() &lt;&lt; endl;</pre>
<p> Output: </p>
<pre>The eigenvalues of the 3x3 matrix of ones are:
(-5.31e-17,0)
        (3,0)
        (0,0)
</pre>
<dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1eigensolver.html#a66288022802172e3ee059283b26201d7" title="Returns the eigenvectors of given matrix.">eigenvectors()</a>, <a href="classeigen_1_1eigensolver.html#a4979eafe0aeef06b19ada7fa5e19db17" title="Returns the block-diagonal matrix in the pseudo-eigendecomposition.">pseudoEigenvalueMatrix()</a>, <a href="classeigen_1_1matrixbase.html#a30430fa3d5b4e74d312fd4f502ac984d" title="Computes the eigenvalues of a matrix.">MatrixBase::eigenvalues()</a> </dd>
</dl> </div> </div> <a id="a66288022802172e3ee059283b26201d7"></a> <h2>eigenvectors()</h2> <div> <div> <div> template&lt;typename MatrixType &gt; </div> <table> <tr> <td>
<a href="classeigen_1_1eigensolver.html">EigenSolver</a>&lt; <a href="classeigen_1_1eigensolver.html#a83acd180404ddaac8a678fa65a6b632b">MatrixType</a> &gt;::<a href="classeigen_1_1eigensolver.html#aa140354e2f7d5ce34c6488c39e19f2c2">EigenvectorsType</a> <a href="classeigen_1_1eigensolver.html">Eigen::EigenSolver</a>&lt; <a href="classeigen_1_1eigensolver.html#a83acd180404ddaac8a678fa65a6b632b">MatrixType</a> &gt;::eigenvectors</td> </tr> </table> </div>
<div> <p>Returns the eigenvectors of given matrix. </p> <dl>
<dt>Returns</dt>
<dd>Matrix whose columns are the (possibly complex) eigenvectors.</dd>
</dl> <dl>
<dt>Precondition</dt>
<dd>Either the constructor EigenSolver(const MatrixType&amp;,bool) or the member function compute(const MatrixType&amp;, bool) has been called before, and <code>computeEigenvectors</code> was set to true (the default).</dd>
</dl> <p>Column \( k \) of the returned matrix is an eigenvector corresponding to eigenvalue number \( k \) as returned by <a href="classeigen_1_1eigensolver.html#a114189009e42f5e03372a7a3dfa33b97" title="Returns the eigenvalues of given matrix.">eigenvalues()</a>. The eigenvectors are normalized to have (Euclidean) norm equal to one. The matrix returned by this function is the matrix \( V \) in the eigendecomposition \( A = V D V^{-1} \), if it exists.</p> <p>Example: </p>
<pre data-language="cpp">MatrixXd ones = <a href="classeigen_1_1densebase.html#a2755cb4023f7376880523626a8e05101">MatrixXd::Ones</a>(3,3);
EigenSolver&lt;MatrixXd&gt; es(ones);
cout &lt;&lt; <span>"The first eigenvector of the 3x3 matrix of ones is:"</span>
     &lt;&lt; endl &lt;&lt; es.eigenvectors().col(0) &lt;&lt; endl;
</pre>
<p> Output: </p>
<pre>The first eigenvector of the 3x3 matrix of ones is:
(-0.816,0)
 (0.408,0)
 (0.408,0)
</pre>
<dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1eigensolver.html#a114189009e42f5e03372a7a3dfa33b97" title="Returns the eigenvalues of given matrix.">eigenvalues()</a>, <a href="classeigen_1_1eigensolver.html#a4e796226f06e1f7347cf03a38755a155" title="Returns the pseudo-eigenvectors of given matrix.">pseudoEigenvectors()</a> </dd>
</dl> </div> </div> <a id="ac4af54fadc33abcdd1778c87bfbf005b"></a> <h2>info()</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>
<a href="group__enums.html#ga85fad7b87587764e5cf6b513a9e0ee5e">ComputationInfo</a> <a href="classeigen_1_1eigensolver.html">Eigen::EigenSolver</a>&lt; _MatrixType &gt;::info </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>NumericalIssue if the input contains INF or NaN values or overflow occurred. Returns Success otherwise. </dd>
</dl> </div> </div> <a id="a4979eafe0aeef06b19ada7fa5e19db17"></a> <h2>pseudoEigenvalueMatrix()</h2> <div> <div> <div> template&lt;typename MatrixType &gt; </div> <table> <tr> <td>
<a href="classeigen_1_1eigensolver.html#a83acd180404ddaac8a678fa65a6b632b">MatrixType</a> <a href="classeigen_1_1eigensolver.html">Eigen::EigenSolver</a>&lt; <a href="classeigen_1_1eigensolver.html#a83acd180404ddaac8a678fa65a6b632b">MatrixType</a> &gt;::pseudoEigenvalueMatrix</td> </tr> </table> </div>
<div> <p>Returns the block-diagonal matrix in the pseudo-eigendecomposition. </p> <dl>
<dt>Returns</dt>
<dd>A block-diagonal matrix.</dd>
</dl> <dl>
<dt>Precondition</dt>
<dd>Either the constructor EigenSolver(const MatrixType&amp;,bool) or the member function compute(const MatrixType&amp;, bool) has been called before.</dd>
</dl> <p>The matrix \( D \) returned by this function is real and block-diagonal. The blocks on the diagonal are either 1-by-1 or 2-by-2 blocks of the form \( \begin{bmatrix} u &amp; v \\ -v &amp; u \end{bmatrix} \). These blocks are not sorted in any particular order. The matrix \( D \) and the matrix \( V \) returned by <a href="classeigen_1_1eigensolver.html#a4e796226f06e1f7347cf03a38755a155" title="Returns the pseudo-eigenvectors of given matrix.">pseudoEigenvectors()</a> satisfy \( AV = VD \).</p> <dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1eigensolver.html#a4e796226f06e1f7347cf03a38755a155" title="Returns the pseudo-eigenvectors of given matrix.">pseudoEigenvectors()</a> for an example, <a href="classeigen_1_1eigensolver.html#a114189009e42f5e03372a7a3dfa33b97" title="Returns the eigenvalues of given matrix.">eigenvalues()</a> </dd>
</dl> </div> </div> <a id="a4e796226f06e1f7347cf03a38755a155"></a> <h2>pseudoEigenvectors()</h2> <div> <div> <div> template&lt;typename _MatrixType &gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="classeigen_1_1eigensolver.html#a83acd180404ddaac8a678fa65a6b632b">MatrixType</a>&amp; <a href="classeigen_1_1eigensolver.html">Eigen::EigenSolver</a>&lt; _MatrixType &gt;::pseudoEigenvectors </td> <td>(</td> <td></td>
<td>)</td> <td> const</td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>Returns the pseudo-eigenvectors of given matrix. </p> <dl>
<dt>Returns</dt>
<dd>Const reference to matrix whose columns are the pseudo-eigenvectors.</dd>
</dl> <dl>
<dt>Precondition</dt>
<dd>Either the constructor EigenSolver(const MatrixType&amp;,bool) or the member function compute(const MatrixType&amp;, bool) has been called before, and <code>computeEigenvectors</code> was set to true (the default).</dd>
</dl> <p>The real matrix \( V \) returned by this function and the block-diagonal matrix \( D \) returned by <a href="classeigen_1_1eigensolver.html#a4979eafe0aeef06b19ada7fa5e19db17" title="Returns the block-diagonal matrix in the pseudo-eigendecomposition.">pseudoEigenvalueMatrix()</a> satisfy \( AV = VD \).</p> <p>Example: </p>
<pre data-language="cpp">MatrixXd A = <a href="classeigen_1_1densebase.html#ae814abb451b48ed872819192dc188c19">MatrixXd::Random</a>(6,6);
cout &lt;&lt; <span>"Here is a random 6x6 matrix, A:"</span> &lt;&lt; endl &lt;&lt; A &lt;&lt; endl &lt;&lt; endl;
 
EigenSolver&lt;MatrixXd&gt; es(A);
MatrixXd D = es.pseudoEigenvalueMatrix();
MatrixXd V = es.pseudoEigenvectors();
cout &lt;&lt; <span>"The pseudo-eigenvalue matrix D is:"</span> &lt;&lt; endl &lt;&lt; D &lt;&lt; endl;
cout &lt;&lt; <span>"The pseudo-eigenvector matrix V is:"</span> &lt;&lt; endl &lt;&lt; V &lt;&lt; endl;
cout &lt;&lt; <span>"Finally, V * D * V^(-1) = "</span> &lt;&lt; endl &lt;&lt; V * D * V.inverse() &lt;&lt; endl;
</pre>
<p> Output: </p>
<pre>Here is a random 6x6 matrix, A:
   0.68   -0.33   -0.27  -0.717  -0.687  0.0259
 -0.211   0.536  0.0268   0.214  -0.198   0.678
  0.566  -0.444   0.904  -0.967   -0.74   0.225
  0.597   0.108   0.832  -0.514  -0.782  -0.408
  0.823 -0.0452   0.271  -0.726   0.998   0.275
 -0.605   0.258   0.435   0.608  -0.563  0.0486

The pseudo-eigenvalue matrix D is:
 0.049   1.06      0      0      0      0
 -1.06  0.049      0      0      0      0
     0      0  0.967      0      0      0
     0      0      0  0.353      0      0
     0      0      0      0  0.618  0.129
     0      0      0      0 -0.129  0.618
The pseudo-eigenvector matrix V is:
  -0.571   -0.888   -0.066    -1.13     17.2    -3.53
   0.263   -0.204   -0.869     0.21     9.73     10.7
  -0.827   -0.352    0.209   0.0871    -9.74    -4.17
   -1.15   0.0535  -0.0857   -0.971     9.36    -4.52
  -0.485    0.258    0.436    0.337    -9.74    -2.21
   0.206    0.353   -0.426 -0.00873   -0.944     2.98
Finally, V * D * V^(-1) = 
   0.68   -0.33   -0.27  -0.717  -0.687  0.0259
 -0.211   0.536  0.0268   0.214  -0.198   0.678
  0.566  -0.444   0.904  -0.967   -0.74   0.225
  0.597   0.108   0.832  -0.514  -0.782  -0.408
  0.823 -0.0452   0.271  -0.726   0.998   0.275
 -0.605   0.258   0.435   0.608  -0.563  0.0486
</pre>
<dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1eigensolver.html#a4979eafe0aeef06b19ada7fa5e19db17" title="Returns the block-diagonal matrix in the pseudo-eigendecomposition.">pseudoEigenvalueMatrix()</a>, <a href="classeigen_1_1eigensolver.html#a66288022802172e3ee059283b26201d7" title="Returns the eigenvectors of given matrix.">eigenvectors()</a> </dd>
</dl> </div> </div> <hr>The documentation for this class was generated from the following file:<ul> <li><a href="https://eigen.tuxfamily.org/dox/EigenSolver_8h_source.html">EigenSolver.h</a></li> </ul> </div> <div class="_attribution">
  <p class="_attribution-p">
    &copy; Eigen.<br>Licensed under the MPL2 License.<br>
    <a href="https://eigen.tuxfamily.org/dox/classEigen_1_1EigenSolver.html" class="_attribution-link">https://eigen.tuxfamily.org/dox/classEigen_1_1EigenSolver.html</a>
  </p>
</div>
