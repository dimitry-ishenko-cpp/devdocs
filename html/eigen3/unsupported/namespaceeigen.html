<h1>Eigen</h1>      <div> <p>Namespace containing all symbols from the Eigen library. <a href="namespaceeigen.html#details">More...</a></p> <table> <tr><td colspan="2"></td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1aligned__allocator.html">aligned_allocator</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1alignedbox.html">AlignedBox</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1alignedvector3.html">AlignedVector3</a></td>
</tr> <tr>
<td> </td>
<td>A vectorization friendly 3D vector. <a href="classeigen_1_1alignedvector3.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1amdordering.html">AMDOrdering</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1angleaxis.html">AngleAxis</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1arithmeticsequence.html">ArithmeticSequence</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1array.html">Array</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1arraybase.html">ArrayBase</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1arraywrapper.html">ArrayWrapper</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">struct </td>
<td valign="bottom"><a href="../structeigen_1_1arrayxpr.html">ArrayXpr</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1autodiffscalar.html">AutoDiffScalar</a></td>
</tr> <tr>
<td> </td>
<td>A scalar type replacement with automatic differentiation capability. <a href="classeigen_1_1autodiffscalar.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1bdcsvd.html">BDCSVD</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1bicgstab.html">BiCGSTAB</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1block.html">Block</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1blockimpl_3_01xprtype_00_01blockrows_00_01blockcols_00_01innerpanel_00_01sparse_01_4.html">BlockImpl&lt; XprType, BlockRows, BlockCols, InnerPanel, Sparse &gt;</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1blocksparsematrix.html">BlockSparseMatrix</a></td>
</tr> <tr>
<td> </td>
<td>A versatile sparse matrix representation where each element is a block. <a href="classeigen_1_1blocksparsematrix.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1cholmodbase.html">CholmodBase</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1cholmoddecomposition.html">CholmodDecomposition</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1cholmodsimplicialldlt.html">CholmodSimplicialLDLT</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1cholmodsimplicialllt.html">CholmodSimplicialLLT</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1cholmodsupernodalllt.html">CholmodSupernodalLLT</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1colamdordering.html">COLAMDOrdering</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1colpivhouseholderqr.html">ColPivHouseholderQR</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../structeigen_1_1commainitializer.html">CommaInitializer</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1completeorthogonaldecomposition.html">CompleteOrthogonalDecomposition</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1complexeigensolver.html">ComplexEigenSolver</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1complexschur.html">ComplexSchur</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1conjugategradient.html">ConjugateGradient</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1cwisebinaryop.html">CwiseBinaryOp</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1cwisenullaryop.html">CwiseNullaryOp</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1cwiseternaryop.html">CwiseTernaryOp</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1cwiseunaryop.html">CwiseUnaryOp</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1cwiseunaryview.html">CwiseUnaryView</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">struct </td>
<td valign="bottom"><a href="../structeigen_1_1dense.html">Dense</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1densebase.html">DenseBase</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1densecoeffsbase_3_01derived_00_01directaccessors_01_4.html">DenseCoeffsBase&lt; Derived, DirectAccessors &gt;</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1densecoeffsbase_3_01derived_00_01directwriteaccessors_01_4.html">DenseCoeffsBase&lt; Derived, DirectWriteAccessors &gt;</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1densecoeffsbase_3_01derived_00_01readonlyaccessors_01_4.html">DenseCoeffsBase&lt; Derived, ReadOnlyAccessors &gt;</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1densecoeffsbase_3_01derived_00_01writeaccessors_01_4.html">DenseCoeffsBase&lt; Derived, WriteAccessors &gt;</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1dgmres.html">DGMRES</a></td>
</tr> <tr>
<td> </td>
<td>A Restarted <a href="classeigen_1_1gmres.html" title="A GMRES solver for sparse square problems.">GMRES</a> with deflation. This class implements a modification of the <a href="classeigen_1_1gmres.html" title="A GMRES solver for sparse square problems.">GMRES</a> solver for sparse linear systems. The basis is built with modified Gram-Schmidt. At each restart, a few approximated eigenvectors corresponding to the smallest eigenvalues are used to build a preconditioner for the next cycle. This preconditioner for deflation can be combined with any other preconditioner, the <a href="../classeigen_1_1incompletelut.html">IncompleteLUT</a> for instance. The preconditioner is applied at right of the matrix and the combination is multiplicative. <a href="classeigen_1_1dgmres.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1diagonal.html">Diagonal</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1diagonalmatrix.html">DiagonalMatrix</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1diagonalpreconditioner.html">DiagonalPreconditioner</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1diagonalwrapper.html">DiagonalWrapper</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1dynamicsgroup.html">DynamicSGroup</a></td>
</tr> <tr>
<td> </td>
<td>Dynamic symmetry group. <a href="classeigen_1_1dynamicsgroup.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1dynamicsparsematrix.html">DynamicSparseMatrix</a></td>
</tr> <tr>
<td> </td>
<td>A sparse matrix class designed for matrix assembly purpose. <a href="classeigen_1_1dynamicsparsematrix.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../structeigen_1_1eigenbase.html">EigenBase</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1eigensolver.html">EigenSolver</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1eulerangles.html">EulerAngles</a></td>
</tr> <tr>
<td> </td>
<td>Represents a rotation in a 3 dimensional space as three Euler angles. <a href="classeigen_1_1eulerangles.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1eulersystem.html">EulerSystem</a></td>
</tr> <tr>
<td> </td>
<td>Represents a fixed Euler rotation system. <a href="classeigen_1_1eulersystem.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1forcealignedaccess.html">ForceAlignedAccess</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1fullpivhouseholderqr.html">FullPivHouseholderQR</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1fullpivlu.html">FullPivLU</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1generalizedeigensolver.html">GeneralizedEigenSolver</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1generalizedselfadjointeigensolver.html">GeneralizedSelfAdjointEigenSolver</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1gmres.html">GMRES</a></td>
</tr> <tr>
<td> </td>
<td>A <a href="classeigen_1_1gmres.html" title="A GMRES solver for sparse square problems.">GMRES</a> solver for sparse square problems. <a href="classeigen_1_1gmres.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1hessenbergdecomposition.html">HessenbergDecomposition</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1homogeneous.html">Homogeneous</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1householderqr.html">HouseholderQR</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1householdersequence.html">HouseholderSequence</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1hybridnonlinearsolver.html">HybridNonLinearSolver</a></td>
</tr> <tr>
<td> </td>
<td>Finds a zero of a system of n nonlinear functions in n variables by a modification of the Powell hybrid method ("dogleg"). <a href="classeigen_1_1hybridnonlinearsolver.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1hyperplane.html">Hyperplane</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1identitypreconditioner.html">IdentityPreconditioner</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1idrs.html">IDRS</a></td>
</tr> <tr>
<td> </td>
<td>The Induced Dimension Reduction method (IDR(s)) is a short-recurrences Krylov method for sparse square problems. <a href="classeigen_1_1idrs.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1incompletecholesky.html">IncompleteCholesky</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1incompletelut.html">IncompleteLUT</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1indexedview.html">IndexedView</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1innerstride.html">InnerStride</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1inverse.html">Inverse</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../structeigen_1_1ioformat.html">IOFormat</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1iterationcontroller.html">IterationController</a></td>
</tr> <tr>
<td> </td>
<td>Controls the iterations of the iterative solvers. <a href="classeigen_1_1iterationcontroller.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1iterativesolverbase.html">IterativeSolverBase</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1iterscaling.html">IterScaling</a></td>
</tr> <tr>
<td> </td>
<td>iterative scaling algorithm to equilibrate rows and column norms in matrices <a href="classeigen_1_1iterscaling.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1jacobirotation.html">JacobiRotation</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1jacobisvd.html">JacobiSVD</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1kdbvh.html">KdBVH</a></td>
</tr> <tr>
<td> </td>
<td>A simple bounding volume hierarchy based on <a href="../classeigen_1_1alignedbox.html">AlignedBox</a>. <a href="classeigen_1_1kdbvh.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1kroneckerproduct.html">KroneckerProduct</a></td>
</tr> <tr>
<td> </td>
<td>Kronecker tensor product helper class for dense matrices. <a href="classeigen_1_1kroneckerproduct.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1kroneckerproductbase.html">KroneckerProductBase</a></td>
</tr> <tr>
<td> </td>
<td>The base class of dense and sparse Kronecker product. <a href="classeigen_1_1kroneckerproductbase.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1kroneckerproductsparse.html">KroneckerProductSparse</a></td>
</tr> <tr>
<td> </td>
<td>Kronecker tensor product helper class for sparse matrices. <a href="classeigen_1_1kroneckerproductsparse.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1ldlt.html">LDLT</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1leastsquarediagonalpreconditioner.html">LeastSquareDiagonalPreconditioner</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1leastsquaresconjugategradient.html">LeastSquaresConjugateGradient</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1levenbergmarquardt.html">LevenbergMarquardt</a></td>
</tr> <tr>
<td> </td>
<td>Performs non linear optimization over a non-linear function, using a variant of the Levenberg Marquardt algorithm. <a href="classeigen_1_1levenbergmarquardt.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1llt.html">LLT</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1map.html">Map</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1map_3_01const_01quaternion_3_01__scalar_01_4_00_01__options_01_4.html">Map&lt; const Quaternion&lt; _Scalar &gt;, _Options &gt;</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1map_3_01quaternion_3_01__scalar_01_4_00_01__options_01_4.html">Map&lt; Quaternion&lt; _Scalar &gt;, _Options &gt;</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1map_3_01sparsematrixtype_01_4.html">Map&lt; SparseMatrixType &gt;</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1mapbase_3_01derived_00_01readonlyaccessors_01_4.html">MapBase&lt; Derived, ReadOnlyAccessors &gt;</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1mapbase_3_01derived_00_01writeaccessors_01_4.html">MapBase&lt; Derived, WriteAccessors &gt;</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1mappedsparsematrix.html">MappedSparseMatrix</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1matrix.html">Matrix</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1matrixbase.html">MatrixBase</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1matrixcomplexpowerreturnvalue.html">MatrixComplexPowerReturnValue</a></td>
</tr> <tr>
<td> </td>
<td>Proxy for the matrix power of some matrix (expression). <a href="classeigen_1_1matrixcomplexpowerreturnvalue.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">struct </td>
<td valign="bottom"><a href="structeigen_1_1matrixexponentialreturnvalue.html">MatrixExponentialReturnValue</a></td>
</tr> <tr>
<td> </td>
<td>Proxy for the matrix exponential of some matrix (expression). <a href="structeigen_1_1matrixexponentialreturnvalue.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1matrixfunctionreturnvalue.html">MatrixFunctionReturnValue</a></td>
</tr> <tr>
<td> </td>
<td>Proxy for the matrix function of some matrix (expression). <a href="classeigen_1_1matrixfunctionreturnvalue.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1matrixlogarithmreturnvalue.html">MatrixLogarithmReturnValue</a></td>
</tr> <tr>
<td> </td>
<td>Proxy for the matrix logarithm of some matrix (expression). <a href="classeigen_1_1matrixlogarithmreturnvalue.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1matrixmarketiterator.html">MatrixMarketIterator</a></td>
</tr> <tr>
<td> </td>
<td>Iterator to browse matrices from a specified folder. <a href="classeigen_1_1matrixmarketiterator.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1matrixpower.html">MatrixPower</a></td>
</tr> <tr>
<td> </td>
<td>Class for computing matrix powers. <a href="classeigen_1_1matrixpower.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1matrixpoweratomic.html">MatrixPowerAtomic</a></td>
</tr> <tr>
<td> </td>
<td>Class for computing matrix powers. <a href="classeigen_1_1matrixpoweratomic.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1matrixpowerparenthesesreturnvalue.html">MatrixPowerParenthesesReturnValue</a></td>
</tr> <tr>
<td> </td>
<td>Proxy for the matrix power of some matrix. <a href="classeigen_1_1matrixpowerparenthesesreturnvalue.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1matrixpowerreturnvalue.html">MatrixPowerReturnValue</a></td>
</tr> <tr>
<td> </td>
<td>Proxy for the matrix power of some matrix (expression). <a href="classeigen_1_1matrixpowerreturnvalue.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1matrixsquarerootreturnvalue.html">MatrixSquareRootReturnValue</a></td>
</tr> <tr>
<td> </td>
<td>Proxy for the matrix square root of some matrix (expression). <a href="classeigen_1_1matrixsquarerootreturnvalue.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1matrixwrapper.html">MatrixWrapper</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">struct </td>
<td valign="bottom"><a href="../structeigen_1_1matrixxpr.html">MatrixXpr</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1maxsizevector.html">MaxSizeVector</a></td>
</tr> <tr>
<td> </td>
<td>The <a href="classeigen_1_1maxsizevector.html" title="The MaxSizeVector class.">MaxSizeVector</a> class. <a href="classeigen_1_1maxsizevector.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1metisordering.html">MetisOrdering</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1minres.html">MINRES</a></td>
</tr> <tr>
<td> </td>
<td>A minimal residual solver for sparse symmetric problems. <a href="classeigen_1_1minres.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1naturalordering.html">NaturalOrdering</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1nestbyvalue.html">NestByValue</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1noalias.html">NoAlias</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1numericaldiff.html">NumericalDiff</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../structeigen_1_1numtraits.html">NumTraits</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">struct </td>
<td valign="bottom"><a href="structeigen_1_1numtraits_3_01mpfr_1_1mpreal_01_4.html">NumTraits&lt; mpfr::mpreal &gt;</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1outerstride.html">OuterStride</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1parametrizedline.html">ParametrizedLine</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1pardisoldlt.html">PardisoLDLT</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1pardisollt.html">PardisoLLT</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1pardisolu.html">PardisoLU</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1partialpivlu.html">PartialPivLU</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1partialreduxexpr.html">PartialReduxExpr</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1pastixldlt.html">PastixLDLT</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1pastixllt.html">PastixLLT</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1pastixlu.html">PastixLU</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1permutationbase.html">PermutationBase</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1permutationmatrix.html">PermutationMatrix</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">struct </td>
<td valign="bottom"><a href="../structeigen_1_1permutationstorage.html">PermutationStorage</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1permutationwrapper.html">PermutationWrapper</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1plainobjectbase.html">PlainObjectBase</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1polynomialsolver.html">PolynomialSolver</a></td>
</tr> <tr>
<td> </td>
<td>A polynomial solver. <a href="classeigen_1_1polynomialsolver.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1polynomialsolverbase.html">PolynomialSolverBase</a></td>
</tr> <tr>
<td> </td>
<td>Defined to be inherited by polynomial solvers: it provides convenient methods such as. <a href="classeigen_1_1polynomialsolverbase.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1product.html">Product</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1quaternion.html">Quaternion</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1quaternionbase.html">QuaternionBase</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1randomsetter.html">RandomSetter</a></td>
</tr> <tr>
<td> </td>
<td>The <a href="classeigen_1_1randomsetter.html" title="The RandomSetter is a wrapper object allowing to set/update a sparse matrix with random access.">RandomSetter</a> is a wrapper object allowing to set/update a sparse matrix with random access. <a href="classeigen_1_1randomsetter.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1realqz.html">RealQZ</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1realschur.html">RealSchur</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1ref.html">Ref</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1ref_3_01sparsematrixtype_00_01options_01_4.html">Ref&lt; SparseMatrixType, Options &gt;</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1ref_3_01sparsevectortype_01_4.html">Ref&lt; SparseVectorType &gt;</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1replicate.html">Replicate</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1reshaped.html">Reshaped</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1reverse.html">Reverse</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1rotation2d.html">Rotation2D</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1rotationbase.html">RotationBase</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../structeigen_1_1scalarbinaryoptraits.html">ScalarBinaryOpTraits</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1select.html">Select</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1selfadjointeigensolver.html">SelfAdjointEigenSolver</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1selfadjointview.html">SelfAdjointView</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1sgroup.html">SGroup</a></td>
</tr> <tr>
<td> </td>
<td>Symmetry group, initialized from template arguments. <a href="classeigen_1_1sgroup.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1simplicialcholesky.html">SimplicialCholesky</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1simplicialcholeskybase.html">SimplicialCholeskyBase</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1simplicialldlt.html">SimplicialLDLT</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1simplicialllt.html">SimplicialLLT</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1skylineinplacelu.html">SkylineInplaceLU</a></td>
</tr> <tr>
<td> </td>
<td>Inplace LU decomposition of a skyline matrix and associated features. <a href="classeigen_1_1skylineinplacelu.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1skylinematrix.html">SkylineMatrix</a></td>
</tr> <tr>
<td> </td>
<td>The main skyline matrix class. <a href="classeigen_1_1skylinematrix.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1skylinematrixbase.html">SkylineMatrixBase</a></td>
</tr> <tr>
<td> </td>
<td>Base class of any skyline matrices or skyline expressions. <a href="classeigen_1_1skylinematrixbase.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1skylinestorage.html">SkylineStorage</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1solve.html">Solve</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1solverbase.html">SolverBase</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">struct </td>
<td valign="bottom"><a href="../structeigen_1_1solverstorage.html">SolverStorage</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1solvewithguess.html">SolveWithGuess</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">struct </td>
<td valign="bottom"><a href="../structeigen_1_1sparse.html">Sparse</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1sparsecompressedbase.html">SparseCompressedBase</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1sparselu.html">SparseLU</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1sparsemapbase_3_01derived_00_01readonlyaccessors_01_4.html">SparseMapBase&lt; Derived, ReadOnlyAccessors &gt;</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1sparsemapbase_3_01derived_00_01writeaccessors_01_4.html">SparseMapBase&lt; Derived, WriteAccessors &gt;</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1sparsematrix.html">SparseMatrix</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1sparsematrixbase.html">SparseMatrixBase</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1sparseqr.html">SparseQR</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1sparseselfadjointview.html">SparseSelfAdjointView</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1sparsesolverbase.html">SparseSolverBase</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1sparsevector.html">SparseVector</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1sparseview.html">SparseView</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1spline.html">Spline</a></td>
</tr> <tr>
<td> </td>
<td>A class representing multi-dimensional spline curves. <a href="classeigen_1_1spline.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">struct </td>
<td valign="bottom"><a href="structeigen_1_1splinefitting.html">SplineFitting</a></td>
</tr> <tr>
<td> </td>
<td>
<a href="classeigen_1_1spline.html" title="A class representing multi-dimensional spline curves.">Spline</a> fitting methods. <a href="structeigen_1_1splinefitting.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">struct </td>
<td valign="bottom"><a href="structeigen_1_1splinetraits_3_01spline_3_01__scalar_00_01__dim_00_01__degree_01_4_00_01__derivativeorder_01_4.html">SplineTraits&lt; Spline&lt; _Scalar, _Dim, _Degree &gt;, _DerivativeOrder &gt;</a></td>
</tr> <tr>
<td> </td>
<td>Compile-time attributes of the <a href="classeigen_1_1spline.html" title="A class representing multi-dimensional spline curves.">Spline</a> class for fixed degree. <a href="structeigen_1_1splinetraits_3_01spline_3_01__scalar_00_01__dim_00_01__degree_01_4_00_01__derivativeorder_01_4.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">struct </td>
<td valign="bottom"><a href="structeigen_1_1splinetraits_3_01spline_3_01__scalar_00_01__dim_00_01__degree_01_4_00_01dynamic_01_4.html">SplineTraits&lt; Spline&lt; _Scalar, _Dim, _Degree &gt;, Dynamic &gt;</a></td>
</tr> <tr>
<td> </td>
<td>Compile-time attributes of the <a href="classeigen_1_1spline.html" title="A class representing multi-dimensional spline curves.">Spline</a> class for Dynamic degree. <a href="structeigen_1_1splinetraits_3_01spline_3_01__scalar_00_01__dim_00_01__degree_01_4_00_01dynamic_01_4.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1spqr.html">SPQR</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1staticsgroup.html">StaticSGroup</a></td>
</tr> <tr>
<td> </td>
<td>Static symmetry group. <a href="classeigen_1_1staticsgroup.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">struct </td>
<td valign="bottom"><a href="structeigen_1_1stdmaptraits.html">StdMapTraits</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1stride.html">Stride</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1superilu.html">SuperILU</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1superlu.html">SuperLU</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1superlubase.html">SuperLUBase</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1svdbase.html">SVDBase</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensor.html">Tensor</a></td>
</tr> <tr>
<td> </td>
<td>The tensor class. <a href="classeigen_1_1tensor.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensorasyncdevice.html">TensorAsyncDevice</a></td>
</tr> <tr>
<td> </td>
<td>Pseudo expression providing an operator = that will evaluate its argument asynchronously on the specified device. Currently only ThreadPoolDevice implements proper asynchronous execution, while the default and GPU devices just run the expression synchronously and call m_done() on completion.. <a href="classeigen_1_1tensorasyncdevice.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensorbase.html">TensorBase</a></td>
</tr> <tr>
<td> </td>
<td>The tensor base class. <a href="classeigen_1_1tensorbase.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensorconcatenationop.html">TensorConcatenationOp</a></td>
</tr> <tr>
<td> </td>
<td>
<a href="classeigen_1_1tensor.html" title="The tensor class.">Tensor</a> concatenation class. <a href="classeigen_1_1tensorconcatenationop.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensorconversionop.html">TensorConversionOp</a></td>
</tr> <tr>
<td> </td>
<td>
<a href="classeigen_1_1tensor.html" title="The tensor class.">Tensor</a> conversion class. This class makes it possible to vectorize type casting operations when the number of scalars per packet in the source and the destination type differ. <a href="classeigen_1_1tensorconversionop.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensorcustombinaryop.html">TensorCustomBinaryOp</a></td>
</tr> <tr>
<td> </td>
<td>
<a href="classeigen_1_1tensor.html" title="The tensor class.">Tensor</a> custom class. <a href="classeigen_1_1tensorcustombinaryop.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensorcustomunaryop.html">TensorCustomUnaryOp</a></td>
</tr> <tr>
<td> </td>
<td>
<a href="classeigen_1_1tensor.html" title="The tensor class.">Tensor</a> custom class. <a href="classeigen_1_1tensorcustomunaryop.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensordevice.html">TensorDevice</a></td>
</tr> <tr>
<td> </td>
<td>Pseudo expression providing an operator = that will evaluate its argument on the specified computing 'device' (GPU, thread pool, ...) <a href="classeigen_1_1tensordevice.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="structeigen_1_1tensorevaluator.html">TensorEvaluator</a></td>
</tr> <tr>
<td> </td>
<td>A cost model used to limit the number of threads used for evaluating tensor expression. <a href="structeigen_1_1tensorevaluator.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensorfixedsize.html">TensorFixedSize</a></td>
</tr> <tr>
<td> </td>
<td>The fixed sized version of the tensor class. <a href="classeigen_1_1tensorfixedsize.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensorgeneratorop.html">TensorGeneratorOp</a></td>
</tr> <tr>
<td> </td>
<td>
<a href="classeigen_1_1tensor.html" title="The tensor class.">Tensor</a> generator class. <a href="classeigen_1_1tensorgeneratorop.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensormap.html">TensorMap</a></td>
</tr> <tr>
<td> </td>
<td>A tensor expression mapping an existing array of data. <a href="classeigen_1_1tensormap.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensorref.html">TensorRef</a></td>
</tr> <tr>
<td> </td>
<td>A reference to a tensor expression The expression will be evaluated lazily (as much as possible). <a href="classeigen_1_1tensorref.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1transform.html">Transform</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1translation.html">Translation</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1transpose.html">Transpose</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1transpositions.html">Transpositions</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">struct </td>
<td valign="bottom"><a href="../structeigen_1_1transpositionsstorage.html">TranspositionsStorage</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1triangularbase.html">TriangularBase</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1triangularview.html">TriangularView</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1triangularviewimpl_3_01__matrixtype_00_01__mode_00_01dense_01_4.html">TriangularViewImpl&lt; _MatrixType, _Mode, Dense &gt;</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1triangularviewimpl_3_01matrixtype_00_01mode_00_01sparse_01_4.html">TriangularViewImpl&lt; MatrixType, Mode, Sparse &gt;</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1tridiagonalization.html">Tridiagonalization</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1triplet.html">Triplet</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1umfpacklu.html">UmfPackLU</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1uniformscaling.html">UniformScaling</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1vectorblock.html">VectorBlock</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1vectorwiseop.html">VectorwiseOp</a></td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="../classeigen_1_1withformat.html">WithFormat</a></td>
</tr> <tr><td colspan="2"> </td></tr> </table>
<table> <tr><td colspan="2"></td></tr> <tr>
<td align="right" valign="top">
<a id="aa04df76fa4fc7d93538c28bbbd838507"></a> typedef <a href="classeigen_1_1spline.html">Spline</a>&lt; double, 2 &gt; </td>
<td valign="bottom"><a href="namespaceeigen.html#aa04df76fa4fc7d93538c28bbbd838507">Spline2d</a></td>
</tr> <tr>
<td> </td>
<td>2D double B-spline with dynamic degree. <br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a id="a1709ceddcb1e899317ac4bdb9682807f"></a> typedef <a href="classeigen_1_1spline.html">Spline</a>&lt; float, 2 &gt; </td>
<td valign="bottom"><a href="namespaceeigen.html#a1709ceddcb1e899317ac4bdb9682807f">Spline2f</a></td>
</tr> <tr>
<td> </td>
<td>2D float B-spline with dynamic degree. <br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a id="a34dfede40d5b8f3b2443ff20d891f455"></a> typedef <a href="classeigen_1_1spline.html">Spline</a>&lt; double, 3 &gt; </td>
<td valign="bottom"><a href="namespaceeigen.html#a34dfede40d5b8f3b2443ff20d891f455">Spline3d</a></td>
</tr> <tr>
<td> </td>
<td>3D double B-spline with dynamic degree. <br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">
<a id="a612e989f65acc6abc1593909f901e455"></a> typedef <a href="classeigen_1_1spline.html">Spline</a>&lt; float, 3 &gt; </td>
<td valign="bottom"><a href="namespaceeigen.html#a612e989f65acc6abc1593909f901e455">Spline3f</a></td>
</tr> <tr>
<td> </td>
<td>3D float B-spline with dynamic degree. <br>
</td>
</tr> <tr><td colspan="2"> </td></tr> </table>
<table> <tr><td colspan="2"></td></tr> <tr>
<td align="right" valign="top">enum </td>
<td valign="bottom">
<a href="group__eulerangles__module.html#gae614aa7cdd687fb5c421a54f2ce5c361">EulerAxis</a> { <br> <a href="group__eulerangles__module.html#ggae614aa7cdd687fb5c421a54f2ce5c361a11e1ea88cbe04a6fc077475d515d0b38">EULER_X</a> , <br> <a href="group__eulerangles__module.html#ggae614aa7cdd687fb5c421a54f2ce5c361aee756a2b63043248f3d83541386c266b">EULER_Y</a> , <br> <a href="group__eulerangles__module.html#ggae614aa7cdd687fb5c421a54f2ce5c361a95187b9943820cca5edc4bc96b3c08be">EULER_Z</a> <br> }</td>
</tr> <tr>
<td> </td>
<td>Representation of a fixed signed rotation axis for EulerSystem. <a href="group__eulerangles__module.html#gae614aa7cdd687fb5c421a54f2ce5c361">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> </table>
<table> <tr><td colspan="2"></td></tr> <tr><td colspan="2">template&lt;typename Derived &gt; </td></tr> <tr>
<td align="right" valign="top">const <a href="../classeigen_1_1cwiseunaryop.html">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_i0_op&lt; typename Derived::Scalar &gt;, const Derived &gt; </td>
<td valign="bottom">
<a href="namespaceeigen.html#ab0c429bb38ce58964b561fb9d6c9377a">bessel_i0</a> (const <a href="../classeigen_1_1arraybase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;x)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename Derived &gt; </td></tr> <tr>
<td align="right" valign="top">const <a href="../classeigen_1_1cwiseunaryop.html">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_i0e_op&lt; typename Derived::Scalar &gt;, const Derived &gt; </td>
<td valign="bottom">
<a href="namespaceeigen.html#aef13ab56dea757bfb7bd3e220ac478d5">bessel_i0e</a> (const <a href="../classeigen_1_1arraybase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;x)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename Derived &gt; </td></tr> <tr>
<td align="right" valign="top">const <a href="../classeigen_1_1cwiseunaryop.html">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_i1_op&lt; typename Derived::Scalar &gt;, const Derived &gt; </td>
<td valign="bottom">
<a href="namespaceeigen.html#ae35e1cabdc81f3783219186a7e658a2b">bessel_i1</a> (const <a href="../classeigen_1_1arraybase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;x)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename Derived &gt; </td></tr> <tr>
<td align="right" valign="top">const <a href="../classeigen_1_1cwiseunaryop.html">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_i1e_op&lt; typename Derived::Scalar &gt;, const Derived &gt; </td>
<td valign="bottom">
<a href="namespaceeigen.html#ae52c524c4108c6265e9543468da42e28">bessel_i1e</a> (const <a href="../classeigen_1_1arraybase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;x)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename Derived &gt; </td></tr> <tr>
<td align="right" valign="top">const <a href="../classeigen_1_1cwiseunaryop.html">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_j0_op&lt; typename Derived::Scalar &gt;, const Derived &gt; </td>
<td valign="bottom">
<a href="namespaceeigen.html#a65acfc33a2b6140a09af67e45928e037">bessel_j0</a> (const <a href="../classeigen_1_1arraybase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;x)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename Derived &gt; </td></tr> <tr>
<td align="right" valign="top">const <a href="../classeigen_1_1cwiseunaryop.html">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_j1_op&lt; typename Derived::Scalar &gt;, const Derived &gt; </td>
<td valign="bottom">
<a href="namespaceeigen.html#a4079ddbfe44e3a865cdb600353f371ab">bessel_j1</a> (const <a href="../classeigen_1_1arraybase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;x)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename Derived &gt; </td></tr> <tr>
<td align="right" valign="top">const <a href="../classeigen_1_1cwiseunaryop.html">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_k0_op&lt; typename Derived::Scalar &gt;, const Derived &gt; </td>
<td valign="bottom">
<a href="namespaceeigen.html#a4664123a5ae23d981410d7dc5cd86970">bessel_k0</a> (const <a href="../classeigen_1_1arraybase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;x)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename Derived &gt; </td></tr> <tr>
<td align="right" valign="top">const <a href="../classeigen_1_1cwiseunaryop.html">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_k0e_op&lt; typename Derived::Scalar &gt;, const Derived &gt; </td>
<td valign="bottom">
<a href="namespaceeigen.html#a9cc57448af6eda4fa72f34be7cc72da5">bessel_k0e</a> (const <a href="../classeigen_1_1arraybase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;x)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename Derived &gt; </td></tr> <tr>
<td align="right" valign="top">const <a href="../classeigen_1_1cwiseunaryop.html">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_k1_op&lt; typename Derived::Scalar &gt;, const Derived &gt; </td>
<td valign="bottom">
<a href="namespaceeigen.html#a76e76fa84ed24785bf32665a48157bf1">bessel_k1</a> (const <a href="../classeigen_1_1arraybase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;x)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename Derived &gt; </td></tr> <tr>
<td align="right" valign="top">const <a href="../classeigen_1_1cwiseunaryop.html">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_k1e_op&lt; typename Derived::Scalar &gt;, const Derived &gt; </td>
<td valign="bottom">
<a href="namespaceeigen.html#af9e044c2baa913adea597c4d497a3315">bessel_k1e</a> (const <a href="../classeigen_1_1arraybase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;x)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename Derived &gt; </td></tr> <tr>
<td align="right" valign="top">const <a href="../classeigen_1_1cwiseunaryop.html">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_y0_op&lt; typename Derived::Scalar &gt;, const Derived &gt; </td>
<td valign="bottom">
<a href="namespaceeigen.html#aad0c42bfd8d5b4169a542206b460b2d0">bessel_y0</a> (const <a href="../classeigen_1_1arraybase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;x)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename Derived &gt; </td></tr> <tr>
<td align="right" valign="top">const <a href="../classeigen_1_1cwiseunaryop.html">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_y1_op&lt; typename Derived::Scalar &gt;, const Derived &gt; </td>
<td valign="bottom">
<a href="namespaceeigen.html#a60d76185793d52703fa01d83d5b46615">bessel_y1</a> (const <a href="../classeigen_1_1arraybase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;x)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename ADerived , typename BDerived , typename XDerived &gt; </td></tr> <tr>
<td align="right" valign="top">const TensorCwiseTernaryOp&lt; internal::scalar_betainc_op&lt; typename XDerived::Scalar &gt;, const ADerived, const BDerived, const XDerived &gt; </td>
<td valign="bottom">
<a href="namespaceeigen.html#a6d7e9b581a1fc3ca3c8aff6a0a69f523">betainc</a> (const ADerived &amp;a, const BDerived &amp;b, const XDerived &amp;x)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename ArgADerived , typename ArgBDerived , typename ArgXDerived &gt; </td></tr> <tr>
<td align="right" valign="top">const <a href="../classeigen_1_1cwiseternaryop.html">Eigen::CwiseTernaryOp</a>&lt; Eigen::internal::scalar_betainc_op&lt; typename ArgXDerived::Scalar &gt;, const ArgADerived, const ArgBDerived, const ArgXDerived &gt; </td>
<td valign="bottom">
<a href="namespaceeigen.html#ac58db11132cd34e57ad819f3e77ff60c">betainc</a> (const <a href="../classeigen_1_1arraybase.html">Eigen::ArrayBase</a>&lt; ArgADerived &gt; &amp;a, const <a href="../classeigen_1_1arraybase.html">Eigen::ArrayBase</a>&lt; ArgBDerived &gt; &amp;b, const <a href="../classeigen_1_1arraybase.html">Eigen::ArrayBase</a>&lt; ArgXDerived &gt; &amp;x)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename BVH , typename Intersector &gt; </td></tr> <tr>
<td align="right" valign="top">void </td>
<td valign="bottom">
<a href="namespaceeigen.html#a07d8e283f082c972338f3fc4f644b2a9">BVIntersect</a> (const BVH &amp;tree, Intersector &amp;intersector)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename BVH1 , typename BVH2 , typename Intersector &gt; </td></tr> <tr>
<td align="right" valign="top">void </td>
<td valign="bottom">
<a href="namespaceeigen.html#ac3b8047a3ee05b5e6fec4668197a9a43">BVIntersect</a> (const BVH1 &amp;tree1, const BVH2 &amp;tree2, Intersector &amp;intersector)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename BVH , typename Minimizer &gt; </td></tr> <tr>
<td align="right" valign="top">Minimizer::Scalar </td>
<td valign="bottom">
<a href="namespaceeigen.html#adcbe73ac1482eacab0e18ee32c25508e">BVMinimize</a> (const BVH &amp;tree, Minimizer &amp;minimizer)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename BVH1 , typename BVH2 , typename Minimizer &gt; </td></tr> <tr>
<td align="right" valign="top">Minimizer::Scalar </td>
<td valign="bottom">
<a href="namespaceeigen.html#a915f6adc8b195c94a83c35de6a842556">BVMinimize</a> (const BVH1 &amp;tree1, const BVH2 &amp;tree2, Minimizer &amp;minimizer)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename Polynomial &gt; </td></tr> <tr>
<td align="right" valign="top">
<a href="../structeigen_1_1numtraits.html">NumTraits</a>&lt; typename Polynomial::Scalar &gt;::Real </td>
<td valign="bottom">
<a href="group__polynomials__module.html#ga375e3ea1f370fb76dfe0f43a89b95926">cauchy_max_bound</a> (const Polynomial &amp;poly)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename Polynomial &gt; </td></tr> <tr>
<td align="right" valign="top">
<a href="../structeigen_1_1numtraits.html">NumTraits</a>&lt; typename Polynomial::Scalar &gt;::Real </td>
<td valign="bottom">
<a href="group__polynomials__module.html#gab076afbdba0e9298a541cc4e8cc7506b">cauchy_min_bound</a> (const Polynomial &amp;poly)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename PointArrayType , typename KnotVectorType &gt; </td></tr> <tr>
<td align="right" valign="top">void </td>
<td valign="bottom">
<a href="group__splines__module.html#ga1b4cbde5d98411405871accf877552d2">ChordLengths</a> (const PointArrayType &amp;pts, KnotVectorType &amp;chord_lengths)</td>
</tr> <tr>
<td> </td>
<td>Computes chord length parameters which are required for spline interpolation. <a href="group__splines__module.html#ga1b4cbde5d98411405871accf877552d2">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename AlphaDerived , typename SampleDerived &gt; </td></tr> <tr>
<td align="right" valign="top">const <a href="../classeigen_1_1cwisebinaryop.html">Eigen::CwiseBinaryOp</a>&lt; Eigen::internal::scalar_gamma_sample_der_alpha_op&lt; typename AlphaDerived::Scalar &gt;, const AlphaDerived, const SampleDerived &gt; </td>
<td valign="bottom">
<a href="namespaceeigen.html#afd81653604859fe8e5b09552a7a800c9">gamma_sample_der_alpha</a> (const <a href="../classeigen_1_1arraybase.html">Eigen::ArrayBase</a>&lt; AlphaDerived &gt; &amp;alpha, const <a href="../classeigen_1_1arraybase.html">Eigen::ArrayBase</a>&lt; SampleDerived &gt; &amp;sample)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename Derived , typename ExponentDerived &gt; </td></tr> <tr>
<td align="right" valign="top">const <a href="../classeigen_1_1cwisebinaryop.html">Eigen::CwiseBinaryOp</a>&lt; Eigen::internal::scalar_igamma_op&lt; typename Derived::Scalar &gt;, const Derived, const ExponentDerived &gt; </td>
<td valign="bottom">
<a href="namespaceeigen.html#a6e89509c5ff1af076baea462520f231c">igamma</a> (const <a href="../classeigen_1_1arraybase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;a, const <a href="../classeigen_1_1arraybase.html">Eigen::ArrayBase</a>&lt; ExponentDerived &gt; &amp;x)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename Derived , typename ExponentDerived &gt; </td></tr> <tr>
<td align="right" valign="top">const <a href="../classeigen_1_1cwisebinaryop.html">Eigen::CwiseBinaryOp</a>&lt; Eigen::internal::scalar_igamma_der_a_op&lt; typename Derived::Scalar &gt;, const Derived, const ExponentDerived &gt; </td>
<td valign="bottom">
<a href="namespaceeigen.html#ad0b09518c9ef2376690af1b346f77ff1">igamma_der_a</a> (const <a href="../classeigen_1_1arraybase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;a, const <a href="../classeigen_1_1arraybase.html">Eigen::ArrayBase</a>&lt; ExponentDerived &gt; &amp;x)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename Derived , typename ExponentDerived &gt; </td></tr> <tr>
<td align="right" valign="top">const <a href="../classeigen_1_1cwisebinaryop.html">Eigen::CwiseBinaryOp</a>&lt; Eigen::internal::scalar_igammac_op&lt; typename Derived::Scalar &gt;, const Derived, const ExponentDerived &gt; </td>
<td valign="bottom">
<a href="namespaceeigen.html#a2b1593c0c3f9d1673ae5980ae03e75f1">igammac</a> (const <a href="../classeigen_1_1arraybase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;a, const <a href="../classeigen_1_1arraybase.html">Eigen::ArrayBase</a>&lt; ExponentDerived &gt; &amp;x)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename KnotVectorType &gt; </td></tr> <tr>
<td align="right" valign="top">void </td>
<td valign="bottom">
<a href="group__splines__module.html#ga9474da5ed68bbd9a6788a999330416d6">KnotAveraging</a> (const KnotVectorType &amp;parameters, DenseIndex degree, KnotVectorType &amp;knots)</td>
</tr> <tr>
<td> </td>
<td>Computes knot averages. <a href="group__splines__module.html#ga9474da5ed68bbd9a6788a999330416d6">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename KnotVectorType , typename ParameterVectorType , typename IndexArray &gt; </td></tr> <tr>
<td align="right" valign="top">void </td>
<td valign="bottom">
<a href="group__splines__module.html#gae10a6f9b6ab7fb400a2526b6382c533b">KnotAveragingWithDerivatives</a> (const ParameterVectorType &amp;parameters, const unsigned int degree, const IndexArray &amp;derivativeIndices, KnotVectorType &amp;knots)</td>
</tr> <tr>
<td> </td>
<td>Computes knot averages when derivative constraints are present. Note that this is a technical interpretation of the referenced article since the algorithm contained therein is incorrect as written. <a href="group__splines__module.html#gae10a6f9b6ab7fb400a2526b6382c533b">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename A , typename B &gt; </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1kroneckerproductsparse.html">KroneckerProductSparse</a>&lt; A, B &gt; </td>
<td valign="bottom">
<a href="group__kroneckerproduct__module.html#gaca497f43cc92bcbf6eaff64984a266cc">kroneckerProduct</a> (const <a href="../structeigen_1_1eigenbase.html">EigenBase</a>&lt; A &gt; &amp;a, const <a href="../structeigen_1_1eigenbase.html">EigenBase</a>&lt; B &gt; &amp;b)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename A , typename B &gt; </td></tr> <tr>
<td align="right" valign="top">
<a href="classeigen_1_1kroneckerproduct.html">KroneckerProduct</a>&lt; A, B &gt; </td>
<td valign="bottom">
<a href="group__kroneckerproduct__module.html#gaa8924dffc6cee7aa1e908dc395a7a167">kroneckerProduct</a> (const <a href="../classeigen_1_1matrixbase.html">MatrixBase</a>&lt; A &gt; &amp;a, const <a href="../classeigen_1_1matrixbase.html">MatrixBase</a>&lt; B &gt; &amp;b)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename MatrixType , typename ResultType &gt; </td></tr> <tr>
<td align="right" valign="top">void </td>
<td valign="bottom">
<a href="group__matrixfunctions__module.html#ga2f490197e16df831683018e383e29346">matrix_sqrt_quasi_triangular</a> (const MatrixType &amp;<a href="../namespaceeigen.html#aa539408a09481d35961e11ee78793db1">arg</a>, ResultType &amp;result)</td>
</tr> <tr>
<td> </td>
<td>Compute matrix square root of quasi-triangular matrix. <a href="group__matrixfunctions__module.html#ga2f490197e16df831683018e383e29346">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename MatrixType , typename ResultType &gt; </td></tr> <tr>
<td align="right" valign="top">void </td>
<td valign="bottom">
<a href="group__matrixfunctions__module.html#gae51c91f920f6ea4a7f6f72caa1e8249f">matrix_sqrt_triangular</a> (const MatrixType &amp;<a href="../namespaceeigen.html#aa539408a09481d35961e11ee78793db1">arg</a>, ResultType &amp;result)</td>
</tr> <tr>
<td> </td>
<td>Compute matrix square root of triangular matrix. <a href="group__matrixfunctions__module.html#gae51c91f920f6ea4a7f6f72caa1e8249f">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename Polynomials , typename T &gt; </td></tr> <tr>
<td align="right" valign="top">T </td>
<td valign="bottom">
<a href="group__polynomials__module.html#gadb64ffddaa9e83634e3ab0e3fd3664f5">poly_eval</a> (const Polynomials &amp;poly, const T &amp;x)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename Polynomials , typename T &gt; </td></tr> <tr>
<td align="right" valign="top">T </td>
<td valign="bottom">
<a href="group__polynomials__module.html#gaadbf059bc28ce1cf94c57c1454633d40">poly_eval_horner</a> (const Polynomials &amp;poly, const T &amp;x)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename DerivedN , typename DerivedX &gt; </td></tr> <tr>
<td align="right" valign="top">const <a href="../classeigen_1_1cwisebinaryop.html">Eigen::CwiseBinaryOp</a>&lt; Eigen::internal::scalar_polygamma_op&lt; typename DerivedX::Scalar &gt;, const DerivedN, const DerivedX &gt; </td>
<td valign="bottom">
<a href="namespaceeigen.html#a7ec2455c3a3bb4b0c1401b25a8480361">polygamma</a> (const <a href="../classeigen_1_1arraybase.html">Eigen::ArrayBase</a>&lt; DerivedN &gt; &amp;n, const <a href="../classeigen_1_1arraybase.html">Eigen::ArrayBase</a>&lt; DerivedX &gt; &amp;x)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename RootVector , typename Polynomial &gt; </td></tr> <tr>
<td align="right" valign="top">void </td>
<td valign="bottom">
<a href="group__polynomials__module.html#gafbc3648f7ef67db3d5d04454fc1257fd">roots_to_monicPolynomial</a> (const RootVector &amp;rv, Polynomial &amp;poly)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr><td colspan="2">template&lt;typename DerivedX , typename DerivedQ &gt; </td></tr> <tr>
<td align="right" valign="top">const <a href="../classeigen_1_1cwisebinaryop.html">Eigen::CwiseBinaryOp</a>&lt; Eigen::internal::scalar_zeta_op&lt; typename DerivedX::Scalar &gt;, const DerivedX, const DerivedQ &gt; </td>
<td valign="bottom">
<a href="namespaceeigen.html#ade7c45ba55113cf0c89e33972f3da434">zeta</a> (const <a href="../classeigen_1_1arraybase.html">Eigen::ArrayBase</a>&lt; DerivedX &gt; &amp;x, const <a href="../classeigen_1_1arraybase.html">Eigen::ArrayBase</a>&lt; DerivedQ &gt; &amp;q)</td>
</tr> <tr><td colspan="2"> </td></tr> </table>  <div>
<p>Namespace containing all symbols from the Eigen library. </p> </div> <a id="ab0c429bb38ce58964b561fb9d6c9377a"></a> <h2>bessel_i0()</h2> <div> <div> <div> template&lt;typename Derived &gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="../classeigen_1_1cwiseunaryop.html">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_i0_op&lt;typename Derived::Scalar&gt;, const Derived&gt; Eigen::bessel_i0 </td> <td>(</td> <td>const <a href="../classeigen_1_1arraybase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp; </td> <td><em>x</em></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>an expression of the coefficient-wise i0(<em>x</em>) to the given arrays.</dd>
</dl> <p>It returns the modified Bessel function of the first kind of order zero.</p> <dl>
<dt>Parameters</dt>
<dd> <table> <tr>
<td>x</td>
<td>is the argument</td>
</tr> </table> </dd> </dl> <dl>
<dt>Note</dt>
<dd>This function supports only float and double scalar types. To support other scalar types, the user has to provide implementations of i0(T) for any scalar type T to be supported.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>ArrayBase::bessel_i0() </dd>
</dl> </div> </div> <a id="aef13ab56dea757bfb7bd3e220ac478d5"></a> <h2>bessel_i0e()</h2> <div> <div> <div> template&lt;typename Derived &gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="../classeigen_1_1cwiseunaryop.html">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_i0e_op&lt;typename Derived::Scalar&gt;, const Derived&gt; Eigen::bessel_i0e </td> <td>(</td> <td>const <a href="../classeigen_1_1arraybase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp; </td> <td><em>x</em></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>an expression of the coefficient-wise i0e(<em>x</em>) to the given arrays.</dd>
</dl> <p>It returns the exponentially scaled modified Bessel function of the first kind of order zero.</p> <dl>
<dt>Parameters</dt>
<dd> <table> <tr>
<td>x</td>
<td>is the argument</td>
</tr> </table> </dd> </dl> <dl>
<dt>Note</dt>
<dd>This function supports only float and double scalar types. To support other scalar types, the user has to provide implementations of i0e(T) for any scalar type T to be supported.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>ArrayBase::bessel_i0e() </dd>
</dl> </div> </div> <a id="ae35e1cabdc81f3783219186a7e658a2b"></a> <h2>bessel_i1()</h2> <div> <div> <div> template&lt;typename Derived &gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="../classeigen_1_1cwiseunaryop.html">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_i1_op&lt;typename Derived::Scalar&gt;, const Derived&gt; Eigen::bessel_i1 </td> <td>(</td> <td>const <a href="../classeigen_1_1arraybase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp; </td> <td><em>x</em></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>an expression of the coefficient-wise i1(<em>x</em>) to the given arrays.</dd>
</dl> <p>It returns the modified Bessel function of the first kind of order one.</p> <dl>
<dt>Parameters</dt>
<dd> <table> <tr>
<td>x</td>
<td>is the argument</td>
</tr> </table> </dd> </dl> <dl>
<dt>Note</dt>
<dd>This function supports only float and double scalar types. To support other scalar types, the user has to provide implementations of i1(T) for any scalar type T to be supported.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>ArrayBase::bessel_i1() </dd>
</dl> </div> </div> <a id="ae52c524c4108c6265e9543468da42e28"></a> <h2>bessel_i1e()</h2> <div> <div> <div> template&lt;typename Derived &gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="../classeigen_1_1cwiseunaryop.html">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_i1e_op&lt;typename Derived::Scalar&gt;, const Derived&gt; Eigen::bessel_i1e </td> <td>(</td> <td>const <a href="../classeigen_1_1arraybase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp; </td> <td><em>x</em></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>an expression of the coefficient-wise i1e(<em>x</em>) to the given arrays.</dd>
</dl> <p>It returns the exponentially scaled modified Bessel function of the first kind of order one.</p> <dl>
<dt>Parameters</dt>
<dd> <table> <tr>
<td>x</td>
<td>is the argument</td>
</tr> </table> </dd> </dl> <dl>
<dt>Note</dt>
<dd>This function supports only float and double scalar types. To support other scalar types, the user has to provide implementations of i1e(T) for any scalar type T to be supported.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>ArrayBase::bessel_i1e() </dd>
</dl> </div> </div> <a id="a65acfc33a2b6140a09af67e45928e037"></a> <h2>bessel_j0()</h2> <div> <div> <div> template&lt;typename Derived &gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="../classeigen_1_1cwiseunaryop.html">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_j0_op&lt;typename Derived::Scalar&gt;, const Derived&gt; Eigen::bessel_j0 </td> <td>(</td> <td>const <a href="../classeigen_1_1arraybase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp; </td> <td><em>x</em></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>an expression of the coefficient-wise j0(<em>x</em>) to the given arrays.</dd>
</dl> <p>It returns the Bessel function of the first kind of order zero.</p> <dl>
<dt>Parameters</dt>
<dd> <table> <tr>
<td>x</td>
<td>is the argument</td>
</tr> </table> </dd> </dl> <dl>
<dt>Note</dt>
<dd>This function supports only float and double scalar types. To support other scalar types, the user has to provide implementations of j0(T) for any scalar type T to be supported.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>ArrayBase::bessel_j0() </dd>
</dl> </div> </div> <a id="a4079ddbfe44e3a865cdb600353f371ab"></a> <h2>bessel_j1()</h2> <div> <div> <div> template&lt;typename Derived &gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="../classeigen_1_1cwiseunaryop.html">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_j1_op&lt;typename Derived::Scalar&gt;, const Derived&gt; Eigen::bessel_j1 </td> <td>(</td> <td>const <a href="../classeigen_1_1arraybase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp; </td> <td><em>x</em></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>an expression of the coefficient-wise j1(<em>x</em>) to the given arrays.</dd>
</dl> <p>It returns the modified Bessel function of the first kind of order one.</p> <dl>
<dt>Parameters</dt>
<dd> <table> <tr>
<td>x</td>
<td>is the argument</td>
</tr> </table> </dd> </dl> <dl>
<dt>Note</dt>
<dd>This function supports only float and double scalar types. To support other scalar types, the user has to provide implementations of j1(T) for any scalar type T to be supported.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>ArrayBase::bessel_j1() </dd>
</dl> </div> </div> <a id="a4664123a5ae23d981410d7dc5cd86970"></a> <h2>bessel_k0()</h2> <div> <div> <div> template&lt;typename Derived &gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="../classeigen_1_1cwiseunaryop.html">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_k0_op&lt;typename Derived::Scalar&gt;, const Derived&gt; Eigen::bessel_k0 </td> <td>(</td> <td>const <a href="../classeigen_1_1arraybase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp; </td> <td><em>x</em></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>an expression of the coefficient-wise k0(<em>x</em>) to the given arrays.</dd>
</dl> <p>It returns the modified Bessel function of the second kind of order zero.</p> <dl>
<dt>Parameters</dt>
<dd> <table> <tr>
<td>x</td>
<td>is the argument</td>
</tr> </table> </dd> </dl> <dl>
<dt>Note</dt>
<dd>This function supports only float and double scalar types. To support other scalar types, the user has to provide implementations of k0(T) for any scalar type T to be supported.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>ArrayBase::bessel_k0() </dd>
</dl> </div> </div> <a id="a9cc57448af6eda4fa72f34be7cc72da5"></a> <h2>bessel_k0e()</h2> <div> <div> <div> template&lt;typename Derived &gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="../classeigen_1_1cwiseunaryop.html">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_k0e_op&lt;typename Derived::Scalar&gt;, const Derived&gt; Eigen::bessel_k0e </td> <td>(</td> <td>const <a href="../classeigen_1_1arraybase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp; </td> <td><em>x</em></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>an expression of the coefficient-wise k0e(<em>x</em>) to the given arrays.</dd>
</dl> <p>It returns the exponentially scaled modified Bessel function of the second kind of order zero.</p> <dl>
<dt>Parameters</dt>
<dd> <table> <tr>
<td>x</td>
<td>is the argument</td>
</tr> </table> </dd> </dl> <dl>
<dt>Note</dt>
<dd>This function supports only float and double scalar types. To support other scalar types, the user has to provide implementations of k0e(T) for any scalar type T to be supported.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>ArrayBase::bessel_k0e() </dd>
</dl> </div> </div> <a id="a76e76fa84ed24785bf32665a48157bf1"></a> <h2>bessel_k1()</h2> <div> <div> <div> template&lt;typename Derived &gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="../classeigen_1_1cwiseunaryop.html">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_k1_op&lt;typename Derived::Scalar&gt;, const Derived&gt; Eigen::bessel_k1 </td> <td>(</td> <td>const <a href="../classeigen_1_1arraybase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp; </td> <td><em>x</em></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>an expression of the coefficient-wise k1(<em>x</em>) to the given arrays.</dd>
</dl> <p>It returns the modified Bessel function of the second kind of order one.</p> <dl>
<dt>Parameters</dt>
<dd> <table> <tr>
<td>x</td>
<td>is the argument</td>
</tr> </table> </dd> </dl> <dl>
<dt>Note</dt>
<dd>This function supports only float and double scalar types. To support other scalar types, the user has to provide implementations of k1(T) for any scalar type T to be supported.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>ArrayBase::bessel_k1() </dd>
</dl> </div> </div> <a id="af9e044c2baa913adea597c4d497a3315"></a> <h2>bessel_k1e()</h2> <div> <div> <div> template&lt;typename Derived &gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="../classeigen_1_1cwiseunaryop.html">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_k1e_op&lt;typename Derived::Scalar&gt;, const Derived&gt; Eigen::bessel_k1e </td> <td>(</td> <td>const <a href="../classeigen_1_1arraybase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp; </td> <td><em>x</em></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>an expression of the coefficient-wise k1e(<em>x</em>) to the given arrays.</dd>
</dl> <p>It returns the exponentially scaled modified Bessel function of the second kind of order one.</p> <dl>
<dt>Parameters</dt>
<dd> <table> <tr>
<td>x</td>
<td>is the argument</td>
</tr> </table> </dd> </dl> <dl>
<dt>Note</dt>
<dd>This function supports only float and double scalar types. To support other scalar types, the user has to provide implementations of k1e(T) for any scalar type T to be supported.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>ArrayBase::bessel_k1e() </dd>
</dl> </div> </div> <a id="aad0c42bfd8d5b4169a542206b460b2d0"></a> <h2>bessel_y0()</h2> <div> <div> <div> template&lt;typename Derived &gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="../classeigen_1_1cwiseunaryop.html">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_y0_op&lt;typename Derived::Scalar&gt;, const Derived&gt; Eigen::bessel_y0 </td> <td>(</td> <td>const <a href="../classeigen_1_1arraybase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp; </td> <td><em>x</em></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>an expression of the coefficient-wise y0(<em>x</em>) to the given arrays.</dd>
</dl> <p>It returns the Bessel function of the second kind of order zero.</p> <dl>
<dt>Parameters</dt>
<dd> <table> <tr>
<td>x</td>
<td>is the argument</td>
</tr> </table> </dd> </dl> <dl>
<dt>Note</dt>
<dd>This function supports only float and double scalar types. To support other scalar types, the user has to provide implementations of y0(T) for any scalar type T to be supported.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>ArrayBase::bessel_y0() </dd>
</dl> </div> </div> <a id="a60d76185793d52703fa01d83d5b46615"></a> <h2>bessel_y1()</h2> <div> <div> <div> template&lt;typename Derived &gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="../classeigen_1_1cwiseunaryop.html">Eigen::CwiseUnaryOp</a>&lt; Eigen::internal::scalar_bessel_y1_op&lt;typename Derived::Scalar&gt;, const Derived&gt; Eigen::bessel_y1 </td> <td>(</td> <td>const <a href="../classeigen_1_1arraybase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp; </td> <td><em>x</em></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>an expression of the coefficient-wise y1(<em>x</em>) to the given arrays.</dd>
</dl> <p>It returns the Bessel function of the second kind of order one.</p> <dl>
<dt>Parameters</dt>
<dd> <table> <tr>
<td>x</td>
<td>is the argument</td>
</tr> </table> </dd> </dl> <dl>
<dt>Note</dt>
<dd>This function supports only float and double scalar types. To support other scalar types, the user has to provide implementations of y1(T) for any scalar type T to be supported.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>ArrayBase::bessel_y1() </dd>
</dl> </div> </div> <a id="a6d7e9b581a1fc3ca3c8aff6a0a69f523"></a> <h2>betainc() <span>[1/2]</span>
</h2> <div> <div> <div> template&lt;typename ADerived , typename BDerived , typename XDerived &gt; </div> <table> <tr> <td> <table> <tr> <td>const TensorCwiseTernaryOp&lt;internal::scalar_betainc_op&lt;typename XDerived::Scalar&gt;, const ADerived, const BDerived, const XDerived&gt; Eigen::betainc </td> <td>(</td> <td>const ADerived &amp; </td> <td>
<em>a</em>, </td> </tr> <tr> <td></td> <td></td> <td>const BDerived &amp; </td> <td>
<em>b</em>, </td> </tr> <tr> <td></td> <td></td> <td>const XDerived &amp; </td> <td>
<em>x</em> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p><span>[c++11]</span> </p>
<dl>
<dt>Returns</dt>
<dd>an expression of the coefficient-wise betainc(<em>x</em>, <em>a</em>, <em>b</em>) to the given tensors.</dd>
</dl> <p>This function computes the regularized incomplete beta function (integral). </p> </div> </div> <a id="ac58db11132cd34e57ad819f3e77ff60c"></a> <h2>betainc() <span>[2/2]</span>
</h2> <div> <div> <div> template&lt;typename ArgADerived , typename ArgBDerived , typename ArgXDerived &gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="../classeigen_1_1cwiseternaryop.html">Eigen::CwiseTernaryOp</a>&lt;Eigen::internal::scalar_betainc_op&lt;typename ArgXDerived::Scalar&gt;, const ArgADerived, const ArgBDerived, const ArgXDerived&gt; Eigen::betainc </td> <td>(</td> <td>const <a href="../classeigen_1_1arraybase.html">Eigen::ArrayBase</a>&lt; ArgADerived &gt; &amp; </td> <td>
<em>a</em>, </td> </tr> <tr> <td></td> <td></td> <td>const <a href="../classeigen_1_1arraybase.html">Eigen::ArrayBase</a>&lt; ArgBDerived &gt; &amp; </td> <td>
<em>b</em>, </td> </tr> <tr> <td></td> <td></td> <td>const <a href="../classeigen_1_1arraybase.html">Eigen::ArrayBase</a>&lt; ArgXDerived &gt; &amp; </td> <td>
<em>x</em> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p><span>[c++11]</span> </p>
<dl>
<dt>Returns</dt>
<dd>an expression of the coefficient-wise betainc(<em>x</em>, <em>a</em>, <em>b</em>) to the given arrays.</dd>
</dl> <p>This function computes the regularized incomplete beta function (integral).</p> <dl>
<dt>Note</dt>
<dd>This function supports only float and double scalar types in c++11 mode. To support other scalar types, or float/double in non c++11 mode, the user has to provide implementations of betainc(T,T,T) for any scalar type T to be supported.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>
<a href="namespaceeigen.html#a6d7e9b581a1fc3ca3c8aff6a0a69f523">Eigen::betainc()</a>, <a href="../namespaceeigen.html#ac2e6331628bb1989b7be6d7e42827649">Eigen::lgamma()</a> </dd>
</dl> </div> </div> <a id="a07d8e283f082c972338f3fc4f644b2a9"></a> <h2>BVIntersect() <span>[1/2]</span>
</h2> <div> <div> <div> template&lt;typename BVH , typename Intersector &gt; </div> <table> <tr> <td>void Eigen::BVIntersect </td> <td>(</td> <td>const BVH &amp; </td> <td>
<em>tree</em>, </td> </tr> <tr> <td></td> <td></td> <td>Intersector &amp; </td> <td>
<em>intersector</em> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </div>
<div> <p>Given a BVH, runs the query encapsulated by <em>intersector</em>. The Intersector type must provide the following members:</p>
<pre data-language="cpp"><span>bool</span> intersectVolume(<span>const</span> BVH::Volume &amp;volume) <span>//returns true if volume intersects the query</span>
<span>bool</span> intersectObject(<span>const</span> BVH::Object &amp;<span>object</span>) <span>//returns true if the search should terminate immediately</span>
</pre> </div> </div> <a id="ac3b8047a3ee05b5e6fec4668197a9a43"></a> <h2>BVIntersect() <span>[2/2]</span>
</h2> <div> <div> <div> template&lt;typename BVH1 , typename BVH2 , typename Intersector &gt; </div> <table> <tr> <td>void Eigen::BVIntersect </td> <td>(</td> <td>const BVH1 &amp; </td> <td>
<em>tree1</em>, </td> </tr> <tr> <td></td> <td></td> <td>const BVH2 &amp; </td> <td>
<em>tree2</em>, </td> </tr> <tr> <td></td> <td></td> <td>Intersector &amp; </td> <td>
<em>intersector</em> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </div>
<div> <p>Given two BVH's, runs the query on their Cartesian product encapsulated by <em>intersector</em>. The Intersector type must provide the following members:</p>
<pre data-language="cpp"><span>bool</span> intersectVolumeVolume(<span>const</span> BVH1::Volume &amp;v1, <span>const</span> BVH2::Volume &amp;v2) <span>//returns true if product of volumes intersects the query</span>
<span>bool</span> intersectVolumeObject(<span>const</span> BVH1::Volume &amp;v1, <span>const</span> BVH2::Object &amp;o2) <span>//returns true if the volume-object product intersects the query</span>
<span>bool</span> intersectObjectVolume(<span>const</span> BVH1::Object &amp;o1, <span>const</span> BVH2::Volume &amp;v2) <span>//returns true if the volume-object product intersects the query</span>
<span>bool</span> intersectObjectObject(<span>const</span> BVH1::Object &amp;o1, <span>const</span> BVH2::Object &amp;o2) <span>//returns true if the search should terminate immediately</span>
</pre> </div> </div> <a id="adcbe73ac1482eacab0e18ee32c25508e"></a> <h2>BVMinimize() <span>[1/2]</span>
</h2> <div> <div> <div> template&lt;typename BVH , typename Minimizer &gt; </div> <table> <tr> <td>Minimizer::Scalar Eigen::BVMinimize </td> <td>(</td> <td>const BVH &amp; </td> <td>
<em>tree</em>, </td> </tr> <tr> <td></td> <td></td> <td>Minimizer &amp; </td> <td>
<em>minimizer</em> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </div>
<div> <p>Given a BVH, runs the query encapsulated by <em>minimizer</em>. </p>
<dl>
<dt>Returns</dt>
<dd>the minimum value. The Minimizer type must provide the following members:<pre data-language="cpp"><span>typedef</span> Scalar <span>//the numeric type of what is being minimized--not necessarily the Scalar type of the BVH (if it has one)</span>
Scalar minimumOnVolume(<span>const</span> BVH::Volume &amp;volume)
Scalar minimumOnObject(<span>const</span> BVH::Object &amp;<span>object</span>)
</pre> </dd>
</dl> </div> </div> <a id="a915f6adc8b195c94a83c35de6a842556"></a> <h2>BVMinimize() <span>[2/2]</span>
</h2> <div> <div> <div> template&lt;typename BVH1 , typename BVH2 , typename Minimizer &gt; </div> <table> <tr> <td>Minimizer::Scalar Eigen::BVMinimize </td> <td>(</td> <td>const BVH1 &amp; </td> <td>
<em>tree1</em>, </td> </tr> <tr> <td></td> <td></td> <td>const BVH2 &amp; </td> <td>
<em>tree2</em>, </td> </tr> <tr> <td></td> <td></td> <td>Minimizer &amp; </td> <td>
<em>minimizer</em> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </div>
<div> <p>Given two BVH's, runs the query on their cartesian product encapsulated by <em>minimizer</em>. </p>
<dl>
<dt>Returns</dt>
<dd>the minimum value. The Minimizer type must provide the following members:<pre data-language="cpp"><span>typedef</span> Scalar <span>//the numeric type of what is being minimized--not necessarily the Scalar type of the BVH (if it has one)</span>
Scalar minimumOnVolumeVolume(<span>const</span> BVH1::Volume &amp;v1, <span>const</span> BVH2::Volume &amp;v2)
Scalar minimumOnVolumeObject(<span>const</span> BVH1::Volume &amp;v1, <span>const</span> BVH2::Object &amp;o2)
Scalar minimumOnObjectVolume(<span>const</span> BVH1::Object &amp;o1, <span>const</span> BVH2::Volume &amp;v2)
Scalar minimumOnObjectObject(<span>const</span> BVH1::Object &amp;o1, <span>const</span> BVH2::Object &amp;o2)
</pre> </dd>
</dl> </div> </div> <a id="afd81653604859fe8e5b09552a7a800c9"></a> <h2>gamma_sample_der_alpha()</h2> <div> <div> <div> template&lt;typename AlphaDerived , typename SampleDerived &gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="../classeigen_1_1cwisebinaryop.html">Eigen::CwiseBinaryOp</a>&lt;Eigen::internal::scalar_gamma_sample_der_alpha_op&lt;typename AlphaDerived::Scalar&gt;, const AlphaDerived, const SampleDerived&gt; Eigen::gamma_sample_der_alpha </td> <td>(</td> <td>const <a href="../classeigen_1_1arraybase.html">Eigen::ArrayBase</a>&lt; AlphaDerived &gt; &amp; </td> <td>
<em>alpha</em>, </td> </tr> <tr> <td></td> <td></td> <td>const <a href="../classeigen_1_1arraybase.html">Eigen::ArrayBase</a>&lt; SampleDerived &gt; &amp; </td> <td>
<em>sample</em> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p><span>[c++11]</span> </p>
<dl>
<dt>Returns</dt>
<dd>an expression of the coefficient-wise gamma_sample_der_alpha(<em>alpha</em>, <em>sample</em>) to the given arrays.</dd>
</dl> <p>This function computes the coefficient-wise derivative of the sample of a Gamma(alpha, 1) random variable with respect to the parameter alpha.</p> <dl>
<dt>Note</dt>
<dd>This function supports only float and double scalar types in c++11 mode. To support other scalar types, or float/double in non c++11 mode, the user has to provide implementations of gamma_sample_der_alpha(T,T) for any scalar type T to be supported.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>
<a href="namespaceeigen.html#a6e89509c5ff1af076baea462520f231c">Eigen::igamma()</a>, <a href="../namespaceeigen.html#ac2e6331628bb1989b7be6d7e42827649">Eigen::lgamma()</a> </dd>
</dl> </div> </div> <a id="a6e89509c5ff1af076baea462520f231c"></a> <h2>igamma()</h2> <div> <div> <div> template&lt;typename Derived , typename ExponentDerived &gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="../classeigen_1_1cwisebinaryop.html">Eigen::CwiseBinaryOp</a>&lt;Eigen::internal::scalar_igamma_op&lt;typename Derived::Scalar&gt;, const Derived, const ExponentDerived&gt; Eigen::igamma </td> <td>(</td> <td>const <a href="../classeigen_1_1arraybase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp; </td> <td>
<em>a</em>, </td> </tr> <tr> <td></td> <td></td> <td>const <a href="../classeigen_1_1arraybase.html">Eigen::ArrayBase</a>&lt; ExponentDerived &gt; &amp; </td> <td>
<em>x</em> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p><span>[c++11]</span> </p>
<dl>
<dt>Returns</dt>
<dd>an expression of the coefficient-wise igamma(<em>a</em>, <em>x</em>) to the given arrays.</dd>
</dl> <p>This function computes the coefficient-wise incomplete gamma function.</p> <dl>
<dt>Note</dt>
<dd>This function supports only float and double scalar types in c++11 mode. To support other scalar types, or float/double in non c++11 mode, the user has to provide implementations of igammac(T,T) for any scalar type T to be supported.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>
<a href="namespaceeigen.html#a2b1593c0c3f9d1673ae5980ae03e75f1">Eigen::igammac()</a>, <a href="../namespaceeigen.html#ac2e6331628bb1989b7be6d7e42827649">Eigen::lgamma()</a> </dd>
</dl> </div> </div> <a id="ad0b09518c9ef2376690af1b346f77ff1"></a> <h2>igamma_der_a()</h2> <div> <div> <div> template&lt;typename Derived , typename ExponentDerived &gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="../classeigen_1_1cwisebinaryop.html">Eigen::CwiseBinaryOp</a>&lt;Eigen::internal::scalar_igamma_der_a_op&lt;typename Derived::Scalar&gt;, const Derived, const ExponentDerived&gt; Eigen::igamma_der_a </td> <td>(</td> <td>const <a href="../classeigen_1_1arraybase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp; </td> <td>
<em>a</em>, </td> </tr> <tr> <td></td> <td></td> <td>const <a href="../classeigen_1_1arraybase.html">Eigen::ArrayBase</a>&lt; ExponentDerived &gt; &amp; </td> <td>
<em>x</em> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p><span>[c++11]</span> </p>
<dl>
<dt>Returns</dt>
<dd>an expression of the coefficient-wise igamma_der_a(<em>a</em>, <em>x</em>) to the given arrays.</dd>
</dl> <p>This function computes the coefficient-wise derivative of the incomplete gamma function with respect to the parameter a.</p> <dl>
<dt>Note</dt>
<dd>This function supports only float and double scalar types in c++11 mode. To support other scalar types, or float/double in non c++11 mode, the user has to provide implementations of igamma_der_a(T,T) for any scalar type T to be supported.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>
<a href="namespaceeigen.html#a6e89509c5ff1af076baea462520f231c">Eigen::igamma()</a>, <a href="../namespaceeigen.html#ac2e6331628bb1989b7be6d7e42827649">Eigen::lgamma()</a> </dd>
</dl> </div> </div> <a id="a2b1593c0c3f9d1673ae5980ae03e75f1"></a> <h2>igammac()</h2> <div> <div> <div> template&lt;typename Derived , typename ExponentDerived &gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="../classeigen_1_1cwisebinaryop.html">Eigen::CwiseBinaryOp</a>&lt;Eigen::internal::scalar_igammac_op&lt;typename Derived::Scalar&gt;, const Derived, const ExponentDerived&gt; Eigen::igammac </td> <td>(</td> <td>const <a href="../classeigen_1_1arraybase.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp; </td> <td>
<em>a</em>, </td> </tr> <tr> <td></td> <td></td> <td>const <a href="../classeigen_1_1arraybase.html">Eigen::ArrayBase</a>&lt; ExponentDerived &gt; &amp; </td> <td>
<em>x</em> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p><span>[c++11]</span> </p>
<dl>
<dt>Returns</dt>
<dd>an expression of the coefficient-wise igammac(<em>a</em>, <em>x</em>) to the given arrays.</dd>
</dl> <p>This function computes the coefficient-wise complementary incomplete gamma function.</p> <dl>
<dt>Note</dt>
<dd>This function supports only float and double scalar types in c++11 mode. To support other scalar types, or float/double in non c++11 mode, the user has to provide implementations of igammac(T,T) for any scalar type T to be supported.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>
<a href="namespaceeigen.html#a6e89509c5ff1af076baea462520f231c">Eigen::igamma()</a>, <a href="../namespaceeigen.html#ac2e6331628bb1989b7be6d7e42827649">Eigen::lgamma()</a> </dd>
</dl> </div> </div> <a id="a7ec2455c3a3bb4b0c1401b25a8480361"></a> <h2>polygamma()</h2> <div> <div> <div> template&lt;typename DerivedN , typename DerivedX &gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="../classeigen_1_1cwisebinaryop.html">Eigen::CwiseBinaryOp</a>&lt;Eigen::internal::scalar_polygamma_op&lt;typename DerivedX::Scalar&gt;, const DerivedN, const DerivedX&gt; Eigen::polygamma </td> <td>(</td> <td>const <a href="../classeigen_1_1arraybase.html">Eigen::ArrayBase</a>&lt; DerivedN &gt; &amp; </td> <td>
<em>n</em>, </td> </tr> <tr> <td></td> <td></td> <td>const <a href="../classeigen_1_1arraybase.html">Eigen::ArrayBase</a>&lt; DerivedX &gt; &amp; </td> <td>
<em>x</em> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p><span>[c++11]</span> </p>
<dl>
<dt>Returns</dt>
<dd>an expression of the coefficient-wise polygamma(<em>n</em>, <em>x</em>) to the given arrays.</dd>
</dl> <p>It returns the <em>n</em> -th derivative of the digamma(psi) evaluated at <code>x</code>.</p> <dl>
<dt>Note</dt>
<dd>This function supports only float and double scalar types in c++11 mode. To support other scalar types, or float/double in non c++11 mode, the user has to provide implementations of polygamma(T,T) for any scalar type T to be supported.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>
<a href="../namespaceeigen.html#af40db84b3db19fe25fe2f77c429420e5">Eigen::digamma()</a> </dd>
</dl> </div> </div> <a id="ade7c45ba55113cf0c89e33972f3da434"></a> <h2>zeta()</h2> <div> <div> <div> template&lt;typename DerivedX , typename DerivedQ &gt; </div> <table> <tr> <td> <table> <tr> <td>const <a href="../classeigen_1_1cwisebinaryop.html">Eigen::CwiseBinaryOp</a>&lt;Eigen::internal::scalar_zeta_op&lt;typename DerivedX::Scalar&gt;, const DerivedX, const DerivedQ&gt; Eigen::zeta </td> <td>(</td> <td>const <a href="../classeigen_1_1arraybase.html">Eigen::ArrayBase</a>&lt; DerivedX &gt; &amp; </td> <td>
<em>x</em>, </td> </tr> <tr> <td></td> <td></td> <td>const <a href="../classeigen_1_1arraybase.html">Eigen::ArrayBase</a>&lt; DerivedQ &gt; &amp; </td> <td>
<em>q</em> </td> </tr> <tr> <td></td> <td>)</td> <td></td>
<td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <dl>
<dt>Returns</dt>
<dd>an expression of the coefficient-wise zeta(<em>x</em>, <em>q</em>) to the given arrays.</dd>
</dl> <p>It returns the Riemann zeta function of two arguments <em>x</em> and <em>q:</em> </p> <dl>
<dt>Parameters</dt>
<dd> <table> <tr>
<td>x</td>
<td>is the exponent, it must be &gt; 1 </td>
</tr> <tr>
<td>q</td>
<td>is the shift, it must be &gt; 0</td>
</tr> </table> </dd> </dl> <dl>
<dt>Note</dt>
<dd>This function supports only float and double scalar types. To support other scalar types, the user has to provide implementations of zeta(T,T) for any scalar type T to be supported.</dd>
</dl> <dl>
<dt>See also</dt>
<dd>ArrayBase::zeta() </dd>
</dl> </div> </div> </div> <div class="_attribution">
  <p class="_attribution-p">
    &copy; Eigen.<br>Licensed under the MPL2 License.<br>
    <a href="https://eigen.tuxfamily.org/dox/unsupported/namespaceEigen.html" class="_attribution-link">https://eigen.tuxfamily.org/dox/unsupported/namespaceEigen.html</a>
  </p>
</div>
