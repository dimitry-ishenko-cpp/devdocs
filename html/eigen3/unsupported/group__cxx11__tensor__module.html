<h1>Tensor Module</h1>      <div>  <p>This module provides a Tensor class for storing arbitrarily indexed objects.</p> <pre data-language="cpp"><span>#include &lt;Eigen/CXX11/Tensor&gt;</span>
</pre>
<p>Much of the documentation can be found <a href="eigen_tensors.html">here</a>. </p> <table> <tr><td colspan="2"></td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensor.html">Eigen::Tensor&lt; Scalar_, NumIndices_, Options_, IndexType_ &gt;</a></td>
</tr> <tr>
<td> </td>
<td>The tensor class. <a href="classeigen_1_1tensor.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorassign.html">TensorAssign</a></td>
</tr> <tr>
<td> </td>
<td>The tensor assignment class. <a href="classtensorassign.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensorasyncdevice.html">Eigen::TensorAsyncDevice&lt; ExpressionType, DeviceType, DoneCallback &gt;</a></td>
</tr> <tr>
<td> </td>
<td>Pseudo expression providing an operator = that will evaluate its argument asynchronously on the specified device. Currently only ThreadPoolDevice implements proper asynchronous execution, while the default and GPU devices just run the expression synchronously and call m_done() on completion.. <a href="classeigen_1_1tensorasyncdevice.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensorbase.html">Eigen::TensorBase&lt; Derived, AccessLevel &gt;</a></td>
</tr> <tr>
<td> </td>
<td>The tensor base class. <a href="classeigen_1_1tensorbase.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorbroadcasting.html">TensorBroadcasting</a></td>
</tr> <tr>
<td> </td>
<td>Tensor broadcasting class. <a href="classtensorbroadcasting.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensorconcatenationop.html">Eigen::TensorConcatenationOp&lt; Axis, LhsXprType, RhsXprType &gt;</a></td>
</tr> <tr>
<td> </td>
<td>
<a href="classeigen_1_1tensor.html" title="The tensor class.">Tensor</a> concatenation class. <a href="classeigen_1_1tensorconcatenationop.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorcontraction.html">TensorContraction</a></td>
</tr> <tr>
<td> </td>
<td>Tensor contraction class. <a href="classtensorcontraction.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensorconversionop.html">Eigen::TensorConversionOp&lt; TargetType, XprType &gt;</a></td>
</tr> <tr>
<td> </td>
<td>
<a href="classeigen_1_1tensor.html" title="The tensor class.">Tensor</a> conversion class. This class makes it possible to vectorize type casting operations when the number of scalars per packet in the source and the destination type differ. <a href="classeigen_1_1tensorconversionop.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorconvolution.html">TensorConvolution</a></td>
</tr> <tr>
<td> </td>
<td>Tensor convolution class. <a href="classtensorconvolution.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensorcustombinaryop.html">Eigen::TensorCustomBinaryOp&lt; CustomBinaryFunc, LhsXprType, RhsXprType &gt;</a></td>
</tr> <tr>
<td> </td>
<td>
<a href="classeigen_1_1tensor.html" title="The tensor class.">Tensor</a> custom class. <a href="classeigen_1_1tensorcustombinaryop.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensorcustomunaryop.html">Eigen::TensorCustomUnaryOp&lt; CustomUnaryFunc, XprType &gt;</a></td>
</tr> <tr>
<td> </td>
<td>
<a href="classeigen_1_1tensor.html" title="The tensor class.">Tensor</a> custom class. <a href="classeigen_1_1tensorcustomunaryop.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensordevice.html">Eigen::TensorDevice&lt; ExpressionType, DeviceType &gt;</a></td>
</tr> <tr>
<td> </td>
<td>Pseudo expression providing an operator = that will evaluate its argument on the specified computing 'device' (GPU, thread pool, ...) <a href="classeigen_1_1tensordevice.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="structeigen_1_1tensorevaluator.html">Eigen::TensorEvaluator&lt; Derived, Device &gt;</a></td>
</tr> <tr>
<td> </td>
<td>A cost model used to limit the number of threads used for evaluating tensor expression. <a href="structeigen_1_1tensorevaluator.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorexecutor.html">TensorExecutor</a></td>
</tr> <tr>
<td> </td>
<td>The tensor executor class. <a href="classtensorexecutor.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorexpr.html">TensorExpr</a></td>
</tr> <tr>
<td> </td>
<td>Tensor expression classes. <a href="classtensorexpr.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorfft.html">TensorFFT</a></td>
</tr> <tr>
<td> </td>
<td>Tensor FFT class. <a href="classtensorfft.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensorfixedsize.html">Eigen::TensorFixedSize&lt; Scalar_, Dimensions_, Options_, IndexType &gt;</a></td>
</tr> <tr>
<td> </td>
<td>The fixed sized version of the tensor class. <a href="classeigen_1_1tensorfixedsize.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorforcedeval.html">TensorForcedEval</a></td>
</tr> <tr>
<td> </td>
<td>Tensor reshaping class. <a href="classtensorforcedeval.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensorgeneratorop.html">Eigen::TensorGeneratorOp&lt; Generator, XprType &gt;</a></td>
</tr> <tr>
<td> </td>
<td>
<a href="classeigen_1_1tensor.html" title="The tensor class.">Tensor</a> generator class. <a href="classeigen_1_1tensorgeneratorop.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorimagepatch.html">TensorImagePatch</a></td>
</tr> <tr>
<td> </td>
<td>Patch extraction specialized for image processing. This assumes that the input has a least 3 dimensions ordered as follow: 1st dimension: channels (of size d) 2nd dimension: rows (of size r) 3rd dimension: columns (of size c) There can be additional dimensions such as time (for video) or batch (for bulk processing after the first 3. Calling the image patch code with patch_rows and patch_cols is equivalent to calling the regular patch extraction code with parameters d, patch_rows, patch_cols, and 1 for all the additional dimensions. <a href="classtensorimagepatch.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorindextuple.html">TensorIndexTuple</a></td>
</tr> <tr>
<td> </td>
<td>Tensor + Index Tuple class. <a href="classtensorindextuple.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorinflation.html">TensorInflation</a></td>
</tr> <tr>
<td> </td>
<td>Tensor inflation class. <a href="classtensorinflation.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorkchippingreshaping.html">TensorKChippingReshaping</a></td>
</tr> <tr>
<td> </td>
<td>A chip is a thin slice, corresponding to a column or a row in a 2-d tensor. <a href="classtensorkchippingreshaping.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorlayoutswap.html">TensorLayoutSwap</a></td>
</tr> <tr>
<td> </td>
<td>Swap the layout from col-major to row-major, or row-major to col-major, and invert the order of the dimensions. <a href="classtensorlayoutswap.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensormap.html">Eigen::TensorMap&lt; PlainObjectType, Options_, MakePointer_ &gt;</a></td>
</tr> <tr>
<td> </td>
<td>A tensor expression mapping an existing array of data. <a href="classeigen_1_1tensormap.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorpadding.html">TensorPadding</a></td>
</tr> <tr>
<td> </td>
<td>Tensor padding class. At the moment only padding with a constant value is supported. <a href="classtensorpadding.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorpatch.html">TensorPatch</a></td>
</tr> <tr>
<td> </td>
<td>Tensor patch class. <a href="classtensorpatch.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorreduction.html">TensorReduction</a></td>
</tr> <tr>
<td> </td>
<td>Tensor reduction class. <a href="classtensorreduction.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classeigen_1_1tensorref.html">Eigen::TensorRef&lt; PlainObjectType &gt;</a></td>
</tr> <tr>
<td> </td>
<td>A reference to a tensor expression The expression will be evaluated lazily (as much as possible). <a href="classeigen_1_1tensorref.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorreshaping.html">TensorReshaping</a></td>
</tr> <tr>
<td> </td>
<td>Tensor reshaping class. <a href="classtensorreshaping.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorreverse.html">TensorReverse</a></td>
</tr> <tr>
<td> </td>
<td>Tensor reverse elements class. <a href="classtensorreverse.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorscan.html">TensorScan</a></td>
</tr> <tr>
<td> </td>
<td>Tensor scan class. <a href="classtensorscan.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorshuffling.html">TensorShuffling</a></td>
</tr> <tr>
<td> </td>
<td>Tensor shuffling class. <a href="classtensorshuffling.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorslicing.html">TensorSlicing</a></td>
</tr> <tr>
<td> </td>
<td>Tensor slicing class. <a href="classtensorslicing.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorstriding.html">TensorStriding</a></td>
</tr> <tr>
<td> </td>
<td>Tensor striding class. <a href="classtensorstriding.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensortrace.html">TensorTrace</a></td>
</tr> <tr>
<td> </td>
<td>Tensor Trace class. <a href="classtensortrace.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensortupleindex.html">TensorTupleIndex</a></td>
</tr> <tr>
<td> </td>
<td>Converts to Tensor&lt;Tuple&lt;Index, Scalar&gt; &gt; and reduces to Tensor&lt;Index&gt;. <a href="classtensortupleindex.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">class </td>
<td valign="bottom"><a href="classtensorvolumepatch.html">TensorVolumePatch</a></td>
</tr> <tr>
<td> </td>
<td>Patch extraction specialized for processing of volumetric data. This assumes that the input has a least 4 dimensions ordered as follows: <a href="classtensorvolumepatch.html#details">More...</a><br>
</td>
</tr> <tr><td colspan="2"> </td></tr> </table> </div> <div class="_attribution">
  <p class="_attribution-p">
    &copy; Eigen.<br>Licensed under the MPL2 License.<br>
    <a href="https://eigen.tuxfamily.org/dox/unsupported/group__CXX11__Tensor__Module.html" class="_attribution-link">https://eigen.tuxfamily.org/dox/unsupported/group__CXX11__Tensor__Module.html</a>
  </p>
</div>
