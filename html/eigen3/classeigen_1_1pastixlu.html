<h1>Eigen::PastixLU</h1>      <div>  <div>
<h3>template&lt;typename _MatrixType, bool IsStrSym&gt;<br> class Eigen::PastixLU&lt; _MatrixType, IsStrSym &gt;</h3> <p>Interface to the PaStix solver. </p> <p><a href="structeigen_1_1sparse.html">Sparse</a> direct LU solver based on PaStiX library.</p> <p>This class is used to solve the linear systems A.X = B via the PaStix library. The matrix can be either real or complex, symmetric or not.</p> <dl>
<dt>See also</dt>
<dd>TutorialSparseDirectSolvers</dd>
</dl> <p>This class is used to solve the linear systems A.X = B with a supernodal LU factorization in the PaStiX library. The matrix A should be squared and nonsingular PaStiX requires that the matrix A has a symmetric structural pattern. This interface can symmetrize the input matrix otherwise. The vectors or matrices X and B can be either dense or sparse.</p> <dl>
<dt>Template Parameters</dt>
<dd> <table> <tr>
<td>_MatrixType</td>
<td>the type of the sparse matrix A, it must be a SparseMatrix&lt;&gt; </td>
</tr> <tr>
<td>IsStrSym</td>
<td>Indicates if the input matrix has a symmetric pattern, default is false NOTE : Note that if the analysis and factorization phase are called separately, the input matrix will be symmetrized at each call, hence it is advised to symmetrize the matrix in a end-user program and set <code>IsStrSym</code> to true</td>
</tr> </table> </dd> </dl> <p>This class follows the <a href="group__topicsparsesystems.html#TutorialSparseSolverConcept">sparse solver concept </a>.</p> <dl>
<dt>See also</dt>
<dd>
<a href="group__topicsparsesystems.html#TutorialSparseSolverConcept">Sparse solver concept</a>, class <a href="classeigen_1_1sparselu.html" title="Sparse supernodal LU factorization for general matrices.">SparseLU</a> </dd>
</dl> </div> <p>Inherits Eigen::PastixBase&lt; Derived &gt;.</p> <table> <tr><td colspan="2"></td></tr> <tr>
<td align="right" valign="top">void </td>
<td valign="bottom">
<a href="classeigen_1_1pastixlu.html#abae3ca7f1254106d9e2d5e0f273189fa">analyzePattern</a> (const MatrixType &amp;matrix)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">void </td>
<td valign="bottom">
<a href="classeigen_1_1pastixlu.html#adc28ee2550086c7bdfe991d624bde2ee">compute</a> (const MatrixType &amp;matrix)</td>
</tr> <tr><td colspan="2"> </td></tr> <tr>
<td align="right" valign="top">void </td>
<td valign="bottom">
<a href="classeigen_1_1pastixlu.html#ac178a87b499a2210a402787fbfd98f26">factorize</a> (const MatrixType &amp;matrix)</td>
</tr> <tr><td colspan="2"> </td></tr> </table>  <a id="abae3ca7f1254106d9e2d5e0f273189fa"></a> <h2>analyzePattern()</h2> <div> <div> <div> template&lt;typename _MatrixType , bool IsStrSym&gt; </div> <table> <tr> <td> <table> <tr> <td>void <a href="classeigen_1_1pastixlu.html">Eigen::PastixLU</a>&lt; _MatrixType, IsStrSym &gt;::analyzePattern </td> <td>(</td> <td>const MatrixType &amp; </td> <td><em>matrix</em></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>Compute the LU symbolic factorization of <code>matrix</code> using its sparsity pattern. Several ordering methods can be used at this step. See the PaStiX user's manual. The result of this operation can be used with successive matrices having the same pattern as <code>matrix</code> </p>
<dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1pastixlu.html#ac178a87b499a2210a402787fbfd98f26">factorize()</a> </dd>
</dl> </div> </div> <a id="adc28ee2550086c7bdfe991d624bde2ee"></a> <h2>compute()</h2> <div> <div> <div> template&lt;typename _MatrixType , bool IsStrSym&gt; </div> <table> <tr> <td> <table> <tr> <td>void <a href="classeigen_1_1pastixlu.html">Eigen::PastixLU</a>&lt; _MatrixType, IsStrSym &gt;::compute </td> <td>(</td> <td>const MatrixType &amp; </td> <td><em>matrix</em></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>Compute the LU supernodal factorization of <code>matrix</code>. iparm and dparm can be used to tune the PaStiX parameters. see the PaStiX user's manual </p>
<dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1pastixlu.html#abae3ca7f1254106d9e2d5e0f273189fa">analyzePattern()</a> <a href="classeigen_1_1pastixlu.html#ac178a87b499a2210a402787fbfd98f26">factorize()</a> </dd>
</dl> </div> </div> <a id="ac178a87b499a2210a402787fbfd98f26"></a> <h2>factorize()</h2> <div> <div> <div> template&lt;typename _MatrixType , bool IsStrSym&gt; </div> <table> <tr> <td> <table> <tr> <td>void <a href="classeigen_1_1pastixlu.html">Eigen::PastixLU</a>&lt; _MatrixType, IsStrSym &gt;::factorize </td> <td>(</td> <td>const MatrixType &amp; </td> <td><em>matrix</em></td>
<td>)</td> <td></td> </tr> </table> </td> <td> <span><span>inline</span></span> </td> </tr> </table> </div>
<div> <p>Compute the LU supernodal factorization of <code>matrix</code> WARNING The matrix <code>matrix</code> should have the same structural pattern as the same used in the analysis phase. </p>
<dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1pastixlu.html#abae3ca7f1254106d9e2d5e0f273189fa">analyzePattern()</a> </dd>
</dl> </div> </div> <hr>The documentation for this class was generated from the following file:<ul> <li><a href="https://eigen.tuxfamily.org/dox/PaStiXSupport_8h_source.html">PaStiXSupport.h</a></li> </ul> </div> <div class="_attribution">
  <p class="_attribution-p">
    &copy; Eigen.<br>Licensed under the MPL2 License.<br>
    <a href="https://eigen.tuxfamily.org/dox/classEigen_1_1PastixLU.html" class="_attribution-link">https://eigen.tuxfamily.org/dox/classEigen_1_1PastixLU.html</a>
  </p>
</div>
