<h1>Sparse matrix manipulations</h1>      <div> <p>Manipulating and solving sparse problems involves various modules which are summarized below:</p> <table> <tr> <th>Module</th>
<th>Header file</th>
<th>Contents </th>
</tr> <tr> <td><a href="group__sparsecore__module.html">SparseCore </a></td>
<td><pre data-language="cpp"><span>#include &lt;Eigen/SparseCore&gt;</span>
</pre></td>
<td>
<a href="classeigen_1_1sparsematrix.html" title="A versatible sparse matrix representation.">SparseMatrix</a> and <a href="classeigen_1_1sparsevector.html" title="a sparse vector class">SparseVector</a> classes, matrix assembly, basic sparse linear algebra (including sparse triangular solvers) </td>
</tr> <tr> <td><a href="group__sparsecholesky__module.html">SparseCholesky </a></td>
<td><pre data-language="cpp"><span>#include &lt;Eigen/SparseCholesky&gt;</span>
</pre></td>
<td>Direct sparse <a href="classeigen_1_1llt.html" title="Standard Cholesky decomposition (LL^T) of a matrix and associated features.">LLT</a> and <a href="classeigen_1_1ldlt.html" title="Robust Cholesky decomposition of a matrix with pivoting.">LDLT</a> Cholesky factorization to solve sparse self-adjoint positive definite problems </td>
</tr> <tr> <td><a href="group__sparselu__module.html">SparseLU </a></td>
<td>
<pre data-language="cpp"><span>#include&lt;Eigen/SparseLU&gt;</span> 
</pre> </td>
<td>Sparse LU factorization to solve general square sparse systems </td>
</tr> <tr> <td><a href="group__sparseqr__module.html">SparseQR </a></td>
<td>
<pre data-language="cpp"><span>#include&lt;Eigen/SparseQR&gt;</span>
</pre> </td>
<td>Sparse QR factorization for solving sparse linear least-squares problems </td>
</tr> <tr> <td><a href="group__iterativelinearsolvers__module.html">IterativeLinearSolvers </a></td>
<td><pre data-language="cpp"><span>#include &lt;Eigen/IterativeLinearSolvers&gt;</span>
</pre></td>
<td>Iterative solvers to solve large general linear square problems (including self-adjoint positive definite problems) </td>
</tr> <tr> <td><a href="group__sparse__module.html">Sparse </a></td>
<td><pre data-language="cpp"><span>#include &lt;Eigen/Sparse&gt;</span>
</pre></td>
<td>Includes all the above modules </td>
</tr> </table> <h1>
<a id="TutorialSparseIntro"></a> Sparse matrix format</h1> <p>In many applications (e.g., finite element methods) it is common to deal with very large matrices where only a few coefficients are different from zero. In such cases, memory consumption can be reduced and performance increased by using a specialized representation storing only the nonzero coefficients. Such a matrix is called a sparse matrix.</p> <p><b>The</b> <b>SparseMatrix</b> <b>class</b> </p> <p>The class <a href="classeigen_1_1sparsematrix.html" title="A versatible sparse matrix representation.">SparseMatrix</a> is the main sparse matrix representation of <a href="namespaceeigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a>'s sparse module; it offers high performance and low memory usage. It implements a more versatile variant of the widely-used Compressed Column (or Row) Storage scheme. It consists of four compact arrays:</p>
<ul> <li>
<code>Values:</code> stores the coefficient values of the non-zeros.</li> <li>
<code>InnerIndices:</code> stores the row (resp. column) indices of the non-zeros.</li> <li>
<code>OuterStarts:</code> stores for each column (resp. row) the index of the first non-zero in the previous two arrays.</li> <li>
<code>InnerNNZs:</code> stores the number of non-zeros of each column (resp. row). The word <code>inner</code> refers to an <em>inner</em> <em>vector</em> that is a column for a column-major matrix, or a row for a row-major matrix. The word <code>outer</code> refers to the other direction.</li> </ul> <p>This storage scheme is better explained on an example. The following matrix </p>
<table> <tr> <td>0</td>
<td>3</td>
<td>0</td>
<td>0</td>
<td>0 </td>
</tr> <tr> <td>22</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>17 </td>
</tr> <tr> <td>7</td>
<td>5</td>
<td>0</td>
<td>1</td>
<td>0 </td>
</tr> <tr> <td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0 </td>
</tr> <tr> <td>0</td>
<td>0</td>
<td>14</td>
<td>0</td>
<td>8 </td>
</tr> </table> <p>and one of its possible sparse, <b>column</b> <b>major</b> representation: </p>
<table> <tr> <td>Values: </td>
<td>22</td>
<td>7</td>
<td>_</td>
<td>3</td>
<td>5</td>
<td>14</td>
<td>_</td>
<td>_</td>
<td>1</td>
<td>_</td>
<td>17</td>
<td>8 </td>
</tr> <tr> <td>InnerIndices: </td>
<td>1</td>
<td>2</td>
<td>_</td>
<td>0</td>
<td>2</td>
<td>4</td>
<td>_</td>
<td>_</td>
<td>2</td>
<td>_</td>
<td>1</td>
<td>4 </td>
</tr> </table> <table> <tr> <td>OuterStarts:</td>
<td>0</td>
<td>3</td>
<td>5</td>
<td>8</td>
<td>10</td>
<td>
<em>12</em> </td>
</tr> <tr> <td>InnerNNZs: </td>
<td>2</td>
<td>2</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td></td>
</tr> </table> <p>Currently the elements of a given inner vector are guaranteed to be always sorted by increasing inner indices. The <code>"_"</code> indicates available free space to quickly insert new elements. Assuming no reallocation is needed, the insertion of a random element is therefore in O(nnz_j) where nnz_j is the number of nonzeros of the respective inner vector. On the other hand, inserting elements with increasing inner indices in a given inner vector is much more efficient since this only requires to increase the respective <code>InnerNNZs</code> entry that is a O(1) operation.</p> <p>The case where no empty space is available is a special case, and is referred as the <em>compressed</em> mode. It corresponds to the widely used Compressed Column (or Row) Storage schemes (CCS or CRS). Any <a href="classeigen_1_1sparsematrix.html" title="A versatible sparse matrix representation.">SparseMatrix</a> can be turned to this form by calling the <a href="classeigen_1_1sparsematrix.html#a5ff54ffc10296f9466dc81fa888733fd">SparseMatrix::makeCompressed()</a> function. In this case, one can remark that the <code>InnerNNZs</code> array is redundant with <code>OuterStarts</code> because we have the equality: <code>InnerNNZs</code>[j] = <code>OuterStarts</code>[j+1]-<code>OuterStarts</code>[j]. Therefore, in practice a call to <a href="classeigen_1_1sparsematrix.html#a5ff54ffc10296f9466dc81fa888733fd">SparseMatrix::makeCompressed()</a> frees this buffer.</p> <p>It is worth noting that most of our wrappers to external libraries requires compressed matrices as inputs.</p> <p>The results of Eigen's operations always produces <b>compressed</b> sparse matrices. On the other hand, the insertion of a new element into a <a href="classeigen_1_1sparsematrix.html" title="A versatible sparse matrix representation.">SparseMatrix</a> converts this later to the <b>uncompressed</b> mode.</p> <p>Here is the previous matrix represented in compressed mode: </p>
<table> <tr> <td>Values: </td>
<td>22</td>
<td>7</td>
<td>3</td>
<td>5</td>
<td>14</td>
<td>1</td>
<td>17</td>
<td>8 </td>
</tr> <tr> <td>InnerIndices: </td>
<td>1</td>
<td>2</td>
<td>0</td>
<td>2</td>
<td>4</td>
<td>2</td>
<td>1</td>
<td>4 </td>
</tr> </table> <table> <tr> <td>OuterStarts:</td>
<td>0</td>
<td>2</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>
<em>8</em> </td>
</tr> </table> <p>A <a href="classeigen_1_1sparsevector.html" title="a sparse vector class">SparseVector</a> is a special case of a <a href="classeigen_1_1sparsematrix.html" title="A versatible sparse matrix representation.">SparseMatrix</a> where only the <code>Values</code> and <code>InnerIndices</code> arrays are stored. There is no notion of compressed/uncompressed mode for a <a href="classeigen_1_1sparsevector.html" title="a sparse vector class">SparseVector</a>.</p> <h1>
<a id="TutorialSparseExample"></a> First example</h1> <p>Before describing each individual class, let's start with the following typical example: solving the Laplace equation \( \Delta u = 0 \) on a regular 2D grid using a finite difference scheme and Dirichlet boundary conditions. Such problem can be mathematically expressed as a linear problem of the form \( Ax=b \) where \( x \) is the vector of <code>m</code> unknowns (in our case, the values of the pixels), \( b \) is the right hand side vector resulting from the boundary conditions, and \( A \) is an \( m \times m \) matrix containing only a few non-zero elements resulting from the discretization of the Laplacian operator.</p> <table> <tr> <td>
<pre data-language="cpp"><span>#include &lt;Eigen/Sparse&gt;</span>
<span>#include &lt;vector&gt;</span>
<span>#include &lt;iostream&gt;</span>
 
<span>typedef</span> <a href="classeigen_1_1sparsematrix.html">Eigen::SparseMatrix&lt;double&gt;</a> SpMat; <span>// declares a column-major sparse matrix type of double</span>
<span>typedef</span> <a href="classeigen_1_1triplet.html">Eigen::Triplet&lt;double&gt;</a> T;
 
<span>void</span> buildProblem(std::vector&lt;T&gt;&amp; coefficients, <a href="classeigen_1_1matrix.html">Eigen::VectorXd</a>&amp; b, <span>int</span> n);
<span>void</span> saveAsBitmap(<span>const</span> <a href="classeigen_1_1matrix.html">Eigen::VectorXd</a>&amp; x, <span>int</span> n, <span>const</span> <span>char</span>* filename);
 
<span>int</span> main(<span>int</span> argc, <span>char</span>** argv)
{
  <span>if</span>(argc!=2) {
    std::cerr &lt;&lt; <span>"Error: expected one and only one argument.\n"</span>;
    <span>return</span> -1;
  }
  
  <span>int</span> n = 300;  <span>// size of the image</span>
  <span>int</span> m = n*n;  <span>// number of unknowns (=number of pixels)</span>
 
  <span>// Assembly:</span>
  std::vector&lt;T&gt; coefficients;            <span>// list of non-zeros coefficients</span>
  <a href="classeigen_1_1matrix.html">Eigen::VectorXd</a> b(m);                   <span>// the right hand side-vector resulting from the constraints</span>
  buildProblem(coefficients, b, n);
 
  SpMat A(m,m);
  A.setFromTriplets(coefficients.begin(), coefficients.end());
 
  <span>// Solving:</span>
  <a href="classeigen_1_1simplicialcholesky.html">Eigen::SimplicialCholesky&lt;SpMat&gt;</a> chol(A);  <span>// performs a Cholesky factorization of A</span>
  <a href="classeigen_1_1matrix.html">Eigen::VectorXd</a> x = chol.solve(b);         <span>// use the factorization to solve for the given right hand side</span>
 
  <span>// Export the result to a file:</span>
  saveAsBitmap(x, n, argv[1]);
 
  <span>return</span> 0;
}
 </pre> </td>
<td>
<div> <img src="https://eigen.tuxfamily.org/dox/Tutorial_sparse_example.jpeg" alt=""> </div> </td>
</tr> </table> <p>In this example, we start by defining a column-major sparse matrix type of double <code>SparseMatrix&lt;double&gt;</code>, and a triplet list of the same scalar type <code>Triplet&lt;double&gt;</code>. A triplet is a simple object representing a non-zero entry as the triplet: <code>row</code> index, <code>column</code> index, <code>value</code>.</p> <p>In the main function, we declare a list <code>coefficients</code> of triplets (as a std vector) and the right hand side vector \( b \) which are filled by the <em>buildProblem</em> function. The raw and flat list of non-zero entries is then converted to a true <a href="classeigen_1_1sparsematrix.html" title="A versatible sparse matrix representation.">SparseMatrix</a> object <code>A</code>. Note that the elements of the list do not have to be sorted, and possible duplicate entries will be summed up.</p> <p>The last step consists of effectively solving the assembled problem. Since the resulting matrix <code>A</code> is symmetric by construction, we can perform a direct Cholesky factorization via the <a href="classeigen_1_1simplicialldlt.html" title="A direct sparse LDLT Cholesky factorizations without square root.">SimplicialLDLT</a> class which behaves like its <a href="classeigen_1_1ldlt.html" title="Robust Cholesky decomposition of a matrix with pivoting.">LDLT</a> counterpart for dense objects.</p> <p>The resulting vector <code>x</code> contains the pixel values as a 1D array which is saved to a jpeg file shown on the right of the code above.</p> <p>Describing the <em>buildProblem</em> and <em>save</em> functions is out of the scope of this tutorial. They are given <a href="tutorialsparse_example_details.html">here</a> for the curious and reproducibility purpose.</p> <h1>
<a id="TutorialSparseSparseMatrix"></a> The SparseMatrix class</h1> <p><b>Matrix</b> <b>and</b> <b>vector</b> <b>properties</b> <br> The <a href="classeigen_1_1sparsematrix.html" title="A versatible sparse matrix representation.">SparseMatrix</a> and <a href="classeigen_1_1sparsevector.html" title="a sparse vector class">SparseVector</a> classes take three template arguments: the scalar type (e.g., double) the storage order (ColMajor or RowMajor, the default is ColMajor) the inner index type (default is <code>int</code>).</p> <p>As for dense <a href="classeigen_1_1matrix.html" title="The matrix class, also used for vectors and row-vectors.">Matrix</a> objects, constructors takes the size of the object. Here are some examples:</p> <pre data-language="cpp">SparseMatrix&lt;std::complex&lt;float&gt; &gt; mat(1000,2000);         <span>// declares a 1000x2000 column-major compressed sparse matrix of complex&lt;float&gt;</span>
SparseMatrix&lt;double,RowMajor&gt; mat(1000,2000);              <span>// declares a 1000x2000 row-major compressed sparse matrix of double</span>
SparseVector&lt;std::complex&lt;float&gt; &gt; vec(1000);              <span>// declares a column sparse vector of complex&lt;float&gt; of size 1000</span>
SparseVector&lt;double,RowMajor&gt; vec(1000);                   <span>// declares a row sparse vector of double of size 1000</span>
</pre>
<p>In the rest of the tutorial, <code>mat</code> and <code>vec</code> represent any sparse-matrix and sparse-vector objects, respectively.</p> <p>The dimensions of a matrix can be queried using the following functions: </p>
<table> <tr> <td>Standard <br> dimensions</td>
<td>
<pre data-language="cpp">mat.rows()
mat.cols()
</pre> </td>
<td>
<pre data-language="cpp">vec.size() 
</pre> </td>
</tr> <tr> <td>Sizes along the <br> inner/outer dimensions</td>
<td>
<pre data-language="cpp">mat.innerSize()
mat.outerSize()
</pre> </td>
<td></td>
</tr> <tr> <td>Number of non <br> zero coefficients</td>
<td>
<pre data-language="cpp">mat.nonZeros() 
</pre> </td>
<td>
<pre data-language="cpp">vec.nonZeros() 
</pre> </td>
</tr> </table> <p><b>Iterating</b> <b>over</b> <b>the</b> <b>nonzero</b> <b>coefficients</b> <br> Random access to the elements of a sparse object can be done through the <code>coeffRef(i,j)</code> function. However, this function involves a quite expensive binary search. In most cases, one only wants to iterate over the non-zeros elements. This is achieved by a standard loop over the outer dimension, and then by iterating over the non-zeros of the current inner vector via an InnerIterator. Thus, the non-zero entries have to be visited in the same order than the storage order. Here is an example: </p>
<table> <tr> <td>
<pre data-language="cpp">SparseMatrix&lt;double&gt; mat(rows,cols);
<span>for</span> (<span>int</span> k=0; k&lt;mat.outerSize(); ++k)
  <span>for</span> (SparseMatrix&lt;double&gt;::InnerIterator it(mat,k); it; ++it)
  {
    it.value();
    it.row();   <span>// row index</span>
    it.col();   <span>// col index (here it is equal to k)</span>
    it.index(); <span>// inner index, here it is equal to it.row()</span>
  }
</pre> </td>
<td>
<pre data-language="cpp">SparseVector&lt;double&gt; vec(size);
<span>for</span> (SparseVector&lt;double&gt;::InnerIterator it(vec); it; ++it)
{
  it.value(); <span>// == vec[ it.index() ]</span>
  it.index();
}
</pre> </td>
</tr> </table> <p>For a writable expression, the referenced value can be modified using the valueRef() function. If the type of the sparse matrix or vector depends on a template parameter, then the <code>typename</code> keyword is required to indicate that <code>InnerIterator</code> denotes a type; see <a href="topictemplatekeyword.html">The template and typename keywords in C++</a> for details.</p> <h1>
<a id="TutorialSparseFilling"></a> Filling a sparse matrix</h1> <p>Because of the special storage scheme of a <a href="classeigen_1_1sparsematrix.html" title="A versatible sparse matrix representation.">SparseMatrix</a>, special care has to be taken when adding new nonzero entries. For instance, the cost of a single purely random insertion into a <a href="classeigen_1_1sparsematrix.html" title="A versatible sparse matrix representation.">SparseMatrix</a> is <code>O(nnz)</code>, where <code>nnz</code> is the current number of non-zero coefficients.</p> <p>The simplest way to create a sparse matrix while guaranteeing good performance is thus to first build a list of so-called <em>triplets</em>, and then convert it to a <a href="classeigen_1_1sparsematrix.html" title="A versatible sparse matrix representation.">SparseMatrix</a>.</p> <p>Here is a typical usage example: </p>
<pre data-language="cpp"><span>typedef</span> <a href="classeigen_1_1triplet.html">Eigen::Triplet&lt;double&gt;</a> T;
std::vector&lt;T&gt; tripletList;
tripletList.reserve(estimation_of_entries);
<span>for</span>(...)
{
  <span>// ...</span>
  tripletList.push_back(T(i,j,v_ij));
}
SparseMatrixType mat(rows,cols);
mat.setFromTriplets(tripletList.begin(), tripletList.end());
<span>// mat is ready to go!</span>
</pre>
<p> The <code>std::vector</code> of triplets might contain the elements in arbitrary order, and might even contain duplicated elements that will be summed up by setFromTriplets(). See the <a href="classeigen_1_1sparsematrix.html#acc35051d698e3973f1de5b9b78dbe345">SparseMatrix::setFromTriplets()</a> function and class <a href="classeigen_1_1triplet.html" title="A small structure to hold a non zero as a triplet (i,j,value).">Triplet</a> for more details.</p> <p>In some cases, however, slightly higher performance, and lower memory consumption can be reached by directly inserting the non-zeros into the destination matrix. A typical scenario of this approach is illustrated below: </p>
<pre data-language="cpp">1: SparseMatrix&lt;double&gt; mat(rows,cols);         <span>// default is column major</span>
2: mat.reserve(<a href="classeigen_1_1densebase.html#a68a7ece6c5629d1e9447a321fcb14ccd">VectorXi::Constant</a>(cols,6));
3: <span>for each</span> i,j such that v_ij != 0
4:   mat.insert(i,j) = v_ij;                    <span>// alternative: mat.coeffRef(i,j) += v_ij;</span>
5: mat.makeCompressed();                        <span>// optional</span></pre>
<ul> <li>The key ingredient here is the line 2 where we reserve room for 6 non-zeros per column. In many cases, the number of non-zeros per column or row can easily be known in advance. If it varies significantly for each inner vector, then it is possible to specify a reserve size for each inner vector by providing a vector object with an operator[](int j) returning the reserve size of the <code>j-th</code> inner vector (e.g., via a VectorXi or std::vector&lt;int&gt;). If only a rought estimate of the number of nonzeros per inner-vector can be obtained, it is highly recommended to overestimate it rather than the opposite. If this line is omitted, then the first insertion of a new element will reserve room for 2 elements per inner vector.</li> <li>The line 4 performs a sorted insertion. In this example, the ideal case is when the <code>j-th</code> column is not full and contains non-zeros whose inner-indices are smaller than <code>i</code>. In this case, this operation boils down to trivial O(1) operation.</li> <li>When calling insert(i,j) the element <code>i</code> <code></code>,j must not already exists, otherwise use the coeffRef(i,j) method that will allow to, e.g., accumulate values. This method first performs a binary search and finally calls insert(i,j) if the element does not already exist. It is more flexible than insert() but also more costly.</li> <li>The line 5 suppresses the remaining empty space and transforms the matrix into a compressed column storage.</li> </ul> <h1>
<a id="TutorialSparseFeatureSet"></a> Supported operators and functions</h1> <p>Because of their special storage format, sparse matrices cannot offer the same level of flexibility than dense matrices. In <a href="namespaceeigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a>'s sparse module we chose to expose only the subset of the dense matrix API which can be efficiently implemented. In the following <em>sm</em> denotes a sparse matrix, <em>sv</em> a sparse vector, <em>dm</em> a dense matrix, and <em>dv</em> a dense vector.</p> <h2>
<a id="TutorialSparse_BasicOps"></a> Basic operations</h2> <p>Sparse expressions support most of the unary and binary coefficient wise operations: </p>
<pre data-language="cpp">sm1.real()   sm1.imag()   -sm1                    0.5*sm1
sm1+sm2      sm1-sm2      sm1.cwiseProduct(sm2)
</pre>
<p> However, <b>a strong restriction is that the storage orders must match</b>. For instance, in the following example: </p>
<pre data-language="cpp">sm4 = sm1 + sm2 + sm3;
</pre>
<p> sm1, sm2, and sm3 must all be row-major or all column-major. On the other hand, there is no restriction on the target matrix sm4. For instance, this means that for computing \( A^T + A \), the matrix \( A^T \) must be evaluated into a temporary matrix of compatible storage order: </p>
<pre data-language="cpp">SparseMatrix&lt;double&gt; A, B;
B = SparseMatrix&lt;double&gt;(A.transpose()) + A;
</pre>
<p>Binary coefficient wise operators can also mix sparse and dense expressions: </p>
<pre data-language="cpp">sm2 = sm1.cwiseProduct(dm1);
dm2 = sm1 + dm1;
dm2 = dm1 - sm1;
</pre>
<p> Performance-wise, the adding/subtracting sparse and dense matrices is better performed in two steps. For instance, instead of doing <code>dm2 = sm1 + dm1</code>, better write: </p>
<pre data-language="cpp">dm2 = dm1;
dm2 += sm1;
</pre>
<p> This version has the advantage to fully exploit the higher performance of dense storage (no indirection, SIMD, etc.), and to pay the cost of slow sparse evaluation on the few non-zeros of the sparse matrix only.</p> <p>Sparse expressions also support transposition: </p>
<pre data-language="cpp">sm1 = sm2.transpose();
sm1 = sm2.adjoint();
</pre>
<p> However, there is no transposeInPlace() method.</p> <h2>
<a id="TutorialSparse_Products"></a> Matrix products</h2> <p>Eigen supports various kind of sparse matrix products which are summarize below:</p>
<ul> <li>
<b>sparse-dense</b>: <pre data-language="cpp">dv2 = sm1 * dv1;
dm2 = dm1 * sm1.adjoint();
dm2 = 2. * sm1 * dm1;
</pre>
</li> <li>
<b>symmetric</b> <b>sparse-dense</b>. The product of a sparse symmetric matrix with a dense matrix (or vector) can also be optimized by specifying the symmetry with selfadjointView(): <pre data-language="cpp">dm2 = sm1.selfadjointView&lt;&gt;() * dm1;        <span>// if all coefficients of A are stored</span>
dm2 = A.selfadjointView&lt;<a href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cdafca2ccebb604f171656deb53e8c083c1">Upper</a>&gt;() * dm1;     <span>// if only the upper part of A is stored</span>
dm2 = A.selfadjointView&lt;<a href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cdaf581029282d421eee5aae14238c6f749">Lower</a>&gt;() * dm1;     <span>// if only the lower part of A is stored</span></pre>
</li> <li>
<b>sparse-sparse</b>. For sparse-sparse products, two different algorithms are available. The default one is conservative and preserve the explicit zeros that might appear: <pre data-language="cpp">sm3 = sm1 * sm2;
sm3 = 4 * sm1.adjoint() * sm2;
</pre> The second algorithm prunes on the fly the explicit zeros, or the values smaller than a given threshold. It is enabled and controlled through the prune() functions: <pre data-language="cpp">sm3 = (sm1 * sm2).pruned();                  <span>// removes numerical zeros</span>
sm3 = (sm1 * sm2).pruned(ref);               <span>// removes elements much smaller than ref</span>
sm3 = (sm1 * sm2).pruned(ref,epsilon);       <span>// removes elements smaller than ref*epsilon</span>
</pre>
</li> <li>
<b>permutations</b>. Finally, permutations can be applied to sparse matrices too: <pre data-language="cpp">PermutationMatrix&lt;Dynamic,Dynamic&gt; P = ...;
sm2 = P * sm1;
sm2 = sm1 * P.inverse();
sm2 = sm1.transpose() * P;
</pre>
</li> </ul> <h2>
<a id="TutorialSparse_SubMatrices"></a> Block operations</h2> <p>Regarding read-access, sparse matrices expose the same API than for dense matrices to access to sub-matrices such as blocks, columns, and rows. See <a href="group__tutorialblockoperations.html">Block operations</a> for a detailed introduction. However, for performance reasons, writing to a sub-sparse-matrix is much more limited, and currently only contiguous sets of columns (resp. rows) of a column-major (resp. row-major) <a href="classeigen_1_1sparsematrix.html" title="A versatible sparse matrix representation.">SparseMatrix</a> are writable. Moreover, this information has to be known at compile-time, leaving out methods such as <code>block(...)</code> and <code>corner*(...)</code>. The available API for write-access to a <a href="classeigen_1_1sparsematrix.html" title="A versatible sparse matrix representation.">SparseMatrix</a> are summarized below: </p>
<pre data-language="cpp">SparseMatrix&lt;double,ColMajor&gt; sm1;
sm1.col(j) = ...;
sm1.leftCols(ncols) = ...;
sm1.middleCols(j,ncols) = ...;
sm1.rightCols(ncols) = ...;
 
SparseMatrix&lt;double,RowMajor&gt; sm2;
sm2.row(i) = ...;
sm2.topRows(nrows) = ...;
sm2.middleRows(i,nrows) = ...;
sm2.bottomRows(nrows) = ...;
</pre>
<p>In addition, sparse matrices expose the SparseMatrixBase::innerVector() and SparseMatrixBase::innerVectors() methods, which are aliases to the col/middleCols methods for a column-major storage, and to the row/middleRows methods for a row-major storage.</p> <h2>
<a id="TutorialSparse_TriangularSelfadjoint"></a> Triangular and selfadjoint views</h2> <p>Just as with dense matrices, the triangularView() function can be used to address a triangular part of the matrix, and perform triangular solves with a dense right hand side: </p>
<pre data-language="cpp">dm2 = sm1.triangularView&lt;<a href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cdaf581029282d421eee5aae14238c6f749">Lower</a>&gt;(dm1);
dv2 = sm1.transpose().triangularView&lt;<a href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cdafca2ccebb604f171656deb53e8c083c1">Upper</a>&gt;(dv1);
</pre>
<p>The selfadjointView() function permits various operations:</p>
<ul> <li>optimized sparse-dense matrix products: <pre data-language="cpp">dm2 = sm1.selfadjointView&lt;&gt;() * dm1;        <span>// if all coefficients of A are stored</span>
dm2 = A.selfadjointView&lt;<a href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cdafca2ccebb604f171656deb53e8c083c1">Upper</a>&gt;() * dm1;     <span>// if only the upper part of A is stored</span>
dm2 = A.selfadjointView&lt;<a href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cdaf581029282d421eee5aae14238c6f749">Lower</a>&gt;() * dm1;     <span>// if only the lower part of A is stored</span>
</pre>
</li> <li>copy of triangular parts: <pre data-language="cpp">sm2 = sm1.selfadjointView&lt;<a href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cdafca2ccebb604f171656deb53e8c083c1">Upper</a>&gt;();                               <span>// makes a full selfadjoint matrix from the upper triangular part</span>
sm2.selfadjointView&lt;<a href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cdaf581029282d421eee5aae14238c6f749">Lower</a>&gt;() = sm1.selfadjointView&lt;<a href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cdafca2ccebb604f171656deb53e8c083c1">Upper</a>&gt;();      <span>// copies the upper triangular part to the lower triangular part</span>
</pre>
</li> <li>application of symmetric permutations: <pre data-language="cpp">PermutationMatrix&lt;Dynamic,Dynamic&gt; P = ...;
sm2 = A.selfadjointView&lt;<a href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cdafca2ccebb604f171656deb53e8c083c1">Upper</a>&gt;().twistedBy(P);                                <span>// compute P S P' from the upper triangular part of A, and make it a full matrix</span>
sm2.selfadjointView&lt;<a href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cdaf581029282d421eee5aae14238c6f749">Lower</a>&gt;() = A.selfadjointView&lt;<a href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cdaf581029282d421eee5aae14238c6f749">Lower</a>&gt;().twistedBy(P);       <span>// compute P S P' from the lower triangular part of A, and then only compute the lower part</span>
</pre>
</li> </ul> <p>Please, refer to the <a href="group__sparsequickrefpage.html">Quick Reference </a> guide for the list of supported operations. The list of linear solvers available is <a href="group__topicsparsesystems.html">here. </a> </p> </div> <div class="_attribution">
  <p class="_attribution-p">
    &copy; Eigen.<br>Licensed under the MPL2 License.<br>
    <a href="https://eigen.tuxfamily.org/dox/group__TutorialSparse.html" class="_attribution-link">https://eigen.tuxfamily.org/dox/group__TutorialSparse.html</a>
  </p>
</div>
