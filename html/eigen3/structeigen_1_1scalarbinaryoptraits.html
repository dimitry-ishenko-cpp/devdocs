<h1>Eigen::ScalarBinaryOpTraits</h1>      <div>  <div>
<h3>template&lt;typename ScalarA, typename ScalarB, typename BinaryOp = internal::scalar_product_op&lt;ScalarA,ScalarB&gt;&gt;<br> class Eigen::ScalarBinaryOpTraits&lt; ScalarA, ScalarB, BinaryOp &gt;</h3> <p>Determines whether the given binary operation of two numeric types is allowed and what the scalar return type is. </p> <p>This class permits to control the scalar return type of any binary operation performed on two different scalar types through (partial) template specializations.</p> <p>For instance, let <code>U1</code>, <code>U2</code> and <code>U3</code> be three user defined scalar types for which most operations between instances of <code>U1</code> and <code>U2</code> returns an <code>U3</code>. You can let Eigen knows that by defining: </p>
<pre data-language="cpp"><span>template</span>&lt;<span>typename</span> BinaryOp&gt;
<span>struct </span>ScalarBinaryOpTraits&lt;U1,U2,BinaryOp&gt; { <span>typedef</span> U3 ReturnType;  };
<span>template</span>&lt;<span>typename</span> BinaryOp&gt;
<span>struct </span>ScalarBinaryOpTraits&lt;U2,U1,BinaryOp&gt; { <span>typedef</span> U3 ReturnType;  };
</pre>
<p> You can then explicitly disable some particular operations to get more explicit error messages: </p>
<pre data-language="cpp"><span>template</span>&lt;&gt;
<span>struct </span>ScalarBinaryOpTraits&lt;U1,U2,internal::scalar_max_op&lt;U1,U2&gt; &gt; {};
</pre>
<p> Or customize the return type for individual operation: </p>
<pre data-language="cpp"><span>template</span>&lt;&gt;
<span>struct </span>ScalarBinaryOpTraits&lt;U1,U2,internal::scalar_sum_op&lt;U1,U2&gt; &gt; { <span>typedef</span> U1 ReturnType; };
</pre>
<p>By default, the following generic combinations are supported: </p>
<table> <tr> <th>ScalarA</th>
<th>ScalarB</th>
<th>BinaryOp</th>
<th>ReturnType</th>
<th>Note </th>
</tr> <tr> <td>
<code>T</code> </td>
<td>
<code>T</code> </td>
<td>
<code>*</code> </td>
<td>
<code>T</code> </td>
<td></td>
</tr> <tr> <td>
<code>NumTraits&lt;T&gt;::Real</code> </td>
<td>
<code>T</code> </td>
<td>
<code>*</code> </td>
<td>
<code>T</code> </td>
<td>Only if <code>NumTraits&lt;T&gt;::IsComplex</code> </td>
</tr> <tr> <td>
<code>T</code> </td>
<td>
<code>NumTraits&lt;T&gt;::Real</code> </td>
<td>
<code>*</code> </td>
<td>
<code>T</code> </td>
<td>Only if <code>NumTraits&lt;T&gt;::IsComplex</code> </td>
</tr> </table> <dl>
<dt>See also</dt>
<dd>
<a href="classeigen_1_1cwisebinaryop.html" title="Generic expression where a coefficient-wise binary operator is applied to two expressions.">CwiseBinaryOp</a> </dd>
</dl> </div>
<hr>The documentation for this class was generated from the following file:<ul> <li><a href="https://eigen.tuxfamily.org/dox/XprHelper_8h_source.html">XprHelper.h</a></li> </ul> </div> <div class="_attribution">
  <p class="_attribution-p">
    &copy; Eigen.<br>Licensed under the MPL2 License.<br>
    <a href="https://eigen.tuxfamily.org/dox/structEigen_1_1ScalarBinaryOpTraits.html" class="_attribution-link">https://eigen.tuxfamily.org/dox/structEigen_1_1ScalarBinaryOpTraits.html</a>
  </p>
</div>
