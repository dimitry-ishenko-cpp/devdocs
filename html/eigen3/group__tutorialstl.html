<h1>STL iterators and algorithms</h1>      <div> <p>Since the version 3.4, Eigen's dense matrices and arrays provide STL compatible iterators. As demonstrated below, this makes them naturally compatible with range-for-loops and STL's algorithms.</p> <h1>
<a id="TutorialSTLVectors"></a> Iterating over 1D arrays and vectors</h1> <p>Any dense 1D expressions exposes the pair of <code>begin()/end()</code> methods to iterate over them.</p> <p>This directly enables c++11 range for loops: </p>
<table> <tr> <th>Example:</th>
<th>Output: </th>
</tr> <tr> <td>
<pre data-language="cpp">VectorXi v = <a href="classeigen_1_1densebase.html#ae814abb451b48ed872819192dc188c19">VectorXi::Random</a>(4);
cout &lt;&lt; <span>"Here is the vector v:\n"</span>;
<span>for</span>(<span>auto</span> x : v) cout &lt;&lt; x &lt;&lt; <span>" "</span>;
cout &lt;&lt; <span>"\n"</span>;</pre> </td>
<td>
<pre>Here is the vector v:
7 -2 6 6 
</pre> </td>
</tr> </table> <p>One dimensional expressions can also easily be passed to STL algorithms: </p>
<table> <tr> <th>Example:</th>
<th>Output: </th>
</tr> <tr> <td>
<pre data-language="cpp">Array4i v = <a href="classeigen_1_1densebase.html#ae814abb451b48ed872819192dc188c19">Array4i::Random</a>().abs();
cout &lt;&lt; <span>"Here is the initial vector v:\n"</span> &lt;&lt; v.transpose() &lt;&lt; <span>"\n"</span>;
std::sort(v.begin(), v.end());
cout &lt;&lt; <span>"Here is the sorted vector v:\n"</span> &lt;&lt; v.transpose() &lt;&lt; <span>"\n"</span>;
</pre> </td>
<td>
<pre>Here is the initial vector v:
7 2 6 6
Here is the sorted vector v:
2 6 6 7
</pre> </td>
</tr> </table> <p>Similar to <code>std::vector</code>, 1D expressions also exposes the pair of <code>cbegin()/cend()</code> methods to conveniently get const iterators on non-const object.</p> <h1>
<a id="TutorialSTLMatrices"></a> Iterating over coefficients of 2D arrays and matrices</h1> <p>STL iterators are intrinsically designed to iterate over 1D structures. This is why <code>begin()/end()</code> methods are disabled for 2D expressions. Iterating over all coefficients of a 2D expressions is still easily accomplished by creating a 1D linear view through <code>reshaped()</code>: </p>
<table> <tr> <th>Example:</th>
<th>Output: </th>
</tr> <tr> <td>
<pre data-language="cpp">Matrix2i A = <a href="classeigen_1_1densebase.html#ae814abb451b48ed872819192dc188c19">Matrix2i::Random</a>();
cout &lt;&lt; <span>"Here are the coeffs of the 2x2 matrix A:\n"</span>;
<span>for</span>(<span>auto</span> x : A.reshaped())
  cout &lt;&lt; x &lt;&lt; <span>" "</span>;
cout &lt;&lt; <span>"\n"</span>;
</pre> </td>
<td>
<pre>Here are the coeffs of the 2x2 matrix A:
7 -2 6 6 
</pre> </td>
</tr> </table> <h1>
<a id="TutorialSTLRowsColumns"></a> Iterating over rows or columns of 2D arrays and matrices</h1> <p>It is also possible to get iterators over rows or columns of 2D expressions. Those are available through the <code>rowwise()</code> and <code>colwise()</code> proxies. Here is an example sorting each row of a matrix: </p>
<table> <tr> <th>Example:</th>
<th>Output: </th>
</tr> <tr> <td>
<pre data-language="cpp">ArrayXXi A = <a href="classeigen_1_1densebase.html#ae814abb451b48ed872819192dc188c19">ArrayXXi::Random</a>(4,4).abs();
cout &lt;&lt; <span>"Here is the initial matrix A:\n"</span> &lt;&lt; A &lt;&lt; <span>"\n"</span>;
<span>for</span>(<span>auto</span> row : A.rowwise())
  std::sort(row.begin(), row.end());
cout &lt;&lt; <span>"Here is the sorted matrix A:\n"</span> &lt;&lt; A &lt;&lt; <span>"\n"</span>;
</pre> </td>
<td>
<pre>Here is the initial matrix A:
7 9 5 3
2 6 1 0
6 3 0 9
6 6 3 9
Here is the sorted matrix A:
3 5 7 9
0 1 2 6
0 3 6 9
3 6 6 9
</pre> </td>
</tr> </table> </div> <div class="_attribution">
  <p class="_attribution-p">
    &copy; Eigen.<br>Licensed under the MPL2 License.<br>
    <a href="https://eigen.tuxfamily.org/dox/group__TutorialSTL.html" class="_attribution-link">https://eigen.tuxfamily.org/dox/group__TutorialSTL.html</a>
  </p>
</div>
