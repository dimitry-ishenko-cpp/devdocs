<h1>HTTP API Reference</h1>     <ul> <li><a href="#general-information">General Information</a></li> <li><a href="#writing-data">Writing Data</a></li> <li><a href="#tasks">Tasks</a></li> <li><a href="#templates">Templates</a></li> <li><a href="#recordings">Recordings</a></li> <li><a href="#replays">Replays</a></li> <li><a href="#alerts">Alerts</a></li> <li><a href="#configuration">Configuration</a></li> <li><a href="#storage">Storage</a></li> <li><a href="#testing-services">Testing Services</a></li> <li><a href="#miscellaneous">Miscellaneous</a></li> </ul> <h2 id="general-information">General Information</h2> <p>Kapacitor provides an HTTP API on port 9092 by default. With the API you can control which tasks are executing, query status of tasks and manage recordings etc.</p> <p>Each section below defines the available API endpoints and there inputs and outputs.</p> <p>All requests are versioned and namespaced using the base path <code>/kapacitor/v1/</code>.</p> <h3 id="response-codes">Response Codes</h3> <p>All requests can return these response codes:</p> <table> <thead> <tr> <th>HTTP Response Code</th> <th>Meaning</th> </tr> </thead> <tbody> <tr> <td>2xx</td> <td>The request was a success, content is dependent on the request.</td> </tr> <tr> <td>4xx</td> <td>Invalid request, refer to error for what it wrong with the request. Repeating the request will continue to return the same error.</td> </tr> <tr> <td>5xx</td> <td>The server was unable to process the request, refer to the error for a reason. Repeating the request may result in a success if the server issue has been resolved.</td> </tr> </tbody> </table> <h3 id="errors">Errors</h3> <p>All requests can return JSON in the following format to provide more information about a failed request.</p> <pre>{
    "error" : "error message"
}
</pre> <h3 id="query-parameters-vs-json-body">Query Parameters vs JSON body</h3> <p>To make using this API a consistent and easy experience we follow one simple rule for when extra information about a request is found in the query parameters of the URL or when they are part of the submitted JSON body.</p> <p>Query parameters are used only for GET requests and all other requests expect parameters to be specified in the JSON body.</p> <blockquote> <p>NOTE: The /kapacitor/v1/write endpoint is the one exception to this rule since Kapacitor is compatible with the InfluxDB /write endpoint.</p> </blockquote> <h3 id="links">Links</h3> <p>When creating resources in Kapacitor the API server will return a <code>link</code> object with an <code>href</code> of the resource. Clients should not need to perform path manipulation in most cases and can use the links provided from previous calls.</p> <h3 id="ids">IDs</h3> <p>The API allows the client to specify IDs for the various resources. This way you can control the meaning of the IDs. If you do not specify an ID a random UUID will be generated for the resource.</p> <p>All IDs must match this regex <code>^[-\._\p{L}0-9]+$</code>, which is essentially numbers, unicode letters, ‘-’, ‘.’ and ‘_‘.</p> <h3 id="backwards-compatibility">Backwards Compatibility</h3> <p>Currently Kapacitor is in 1.x release with a guarantee that all new releases will be backwards compatible with previous releases. This applies directly to the API. New additions may be made to the API but existing endpoints will not be changed in backwards incompatible ways during the 1.x releases.</p> <h3 id="technical-preview">Technical Preview</h3> <p>On occasion when a new feature is added to Kapacitor it may be added in a technical preview for a few minor releases and then later promoted to fully fledged v1 feature. Preview means that the newly added features may be changed in backwards incompatible ways until they are promoted to v1 features. Using technical preview allows for new features to fully mature while maintaining regularly scheduled releases.</p> <p>To make it clear which features of the API are in technical preview the base path <code>/kapacitor/v1preview</code> is used. If you wish to preview some of these new features, simply use the path <code>/kapacitor/v1preview</code> instead of <code>/kapacitor/v1</code> for your requests. All v1 endpoints are available under the v1preview path so that your client need not be configured with multiple paths. The technical preview endpoints are only available under the v1preview path.</p> <blockquote> <p>NOTE: Using a technical preview means that you may have to update your client for breaking changes to the previewed endpoints.</p> </blockquote> <h2 id="writing-data">Writing Data</h2> <p>Kapacitor can accept writes over HTTP using the line protocol. This endpoint is identical in nature to the InfluxDB write endpoint.</p> <table> <thead> <tr> <th>Query Parameter</th> <th>Purpose</th> </tr> </thead> <tbody> <tr> <td>db</td> <td>Database name for the writes.</td> </tr> <tr> <td>rp</td> <td>Retention policy name for the writes.</td> </tr> </tbody> </table> <blockquote> <p>NOTE: Kapacitor scopes all points by their database and retention policy. This means you MUST specify the <code>rp</code> for writes or Kapacitor will not know which retention policy to use.</p> </blockquote> <h4 id="example">Example</h4> <p>Write data to Kapacitor.</p> <pre>POST /kapacitor/v1/write?db=DB_NAME&amp;rp=RP_NAME
cpu,host=example.com value=87.6
</pre> <p>For compatibility with the equivalent InfluxDB write endpoint the <code>/write</code> endpoint is maintained as an alias to the <code>/kapacitor/v1/write</code> endpoint.</p> <pre>POST /write?db=DB_NAME&amp;rp=RP_NAME
cpu,host=example.com value=87.6
</pre> <h2 id="tasks">Tasks</h2> <p>A task represents work for Kapacitor to perform. A task is defined by its id, type, TICKscript, and list of database retention policy pairs it is allowed to access.</p> <h3 id="define-task">Define Task</h3> <p>To define a task POST to the <code>/kapacitor/v1/tasks</code> endpoint. If a task already exists then use the <code>PATCH</code> method to modify any property of the task.</p> <p>Define a task using a JSON object with the following options:</p> <table> <thead> <tr> <th>Property</th> <th>Purpose</th> </tr> </thead> <tbody> <tr> <td>id</td> <td>Unique identifier for the task. If empty a random ID will be chosen.</td> </tr> <tr> <td>template-id</td> <td>An optional ID of a template to use instead of specifying a TICKscript and type directly.</td> </tr> <tr> <td>type</td> <td>The task type: <code>stream</code> or <code>batch</code>.</td> </tr> <tr> <td>dbrps</td> <td>List of database retention policy pairs the task is allowed to access.</td> </tr> <tr> <td>script</td> <td>The content of the script.</td> </tr> <tr> <td>status</td> <td>One of <code>enabled</code> or <code>disabled</code>.</td> </tr> <tr> <td>vars</td> <td>A set of vars for overwriting any defined vars in the TICKscript.</td> </tr> </tbody> </table> <p>When using PATCH, if any option is missing it will be left unmodified.</p> <h5 id="vars">Vars</h5> <p>The vars object has the form:</p> <pre data-language="json">{
    "field_name" : {
        "value": &lt;VALUE&gt;,
        "type": &lt;TYPE&gt;
    },
    "another_field" : {
        "value": &lt;VALUE&gt;,
        "type": &lt;TYPE&gt;
    }
}
</pre> <p>The following is a table of valid types and example values.</p> <table> <thead> <tr> <th>Type</th> <th>Example Value</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td>bool</td> <td>true</td> <td>“true” or “false”</td> </tr> <tr> <td>int</td> <td>42</td> <td>Any integer value</td> </tr> <tr> <td>float</td> <td>2.5 or 67</td> <td>Any numeric value</td> </tr> <tr> <td>duration</td> <td>“1s” or 1000000000</td> <td>Any integer value interpretted in nanoseconds or an influxql duration string, (i.e. 10000000000 is 10s)</td> </tr> <tr> <td>string</td> <td>“a string”</td> <td>Any string value</td> </tr> <tr> <td>regex</td> <td>”^abc.*xyz”</td> <td>Any string value that represents a valid Go regular expression <a href="https://golang.org/pkg/regexp/">https://golang.org/pkg/regexp/</a>
</td> </tr> <tr> <td>lambda</td> <td>“\“value\” &gt; 5”</td> <td>Any string that is a valid TICKscript lambda expression</td> </tr> <tr> <td>star</td> <td>””</td> <td>No value is required, a star type var represents the literal <code>*</code> in TICKscript (i.e. <code>.groupBy(*)</code>)</td> </tr> <tr> <td>list</td> <td>[{“type”: TYPE, “value”: VALUE}]</td> <td>A list of var objects. Currently lists may only contain string or star vars</td> </tr> </tbody> </table> <h4 id="example-1">Example</h4> <p>Create a new task with ID TASK_ID.</p> <pre>POST /kapacitor/v1/tasks
{
    "id" : "TASK_ID",
    "type" : "stream",
    "dbrps": [{"db": "DATABASE_NAME", "rp" : "RP_NAME"}],
    "script": "stream\n    |from()\n        .measurement('cpu')\n",
    "vars" : {
        "var1": {
            "value": 42,
            "type": "float"
        }
    }
}
</pre> <p>Response with task id and link.</p> <pre data-language="json">{
    "link" : {"rel": "self", "href": "/kapacitor/v1/tasks/TASK_ID"},
    "id" : "TASK_ID",
    "type" : "stream",
    "dbrps" : [{"db": "DATABASE_NAME", "rp" : "RP_NAME"}],
    "script" : "stream\n    |from()\n        .measurement('cpu')\n",
    "dot" : "digraph TASK_ID { ... }",
    "vars" : {
        "var1": {
            "value": 42,
            "type": "float"
        }
    },
    "status" : "enabled",
    "executing" : true,
    "error" : "",
    "created": "2006-01-02T15:04:05Z07:00",
    "modified": "2006-01-02T15:04:05Z07:00",
    "stats" : {}
}
</pre> <p>Modify only the dbrps of the task.</p> <pre>PATCH /kapacitor/v1/tasks/TASK_ID
{
    "dbrps": [{"db": "NEW_DATABASE_NAME", "rp" : "NEW_RP_NAME"}]
}
</pre> <blockquote> <p>NOTE: Setting any DBRP will overwrite all stored DBRPs. Setting any Vars will overwrite all stored Vars.</p> </blockquote> <p>Enable an existing task.</p> <pre>PATCH /kapacitor/v1/tasks/TASK_ID
{
    "status" : "enabled",
}
</pre> <p>Disable an existing task.</p> <pre>PATCH /kapacitor/v1/tasks/TASK_ID
{
    "status" : "disabled",
}
</pre> <p>Define a new task that is enabled on creation.</p> <pre>POST /kapacitor/v1/tasks
{
    "id" : "TASK_ID",
    "type" : "stream",
    "dbrps" : [{"db": "DATABASE_NAME", "rp" : "RP_NAME"}],
    "script" : "stream\n    |from()\n        .measurement('cpu')\n",
    "status" : "enabled"
}
</pre> <p>Response with task id and link.</p> <pre data-language="json">{
    "id" : "TASK_ID",
    "link" : {"rel": "self", "href": "/kapacitor/v1/tasks/TASK_ID"}
}
</pre> <h4 id="response">Response</h4> <table> <thead> <tr> <th>Code</th> <th>Meaning</th> </tr> </thead> <tbody> <tr> <td>200</td> <td>Task created, contains task information.</td> </tr> <tr> <td>404</td> <td>Task does not exist</td> </tr> </tbody> </table> <h3 id="get-task">Get Task</h3> <p>To get information about a task make a GET request to the <code>/kapacitor/v1/tasks/TASK_ID</code> endpoint.</p> <table> <thead> <tr> <th>Query Parameter</th> <th>Default</th> <th>Purpose</th> </tr> </thead> <tbody> <tr> <td>dot-view</td> <td>attributes</td> <td>One of <code>labels</code> or <code>attributes</code>. Labels is less readable but will correctly render with all the information contained in labels.</td> </tr> <tr> <td>script-format</td> <td>formatted</td> <td>One of <code>formatted</code> or <code>raw</code>. Raw will return the script identical to how it was defined. Formatted will first format the script.</td> </tr> <tr> <td>replay-id</td> <td></td> <td>Optional ID of a running replay. The returned task information will be in the context of the task for the running replay.</td> </tr> </tbody> </table> <p>A task has these read only properties in addition to the properties listed <a href="#define-task">above</a>.</p> <table> <thead> <tr> <th>Property</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td>dot</td> <td>
<a href="https://en.wikipedia.org/wiki/DOT_(graph_description_language">GraphViz DOT</a>) syntax formatted representation of the task DAG.</td> </tr> <tr> <td>executing</td> <td>Whether the task is currently executing.</td> </tr> <tr> <td>error</td> <td>Any error encountered when executing the task.</td> </tr> <tr> <td>stats</td> <td>Map of statistics about a task.</td> </tr> <tr> <td>created</td> <td>Date the task was first created</td> </tr> <tr> <td>modified</td> <td>Date the task was last modified</td> </tr> <tr> <td>last-enabled</td> <td>Date the task was last set to status <code>enabled</code>
</td> </tr> </tbody> </table> <h4 id="example-2">Example</h4> <p>Get information about a task using defaults.</p> <pre>GET /kapacitor/v1/tasks/TASK_ID
</pre> <pre data-language="json">{
    "link" : {"rel": "self", "href": "/kapacitor/v1/tasks/TASK_ID"},
    "id" : "TASK_ID",
    "type" : "stream",
    "dbrps" : [{"db": "DATABASE_NAME", "rp" : "RP_NAME"}],
    "script" : "stream\n    |from()\n        .measurement('cpu')\n",
    "dot" : "digraph TASK_ID { ... }",
    "status" : "enabled",
    "executing" : true,
    "error" : "",
    "created": "2006-01-02T15:04:05Z07:00",
    "modified": "2006-01-02T15:04:05Z07:00",
    "last-enabled": "2006-01-03T15:04:05Z07:00",
    "stats" : {}
}
</pre> <p>Get information about a task using only labels in the DOT content and skip the format step.</p> <pre>GET /kapacitor/v1/tasks/TASK_ID?dot-view=labels&amp;script-format=raw
</pre> <pre data-language="json">{
    "link" : {"rel": "self", "href": "/kapacitor/v1/tasks/TASK_ID"},
    "id" : "TASK_ID",
    "type" : "stream",
    "dbrps" : [{"db": "DATABASE_NAME", "rp" : "RP_NAME"}],
    "script" : "stream|from().measurement('cpu')",
    "dot" : "digraph TASK_ID { ... }",
    "status" : "enabled",
    "executing" : true,
    "error" : "",
    "created": "2006-01-02T15:04:05Z07:00",
    "modified": "2006-01-02T15:04:05Z07:00",
    "last-enabled": "2006-01-03T15:04:05Z07:00",
    "stats" : {}
}
</pre> <h4 id="response-1">Response</h4> <table> <thead> <tr> <th>Code</th> <th>Meaning</th> </tr> </thead> <tbody> <tr> <td>200</td> <td>Success</td> </tr> <tr> <td>404</td> <td>Task does not exist</td> </tr> </tbody> </table> <h3 id="delete-task">Delete Task</h3> <p>To delete a task make a DELETE request to the <code>/kapacitor/v1/tasks/TASK_ID</code> endpoint.</p> <pre>DELETE /kapacitor/v1/tasks/TASK_ID
</pre> <h4 id="response-2">Response</h4> <table> <thead> <tr> <th>Code</th> <th>Meaning</th> </tr> </thead> <tbody> <tr> <td>204</td> <td>Success</td> </tr> </tbody> </table> <blockquote> <p>NOTE: Deleting a non-existent task is not an error and will return a 204 success.</p> </blockquote> <h3 id="list-tasks">List Tasks</h3> <p>To get information about several tasks make a GET request to the <code>/kapacitor/v1/tasks</code> endpoint.</p> <table> <thead> <tr> <th>Query Parameter</th> <th>Default</th> <th>Purpose</th> </tr> </thead> <tbody> <tr> <td>pattern</td> <td></td> <td>Filter results based on the pattern. Uses standard shell glob matching, see <a href="https://golang.org/pkg/path/filepath/#Match">this</a> for more details.</td> </tr> <tr> <td>fields</td> <td></td> <td>List of fields to return. If empty returns all fields. Fields <code>id</code> and <code>link</code> are always returned.</td> </tr> <tr> <td>dot-view</td> <td>attributes</td> <td>One of <code>labels</code> or <code>attributes</code>. Labels is less readable but will correctly render with all the information contained in labels.</td> </tr> <tr> <td>script-format</td> <td>formatted</td> <td>One of <code>formatted</code> or <code>raw</code>. Raw will return the script identical to how it was defined. Formatted will first format the script.</td> </tr> <tr> <td>offset</td> <td>0</td> <td>Offset count for paginating through tasks.</td> </tr> <tr> <td>limit</td> <td>100</td> <td>Maximum number of tasks to return.</td> </tr> </tbody> </table> <h4 id="example-3">Example</h4> <p>Get all tasks.</p> <pre>GET /kapacitor/v1/tasks
</pre> <pre data-language="json">{
    "tasks" : [
        {
            "link" : {"rel":"self", "href":"/kapacitor/v1/tasks/TASK_ID"},
            "id" : "TASK_ID",
            "type" : "stream",
            "dbrps" : [{"db": "DATABASE_NAME", "rp" : "RP_NAME"}],
            "script" : "stream|from().measurement('cpu')",
            "dot" : "digraph TASK_ID { ... }",
            "status" : "enabled",
            "executing" : true,
            "error" : "",
            "stats" : {}
        },
        {
            "link" : {"rel":"self", "href":"/kapacitor/v1/tasks/ANOTHER_TASK_ID"},
            "id" : "ANOTHER_TASK_ID",
            "type" : "stream",
            "dbrps" : [{"db": "DATABASE_NAME", "rp" : "RP_NAME"}],
            "script" : "stream|from().measurement('cpu')",
            "dot" : "digraph ANOTHER_TASK_ID{ ... }",
            "status" : "disabled",
            "executing" : true,
            "error" : "",
            "stats" : {}
        }
    ]
}
</pre> <p>Optionally specify a glob <code>pattern</code> to list only matching tasks.</p> <pre>GET /kapacitor/v1/tasks?pattern=TASK*
</pre> <pre data-language="json">{
    "tasks" : [
        {
            "link" : {"rel":"self", "href":"/kapacitor/v1/tasks/TASK_ID"},
            "id" : "TASK_ID",
            "type" : "stream",
            "dbrps" : [{"db": "DATABASE_NAME", "rp" : "RP_NAME"}],
            "script" : "stream|from().measurement('cpu')",
            "dot" : "digraph TASK_ID { ... }",
            "status" : "enabled:,
            "executing" : true,
            "error" : "",
            "stats" : {}
        }
    ]
}
</pre> <p>Get all tasks, but only the status, executing and error fields.</p> <pre>GET /kapacitor/v1/tasks?fields=status&amp;fields=executing&amp;fields=error
</pre> <pre data-language="json">{
    "tasks" : [
        {
            "link" : {"rel":"self", "href":"/kapacitor/v1/tasks/TASK_ID"},
            "id" : "TASK_ID",
            "status" : "enabled",
            "executing" : true,
            "error" : "",
        },
        {
            "link" : {"rel":"self", "href":"/kapacitor/v1/tasks/ANOTHER_TASK_ID"},
            "id" : "ANOTHER_TASK_ID",
            "status" : "disabled",
            "executing" : true,
            "error" : "",
        }
    ]
}
</pre> <h4 id="response-3">Response</h4> <table> <thead> <tr> <th>Code</th> <th>Meaning</th> </tr> </thead> <tbody> <tr> <td>200</td> <td>Success</td> </tr> </tbody> </table> <blockquote> <p>NOTE: If the pattern does not match any tasks an empty list will be returned, with a 200 success.</p> </blockquote> <h3 id="custom-task-http-endpoints">Custom Task HTTP Endpoints</h3> <p>In TICKscript it is possible to expose a cache of recent data via the <a href="https://docs.influxdata.com/kapacitor/latest/nodes/http_out_node/">HTTPOut</a> node. The data is available at the path <code>/kapacitor/v1/tasks/TASK_ID/ENDPOINT_NAME</code>.</p> <h3 id="example-4">Example</h3> <p>For the TICKscript:</p> <pre data-language="go">stream
    |from()
        .measurement('cpu')
    |window()
        .period(60s)
        .every(60s)
    |httpOut('mycustom_endpoint')
</pre> <pre>GET /kapacitor/v1/tasks/TASK_ID/mycustom_endpoint
</pre> <pre data-language="json">{
    "series": [
        {
            "name": "cpu",
            "columns": [
                "time",
                "value"
            ],
            "values": [
                [
                    "2015-01-29T21:55:43.702900257Z",
                    55
                ],
                [
                    "2015-01-29T21:56:43.702900257Z",
                    42
                ],
            ]
        }
    ]
}
</pre> <p>The output is the same as a query for data to <a href="https://docs.influxdata.com/influxdb/latest/guides/querying_data/">InfluxDB</a>.</p> <h2 id="templates">Templates</h2> <p>You can also define a task templates. A task template is defined by a template TICKscript, and a task type.</p> <h3 id="define-templates">Define Templates</h3> <p>To define a template POST to the <code>/kapacitor/v1/templates</code> endpoint. If a template already exists then use the <code>PATCH</code> method to modify any property of the template.</p> <p>Define a template using a JSON object with the following options:</p> <table> <thead> <tr> <th>Property</th> <th>Purpose</th> </tr> </thead> <tbody> <tr> <td>id</td> <td>Unique identifier for the template. If empty a random ID will be chosen.</td> </tr> <tr> <td>type</td> <td>The template type: <code>stream</code> or <code>batch</code>.</td> </tr> <tr> <td>script</td> <td>The content of the script.</td> </tr> </tbody> </table> <p>When using PATCH, if any option is missing it will be left unmodified.</p> <h4 id="updating-templates">Updating Templates</h4> <p>When updating an existing template all associated tasks are reloaded with the new template definition. The first error if any is returned when reloading associated tasks. If an error occurs, any task that was updated to the new definition is reverted to the old definition. This ensures that all associated tasks for a template either succeed or fail together.</p> <p>As a result, you will not be able to update a template if it introduces a breaking change in the TICKscript. In order to update a template in a breaking way you have two options:</p> <ol> <li>Create a new template and reassign each task to the new template updating the task vars as needed.</li> <li>If the breaking change is forward compatible (i.e. adds a new required var), first update each task with the needed vars, then update the template once all tasks are ready.</li> </ol> <h4 id="example-5">Example</h4> <p>Create a new template with ID TEMPLATE_ID.</p> <pre>POST /kapacitor/v1/templates
{
    "id" : "TEMPLATE_ID",
    "type" : "stream",
    "script": "stream\n    |from()\n        .measurement('cpu')\n"
}
</pre> <p>Response with template id and link.</p> <pre data-language="json">{
    "link" : {"rel": "self", "href": "/kapacitor/v1/templates/TASK_ID"},
    "id" : "TASK_ID",
    "type" : "stream",
    "script" : "stream\n    |from()\n        .measurement('cpu')\n",
    "dot" : "digraph TASK_ID { ... }",
    "error" : "",
    "created": "2006-01-02T15:04:05Z07:00",
    "modified": "2006-01-02T15:04:05Z07:00",
}
</pre> <p>Modify only the script of the template.</p> <pre>PATCH /kapacitor/v1/templates/TEMPLATE_ID
{
    "script": "stream|from().measurement('mem')"
}
</pre> <h4 id="response-4">Response</h4> <table> <thead> <tr> <th>Code</th> <th>Meaning</th> </tr> </thead> <tbody> <tr> <td>200</td> <td>Template created, contains template information.</td> </tr> <tr> <td>404</td> <td>Template does not exist</td> </tr> </tbody> </table> <h3 id="get-template">Get Template</h3> <p>To get information about a template make a GET request to the <code>/kapacitor/v1/templates/TEMPLATE_ID</code> endpoint.</p> <table> <thead> <tr> <th>Query Parameter</th> <th>Default</th> <th>Purpose</th> </tr> </thead> <tbody> <tr> <td>script-format</td> <td>formatted</td> <td>One of <code>formatted</code> or <code>raw</code>. Raw will return the script identical to how it was defined. Formatted will first format the script.</td> </tr> </tbody> </table> <p>A template has these read only properties in addition to the properties listed <a href="#define-template">above</a>.</p> <table> <thead> <tr> <th>Property</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td>vars</td> <td>Set of named vars from the TICKscript with their type, default values and description.</td> </tr> <tr> <td>dot</td> <td>
<a href="https://en.wikipedia.org/wiki/DOT_(graph_description_language">GraphViz DOT</a>) syntax formatted representation of the template DAG. NOTE: lables vs attributes does not matter since a template is never executing.</td> </tr> <tr> <td>error</td> <td>Any error encountered when reading the template.</td> </tr> <tr> <td>created</td> <td>Date the template was first created</td> </tr> <tr> <td>modified</td> <td>Date the template was last modified</td> </tr> </tbody> </table> <h4 id="example-6">Example</h4> <p>Get information about a template using defaults.</p> <pre>GET /kapacitor/v1/templates/TEMPLATE_ID
</pre> <pre data-language="json">{
    "link" : {"rel": "self", "href": "/kapacitor/v1/templates/TEMPLATE_ID"},
    "id" : "TASK_ID",
    "type" : "stream",
    "script" : "var x = 5\nstream\n    |from()\n        .measurement('cpu')\n",
    "vars": {"x":{"value": 5, "type":"int", "description": "threshold value"}},
    "dot" : "digraph TASK_ID { ... }",
    "error" : "",
    "created": "2006-01-02T15:04:05Z07:00",
    "modified": "2006-01-02T15:04:05Z07:00",
}
</pre> <h4 id="response-5">Response</h4> <table> <thead> <tr> <th>Code</th> <th>Meaning</th> </tr> </thead> <tbody> <tr> <td>200</td> <td>Success</td> </tr> <tr> <td>404</td> <td>Template does not exist</td> </tr> </tbody> </table> <h3 id="delete-template">Delete Template</h3> <p>To delete a template make a DELETE request to the <code>/kapacitor/v1/templates/TEMPLATE_ID</code> endpoint.</p> <blockquote> <p>NOTE:Deleting a template renders all associated tasks as orphans. The current state of the orphaned tasks will be left unmodified, but orphaned tasks will not be able to be enabled.</p> </blockquote> <pre>DELETE /kapacitor/v1/templates/TEMPLATE_ID
</pre> <h4 id="response-6">Response</h4> <table> <thead> <tr> <th>Code</th> <th>Meaning</th> </tr> </thead> <tbody> <tr> <td>204</td> <td>Success</td> </tr> </tbody> </table> <blockquote> <p>NOTE: Deleting a non-existent template is not an error and will return a 204 success.</p> </blockquote> <h3 id="list-templates">List Templates</h3> <p>To get information about several templates make a GET request to the <code>/kapacitor/v1/templates</code> endpoint.</p> <table> <thead> <tr> <th>Query Parameter</th> <th>Default</th> <th>Purpose</th> </tr> </thead> <tbody> <tr> <td>pattern</td> <td></td> <td>Filter results based on the pattern. Uses standard shell glob matching, see <a href="https://golang.org/pkg/path/filepath/#Match">this</a> for more details.</td> </tr> <tr> <td>fields</td> <td></td> <td>List of fields to return. If empty returns all fields. Fields <code>id</code> and <code>link</code> are always returned.</td> </tr> <tr> <td>script-format</td> <td>formatted</td> <td>One of <code>formatted</code> or <code>raw</code>. Raw will return the script identical to how it was defined. Formatted will first format the script.</td> </tr> <tr> <td>offset</td> <td>0</td> <td>Offset count for paginating through templates.</td> </tr> <tr> <td>limit</td> <td>100</td> <td>Maximum number of templates to return.</td> </tr> </tbody> </table> <h4 id="example-7">Example</h4> <p>Get all templates.</p> <pre>GET /kapacitor/v1/templates
</pre> <pre data-language="json">{
    "templates" : [
        {
            "link" : {"rel":"self", "href":"/kapacitor/v1/templates/TEMPLATE_ID"},
            "id" : "TEMPLATE_ID",
            "type" : "stream",
            "script" : "stream|from().measurement('cpu')",
            "dot" : "digraph TEMPLATE_ID { ... }",
            "error" : ""
        },
        {
            "link" : {"rel":"self", "href":"/kapacitor/v1/templates/ANOTHER_TEMPLATE_ID"},
            "id" : "ANOTHER_TEMPLATE_ID",
            "type" : "stream",
            "script" : "stream|from().measurement('cpu')",
            "dot" : "digraph ANOTHER_TEMPLATE_ID{ ... }",
            "error" : ""
        }
    ]
}
</pre> <p>Optionally specify a glob <code>pattern</code> to list only matching templates.</p> <pre>GET /kapacitor/v1/template?pattern=TEMPLATE*
</pre> <pre data-language="json">{
    "templates" : [
        {
            "link" : {"rel":"self", "href":"/kapacitor/v1/templates/TEMPLATE_ID"},
            "id" : "TEMPLATE_ID",
            "type" : "stream",
            "script" : "stream|from().measurement('cpu')",
            "dot" : "digraph TEMPLATE_ID { ... }",
            "error" : ""
        }
    ]
}
</pre> <p>Get all templates, but only the script and error fields.</p> <pre>GET /kapacitor/v1/templates?fields=status&amp;fields=executing&amp;fields=error
</pre> <pre data-language="json">{
    "templates" : [
        {
            "link" : {"rel":"self", "href":"/kapacitor/v1/templates/TEMPLATE_ID"},
            "id" : "TEMPLATE_ID",
            "script" : "stream|from().measurement('cpu')",
            "error" : ""
        },
        {
            "link" : {"rel":"self", "href":"/kapacitor/v1/templates/ANOTHER_TEMPLATE_ID"},
            "id" : "ANOTHER_TEMPLATE_ID",
            "script" : "stream|from().measurement('cpu')",
            "error" : ""
        }
    ]
}
</pre> <h4 id="response-7">Response</h4> <table> <thead> <tr> <th>Code</th> <th>Meaning</th> </tr> </thead> <tbody> <tr> <td>200</td> <td>Success</td> </tr> </tbody> </table> <blockquote> <p>NOTE: If the pattern does not match any templates an empty list will be returned, with a 200 success.</p> </blockquote> <h2 id="recordings">Recordings</h2> <p>Kapacitor can save recordings of data and replay them against a specified task.</p> <h3 id="start-recording">Start Recording</h3> <p>There are three methods for recording data with Kapacitor: To create a recording make a POST request to the <code>/kapacitor/v1/recordings/METHOD</code> endpoint.</p> <table> <thead> <tr> <th>Method</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td>stream</td> <td>Record the incoming stream of data.</td> </tr> <tr> <td>batch</td> <td>Record the results of the queries in a batch task.</td> </tr> <tr> <td>query</td> <td>Record the result of an explicit query.</td> </tr> </tbody> </table> <p>The request returns once the recording is started and does not wait for it to finish. A recording ID is returned to later identify the recording.</p> <h5 id="stream">Stream</h5> <table> <thead> <tr> <th>Parameter</th> <th>Purpose</th> </tr> </thead> <tbody> <tr> <td>id</td> <td>Unique identifier for the recording. If empty a random one will be chosen.</td> </tr> <tr> <td>task</td> <td>ID of a task, used to only record data for the DBRPs of the task.</td> </tr> <tr> <td>stop</td> <td>Record stream data until stop date.</td> </tr> </tbody> </table> <h5 id="batch">Batch</h5> <table> <thead> <tr> <th>Parameter</th> <th>Purpose</th> </tr> </thead> <tbody> <tr> <td>id</td> <td>Unique identifier for the recording. If empty a random one will be chosen.</td> </tr> <tr> <td>task</td> <td>ID of a task, records the results of the queries defined in the task.</td> </tr> <tr> <td>start</td> <td>Earliest date for which data will be recorded. RFC3339Nano formatted.</td> </tr> <tr> <td>stop</td> <td>Latest date for which data will be recorded. If not specified uses the current time. RFC3339Nano formatted data.</td> </tr> </tbody> </table> <h5 id="query">Query</h5> <table> <thead> <tr> <th>Parameter</th> <th>Purpose</th> </tr> </thead> <tbody> <tr> <td>id</td> <td>Unique identifier for the recording. If empty a random one will be chosen.</td> </tr> <tr> <td>type</td> <td>Type of recording, <code>stream</code> or <code>batch</code>.</td> </tr> <tr> <td>query</td> <td>Query to execute.</td> </tr> <tr> <td>cluster</td> <td>Name of a configured InfluxDB cluster. If empty uses the default cluster.</td> </tr> </tbody> </table> <blockquote> <p>NOTE: A recording itself is typed as either a stream or batch recording and can only be replayed to a task of a corresponding type. Therefore when you record the result of a raw query you must specify the type recording you wish to create.</p> </blockquote> <h4 id="example-8">Example</h4> <p>Create a recording using the <code>stream</code> method</p> <pre>POST /kapacitor/v1/recordings/stream
{
    "task" : "TASK_ID",
    "stop" : "2006-01-02T15:04:05Z07:00"
}
</pre> <p>Create a recording using the <code>batch</code> method specifying a start time.</p> <pre>POST /kapacitor/v1/recordings/batch
{
    "task" : "TASK_ID",
    "start" : "2006-01-02T15:04:05Z07:00"
}
</pre> <p>Create a recording using the <code>query</code> method specifying a <code>stream</code> type.</p> <pre>POST /kapacitor/v1/recordings/query
{
    "query" : "SELECT mean(usage_idle) FROM cpu WHERE time &gt; now() - 1h GROUP BY time(10m)",
    "type" : "stream"
}
</pre> <p>Create a recording using the <code>query</code> method specifying a <code>batch</code> type.</p> <pre>POST /kapacitor/v1/recordings/query
{
    "query" : "SELECT mean(usage_idle) FROM cpu WHERE time &gt; now() - 1h GROUP BY time(10m)",
    "type" : "batch"
}
</pre> <p>Create a recording with a custom ID.</p> <pre>POST /kapacitor/v1/recordings/query
{
    "id" : "MY_RECORDING_ID",
    "query" : "SELECT mean(usage_idle) FROM cpu WHERE time &gt; now() - 1h GROUP BY time(10m)",
    "type" : "batch"
}
</pre> <h4 id="response-8">Response</h4> <p>All recordings are assigned an ID which is returned in this format with a link.</p> <pre data-language="json">{
    "link" : {"rel": "self", "href": "/kapacitor/v1/recordings/e24db07d-1646-4bb3-a445-828f5049bea0"},
    "id" : "e24db07d-1646-4bb3-a445-828f5049bea0",
    "type" : "stream",
    "size" : 0,
    "date" : "2006-01-02T15:04:05Z07:00",
    "error" : "",
    "status" : "running",
    "progress" : 0
}
</pre> <table> <thead> <tr> <th>Code</th> <th>Meaning</th> </tr> </thead> <tbody> <tr> <td>201</td> <td>Success, the recording has started.</td> </tr> </tbody> </table> <h3 id="wait-for-recording">Wait for Recording</h3> <p>In order to determine when a recording has finished you must make a GET request to the returned link typically something like <code>/kapacitor/v1/recordings/RECORDING_ID</code>.</p> <p>A recording has these read only properties.</p> <table> <thead> <tr> <th>Property</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td>size</td> <td>Size of the recording on disk in bytes.</td> </tr> <tr> <td>date</td> <td>Date the recording finished.</td> </tr> <tr> <td>error</td> <td>Any error encountered when creating the recording.</td> </tr> <tr> <td>status</td> <td>One of <code>running</code>, <code>failed</code> or <code>finished</code>.</td> </tr> <tr> <td>progress</td> <td>Number between 0 and 1 indicating the approximate progress of the recording.</td> </tr> </tbody> </table> <h4 id="example-9">Example</h4> <pre>GET /kapacitor/v1/recordings/e24db07d-1646-4bb3-a445-828f5049bea0
</pre> <pre data-language="json">{
    "link" : {"rel": "self", "href": "/kapacitor/v1/recordings/e24db07d-1646-4bb3-a445-828f5049bea0"},
    "id" : "e24db07d-1646-4bb3-a445-828f5049bea0",
    "type" : "stream",
    "size" : 1980353,
    "date" : "2006-01-02T15:04:05Z07:00",
    "error" : "",
    "status" : "running",
    "progress" : 0.75
}
</pre> <p>Once the recording is complete.</p> <pre>GET /kapacitor/v1/recordings/e24db07d-1646-4bb3-a445-828f5049bea0
</pre> <pre data-language="json">{
    "link" : {"rel": "self", "href": "/kapacitor/v1/recordings/e24db07d-1646-4bb3-a445-828f5049bea0"},
    "id" : "e24db07d-1646-4bb3-a445-828f5049bea0",
    "type" : "stream",
    "size" : 1980353,
    "date" : "2006-01-02T15:04:05Z07:00",
    "error" : "",
    "status" : "finished",
    "progress" : 1
}
</pre> <p>Or if the recording fails.</p> <pre>GET /kapacitor/v1/recordings/e24db07d-1646-4bb3-a445-828f5049bea0
</pre> <pre data-language="json">{
    "link" : {"rel": "self", "href": "/kapacitor/v1/recordings/e24db07d-1646-4bb3-a445-828f5049bea0"},
    "id" : "e24db07d-1646-4bb3-a445-828f5049bea0",
    "type" : "stream",
    "size" : 1980353,
    "date" : "2006-01-02T15:04:05Z07:00",
    "error" : "error message explaining failure",
    "status" : "failed",
    "progress" : 1
}
</pre> <h4 id="response-9">Response</h4> <table> <thead> <tr> <th>Code</th> <th>Meaning</th> </tr> </thead> <tbody> <tr> <td>200</td> <td>Success, the recording is no longer running.</td> </tr> <tr> <td>202</td> <td>Success, the recording exists but is not finished.</td> </tr> <tr> <td>404</td> <td>No such recording exists.</td> </tr> </tbody> </table> <h3 id="delete-recording">Delete Recording</h3> <p>To delete a recording make a DELETE request to the <code>/kapacitor/v1/recordings/RECORDING_ID</code> endpoint.</p> <pre>DELETE /kapacitor/v1/recordings/RECORDING_ID
</pre> <h4 id="response-10">Response</h4> <table> <thead> <tr> <th>Code</th> <th>Meaning</th> </tr> </thead> <tbody> <tr> <td>204</td> <td>Success</td> </tr> </tbody> </table> <blockquote> <p>NOTE: Deleting a non-existent recording is not an error and will return a 204 success.</p> </blockquote> <h3 id="list-recordings">List Recordings</h3> <p>To list all recordings make a GET request to the <code>/kapacitor/v1/recordings</code> endpoint. Recordings are sorted by date.</p> <table> <thead> <tr> <th>Query Parameter</th> <th>Default</th> <th>Purpose</th> </tr> </thead> <tbody> <tr> <td>pattern</td> <td></td> <td>Filter results based on the pattern. Uses standard shell glob matching, see <a href="https://golang.org/pkg/path/filepath/#Match">this</a> for more details.</td> </tr> <tr> <td>fields</td> <td></td> <td>List of fields to return. If empty returns all fields. Fields <code>id</code> and <code>link</code> are always returned.</td> </tr> <tr> <td>offset</td> <td>0</td> <td>Offset count for paginating through tasks.</td> </tr> <tr> <td>limit</td> <td>100</td> <td>Maximum number of tasks to return.</td> </tr> </tbody> </table> <h4 id="example-10">Example</h4> <pre>GET /kapacitor/v1/recordings
</pre> <pre data-language="json">{
    "recordings" : [
        {
            "link" : {"rel": "self", "href": "/kapacitor/v1/recordings/e24db07d-1646-4bb3-a445-828f5049bea0"},
            "id" : "e24db07d-1646-4bb3-a445-828f5049bea0",
            "type" : "stream",
            "size" : 1980353,
            "date" : "2006-01-02T15:04:05Z07:00",
            "error" : "",
            "status" : "finished",
            "progress" : 1
        },
        {
            "link" : {"rel": "self", "href": "/kapacitor/v1/recordings/8a4c06c6-30fb-42f4-ac4a-808aa31278f6"},
            "id" : "8a4c06c6-30fb-42f4-ac4a-808aa31278f6",
            "type" : "batch",
            "size" : 216819562,
            "date" : "2006-01-02T15:04:05Z07:00",
            "error" : "",
            "status" : "finished",
            "progress" : 1
        }
    ]
}
</pre> <h4 id="response-11">Response</h4> <table> <thead> <tr> <th>Code</th> <th>Meaning</th> </tr> </thead> <tbody> <tr> <td>200</td> <td>Success</td> </tr> </tbody> </table> <h2 id="replays">Replays</h2> <h3 id="replaying-a-recording">Replaying a recording</h3> <p>To replay a recording make a POST request to <code>/kapacitor/v1/replays/</code></p> <table> <thead> <tr> <th>Parameter</th> <th>Default</th> <th>Purpose</th> </tr> </thead> <tbody> <tr> <td>id</td> <td>random</td> <td>Unique identifier for the replay. If empty a random ID is chosen.</td> </tr> <tr> <td>task</td> <td></td> <td>ID of task.</td> </tr> <tr> <td>recording</td> <td></td> <td>ID of recording.</td> </tr> <tr> <td>recording-time</td> <td>false</td> <td>If true, use the times in the recording, otherwise adjust times relative to the current time.</td> </tr> <tr> <td>clock</td> <td>fast</td> <td>One of <code>fast</code> or <code>real</code>. If <code>real</code> wait for real time to pass corresponding with the time in the recordings. If <code>fast</code> replay data without delay. For example, if clock is <code>real</code> then a stream recording of duration 5m will take 5m to replay.</td> </tr> </tbody> </table> <h4 id="example-11">Example</h4> <p>Replay a recording using default parameters.</p> <pre>POST /kapacitor/v1/replays/
{
    "task" : "TASK_ID",
    "recording" : "RECORDING_ID"
}
</pre> <p>Replay a recording in real-time mode and preserve recording times.</p> <pre>POST /kapacitor/v1/replays/
{
    "task" : "TASK_ID",
    "recording" : "RECORDING_ID",
    "clock" : "real",
    "recording-time" : true,
}
</pre> <p>Replay a recording using a custom ID.</p> <pre>POST /kapacitor/v1/replays/
{
    "id" : "MY_REPLAY_ID",
    "task" : "TASK_ID",
    "recording" : "RECORDING_ID"
}
</pre> <h4 id="response-12">Response</h4> <p>The request returns once the replay is started and provides a replay ID and link.</p> <pre data-language="json">{
    "link" : {"rel": "self", "href": "/kapacitor/v1/replays/ad95677b-096b-40c8-82a8-912706f41d4c"},
    "id" : "ad95677b-096b-40c8-82a8-912706f41d4c",
    "task" : "TASK_ID",
    "recording" : "RECORDING_ID",
    "clock" : "fast",
    "recording-time" : false,
    "status" : "running",
    "progress" : 0,
    "error" : ""
}
</pre> <table> <thead> <tr> <th>Code</th> <th>Meaning</th> </tr> </thead> <tbody> <tr> <td>201</td> <td>Success, replay has started.</td> </tr> </tbody> </table> <h3 id="replay-data-without-recording">Replay data without Recording</h3> <p>It is also possible to replay data directly without recording it first. This is done by issuing a request similar to either a <code>batch</code> or <code>query</code> recording but instead of storing the data it is immediately replayed against a task. Using a <code>stream</code> recording for immediately replaying against a task is equivalent to enabling the task and so is not supported.</p> <table> <thead> <tr> <th>Method</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td>batch</td> <td>Replay the results of the queries in a batch task.</td> </tr> <tr> <td>query</td> <td>Replay the results of an explicit query.</td> </tr> </tbody> </table> <h5 id="batch-1">Batch</h5> <table> <thead> <tr> <th>Parameter</th> <th>Default</th> <th>Purpose</th> </tr> </thead> <tbody> <tr> <td>id</td> <td>random</td> <td>Unique identifier for the replay. If empty a random one will be chosen.</td> </tr> <tr> <td>task</td> <td></td> <td>ID of a task, replays the results of the queries defined in the task against the task.</td> </tr> <tr> <td>start</td> <td></td> <td>Earliest date for which data will be replayed. RFC3339Nano formatted.</td> </tr> <tr> <td>stop</td> <td>now</td> <td>Latest date for which data will be replayed. If not specified uses the current time. RFC3339Nano formatted data.</td> </tr> <tr> <td>recording-time</td> <td>false</td> <td>If true, use the times in the recording, otherwise adjust times relative to the current time.</td> </tr> <tr> <td>clock</td> <td>fast</td> <td>One of <code>fast</code> or <code>real</code>. If <code>real</code> wait for real time to pass corresponding with the time in the recordings. If <code>fast</code> replay data without delay. For example, if clock is <code>real</code> then a stream recording of duration 5m will take 5m to replay.</td> </tr> </tbody> </table> <h5 id="query-1">Query</h5> <table> <thead> <tr> <th>Parameter</th> <th>Default</th> <th>Purpose</th> </tr> </thead> <tbody> <tr> <td>id</td> <td>random</td> <td>Unique identifier for the replay. If empty a random one will be chosen.</td> </tr> <tr> <td>task</td> <td></td> <td>ID of a task, replays the results of the queries against the task.</td> </tr> <tr> <td>query</td> <td></td> <td>Query to execute.</td> </tr> <tr> <td>cluster</td> <td></td> <td>Name of a configured InfluxDB cluster. If empty uses the default cluster.</td> </tr> <tr> <td>recording-time</td> <td>false</td> <td>If true, use the times in the recording, otherwise adjust times relative to the current time.</td> </tr> <tr> <td>clock</td> <td>fast</td> <td>One of <code>fast</code> or <code>real</code>. If <code>real</code> wait for real time to pass corresponding with the time in the recordings. If <code>fast</code> replay data without delay. For example, if clock is <code>real</code> then a stream recording of duration 5m will take 5m to replay.</td> </tr> </tbody> </table> <h4 id="example-12">Example</h4> <p>Perform a replay using the <code>batch</code> method specifying a start time.</p> <pre>POST /kapacitor/v1/replays/batch
{
    "task" : "TASK_ID",
    "start" : "2006-01-02T15:04:05Z07:00"
}
</pre> <p>Replay the results of the query against the task.</p> <pre>POST /kapacitor/v1/replays/query
{
    "task" : "TASK_ID",
    "query" : "SELECT mean(usage_idle) FROM cpu WHERE time &gt; now() - 1h GROUP BY time(10m)",
}
</pre> <p>Create a replay with a custom ID.</p> <pre>POST /kapacitor/v1/replays/query
{
    "id" : "MY_REPLAY_ID",
    "task" : "TASK_ID",
    "query" : "SELECT mean(usage_idle) FROM cpu WHERE time &gt; now() - 1h GROUP BY time(10m)",
}
</pre> <h4 id="response-13">Response</h4> <p>All replays are assigned an ID which is returned in this format with a link.</p> <pre data-language="json">{
    "link" : {"rel": "self", "href": "/kapacitor/v1/replays/e24db07d-1646-4bb3-a445-828f5049bea0"},
    "id" : "e24db07d-1646-4bb3-a445-828f5049bea0",
    "task" : "TASK_ID",
    "recording" : "",
    "clock" : "fast",
    "recording-time" : false,
    "status" : "running",
    "progress" : 0.57,
    "error" : ""
}
</pre> <blockquote> <p>NOTE: For a replay created in this manner the <code>recording</code> ID will be empty since no recording was used or created.</p> </blockquote> <table> <thead> <tr> <th>Code</th> <th>Meaning</th> </tr> </thead> <tbody> <tr> <td>201</td> <td>Success, the replay has started.</td> </tr> </tbody> </table> <h3 id="waiting-for-a-replay">Waiting for a Replay</h3> <p>Like recordings you make a GET request to the <code>/kapacitor/v1/replays/REPLAY_ID</code> endpoint to get the status of the replay.</p> <p>A replay has these read only properties in addition to the properties listed <a href="#replay-recording">above</a>.</p> <table> <thead> <tr> <th>Property</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td>status</td> <td>One of <code>running</code>, <code>failed</code> or <code>finished</code>.</td> </tr> <tr> <td>progress</td> <td>Number between 0 and 1 indicating the approximate progress of the replay.</td> </tr> <tr> <td>error</td> <td>Any error that occured while perfoming the replay</td> </tr> </tbody> </table> <h4 id="example-13">Example</h4> <p>Get the status of a replay.</p> <pre>GET /kapacitor/v1/replays/ad95677b-096b-40c8-82a8-912706f41d4c
</pre> <pre data-language="json">{
    "link" : {"rel": "self", "href": "/kapacitor/v1/replays/ad95677b-096b-40c8-82a8-912706f41d4c"},
    "id" : "ad95677b-096b-40c8-82a8-912706f41d4c",
    "task" : "TASK_ID",
    "recording" : "RECORDING_ID",
    "clock" : "fast",
    "recording-time" : false,
    "status" : "running",
    "progress" : 0.57,
    "error" : ""
}
</pre> <p>Once the replay is complete.</p> <pre>GET /kapacitor/v1/replays/ad95677b-096b-40c8-82a8-912706f41d4c
</pre> <pre data-language="json">{
    "link" : {"rel": "self", "href": "/kapacitor/v1/replays/ad95677b-096b-40c8-82a8-912706f41d4c"},
    "id" : "ad95677b-096b-40c8-82a8-912706f41d4c",
    "task" : "TASK_ID",
    "recording" : "RECORDING_ID",
    "clock" : "fast",
    "recording-time" : false,
    "status" : "finished",
    "progress" : 1,
    "error" : ""
}
</pre> <p>Or if the replay fails.</p> <pre>GET /kapacitor/v1/replays/ad95677b-096b-40c8-82a8-912706f41d4c
</pre> <pre data-language="json">{
    "link" : {"rel": "self", "href": "/kapacitor/v1/replays/ad95677b-096b-40c8-82a8-912706f41d4c"},
    "id" : "ad95677b-096b-40c8-82a8-912706f41d4c",
    "task" : "TASK_ID",
    "recording" : "RECORDING_ID",
    "clock" : "fast",
    "recording-time" : false,
    "status" : "failed",
    "progress" : 1,
    "error" : "error message explaining failure"
}
</pre> <h4 id="response-14">Response</h4> <table> <thead> <tr> <th>Code</th> <th>Meaning</th> </tr> </thead> <tbody> <tr> <td>200</td> <td>Success, replay is no longer running.</td> </tr> <tr> <td>202</td> <td>Success, the replay exists but is not finished.</td> </tr> <tr> <td>404</td> <td>No such replay exists.</td> </tr> </tbody> </table> <h3 id="delete-replay">Delete Replay</h3> <p>To delete a replay make a DELETE request to the <code>/kapacitor/v1/replays/REPLAY_ID</code> endpoint.</p> <pre>DELETE /kapacitor/v1/replays/REPLAY_ID
</pre> <h4 id="response-15">Response</h4> <table> <thead> <tr> <th>Code</th> <th>Meaning</th> </tr> </thead> <tbody> <tr> <td>204</td> <td>Success</td> </tr> </tbody> </table> <blockquote> <p>NOTE: Deleting a non-existent replay is not an error and will return a 204 success.</p> </blockquote> <h3 id="list-replays">List Replays</h3> <p>You can list replays for a given recording by making a GET request to <code>/kapacitor/v1/replays</code>.</p> <table> <thead> <tr> <th>Query Parameter</th> <th>Default</th> <th>Purpose</th> </tr> </thead> <tbody> <tr> <td>pattern</td> <td></td> <td>Filter results based on the pattern. Uses standard shell glob matching, see <a href="https://golang.org/pkg/path/filepath/#Match">this</a> for more details.</td> </tr> <tr> <td>fields</td> <td></td> <td>List of fields to return. If empty returns all fields. Fields <code>id</code> and <code>link</code> are always returned.</td> </tr> <tr> <td>offset</td> <td>0</td> <td>Offset count for paginating through tasks.</td> </tr> <tr> <td>limit</td> <td>100</td> <td>Maximum number of tasks to return.</td> </tr> </tbody> </table> <h4 id="example-14">Example</h4> <pre>GET /kapacitor/v1/replays
</pre> <pre data-language="json">{
    "replays": [
        {
            "link" : {"rel": "self", "href": "/kapacitor/v1/replays/ad95677b-096b-40c8-82a8-912706f41d4c"},
            "id" : "ad95677b-096b-40c8-82a8-912706f41d4c",
            "task" : "TASK_ID",
            "recording" : "RECORDING_ID",
            "clock" : "fast",
            "recording-time" : false,
            "status" : "finished",
            "progress" : 1,
            "error" : ""
        },
        {
            "link" : {"rel": "self", "href": "/kapacitor/v1/replays/be33f0a1-0272-4019-8662-c730706dac7d"},
            "id" : "be33f0a1-0272-4019-8662-c730706dac7d",
            "task" : "TASK_ID",
            "recording" : "RECORDING_ID",
            "clock" : "fast",
            "recording-time" : false,
            "status" : "finished",
            "progress" : 1,
            "error" : ""
        }
    ]
}
</pre> <h2 id="alerts">Alerts</h2> <p>Kapacitor can generate and handle alerts. The API allows you to see the current state of any alert and to configure various handlers for the alerts.</p> <blockquote> <p>NOTE: All API endpoints related to alerts are in a technical preview. Meaning that they are subject to change in the future until the technical preview is completed. As such the URL for the endpoints uses the base path <code>/kapacitor/v1preview</code>. Once the technical preview is deemed complete the endpoint paths will be promoted to use the v1 <code>/kapacitor/v1</code> base path.</p> </blockquote> <h3 id="topics">Topics</h3> <p>Alerts are grouped into topics. An alert handler “listens” on a topic for any new events. You can either specify the alert topic in the TICKscript or one will be generated for you.</p> <h3 id="creating-and-removing-topics">Creating and Removing Topics</h3> <p>Topics are created dynamically when they referenced in TICKscripts or in handlers. To delete a topic make a <code>DELETE</code> request to <code>/kapacitor/v1preview/alerts/topics/&lt;topic id&gt;</code>. This will delete all known events and state for the topic.</p> <blockquote> <p>NOTE: Since topics are dynamically created, a topic may return after having deleted it, if a new event is created for the topic.</p> </blockquote> <h4 id="example-15">Example</h4> <pre>DELETE /kapacitor/v1preview/alerts/topics/system
</pre> <h3 id="list-topics">List Topics</h3> <p>To query the list of available topics make a GET requests to <code>/kapacitor/v1preview/alerts/topics</code>.</p> <table> <thead> <tr> <th>Query Parameter</th> <th>Default</th> <th>Purpose</th> </tr> </thead> <tbody> <tr> <td>min-level</td> <td>OK</td> <td>Only return topics that are greater or equal to the min-level. Valid values include OK, INFO, WARNING, CRITICAL.</td> </tr> <tr> <td>pattern</td> <td>*</td> <td>Filter results based on the pattern. Uses standard shell glob matching on the topic ID, see <a href="https://golang.org/pkg/path/filepath/#Match">this</a> for more details.</td> </tr> </tbody> </table> <h4 id="example-16">Example</h4> <p>Get all topics.</p> <pre>GET /kapacitor/v1preview/alerts/topics
</pre> <pre>{
    "link": {"rel":"self","href":"/kapacitor/v1preview/alerts/topics"},
    "topics": [
        {
            "link": {"rel":"self","href":"/kapacitor/v1preview/alerts/topics/system"},
            "events-link" : {"rel":"events","href":"/kapacitor/v1preview/alerts/topics/system/events"},
            "handlers-link": {"rel":"handlers","href":"/kapacitor/v1preview/alerts/topics/system/handlers"},
            "id": "system",
            "level":"CRITICAL"
        },
        {
            "link": {"rel":"self","href":"/kapacitor/v1preview/alerts/topics/app"},
            "events-link" : {"rel":"events","href":"/kapacitor/v1preview/alerts/topics/app/events"},
            "handlers-link": {"rel":"handlers","href":"/kapacitor/v1preview/alerts/topics/app/handlers"},
            "id": "app",
            "level":"OK"
        }
    ]
}
</pre> <p>Get all topics in a WARNING or CRITICAL state.</p> <pre>GET /kapacitor/v1preview/alerts/topics?min-level=WARNING
</pre> <pre>{
    "link": {"rel":"self","href":"/kapacitor/v1preview/alerts/topics"},
    "topics": [
        {
            "link": {"rel":"self","href":"/kapacitor/v1preview/alerts/topics/system"},
            "events-link" : {"rel":"events","href":"/kapacitor/v1preview/alerts/topics/system/events"},
            "handlers-link": {"rel":"handlers","href":"/kapacitor/v1preview/alerts/topics/system/handlers"},
            "id": "system",
            "level":"CRITICAL"
        }
    ]
}
</pre> <h3 id="topic-state">Topic State</h3> <p>To query the state of a topic make a GET request to <code>/kapacitor/v1preview/alerts/topics/&lt;topic id&gt;</code>.</p> <h4 id="example-17">Example</h4> <pre>GET /kapacitor/v1preview/alerts/topics/system
</pre> <pre>{
    "link": {"rel":"self","href":"/kapacitor/v1preview/alerts/topics/system"},
    "id": "system",
    "level":"CRITICAL"
    "events-link" : {"rel":"events","href":"/kapacitor/v1preview/alerts/topics/system/events"},
    "handlers-link": {"rel":"handlers","href":"/kapacitor/v1preview/alerts/topics/system/handlers"},
}
</pre> <h3 id="list-topic-events">List Topic Events</h3> <p>To query all the events within a topic make a GET request to <code>/kapacitor/v1preview/alerts/topics/&lt;topic id&gt;/events</code>.</p> <table> <thead> <tr> <th>Query Parameter</th> <th>Default</th> <th>Purpose</th> </tr> </thead> <tbody> <tr> <td>min-level</td> <td>OK</td> <td>Only return events that are greater or equal to the min-level. Valid values include OK, INFO, WARNING, CRITICAL.</td> </tr> </tbody> </table> <h4 id="example-18">Example</h4> <pre>GET /kapacitor/v1preview/alerts/topics/system/events
</pre> <pre>{
    "link": {"rel":"self","href":"/kapacitor/v1preview/alerts/topics/system/events"},
    "topic": "system",
    "events": [
        {
            "link":{"rel":"self","href":"/kapacitor/v1preview/alerts/topics/system/events/cpu"},
            "id": "cpu",
            "state": {
                "level": "WARNING",
                "message": "cpu is WARNING",
                "time": "2016-12-01T00:00:00Z",
                "duration": "5m"
            }
        },
        {
            "link":{"rel":"self","href":"/kapacitor/v1preview/alerts/topics/system/events/mem"},
            "id": "mem",
            "state": {
                "level": "CRITICAL",
                "message": "mem is CRITICAL",
                "time": "2016-12-01T00:10:00Z",
                "duration": "1m"
            }
        }
    ]
}
</pre> <h3 id="topic-event">Topic Event</h3> <p>You can query a specific event within a topic by making a GET request to <code>/kapacitor/v1preview/alerts/topics/&lt;topic id&gt;/events/&lt;event id&gt;</code>.</p> <h4 id="example-19">Example</h4> <pre>GET /kapacitor/v1preview/alerts/topics/system/events/cpu
</pre> <pre>{
    "link":{"rel":"self","href":"/kapacitor/v1preview/alerts/topics/system/events/cpu"},
    "id": "cpu",
    "state": {
        "level": "WARNING",
        "message": "cpu is WARNING",
        "time": "2016-12-01T00:00:00Z",
        "duration": "5m"
    }
}
</pre> <h3 id="list-topic-handlers">List Topic Handlers</h3> <p>Handlers are created within a topic. You can get a list of handlers configured for a topic by making a GET request to <code>/kapacitor/v1preview/alerts/topics/&lt;topic id&gt;/handlers</code>.</p> <table> <thead> <tr> <th>Query Parameter</th> <th>Default</th> <th>Purpose</th> </tr> </thead> <tbody> <tr> <td>pattern</td> <td>*</td> <td>Filter results based on the pattern. Uses standard shell glob matching on the service name, see <a href="https://golang.org/pkg/path/filepath/#Match">this</a> for more details.</td> </tr> </tbody> </table> <blockquote> <p>NOTE: Anonymous handlers (created automatically from TICKscripts) will not be listed under their associated anonymous topic as they are not configured via the API.</p> </blockquote> <h4 id="example-20">Example</h4> <p>Get the handlers for the <code>system</code> topic.</p> <pre>GET /kapacitor/v1preview/alerts/topics/system/handlers
</pre> <pre>{
    "link":{"rel":"self","href":"/kapacitor/v1preview/alerts/topics/system/handlers"},
    "topic": "system",
    "handlers": [
        {
            "link":{"rel":"self","href":"/kapacitor/v1preview/alerts/topics/system/handlers/slack"},
            "id":"slack",
            "actions": [{
                "kind":"slack",
                "options":{
                    "channel":"#alerts"
                }
            }]
        },
        {
            "link":{"rel":"self","href":"/kapacitor/v1preview/alerts/topics/system/handlers/smtp"},
            "id":"smtp",
            "actions": [{
                "kind":"smtp"
            }]
        }
    ]
}
</pre> <p>This <code>main:alert_cpu:alert5</code> topic represents an auto-generated topic from a task that has defined handlers explicitly in the TICKscript. Anonymous handlers cannot be listed or modified via the API.</p> <pre>GET /kapacitor/v1preview/alerts/topics/main:alert_cpu:alert5/handlers
</pre> <pre>{
    "link":{"rel":"self","href":"/kapacitor/v1preview/alerts/topics/system/handlers"},
    "topic": "main:alert_cpu:alert5",
    "handlers": null
}
</pre> <h3 id="get-a-handler">Get a Handler</h3> <p>To query information about a specific handler make a GET request to <code>/kapacitor/v1preview/alerts/topics/&lt;topic id&gt;/handlers/&lt;handler id&gt;</code>.</p> <h4 id="example-21">Example</h4> <pre>GET /kapacitor/v1preview/alerts/topics/system/handlers/slack
</pre> <pre>{
    "link":{"rel":"self","href":"/kapacitor/v1preview/alerts/topics/system/handlers/slack"},
    "id":"slack",
    "actions": [{
        "kind":"slack",
        "options": {
            "channel":"#alerts"
        }
    }]
}
</pre> <h3 id="create-a-handler">Create a Handler</h3> <p>To create a new handler make a POST request to <code>/kapacitor/v1preview/alerts/topics/system/handlers</code>.</p> <pre>POST /kapacitor/v1preview/alerts/topics/system/handlers
{
    "id":"slack",
    "actions": [{
        "kind":"slack",
        "options": {
            "channel":"#alerts"
        }
    }]

}
</pre> <pre>{
    "link":{"rel":"self","href":"/kapacitor/v1preview/alerts/topics/system/handlers/slack"},
    "id": "slack",
    "actions": [{
        "kind":"slack",
        "options": {
            "channel":"#alerts"
        }
    }]
}
</pre> <h3 id="update-a-handler">Update a Handler</h3> <p>To update an existing handler you can either make a PUT or PATCH request to <code>/kapacitor/v1preview/alerts/topics/system/handlers/&lt;handler id&gt;</code>.</p> <p>Using PUT will replace the entire handler, by using PATCH specific parts of the handler can be modified.</p> <p>PATCH will apply JSON patch object to the existing handler, see <a href="https://tools.ietf.org/html/rfc6902">rfc6902</a> for more details.</p> <h4 id="example-22">Example</h4> <p>Update the topics and actions for a handler using the PATCH method.</p> <pre>PATCH /kapacitor/v1preview/alerts/topics/system/handlers/slack
[
    {"op":"replace", "path":"/topics", "value":["system", "test"]},
    {"op":"replace", "path":"/actions/0/options/channel", "value":"#testing_alerts"}
]
</pre> <pre>{
    "link":{"rel":"self","href":"/kapacitor/v1preview/alerts/topics/system/handlers/slack"},
    "id": "slack",
    "actions": [
        {
            "kind":"slack",
            "options": {
                "channel":"#testing_alerts"
            }
        }
    ]
}
</pre> <p>Replace an entire handler using the PUT method.</p> <pre>PUT /kapacitor/v1preview/alerts/topics/system/handlers/slack
{
    "id": "slack",
    "actions": [
        {
            "kind":"slack",
            "options": {
                "channel":"#testing_alerts"
            }
        }
    ]
}
</pre> <pre>{
    "link":{"rel":"self","href":"/kapacitor/v1preview/alerts/topics/system/handlers/slack"},
    "id": "slack",
    "actions": [
        {
            "kind":"slack",
            "options": {
                "channel":"#testing_alerts"
            }
        }
    ]
}
</pre> <h3 id="remove-a-handler">Remove a Handler</h3> <p>To remove an existing handler make a DELETE request to <code>/kapacitor/v1preview/alerts/topics/system/handlers/&lt;handler id&gt;</code>.</p> <pre>DELETE /kapacitor/v1preview/alerts/topics/system/handlers/&lt;handler id&gt;
</pre> <h2 id="configuration">Configuration</h2> <p>You can set configuration overrides via the API for certain sections of the config. The overrides set via the API always take precedent over what may exist in the configuration file. The sections available for overriding include the InfluxDB clusters and the alert handler sections.</p> <p>The intent of the API is to allow for dynamic configuration of sensitive credentials without requiring that the Kapacitor process be restarted. As such, it is recommended to use either the configuration file or the API to manage these configuration sections, but not both. This will help to eliminate any confusion that may arise as to the source of a given configuration option.</p> <h3 id="enabling-disabling-configuration-overrides">Enabling/Disabling Configuration Overrides</h3> <p>By default the ability to override the configuration is enabled. If you do not wish to enable this feature it can be disabled via the <code>config-override</code> configuration section.</p> <pre>[config-override]
  enabled = false
</pre> <p>If the <code>config-override</code> service is disabled then the relevant API endpoints will return 403 forbidden errors.</p> <h3 id="recovering-from-bad-configuration">Recovering from bad configuration</h3> <p>If somehow you have created a configuration that causes Kapacitor to crash or otherwise not function, you can disable applying overrides during startup with the <code>skip-config-overrides</code> top level configuration option.</p> <pre># This configuration option is only a safe guard and should not be needed in practice.
skip-config-overrides = true
</pre> <p>This allows you to still access the API to fix any unwanted configuration without applying that configuration during statup.</p> <blockquote> <p>NOTE: It is probably easiest and safest to set this option as an environment variable <code>KAPACITOR_SKIP_CONFIG_OVERRIDES=true</code>, since it is meant to be temporary. That way you do not have to modify your on disk configuration file or accidentally leave it in place causing issues later on.</p> </blockquote> <h3 id="overview">Overview</h3> <p>The paths for the configuration API endpoints are as follows:</p> <p><code>/kapacitor/v1/config/&lt;section name&gt;/[&lt;element name&gt;]</code></p> <p>Example:</p> <pre>/kapacitor/v1/config/smtp/
/kapacitor/v1/config/influxdb/localhost
/kapacitor/v1/config/influxdb/remote
</pre> <p>The optional <code>element name</code> path element corresponds to a specific item from a list of entries.</p> <p>For example the above paths correspond to the following configuration sections:</p> <pre>[smtp]
    # SMTP config here

[[influxdb]]
    name = "localhost"
    # InfluxDB config here for the "localhost" cluster

[[influxdb]]
    name = "remote"
    # InfluxDB config here for the "remote" cluster
</pre> <h3 id="retrieving-the-current-configuration">Retrieving the current configuration</h3> <p>To retrieve the current configuration perform a GET request to the desired path. The returned configuration will be the merged values from the configuration file and what has been stored in the overrides. The returned content will be JSON encoded version of the configuration objects.</p> <p>All sensitive information will not be returned in the request body. Instead a boolean value will be in its place indicating whether the value is empty or not. A list of which options are redacted is returned for each element.</p> <h4 id="example-23">Example</h4> <p>Retrieve all the configuration sections which can be overridden.</p> <pre>GET /kapacitor/v1/config
</pre> <pre data-language="json">{
    "link" : {"rel": "self", "href": "/kapacitor/v1/config"},
    "sections": {
        "influxdb": {
            "link" : {"rel": "self", "href": "/kapacitor/v1/config/influxdb"},
            "elements": [
                {
                    "link" : {"rel": "self", "href": "/kapacitor/v1/config/influxdb/localhost"},
                    "options": {
                        "name": "localhost",
                        "urls": ["http://localhost:8086"],
                        "default": true,
                        "username": "",
                        "password": false
                    },
                    "redacted" : [
                        "password"
                    ]
                },
                {
                    "link" : {"rel": "self", "href": "/kapacitor/v1/config/influxdb/remote"},
                    "options": {
                        "name": "remote",
                        "urls": ["http://influxdb.example.com:8086"],
                        "default": false,
                        "username": "jim",
                        "password": true
                    },
                    "redacted" : [
                        "password"
                    ]
                }
            ]
        },
        "smtp": {
            "link" : {"rel": "self", "href": "/kapacitor/v1/config/smtp"},
            "elements": [{
                "link" : {"rel": "self", "href": "/kapacitor/v1/config/smtp/"},
                "options": {
                    "enabled": true,
                    "host": "smtp.example.com",
                    "port": 587,
                    "username": "bob",
                    "password": true,
                    "no-verify": false,
                    "global": false,
                    "to": [ "oncall@example.com"],
                    "from": "kapacitor@example.com",
                    "idle-timeout": "30s"
                },
                "redacted" : [
                    "password"
                ]
            }]
        }
    }
}
</pre> <p>Retrieve only the SMTP section.</p> <pre>GET /kapacitor/v1/config/smtp
</pre> <pre data-language="json">{
    "link" : {"rel": "self", "href": "/kapacitor/v1/config/smtp"},
    "elements": [{
        "link" : {"rel": "self", "href": "/kapacitor/v1/config/smtp/"},
        "options": {
            "enabled": true,
            "host": "smtp.example.com",
            "port": 587,
            "username": "bob",
            "password": true,
            "no-verify": false,
            "global": false,
            "to": ["oncall@example.com"],
            "from": "kapacitor@example.com",
            "idle-timeout": "30s"
        },
        "redacted" : [
            "password"
        ]
    }]
}
</pre> <p>Retrieve the single element from the SMTP section.</p> <pre>GET /kapacitor/v1/config/smtp/
</pre> <pre data-language="json">{
    "link" : {"rel": "self", "href": "/kapacitor/v1/config/smtp/"},
    "options": {
        "enabled": true,
        "host": "smtp.example.com",
        "port": 587,
        "username": "bob",
        "password": true,
        "no-verify": false,
        "global": false,
        "to": ["oncall@example.com"],
        "from": "kapacitor@example.com",
        "idle-timeout": "30s"
    },
    "redacted" : [
        "password"
    ]
}
</pre> <blockquote> <p>NOTE: Sections that are not lists can be treated as having an empty string for their element name.</p> </blockquote> <p>Retrieve only the InfluxDB section.</p> <pre>GET /kapacitor/v1/config/influxdb
</pre> <pre data-language="json">{
    "link" : {"rel": "self", "href": "/kapacitor/v1/config/influxdb"},
    "elements" : [
        {
            "link" : {"rel": "self", "href": "/kapacitor/v1/config/influxdb/localhost"},
            "options": {
               "name": "localhost",
               "urls": ["http://localhost:8086"],
               "default": true,
               "username": "",
               "password": false
            },
            "redacted" : [
                "password"
            ]
        },
        {
            "link" : {"rel": "self", "href": "/kapacitor/v1/config/influxdb/remote"},
            "options": {
                "name": "remote",
                "urls": ["http://influxdb.example.com:8086"],
                "default": false,
                "username": "jim",
                "password": true
            },
            "redacted" : [
                "password"
            ]
        }
    ]
}
</pre> <p>Retrieve only the <code>remote</code> element of the InfluxDB section.</p> <pre>GET /kapacitor/v1/config/influxdb/remote
</pre> <pre data-language="json">{
    "link" : {"rel": "self", "href": "/kapacitor/v1/config/influxdb/remote"},
    "options": {
        "name": "remote",
        "urls": ["http://influxdb.example.com:8086"],
        "default": false,
        "username": "jim",
        "password": true
    },
    "redacted" : [
        "password"
    ]
}
</pre> <blockquote> <p>NOTE: The password value is not returned, but the <code>true</code> value indicates that a non empty password has been set.</p> </blockquote> <h4 id="response-16">Response</h4> <table> <thead> <tr> <th>Code</th> <th>Meaning</th> </tr> </thead> <tbody> <tr> <td>200</td> <td>Success</td> </tr> <tr> <td>403</td> <td>Config override service not enabled</td> </tr> </tbody> </table> <h3 id="overriding-the-configuration">Overriding the configuration</h3> <p>To override a value in the configuration make a POST request to the desired path. The request should contain a JSON object describing what should be modified.</p> <p>Use the following top level actions:</p> <table> <thead> <tr> <th>Key</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td>set</td> <td>Set the value in the configuration overrides.</td> </tr> <tr> <td>delete</td> <td>Delete the value from the configuration overrides.</td> </tr> <tr> <td>add</td> <td>Add a new element to a list configuration section.</td> </tr> <tr> <td>remove</td> <td>Remove a previously added element from a list configuration section.</td> </tr> </tbody> </table> <p>Configuration options not specified in the request will be left unmodified.</p> <h4 id="example-24">Example</h4> <p>To disable the SMTP alert handler:</p> <pre>POST /kapacitor/v1/config/smtp/
{
    "set":{
        "enabled": false
    }
}
</pre> <p>To delete the override for the SMTP alert handler:</p> <pre>POST /kapacitor/v1/config/smtp/
{
    "delete":[
        "enabled"
    ]
}
</pre> <p>Actions can be combined in a single request. Enable the SMTP handler, set its host and remove the port override.</p> <pre>POST /kapacitor/v1/config/smtp/
{
    "set":{
        "enabled": true,
        "host": "smtp.example.com"
    },
    "delete":[
        "port"
    ]
}
</pre> <p>Add a new InfluxDB cluster:</p> <pre>POST /kapacitor/v1/config/influxdb
{
    "add":{
        "name": "example",
        "urls": ["https://influxdb.example.com:8086"],
        "default": true,
        "disable-subscriptions": true
    }
}
</pre> <p>Remove an existing InfluxDB cluster override:</p> <pre>POST /kapacitor/v1/config/influxdb
{
    "remove":[
        "example"
    ]
}
</pre> <blockquote> <p>NOTE: Only the overrides can be removed, this means that InfluxDB clusters that exist in the configuration cannot be removed.</p> </blockquote> <p>Modify an existing InfluxDB cluster:</p> <pre>POST /kapacitor/v1/config/influxdb/remote
{
    "set":{
        "disable-subscriptions": false,
    },
    "delete": [
        "default"
    ]
}
</pre> <h4 id="response-17">Response</h4> <table> <thead> <tr> <th>Code</th> <th>Meaning</th> </tr> </thead> <tbody> <tr> <td>200</td> <td>Success</td> </tr> <tr> <td>403</td> <td>Config override service not enabled</td> </tr> <tr> <td>404</td> <td>The specified configuration section/option does not exist</td> </tr> </tbody> </table> <h2 id="storage">Storage</h2> <p>Kapacitor exposes some operations that can be performed on the underlying storage.</p> <blockquote> <p>WARNING: Everything storage operation is directly manipulating the underlying storage database. Always make a backup of the database before performing any of these operations.</p> </blockquote> <h3 id="backing-up-the-storage">Backing up the Storage</h3> <p>Making a GET request to <code>/kapacitor/v1/storage/backup</code> will return a dump of the Kapacitor database. To restore from a backup replace the <code>kapacitor.db</code> file with the contents of the backup request.</p> <pre># Create a backup.
curl http://localhost:9092/kapacitor/v1/storage/backup &gt; kapacitor.db
</pre> <pre># Restore a backup.
# The destination path is dependent on your configuration.
cp kapacitor.db ~/.kapacitor/kapacitor.db
</pre> <h3 id="stores">Stores</h3> <p>Kapacitor’s underlying storage system is organized into different stores. Various actions can be performed on each individual store.</p> <blockquote> <p>WARNING: Everything storage operation is directly manipulating the underlying storage database. Always make a backup of the database before performing any of these operations.</p> </blockquote> <p>Available actions:</p> <table> <thead> <tr> <th>Action</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td>rebuild</td> <td>Rebuild all indexes in a store, this operation can be very expensive.</td> </tr> </tbody> </table> <p>To perform an action make a POST request to the <code>/kapacitor/v1/storage/stores/&lt;name of store&gt;</code></p> <h4 id="example-25">Example</h4> <pre>POST /kapacitor/v1/storage/stores/tasks
{
    "action" : "rebuild"
}
</pre> <h4 id="response-18">Response</h4> <table> <thead> <tr> <th>Code</th> <th>Meaning</th> </tr> </thead> <tbody> <tr> <td>204</td> <td>Success</td> </tr> <tr> <td>400</td> <td>Unknown action</td> </tr> <tr> <td>404</td> <td>The specified store does not exist</td> </tr> </tbody> </table> <h2 id="testing-services">Testing Services</h2> <p>Kapacitor makes use of various service integrations. The following API endpoints provide way for a user to run simple tests to ensure that a service is configured correctly.</p> <h3 id="listing-testable-services">Listing testable services</h3> <p>A list of services that can be tested is available at the <code>/kapacitor/v1/service-tests</code> endpoint</p> <table> <thead> <tr> <th>Query Parameter</th> <th>Default</th> <th>Purpose</th> </tr> </thead> <tbody> <tr> <td>pattern</td> <td>*</td> <td>Filter results based on the pattern. Uses standard shell glob matching on the service name, see <a href="https://golang.org/pkg/path/filepath/#Match">this</a> for more details.</td> </tr> </tbody> </table> <h4 id="example-26">Example</h4> <pre>GET /kapacitor/v1/service-tests
</pre> <pre>{
    "link": {"rel":"self", "href": "/kapacitor/v1/service-tests"},
    "services" : [
        {
            "link": {"rel":"self", "href": "/kapacitor/v1/service-tests/influxdb"},
            "name": "influxdb",
            "options": {
                "cluster": ""
            }
        },
        {
            "link": {"rel":"self", "href": "/kapacitor/v1/service-tests/slack"},
            "name": "slack",
            "options": {
                "message": "test slack message",
                "channel": "#alerts",
                "level": "CRITICAL"
            }
        },
        {
            "link": {"rel":"self", "href": "/kapacitor/v1/service-tests/smtp"},
            "name": "smtp",
            "options": {
                "to": ["user@example.com"],
                "subject": "test subject",
                "body": "test body"
            }
        }
    ]
}
</pre> <h4 id="response-19">Response</h4> <table> <thead> <tr> <th>Code</th> <th>Meaning</th> </tr> </thead> <tbody> <tr> <td>200</td> <td>Success</td> </tr> </tbody> </table> <h3 id="testing-a-service">Testing a service</h3> <p>To test a service make a POST request to the <code>/kapacitor/v1/service-tests/&lt;service name&gt;</code> endpoint. The contents of the POST body depend on the service in test. To determine the available options use a GET request to the same endpoint. The returned options are also the defaults.</p> <h4 id="example-27">Example</h4> <p>See available/default options for the slack service:</p> <pre>GET /kapacitor/v1/service-tests/slack
</pre> <pre data-language="json">{
    "link": {"rel":"self", "href": "/kapacitor/v1/service-tests/slack"},
    "name": "slack"
    "options": {
        "message": "test slack message",
        "channel": "#alerts",
        "level": "CRITICAL"
    }
}
</pre> <p>Test the slack service integration using custom options:</p> <pre>POST /kapacitor/v1/service-tests/slack
{
    "message": "my custom test message",
    "channel": "@user",
    "level": "OK"
}
</pre> <p>A successful response looks like:</p> <pre data-language="json">{
    "success": true,
    "message": ""
}
</pre> <p>A failed response looks like:</p> <pre data-language="json">{
    "success": false,
    "message": "could not connect to slack"
}
</pre> <h4 id="response-20">Response</h4> <table> <thead> <tr> <th>Code</th> <th>Meaning</th> </tr> </thead> <tbody> <tr> <td>200</td> <td>Success, even if the service under test fails a 200 is returned as the test complete correctly.</td> </tr> </tbody> </table> <h2 id="miscellaneous">Miscellaneous</h2> <h3 id="ping">Ping</h3> <p>You can ‘ping’ the Kapacitor server to validate you have a successful connection. A ping request does nothing but respond with a 204.</p> <blockquote> <p>NOTE: The Kapacitor server version is returned in the <code>X-Kapacitor-Version</code> HTTP header on all requests. Ping is a useful request if you simply need the verify the version of server you are talking to.</p> </blockquote> <h4 id="example-28">Example</h4> <pre>GET /kapacitor/v1/ping
</pre> <h4 id="response-21">Response</h4> <table> <thead> <tr> <th>Code</th> <th>Meaning</th> </tr> </thead> <tbody> <tr> <td>204</td> <td>Success</td> </tr> </tbody> </table> <h3 id="debug-vars">Debug Vars</h3> <p>Kapacitor also exposes several statistics and information about its runtime. These can be accessed at the <code>/kapacitor/v1/debug/vars</code> endpoint.</p> <h4 id="example-29">Example</h4> <pre>GET /kapacitor/v1/debug/vars
</pre> <h3 id="debug-pprof">Debug Pprof</h3> <p>Kapacitor also the standard Go <a href="https://golang.org/pkg/net/http/pprof/">net/http/pprof</a> endpoints.</p> <pre>GET /kapacitor/v1/debug/pprof/...
</pre> <blockquote> <p>NOTE: Not all of these endpoints return JSON content.</p> </blockquote> <h3 id="routes">Routes</h3> <p>Displays available routes for the API</p> <pre>GET /kapacitor/v1/:routes
</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2015 InfluxData, Inc.<br>Licensed under the MIT license.<br>
    <a href="https://docs.influxdata.com/kapacitor/v1.3/api/api/" class="_attribution-link">https://docs.influxdata.com/kapacitor/v1.3/api/api/</a>
  </p>
</div>
