<h1>Configuration</h1>     <p>You can see the latest config file with all available plugins here: <a href="https://github.com/influxdata/telegraf/blob/master/etc/telegraf.conf">telegraf.conf</a></p> <h2 id="generating-a-configuration-file">Generating a Configuration File</h2> <p>A default Telegraf config file can be auto-generated by telegraf:</p> <pre>telegraf config &gt; telegraf.conf
</pre> <p>To generate a file with specific inputs and outputs, you can use the –input-filter and –output-filter flags:</p> <pre>telegraf --input-filter cpu:mem:net:swap --output-filter influxdb:kafka config
</pre> <h2 id="environment-variables">Environment Variables</h2> <p>Environment variables can be used anywhere in the config file, simply prepend them with $. For strings the variable must be within quotes (ie, “$STR_VAR”), for numbers and booleans they should be plain (ie, $INT_VAR, $BOOL_VAR)</p> <p>Environment variables can be set via the ‘export’ command in Linux (ie, “export password=mypassword”). Using enviroment variables for sensitive information is considered a best practice.</p> <h2 id="configuration-file-locations">Configuration file locations</h2> <p>The location of the configuration file can be set via the <code>--config</code> command line flag. Telegraf will also pick up all files matching the pattern <code>*.conf</code> if the <code>-config-directory</code> command line flag is used.</p> <p>On most systems, the default locations are <code>/etc/telegraf/telegraf.conf</code> for the main configuration file and <code>/etc/telegraf/telegraf.d</code> for the directory of configuration files.</p> <h1 id="global-tags">Global Tags</h1> <p>Global tags can be specified in the <code>[global_tags]</code> section of the config file in key=“value” format. All metrics being gathered on this host will be tagged with the tags specified here.</p> <h2 id="agent-configuration">Agent Configuration</h2> <p>Telegraf has a few options you can configure under the <code>[agent]</code> section of the config.</p> <ul> <li>
<strong>interval</strong>: Default data collection interval for all inputs</li> <li>
<strong>round_interval</strong>: Rounds collection interval to ‘interval’ ie, if interval=“10s” then always collect on :00, :10, :20, etc.</li> <li>
<strong>metric_batch_size</strong>: Telegraf will send metrics to output in batch of at most metric_batch_size metrics.</li> <li>
<strong>metric_buffer_limit</strong>: Telegraf will cache metric_buffer_limit metrics for each output, and will flush this buffer on a successful write. This should be a multiple of metric_batch_size and could not be less than 2 times metric_batch_size.</li> <li>
<strong>collection_jitter</strong>: Collection jitter is used to jitter the collection by a random amount. Each plugin will sleep for a random time within jitter before collecting. This can be used to avoid many plugins querying things like sysfs at the same time, which can have a measurable effect on the system.</li> <li>
<strong>flush_interval</strong>: Default data flushing interval for all outputs. You should not set this below interval. Maximum flush_interval will be flush_interval + flush_jitter</li> <li>
<strong>flush_jitter</strong>: Jitter the flush interval by a random amount. This is primarily to avoid large write spikes for users running a large number of telegraf instances. ie, a jitter of 5s and flush_interval 10s means flushes will happen every 10-15s.</li> <li>
<strong>precision</strong>: By default, precision will be set to the same timestamp order as the collection interval, with the maximum being 1s. Precision will NOT be used for service inputs, such as logparser and statsd. Valid values are “ns”, “us” (or “µs”), “ms”, “s”.</li> <li>
<strong>logfile</strong>: Specify the log file name. The empty string means to log to stderr.</li> <li>
<strong>debug</strong>: Run telegraf in debug mode.</li> <li>
<strong>quiet</strong>: Run telegraf in quiet mode (error messages only).</li> <li>
<strong>hostname</strong>: Override default hostname, if empty use os.Hostname().</li> <li>
<strong>omit_hostname</strong>: If true, do no set the “host” tag in the telegraf agent.</li> </ul> <h2 id="input-configuration">Input Configuration</h2> <p>The following config parameters are available for all inputs:</p> <ul> <li>
<strong>interval</strong>: How often to gather this metric. Normal plugins use a single global interval, but if one particular input should be run less or more often, you can configure that here.</li> <li>
<strong>name_override</strong>: Override the base name of the measurement. (Default is the name of the input).</li> <li>
<strong>name_prefix</strong>: Specifies a prefix to attach to the measurement name.</li> <li>
<strong>name_suffix</strong>: Specifies a suffix to attach to the measurement name.</li> <li>
<strong>tags</strong>: A map of tags to apply to a specific input’s measurements.</li> </ul> <h2 id="output-configuration">Output Configuration</h2> <p>There are no generic configuration options available for all outputs.</p> <h2 id="aggregator-configuration">Aggregator Configuration</h2> <p>The following config parameters are available for all aggregators:</p> <ul> <li>
<strong>period</strong>: The period on which to flush &amp; clear each aggregator. All metrics that are sent with timestamps outside of this period will be ignored by the aggregator.</li> <li>
<strong>delay</strong>: The delay before each aggregator is flushed. This is to control how long for aggregators to wait before receiving metrics from input plugins, in the case that aggregators are flushing and inputs are gathering on the same interval.</li> <li>
<strong>drop_original</strong>: If true, the original metric will be dropped by the aggregator and will not get sent to the output plugins.</li> <li>
<strong>name_override</strong>: Override the base name of the measurement. (Default is the name of the input).</li> <li>
<strong>name_prefix</strong>: Specifies a prefix to attach to the measurement name.</li> <li>
<strong>name_suffix</strong>: Specifies a suffix to attach to the measurement name.</li> <li>
<strong>tags</strong>: A map of tags to apply to a specific input’s measurements.</li> </ul> <h2 id="processor-configuration">Processor Configuration</h2> <p>The following config parameters are available for all processors:</p> <ul> <li>
<strong>order</strong>: This is the order in which the processor(s) get executed. If this is not specified then processor execution order will be random.</li> </ul> <h4 id="measurement-filtering">Measurement Filtering</h4> <p>Filters can be configured per input, output, processor, or aggregator, see below for examples.</p> <ul> <li>
<strong>namepass</strong>: An array of glob pattern strings. Only points whose measurement name matches a pattern in this list are emitted.</li> <li>
<strong>namedrop</strong>: The inverse of <code>namepass</code>. If a match is found the point is discarded. This is tested on points after they have passed the <code>namepass</code> test.</li> <li>
<strong>fieldpass</strong>: An array of glob pattern strings. Only fields whose field key matches a pattern in this list are emitted. Not available for outputs.</li> <li>
<strong>fielddrop</strong>: The inverse of <code>fieldpass</code>. Fields with a field key matching one of the patterns will be discarded from the point. Not available for outputs.</li> <li>
<strong>tagpass</strong>: A table mapping tag keys to arrays of glob pattern strings. Only points that contain a tag key in the table and a tag value matching one of its patterns is emitted.</li> <li>
<strong>tagdrop</strong>: The inverse of <code>tagpass</code>. If a match is found the point is discarded. This is tested on points after they have passed the <code>tagpass</code> test.</li> <li>
<strong>taginclude</strong>: An array of glob pattern strings. Only tags with a tag key matching one of the patterns are emitted. In contrast to <code>tagpass</code>, which will pass an entire point based on its tag, <code>taginclude</code> removes all non matching tags from the point. This filter can be used on both inputs &amp; outputs, but it is <em>recommended</em> to be used on inputs, as it is more efficient to filter out tags at the ingestion point.</li> <li>
<strong>tagexclude</strong>: The inverse of <code>taginclude</code>. Tags with a tag key matching one of the patterns will be discarded from the point.</li> </ul> <p><strong>NOTE</strong> Due to the way TOML is parsed, <code>tagpass</code> and <code>tagdrop</code> parameters must be defined at the <em>end</em> of the plugin definition, otherwise subsequent plugin config options will be interpreted as part of the tagpass/tagdrop tables.</p> <h4 id="input-configuration-examples">Input Configuration Examples</h4> <p>This is a full working config that will output CPU data to an InfluxDB instance at 192.168.59.103:8086, tagging measurements with dc=“denver-1”. It will output measurements at a 10s interval and will collect per-cpu data, dropping any fields which begin with <code>time_</code>.</p> <pre data-language="toml">[global_tags]
  dc = "denver-1"

[agent]
  interval = "10s"

# OUTPUTS
[[outputs.influxdb]]
  url = "http://192.168.59.103:8086" # required.
  database = "telegraf" # required.
  precision = "s"

# INPUTS
[[inputs.cpu]]
  percpu = true
  totalcpu = false
  # filter all fields beginning with 'time_'
  fielddrop = ["time_*"]
</pre> <h4 id="input-config-tagpass-and-tagdrop">Input Config: tagpass and tagdrop</h4> <p><strong>NOTE</strong> <code>tagpass</code> and <code>tagdrop</code> parameters must be defined at the <em>end</em> of the plugin definition, otherwise subsequent plugin config options will be interpreted as part of the tagpass/tagdrop map.</p> <pre data-language="toml">[[inputs.cpu]]
  percpu = true
  totalcpu = false
  fielddrop = ["cpu_time"]
  # Don't collect CPU data for cpu6 &amp; cpu7
  [inputs.cpu.tagdrop]
    cpu = [ "cpu6", "cpu7" ]

[[inputs.disk]]
  [inputs.disk.tagpass]
    # tagpass conditions are OR, not AND.
    # If the (filesystem is ext4 or xfs) OR (the path is /opt or /home)
    # then the metric passes
    fstype = [ "ext4", "xfs" ]
    # Globs can also be used on the tag values
    path = [ "/opt", "/home*" ]
</pre> <h4 id="input-config-fieldpass-and-fielddrop">Input Config: fieldpass and fielddrop</h4> <pre data-language="toml"># Drop all metrics for guest &amp; steal CPU usage
[[inputs.cpu]]
  percpu = false
  totalcpu = true
  fielddrop = ["usage_guest", "usage_steal"]

# Only store inode related metrics for disks
[[inputs.disk]]
  fieldpass = ["inodes*"]
</pre> <h4 id="input-config-namepass-and-namedrop">Input Config: namepass and namedrop</h4> <pre data-language="toml"># Drop all metrics about containers for kubelet
[[inputs.prometheus]]
  urls = ["http://kube-node-1:4194/metrics"]
  namedrop = ["container_*"]

# Only store rest client related metrics for kubelet
[[inputs.prometheus]]
  urls = ["http://kube-node-1:4194/metrics"]
  namepass = ["rest_client_*"]
</pre> <h4 id="input-config-taginclude-and-tagexclude">Input Config: taginclude and tagexclude</h4> <pre data-language="toml"># Only include the "cpu" tag in the measurements for the cpu plugin.
[[inputs.cpu]]
  percpu = true
  totalcpu = true
  taginclude = ["cpu"]

# Exclude the "fstype" tag from the measurements for the disk plugin.
[[inputs.disk]]
  tagexclude = ["fstype"]
</pre> <h4 id="input-config-prefix-suffix-and-override">Input config: prefix, suffix, and override</h4> <p>This plugin will emit measurements with the name <code>cpu_total</code></p> <pre data-language="toml">[[inputs.cpu]]
  name_suffix = "_total"
  percpu = false
  totalcpu = true
</pre> <p>This will emit measurements with the name <code>foobar</code></p> <pre data-language="toml">[[inputs.cpu]]
  name_override = "foobar"
  percpu = false
  totalcpu = true
</pre> <h4 id="input-config-tags">Input config: tags</h4> <p>This plugin will emit measurements with two additional tags: <code>tag1=foo</code> and <code>tag2=bar</code></p> <p>NOTE: Order matters, the <code>[inputs.cpu.tags]</code> table must be at the <em>end</em> of the plugin definition.</p> <pre data-language="toml">[[inputs.cpu]]
  percpu = false
  totalcpu = true
  [inputs.cpu.tags]
    tag1 = "foo"
    tag2 = "bar"
</pre> <h4 id="multiple-inputs-of-the-same-type">Multiple inputs of the same type</h4> <p>Additional inputs (or outputs) of the same type can be specified, just define more instances in the config file. It is highly recommended that you utilize <code>name_override</code>, <code>name_prefix</code>, or <code>name_suffix</code> config options to avoid measurement collisions:</p> <pre data-language="toml">[[inputs.cpu]]
  percpu = false
  totalcpu = true

[[inputs.cpu]]
  percpu = true
  totalcpu = false
  name_override = "percpu_usage"
  fielddrop = ["cpu_time*"]
</pre> <h4 id="output-configuration-examples">Output Configuration Examples:</h4> <pre data-language="toml">[[outputs.influxdb]]
  urls = [ "http://localhost:8086" ]
  database = "telegraf"
  precision = "s"
  # Drop all measurements that start with "aerospike"
  namedrop = ["aerospike*"]

[[outputs.influxdb]]
  urls = [ "http://localhost:8086" ]
  database = "telegraf-aerospike-data"
  precision = "s"
  # Only accept aerospike data:
  namepass = ["aerospike*"]

[[outputs.influxdb]]
  urls = [ "http://localhost:8086" ]
  database = "telegraf-cpu0-data"
  precision = "s"
  # Only store measurements where the tag "cpu" matches the value "cpu0"
  [outputs.influxdb.tagpass]
    cpu = ["cpu0"]
</pre> <h4 id="aggregator-configuration-examples">Aggregator Configuration Examples:</h4> <p>This will collect and emit the min/max of the system load1 metric every 30s, dropping the originals.</p> <pre data-language="toml">[[inputs.system]]
  fieldpass = ["load1"] # collects system load1 metric.

[[aggregators.minmax]]
  period = "30s"        # send &amp; clear the aggregate every 30s.
  drop_original = true  # drop the original metrics.

[[outputs.file]]
  files = ["stdout"]
</pre> <p>This will collect and emit the min/max of the swap metrics every 30s, dropping the originals. The aggregator will not be applied to the system load metrics due to the <code>namepass</code> parameter.</p> <pre data-language="toml">[[inputs.swap]]

[[inputs.system]]
  fieldpass = ["load1"] # collects system load1 metric.

[[aggregators.minmax]]
  period = "30s"        # send &amp; clear the aggregate every 30s.
  drop_original = true  # drop the original metrics.
  namepass = ["swap"]   # only "pass" swap metrics through the aggregator.

[[outputs.file]]
  files = ["stdout"]
</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2015 InfluxData, Inc.<br>Licensed under the MIT license.<br>
    <a href="https://docs.influxdata.com/telegraf/v1.3/administration/configuration/" class="_attribution-link">https://docs.influxdata.com/telegraf/v1.3/administration/configuration/</a>
  </p>
</div>
