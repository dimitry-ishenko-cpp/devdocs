<h1>Moment.js Timezone</h1>   <h2 class="docs-section-title" id="/use-it/">Where to use it</h2>     <p>To use moment-timezone, you will need <code>moment@2.9.0+</code>, <code>moment-timezone.js</code>, and the <code>moment-timezone</code> data.</p> <p>For convenience, there are builds available on <a href="https://momentjs.com/timezone/">momentjs.com/timezone/</a> with all the zone data or a subset of the data.</p> <ul> <li>
<code>moment-timezone-with-data.js</code> is recommended for server environments (Node.js) and covers all years available.</li> <li>
<code>moment-timezone-with-data-10-year-range.js</code> is recommend for most browser environments, covering +/- 5 years from the year published.</li> <li>
<code>moment-timezone-with-data-1970-2030.js</code> covers a 60 year range, for those that need more data but not the larger file size of the full data file.</li> </ul> <p>If you use one of the above files, you still need <code>moment.js</code>, but you do not need <code>moment-timezone.js</code> because it is included.</p>     <h3 class="docs-method-title" id="/use-it/node-js/"> Node.js </h3>    <pre data-language="javascript">npm install moment-timezone
</pre>  <p>In Node.js, all the data is preloaded. No additional code is needed for loading data.</p> <pre data-language="javascript">var moment = require('moment-timezone');
moment().tz("America/Los_Angeles").format();
</pre>     <h3 class="docs-method-title" id="/use-it/browser/"> Browser </h3>    <pre data-language="html">&lt;script src="moment.js"&gt;&lt;/script&gt;
&lt;script src="moment-timezone-with-data.js"&gt;&lt;/script&gt;
</pre>  <p>When using Moment Timezone in the browser, you will need to load the data as well as the library.</p> <p>You can either use the prebuilt library and data files linked on <a href="https://momentjs.com/timezone/">the homepage</a> or build a subset of the data yourself and <a href="#/data-loading/">load it</a>.</p> <pre data-language="javascript">moment().tz("America/Los_Angeles").format();
</pre>     <h3 class="docs-method-title" id="/use-it/require-js/"> Require.js </h3>    <pre data-language="javascript">require.config({
    paths: {
        "moment": "path/to/moment"
    }
});
define(["path/to/moment-timezone-with-data"], function (moment) {
    moment().tz("America/Los_Angeles").format();
});
</pre>      <h3 class="docs-method-title" id="/use-it/webpack/"> Webpack </h3>    <pre data-language="javascript">npm install moment-timezone
</pre>  <pre data-language="javascript">var moment = require('moment-timezone');
moment().tz("America/Los_Angeles").format();
</pre> <p><strong>Note:</strong> By default, webpack bundles <em>all</em> moment-timezone data (in moment-timezone 0.5.25, that’s over 900 KBs minified). To strip out unwanted data and bundle only the zone and date range data you need, add the <a href="https://www.npmjs.com/package/moment-timezone-data-webpack-plugin"><code>moment-timezone-data-webpack-plugin</code></a> package:</p>  <pre data-language="javascript">// webpack.config.js
const MomentTimezoneDataPlugin = require('moment-timezone-data-webpack-plugin');
const currentYear = new Date().getFullYear();

module.exports = {
    plugins: [
        // To include only specific zones, use the matchZones option
        new MomentTimezoneDataPlugin({
            matchZones: /^America/
        }),

        // To keep all zones but limit data to specific years, use the year range options
        new MomentTimezoneDataPlugin({
            startYear: currentYear - 5,
            endYear: currentYear + 5,
        }),
    ],
};
</pre> <p>Also see the primary <a href="https://momentjs.com/docs/#/use-it/webpack/">Moment.js Webpack documentation</a> for an example of how to reduce Moment’s bundled locale data. Together these techniques can significantly reduce the final bundle size (by over 1 MB minified, or 85 KB minified + gzipped).</p>     <h2 class="docs-section-title" id="/using-timezones/">Using Time zones</h2>     <p>There are two interfaces for using time zones with Moment.js.</p> <p><code>moment.tz(..., String)</code> does <em>parsing in given time zone</em></p> <p>It takes all the same arguments as the <code>moment</code> constructor, but uses the last argument as a time zone identifier:</p> <pre data-language="javascript">var a = moment.tz("2013-11-18 11:55", "Asia/Taipei");
var b = moment.tz("2013-11-18 11:55", "America/Toronto");

a.format(); // 2013-11-18T11:55:00+08:00
b.format(); // 2013-11-18T11:55:00-05:00

a.utc().format(); // 2013-11-18T03:55Z
b.utc().format(); // 2013-11-18T16:55Z
</pre> <p>Note that created moments have different UTC time because these moments were created in different time zones.</p> <p><code>moment().tz(String)</code> does <em>converting to provided time zone</em></p> <pre data-language="javascript">var a = moment.utc("2013-11-18 11:55").tz("Asia/Taipei");
var b = moment.utc("2013-11-18 11:55").tz("America/Toronto");

a.format(); // 2013-11-18T19:55:00+08:00
b.format(); // 2013-11-18T06:55:00-05:00

a.utc().format(); // 2013-11-18T11:55Z
b.utc().format(); // 2013-11-18T11:55Z
</pre> <p>In this example, you first create <code>moment.utc("2013-11-18 11:55")</code> object in UTC, and then change its timezone to specified. This also works if you create the object in your default timezone: <code>moment("2013-11-18 11:55")</code>.</p> <p>Note that created moments have equal UTC time because these moments were created in a <a href="#/using-timezones/default-timezone/">default timezone</a>.</p>     <h3 class="docs-method-title" id="/using-timezones/parsing-in-zone/"> Parsing in Zone </h3>    <pre data-language="javascript">moment.tz(..., String);
</pre>  <p>The <code>moment.tz</code> constructor takes all the same arguments as the <code>moment</code> constructor, but uses the last argument as a <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">time zone identifier</a>.</p> <pre data-language="javascript">var a = moment.tz("2013-11-18 11:55", "America/Toronto");
var b = moment.tz("May 12th 2014 8PM", "MMM Do YYYY hA", "America/Toronto");
var c = moment.tz(1403454068850, "America/Toronto");
a.format(); // 2013-11-18T11:55:00-05:00
b.format(); // 2014-05-12T20:00:00-04:00
c.format(); // 2014-06-22T12:21:08-04:00
</pre> <p>This constructor is DST aware, and will use the correct offset when parsing.</p> <pre data-language="javascript">moment.tz("2013-12-01", "America/Los_Angeles").format(); // 2013-12-01T00:00:00-08:00
moment.tz("2013-06-01", "America/Los_Angeles").format(); // 2013-06-01T00:00:00-07:00
</pre> <p>The offset is only taken into consideration when constructing with an array, string without offset, or object.</p> <pre data-language="javascript">var arr = [2013, 5, 1],
    str = "2013-12-01",
    obj = { year : 2013, month : 5, day : 1 };

moment.tz(arr, "America/Los_Angeles").format(); // 2013-06-01T00:00:00-07:00
moment.tz(str, "America/Los_Angeles").format(); // 2013-12-01T00:00:00-08:00
moment.tz(obj, "America/Los_Angeles").format(); // 2013-06-01T00:00:00-07:00

moment.tz(arr, "America/New_York").format();    // 2013-06-01T00:00:00-04:00
moment.tz(str, "America/New_York").format();    // 2013-12-01T00:00:00-05:00
moment.tz(obj, "America/New_York").format();    // 2013-06-01T00:00:00-04:00
</pre> <p>If the input string contains an offset, it is used instead for parsing. The parsed moment is then converted to the target zone.</p> <pre data-language="javascript">var zone = "America/Los_Angeles";
moment.tz('2013-06-01T00:00:00',       zone).format(); // 2013-06-01T00:00:00-07:00
moment.tz('2013-06-01T00:00:00-04:00', zone).format(); // 2013-05-31T21:00:00-07:00
moment.tz('2013-06-01T00:00:00+00:00', zone).format(); // 2013-05-31T17:00:00-07:00
</pre> <p>Unix timestamps and <code>Date</code> objects refer to specific points in time, thus it doesn't make sense to use the time zone offset when constructing. Using <code>moment.tz(Number|Date, zone)</code> is functionally equivalent to <code>moment(Number|Date).tz(zone)</code>.</p> <pre data-language="javascript">var timestamp = 1403454068850,
    date = new Date(timestamp);

moment.tz(timestamp, "America/Los_Angeles").format(); // 2014-06-22T09:21:08-07:00
moment(timestamp).tz("America/Los_Angeles").format(); // 2014-06-22T09:21:08-07:00

moment.tz(date, "America/Los_Angeles").format();      // 2014-06-22T09:21:08-07:00
moment(date).tz("America/Los_Angeles").format();      // 2014-06-22T09:21:08-07:00
</pre> <p>Уou may specify a boolean right after format argument to use strict parsing. Strict parsing requires that the format and input match exactly, <em>including delimeters</em>.</p> <pre data-language="javascript">moment.tz('It is 2012-05-25', 'YYYY-MM-DD', "America/Toronto").isValid();       // true 
moment.tz('It is 2012-05-25', 'YYYY-MM-DD', true, "America/Toronto").isValid(); // false
moment.tz('2012-05-25', 'YYYY-MM-DD', true, "America/Toronto").isValid();       // true
moment.tz('2012-05.25', 'YYYY-MM-DD', true, "America/Toronto").isValid();       // false
</pre>     <h3 class="docs-method-title" id="/using-timezones/parsing-ambiguous-inputs/"> Parsing Ambiguities </h3>   <p>Due to daylight saving time, there is a possibility that a time either does not exist, or has existed twice.</p> <h3>Spring Forward</h3> <p>In the spring, at the start of DST, clocks move forward an hour. In reality though, it is not time that is moving, it is the offset moving.</p> <p>Moving the offset forward gives the illusion that an hour has disappeared. As the clock ticks, you can see it move from <code>1:58</code> to <code>1:59</code> to <code>3:00</code>. It is easier to see what is actually happening when you include the offset.</p> <pre>1:58 -5
1:59 -5
3:00 -4
3:01 -4
</pre> <p>The result is that any time between <code>1:59:59</code> and <code>3:00:00</code> never actually happened. Moment Timezone accounts for this. If you try to parse a time that never existed, it will skip forward by the amount of the DST gap (usually 1 hour).</p> <pre data-language="javascript">moment.tz("2012-03-11 01:59:59", "America/New_York").format() // 2012-03-11T01:59:59-05:00
moment.tz("2012-03-11 02:00:00", "America/New_York").format() // 2012-03-11T03:00:00-04:00
moment.tz("2012-03-11 02:59:59", "America/New_York").format() // 2012-03-11T03:59:59-04:00
moment.tz("2012-03-11 03:00:00", "America/New_York").format() // 2012-03-11T03:00:00-04:00
</pre> <p>In this example, the two o'clock hour doesn't exist, so it is treated as equivalent to the three o'clock hour.</p> <h3>Fall Back</h3> <p>In the fall, at the end of DST, clocks move backward an hour. Again, time is not moving backwards, only the offset is. In this case, the illusion is that an hour repeats itself.</p> <p>Again, it is easier to see what is actually happening when you include the offset.</p> <pre>1:58 -4
1:59 -4
1:00 -5
1:01 -5
</pre> <p>Moment Timezone handles this by always using the earlier instance of a duplicated hour.</p> <pre data-language="javascript">moment.tz("2012-11-04 00:59:59", "America/New_York"); // 2012-11-04T00:59:59-04:00
moment.tz("2012-11-04 01:00:00", "America/New_York"); // 2012-11-04T01:00:00-04:00
moment.tz("2012-11-04 01:59:59", "America/New_York"); // 2012-11-04T01:59:59-04:00
moment.tz("2012-11-04 02:00:00", "America/New_York"); // 2012-11-04T02:00:00-05:00
</pre> <p>You won't be able to create a moment with the later instance of the duplicated hour unless you include the offset when parsing.</p> <pre data-language="javascript">moment.tz("2012-11-04 01:00:00-04:00", "America/New_York"); // 2012-11-04T01:00:00-04:00
moment.tz("2012-11-04 01:00:00-05:00", "America/New_York"); // 2012-11-04T01:00:00-05:00
</pre>     <h3 class="docs-method-title" id="/using-timezones/converting-to-zone/"> Converting to Zone </h3>    <pre data-language="javascript">moment().tz(String);
moment().tz(String, Boolean);
</pre>  <p>The <code>moment#tz</code> mutator will change the time zone and update the offset.</p> <pre data-language="javascript">moment("2013-11-18").tz("America/Toronto").format('Z'); // -05:00
moment("2013-11-18").tz("Europe/Berlin").format('Z');   // +01:00
</pre> <p>This information is used consistently in other operations, like calculating the start of the day.</p> <pre data-language="javascript">var m = moment.tz("2013-11-18 11:55", "America/Toronto");
m.format();                     // 2013-11-18T11:55:00-05:00
m.startOf("day").format();      // 2013-11-18T00:00:00-05:00
m.tz("Europe/Berlin").format(); // 2013-11-18T06:00:00+01:00
m.startOf("day").format();      // 2013-11-18T00:00:00+01:00
</pre> <p>Without any argument, <code>moment#tz</code> returns:</p> <ul> <li>the time zone name assigned to the moment instance or</li> <li>
<code>undefined</code> if a time zone has not been set.</li> </ul> <pre data-language="javascript">var m = moment.tz("2013-11-18 11:55", "America/Toronto");
m.tz();  // America/Toronto
var m = moment.tz("2013-11-18 11:55");
m.tz() === undefined;  // true
</pre> <p>On passing a second parameter as <code>true</code>, only the timezone (and offset) is updated, keeping the local time same. Consequently, it will now point to a different point in time if the offset has changed.</p> <pre data-language="javascript">var m = moment.tz("2013-11-18 11:55", "America/Toronto");
m.format();                           // 2013-11-18T11:55:00-05:00
m.tz('Europe/Berlin', true).format()  // 2013-11-18T11:55:00+01:00
</pre>     <h3 class="docs-method-title" id="/using-timezones/formatting/"> Formatting Additions </h3>    <pre data-language="javascript">moment.tz(String).format("Z z"); // -08:00 PST
moment.tz(String).zoneAbbr();    // PST
moment.tz(String).zoneName();    // PST
</pre>  <p>In addition to including the <code>+00:00</code> formatting information, Moment Timezone also includes information for the abbreviated time zone name.</p> <pre data-language="javascript">moment.tz([2012, 0], 'America/New_York').format('z');    // EST
moment.tz([2012, 5], 'America/New_York').format('z');    // EDT
moment.tz([2012, 0], 'America/Los_Angeles').format('z'); // PST
moment.tz([2012, 5], 'America/Los_Angeles').format('z'); // PDT
</pre> <p>Note that these abbreviations may change depending on the time zone offset. This helps to distinguish offsets between places that may or may not use DST.</p> <pre data-language="javascript">// Denver observes DST
moment.tz([2012, 0], 'America/Denver').format('Z z');  // -07:00 MST
moment.tz([2012, 5], 'America/Denver').format('Z z');  // -06:00 MDT
// Phoenix does not observe DST
moment.tz([2012, 0], 'America/Phoenix').format('Z z'); // -07:00 MST
moment.tz([2012, 5], 'America/Phoenix').format('Z z'); // -07:00 MST
</pre> <p>Note also that these abbreviations are not globally unique. Below, you can see that both United States Central Standard Time and China Standard Time have the same abbreviation.</p> <pre data-language="javascript">moment.tz('2016-01-01', 'America/Chicago').format('z');    // CST
moment.tz('2016-01-01', 'Asia/Shanghai').format('z');      // CST
</pre> <p>You can also use <code>moment#zoneAbbr</code> to get the zone abbreviation. This is what moment.js uses when formatting the <code>z</code> token.</p> <pre data-language="javascript">moment.tz([2012, 0], 'America/New_York').zoneAbbr(); // EST
moment.tz([2012, 5], 'America/New_York').zoneAbbr(); // EDT
</pre> <p>Moment.js also provides a hook for the long form time zone name. Because these strings are generally localized, Moment Timezone does not provide any long names for zones.</p> <p>To provide long form names, you can override <code>moment.fn.zoneName</code> and use the <code>zz</code> token.</p> <pre data-language="javascript">var abbrs = {
    EST : 'Eastern Standard Time',
    EDT : 'Eastern Daylight Time',
    CST : 'Central Standard Time',
    CDT : 'Central Daylight Time',
    MST : 'Mountain Standard Time',
    MDT : 'Mountain Daylight Time',
    PST : 'Pacific Standard Time',
    PDT : 'Pacific Daylight Time',
};

moment.fn.zoneName = function () {
    var abbr = this.zoneAbbr();
    return abbrs[abbr] || abbr;
};

moment.tz([2012, 0], 'America/New_York').format('zz');    // Eastern Standard Time
moment.tz([2012, 5], 'America/New_York').format('zz');    // Eastern Daylight Time
moment.tz([2012, 0], 'America/Los_Angeles').format('zz'); // Pacific Standard Time
moment.tz([2012, 5], 'America/Los_Angeles').format('zz'); // Pacific Daylight Time
</pre> <p>Please note that the <code>z</code> formatting token will not always show the abbreviated time zone name, instead, will show the time offsets for each region.</p> <pre data-language="javascript">moment.tz('America/Los_Angeles').format('z')  // "PDT"     (abbreviation)
moment.tz('Asia/Magadan').format('z')         // "+11"     (3-char offset)
moment.tz('Asia/Colombo').format('z')         // "+0530"   (5-char offset)
</pre>     <h3 class="docs-method-title" id="/using-timezones/default-timezone/"> Default time zone </h3>    <pre data-language="javascript">moment.tz.setDefault(String);
</pre>  <p>By default, <code>moment</code> objects are created in the local time zone.<br> Local time zone - it's a time zone which is set in a browser or on your <code>node.js</code> server.</p> <p>To change the default time zone, use <code>moment.tz.setDefault</code> with a valid time zone.</p> <pre data-language="javascript">moment.tz.setDefault("America/New_York");
</pre> <p>To reset the default time zone to local, use <code>moment.tz.setDefault</code> with no arguments.</p> <pre data-language="javascript">moment.tz.setDefault();
</pre> <p>This is a global setting (shared by all modules).</p> <p>Subsequent calls to <code>moment.tz.setDefault</code> will not affect existing <code>moment</code> objects or their clones.</p>     <h3 class="docs-method-title" id="/using-timezones/guessing-user-timezone/"> Guessing user zone </h3>    <pre data-language="javascript">moment.tz.guess();
moment.tz.guess(Boolean);
</pre>  <p>Moment Timezone uses the Internationalization API (<code>Intl.DateTimeFormat().resolvedOptions().timeZone</code>) in <a href="http://caniuse.com/#feat=internationalization">supported browsers</a> to determine the user's time zone.</p> <p>On other browsers, time zone detection is rather tricky to get right, as there is little information provided by those browsers. For those, it will use <code>Date#getTimezoneOffset</code> and <code>Date#toString</code> on a handful of moments around the current year to gather as much information about the browser environment as possible. It then compares that information with all the time zone data loaded and returns the closest match. In case of ties, the time zone with the city with largest population is returned.</p> <p>By default Moment Timezone caches the detected timezone. This means that subsequent calls to <code>moment.tz.guess()</code> will always return the same value.</p> <p>You can call <code>moment.tz.guess()</code> with an optional boolean argument "ignoreCache". If set to true, the cache will be ignored and overwritten with the new value.</p> <pre data-language="javascript">moment.tz.guess(); // America/Chicago
// suppose the client's timezone changes to Europe/Berlin
moment.tz.guess(); // America/Chicago
moment.tz.guess(true); // Europe/Berlin
moment.tz.guess(); // Europe/Berlin
</pre>     <h3 class="docs-method-title" id="/using-timezones/getting-zone-names/"> Getting all Zones </h3>    <pre data-language="javascript">moment.tz.names(); // String[]
</pre>  <p>To get a list of all available time zone names, use <code>moment.tz.names</code>.</p> <pre data-language="javascript">moment.tz.names(); // ["Africa/Abidjan", "Africa/Accra", "Africa/Addis_Ababa", ...]
</pre>     <h3 class="docs-method-title" id="/using-timezones/getting-country-zones/"> Getting Zones for country </h3>    <pre data-language="javascript">moment.tz.zonesForCountry(String); // String[]
moment.tz.zonesForCountry(String, Boolean);
</pre>  <p>To get a list of time zones for some country, use <code>moment.tz.zonesForCountry()</code>.</p> <pre data-language="javascript">moment.tz.zonesForCountry('US');
</pre> <p>By default this method returns zone names sorted alphabetically:</p> <pre data-language="javascript">["America/Adak", "America/Anchorage", ... "Pacific/Honolulu"]
</pre> <p>To get also offsets, pass <code>true</code> as 2nd parameter:</p> <pre data-language="javascript">moment.tz.zonesForCountry('CN', true);
</pre> <p>it returns array of objects with name and offset:</p> <pre data-language="javascript">[
   { name: "Asia/Shanghai", offset: -480 },
   { name: "Asia/Urumqi", offset: -360 }
]
</pre> <p>It's useful if you need to sort time zones by offset.</p> <p>All country codes can be retrieved using method <code>moment.tz.countries()</code></p>     <h2 class="docs-section-title" id="/zone-object/">Zone Object</h2>     <p>In order to match a timestamp to an offset, Moment Timezone uses a <code>Zone</code> object.</p> <p>Though you shouldn't even need to use it, this object's constructor is available on the <code>moment.tz.Zone</code> namespace.</p> <p>This object has 4 properties.</p>  <pre data-language="javascript">{
    name    : 'America/Los_Angeles',          // the unique identifier
    abbrs   : ['PDT', 'PST'],                 // the abbreviations
    untils  : [1414918800000, 1425808800000], // the timestamps in milliseconds
    offsets : [420, 480]                      // the offsets in minutes
}
</pre>     <h3 class="docs-method-title" id="/zone-object/name/"> Name </h3>    <pre data-language="javascript">zone.name; // America/Los_Angeles
</pre>  <p>The uniquely identifying name of the time zone.</p>     <h3 class="docs-method-title" id="/zone-object/abbr/"> Abbreviation </h3>    <pre data-language="javascript">zone.abbr(timestamp); // PST
</pre>  <p>Get the abbreviation for a given timestamp from a <code>Zone</code>.</p> <pre data-language="javascript">moment.tz.zone('America/Los_Angeles').abbr(1403465838805); // PDT
moment.tz.zone('America/Los_Angeles').abbr(1388563200000); // PST
</pre>     <h3 class="docs-method-title" id="/zone-object/offset/"> Offset </h3>    <pre data-language="javascript">zone.utcOffset(timestamp); // 480
</pre>  <p>Get the offset for a given timestamp (in ms) from a <code>Zone</code>.</p> <pre data-language="javascript">moment.tz.zone('America/Los_Angeles').utcOffset(1403465838805); // 420
moment.tz.zone('America/Los_Angeles').utcOffset(1388563200000); // 480
</pre> <p>POSIX compatibility requires that the offsets are inverted. Therefore, Etc/GMT-X will have an offset of <code>+X</code> and Etc/GMT+X will have an offset of <code>-X</code>. This is a result of IANA's <a href="https://github.com/eggert/tz/blob/2017b/etcetera#L36-L42">Time Zone Database</a> and not an arbitrary choice by Moment.js. Thus, using locality based identifiers is preferred over fixed-offset identifiers.</p> <p>For example, <code>moment().tz('Etc/GMT+1').format('YYYY-MM-DD HH:mm ZZ')</code> will return <code>2014-12-18 11:22 -0100</code> while <code>moment().tz('Europe/Madrid').format('YYYY-MM-DD HH:mm ZZ')</code> will return <code>2014-12-18 13:22 +0100</code>. The <code>Europe/Madrid</code> indentifer should be used instead of the <code>Etc/GMT+1</code> identifier.</p>     <h3 class="docs-method-title" id="/zone-object/parse/"> Parse Offset </h3>    <pre data-language="javascript">zone.parse(timestamp); // 480
</pre>  <p>Parse an offset for a timestamp constructed from <code>Date.UTC</code> in that zone.</p> <p>This is what Moment Timezone uses to parse input into a time zone. The process is conceptually similar to the following.</p> <p>Assume we want to find the exact moment of <code>March 19 2014 8:30 am</code> in New York. Because the offset varies between <code>-04:00</code> and <code>-05:00</code> in New York, we don't know what the offset was on March 19th.</p> <p>Instead, we create a timestamp in UTC and pass that to <code>zone.parse</code>, which will return the offset at that time.</p> <pre data-language="javascript">var zone = moment.tz.zone('America/New_York');
zone.parse(Date.UTC(2012, 2, 19, 8, 30)); // 240
</pre> <p>This is the code that handles the cases referenced in the <a href="#/using-timezones/parsing-ambiguous-inputs/">Parsing Ambiguities</a> section above.</p> <pre data-language="javascript">var zone = moment.tz.zone('America/New_York');
zone.parse(Date.UTC(2012, 2, 11, 1, 59)); // 300
zone.parse(Date.UTC(2012, 2, 11, 2, 0)); // 240
</pre>     <h2 class="docs-section-title" id="/data-formats/">Data Formats</h2>     <p>Moment Timezone uses two data formats. An unpacked version for calculations and a packed version for minified transport.</p>     <h3 class="docs-method-title" id="/data-formats/unpacked-format/"> Unpacked Format </h3>   <p>The unpacked format looks exactly like the <a href="#/zone-object/">zone object</a>.</p> <p>The data below is for Los Angeles between 2014 and 2018.</p>  <pre data-language="javascript">{
    name    : 'America/Los_Angeles',
    abbrs   : ['PST', 'PDT','PST', 'PDT', 'PST', 'PDT', 'PST', 'PDT', 'PST', 'PDT', 'PST'],
    untils  : [1394359200000, 1414918800000, 1425808800000, 1446368400000, 1457863200000, 1478422800000, 1489312800000, 1509872400000, 1520762400000, 1541322000000, null],
    offsets : [480, 420, 480, 420, 480, 420, 480, 420, 480, 420, 480]
}
</pre> <p>The lengths of <code>abbrs, untils, offsets</code> are all the same. The <code>offset</code> and <code>abbr</code> at any index are only active while the timestamp is less than the <code>until</code> at that index.</p> <p>An easy way to read this aloud is <em>"between <code>untils[n-1]</code> and <code>untils[n]</code>, the abbr should be <code>abbrs[n]</code> and the offset should be <code>offsets[n]</code>"</em>.</p> <p>Note that <code>untils</code> are measured in milliseconds and <code>offsets</code> are measured in minutes.</p>     <h3 class="docs-method-title" id="/data-formats/packed-format/"> Packed Format </h3>   <p>The packed format represents an unpacked zone in a single string.</p> <p>The data below is for Los Angeles between 2014 and 2018. More time zones can be seen <a href="https://github.com/moment/moment-timezone/blob/develop/data/packed/latest.json">here</a></p> <pre data-language="javascript">'America/Los_Angeles|PST PDT|80 70|01010101010|1Lzm0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0'
</pre> <p>In order to save as many bytes as possible, we used a very compact format to store the data.</p> <p>The data is split into 5 sections separated by pipes.</p> <table> <thead> <tr>
<th>#</th>
<th>Type</th>
<th>Example</th>
</tr> </thead> <tbody> <tr>
<td>0</td>
<td>Name</td>
<td><code>America/Los_Angeles</code></td>
</tr> <tr>
<td>1</td>
<td>Abbr Map</td>
<td><code>PST PDT</code></td>
</tr> <tr>
<td>2</td>
<td>Offset Map</td>
<td><code>80 70</code></td>
</tr> <tr>
<td>3</td>
<td>Abbr/Offset Index</td>
<td><code>01010101010</code></td>
</tr> <tr>
<td>4</td>
<td>Timestamp Diff</td>
<td><code>1Lzm0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0</code></td>
</tr> </tbody> </table> <p><strong>Name:</strong> The canonical name of the time zone.</p> <p><strong>Abbr Map:</strong> A space separated list of all the abbreviations ever used in this time zone.</p> <p><strong>Offset Map:</strong> A space separated list of all the offsets ever used in this time zone in minutes in base 60.</p> <p><strong>Abbr/Offset Index:</strong> A tightly packed array of indices into the offset and abbr maps. These are also in base 60.</p> <p><strong>Timestamp Diffs:</strong> This is where the timestamps are stored.</p> <p>Because we are dealing with a sorted list of timestamps, we just store the diff from the last timestamps rather than storing the full timestamps.</p> <p>The first item in the array is a unix timestamp in minutes. All items after the first item are numbers of minutes to be added to the previous value during unpacking. All items are stored in base 60.</p> <p>As you may have seen from the example above, the timestamp diffs tend to duplicate the same values from year to year. These duplications allow gzip to compress the data even further than if we used full timestamps.</p> <h3>Base 60?</h3> <p>You may be wondering why base 60 is used. Base 62 is a fairly common tool for ascii data compression, using <code>a-z</code> to represent <code>10-35</code> and <code>A-Z</code> to represent <code>36-61</code>.</p> <p>While it may have saved a few bytes to use base 62, much of the data in Moment Timezone maps nicely to multiples of 60.</p> <p>There are 60 minutes in an hour and 60 seconds in a minute. 3 hours is <code>30</code> minutes in base 60 and <code>300</code> seconds in base 60 instead of <code>180</code> and <code>10800</code> in base 10 or <code>2U</code> and <code>2Oc</code> in base 62.</p>     <h3 class="docs-method-title" id="/data-formats/link-format/"> Link Format </h3>   <p>In order to reduce duplication, the Moment Timezone data packer will create links out of two zones that share data that is exactly the same.</p> <p>This data is the two zone names separated by a pipe.</p> <pre data-language="javascript">moment.tz.add('America/Los_Angeles|PST PDT|80 70|01010101010|1Lzm0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0');
moment.tz.link('America/Los_Angeles|US/Pacific');
moment.tz("2013-12-01", "America/Los_Angeles").format(); // 2013-12-01T00:00:00-08:00
moment.tz("2013-12-01", "US/Pacific").format();          // 2013-12-01T00:00:00-08:00
</pre>     <h2 class="docs-section-title" id="/data-loading/">Data Loading</h2>     <p>Once the data has been packed and transported to the client, it must be added to Moment Timezone.</p>     <h3 class="docs-method-title" id="/data-loading/adding-a-zone/"> Adding a Zone </h3>    <pre data-language="javascript">moment.tz.add(PackedZoneString)
moment.tz.add(PackedZoneString[])
</pre>  <p>To add zone data to Moment Timezone, use <code>moment.tz.add</code>.</p> <pre data-language="javascript">moment.tz.add('America/Los_Angeles|PST PDT|80 70|0101|1Lzm0 1zb0 Op0');
</pre> <p>To add more than one zone, pass an array of packed data.</p> <pre data-language="javascript">moment.tz.add([
    'America/Los_Angeles|PST PDT|80 70|0101|1Lzm0 1zb0 Op0',
    'America/New_York|EST EDT|50 40|0101|1Lz50 1zb0 Op0'
]);
</pre> <p><strong>Note: The above zone data is sample data and is not up to date. Reference the <a href="https://github.com/moment/moment-timezone/blob/develop/data/packed/latest.json">moment-timezone source</a> for up to date data.</strong></p>     <h3 class="docs-method-title" id="/data-loading/adding-a-link/"> Adding a Link </h3>    <pre data-language="javascript">moment.tz.link(PackedLinkString)
moment.tz.link(PackedLinkString[])
</pre>  <p>To link two zone names to the same data, use <code>moment.tz.link</code>.</p> <p>The strings passed in should be in the <a href="#/data-formats/link-format/">link format</a>: the two zone names separated by a pipe.</p> <pre data-language="javascript">moment.tz.link('America/Los_Angeles|US/Pacific');
</pre> <p>To add more than one link at a time, pass an array of link strings.</p> <pre data-language="javascript">moment.tz.link([
    'America/Los_Angeles|US/Pacific',
    'America/New_York|US/Eastern'
]);
</pre>     <h3 class="docs-method-title" id="/data-loading/loading-a-data-bundle/"> Loading a Data Bundle </h3>    <pre data-language="javascript">moment.tz.load({
    zones : [],
    links : [],
    version : '2014e'
});
</pre>  <p>The data for Moment Timezone comes from <a href="https://www.iana.org/time-zones">the IANA Time Zone Database</a>. New versions are released periodically as time zone laws change in various countries.</p> <p>The versions are named after the year and an incrementing letter. <code>2014a 2014b 2014c...</code></p> <p>In order to keep versions together, Moment Timezone has a bundled object format as well.</p>  <pre data-language="javascript">{
    version : '2014e',
    zones : [
        'America/Los_Angeles|PST PDT|80 70|0101|1Lzm0 1zb0 Op0',
        'America/New_York|EST EDT|50 40|0101|1Lz50 1zb0 Op0'
    ],
    links : [
        'America/Los_Angeles|US/Pacific',
        'America/New_York|US/Eastern'
    ]
}
</pre> <p>To load a bundle into Moment Timezone, use <code>moment.tz.load</code>.</p>  <pre data-language="javascript">moment.tz.load({
    version : '2014e',
    zones : [...],
    links : [...]
})
</pre>     <h3 class="docs-method-title" id="/data-loading/checking-if-a-zone-exists/"> Checking Zone Existence </h3>    <pre data-language="javascript">moment.tz.zone(name); // Zone or null
</pre>  <p>To check if a zone exists, use <code>moment.tz.zone</code>. It will return the Zone if it was loaded and <code>null</code> if it was not loaded.</p> <pre data-language="javascript">moment.tz.zone("UnloadedZone"); // null
moment.tz.add("UnloadedZone|UZ|0|0|");
moment.tz.zone("UnloadedZone"); // Zone { name : "UnloadedZone", ...}
</pre>     <h3 class="docs-method-title" id="/data-loading/getting-zone-names/"> Getting Zone Names </h3>    <pre data-language="javascript">moment.tz.names(); // String[]
</pre>  <p>To get a list of all available time zone names, use <code>moment.tz.names</code>.</p> <pre data-language="javascript">moment.tz.names(); // ["Africa/Abidjan", "Africa/Accra", "Africa/Addis_Ababa", ...]
</pre>     <h2 class="docs-section-title" id="/data-utilities/">Data Utilities</h2>     <p>Because of the complexity of the packed and unpacked data formats, Moment Timezone has some heavily tested utility functions for working with the data.</p> <p>Methods for unpacking data are included with the core library, as they are needed in order to use the library.</p> <p>Methods for packing and subsetting the data are included in an additional <code>moment-timezone-utils.js</code> file. This file adds some more methods to the <code>moment.tz</code> namespace.</p> <pre data-language="javascript">// in moment-timezone.js
moment.tz.unpack
moment.tz.unpackBase60
// in moment-timezone-utils.js
moment.tz.pack
moment.tz.packBase60
moment.tz.createLinks
moment.tz.filterYears
moment.tz.filterLinkPack
</pre>     <h3 class="docs-method-title" id="/data-utilities/pack/"> Pack </h3>    <pre data-language="javascript">moment.tz.pack(UnpackedObject); // PackedString
</pre>  <p>This converts data in the <a href="#/data-formats/unpacked-format/">unpacked format</a> to the <a href="#/data-formats/packed-format/">packed format</a>.</p> <pre data-language="javascript">var unpacked = {
    name    : 'Indian/Mauritius',
    abbrs   : ['LMT', 'MUT', 'MUST', 'MUT', 'MUST', 'MUT'],
    offsets : [-230, -240, -300, -240, -300, -240],
    untils  : [-1988164200000, 403041600000, 417034800000, 1224972000000, 1238274000000, null]
};
moment.tz.pack(unpacked); // "Indian/Mauritius|LMT MUT MUST|-3O -40 -50|012121|-2xorO 34unO 14L0 12kr0 11z0"
</pre>     <h3 class="docs-method-title" id="/data-utilities/unpack/"> Unpack </h3>    <pre data-language="javascript">moment.tz.unpack(PackedString); // UnpackedObject
</pre>  <p>This converts data in the <a href="#/data-formats/packed-format/">packed format</a> to the <a href="#/data-formats/unpacked-format/">unpacked format</a>.</p> <pre data-language="javascript">var packed = "Indian/Mauritius|LMT MUT MUST|-3O -40 -50|012121|-2xorO 34unO 14L0 12kr0 11z0";

moment.tz.unpack(packed);
// {
//     name    : 'Indian/Mauritius',
//     abbrs   : ['LMT', 'MUT', 'MUST', 'MUT', 'MUST', 'MUT'],
//     offsets : [-230, -240, -300, -240, -300, -240],
//     untils  : [-1988164200000, 403041600000, 417034800000, 1224972000000, 1238274000000, null]
// };
</pre>     <h3 class="docs-method-title" id="/data-utilities/pack-base-60/"> Pack Base 60 </h3>    <pre data-language="javascript">moment.tz.packBase60(Number); // Base60String
</pre>  <p>Convert a base 10 number to a base 60 string.</p> <pre data-language="javascript">moment.tz.packBase60(9);    // 9
moment.tz.packBase60(10);   // a
moment.tz.packBase60(59);   // X
moment.tz.packBase60(1337); // mh
</pre> <p>Much like <code>Number.prototype.toFixed</code>, <code>moment.tz.packBase60</code> accepts a second argument for the number of digits of precision.</p> <pre data-language="javascript">moment.tz.packBase60(1.1667,   1); // 1.a
moment.tz.packBase60(20.12345, 3); // k.7op
moment.tz.packBase60(59,       1); // X
</pre> <p>A solitary <code>0</code> before the decimal point is dropped.</p> <pre data-language="javascript">moment.tz.packBase60(1.1667, 1); // 1.a
moment.tz.packBase60(0.1667, 1); // .a
</pre> <p>Trailing zeroes after the decimal point are dropped.</p> <pre data-language="javascript">moment.tz.packBase60(1/6, 1); // .a
moment.tz.packBase60(1/6, 5); // .a
moment.tz.packBase60(59, 5);  // X
</pre>     <h3 class="docs-method-title" id="/data-utilities/unpack-base-60/"> Unpack Base 60 </h3>    <pre data-language="javascript">moment.tz.unpackBase60(Base60String); // Number
</pre>  <p>Convert a base 60 string to a base 10 number.</p> <pre data-language="javascript">moment.tz.unpackBase60('9');     // 9
moment.tz.unpackBase60('a');     // 10
moment.tz.unpackBase60('X');     // 59
moment.tz.unpackBase60('mh');    // 1337
moment.tz.unpackBase60('1.9');   // 1.15
moment.tz.unpackBase60('k.7op'); // 20.123449074074074
</pre>     <h3 class="docs-method-title" id="/data-utilities/create-links/"> Create Links </h3>    <pre data-language="javascript">moment.tz.createLinks(UnpackedBundle); // UnpackedBundle
</pre>  <p>In order to reduce duplication, we can create links out of two zones that share data.</p>  <pre data-language="javascript">var unlinked = {
    zones : [
        {name:"Zone/One",abbrs:["OST","ODT"],offsets:[60,120],untils:[403041600000,417034800000]},
        {name:"Zone/Two",abbrs:["OST","ODT"],offsets:[60,120],untils:[403041600000,417034800000]}
    ],
    links : [],
    version : "2014x-doc-example"
};

moment.tz.createLinks(unlinked);

{
    zones : [
        {name:"Zone/One",abbrs:["OST","ODT"],offsets:[60,120],untils:[403041600000,417034800000]}
    ],
    links : ["Zone/One|Zone/Two"],
    version : "2014x-doc-example"
}
</pre> <p>This is especially useful when combined with <code>moment.tz.filterYears</code>, as older rules that would have differentiated two Zones may not be in the filtered year range, allowing them to be linked to save space.</p>     <h3 class="docs-method-title" id="/data-utilities/filter-years/"> Filter Years </h3>    <pre data-language="javascript">moment.tz.filterYears(UnpackedZone, Number, Number); // UnpackedZone
</pre>  <p>By default, Moment Timezone includes all the data from <a href="https://www.iana.org/time-zones">the IANA Time Zone Database</a>. This includes data from 1900 to 2038. The data for all these years may not be necessary for your use case.</p> <p><code>moment.tz.filterYears</code> can be used to filter out data for years outside a certain range.</p>  <pre data-language="javascript">var all    = { name : "America/Los_Angeles", abbrs : [...], offsets : [...] untils : [...]};
var subset = moment.tz.filterYears(all, 2012, 2016);
all.untils.length;    // 186
subset.untils.length; // 11
</pre> <p>If only one year is passed, it will be used for the start and end year.</p>  <pre data-language="javascript">var all    = { name : "America/Los_Angeles", abbrs : [...], offsets : [...] untils : [...]};
var subset = moment.tz.filterYears(all, 2012);
all.untils.length;    // 186
subset.untils.length; // 3
</pre>     <h3 class="docs-method-title" id="/data-utilities/filter-link-pack/"> Filter Years, Create Links, and Pack </h3>    <pre data-language="javascript">moment.tz.filterLinkPack(UnpackedBundle, Number, Number); // PackedBundle
</pre>  <p>The packing, link creation, and subsetting of years are all tools for compressing data to be transported to the client.</p> <p>The <code>moment.tz.filterLinkPack</code> method combines all these into one simple interface. Pass in an unpacked bundle, start year, and end year and get a filtered, linked, packed bundle back.</p> <p>This is what is being used to compress the output for the <a href="https://momentjs.com/timezone/">bundled data + library files on the homepage</a>.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; JS Foundation and other contributors<br>Licensed under the MIT License.<br>
    <a href="https://momentjs.com/timezone/docs/" class="_attribution-link">https://momentjs.com/timezone/docs/</a>
  </p>
</div>
