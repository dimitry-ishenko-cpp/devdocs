    <h1 id="firstHeading" class="firstHeading">Standard library header &lt;linalg&gt; <span class="t-mark-rev t-since-cxx26">(C++26)</span>
</h1>            <p>This header is part of the <a href="../numeric.html" title="cpp/numeric">numeric</a> library.</p>
<table class="t-dsc-begin"> <tr> <td colspan="2">  <h3 id="Classes"> Classes</h3> </td>
</tr> <tr class="t-dsc-header"> <th colspan="2"> Defined in namespace <code>std::linalg</code>  </th>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/numeric/linalg/layout_blas_packed&amp;action=edit&amp;redlink=1" class="new" title="cpp/numeric/linalg/layout blas packed (page does not exist)"> <span class="t-lines"><span>layout_blas_packed</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx26">(C++26)</span></span></span></div> </td> <td> <code>std::mdspan</code> layout mapping policy that represents a square matrix that stores only the entries in one triangle, in a packed contiguous format <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/numeric/linalg/scaled_accessor&amp;action=edit&amp;redlink=1" class="new" title="cpp/numeric/linalg/scaled accessor (page does not exist)"> <span class="t-lines"><span>scaled_accessor</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx26">(C++26)</span></span></span></div> </td> <td> <code>std::mdspan</code> accessor policy whose reference represents the product of a scaling factor that is fixed and its nested <code>std::mdspan</code> accessor's reference <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/numeric/linalg/conjugated_accessor&amp;action=edit&amp;redlink=1" class="new" title="cpp/numeric/linalg/conjugated accessor (page does not exist)"> <span class="t-lines"><span>conjugated_accessor</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx26">(C++26)</span></span></span></div> </td> <td> <code>std::mdspan</code> accessor policy whose reference represents the complex conjugate of its nested <code>std::mdspan</code> accessor's reference <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/numeric/linalg/layout_transpose&amp;action=edit&amp;redlink=1" class="new" title="cpp/numeric/linalg/layout transpose (page does not exist)"> <span class="t-lines"><span>layout_transpose</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx26">(C++26)</span></span></span></div> </td> <td> <code>std::mdspan</code> layout mapping policy that swaps the rightmost two indices, extents, and strides of any unique layout mapping policy <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr> <td colspan="2"> <h3 id="Tags"> Tags</h3> </td>
</tr> <tr class="t-dsc-header"> <th colspan="2"> Defined in namespace <code>std::linalg</code>  </th>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/numeric/linalg/storage_order_tags&amp;action=edit&amp;redlink=1" class="new" title="cpp/numeric/linalg/storage order tags (page does not exist)"> <span class="t-lines"><span>column_major</span><span>row_major</span><span>column_major_t</span><span>row_major_t</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx26">(C++26)</span></span></span></div> </td> <td> describe the order of elements in an <code>std::mdspan</code> with <code>linalg::layout_blas_packed</code> layout<br><span class="t-mark">(tag)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/numeric/linalg/triangle_tags&amp;action=edit&amp;redlink=1" class="new" title="cpp/numeric/linalg/triangle tags (page does not exist)"> <span class="t-lines"><span>upper_triangle</span><span>lower_triangle</span><span>upper_triangle_t</span><span>lower_triangle_t</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx26">(C++26)</span></span></span></div> </td> <td> specify whether algorithms and other users of a matrix should access the upper triangle or lower triangle of the matrix<br><span class="t-mark">(tag)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/numeric/linalg/diagonal_tags&amp;action=edit&amp;redlink=1" class="new" title="cpp/numeric/linalg/diagonal tags (page does not exist)"> <span class="t-lines"><span>implicit_unit_diagonal</span><span>explicit_diagonal</span><span>implicit_unit_diagonal_t</span><span>explicit_diagonal_t</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx26">(C++26)</span></span></span></div> </td> <td> specify whether algorithms should access diagonal entries of the matrix<br><span class="t-mark">(tag)</span> </td>
</tr> <tr> <td colspan="2"> <h3 id="Functions"> Functions</h3> </td>
</tr> <tr class="t-dsc-header"> <th colspan="2"> Defined in namespace <code>std::linalg</code>  </th>
</tr> <tr> <td colspan="2"> <h5 id="In-place_transformations">  In-place transformations </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/numeric/linalg/scaled&amp;action=edit&amp;redlink=1" class="new" title="cpp/numeric/linalg/scaled (page does not exist)"> <span class="t-lines"><span>scaled</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx26">(C++26)</span></span></span></div> </td> <td> returns a new read-only <code>std::mdspan</code> computed by the elementwise product of the scaling factor and the corresponding elements of the given <code>std::mdspan</code> <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/numeric/linalg/conjugated&amp;action=edit&amp;redlink=1" class="new" title="cpp/numeric/linalg/conjugated (page does not exist)"> <span class="t-lines"><span>conjugated</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx26">(C++26)</span></span></span></div> </td> <td> returns a new read-only <code>std::mdspan</code> whose elements are the complex conjugates of the corresponding elements of the given <code>std::mdspan</code> <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/numeric/linalg/transposed&amp;action=edit&amp;redlink=1" class="new" title="cpp/numeric/linalg/transposed (page does not exist)"> <span class="t-lines"><span>transposed</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx26">(C++26)</span></span></span></div> </td> <td> returns a new <code>std::mdspan</code> representing the transpose of the input matrix by the given <code>std::mdspan</code> <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/numeric/linalg/conjugate_transposed&amp;action=edit&amp;redlink=1" class="new" title="cpp/numeric/linalg/conjugate transposed (page does not exist)"> <span class="t-lines"><span>conjugate_transposed</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx26">(C++26)</span></span></span></div> </td> <td> returns a conjugate transpose view of an object <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="BLAS_1_functions">  BLAS 1 functions </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/numeric/linalg/setup_givens_rotation&amp;action=edit&amp;redlink=1" class="new" title="cpp/numeric/linalg/setup givens rotation (page does not exist)"> <span class="t-lines"><span>setup_givens_rotation</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx26">(C++26)</span></span></span></div> </td> <td> generates plane rotation <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/numeric/linalg/apply_givens_rotation&amp;action=edit&amp;redlink=1" class="new" title="cpp/numeric/linalg/apply givens rotation (page does not exist)"> <span class="t-lines"><span>apply_givens_rotation</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx26">(C++26)</span></span></span></div> </td> <td> applies plane rotation to vectors <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/numeric/linalg/swap_elements&amp;action=edit&amp;redlink=1" class="new" title="cpp/numeric/linalg/swap elements (page does not exist)"> <span class="t-lines"><span>swap_elements</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx26">(C++26)</span></span></span></div> </td> <td> swaps all corresponding elements of matrix or vector <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/numeric/linalg/scale&amp;action=edit&amp;redlink=1" class="new" title="cpp/numeric/linalg/scale (page does not exist)"> <span class="t-lines"><span>scale</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx26">(C++26)</span></span></span></div> </td> <td> overwrites matrix or vector with the result of computing the elementwise multiplication by a scalar <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/numeric/linalg/copy&amp;action=edit&amp;redlink=1" class="new" title="cpp/numeric/linalg/copy (page does not exist)"> <span class="t-lines"><span>copy</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx26">(C++26)</span></span></span></div> </td> <td> copies elements of one matrix or vector into another <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/numeric/linalg/add&amp;action=edit&amp;redlink=1" class="new" title="cpp/numeric/linalg/add (page does not exist)"> <span class="t-lines"><span>add</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx26">(C++26)</span></span></span></div> </td> <td> adds vectors or matrices elementwise <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/numeric/linalg/dot&amp;action=edit&amp;redlink=1" class="new" title="cpp/numeric/linalg/dot (page does not exist)"> <span class="t-lines"><span>dot</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx26">(C++26)</span></span></span></div> </td> <td> returns nonconjugated dot product of two vectors <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/numeric/linalg/dotc&amp;action=edit&amp;redlink=1" class="new" title="cpp/numeric/linalg/dotc (page does not exist)"> <span class="t-lines"><span>dotc</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx26">(C++26)</span></span></span></div> </td> <td> returns conjugated dot product of two vectors <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/numeric/linalg/vector_sum_of_squares&amp;action=edit&amp;redlink=1" class="new" title="cpp/numeric/linalg/vector sum of squares (page does not exist)"> <span class="t-lines"><span>vector_sum_of_squares</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx26">(C++26)</span></span></span></div> </td> <td> returns scaled sum of squares of the vector elements <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/numeric/linalg/vector_two_norm&amp;action=edit&amp;redlink=1" class="new" title="cpp/numeric/linalg/vector two norm (page does not exist)"> <span class="t-lines"><span>vector_two_norm</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx26">(C++26)</span></span></span></div> </td> <td> returns Euclidean norm of a vector <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/numeric/linalg/vector_abs_sum&amp;action=edit&amp;redlink=1" class="new" title="cpp/numeric/linalg/vector abs sum (page does not exist)"> <span class="t-lines"><span>vector_abs_sum</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx26">(C++26)</span></span></span></div> </td> <td> returns sum of absolute values of the vector elements <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/numeric/linalg/vector_idx_abs_max&amp;action=edit&amp;redlink=1" class="new" title="cpp/numeric/linalg/vector idx abs max (page does not exist)"> <span class="t-lines"><span>vector_idx_abs_max</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx26">(C++26)</span></span></span></div> </td> <td> returns index of maximum absolute value of vector elements <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/numeric/linalg/matrix_frob_norm&amp;action=edit&amp;redlink=1" class="new" title="cpp/numeric/linalg/matrix frob norm (page does not exist)"> <span class="t-lines"><span>matrix_frob_norm</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx26">(C++26)</span></span></span></div> </td> <td> returns Frobenius norm of a matrix <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/numeric/linalg/matrix_one_norm&amp;action=edit&amp;redlink=1" class="new" title="cpp/numeric/linalg/matrix one norm (page does not exist)"> <span class="t-lines"><span>matrix_one_norm</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx26">(C++26)</span></span></span></div> </td> <td> returns one norm of a matrix <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/numeric/linalg/matrix_inf_norm&amp;action=edit&amp;redlink=1" class="new" title="cpp/numeric/linalg/matrix inf norm (page does not exist)"> <span class="t-lines"><span>matrix_inf_norm</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx26">(C++26)</span></span></span></div> </td> <td> returns infinity norm of a matrix <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="BLAS_2_functions">  BLAS 2 functions </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/numeric/linalg/matrix_vector_product&amp;action=edit&amp;redlink=1" class="new" title="cpp/numeric/linalg/matrix vector product (page does not exist)"> <span class="t-lines"><span>matrix_vector_product</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx26">(C++26)</span></span></span></div> </td> <td> computes matrix-vector product <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/numeric/linalg/symmetric_matrix_vector_product&amp;action=edit&amp;redlink=1" class="new" title="cpp/numeric/linalg/symmetric matrix vector product (page does not exist)"> <span class="t-lines"><span>symmetric_matrix_vector_product</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx26">(C++26)</span></span></span></div> </td> <td> computes symmetric matrix-vector product <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/numeric/linalg/hermitian_matrix_vector_product&amp;action=edit&amp;redlink=1" class="new" title="cpp/numeric/linalg/hermitian matrix vector product (page does not exist)"> <span class="t-lines"><span>hermitian_matrix_vector_product</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx26">(C++26)</span></span></span></div> </td> <td> computes Hermitian matrix-vector product <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/numeric/linalg/triangular_matrix_vector_product&amp;action=edit&amp;redlink=1" class="new" title="cpp/numeric/linalg/triangular matrix vector product (page does not exist)"> <span class="t-lines"><span>triangular_matrix_vector_product</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx26">(C++26)</span></span></span></div> </td> <td> computes triangular matrix-vector product <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/numeric/linalg/triangular_matrix_vector_solve&amp;action=edit&amp;redlink=1" class="new" title="cpp/numeric/linalg/triangular matrix vector solve (page does not exist)"> <span class="t-lines"><span>triangular_matrix_vector_solve</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx26">(C++26)</span></span></span></div> </td> <td> solves a triangular linear system <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/numeric/linalg/matrix_rank_1_update&amp;action=edit&amp;redlink=1" class="new" title="cpp/numeric/linalg/matrix rank 1 update (page does not exist)"> <span class="t-lines"><span>matrix_rank_1_update</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx26">(C++26)</span></span></span></div> </td> <td> performs nonsymmetric nonconjugated rank-1 update of a matrix <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/numeric/linalg/matrix_rank_1_update_c&amp;action=edit&amp;redlink=1" class="new" title="cpp/numeric/linalg/matrix rank 1 update c (page does not exist)"> <span class="t-lines"><span>matrix_rank_1_update_c</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx26">(C++26)</span></span></span></div> </td> <td> performs nonsymmetric conjugated rank-1 update of a matrix <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/numeric/linalg/symmetric_matrix_rank_1_update&amp;action=edit&amp;redlink=1" class="new" title="cpp/numeric/linalg/symmetric matrix rank 1 update (page does not exist)"> <span class="t-lines"><span>symmetric_matrix_rank_1_update</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx26">(C++26)</span></span></span></div> </td> <td> performs rank-1 update of a symmetric matrix <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/numeric/linalg/hermitian_matrix_rank_1_update&amp;action=edit&amp;redlink=1" class="new" title="cpp/numeric/linalg/hermitian matrix rank 1 update (page does not exist)"> <span class="t-lines"><span>hermitian_matrix_rank_1_update</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx26">(C++26)</span></span></span></div> </td> <td> performs rank-1 update of a Hermitian matrix <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/numeric/linalg/hermitian_matrix_rank_2_update&amp;action=edit&amp;redlink=1" class="new" title="cpp/numeric/linalg/hermitian matrix rank 2 update (page does not exist)"> <span class="t-lines"><span>hermitian_matrix_rank_2_update</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx26">(C++26)</span></span></span></div> </td> <td> performs rank-2 update of a symmetric matrix <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/numeric/linalg/hermitian_matrix_rank_2_update&amp;action=edit&amp;redlink=1" class="new" title="cpp/numeric/linalg/hermitian matrix rank 2 update (page does not exist)"> <span class="t-lines"><span>hermitian_matrix_rank_2_update</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx26">(C++26)</span></span></span></div> </td> <td> performs rank-2 update of a Hermitian matrix <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="BLAS_3_functions">  BLAS 3 functions </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/numeric/linalg/matrix_product&amp;action=edit&amp;redlink=1" class="new" title="cpp/numeric/linalg/matrix product (page does not exist)"> <span class="t-lines"><span>matrix_product</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx26">(C++26)</span></span></span></div> </td> <td> computes matrix-matrix product <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/numeric/linalg/symmetric_matrix_product&amp;action=edit&amp;redlink=1" class="new" title="cpp/numeric/linalg/symmetric matrix product (page does not exist)"> <span class="t-lines"><span>symmetric_matrix_product</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx26">(C++26)</span></span></span></div> </td> <td> computes symmetric matrix-matrix product <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/numeric/linalg/hermitian_matrix_product&amp;action=edit&amp;redlink=1" class="new" title="cpp/numeric/linalg/hermitian matrix product (page does not exist)"> <span class="t-lines"><span>hermitian_matrix_product</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx26">(C++26)</span></span></span></div> </td> <td> computes Hermitian matrix-matrix product <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/numeric/linalg/triangular_matrix_product&amp;action=edit&amp;redlink=1" class="new" title="cpp/numeric/linalg/triangular matrix product (page does not exist)"> <span class="t-lines"><span>triangular_matrix_product</span><span>triangular_matrix_left_product</span><span>triangular_matrix_right_product</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx26">(C++26)</span></span></span></div> </td> <td> computes triangular matrix-matrix product <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/numeric/linalg/symmetric_matrix_rank_k_update&amp;action=edit&amp;redlink=1" class="new" title="cpp/numeric/linalg/symmetric matrix rank k update (page does not exist)"> <span class="t-lines"><span>symmetric_matrix_rank_k_update</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx26">(C++26)</span></span></span></div> </td> <td> performs rank-k update of a symmetric matrix <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/numeric/linalg/hermitian_matrix_rank_k_update&amp;action=edit&amp;redlink=1" class="new" title="cpp/numeric/linalg/hermitian matrix rank k update (page does not exist)"> <span class="t-lines"><span>hermitian_matrix_rank_k_update</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx26">(C++26)</span></span></span></div> </td> <td> performs rank-k update of a Hermitian matrix <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/numeric/linalg/symmetric_matrix_rank_2k_update&amp;action=edit&amp;redlink=1" class="new" title="cpp/numeric/linalg/symmetric matrix rank 2k update (page does not exist)"> <span class="t-lines"><span>symmetric_matrix_rank_2k_update</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx26">(C++26)</span></span></span></div> </td> <td> performs rank-2k update of a symmetric matrix <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/numeric/linalg/hermitian_matrix_rank_2k_update&amp;action=edit&amp;redlink=1" class="new" title="cpp/numeric/linalg/hermitian matrix rank 2k update (page does not exist)"> <span class="t-lines"><span>hermitian_matrix_rank_2k_update</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx26">(C++26)</span></span></span></div> </td> <td> performs rank-2k update of a Hermitian matrix <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/numeric/linalg/triangular_matrix_matrix_solve&amp;action=edit&amp;redlink=1" class="new" title="cpp/numeric/linalg/triangular matrix matrix solve (page does not exist)"> <span class="t-lines"><span>triangular_matrix_matrix_left_solve</span><span>triangular_matrix_matrix_right_solve</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx26">(C++26)</span></span></span></div> </td> <td> solves multiple triangular linear systems <br> <span class="t-mark">(function template)</span>  </td>
</tr> </table> <h3 id="Synopsis"> Synopsis</h3> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::linalg {
 
// storage order tags
struct column_major_t;
inline constexpr column_major_t column_major;
struct row_major_t;
inline constexpr row_major_t row_major;
 
// triangle tags
struct upper_triangle_t;
inline constexpr upper_triangle_t upper_triangle;
struct lower_triangle_t;
inline constexpr lower_triangle_t lower_triangle;
 
// diagonal tags
struct implicit_unit_diagonal_t;
inline constexpr implicit_unit_diagonal_t implicit_unit_diagonal;
struct explicit_diagonal_t;
inline constexpr explicit_diagonal_t explicit_diagonal;
 
// class template layout_blas_packed
template&lt;class Triangle, class StorageOrder&gt;
class layout_blas_packed;
 
// exposition-only concepts and traits
template&lt;class T&gt;
struct __is_mdspan; // exposition only
 
template&lt;class T&gt;
concept __in_vector = /* see description */; // exposition only
 
template&lt;class T&gt;
concept __out_vector = /* see description */; // exposition only
 
template&lt;class T&gt;
concept __inout_vector = /* see description */; // exposition only
 
template&lt;class T&gt;
concept __in_matrix = /* see description */; // exposition only
 
template&lt;class T&gt;
concept __out_matrix = /* see description */; // exposition only
 
template&lt;class T&gt;
concept __inout_matrix = /* see description */; // exposition only
 
template&lt;class T&gt;
concept __possibly_packed_inout_matrix = /* see description */; // exposition only
 
template&lt;class T&gt;
concept __in_object = /* see description */; // exposition only
 
template&lt;class T&gt;
concept __out_object = /* see description */; // exposition only
 
template&lt;class T&gt;
concept __inout_object = /* see description */; // exposition only
 
// scaled in-place transformation
template&lt;class ScalingFactor, class Accessor&gt;
class scaled_accessor;
 
template&lt;class ScalingFactor,
         class ElementType, class Extents, class Layout, class Accessor&gt;
constexpr auto scaled(ScalingFactor scaling_factor,
                      mdspan&lt;ElementType, Extents, Layout, Accessor&gt; x);
 
// conjugated in-place transformation
template&lt;class Accessor&gt;
class conjugated_accessor;
 
template&lt;class ElementType, class Extents, class Layout, class Accessor&gt;
constexpr auto conjugated(mdspan&lt;ElementType, Extents, Layout, Accessor&gt; a);
 
// transposed in-place transformation
template&lt;class Layout&gt;
class layout_transpose;
 
template&lt;class ElementType, class Extents, class Layout, class Accessor&gt;
constexpr auto transposed(mdspan&lt;ElementType, Extents, Layout, Accessor&gt; a);
 
// conjugated transposed in-place transformation
template&lt;class ElementType, class Extents, class Layout, class Accessor&gt;
constexpr auto conjugate_transposed(mdspan&lt;ElementType, Extents, Layout, Accessor&gt; a);
 
// algorithms
// compute Givens rotation
 
template&lt;class Real&gt;
struct setup_givens_rotation_result {
  Real c;
  Real s;
  Real r;
};
 
template&lt;class Real&gt;
struct setup_givens_rotation_result&lt;complex&lt;Real&gt;&gt; {
  Real c;
  complex&lt;Real&gt; s;
  complex&lt;Real&gt; r;
};
 
template&lt;class Real&gt;
setup_givens_rotation_result&lt;Real&gt; setup_givens_rotation(Real a, Real b) noexcept;
 
template&lt;class Real&gt;
setup_givens_rotation_result&lt;complex&lt;Real&gt;&gt;
setup_givens_rotation(complex&lt;Real&gt; a, complex&lt;Real&gt; b) noexcept;
 
// apply computed Givens rotation
template&lt;__inout_vector InOutVec1, __inout_vector InOutVec2, class Real&gt;
void apply_givens_rotation(InOutVec1 x, InOutVec2 y, Real c, Real s);
 
template&lt;class ExecutionPolicy,
         __inout_vector InOutVec1, __inout_vector InOutVec2, class Real&gt;
void apply_givens_rotation(ExecutionPolicy&amp;&amp; exec,
                           InOutVec1 x, InOutVec2 y, Real c, Real s);
 
template&lt;__inout_vector InOutVec1, __inout_vector InOutVec2, class Real&gt;
void apply_givens_rotation(InOutVec1 x, InOutVec2 y, Real c, complex&lt;Real&gt; s);
 
template&lt;class ExecutionPolicy,
         __inout_vector InOutVec1, __inout_vector InOutVec2, class Real&gt;
void apply_givens_rotation(ExecutionPolicy&amp;&amp; exec,
                           InOutVec1 x, InOutVec2 y, Real c, complex&lt;Real&gt; s);
 
// swap elements
template&lt;__inout_object InOutObj1, __inout_object InOutObj2&gt;
void swap_elements(InOutObj1 x, InOutObj2 y);
 
template&lt;class ExecutionPolicy, __inout_object InOutObj1, __inout_object InOutObj2&gt;
void swap_elements(ExecutionPolicy&amp;&amp; exec, InOutObj1 x, InOutObj2 y);
 
// multiply elements by scalar
template&lt;class Scalar, __inout_object InOutObj&gt;
void scale(Scalar alpha, InOutObj x);
 
template&lt;class ExecutionPolicy, class Scalar, __inout_object InOutObj&gt;
void scale(ExecutionPolicy&amp;&amp; exec, Scalar alpha, InOutObj x);
 
// copy elements
template&lt;__in_object InObj, __out_object OutObj&gt;
void copy(InObj x, OutObj y);
 
template&lt;class ExecutionPolicy, __in_object InObj, __out_object OutObj&gt;
void copy(ExecutionPolicy&amp;&amp; exec, InObj x, OutObj y);
 
// add elementwise
template&lt;__in_object InObj1, __in_object InObj2, __out_object OutObj&gt;
void add(InObj1 x, InObj2 y, OutObj z);
 
template&lt;class ExecutionPolicy,
         __in_object InObj1, __in_object InObj2, __out_object OutObj&gt;
void add(ExecutionPolicy&amp;&amp; exec, InObj1 x, InObj2 y, OutObj z);
 
// nonconjugated dot product of two vectors
template&lt;__in_vector InVec1, __in_vector InVec2, class Scalar&gt;
Scalar dot(InVec1 v1, InVec2 v2, Scalar init);
 
template&lt;class ExecutionPolicy,
         __in_vector InVec1, __in_vector InVec2, class Scalar&gt;
Scalar dot(ExecutionPolicy&amp;&amp; exec, InVec1 v1, InVec2 v2, Scalar init);
 
template&lt;__in_vector InVec1, __in_vector InVec2&gt;
auto dot(InVec1 v1, InVec2 v2) -&gt; /* see description */;
 
template&lt;class ExecutionPolicy, __in_vector InVec1, __in_vector InVec2&gt;
auto dot(ExecutionPolicy&amp;&amp; exec, InVec1 v1, InVec2 v2) -&gt; /* see description */;
 
// conjugated dot product of two vectors
template&lt;__in_vector InVec1, __in_vector InVec2, class Scalar&gt;
Scalar dotc(InVec1 v1, InVec2 v2, Scalar init);
 
template&lt;class ExecutionPolicy,
         __in_vector InVec1, __in_vector InVec2, class Scalar&gt;
Scalar dotc(ExecutionPolicy&amp;&amp; exec, InVec1 v1, InVec2 v2, Scalar init);
 
template&lt;__in_vector InVec1, __in_vector InVec2&gt;
auto dotc(InVec1 v1, InVec2 v2) -&gt; /* see description */;
 
template&lt;class ExecutionPolicy, __in_vector InVec1, __in_vector InVec2&gt;
auto dotc(ExecutionPolicy&amp;&amp; exec, InVec1 v1, InVec2 v2) -&gt; /* see description */;
 
// Scaled sum of squares of a vector's elements
template&lt;class Scalar&gt;
struct sum_of_squares_result {
  Scalar scaling_factor;
  Scalar scaled_sum_of_squares;
};
 
template&lt;__in_vector InVec, class Scalar&gt;
sum_of_squares_result&lt;Scalar&gt;
vector_sum_of_squares(InVec v, sum_of_squares_result&lt;Scalar&gt; init);
 
template&lt;class ExecutionPolicy, __in_vector InVec, class Scalar&gt;
sum_of_squares_result&lt;Scalar&gt;
vector_sum_of_squares(ExecutionPolicy&amp;&amp; exec, InVec v,
                      sum_of_squares_result&lt;Scalar&gt; init);
 
// Euclidean norm of a vector
template&lt;__in_vector InVec, class Scalar&gt;
Scalar vector_two_norm(InVec v, Scalar init);
 
template&lt;class ExecutionPolicy, __in_vector InVec, class Scalar&gt;
Scalar vector_two_norm(ExecutionPolicy&amp;&amp; exec, InVec v, Scalar init);
 
template&lt;__in_vector InVec&gt;
auto vector_two_norm(InVec v) -&gt; /* see description */;
 
template&lt;class ExecutionPolicy, __in_vector InVec&gt;
auto vector_two_norm(ExecutionPolicy&amp;&amp; exec, InVec v) -&gt; /* see description */;
 
// sum of absolute values of vector elements
template&lt;__in_vector InVec, class Scalar&gt;
Scalar vector_abs_sum(InVec v, Scalar init);
template&lt;class ExecutionPolicy, __in_vector InVec, class Scalar&gt;
Scalar vector_abs_sum(ExecutionPolicy&amp;&amp; exec, InVec v, Scalar init);
 
template&lt;__in_vector InVec&gt;
auto vector_abs_sum(InVec v) -&gt; /* see description */;
 
template&lt;class ExecutionPolicy, __in_vector InVec&gt;
auto vector_abs_sum(ExecutionPolicy&amp;&amp; exec, InVec v) -&gt; /* see description */;
 
// index of maximum absolute value of vector elements
template&lt;__in_vector InVec&gt;
typename InVec::extents_type vector_idx_abs_max(InVec v);
 
template&lt;class ExecutionPolicy, __in_vector InVec&gt;
typename InVec::extents_type vector_idx_abs_max(ExecutionPolicy&amp;&amp; exec, InVec v);
 
// Frobenius norm of a matrix
template&lt;__in_matrix InMat, class Scalar&gt;
Scalar matrix_frob_norm(InMat A, Scalar init);
 
template&lt;class ExecutionPolicy, __in_matrix InMat, class Scalar&gt;
Scalar matrix_frob_norm(ExecutionPolicy&amp;&amp; exec,
                        InMat A, Scalar init);
 
template&lt;__in_matrix InMat&gt;
auto matrix_frob_norm(InMat A) -&gt; /* see description */;
 
template&lt;class ExecutionPolicy, __in_matrix InMat&gt;
auto matrix_frob_norm(ExecutionPolicy&amp;&amp; exec, InMat A) -&gt; /* see description */;
 
// One norm of a matrix
template&lt;__in_matrix InMat, class Scalar&gt;
Scalar matrix_one_norm(InMat A, Scalar init);
 
template&lt;class ExecutionPolicy, __in_matrix InMat, class Scalar&gt;
Scalar matrix_one_norm(ExecutionPolicy&amp;&amp; exec,
                       InMat A, Scalar init);
 
template&lt;__in_matrix InMat&gt;
auto matrix_one_norm(InMat A) -&gt; /* see description */;
 
template&lt;class ExecutionPolicy, __in_matrix InMat&gt;
auto matrix_one_norm(ExecutionPolicy&amp;&amp; exec, InMat A) -&gt; /* see description */;
 
// Infinity norm of a matrix
template&lt;__in_matrix InMat, class Scalar&gt;
Scalar matrix_inf_norm(InMat A, Scalar init);
 
template&lt;class ExecutionPolicy, __in_matrix InMat, class Scalar&gt;
Scalar matrix_inf_norm(ExecutionPolicy&amp;&amp; exec,
                       InMat A, Scalar init);
 
template&lt;__in_matrix InMat&gt;
auto matrix_inf_norm(InMat A) -&gt; /* see description */;
 
template&lt;class ExecutionPolicy, __in_matrix InMat&gt;
auto matrix_inf_norm(ExecutionPolicy&amp;&amp; exec, InMat A) -&gt; /* see description */;
 
// general matrix-vector product
template&lt;__in_matrix InMat, __in_vector InVec, __out_vector OutVec&gt;
void matrix_vector_product(InMat A, InVec x, OutVec y);
 
template&lt;class ExecutionPolicy,
         __in_matrix InMat, __in_vector InVec, __out_vector OutVec&gt;
void matrix_vector_product(ExecutionPolicy&amp;&amp; exec,
                           InMat A, InVec x, OutVec y);
 
template&lt;__in_matrix InMat, __in_vector InVec1,
         __in_vector InVec2, __out_vector OutVec&gt;
void matrix_vector_product(InMat A, InVec1 x, InVec2 y, OutVec z);
 
template&lt;class ExecutionPolicy,
         __in_matrix InMat, __in_vector InVec1,
         __in_vector InVec2, __out_vector OutVec&gt;
void matrix_vector_product(ExecutionPolicy&amp;&amp; exec,
                           InMat A, InVec1 x, InVec2 y, OutVec z);
 
// symmetric matrix-vector product
template&lt;__in_matrix InMat, class Triangle,
         __in_vector InVec, __out_vector OutVec&gt;
void symmetric_matrix_vector_product(InMat A, Triangle t,
                                     InVec x, OutVec y);
 
template&lt;class ExecutionPolicy,
         __in_matrix InMat, class Triangle,
         __in_vector InVec, __out_vector OutVec&gt;
void symmetric_matrix_vector_product(ExecutionPolicy&amp;&amp; exec,
                                     InMat A, Triangle t,
                                     InVec x, OutVec y);
 
template&lt;__in_matrix InMat, class Triangle,
         __in_vector InVec1, __in_vector InVec2,
         __out_vector OutVec&gt;
void symmetric_matrix_vector_product(InMat A, Triangle t,
                                     InVec1 x, InVec2 y, OutVec z);
 
template&lt;class ExecutionPolicy,
         __in_matrix InMat, class Triangle,
         __in_vector InVec1, __in_vector InVec2,
         __out_vector OutVec&gt;
void symmetric_matrix_vector_product(ExecutionPolicy&amp;&amp; exec,
                                     InMat A, Triangle t,
                                     InVec1 x, InVec2 y, OutVec z);
 
// Hermitian matrix-vector product
template&lt;__in_matrix InMat, class Triangle,
         __in_vector InVec, __out_vector OutVec&gt;
void hermitian_matrix_vector_product(InMat A, Triangle t,
                                     InVec x, OutVec y);
 
template&lt;class ExecutionPolicy,
         __in_matrix InMat, class Triangle,
         __in_vector InVec, __out_vector OutVec&gt;
void hermitian_matrix_vector_product(ExecutionPolicy&amp;&amp; exec,
                                     InMat A, Triangle t,
                                     InVec x, OutVec y);
 
template&lt;__in_matrix InMat, class Triangle,
         __in_vector InVec1, __in_vector InVec2,
         __out_vector OutVec&gt;
void hermitian_matrix_vector_product(InMat A, Triangle t,
                                     InVec1 x, InVec2 y, OutVec z);
 
template&lt;class ExecutionPolicy,
         __in_matrix InMat, class Triangle,
         __in_vector InVec1, __in_vector InVec2,
         __out_vector OutVec&gt;
void hermitian_matrix_vector_product(ExecutionPolicy&amp;&amp; exec,
                                     InMat A, Triangle t,
                                     InVec1 x, InVec2 y, OutVec z);
 
// Triangular matrix-vector product
// Overwriting triangular matrix-vector product
template&lt;__in_matrix InMat, class Triangle, class DiagonalStorage,
         __in_vector InVec, __out_vector OutVec&gt;
void triangular_matrix_vector_product(InMat A, Triangle t, DiagonalStorage d,
                                      InVec x, OutVec y);
 
template&lt;class ExecutionPolicy,
         __in_matrix InMat, class Triangle, class DiagonalStorage,
         __in_vector InVec, __out_vector OutVec&gt;
void triangular_matrix_vector_product(ExecutionPolicy&amp;&amp; exec,
                                      InMat A, Triangle t, DiagonalStorage d,
                                      InVec x, OutVec y);
 
// In-place triangular matrix-vector product
template&lt;__in_matrix InMat, class Triangle, class DiagonalStorage,
         __inout_vector InOutVec&gt;
void triangular_matrix_vector_product(InMat A, Triangle t, DiagonalStorage d,
                                      InOutVec y);
 
template&lt;class ExecutionPolicy,
         __in_matrix InMat, class Triangle, class DiagonalStorage,
         __inout_vector InOutVec&gt;
void triangular_matrix_vector_product(ExecutionPolicy&amp;&amp; exec,
                                      InMat A, Triangle t, DiagonalStorage d,
                                      InOutVec y);
 
// Updating triangular matrix-vector product
template&lt;__in_matrix InMat, class Triangle, class DiagonalStorage,
         __in_vector InVec1, __in_vector InVec2,
         __out_vector OutVec&gt;
void triangular_matrix_vector_product(InMat A, Triangle t, DiagonalStorage d,
                                      InVec1 x, InVec2 y, OutVec z);
 
template&lt;class ExecutionPolicy,
         __in_matrix InMat, class Triangle, class DiagonalStorage,
         __in_vector InVec1, __in_vector InVec2,
         __out_vector OutVec&gt;
void triangular_matrix_vector_product(ExecutionPolicy&amp;&amp; exec,
                                      InMat A, Triangle t, DiagonalStorage d,
                                      InVec1 x, InVec2 y, OutVec z);
 
// Solve a triangular linear system, not in place
template&lt;__in_matrix InMat, class Triangle, class DiagonalStorage,
         __in_vector InVec, __out_vector OutVec, class BinaryDivideOp&gt;
void triangular_matrix_vector_solve(InMat A, Triangle t, DiagonalStorage d,
                                    InVec b, OutVec x, BinaryDivideOp divide);
 
template&lt;class ExecutionPolicy,
         __in_matrix InMat, class Triangle, class DiagonalStorage,
         __in_vector InVec, __out_vector OutVec, class BinaryDivideOp&gt;
void triangular_matrix_vector_solve(ExecutionPolicy&amp;&amp; exec,
                                    InMat A, Triangle t, DiagonalStorage d,
                                    InVec b, OutVec x, BinaryDivideOp divide);
 
template&lt;__in_matrix InMat, class Triangle, class DiagonalStorage,
         __in_vector InVec, __out_vector OutVec&gt;
void triangular_matrix_vector_solve(InMat A, Triangle t, DiagonalStorage d,
                                    InVec b, OutVec x);
 
template&lt;class ExecutionPolicy,
         __in_matrix InMat, class Triangle, class DiagonalStorage,
         __in_vector InVec, __out_vector OutVec&gt;
void triangular_matrix_vector_solve(ExecutionPolicy&amp;&amp; exec,
                                    InMat A, Triangle t, DiagonalStorage d,
                                    InVec b, OutVec x);
 
// Solve a triangular linear system, in place
template&lt;__in_matrix InMat, class Triangle, class DiagonalStorage,
         __inout_vector InOutVec, class BinaryDivideOp&gt;
void triangular_matrix_vector_solve(InMat A, Triangle t, DiagonalStorage d,
                                    InOutVec b, BinaryDivideOp divide);
 
template&lt;class ExecutionPolicy,
         __in_matrix InMat, class Triangle, class DiagonalStorage,
         __inout_vector InOutVec, class BinaryDivideOp&gt;
void triangular_matrix_vector_solve(ExecutionPolicy&amp;&amp; exec,
                                    InMat A, Triangle t, DiagonalStorage d,
                                    InOutVec b, BinaryDivideOp divide);
 
template&lt;__in_matrix InMat, class Triangle, class DiagonalStorage,
         __inout_vector InOutVec&gt;
void triangular_matrix_vector_solve(InMat A, Triangle t, DiagonalStorage d,
                                    InOutVec b);
 
template&lt;class ExecutionPolicy,
         __in_matrix InMat, class Triangle, class DiagonalStorage,
         __inout_vector InOutVec&gt;
void triangular_matrix_vector_solve(ExecutionPolicy&amp;&amp; exec,
                                    InMat A, Triangle t, DiagonalStorage d,
                                    InOutVec b);
 
// nonconjugated rank-1 matrix update
template&lt;__in_vector InVec1, __in_vector InVec2, __inout_matrix InOutMat&gt;
void matrix_rank_1_update(InVec1 x, InVec2 y, InOutMat A);
 
template&lt;class ExecutionPolicy,
         __in_vector InVec1, __in_vector InVec2, __inout_matrix InOutMat&gt;
void matrix_rank_1_update(ExecutionPolicy&amp;&amp; exec,
                          InVec1 x, InVec2 y, InOutMat A);
 
// conjugated rank-1 matrix update
template&lt;__in_vector InVec1, __in_vector InVec2, __inout_matrix InOutMat&gt;
void matrix_rank_1_update_c(InVec1 x, InVec2 y, InOutMat A);
 
template&lt;class ExecutionPolicy, 
         __in_vector InVec1, __in_vector InVec2, __inout_matrix InOutMat&gt;
void matrix_rank_1_update_c(ExecutionPolicy&amp;&amp; exec,
                            InVec1 x, InVec2 y, InOutMat A);
 
// symmetric rank-1 matrix update
template&lt;__in_vector InVec, __possibly_packed_inout_matrix InOutMat,
         class Triangle&gt;
void symmetric_matrix_rank_1_update(InVec x, InOutMat A, Triangle t);
 
template&lt;class ExecutionPolicy,
         __in_vector InVec, __possibly_packed_inout_matrix InOutMat,
         class Triangle&gt;
void symmetric_matrix_rank_1_update(ExecutionPolicy&amp;&amp; exec,
                                    InVec x, InOutMat A, Triangle t);
 
template&lt;class Scalar, __in_vector InVec,
         __possibly_packed_inout_matrix InOutMat, class Triangle&gt;
void symmetric_matrix_rank_1_update(Scalar alpha, InVec x, InOutMat A,
                                    Triangle t);
 
template&lt;class ExecutionPolicy,
         class Scalar, __in_vector InVec,
         __possibly_packed_inout_matrix InOutMat, class Triangle&gt;
void symmetric_matrix_rank_1_update(ExecutionPolicy&amp;&amp; exec,
                                    Scalar alpha, InVec x, InOutMat A,
                                    Triangle t);
 
// Hermitian rank-1 matrix update
template&lt;__in_vector InVec, __possibly_packed_inout_matrix InOutMat,
         class Triangle&gt;
void hermitian_matrix_rank_1_update(InVec x, InOutMat A, Triangle t);
 
template&lt;class ExecutionPolicy,
         __in_vector InVec, __possibly_packed_inout_matrix InOutMat,
         class Triangle&gt;
void hermitian_matrix_rank_1_update(ExecutionPolicy&amp;&amp; exec,
                                    InVec x, InOutMat A, Triangle t);
 
template&lt;class Scalar, __in_vector InVec,
         __possibly_packed_inout_matrix InOutMat,
         class Triangle&gt;
void hermitian_matrix_rank_1_update(Scalar alpha, InVec x, InOutMat A,
                                    Triangle t);
 
template&lt;class ExecutionPolicy,
         class Scalar, __in_vector InVec,
         __possibly_packed_inout_matrix InOutMat,
         class Triangle&gt;
void hermitian_matrix_rank_1_update(ExecutionPolicy&amp;&amp; exec,
                                    Scalar alpha, InVec x, InOutMat A,
                                    Triangle t);
 
// symmetric rank-2 matrix update
template&lt;__in_vector InVec1, __in_vector InVec2,
         __possibly_packed_inout_matrix InOutMat,
         class Triangle&gt;
void symmetric_matrix_rank_2_update(InVec1 x, InVec2 y, InOutMat A,
                                    Triangle t);
 
template&lt;class ExecutionPolicy,
         __in_vector InVec1, __in_vector InVec2,
         __possibly_packed_inout_matrix InOutMat,
         class Triangle&gt;
void symmetric_matrix_rank_2_update(ExecutionPolicy&amp;&amp; exec,
                                    InVec1 x, InVec2 y, InOutMat A,
                                    Triangle t);
 
// Hermitian rank-2 matrix update
template&lt;__in_vector InVec1, __in_vector InVec2,
         __possibly_packed_inout_matrix InOutMat,
         class Triangle&gt;
void hermitian_matrix_rank_2_update(InVec1 x, InVec2 y, InOutMat A,
                                    Triangle t);
 
template&lt;class ExecutionPolicy,
         __in_vector InVec1, __in_vector InVec2,
         __possibly_packed_inout_matrix InOutMat,
         class Triangle&gt;
void hermitian_matrix_rank_2_update(ExecutionPolicy&amp;&amp; exec,
                                    InVec1 x, InVec2 y, InOutMat A,
                                    Triangle t);
 
// general matrix-matrix product
template&lt;__in_matrix InMat1, __in_matrix InMat2, __out_matrix OutMat&gt;
void matrix_product(InMat1 A, InMat2 B, OutMat C);
 
template&lt;class ExecutionPolicy,
         __in_matrix InMat1, __in_matrix InMat2, __out_matrix OutMat&gt;
void matrix_product(ExecutionPolicy&amp;&amp; exec, InMat1 A, InMat2 B, OutMat C);
 
template&lt;__in_matrix InMat1, __in_matrix InMat2, __in_matrix InMat3,
         __out_matrix OutMat&gt;
void matrix_product(InMat1 A, InMat2 B, InMat3 E, OutMat C);
 
template&lt;class ExecutionPolicy,
         __in_matrix InMat1, __in_matrix InMat2, __in_matrix InMat3,
         __out_matrix OutMat&gt;
void matrix_product(ExecutionPolicy&amp;&amp; exec,
                    InMat1 A, InMat2 B, InMat3 E, OutMat C);
 
 
// symmetric matrix-matrix product
// overwriting symmetric matrix-matrix left product
template&lt;__in_matrix InMat1, class Triangle,
         __in_matrix InMat2, __out_matrix OutMat&gt;
void symmetric_matrix_product(InMat1 A, Triangle t,
                              InMat2 B, OutMat C);
 
template&lt;class ExecutionPolicy,
         __in_matrix InMat1, class Triangle,
         __in_matrix InMat2, __out_matrix OutMat&gt;
void symmetric_matrix_product(ExecutionPolicy&amp;&amp; exec,
                              InMat1 A, Triangle t,
                              InMat2 B, OutMat C);
 
// overwriting symmetric matrix-matrix right product
template&lt;__in_matrix InMat1, __in_matrix InMat2,
         class Triangle, __out_matrix OutMat&gt;
void symmetric_matrix_product(InMat1 B, InMat2 A, Triangle t,
                              OutMat C);
 
template&lt;class ExecutionPolicy,
         __in_matrix InMat1, __in_matrix InMat2,
         class Triangle, __out_matrix OutMat&gt;
void symmetric_matrix_product(ExecutionPolicy&amp;&amp; exec,
                              InMat1 B, InMat2 A, Triangle t,
                              OutMat C);
 
// updating symmetric matrix-matrix left product
template&lt;__in_matrix InMat1, class Triangle,
         __in_matrix InMat2, __in_matrix InMat3,
         __out_matrix OutMat&gt;
void symmetric_matrix_product(InMat1 A, Triangle t,
                              InMat2 B, InMat3 E,
                              OutMat C);
 
template&lt;class ExecutionPolicy,
         __in_matrix InMat1, class Triangle,
         __in_matrix InMat2, __in_matrix InMat3,
         __out_matrix OutMat&gt;
void symmetric_matrix_product(ExecutionPolicy&amp;&amp; exec,
                              InMat1 A, Triangle t,
                              InMat2 B, InMat3 E,
                              OutMat C);
 
// updating symmetric matrix-matrix right product
template&lt;__in_matrix InMat1, __in_matrix InMat2, class Triangle,
         __in_matrix InMat3, __out_matrix OutMat&gt;
void symmetric_matrix_product(InMat1 B, InMat2 A, Triangle t,
                              InMat3 E, OutMat C);
 
template&lt;class ExecutionPolicy,
         __in_matrix InMat1, __in_matrix InMat2, class Triangle,
         __in_matrix InMat3, __out_matrix OutMat&gt;
void symmetric_matrix_product(ExecutionPolicy&amp;&amp; exec,
                              InMat1 B, InMat2 A, Triangle t,
                              InMat3 E, OutMat C);
 
// Hermitian matrix-matrix product
// overwriting Hermitian matrix-matrix left product
template&lt;__in_matrix InMat1, class Triangle,
         __in_matrix InMat2, __out_matrix OutMat&gt;
void hermitian_matrix_product(InMat1 A, Triangle t,
                              InMat2 B, OutMat C);
template&lt;class ExecutionPolicy,
         __in_matrix InMat1, class Triangle,
         __in_matrix InMat2, __out_matrix OutMat&gt;
void hermitian_matrix_product(ExecutionPolicy&amp;&amp; exec,
                              InMat1 A, Triangle t,
                              InMat2 B, OutMat C);
 
// overwriting Hermitian matrix-matrix right product
template&lt;__in_matrix InMat1, __in_matrix InMat2,
         class Triangle, __out_matrix OutMat&gt;
void hermitian_matrix_product(InMat1 B, InMat2 A, Triangle t,
                              OutMat C);
 
template&lt;class ExecutionPolicy,
         __in_matrix InMat1, __in_matrix InMat2,
         class Triangle, __out_matrix OutMat&gt;
void hermitian_matrix_product(ExecutionPolicy&amp;&amp; exec,
                              InMat1 B, InMat2 A, Triangle t,
                              OutMat C);
 
// updating Hermitian matrix-matrix left product
template&lt;__in_matrix InMat1, class Triangle,
         __in_matrix InMat2, __in_matrix InMat3, __out_matrix OutMat&gt;
void hermitian_matrix_product(InMat1 A, Triangle t,
                              InMat2 B, InMat3 E, OutMat C);
 
template&lt;class ExecutionPolicy,
         __in_matrix InMat1, class Triangle,
         __in_matrix InMat2, __in_matrix InMat3, __out_matrix OutMat&gt;
void hermitian_matrix_product(ExecutionPolicy&amp;&amp; exec,
                              InMat1 A, Triangle t,
                              InMat2 B, InMat3 E, OutMat C);
 
// updating Hermitian matrix-matrix right product
template&lt;__in_matrix InMat1, __in_matrix InMat2, class Triangle,
         __in_matrix InMat3, __out_matrix OutMat&gt;
void hermitian_matrix_product(InMat1 B, InMat2 A, Triangle t,
                              InMat3 E, OutMat C);
 
template&lt;class ExecutionPolicy,
         __in_matrix InMat1, __in_matrix InMat2, class Triangle,
         __in_matrix InMat3, __out_matrix OutMat&gt;
void hermitian_matrix_product(ExecutionPolicy&amp;&amp; exec,
                              InMat1 B, InMat2 A, Triangle t,
                              InMat3 E, OutMat C);
 
// triangular matrix-matrix product
// overwriting triangular matrix-matrix left product
template&lt;__in_matrix InMat1, class Triangle, class DiagonalStorage,
         __in_matrix InMat2, __out_matrix OutMat&gt;
void triangular_matrix_product(InMat1 A, Triangle t, DiagonalStorage d,
                               InMat2 B, OutMat C);
 
template&lt;class ExecutionPolicy,
         __in_matrix InMat1, class Triangle, class DiagonalStorage,
         __in_matrix InMat2, __out_matrix OutMat&gt;
void triangular_matrix_product(ExecutionPolicy&amp;&amp; exec,
                               InMat1 A, Triangle t, DiagonalStorage d,
                               InMat2 B, OutMat C);
 
template&lt;__in_matrix InMat1, class Triangle, class DiagonalStorage,
         __inout_matrix InOutMat&gt;
void triangular_matrix_left_product(InMat1 A, Triangle t, DiagonalStorage d,
                                    InOutMat C);
 
template&lt;class ExecutionPolicy,
         __in_matrix InMat1, class Triangle, class DiagonalStorage,
         __inout_matrix InOutMat&gt;
void triangular_matrix_left_product(ExecutionPolicy&amp;&amp; exec,
                                    InMat1 A, Triangle t, DiagonalStorage d,
                                    InOutMat C);
 
// overwriting triangular matrix-matrix right product
template&lt;__in_matrix InMat1, __in_matrix InMat2,
         class Triangle, class DiagonalStorage,
         __out_matrix OutMat&gt;
void triangular_matrix_product(InMat1 B, InMat2 A,
                               Triangle t, DiagonalStorage d,
                               OutMat C);
 
template&lt;class ExecutionPolicy,
         __in_matrix InMat1, __in_matrix InMat2,
         class Triangle, class DiagonalStorage,
         __out_matrix OutMat&gt;
void triangular_matrix_product(ExecutionPolicy&amp;&amp; exec,
                               InMat1 B, InMat2 A,
                               Triangle t, DiagonalStorage d,
                               OutMat C);
 
template&lt;__in_matrix InMat1, class Triangle, class DiagonalStorage,
         __inout_matrix InOutMat&gt;
void triangular_matrix_right_product(InMat1 A, Triangle t, DiagonalStorage d,
                                     InOutMat C);
 
template&lt;class ExecutionPolicy,
         __in_matrix InMat1, class Triangle, class DiagonalStorage,
         __inout_matrix InOutMat&gt;
void triangular_matrix_right_product(ExecutionPolicy&amp;&amp; exec,
                                     InMat1 A, Triangle t, DiagonalStorage d,
                                     InOutMat C);
 
// updating triangular matrix-matrix left product
template&lt;__in_matrix InMat1, class Triangle, class DiagonalStorage,
         __in_matrix InMat2, __in_matrix InMat3,
         __out_matrix OutMat&gt;
void triangular_matrix_product(InMat1 A, Triangle t, DiagonalStorage d,
                               InMat2 B, InMat3 E, OutMat C);
 
template&lt;class ExecutionPolicy,
         __in_matrix InMat1, class Triangle, class DiagonalStorage,
         __in_matrix InMat2, __in_matrix InMat3,
         __out_matrix OutMat&gt;
void triangular_matrix_product(ExecutionPolicy&amp;&amp; exec,
                               InMat1 A, Triangle t, DiagonalStorage d,
                               InMat2 B, InMat3 E, OutMat C);
 
// updating triangular matrix-matrix right product
template&lt;__in_matrix InMat1, __in_matrix InMat2,
         class Triangle, class DiagonalStorage,
         __in_matrix InMat3, __out_matrix OutMat&gt;
void triangular_matrix_product(InMat1 B, InMat2 A,
                               Triangle t, DiagonalStorage d,
                               InMat3 E, OutMat C);
 
template&lt;class ExecutionPolicy,
         __in_matrix InMat1, __in_matrix InMat2,
         class Triangle, class DiagonalStorage,
         __in_matrix InMat3, __out_matrix OutMat&gt;
void triangular_matrix_product(ExecutionPolicy&amp;&amp; exec,
                               InMat1 B, InMat2 A,
                               Triangle t, DiagonalStorage d,
                               InMat3 E, OutMat C);
 
// rank-k symmetric matrix update
template&lt;class Scalar, __in_matrix InMat1,
         __possibly_packed_inout_matrix InOutMat, class Triangle&gt;
void symmetric_matrix_rank_k_update(Scalar alpha, InMat1 A, InOutMat C,
                                    Triangle t);
 
template&lt;class Scalar,
         class ExecutionPolicy,
         ___in_matrix InMat1,
         __possibly_packed_inout_matrix InOutMat, class Triangle&gt;
void symmetric_matrix_rank_k_update(ExecutionPolicy&amp;&amp; exec,
                                    Scalar alpha, InMat1 A, InOutMat C,
                                    Triangle t);
 
template&lt;__in_matrix InMat1,
         __possibly_packed_inout_matrix InOutMat, class Triangle&gt;
void symmetric_matrix_rank_k_update(InMat1 A, InOutMat C, Triangle t);
 
template&lt;class ExecutionPolicy,
         __in_matrix InMat1,
         __possibly_packed_inout_matrix InOutMat, class Triangle&gt;
void symmetric_matrix_rank_k_update(ExecutionPolicy&amp;&amp; exec,
                                    InMat1 A, InOutMat C, Triangle t);
 
// rank-k Hermitian matrix update
template&lt;class Scalar, __in_matrix InMat1,
         __possibly_packed_inout_matrix InOutMat, class Triangle&gt;
void hermitian_matrix_rank_k_update(Scalar alpha, InMat1 A, InOutMat C,
                                    Triangle t);
 
template&lt;class ExecutionPolicy,
         class Scalar, __in_matrix InMat1,
         __possibly_packed_inout_matrix InOutMat, class Triangle
void hermitian_matrix_rank_k_update(ExecutionPolicy&amp;&amp; exec,
                                    Scalar alpha, InMat1 A, InOutMat C,
                                    Triangle t);
 
template&lt;__in_matrix InMat1,
         __possibly_packed_inout_matrix InOutMat, class Triangle&gt;
void hermitian_matrix_rank_k_update(InMat1 A, InOutMat C, Triangle t);
 
template&lt;class ExecutionPolicy,
         __in_matrix InMat1,
         __possibly_packed_inout_matrix InOutMat, class Triangle&gt;
void hermitian_matrix_rank_k_update(ExecutionPolicy&amp;&amp; exec,
                                    InMat1 A, InOutMat C, Triangle t);
 
// rank-2k symmetric matrix update
template&lt;__in_matrix InMat1, __in_matrix InMat2,
         __possibly_packed_inout_matrix InOutMat, class Triangle&gt;
void symmetric_matrix_rank_2k_update(InMat1 A, InMat2 B, InOutMat C,
                                     Triangle t);
 
template&lt;class ExecutionPolicy,
         __in_matrix InMat1, __in_matrix InMat2,
         __possibly_packed_inout_matrix InOutMat, class Triangle&gt;
void symmetric_matrix_rank_2k_update(ExecutionPolicy&amp;&amp; exec,
                                     InMat1 A, InMat2 B, InOutMat C,
                                     Triangle t);
 
// rank-2k Hermitian matrix update
template&lt;__in_matrix InMat1, __in_matrix InMat2,
         __possibly_packed_inout_matrix InOutMat, class Triangle&gt;
void hermitian_matrix_rank_2k_update(InMat1 A, InMat2 B, InOutMat C,
                                     Triangle t);
 
template&lt;class ExecutionPolicy,
         __in_matrix InMat1, __in_matrix InMat2,
         __possibly_packed_inout_matrix InOutMat, class Triangle&gt;
void hermitian_matrix_rank_2k_update(ExecutionPolicy&amp;&amp; exec,
                                     InMat1 A, InMat2 B, InOutMat C,
                                     Triangle t);
 
// solve multiple triangular linear systems
// with triangular matrix on the left
template&lt;__in_matrix InMat1, class Triangle, class DiagonalStorage,
         __in_matrix InMat2, __out_matrix OutMat, class BinaryDivideOp&gt;
void triangular_matrix_matrix_left_solve(InMat1 A,
                                         Triangle t, DiagonalStorage d,
                                         InMat2 B, OutMat X,
                                         BinaryDivideOp divide);
 
template&lt;class ExecutionPolicy,
         __in_matrix InMat1, class Triangle, class DiagonalStorage,
         __in_matrix InMat2, __out_matrix OutMat, class BinaryDivideOp&gt;
void triangular_matrix_matrix_left_solve(ExecutionPolicy&amp;&amp; exec,
                                         InMat1 A,
                                         Triangle t, DiagonalStorage d,
                                         InMat2 B, OutMat X,
                                         BinaryDivideOp divide);
 
template&lt;__in_matrix InMat1, class Triangle, class DiagonalStorage,
         __inout_matrix InOutMat, class BinaryDivideOp&gt;
void triangular_matrix_matrix_left_solve(InMat1 A, Triangle t, DiagonalStorage d,
                                         InOutMat B, BinaryDivideOp divide);
 
template&lt;class ExecutionPolicy,
         __in_matrix InMat1, class Triangle, class DiagonalStorage,
         __inout_matrix InOutMat, class BinaryDivideOp&gt;
void triangular_matrix_matrix_left_solve(ExecutionPolicy&amp;&amp; exec,
                                         InMat1 A, Triangle t, DiagonalStorage d,
                                         InOutMat B, BinaryDivideOp divide);
 
template&lt;__in_matrix InMat1, class Triangle, class DiagonalStorage,
         __in_matrix InMat2, __out_matrix OutMat&gt;
void triangular_matrix_matrix_left_solve(InMat1 A, Triangle t, DiagonalStorage d,
                                         InMat2 B, OutMat X);
 
template&lt;class ExecutionPolicy,
         __in_matrix InMat1, class Triangle, class DiagonalStorage,
         __in_matrix InMat2, __out_matrix OutMat&gt;
void triangular_matrix_matrix_left_solve(ExecutionPolicy&amp;&amp; exec,
                                         InMat1 A, Triangle t, DiagonalStorage d,
                                         InMat2 B, OutMat X);
 
template&lt;__in_matrix InMat1, class Triangle, class DiagonalStorage,
         __inout_matrix InOutMat&gt;
void triangular_matrix_matrix_left_solve(InMat1 A, Triangle t, DiagonalStorage d,
                                         InOutMat B);
 
template&lt;class ExecutionPolicy,
         __in_matrix InMat1, class Triangle, class DiagonalStorage,
         __inout_matrix InOutMat&gt;
void triangular_matrix_matrix_left_solve(ExecutionPolicy&amp;&amp; exec,
                                         InMat1 A, Triangle t, DiagonalStorage d,
                                         InOutMat B);
 
// solve multiple triangular linear systems
// with triangular matrix on the right
template&lt;__in_matrix InMat1, class Triangle, class DiagonalStorage,
         __in_matrix InMat2, __out_matrix OutMat, class BinaryDivideOp&gt;
void triangular_matrix_matrix_right_solve(InMat1 A, Triangle t, DiagonalStorage d,
                                          InMat2 B, OutMat X, BinaryDivideOp divide);
 
template&lt;class ExecutionPolicy,
         __in_matrix InMat1, class Triangle, class DiagonalStorage,
         __in_matrix InMat2, __out_matrix OutMat, class BinaryDivideOp&gt;
void triangular_matrix_matrix_right_solve(ExecutionPolicy&amp;&amp; exec,
                                          InMat1 A, Triangle t, DiagonalStorage d,
                                          InMat2 B, OutMat X, BinaryDivideOp divide);
 
template&lt;__in_matrix InMat1, class Triangle, class DiagonalStorage,
         __inout_matrix InOutMat, class BinaryDivideOp&gt;
void triangular_matrix_matrix_right_solve(InMat1 A, Triangle t, DiagonalStorage d,
                                          InOutMat B, BinaryDivideOp divide);
 
template&lt;class ExecutionPolicy,
         __in_matrix InMat1, class Triangle, class DiagonalStorage,
         __inout_matrix InOutMat, class BinaryDivideOp&gt;
void triangular_matrix_matrix_right_solve(ExecutionPolicy&amp;&amp; exec,
                                          InMat1 A, Triangle t, DiagonalStorage d,
                                          InOutMat B, BinaryDivideOp divide));
 
template&lt;__in_matrix InMat1, class Triangle, class DiagonalStorage,
         __in_matrix InMat2, __out_matrix OutMat&gt;
void triangular_matrix_matrix_right_solve(InMat1 A, Triangle t, DiagonalStorage d,
                                          InMat2 B, OutMat X);
 
template&lt;class ExecutionPolicy,
         __in_matrix InMat1, class Triangle, class DiagonalStorage,
         __in_matrix InMat2, __out_matrix OutMat&gt;
void triangular_matrix_matrix_right_solve(ExecutionPolicy&amp;&amp; exec,
                                          InMat1 A, Triangle t, DiagonalStorage d,
                                          InMat2 B, OutMat X);
 
template&lt;__in_matrix InMat1, class Triangle, class DiagonalStorage,
         __inout_matrix InOutMat&gt;
void triangular_matrix_matrix_right_solve(InMat1 A, Triangle t, DiagonalStorage d,
                                          InOutMat B);
 
template&lt;class ExecutionPolicy,
         __in_matrix InMat1, class Triangle, class DiagonalStorage,
         __inout_matrix InOutMat&gt;
void triangular_matrix_matrix_right_solve(ExecutionPolicy&amp;&amp; exec,
                                          InMat1 A, Triangle t, DiagonalStorage d,
                                          InOutMat B);
}</pre></div> <h4 id="Tags_2"> Tags</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::linalg {
  struct column_major_t {
    explicit column_major_t() = default;
  };
  inline constexpr column_major_t column_major = { };
 
  struct row_major_t {
    explicit row_major_t() = default;
  };
  inline constexpr row_major_t row_major = { };
 
  struct upper_triangle_t {
    explicit upper_triangle_t() = default;
  };
  inline constexpr upper_triangle_t upper_triangle = { };
 
  struct lower_triangle_t {
    explicit lower_triangle_t() = default;
  };
  inline constexpr lower_triangle_t lower_triangle = { };
 
  struct implicit_unit_diagonal_t {
    explicit implicit_unit_diagonal_t() = default;
  };
  inline constexpr implicit_unit_diagonal_t implicit_unit_diagonal = { };
 
  struct explicit_diagonal_t {
    explicit explicit_diagonal_t() = default;
  };
  inline constexpr explicit_diagonal_t explicit_diagonal = { };
}</pre></div> <h4 id="Class_template_std::linalg::layout_blas_packed"> Class template <code>std::linalg::layout_blas_packed</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::linalg {
  template&lt;class Triangle, class StorageOrder&gt;
  class layout_blas_packed {
   public:
    using triangle_type = Triangle;
    using storage_order_type = StorageOrder;
 
    template&lt;class Extents&gt;
    struct mapping {
     public:
      using extents_type = Extents;
      using index_type = typename extents_type::index_type;
      using size_type = typename extents_type::size_type;
      using rank_type = typename extents_type::rank_type;
      using layout_type = layout_blas_packed&lt;Triangle, StorageOrder&gt;;
 
     private:
      Extents __the_extents{}; // exposition only
 
     public:
      constexpr mapping() noexcept = default;
      constexpr mapping(const mapping&amp;) noexcept = default;
      constexpr mapping(const extents_type&amp; e) noexcept;
      template&lt;class OtherExtents&gt;
      constexpr explicit(!is_convertible_v&lt;OtherExtents, extents_type&gt;)
      mapping(const mapping&lt;OtherExtents&gt;&amp; other) noexcept;
 
      constexpr mapping&amp; operator=(const mapping&amp;) noexcept = default;
 
      constexpr extents_type extents() const noexcept { return __the_extents; }
 
      constexpr size_type required_span_size() const noexcept;
 
      template&lt;class Index0, class Index1&gt;
      constexpr index_type operator() (Index0 ind0, Index1 ind1) const noexcept;
 
      static constexpr bool is_always_unique() {
        return (extents_type::static_extent(0) != dynamic_extent &amp;&amp;
                extents_type::static_extent(0) &lt; 2) ||
               (extents_type::static_extent(1) != dynamic_extent &amp;&amp;
                extents_type::static_extent(1) &lt; 2);
      }
      static constexpr bool is_always_exhaustive() { return true; }
      static constexpr bool is_always_strided() {
        return is_always_unique();
      }
 
      constexpr bool is_unique() const noexcept {
        return __the_extents.extent(0) &lt; 2;
      }
      constexpr bool is_exhaustive() const noexcept { return true; }
      constexpr bool is_strided() const noexcept {
        return __the_extents.extent(0) &lt; 2;
      }
 
      constexpr index_type stride(rank_type) const noexcept;
 
      template&lt;class OtherExtents&gt;
      friend constexpr bool
      operator==(const mapping&amp;, const mapping&lt;OtherExtents&gt;&amp;) noexcept;
 
    };
  };
}</pre></div> <h4 id="Class_template_std::linalg::scaled_accessor"> Class template <code>std::linalg::scaled_accessor</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::linalg {
  template&lt;class ScalingFactor, class NestedAccessor&gt;
  class scaled_accessor {
   public:
    using element_type = 
      add_const_t&lt;decltype(declval&lt;ScalingFactor&gt;() * 
                           declval&lt;NestedAccessor::element_type&gt;())&gt;;
    using reference = remove_const_t&lt;element_type&gt;;
    using data_handle_type = NestedAccessor::data_handle_type;
    using offset_policy = scaled_accessor&lt;ScalingFactor, NestedAccessor::offset_policy&gt;;
 
    constexpr scaled_accessor() = default;
    template&lt;class OtherNestedAccessor&gt;
      explicit(!is_convertible_v&lt;OtherNestedAccessor, NestedAccessor&gt;)
    constexpr scaled_accessor(const scaled_accessor&lt;ScalingFactor, OtherNestedAccessor&gt;&amp;);
    constexpr scaled_accessor(const ScalingFactor&amp; s, const Accessor&amp; a);
 
    constexpr reference access(data_handle_type p, size_t i) const noexcept;
    constexpr 
      offset_policy::data_handle_type offset(data_handle_type p, size_t i) const noexcept;
 
    constexpr const ScalingFactor&amp; scaling_factor() const noexcept 
      { return __scaling_factor; } 
    constexpr const NestedAccessor&amp; nested_accessor() const noexcept
      { return __nested_accessor; }
 
   private:
    ScalingFactor __scaling_factor; // exposition only
    NestedAccessor __nested_accessor; // exposition only
  };
}</pre></div> <h4 id="Class_template_std::linalg::conjugated_accessor"> Class template <code>std::linalg::conjugated_accessor</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::linalg {
  template&lt;class NestedAccessor&gt;
  class conjugated_accessor {
   private:
    NestedAccessor __nested_accessor; // exposition only
 
   public:
    using element_type =
      add_const_t&lt;decltype(/*conj-if-needed*/(declval&lt;NestedAccessor::element_type&gt;()))&gt;;
    using reference = remove_const_t&lt;element_type&gt;;
    using data_handle_type = typename NestedAccessor::data_handle_type;
    using offset_policy = conjugated_accessor&lt;NestedAccessor::offset_policy&gt;;
 
    constexpr conjugated_accessor() = default;
    template&lt;class OtherNestedAccessor&gt;
      explicit(!is_convertible_v&lt;OtherNestedAccessor, NestedAccessor&gt;)
      constexpr conjugated_accessor(const conjugated_accessor&lt;OtherNestedAccessor&gt;&amp; other);
 
    constexpr reference access(data_handle_type p, size_t i) const;
 
    constexpr typename offset_policy::data_handle_type
      offset(data_handle_type p, size_t i) const;
 
    constexpr const NestedAccessor&amp; nested_accessor() const noexcept
      { return __nested_accessor; }
  };
}</pre></div> <h4 id="Class_template_std::linalg::layout_transpose"> Class template <code>std::linalg::layout_transpose</code>
</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::linalg {
  template&lt;class InputExtents&gt;
  using __transpose_extents_t = /* see description */; // exposition only
 
  template&lt;class Layout&gt;
  class layout_transpose {
   public:
    using nested_layout_type = Layout;
 
    template&lt;class Extents&gt;
    struct mapping {
     private:
      using __nested_mapping_type =
        typename Layout::template mapping&lt;
          __transpose_extents_t&lt;Extents&gt;&gt;;    // exposition only
 
      __nested_mapping_type __nested_mapping; // exposition only
        extents_type __extents;               // exposition only
 
     public:
      using extents_type = Extents;
      using index_type = typename extents_type::index_type;
      using size_type = typename extents_type::size_type;
      using rank_type = typename extents_type::rank_type;
      using layout_type = layout_transpose;
 
      constexpr explicit mapping(const __nested_mapping_type&amp; map);
 
      constexpr const extents_type&amp; extents() const noexcept { return __extents; }
 
      constexpr index_type required_span_size() const
        { return __nested_mapping.required_span_size(); }
 
      template&lt;class Index0, class Index1&gt;
        constexpr index_type operator()(Index0 ind0, Index1 ind1) const
        { return __nested_mapping(ind1, ind0); }
 
      constexpr const __nested_mapping_type&amp; nested_mapping() const noexcept
        { return __nested_mapping; }
 
      static constexpr bool is_always_unique() noexcept
        { return __nested_mapping_type::is_always_unique(); }
      static constexpr bool is_always_exhaustive() noexcept
        { return __nested_mapping_type::is_always_exhaustive(); }
      static constexpr bool is_always_strided() noexcept
        { return __nested_mapping_type::is_always_strided(); }
 
      constexpr bool is_unique() const 
        { return __nested_mapping.is_unique(); }
      constexpr bool is_exhaustive() const 
        { return __nested_mapping.is_exhaustive(); }
      constexpr bool is_strided() const 
        { return __nested_mapping.is_strided(); }
 
      constexpr index_type stride(size_t r) const;
 
      template&lt;class OtherExtents&gt;
      friend constexpr bool
        operator==(const mapping&amp; x, const mapping&lt;OtherExtents&gt;&amp; y);
    };
  };
}</pre></div> <h4 id="Helper_concepts_and_traits"> Helper concepts and traits</h4> <div class="cpp source-cpp"><pre data-language="cpp">namespace std::linalg {
  template&lt;class T&gt;
  struct __is_mdspan : false_type {}; // exposition only
 
  template&lt;class ElementType, class Extents, class Layout, class Accessor&gt;
  struct __is_mdspan&lt;mdspan&lt;ElementType, Extents, Layout, Accessor&gt;&gt;
  : true_type {}; // exposition only
 
  template&lt;class T&gt;
  concept __in_vector = // exposition only
    __is_mdspan&lt;T&gt;::value &amp;&amp;
    T::rank() == 1;
 
  template&lt;class T&gt;
  concept __out_vector = // exposition only
    __is_mdspan&lt;T&gt;::value &amp;&amp;
    T::rank() == 1 &amp;&amp;
    is_assignable_v&lt;typename T::reference, typename T::element_type&gt; &amp;&amp;
    T::is_always_unique();
 
  template&lt;class T&gt;
  concept __inout_vector = // exposition only
    __is_mdspan&lt;T&gt;::value &amp;&amp;
    T::rank() == 1 &amp;&amp;
    is_assignable_v&lt;typename T::reference, typename T::element_type&gt; &amp;&amp;
    T::is_always_unique();
 
  template&lt;class T&gt;
  concept __in_matrix = // exposition only
    __is_mdspan&lt;T&gt;::value &amp;&amp;
    T::rank() == 2;
 
  template&lt;class T&gt;
  concept __out_matrix = // exposition only
    __is_mdspan&lt;T&gt;::value &amp;&amp;
    T::rank() == 2 &amp;&amp;
    is_assignable_v&lt;typename T::reference, typename T::element_type&gt; &amp;&amp;
   T::is_always_unique();
 
  template&lt;class T&gt;
  concept __inout_matrix = // exposition only
    __is_mdspan&lt;T&gt;::value &amp;&amp;
    T::rank() == 2 &amp;&amp;
    is_assignable_v&lt;typename T::reference, typename T::element_type&gt; &amp;&amp;
    T::is_always_unique();
 
  template&lt;class T&gt;
  concept __possibly_packed_inout_matrix = // exposition only
    __is_mdspan&lt;T&gt;::value &amp;&amp;
    T::rank() == 2 &amp;&amp;
    is_assignable_v&lt;typename T::reference, typename T::element_type&gt; &amp;&amp;
    (T::is_always_unique() || is_same_v&lt;typename T::layout_type, layout_blas_packed&gt;);
 
  template&lt;class T&gt;
  concept __in_object = // exposition only
    __is_mdspan&lt;T&gt;::value &amp;&amp;
    (T::rank() == 1 || T::rank() == 2);
 
  template&lt;class T&gt;
  concept __out_object = // exposition only
    __is_mdspan&lt;T&gt;::value &amp;&amp;
    (T::rank() == 1 || T::rank() == 2) &amp;&amp;
    is_assignable_v&lt;typename T::reference, typename T::element_type&gt; &amp;&amp;
    T::is_always_unique();
 
  template&lt;class T&gt;
  concept __inout_object = // exposition only
    __is_mdspan&lt;T&gt;::value &amp;&amp;
    (T::rank() == 1 || T::rank() == 2) &amp;&amp;
    is_assignable_v&lt;typename T::reference, typename T::element_type&gt; &amp;&amp;
    T::is_always_unique();
}</pre></div>           <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/header/linalg" class="_attribution-link">https://en.cppreference.com/w/cpp/header/linalg</a>
  </p>
</div>
