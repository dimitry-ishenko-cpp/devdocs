    <h1 id="firstHeading" class="firstHeading">std::atomic<small>&lt;std::shared_ptr&gt;</small>
</h1>            <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th> Defined in header <code><a href="../../header/memory.html" title="cpp/header/memory">&lt;memory&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">template&lt; class T &gt;
struct std::atomic&lt;std::shared_ptr&lt;T&gt;&gt;;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td> </tr>  </table> <p>The partial template specialization of <code><a href="../../atomic/atomic.html" title="cpp/atomic/atomic">std::atomic</a></code> for <code><a href="http://en.cppreference.com/w/cpp/memory/shared_ptr"><span class="kw736">std::<span class="me2">shared_ptr</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span></code> allows users to manipulate <code>shared_ptr</code> objects atomically.</p>
<p>If multiple threads of execution access the same <code><a href="../shared_ptr.html" title="cpp/memory/shared ptr">std::shared_ptr</a></code> object without synchronization and any of those accesses uses a non-const member function of <code>shared_ptr</code> then a data race will occur unless all such access is performed through an instance of <code><a href="http://en.cppreference.com/w/cpp/atomic/atomic"><span class="kw2070">std::<span class="me2">atomic</span></span></a><span class="sy1">&lt;</span><a href="http://en.cppreference.com/w/cpp/memory/shared_ptr"><span class="kw736">std::<span class="me2">shared_ptr</span></span></a><span class="sy1">&gt;</span></code> (or, deprecated as of C++20, through the <a href="atomic.html" title="cpp/memory/shared ptr/atomic">standalone functions</a> for atomic access to <code><a href="../shared_ptr.html" title="cpp/memory/shared ptr">std::shared_ptr</a></code>).</p>
<p>Associated <code>use_count</code> increments are guaranteed to be part of the atomic operation. Associated <code>use_count</code> decrements are sequenced after the atomic operation, but are not required to be part of it, except for the <code>use_count</code> change when overriding <code>expected</code> in a failed CAS. Any associated deletion and deallocation are sequenced after the atomic update step and are not part of the atomic operation.</p>
<p>Note that the control block of a <code>shared_ptr</code> is thread-safe: different non-atomic <code><a href="../shared_ptr.html" title="cpp/memory/shared ptr">std::shared_ptr</a></code> objects can be accessed using mutable operations, such as <code>operator=</code> or <code>reset</code>, simultaneously by multiple threads, even when these instances are copies, and share the same control block internally.</p>
<p>The type T may be an incomplete type.</p>
<h3 id="Member_types"> Member types</h3> <table class="t-dsc-begin"> <tr class="t-dsc-hitem"> <th> Member type </th> <th> Definition </th>
</tr> <tr class="t-dsc"> <td> <code>value_type</code> </td> <td> <code><a href="http://en.cppreference.com/w/cpp/memory/shared_ptr"><span class="kw736">std::<span class="me2">shared_ptr</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span></code> </td>
</tr> </table> <h3 id="Member_functions"> Member functions</h3> <p>All non-specialized <code><a href="../../atomic/atomic.html" title="cpp/atomic/atomic">std::atomic</a></code> functions are also provided by this specialization, and no additional member functions.</p>
<div class="t-member"> <h2 id="atomic.3Cshared_ptr.3CT.3E.3E::atomic"> atomic&lt;shared_ptr&lt;T&gt;&gt;::atomic</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td> <pre data-language="cpp">constexpr atomic() noexcept = default;</pre>
</td> <td> (1) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">constexpr atomic( std::nullptr_t ) noexcept : atomic() {}</pre>
</td> <td> (2) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">atomic( std::shared_ptr&lt;T&gt; desired ) noexcept;</pre>
</td> <td> (3) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">atomic( const atomic&amp; ) = delete;</pre>
</td> <td> (4) </td> <td class="t-dcl-nopad"> </td> </tr>  </table> <div class="t-li1">
<span class="t-li">1,2)</span> Initializes the underlying <code>shared_ptr&lt;T&gt;</code> to the null value.</div> <div class="t-li1">
<span class="t-li">3)</span> Initializes the underlying <code>shared_ptr&lt;T&gt;</code> to a copy of <code>desired</code>. As with any <code><a href="../../atomic/atomic.html" title="cpp/atomic/atomic">std::atomic</a></code> type, initialization is not an atomic operation.</div> <div class="t-li1">
<span class="t-li">4)</span> Atomic types are not copy/move constructible. </div>
</div> <div class="t-member"> <h2 id="atomic.3Cshared_ptr.3CT.3E.3E::operator.3D"> atomic&lt;shared_ptr&lt;T&gt;&gt;::operator=</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td> <pre data-language="cpp">void operator=( const atomic&amp; ) = delete;</pre>
</td> <td> (1) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">void operator=( std::shared_ptr&lt;T&gt; desired ) noexcept;</pre>
</td> <td> (2) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">void operator=( std::nullptr_t ) noexcept;</pre>
</td> <td> (3) </td> <td class="t-dcl-nopad"> </td> </tr>  </table> <div class="t-li1">
<span class="t-li">1)</span> Atomic types are not copy/move assignable.</div> <div class="t-li1">
<span class="t-li">2)</span> Value assignment, equivalent to <code>store(desired)</code>.</div> <div class="t-li1">
<span class="t-li">3)</span> Resets the atomic shared pointer to null pointer value. Equivalent to <code>store(nullptr);</code>. </div>
</div> <div class="t-member"> <h2 id="atomic.3Cshared_ptr.3CT.3E.3E::is_lock_free"> atomic&lt;shared_ptr&lt;T&gt;&gt;::is_lock_free</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">bool is_lock_free() const noexcept;</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr>  </table> <p>Returns <code>true</code> if the atomic operations on all objects of this type are lock-free, <code>false</code> otherwise.</p>
</div> <div class="t-member"> <h2 id="atomic.3Cshared_ptr.3CT.3E.3E::store"> atomic&lt;shared_ptr&lt;T&gt;&gt;::store</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">void store( std::shared_ptr&lt;T&gt; desired,
            std::memory_order order = std::memory_order_seq_cst ) noexcept;</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr>  </table> <p>Atomically replaces the value of <code>*this</code> with the value of <code>desired</code> as if by <code>p.swap(desired)</code> where <code>p</code> is the underlying <code><a href="http://en.cppreference.com/w/cpp/memory/shared_ptr"><span class="kw736">std::<span class="me2">shared_ptr</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span></code>. Memory is ordered according to <code>order</code>. The behavior is undefined if <code>order</code> is <code><a href="../../atomic/memory_order.html" title="cpp/atomic/memory order">std::memory_order_consume</a></code>, <code><a href="../../atomic/memory_order.html" title="cpp/atomic/memory order">std::memory_order_acquire</a></code>, or <code><a href="../../atomic/memory_order.html" title="cpp/atomic/memory order">std::memory_order_acq_rel</a></code>.</p>
</div> <div class="t-member"> <h2 id="atomic.3Cshared_ptr.3CT.3E.3E::load"> atomic&lt;shared_ptr&lt;T&gt;&gt;::load</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">std::shared_ptr&lt;T&gt; load( std::memory_order order = std::memory_order_seq_cst ) const noexcept;</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr>  </table> <p>Atomically returns a copy of the underlying shared pointer. Memory is ordered according to <code>order</code>. The behavior is undefined if <code>order</code> is <code><a href="../../atomic/memory_order.html" title="cpp/atomic/memory order">std::memory_order_release</a></code> or <code><a href="../../atomic/memory_order.html" title="cpp/atomic/memory order">std::memory_order_acq_rel</a></code>.</p>
</div> <div class="t-member"> <h2 id="atomic.3Cshared_ptr.3CT.3E.3E::operator_std::shared_ptr.3CT.3E"> atomic&lt;shared_ptr&lt;T&gt;&gt;::operator std::shared_ptr&lt;T&gt;</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">operator std::shared_ptr&lt;T&gt;() const noexcept;</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr>  </table> <p>Equivalent to <code>return load();</code>.</p>
</div> <div class="t-member"> <h2 id="atomic.3Cshared_ptr.3CT.3E.3E::exchange"> atomic&lt;shared_ptr&lt;T&gt;&gt;::exchange</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">std::shared_ptr&lt;T&gt; exchange( std::shared_ptr&lt;T&gt; desired,
                             std::memory_order order = std::memory_order_seq_cst ) noexcept;</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr>  </table> <p>Atomically replaces the underlying <code><a href="http://en.cppreference.com/w/cpp/memory/shared_ptr"><span class="kw736">std::<span class="me2">shared_ptr</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span></code> with <code>desired</code> as if by <code>p.swap(desired)</code> where <code>p</code> is the underlying <code><a href="http://en.cppreference.com/w/cpp/memory/shared_ptr"><span class="kw736">std::<span class="me2">shared_ptr</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span></code> and returns a copy of the value that <code>p</code> had immediately before the swap. Memory is ordered according to <code>order</code>. This is an atomic read-modify-write operation.</p>
</div> <div class="t-member"> <h2 id="atomic.3Cshared_ptr.3CT.3E.3E::compare_exchange_weak.2C_compare_exchange_strong"> atomic&lt;shared_ptr&lt;T&gt;&gt;::compare_exchange_weak, compare_exchange_strong</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td> <pre data-language="cpp">bool compare_exchange_strong( std::shared_ptr&lt;T&gt;&amp; expected, std::shared_ptr&lt;T&gt; desired,
                              std::memory_order success, std::memory_order failure ) noexcept;</pre>
</td> <td> (1) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">bool compare_exchange_weak( std::shared_ptr&lt;T&gt;&amp; expected, std::shared_ptr&lt;T&gt; desired,
                            std::memory_order success, std::memory_order failure ) noexcept;</pre>
</td> <td> (2) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">bool compare_exchange_strong( std::shared_ptr&lt;T&gt;&amp; expected, std::shared_ptr&lt;T&gt; desired,
                              std::memory_order order = std::memory_order_seq_cst ) noexcept;</pre>
</td> <td> (3) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">bool compare_exchange_weak( std::shared_ptr&lt;T&gt;&amp; expected, std::shared_ptr&lt;T&gt; desired,
                            std::memory_order order = std::memory_order_seq_cst ) noexcept;</pre>
</td> <td> (4) </td> <td class="t-dcl-nopad"> </td> </tr>  </table> <div class="t-li1">
<span class="t-li">1)</span> If the underlying <code><a href="http://en.cppreference.com/w/cpp/memory/shared_ptr"><span class="kw736">std::<span class="me2">shared_ptr</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span></code> stores the same <code>T*</code> as <code>expected</code> and shares ownership with it, or if both underlying and <code>expected</code> are empty, assigns from <code>desired</code> to the underlying <code><a href="http://en.cppreference.com/w/cpp/memory/shared_ptr"><span class="kw736">std::<span class="me2">shared_ptr</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span></code>, returns <code>true</code>, and orders memory according to <code>success</code>, otherwise assigns from the underlying <code><a href="http://en.cppreference.com/w/cpp/memory/shared_ptr"><span class="kw736">std::<span class="me2">shared_ptr</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span></code> to <code>expected</code>, returns <code>false</code>, and orders memory according to <code>failure</code>. The behavior is undefined if <code>failure</code> is <code><a href="../../atomic/memory_order.html" title="cpp/atomic/memory order">std::memory_order_release</a></code> or <code><a href="../../atomic/memory_order.html" title="cpp/atomic/memory order">std::memory_order_acq_rel</a></code>. On success, the operation is an atomic read-modify-write operation on <code>*this</code> and <code>expected</code> is not accessed after the atomic update. On failure, the operation is an atomic load operation on <code>*this</code> and <code>expected</code> is updated with the existing value read from the atomic object. This update to <code>expected</code>'s <code>use_count</code> is part of this atomic operation, although the write itself (and any subsequent deallocation/destruction) is not required to be.</div> <div class="t-li1">
<span class="t-li">2)</span> Same as <span class="t-v">(1)</span>, but may also fail spuriously.</div> <div class="t-li1">
<span class="t-li">3)</span> Equivalent to: <code>return compare_exchange_strong(expected, desired, order, fail_order);</code>, where <code>fail_order</code> is the same as <code>order</code> except that <code><a href="../../atomic/memory_order.html" title="cpp/atomic/memory order">std::memory_order_acq_rel</a></code> is replaced by <code><a href="../../atomic/memory_order.html" title="cpp/atomic/memory order">std::memory_order_acquire</a></code> and <code><a href="../../atomic/memory_order.html" title="cpp/atomic/memory order">std::memory_order_release</a></code> is replaced by <code><a href="../../atomic/memory_order.html" title="cpp/atomic/memory order">std::memory_order_relaxed</a></code>.</div> <div class="t-li1">
<span class="t-li">4)</span> Equivalent to: <code>return compare_exchange_weak(expected, desired, order, fail_order);</code>, where <code>fail_order</code> is the same as <code>order</code> except that <code><a href="../../atomic/memory_order.html" title="cpp/atomic/memory order">std::memory_order_acq_rel</a></code> is replaced by <code><a href="../../atomic/memory_order.html" title="cpp/atomic/memory order">std::memory_order_acquire</a></code> and <code><a href="../../atomic/memory_order.html" title="cpp/atomic/memory order">std::memory_order_release</a></code> is replaced by <code><a href="../../atomic/memory_order.html" title="cpp/atomic/memory order">std::memory_order_relaxed</a></code>. </div>
</div> <div class="t-member"> <h2 id="atomic.3Cshared_ptr.3CT.3E.3E::wait"> atomic&lt;shared_ptr&lt;T&gt;&gt;::wait</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">void wait( std::shared_ptr&lt;T&gt; old,
           std::memory_order order = std::memory_order_seq_cst ) const noexcept;</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr>  </table> <p>Performs an atomic waiting operation.</p>
<p>Compares <code>load(order)</code> with <code>old</code> and if they are equivalent then blocks until <code>*this</code> is notified by <code>notify_one()</code> or <code>notify_all()</code>. This is repeated until <code>load(order)</code> changes. This function is guaranteed to return only if value has changed, even if underlying implementation unblocks spuriously.</p>
<p>Memory is ordered according to <code>order</code>. The behavior is undefined if <code>order</code> is <code><a href="../../atomic/memory_order.html" title="cpp/atomic/memory order">std::memory_order_release</a></code> or <code><a href="../../atomic/memory_order.html" title="cpp/atomic/memory order">std::memory_order_acq_rel</a></code>.</p>
<p>Notes: two <code>shared_ptr</code>s are equivalent if they store the same pointer and either share ownership or are both empty.</p>
</div> <div class="t-member"> <h2 id="atomic.3Cshared_ptr.3CT.3E.3E::notify_one"> atomic&lt;shared_ptr&lt;T&gt;&gt;::notify_one</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">void notify_one() noexcept;</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr>  </table> <p>Performs an atomic notifying operation.</p>
<p>If there is a thread blocked in atomic waiting operations (i.e. <code>wait()</code>) on <code>*this</code>, then unblocks at least one such thread; otherwise does nothing.</p>
</div> <div class="t-member"> <h2 id="atomic.3Cshared_ptr.3CT.3E.3E::notify_all"> atomic&lt;shared_ptr&lt;T&gt;&gt;::notify_all</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">void notify_all() noexcept;</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr>  </table> <p>Performs an atomic notifying operation.</p>
<p>Unblocks all threads blocked in atomic waiting operations (i.e. <code>wait()</code>) on <code>*this</code>, if there are any; otherwise does nothing.</p>
</div> <h3 id="Member_constants"> Member constants</h3> <p>The only standard <code><a href="../../atomic/atomic.html" title="cpp/atomic/atomic">std::atomic</a></code> member constant <code>is_always_lock_free</code> is also provided by this specialization.</p>
<div class="t-member"> <h2 id="atomic.3Cshared_ptr.3CT.3E.3E::is_always_lock_free"> atomic&lt;shared_ptr&lt;T&gt;&gt;::is_always_lock_free</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">static constexpr bool is_always_lock_free = /*implementation-defined*/;</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr>  </table> </div> <h3 id="Notes"> Notes</h3> <table class="wikitable ftm-begin ftm-has-value"> <tr> <th>
<a href="../../utility/feature_test.html" title="cpp/utility/feature test">Feature-test</a> macro</th> <th>Value</th> <th><span title="Standard in which the feature is introduced">Std</span></th> <th>Feature </th>
</tr> <tr> <td><a href="../../feature_test.html#cpp_lib_atomic_shared_ptr" title="cpp/feature test"><code>__cpp_lib_atomic_shared_ptr</code></a></td> <td><span class="nu0">201711L</span></td> <td><span class="t-mark">(C++20)</span></td> <td>
<a href="#top"><code>std::atomic&lt;std::shared_ptr&gt;</code></a> </td>
</tr>
</table> <h3 id="Example"> Example</h3>  <h3 id="Defect_reports"> Defect reports</h3> <p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.</p>
<table class="dsctable"> <tr> <th>DR </th> <th>Applied to </th> <th>Behavior as published </th> <th>Correct behavior </th>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/LWG/issue3661">LWG 3661</a> </td> <td>C++20 </td> <td>
<code>atomic&lt;shared_ptr&lt;T&gt;&gt;</code> was not constant-initializable from <code>nullptr</code> </td> <td>made constant-initializable </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/LWG/issue3893">LWG 3893</a> </td> <td>C++20 </td> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/LWG/issue3661">LWG3661</a> made <code>atomic&lt;shared_ptr&lt;T&gt;&gt;</code> not assignable from <code>nullptr_t</code> </td> <td>assignability restored </td>
</tr>
</table> <h3 id="See_also"> See also</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../../atomic/atomic.html" title="cpp/atomic/atomic"> <span class="t-lines"><span>atomic</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> atomic class template and specializations for bool, integral,<span class="t-rev-inl t-since-cxx20"><span> floating-point,</span><span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span> and pointer types <br> <span class="t-mark">(class template)</span>  </td>
</tr> </table>           <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/memory/shared_ptr/atomic2" class="_attribution-link">https://en.cppreference.com/w/cpp/memory/shared_ptr/atomic2</a>
  </p>
</div>
