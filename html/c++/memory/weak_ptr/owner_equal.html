    <h1 id="firstHeading" class="firstHeading">std::weak_ptr&lt;T&gt;::owner_equal</h1>             <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx26"> <td> <pre data-language="cpp">template&lt; class Y &gt; 
bool owner_equal( const std::weak_ptr&lt;Y&gt;&amp; other ) const noexcept;</pre>
</td> <td> (1) </td> <td> <span class="t-mark-rev t-since-cxx26">(since C++26)</span> </td> </tr> <tr class="t-dcl t-since-cxx26"> <td> <pre data-language="cpp">template&lt; class Y &gt;
bool owner_equal( const std::shared_ptr&lt;Y&gt;&amp; other ) const noexcept;</pre>
</td> <td> (2) </td> <td> <span class="t-mark-rev t-since-cxx26">(since C++26)</span> </td> </tr>  </table> <p>Checks whether this <code>weak_ptr</code> and <code>other</code> share ownership or are both empty. The comparison is such that two smart pointers compare equivalent only if they are both empty or if they both own the same object, even if the values of the pointers obtained by <code>get()</code> are different (e.g. because they point at different subobjects within the same object).</p>
<p>The member function <code>owner_equal</code> is an equivalence relation such that <code>!owner_before(other) &amp;&amp; !other.owner_before(*this)</code> is <code>true</code> if and only if <code>owner_equal(other)</code> is <code>true</code>.</p>
<p>This ordering is used to make shared and weak pointers usable as keys in unordered associative containers, typically through <code>std::owner_equal</code>.</p>
<h3 id="Parameters"> Parameters</h3> <table class="t-par-begin"> <tr class="t-par"> <td> other </td> <td> - </td> <td> the <code><a href="../shared_ptr.html" title="cpp/memory/shared ptr">std::shared_ptr</a></code> or <code><a href="../weak_ptr.html" title="cpp/memory/weak ptr">std::weak_ptr</a></code> to be compared </td>
</tr>
</table> <h3 id="Return_value"> Return value</h3> <p><code>true</code> if <code>*this</code> and <code>other</code> share ownership or are both empty. Otherwise, returns <code>false</code>.</p>
<h3 id="Notes"> Notes</h3> <table class="wikitable ftm-begin ftm-has-value"> <tr> <th>
<a href="../../utility/feature_test.html" title="cpp/utility/feature test">Feature-test</a> macro</th> <th>Value</th> <th><span title="Standard in which the feature is introduced">Std</span></th> <th>Feature </th>
</tr> <tr> <td><a href="../../feature_test.html#cpp_lib_smart_ptr_owner_equality" title="cpp/feature test"><code>__cpp_lib_smart_ptr_owner_equality</code></a></td> <td><span class="nu0">202306L</span></td> <td><span class="t-mark">(C++26)</span></td> <td>Enabling the use of <code>std::weak_ptr</code> as keys in <a href="../../container.html#Unordered_associative_containers" title="cpp/container">unordered associative containers</a> </td>
</tr>
</table> <h3 id="Example"> Example</h3>  <h3 id="See_also"> See also</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../owner_equal.html" title="cpp/memory/owner equal"> <span class="t-lines"><span>owner_equal</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx26">(C++26)</span></span></span></div> </td> <td> provides mixed-type owner-based equal comparisons of shared and weak pointers <br> <span class="t-mark">(class)</span>  </td>
</tr> </table>           <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/memory/weak_ptr/owner_equal" class="_attribution-link">https://en.cppreference.com/w/cpp/memory/weak_ptr/owner_equal</a>
  </p>
</div>
