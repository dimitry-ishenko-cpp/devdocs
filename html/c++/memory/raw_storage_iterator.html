    <h1 id="firstHeading" class="firstHeading">std::raw_storage_iterator</h1>            <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th> Defined in header <code><a href="../header/memory.html" title="cpp/header/memory">&lt;memory&gt;</a></code> </th> <th> </th> <th> </th> </tr>   <tr class="t-dcl t-until-cxx17"> <td> <pre data-language="cpp">template&lt; class OutputIt, class T &gt;
class raw_storage_iterator
    : public std::iterator&lt;std::output_iterator_tag, void, void, void, void&gt;;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-until-cxx17">(until C++17)</span> </td> </tr> <tr class="t-dcl t-since-cxx17 t-until-cxx20"> <td> <pre data-language="cpp">template&lt; class OutputIt, class T &gt;
class raw_storage_iterator;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> <br><span class="t-mark">(deprecated in C++17)</span> <br><span class="t-mark-rev t-until-cxx20">(removed in C++20)</span> </td> </tr>   </table> <p>The output iterator <code>std::raw_storage_iterator</code> makes it possible for standard algorithms to store results in uninitialized memory. Whenever the algorithm writes an object of type <code>T</code> to the dereferenced iterator, the object is copy-constructed into the location in the uninitialized storage pointed to by the iterator. The template parameter <code>OutputIt</code> is any type that meets the requirements of <a href="../named_req/outputiterator.html" title="cpp/named req/OutputIterator">LegacyOutputIterator</a> and has <code>operator*</code> defined to return an object, for which <code>operator&amp;</code> returns an object of type <code>T*</code>. Usually, the type <code>T*</code> is used as <code>OutputIt</code>.</p>
<h3 id="Type_requirements"> Type requirements</h3> <table class="t-par-begin"> <tr class="t-par-req"> <td colspan="3"> -<code>OutputIt</code> must meet the requirements of <a href="../named_req/outputiterator.html" title="cpp/named req/OutputIterator">LegacyOutputIterator</a>. </td>
</tr>
</table> <h3 id="Member_functions"> Member functions</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="raw_storage_iterator/raw_storage_iterator.html" title="cpp/memory/raw storage iterator/raw storage iterator"> <span class="t-lines"><span>(constructor)</span></span></a></div> </td> <td> creates a new <code>raw_storage_iterator</code> <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="raw_storage_iterator/operator=.html" title="cpp/memory/raw storage iterator/operator="> <span class="t-lines"><span>operator=</span></span></a></div> </td> <td> constructs an object at the pointed-to location in the buffer <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="raw_storage_iterator/operator*.html" title="cpp/memory/raw storage iterator/operator*"> <span class="t-lines"><span>operator*</span></span></a></div> </td> <td> dereferences the iterator <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="raw_storage_iterator/operator_arith.html" title="cpp/memory/raw storage iterator/operator arith"> <span class="t-lines"><span>operator++</span><span>operator++<span class="t-dsc-small">(int)</span></span></span></a></div> </td> <td> advances the iterator <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="raw_storage_iterator/base.html" title="cpp/memory/raw storage iterator/base"> <span class="t-lines"><span>base</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span></div> </td> <td> provides access to the wrapped iterator <br> <span class="t-mark">(public member function)</span>  </td>
</tr> </table> <h3 id="Member_types"> Member types</h3> <table class="t-dsc-begin"> <tr class="t-dsc-hitem"> <th> Member type </th> <th> Definition </th>
</tr> <tr class="t-dsc"> <td> <code>iterator_category</code> </td> <td> <a href="http://en.cppreference.com/w/cpp/iterator/iterator_tags"><span class="kw656">std::<span class="me2">output_iterator_tag</span></span></a> </td>
</tr> <tr class="t-dsc"> <td> <code>value_type</code> </td> <td> <span class="kw4">void</span> </td>
</tr> <tr class="t-dsc"> <td> <code>difference_type</code> </td> <td> <table class="t-rev-begin t-rev-begin-noborder"> <tr class="t-rev t-until-cxx20">
<td> <p><span class="kw4">void</span></p>
</td> <td><span class="t-mark-rev t-until-cxx20">(until C++20)</span></td>
</tr> <tr class="t-rev t-since-cxx20">
<td> <p><code><a href="../types/ptrdiff_t.html" title="cpp/types/ptrdiff t">std::ptrdiff_t</a></code></p>
</td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> </td>
</tr> <tr class="t-dsc"> <td> <code>pointer</code> </td> <td> <span class="kw4">void</span> </td>
</tr> <tr class="t-dsc"> <td> <code>reference</code> </td> <td> <span class="kw4">void</span> </td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx17">
<td> <p>Member types <code>iterator_category</code>, <code>value_type</code>, <code>difference_type</code>, <code>pointer</code> and <code>reference</code> are required to be obtained by inheriting from <a href="http://en.cppreference.com/w/cpp/iterator/iterator"><span class="kw660">std::<span class="me2">iterator</span></span></a><span class="sy1">&lt;</span><a href="http://en.cppreference.com/w/cpp/iterator/iterator_tags"><span class="kw656">std::<span class="me2">output_iterator_tag</span></span></a>, <span class="kw4">void</span>, <span class="kw4">void</span>, <span class="kw4">void</span>, <span class="kw4">void</span><span class="sy1">&gt;</span>.</p>
</td> <td><span class="t-mark-rev t-until-cxx17">(until C++17)</span></td>
</tr> </table> <h3 id="Note"> Note</h3> <p><code>std::raw_storage_iterator</code> was deprecated primarily because of its exception-unsafe behavior. Unlike <code><a href="uninitialized_copy.html" title="cpp/memory/uninitialized copy">std::uninitialized_copy</a></code>, it doesn't handle exceptions during operations like <code><a href="../algorithm/copy.html" title="cpp/algorithm/copy">std::copy</a></code> safely, potentially leading to resource leaks due to a lack of tracking the number of successfully constructed objects and their proper destruction in the presence of exceptions.</p>
<h3 id="Example"> Example</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;string&gt;
 
int main()
{
    const std::string s[] = {"This", "is", "a", "test", "."};
    std::string* p = std::allocator&lt;std::string&gt;().allocate(5);
 
    std::copy(std::begin(s), std::end(s),
              std::raw_storage_iterator&lt;std::string*, std::string&gt;(p));
 
    for (std::string* i = p; i != p + 5; ++i)
    {
        std::cout &lt;&lt; *i &lt;&lt; '\n';
        i-&gt;~basic_string&lt;char&gt;();
    }
    std::allocator&lt;std::string&gt;().deallocate(p, 5);
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">This
is
a
test
.</pre></div> </div> <h3 id="See_also"> See also</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="allocator_traits.html" title="cpp/memory/allocator traits"> <span class="t-lines"><span>allocator_traits</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> provides information about allocator types <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="scoped_allocator_adaptor.html" title="cpp/memory/scoped allocator adaptor"> <span class="t-lines"><span>scoped_allocator_adaptor</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> implements multi-level allocator for multi-level containers <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="uses_allocator.html" title="cpp/memory/uses allocator"> <span class="t-lines"><span>uses_allocator</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> checks if the specified type supports uses-allocator construction <br> <span class="t-mark">(class template)</span>  </td>
</tr> </table>           <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/memory/raw_storage_iterator" class="_attribution-link">https://en.cppreference.com/w/cpp/memory/raw_storage_iterator</a>
  </p>
</div>
