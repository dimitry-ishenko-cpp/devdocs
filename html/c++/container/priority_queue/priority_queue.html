    <h1 id="firstHeading" class="firstHeading">std::priority_queue&lt;T,Container,Compare&gt;::priority_queue</h1>            <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">priority_queue() : priority_queue(Compare(), Container()) {}</pre>
</td> <td> (1) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">explicit priority_queue( const Compare&amp; compare )
    : priority_queue(compare, Container()) {}</pre>
</td> <td> (2) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr>  <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(3)</td> <td></td> </tr> <tr class="t-dcl t-until-cxx11"> <td><pre data-language="cpp">explicit priority_queue( const Compare&amp; compare = Compare(),
                         const Container&amp; cont = Container() );</pre></td>  <td><span class="t-mark-rev t-until-cxx11">(until C++11)</span></td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">priority_queue( const Compare&amp; compare, const Container&amp; cont );</pre>
</td>  <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr>  <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">priority_queue( const Compare&amp; compare, Container&amp;&amp; cont );</pre>
</td> <td> (4) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">priority_queue( const priority_queue&amp; other );</pre>
</td> <td> (5) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">priority_queue( priority_queue&amp;&amp; other );</pre>
</td> <td> (6) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">template&lt; class InputIt &gt;
priority_queue( InputIt first, InputIt last,
                const Compare&amp; compare = Compare() );</pre>
</td> <td> (7) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr>  <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(8)</td> <td></td> </tr> <tr class="t-dcl t-until-cxx11"> <td><pre data-language="cpp">template&lt; class InputIt &gt;
priority_queue( InputIt first, InputIt last,
                const Compare&amp; compare = Compare(),
                const Container&amp; cont = Container() );</pre></td>  <td><span class="t-mark-rev t-until-cxx11">(until C++11)</span></td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">template&lt; class InputIt &gt;
priority_queue( InputIt first, InputIt last,
                const Compare&amp; compare, const Container&amp; cont );</pre>
</td>  <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr>  <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">template&lt; class InputIt &gt;
priority_queue( InputIt first, InputIt last,
                const Compare&amp; compare, Container&amp;&amp; cont );</pre>
</td> <td> (9) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">template&lt; class Alloc &gt;
explicit priority_queue( const Alloc&amp; alloc );</pre>
</td> <td> (10) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">template&lt; class Alloc &gt;
priority_queue( const Compare&amp; compare, const Alloc&amp; alloc );</pre>
</td> <td> (11) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">template&lt; class Alloc &gt;
priority_queue( const Compare&amp; compare, const Container&amp; cont,
                const Alloc&amp; alloc );</pre>
</td> <td> (12) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">template&lt; class Alloc &gt;
priority_queue( const Compare&amp; compare, Container&amp;&amp; cont,
                const Alloc&amp; alloc );</pre>
</td> <td> (13) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">template&lt; class Alloc &gt;
priority_queue( const priority_queue&amp; other, const Alloc&amp; alloc );</pre>
</td> <td> (14) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">template&lt; class Alloc &gt;
priority_queue( priority_queue&amp;&amp; other, const Alloc&amp; alloc );</pre>
</td> <td> (15) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">template&lt; class InputIt, class Alloc &gt;
priority_queue( InputIt first, InputIt last, const Alloc&amp; alloc );</pre>
</td> <td> (16) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">template&lt; class InputIt, class Alloc &gt;
priority_queue( InputIt first, InputIt last, const Compare&amp; compare,
                const Alloc&amp; alloc );</pre>
</td> <td> (17) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">template&lt; class InputIt, class Alloc &gt;
priority_queue( InputIt first, InputIt last, const Compare&amp; compare,
                const Container&amp; cont, const Alloc&amp; alloc );</pre>
</td> <td> (18) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">template&lt; class InputIt, class Alloc &gt;
priority_queue( InputIt first, InputIt last, const Compare&amp; compare,
                Container&amp;&amp; cont, const Alloc&amp; alloc );</pre>
</td> <td> (19) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr> <tr class="t-dcl t-since-cxx23"> <td><pre data-language="cpp">template&lt; container-compatible-range&lt;T&gt; R &gt;
priority_queue( std::from_range_t, R&amp;&amp; rg,
                const Compare&amp; compare = Compare() );</pre></td> <td> (20)</td> <td><span class="t-mark-rev t-since-cxx23">(since C++23)</span></td> </tr> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">template&lt; container-compatible-range&lt;T&gt; R, class Alloc &gt;
priority_queue( std::from_range_t, R&amp;&amp; rg,
                const Compare&amp; compare, const Alloc&amp; alloc );</pre>
</td> <td> (21) </td> <td> <span class="t-mark-rev t-since-cxx23">(since C++23)</span> </td> </tr> <tr class="t-dcl t-since-cxx23"> <td> <pre data-language="cpp">template&lt; container-compatible-range&lt;T&gt; R, class Alloc &gt;
priority_queue( std::from_range_t, R&amp;&amp; rg, const Alloc&amp; alloc );</pre>
</td> <td> (22) </td> <td> <span class="t-mark-rev t-since-cxx23">(since C++23)</span> </td> </tr>  </table> <p>Constructs new underlying container of the container adaptor from a variety of data sources.</p>
<div class="t-li1">
<span class="t-li">1)</span> Default constructor. Value-initializes the comparator and the underlying container.</div> <div class="t-li1">
<span class="t-li">2)</span> Copy-constructs the comparison functor <code>comp</code> with the contents of <code>compare</code>. Value-initializes the underlying container <code>c</code>.</div> <div class="t-li1">
<span class="t-li">3)</span> Copy-constructs the underlying container <code>c</code> with the contents of <code>cont</code>. Copy-constructs the comparison functor <code>comp</code> with the contents of <code>compare</code>. Calls <code><a href="http://en.cppreference.com/w/cpp/algorithm/make_heap"><span class="kw1640">std::<span class="me2">make_heap</span></span></a><span class="br0">(</span>c.<span class="me1">begin</span><span class="br0">(</span><span class="br0">)</span>, c.<span class="me1">end</span><span class="br0">(</span><span class="br0">)</span>, comp<span class="br0">)</span></code>. <span class="t-rev-inl t-until-cxx11"><span>This is also the default constructor.</span><span><span class="t-mark-rev t-until-cxx11">(until C++11)</span></span></span>
</div> <div class="t-li1">
<span class="t-li">4)</span> Move-constructs the underlying container <code>c</code> with <code>std::move(cont)</code>. Copy-constructs the comparison functor <code>comp</code> with <code>compare</code>. Calls <code><a href="http://en.cppreference.com/w/cpp/algorithm/make_heap"><span class="kw1640">std::<span class="me2">make_heap</span></span></a><span class="br0">(</span>c.<span class="me1">begin</span><span class="br0">(</span><span class="br0">)</span>, c.<span class="me1">end</span><span class="br0">(</span><span class="br0">)</span>, comp<span class="br0">)</span></code>.</div> <div class="t-li1">
<span class="t-li">5)</span> <a href="../../language/copy_constructor.html" title="cpp/language/copy constructor">Copy constructor</a>. The underlying container is copy-constructed with <code>other.c</code>. The comparison functor is copy-constructed with <code>other.comp</code>. <span class="t-mark">(implicitly declared)</span>
</div> <div class="t-li1">
<span class="t-li">6)</span> <a href="../../language/move_constructor.html" title="cpp/language/move constructor">Move constructor</a>. The underlying container is constructed with <code>std::move(other.c)</code>. The comparison functor is constructed with <code>std::move(other.comp)</code>. <span class="t-mark">(implicitly declared)</span>
</div> <div class="t-li1">
<span class="t-li">7-9)</span> Iterator-pair constructors. These overloads participate in overload resolution only if <code>InputIt</code> satisfies <a href="../../named_req/inputiterator.html" title="cpp/named req/InputIterator">LegacyInputIterator</a>.</div> <div class="t-li1">
<span class="t-li">7)</span> Constructs <code>c</code> as if by <code>c(first, last)</code> and <code>comp</code> from <code>compare</code>. Then calls <code><a href="http://en.cppreference.com/w/cpp/algorithm/make_heap"><span class="kw1640">std::<span class="me2">make_heap</span></span></a><span class="br0">(</span>c.<span class="me1">begin</span><span class="br0">(</span><span class="br0">)</span>, c.<span class="me1">end</span><span class="br0">(</span><span class="br0">)</span>, comp<span class="br0">)</span><span class="sy4">;</span></code>.</div> <div class="t-li1">
<span class="t-li">8)</span> Copy-constructs <code>c</code> from <code>cont</code> and <code>comp</code> from <code>compare</code>. Then calls <code>c.insert(c.end(), first, last);</code>, and then calls <code><a href="http://en.cppreference.com/w/cpp/algorithm/make_heap"><span class="kw1640">std::<span class="me2">make_heap</span></span></a><span class="br0">(</span>c.<span class="me1">begin</span><span class="br0">(</span><span class="br0">)</span>, c.<span class="me1">end</span><span class="br0">(</span><span class="br0">)</span>, comp<span class="br0">)</span><span class="sy4">;</span></code>.</div> <div class="t-li1">
<span class="t-li">9)</span> Move-constructs <code>c</code> from <code>std::move(cont)</code> and copy-constructs <code>comp</code> from <code>compare</code>. Then calls <code>c.insert(c.end(), first, last);</code>, and then calls <code><a href="http://en.cppreference.com/w/cpp/algorithm/make_heap"><span class="kw1640">std::<span class="me2">make_heap</span></span></a><span class="br0">(</span>c.<span class="me1">begin</span><span class="br0">(</span><span class="br0">)</span>, c.<span class="me1">end</span><span class="br0">(</span><span class="br0">)</span>, comp<span class="br0">)</span><span class="sy4">;</span></code>.</div> <div class="t-li1">
<span class="t-li">10-15)</span> Allocator-extended constructors. These overloads participate in overload resolution only if <code><a href="http://en.cppreference.com/w/cpp/memory/uses_allocator"><span class="kw706">std::<span class="me2">uses_allocator</span></span></a><span class="sy1">&lt;</span>container_type, Alloc<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">value</span></code> is <code>true</code>, that is, if the underlying container is an allocator-aware container (true for all standard library containers).</div> <div class="t-li1">
<span class="t-li">10)</span> Constructs the underlying container using <code>alloc</code> as allocator. Effectively calls <code>c(alloc)</code>. <code>comp</code> is value-initialized.</div> <div class="t-li1">
<span class="t-li">11)</span> Constructs the underlying container using <code>alloc</code> as allocator. Effectively calls <code>c(alloc)</code>. Copy-constructs <code>comp</code> from <code>compare</code>.</div> <div class="t-li1">
<span class="t-li">12)</span> Constructs the underlying container with the contents of <code>cont</code> and using <code>alloc</code> as allocator, as if by <code>c(cont, alloc)</code>. Copy-constructs <code>comp</code> from <code>compare</code>. Then calls <code><a href="http://en.cppreference.com/w/cpp/algorithm/make_heap"><span class="kw1640">std::<span class="me2">make_heap</span></span></a><span class="br0">(</span>c.<span class="me1">begin</span><span class="br0">(</span><span class="br0">)</span>, c.<span class="me1">end</span><span class="br0">(</span><span class="br0">)</span>, comp<span class="br0">)</span></code>.</div> <div class="t-li1">
<span class="t-li">13)</span> Constructs the underlying container with the contents of <code>cont</code> using move semantics while using <code>alloc</code> as allocator, as if by <code>c(std::move(cont), alloc)</code>. Copy-constructs <code>comp</code> from <code>compare</code>. Then calls <code><a href="http://en.cppreference.com/w/cpp/algorithm/make_heap"><span class="kw1640">std::<span class="me2">make_heap</span></span></a><span class="br0">(</span>c.<span class="me1">begin</span><span class="br0">(</span><span class="br0">)</span>, c.<span class="me1">end</span><span class="br0">(</span><span class="br0">)</span>, comp<span class="br0">)</span></code>.</div> <div class="t-li1">
<span class="t-li">14)</span> Constructs the underlying container with the contents of <code>other.c</code> and using <code>alloc</code> as allocator. Effectively calls <code>c(other.c, alloc)</code>. Copy-constructs <code>comp</code> from <code>other.comp</code>.</div> <div class="t-li1">
<span class="t-li">15)</span> Constructs the underlying container with the contents of <code>other</code> using move semantics while utilizing <code>alloc</code> as allocator. Effectively calls <code>c(std::move(other.c), alloc)</code>. Move-constructs <code>comp</code> from <code>other.comp</code>.</div> <div class="t-li1">
<span class="t-li">16-19)</span> Allocator-extended iterator-pair constructors. Same as <span class="t-v">(7-9)</span>, except that <code>alloc</code> is used for constructing the underlying container. These overloads participate in overload resolution only if <code><a href="http://en.cppreference.com/w/cpp/memory/uses_allocator"><span class="kw706">std::<span class="me2">uses_allocator</span></span></a><span class="sy1">&lt;</span>container_type, Alloc<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">value</span></code> is <code>true</code> and <code>InputIt</code> satisfies <a href="../../named_req/inputiterator.html" title="cpp/named req/InputIterator">LegacyInputIterator</a>.</div> <div class="t-li1">
<span class="t-li">20)</span> Initializes <code>comp</code> with <code>compare</code> and <code>c</code> with <code><a href="http://en.cppreference.com/w/cpp/ranges/to"><span class="kw3606">ranges::<span class="me2">to</span></span></a><span class="sy1">&lt;</span>Container<span class="sy1">&gt;</span><span class="br0">(</span><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>R<span class="sy1">&gt;</span><span class="br0">(</span>rg<span class="br0">)</span><span class="br0">)</span></code>. Then calls <code><a href="http://en.cppreference.com/w/cpp/algorithm/make_heap"><span class="kw1640">std::<span class="me2">make_heap</span></span></a><span class="br0">(</span>c.<span class="me1">begin</span><span class="br0">(</span><span class="br0">)</span>, c.<span class="me1">end</span><span class="br0">(</span><span class="br0">)</span>, comp<span class="br0">)</span></code>.</div> <div class="t-li1">
<span class="t-li">21)</span> Initializes <code>comp</code> with <code>compare</code> and <code>c</code> with <code><a href="http://en.cppreference.com/w/cpp/ranges/to"><span class="kw3606">ranges::<span class="me2">to</span></span></a><span class="sy1">&lt;</span>Container<span class="sy1">&gt;</span><span class="br0">(</span><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>R<span class="sy1">&gt;</span><span class="br0">(</span>rg<span class="br0">)</span>, alloc<span class="br0">)</span></code>. Then calls <code><a href="http://en.cppreference.com/w/cpp/algorithm/make_heap"><span class="kw1640">std::<span class="me2">make_heap</span></span></a><span class="br0">(</span>c.<span class="me1">begin</span><span class="br0">(</span><span class="br0">)</span>, c.<span class="me1">end</span><span class="br0">(</span><span class="br0">)</span>, comp<span class="br0">)</span></code>. </div> <div class="t-li1">
<span class="t-li">22)</span> Initializes <code>c</code> with <code><a href="http://en.cppreference.com/w/cpp/ranges/to"><span class="kw3606">ranges::<span class="me2">to</span></span></a><span class="sy1">&lt;</span>Container<span class="sy1">&gt;</span><span class="br0">(</span><a href="http://en.cppreference.com/w/cpp/utility/forward"><span class="kw1120">std::<span class="me2">forward</span></span></a><span class="sy1">&lt;</span>R<span class="sy1">&gt;</span><span class="br0">(</span>rg<span class="br0">)</span>, alloc<span class="br0">)</span></code>. Then calls <code><a href="http://en.cppreference.com/w/cpp/algorithm/make_heap"><span class="kw1640">std::<span class="me2">make_heap</span></span></a><span class="br0">(</span>c.<span class="me1">begin</span><span class="br0">(</span><span class="br0">)</span>, c.<span class="me1">end</span><span class="br0">(</span><span class="br0">)</span>, comp<span class="br0">)</span></code>.</div> <p>Note that how an implementation checks whether a type satisfies <a href="../../named_req/inputiterator.html" title="cpp/named req/InputIterator">LegacyInputIterator</a> is unspecified, except that integral types are required to be rejected.</p>
<h3 id="Parameters"> Parameters</h3> <table class="t-par-begin"> <tr class="t-par"> <td> alloc </td> <td> - </td> <td> allocator to use for all memory allocations of the underlying container </td>
</tr> <tr class="t-par"> <td> other </td> <td> - </td> <td> another container adaptor to be used as source to initialize the underlying container </td>
</tr> <tr class="t-par"> <td> cont </td> <td> - </td> <td> container to be used as source to initialize the underlying container </td>
</tr> <tr class="t-par"> <td> compare </td> <td> - </td> <td> the comparison function object to initialize the underlying comparison functor </td>
</tr> <tr class="t-par"> <td> first, last </td> <td> - </td> <td> a range <code>[</code><code>first</code><code>, </code><code>last</code><code>)</code> of elements to initialize with </td>
</tr> <tr class="t-par"> <td> rg </td> <td> - </td> <td> a <a href="../../ranges/to.html#container_compatible_range" title="cpp/ranges/to">container compatible range</a>, that is, an <a href="../../ranges/input_range.html" title="cpp/ranges/input range"><code>input_range</code></a> whose elements are convertible to <code>T</code> </td>
</tr> <tr class="t-par-hitem"> <td colspan="3"> Type requirements </td>
</tr> <tr class="t-par-req"> <td colspan="3"> -<code>Alloc</code> must meet the requirements of <a href="../../named_req/allocator.html" title="cpp/named req/Allocator">Allocator</a>. </td>
</tr> <tr class="t-par-req"> <td colspan="3"> -<code>Compare</code> must meet the requirements of <a href="../../named_req/compare.html" title="cpp/named req/Compare">Compare</a>. </td>
</tr> <tr class="t-par-req"> <td colspan="3"> -<code>Container</code> must meet the requirements of <a href="../../named_req/container.html" title="cpp/named req/Container">Container</a>. The allocator-extended constructors are only defined if <code>Container</code> meets the requirements of <a href="../../named_req/allocatorawarecontainer.html" title="cpp/named req/AllocatorAwareContainer">AllocatorAwareContainer</a>. </td>
</tr> <tr class="t-par-req"> <td colspan="3"> -<code>InputIt</code> must meet the requirements of <a href="../../named_req/inputiterator.html" title="cpp/named req/InputIterator">LegacyInputIterator</a>. </td>
</tr>
</table> <h3 id="Complexity"> Complexity</h3> <div class="t-li1">
<span class="t-li">1,2)</span> Constant.</div> <div class="t-li1">
<span class="t-li">3,5,12)</span> \(\scriptsize \mathcal{O}{(N)}\)O(N) comparisons and \(\scriptsize \mathcal{O}{(N)}\)O(N) calls to the constructor of <code>value_type</code>, where \(\scriptsize N\)N is <code>cont.size()</code>.</div> <div class="t-li1">
<span class="t-li">4)</span> \(\scriptsize \mathcal{O}{(N)}\)O(N) comparisons, where \(\scriptsize N\)N is <code>cont.size()</code>.</div> <div class="t-li1">
<span class="t-li">6)</span> Constant.</div> <div class="t-li1">
<span class="t-li">7,16,17)</span> \(\scriptsize \mathcal{O}{(M)}\)O(M) comparisons, where \(\scriptsize M\)M is <code><a href="http://en.cppreference.com/w/cpp/iterator/distance"><span class="kw676">std::<span class="me2">distance</span></span></a><span class="br0">(</span>first, last<span class="br0">)</span></code>.</div> <div class="t-li1">
<span class="t-li">8,18)</span> \(\scriptsize \mathcal{O}{(N + M)}\)O(N + M) comparisons and \(\scriptsize \mathcal{O}{(N)}\)O(N) calls to the constructor of <code>value_type</code>, where \(\scriptsize N\)N is <code>cont.size()</code> and \(\scriptsize M\)M is <code><a href="http://en.cppreference.com/w/cpp/iterator/distance"><span class="kw676">std::<span class="me2">distance</span></span></a><span class="br0">(</span>first, last<span class="br0">)</span></code>.</div> <div class="t-li1">
<span class="t-li">9)</span> \(\scriptsize \mathcal{O}{(N + M)}\)O(N + M) comparisons, where \(\scriptsize N\)N is <code>cont.size()</code> and \(\scriptsize M\)M is <code><a href="http://en.cppreference.com/w/cpp/iterator/distance"><span class="kw676">std::<span class="me2">distance</span></span></a><span class="br0">(</span>first, last<span class="br0">)</span></code>.</div> <div class="t-li1">
<span class="t-li">10,11)</span> Constant.</div> <div class="t-li1">
<span class="t-li">13)</span> \(\scriptsize \mathcal{O}{(N)}\)O(N) comparisons, where \(\scriptsize N\)N is <code>cont.size()</code>.</div> <div class="t-li1">
<span class="t-li">14)</span> Linear in size of <code>other</code>.</div> <div class="t-li1">
<span class="t-li">15)</span> Constant if <code>Alloc</code> compares equal to the allocator of <code>other</code>. Linear in size of <code>other</code> otherwise.</div> <div class="t-li1">
<span class="t-li">19)</span> \(\scriptsize \mathcal{O}{(N + M)}\)O(N + M) comparisons and possibly \(\scriptsize \mathcal{O}{(N)}\)O(N) calls to the constructor of <code>value_type</code> (present if <code>Alloc</code> does not compare equal to the allocator of <code>other</code>), where \(\scriptsize N\)N is <code>cont.size()</code> and \(\scriptsize M\)M is <code><a href="http://en.cppreference.com/w/cpp/iterator/distance"><span class="kw676">std::<span class="me2">distance</span></span></a><span class="br0">(</span>first, last<span class="br0">)</span></code>.</div> <div class="t-li1">
<span class="t-li">20)</span> \(\scriptsize \mathcal{O}{(N)}\)O(N) comparisons and \(\scriptsize \mathcal{O}{(N)}\)O(N) calls to the constructor of <code>value_type</code>, where \(\scriptsize N\)N is <code><a href="http://en.cppreference.com/w/cpp/iterator/ranges/distance"><span class="kw3142">ranges::<span class="me2">distance</span></span></a><span class="br0">(</span>rg<span class="br0">)</span></code>.</div> <div class="t-li1">
<span class="t-li">21,22)</span> </div> <h3 id="Notes"> Notes</h3> <table class="wikitable ftm-begin ftm-has-value"> <tr> <th>
<a href="../../utility/feature_test.html" title="cpp/utility/feature test">Feature-test</a> macro</th> <th>Value</th> <th><span title="Standard in which the feature is introduced">Std</span></th> <th>Feature </th>
</tr> <tr> <td><a href="../../feature_test.html#cpp_lib_containers_ranges" title="cpp/feature test"><code>__cpp_lib_containers_ranges</code></a></td> <td><span class="nu0">202202L</span></td> <td><span class="t-mark">(C++23)</span></td> <td>
<a href="../../ranges/to.html#container_compatible_range" title="cpp/ranges/to">Ranges-aware</a> construction and insertion; overloads <span class="t-v">(<a href="#Version_20">20-22</a>)</span> </td>
</tr>
</table> <h3 id="Example"> Example</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;complex&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
 
int main()
{
    std::priority_queue&lt;int&gt; pq1;
    pq1.push(5);
    std::cout &lt;&lt; "pq1.size() = " &lt;&lt; pq1.size() &lt;&lt; '\n';
 
    std::priority_queue&lt;int&gt; pq2 {pq1};
    std::cout &lt;&lt; "pq2.size() = " &lt;&lt; pq2.size() &lt;&lt; '\n';
 
    std::vector&lt;int&gt; vec {3, 1, 4, 1, 5};
    std::priority_queue&lt;int&gt; pq3 {std::less&lt;int&gt;(), vec};
    std::cout &lt;&lt; "pq3.size() = " &lt;&lt; pq3.size() &lt;&lt; '\n';
 
    for (std::cout &lt;&lt; "pq3 : "; !pq3.empty(); pq3.pop())
        std::cout &lt;&lt; pq3.top() &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
 
    // Demo With Custom Comparator:
 
    using my_value_t = std::complex&lt;double&gt;;
    using my_container_t = std::vector&lt;my_value_t&gt;;
 
    auto my_comp = [](const my_value_t&amp; z1, const my_value_t&amp; z2)
    {
        return z2.real() &lt; z1.real();
    };
 
    std::priority_queue&lt;my_value_t,
                        my_container_t,
                        decltype(my_comp)&gt; pq4{my_comp};
 
    using namespace std::complex_literals;
    pq4.push(5.0 + 1i);
    pq4.push(3.0 + 2i);
    pq4.push(7.0 + 3i);
 
    for (; !pq4.empty(); pq4.pop())
    {
        const auto&amp; z = pq4.top();
        std::cout &lt;&lt; "pq4.top() = " &lt;&lt; z &lt;&lt; '\n';
    }
 
    // TODO: C++23 range-aware ctors
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">pq1.size() = 1
pq2.size() = 1
pq3.size() = 5
pq3 : 5 4 3 1 1
pq4.top() = (3,2)
pq4.top() = (5,1)
pq4.top() = (7,3)</pre></div> </div> <h3 id="Defect_reports"> Defect reports</h3> <p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.</p>
<table class="dsctable"> <tr> <th>DR </th> <th>Applied to </th> <th>Behavior as published </th> <th>Correct behavior </th>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://wg21.link/P0935R0">P0935R0</a> </td> <td>C++11 </td> <td>default constructor and constructor <span class="t-v">(4)</span> were explicit </td> <td>made implicit </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/LWG/issue3506">LWG 3506</a> </td> <td>C++11 </td> <td>allocator-extended iterator-pair constructors were missing </td> <td>added </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/LWG/issue3522">LWG 3522</a> </td> <td>C++11 </td> <td>constraints on iterator-pair constructors were missing </td> <td>added </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/LWG/issue3529">LWG 3529</a> </td> <td>C++11 </td> <td>construction from a pair of iterators called <code>insert</code> </td> <td>constructs the container from them </td>
</tr>
</table> <h3 id="See_also"> See also</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="operator=.html" title="cpp/container/priority queue/operator="> <span class="t-lines"><span>operator=</span></span></a></div> </td> <td> assigns values to the container adaptor <br> <span class="t-mark">(public member function)</span>  </td>
</tr> </table>           <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/container/priority_queue/priority_queue" class="_attribution-link">https://en.cppreference.com/w/cpp/container/priority_queue/priority_queue</a>
  </p>
</div>
