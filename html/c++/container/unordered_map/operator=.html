    <h1 id="firstHeading" class="firstHeading">std::unordered_map&lt;Key,T,Hash,KeyEqual,Allocator&gt;::operator=</h1>             <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">unordered_map&amp; operator=( const unordered_map&amp; other );</pre>
</td> <td> (1) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr>  <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(2)</td> <td></td> </tr> <tr class="t-dcl t-since-cxx11 t-until-cxx17"> <td><pre data-language="cpp">unordered_map&amp; operator=( unordered_map&amp;&amp; other );</pre></td>  <td>
<span class="t-mark-rev t-since-cxx11">(since C++11)</span> <br><span class="t-mark-rev t-until-cxx17">(until C++17)</span>
</td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">unordered_map&amp; operator=( unordered_map&amp;&amp; other ) noexcept(/* see below */);</pre>
</td>  <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr>  <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">unordered_map&amp; operator=( std::initializer_list&lt;value_type&gt; ilist );</pre>
</td> <td> (3) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr>  </table> <p>Replaces the contents of the container.</p>
<div class="t-li1">
<span class="t-li">1)</span> Copy assignment operator. Replaces the contents with a copy of the contents of <code>other</code>.</div> <div class="t-li1">
 If <code><a href="http://en.cppreference.com/w/cpp/memory/allocator_traits"><span class="kw703">std::<span class="me2">allocator_traits</span></span></a><span class="sy1">&lt;</span>allocator_type<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">propagate_on_container_copy_assignment</span><span class="sy4">::</span><span class="me2">value</span></code> is <code>true</code>, the allocator of <code>*this</code> is replaced by a copy of <code>other</code>. If the allocator of <code>*this</code> after assignment would compare unequal to its old value, the old allocator is used to deallocate the memory, then the new allocator is used to allocate it before copying the elements. Otherwise, the memory owned by <code>*this</code> may be reused when possible. In any case, the elements originally belonging to <code>*this</code> may be either destroyed or replaced by element-wise copy-assignment.</div> <div class="t-li1">
<span class="t-li">2)</span> Move assignment operator. Replaces the contents with those of <code>other</code> using move semantics (i.e. the data in <code>other</code> is moved from <code>other</code> into this container). <code>other</code> is in a valid but unspecified state afterwards.</div> <div class="t-li1">
 If <code><a href="http://en.cppreference.com/w/cpp/memory/allocator_traits"><span class="kw703">std::<span class="me2">allocator_traits</span></span></a><span class="sy1">&lt;</span>allocator_type<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">propagate_on_container_move_assignment</span><span class="sy4">::</span><span class="me2">value</span></code> is <code>true</code>, the allocator of <code>*this</code> is replaced by a copy of that of <code>other</code>. If it is <code>false</code> and the allocators of <code>*this</code> and <code>other</code> do not compare equal, <code>*this</code> cannot take ownership of the memory owned by <code>other</code> and must move-assign each element individually, allocating additional memory using its own allocator as needed. In any case, all elements originally belonging to <code>*this</code> are either destroyed or replaced by element-wise move-assignment.</div> <div class="t-li1">
<span class="t-li">3)</span> Replaces the contents with those identified by initializer list <code>ilist</code>.</div>  <h3 id="Parameters"> Parameters</h3> <table class="t-par-begin"> <tr class="t-par"> <td> other </td> <td> - </td> <td> another container to use as data source </td>
</tr> <tr class="t-par"> <td> ilist </td> <td> - </td> <td> initializer list to use as data source </td>
</tr>
</table> <h3 id="Return_value"> Return value</h3> <p><code>*this</code></p>
<h3 id="Complexity"> Complexity</h3> <div class="t-li1">
<span class="t-li">1)</span> Linear in the size of <code>*this</code> and <code>other</code>.</div> <div class="t-li1">
<span class="t-li">2)</span> Linear in the size of <code>*this</code> unless the allocators do not compare equal and do not propagate, in which case linear in the size of <code>*this</code> and <code>other</code>.</div> <div class="t-li1">
<span class="t-li">3)</span> Linear in the size of <code>*this</code> and <code>ilist</code>.</div> <h3 id="Exceptions"> Exceptions</h3> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx17">
<td> <p>May throw implementation-defined exceptions.</p>
</td> <td><span class="t-mark-rev t-until-cxx17">(until C++17)</span></td>
</tr> <tr class="t-rev t-since-cxx17">
<td> <span class="t-li">1,3)</span> May throw implementation-defined exceptions. <span class="t-li">2)</span> <div class="t-noexcept-full">
<a href="../../language/noexcept_spec.html" title="cpp/language/noexcept spec"><code>noexcept</code></a> specification: <div class="t-noexcept-box"><span class="t-cc"><code><span class="kw1">noexcept</span><span class="br0">(</span><a href="http://en.cppreference.com/w/cpp/memory/allocator_traits"><span class="kw703">std::<span class="me2">allocator_traits</span></span></a><span class="sy1">&lt;</span>Allocator<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">is_always_equal</span><span class="sy4">::</span><span class="me2">value</span><br> <p><span class="sy3">&amp;&amp;</span> <a href="http://en.cppreference.com/w/cpp/types/is_move_assignable"><span class="kw567">std::<span class="me2">is_nothrow_move_assignable</span></span></a><span class="sy1">&lt;</span>Hash<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">value</span><br></p>
<span class="sy3">&amp;&amp;</span> <a href="http://en.cppreference.com/w/cpp/types/is_move_assignable"><span class="kw567">std::<span class="me2">is_nothrow_move_assignable</span></span></a><span class="sy1">&lt;</span>Pred<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">value</span><span class="br0">)</span></code></span></div>
</div> </td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <h3 id="Notes"> Notes</h3> <p>After container move assignment (overload <span class="t-v">(2)</span>), unless element-wise move assignment is forced by incompatible allocators, references, pointers, and iterators (other than the end iterator) to <code>other</code> remain valid, but refer to elements that are now in <code>*this</code>. The current standard makes this guarantee via the blanket statement in <a rel="nofollow" class="external text" href="https://eel.is/c++draft/container.reqmts#67">[container.reqmts]/67</a>, and a more direct guarantee is under consideration via <a rel="nofollow" class="external text" href="https://cplusplus.github.io/LWG/issue2321">LWG issue 2321</a>.</p>
<h3 id="Example"> Example</h3> <div class="t-example">
<p>The following code uses <code>operator=</code> to assign one <code><a href="../unordered_map.html" title="cpp/container/unordered map">std::unordered_map</a></code> to another:</p>
<div class="cpp source-cpp"><pre data-language="cpp">#include &lt;initializer_list&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;unordered_map&gt;
#include &lt;utility&gt;
 
void print(auto const comment, auto const&amp; container)
{
    auto size = std::size(container);
    std::cout &lt;&lt; comment &lt;&lt; "{ ";
    for (auto const&amp; [key, value] : container)
        std::cout &lt;&lt; '{' &lt;&lt; key &lt;&lt; ',' &lt;&lt; value &lt;&lt; (--size ? "}, " : "} ");
    std::cout &lt;&lt; "}\n";
}
 
int main()
{
    std::unordered_map&lt;int, int&gt; x{{1,1}, {2,2}, {3,3}}, y, z;
    const auto w = {std::pair&lt;const int, int&gt;{4,4}, {5,5}, {6,6}, {7,7}};
 
    std::cout &lt;&lt; "Initially:\n";
    print("x = ", x);
    print("y = ", y);
    print("z = ", z);
 
    std::cout &lt;&lt; "Copy assignment copies data from x to y:\n";
    y = x;
    print("x = ", x);
    print("y = ", y);
 
    std::cout &lt;&lt; "Move assignment moves data from x to z, modifying both x and z:\n";
    z = std::move(x);
    print("x = ", x);
    print("z = ", z);
 
    std::cout &lt;&lt; "Assignment of initializer_list w to z:\n";
    z = w;
    print("w = ", w);
    print("z = ", z);
}</pre></div> <p>Possible output:</p>
<div class="text source-text"><pre data-language="c">Initially:
x = { {3,3}, {2,2}, {1,1} }
y = { }
z = { }
Copy assignment copies data from x to y:
x = { {3,3}, {2,2}, {1,1} }
y = { {3,3}, {2,2}, {1,1} }
Move assignment moves data from x to z, modifying both x and z:
x = { }
z = { {3,3}, {2,2}, {1,1} }
Assignment of initializer_list w to z:
w = { {4,4}, {5,5}, {6,6}, {7,7} }
z = { {7,7}, {6,6}, {5,5}, {4,4} }</pre></div> </div> <h3 id="See_also"> See also</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="unordered_map.html" title="cpp/container/unordered map/unordered map"> <span class="t-lines"><span>(constructor)</span></span></a></div> </td> <td> constructs the <code>unordered_map</code> <br> <span class="t-mark">(public member function)</span>  </td>
</tr> </table>           <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/container/unordered_map/operator%3D" class="_attribution-link">https://en.cppreference.com/w/cpp/container/unordered_map/operator%3D</a>
  </p>
</div>
