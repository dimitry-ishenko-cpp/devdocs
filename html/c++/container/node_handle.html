    <h1 id="firstHeading" class="firstHeading">Node handle <span class="t-mark-rev t-since-cxx17">(C++17)</span>
</h1>            <table class="t-dcl-begin"> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">template&lt;/* unspecified */&gt;
class /* node-handle */;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr>  </table> <p>Associative containers <code><a href="set.html" title="cpp/container/set">std::set</a></code>, <code><a href="map.html" title="cpp/container/map">std::map</a></code>, <code><a href="multiset.html" title="cpp/container/multiset">std::multiset</a></code>, <code><a href="multimap.html" title="cpp/container/multimap">std::multimap</a></code>, <code><a href="unordered_set.html" title="cpp/container/unordered set">std::unordered_set</a></code>, <code><a href="unordered_map.html" title="cpp/container/unordered map">std::unordered_map</a></code>, <code><a href="unordered_multiset.html" title="cpp/container/unordered multiset">std::unordered_multiset</a></code>, <code><a href="unordered_multimap.html" title="cpp/container/unordered multimap">std::unordered_multimap</a></code> are node-based data structures, and their nodes can be extracted as an object of unspecified type known as <i>node handle</i>.</p>
<p>Node handle is a move-only type that owns and provides access to the element (the <code>value_type</code>) stored in the node, and provides non-const access to the key part of the element (the <code>key_type</code>) and the mapped part of the element (the <code>mapped_type</code>). If the node handle destructs while holding the node, the node is properly destructed using the appropriate allocator for the container. The node handle contains a copy of the containerâ€™s allocator. This is necessary so that the node handle can outlive the container.</p>
<p>The exact type of node handle (shown here as <span class="coMULTI">/* node-handle */</span>) is unspecified, but each container exposes its node handle type as the member <code>node_type</code>.</p>
<p>Node handles can be used to transfer ownership of an element between two associative containers with the same key, value, and allocator type (ignoring comparison or hash/equality), without invoking any copy/move operations on the container element (this kind of operation is known as "splicing"). Transfer between unique and non-unique containers is also permitted: a node handle from a <code><a href="map.html" title="cpp/container/map">std::map</a></code> can be inserted into an <code><a href="multimap.html" title="cpp/container/multimap">std::multimap</a></code>, but not into <code><a href="unordered_map.html" title="cpp/container/unordered map">std::unordered_map</a></code> or <code><a href="set.html" title="cpp/container/set">std::set</a></code>.</p>
<p>A node handle may be empty, in which case it holds no element and no allocator. The default-constructed and moved-from node handle is empty. In addition, an empty node handle can be produced by a failed call to container member function <code>extract</code>.</p>
<p>Pointers and references to an element that are obtained while it is owned by a node handle are invalidated if the element is successfully inserted into a container.</p>
<p>For all map containers (<code><a href="map.html" title="cpp/container/map">std::map</a></code>, <code><a href="multimap.html" title="cpp/container/multimap">std::multimap</a></code>, <code><a href="unordered_map.html" title="cpp/container/unordered map">std::unordered_map</a></code>, and <code><a href="unordered_multimap.html" title="cpp/container/unordered multimap">std::unordered_multimap</a></code>) whose <code>key_type</code> is <code>K</code> and <code>mapped_type</code> is <code>T</code>, the behavior of operations involving node handles is undefined if a user-defined specialization of <code><a href="../utility/pair.html" title="cpp/utility/pair">std::pair</a></code> exists for <a href="http://en.cppreference.com/w/cpp/utility/pair"><span class="kw1099">std::<span class="me2">pair</span></span></a><span class="sy1">&lt;</span>K, T<span class="sy1">&gt;</span> or <a href="http://en.cppreference.com/w/cpp/utility/pair"><span class="kw1099">std::<span class="me2">pair</span></span></a><span class="sy1">&lt;</span><span class="kw4">const</span> K, T<span class="sy1">&gt;</span>.</p>
<h3 id="Member_types"> Member types</h3> <table class="t-dsc-begin"> <tr class="t-dsc-hitem"> <th> Member type </th> <th> Definition </th>
</tr> <tr class="t-dsc"> <td> <code>key_type</code><span class="t-mark">(map containers only)</span> </td> <td> the key stored in the node </td>
</tr> <tr class="t-dsc"> <td> <code>mapped_type</code><span class="t-mark">(map containers only)</span> </td> <td> the mapped part of the element stored in the node </td>
</tr> <tr class="t-dsc"> <td> <code>value_type</code><span class="t-mark">(set containers only)</span> </td> <td> the element stored in the node </td>
</tr> <tr class="t-dsc"> <td> <code>allocator_type</code> </td> <td> the allocator to be used when destroying the element </td>
</tr> </table> <h3 id="Member_functions"> Member functions</h3> <div class="t-member"> <h2 id="constructors"> constructors</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td> <pre data-language="cpp">constexpr /* node-handle */() noexcept;</pre>
</td> <td> (1) </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td> <pre data-language="cpp">/* node-handle */ (/* node-handle */&amp;&amp; nh) noexcept;</pre>
</td> <td> (2) </td> <td class="t-dcl-nopad"> </td> </tr>  </table> <div class="t-li1">
<span class="t-li">1)</span> The default constructor initializes the node handle to the empty state.</div> <div class="t-li1">
<span class="t-li">2)</span> The move constructor takes ownership of the container element from <code>nh</code>, move-constructs the member allocator, and leaves <code>nh</code> in the empty state.</div> <h3 id="Parameters"> Parameters</h3> <table class="t-par-begin"> <tr class="t-par"> <td> nh </td> <td> - </td> <td> a node handle with the same type (not necessarily the same container) </td>
</tr>
</table> <h3 id="Notes"> Notes</h3> <p>Node handles are move-only, the copy constructor is not defined.</p>
</div>  <h2 id="operator.3D"> operator=</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">/* node-handle */&amp; operator=(/* node-handle */&amp;&amp; nh);</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr>  </table> <ul>
<li> If the node handle is not empty, </li>
<ul>
<li> destroys the <code>value_type</code> subobject in the container element object managed by this node handle by calling <code>std::allocator_traits&lt;allocator_type&gt;::destroy</code>; </li>
<li> deallocates the container element by calling <a href="http://en.cppreference.com/w/cpp/memory/allocator_traits"><span class="kw703">std::<span class="me2">allocator_traits</span></span></a><span class="sy1">&lt;</span>allocator_type<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">rebind_traits</span><span class="sy1">&lt;</span><span class="coMULTI">/* container-node-type */</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">deallocate</span>; </li>
</ul>
<li> Acquires ownership of the container element from <code>nh</code>; </li>
<li> If node handle was empty (and so did not contain an allocator) or if <a href="http://en.cppreference.com/w/cpp/memory/allocator_traits"><span class="kw703">std::<span class="me2">allocator_traits</span></span></a><span class="sy1">&lt;</span>allocator_type<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">propagate_on_container_move_assignment</span> is <code>true</code>, move-assigns the allocator from <code>nh</code>; </li>
<li> sets <code>nh</code> to the empty state. </li>
</ul>   <p>The behavior is undefined if the node is not empty and <a href="http://en.cppreference.com/w/cpp/memory/allocator_traits"><span class="kw703">std::<span class="me2">allocator_traits</span></span></a><span class="sy1">&lt;</span>allocator_type<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">propagate_on_container_move_assignment</span> is <code>false</code> and the allocators do not compare equal.</p>
<h3 id="Parameters_2"> Parameters</h3> <table class="t-par-begin"> <tr class="t-par"> <td> nh </td> <td> - </td> <td> node handle with the same type (not necessarily the same container) </td>
</tr>
</table> <h3 id="Return"> Return</h3> <p><code>*this</code></p>
<h3 id="Exceptions"> Exceptions</h3> <p>Throws nothing.</p>
<h3 id="Notes_2"> Notes</h3> <p>Node handles are move-only, the copy assignment is not defined.</p>
<h2 id="destructor"> destructor</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">~/* node-handle */();</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr>  </table> <ul>
<li> If the node handle is not empty, </li>
<ul>
<li> destroys the <code>value_type</code> subobject in the container element object managed by this node handle by calling <a href="http://en.cppreference.com/w/cpp/memory/allocator_traits"><span class="kw703">std::<span class="me2">allocator_traits</span></span></a><span class="sy1">&lt;</span>allocator_type<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">destroy</span>; </li>
<li> deallocates the container element by calling <a href="http://en.cppreference.com/w/cpp/memory/allocator_traits"><span class="kw703">std::<span class="me2">allocator_traits</span></span></a><span class="sy1">&lt;</span>allocator_type<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">rebind_traits</span><span class="sy1">&lt;</span><span class="coMULTI">/* container-node-type */</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">deallocate</span>. </li>
</ul>
</ul>   <div class="t-member"> <h2 id="empty"> empty</h2> <table class="t-dcl-begin">   <tr class="t-dcl t-until-cxx20"> <td><pre data-language="cpp">bool empty() const noexcept;</pre></td> <td class="t-dcl-nopad"> </td> <td><span class="t-mark-rev t-until-cxx20">(until C++20)</span></td> </tr> <tr class="t-dcl t-since-cxx20"> <td> <pre data-language="cpp">[[nodiscard]] bool empty() const noexcept;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span> </td> </tr>   </table> <p>Returns <code>true</code> if the node handle is empty, <code>false</code> otherwise.</p>
</div> <div class="t-member"> <h2 id="operator_bool"> operator bool</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">explicit operator bool() const noexcept;</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr>  </table> <p>Converts to <code>false</code> if the node handle is empty, <code>true</code> otherwise.</p>
</div> <div class="t-member"> <h2 id="get_allocator"> get_allocator</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">allocator_type get_allocator() const;</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr>  </table> <p>Returns a copy of the stored allocator (which is a copy of the allocator of the source container). The behavior is undefined if the node handle is empty.</p>
<h3 id="Exceptions_2"> Exceptions</h3> <p>Throws nothing.</p>
</div> <div class="t-member"> <h2 id="value"> value</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td> <pre data-language="cpp">value_type&amp; value() const;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark">(set containers only)</span> </td> </tr>  </table> <p>Returns a reference to the <code>value_type</code> subobject in the container element object managed by this node handle. The behavior is undefined if the node handle is empty.</p>
<h3 id="Exceptions_3"> Exceptions</h3> <p>Throws nothing.</p>
</div> <div class="t-member"> <h2 id="key"> key</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td> <pre data-language="cpp">key_type&amp; key() const;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark">(map containers only)</span> </td> </tr>  </table> <p>Returns a non-const reference to the <code>key_type</code> member of the <code>value_type</code> subobject in the container element object managed by this node handle. The behavior is undefined if the node handle is empty.</p>
<h3 id="Exceptions_4"> Exceptions</h3> <p>Throws nothing.</p>
<h3 id="Notes_3"> Notes</h3> <p>This function makes it possible to modify the key of a node extracted from a map, and then re-insert it into the map, without ever copying or moving the element.</p>
</div> <div class="t-member"> <h2 id="mapped"> mapped</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td> <pre data-language="cpp">mapped_type&amp; mapped() const;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark">(map containers only)</span> </td> </tr>  </table> <p>Returns a reference to the <code>mapped_type</code> member of the <code>value_type</code> subobject in the container element object managed by this node handle. The behavior is undefined if the node handle is empty.</p>
<h3 id="Exceptions_5"> Exceptions</h3> <p>Throws nothing.</p>
</div>  <h2 id="swap"> swap</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">void swap(/* node-handle */&amp; nh) noexcept(/* see below */);</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr>  </table> <ul>
<li> swaps ownership of container nodes; </li>
<li> if one node is empty or if both nodes are non-empty and <a href="http://en.cppreference.com/w/cpp/memory/allocator_traits"><span class="kw703">std::<span class="me2">allocator_traits</span></span></a><span class="sy1">&lt;</span>allocator_type<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">propagate_on_container_swap</span> is <code>true</code>, swaps the allocators as well. </li>
</ul> <p>The behavior is undefined if both nodes are not empty and <a href="http://en.cppreference.com/w/cpp/memory/allocator_traits"><span class="kw703">std::<span class="me2">allocator_traits</span></span></a><span class="sy1">&lt;</span>allocator_type<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">propagate_on_container_swap</span> is <code>false</code> and the allocators do not compare equal.</p>
<h3 id="Exceptions_6"> Exceptions</h3> <div class="t-noexcept-full">
<a href="../language/noexcept_spec.html" title="cpp/language/noexcept spec"><code>noexcept</code></a> specification: <div class="t-noexcept-box"><span class="t-cc"><code><span class="kw1">noexcept</span><span class="br0">(</span><a href="http://en.cppreference.com/w/cpp/memory/allocator_traits"><span class="kw703">std::<span class="me2">allocator_traits</span></span></a><span class="sy1">&lt;</span>allocator_type<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">propagate_on_container_swap</span><span class="sy4">::</span><span class="me2">value</span> <span class="sy3">||</span><br> <a href="http://en.cppreference.com/w/cpp/memory/allocator_traits"><span class="kw703">std::<span class="me2">allocator_traits</span></span></a><span class="sy1">&lt;</span>allocator_type<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">is_always_equal</span><span class="sy4">::</span><span class="me2">value</span><span class="br0">)</span></code></span></div>
</div>  <h3 id="Non-member_functions"> Non-member functions</h3> <div class="t-member"> <h2 id="swap_2"> swap</h2> <table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">friend void swap(/* node-handle */&amp; x, /* node-handle */&amp; y) noexcept(noexcept(x.swap(y)));</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr>  </table> <p>Effectively executes <code>x.swap(y)</code>.</p>
<p>This function is not visible to ordinary <a href="../language/unqualified_lookup.html" title="cpp/language/unqualified lookup">unqualified</a> or <a href="../language/qualified_lookup.html" title="cpp/language/qualified lookup">qualified lookup</a>, and can only be found by <a href="../language/adl.html" title="cpp/language/adl">argument-dependent lookup</a> when <code><i>node-handle</i></code> is an associated class of the arguments.</p>
</div>           <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/container/node_handle" class="_attribution-link">https://en.cppreference.com/w/cpp/container/node_handle</a>
  </p>
</div>
