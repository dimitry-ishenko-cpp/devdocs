    <h1 id="firstHeading" class="firstHeading">std::shared_mutex</h1>            <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th> Defined in header <code><a href="../header/shared_mutex.html" title="cpp/header/shared mutex">&lt;shared_mutex&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">class shared_mutex;</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr>  </table> <p>The <code>shared_mutex</code> class is a synchronization primitive that can be used to protect shared data from being simultaneously accessed by multiple threads. In contrast to other mutex types which facilitate exclusive access, a shared_mutex has two levels of access:</p>
<ul>
<li> <i>shared</i> - several threads can share ownership of the same mutex. </li>
<li> <i>exclusive</i> - only one thread can own the mutex. </li>
</ul>  <p>If one thread has acquired the <i>exclusive</i> lock (through <code><a href="shared_mutex/lock.html" title="cpp/thread/shared mutex/lock">lock</a></code>, <code><a href="shared_mutex/try_lock.html" title="cpp/thread/shared mutex/try lock">try_lock</a></code>), no other threads can acquire the lock (including the <i>shared</i>).</p>
<p>If one thread has acquired the <i>shared</i> lock (through <code><a href="shared_mutex/lock_shared.html" title="cpp/thread/shared mutex/lock shared">lock_shared</a></code>, <code><a href="shared_mutex/try_lock_shared.html" title="cpp/thread/shared mutex/try lock shared">try_lock_shared</a></code>), no other thread can acquire the <i>exclusive</i> lock, but can acquire the <i>shared</i> lock.</p>
<p>Only when the <i>exclusive</i> lock has not been acquired by any thread, the <i>shared</i> lock can be acquired by multiple threads.</p>
<p>Within one thread, only one lock (<i>shared</i> or <i>exclusive</i>) can be acquired at the same time.</p>
<p>Shared mutexes are especially useful when shared data can be safely read by any number of threads simultaneously, but a thread may only write the same data when no other thread is reading or writing at the same time.</p>
<p>The <code>shared_mutex</code> class satisfies all requirements of <a href="../named_req/sharedmutex.html" title="cpp/named req/SharedMutex">SharedMutex</a> and <a href="../named_req/standardlayouttype.html" title="cpp/named req/StandardLayoutType">StandardLayoutType</a>.</p>
<h3 id="Member_types"> Member types</h3> <table class="t-dsc-begin"> <tr class="t-dsc-hitem"> <th> Member type </th> <th> Definition </th>
</tr> <tr class="t-dsc"> <td> <code>native_handle_type</code><span class="t-mark">(not always present)</span> </td> <td> <i>implementation-defined</i> </td>
</tr> </table> <h3 id="Member_functions"> Member functions</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="shared_mutex/shared_mutex.html" title="cpp/thread/shared mutex/shared mutex"> <span class="t-lines"><span>(constructor)</span></span></a></div> </td> <td> constructs the mutex <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="shared_mutex/~shared_mutex.html" title="cpp/thread/shared mutex/~shared mutex"> <span class="t-lines"><span>(destructor)</span></span></a></div> </td> <td> destroys the mutex <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><span class="t-lines"><span>operator=</span></span></div>
<div><span class="t-lines"><span><span class="t-cmark">[deleted]</span></span></span></div> </td> <td> not copy-assignable <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Exclusive_locking">  Exclusive locking </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="shared_mutex/lock.html" title="cpp/thread/shared mutex/lock"> <span class="t-lines"><span>lock</span></span></a></div> </td> <td> locks the mutex, blocks if the mutex is not available <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="shared_mutex/try_lock.html" title="cpp/thread/shared mutex/try lock"> <span class="t-lines"><span>try_lock</span></span></a></div> </td> <td> tries to lock the mutex, returns if the mutex is not available <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="shared_mutex/unlock.html" title="cpp/thread/shared mutex/unlock"> <span class="t-lines"><span>unlock</span></span></a></div> </td> <td> unlocks the mutex <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Shared_locking">  Shared locking </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="shared_mutex/lock_shared.html" title="cpp/thread/shared mutex/lock shared"> <span class="t-lines"><span>lock_shared</span></span></a></div> </td> <td> locks the mutex for shared ownership, blocks if the mutex is not available <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="shared_mutex/try_lock_shared.html" title="cpp/thread/shared mutex/try lock shared"> <span class="t-lines"><span>try_lock_shared</span></span></a></div> </td> <td> tries to lock the mutex for shared ownership, returns if the mutex is not available <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="shared_mutex/unlock_shared.html" title="cpp/thread/shared mutex/unlock shared"> <span class="t-lines"><span>unlock_shared</span></span></a></div> </td> <td> unlocks the mutex (shared ownership) <br> <span class="t-mark">(public member function)</span>  </td>
</tr> <tr> <td colspan="2"> <h5 id="Native_handle">  Native handle </h5> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="shared_mutex/native_handle.html" title="cpp/thread/shared mutex/native handle"> <span class="t-lines"><span>native_handle</span></span></a></div> </td> <td> returns the underlying implementation-defined native handle object <br> <span class="t-mark">(public member function)</span>  </td>
</tr> </table> <h3 id="Example"> Example</h3> <div class="t-example">
<p>The output below was generated on a single-core machine. When <code>thread1</code> starts, it enters the loop for the first time and calls <code>increment()</code> followed by <code>get()</code>. However, before it can print the returned value to <a href="http://en.cppreference.com/w/cpp/io/cout"><span class="kw1762">std::<span class="me2">cout</span></span></a>, the scheduler puts <code>thread1</code> to sleep and wakes up <code>thread2</code>, which obviously has time enough to run all three loop iterations at once. Back to <code>thread1</code>, still in the first loop iteration, it finally prints its local copy of the counter's value, which is <code>1</code>, to <code>std::cout</code> and then runs the remaining two loop iterations. On a multi-core machine, none of the threads is put to sleep and the output is more likely to be in ascending order.</p>
<div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;shared_mutex&gt;
#include &lt;syncstream&gt;
#include &lt;thread&gt;
 
class ThreadSafeCounter
{
public:
    ThreadSafeCounter() = default;
 
    // Multiple threads/readers can read the counter's value at the same time.
    unsigned int get() const
    {
        std::shared_lock lock(mutex_);
        return value_;
    }
 
    // Only one thread/writer can increment/write the counter's value.
    void increment()
    {
        std::unique_lock lock(mutex_);
        ++value_;
    }
 
    // Only one thread/writer can reset/write the counter's value.
    void reset()
    {
        std::unique_lock lock(mutex_);
        value_ = 0;
    }
 
private:
    mutable std::shared_mutex mutex_;
    unsigned int value_{};
};
 
int main()
{
    ThreadSafeCounter counter;
 
    auto increment_and_print = [&amp;counter]()
    {
        for (int i{}; i != 3; ++i)
        {
            counter.increment();
            std::osyncstream(std::cout)
                &lt;&lt; std::this_thread::get_id() &lt;&lt; ' ' &lt;&lt; counter.get() &lt;&lt; '\n';
        }
    };
 
    std::thread thread1(increment_and_print);
    std::thread thread2(increment_and_print);
 
    thread1.join();
    thread2.join();
}</pre></div> <p>Possible output:</p>
<div class="text source-text"><pre data-language="c">123084176803584 2
123084176803584 3
123084176803584 4
123084185655040 1
123084185655040 5
123084185655040 6</pre></div> </div> <h3 id="See_also"> See also</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="shared_timed_mutex.html" title="cpp/thread/shared timed mutex"> <span class="t-lines"><span>shared_timed_mutex</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx14">(C++14)</span></span></span></div> </td> <td> provides shared mutual exclusion facility and implements locking with a timeout <br> <span class="t-mark">(class)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="shared_lock.html" title="cpp/thread/shared lock"> <span class="t-lines"><span>shared_lock</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx14">(C++14)</span></span></span></div> </td> <td> implements movable shared mutex ownership wrapper <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="unique_lock.html" title="cpp/thread/unique lock"> <span class="t-lines"><span>unique_lock</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> implements movable mutex ownership wrapper <br> <span class="t-mark">(class template)</span>  </td>
</tr> </table>           <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/thread/shared_mutex" class="_attribution-link">https://en.cppreference.com/w/cpp/thread/shared_mutex</a>
  </p>
</div>
