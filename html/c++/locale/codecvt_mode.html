    <h1 id="firstHeading" class="firstHeading">std::codecvt_mode</h1>            <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th> Defined in header <code><a href="../header/codecvt.html" title="cpp/header/codecvt">&lt;codecvt&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx11 t-until-cxx26"> <td> <pre data-language="cpp">enum codecvt_mode {
    consume_header = 4,
    generate_header = 2,
    little_endian = 1
};</pre>
</td> <td class="t-dcl-nopad"> </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> <br><span class="t-mark">(deprecated in C++17)</span> <br><span class="t-mark-rev t-until-cxx26">(removed in C++26)</span> </td> </tr>  </table> <p>The facets <code><a href="codecvt_utf8.html" title="cpp/locale/codecvt utf8">std::codecvt_utf8</a></code>, <code><a href="codecvt_utf16.html" title="cpp/locale/codecvt utf16">std::codecvt_utf16</a></code>, and <code><a href="codecvt_utf8_utf16.html" title="cpp/locale/codecvt utf8 utf16">std::codecvt_utf8_utf16</a></code> accept an optional value of type <code>std::codecvt_mode</code> as a template argument, which specifies optional features of the unicode string conversion.</p>
<h3 id="Constants"> Constants</h3> <table class="t-dsc-begin"> <tr class="t-dsc-header"> <th colspan="2"> Defined in header <code><a href="../header/locale.html" title="cpp/header/locale">&lt;locale&gt;</a></code>  </th>
</tr> <tr class="t-dsc-hitem"> <th> Value </th> <th> Meaning </th>
</tr> <tr class="t-dsc"> <td> <code>little_endian</code> </td> <td> assume the input is in little-endian byte order (applies to UTF-16 input only, the default is big-endian) </td>
</tr> <tr class="t-dsc"> <td> <code>consume_header</code> </td> <td> consume the byte order mark, if present at the start of input sequence, and (in case of UTF-16), rely on the byte order it specifies for decoding the rest of the input </td>
</tr> <tr class="t-dsc"> <td> <code>generate_header</code> </td> <td> output the byte order mark at the start of the output sequence </td>
</tr> </table> <p>The recognized byte order marks are:</p>
<table class="t-dsc-begin"> <tr class="t-dsc"> <td> <code>0xfe 0xff</code> </td> <td> UTF-16 big-endian </td>
</tr> <tr class="t-dsc"> <td> <code>0xff 0xfe</code> </td> <td> UTF-16 little-endian </td>
</tr> <tr class="t-dsc"> <td> <code>0xef 0xbb 0xbf</code> </td> <td> UTF-8 (no effect on endianness) </td>
</tr> </table> <p>If <code>std::consume_header</code> is not selected when reading a file beginning with byte order mark, the Unicode character U+FEFF (Zero width non-breaking space) will be read as the first character of the string content.</p>
<h3 id="Example"> Example</h3> <div class="t-example">
<p>The following example demonstrates consuming the UTF-8 BOM:</p>
<div class="cpp source-cpp"><pre data-language="cpp">#include &lt;codecvt&gt;
#include &lt;cwchar&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;locale&gt;
#include &lt;string&gt;
 
int main()
{
    // UTF-8 data with BOM
    std::ofstream{"text.txt"} &lt;&lt; "\ufeffz\u6c34\U0001d10b";
 
    // read the UTF-8 file, skipping the BOM
    std::wifstream fin{"text.txt"};
    fin.imbue(std::locale(fin.getloc(),
                          new std::codecvt_utf8&lt;wchar_t, 0x10ffff, std::consume_header&gt;));
 
    for (wchar_t c; fin.get(c);)
        std::cout &lt;&lt; std::hex &lt;&lt; std::showbase &lt;&lt; (std::wint_t)c &lt;&lt; '\n';
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">0x7a
0x6c34
0x1d10b</pre></div> </div> <h3 id="See_also"> See also</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="codecvt.html" title="cpp/locale/codecvt"> <span class="t-lines"><span>codecvt</span></span></a></div> </td> <td> converts between character encodings, including UTF-8, UTF-16, UTF-32 <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="codecvt_utf8.html" title="cpp/locale/codecvt utf8"> <span class="t-lines"><span>codecvt_utf8</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span><span class="t-mark-rev t-deprecated-cxx17">(deprecated in C++17)</span><span class="t-mark-rev t-until-cxx26">(removed in C++26)</span></span></span></div> </td> <td> converts between UTF-8 and UCS-2/UCS-4 <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="codecvt_utf16.html" title="cpp/locale/codecvt utf16"> <span class="t-lines"><span>codecvt_utf16</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span><span class="t-mark-rev t-deprecated-cxx17">(deprecated in C++17)</span><span class="t-mark-rev t-until-cxx26">(removed in C++26)</span></span></span></div> </td> <td> converts between UTF-16 and UCS-2/UCS-4 <br> <span class="t-mark">(class template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="codecvt_utf8_utf16.html" title="cpp/locale/codecvt utf8 utf16"> <span class="t-lines"><span>codecvt_utf8_utf16</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span><span class="t-mark-rev t-deprecated-cxx17">(deprecated in C++17)</span><span class="t-mark-rev t-until-cxx26">(removed in C++26)</span></span></span></div> </td> <td> converts between UTF-8 and UTF-16 <br> <span class="t-mark">(class template)</span>  </td>
</tr> </table>           <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/locale/codecvt_mode" class="_attribution-link">https://en.cppreference.com/w/cpp/locale/codecvt_mode</a>
  </p>
</div>
