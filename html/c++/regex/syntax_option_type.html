    <h1 id="firstHeading" class="firstHeading">std::regex_constants::syntax_option_type</h1>            <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th> Defined in header <code><a href="../header/regex.html" title="cpp/header/regex">&lt;regex&gt;</a></code> </th> <th> </th> <th> </th> </tr> <tr class="t-dcl t-since-cxx11"> <td> <pre data-language="cpp">using syntax_option_type = /* implementation-defined */;</pre>
</td> <td> (1) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td> </tr>  <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(2)</td> <td></td> </tr> <tr class="t-dcl t-since-cxx11 t-until-cxx17"> <td><pre data-language="cpp">constexpr syntax_option_type icase      = /* unspecified */;
constexpr syntax_option_type nosubs     = /* unspecified */;
constexpr syntax_option_type optimize   = /* unspecified */;
constexpr syntax_option_type collate    = /* unspecified */;
constexpr syntax_option_type ECMAScript = /* unspecified */;
constexpr syntax_option_type basic      = /* unspecified */;
constexpr syntax_option_type extended   = /* unspecified */;
constexpr syntax_option_type awk        = /* unspecified */;
constexpr syntax_option_type grep       = /* unspecified */;
constexpr syntax_option_type egrep      = /* unspecified */;</pre></td>  <td>
<span class="t-mark-rev t-since-cxx11">(since C++11)</span> <br><span class="t-mark-rev t-until-cxx17">(until C++17)</span>
</td> </tr> <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">inline constexpr syntax_option_type icase      = /* unspecified */;
inline constexpr syntax_option_type nosubs     = /* unspecified */;
inline constexpr syntax_option_type optimize   = /* unspecified */;
inline constexpr syntax_option_type collate    = /* unspecified */;
inline constexpr syntax_option_type ECMAScript = /* unspecified */;
inline constexpr syntax_option_type basic      = /* unspecified */;
inline constexpr syntax_option_type extended   = /* unspecified */;
inline constexpr syntax_option_type awk        = /* unspecified */;
inline constexpr syntax_option_type grep       = /* unspecified */;
inline constexpr syntax_option_type egrep      = /* unspecified */;</pre>
</td>  <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr>  <tr class="t-dcl t-since-cxx17"> <td> <pre data-language="cpp">inline constexpr syntax_option_type multiline  = /* unspecified */;</pre>
</td> <td> (3) </td> <td> <span class="t-mark-rev t-since-cxx17">(since C++17)</span> </td> </tr>  </table> <div class="t-li1">
<span class="t-li">1)</span> The <code>syntax_option_type</code> is a <a href="../named_req/bitmasktype.html" title="cpp/named req/BitmaskType">BitmaskType</a> that contains options that govern how regular expressions behave.</div> <div class="t-li1">
<span class="t-li">2,3)</span> The possible values (<code>icase</code>, <code>optimize</code>, etc.) for type <span class="t-v">(1)</span> are duplicated inside <a href="basic_regex/constants.html" title="cpp/regex/basic regex/constants"><code>std::basic_regex</code></a>.</div>  <h3 id="Constants"> Constants</h3> <table class="t-dsc-begin"> <tr class="t-dsc-hitem"> <th> Value </th> <th> Effect(s) </th>
</tr> <tr class="t-dsc"> <td> <code>icase</code> </td> <td> Character matching should be performed without regard to case. </td>
</tr> <tr class="t-dsc"> <td> <code>nosubs</code> </td> <td> When performing matches, all marked sub-expressions <code>(<span class="t-spar">expr</span>)</code> are treated as non-marking sub-expressions <code>(?:<span class="t-spar">expr</span>)</code>. No matches are stored in the supplied <code><a href="regex_match.html" title="cpp/regex/regex match">std::regex_match</a></code> structure and <code>mark_count()</code> is zero. </td>
</tr> <tr class="t-dsc"> <td> <code>optimize</code> </td> <td> Instructs the regular expression engine to make matching faster, with the potential cost of making construction slower. For example, this might mean converting a non-deterministic FSA to a deterministic FSA. </td>
</tr> <tr class="t-dsc"> <td> <code>collate</code> </td> <td> Character ranges of the form <i>"[a-b]"</i> will be locale sensitive. </td>
</tr> <tr class="t-dsc"> <td> <code>multiline</code> <span class="t-mark-rev t-since-cxx17">(C++17)</span> </td> <td> Specifies that <code>^</code> shall match the beginning of a line and <code>$</code> shall match the end of a line, if the ECMAScript engine is selected. </td>
</tr> <tr class="t-dsc"> <td> <code>ECMAScript</code> </td> <td> Use the <a href="ecmascript.html" title="cpp/regex/ecmascript">Modified ECMAScript regular expression grammar</a>. </td>
</tr> <tr class="t-dsc"> <td> <code>basic</code> </td> <td> Use the basic POSIX regular expression grammar (<a rel="nofollow" class="external text" href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_03">grammar documentation</a>). </td>
</tr> <tr class="t-dsc"> <td> <code>extended</code> </td> <td> Use the extended POSIX regular expression grammar (<a rel="nofollow" class="external text" href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_04">grammar documentation</a>). </td>
</tr> <tr class="t-dsc"> <td> <code>awk</code> </td> <td> Use the regular expression grammar used by the <i>awk</i> utility in POSIX (<a rel="nofollow" class="external text" href="https://pubs.opengroup.org/onlinepubs/9699919799/utilities/awk.html#tag_20_06_13_04">grammar documentation</a>). </td>
</tr> <tr class="t-dsc"> <td> <code>grep</code> </td> <td> Use the regular expression grammar used by the <i>grep</i> utility in POSIX. This is effectively the same as the <code>basic</code> option with the addition of newline <code>'\n'</code> as an alternation separator. </td>
</tr> <tr class="t-dsc"> <td> <code>egrep</code> </td> <td> Use the regular expression grammar used by the <i>grep</i> utility, with the <i>-E</i> option, in POSIX. This is effectively the same as the <code>extended</code> option with the addition of newline <code>'\n'</code> as an alternation separator in addition to <code>'|'</code>. </td>
</tr> </table> <p>At most one grammar option must be chosen out of <code>ECMAScript</code>, <code>basic</code>, <code>extended</code>, <code>awk</code>, <code>grep</code>, <code>egrep</code>. If no grammar is chosen, <code>ECMAScript</code> is assumed to be selected. The other options serve as modifiers, such that <code><a href="http://en.cppreference.com/w/cpp/regex/basic_regex"><span class="kw2004">std::<span class="me2">regex</span></span></a><span class="br0">(</span><span class="st0">"meow"</span>, std<span class="sy4">::</span><span class="me2">regex</span><span class="sy4">::</span><span class="me2">icase</span><span class="br0">)</span></code> is equivalent to <code><a href="http://en.cppreference.com/w/cpp/regex/basic_regex"><span class="kw2004">std::<span class="me2">regex</span></span></a><span class="br0">(</span><span class="st0">"meow"</span>, std<span class="sy4">::</span><span class="me2">regex</span><span class="sy4">::</span><span class="me2">ECMAScript</span><span class="sy3">|</span>std<span class="sy4">::</span><span class="me2">regex</span><span class="sy4">::</span><span class="me2">icase</span><span class="br0">)</span></code>.</p>
<h3 id="Notes"> Notes</h3> <p>Because POSIX uses "leftmost longest" matching rule (the longest matching subsequence is matched, and if there are several such subsequences, the first one is matched), it is not suitable, for example, for parsing markup languages: a POSIX regex such as <code>"&lt;tag[^&gt;]*&gt;.*&lt;/tag&gt;"</code> would match everything from the first <code>"&lt;tag"</code> to the last <code>"&lt;/tag&gt;"</code>, including every <code>"&lt;/tag&gt;"</code> and <code>"&lt;tag&gt;"</code> in-between. On the other hand, ECMAScript supports non-greedy matches, and the ECMAScript regex <code>"&lt;tag[^&gt;]*&gt;.*?&lt;/tag&gt;"</code> would match only until the first closing tag.</p>
<h3 id="Example"> Example</h3> <div class="t-example">
<p>Illustrates the difference in the matching algorithm between ECMAScript and POSIX regular expressions:</p>
<div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
#include &lt;regex&gt;
#include &lt;string&gt;
 
int main()
{
    std::string str = "zzxayyzz";
    std::regex re1(".*(a|xayy)"); // ECMA
    std::regex re2(".*(a|xayy)", std::regex::extended); // POSIX
 
    std::cout &lt;&lt; "Searching for .*(a|xayy) in zzxayyzz:\n";
    std::smatch m;
    std::regex_search(str, m, re1);
    std::cout &lt;&lt; "  ECMA (depth first search) match: " &lt;&lt; m[0] &lt;&lt; '\n';
    std::regex_search(str, m, re2);
    std::cout &lt;&lt; "  POSIX (leftmost longest)  match: " &lt;&lt; m[0] &lt;&lt; '\n';
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">Searching for .*(a|xayy) in zzxayyzz:
  ECMA (depth first search) match: zzxa
  POSIX (leftmost longest)  match: zzxayy</pre></div> </div> <h3 id="Defect_reports"> Defect reports</h3> <p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.</p>
<table class="dsctable"> <tr> <th>DR </th> <th>Applied to </th> <th>Behavior as published </th> <th>Correct behavior </th>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/LWG/issue2053">LWG 2053</a> </td> <td>C++11 </td> <td>the constants were declared <span class="kw4">static</span> </td> <td>removed the <span class="kw4">static</span> specifier </td>
</tr>
</table> <h3 id="See_also"> See also</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="basic_regex.html" title="cpp/regex/basic regex"> <span class="t-lines"><span>basic_regex</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> regular expression object <br> <span class="t-mark">(class template)</span>  </td>
</tr> </table>           <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/regex/syntax_option_type" class="_attribution-link">https://en.cppreference.com/w/cpp/regex/syntax_option_type</a>
  </p>
</div>
