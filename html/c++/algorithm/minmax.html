    <h1 id="firstHeading" class="firstHeading">std::minmax</h1>            <table class="t-dcl-begin"> <tr class="t-dsc-header"> <th> Defined in header <code><a href="../header/algorithm.html" title="cpp/header/algorithm">&lt;algorithm&gt;</a></code> </th> <th> </th> <th> </th> </tr>  <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(1)</td> <td></td> </tr> <tr class="t-dcl t-since-cxx11 t-until-cxx14"> <td><pre data-language="cpp">template&lt; class T &gt;
std::pair&lt;const T&amp;, const T&amp;&gt; minmax( const T&amp; a, const T&amp; b );</pre></td>  <td>
<span class="t-mark-rev t-since-cxx11">(since C++11)</span> <br><span class="t-mark-rev t-until-cxx14">(until C++14)</span>
</td> </tr> <tr class="t-dcl t-since-cxx14"> <td> <pre data-language="cpp">template&lt; class T &gt;
constexpr std::pair&lt;const T&amp;, const T&amp;&gt; minmax( const T&amp; a, const T&amp; b );</pre>
</td>  <td> <span class="t-mark-rev t-since-cxx14">(since C++14)</span> </td> </tr>   <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(2)</td> <td></td> </tr> <tr class="t-dcl t-since-cxx11 t-until-cxx14"> <td><pre data-language="cpp">template&lt; class T, class Compare &gt;
std::pair&lt;const T&amp;, const T&amp;&gt; minmax( const T&amp; a, const T&amp; b,
                                      Compare comp );</pre></td>  <td>
<span class="t-mark-rev t-since-cxx11">(since C++11)</span> <br><span class="t-mark-rev t-until-cxx14">(until C++14)</span>
</td> </tr> <tr class="t-dcl t-since-cxx14"> <td> <pre data-language="cpp">template&lt; class T, class Compare &gt;
constexpr std::pair&lt;const T&amp;, const T&amp;&gt; minmax( const T&amp; a, const T&amp; b,
                                                Compare comp );</pre>
</td>  <td> <span class="t-mark-rev t-since-cxx14">(since C++14)</span> </td> </tr>   <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(3)</td> <td></td> </tr> <tr class="t-dcl t-since-cxx11 t-until-cxx14"> <td><pre data-language="cpp">template&lt; class T &gt;
std::pair&lt;T, T&gt; minmax( std::initializer_list&lt;T&gt; ilist );</pre></td>  <td>
<span class="t-mark-rev t-since-cxx11">(since C++11)</span> <br><span class="t-mark-rev t-until-cxx14">(until C++14)</span>
</td> </tr> <tr class="t-dcl t-since-cxx14"> <td> <pre data-language="cpp">template&lt; class T &gt;
constexpr std::pair&lt;T, T&gt; minmax( std::initializer_list&lt;T&gt; ilist );</pre>
</td>  <td> <span class="t-mark-rev t-since-cxx14">(since C++14)</span> </td> </tr>   <tr class="t-dcl-rev-aux"> <td></td> <td rowspan="3">(4)</td> <td></td> </tr> <tr class="t-dcl t-since-cxx11 t-until-cxx14"> <td><pre data-language="cpp">template&lt; class T, class Compare &gt;
std::pair&lt;T, T&gt; minmax( std::initializer_list&lt;T&gt; ilist, Compare comp );</pre></td>  <td>
<span class="t-mark-rev t-since-cxx11">(since C++11)</span> <br><span class="t-mark-rev t-until-cxx14">(until C++14)</span>
</td> </tr> <tr class="t-dcl t-since-cxx14"> <td> <pre data-language="cpp">template&lt; class T, class Compare &gt;
constexpr std::pair&lt;T, T&gt; minmax( std::initializer_list&lt;T&gt; ilist, Compare comp );</pre>
</td>  <td> <span class="t-mark-rev t-since-cxx14">(since C++14)</span> </td> </tr>   </table> <p>Returns the lowest and the greatest of the given values.</p>
<div class="t-li1">
<span class="t-li">1,2)</span> Returns references to the smaller and the greater of <code>a</code> and <code>b</code>.</div> <div class="t-li1">
<span class="t-li">3,4)</span> Returns the smallest and the greatest of the values in initializer list <code>ilist</code>.</div> <p>The <span class="t-v">(1,3)</span> versions use <code>operator&lt;</code> to compare the values, whereas the <span class="t-v">(2,4)</span> versions use the given comparison function <code>comp</code>.</p>
<h3 id="Parameters"> Parameters</h3> <table class="t-par-begin"> <tr class="t-par"> <td> a, b </td> <td> - </td> <td> the values to compare </td>
</tr> <tr class="t-par"> <td> ilist </td> <td> - </td> <td> initializer list with the values to compare </td>
</tr> <tr class="t-par"> <td> comp </td> <td> - </td> <td> comparison function object (i.e. an object that satisfies the requirements of <a href="../named_req/compare.html" title="cpp/named req/Compare">Compare</a>) which returns <code>true</code> if the first argument is <i>less</i> than the second.<br> <p>The signature of the comparison function should be equivalent to the following:</p>
<p><span class="t-cc"><code>bool cmp(const Type1&amp; a, const Type2&amp; b);</code></span></p>
<p>While the signature does not need to have <code>const&amp;</code>, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) <code>Type1</code> and <code>Type2</code> regardless of <a href="../language/value_category.html" title="cpp/language/value category">value category</a> (thus, <code>Type1&amp;</code> is not allowed<span class="t-rev-inl t-since-cxx11"><span>, nor is <code>Type1</code> unless for <code>Type1</code> a move is equivalent to a copy</span><span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span>).<br> The types Type1 and Type2 must be such that an object of type T can be implicitly converted to both of them.</p>
</td>
</tr> <tr class="t-par-hitem"> <td colspan="3"> Type requirements </td>
</tr> <tr class="t-par-req"> <td colspan="3"> -<code>T</code> must meet the requirements of <a href="../named_req/lessthancomparable.html" title="cpp/named req/LessThanComparable">LessThanComparable</a> in order to use overloads (1,3). </td>
</tr> <tr class="t-par-req"> <td colspan="3"> -<code>T</code> must meet the requirements of <a href="../named_req/copyconstructible.html" title="cpp/named req/CopyConstructible">CopyConstructible</a> in order to use overloads (3,4). </td>
</tr>
</table> <h3 id="Return_value"> Return value</h3> <div class="t-li1">
<span class="t-li">1,2)</span> Returns the result of <code><a href="http://en.cppreference.com/w/cpp/utility/pair"><span class="kw1099">std::<span class="me2">pair</span></span></a><span class="sy1">&lt;</span><span class="kw4">const</span> T<span class="sy3">&amp;</span>, <span class="kw4">const</span> T<span class="sy3">&amp;</span><span class="sy1">&gt;</span><span class="br0">(</span>a, b<span class="br0">)</span></code> if <code>a &lt; b</code> or if <code>a</code> is equivalent to <code>b</code>. Returns the result of <code><a href="http://en.cppreference.com/w/cpp/utility/pair"><span class="kw1099">std::<span class="me2">pair</span></span></a><span class="sy1">&lt;</span><span class="kw4">const</span> T<span class="sy3">&amp;</span>, <span class="kw4">const</span> T<span class="sy3">&amp;</span><span class="sy1">&gt;</span><span class="br0">(</span>b, a<span class="br0">)</span></code> if <code>b &lt; a</code>.</div> <div class="t-li1">
<span class="t-li">3,4)</span> A pair with the smallest value in <code>ilist</code> as the first element and the greatest as the second. If several elements are equivalent to the smallest, the leftmost such element is returned. If several elements are equivalent to the largest, the rightmost such element is returned.</div> <h3 id="Complexity"> Complexity</h3> <div class="t-li1">
<span class="t-li">1,2)</span> Exactly one comparison.</div> <div class="t-li1">
<span class="t-li">3,4)</span> At most <code>ilist.size() * 3 / 2</code> comparisons.</div> <h3 id="Possible_implementation"> Possible implementation</h3> <table class="eq-fun-cpp-table"> <tr> <th>
<a href="#Version_1">minmax (1)</a> </th>
</tr> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class T&gt;
constexpr std::pair&lt;const T&amp;, const T&amp;&gt; minmax(const T&amp; a, const T&amp; b)
{
    return (b &lt; a) ? std::pair&lt;const T&amp;, const T&amp;&gt;(b, a)
                   : std::pair&lt;const T&amp;, const T&amp;&gt;(a, b);
}</pre></div> </td>
</tr> <tr> <th>
<a href="#Version_2">minmax (2)</a> </th>
</tr> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class T, class Compare&gt;
constexpr std::pair&lt;const T&amp;, const T&amp;&gt; minmax(const T&amp; a, const T&amp; b, Compare comp)
{
    return comp(b, a) ? std::pair&lt;const T&amp;, const T&amp;&gt;(b, a)
                      : std::pair&lt;const T&amp;, const T&amp;&gt;(a, b);
}</pre></div> </td>
</tr> <tr> <th>
<a href="#Version_3">minmax (3)</a> </th>
</tr> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class T&gt;
constexpr std::pair&lt;T, T&gt; minmax(std::initializer_list&lt;T&gt; ilist)
{
    auto p = std::minmax_element(ilist.begin(), ilist.end());
    return std::pair(*p.first, *p.second);
}</pre></div> </td>
</tr> <tr> <th>
<a href="#Version_4">minmax (4)</a> </th>
</tr> <tr> <td> <div class="cpp source-cpp"><pre data-language="cpp">template&lt;class T, class Compare&gt;
constexpr std::pair&lt;T, T&gt; minmax(std::initializer_list&lt;T&gt; ilist, Compare comp)
{
    auto p = std::minmax_element(ilist.begin(), ilist.end(), comp);
    return std::pair(*p.first, *p.second);
}</pre></div> </td>
</tr>
</table> <h3 id="Notes"> Notes</h3> <p>For overloads <span class="t-v">(1,2)</span>, if one of the parameters is a temporary, the reference returned becomes a dangling reference at the end of the full expression that contains the call to <code>minmax</code>:</p>
<div class="cpp source-cpp"><pre data-language="cpp">int n = 1;
auto p = std::minmax(n, n + 1);
int m = p.first; // ok
int x = p.second; // undefined behavior
 
// Note that structured bindings have the same issue
auto [mm, xx] = std::minmax(n, n + 1);
xx; // undefined behavior</pre></div> <h3 id="Example"> Example</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;algorithm&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
 
int main()
{
    std::vector&lt;int&gt; v{3, 1, 4, 1, 5, 9, 2, 6};
    std::srand(std::time(0));
    std::pair&lt;int, int&gt; bounds = std::minmax(std::rand() % v.size(),
                                             std::rand() % v.size());
 
    std::cout &lt;&lt; "v[" &lt;&lt; bounds.first &lt;&lt; "," &lt;&lt; bounds.second &lt;&lt; "]: ";
    for (int i = bounds.first; i &lt; bounds.second; ++i)
        std::cout &lt;&lt; v[i] &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}</pre></div> <p>Possible output:</p>
<div class="text source-text"><pre data-language="c">v[2,7]: 4 1 5 9 2</pre></div> </div> <h3 id="See_also"> See also</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="min.html" title="cpp/algorithm/min"> <span class="t-lines"><span>min</span></span></a></div> </td> <td> returns the smaller of the given values <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="max.html" title="cpp/algorithm/max"> <span class="t-lines"><span>max</span></span></a></div> </td> <td> returns the greater of the given values <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="minmax_element.html" title="cpp/algorithm/minmax element"> <span class="t-lines"><span>minmax_element</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> returns the smallest and the largest elements in a range <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="ranges/minmax.html" title="cpp/algorithm/ranges/minmax"> <span class="t-lines"><span>ranges::minmax</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> returns the smaller and larger of two elements<br><span class="t-mark">(niebloid)</span> </td>
</tr> </table>           <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/algorithm/minmax" class="_attribution-link">https://en.cppreference.com/w/cpp/algorithm/minmax</a>
  </p>
</div>
