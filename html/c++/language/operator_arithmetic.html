    <h1 id="firstHeading" class="firstHeading">Arithmetic operators</h1>            <p>Returns the result of specific arithmetic operation.</p>
<table class="wikitable"> <tr> <th rowspan="2">Operator name </th> <th rowspan="2">Syntax </th> <th rowspan="2">
<a href="operators.html" title="cpp/language/operators">Over​load​able</a> </th> <th colspan="2">Prototype examples (for <span class="kw1">class</span> T) </th>
</tr> <tr> <th>Inside class definition </th> <th>Outside class definition </th>
</tr> <tr> <td>unary plus </td> <td>
<code>+a</code> </td> <td class="table-yes">Yes </td> <td>
<code>T T::operator+() const;</code> </td> <td>
<code>T operator+(const T &amp;a);</code> </td>
</tr> <tr> <td>unary minus </td> <td>
<code>-a</code> </td> <td class="table-yes">Yes </td> <td>
<code>T T::operator-() const;</code> </td> <td>
<code>T operator-(const T &amp;a);</code> </td>
</tr> <tr> <td>addition </td> <td>
<code>a + b</code> </td> <td class="table-yes">Yes </td> <td>
<code>T T::operator+(const T2 &amp;b) const;</code> </td> <td>
<code>T operator+(const T &amp;a, const T2 &amp;b);</code> </td>
</tr> <tr> <td>subtraction </td> <td>
<code>a - b</code> </td> <td class="table-yes">Yes </td> <td>
<code>T T::operator-(const T2 &amp;b) const;</code> </td> <td>
<code>T operator-(const T &amp;a, const T2 &amp;b);</code> </td>
</tr> <tr> <td>multiplication </td> <td>
<code>a * b</code> </td> <td class="table-yes">Yes </td> <td>
<code>T T::operator*(const T2 &amp;b) const;</code> </td> <td>
<code>T operator*(const T &amp;a, const T2 &amp;b);</code> </td>
</tr> <tr> <td>division </td> <td>
<code>a / b</code> </td> <td class="table-yes">Yes </td> <td>
<code>T T::operator/(const T2 &amp;b) const;</code> </td> <td>
<code>T operator/(const T &amp;a, const T2 &amp;b);</code> </td>
</tr> <tr> <td>remainder </td> <td>
<code>a % b</code> </td> <td class="table-yes">Yes </td> <td>
<code>T T::operator%(const T2 &amp;b) const;</code> </td> <td>
<code>T operator%(const T &amp;a, const T2 &amp;b);</code> </td>
</tr> <tr> <td>bitwise NOT </td> <td>
<code>~a</code> </td> <td class="table-yes">Yes </td> <td>
<code>T T::operator~() const;</code> </td> <td>
<code>T operator~(const T &amp;a);</code> </td>
</tr> <tr> <td>bitwise AND </td> <td>
<code>a &amp; b</code> </td> <td class="table-yes">Yes </td> <td>
<code>T T::operator&amp;(const T2 &amp;b) const;</code> </td> <td>
<code>T operator&amp;(const T &amp;a, const T2 &amp;b);</code> </td>
</tr> <tr> <td>bitwise OR </td> <td>
<code>a | b</code> </td> <td class="table-yes">Yes </td> <td>
<code>T T::operator|(const T2 &amp;b) const;</code> </td> <td>
<code>T operator|(const T &amp;a, const T2 &amp;b);</code> </td>
</tr> <tr> <td>bitwise XOR </td> <td>
<code>a ^ b</code> </td> <td class="table-yes">Yes </td> <td>
<code>T T::operator^(const T2 &amp;b) const;</code> </td> <td>
<code>T operator^(const T &amp;a, const T2 &amp;b);</code> </td>
</tr> <tr> <td>bitwise left shift </td> <td>
<code>a &lt;&lt; b</code> </td> <td class="table-yes">Yes </td> <td>
<code>T T::operator&lt;&lt;(const T2 &amp;b) const;</code> </td> <td>
<code>T operator&lt;&lt;(const T &amp;a, const T2 &amp;b);</code> </td>
</tr> <tr> <td>bitwise right shift </td> <td>
<code>a &gt;&gt; b</code> </td> <td class="table-yes">Yes </td> <td>
<code>T T::operator&gt;&gt;(const T2 &amp;b) const;</code> </td> <td>
<code>T operator&gt;&gt;(const T &amp;a, const T2 &amp;b);</code> </td>
</tr> <tr> <td colspan="5"> <b>Notes</b><br>  <ul>
<li> All built-in operators return values, and most <a href="operators.html" title="cpp/language/operators">user-defined overloads</a> also return values so that the user-defined operators can be used in the same manner as the built-ins. However, in a user-defined operator overload, any type can be used as return type (including <span class="kw4">void</span>). In particular, stream insertion and stream extraction overloads of operator<span class="sy1">&lt;&lt;</span> and operator<span class="sy1">&gt;&gt;</span> return <code>T&amp;</code>. </li>
<li> <code>T2</code> can be any type including <code>T</code>. </li>
</ul> </td>
</tr>
</table>  <h3 id="General_explanation"> General explanation</h3> <p>All built-in arithmetic operators compute the result of specific arithmetic operation and returns its result. The arguments are not modified.</p>
<h4 id="Conversions"> Conversions</h4> <p>If the operand passed to a built-in arithmetic operator is integral or unscoped enumeration type, then before any other action (but after lvalue-to-rvalue conversion, if applicable), the operand undergoes <a href="implicit_conversion.html#Integral_promotion" title="cpp/language/implicit conversion">integral promotion</a>. If an operand has array or function type, <a href="implicit_conversion.html#Array-to-pointer_conversion" title="cpp/language/implicit conversion">array-to-pointer</a> and <a href="implicit_conversion.html#Function-to-pointer" title="cpp/language/implicit conversion">function-to-pointer</a> conversions are applied.</p>
<p>For the binary operators (except shifts), if the promoted operands have different types, <a href="usual_arithmetic_conversions.html" title="cpp/language/usual arithmetic conversions">usual arithmetic conversions</a> are applied.</p>
<h4 id="Overflows"> Overflows</h4> <p>Unsigned integer arithmetic is always performed modulo 2<sup class="t-su">n</sup> where n is the number of bits in that particular integer. E.g. for <span class="kw4">unsigned</span> <span class="kw4">int</span>, adding one to <code><a href="../types/climits.html" title="cpp/types/climits">UINT_MAX</a></code> gives <code>​0​</code>, and subtracting one from <code>​0​</code> gives <code><a href="../types/climits.html" title="cpp/types/climits">UINT_MAX</a></code>.</p>
<p>When signed integer arithmetic operation overflows (the result does not fit in the result type), the behavior is undefined, — the possible manifestations of such an operation include:</p>
<ul>
<li> it wraps around according to the rules of the representation (typically <a href="types.html#Range_of_values" title="cpp/language/types">two's complement</a>), </li>
<li> it traps — on some platforms or due to compiler options (e.g. <code>-ftrapv</code> in GCC and Clang), </li>
<li> it saturates to minimal or maximal value (on many DSPs), </li>
<li> it is completely <a rel="nofollow" class="external text" href="https://blog.llvm.org/2011/05/what-every-c-programmer-should-know_14.html">optimized out by the compiler</a>. </li>
</ul> <h4 id="Floating-point_environment"> Floating-point environment</h4> <p>If <a href="../preprocessor/impl.html" title="cpp/preprocessor/impl"><code> #pragma STDC FENV_ACCESS</code></a> is supported and set to <code>ON</code>, all floating-point arithmetic operators obey the current floating-point <a href="../numeric/fenv/fe_round.html" title="cpp/numeric/fenv/FE round">rounding direction</a> and report floating-point arithmetic errors as specified in <a href="../numeric/math/math_errhandling.html" title="cpp/numeric/math/math errhandling"><code>math_errhandling</code></a> unless part of a <a href="initialization.html#Non-local_variables" title="cpp/language/initialization">static initializer</a> (in which case floating-point exceptions are not raised and the rounding mode is to nearest).</p>
<h4 id="Floating-point_contraction"> Floating-point contraction</h4> <p>Unless <a href="../preprocessor/impl.html" title="cpp/preprocessor/impl"><code> #pragma STDC FP_CONTRACT</code></a> is supported and set to <code>OFF</code>, all floating-point arithmetic may be performed as if the intermediate results have infinite range and precision, that is, optimizations that omit rounding errors and floating-point exceptions are allowed. For example, C++ allows the implementation of <code>(x * y) + z</code> with a single fused multiply-add CPU instruction or optimization of <code>a = x * x * x * x;</code> as <code>tmp = x * x; a = tmp * tmp</code>.</p>
<p>Unrelated to contracting, intermediate results of floating-point arithmetic may have range and precision that is different from the one indicated by its type, see <code><a href="../types/climits/flt_eval_method.html" title="cpp/types/climits/FLT EVAL METHOD">FLT_EVAL_METHOD</a></code>.</p>
<p>Formally, the C++ standard makes no guarantee on the accuracy of floating-point operations.</p>
<h3 id="Unary_arithmetic_operators"> Unary arithmetic operators</h3> <p>The unary arithmetic operator expressions have the form</p>
<table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <code>+</code> <span class="t-spar">expression</span> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>-</code> <span class="t-spar">expression</span> </td> <td> (2) </td> <td class="t-sdsc-nopad"> </td>
</tr> 
</table> <div class="t-li1">
<span class="t-li">1)</span> Unary plus (promotion).</div> <div class="t-li1">
<span class="t-li">2)</span> Unary minus (negation).</div> <p>Unary <code>+</code> and <code>-</code> operators have higher <a href="operator_precedence.html" title="cpp/language/operator precedence">precedence</a> than all binary arithmetic operators, so <span class="t-spar">expression</span> cannot contain top-level binary arithmetic operators. These operators associate from right to left:</p>
<div class="cpp source-cpp"><pre data-language="cpp">+a - b; // equivalent to (+a) - b, NOT +(a - b)
-c + d; // equivalent to (-c) + d, NOT -(a + b)
 
+-e; // equivalent to +(-e), the unary + is a no-op if `e` is a built-in type
     // because any possible promotion is performed during negation</pre></div> <h4 id="Built-in_unary_arithmetic_operators"> Built-in unary arithmetic operators</h4> <div class="t-li1">
<span class="t-li">1)</span> For the built-in unary plus operator, <span class="t-spar">expression</span> must be a prvalue of arithmetic, unscoped enumeration, or pointer type. Integral promotion is performed on <span class="t-spar">expression</span> if it has integral or unscoped enumeration type. The type of the result is the (possibly promoted) type of <span class="t-spar">expression</span>.</div> <div class="t-li1">
 The result of the built-in promotion is the value of <span class="t-spar">expression</span>. The built-in unary operation is no-op if the operand is a prvalue of a promoted integral type or a pointer type. Otherwise, the type or value category of the operand is changed by integral promotion or lvalue-to-rvalue, array-to-pointer, function-to-pointer, or user-defined conversion. For example, <code>char</code> is converted to <code>int</code> <span class="t-rev-inl t-since-cxx11"><span>, and non-generic captureless <a href="lambda.html" title="cpp/language/lambda">lambda expression</a> is converted to function pointer</span><span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span> in unary plus expressions.</div> <div class="t-li1">
<span class="t-li">2)</span> For the built-in unary minus operator, <span class="t-spar">expression</span> must be a prvalue of arithmetic or unscoped enumeration type. Integral promotion is performed on <span class="t-spar">expression</span>. The type of the result is the type of the promoted type of <span class="t-spar">expression</span>.</div>  The result of the built-in negation is the negative of the promoted <span class="t-spar">expression</span>. For unsigned <code>a</code>, the value of <code>-a</code> is \({\small 2^N-a}\)2<sup class="t-su">N</sup>-a, where <code>N</code> is the number of bits after promotion. <ul><li> In other words, the result is the two’s complement of the operand (where operand and result are considered as unsigned).</li></ul> <h4 id="Overloads"> Overloads</h4> <p>In <a href="overload_resolution.html#Call_to_an_overloaded_operator" title="cpp/language/overload resolution">overload resolution against user-defined operators</a>, for every cv-unqualified promoted arithmetic type <code>A</code> and for every type <code>T</code>, the following function signatures participate in overload resolution:</p>
<table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">A operator+(A)</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">T* operator+(T*)</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">A operator-(A)</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr>  </table> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
 
int main()
{
    char c = 0x6a;
    int n1 = 1;
    unsigned char n2 = 1;
    unsigned int n3 = 1;
    std::cout &lt;&lt; "char: " &lt;&lt; c &lt;&lt; " int: " &lt;&lt; +c &lt;&lt; "\n"
                 "-1, where 1 is signed: " &lt;&lt; -n1 &lt;&lt; "\n"
                 "-1, where 1 is unsigned char: " &lt;&lt; -n2 &lt;&lt; "\n"
                 "-1, where 1 is unsigned int: " &lt;&lt; -n3 &lt;&lt; '\n';
    char a[3];
    std::cout &lt;&lt; "size of array: " &lt;&lt; sizeof a &lt;&lt; "\n"
                 "size of pointer: " &lt;&lt; sizeof +a &lt;&lt; '\n';
}</pre></div> <p>Possible output:</p>
<div class="text source-text"><pre data-language="c">char: j int: 106
-1, where 1 is signed: -1
-1, where 1 is unsigned char: -1
-1, where 1 is unsigned int: 4294967295
size of array: 3
size of pointer: 8</pre></div> </div> <h3 id="Additive_operators"> Additive operators</h3> <p>The additive operator expressions have the form</p>
<table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <span class="t-spar">lhs</span> <code>+</code> <span class="t-spar">rhs</span> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">lhs</span> <code>-</code> <span class="t-spar">rhs</span> </td> <td> (2) </td> <td class="t-sdsc-nopad"> </td>
</tr> 
</table> <div class="t-li1">
<span class="t-li">1)</span> Binary plus (addition).</div> <div class="t-li1">
<span class="t-li">2)</span> Binary minus (subtraction).</div> <p>Binary <code>+</code> and <code>-</code> operators have higher <a href="operator_precedence.html" title="cpp/language/operator precedence">precedence</a> than all other binary arithmetic operators except <code>*</code>, <code>/</code> and <code>%</code>. These operators associate from left to right:</p>
<div class="cpp source-cpp"><pre data-language="cpp">a + b * c;  // equivalent to a + (b * c),  NOT (a + b) * c
d / e - f;  // equivalent to (d / e) - f,  NOT d / (e - f)
g + h &gt;&gt; i; // equivalent to (g + h) &gt;&gt; i, NOT g + (h &gt;&gt; i)
 
j - k + l - m; // equivalent to ((j - k) + l) - m</pre></div> <h4 id="Built-in_additive_operators"> Built-in additive operators</h4> <p>For built-in binary plus and binary minus operators, both of <span class="t-spar">lhs</span> and <span class="t-spar">rhs</span> must be prvalues, and one of the following conditions must be satisfied:</p>
<ul>
<li> Both operands have arithmetic or unscoped enumeration type. In this case, <a href="usual_arithmetic_conversions.html" title="cpp/language/usual arithmetic conversions">usual arithmetic conversions</a> are performed on both operands. </li>
<li> Exactly one operand has integral or unscoped enumeration type. In this case, integral promotion is applied to that operand. </li>
</ul> <p>In the remaining description in this section, "operand(s)", <span class="t-spar">lhs</span> and <span class="t-spar">rhs</span> refer to the converted or promoted operand(s).</p>
<span class="t-li">1)</span> For built-in addition, one of the following conditions must be satisfied: <ul>
<li> Both operands have arithmetic type. In this case, the result is the sum of the operands. </li>
<li> One operand is a pointer to a completely-defined object type, and the other operand has integral type. In this case, the integral value is added to the pointer (see <a href="#Pointer_arithmetic">pointer arithmetic</a>).</li>
</ul> <span class="t-li">2)</span> For built-in subtraction, one of the following conditions must be satisfied: <ul>
<li> Both operands have arithmetic type. In this case, the result is the difference resulting from the subtraction of <span class="t-spar">rhs</span> from <span class="t-spar">lhs</span>. </li>
<li> <span class="t-spar">lhs</span> is a pointer to a completely-defined object type, and <span class="t-spar">rhs</span> has integral type. In this case, the integral value is subtracted from the pointer (see <a href="#Pointer_arithmetic">pointer arithmetic</a>). </li>
<li> Both operands are pointers to cv-qualified or cv-unqualified versions of the same completely-defined object type. In this case <span class="t-spar">rhs</span> is subtracted from <span class="t-spar">lhs</span> (see <a href="#Pointer_arithmetic">pointer arithmetic</a>).</li>
</ul> <p>If both operands have a floating-point type, and the type supports IEEE floating-point arithmetic (see <code><a href="../types/numeric_limits/is_iec559.html" title="cpp/types/numeric limits/is iec559">std::numeric_limits::is_iec559</a></code>):</p>
<ul>
<li> If one operand is NaN, the result is NaN. </li>
<li> Infinity minus infinity is NaN, and <code><a href="../numeric/fenv/fe_exceptions.html" title="cpp/numeric/fenv/FE exceptions">FE_INVALID</a></code> is raised. </li>
<li> Infinity plus the negative infinity is NaN, and <code><a href="../numeric/fenv/fe_exceptions.html" title="cpp/numeric/fenv/FE exceptions">FE_INVALID</a></code> is raised. </li>
</ul> <h4 id="Pointer_arithmetic"> Pointer arithmetic</h4> <p>When an expression <code>J</code> that has integral type is added to or subtracted from an expression <code>P</code> of pointer type, the result has the type of <code>P</code>.</p>
<ul>
<li> If <code>P</code> evaluates to a <a href="pointer.html#Null_pointers" title="cpp/language/pointer">null pointer value</a> and <code>J</code> evaluates to <code>​0​</code>, the result is a null pointer value. </li>
<li> Otherwise, if <code>P</code> points to the <code>i</code>th element of an array object <code>x</code> with <code>n</code> elements, given the value of <code>J</code> as <code>j</code>, <code>P</code> is added or subtracted as follows: </li>
<li> The expressions <code>P + J</code> and <code>J + P</code> </li>
<ul>
<li> point to the <code>i+j</code>th element of <code>x</code> if <code>i + j</code> is in <code>[</code><code>​0​</code><code>, </code><code>n</code><code>)</code>, and </li>
<li> are pointers past the end of the last element of <code>x</code> if <code>i + j</code> is <code>n</code>. </li>
</ul>
<li> The expression <code>P - J</code> </li>
<ul>
<li> points to the <code>i-j</code>th element of <code>x</code> if <code>i - j</code> is in <code>[</code><code>​0​</code><code>, </code><code>n</code><code>)</code>, and </li>
<li> is a pointer past the end of the last element of <code>x</code> if <code>i - j</code> is <code>n</code>. </li>
</ul>
<li> Other <code>j</code> values result in undefined behavior. </li>
<li> Otherwise, if <code>P</code> points to a complete object, a base class subobject or a member subobject <code>y</code>, given the value of <code>J</code> as <code>j</code>, <code>P</code> is added or subtracted as follows: </li>
<li> The expressions <code>P + J</code> and <code>J + P</code> </li>
<ul>
<li> point to <code>y</code> if <code>j</code> is <code>​0​</code>, and </li>
<li> are pointers past the end of <code>y</code> if <code>j</code> is <code>1</code>. </li>
</ul>
<li> The expression <code>P - J</code> </li>
<ul>
<li> points to <code>y</code> if <code>j</code> is <code>​0​</code>, and </li>
<li> is a pointer past the end of <code>y</code> if <code>j</code> is <code>-1</code>. </li>
</ul>
<li> Other <code>j</code> values result in undefined behavior. </li>
<li> Otherwise, the behavior is undefined. </li>
</ul>               <p>When two pointer expressions <code>P</code> and <code>Q</code> are subtracted, the type of the result is <code><a href="../types/ptrdiff_t.html" title="cpp/types/ptrdiff t">std::ptrdiff_t</a></code>.</p>
<ul>
<li> If <code>P</code> and <code>Q</code> both evaluate to <a href="pointer.html#Null_pointers" title="cpp/language/pointer">null pointer values</a>, the result is <code>​0​</code>. </li>
<li> Otherwise, if <code>P</code> and <code>Q</code> point to, respectively, the <code>i</code>th and <code>j</code>th array elements of the same array object <code>x</code>, the expression <code>P - Q</code> has the value <code>i − j</code>. </li>
<ul><li> If <code>i − j</code> is not representable by <code><a href="../types/ptrdiff_t.html" title="cpp/types/ptrdiff t">std::ptrdiff_t</a></code>, the behavior is undefined. </li></ul>
<li> Otherwise, if <code>P</code> and <code>Q</code> point to the same complete object, base class subobject or member subobject, the result is <code>​0​</code>. </li>
<li> Otherwise, the behavior is undefined. </li>
</ul>   <p>These pointer arithmetic operators allow pointers to satisfy the <a href="../named_req/randomaccessiterator.html" title="cpp/named req/RandomAccessIterator">LegacyRandomAccessIterator</a> requirements.</p>
<p>For addition and subtraction, if <code>P</code> or <code>Q</code> have type “pointer to (possibly cv-qualified) <code>T</code>”, where <code>T</code> and the array element type are not <a href="implicit_conversion.html#Similar_types" title="cpp/language/implicit conversion">similar</a>, the behavior is undefined:</p>
<div class="cpp source-cpp"><pre data-language="cpp">int arr[5] = {1, 2, 3, 4, 5};
unsigned int *p = reinterpret_cast&lt;unsigned int*&gt;(arr + 1);
unsigned int k = *p; // OK, the value of `k` is 2
unsigned int *q = p + 1; // undefined behavior: `p` points to int, not unsigned int</pre></div> <h4 id="Overloads_2"> Overloads</h4> <p>In <a href="overload_resolution.html#Call_to_an_overloaded_operator" title="cpp/language/overload resolution">overload resolution against user-defined operators</a>, for every pair of promoted arithmetic types <code>L</code> and <code>R</code> and for every object type <code>T</code>, the following function signatures participate in overload resolution:</p>
<table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">LR operator+(L, R)</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">LR operator-(L, R)</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">T* operator+(T*, std::ptrdiff_t)</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">T* operator+(std::ptrdiff_t, T*)</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">T* operator-(T*, std::ptrdiff_t)</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">std::ptrdiff_t operator-(T*, T*)</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr>  </table> <p>where <code>LR</code> is the result of <a href="usual_arithmetic_conversions.html" title="cpp/language/usual arithmetic conversions">usual arithmetic conversions</a> on <code>L</code> and <code>R</code>.</p>
<div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
 
int main()
{
    char c = 2;
    unsigned int un = 2;
    int n = -10;
    std::cout &lt;&lt; " 2 + (-10), where 2 is a char    = " &lt;&lt; c + n &lt;&lt; "\n"
                 " 2 + (-10), where 2 is unsigned  = " &lt;&lt; un + n &lt;&lt; "\n"
                 " -10 - 2.12  = " &lt;&lt; n - 2.12 &lt;&lt; '\n';
 
    char a[4] = {'a', 'b', 'c', 'd'};
    char* p = &amp;a[1];
    std::cout &lt;&lt; "Pointer addition examples: " &lt;&lt; *p &lt;&lt; *(p + 2)
              &lt;&lt; *(2 + p) &lt;&lt; *(p - 1) &lt;&lt; '\n';
    char* p2 = &amp;a[4];
    std::cout &lt;&lt; "Pointer difference: " &lt;&lt; p2 - p &lt;&lt; '\n';
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">
 2 + (-10), where 2 is a char    = -8
 2 + (-10), where 2 is unsigned  = 4294967288
 -10 - 2.12  = -12.12
Pointer addition examples: bdda
Pointer difference: 3</pre></div> </div> <h4 id="Multiplicative_operators"> Multiplicative operators</h4> <p>The multiplicative operator expressions have the form</p>
<table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <span class="t-spar">lhs</span> <code>*</code> <span class="t-spar">rhs</span> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">lhs</span> <code>/</code> <span class="t-spar">rhs</span> </td> <td> (2) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">lhs</span> <code>%</code> <span class="t-spar">rhs</span> </td> <td> (3) </td> <td class="t-sdsc-nopad"> </td>
</tr> 
</table> <div class="t-li1">
<span class="t-li">1)</span> Multiplication.</div> <div class="t-li1">
<span class="t-li">2)</span> Division.</div> <div class="t-li1">
<span class="t-li">3)</span> Remainder.</div> <p>Multiplicative operators have higher <a href="operator_precedence.html" title="cpp/language/operator precedence">precedence</a> than all other binary arithmetic operators. These operators associate from left to right:</p>
<div class="cpp source-cpp"><pre data-language="cpp">a + b * c;  // equivalent to a + (b * c),  NOT (a + b) * c
d / e - f;  // equivalent to (d / e) - f,  NOT d / (e - f)
g % h &gt;&gt; i; // equivalent to (g % h) &gt;&gt; i, NOT g % (h &gt;&gt; i)
 
j * k / l % m; // equivalent to ((j * k) / l) % m</pre></div> <h4 id="Built-in_multiplicative_operators"> Built-in multiplicative operators</h4> <p>For built-in multiplication and division operators, both operands must have arithmetic or unscoped enumeration type. For the built-in remainder operator, both operands must have integral or unscoped enumeration type. <a href="usual_arithmetic_conversions.html" title="cpp/language/usual arithmetic conversions">Usual arithmetic conversions</a> are performed on both operands.</p>
<p>In the remaining description in this section, "operand(s)", <span class="t-spar">lhs</span> and <span class="t-spar">rhs</span> refer to the converted operand(s).</p>
<div class="t-li1">
<span class="t-li">1)</span> The result of built-in multiplication is the product of the operands.</div>  If both operands have a floating-point type, and the type supports IEEE floating-point arithmetic (see <code><a href="../types/numeric_limits/is_iec559.html" title="cpp/types/numeric limits/is iec559">std::numeric_limits::is_iec559</a></code>): <ul>
<li> Multiplication of a NaN by any number gives NaN. </li>
<li> Multiplication of infinity by zero gives NaN and <code><a href="../numeric/fenv/fe_exceptions.html" title="cpp/numeric/fenv/FE exceptions">FE_INVALID</a></code> is raised.</li>
</ul> <div class="t-li1">
<span class="t-li">2)</span> The result of built-in division is <span class="t-spar">lhs</span> divided by <span class="t-spar">rhs</span>. If <span class="t-spar">rhs</span> is zero, the behavior is undefined.</div> <div class="t-li1">
 If both operands have an integral type, the result is the algebraic quotient (performs integer division): the quotient is truncated towards zero (fractional part is discarded).</div>  If both operands have a floating-point type, and the type supports IEEE floating-point arithmetic (see <code><a href="../types/numeric_limits/is_iec559.html" title="cpp/types/numeric limits/is iec559">std::numeric_limits::is_iec559</a></code>): <ul>
<li> If one operand is NaN, the result is NaN. </li>
<li> Dividing a non-zero number by ±0.0 gives the correctly-signed infinity and <code><a href="../numeric/fenv/fe_exceptions.html" title="cpp/numeric/fenv/FE exceptions">FE_DIVBYZERO</a></code> is raised. </li>
<li> Dividing 0.0 by 0.0 gives NaN and <code><a href="../numeric/fenv/fe_exceptions.html" title="cpp/numeric/fenv/FE exceptions">FE_INVALID</a></code> is raised.</li>
</ul> <div class="t-li1">
<span class="t-li">3)</span> The result of built-in remainder is the remainder of the integer division of <span class="t-spar">lhs</span> by <span class="t-spar">rhs</span>. If <span class="t-spar">rhs</span> is zero, the behavior is undefined.</div> <div class="t-li1">
 If <code>a / b</code> is representable in the result type, <code>(a / b) * b + a % b == a</code>.</div> <div class="t-li1">
 If <code>a / b</code> is not representable in the result type, the behavior of both <code>a / b</code> and <code>a % b</code> is undefined (that means <code><a href="http://en.cppreference.com/w/cpp/types/climits"><span class="kw400">INT_MIN</span></a> <span class="sy2">%</span> <span class="sy2">-</span><span class="nu0">1</span></code> is undefined on two's complement systems).</div> <p>Note: Until <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/614.html">CWG issue 614</a> was resolved (<a rel="nofollow" class="external text" href="https://wg21.link/n2757">N2757</a>), if one or both operands to binary operator % were negative, the sign of the remainder was implementation-defined, as it depends on the rounding direction of integer division. The function <code><a href="../numeric/math/div.html" title="cpp/numeric/math/div">std::div</a></code> provided well-defined behavior in that case.</p>
<p>Note: for floating-point remainder, see <code><a href="../numeric/math/remainder.html" title="cpp/numeric/math/remainder">std::remainder</a></code> and <code><a href="../numeric/math/fmod.html" title="cpp/numeric/math/fmod">std::fmod</a></code>.</p>
<h4 id="Overloads_3"> Overloads</h4> <p>In <a href="overload_resolution.html#Call_to_an_overloaded_operator" title="cpp/language/overload resolution">overload resolution against user-defined operators</a>, for every pair of promoted arithmetic types <code>LA</code> and <code>RA</code> and for every pair of promoted integral types <code>LI</code> and <code>RI</code> the following function signatures participate in overload resolution:</p>
<table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">LRA operator*(LA, RA)</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">LRA operator/(LA, RA)</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">LRI operator%(LI, RI)</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr>  </table> <p>where <code>LRx</code> is the result of <a href="usual_arithmetic_conversions.html" title="cpp/language/usual arithmetic conversions">usual arithmetic conversions</a> on <code>Lx</code> and <code>Rx</code>.</p>
<div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
 
int main()
{
    char c = 2;
    unsigned int un = 2;
    int  n = -10;
    std::cout &lt;&lt; "2 * (-10), where 2 is a char    = " &lt;&lt; c * n &lt;&lt; "\n"
                 "2 * (-10), where 2 is unsigned  = " &lt;&lt; un * n &lt;&lt; "\n"
                 "-10 / 2.12  = " &lt;&lt; n / 2.12 &lt;&lt; "\n"
                 "-10 / 21  = " &lt;&lt; n / 21 &lt;&lt; "\n"
                 "-10 % 21  = " &lt;&lt; n % 21 &lt;&lt; '\n';
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">2 * (-10), where 2 is a char    = -20
2 * (-10), where 2 is unsigned  = 4294967276
-10 / 2.12  = -4.71698
-10 / 21  = 0
-10 % 21  = -10</pre></div> </div> <h3 id="Bitwise_logic_operators"> Bitwise logic operators</h3> <p>The bitwise logic operator expressions have the form</p>
<table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <code>~</code> <span class="t-spar">rhs</span> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">lhs</span> <code>&amp;</code> <span class="t-spar">rhs</span> </td> <td> (2) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">lhs</span> <code>|</code> <span class="t-spar">rhs</span> </td> <td> (3) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">lhs</span> <code>^</code> <span class="t-spar">rhs</span> </td> <td> (4) </td> <td class="t-sdsc-nopad"> </td>
</tr> 
</table> <div class="t-li1">
<span class="t-li">1)</span> Bitwise NOT.</div> <div class="t-li1">
<span class="t-li">2)</span> Bitwise AND.</div> <div class="t-li1">
<span class="t-li">3)</span> Bitwise OR.</div> <div class="t-li1">
<span class="t-li">4)</span> Bitwise XOR.</div> <p>The bitwise NOT operator has higher <a href="operator_precedence.html" title="cpp/language/operator precedence">precedence</a> than all binary arithmetic operators. It associates from right to left:</p>
<div class="cpp source-cpp"><pre data-language="cpp">~a - b; // equivalent to (~a) - b, NOT ~(a - b)
~c * d; // equivalent to (~c) * d, NOT ~(c * d)
 
~-e; // equivalent to ~(-e)</pre></div> <p>There is an ambiguity in the grammar when <code>~</code> is followed by a <a href="type.html#type_naming" title="cpp/language/type">type name</a><span class="t-rev-inl t-since-cxx11"><span> or <a href="decltype.html" title="cpp/language/decltype"><code>decltype</code></a> specifier</span><span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span>: it can either be operator~ or start a <a href="destructor.html" title="cpp/language/destructor">destructor</a> identifier). The ambiguity is resolved by treating <code>~</code> as operator~. <code>~</code> can start a destructor identifier only in places where forming an operator~ is syntactically invalid.</p>
<p>All other bitwise logic operators have lower <a href="operator_precedence.html" title="cpp/language/operator precedence">precedence</a> than all other binary arithmetic operators. Bitwise AND has higher precedence than bitwise XOR, which has higher precedence than bitwise OR. They associate from left to right:</p>
<div class="cpp source-cpp"><pre data-language="cpp">a &amp; b * c;  // equivalent to a &amp; (b * c),  NOT (a &amp; b) * c
d / e ^ f;  // equivalent to (d ^ e) - f,  NOT d ^ (e - f)
g &lt;&lt; h | i; // equivalent to (g &lt;&lt; h) | i, NOT g &lt;&lt; (h | i)
 
j &amp; k &amp; l; // equivalent to (j &amp; k) &amp; l
m | n ^ o  // equivalent to m | (n ^ o)</pre></div> <h4 id="Built-in_bitwise_logic_operators"> Built-in bitwise logic operators</h4> <p>For the built-in bitwise NOT operator, <span class="t-spar">rhs</span> must be a prvalue of integral or unscoped enumeration type, and integral promotion is performed on <span class="t-spar">rhs</span>. For other built-in bitwise logic operators, both operands must have integral or unscoped enumeration type, and <a href="usual_arithmetic_conversions.html" title="cpp/language/usual arithmetic conversions">usual arithmetic conversions</a> are performed on both operands.</p>
<p>In the remaining description in this section, "operand(s)", <span class="t-spar">lhs</span> and <span class="t-spar">rhs</span> refer to the converted or promoted operand(s).</p>
<span class="t-li">1)</span> Given the operand as <code>x</code> and the result of the built-in bitwise NOT operation as <code>r</code>. For each coefficient <code>x_i</code> of the base-2 representation of <code>x</code>, the corresponding coefficient <code>r_i</code> of the base-2 representation of <code>r</code> is <code>1</code> if <code>x_i</code> is <code>​0​</code>, and <code>​0​</code> otherwise. <ul><li> In other words, the result is the one’s complement of the operand (where operand and result are considered as unsigned).</li></ul> <div class="t-li1">
 The type of the result <code>r</code> is the type of the operand <code>x</code>.</div> <div class="t-li1">
<span class="t-li">2-4)</span> Given the operands as <code>x</code> and <code>y</code> respectively and the result of the built-in binary bitwise logic operations as <code>r</code>. For each pair of coefficients <code>x_i</code> and <code>y_i</code> of the base-2 representations of <code>x</code> and <code>y</code> respectively, the corresponding coefficient <code>r_i</code> of the base-2 representation of <code>r</code> is</div> <div class="t-li2">
<span class="t-li">2)</span> <code>1</code> if both <code>x_i</code> and <code>y_i</code> are <code>1</code>, and <code>​0​</code> otherwise.</div> <div class="t-li2">
<span class="t-li">3)</span> <code>1</code> if at least one of <code>x_i</code> and <code>y_i</code> is <code>1</code>, and <code>​0​</code> otherwise.</div> <div class="t-li2">
<span class="t-li">4)</span> <code>1</code> if either (but not both) of <code>x_i</code> and <code>y_i</code> is <code>1</code>, and <code>​0​</code> otherwise.</div> <div class="t-li1">
 The type of the result <code>r</code> is the type of the operands <code>x</code> and <code>y</code>.</div> <h4 id="Overloads_4"> Overloads</h4> <p>In <a href="overload_resolution.html#Call_to_an_overloaded_operator" title="cpp/language/overload resolution">overload resolution against user-defined operators</a>, for every pair of promoted integral types <code>L</code> and <code>R</code> the following function signatures participate in overload resolution:</p>
<table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">R operator~(R)</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">LR operator&amp;(L, R)</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">LR operator^(L, R)</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">LR operator|(L, R)</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr>  </table> <p>where <code>LR</code> is the result of <a href="usual_arithmetic_conversions.html" title="cpp/language/usual arithmetic conversions">usual arithmetic conversions</a> on <code>L</code> and <code>R</code>.</p>
<div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;bitset&gt;
#include &lt;cstdint&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
 
int main()
{
    std::uint16_t mask = 0x00f0;
    std::uint32_t x0 = 0x12345678;
    std::uint32_t x1 = x0 | mask;
    std::uint32_t x2 = x0 &amp; ~mask;
    std::uint32_t x3 = x0 &amp; mask;
    std::uint32_t x4 = x0 ^ mask;
    std::uint32_t x5 = ~x0;
    using bin16 = std::bitset&lt;16&gt;;
    using bin32 = std::bitset&lt;32&gt;;
    std::cout &lt;&lt; std::hex &lt;&lt; std::showbase
              &lt;&lt; "Mask: " &lt;&lt; mask &lt;&lt; std::setw(49) &lt;&lt; bin16(mask) &lt;&lt; "\n"
                 "Value: " &lt;&lt; x0 &lt;&lt; std::setw(42) &lt;&lt; bin32(x0) &lt;&lt; "\n"
                 "Setting bits: " &lt;&lt; x1 &lt;&lt; std::setw(35) &lt;&lt; bin32(x1) &lt;&lt; "\n"
                 "Clearing bits: " &lt;&lt; x2 &lt;&lt; std::setw(34) &lt;&lt; bin32(x2) &lt;&lt; "\n"
                 "Selecting bits: " &lt;&lt; x3 &lt;&lt; std::setw(39) &lt;&lt; bin32(x3) &lt;&lt; "\n"
                 "XOR-ing bits: " &lt;&lt; x4 &lt;&lt; std::setw(35) &lt;&lt; bin32(x4) &lt;&lt; "\n"
                 "Inverting bits: " &lt;&lt; x5 &lt;&lt; std::setw(33) &lt;&lt; bin32(x5) &lt;&lt; '\n';
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">Mask: 0xf0                                 0000000011110000
Value: 0x12345678          00010010001101000101011001111000
Setting bits: 0x123456f8   00010010001101000101011011111000
Clearing bits: 0x12345608  00010010001101000101011000001000
Selecting bits: 0x70       00000000000000000000000001110000
XOR-ing bits: 0x12345688   00010010001101000101011010001000
Inverting bits: 0xedcba987 11101101110010111010100110000111</pre></div> </div> <h3 id="Bitwise_shift_operators"> Bitwise shift operators</h3> <p>The bitwise shift operator expressions have the form</p>
<table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <span class="t-spar">lhs</span> <code>&lt;&lt;</code> <span class="t-spar">rhs</span> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">lhs</span> <code>&gt;&gt;</code> <span class="t-spar">rhs</span> </td> <td> (2) </td> <td class="t-sdsc-nopad"> </td>
</tr> 
</table> <div class="t-li1">
<span class="t-li">1)</span> Bitwise left-shift.</div> <div class="t-li1">
<span class="t-li">2)</span> Bitwise right-shift.</div> <p>Bitwise shift operators have higher <a href="operator_precedence.html" title="cpp/language/operator precedence">precedence</a> than bitwise logic operators, but have lower precedence than additive and multiplicative operators. These operators associate from left to right:</p>
<div class="cpp source-cpp"><pre data-language="cpp">a &gt;&gt; b * c;  // equivalent to a &gt;&gt; (b * c),  NOT (a &gt;&gt; b) * c
d &lt;&lt; e &amp; f;  // equivalent to (d &lt;&lt; e) &amp; f,  NOT d &lt;&lt; (e &amp; f)
 
g &lt;&lt; h &gt;&gt; i; // equivalent to (g &lt;&lt; h) &gt;&gt; i, NOT g &lt;&lt; (h &gt;&gt; i)</pre></div> <h4 id="Built-in_bitwise_shift_operators"> Built-in bitwise shift operators</h4> <p>For the built-in bitwise shift operators, both operands must be prvalues of integral or unscoped enumeration type. Integral promotions are performed on both operands.</p>
<p>In the remaining description in this section, "operand(s)", <code>a</code>, <code>b</code>, <span class="t-spar">lhs</span> and <span class="t-spar">rhs</span> refer to the converted or promoted operand(s).</p>
<table class="t-rev-begin"> <tr class="t-rev t-until-cxx20">
<td> <p>For unsigned <code>a</code>, the value of <code>a &lt;&lt; b</code> is the value of a * 2<sup class="t-su">b</sup>, reduced modulo 2<sup class="t-su">N</sup> where N is the number of bits in the return type (that is, bitwise left shift is performed and the bits that get shifted out of the destination type are discarded).</p>
<p>For signed and non-negative <code>a</code>, if a * 2<sup class="t-su">b</sup> is representable in the unsigned version of the return type, then that value, <a href="implicit_conversion.html#Integral_conversions" title="cpp/language/implicit conversion">converted</a> to signed, is the value of <code>a &lt;&lt; b</code> (this makes it legal to create <code><a href="../types/climits.html" title="cpp/types/climits">INT_MIN</a></code> as <code>1 &lt;&lt; 31</code>); otherwise the behavior is undefined.</p>
<p>For negative <code>a</code>, the behavior of <code>a &lt;&lt; b</code> is undefined.</p>
<p>For unsigned <code>a</code> and for signed and non-negative <code>a</code>, the value of <code>a &gt;&gt; b</code> is the integer part of a/2<sup class="t-su">b</sup>.</p>
<p>For negative <code>a</code>, the value of <code>a &gt;&gt; b</code> is implementation-defined (in most implementations, this performs arithmetic right shift, so that the result remains negative).</p>
</td> <td><span class="t-mark-rev t-until-cxx20">(until C++20)</span></td>
</tr> <tr class="t-rev t-since-cxx20">
<td> <p>The value of <code>a &lt;&lt; b</code> is the unique value congruent to a * 2<sup class="t-su">b</sup> modulo 2<sup class="t-su">N</sup> where N is the number of bits in the return type (that is, bitwise left shift is performed and the bits that get shifted out of the destination type are discarded).</p>
<p>The value of <code>a &gt;&gt; b</code> is a/2<sup class="t-su">b</sup>, rounded towards negative infinity (in other words, right shift on signed <code>a</code> is arithmetic right shift).</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> <p>The type of the result is that of <span class="t-spar">lhs</span>. If the value of <span class="t-spar">rhs</span> is negative or is not less than the number of bits in <span class="t-spar">lhs</span>, the behavior is undefined.</p>
<h4 id="Overloads_5"> Overloads</h4> <p>In <a href="overload_resolution.html#Call_to_an_overloaded_operator" title="cpp/language/overload resolution">overload resolution against user-defined operators</a>, for every pair of promoted integral types <code>L</code> and <code>R</code>, the following function signatures participate in overload resolution:</p>
<table class="t-dcl-begin"> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">L operator&lt;&lt;(L, R)</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr> <tr class="t-dcl"> <td class="t-dcl-nopad"> <pre data-language="cpp">L operator&gt;&gt;(L, R)</pre>
</td> <td class="t-dcl-nopad"> </td> <td class="t-dcl-nopad"> </td> </tr>  </table> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
 
enum { ONE = 1, TWO = 2 };
 
int main()
{
    std::cout &lt;&lt; std::hex &lt;&lt; std::showbase;
    char c = 0x10;
    unsigned long long ull = 0x123;
    std::cout &lt;&lt; "0x123 &lt;&lt; 1 = " &lt;&lt; (ull &lt;&lt; 1) &lt;&lt; "\n"
                 "0x123 &lt;&lt; 63 = " &lt;&lt; (ull &lt;&lt; 63) &lt;&lt; "\n" // overflow in unsigned
                 "0x10 &lt;&lt; 10 = " &lt;&lt; (c &lt;&lt; 10) &lt;&lt; '\n';   // char is promoted to int
    long long ll = -1000;
    std::cout &lt;&lt; std::dec &lt;&lt; "-1000 &gt;&gt; 1 = " &lt;&lt; (ll &gt;&gt; ONE) &lt;&lt; '\n';
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">0x123 &lt;&lt; 1 = 0x246
0x123 &lt;&lt; 63 = 0x8000000000000000
0x10 &lt;&lt; 10 = 0x4000
-1000 &gt;&gt; 1 = -500</pre></div> </div> <h3 id="Standard_library"> Standard library</h3> <p>Arithmetic operators are overloaded for many standard library types.</p>
<h4 id="Unary_arithmetic_operators_2"> Unary arithmetic operators</h4> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../chrono/duration/operator_arith.html" title="cpp/chrono/duration/operator arith"> <span class="t-lines"><span>operator+</span><span>operator-</span></span></a></div> </td> <td> implements unary + and unary - <br> <span class="t-mark">(public member function of <code>std::chrono::duration&lt;Rep,Period&gt;</code>)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../numeric/complex/operator_arith2.html" title="cpp/numeric/complex/operator arith2"> <span class="t-lines"><span>operator+</span><span>operator-</span></span></a></div> </td> <td> applies unary operators to complex numbers <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../numeric/valarray/operator_arith.html" title="cpp/numeric/valarray/operator arith"> <span class="t-lines"><span>operator+</span><span>operator-</span><span>operator~</span><span>operator!</span></span></a></div> </td> <td> applies a unary arithmetic operator to each element of the valarray <br> <span class="t-mark">(public member function of <code>std::valarray&lt;T&gt;</code>)</span>  </td>
</tr> </table> <h4 id="Additive_operators_2"> Additive operators</h4> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../chrono/time_point/operator_arith2.html" title="cpp/chrono/time point/operator arith2"> <span class="t-lines"><span>operator+</span><span>operator-</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> performs add and subtract operations involving a time point <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../chrono/duration/operator_arith4.html" title="cpp/chrono/duration/operator arith4"> <span class="t-lines"><span>operator+</span><span>operator-</span><span>operator*</span><span>operator/</span><span>operator%</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> implements arithmetic operations with durations as arguments <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../chrono/year_month_day/operator_arith_2.html" title="cpp/chrono/year month day/operator arith 2"> <span class="t-lines"><span>operator+</span><span>operator-</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div> </td> <td> adds or subtracts a <code>year_month_day</code> and some number of years or months <br> <span class="t-mark">(function)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../string/basic_string/operator_plus_.html" title="cpp/string/basic string/operator+"> <span class="t-lines"><span>operator+</span></span></a></div> </td> <td> concatenates two strings or a string and a <span class="kw4">char</span> <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/reverse_iterator/operator_arith.html" title="cpp/iterator/reverse iterator/operator arith"> <span class="t-lines"><span>operator+</span><span>operator-</span></span></a></div> </td> <td> advances or decrements the iterator <br> <span class="t-mark">(public member function of <code>std::reverse_iterator&lt;Iter&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../iterator/move_iterator/operator_arith.html" title="cpp/iterator/move iterator/operator arith"> <span class="t-lines"><span>operator+</span><span>operator-</span></span></a></div> </td> <td> advances or decrements the iterator <br> <span class="t-mark">(public member function of <code>std::move_iterator&lt;Iter&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../numeric/complex/operator_arith3.html" title="cpp/numeric/complex/operator arith3"> <span class="t-lines"><span>operator+</span><span>operator-</span><span>operator*</span><span>operator/</span></span></a></div> </td> <td> performs complex number arithmetic on two complex values or a complex and a scalar <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../numeric/valarray/operator_arith3.html" title="cpp/numeric/valarray/operator arith3"> <span class="t-lines"><span>operator+</span><span>operator-</span><span>operator*</span><span>operator/</span><span>operator%</span><span>operator&amp;</span><span>operator|</span><span>operator^</span><span>operator&lt;&lt;</span><span>operator&gt;&gt;</span><span>operator&amp;&amp;</span><span>operator||</span></span></a></div> </td> <td> applies binary operators to each element of two valarrays, or a valarray and a value <br> <span class="t-mark">(function template)</span>  </td>
</tr> </table> <h4 id="Multiplicative_operators_2"> Multiplicative operators</h4> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../chrono/duration/operator_arith4.html" title="cpp/chrono/duration/operator arith4"> <span class="t-lines"><span>operator+</span><span>operator-</span><span>operator*</span><span>operator/</span><span>operator%</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> implements arithmetic operations with durations as arguments <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../numeric/complex/operator_arith3.html" title="cpp/numeric/complex/operator arith3"> <span class="t-lines"><span>operator+</span><span>operator-</span><span>operator*</span><span>operator/</span></span></a></div> </td> <td> performs complex number arithmetic on two complex values or a complex and a scalar <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../numeric/valarray/operator_arith3.html" title="cpp/numeric/valarray/operator arith3"> <span class="t-lines"><span>operator+</span><span>operator-</span><span>operator*</span><span>operator/</span><span>operator%</span><span>operator&amp;</span><span>operator|</span><span>operator^</span><span>operator&lt;&lt;</span><span>operator&gt;&gt;</span><span>operator&amp;&amp;</span><span>operator||</span></span></a></div> </td> <td> applies binary operators to each element of two valarrays, or a valarray and a value <br> <span class="t-mark">(function template)</span>  </td>
</tr> </table> <h4 id="Bitwise_logic_operators_2"> Bitwise logic operators</h4> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../utility/bitset/operator_logic.html" title="cpp/utility/bitset/operator logic"> <span class="t-lines"><span>operator&amp;=</span><span>operator|=</span><span>operator^=</span><span>operator~</span></span></a></div> </td> <td> performs binary AND, OR, XOR and NOT <br> <span class="t-mark">(public member function of <code>std::bitset&lt;N&gt;</code>)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/bitset/operator_logic2.html" title="cpp/utility/bitset/operator logic2"> <span class="t-lines"><span>operator&amp;</span><span>operator|</span><span>operator^</span></span></a></div> </td> <td> performs binary logic operations on bitsets <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../numeric/valarray/operator_arith.html" title="cpp/numeric/valarray/operator arith"> <span class="t-lines"><span>operator~</span></span></a></div> </td> <td> applies a unary arithmetic operator to each element of the valarray <br> <span class="t-mark">(public member function of <code>std::valarray&lt;T&gt;</code>)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../numeric/valarray/operator_arith3.html" title="cpp/numeric/valarray/operator arith3"> <span class="t-lines"><span>operator^</span><span>operator&amp;</span><span>operator|</span></span></a></div> </td> <td> applies binary operators to each element of two valarrays, or a valarray and a value <br> <span class="t-mark">(function template)</span> </td>
</tr> </table> <h4 id="Bitwise_shift_operators_2"> Bitwise shift operators</h4> <table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../numeric/valarray/operator_arith3.html" title="cpp/numeric/valarray/operator arith3"> <span class="t-lines"><span>operator&lt;&lt;</span><span>operator&gt;&gt;</span></span></a></div> </td> <td> applies binary operators to each element of two valarrays, or a valarray and a value <br> <span class="t-mark">(function template)</span> </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/bitset/operator_ltltgtgt.html" title="cpp/utility/bitset/operator ltltgtgt"> <span class="t-lines"><span>operator&lt;&lt;</span><span>operator&gt;&gt;</span></span></a></div> </td> <td> performs binary shift left and shift right <br> <span class="t-mark">(public member function of <code>std::bitset&lt;N&gt;</code>)</span> </td>
</tr> </table> <h4 id="Stream_insertion.2Fextraction_operators"> Stream insertion/extraction operators</h4> <p>Throughout the standard library, bitwise shift operators are commonly overloaded with I/O stream (<a href="http://en.cppreference.com/w/cpp/io/ios_base"><span class="kw1673">std::<span class="me2">ios_base</span></span></a><span class="sy3">&amp;</span> or one of the classes derived from it) as both the left operand and return type. Such operators are known as <i>stream insertion</i> and <i>stream extraction</i> operators:</p>
<table class="t-dsc-begin"> <tr class="t-dsc"> <td> <div><a href="../io/basic_istream/operator_gtgt.html" title="cpp/io/basic istream/operator gtgt"> <span class="t-lines"><span>operator&gt;&gt;</span></span></a></div> </td> <td> extracts formatted data <br> <span class="t-mark">(public member function of <code>std::basic_istream&lt;CharT,Traits&gt;</code>)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../io/basic_istream/operator_gtgt2.html" title="cpp/io/basic istream/operator gtgt2"> <span class="t-lines"><span>operator&gt;&gt;<span class="t-dsc-small">(std::basic_istream)</span></span></span></a></div> </td> <td> extracts characters and character arrays <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../io/basic_ostream/operator_ltlt.html" title="cpp/io/basic ostream/operator ltlt"> <span class="t-lines"><span>operator&lt;&lt;</span></span></a></div> </td> <td> inserts formatted data <br> <span class="t-mark">(public member function of <code>std::basic_ostream&lt;CharT,Traits&gt;</code>)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../io/basic_ostream/operator_ltlt2.html" title="cpp/io/basic ostream/operator ltlt2"> <span class="t-lines"><span>operator&lt;&lt;<span class="t-dsc-small">(std::basic_ostream)</span></span></span></a></div> </td> <td> inserts character data or insert into rvalue stream <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../numeric/complex/operator_ltltgtgt.html" title="cpp/numeric/complex/operator ltltgtgt"> <span class="t-lines"><span>operator&lt;&lt;</span><span>operator&gt;&gt;</span></span></a></div> </td> <td> serializes and deserializes a complex number <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../utility/bitset/operator_ltltgtgt2.html" title="cpp/utility/bitset/operator ltltgtgt2"> <span class="t-lines"><span>operator&lt;&lt;</span><span>operator&gt;&gt;</span></span></a></div> </td> <td> performs stream input and output of bitsets <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../string/basic_string/operator_ltltgtgt.html" title="cpp/string/basic string/operator ltltgtgt"> <span class="t-lines"><span>operator&lt;&lt;</span><span>operator&gt;&gt;</span></span></a></div> </td> <td> performs stream input and output on strings <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../numeric/random/linear_congruential_engine/operator_ltltgtgt.html" title="cpp/numeric/random/linear congruential engine/operator ltltgtgt"> <span class="t-lines"><span>operator&lt;&lt;</span><span>operator&gt;&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> performs stream input and output on pseudo-random number engine <br> <span class="t-mark">(function template)</span>  </td>
</tr> <tr class="t-dsc"> <td> <div><a href="../numeric/random/uniform_int_distribution/operator_ltltgtgt.html" title="cpp/numeric/random/uniform int distribution/operator ltltgtgt"> <span class="t-lines"><span>operator&lt;&lt;</span><span>operator&gt;&gt;</span></span></a></div>
<div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div> </td> <td> performs stream input and output on pseudo-random number distribution <br> <span class="t-mark">(function template)</span>  </td>
</tr> </table> <h3 id="Defect_reports"> Defect reports</h3> <p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.</p>
<table class="dsctable"> <tr> <th>DR </th> <th>Applied to </th> <th>Behavior as published </th> <th>Correct behavior </th>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/614.html">CWG 614</a> </td> <td>C++98 </td> <td>the algebraic quotient of integer division was<br>rounded in implementation-defined direction </td> <td>the algebraic quotient of integer<br>division is truncated towards zero<br>(fractional part is discarded) </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1450.html">CWG 1450</a> </td> <td>C++98 </td> <td>the result of <code>a / b</code> was unspecified if<br>it is not representable in the result type </td> <td>the behavior of both <code>a / b</code> and<br><code>a % b</code> is undefined in this case </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1457.html">CWG 1457</a> </td> <td>C++98 </td> <td>the behavior of shifting the leftmost <code>1</code> bit of a<br>positive signed value into the sign bit was undefined </td> <td>made well-defined </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1504.html">CWG 1504</a> </td> <td>C++98 </td> <td>a pointer to a base class subobject of an array<br>element could be used in pointer arithmetic </td> <td>the behavior is<br>undefined in this case </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1515.html">CWG 1515</a> </td> <td>C++98 </td> <td>only unsigned integers which declared <span class="kw4">unsigned</span> <br>should obey the laws of arithmetic modulo 2<sup class="t-su">n</sup> </td> <td>applies to all unsigned integers </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1642.html">CWG 1642</a> </td> <td>C++98 </td> <td>arithmetic operators allow their operands to be lvalues </td> <td>some operands must be rvalues </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1865.html">CWG 1865</a> </td> <td>C++98 </td> <td>the resolution of <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1504.html">CWG issue 1504</a> made the behaviors<br>of pointer arithmetic involving pointers to array element<br>undefined if the pointed-to type and the array element<br>type have different cv-qualifications in non-top levels </td> <td>made well-defined </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1971.html">CWG 1971</a> </td> <td>C++98 </td> <td>it was unclear whether the rule resolving the<br>ambiguity of <code>~</code> applies to cases such as <code>~X(0)</code> </td> <td>the rule applies to such cases </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2419.html">CWG 2419</a> </td> <td>C++98 </td> <td>a pointer to non-array object was only treated as a<br>pointer to the first element of an array with size 1<br>in pointer arithmetic if the pointer is obtained by <code>&amp;</code> </td> <td>applies to all pointers<br>to non-array objects </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2626.html">CWG 2626</a> </td> <td>C++98 </td> <td>the result of built-in <code>operator~</code> was simply<br>'one's complement' without proper definition </td> <td>the result is phrased in terms<br>of the base-2 representation </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2724.html">CWG 2724</a> </td> <td>C++20 </td> <td>the rounding direction of arithmetic right shift was unclear </td> <td>made clear </td>
</tr>
</table> <h3 id="See_also"> See also</h3> <p><a href="operator_precedence.html" title="cpp/language/operator precedence">Operator precedence</a></p>
<p><a href="operators.html" title="cpp/language/operators">Operator overloading</a></p>
<table class="wikitable"> <tr style="text-align:center"> <th colspan="7">Common operators </th>
</tr> <tr style="text-align:center"> <td>
<a href="operator_assignment.html" title="cpp/language/operator assignment">assignment</a> </td> <td>
<a href="operator_incdec.html" title="cpp/language/operator incdec">increment<br>decrement</a> </td> <td>
<strong class="selflink">arithmetic</strong> </td> <td>
<a href="operator_logical.html" title="cpp/language/operator logical">logical</a> </td> <td>
<a href="operator_comparison.html" title="cpp/language/operator comparison">comparison</a> </td> <td>
<a href="operator_member_access.html" title="cpp/language/operator member access">member<br>access</a> </td> <td>
<a href="operator_other.html" title="cpp/language/operator other">other</a> </td>
</tr> <tr style="text-align:center"> <td rowspan="6"> <p><code>a = b a += b a -= b a *= b a /= b a %= b a &amp;= b a |= b a ^= b a &lt;&lt;= b a &gt;&gt;= b</code></p>
</td> <td rowspan="6"> <p><code>++a --a a++ a--</code></p>
</td> <td rowspan="6"> <p><code>+a -a a + b a - b a * b a / b a % b ~a a &amp; b a | b a ^ b a &lt;&lt; b a &gt;&gt; b</code></p>
</td> <td rowspan="6"> <p><code>!a a &amp;&amp; b a || b</code></p>
</td> <td rowspan="6"> <p><code>a == b a != b a &lt; b a &gt; b a &lt;= b a &gt;= b a &lt;=&gt; b</code></p>
</td> <td rowspan="6"> <p><code>a[...] *a &amp;a a-&gt;b a.b a-&gt;*b a.*b</code></p>
</td> <td>function call </td>
</tr> <tr style="text-align:center"> <td>
<code>a(...)</code> </td>
</tr> <tr style="text-align:center"> <td>comma </td>
</tr> <tr style="text-align:center"> <td>
<code>a, b</code> </td>
</tr> <tr style="text-align:center"> <td>conditional </td>
</tr> <tr style="text-align:center"> <td>
<code>a ? b : c</code> </td>
</tr> <tr> <th colspan="7">Special operators </th>
</tr> <tr> <td colspan="7"> <p><a href="static_cast.html" title="cpp/language/static cast"><code>static_cast</code></a> converts one type to another related type <br> <a href="dynamic_cast.html" title="cpp/language/dynamic cast"><code>dynamic_cast</code></a> converts within inheritance hierarchies <br> <a href="const_cast.html" title="cpp/language/const cast"><code>const_cast</code></a> adds or removes <a href="cv.html" title="cpp/language/cv">cv</a>-qualifiers<br> <a href="reinterpret_cast.html" title="cpp/language/reinterpret cast"><code>reinterpret_cast</code></a> converts type to unrelated type<br> <a href="explicit_cast.html" title="cpp/language/explicit cast">C-style cast</a> converts one type to another by a mix of <code>static_cast</code>, <code>const_cast</code>, and <code>reinterpret_cast</code> <br> <a href="new.html" title="cpp/language/new"><code>new</code></a> creates objects with dynamic storage duration<br> <a href="delete.html" title="cpp/language/delete"><code>delete</code></a> destructs objects previously created by the new expression and releases obtained memory area<br> <a href="sizeof.html" title="cpp/language/sizeof"><code>sizeof</code></a> queries the size of a type<br> <a href="sizeof....html" title="cpp/language/sizeof..."><code>sizeof...</code></a> queries the size of a <a href="parameter_pack.html" title="cpp/language/parameter pack">parameter pack</a> <span class="t-mark-rev t-since-cxx11">(since C++11)</span><br> <a href="typeid.html" title="cpp/language/typeid"><code>typeid</code></a> queries the type information of a type<br> <a href="noexcept.html" title="cpp/language/noexcept"><code>noexcept</code></a> checks if an expression can throw an exception <span class="t-mark-rev t-since-cxx11">(since C++11)</span><br> <a href="alignof.html" title="cpp/language/alignof"><code>alignof</code></a> queries alignment requirements of a type <span class="t-mark-rev t-since-cxx11">(since C++11)</span></p>
</td>
</tr>
</table> <table class="t-dsc-begin"> <tr class="t-dsc"> <td colspan="2"> <span><a href="https://en.cppreference.com/w/c/language/operator_arithmetic" title="c/language/operator arithmetic">C documentation</a></span> for <span class=""><span>Arithmetic operators</span></span> </td>
</tr> </table>           <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/language/operator_arithmetic" class="_attribution-link">https://en.cppreference.com/w/cpp/language/operator_arithmetic</a>
  </p>
</div>
