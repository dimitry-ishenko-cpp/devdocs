    <h1 id="firstHeading" class="firstHeading">Function declaration</h1>            <p>A function declaration introduces the function name and its type. A function definition associates the function name/type with the function body.</p>
<h3 id="Function_declaration"> Function declaration</h3> <p>Function declarations may appear in any scope. A function declaration at class scope introduces a class member function (unless the <span class="kw1">friend</span> specifier is used), see <a href="member_functions.html" title="cpp/language/member functions">member functions</a> and <a href="friend.html" title="cpp/language/friend">friend functions</a> for details.</p>
<table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <span class="t-spar">noptr-declarator</span> <code>(</code> <span class="t-spar">parameter-list</span> <code>)</code> <span class="t-spar">cv</span> ﻿<span class="t-mark">(optional)</span> <span class="t-spar">ref</span> ﻿ ﻿<span class="t-mark">(optional)</span> <span class="t-spar">except</span> ﻿<span class="t-mark">(optional)</span> <span class="t-spar">attr</span> ﻿<span class="t-mark">(optional)</span> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">noptr-declarator</span> <code>(</code> <span class="t-spar">parameter-list</span> <code>)</code> <span class="t-spar">cv</span> ﻿<span class="t-mark">(optional)</span> <span class="t-spar">ref</span> ﻿ ﻿<span class="t-mark">(optional)</span> <span class="t-spar">except</span> ﻿<span class="t-mark">(optional)</span> <span class="t-spar">attr</span> ﻿<span class="t-mark">(optional)</span><br><code>-&gt;</code> <span class="t-spar">trailing</span> </td> <td> (2) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td>
</tr> 
</table> <p>(see <a href="declarations.html" title="cpp/language/declarations">Declarations</a> for the other forms of the <span class="t-spar">declarator</span> syntax)</p>
<div class="t-li1">
<span class="t-li">1)</span> Regular function declarator syntax.</div> <div class="t-li1">
<span class="t-li">2)</span> Trailing return type declaration. The <span class="t-spar">decl-specifier-seq</span> in this case must contain the keyword <code>auto</code>.</div> <table class="t-par-begin"> <tr class="t-par"> <td> <span class="t-spar">noptr-declarator</span> </td> <td> - </td> <td> any valid <span class="t-spar">declarator</span>, but if it begins with <code>*</code>, <code>&amp;</code>, or <code>&amp;&amp;</code>, it has to be surrounded by parentheses. </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">parameter-list</span> </td> <td> - </td> <td> possibly empty, comma-separated list of the function parameters (see below for details) </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">attr</span> </td> <td> - </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> a list of <a href="attributes.html" title="cpp/language/attributes">attributes</a>. These attributes are applied to the type of the function, not the function itself. The attributes for the function appear after the identifier within the declarator and are combined with the attributes that appear in the beginning of the declaration, if any. </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">cv</span> </td> <td> - </td> <td> const/volatile qualification, only allowed in non-static member function declarations </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">ref</span> </td> <td> - </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> ref-qualification, only allowed in non-static member function declarations </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">except</span> </td> <td> - </td> <td> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx11">
<td> <p><a href="except_spec.html" title="cpp/language/except spec">dynamic exception specification</a></p>
</td> <td><span class="t-mark-rev t-until-cxx11">(until C++11)</span></td>
</tr> <tr class="t-rev t-since-cxx11 t-until-cxx17">
<td> <p>either <a href="except_spec.html" title="cpp/language/except spec">dynamic exception specification</a><br>or <a href="noexcept_spec.html" title="cpp/language/noexcept spec">noexcept specification</a></p>
</td> <td>
<span class="t-mark-rev t-since-cxx11">(since C++11)</span><br><span class="t-mark-rev t-until-cxx17">(until C++17)</span>
</td>
</tr> <tr class="t-rev t-since-cxx17">
<td> <p><a href="noexcept_spec.html" title="cpp/language/noexcept spec">noexcept specification</a></p>
</td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx17">
<td> <p>Note that the exception specification is not part of the function type</p>
</td> <td><span class="t-mark-rev t-until-cxx17">(until C++17)</span></td>
</tr> </table> </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">trailing</span> </td> <td> - </td> <td> Trailing return type, useful if the return type depends on argument names, such as <code>template&lt;class T, class U&gt; auto add(T t, U u) -&gt; decltype(t + u);</code> or is complicated, such as in <code>auto fpif(int)-&gt;int(*)(int)</code> </td>
</tr>
</table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p>As mentioned in <a href="declarations.html#Declarators" title="cpp/language/declarations">Declarations</a>, the declarator can be followed by a <i>requires</i> clause, which declares the associated <a href="constraints.html" title="cpp/language/constraints">constraints</a> for the function, which must be satisfied in order for the function to be selected by <a href="overload_resolution.html" title="cpp/language/overload resolution">overload resolution</a>. (example: <code>void f1(int a) requires true;</code>) Note that the associated constraint is part of function signature, but not part of function type.</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> <p>Function declarators can be mixed with other declarators, where <span class="t-spar">decl-specifier-seq</span> allows:</p>
<div class="cpp source-cpp"><pre data-language="cpp">// declares an int, an int*, a function, and a pointer to a function
int a = 1, *p = NULL, f(), (*pf)(double);
// decl-specifier-seq is int
// declarator f() declares (but doesn't define)
//                a function taking no arguments and returning int
 
struct S
{
    virtual int f(char) const, g(int) &amp;&amp;; // declares two non-static member functions
    virtual int f(char), x; // compile-time error: virtual (in decl-specifier-seq)
                            // is only allowed in declarations of non-static
                            // member functions
};</pre></div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p>Using a volatile-qualified object type as parameter type or return type is deprecated.</p>
</td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> <p>The return type of a function cannot be a function type or an array type (but can be a pointer or reference to those).</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>As with any declaration, attributes that appear before the declaration and the attributes that appear immediately after the identifier within the declarator both apply to the entity being declared or defined (in this case, to the function):</p>
<div class="cpp source-cpp"><pre data-language="cpp">[[noreturn]] void f [[noreturn]] (); // okay: both attributes apply to the function f</pre></div> <p>However, the attributes that appear after the declarator (in the syntax above), apply to the type of the function, not to the function itself:</p>
<div class="cpp source-cpp"><pre data-language="cpp">void f() [[noreturn]]; // error: this attribute has no effect on the function itself</pre></div> </td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx14">
<td> <h3 id="Return_type_deduction"> Return type deduction</h3> <p>If the <span class="t-spar">decl-specifier-seq</span> of the function declaration contains the keyword <span class="kw4">auto</span>, trailing return type may be omitted, and will be deduced by the compiler from the type of the expression used in the <a href="return.html" title="cpp/language/return">return</a> statement. If the return type does not use decltype<span class="br0">(</span><span class="kw4">auto</span><span class="br0">)</span>, the deduction follows the rules of <a href="template_argument_deduction.html#Other_contexts" title="cpp/language/template argument deduction">template argument deduction</a>:</p>
<div class="cpp source-cpp"><pre data-language="cpp">int x = 1;
auto f() { return x; }        // return type is int
const auto&amp; f() { return x; } // return type is const int&amp;</pre></div> <p>If the return type is decltype<span class="br0">(</span><span class="kw4">auto</span><span class="br0">)</span>, the return type is as what would be obtained if the expression used in the return statement were wrapped in <a href="decltype.html" title="cpp/language/decltype"><code>decltype</code></a>:</p>
<div class="cpp source-cpp"><pre data-language="cpp">int x = 1;
decltype(auto) f() { return x; }  // return type is int, same as decltype(x)
decltype(auto) f() { return(x); } // return type is int&amp;, same as decltype((x))</pre></div> <p>(note: "<span class="kw4">const</span> decltype<span class="br0">(</span><span class="kw4">auto</span><span class="br0">)</span><span class="sy3">&amp;</span>" is an error, decltype<span class="br0">(</span><span class="kw4">auto</span><span class="br0">)</span> must be used on its own)</p>
<p>If there are multiple return statements, they must all deduce to the same type:</p>
<div class="cpp source-cpp"><pre data-language="cpp">auto f(bool val)
{
    if (val) return 123; // deduces return type int
    else return 3.14f;   // error: deduces return type float
}</pre></div> <p>If there is no return statement or if the argument of the return statement is a void expression, the declared return type must be either decltype<span class="br0">(</span><span class="kw4">auto</span><span class="br0">)</span>, in which case the deduced return type is <span class="kw4">void</span>, or (possibly cv-qualified) <span class="kw4">auto</span>, in which case the deduced return type is then (identically cv-qualified) <span class="kw4">void</span>:</p>
<div class="cpp source-cpp"><pre data-language="cpp">auto f() {}              // returns void
auto g() { return f(); } // returns void
auto* x() {}             // error: cannot deduce auto* from void</pre></div> <p>Once a return statement has been seen in a function, the return type deduced from that statement can be used in the rest of the function, including in other return statements:</p>
<div class="cpp source-cpp"><pre data-language="cpp">auto sum(int i)
{
    if (i == 1)
        return i;              // sum’s return type is int
    else
        return sum(i - 1) + i; // okay: sum’s return type is already known
}</pre></div> <p>If the return statement uses a braced-init-list, deduction is not allowed:</p>
<div class="cpp source-cpp"><pre data-language="cpp">auto func() { return {1, 2, 3}; } // error</pre></div> <p><a href="virtual.html" title="cpp/language/virtual">Virtual functions</a><span class="t-rev-inl t-since-cxx20"><span> and <a href="coroutines.html" title="cpp/language/coroutines">coroutines</a></span><span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span> cannot use return type deduction:</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct F
{
    virtual auto f() { return 2; } // error
};</pre></div> <p><a href="function_template.html" title="cpp/language/function template">Function templates</a> other than <a href="cast_operator.html" title="cpp/language/cast operator">user-defined conversion functions</a> can use return type deduction. The deduction takes place at instantiation even if the expression in the return statement is not <a href="dependent_name.html" title="cpp/language/dependent name">dependent</a>. This instantiation is not in an immediate context for the purposes of <a href="sfinae.html" title="cpp/language/sfinae">SFINAE</a>.</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;class T&gt;
auto f(T t) { return t; }
typedef decltype(f(1)) fint_t;    // instantiates f&lt;int&gt; to deduce return type
 
template&lt;class T&gt;
auto f(T* t) { return *t; }
void g() { int (*p)(int*) = &amp;f; } // instantiates both fs to determine return types,
                                  // chooses second template overload</pre></div> <p>Redeclarations or specializations of functions or function templates that use return type deduction must use the same return type placeholders:</p>
<div class="cpp source-cpp"><pre data-language="cpp">auto f(int num) { return num; }
// int f(int num);            // error: no placeholder return type
// decltype(auto) f(int num); // error: different placeholder
 
template&lt;typename T&gt;
auto g(T t) { return t; }
template auto g(int);     // okay: return type is int
// template char g(char); // error: not a specialization of the primary template g</pre></div> <p>Similarly, redeclarations or specializations of functions or function templates that do not use return type deduction must not use a placeholder:</p>
<div class="cpp source-cpp"><pre data-language="cpp">int f(int num);
// auto f(int num) { return num; } // error: not a redeclaration of f
 
template&lt;typename T&gt;
T g(T t) { return t; }
template int g(int);      // okay: specialize T as int
// template auto g(char); // error: not a specialization of the primary template g</pre></div> <p><a href="function_template.html#Explicit_instantiation" title="cpp/language/function template">Explicit instantiation declarations</a> do not themselves instantiate function templates that use return type deduction:</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;typename T&gt;
auto f(T t) { return t; }
extern template auto f(int); // does not instantiate f&lt;int&gt;
 
int (*p)(int) = f; // instantiates f&lt;int&gt; to determine its return type,
                   // but an explicit instantiation definition 
                   // is still required somewhere in the program</pre></div> </td> <td><span class="t-mark-rev t-since-cxx14">(since C++14)</span></td>
</tr> </table> <h3 id="Parameter_list"> Parameter list</h3> <p>Parameter list determines the arguments that can be specified when the function is called. It is a comma-separated list of <i>parameter declarations</i>, each of which has the following syntax:</p>
<table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <span class="t-spar">attr</span> ﻿<span class="t-mark">(optional)</span> <span class="t-spar">decl-specifier-seq</span> <span class="t-spar">declarator</span> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">attr</span> ﻿<span class="t-mark">(optional)</span> <span class="t-spar">decl-specifier-seq</span> <span class="t-spar">declarator</span> <code>=</code> <span class="t-spar">initializer</span> </td> <td> (2) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">attr</span> ﻿<span class="t-mark">(optional)</span> <span class="t-spar">decl-specifier-seq</span> <span class="t-spar">abstract-declarator</span> ﻿<span class="t-mark">(optional)</span> </td> <td> (3) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">attr</span> ﻿<span class="t-mark">(optional)</span> <span class="t-spar">decl-specifier-seq</span> <span class="t-spar">abstract-declarator</span> ﻿<span class="t-mark">(optional)</span> <code>=</code> <span class="t-spar">initializer</span> </td> <td> (4) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>void</code> </td> <td> (5) </td> <td class="t-sdsc-nopad"> </td>
</tr> 
</table> <div class="t-li1">
<span class="t-li">1)</span> Declares a named (formal) parameter. For the meanings of <span class="t-spar">decl-specifier-seq</span> and <span class="t-spar">declarator</span>, see <a href="declarations.html" title="cpp/language/declarations">declarations</a>.</div> <div class="t-li1">
 <span class="t-cc"><code>int f(int a, int* p, int (*(*x)(double))[3]);</code></span>
</div> <div class="t-li1">
<span class="t-li">2)</span> Declares a named (formal) parameter with a <a href="default_arguments.html" title="cpp/language/default arguments">default value</a>.</div> <div class="t-li1">
 <span class="t-cc"><code>int f(int a = 7, int* p = nullptr, int (*(*x)(double))[3] = nullptr);</code></span>
</div> <div class="t-li1">
<span class="t-li">3)</span> Declares an unnamed parameter.</div> <div class="t-li1">
 <span class="t-cc"><code>int f(int, int*, int (*(*)(double))[3]);</code></span>
</div> <div class="t-li1">
<span class="t-li">4)</span> Declares an unnamed parameter with a <a href="default_arguments.html" title="cpp/language/default arguments">default value</a>.</div> <div class="t-li1">
 <span class="t-cc"><code>int f(int = 7, int* = nullptr, int (*(*)(double))[3] = nullptr);</code></span>
</div> <div class="t-li1">
<span class="t-li">5)</span> Indicates that the function takes no parameters, it is the exact synonym for an empty parameter list: <code>int f(void);</code> and <code>int f();</code> declare the same function. Note that the type <code>void</code> (possibly cv-qualified) cannot be used in a parameter list otherwise: <code>int f(void, int);</code> and <code>int f(const void);</code> are errors (although derived types, such as <code>void*</code> can be used). In a template, only non-dependent void type can be used (a function taking a single parameter of type <code>T</code> does not become a no-parameter function if instantiated with <code>T = void</code>).</div> <p>An ellipsis <code>...</code> may appear at the end of the parameter list; this declares a <a href="variadic_arguments.html" title="cpp/language/variadic arguments">variadic function</a>:</p>
<div class="cpp source-cpp"><pre data-language="cpp">int printf(const char* fmt ...);</pre></div> <p>For compatibility with C89, an optional comma may appear before the ellipsis if the parameter list contains at least one parameter:</p>
<div class="cpp source-cpp"><pre data-language="cpp">int printf(const char* fmt, ...); // OK, same as above</pre></div> <table class="t-rev-begin"> <tr class="t-rev t-until-cxx17">
<td> <p>Although <span class="t-spar">decl-specifier-seq</span> implies there can exist <a href="declarations.html#Specifiers" title="cpp/language/declarations">specifiers</a> other than type specifiers, the only other specifier allowed is <span class="kw4">register</span> <span class="t-rev-inl t-until-cxx11"><span>as well as <code>auto</code></span><span><span class="t-mark-rev t-until-cxx11">(until C++11)</span></span></span>, and it has no effect.</p>
</td> <td><span class="t-mark-rev t-until-cxx17">(until C++17)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx20">
<td> <p>If any of the function parameters uses a <i>placeholder</i> (either <span class="kw4">auto</span> or a <a href="../concepts.html" title="cpp/concepts">concept type</a>), the function declaration is instead an <a href="function_template.html#Abbreviated_function_template" title="cpp/language/function template">abbreviated function template</a> declaration:</p>
<div class="cpp source-cpp"><pre data-language="cpp">void f1(auto);    // same as template&lt;class T&gt; void f1(T)
void f2(C1 auto); // same as template&lt;C1 T&gt; void f2(T), if C1 is a concept</pre></div> </td> <td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td>
</tr> </table> <p>Parameter names declared in function declarations are usually for only self-documenting purposes. They are used (but remain optional) in function definitions.</p>
<p>The type of each function parameter in the parameter list is determined according to the following rules:</p>
<div class="t-li1">
<span class="t-li">1)</span> First, <span class="t-spar">decl-specifier-seq</span> and the declarator are combined as in any <a href="declarations.html" title="cpp/language/declarations">declaration</a> to determine the type.</div> <div class="t-li1">
<span class="t-li">2)</span> If the type is "array of T" or "array of unknown bound of T", it is replaced by the type "pointer to T".</div> <div class="t-li1">
<span class="t-li">3)</span> If the type is a function type F, it is replaced by the type "pointer to F".</div> <div class="t-li1">
<span class="t-li">4)</span> Top-level cv-qualifiers are dropped from the parameter type (This adjustment only affects the function type, but doesn't modify the property of the parameter: <code>int f(const int p, decltype(p)*);</code> and <code>int f(int, const int*);</code> declare the same function).</div> <p>Because of these rules, the following function declarations declare exactly the same function:</p>
<div class="cpp source-cpp"><pre data-language="cpp">int f(char s[3]);
int f(char[]);
int f(char* s);
int f(char* const);
int f(char* volatile s);</pre></div> <p>The following declarations also declare exactly the same function:</p>
<div class="cpp source-cpp"><pre data-language="cpp">int f(int());
int f(int (*g)());</pre></div> <p>An ambiguity arises in a parameter list when a type name is nested in parentheses <span class="t-rev-inl t-since-cxx11"><span>(including <a href="lambda.html" title="cpp/language/lambda">lambda expressions</a>)</span><span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span>. In this case, the choice is between the declaration of a parameter of type pointer to function and the declaration of a parameter with redundant parentheses around the identifier of the <span class="t-spar">declarator</span>. The resolution is to consider the type name as a <a href="declarations.html#Specifiers" title="cpp/language/declarations">simple type specifier</a> (which is the pointer to function type):</p>
<div class="cpp source-cpp"><pre data-language="cpp">class C {};
 
void f(int(C)) {} // void f(int(*fp)(C param)) {}
                  // NOT void f(int C) {}
 
void g(int *(C[10])); // void g(int *(*fp)(C param[10]));
                      // NOT void g(int *C[10]);</pre></div> <p>Parameter type cannot be a type that includes a reference or a pointer to array of unknown bound, including a multi-level pointers/arrays of such types, or a pointer to functions whose parameters are such types. </p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>The ellipsis that indicates <a href="variadic_arguments.html" title="cpp/language/variadic arguments">variadic arguments</a> need not be preceded by a comma, even if it follows the ellipsis that indicates a <a href="parameter_pack.html" title="cpp/language/parameter pack">parameter pack</a> expansion, so the following function templates are exactly the same:</p>
<div class="cpp source-cpp"><pre data-language="cpp">template&lt;typename... Args&gt;
void f(Args..., ...);
 
template&lt;typename... Args&gt;
void f(Args... ...);
 
template&lt;typename... Args&gt;
void f(Args......);</pre></div> <p>An example of when such declaration might be used is the <a href="../types/is_function.html#Possible_implementation" title="cpp/types/is function">possible implementation</a> of <code><a href="../types/is_function.html" title="cpp/types/is function">std::is_function</a></code>.</p>
<div class="cpp source-cpp"><pre data-language="cpp">#include &lt;cstdio&gt;
 
template&lt;typename... Variadic, typename... Args&gt;
constexpr void invoke(auto (*fun)(Variadic......), Args... args)
{
    fun(args...);
}
 
int main()
{
    invoke(std::printf, "%dm•%dm•%dm = %d%s%c", 2,3,7, 2*3*7, "m³", '\n');
}</pre></div> <p>Output:</p>
<div class="text source-text"><pre data-language="c">2m•3m•7m = 42m³</pre></div>  </td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <h3 id="Function_type"> Function type</h3> <h4 id="Parameter-type-list"> Parameter-type-list</h4> <p>A function’s <i>parameter-type-list</i> is determined as follows:</p>
<ol>
<li> The type of each parameter<span class="t-rev-inl t-since-cxx11"><span> (including function <a href="parameter_pack.html" title="cpp/language/parameter pack">parameter packs</a>)</span><span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span> is determined from its own <a href="#Parameter_list">parameter declaration</a>. </li>
<li> After determining the type of each parameter, any parameter of type “array of <code>T</code>” or of function type <code>T</code> is adjusted to be “pointer to <code>T</code>”. </li>
<li> After producing the list of parameter types, any top-level <a href="cv.html" title="cpp/language/cv">cv-qualifiers</a> modifying a parameter type are deleted when forming the function type. </li>
<li> The resulting list of transformed parameter types and the presence or absence of the <a href="variadic_arguments.html" title="cpp/language/variadic arguments">ellipsis</a><span class="t-rev-inl t-since-cxx11"><span> or a function <a href="parameter_pack.html" title="cpp/language/parameter pack">parameter pack</a></span><span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span> is the function’s parameter-type-list. </li>
</ol> <div class="cpp source-cpp"><pre data-language="cpp">void f(char*);         // #1
void f(char[]) {}      // defines #1
void f(const char*) {} // OK, another overload
void f(char* const) {} // error: redefines #1
 
void g(char(*)[2]);   // #2
void g(char[3][2]) {} // defines #2
void g(char[3][3]) {} // OK, another overload
 
void h(int x(const int)); // #3
void h(int (*)(int)) {}   // defines #3</pre></div> <h4 id="Determining_function_type"> Determining function type</h4> <p>In syntax <span class="t-v">(1)</span>, assuming <span class="t-spar">noptr-declarator</span> as a standalone declaration, given the type of the <span class="t-spar">qualified-id</span> or <span class="t-spar">unqualified-id</span> in <span class="t-spar">noptr-declarator</span> as “derived-declarator-type-list <code>T</code>”:</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <ul><li> If the exception specification is <a href="noexcept_spec.html" title="cpp/language/noexcept spec">non-throwing</a>, the type of the function declared is<br>“derived-declarator-type-list <span class="kw1">noexcept</span> function of<br>parameter-type-list <span class="t-spar">cv</span> ﻿<span class="t-mark">(optional)</span> <span class="t-spar">ref</span> ﻿ ﻿<span class="t-mark">(optional)</span> returning <code>T</code>”. </li></ul> </td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <ul><li> <span class="t-rev-inl t-until-cxx17"><span>The</span><span><span class="t-mark-rev t-until-cxx17">(until C++17)</span></span></span><span class="t-rev-inl t-since-cxx17"><span>Otherwise, the</span><span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span> type of the function declared is<br>“derived-declarator-type-list function of<br>parameter-type-list <span class="t-spar">cv</span> ﻿<span class="t-mark">(optional)</span><span class="t-rev-inl t-since-cxx11"><span> <span class="t-spar">ref</span> ﻿ ﻿<span class="t-mark">(optional)</span></span><span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span> returning <code>T</code>”. </li></ul> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p>In syntax <span class="t-v">(2)</span>, assuming <span class="t-spar">noptr-declarator</span> as a standalone declaration, given the type of the <span class="t-spar">qualified-id</span> or <span class="t-spar">unqualified-id</span> in <span class="t-spar">noptr-declarator</span> as “derived-declarator-type-list <code>T</code>” (<code>T</code> must be <span class="kw4">auto</span> in this case):</p>
<table class="t-rev-begin"> <tr class="t-rev t-since-cxx17">
<td> <ul><li> If the exception specification is <a href="noexcept_spec.html" title="cpp/language/noexcept spec">non-throwing</a>, the type of the function declared is<br>“derived-declarator-type-list <span class="kw1">noexcept</span> function of<br>parameter-type-list <span class="t-spar">cv</span> ﻿<span class="t-mark">(optional)</span> <span class="t-spar">ref</span> ﻿ ﻿<span class="t-mark">(optional)</span> returning <span class="t-spar">trailing</span> ﻿”. </li></ul> </td> <td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td>
</tr> </table> <ul><li> <span class="t-rev-inl t-until-cxx17"><span>The</span><span><span class="t-mark-rev t-until-cxx17">(until C++17)</span></span></span><span class="t-rev-inl t-since-cxx17"><span>Otherwise, the</span><span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span> type of the function declared is<br>“derived-declarator-type-list function of<br>parameter-type-list <span class="t-spar">cv</span> ﻿<span class="t-mark">(optional)</span> <span class="t-spar">ref</span> ﻿ ﻿<span class="t-mark">(optional)</span> returning <span class="t-spar">trailing</span> ﻿”. </li></ul> </td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <p><span class="t-spar">attr</span>, if present, applies to the function type.</p>
</td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <div class="cpp source-cpp"><pre data-language="cpp">// the type of “f1” is
// “function of int returning void, with attribute noreturn”
void f1(int a) [[noreturn]];
 
// the type of “f2” is
// “constexpr noexcept function of pointer to int returning int”
constexpr auto f2(int[] b) noexcept -&gt; int;
 
struct X
{
    // the type of “f3” is
    // “function of no parameter const returning const int”
    const int f3() const;
};</pre></div> <h4 id="Trailing_qualifiers"> Trailing qualifiers</h4> <p>A function type with <span class="t-spar">cv</span> ﻿<span class="t-rev-inl t-since-cxx11"><span> or <span class="t-spar">ref</span> ﻿ ﻿</span><span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span> (including a type named by <a href="typedef.html" title="cpp/language/typedef"><code>typedef</code></a> name) can appear only as:</p>
<ul>
<li> the function type for a <a href="member_functions.html" title="cpp/language/member functions">non-static member function</a>, </li>
<li> the function type to which a pointer to member refers, </li>
<li> the top-level function type of a function <span class="kw1">typedef</span> declaration<span class="t-rev-inl t-since-cxx11"><span> or <a href="type_alias.html" title="cpp/language/type alias">alias declaration</a></span><span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span>, </li>
<li> the <a href="type.html#Type_naming" title="cpp/language/type">type-id</a> in the default argument of a <a href="template_parameters.html#Type_template_parameter" title="cpp/language/template parameters">template type parameter</a>, or </li>
<li> the type-id of a template argument for a template type parameter. </li>
</ul> <div class="cpp source-cpp"><pre data-language="cpp">typedef int FIC(int) const;
FIC f;     // Error: does not declare a member function
 
struct S
{
    FIC f; // OK
};
 
FIC S::*pm = &amp;S::f; // OK</pre></div> <h3 id="Function_definition"> Function definition</h3> <p>A non-member function definition may appear at namespace scope only (there are no nested functions). A <a href="member_functions.html" title="cpp/language/member functions">member function</a> definition may also appear in the body of a <a href="class.html" title="cpp/language/class">class definition</a>. They have the following syntax:</p>
<table class="t-sdsc-begin">  <tr class="t-sdsc"> <td class="t-sdsc-nopad"> <span class="t-spar">attr</span> ﻿<span class="t-mark">(optional)</span> <span class="t-spar">decl-specifier-seq</span> ﻿<span class="t-mark">(optional)</span> <span class="t-spar">declarator</span> <span class="t-spar">virt-specifier-seq</span> ﻿<span class="t-mark">(optional)</span> <span class="t-spar">function-body</span> </td> <td class="t-sdsc-nopad"> </td> <td class="t-sdsc-nopad"> </td>
</tr> 
</table> <p>where <span class="t-spar">function-body</span> is one of the following</p>
<table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <span class="t-spar">ctor-initializer</span> ﻿<span class="t-mark">(optional)</span> <span class="t-spar">compound-statement</span> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">function-try-block</span> </td> <td> (2) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <code>=</code> <code>delete</code> <code>;</code> </td> <td> (3) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td>
</tr>  <tr class="t-sdsc"> <td> <code>=</code> <code>default</code> <code>;</code> </td> <td> (4) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td>
</tr> 
</table> <div class="t-li1">
<span class="t-li">1)</span> Regular function body.</div> <div class="t-li1">
<span class="t-li">2)</span> <a href="function-try-block.html" title="cpp/language/function-try-block">Function-try-block</a> (which is a regular function body wrapped in a try/catch block).</div> <div class="t-li1">
<span class="t-li">3)</span> Explicitly deleted function definition.</div> <div class="t-li1">
<span class="t-li">4)</span> Explicitly defaulted function definition, only allowed for <a href="member_functions.html#Special_member_functions" title="cpp/language/member functions">special member functions</a><span class="t-rev-inl t-since-cxx20"><span> and <a href="default_comparisons.html" title="cpp/language/default comparisons">comparison operator functions</a></span><span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span>.</div> <table class="t-par-begin"> <tr class="t-par"> <td> <span class="t-spar">attr</span> </td> <td> - </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> a list of <a href="attributes.html" title="cpp/language/attributes">attributes</a>. These attributes are combined with the attributes after the identifier in the <span class="t-spar">declarator</span> (see top of this page), if any. </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">decl-specifier-seq</span> </td> <td> - </td> <td> the return type with specifiers, as in the <a href="declarations.html" title="cpp/language/declarations">declaration grammar</a> </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">declarator</span> </td> <td> - </td> <td> function declarator, same as in the function declaration grammar above (can be parenthesized). <span class="t-rev-inl t-since-cxx20"><span>as with function declaration, it may be followed by a <span class="t-spar">requires-clause</span></span><span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span> </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">virt-specifier-seq</span> </td> <td> - </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> <a href="override.html" title="cpp/language/override"><code>override</code></a>, <a href="final.html" title="cpp/language/final"><code>final</code></a>, or their combination in any order (only allowed for non-static member functions) </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">ctor-initializer</span> </td> <td> - </td> <td> <a href="initializer_list.html" title="cpp/language/initializer list" class="mw-redirect">member initializer list</a>, only allowed in constructors </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">compound-statement</span> </td> <td> - </td> <td> the brace-enclosed <a href="statements.html#Compound_statements" title="cpp/language/statements">sequence of statements</a> that constitutes the body of a function </td>
</tr>
</table> <div class="cpp source-cpp"><pre data-language="cpp">int max(int a, int b, int c)
{
    int m = (a &gt; b) ? a : b;
    return (m &gt; c) ? m : c;
}
 
// decl-specifier-seq is "int"
// declarator is "max(int a, int b, int c)"
// body is { ... }</pre></div> <p>The function body is a <a href="statements.html#Compound_statements" title="cpp/language/statements">compound statement</a> (sequence of zero or more statements surrounded by a pair of curly braces), which is executed when the function call is made.</p>
<p>The parameter types, as well as the return type of a function definition cannot be (possibly cv-qualified) <a href="incomplete_type.html" title="cpp/language/incomplete type" class="mw-redirect">incomplete</a> <a href="class.html" title="cpp/language/class">class types</a><span class="t-rev-inl t-since-cxx11"><span> unless the function is defined as deleted</span><span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span>. The completeness check is only made in the function body, which allows <a href="member_functions.html" title="cpp/language/member functions">member functions</a> to return the class in which they are defined (or its enclosing class), even if it is incomplete at the point of definition (it is complete in the function body).</p>
<p>The parameters declared in the <span class="t-spar">declarator</span> of a function definition are <a href="scope.html" title="cpp/language/scope">in scope</a> within the body. If a parameter is not used in the function body, it does not need to be named (it's sufficient to use an abstract declarator):</p>
<div class="cpp source-cpp"><pre data-language="cpp">void print(int a, int) // second parameter is not used
{
    std::printf("a = %d\n", a);
}</pre></div> <p>Even though top-level <a href="cv.html" title="cpp/language/cv">cv-qualifiers</a> on the parameters are discarded in function declarations, they modify the type of the parameter as visible in the body of a function:</p>
<div class="cpp source-cpp"><pre data-language="cpp">void f(const int n) // declares function of type void(int)
{
    // but in the body, the type of n is const int
}</pre></div> <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11">
<td> <h3 id="Deleted_functions"> Deleted functions</h3> <p>If, instead of a function body, the special syntax <code>= delete;</code> is used, the function is defined as <i>explicitly deleted</i>. Any use of a deleted function is ill-formed (the program will not compile). This includes calls, both explicit (with a function call operator) and implicit (a call to deleted overloaded operator, special member function, allocation function etc), constructing a pointer or pointer-to-member to a deleted function, and even the use of a deleted function in an expression that is not <a href="expressions.html#Potentially-evaluated_expressions" title="cpp/language/expressions">potentially-evaluated</a>. However, implicit <a href="definition.html#ODR-use" title="cpp/language/definition">ODR-use</a> of a non-pure virtual member function that happens to be deleted is allowed.</p>
<p>If the function is overloaded, <a href="overload_resolution.html" title="cpp/language/overload resolution">overload resolution</a> takes place first, and the program is only ill-formed if the deleted function was selected:</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct sometype
{
    void* operator new(std::size_t) = delete;
    void* operator new[](std::size_t) = delete;
};
sometype* p = new sometype; // error: attempts to call deleted sometype::operator new</pre></div> <p>The deleted definition of a function must be the first declaration in a translation unit: a previously-declared function cannot be redeclared as deleted:</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct sometype { sometype(); };
sometype::sometype() = delete; // error: must be deleted on the first declaration</pre></div> <h3 id="User-provided_functions"> User-provided functions</h3> <p>A function is <i>user-provided</i> if it is user-declared and not explicitly defaulted or deleted on its first declaration. A user-provided explicitly-defaulted function (i.e., explicitly defaulted after its first declaration) is defined at the point where it is explicitly defaulted; if such a function is implicitly defined as deleted, the program is ill-formed. Declaring a function as defaulted after its first declaration can provide efficient execution and concise definition while enabling a stable binary interface to an evolving code base.</p>
<div class="cpp source-cpp"><pre data-language="cpp">// All special member functions of “trivial” are
// defaulted on their first declarations respectively,
// they are not user-provided
struct trivial
{
    trivial() = default;
    trivial(const trivial&amp;) = default;
    trivial(trivial&amp;&amp;) = default;
    trivial&amp; operator=(const trivial&amp;) = default;
    trivial&amp; operator=(trivial&amp;&amp;) = default;
    ~trivial() = default;
};
 
struct nontrivial
{
    nontrivial(); // first declaration
};
 
// not defaulted on the first declaration,
// it is user-provided and is defined here
nontrivial::nontrivial() = default;</pre></div> <h3 id="func"> __func__</h3> <p>Within the function body, the function-local predefined variable <code>__func__</code> is defined as if by</p>
<div class="cpp source-cpp"><pre data-language="cpp">static const char __func__[] = "function-name";</pre></div> <p>This variable has block scope and static storage duration:</p>
<div class="cpp source-cpp"><pre data-language="cpp">struct S
{
    S(): s(__func__) {} // okay: initializer-list is part of function body
    const char* s;
};
void f(const char* s = __func__); // error: parameter-list is part of declarator</pre></div>  <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
 
void Foo() { std::cout &lt;&lt; __func__ &lt;&lt; ' '; }
 
struct Bar
{
    Bar() { std::cout &lt;&lt; __func__ &lt;&lt; ' '; }
    ~Bar() { std::cout &lt;&lt; __func__ &lt;&lt; ' '; }
    struct Pub { Pub() { std::cout &lt;&lt; __func__ &lt;&lt; ' '; } };
};
 
int main()
{
    Foo();
    Bar bar;
    Bar::Pub pub;
}</pre></div> <p>Possible output:</p>
<div class="text source-text"><pre data-language="c">Foo Bar Pub ~Bar</pre></div>  </td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <h3 id="Notes"> Notes</h3> <p>In case of ambiguity between a variable declaration using the direct-initialization syntax and a function declaration, the compiler always chooses function declaration; see <a href="direct_initialization.html#Notes" title="cpp/language/direct initialization">direct-initialization</a>.</p>
<table class="wikitable ftm-begin ftm-has-value"> <tr> <th>Feature-test macro</th> <th>Value</th> <th><span title="Standard in which the feature is introduced">Std</span></th> <th>Feature </th>
</tr> <tr> <td><a href="../feature_test.html#cpp_decltype_auto" title="cpp/feature test"><code>__cpp_decltype_auto</code></a></td> <td><span class="nu0">201304L</span></td> <td><span class="t-mark">(C++14)</span></td> <td>
<a href="auto.html" title="cpp/language/auto"><code>decltype(auto)</code></a> </td>
</tr> <tr> <td><a href="../feature_test.html#cpp_return_type_deduction" title="cpp/feature test"><code>__cpp_return_type_deduction</code></a></td> <td><span class="nu0">201304L</span></td> <td><span class="t-mark">(C++14)</span></td> <td>
<a href="#Return_type_deduction">Return type deduction for normal functions</a> </td>
</tr>
</table> <h3 id="Example"> Example</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
 
// simple function with a default argument, returning nothing
void f0(const std::string&amp; arg = "world!")
{
    std::cout &lt;&lt; "Hello, " &lt;&lt; arg &lt;&lt; '\n';
}
 
// the declaration is in namespace (file) scope
// (the definition is provided later)
int f1();
 
// function returning a pointer to f0, pre-C++11 style
void (*fp03())(const std::string&amp;)
{
    return f0;
}
 
// function returning a pointer to f0, with C++11 trailing return type
auto fp11() -&gt; void(*)(const std::string&amp;)
{
    return f0;
}
 
int main()
{
    f0();
    fp03()("test!");
    fp11()("again!");
    int f2(std::string) noexcept; // declaration in function scope
    std::cout &lt;&lt; "f2(\"bad\"): " &lt;&lt; f2("bad") &lt;&lt; '\n';
    std::cout &lt;&lt; "f2(\"42\"): " &lt;&lt; f2("42") &lt;&lt; '\n';
}
 
// simple non-member function returning int
int f1()
{
    return 007;
}
 
// function with an exception specification and a function try block
int f2(std::string str) noexcept
try
{
    return std::stoi(str);
}
catch (const std::exception&amp; e)
{
    std::cerr &lt;&lt; "stoi() failed!\n";
    return 0;
}</pre></div> <p>Possible output:</p>
<div class="text source-text"><pre data-language="c">stoi() failed!
Hello, world!
Hello, test!
Hello, again!
f2("bad"): 0
f2("42"): 42</pre></div> </div> <h3 id="Defect_reports"> Defect reports</h3> <p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.</p>
<table class="dsctable"> <tr> <th>DR </th> <th>Applied to </th> <th>Behavior as published </th> <th>Correct behavior </th>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/135.html">CWG 135</a> </td> <td>C++98 </td> <td>member functions defined in class<br>could not have a parameter of or return<br>its own class because it is incomplete </td> <td>allowed </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/332.html">CWG 332</a> </td> <td>C++98 </td> <td>a parameter could have cv-qualified <span class="kw4">void</span> type </td> <td>prohibited </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/393.html">CWG 393</a> </td> <td>C++98 </td> <td>types that include pointers/references to<br>array of unknown bound could not be parameters </td> <td>such types are allowed </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/452.html">CWG 452</a> </td> <td>C++98 </td> <td>member initializer list was not a part of function body </td> <td>made it a part of function<br>body by modifying the syntax<br>of function definition </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/577.html">CWG 577</a> </td> <td>C++98 </td> <td>dependent type <span class="kw4">void</span> could be used to<br>declare a function taking no parameters </td> <td>only non-dependent<br><span class="kw4">void</span> is allowed </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1327.html">CWG 1327</a> </td> <td>C++11 </td> <td>defaulted or deleted functions could not<br>be specified with override or final </td> <td>allowed </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1355.html">CWG 1355</a> </td> <td>C++11 </td> <td>only special member functions could be user-provided </td> <td>extended to all functions </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1394.html">CWG 1394</a> </td> <td>C++11 </td> <td>deleted functions could not have any parameter of<br>an incomplete type or return an incomplete type </td> <td>incomplete type allowed </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1824.html">CWG 1824</a> </td> <td>C++98 </td> <td>the completeness check on parameter type and<br>return type of a function definition could be made<br>outside the context of the function definition </td> <td>only make the completeness<br>check in the context of<br>the function definition </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1877.html">CWG 1877</a> </td> <td>C++14 </td> <td>return type deduction treated <code>return;</code> as <code>return void();</code> </td> <td>simply deduce the return<br>type as <span class="kw4">void</span> in this case </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2015.html">CWG 2015</a> </td> <td>C++11 </td> <td>the implicit odr-use of a deleted<br>virtual function was ill-formed </td> <td>such odr-uses are exempt<br>from the use prohibition </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2044.html">CWG 2044</a> </td> <td>C++14 </td> <td>return type deduction on functions returning <span class="kw4">void</span><br>would fail if the declared return type is decltype<span class="br0">(</span><span class="kw4">auto</span><span class="br0">)</span> </td> <td>updated the deduction<br>rule to handle this case </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2081.html">CWG 2081</a> </td> <td>C++14 </td> <td>function redeclarations could use return type<br>deduction even if the initial declaration does not </td> <td>not allowed </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2145.html">CWG 2145</a> </td> <td>C++98 </td> <td>the <span class="t-spar">declarator</span> in function definition could not be parenthesized </td> <td>allowed </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2259.html">CWG 2259</a> </td> <td>C++11 </td> <td>the ambiguity resolution rule regarding parenthesized<br>type names did not cover lambda expressions </td> <td>covered </td>
</tr> <tr> <td>
<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2430.html">CWG 2430</a> </td> <td>C++98 </td> <td>in the definition of a member function in a class definition,<br>the type of that class could not be the return type or<br>parameter type due to the resolution of <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1824.html">CWG issue 1824</a> </td> <td>only make the completeness<br>check in the function body </td>
</tr>
</table> <h3 id="See_also"> See also</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td colspan="2"> <span><a href="https://en.cppreference.com/w/c/language/function_declaration" title="c/language/function declaration">C documentation</a></span> for <span class=""><span>Declaring functions</span></span> </td>
</tr> </table>           <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/cpp/language/function" class="_attribution-link">https://en.cppreference.com/w/cpp/language/function</a>
  </p>
</div>
