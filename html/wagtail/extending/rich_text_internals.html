<h1>Rich text internals</h1> <p>At first glance, Wagtail’s rich text capabilities appear to give editors direct control over a block of HTML content. In reality, it’s necessary to give editors a representation of rich text content that is several steps removed from the final HTML output, for several reasons:</p> <ul class="simple"> <li>The editor interface needs to filter out certain kinds of unwanted markup; this includes malicious scripting, font styles pasted from an external word processor, and elements which would break the validity or consistency of the site design (for example, pages will generally reserve the <code>&lt;h1&gt;</code> element for the page title, and so it would be inappropriate to allow users to insert their own additional <code>&lt;h1&gt;</code> elements through rich text).</li> <li>Rich text fields can specify a <code>features</code> argument to further restrict the elements permitted in the field - see <a class="reference internal" href="../advanced_topics/customisation/page_editing_interface.html#rich-text-features"><span class="std std-ref">Rich Text Features</span></a>.</li> <li>Enforcing a subset of HTML helps to keep presentational markup out of the database, making the site more maintainable, and making it easier to repurpose site content (including, potentially, producing non-HTML output such as <a class="reference external" href="https://www.latex-project.org/">LaTeX</a>).</li> <li>Elements such as page links and images need to preserve metadata such as the page or image ID, which is not present in the final HTML representation.</li> </ul> <p>This requires the rich text content to go through a number of validation and conversion steps; both between the editor interface and the version stored in the database, and from the database representation to the final rendered HTML.</p> <p>For this reason, extending Wagtail’s rich text handling to support a new element is more involved than simply saying (for example) “enable the <code>&lt;blockquote&gt;</code> element”, since various components of Wagtail - both client and server-side - need to agree on how to handle that feature, including how it should be exposed in the editor interface, how it should be represented within the database, and (if appropriate) how it should be translated when rendered on the front-end.</p> <p>The components involved in Wagtail’s rich text handling are described below.</p> <section id="data-format"> <h2>Data format</h2> <p>Rich text data (as handled by <a class="reference internal" href="../advanced_topics/customisation/page_editing_interface.html#rich-text"><span class="std std-ref">RichTextField</span></a>, and <code>RichTextBlock</code> within <a class="reference internal" href="../topics/streamfield.html"><span class="doc std std-doc">StreamField</span></a>) is stored in the database in a format that is similar, but not identical, to HTML. For example, a link to a page might be stored as:</p> <pre data-language="html">&lt;p&gt;&lt;a linktype="page" id="3"&gt;Contact us&lt;/a&gt; for more information.&lt;/p&gt;
</pre> <p>Here, the <code>linktype</code> attribute identifies a rule that shall be used to rewrite the tag. When rendered on a template through the <code>|richtext</code> filter (see <a class="reference internal" href="../topics/writing_templates.html#rich-text-filter"><span class="std std-ref">rich text filter</span></a>), this is converted into valid HTML:</p> <pre data-language="html">&lt;p&gt;&lt;a href="/contact-us/.html"&gt;Contact us&lt;/a&gt; for more information.&lt;/p&gt;
</pre> <p>In the case of <code>RichTextBlock</code>, the block’s value is a <code>RichText</code> object which performs this conversion automatically when rendered as a string, so the <code>|richtext</code> filter is not necessary.</p> <p>Likewise, an image inside rich text content might be stored as:</p> <pre data-language="html">&lt;embed embedtype="image" id="10" alt="A pied wagtail" format="left" /&gt;
</pre> <p>which is converted into an <code>img</code> element when rendered:</p> <pre data-language="html">&lt;img
    alt="A pied wagtail"
    class="richtext-image left"
    height="294"
    src="/media/images/pied-wagtail.width-500_ENyKffb.jpg"
    width="500"
/&gt;
</pre> <p>Again, the <code>embedtype</code> attribute identifies a rule that shall be used to rewrite the tag. All tags other than <code>&lt;a linktype="..."&gt;</code> and <code>&lt;embed embedtype="..." /&gt;</code> are left unchanged in the converted HTML.</p> <p>A number of additional constraints apply to <code>&lt;a linktype="..."&gt;</code> and <code>&lt;embed embedtype="..." /&gt;</code> tags, to allow the conversion to be performed efficiently via string replacement:</p> <ul class="simple"> <li>The tag name and attributes must be lower-case</li> <li>Attribute values must be quoted with double-quotes</li> <li>
<code>embed</code> elements must use XML self-closing tag syntax (those that end in <code>/&gt;</code> instead of a closing <code>&lt;/embed&gt;</code> tag)</li> <li>The only HTML entities permitted in attribute values are <code>&amp;lt;</code>, <code>&amp;gt;</code>, <code>&amp;amp;</code> and <code>&amp;quot;</code>
</li> </ul> </section> <section id="the-feature-registry"> <h2>The feature registry</h2> <p>Any app within your project can define extensions to Wagtail’s rich text handling, such as new <code>linktype</code> and <code>embedtype</code> rules. An object known as the <em>feature registry</em> serves as a central source of truth about how rich text should behave. This object can be accessed through the <a class="reference internal" href="../reference/hooks.html#register-rich-text-features"><span class="std std-ref">Register Rich Text Features</span></a> hook, which is called on startup to gather all definitions relating to rich text:</p> <pre data-language="python">
    # my_app/wagtail_hooks.py

    from wagtail import hooks

    @hooks.register('register_rich_text_features')
    def register_my_feature(features):
        # add new definitions to 'features' here
</pre> </section> <section id="rewrite-handlers"> <h2 id="rich-text-rewrite-handlers">Rewrite handlers</h2> <p>Rewrite handlers are classes that know how to translate the content of rich text tags like <code>&lt;a linktype="..."&gt;</code> and <code>&lt;embed embedtype="..." /&gt;</code> into front-end HTML. For example, the <code>PageLinkHandler</code> class knows how to convert the rich text tag <code>&lt;a linktype="page" id="123"&gt;</code> into the HTML tag <code>&lt;a href="/path/to/page/123.html"&gt;</code>.</p> <p>Rewrite handlers can also provide other useful information about rich text tags. For example, given an appropriate tag, <code>PageLinkHandler</code> can be used to extract which page is being referred to. This can be useful for downstream code that may want information about objects being referenced in rich text.</p> <p>You can create custom rewrite handlers to support your own new <code>linktype</code> and <code>embedtype</code> tags. New handlers must be Python classes that inherit from either <code>wagtail.richtext.LinkHandler</code> or <code>wagtail.richtext.EmbedHandler</code>. Your new classes should override at least some of the following methods (listed here for <code>LinkHandler</code>, although <code>EmbedHandler</code> has an identical signature):</p>  <p>Below is an example custom rewrite handler that implements these methods to add support for rich text linking to user email addresses. It supports the conversion of rich text tags like <code>&lt;a linktype="user" username="wagtail"&gt;</code> to valid HTML like <code>&lt;a href="mailto:hello@wagtail.org.html"&gt;</code>. This example assumes that equivalent front-end functionality has been added to allow users to insert these kinds of links into their rich text editor.</p> <pre data-language="python">from django.contrib.auth import get_user_model
from wagtail.rich_text import LinkHandler

class UserLinkHandler(LinkHandler):
    identifier = 'user'

    @staticmethod
    def get_model():
        return get_user_model()

    @classmethod
    def get_instance(cls, attrs):
        model = cls.get_model()
        return model.objects.get(username=attrs['username'])

    @classmethod
    def expand_db_attributes(cls, attrs):
        user = cls.get_instance(attrs)
        return '&lt;a href="mailto:%s.html"&gt;' % user.email
</pre> <section id="registering-rewrite-handlers"> <h3>Registering rewrite handlers</h3> <p>Rewrite handlers must also be registered with the feature registry via the <a class="reference internal" href="../reference/hooks.html#register-rich-text-features"><span class="std std-ref">register rich text features</span></a> hook. Independent methods for registering both link handlers and embed handlers are provided.</p>  <p>This method allows you to register a custom handler deriving from <code>wagtail.rich_text.LinkHandler</code>, and adds it to the list of link handlers available during rich text conversion.</p> <pre data-language="python"># my_app/wagtail_hooks.py

from wagtail import hooks
from my_app.handlers import MyCustomLinkHandler

@hooks.register('register_rich_text_features')
def register_link_handler(features):
    features.register_link_type(MyCustomLinkHandler)
</pre> <p>It is also possible to define link rewrite handlers for Wagtail’s built-in <code>external</code> and <code>email</code> links, even though they do not have a predefined <code>linktype</code>. For example, if you want external links to have a <code>rel="nofollow"</code> attribute for SEO purposes:</p> <pre data-language="python">from django.utils.html import escape
from wagtail import hooks
from wagtail.rich_text import LinkHandler

class NoFollowExternalLinkHandler(LinkHandler):
    identifier = 'external'

    @classmethod
    def expand_db_attributes(cls, attrs):
        href = attrs["href"]
        return '&lt;a href="%s.html" rel="nofollow"&gt;' % escape(href)

@hooks.register('register_rich_text_features')
def register_external_link(features):
    features.register_link_type(NoFollowExternalLinkHandler)
</pre> <p>Similarly you can use <code>email</code> linktype to add a custom rewrite handler for email links (for example to obfuscate emails in rich text).</p>  <p>This method allows you to register a custom handler deriving from <code>wagtail.rich_text.EmbedHandler</code>, and adds it to the list of embed handlers available during rich text conversion.</p> <pre data-language="python"># my_app/wagtail_hooks.py

from wagtail import hooks
from my_app.handlers import MyCustomEmbedHandler

@hooks.register('register_rich_text_features')
def register_embed_handler(features):
    features.register_embed_type(MyCustomEmbedHandler)
</pre> </section> </section> <section id="editor-widgets"> <h2>Editor widgets</h2> <p>The editor interface used on rich text fields can be configured with the <a class="reference internal" href="../reference/settings.html#wagtailadmin-rich-text-editors"><span class="std std-ref">WAGTAILADMIN_RICH_TEXT_EDITORS</span></a> setting. Wagtail provides an implementation: <code>wagtail.admin.rich_text.DraftailRichTextArea</code> (the <a class="reference external" href="https://www.draftail.org/">Draftail</a> editor based on <a class="reference external" href="https://draftjs.org/">Draft.js</a>).</p> <p>It is possible to create your own rich text editor implementation. At minimum, a rich text editor is a Django <strong><em>class</em> django.forms.Widget</strong> subclass whose constructor accepts an <code>options</code> keyword argument (a dictionary of editor-specific configuration options sourced from the <code>OPTIONS</code> field in <code>WAGTAILADMIN_RICH_TEXT_EDITORS</code>), and which consumes and produces string data in the HTML-like format described above.</p> <p>Typically, a rich text widget also receives a <code>features</code> list, passed from either <code>RichTextField</code> / <code>RichTextBlock</code> or the <code>features</code> option in <code>WAGTAILADMIN_RICH_TEXT_EDITORS</code>, which defines the features available in that instance of the editor (see <a class="reference internal" href="../advanced_topics/customisation/page_editing_interface.html#rich-text-features"><span class="std std-ref">rich text features</span></a>). To opt in to supporting features, set the attribute <code>accepts_features = True</code> on your widget class; the widget constructor will then receive the feature list as a keyword argument <code>features</code>.</p> <p>There is a standard set of recognised feature identifiers as listed under <a class="reference internal" href="../advanced_topics/customisation/page_editing_interface.html#rich-text-features"><span class="std std-ref">rich text features</span></a>, but this is not a definitive list; feature identifiers are only defined by convention, and it is up to each editor widget to determine which features it will recognise, and adapt its behaviour accordingly. Individual editor widgets might implement fewer or more features than the default set, either as built-in functionality or through a plugin mechanism if the editor widget has one.</p> <p>For example, a third-party Wagtail extension might introduce <code>table</code> as a new rich text feature, and provide implementations for the Draftail editor (which provides a plugin mechanism). In this case, the third-party extension will not be aware of your custom editor widget, and so the widget will not know how to handle the <code>table</code> feature identifier. Editor widgets should silently ignore any feature identifiers that they do not recognise.</p> <p>The <code>default_features</code> attribute of the feature registry is a list of feature identifiers to be used whenever an explicit feature list has not been given in <code>RichTextField</code> / <code>RichTextBlock</code> or <code>WAGTAILADMIN_RICH_TEXT_EDITORS</code>. This list can be modified within the <code>register_rich_text_features</code> hook to make new features enabled by default, and retrieved by calling <code>get_default_features()</code>.</p> <pre data-language="python">@hooks.register('register_rich_text_features')
def make_h1_default(features):
    features.default_features.append('h1')
</pre> <p>Outside of the <code>register_rich_text_features</code> hook - for example, inside a widget class - the feature registry can be imported as the object <code>wagtail.rich_text.features</code>. A possible starting point for a rich text editor with feature support would be:</p> <pre data-language="python">from django.forms import widgets
from wagtail.rich_text import features

class CustomRichTextArea(widgets.TextArea):
    accepts_features = True

    def __init__(self, *args, **kwargs):
        self.options = kwargs.pop('options', None)

        self.features = kwargs.pop('features', None)
        if self.features is None:
            self.features = features.get_default_features()

        super().__init__(*args, **kwargs)
</pre> </section> <section id="editor-plugins"> <h2>Editor plugins</h2>  <p>Rich text editors often provide a plugin mechanism to allow extending the editor with new functionality. The <code>register_editor_plugin</code> method provides a standardised way for <code>register_rich_text_features</code> hooks to define plugins to be pulled in to the editor when a given rich text feature is enabled.</p> <p><code>register_editor_plugin</code> is passed an editor name (a string uniquely identifying the editor widget - Wagtail uses the identifier <code>draftail</code> for the built-in editor), a feature identifier, and a plugin definition object. This object is specific to the editor widget and can be any arbitrary value, but will typically include a <a class="reference external" href="https://docs.djangoproject.com/en/stable/topics/forms/media/" title="(in Django v4.1)"><span class="xref std std-doc">Django form media</span></a> definition referencing the plugin’s JavaScript code - which will then be merged into the editor widget’s own media definition - along with any relevant configuration options to be passed when instantiating the editor.</p>  <p>Within the editor widget, the plugin definition for a given feature can be retrieved via the <code>get_editor_plugin</code> method, passing the editor’s own identifier string and the feature identifier. This will return <code>None</code> if no matching plugin has been registered.</p> <p>For details of the plugin formats for Wagtail’s built-in editors, see <a class="reference internal" href="extending_draftail.html"><span class="doc">Extending the Draftail Editor</span></a>.</p> </section> <section id="format-converters"> <h2 id="rich-text-format-converters">Format converters</h2> <p>Editor widgets will often be unable to work directly with Wagtail’s rich text format, and require conversion to their own native format. For Draftail, this is a JSON-based format known as ContentState (see <a class="reference external" href="https://rajaraodv.medium.com/how-draft-js-represents-rich-text-data-eeabb5f25cf2">How Draft.js Represents Rich Text Data</a>). Editors based on HTML’s <code>contentEditable</code> mechanism require valid HTML, and so Wagtail uses a convention referred to as “editor HTML”, where the additional data required on link and embed elements is stored in <code>data-</code> attributes, for example: <code>&lt;a href="/contact-us/.html" data-linktype="page" data-id="3"&gt;Contact us&lt;/a&gt;</code>.</p> <p>Wagtail provides two utility classes, <code>wagtail.admin.rich_text.converters.contentstate.ContentstateConverter</code> and <code>wagtail.admin.rich_text.converters.editor_html.EditorHTMLConverter</code>, to perform conversions between rich text format and the native editor formats. These classes are independent of any editor widget, and distinct from the rewriting process that happens when rendering rich text onto a template.</p> <p>Both classes accept a <code>features</code> list as an argument to their constructor, and implement two methods, <code>from_database_format(data)</code> which converts Wagtail rich text data to the editor’s format, and <code>to_database_format(data)</code> which converts editor data to Wagtail rich text format.</p> <p>As with editor plugins, the behaviour of a converter class can vary according to the feature list passed to it. In particular, it can apply whitelisting rules to ensure that the output only contains HTML elements corresponding to the currently active feature set. The feature registry provides a <code>register_converter_rule</code> method to allow <code>register_rich_text_features</code> hooks to define conversion rules that will be activated when a given feature is enabled.</p>  <p><code>register_editor_plugin</code> is passed a converter name (a string uniquely identifying the converter class - Wagtail uses the identifiers <code>contentstate</code> and <code>editorhtml</code>), a feature identifier, and a rule definition object. This object is specific to the converter and can be any arbitrary value.</p> <p>For details of the rule definition format for the <code>contentstate</code> converter, see <a class="reference internal" href="extending_draftail.html"><span class="doc">Extending the Draftail Editor</span></a>.</p>  <p>Within a converter class, the rule definition for a given feature can be retrieved via the <code>get_converter_rule</code> method, passing the converter’s own identifier string and the feature identifier. This will return <code>None</code> if no matching rule has been registered.</p> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2014-present Torchbox Ltd and individual contributors.<br>All rights are reserved.<br>Licensed under the BSD License.<br>
    <a href="https://docs.wagtail.org/en/stable/extending/rich_text_internals.html" class="_attribution-link">https://docs.wagtail.org/en/stable/extending/rich_text_internals.html</a>
  </p>
</div>
