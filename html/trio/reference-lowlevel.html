<section id="module-trio.lowlevel"> <h1>Introspecting and extending Trio with <code class="docutils literal notranslate"><span class="pre">trio.lowlevel</span></code>
</h1> <p><a class="reference internal" href="#module-trio.lowlevel" title="trio.lowlevel"><code class="xref py py-mod docutils literal notranslate"><span class="pre">trio.lowlevel</span></code></a> contains low-level APIs for introspecting and extending Trio. If you’re writing ordinary, everyday code, then you can ignore this module completely. But sometimes you need something a bit lower level. Here are some examples of situations where you should reach for <a class="reference internal" href="#module-trio.lowlevel" title="trio.lowlevel"><code class="xref py py-mod docutils literal notranslate"><span class="pre">trio.lowlevel</span></code></a>:</p> <ul class="simple"> <li><p>You want to implement a new <a class="reference internal" href="reference-core.html#synchronization"><span class="std std-ref">synchronization primitive</span></a> that Trio doesn’t (yet) provide, like a reader-writer lock.</p></li> <li><p>You want to extract low-level metrics to monitor the health of your application.</p></li> <li><p>You want to use a low-level operating system interface that Trio doesn’t (yet) provide its own wrappers for, like watching a filesystem directory for changes.</p></li> <li><p>You want to implement an interface for calling between Trio and another event loop within the same process.</p></li> <li><p>You’re writing a debugger and want to visualize Trio’s task tree.</p></li> <li><p>You need to interoperate with a C library whose API exposes raw file descriptors.</p></li> </ul> <p>You don’t need to be scared of <a class="reference internal" href="#module-trio.lowlevel" title="trio.lowlevel"><code class="xref py py-mod docutils literal notranslate"><span class="pre">trio.lowlevel</span></code></a>, as long as you take proper precautions. These are real public APIs, with strictly defined and carefully documented semantics. They’re the same tools we use to implement all the nice high-level APIs in the <a class="reference internal" href="reference-core.html#module-trio" title="trio"><code class="xref py py-mod docutils literal notranslate"><span class="pre">trio</span></code></a> namespace. But, be careful. Some of those strict semantics have <a class="reference external" href="https://en.wikipedia.org/wiki/Rabbit_of_Caerbannog">nasty big pointy teeth</a>. If you make a mistake, Trio may not be able to handle it gracefully; conventions and guarantees that are followed strictly in the rest of Trio do not always apply. When you use this module, it’s your job to think about how you’re going to handle the tricky cases so you can expose a friendly Trio-style API to your users.</p> <section id="debugging-and-instrumentation"> <h2>Debugging and instrumentation</h2> <p>Trio tries hard to provide useful hooks for debugging and instrumentation. Some are documented above (the nursery introspection attributes, <a class="reference internal" href="reference-core.html#trio.Lock.statistics" title="trio.Lock.statistics"><code class="xref py py-meth docutils literal notranslate"><span class="pre">trio.Lock.statistics()</span></code></a>, etc.). Here are some more.</p> <section id="global-statistics"> <h3>Global statistics</h3> <dl class="py function"> <h3 class="sig sig-object py" id="trio.lowlevel.current_statistics"><code>trio.lowlevel.current_statistics()</code></h3> <dd>
<p>Returns an object containing run-loop-level debugging information.</p> <p>Currently the following fields are defined:</p> <ul class="simple"> <li><p><code class="docutils literal notranslate"><span class="pre">tasks_living</span></code> (int): The number of tasks that have been spawned and not yet exited.</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">tasks_runnable</span></code> (int): The number of tasks that are currently queued on the run queue (as opposed to blocked waiting for something to happen).</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">seconds_to_next_deadline</span></code> (float): The time until the next pending cancel scope deadline. May be negative if the deadline has expired but we haven’t yet processed cancellations. May be <a class="reference external" href="https://docs.python.org/3/library/math.html#math.inf" title="(in Python v3.11)"><code class="xref py py-data docutils literal notranslate"><span class="pre">inf</span></code></a> if there are no pending deadlines.</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">run_sync_soon_queue_size</span></code> (int): The number of unprocessed callbacks queued via <a class="reference internal" href="#trio.lowlevel.TrioToken.run_sync_soon" title="trio.lowlevel.TrioToken.run_sync_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">trio.lowlevel.TrioToken.run_sync_soon()</span></code></a>.</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">io_statistics</span></code> (object): Some statistics from Trio’s I/O backend. This always has an attribute <code class="docutils literal notranslate"><span class="pre">backend</span></code> which is a string naming which operating-system-specific I/O backend is in use; the other attributes vary between backends.</p></li> </ul> </dd>
</dl> </section> <section id="the-current-clock"> <h3>The current clock</h3> <dl class="py function"> <h3 class="sig sig-object py" id="trio.lowlevel.current_clock"><code>trio.lowlevel.current_clock()</code></h3> <dd>
<p>Returns the current <a class="reference internal" href="reference-core.html#trio.abc.Clock" title="trio.abc.Clock"><code class="xref py py-class docutils literal notranslate"><span class="pre">Clock</span></code></a>.</p> </dd>
</dl> </section> <section id="instrument-api"> <h3>Instrument API</h3> <p>The instrument API provides a standard way to add custom instrumentation to the run loop. Want to make a histogram of scheduling latencies, log a stack trace of any task that blocks the run loop for &gt;50 ms, or measure what percentage of your process’s running time is spent waiting for I/O? This is the place.</p> <p>The general idea is that at any given moment, <a class="reference internal" href="reference-core.html#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a> maintains a set of “instruments”, which are objects that implement the <a class="reference internal" href="#trio.abc.Instrument" title="trio.abc.Instrument"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.abc.Instrument</span></code></a> interface. When an interesting event happens, it loops over these instruments and notifies them by calling an appropriate method. The tutorial has <a class="reference internal" href="https://trio.readthedocs.io/en/v0.22.2/tutorial.html#tutorial-instrument-example"><span class="std std-ref">a simple example of using this for tracing</span></a>.</p> <p>Since this hooks into Trio at a rather low level, you do have to be careful. The callbacks are run synchronously, and in many cases if they error out then there isn’t any plausible way to propagate this exception (for instance, we might be deep in the guts of the exception propagation machinery…). Therefore our <a class="reference external" href="https://github.com/python-trio/trio/issues/47">current strategy</a> for handling exceptions raised by instruments is to (a) log an exception to the <code class="docutils literal notranslate"><span class="pre">"trio.abc.Instrument"</span></code> logger, which by default prints a stack trace to standard error and (b) disable the offending instrument.</p> <p>You can register an initial list of instruments by passing them to <a class="reference internal" href="reference-core.html#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a>. <a class="reference internal" href="#trio.lowlevel.add_instrument" title="trio.lowlevel.add_instrument"><code class="xref py py-func docutils literal notranslate"><span class="pre">add_instrument()</span></code></a> and <a class="reference internal" href="#trio.lowlevel.remove_instrument" title="trio.lowlevel.remove_instrument"><code class="xref py py-func docutils literal notranslate"><span class="pre">remove_instrument()</span></code></a> let you add and remove instruments at runtime.</p> <dl class="py function"> <h3 class="sig sig-object py" id="trio.lowlevel.add_instrument"><code>trio.lowlevel.add_instrument(instrument: Instrument) → None</code></h3> <dd>
<p>Start instrumenting the current run loop with the given instrument.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><strong>instrument</strong> (<a class="reference internal" href="#trio.abc.Instrument" title="trio.abc.Instrument"><em>trio.abc.Instrument</em></a>) – The instrument to activate.</p> </dd> </dl> <p>If <code class="docutils literal notranslate"><span class="pre">instrument</span></code> is already active, does nothing.</p> </dd>
</dl> <dl class="py function"> <h3 class="sig sig-object py" id="trio.lowlevel.remove_instrument"><code>trio.lowlevel.remove_instrument(instrument: Instrument) → None</code></h3> <dd>
<p>Stop instrumenting the current run loop with the given instrument.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><strong>instrument</strong> (<a class="reference internal" href="#trio.abc.Instrument" title="trio.abc.Instrument"><em>trio.abc.Instrument</em></a>) – The instrument to de-activate.</p> </dd> <h4 class="field-even" style="margin: 0">Raises<span class="colon">:</span>
</h4> <dd class="field-even">
<p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyError" title="(in Python v3.11)"><strong>KeyError</strong></a> – if the instrument is not currently active. This could occur either because you never added it, or because you added it and then it raised an unhandled exception and was automatically deactivated.</p> </dd> </dl> </dd>
</dl> <p>And here’s the interface to implement if you want to build your own <a class="reference internal" href="#trio.abc.Instrument" title="trio.abc.Instrument"><code class="xref py py-class docutils literal notranslate"><span class="pre">Instrument</span></code></a>:</p> <dl class="py class"> <h3 class="sig sig-object py" id="trio.abc.Instrument"><code><em>class</em> trio.abc.Instrument</code></h3> <dd>
<p>The interface for run loop instrumentation.</p> <p>Instruments don’t have to inherit from this abstract base class, and all of these methods are optional. This class serves mostly as documentation.</p> <dl class="py method"> <h3 class="sig sig-object py" id="trio.abc.Instrument.after_io_wait"><code>after_io_wait(timeout)</code></h3> <dd>
<p>Called after handling pending I/O.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><strong>timeout</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – The number of seconds we were willing to wait. This much time may or may not have elapsed, depending on whether any I/O was ready.</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.abc.Instrument.after_run"><code>after_run()</code></h3> <dd>
<p>Called just before <a class="reference internal" href="reference-core.html#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a> returns.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.abc.Instrument.after_task_step"><code>after_task_step(task)</code></h3> <dd>
<p>Called when we return to the main run loop after a task has yielded.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><strong>task</strong> (<a class="reference internal" href="#trio.lowlevel.Task" title="trio.lowlevel.Task"><em>trio.lowlevel.Task</em></a>) – The task that just ran.</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.abc.Instrument.before_io_wait"><code>before_io_wait(timeout)</code></h3> <dd>
<p>Called before blocking to wait for I/O readiness.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><strong>timeout</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – The number of seconds we are willing to wait.</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.abc.Instrument.before_run"><code>before_run()</code></h3> <dd>
<p>Called at the beginning of <a class="reference internal" href="reference-core.html#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a>.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.abc.Instrument.before_task_step"><code>before_task_step(task)</code></h3> <dd>
<p>Called immediately before we resume running the given task.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><strong>task</strong> (<a class="reference internal" href="#trio.lowlevel.Task" title="trio.lowlevel.Task"><em>trio.lowlevel.Task</em></a>) – The task that is about to run.</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.abc.Instrument.task_exited"><code>task_exited(task)</code></h3> <dd>
<p>Called when the given task exits.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><strong>task</strong> (<a class="reference internal" href="#trio.lowlevel.Task" title="trio.lowlevel.Task"><em>trio.lowlevel.Task</em></a>) – The finished task.</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.abc.Instrument.task_scheduled"><code>task_scheduled(task)</code></h3> <dd>
<p>Called when the given task becomes runnable.</p> <p>It may still be some time before it actually runs, if there are other runnable tasks ahead of it.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><strong>task</strong> (<a class="reference internal" href="#trio.lowlevel.Task" title="trio.lowlevel.Task"><em>trio.lowlevel.Task</em></a>) – The task that became runnable.</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.abc.Instrument.task_spawned"><code>task_spawned(task)</code></h3> <dd>
<p>Called when the given task is created.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><strong>task</strong> (<a class="reference internal" href="#trio.lowlevel.Task" title="trio.lowlevel.Task"><em>trio.lowlevel.Task</em></a>) – The new task.</p> </dd> </dl> </dd>
</dl> </dd>
</dl> <p>The tutorial has a <a class="reference internal" href="https://trio.readthedocs.io/en/v0.22.2/tutorial.html#tutorial-instrument-example"><span class="std std-ref">fully-worked example</span></a> of defining a custom instrument to log Trio’s internal scheduling decisions.</p> </section> </section> <section id="low-level-process-spawning"> <h2>Low-level process spawning</h2> <dl class="py function"> <h3 class="sig sig-object py" id="trio.lowlevel.open_process"><code><em>await</em> trio.lowlevel.open_process(command, *, stdin=None, stdout=None, stderr=None, **options) → Process</code></h3> <dd>
<p>Execute a child program in a new process.</p> <p>After construction, you can interact with the child process by writing data to its <a class="reference internal" href="reference-io.html#trio.Process.stdin" title="trio.Process.stdin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stdin</span></code></a> stream (a <a class="reference internal" href="reference-io.html#trio.abc.SendStream" title="trio.abc.SendStream"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SendStream</span></code></a>), reading data from its <a class="reference internal" href="reference-io.html#trio.Process.stdout" title="trio.Process.stdout"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stdout</span></code></a> and/or <a class="reference internal" href="reference-io.html#trio.Process.stderr" title="trio.Process.stderr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stderr</span></code></a> streams (both <a class="reference internal" href="reference-io.html#trio.abc.ReceiveStream" title="trio.abc.ReceiveStream"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReceiveStream</span></code></a>s), sending it signals using <a class="reference internal" href="reference-io.html#trio.Process.terminate" title="trio.Process.terminate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">terminate</span></code></a>, <a class="reference internal" href="reference-io.html#trio.Process.kill" title="trio.Process.kill"><code class="xref py py-obj docutils literal notranslate"><span class="pre">kill</span></code></a>, or <a class="reference internal" href="reference-io.html#trio.Process.send_signal" title="trio.Process.send_signal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">send_signal</span></code></a>, and waiting for it to exit using <a class="reference internal" href="reference-io.html#trio.Process.wait" title="trio.Process.wait"><code class="xref py py-obj docutils literal notranslate"><span class="pre">wait</span></code></a>. See <a class="reference internal" href="reference-io.html#trio.Process" title="trio.Process"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.Process</span></code></a> for details.</p> <p>Each standard stream is only available if you specify that a pipe should be created for it. For example, if you pass <code class="docutils literal notranslate"><span class="pre">stdin=subprocess.PIPE</span></code>, you can write to the <a class="reference internal" href="reference-io.html#trio.Process.stdin" title="trio.Process.stdin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stdin</span></code></a> stream, else <a class="reference internal" href="reference-io.html#trio.Process.stdin" title="trio.Process.stdin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stdin</span></code></a> will be <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p> <p>Unlike <a class="reference internal" href="reference-io.html#trio.run_process" title="trio.run_process"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.run_process</span></code></a>, this function doesn’t do any kind of automatic management of the child process. It’s up to you to implement whatever semantics you want.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<ul class="simple"> <li><p><strong>command</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.11)"><em>list</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)"><em>str</em></a>) – The command to run. Typically this is a sequence of strings such as <code class="docutils literal notranslate"><span class="pre">['ls',</span> <span class="pre">'-l',</span> <span class="pre">'directory</span> <span class="pre">with</span> <span class="pre">spaces']</span></code>, where the first element names the executable to invoke and the other elements specify its arguments. With <code class="docutils literal notranslate"><span class="pre">shell=True</span></code> in the <code class="docutils literal notranslate"><span class="pre">**options</span></code>, or on Windows, <code class="docutils literal notranslate"><span class="pre">command</span></code> may alternatively be a string, which will be parsed following platform-dependent <a class="reference internal" href="reference-io.html#subprocess-quoting"><span class="std std-ref">quoting rules</span></a>.</p></li> <li><p><strong>stdin</strong> – Specifies what the child process’s standard input stream should connect to: output written by the parent (<code class="docutils literal notranslate"><span class="pre">subprocess.PIPE</span></code>), nothing (<code class="docutils literal notranslate"><span class="pre">subprocess.DEVNULL</span></code>), or an open file (pass a file descriptor or something whose <code class="docutils literal notranslate"><span class="pre">fileno</span></code> method returns one). If <code class="docutils literal notranslate"><span class="pre">stdin</span></code> is unspecified, the child process will have the same standard input stream as its parent.</p></li> <li><p><strong>stdout</strong> – Like <code class="docutils literal notranslate"><span class="pre">stdin</span></code>, but for the child process’s standard output stream.</p></li> <li><p><strong>stderr</strong> – Like <code class="docutils literal notranslate"><span class="pre">stdin</span></code>, but for the child process’s standard error stream. An additional value <code class="docutils literal notranslate"><span class="pre">subprocess.STDOUT</span></code> is supported, which causes the child’s standard output and standard error messages to be intermixed on a single standard output stream, attached to whatever the <code class="docutils literal notranslate"><span class="pre">stdout</span></code> option says to attach it to.</p></li> <li><p><strong>**options</strong> – Other <a class="reference internal" href="reference-io.html#subprocess-options"><span class="std std-ref">general subprocess options</span></a> are also accepted.</p></li> </ul> </dd> <h4 class="field-even" style="margin: 0">Returns<span class="colon">:</span>
</h4> <dd class="field-even">
<p>A new <a class="reference internal" href="reference-io.html#trio.Process" title="trio.Process"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.Process</span></code></a> object.</p> </dd> <h4 class="field-odd" style="margin: 0">Raises<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#OSError" title="(in Python v3.11)"><strong>OSError</strong></a> – if the process spawning fails, for example because the specified command could not be found.</p> </dd> </dl> </dd>
</dl> </section> <section id="low-level-i-o-primitives"> <h2>Low-level I/O primitives</h2> <p>Different environments expose different low-level APIs for performing async I/O. <a class="reference internal" href="#module-trio.lowlevel" title="trio.lowlevel"><code class="xref py py-mod docutils literal notranslate"><span class="pre">trio.lowlevel</span></code></a> exposes these APIs in a relatively direct way, so as to allow maximum power and flexibility for higher level code. However, this means that the exact API provided may vary depending on what system Trio is running on.</p> <section id="universally-available-api"> <h3>Universally available API</h3> <p>All environments provide the following functions:</p> <dl class="py function"> <h3 class="sig sig-object py" id="trio.lowlevel.wait_readable"><code><em>await</em> trio.lowlevel.wait_readable(obj)</code></h3> <dd>
<p>Block until the kernel reports that the given object is readable.</p> <p>On Unix systems, <code class="docutils literal notranslate"><span class="pre">obj</span></code> must either be an integer file descriptor, or else an object with a <code class="docutils literal notranslate"><span class="pre">.fileno()</span></code> method which returns an integer file descriptor. Any kind of file descriptor can be passed, though the exact semantics will depend on your kernel. For example, this probably won’t do anything useful for on-disk files.</p> <p>On Windows systems, <code class="docutils literal notranslate"><span class="pre">obj</span></code> must either be an integer <code class="docutils literal notranslate"><span class="pre">SOCKET</span></code> handle, or else an object with a <code class="docutils literal notranslate"><span class="pre">.fileno()</span></code> method which returns an integer <code class="docutils literal notranslate"><span class="pre">SOCKET</span></code> handle. File descriptors aren’t supported, and neither are handles that refer to anything besides a <code class="docutils literal notranslate"><span class="pre">SOCKET</span></code>.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Raises<span class="colon">:</span>
</h4> <dd class="field-odd">
<ul class="simple"> <li><p><a class="reference internal" href="reference-core.html#trio.BusyResourceError" title="trio.BusyResourceError"><strong>trio.BusyResourceError</strong></a> – if another task is already waiting for the given socket to become readable.</p></li> <li><p><a class="reference internal" href="reference-core.html#trio.ClosedResourceError" title="trio.ClosedResourceError"><strong>trio.ClosedResourceError</strong></a> – if another task calls <a class="reference internal" href="#trio.lowlevel.notify_closing" title="trio.lowlevel.notify_closing"><code class="xref py py-func docutils literal notranslate"><span class="pre">notify_closing()</span></code></a> while this function is still working.</p></li> </ul> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 class="sig sig-object py" id="trio.lowlevel.wait_writable"><code><em>await</em> trio.lowlevel.wait_writable(obj)</code></h3> <dd>
<p>Block until the kernel reports that the given object is writable.</p> <p>See <a class="reference internal" href="#trio.lowlevel.wait_readable" title="trio.lowlevel.wait_readable"><code class="xref py py-obj docutils literal notranslate"><span class="pre">wait_readable</span></code></a> for the definition of <code class="docutils literal notranslate"><span class="pre">obj</span></code>.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Raises<span class="colon">:</span>
</h4> <dd class="field-odd">
<ul class="simple"> <li><p><a class="reference internal" href="reference-core.html#trio.BusyResourceError" title="trio.BusyResourceError"><strong>trio.BusyResourceError</strong></a> – if another task is already waiting for the given socket to become writable.</p></li> <li><p><a class="reference internal" href="reference-core.html#trio.ClosedResourceError" title="trio.ClosedResourceError"><strong>trio.ClosedResourceError</strong></a> – if another task calls <a class="reference internal" href="#trio.lowlevel.notify_closing" title="trio.lowlevel.notify_closing"><code class="xref py py-func docutils literal notranslate"><span class="pre">notify_closing()</span></code></a> while this function is still working.</p></li> </ul> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 class="sig sig-object py" id="trio.lowlevel.notify_closing"><code>trio.lowlevel.notify_closing(obj)</code></h3> <dd>
<p>Call this before closing a file descriptor (on Unix) or socket (on Windows). This will cause any <a class="reference internal" href="#trio.lowlevel.wait_readable" title="trio.lowlevel.wait_readable"><code class="xref py py-obj docutils literal notranslate"><span class="pre">wait_readable</span></code></a> or <a class="reference internal" href="#trio.lowlevel.wait_writable" title="trio.lowlevel.wait_writable"><code class="xref py py-obj docutils literal notranslate"><span class="pre">wait_writable</span></code></a> calls on the given object to immediately wake up and raise <a class="reference internal" href="reference-core.html#trio.ClosedResourceError" title="trio.ClosedResourceError"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ClosedResourceError</span></code></a>.</p> <p>This doesn’t actually close the object – you still have to do that yourself afterwards. Also, you want to be careful to make sure no new tasks start waiting on the object in between when you call this and when it’s actually closed. So to close something properly, you usually want to do these steps in order:</p> <ol class="arabic simple"> <li><p>Explicitly mark the object as closed, so that any new attempts to use it will abort before they start.</p></li> <li><p>Call <a class="reference internal" href="#trio.lowlevel.notify_closing" title="trio.lowlevel.notify_closing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">notify_closing</span></code></a> to wake up any already-existing users.</p></li> <li><p>Actually close the object.</p></li> </ol> <p>It’s also possible to do them in a different order if that’s more convenient, <em>but only if</em> you make sure not to have any checkpoints in between the steps. This way they all happen in a single atomic step, so other tasks won’t be able to tell what order they happened in anyway.</p> </dd>
</dl> </section> <section id="unix-specific-api"> <h3>Unix-specific API</h3> <p><a class="reference internal" href="#trio.lowlevel.FdStream" title="trio.lowlevel.FdStream"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FdStream</span></code></a> supports wrapping Unix files (such as a pipe or TTY) as a stream.</p> <p>If you have two different file descriptors for sending and receiving, and want to bundle them together into a single bidirectional <a class="reference internal" href="reference-io.html#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Stream</span></code></a>, then use <a class="reference internal" href="reference-io.html#trio.StapledStream" title="trio.StapledStream"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.StapledStream</span></code></a>:</p> <pre data-language="python">bidirectional_stream = trio.StapledStream(
    trio.lowlevel.FdStream(write_fd),
    trio.lowlevel.FdStream(read_fd)
)</pre> <dl class="py class"> <h3 class="sig sig-object py" id="trio.lowlevel.FdStream"><code><em>class</em> trio.lowlevel.FdStream(fd: int)</code></h3> <dd>
<p>Bases: <a class="reference internal" href="reference-io.html#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a></p> <p>Represents a stream given the file descriptor to a pipe, TTY, etc.</p> <p><em>fd</em> must refer to a file that is open for reading and/or writing and supports non-blocking I/O (pipes and TTYs will work, on-disk files probably not). The returned stream takes ownership of the fd, so closing the stream will close the fd too. As with <a class="reference external" href="https://docs.python.org/3/library/os.html#os.fdopen" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">os.fdopen</span></code></a>, you should not directly use an fd after you have wrapped it in a stream using this function.</p> <p>To be used as a Trio stream, an open file must be placed in non-blocking mode. Unfortunately, this impacts all I/O that goes through the underlying open file, including I/O that uses a different file descriptor than the one that was passed to Trio. If other threads or processes are using file descriptors that are related through <a class="reference external" href="https://docs.python.org/3/library/os.html#os.dup" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">os.dup</span></code></a> or inheritance across <a class="reference external" href="https://docs.python.org/3/library/os.html#os.fork" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">os.fork</span></code></a> to the one that Trio is using, they are unlikely to be prepared to have non-blocking I/O semantics suddenly thrust upon them. For example, you can use <code class="docutils literal notranslate"><span class="pre">FdStream(os.dup(sys.stdin.fileno()))</span></code> to obtain a stream for reading from standard input, but it is only safe to do so with heavy caveats: your stdin must not be shared by any other processes, and you must not make any calls to synchronous methods of <a class="reference external" href="https://docs.python.org/3/library/sys.html#sys.stdin" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sys.stdin</span></code></a> until the stream returned by <a class="reference internal" href="#trio.lowlevel.FdStream" title="trio.lowlevel.FdStream"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FdStream</span></code></a> is closed. See <a class="reference external" href="https://github.com/python-trio/trio/issues/174">issue #174</a> for a discussion of the challenges involved in relaxing this restriction.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><strong>fd</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a>) – The fd to be wrapped.</p> </dd> <h4 class="field-even" style="margin: 0">Returns<span class="colon">:</span>
</h4> <dd class="field-even">
<p>A new <a class="reference internal" href="#trio.lowlevel.FdStream" title="trio.lowlevel.FdStream"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FdStream</span></code></a> object.</p> </dd> </dl> </dd>
</dl> </section> <section id="kqueue-specific-api"> <h3>Kqueue-specific API</h3> <p>TODO: these are implemented, but are currently more of a sketch than anything real. See <a class="reference external" href="https://github.com/python-trio/trio/issues/26">#26</a>.</p> <dl class="py function"> <h3 class="sig sig-object py" id="trio.lowlevel.current_kqueue"><code>trio.lowlevel.current_kqueue()</code></h3> 
</dl> <dl class="py function"> <h3 class="sig sig-object py" id="trio.lowlevel.wait_kevent"><code><em>await</em> trio.lowlevel.wait_kevent(ident, filter, abort_func)</code></h3> 
</dl> <dl class="py function"> <h3 class="sig sig-object py" id="trio.lowlevel.monitor_kevent"><code><em>with</em> trio.lowlevel.monitor_kevent(ident, filter) as queue</code></h3> 
</dl> </section> <section id="windows-specific-api"> <h3>Windows-specific API</h3> <dl class="py function"> <h3 class="sig sig-object py" id="trio.lowlevel.WaitForSingleObject"><code><em>await</em> trio.lowlevel.WaitForSingleObject(handle)</code></h3> <dd>
<p>Async and cancellable variant of <a class="reference external" href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms687032(v=vs.85).aspx">WaitForSingleObject</a>. Windows only.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><strong>handle</strong> – A Win32 object handle, as a Python integer.</p> </dd> <h4 class="field-even" style="margin: 0">Raises<span class="colon">:</span>
</h4> <dd class="field-even">
<p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#OSError" title="(in Python v3.11)"><strong>OSError</strong></a> – If the handle is invalid, e.g. when it is already closed.</p> </dd> </dl> </dd>
</dl> <p>TODO: these are implemented, but are currently more of a sketch than anything real. See <a class="reference external" href="https://github.com/python-trio/trio/issues/26">#26</a> and <a class="reference external" href="https://github.com/python-trio/trio/issues/52">#52</a>.</p> <dl class="py function"> <h3 class="sig sig-object py" id="trio.lowlevel.register_with_iocp"><code>trio.lowlevel.register_with_iocp(handle)</code></h3> 
</dl> <dl class="py function"> <h3 class="sig sig-object py" id="trio.lowlevel.wait_overlapped"><code><em>await</em> trio.lowlevel.wait_overlapped(handle, lpOverlapped)</code></h3> 
</dl> <dl class="py function"> <h3 class="sig sig-object py" id="trio.lowlevel.current_iocp"><code>trio.lowlevel.current_iocp()</code></h3> 
</dl> <dl class="py function"> <h3 class="sig sig-object py" id="trio.lowlevel.monitor_completion_key"><code><em>with</em> trio.lowlevel.monitor_completion_key() as queue</code></h3> 
</dl> </section> </section> <section id="global-state-system-tasks-and-run-local-variables"> <h2>Global state: system tasks and run-local variables</h2> <dl class="py class"> <h3 class="sig sig-object py" id="trio.lowlevel.RunVar"><code><em>class</em> trio.lowlevel.RunVar(name, default=<object object>)</object></code></h3> <dd>
<p>The run-local variant of a context variable.</p> <p><a class="reference internal" href="#trio.lowlevel.RunVar" title="trio.lowlevel.RunVar"><code class="xref py py-class docutils literal notranslate"><span class="pre">RunVar</span></code></a> objects are similar to context variable objects, except that they are shared across a single call to <a class="reference internal" href="reference-core.html#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a> rather than a single task.</p> </dd>
</dl> <dl class="py function"> <h3 class="sig sig-object py" id="trio.lowlevel.spawn_system_task"><code>trio.lowlevel.spawn_system_task(async_fn, *args, name=None, context=None)</code></h3> <dd>
<p>Spawn a “system” task.</p> <p>System tasks have a few differences from regular tasks:</p> <ul class="simple"> <li><p>They don’t need an explicit nursery; instead they go into the internal “system nursery”.</p></li> <li><p>If a system task raises an exception, then it’s converted into a <a class="reference internal" href="reference-core.html#trio.TrioInternalError" title="trio.TrioInternalError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TrioInternalError</span></code></a> and <em>all</em> tasks are cancelled. If you write a system task, you should be careful to make sure it doesn’t crash.</p></li> <li><p>System tasks are automatically cancelled when the main task exits.</p></li> <li><p>By default, system tasks have <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt" title="(in Python v3.11)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> protection <em>enabled</em>. If you want your task to be interruptible by control-C, then you need to use <a class="reference internal" href="#trio.lowlevel.disable_ki_protection" title="trio.lowlevel.disable_ki_protection"><code class="xref py py-func docutils literal notranslate"><span class="pre">disable_ki_protection()</span></code></a> explicitly (and come up with some plan for what to do with a <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt" title="(in Python v3.11)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a>, given that system tasks aren’t allowed to raise exceptions).</p></li> <li><p>System tasks do not inherit context variables from their creator.</p></li> </ul> <p>Towards the end of a call to <a class="reference internal" href="reference-core.html#trio.run" title="trio.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">trio.run()</span></code></a>, after the main task and all system tasks have exited, the system nursery becomes closed. At this point, new calls to <a class="reference internal" href="#trio.lowlevel.spawn_system_task" title="trio.lowlevel.spawn_system_task"><code class="xref py py-func docutils literal notranslate"><span class="pre">spawn_system_task()</span></code></a> will raise <code class="docutils literal notranslate"><span class="pre">RuntimeError("Nursery</span>
<span class="pre">is</span> <span class="pre">closed</span> <span class="pre">to</span> <span class="pre">new</span> <span class="pre">arrivals")</span></code> instead of creating a system task. It’s possible to encounter this state either in a <code class="docutils literal notranslate"><span class="pre">finally</span></code> block in an async generator, or in a callback passed to <a class="reference internal" href="#trio.lowlevel.TrioToken.run_sync_soon" title="trio.lowlevel.TrioToken.run_sync_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TrioToken.run_sync_soon()</span></code></a> at the right moment.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<ul class="simple"> <li><p><strong>async_fn</strong> – An async callable.</p></li> <li><p><strong>args</strong> – Positional arguments for <code class="docutils literal notranslate"><span class="pre">async_fn</span></code>. If you want to pass keyword arguments, use <a class="reference external" href="https://docs.python.org/3/library/functools.html#functools.partial" title="(in Python v3.11)"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.partial()</span></code></a>.</p></li> <li><p><strong>name</strong> – The name for this task. Only used for debugging/introspection (e.g. <code class="docutils literal notranslate"><span class="pre">repr(task_obj)</span></code>). If this isn’t a string, <a class="reference internal" href="#trio.lowlevel.spawn_system_task" title="trio.lowlevel.spawn_system_task"><code class="xref py py-func docutils literal notranslate"><span class="pre">spawn_system_task()</span></code></a> will try to make it one. A common use case is if you’re wrapping a function before spawning a new task, you might pass the original function as the <code class="docutils literal notranslate"><span class="pre">name=</span></code> to make debugging easier.</p></li> <li><p><strong>context</strong> – An optional <code class="docutils literal notranslate"><span class="pre">contextvars.Context</span></code> object with context variables to use for this task. You would normally get a copy of the current context with <code class="docutils literal notranslate"><span class="pre">context</span> <span class="pre">=</span> <span class="pre">contextvars.copy_context()</span></code> and then you would pass that <code class="docutils literal notranslate"><span class="pre">context</span></code> object here.</p></li> </ul> </dd> <h4 class="field-even" style="margin: 0">Returns<span class="colon">:</span>
</h4> <dd class="field-even">
<p>the newly spawned task</p> </dd> <h4 class="field-odd" style="margin: 0">Return type<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><a class="reference internal" href="#trio.lowlevel.Task" title="trio.lowlevel.Task">Task</a></p> </dd> </dl> </dd>
</dl> </section> <section id="trio-tokens"> <h2>Trio tokens</h2> <dl class="py class"> <h3 class="sig sig-object py" id="trio.lowlevel.TrioToken"><code><em>class</em> trio.lowlevel.TrioToken</code></h3> <dd>
<p>An opaque object representing a single call to <a class="reference internal" href="reference-core.html#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a>.</p> <p>It has no public constructor; instead, see <a class="reference internal" href="#trio.lowlevel.current_trio_token" title="trio.lowlevel.current_trio_token"><code class="xref py py-func docutils literal notranslate"><span class="pre">current_trio_token()</span></code></a>.</p> <p>This object has two uses:</p> <ol class="arabic simple"> <li><p>It lets you re-enter the Trio run loop from external threads or signal handlers. This is the low-level primitive that <a class="reference internal" href="reference-core.html#module-trio.to_thread" title="trio.to_thread"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.to_thread()</span></code></a> and <a class="reference internal" href="reference-core.html#module-trio.from_thread" title="trio.from_thread"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.from_thread</span></code></a> use to communicate with worker threads, that <a class="reference internal" href="reference-io.html#trio.open_signal_receiver" title="trio.open_signal_receiver"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.open_signal_receiver</span></code></a> uses to receive notifications about signals, and so forth.</p></li> <li><p>Each call to <a class="reference internal" href="reference-core.html#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a> has exactly one associated <a class="reference internal" href="#trio.lowlevel.TrioToken" title="trio.lowlevel.TrioToken"><code class="xref py py-class docutils literal notranslate"><span class="pre">TrioToken</span></code></a> object, so you can use it to identify a particular call.</p></li> </ol> <dl class="py method"> <h3 class="sig sig-object py" id="trio.lowlevel.TrioToken.run_sync_soon"><code>run_sync_soon(sync_fn, *args, idempotent=False)</code></h3> <dd>
<p>Schedule a call to <code class="docutils literal notranslate"><span class="pre">sync_fn(*args)</span></code> to occur in the context of a Trio task.</p> <p>This is safe to call from the main thread, from other threads, and from signal handlers. This is the fundamental primitive used to re-enter the Trio run loop from outside of it.</p> <p>The call will happen “soon”, but there’s no guarantee about exactly when, and no mechanism provided for finding out when it’s happened. If you need this, you’ll have to build your own.</p> <p>The call is effectively run as part of a system task (see <a class="reference internal" href="#trio.lowlevel.spawn_system_task" title="trio.lowlevel.spawn_system_task"><code class="xref py py-func docutils literal notranslate"><span class="pre">spawn_system_task()</span></code></a>). In particular this means that:</p> <ul class="simple"> <li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt" title="(in Python v3.11)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> protection is <em>enabled</em> by default; if you want <code class="docutils literal notranslate"><span class="pre">sync_fn</span></code> to be interruptible by control-C, then you need to use <a class="reference internal" href="#trio.lowlevel.disable_ki_protection" title="trio.lowlevel.disable_ki_protection"><code class="xref py py-func docutils literal notranslate"><span class="pre">disable_ki_protection()</span></code></a> explicitly.</p></li> <li><p>If <code class="docutils literal notranslate"><span class="pre">sync_fn</span></code> raises an exception, then it’s converted into a <a class="reference internal" href="reference-core.html#trio.TrioInternalError" title="trio.TrioInternalError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TrioInternalError</span></code></a> and <em>all</em> tasks are cancelled. You should be careful that <code class="docutils literal notranslate"><span class="pre">sync_fn</span></code> doesn’t crash.</p></li> </ul> <p>All calls with <code class="docutils literal notranslate"><span class="pre">idempotent=False</span></code> are processed in strict first-in first-out order.</p> <p>If <code class="docutils literal notranslate"><span class="pre">idempotent=True</span></code>, then <code class="docutils literal notranslate"><span class="pre">sync_fn</span></code> and <code class="docutils literal notranslate"><span class="pre">args</span></code> must be hashable, and Trio will make a best-effort attempt to discard any call submission which is equal to an already-pending call. Trio will process these in first-in first-out order.</p> <p>Any ordering guarantees apply separately to <code class="docutils literal notranslate"><span class="pre">idempotent=False</span></code> and <code class="docutils literal notranslate"><span class="pre">idempotent=True</span></code> calls; there’s no rule for how calls in the different categories are ordered with respect to each other.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Raises<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><a class="reference internal" href="reference-core.html#trio.RunFinishedError" title="trio.RunFinishedError"><strong>trio.RunFinishedError</strong></a> – if the associated call to <a class="reference internal" href="reference-core.html#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a> has already exited. (Any call that <em>doesn’t</em> raise this error is guaranteed to be fully processed before <a class="reference internal" href="reference-core.html#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a> exits.)</p> </dd> </dl> </dd>
</dl> </dd>
</dl> <dl class="py function"> <h3 class="sig sig-object py" id="trio.lowlevel.current_trio_token"><code>trio.lowlevel.current_trio_token()</code></h3> <dd>
<p>Retrieve the <a class="reference internal" href="#trio.lowlevel.TrioToken" title="trio.lowlevel.TrioToken"><code class="xref py py-class docutils literal notranslate"><span class="pre">TrioToken</span></code></a> for the current call to <a class="reference internal" href="reference-core.html#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a>.</p> </dd>
</dl> </section> <section id="spawning-threads"> <h2>Spawning threads</h2> <dl class="py function"> <h3 class="sig sig-object py" id="trio.lowlevel.start_thread_soon"><code>trio.lowlevel.start_thread_soon(fn, deliver, name: str | None = None)</code></h3> <dd>
<p>Runs <code class="docutils literal notranslate"><span class="pre">deliver(outcome.capture(fn))</span></code> in a worker thread.</p> <p>Generally <code class="docutils literal notranslate"><span class="pre">fn</span></code> does some blocking work, and <code class="docutils literal notranslate"><span class="pre">deliver</span></code> delivers the result back to whoever is interested.</p> <p>This is a low-level, no-frills interface, very similar to using <a class="reference external" href="https://docs.python.org/3/library/threading.html#threading.Thread" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">threading.Thread</span></code></a> to spawn a thread directly. The main difference is that this function tries to re-use threads when possible, so it can be a bit faster than <a class="reference external" href="https://docs.python.org/3/library/threading.html#threading.Thread" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">threading.Thread</span></code></a>.</p> <p>Worker threads have the <a class="reference external" href="https://docs.python.org/3/library/threading.html#threading.Thread.daemon" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">daemon</span></code></a> flag set, which means that if your main thread exits, worker threads will automatically be killed. If you want to make sure that your <code class="docutils literal notranslate"><span class="pre">fn</span></code> runs to completion, then you should make sure that the main thread remains alive until <code class="docutils literal notranslate"><span class="pre">deliver</span></code> is called.</p> <p>It is safe to call this function simultaneously from multiple threads.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<ul class="simple"> <li><p><strong>fn</strong> (<em>sync function</em>) – Performs arbitrary blocking work.</p></li> <li><p><strong>deliver</strong> (<em>sync function</em>) – Takes the <a class="reference external" href="https://outcome.readthedocs.io/en/latest/api.html#outcome.Outcome" title="(in outcome v1.2.0+dev)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">outcome.Outcome</span></code></a> of <code class="docutils literal notranslate"><span class="pre">fn</span></code>, and delivers it. <em>Must not block.</em></p></li> </ul> </dd> </dl> <p>Because worker threads are cached and reused for multiple calls, neither function should mutate thread-level state, like <a class="reference external" href="https://docs.python.org/3/library/threading.html#threading.local" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">threading.local</span></code></a> objects – or if they do, they should be careful to revert their changes before returning.</p> <blockquote class="admonition note"> <h4 class="admonition-title">Note</h4> <p>The split between <code class="docutils literal notranslate"><span class="pre">fn</span></code> and <code class="docutils literal notranslate"><span class="pre">deliver</span></code> serves two purposes. First, it’s convenient, since most callers need something like this anyway.</p> <p>Second, it avoids a small race condition that could cause too many threads to be spawned. Consider a program that wants to run several jobs sequentially on a thread, so the main thread submits a job, waits for it to finish, submits another job, etc. In theory, this program should only need one worker thread. But what could happen is:</p> <ol class="arabic simple"> <li><p>Worker thread: First job finishes, and calls <code class="docutils literal notranslate"><span class="pre">deliver</span></code>.</p></li> <li><p>Main thread: receives notification that the job finished, and calls <code class="docutils literal notranslate"><span class="pre">start_thread_soon</span></code>.</p></li> <li><p>Main thread: sees that no worker threads are marked idle, so spawns a second worker thread.</p></li> <li><p>Original worker thread: marks itself as idle.</p></li> </ol> <p>To avoid this, threads mark themselves as idle <em>before</em> calling <code class="docutils literal notranslate"><span class="pre">deliver</span></code>.</p> <p>Is this potential extra thread a major problem? Maybe not, but it’s easy enough to avoid, and we figure that if the user is trying to limit how many threads they’re using then it’s polite to respect that.</p> </blockquote> </dd>
</dl> </section> <section id="safer-keyboardinterrupt-handling"> <h2>Safer KeyboardInterrupt handling</h2> <p>Trio’s handling of control-C is designed to balance usability and safety. On the one hand, there are sensitive regions (like the core scheduling loop) where it’s simply impossible to handle arbitrary <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt" title="(in Python v3.11)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> exceptions while maintaining our core correctness invariants. On the other, if the user accidentally writes an infinite loop, we do want to be able to break out of that. Our solution is to install a default signal handler which checks whether it’s safe to raise <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt" title="(in Python v3.11)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> at the place where the signal is received. If so, then we do; otherwise, we schedule a <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt" title="(in Python v3.11)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> to be delivered to the main task at the next available opportunity (similar to how <a class="reference internal" href="reference-core.html#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> is delivered).</p> <p>So that’s great, but – how do we know whether we’re in one of the sensitive parts of the program or not?</p> <p>This is determined on a function-by-function basis. By default:</p> <ul class="simple"> <li><p>The top-level function in regular user tasks is unprotected.</p></li> <li><p>The top-level function in system tasks is protected.</p></li> <li><p>If a function doesn’t specify otherwise, then it inherits the protection state of its caller.</p></li> </ul> <p>This means you only need to override the defaults at places where you transition from protected code to unprotected code or vice-versa.</p> <p>These transitions are accomplished using two function decorators:</p> <dl class="py function"> <h3 class="sig sig-object py" id="trio.lowlevel.disable_ki_protection"><code>@trio.lowlevel.disable_ki_protection</code></h3> <dd>
<p>Decorator that marks the given regular function, generator function, async function, or async generator function as unprotected against <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt" title="(in Python v3.11)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a>, i.e., the code inside this function <em>can</em> be rudely interrupted by <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt" title="(in Python v3.11)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> at any moment.</p> <p>If you have multiple decorators on the same function, then this should be at the bottom of the stack (closest to the actual function).</p> <p>An example of where you’d use this is in implementing something like <a class="reference internal" href="reference-core.html#trio.from_thread.run" title="trio.from_thread.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.from_thread.run()</span></code></a>, which uses <a class="reference internal" href="#trio.lowlevel.TrioToken.run_sync_soon" title="trio.lowlevel.TrioToken.run_sync_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">TrioToken.run_sync_soon()</span></code></a> to get into the Trio thread. <a class="reference internal" href="#trio.lowlevel.TrioToken.run_sync_soon" title="trio.lowlevel.TrioToken.run_sync_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run_sync_soon()</span></code></a> callbacks are run with <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt" title="(in Python v3.11)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> protection enabled, and <a class="reference internal" href="reference-core.html#trio.from_thread.run" title="trio.from_thread.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.from_thread.run()</span></code></a> takes advantage of this to safely set up the machinery for sending a response back to the original thread, but then uses <a class="reference internal" href="#trio.lowlevel.disable_ki_protection" title="trio.lowlevel.disable_ki_protection"><code class="xref py py-func docutils literal notranslate"><span class="pre">disable_ki_protection()</span></code></a> when entering the user-provided function.</p> </dd>
</dl> <dl class="py function"> <h3 class="sig sig-object py" id="trio.lowlevel.enable_ki_protection"><code>@trio.lowlevel.enable_ki_protection</code></h3> <dd>
<p>Decorator that marks the given regular function, generator function, async function, or async generator function as protected against <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt" title="(in Python v3.11)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a>, i.e., the code inside this function <em>won’t</em> be rudely interrupted by <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt" title="(in Python v3.11)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a>. (Though if it contains any <a class="reference internal" href="reference-core.html#checkpoints"><span class="std std-ref">checkpoints</span></a>, then it can still receive <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt" title="(in Python v3.11)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> at those. This is considered a polite interruption.)</p> <blockquote class="admonition warning"> <h4 class="admonition-title">Warning</h4> <p>Be very careful to only use this decorator on functions that you know will either exit in bounded time, or else pass through a checkpoint regularly. (Of course all of your functions should have this property, but if you mess it up here then you won’t even be able to use control-C to escape!)</p> </blockquote> <p>If you have multiple decorators on the same function, then this should be at the bottom of the stack (closest to the actual function).</p> <p>An example of where you’d use this is on the <code class="docutils literal notranslate"><span class="pre">__exit__</span></code> implementation for something like a <a class="reference internal" href="reference-core.html#trio.Lock" title="trio.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lock</span></code></a>, where a poorly-timed <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt" title="(in Python v3.11)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> could leave the lock in an inconsistent state and cause a deadlock.</p> </dd>
</dl> <dl class="py function"> <h3 class="sig sig-object py" id="trio.lowlevel.currently_ki_protected"><code>trio.lowlevel.currently_ki_protected()</code></h3> <dd>
<p>Check whether the calling code has <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt" title="(in Python v3.11)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> protection enabled.</p> <p>It’s surprisingly easy to think that one’s <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt" title="(in Python v3.11)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> protection is enabled when it isn’t, or vice-versa. This function tells you what Trio thinks of the matter, which makes it useful for <code class="docutils literal notranslate"><span class="pre">assert</span></code>s and unit tests.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Returns<span class="colon">:</span>
</h4> <dd class="field-odd">
<p>True if protection is enabled, and False otherwise.</p> </dd> <h4 class="field-even" style="margin: 0">Return type<span class="colon">:</span>
</h4> <dd class="field-even">
<p><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)">bool</a></p> </dd> </dl> </dd>
</dl> </section> <section id="sleeping-and-waking"> <h2>Sleeping and waking</h2> <section id="wait-queue-abstraction"> <h3>Wait queue abstraction</h3> <dl class="py class"> <h3 class="sig sig-object py" id="trio.lowlevel.ParkingLot"><code><em>class</em> trio.lowlevel.ParkingLot</code></h3> <dd>
<p>A fair wait queue with cancellation and requeueing.</p> <p>This class encapsulates the tricky parts of implementing a wait queue. It’s useful for implementing higher-level synchronization primitives like queues and locks.</p> <p>In addition to the methods below, you can use <code class="docutils literal notranslate"><span class="pre">len(parking_lot)</span></code> to get the number of parked tasks, and <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">parking_lot:</span> <span class="pre">...</span></code> to check whether there are any parked tasks.</p> <dl class="py method"> <h3 class="sig sig-object py" id="trio.lowlevel.ParkingLot.park"><code><em>await</em> park()</code></h3> <dd>
<p>Park the current task until woken by a call to <a class="reference internal" href="#trio.lowlevel.ParkingLot.unpark" title="trio.lowlevel.ParkingLot.unpark"><code class="xref py py-meth docutils literal notranslate"><span class="pre">unpark()</span></code></a> or <a class="reference internal" href="#trio.lowlevel.ParkingLot.unpark_all" title="trio.lowlevel.ParkingLot.unpark_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">unpark_all()</span></code></a>.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.lowlevel.ParkingLot.repark"><code>repark(new_lot, *, count=1)</code></h3> <dd>
<p>Move parked tasks from one <a class="reference internal" href="#trio.lowlevel.ParkingLot" title="trio.lowlevel.ParkingLot"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParkingLot</span></code></a> object to another.</p> <p>This dequeues <code class="docutils literal notranslate"><span class="pre">count</span></code> tasks from one lot, and requeues them on another, preserving order. For example:</p> <pre data-language="python">async def parker(lot):
    print("sleeping")
    await lot.park()
    print("woken")

async def main():
    lot1 = trio.lowlevel.ParkingLot()
    lot2 = trio.lowlevel.ParkingLot()
    async with trio.open_nursery() as nursery:
        nursery.start_soon(parker, lot1)
        await trio.testing.wait_all_tasks_blocked()
        assert len(lot1) == 1
        assert len(lot2) == 0
        lot1.repark(lot2)
        assert len(lot1) == 0
        assert len(lot2) == 1
        # This wakes up the task that was originally parked in lot1
        lot2.unpark()</pre> <p>If there are fewer than <code class="docutils literal notranslate"><span class="pre">count</span></code> tasks parked, then reparks as many tasks as are available and then returns successfully.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<ul class="simple"> <li><p><strong>new_lot</strong> (<a class="reference internal" href="#trio.lowlevel.ParkingLot" title="trio.lowlevel.ParkingLot"><em>ParkingLot</em></a>) – the parking lot to move tasks to.</p></li> <li><p><strong>count</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a>) – the number of tasks to move.</p></li> </ul> </dd> </dl> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.lowlevel.ParkingLot.repark_all"><code>repark_all(new_lot)</code></h3> <dd>
<p>Move all parked tasks from one <a class="reference internal" href="#trio.lowlevel.ParkingLot" title="trio.lowlevel.ParkingLot"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParkingLot</span></code></a> object to another.</p> <p>See <a class="reference internal" href="#trio.lowlevel.ParkingLot.repark" title="trio.lowlevel.ParkingLot.repark"><code class="xref py py-meth docutils literal notranslate"><span class="pre">repark()</span></code></a> for details.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.lowlevel.ParkingLot.statistics"><code>statistics()</code></h3> <dd>
<p>Return an object containing debugging information.</p> <p>Currently the following fields are defined:</p> <ul class="simple"> <li><p><code class="docutils literal notranslate"><span class="pre">tasks_waiting</span></code>: The number of tasks blocked on this lot’s <a class="reference internal" href="#trio.lowlevel.ParkingLot.park" title="trio.lowlevel.ParkingLot.park"><code class="xref py py-meth docutils literal notranslate"><span class="pre">park()</span></code></a> method.</p></li> </ul> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.lowlevel.ParkingLot.unpark"><code>unpark(*, count=1)</code></h3> <dd>
<p>Unpark one or more tasks.</p> <p>This wakes up <code class="docutils literal notranslate"><span class="pre">count</span></code> tasks that are blocked in <a class="reference internal" href="#trio.lowlevel.ParkingLot.park" title="trio.lowlevel.ParkingLot.park"><code class="xref py py-meth docutils literal notranslate"><span class="pre">park()</span></code></a>. If there are fewer than <code class="docutils literal notranslate"><span class="pre">count</span></code> tasks parked, then wakes as many tasks are available and then returns successfully.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><strong>count</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a>) – the number of tasks to unpark.</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.lowlevel.ParkingLot.unpark_all"><code>unpark_all()</code></h3> <dd>
<p>Unpark all parked tasks.</p> </dd>
</dl> </dd>
</dl> </section> <section id="low-level-checkpoint-functions"> <h3>Low-level checkpoint functions</h3> <dl class="py function"> <h3 class="sig sig-object py" id="trio.lowlevel.checkpoint"><code><em>await</em> trio.lowlevel.checkpoint()</code></h3> <dd>
<p>A pure <a class="reference internal" href="reference-core.html#checkpoints"><span class="std std-ref">checkpoint</span></a>.</p> <p>This checks for cancellation and allows other tasks to be scheduled, without otherwise blocking.</p> <p>Note that the scheduler has the option of ignoring this and continuing to run the current task if it decides this is appropriate (e.g. for increased efficiency).</p> <p>Equivalent to <code class="docutils literal notranslate"><span class="pre">await</span> <span class="pre">trio.sleep(0)</span></code> (which is implemented by calling <a class="reference internal" href="#trio.lowlevel.checkpoint" title="trio.lowlevel.checkpoint"><code class="xref py py-func docutils literal notranslate"><span class="pre">checkpoint()</span></code></a>.)</p> </dd>
</dl> <p>The next two functions are used <em>together</em> to make up a checkpoint:</p> <dl class="py function"> <h3 class="sig sig-object py" id="trio.lowlevel.checkpoint_if_cancelled"><code><em>await</em> trio.lowlevel.checkpoint_if_cancelled()</code></h3> <dd>
<p>Issue a <a class="reference internal" href="reference-core.html#checkpoints"><span class="std std-ref">checkpoint</span></a> if the calling context has been cancelled.</p> <p>Equivalent to (but potentially more efficient than):</p> <pre data-language="python">if trio.current_effective_deadline() == -inf:
    await trio.lowlevel.checkpoint()</pre> <p>This is either a no-op, or else it allow other tasks to be scheduled and then raises <a class="reference internal" href="reference-core.html#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">trio.Cancelled</span></code></a>.</p> <p>Typically used together with <a class="reference internal" href="#trio.lowlevel.cancel_shielded_checkpoint" title="trio.lowlevel.cancel_shielded_checkpoint"><code class="xref py py-func docutils literal notranslate"><span class="pre">cancel_shielded_checkpoint()</span></code></a>.</p> </dd>
</dl> <dl class="py function"> <h3 class="sig sig-object py" id="trio.lowlevel.cancel_shielded_checkpoint"><code><em>await</em> trio.lowlevel.cancel_shielded_checkpoint()</code></h3> <dd>
<p>Introduce a schedule point, but not a cancel point.</p> <p>This is <em>not</em> a <a class="reference internal" href="reference-core.html#checkpoints"><span class="std std-ref">checkpoint</span></a>, but it is half of a checkpoint, and when combined with <a class="reference internal" href="#trio.lowlevel.checkpoint_if_cancelled" title="trio.lowlevel.checkpoint_if_cancelled"><code class="xref py py-func docutils literal notranslate"><span class="pre">checkpoint_if_cancelled()</span></code></a> it can make a full checkpoint.</p> <p>Equivalent to (but potentially more efficient than):</p> <pre data-language="python">with trio.CancelScope(shield=True):
    await trio.lowlevel.checkpoint()</pre> </dd>
</dl> <p>These are commonly used in cases where you have an operation that might-or-might-not block, and you want to implement Trio’s standard checkpoint semantics. Example:</p> <pre data-language="python">async def operation_that_maybe_blocks():
    await checkpoint_if_cancelled()
    try:
        ret = attempt_operation()
    except BlockingIOError:
        # need to block and then retry, which we do below
        pass
    else:
        # operation succeeded, finish the checkpoint then return
        await cancel_shielded_checkpoint()
        return ret
    while True:
        await wait_for_operation_to_be_ready()
        try:
            return attempt_operation()
        except BlockingIOError:
            pass</pre> <p>This logic is a bit convoluted, but accomplishes all of the following:</p> <ul class="simple"> <li><p>Every successful execution path passes through a checkpoint (assuming that <code class="docutils literal notranslate"><span class="pre">wait_for_operation_to_be_ready</span></code> is an unconditional checkpoint)</p></li> <li><p>Our <a class="reference internal" href="reference-core.html#cancellable-primitives"><span class="std std-ref">cancellation semantics</span></a> say that <a class="reference internal" href="reference-core.html#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> should only be raised if the operation didn’t happen. Using <a class="reference internal" href="#trio.lowlevel.cancel_shielded_checkpoint" title="trio.lowlevel.cancel_shielded_checkpoint"><code class="xref py py-func docutils literal notranslate"><span class="pre">cancel_shielded_checkpoint()</span></code></a> on the early-exit branch accomplishes this.</p></li> <li><p>On the path where we do end up blocking, we don’t pass through any schedule points before that, which avoids some unnecessary work.</p></li> <li><p>Avoids implicitly chaining the <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#BlockingIOError" title="(in Python v3.11)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BlockingIOError</span></code></a> with any errors raised by <code class="docutils literal notranslate"><span class="pre">attempt_operation</span></code> or <code class="docutils literal notranslate"><span class="pre">wait_for_operation_to_be_ready</span></code>, by keeping the <code class="docutils literal notranslate"><span class="pre">while</span> <span class="pre">True:</span></code> loop outside of the <code class="docutils literal notranslate"><span class="pre">except</span> <span class="pre">BlockingIOError:</span></code> block.</p></li> </ul> <p>These functions can also be useful in other situations. For example, when <a class="reference internal" href="reference-core.html#trio.to_thread.run_sync" title="trio.to_thread.run_sync"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.to_thread.run_sync()</span></code></a> schedules some work to run in a worker thread, it blocks until the work is finished (so it’s a schedule point), but by default it doesn’t allow cancellation. So to make sure that the call always acts as a checkpoint, it calls <a class="reference internal" href="#trio.lowlevel.checkpoint_if_cancelled" title="trio.lowlevel.checkpoint_if_cancelled"><code class="xref py py-func docutils literal notranslate"><span class="pre">checkpoint_if_cancelled()</span></code></a> before starting the thread.</p> </section> <section id="low-level-blocking"> <h3>Low-level blocking</h3> <dl class="py function"> <h3 class="sig sig-object py" id="trio.lowlevel.wait_task_rescheduled"><code><em>await</em> trio.lowlevel.wait_task_rescheduled(abort_func: Callable[[Callable[[], NoReturn]], Abort]) → Any</code></h3> <dd>
<p>Put the current task to sleep, with cancellation support.</p> <p>This is the lowest-level API for blocking in Trio. Every time a <a class="reference internal" href="#trio.lowlevel.Task" title="trio.lowlevel.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> blocks, it does so by calling this function (usually indirectly via some higher-level API).</p> <p>This is a tricky interface with no guard rails. If you can use <a class="reference internal" href="#trio.lowlevel.ParkingLot" title="trio.lowlevel.ParkingLot"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParkingLot</span></code></a> or the built-in I/O wait functions instead, then you should.</p> <p>Generally the way it works is that before calling this function, you make arrangements for “someone” to call <a class="reference internal" href="#trio.lowlevel.reschedule" title="trio.lowlevel.reschedule"><code class="xref py py-func docutils literal notranslate"><span class="pre">reschedule()</span></code></a> on the current task at some later point.</p> <p>Then you call <a class="reference internal" href="#trio.lowlevel.wait_task_rescheduled" title="trio.lowlevel.wait_task_rescheduled"><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_task_rescheduled()</span></code></a>, passing in <code class="docutils literal notranslate"><span class="pre">abort_func</span></code>, an “abort callback”.</p> <p>(Terminology: in Trio, “aborting” is the process of attempting to interrupt a blocked task to deliver a cancellation.)</p> <p>There are two possibilities for what happens next:</p> <ol class="arabic"> <li><p>“Someone” calls <a class="reference internal" href="#trio.lowlevel.reschedule" title="trio.lowlevel.reschedule"><code class="xref py py-func docutils literal notranslate"><span class="pre">reschedule()</span></code></a> on the current task, and <a class="reference internal" href="#trio.lowlevel.wait_task_rescheduled" title="trio.lowlevel.wait_task_rescheduled"><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_task_rescheduled()</span></code></a> returns or raises whatever value or error was passed to <a class="reference internal" href="#trio.lowlevel.reschedule" title="trio.lowlevel.reschedule"><code class="xref py py-func docutils literal notranslate"><span class="pre">reschedule()</span></code></a>.</p></li> <li>
<p>The call’s context transitions to a cancelled state (e.g. due to a timeout expiring). When this happens, the <code class="docutils literal notranslate"><span class="pre">abort_func</span></code> is called. Its interface looks like:</p> <pre data-language="python">def abort_func(raise_cancel):
    ...
    return trio.lowlevel.Abort.SUCCEEDED  # or FAILED</pre> <p>It should attempt to clean up any state associated with this call, and in particular, arrange that <a class="reference internal" href="#trio.lowlevel.reschedule" title="trio.lowlevel.reschedule"><code class="xref py py-func docutils literal notranslate"><span class="pre">reschedule()</span></code></a> will <em>not</em> be called later. If (and only if!) it is successful, then it should return <a class="reference internal" href="#trio.lowlevel.Abort.SUCCEEDED" title="trio.lowlevel.Abort.SUCCEEDED"><code class="xref py py-data docutils literal notranslate"><span class="pre">Abort.SUCCEEDED</span></code></a>, in which case the task will automatically be rescheduled with an appropriate <a class="reference internal" href="reference-core.html#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> error.</p> <p>Otherwise, it should return <a class="reference internal" href="#trio.lowlevel.Abort.FAILED" title="trio.lowlevel.Abort.FAILED"><code class="xref py py-data docutils literal notranslate"><span class="pre">Abort.FAILED</span></code></a>. This means that the task can’t be cancelled at this time, and still has to make sure that “someone” eventually calls <a class="reference internal" href="#trio.lowlevel.reschedule" title="trio.lowlevel.reschedule"><code class="xref py py-func docutils literal notranslate"><span class="pre">reschedule()</span></code></a>.</p> <p>At that point there are again two possibilities. You can simply ignore the cancellation altogether: wait for the operation to complete and then reschedule and continue as normal. (For example, this is what <a class="reference internal" href="reference-core.html#trio.to_thread.run_sync" title="trio.to_thread.run_sync"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.to_thread.run_sync()</span></code></a> does if cancellation is disabled.) The other possibility is that the <code class="docutils literal notranslate"><span class="pre">abort_func</span></code> does succeed in cancelling the operation, but for some reason isn’t able to report that right away. (Example: on Windows, it’s possible to request that an async (“overlapped”) I/O operation be cancelled, but this request is <em>also</em> asynchronous – you don’t find out until later whether the operation was actually cancelled or not.) To report a delayed cancellation, then you should reschedule the task yourself, and call the <code class="docutils literal notranslate"><span class="pre">raise_cancel</span></code> callback passed to <code class="docutils literal notranslate"><span class="pre">abort_func</span></code> to raise a <a class="reference internal" href="reference-core.html#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> (or possibly <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt" title="(in Python v3.11)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a>) exception into this task. Either of the approaches sketched below can work:</p> <pre data-language="python"># Option 1:
# Catch the exception from raise_cancel and inject it into the task.
# (This is what Trio does automatically for you if you return
# Abort.SUCCEEDED.)
trio.lowlevel.reschedule(task, outcome.capture(raise_cancel))

# Option 2:
# wait to be woken by "someone", and then decide whether to raise
# the error from inside the task.
outer_raise_cancel = None
def abort(inner_raise_cancel):
    nonlocal outer_raise_cancel
    outer_raise_cancel = inner_raise_cancel
    TRY_TO_CANCEL_OPERATION()
    return trio.lowlevel.Abort.FAILED
await wait_task_rescheduled(abort)
if OPERATION_WAS_SUCCESSFULLY_CANCELLED:
    # raises the error
    outer_raise_cancel()</pre> <p>In any case it’s guaranteed that we only call the <code class="docutils literal notranslate"><span class="pre">abort_func</span></code> at most once per call to <a class="reference internal" href="#trio.lowlevel.wait_task_rescheduled" title="trio.lowlevel.wait_task_rescheduled"><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_task_rescheduled()</span></code></a>.</p> </li> </ol> <p>Sometimes, it’s useful to be able to share some mutable sleep-related data between the sleeping task, the abort function, and the waking task. You can use the sleeping task’s <a class="reference internal" href="#trio.lowlevel.Task.custom_sleep_data" title="trio.lowlevel.Task.custom_sleep_data"><code class="xref py py-data docutils literal notranslate"><span class="pre">custom_sleep_data</span></code></a> attribute to store this data, and Trio won’t touch it, except to make sure that it gets cleared when the task is rescheduled.</p> <blockquote class="admonition warning"> <h4 class="admonition-title">Warning</h4> <p>If your <code class="docutils literal notranslate"><span class="pre">abort_func</span></code> raises an error, or returns any value other than <a class="reference internal" href="#trio.lowlevel.Abort.SUCCEEDED" title="trio.lowlevel.Abort.SUCCEEDED"><code class="xref py py-data docutils literal notranslate"><span class="pre">Abort.SUCCEEDED</span></code></a> or <a class="reference internal" href="#trio.lowlevel.Abort.FAILED" title="trio.lowlevel.Abort.FAILED"><code class="xref py py-data docutils literal notranslate"><span class="pre">Abort.FAILED</span></code></a>, then Trio will crash violently. Be careful! Similarly, it is entirely possible to deadlock a Trio program by failing to reschedule a blocked task, or cause havoc by calling <a class="reference internal" href="#trio.lowlevel.reschedule" title="trio.lowlevel.reschedule"><code class="xref py py-func docutils literal notranslate"><span class="pre">reschedule()</span></code></a> too many times. Remember what we said up above about how you should use a higher-level API if at all possible?</p> </blockquote> </dd>
</dl> <dl class="py class"> <h3 class="sig sig-object py" id="trio.lowlevel.Abort"><code><em>class</em> trio.lowlevel.Abort(value, names=None, *, module=None, qualname=None, type=None, start=1, boundary=None)</code></h3> <dd>
<p><a class="reference external" href="https://docs.python.org/3/library/enum.html#enum.Enum" title="(in Python v3.11)"><code class="xref py py-class docutils literal notranslate"><span class="pre">enum.Enum</span></code></a> used as the return value from abort functions.</p> <p>See <a class="reference internal" href="#trio.lowlevel.wait_task_rescheduled" title="trio.lowlevel.wait_task_rescheduled"><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_task_rescheduled()</span></code></a> for details.</p> <dl class="py data"> <h3 class="sig sig-object py" id="trio.lowlevel.Abort.SUCCEEDED"><code>SUCCEEDED</code></h3> <h3 class="sig sig-object py" id="trio.lowlevel.Abort.FAILED"><code>FAILED</code></h3> 
</dl> </dd>
</dl> <dl class="py function"> <h3 class="sig sig-object py" id="trio.lowlevel.reschedule"><code>trio.lowlevel.reschedule(task, next_send=<object object>)</object></code></h3> <dd>
<p>Reschedule the given task with the given <a class="reference external" href="https://outcome.readthedocs.io/en/latest/api.html#outcome.Outcome" title="(in outcome v1.2.0+dev)"><code class="xref py py-class docutils literal notranslate"><span class="pre">outcome.Outcome</span></code></a>.</p> <p>See <a class="reference internal" href="#trio.lowlevel.wait_task_rescheduled" title="trio.lowlevel.wait_task_rescheduled"><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_task_rescheduled()</span></code></a> for the gory details.</p> <p>There must be exactly one call to <a class="reference internal" href="#trio.lowlevel.reschedule" title="trio.lowlevel.reschedule"><code class="xref py py-func docutils literal notranslate"><span class="pre">reschedule()</span></code></a> for every call to <a class="reference internal" href="#trio.lowlevel.wait_task_rescheduled" title="trio.lowlevel.wait_task_rescheduled"><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_task_rescheduled()</span></code></a>. (And when counting, keep in mind that returning <a class="reference internal" href="#trio.lowlevel.Abort.SUCCEEDED" title="trio.lowlevel.Abort.SUCCEEDED"><code class="xref py py-data docutils literal notranslate"><span class="pre">Abort.SUCCEEDED</span></code></a> from an abort callback is equivalent to calling <a class="reference internal" href="#trio.lowlevel.reschedule" title="trio.lowlevel.reschedule"><code class="xref py py-func docutils literal notranslate"><span class="pre">reschedule()</span></code></a> once.)</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<ul class="simple"> <li><p><strong>task</strong> (<a class="reference internal" href="#trio.lowlevel.Task" title="trio.lowlevel.Task"><em>trio.lowlevel.Task</em></a>) – the task to be rescheduled. Must be blocked in a call to <a class="reference internal" href="#trio.lowlevel.wait_task_rescheduled" title="trio.lowlevel.wait_task_rescheduled"><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_task_rescheduled()</span></code></a>.</p></li> <li><p><strong>next_send</strong> (<a class="reference external" href="https://outcome.readthedocs.io/en/latest/api.html#outcome.Outcome" title="(in outcome v1.2.0+dev)"><em>outcome.Outcome</em></a>) – the value (or error) to return (or raise) from <a class="reference internal" href="#trio.lowlevel.wait_task_rescheduled" title="trio.lowlevel.wait_task_rescheduled"><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_task_rescheduled()</span></code></a>.</p></li> </ul> </dd> </dl> </dd>
</dl> <p>Here’s an example lock class implemented using <a class="reference internal" href="#trio.lowlevel.wait_task_rescheduled" title="trio.lowlevel.wait_task_rescheduled"><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_task_rescheduled()</span></code></a> directly. This implementation has a number of flaws, including lack of fairness, O(n) cancellation, missing error checking, failure to insert a checkpoint on the non-blocking path, etc. If you really want to implement your own lock, then you should study the implementation of <a class="reference internal" href="reference-core.html#trio.Lock" title="trio.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.Lock</span></code></a> and use <a class="reference internal" href="#trio.lowlevel.ParkingLot" title="trio.lowlevel.ParkingLot"><code class="xref py py-class docutils literal notranslate"><span class="pre">ParkingLot</span></code></a>, which handles some of these issues for you. But this does serve to illustrate the basic structure of the <a class="reference internal" href="#trio.lowlevel.wait_task_rescheduled" title="trio.lowlevel.wait_task_rescheduled"><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_task_rescheduled()</span></code></a> API:</p> <pre data-language="python">class NotVeryGoodLock:
    def __init__(self):
        self._blocked_tasks = collections.deque()
        self._held = False

    async def acquire(self):
        # We might have to try several times to acquire the lock.
        while self._held:
            # Someone else has the lock, so we have to wait.
            task = trio.lowlevel.current_task()
            self._blocked_tasks.append(task)
            def abort_fn(_):
                self._blocked_tasks.remove(task)
                return trio.lowlevel.Abort.SUCCEEDED
            await trio.lowlevel.wait_task_rescheduled(abort_fn)
            # At this point the lock was released -- but someone else
            # might have swooped in and taken it again before we
            # woke up. So we loop around to check the 'while' condition
            # again.
        # if we reach this point, it means that the 'while' condition
        # has just failed, so we know no-one is holding the lock, and
        # we can take it.
        self._held = True

    def release(self):
        self._held = False
        if self._blocked_tasks:
            woken_task = self._blocked_tasks.popleft()
            trio.lowlevel.reschedule(woken_task)</pre> </section> </section> <section id="task-api"> <h2>Task API</h2> <dl class="py function"> <h3 class="sig sig-object py" id="trio.lowlevel.current_root_task"><code>trio.lowlevel.current_root_task()</code></h3> <dd>
<p>Returns the current root <a class="reference internal" href="#trio.lowlevel.Task" title="trio.lowlevel.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a>.</p> <p>This is the task that is the ultimate parent of all other tasks.</p> </dd>
</dl> <dl class="py function"> <h3 class="sig sig-object py" id="trio.lowlevel.current_task"><code>trio.lowlevel.current_task()</code></h3> <dd>
<p>Return the <a class="reference internal" href="#trio.lowlevel.Task" title="trio.lowlevel.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> object representing the current task.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Returns<span class="colon">:</span>
</h4> <dd class="field-odd">
<p>the <a class="reference internal" href="#trio.lowlevel.Task" title="trio.lowlevel.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> that called <a class="reference internal" href="#trio.lowlevel.current_task" title="trio.lowlevel.current_task"><code class="xref py py-func docutils literal notranslate"><span class="pre">current_task()</span></code></a>.</p> </dd> <h4 class="field-even" style="margin: 0">Return type<span class="colon">:</span>
</h4> <dd class="field-even">
<p><a class="reference internal" href="#trio.lowlevel.Task" title="trio.lowlevel.Task">Task</a></p> </dd> </dl> </dd>
</dl> <dl class="py class"> <h3 class="sig sig-object py" id="trio.lowlevel.Task"><code><em>class</em> trio.lowlevel.Task</code></h3> <dd>
<p>A <a class="reference internal" href="#trio.lowlevel.Task" title="trio.lowlevel.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> object represents a concurrent “thread” of execution. It has no public constructor; Trio internally creates a <a class="reference internal" href="#trio.lowlevel.Task" title="trio.lowlevel.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> object for each call to <code class="docutils literal notranslate"><span class="pre">nursery.start(...)</span></code> or <code class="docutils literal notranslate"><span class="pre">nursery.start_soon(...)</span></code>.</p> <p>Its public members are mostly useful for introspection and debugging:</p> <dl class="py attribute"> <h3 class="sig sig-object py" id="trio.lowlevel.Task.name"><code>name</code></h3> <dd>
<p>String containing this <a class="reference internal" href="#trio.lowlevel.Task" title="trio.lowlevel.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a>'s name. Usually the name of the function this <a class="reference internal" href="#trio.lowlevel.Task" title="trio.lowlevel.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> is running, but can be overridden by passing <code class="docutils literal notranslate"><span class="pre">name=</span></code> to <code class="docutils literal notranslate"><span class="pre">start</span></code> or <code class="docutils literal notranslate"><span class="pre">start_soon</span></code>.</p> </dd>
</dl> <dl class="py attribute"> <h3 class="sig sig-object py" id="trio.lowlevel.Task.coro"><code>coro</code></h3> <dd>
<p>This task’s coroutine object.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.lowlevel.Task.iter_await_frames"><code><em>for ... in</em> iter_await_frames()</code></h3> <dd>
<p>Iterates recursively over the coroutine-like objects this task is waiting on, yielding the frame and line number at each frame.</p> <p>This is similar to <a class="reference external" href="https://docs.python.org/3/library/traceback.html#traceback.walk_stack" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">traceback.walk_stack</span></code></a> in a synchronous context. Note that <a class="reference external" href="https://docs.python.org/3/library/traceback.html#traceback.walk_stack" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">traceback.walk_stack</span></code></a> returns frames from the bottom of the call stack to the top, while this function starts from <a class="reference internal" href="#trio.lowlevel.Task.coro" title="trio.lowlevel.Task.coro"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Task.coro</span></code></a> and works it way down.</p> <p>Example usage: extracting a stack trace:</p> <pre data-language="python">import traceback

def print_stack_for_task(task):
    ss = traceback.StackSummary.extract(task.iter_await_frames())
    print("".join(ss.format()))</pre> </dd>
</dl> <dl class="py attribute"> <h3 class="sig sig-object py" id="trio.lowlevel.Task.context"><code>context</code></h3> <dd>
<p>This task’s <a class="reference external" href="https://docs.python.org/3/library/contextvars.html#contextvars.Context" title="(in Python v3.11)"><code class="xref py py-class docutils literal notranslate"><span class="pre">contextvars.Context</span></code></a> object.</p> </dd>
</dl> <dl class="py attribute"> <h3 class="sig sig-object py" id="trio.lowlevel.Task.parent_nursery"><code>parent_nursery</code></h3> <dd>
<p>The nursery this task is inside (or None if this is the “init” task).</p> <p>Example use case: drawing a visualization of the task tree in a debugger.</p> </dd>
</dl> <dl class="py attribute"> <h3 class="sig sig-object py" id="trio.lowlevel.Task.eventual_parent_nursery"><code>eventual_parent_nursery</code></h3> <dd>
<p>The nursery this task will be inside after it calls <code class="docutils literal notranslate"><span class="pre">task_status.started()</span></code>.</p> <p>If this task has already called <code class="docutils literal notranslate"><span class="pre">started()</span></code>, or if it was not spawned using <a class="reference internal" href="reference-core.html#trio.Nursery.start" title="trio.Nursery.start"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nursery.start()</span></code></a>, then its <a class="reference internal" href="#trio.lowlevel.Task.eventual_parent_nursery" title="trio.lowlevel.Task.eventual_parent_nursery"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eventual_parent_nursery</span></code></a> is <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p> </dd>
</dl> <dl class="py attribute"> <h3 class="sig sig-object py" id="trio.lowlevel.Task.child_nurseries"><code>child_nurseries</code></h3> <dd>
<p>The nurseries this task contains.</p> <p>This is a list, with outer nurseries before inner nurseries.</p> </dd>
</dl> <dl class="py attribute"> <h3 class="sig sig-object py" id="trio.lowlevel.Task.custom_sleep_data"><code>custom_sleep_data</code></h3> <dd>
<p>Trio doesn’t assign this variable any meaning, except that it sets it to <code class="docutils literal notranslate"><span class="pre">None</span></code> whenever a task is rescheduled. It can be used to share data between the different tasks involved in putting a task to sleep and then waking it up again. (See <a class="reference internal" href="#trio.lowlevel.wait_task_rescheduled" title="trio.lowlevel.wait_task_rescheduled"><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_task_rescheduled()</span></code></a> for details.)</p> </dd>
</dl> </dd>
</dl> </section> <section id="using-guest-mode-to-run-trio-on-top-of-other-event-loops"> <h2>Using “guest mode” to run Trio on top of other event loops</h2> <section id="what-is-guest-mode"> <h3>What is “guest mode”?</h3> <p>An event loop acts as a central coordinator to manage all the IO happening in your program. Normally, that means that your application has to pick one event loop, and use it for everything. But what if you like Trio, but also need to use a framework like <a class="reference external" href="https://en.wikipedia.org/wiki/Qt_(software)">Qt</a> or <a class="reference external" href="https://www.pygame.org/">PyGame</a> that has its own event loop? Then you need some way to run both event loops at once.</p> <p>It is possible to combine event loops, but the standard approaches all have significant downsides:</p> <ul class="simple"> <li><p><strong>Polling:</strong> this is where you use a <a class="reference external" href="https://en.wikipedia.org/wiki/Busy_waiting">busy-loop</a> to manually check for IO on both event loops many times per second. This adds latency, and wastes CPU time and electricity.</p></li> <li><p><strong>Pluggable IO backends:</strong> this is where you reimplement one of the event loop APIs on top of the other, so you effectively end up with just one event loop. This requires a significant amount of work for each pair of event loops you want to integrate, and different backends inevitably end up with inconsistent behavior, forcing users to program against the least-common-denominator. And if the two event loops expose different feature sets, it may not even be possible to implement one in terms of the other.</p></li> <li><p><strong>Running the two event loops in separate threads:</strong> This works, but most event loop APIs aren’t thread-safe, so in this approach you need to keep careful track of which code runs on which event loop, and remember to use explicit inter-thread messaging whenever you interact with the other loop – or else risk obscure race conditions and data corruption.</p></li> </ul> <p>That’s why Trio offers a fourth option: <strong>guest mode</strong>. Guest mode lets you execute <a class="reference internal" href="reference-core.html#trio.run" title="trio.run"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.run</span></code></a> on top of some other “host” event loop, like Qt. Its advantages are:</p> <ul> <li><p>Efficiency: guest mode is event-driven instead of using a busy-loop, so it has low latency and doesn’t waste electricity.</p></li> <li>
<p>No need to think about threads: your Trio code runs in the same thread as the host event loop, so you can freely call sync Trio APIs from the host, and call sync host APIs from Trio. For example, if you’re making a GUI app with Qt as the host loop, then making a <a class="reference external" href="https://doc.qt.io/qt-5/qpushbutton.html">cancel button</a> and connecting it to a <a class="reference internal" href="reference-core.html#trio.CancelScope" title="trio.CancelScope"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.CancelScope</span></code></a> is as easy as writing:</p> <pre data-language="python"># Trio code can create Qt objects without any special ceremony...
my_cancel_button = QPushButton("Cancel")
# ...and Qt can call back to Trio just as easily
my_cancel_button.clicked.connect(my_cancel_scope.cancel)</pre> <p>(For async APIs, it’s not that simple, but you can use sync APIs to build explicit bridges between the two worlds, e.g. by passing async functions and their results back and forth through queues.)</p> </li> <li><p>Consistent behavior: guest mode uses the same code as regular Trio: the same scheduler, same IO code, same everything. So you get the full feature set and everything acts the way you expect.</p></li> <li><p>Simple integration and broad compatibility: pretty much every event loop offers some threadsafe “schedule a callback” operation, and that’s all you need to use it as a host loop.</p></li> </ul> </section> <section id="really-how-is-that-possible"> <h3>Really? How is that possible?</h3> <blockquote class="admonition note"> <h4 class="admonition-title">Note</h4> <p>You can use guest mode without reading this section. It’s included for those who enjoy understanding how things work.</p> </blockquote> <p>All event loops have the same basic structure. They loop through two operations, over and over:</p> <ol class="arabic simple"> <li><p>Wait for the operating system to notify them that something interesting has happened, like data arriving on a socket or a timeout passing. They do this by invoking a platform-specific <code class="docutils literal notranslate"><span class="pre">sleep_until_something_happens()</span></code> system call – <code class="docutils literal notranslate"><span class="pre">select</span></code>, <code class="docutils literal notranslate"><span class="pre">epoll</span></code>, <code class="docutils literal notranslate"><span class="pre">kqueue</span></code>, <code class="docutils literal notranslate"><span class="pre">GetQueuedCompletionEvents</span></code>, etc.</p></li> <li><p>Run all the user tasks that care about whatever happened, then go back to step 1.</p></li> </ol> <p>The problem here is step 1. Two different event loops on the same thread can take turns running user tasks in step 2, but when they’re idle and nothing is happening, they can’t both invoke their own <code class="docutils literal notranslate"><span class="pre">sleep_until_something_happens()</span></code> function at the same time.</p> <p>The “polling” and “pluggable backend” strategies solve this by hacking the loops so both step 1s can run at the same time in the same thread. Keeping everything in one thread is great for step 2, but the step 1 hacks create problems.</p> <p>The “separate threads” strategy solves this by moving both steps into separate threads. This makes step 1 work, but the downside is that now the user tasks in step 2 are running separate threads as well, so users are forced to deal with inter-thread coordination.</p> <p>The idea behind guest mode is to combine the best parts of each approach: we move Trio’s step 1 into a separate worker thread, while keeping Trio’s step 2 in the main host thread. This way, when the application is idle, both event loops do their <code class="docutils literal notranslate"><span class="pre">sleep_until_something_happens()</span></code> at the same time in their own threads. But when the app wakes up and your code is actually running, it all happens in a single thread. The threading trickiness is all handled transparently inside Trio.</p> <p>Concretely, we unroll Trio’s internal event loop into a chain of callbacks, and as each callback finishes, it schedules the next callback onto the host loop or a worker thread as appropriate. So the only thing the host loop has to provide is a way to schedule a callback onto the main thread from a worker thread.</p> <p>Coordinating between Trio and the host loop does add some overhead. The main cost is switching in and out of the background thread, since this requires cross-thread messaging. This is cheap (on the order of a few microseconds, assuming your host loop is implemented efficiently), but it’s not free.</p> <p>But, there’s a nice optimization we can make: we only <em>need</em> the thread when our <code class="docutils literal notranslate"><span class="pre">sleep_until_something_happens()</span></code> call actually sleeps, that is, when the Trio part of your program is idle and has nothing to do. So before we switch into the worker thread, we double-check whether we’re idle, and if not, then we skip the worker thread and jump directly to step 2. This means that your app only pays the extra thread-switching penalty at moments when it would otherwise be sleeping, so it should have minimal effect on your app’s overall performance.</p> <p>The total overhead will depend on your host loop, your platform, your application, etc. But we expect that in most cases, apps running in guest mode should only be 5-10% slower than the same code using <a class="reference internal" href="reference-core.html#trio.run" title="trio.run"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.run</span></code></a>. If you find that’s not true for your app, then please let us know and we’ll see if we can fix it!</p> </section> <section id="implementing-guest-mode-for-your-favorite-event-loop"> <h3>Implementing guest mode for your favorite event loop</h3> <p>Let’s walk through what you need to do to integrate Trio’s guest mode with your favorite event loop. Treat this section like a checklist.</p> <p><strong>Getting started:</strong> The first step is to get something basic working. Here’s a minimal example of running Trio on top of asyncio, that you can use as a model:</p> <pre data-language="python">import asyncio, trio

# A tiny Trio program
async def trio_main():
    for _ in range(5):
        print("Hello from Trio!")
        # This is inside Trio, so we have to use Trio APIs
        await trio.sleep(1)
    return "trio done!"

# The code to run it as a guest inside asyncio
async def asyncio_main():
    asyncio_loop = asyncio.get_running_loop()

    def run_sync_soon_threadsafe(fn):
        asyncio_loop.call_soon_threadsafe(fn)

    def done_callback(trio_main_outcome):
        print(f"Trio program ended with: {trio_main_outcome}")

    # This is where the magic happens:
    trio.lowlevel.start_guest_run(
        trio_main,
        run_sync_soon_threadsafe=run_sync_soon_threadsafe,
        done_callback=done_callback,
    )

    # Let the host loop run for a while to give trio_main time to
    # finish. (WARNING: This is a hack. See below for better
    # approaches.)
    #
    # This function is in asyncio, so we have to use asyncio APIs.
    await asyncio.sleep(10)

asyncio.run(asyncio_main())</pre> <p>You can see we’re using asyncio-specific APIs to start up a loop, and then we call <a class="reference internal" href="#trio.lowlevel.start_guest_run" title="trio.lowlevel.start_guest_run"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.lowlevel.start_guest_run</span></code></a>. This function is very similar to <a class="reference internal" href="reference-core.html#trio.run" title="trio.run"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.run</span></code></a>, and takes all the same arguments. But it has two differences:</p> <p>First, instead of blocking until <code class="docutils literal notranslate"><span class="pre">trio_main</span></code> has finished, it schedules <code class="docutils literal notranslate"><span class="pre">trio_main</span></code> to start running on top of the host loop, and then returns immediately. So <code class="docutils literal notranslate"><span class="pre">trio_main</span></code> is running in the background – that’s why we have to sleep and give it time to finish.</p> <p>And second, it requires two extra keyword arguments: <code class="docutils literal notranslate"><span class="pre">run_sync_soon_threadsafe</span></code>, and <code class="docutils literal notranslate"><span class="pre">done_callback</span></code>.</p> <p>For <code class="docutils literal notranslate"><span class="pre">run_sync_soon_threadsafe</span></code>, we need a function that takes a synchronous callback, and schedules it to run on your host loop. And this function needs to be “threadsafe” in the sense that you can safely call it from any thread. So you need to figure out how to write a function that does that using your host loop’s API. For asyncio, this is easy because <a class="reference external" href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.call_soon_threadsafe" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">call_soon_threadsafe</span></code></a> does exactly what we need; for your loop, it might be more or less complicated.</p> <p>For <code class="docutils literal notranslate"><span class="pre">done_callback</span></code>, you pass in a function that Trio will automatically invoke when the Trio run finishes, so you know it’s done and what happened. For this basic starting version, we just print the result; in the next section we’ll discuss better alternatives.</p> <p>At this stage you should be able to run a simple Trio program inside your host loop. Now we’ll turn that prototype into something solid.</p> <p><strong>Loop lifetimes:</strong> One of the trickiest things in most event loops is shutting down correctly. And having two event loops makes this even harder!</p> <p>If you can, we recommend following this pattern:</p> <ul class="simple"> <li><p>Start up your host loop</p></li> <li><p>Immediately call <a class="reference internal" href="#trio.lowlevel.start_guest_run" title="trio.lowlevel.start_guest_run"><code class="xref py py-obj docutils literal notranslate"><span class="pre">start_guest_run</span></code></a> to start Trio</p></li> <li><p>When Trio finishes and your <code class="docutils literal notranslate"><span class="pre">done_callback</span></code> is invoked, shut down the host loop</p></li> <li><p>Make sure that nothing else shuts down your host loop</p></li> </ul> <p>This way, your two event loops have the same lifetime, and your program automatically exits when your Trio function finishes.</p> <p>Here’s how we’d extend our asyncio example to implement this pattern:</p> <pre data-language="python"># Improved version, that shuts down properly after Trio finishes
async def asyncio_main():
    asyncio_loop = asyncio.get_running_loop()

    def run_sync_soon_threadsafe(fn):
        asyncio_loop.call_soon_threadsafe(fn)

    # Revised 'done' callback: set a Future
    done_fut = asyncio_loop.create_future()
    def done_callback(trio_main_outcome):
        done_fut.set_result(trio_main_outcome)

    trio.lowlevel.start_guest_run(
        trio_main,
        run_sync_soon_threadsafe=run_sync_soon_threadsafe,
        done_callback=done_callback,
    )

    # Wait for the guest run to finish
    trio_main_outcome = await done_fut
    # Pass through the return value or exception from the guest run
    return trio_main_outcome.unwrap()</pre> <p>And then you can encapsulate all this machinery in a utility function that exposes a <a class="reference internal" href="reference-core.html#trio.run" title="trio.run"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.run</span></code></a>-like API, but runs both loops together:</p> <pre data-language="python">def trio_run_with_asyncio(trio_main, *args, **trio_run_kwargs):
    async def asyncio_main():
        # same as above
        ...

    return asyncio.run(asyncio_main())</pre> <p>Technically, it is possible to use other patterns. But there are some important limitations you have to respect:</p> <ul> <li>
<p><strong>You must let the Trio program run to completion.</strong> Many event loops let you stop the event loop at any point, and any pending callbacks/tasks/etc. just… don’t run. Trio follows a more structured system, where you can cancel things, but the code always runs to completion, so <code class="docutils literal notranslate"><span class="pre">finally</span></code> blocks run, resources are cleaned up, etc. If you stop your host loop early, before the <code class="docutils literal notranslate"><span class="pre">done_callback</span></code> is invoked, then that cuts off the Trio run in the middle without a chance to clean up. This can leave your code in an inconsistent state, and will definitely leave Trio’s internals in an inconsistent state, which will cause errors if you try to use Trio again in that thread.</p> <p>Some programs need to be able to quit at any time, for example in response to a GUI window being closed or a user selecting a “Quit” from a menu. In these cases, we recommend wrapping your whole program in a <a class="reference internal" href="reference-core.html#trio.CancelScope" title="trio.CancelScope"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.CancelScope</span></code></a>, and cancelling it when you want to quit.</p> </li> <li><p>Each host loop can only have one <a class="reference internal" href="#trio.lowlevel.start_guest_run" title="trio.lowlevel.start_guest_run"><code class="xref py py-obj docutils literal notranslate"><span class="pre">start_guest_run</span></code></a> at a time. If you try to start a second one, you’ll get an error. If you need to run multiple Trio functions at the same time, then start up a single Trio run, open a nursery, and then start your functions as child tasks in that nursery.</p></li> <li><p>Unless you or your host loop register a handler for <a class="reference external" href="https://docs.python.org/3/library/signal.html#signal.SIGINT" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">signal.SIGINT</span></code></a> before starting Trio (this is not common), then Trio will take over delivery of <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a>s. And since Trio can’t tell which host code is safe to interrupt, it will only deliver <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> into the Trio part of your code. This is fine if your program is set up to exit when the Trio part exits, because the <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> will propagate out of Trio and then trigger the shutdown of your host loop, which is just what you want.</p></li> </ul> <p>Given these constraints, we think the simplest approach is to always start and stop the two loops together.</p> <p><strong>Signal management:</strong> <a class="reference external" href="https://en.wikipedia.org/wiki/Signal_(IPC)">“Signals”</a> are a low-level inter-process communication primitive. When you hit control-C to kill a program, that uses a signal. Signal handling in Python has <a class="reference external" href="https://vorpus.org/blog/control-c-handling-in-python-and-trio/">a lot of moving parts</a>. One of those parts is <a class="reference external" href="https://docs.python.org/3/library/signal.html#signal.set_wakeup_fd" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">signal.set_wakeup_fd</span></code></a>, which event loops use to make sure that they wake up when a signal arrives so they can respond to it. (If you’ve ever had an event loop ignore you when you hit control-C, it was probably because they weren’t using <a class="reference external" href="https://docs.python.org/3/library/signal.html#signal.set_wakeup_fd" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">signal.set_wakeup_fd</span></code></a> correctly.)</p> <p>But, only one event loop can use <a class="reference external" href="https://docs.python.org/3/library/signal.html#signal.set_wakeup_fd" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">signal.set_wakeup_fd</span></code></a> at a time. And in guest mode that can cause problems: Trio and the host loop might start fighting over who’s using <a class="reference external" href="https://docs.python.org/3/library/signal.html#signal.set_wakeup_fd" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">signal.set_wakeup_fd</span></code></a>.</p> <p>Some event loops, like asyncio, won’t work correctly unless they win this fight. Fortunately, Trio is a little less picky: as long as <em>someone</em> makes sure that the program wakes up when a signal arrives, it should work correctly. So if your host loop wants <a class="reference external" href="https://docs.python.org/3/library/signal.html#signal.set_wakeup_fd" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">signal.set_wakeup_fd</span></code></a>, then you should disable Trio’s <a class="reference external" href="https://docs.python.org/3/library/signal.html#signal.set_wakeup_fd" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">signal.set_wakeup_fd</span></code></a> support, and then both loops will work correctly.</p> <p>On the other hand, if your host loop doesn’t use <a class="reference external" href="https://docs.python.org/3/library/signal.html#signal.set_wakeup_fd" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">signal.set_wakeup_fd</span></code></a>, then the only way to make everything work correctly is to <em>enable</em> Trio’s <a class="reference external" href="https://docs.python.org/3/library/signal.html#signal.set_wakeup_fd" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">signal.set_wakeup_fd</span></code></a> support.</p> <p>By default, Trio assumes that your host loop doesn’t use <a class="reference external" href="https://docs.python.org/3/library/signal.html#signal.set_wakeup_fd" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">signal.set_wakeup_fd</span></code></a>. It does try to detect when this creates a conflict with the host loop, and print a warning – but unfortunately, by the time it detects it, the damage has already been done. So if you’re getting this warning, then you should disable Trio’s <a class="reference external" href="https://docs.python.org/3/library/signal.html#signal.set_wakeup_fd" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">signal.set_wakeup_fd</span></code></a> support by passing <code class="docutils literal notranslate"><span class="pre">host_uses_signal_set_wakeup_fd=True</span></code> to <a class="reference internal" href="#trio.lowlevel.start_guest_run" title="trio.lowlevel.start_guest_run"><code class="xref py py-obj docutils literal notranslate"><span class="pre">start_guest_run</span></code></a>.</p> <p>If you aren’t seeing any warnings with your initial prototype, you’re <em>probably</em> fine. But the only way to be certain is to check your host loop’s source. For example, asyncio may or may not use <a class="reference external" href="https://docs.python.org/3/library/signal.html#signal.set_wakeup_fd" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">signal.set_wakeup_fd</span></code></a> depending on the Python version and operating system.</p> <p><strong>A small optimization:</strong> Finally, consider a small optimization. Some event loops offer two versions of their “call this function soon” API: one that can be used from any thread, and one that can only be used from the event loop thread, with the latter being cheaper. For example, asyncio has both <a class="reference external" href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.call_soon_threadsafe" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">call_soon_threadsafe</span></code></a> and <a class="reference external" href="https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.call_soon" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">call_soon</span></code></a>.</p> <p>If you have a loop like this, then you can also pass a <code class="docutils literal notranslate"><span class="pre">run_sync_soon_not_threadsafe=...</span></code> kwarg to <a class="reference internal" href="#trio.lowlevel.start_guest_run" title="trio.lowlevel.start_guest_run"><code class="xref py py-obj docutils literal notranslate"><span class="pre">start_guest_run</span></code></a>, and Trio will automatically use it when appropriate.</p> <p>If your loop doesn’t have a split like this, then don’t worry about it; <code class="docutils literal notranslate"><span class="pre">run_sync_soon_not_threadsafe=</span></code> is optional. (If it’s not passed, then Trio will just use your threadsafe version in all cases.)</p> <p><strong>That’s it!</strong> If you’ve followed all these steps, you should now have a cleanly-integrated hybrid event loop. Go make some cool GUIs/games/whatever!</p> </section> <section id="limitations"> <h3>Limitations</h3> <p>In general, almost all Trio features should work in guest mode. The exception is features which rely on Trio having a complete picture of everything that your program is doing, since obviously, it can’t control the host loop or see what it’s doing.</p> <p>Custom clocks can be used in guest mode, but they only affect Trio timeouts, not host loop timeouts. And the <a class="reference internal" href="reference-testing.html#testing-time"><span class="std std-ref">autojump clock</span></a> and related <a class="reference internal" href="reference-testing.html#trio.testing.wait_all_tasks_blocked" title="trio.testing.wait_all_tasks_blocked"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.testing.wait_all_tasks_blocked</span></code></a> can technically be used in guest mode, but they’ll only take Trio tasks into account when decided whether to jump the clock or whether all tasks are blocked.</p> </section> <section id="reference"> <h3>Reference</h3> <dl class="py function"> <h3 class="sig sig-object py" id="trio.lowlevel.start_guest_run"><code>trio.lowlevel.start_guest_run(async_fn, *args, run_sync_soon_threadsafe, done_callback, run_sync_soon_not_threadsafe=None, host_uses_signal_set_wakeup_fd: bool = False, clock=None, instruments=(), restrict_keyboard_interrupt_to_checkpoints: bool = False, strict_exception_groups: bool = False)</code></h3> <dd>
<p>Start a “guest” run of Trio on top of some other “host” event loop.</p> <p>Each host loop can only have one guest run at a time.</p> <p>You should always let the Trio run finish before stopping the host loop; if not, it may leave Trio’s internal data structures in an inconsistent state. You might be able to get away with it if you immediately exit the program, but it’s safest not to go there in the first place.</p> <p>Generally, the best way to do this is wrap this in a function that starts the host loop and then immediately starts the guest run, and then shuts down the host when the guest run completes.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<ul class="simple"> <li>
<p><strong>run_sync_soon_threadsafe</strong> – </p>
<p>An arbitrary callable, which will be passed a function as its sole argument:</p> <pre data-language="python">def my_run_sync_soon_threadsafe(fn):
    ...</pre> <p>This callable should schedule <code class="docutils literal notranslate"><span class="pre">fn()</span></code> to be run by the host on its next pass through its loop. <strong>Must support being called from arbitrary threads.</strong></p> </li> <li>
<p><strong>done_callback</strong> – </p>
<p>An arbitrary callable:</p> <pre data-language="python">def my_done_callback(run_outcome):
    ...</pre> <p>When the Trio run has finished, Trio will invoke this callback to let you know. The argument is an <a class="reference external" href="https://outcome.readthedocs.io/en/latest/api.html#outcome.Outcome" title="(in outcome v1.2.0+dev)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">outcome.Outcome</span></code></a>, reporting what would have been returned or raised by <a class="reference internal" href="reference-core.html#trio.run" title="trio.run"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.run</span></code></a>. This function can do anything you want, but commonly you’ll want it to shut down the host loop, unwrap the outcome, etc.</p> </li> <li><p><strong>run_sync_soon_not_threadsafe</strong> – Like <code class="docutils literal notranslate"><span class="pre">run_sync_soon_threadsafe</span></code>, but will only be called from inside the host loop’s main thread. Optional, but if your host loop allows you to implement this more efficiently than <code class="docutils literal notranslate"><span class="pre">run_sync_soon_threadsafe</span></code> then passing it will make things a bit faster.</p></li> <li><p><strong>host_uses_signal_set_wakeup_fd</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – Pass <a class="reference external" href="https://docs.python.org/3/library/constants.html#True" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">True</span></code></a> if your host loop uses <a class="reference external" href="https://docs.python.org/3/library/signal.html#signal.set_wakeup_fd" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">signal.set_wakeup_fd</span></code></a>, and <a class="reference external" href="https://docs.python.org/3/library/constants.html#False" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">False</span></code></a> otherwise. For more details, see <a class="reference internal" href="#guest-run-implementation"><span class="std std-ref">Implementing guest mode for your favorite event loop</span></a>.</p></li> </ul> </dd> </dl> <p>For the meaning of other arguments, see <a class="reference internal" href="reference-core.html#trio.run" title="trio.run"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.run</span></code></a>.</p> </dd>
</dl> </section> </section> <section id="handing-off-live-coroutine-objects-between-coroutine-runners"> <h2>Handing off live coroutine objects between coroutine runners</h2> <p>Internally, Python’s async/await syntax is built around the idea of “coroutine objects” and “coroutine runners”. A coroutine object represents the state of an async callstack. But by itself, this is just a static object that sits there. If you want it to do anything, you need a coroutine runner to push it forward. Every Trio task has an associated coroutine object (see <a class="reference internal" href="#trio.lowlevel.Task.coro" title="trio.lowlevel.Task.coro"><code class="xref py py-data docutils literal notranslate"><span class="pre">Task.coro</span></code></a>), and the Trio scheduler acts as their coroutine runner.</p> <p>But of course, Trio isn’t the only coroutine runner in Python – <a class="reference external" href="https://docs.python.org/3/library/asyncio.html#module-asyncio" title="(in Python v3.11)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code></a> has one, other event loops have them, you can even define your own.</p> <p>And in some very, very unusual circumstances, it even makes sense to transfer a single coroutine object back and forth between different coroutine runners. That’s what this section is about. This is an <em>extremely</em> exotic use case, and assumes a lot of expertise in how Python async/await works internally. For motivating examples, see <a class="reference external" href="https://github.com/python-trio/trio-asyncio/issues/42">trio-asyncio issue #42</a>, and <a class="reference external" href="https://github.com/python-trio/trio/issues/649">trio issue #649</a>. For more details on how coroutines work, we recommend André Caron’s <a class="reference external" href="https://github.com/AndreLouisCaron/a-tale-of-event-loops">A tale of event loops</a>, or going straight to <a class="reference external" href="https://www.python.org/dev/peps/pep-0492/">PEP 492</a> for the full details.</p> <dl class="py function"> <h3 class="sig sig-object py" id="trio.lowlevel.permanently_detach_coroutine_object"><code><em>await</em> trio.lowlevel.permanently_detach_coroutine_object(final_outcome)</code></h3> <dd>
<p>Permanently detach the current task from the Trio scheduler.</p> <p>Normally, a Trio task doesn’t exit until its coroutine object exits. When you call this function, Trio acts like the coroutine object just exited and the task terminates with the given outcome. This is useful if you want to permanently switch the coroutine object over to a different coroutine runner.</p> <p>When the calling coroutine enters this function it’s running under Trio, and when the function returns it’s running under the foreign coroutine runner.</p> <p>You should make sure that the coroutine object has released any Trio-specific resources it has acquired (e.g. nurseries).</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><strong>final_outcome</strong> (<a class="reference external" href="https://outcome.readthedocs.io/en/latest/api.html#outcome.Outcome" title="(in outcome v1.2.0+dev)"><em>outcome.Outcome</em></a>) – Trio acts as if the current task exited with the given return value or exception.</p> </dd> </dl> <p>Returns or raises whatever value or exception the new coroutine runner uses to resume the coroutine.</p> </dd>
</dl> <dl class="py function"> <h3 class="sig sig-object py" id="trio.lowlevel.temporarily_detach_coroutine_object"><code><em>await</em> trio.lowlevel.temporarily_detach_coroutine_object(abort_func)</code></h3> <dd>
<p>Temporarily detach the current coroutine object from the Trio scheduler.</p> <p>When the calling coroutine enters this function it’s running under Trio, and when the function returns it’s running under the foreign coroutine runner.</p> <p>The Trio <a class="reference internal" href="#trio.lowlevel.Task" title="trio.lowlevel.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> will continue to exist, but will be suspended until you use <a class="reference internal" href="#trio.lowlevel.reattach_detached_coroutine_object" title="trio.lowlevel.reattach_detached_coroutine_object"><code class="xref py py-func docutils literal notranslate"><span class="pre">reattach_detached_coroutine_object()</span></code></a> to resume it. In the mean time, you can use another coroutine runner to schedule the coroutine object. In fact, you have to – the function doesn’t return until the coroutine is advanced from outside.</p> <p>Note that you’ll need to save the current <a class="reference internal" href="#trio.lowlevel.Task" title="trio.lowlevel.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> object to later resume; you can retrieve it with <a class="reference internal" href="#trio.lowlevel.current_task" title="trio.lowlevel.current_task"><code class="xref py py-func docutils literal notranslate"><span class="pre">current_task()</span></code></a>. You can also use this <a class="reference internal" href="#trio.lowlevel.Task" title="trio.lowlevel.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> object to retrieve the coroutine object – see <a class="reference internal" href="#trio.lowlevel.Task.coro" title="trio.lowlevel.Task.coro"><code class="xref py py-data docutils literal notranslate"><span class="pre">Task.coro</span></code></a>.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><strong>abort_func</strong> – Same as for <a class="reference internal" href="#trio.lowlevel.wait_task_rescheduled" title="trio.lowlevel.wait_task_rescheduled"><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_task_rescheduled()</span></code></a>, except that it must return <a class="reference internal" href="#trio.lowlevel.Abort.FAILED" title="trio.lowlevel.Abort.FAILED"><code class="xref py py-data docutils literal notranslate"><span class="pre">Abort.FAILED</span></code></a>. (If it returned <a class="reference internal" href="#trio.lowlevel.Abort.SUCCEEDED" title="trio.lowlevel.Abort.SUCCEEDED"><code class="xref py py-data docutils literal notranslate"><span class="pre">Abort.SUCCEEDED</span></code></a>, then Trio would attempt to reschedule the detached task directly without going through <a class="reference internal" href="#trio.lowlevel.reattach_detached_coroutine_object" title="trio.lowlevel.reattach_detached_coroutine_object"><code class="xref py py-func docutils literal notranslate"><span class="pre">reattach_detached_coroutine_object()</span></code></a>, which would be bad.) Your <code class="docutils literal notranslate"><span class="pre">abort_func</span></code> should still arrange for whatever the coroutine object is doing to be cancelled, and then reattach to Trio and call the <code class="docutils literal notranslate"><span class="pre">raise_cancel</span></code> callback, if possible.</p> </dd> </dl> <p>Returns or raises whatever value or exception the new coroutine runner uses to resume the coroutine.</p> </dd>
</dl> <dl class="py function"> <h3 class="sig sig-object py" id="trio.lowlevel.reattach_detached_coroutine_object"><code><em>await</em> trio.lowlevel.reattach_detached_coroutine_object(task, yield_value)</code></h3> <dd>
<p>Reattach a coroutine object that was detached using <a class="reference internal" href="#trio.lowlevel.temporarily_detach_coroutine_object" title="trio.lowlevel.temporarily_detach_coroutine_object"><code class="xref py py-func docutils literal notranslate"><span class="pre">temporarily_detach_coroutine_object()</span></code></a>.</p> <p>When the calling coroutine enters this function it’s running under the foreign coroutine runner, and when the function returns it’s running under Trio.</p> <p>This must be called from inside the coroutine being resumed, and yields whatever value you pass in. (Presumably you’ll pass a value that will cause the current coroutine runner to stop scheduling this task.) Then the coroutine is resumed by the Trio scheduler at the next opportunity.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<ul class="simple"> <li><p><strong>task</strong> (<a class="reference internal" href="#trio.lowlevel.Task" title="trio.lowlevel.Task"><em>Task</em></a>) – The Trio task object that the current coroutine was detached from.</p></li> <li><p><strong>yield_value</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.11)"><em>object</em></a>) – The object to yield to the current coroutine runner.</p></li> </ul> </dd> </dl> </dd>
</dl> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2017 Nathaniel J. Smith<br>Licensed under the MIT License.<br>
    <a href="https://trio.readthedocs.io/en/v0.22.2/reference-lowlevel.html" class="_attribution-link">https://trio.readthedocs.io/en/v0.22.2/reference-lowlevel.html</a>
  </p>
</div>
