<section id="module-trio"> <h1>Trio’s core functionality</h1> <section id="entering-trio"> <h2>Entering Trio</h2> <p>If you want to use Trio, then the first thing you have to do is call <a class="reference internal" href="#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a>:</p> <dl class="py function"> <h3 class="sig sig-object py" id="trio.run"><code>trio.run(async_fn, *args, clock=None, instruments=(), restrict_keyboard_interrupt_to_checkpoints: bool = False, strict_exception_groups: bool = False)</code></h3> <dd>
<p>Run a Trio-flavored async function, and return the result.</p> <p>Calling:</p> <pre data-language="python">run(async_fn, *args)</pre> <p>is the equivalent of:</p> <pre data-language="python">await async_fn(*args)</pre> <p>except that <a class="reference internal" href="#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">run()</span></code></a> can (and must) be called from a synchronous context.</p> <p>This is Trio’s main entry point. Almost every other function in Trio requires that you be inside a call to <a class="reference internal" href="#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">run()</span></code></a>.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<ul class="simple"> <li><p><strong>async_fn</strong> – An async function.</p></li> <li><p><strong>args</strong> – Positional arguments to be passed to <em>async_fn</em>. If you need to pass keyword arguments, then use <a class="reference external" href="https://docs.python.org/3/library/functools.html#functools.partial" title="(in Python v3.11)"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.partial()</span></code></a>.</p></li> <li><p><strong>clock</strong> – <code class="docutils literal notranslate"><span class="pre">None</span></code> to use the default system-specific monotonic clock; otherwise, an object implementing the <a class="reference internal" href="#trio.abc.Clock" title="trio.abc.Clock"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.abc.Clock</span></code></a> interface, like (for example) a <a class="reference internal" href="reference-testing.html#trio.testing.MockClock" title="trio.testing.MockClock"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.testing.MockClock</span></code></a> instance.</p></li> <li><p><strong>instruments</strong> (list of <a class="reference internal" href="reference-lowlevel.html#trio.abc.Instrument" title="trio.abc.Instrument"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.abc.Instrument</span></code></a> objects) – Any instrumentation you want to apply to this run. This can also be modified during the run; see <a class="reference internal" href="reference-lowlevel.html#instrumentation"><span class="std std-ref">Instrument API</span></a>.</p></li> <li>
<p><strong>restrict_keyboard_interrupt_to_checkpoints</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – </p>
<p>What happens if the user hits control-C while <a class="reference internal" href="#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">run()</span></code></a> is running? If this argument is False (the default), then you get the standard Python behavior: a <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt" title="(in Python v3.11)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> exception will immediately interrupt whatever task is running (or if no task is running, then Trio will wake up a task to be interrupted). Alternatively, if you set this argument to True, then <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt" title="(in Python v3.11)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> delivery will be delayed: it will be <em>only</em> be raised at <a class="reference internal" href="#checkpoints"><span class="std std-ref">checkpoints</span></a>, like a <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> exception.</p> <p>The default behavior is nice because it means that even if you accidentally write an infinite loop that never executes any checkpoints, then you can still break out of it using control-C. The alternative behavior is nice if you’re paranoid about a <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt" title="(in Python v3.11)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> at just the wrong place leaving your program in an inconsistent state, because it means that you only have to worry about <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt" title="(in Python v3.11)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> at the exact same places where you already have to worry about <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a>.</p> <p>This setting has no effect if your program has registered a custom SIGINT handler, or if <a class="reference internal" href="#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">run()</span></code></a> is called from anywhere but the main thread (this is a Python limitation), or if you use <a class="reference internal" href="reference-io.html#trio.open_signal_receiver" title="trio.open_signal_receiver"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_signal_receiver()</span></code></a> to catch SIGINT.</p> </li> <li><p><strong>strict_exception_groups</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If true, nurseries will always wrap even a single raised exception in an exception group. This can be overridden on the level of individual nurseries. This will eventually become the default behavior.</p></li> </ul> </dd> <h4 class="field-even" style="margin: 0">Returns<span class="colon">:</span>
</h4> <dd class="field-even">
<p>Whatever <code class="docutils literal notranslate"><span class="pre">async_fn</span></code> returns.</p> </dd> <h4 class="field-odd" style="margin: 0">Raises<span class="colon">:</span>
</h4> <dd class="field-odd">
<ul class="simple"> <li><p><a class="reference internal" href="#trio.TrioInternalError" title="trio.TrioInternalError"><strong>TrioInternalError</strong></a> – if an unexpected error is encountered inside Trio’s internal machinery. This is a bug and you should <a class="reference external" href="https://github.com/python-trio/trio/issues">let us know</a>.</p></li> <li><p><strong>Anything else</strong> – if <code class="docutils literal notranslate"><span class="pre">async_fn</span></code> raises an exception, then <a class="reference internal" href="#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">run()</span></code></a> propagates it.</p></li> </ul> </dd> </dl> </dd>
</dl> </section> <section id="general-principles"> <h2>General principles</h2> <section id="checkpoints"> <h3>Checkpoints</h3> <p>When writing code using Trio, it’s very important to understand the concept of a <em>checkpoint</em>. Many of Trio’s functions act as checkpoints.</p> <p>A checkpoint is two things:</p> <ol class="arabic simple"> <li><p>It’s a point where Trio checks for cancellation. For example, if the code that called your function set a timeout, and that timeout has expired, then the next time your function executes a checkpoint Trio will raise a <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> exception. See <a class="reference internal" href="#cancellation"><span class="std std-ref">Cancellation and timeouts</span></a> below for more details.</p></li> <li><p>It’s a point where the Trio scheduler checks its scheduling policy to see if it’s a good time to switch to another task, and potentially does so. (Currently, this check is very simple: the scheduler always switches at every checkpoint. But <a class="reference external" href="https://github.com/python-trio/trio/issues/32">this might change in the future</a>.)</p></li> </ol> <p>When writing Trio code, you need to keep track of where your checkpoints are. Why? First, because checkpoints require extra scrutiny: whenever you execute a checkpoint, you need to be prepared to handle a <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> error, or for another task to run and <a class="reference external" href="https://glyph.twistedmatrix.com/2014/02/unyielding.html">rearrange some state out from under you</a>. And second, because you also need to make sure that you have <em>enough</em> checkpoints: if your code doesn’t pass through a checkpoint on a regular basis, then it will be slow to notice and respond to cancellation and – much worse – since Trio is a cooperative multi-tasking system where the <em>only</em> place the scheduler can switch tasks is at checkpoints, it’ll also prevent the scheduler from fairly allocating time between different tasks and adversely effect the response latency of all the other code running in the same process. (Informally we say that a task that does this is “hogging the run loop”.)</p> <p>So when you’re doing code review on a project that uses Trio, one of the things you’ll want to think about is whether there are enough checkpoints, and whether each one is handled correctly. Of course this means you need a way to recognize checkpoints. How do you do that? The underlying principle is that any operation that blocks has to be a checkpoint. This makes sense: if an operation blocks, then it might block for a long time, and you’ll want to be able to cancel it if a timeout expires; and in any case, while this task is blocked we want another task to be scheduled to run so our code can make full use of the CPU.</p> <p>But if we want to write correct code in practice, then this principle is a little too sloppy and imprecise to be useful. How do we know which functions might block? What if a function blocks sometimes, but not others, depending on the arguments passed / network speed / phase of the moon? How do we figure out where the checkpoints are when we’re stressed and sleep deprived but still want to get this code review right, and would prefer to reserve our mental energy for thinking about the actual logic instead of worrying about checkpoints?</p> <p id="checkpoint-rule">Don’t worry – Trio’s got your back. Since checkpoints are important and ubiquitous, we make it as simple as possible to keep track of them. Here are the rules:</p> <ul class="simple"> <li><p>Regular (synchronous) functions never contain any checkpoints.</p></li> <li>
<p>If you call an async function provided by Trio (<code class="docutils literal notranslate"><span class="pre">await</span>
<span class="pre">&lt;something</span> <span class="pre">in</span> <span class="pre">trio&gt;</span></code>), and it doesn’t raise an exception, then it <em>always</em> acts as a checkpoint. (If it does raise an exception, it might act as a checkpoint or might not.)</p> <ul> <li><p>This includes async iterators: If you write <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span> <span class="pre">...</span> <span class="pre">in</span> <span class="pre">&lt;a</span>
<span class="pre">trio</span> <span class="pre">object&gt;</span></code>, then there will be at least one checkpoint in each iteration of the loop, and it will still checkpoint if the iterable is empty.</p></li> <li><p>Partial exception for async context managers: Both the entry and exit of an <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> block are defined as async functions; but for a particular type of async context manager, it’s often the case that only one of them is able to block, which means only that one will act as a checkpoint. This is documented on a case-by-case basis.</p></li> </ul> </li> <li><p>Third-party async functions / iterators / context managers can act as checkpoints; if you see <code class="docutils literal notranslate"><span class="pre">await</span> <span class="pre">&lt;something&gt;</span></code> or one of its friends, then that <em>might</em> be a checkpoint. So to be safe, you should prepare for scheduling or cancellation happening there.</p></li> </ul> <p>The reason we distinguish between Trio functions and other functions is that we can’t make any guarantees about third party code. Checkpoint-ness is a transitive property: if function A acts as a checkpoint, and you write a function that calls function A, then your function also acts as a checkpoint. If you don’t, then it isn’t. So there’s nothing stopping someone from writing a function like:</p> <pre data-language="python"># technically legal, but bad style:
async def why_is_this_async():
    return 7</pre> <p>that never calls any of Trio’s async functions. This is an async function, but it’s not a checkpoint. But why make a function async if it never calls any async functions? It’s possible, but it’s a bad idea. If you have a function that’s not calling any async functions, then you should make it synchronous. The people who use your function will thank you, because it makes it obvious that your function is not a checkpoint, and their code reviews will go faster.</p> <p>(Remember how in the tutorial we emphasized the importance of the <a class="reference internal" href="https://trio.readthedocs.io/en/v0.22.2/tutorial.html#async-sandwich"><span class="std std-ref">“async sandwich”</span></a>, and the way it means that <code class="docutils literal notranslate"><span class="pre">await</span></code> ends up being a marker that shows when you’re calling a function that calls a function that … eventually calls one of Trio’s built-in async functions? The transitivity of async-ness is a technical requirement that Python imposes, but since it exactly matches the transitivity of checkpoint-ness, we’re able to exploit it to help you keep track of checkpoints. Pretty sneaky, eh?)</p> <p>A slightly trickier case is a function like:</p> <pre data-language="python">async def sleep_or_not(should_sleep):
    if should_sleep:
        await trio.sleep(1)
    else:
        pass</pre> <p>Here the function acts as a checkpoint if you call it with <code class="docutils literal notranslate"><span class="pre">should_sleep</span></code> set to a true value, but not otherwise. This is why we emphasize that Trio’s own async functions are <em>unconditional</em> checkpoints: they <em>always</em> check for cancellation and check for scheduling, regardless of what arguments they’re passed. If you find an async function in Trio that doesn’t follow this rule, then it’s a bug and you should <a class="reference external" href="https://github.com/python-trio/trio/issues">let us know</a>.</p> <p>Inside Trio, we’re very picky about this, because Trio is the foundation of the whole system so we think it’s worth the extra effort to make things extra predictable. It’s up to you how picky you want to be in your code. To give you a more realistic example of what this kind of issue looks like in real life, consider this function:</p> <pre data-language="python">async def recv_exactly(sock, nbytes):
    data = bytearray()
    while nbytes &gt; 0:
        # recv() reads up to 'nbytes' bytes each time
        chunk = await sock.recv(nbytes)
        if not chunk:
            raise RuntimeError("socket unexpected closed")
        nbytes -= len(chunk)
        data += chunk
    return data</pre> <p>If called with an <code class="docutils literal notranslate"><span class="pre">nbytes</span></code> that’s greater than zero, then it will call <code class="docutils literal notranslate"><span class="pre">sock.recv</span></code> at least once, and <code class="docutils literal notranslate"><span class="pre">recv</span></code> is an async Trio function, and thus an unconditional checkpoint. So in this case, <code class="docutils literal notranslate"><span class="pre">recv_exactly</span></code> acts as a checkpoint. But if we do <code class="docutils literal notranslate"><span class="pre">await</span>
<span class="pre">recv_exactly(sock,</span> <span class="pre">0)</span></code>, then it will immediately return an empty buffer without executing a checkpoint. If this were a function in Trio itself, then this wouldn’t be acceptable, but you may decide you don’t want to worry about this kind of minor edge case in your own code.</p> <p>If you do want to be careful, or if you have some CPU-bound code that doesn’t have enough checkpoints in it, then it’s useful to know that <code class="docutils literal notranslate"><span class="pre">await</span> <span class="pre">trio.sleep(0)</span></code> is an idiomatic way to execute a checkpoint without doing anything else, and that <a class="reference internal" href="reference-testing.html#trio.testing.assert_checkpoints" title="trio.testing.assert_checkpoints"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.testing.assert_checkpoints()</span></code></a> can be used to test that an arbitrary block of code contains a checkpoint.</p> </section> <section id="thread-safety"> <h3>Thread safety</h3> <p>The vast majority of Trio’s API is <em>not</em> thread safe: it can only be used from inside a call to <a class="reference internal" href="#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a>. This manual doesn’t bother documenting this on individual calls; unless specifically noted otherwise, you should assume that it isn’t safe to call any Trio functions from anywhere except the Trio thread. (But <a class="reference internal" href="#threads"><span class="std std-ref">see below</span></a> if you really do need to work with threads.)</p> </section> </section> <section id="time-and-clocks"> <h2>Time and clocks</h2> <p>Every call to <a class="reference internal" href="#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">run()</span></code></a> has an associated clock.</p> <p>By default, Trio uses an unspecified monotonic clock, but this can be changed by passing a custom clock object to <a class="reference internal" href="#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">run()</span></code></a> (e.g. for testing).</p> <p>You should not assume that Trio’s internal clock matches any other clock you have access to, including the clocks of simultaneous calls to <a class="reference internal" href="#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a> happening in other processes or threads!</p> <p>The default clock is currently implemented as <a class="reference external" href="https://docs.python.org/3/library/time.html#time.perf_counter" title="(in Python v3.11)"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.perf_counter()</span></code></a> plus a large random offset. The idea here is to catch code that accidentally uses <a class="reference external" href="https://docs.python.org/3/library/time.html#time.perf_counter" title="(in Python v3.11)"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.perf_counter()</span></code></a> early, which should help keep our options open for <a class="reference external" href="https://github.com/python-trio/trio/issues/33">changing the clock implementation later</a>, and (more importantly) make sure you can be confident that custom clocks like <a class="reference internal" href="reference-testing.html#trio.testing.MockClock" title="trio.testing.MockClock"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.testing.MockClock</span></code></a> will work with third-party libraries you don’t control.</p> <dl class="py function"> <h3 class="sig sig-object py" id="trio.current_time"><code>trio.current_time()</code></h3> <dd>
<p>Returns the current time according to Trio’s internal clock.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Returns<span class="colon">:</span>
</h4> <dd class="field-odd">
<p>The current time.</p> </dd> <h4 class="field-even" style="margin: 0">Return type<span class="colon">:</span>
</h4> <dd class="field-even">
<p><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)">float</a></p> </dd> <h4 class="field-odd" style="margin: 0">Raises<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#RuntimeError" title="(in Python v3.11)"><strong>RuntimeError</strong></a> – if not inside a call to <a class="reference internal" href="#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a>.</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 class="sig sig-object py" id="trio.sleep"><code><em>await</em> trio.sleep(seconds: float) → None</code></h3> <dd>
<p>Pause execution of the current task for the given number of seconds.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><strong>seconds</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – The number of seconds to sleep. May be zero to insert a checkpoint without actually blocking.</p> </dd> <h4 class="field-even" style="margin: 0">Raises<span class="colon">:</span>
</h4> <dd class="field-even">
<p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.11)"><strong>ValueError</strong></a> – if <em>seconds</em> is negative or NaN.</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 class="sig sig-object py" id="trio.sleep_until"><code><em>await</em> trio.sleep_until(deadline: float) → None</code></h3> <dd>
<p>Pause execution of the current task until the given time.</p> <p>The difference between <a class="reference internal" href="#trio.sleep" title="trio.sleep"><code class="xref py py-func docutils literal notranslate"><span class="pre">sleep()</span></code></a> and <a class="reference internal" href="#trio.sleep_until" title="trio.sleep_until"><code class="xref py py-func docutils literal notranslate"><span class="pre">sleep_until()</span></code></a> is that the former takes a relative time and the latter takes an absolute time according to Trio’s internal clock (as returned by <a class="reference internal" href="#trio.current_time" title="trio.current_time"><code class="xref py py-func docutils literal notranslate"><span class="pre">current_time()</span></code></a>).</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><strong>deadline</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – The time at which we should wake up again. May be in the past, in which case this function executes a checkpoint but does not block.</p> </dd> <h4 class="field-even" style="margin: 0">Raises<span class="colon">:</span>
</h4> <dd class="field-even">
<p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.11)"><strong>ValueError</strong></a> – if deadline is NaN.</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 class="sig sig-object py" id="trio.sleep_forever"><code><em>await</em> trio.sleep_forever() → None</code></h3> <dd>
<p>Pause execution of the current task forever (or until cancelled).</p> <p>Equivalent to calling <code class="docutils literal notranslate"><span class="pre">await</span> <span class="pre">sleep(math.inf)</span></code>.</p> </dd>
</dl> <p>If you’re a mad scientist or otherwise feel the need to take direct control over the PASSAGE OF TIME ITSELF, then you can implement a custom <a class="reference internal" href="#trio.abc.Clock" title="trio.abc.Clock"><code class="xref py py-class docutils literal notranslate"><span class="pre">Clock</span></code></a> class:</p> <dl class="py class"> <h3 class="sig sig-object py" id="trio.abc.Clock"><code><em>class</em> trio.abc.Clock</code></h3> <dd>
<p>The interface for custom run loop clocks.</p> <dl class="py method"> <h3 class="sig sig-object py" id="trio.abc.Clock.current_time"><code><em>abstractmethod</em> current_time()</code></h3> <dd>
<p>Return the current time, according to this clock.</p> <p>This is used to implement functions like <a class="reference internal" href="#trio.current_time" title="trio.current_time"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.current_time()</span></code></a> and <a class="reference internal" href="#trio.move_on_after" title="trio.move_on_after"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.move_on_after()</span></code></a>.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Returns<span class="colon">:</span>
</h4> <dd class="field-odd">
<p>The current time.</p> </dd> <h4 class="field-even" style="margin: 0">Return type<span class="colon">:</span>
</h4> <dd class="field-even">
<p><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)">float</a></p> </dd> </dl> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.abc.Clock.deadline_to_sleep_time"><code><em>abstractmethod</em> deadline_to_sleep_time(deadline)</code></h3> <dd>
<p>Compute the real time until the given deadline.</p> <p>This is called before we enter a system-specific wait function like <a class="reference external" href="https://docs.python.org/3/library/select.html#select.select" title="(in Python v3.11)"><code class="xref py py-func docutils literal notranslate"><span class="pre">select.select()</span></code></a>, to get the timeout to pass.</p> <p>For a clock using wall-time, this should be something like:</p> <pre data-language="python">return deadline - self.current_time()</pre> <p>but of course it may be different if you’re implementing some kind of virtual clock.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><strong>deadline</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – The absolute time of the next deadline, according to this clock.</p> </dd> <h4 class="field-even" style="margin: 0">Returns<span class="colon">:</span>
</h4> <dd class="field-even">
<p>The number of real seconds to sleep until the given deadline. May be <a class="reference external" href="https://docs.python.org/3/library/math.html#math.inf" title="(in Python v3.11)"><code class="xref py py-data docutils literal notranslate"><span class="pre">math.inf</span></code></a>.</p> </dd> <h4 class="field-odd" style="margin: 0">Return type<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)">float</a></p> </dd> </dl> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.abc.Clock.start_clock"><code><em>abstractmethod</em> start_clock()</code></h3> <dd>
<p>Do any setup this clock might need.</p> <p>Called at the beginning of the run.</p> </dd>
</dl> </dd>
</dl> </section> <section id="cancellation-and-timeouts"> <h2>Cancellation and timeouts</h2> <p>Trio has a rich, composable system for cancelling work, either explicitly or when a timeout expires.</p> <section id="a-simple-timeout-example"> <h3>A simple timeout example</h3> <p>In the simplest case, you can apply a timeout to a block of code:</p> <pre data-language="python">with trio.move_on_after(30):
    result = await do_http_get("https://...")
    print("result is", result)
print("with block finished")</pre> <p>We refer to <a class="reference internal" href="#trio.move_on_after" title="trio.move_on_after"><code class="xref py py-func docutils literal notranslate"><span class="pre">move_on_after()</span></code></a> as creating a “cancel scope”, which contains all the code that runs inside the <code class="docutils literal notranslate"><span class="pre">with</span></code> block. If the HTTP request takes more than 30 seconds to run, then it will be cancelled: we’ll abort the request and we <em>won’t</em> see <code class="docutils literal notranslate"><span class="pre">result</span> <span class="pre">is</span> <span class="pre">...</span></code> printed on the console; instead we’ll go straight to printing the <code class="docutils literal notranslate"><span class="pre">with</span> <span class="pre">block</span>
<span class="pre">finished</span></code> message.</p> <blockquote class="admonition note"> <h4 class="admonition-title">Note</h4> <p>Note that this is a single 30 second timeout for the entire body of the <code class="docutils literal notranslate"><span class="pre">with</span></code> statement. This is different from what you might have seen with other Python libraries, where timeouts often refer to something <a class="reference external" href="https://requests.kennethreitz.org/en/master/user/quickstart/#timeouts">more complicated</a>. We think this way is easier to reason about.</p> </blockquote> <p>How does this work? There’s no magic here: Trio is built using ordinary Python functionality, so we can’t just abandon the code inside the <code class="docutils literal notranslate"><span class="pre">with</span></code> block. Instead, we take advantage of Python’s standard way of aborting a large and complex piece of code: we raise an exception.</p> <p>Here’s the idea: whenever you call a cancellable function like <code class="docutils literal notranslate"><span class="pre">await</span>
<span class="pre">trio.sleep(...)</span></code> or <code class="docutils literal notranslate"><span class="pre">await</span> <span class="pre">sock.recv(...)</span></code> – see <a class="reference internal" href="#checkpoints"><span class="std std-ref">Checkpoints</span></a> – then the first thing that function does is to check if there’s a surrounding cancel scope whose timeout has expired, or otherwise been cancelled. If so, then instead of performing the requested operation, the function fails immediately with a <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> exception. In this example, this probably happens somewhere deep inside the bowels of <code class="docutils literal notranslate"><span class="pre">do_http_get</span></code>. The exception then propagates out like any normal exception (you could even catch it if you wanted, but that’s generally a bad idea), until it reaches the <code class="docutils literal notranslate"><span class="pre">with</span> <span class="pre">move_on_after(...):</span></code>. And at this point, the <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> exception has done its job – it’s successfully unwound the whole cancelled scope – so <a class="reference internal" href="#trio.move_on_after" title="trio.move_on_after"><code class="xref py py-func docutils literal notranslate"><span class="pre">move_on_after()</span></code></a> catches it, and execution continues as normal after the <code class="docutils literal notranslate"><span class="pre">with</span></code> block. And this all works correctly even if you have nested cancel scopes, because every <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> object carries an invisible marker that makes sure that the cancel scope that triggered it is the only one that will catch it.</p> </section> <section id="handling-cancellation"> <h3>Handling cancellation</h3> <p>Pretty much any code you write using Trio needs to have some strategy to handle <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> exceptions – even if you didn’t set a timeout, then your caller might (and probably will).</p> <p>You can catch <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a>, but you shouldn’t! Or more precisely, if you do catch it, then you should do some cleanup and then re-raise it or otherwise let it continue propagating (unless you encounter an error, in which case it’s OK to let that propagate instead). To help remind you of this fact, <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> inherits from <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#BaseException" title="(in Python v3.11)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BaseException</span></code></a>, like <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt" title="(in Python v3.11)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> and <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#SystemExit" title="(in Python v3.11)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SystemExit</span></code></a> do, so that it won’t be caught by catch-all <code class="docutils literal notranslate"><span class="pre">except</span>
<span class="pre">Exception:</span></code> blocks.</p> <p>It’s also important in any long-running code to make sure that you regularly check for cancellation, because otherwise timeouts won’t work! This happens implicitly every time you call a cancellable operation; see <a class="reference internal" href="#cancellable-primitives"><span class="std std-ref">below</span></a> for details. If you have a task that has to do a lot of work without any I/O, then you can use <code class="docutils literal notranslate"><span class="pre">await</span> <span class="pre">sleep(0)</span></code> to insert an explicit cancel+schedule point.</p> <p>Here’s a rule of thumb for designing good Trio-style (“trionic”?) APIs: if you’re writing a reusable function, then you shouldn’t take a <code class="docutils literal notranslate"><span class="pre">timeout=</span></code> parameter, and instead let your caller worry about it. This has several advantages. First, it leaves the caller’s options open for deciding how they prefer to handle timeouts – for example, they might find it easier to work with absolute deadlines instead of relative timeouts. If they’re the ones calling into the cancellation machinery, then they get to pick, and you don’t have to worry about it. Second, and more importantly, this makes it easier for others to re-use your code. If you write a <code class="docutils literal notranslate"><span class="pre">http_get</span></code> function, and then I come along later and write a <code class="docutils literal notranslate"><span class="pre">log_in_to_twitter</span></code> function that needs to internally make several <code class="docutils literal notranslate"><span class="pre">http_get</span></code> calls, I don’t want to have to figure out how to configure the individual timeouts on each of those calls – and with Trio’s timeout system, it’s totally unnecessary.</p> <p>Of course, this rule doesn’t apply to APIs that need to impose internal timeouts. For example, if you write a <code class="docutils literal notranslate"><span class="pre">start_http_server</span></code> function, then you probably should give your caller some way to configure timeouts on individual requests.</p> </section> <section id="cancellation-semantics"> <h3>Cancellation semantics</h3> <p>You can freely nest cancellation blocks, and each <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> exception “knows” which block it belongs to. So long as you don’t stop it, the exception will keep propagating until it reaches the block that raised it, at which point it will stop automatically.</p> <p>Here’s an example:</p> <pre data-language="python">print("starting...")
with trio.move_on_after(5):
    with trio.move_on_after(10):
        await trio.sleep(20)
        print("sleep finished without error")
    print("move_on_after(10) finished without error")
print("move_on_after(5) finished without error")</pre> <p>In this code, the outer scope will expire after 5 seconds, causing the <a class="reference internal" href="#trio.sleep" title="trio.sleep"><code class="xref py py-func docutils literal notranslate"><span class="pre">sleep()</span></code></a> call to return early with a <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> exception. Then this exception will propagate through the <code class="docutils literal notranslate"><span class="pre">with</span>
<span class="pre">move_on_after(10)</span></code> line until it’s caught by the <code class="docutils literal notranslate"><span class="pre">with</span>
<span class="pre">move_on_after(5)</span></code> context manager. So this code will print:</p> <pre>starting...
move_on_after(5) finished without error</pre> <p>The end result is that Trio has successfully cancelled exactly the work that was happening within the scope that was cancelled.</p> <p>Looking at this, you might wonder how you can tell whether the inner block timed out – perhaps you want to do something different, like try a fallback procedure or report a failure to our caller. To make this easier, <a class="reference internal" href="#trio.move_on_after" title="trio.move_on_after"><code class="xref py py-func docutils literal notranslate"><span class="pre">move_on_after()</span></code></a>´s <code class="docutils literal notranslate"><span class="pre">__enter__</span></code> function returns an object representing this cancel scope, which we can use to check whether this scope caught a <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> exception:</p> <pre data-language="python">with trio.move_on_after(5) as cancel_scope:
    await trio.sleep(10)
print(cancel_scope.cancelled_caught)  # prints "True"</pre> <p>The <code class="docutils literal notranslate"><span class="pre">cancel_scope</span></code> object also allows you to check or adjust this scope’s deadline, explicitly trigger a cancellation without waiting for the deadline, check if the scope has already been cancelled, and so forth – see <a class="reference internal" href="#trio.CancelScope" title="trio.CancelScope"><code class="xref py py-class docutils literal notranslate"><span class="pre">CancelScope</span></code></a> below for the full details.</p> <p id="blocking-cleanup-example">Cancellations in Trio are “level triggered”, meaning that once a block has been cancelled, <em>all</em> cancellable operations in that block will keep raising <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a>. This helps avoid some pitfalls around resource clean-up. For example, imagine that we have a function that connects to a remote server and sends some messages, and then cleans up on the way out:</p> <pre data-language="python">with trio.move_on_after(TIMEOUT):
    conn = make_connection()
    try:
        await conn.send_hello_msg()
    finally:
        await conn.send_goodbye_msg()</pre> <p>Now suppose that the remote server stops responding, so our call to <code class="docutils literal notranslate"><span class="pre">await</span> <span class="pre">conn.send_hello_msg()</span></code> hangs forever. Fortunately, we were clever enough to put a timeout around this code, so eventually the timeout will expire and <code class="docutils literal notranslate"><span class="pre">send_hello_msg</span></code> will raise <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a>. But then, in the <code class="docutils literal notranslate"><span class="pre">finally</span></code> block, we make another blocking operation, which will also hang forever! At this point, if we were using <a class="reference external" href="https://docs.python.org/3/library/asyncio.html#module-asyncio" title="(in Python v3.11)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code></a> or another library with “edge-triggered” cancellation, we’d be in trouble: since our timeout already fired, it wouldn’t fire again, and at this point our application would lock up forever. But in Trio, this <em>doesn’t</em> happen: the <code class="docutils literal notranslate"><span class="pre">await</span>
<span class="pre">conn.send_goodbye_msg()</span></code> call is still inside the cancelled block, so it will also raise <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a>.</p> <p>Of course, if you really want to make another blocking call in your cleanup handler, Trio will let you; it’s trying to prevent you from accidentally shooting yourself in the foot. Intentional foot-shooting is no problem (or at least – it’s not Trio’s problem). To do this, create a new scope, and set its <a class="reference internal" href="#trio.CancelScope.shield" title="trio.CancelScope.shield"><code class="xref py py-attr docutils literal notranslate"><span class="pre">shield</span></code></a> attribute to <a class="reference external" href="https://docs.python.org/3/library/constants.html#True" title="(in Python v3.11)"><code class="xref py py-data docutils literal notranslate"><span class="pre">True</span></code></a>:</p> <pre data-language="python">with trio.move_on_after(TIMEOUT):
    conn = make_connection()
    try:
        await conn.send_hello_msg()
    finally:
        with trio.move_on_after(CLEANUP_TIMEOUT) as cleanup_scope:
            cleanup_scope.shield = True
            await conn.send_goodbye_msg()</pre> <p>So long as you’re inside a scope with <code class="docutils literal notranslate"><span class="pre">shield</span> <span class="pre">=</span> <span class="pre">True</span></code> set, then you’ll be protected from outside cancellations. Note though that this <em>only</em> applies to <em>outside</em> cancellations: if <code class="docutils literal notranslate"><span class="pre">CLEANUP_TIMEOUT</span></code> expires then <code class="docutils literal notranslate"><span class="pre">await</span> <span class="pre">conn.send_goodbye_msg()</span></code> will still be cancelled, and if <code class="docutils literal notranslate"><span class="pre">await</span> <span class="pre">conn.send_goodbye_msg()</span></code> call uses any timeouts internally, then those will continue to work normally as well. This is a pretty advanced feature that most people probably won’t use, but it’s there for the rare cases where you need it.</p> </section> <section id="cancellation-and-primitive-operations"> <h3>Cancellation and primitive operations</h3> <p>We’ve talked a lot about what happens when an operation is cancelled, and how you need to be prepared for this whenever calling a cancellable operation… but we haven’t gone into the details about which operations are cancellable, and how exactly they behave when they’re cancelled.</p> <p>Here’s the rule: if it’s in the <code class="docutils literal notranslate"><span class="pre">trio</span></code> namespace, and you use <code class="docutils literal notranslate"><span class="pre">await</span></code> to call it, then it’s cancellable (see <a class="reference internal" href="#checkpoints"><span class="std std-ref">Checkpoints</span></a> above). Cancellable means:</p> <ul class="simple"> <li><p>If you try to call it when inside a cancelled scope, then it will raise <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a>.</p></li> <li><p>If it blocks, and while it’s blocked then one of the scopes around it becomes cancelled, it will return early and raise <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a>.</p></li> <li><p>Raising <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> means that the operation <em>did not happen</em>. If a Trio socket’s <code class="docutils literal notranslate"><span class="pre">send</span></code> method raises <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a>, then no data was sent. If a Trio socket’s <code class="docutils literal notranslate"><span class="pre">recv</span></code> method raises <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> then no data was lost – it’s still sitting in the socket receive buffer waiting for you to call <code class="docutils literal notranslate"><span class="pre">recv</span></code> again. And so forth.</p></li> </ul> <p>There are a few idiosyncratic cases where external constraints make it impossible to fully implement these semantics. These are always documented. There is also one systematic exception:</p> <ul class="simple"> <li><p>Async cleanup operations – like <code class="docutils literal notranslate"><span class="pre">__aexit__</span></code> methods or async close methods – are cancellable just like anything else <em>except</em> that if they are cancelled, they still perform a minimum level of cleanup before raising <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a>.</p></li> </ul> <p>For example, closing a TLS-wrapped socket normally involves sending a notification to the remote peer, so that they can be cryptographically assured that you really meant to close the socket, and your connection wasn’t just broken by a man-in-the-middle attacker. But handling this robustly is a bit tricky. Remember our <a class="reference internal" href="#blocking-cleanup-example"><span class="std std-ref">example</span></a> above where the blocking <code class="docutils literal notranslate"><span class="pre">send_goodbye_msg</span></code> caused problems? That’s exactly how closing a TLS socket works: if the remote peer has disappeared, then our code may never be able to actually send our shutdown notification, and it would be nice if it didn’t block forever trying. Therefore, the method for closing a TLS-wrapped socket will <em>try</em> to send that notification – and if it gets cancelled, then it will give up on sending the message, but <em>will</em> still close the underlying socket before raising <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a>, so at least you don’t leak that resource.</p> </section> <section id="cancellation-api-details"> <h3>Cancellation API details</h3> <p><a class="reference internal" href="#trio.move_on_after" title="trio.move_on_after"><code class="xref py py-func docutils literal notranslate"><span class="pre">move_on_after()</span></code></a> and all the other cancellation facilities provided by Trio are ultimately implemented in terms of <a class="reference internal" href="#trio.CancelScope" title="trio.CancelScope"><code class="xref py py-class docutils literal notranslate"><span class="pre">CancelScope</span></code></a> objects.</p> <dl class="py class"> <h3 class="sig sig-object py" id="trio.CancelScope"><code><em>class</em> trio.CancelScope(*, deadline: float = inf, shield: bool = False)</code></h3> <dd>
<p>A <em>cancellation scope</em>: the link between a unit of cancellable work and Trio’s cancellation system.</p> <p>A <a class="reference internal" href="#trio.CancelScope" title="trio.CancelScope"><code class="xref py py-class docutils literal notranslate"><span class="pre">CancelScope</span></code></a> becomes associated with some cancellable work when it is used as a context manager surrounding that work:</p> <pre data-language="python">cancel_scope = trio.CancelScope()
...
with cancel_scope:
    await long_running_operation()</pre> <p>Inside the <code class="docutils literal notranslate"><span class="pre">with</span></code> block, a cancellation of <code class="docutils literal notranslate"><span class="pre">cancel_scope</span></code> (via a call to its <a class="reference internal" href="#trio.CancelScope.cancel" title="trio.CancelScope.cancel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cancel()</span></code></a> method or via the expiry of its <a class="reference internal" href="#trio.CancelScope.deadline" title="trio.CancelScope.deadline"><code class="xref py py-attr docutils literal notranslate"><span class="pre">deadline</span></code></a>) will immediately interrupt the <code class="docutils literal notranslate"><span class="pre">long_running_operation()</span></code> by raising <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> at its next <a class="reference internal" href="#checkpoints"><span class="std std-ref">checkpoint</span></a>.</p> <p>The context manager <code class="docutils literal notranslate"><span class="pre">__enter__</span></code> returns the <a class="reference internal" href="#trio.CancelScope" title="trio.CancelScope"><code class="xref py py-class docutils literal notranslate"><span class="pre">CancelScope</span></code></a> object itself, so you can also write <code class="docutils literal notranslate"><span class="pre">with</span> <span class="pre">trio.CancelScope()</span> <span class="pre">as</span>
<span class="pre">cancel_scope:</span></code>.</p> <p>If a cancel scope becomes cancelled before entering its <code class="docutils literal notranslate"><span class="pre">with</span></code> block, the <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> exception will be raised at the first checkpoint inside the <code class="docutils literal notranslate"><span class="pre">with</span></code> block. This allows a <a class="reference internal" href="#trio.CancelScope" title="trio.CancelScope"><code class="xref py py-class docutils literal notranslate"><span class="pre">CancelScope</span></code></a> to be created in one <a class="reference internal" href="#tasks"><span class="std std-ref">task</span></a> and passed to another, so that the first task can later cancel some work inside the second.</p> <p>Cancel scopes are not reusable or reentrant; that is, each cancel scope can be used for at most one <code class="docutils literal notranslate"><span class="pre">with</span></code> block. (You’ll get a <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#RuntimeError" title="(in Python v3.11)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RuntimeError</span></code></a> if you violate this rule.)</p> <p>The <a class="reference internal" href="#trio.CancelScope" title="trio.CancelScope"><code class="xref py py-class docutils literal notranslate"><span class="pre">CancelScope</span></code></a> constructor takes initial values for the cancel scope’s <a class="reference internal" href="#trio.CancelScope.deadline" title="trio.CancelScope.deadline"><code class="xref py py-attr docutils literal notranslate"><span class="pre">deadline</span></code></a> and <a class="reference internal" href="#trio.CancelScope.shield" title="trio.CancelScope.shield"><code class="xref py py-attr docutils literal notranslate"><span class="pre">shield</span></code></a> attributes; these may be freely modified after construction, whether or not the scope has been entered yet, and changes take immediate effect.</p> <dl class="py attribute"> <h3 class="sig sig-object py" id="trio.CancelScope.deadline"><code>deadline</code></h3> <dd>
<p>Read-write, <a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>. An absolute time on the current run’s clock at which this scope will automatically become cancelled. You can adjust the deadline by modifying this attribute, e.g.:</p> <pre data-language="python"># I need a little more time!
cancel_scope.deadline += 30</pre> <p>Note that for efficiency, the core run loop only checks for expired deadlines every once in a while. This means that in certain cases there may be a short delay between when the clock says the deadline should have expired, and when checkpoints start raising <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a>. This is a very obscure corner case that you’re unlikely to notice, but we document it for completeness. (If this <em>does</em> cause problems for you, of course, then <a class="reference external" href="https://github.com/python-trio/trio/issues">we want to know!</a>)</p> <p>Defaults to <a class="reference external" href="https://docs.python.org/3/library/math.html#math.inf" title="(in Python v3.11)"><code class="xref py py-data docutils literal notranslate"><span class="pre">math.inf</span></code></a>, which means “no deadline”, though this can be overridden by the <code class="docutils literal notranslate"><span class="pre">deadline=</span></code> argument to the <a class="reference internal" href="#trio.CancelScope" title="trio.CancelScope"><code class="xref py py-class docutils literal notranslate"><span class="pre">CancelScope</span></code></a> constructor.</p> </dd>
</dl> <dl class="py attribute"> <h3 class="sig sig-object py" id="trio.CancelScope.shield"><code>shield</code></h3> <dd>
<p>Read-write, <a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a>, default <a class="reference external" href="https://docs.python.org/3/library/constants.html#False" title="(in Python v3.11)"><code class="xref py py-data docutils literal notranslate"><span class="pre">False</span></code></a>. So long as this is set to <a class="reference external" href="https://docs.python.org/3/library/constants.html#True" title="(in Python v3.11)"><code class="xref py py-data docutils literal notranslate"><span class="pre">True</span></code></a>, then the code inside this scope will not receive <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> exceptions from scopes that are outside this scope. They can still receive <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> exceptions from (1) this scope, or (2) scopes inside this scope. You can modify this attribute:</p> <pre data-language="python">with trio.CancelScope() as cancel_scope:
    cancel_scope.shield = True
    # This cannot be interrupted by any means short of
    # killing the process:
    await sleep(10)

    cancel_scope.shield = False
    # Now this can be cancelled normally:
    await sleep(10)</pre> <p>Defaults to <a class="reference external" href="https://docs.python.org/3/library/constants.html#False" title="(in Python v3.11)"><code class="xref py py-data docutils literal notranslate"><span class="pre">False</span></code></a>, though this can be overridden by the <code class="docutils literal notranslate"><span class="pre">shield=</span></code> argument to the <a class="reference internal" href="#trio.CancelScope" title="trio.CancelScope"><code class="xref py py-class docutils literal notranslate"><span class="pre">CancelScope</span></code></a> constructor.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.CancelScope.cancel"><code>cancel()</code></h3> <dd>
<p>Cancels this scope immediately.</p> <p>This method is idempotent, i.e., if the scope was already cancelled then this method silently does nothing.</p> </dd>
</dl> <dl class="py attribute"> <h3 class="sig sig-object py" id="trio.CancelScope.cancelled_caught"><code>cancelled_caught</code></h3> <dd>
<p>Readonly <a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a>. Records whether this scope caught a <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> exception. This requires two things: (1) the <code class="docutils literal notranslate"><span class="pre">with</span></code> block exited with a <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> exception, and (2) this scope is the one that was responsible for triggering this <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> exception.</p> </dd>
</dl> <dl class="py attribute"> <h3 class="sig sig-object py" id="trio.CancelScope.cancel_called"><code>cancel_called</code></h3> <dd>
<p>Readonly <a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a>. Records whether cancellation has been requested for this scope, either by an explicit call to <a class="reference internal" href="#trio.CancelScope.cancel" title="trio.CancelScope.cancel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cancel()</span></code></a> or by the deadline expiring.</p> <p>This attribute being True does <em>not</em> necessarily mean that the code within the scope has been, or will be, affected by the cancellation. For example, if <a class="reference internal" href="#trio.CancelScope.cancel" title="trio.CancelScope.cancel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cancel()</span></code></a> was called after the last checkpoint in the <code class="docutils literal notranslate"><span class="pre">with</span></code> block, when it’s too late to deliver a <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> exception, then this attribute will still be True.</p> <p>This attribute is mostly useful for debugging and introspection. If you want to know whether or not a chunk of code was actually cancelled, then <a class="reference internal" href="#trio.CancelScope.cancelled_caught" title="trio.CancelScope.cancelled_caught"><code class="xref py py-attr docutils literal notranslate"><span class="pre">cancelled_caught</span></code></a> is usually more appropriate.</p> </dd>
</dl> </dd>
</dl> <p>Often there is no need to create <a class="reference internal" href="#trio.CancelScope" title="trio.CancelScope"><code class="xref py py-class docutils literal notranslate"><span class="pre">CancelScope</span></code></a> object. Trio already includes <a class="reference internal" href="#trio.Nursery.cancel_scope" title="trio.Nursery.cancel_scope"><code class="xref py py-attr docutils literal notranslate"><span class="pre">cancel_scope</span></code></a> attribute in a task-related <a class="reference internal" href="#trio.Nursery" title="trio.Nursery"><code class="xref py py-class docutils literal notranslate"><span class="pre">Nursery</span></code></a> object. We will cover nurseries later in the manual.</p> <p>Trio also provides several convenience functions for the common situation of just wanting to impose a timeout on some code:</p> <dl class="py function"> <h3 class="sig sig-object py" id="trio.move_on_after"><code><em>with</em> trio.move_on_after(seconds: float) → CancelScope as cancel_scope</code></h3> <dd>
<p>Use as a context manager to create a cancel scope whose deadline is set to now + <em>seconds</em>.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><strong>seconds</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – The timeout.</p> </dd> <h4 class="field-even" style="margin: 0">Raises<span class="colon">:</span>
</h4> <dd class="field-even">
<p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.11)"><strong>ValueError</strong></a> – if timeout is less than zero or NaN.</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 class="sig sig-object py" id="trio.move_on_at"><code><em>with</em> trio.move_on_at(deadline: float) → CancelScope as cancel_scope</code></h3> <dd>
<p>Use as a context manager to create a cancel scope with the given absolute deadline.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><strong>deadline</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – The deadline.</p> </dd> <h4 class="field-even" style="margin: 0">Raises<span class="colon">:</span>
</h4> <dd class="field-even">
<p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.11)"><strong>ValueError</strong></a> – if deadline is NaN.</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 class="sig sig-object py" id="trio.fail_after"><code><em>with</em> trio.fail_after(seconds: float) → AbstractContextManager[CancelScope] as cancel_scope</code></h3> <dd>
<p>Creates a cancel scope with the given timeout, and raises an error if it is actually cancelled.</p> <p>This function and <a class="reference internal" href="#trio.move_on_after" title="trio.move_on_after"><code class="xref py py-func docutils literal notranslate"><span class="pre">move_on_after()</span></code></a> are similar in that both create a cancel scope with a given timeout, and if the timeout expires then both will cause <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> to be raised within the scope. The difference is that when the <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> exception reaches <a class="reference internal" href="#trio.move_on_after" title="trio.move_on_after"><code class="xref py py-func docutils literal notranslate"><span class="pre">move_on_after()</span></code></a>, it’s caught and discarded. When it reaches <a class="reference internal" href="#trio.fail_after" title="trio.fail_after"><code class="xref py py-func docutils literal notranslate"><span class="pre">fail_after()</span></code></a>, then it’s caught and <a class="reference internal" href="#trio.TooSlowError" title="trio.TooSlowError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TooSlowError</span></code></a> is raised in its place.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><strong>seconds</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – The timeout.</p> </dd> <h4 class="field-even" style="margin: 0">Raises<span class="colon">:</span>
</h4> <dd class="field-even">
<ul class="simple"> <li><p><a class="reference internal" href="#trio.TooSlowError" title="trio.TooSlowError"><strong>TooSlowError</strong></a> – if a <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> exception is raised in this scope and caught by the context manager.</p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.11)"><strong>ValueError</strong></a> – if <em>seconds</em> is less than zero or NaN.</p></li> </ul> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 class="sig sig-object py" id="trio.fail_at"><code><em>with</em> trio.fail_at(deadline: float) → AbstractContextManager[CancelScope] as cancel_scope</code></h3> <dd>
<p>Creates a cancel scope with the given deadline, and raises an error if it is actually cancelled.</p> <p>This function and <a class="reference internal" href="#trio.move_on_at" title="trio.move_on_at"><code class="xref py py-func docutils literal notranslate"><span class="pre">move_on_at()</span></code></a> are similar in that both create a cancel scope with a given absolute deadline, and if the deadline expires then both will cause <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> to be raised within the scope. The difference is that when the <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> exception reaches <a class="reference internal" href="#trio.move_on_at" title="trio.move_on_at"><code class="xref py py-func docutils literal notranslate"><span class="pre">move_on_at()</span></code></a>, it’s caught and discarded. When it reaches <a class="reference internal" href="#trio.fail_at" title="trio.fail_at"><code class="xref py py-func docutils literal notranslate"><span class="pre">fail_at()</span></code></a>, then it’s caught and <a class="reference internal" href="#trio.TooSlowError" title="trio.TooSlowError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TooSlowError</span></code></a> is raised in its place.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><strong>deadline</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – The deadline.</p> </dd> <h4 class="field-even" style="margin: 0">Raises<span class="colon">:</span>
</h4> <dd class="field-even">
<ul class="simple"> <li><p><a class="reference internal" href="#trio.TooSlowError" title="trio.TooSlowError"><strong>TooSlowError</strong></a> – if a <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> exception is raised in this scope and caught by the context manager.</p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.11)"><strong>ValueError</strong></a> – if deadline is NaN.</p></li> </ul> </dd> </dl> </dd>
</dl> <p>Cheat sheet:</p> <ul> <li>
<p>If you want to impose a timeout on a function, but you don’t care whether it timed out or not:</p> <pre data-language="python">with trio.move_on_after(TIMEOUT):
    await do_whatever()
# carry on!</pre> </li> <li>
<p>If you want to impose a timeout on a function, and then do some recovery if it timed out:</p> <pre data-language="python">with trio.move_on_after(TIMEOUT) as cancel_scope:
    await do_whatever()
if cancel_scope.cancelled_caught:
    # The operation timed out, try something else
    try_to_recover()</pre> </li> <li>
<p>If you want to impose a timeout on a function, and then if it times out then just give up and raise an error for your caller to deal with:</p> <pre data-language="python">with trio.fail_after(TIMEOUT):
    await do_whatever()</pre> </li> </ul> <p>It’s also possible to check what the current effective deadline is, which is sometimes useful:</p> <dl class="py function"> <h3 class="sig sig-object py" id="trio.current_effective_deadline"><code>trio.current_effective_deadline()</code></h3> <dd>
<p>Returns the current effective deadline for the current task.</p> <p>This function examines all the cancellation scopes that are currently in effect (taking into account shielding), and returns the deadline that will expire first.</p> <p>One example of where this might be is useful is if your code is trying to decide whether to begin an expensive operation like an RPC call, but wants to skip it if it knows that it can’t possibly complete in the available time. Another example would be if you’re using a protocol like gRPC that <a class="reference external" href="http://www.grpc.io/docs/guides/concepts.html#deadlines">propagates timeout information to the remote peer</a>; this function gives a way to fetch that information so you can send it along.</p> <p>If this is called in a context where a cancellation is currently active (i.e., a blocking call will immediately raise <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a>), then returned deadline is <code class="docutils literal notranslate"><span class="pre">-inf</span></code>. If it is called in a context where no scopes have a deadline set, it returns <code class="docutils literal notranslate"><span class="pre">inf</span></code>.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Returns<span class="colon">:</span>
</h4> <dd class="field-odd">
<p>the effective deadline, as an absolute time.</p> </dd> <h4 class="field-even" style="margin: 0">Return type<span class="colon">:</span>
</h4> <dd class="field-even">
<p><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)">float</a></p> </dd> </dl> </dd>
</dl> </section> </section> <section id="tasks-let-you-do-multiple-things-at-once"> <h2>Tasks let you do multiple things at once</h2> <p>One of Trio’s core design principles is: <em>no implicit concurrency</em>. Every function executes in a straightforward, top-to-bottom manner, finishing each operation before moving on to the next – <em>like Guido intended</em>.</p> <p>But, of course, the entire point of an async library is to let you do multiple things at once. The one and only way to do that in Trio is through the task spawning interface. So if you want your program to walk <em>and</em> chew gum, this is the section for you.</p> <section id="nurseries-and-spawning"> <h3>Nurseries and spawning</h3> <p>Most libraries for concurrent programming let you start new child tasks (or threads, or whatever) willy-nilly, whenever and where-ever you feel like it. Trio is a bit different: you can’t start a child task unless you’re prepared to be a responsible parent. The way you demonstrate your responsibility is by creating a nursery:</p> <pre data-language="python">async with trio.open_nursery() as nursery:
    ...</pre> <p>And once you have a reference to a nursery object, you can start children in that nursery:</p> <pre data-language="python">async def child():
    ...

async def parent():
    async with trio.open_nursery() as nursery:
        # Make two concurrent calls to child()
        nursery.start_soon(child)
        nursery.start_soon(child)</pre> <p>This means that tasks form a tree: when you call <a class="reference internal" href="#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">run()</span></code></a>, then this creates an initial task, and all your other tasks will be children, grandchildren, etc. of the initial task.</p> <p>Essentially, the body of the <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> block acts like an initial task that’s running inside the nursery, and then each call to <code class="docutils literal notranslate"><span class="pre">nursery.start_soon</span></code> adds another task that runs in parallel. Two crucial things to keep in mind:</p> <ul class="simple"> <li><p>If any task inside the nursery finishes with an unhandled exception, then the nursery immediately cancels all the tasks inside the nursery.</p></li> <li><p>Since all of the tasks are running concurrently inside the <code class="docutils literal notranslate"><span class="pre">async</span>
<span class="pre">with</span></code> block, the block does not exit until <em>all</em> tasks have completed. If you’ve used other concurrency frameworks, then you can think of it as, the de-indentation at the end of the <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> automatically “joins” (waits for) all of the tasks in the nursery.</p></li> <li>
<p>Once all the tasks have finished, then:</p> <ul> <li><p>The nursery is marked as “closed”, meaning that no new tasks can be started inside it.</p></li> <li><p>Any unhandled exceptions are re-raised inside the parent task. If there are multiple exceptions, then they’re collected up into a single <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#BaseExceptionGroup" title="(in Python v3.11)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BaseExceptionGroup</span></code></a> or <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ExceptionGroup" title="(in Python v3.11)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ExceptionGroup</span></code></a> exception.</p></li> </ul> </li> </ul> <p>Since all tasks are descendents of the initial task, one consequence of this is that <a class="reference internal" href="#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">run()</span></code></a> can’t finish until all tasks have finished.</p> <blockquote class="admonition note"> <h4 class="admonition-title">Note</h4> <p>A return statement will not cancel the nursery if it still has tasks running:</p> <pre data-language="python">async def main():
    async with trio.open_nursery() as nursery:
        nursery.start_soon(trio.sleep, 5)
        return

trio.run(main)</pre> <p>This code will wait 5 seconds (for the child task to finish), and then return.</p> </blockquote> </section> <section id="child-tasks-and-cancellation"> <h3>Child tasks and cancellation</h3> <p>In Trio, child tasks inherit the parent nursery’s cancel scopes. So in this example, both the child tasks will be cancelled when the timeout expires:</p> <pre data-language="python">with trio.move_on_after(TIMEOUT):
    async with trio.open_nursery() as nursery:
        nursery.start_soon(child1)
        nursery.start_soon(child2)</pre> <p>Note that what matters here is the scopes that were active when <a class="reference internal" href="#trio.open_nursery" title="trio.open_nursery"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_nursery()</span></code></a> was called, <em>not</em> the scopes active when <code class="docutils literal notranslate"><span class="pre">start_soon</span></code> is called. So for example, the timeout block below does nothing at all:</p> <pre data-language="python">async with trio.open_nursery() as nursery:
    with trio.move_on_after(TIMEOUT):  # don't do this!
        nursery.start_soon(child)</pre> <p>Why is this so? Well, <code class="docutils literal notranslate"><span class="pre">start_soon()</span></code> returns as soon as it has scheduled the new task to start running. The flow of execution in the parent then continues on to exit the <code class="docutils literal notranslate"><span class="pre">with</span> <span class="pre">trio.move_on_after(TIMEOUT):</span></code> block, at which point Trio forgets about the timeout entirely. In order for the timeout to apply to the child task, Trio must be able to tell that its associated cancel scope will stay open for at least as long as the child task is executing. And Trio can only know that for sure if the cancel scope block is outside the nursery block.</p> <p>You might wonder why Trio can’t just remember “this task should be cancelled in <code class="docutils literal notranslate"><span class="pre">TIMEOUT</span></code> seconds”, even after the <code class="docutils literal notranslate"><span class="pre">with</span> <span class="pre">trio.move_on_after(TIMEOUT):</span></code> block is gone. The reason has to do with <a class="reference internal" href="#cancellation"><span class="std std-ref">how cancellation is implemented</span></a>. Recall that cancellation is represented by a <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Cancelled</span></code></a> exception, which eventually needs to be caught by the cancel scope that caused it. (Otherwise, the exception would take down your whole program!) In order to be able to cancel the child tasks, the cancel scope has to be able to “see” the <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Cancelled</span></code></a> exceptions that they raise – and those exceptions come out of the <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span> <span class="pre">open_nursery()</span></code> block, not out of the call to <code class="docutils literal notranslate"><span class="pre">start_soon()</span></code>.</p> <p>If you want a timeout to apply to one task but not another, then you need to put the cancel scope in that individual task’s function – <code class="docutils literal notranslate"><span class="pre">child()</span></code>, in this example.</p> </section> <section id="errors-in-multiple-child-tasks"> <h3>Errors in multiple child tasks</h3> <p>Normally, in Python, only one thing happens at a time, which means that only one thing can wrong at a time. Trio has no such limitation. Consider code like:</p> <pre data-language="python">async def broken1():
    d = {}
    return d["missing"]

async def broken2():
    seq = range(10)
    return seq[20]

async def parent():
    async with trio.open_nursery() as nursery:
        nursery.start_soon(broken1)
        nursery.start_soon(broken2)</pre> <p><code class="docutils literal notranslate"><span class="pre">broken1</span></code> raises <code class="docutils literal notranslate"><span class="pre">KeyError</span></code>. <code class="docutils literal notranslate"><span class="pre">broken2</span></code> raises <code class="docutils literal notranslate"><span class="pre">IndexError</span></code>. Obviously <code class="docutils literal notranslate"><span class="pre">parent</span></code> should raise some error, but what? The answer is that both exceptions are grouped in an <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ExceptionGroup" title="(in Python v3.11)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ExceptionGroup</span></code></a>. <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ExceptionGroup" title="(in Python v3.11)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ExceptionGroup</span></code></a> and its parent class <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#BaseExceptionGroup" title="(in Python v3.11)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BaseExceptionGroup</span></code></a> are used to encapsulate multiple exceptions being raised at once.</p> <p>To catch individual exceptions encapsulated in an exception group, the <code class="docutils literal notranslate"><span class="pre">except*</span></code> clause was introduced in Python 3.11 (<a class="pep reference external" href="https://peps.python.org/pep-0654/"><strong>PEP 654</strong></a>). Here’s how it works:</p> <pre data-language="python">try:
    async with trio.open_nursery() as nursery:
        nursery.start_soon(broken1)
        nursery.start_soon(broken2)
except* KeyError as excgroup:
    for exc in excgroup.exceptions:
        ...  # handle each KeyError
except* IndexError as excgroup:
    for exc in excgroup.exceptions:
        ...  # handle each IndexError</pre> <p>If you want to reraise exceptions, or raise new ones, you can do so, but be aware that exceptions raised in <code class="docutils literal notranslate"><span class="pre">except*</span></code> sections will be raised together in a new exception group.</p> <p>But what if you can’t use <code class="docutils literal notranslate"><span class="pre">except*</span></code> just yet? Well, for that there is the handy <a class="reference external" href="https://pypi.org/project/exceptiongroup/">exceptiongroup</a> library which lets you approximate this behavior with exception handler callbacks:</p> <pre data-language="python">from exceptiongroup import catch

def handle_keyerrors(excgroup):
    for exc in excgroup.exceptions:
        ...  # handle each KeyError

def handle_indexerrors(excgroup):
    for exc in excgroup.exceptions:
        ...  # handle each IndexError

with catch({
    KeyError: handle_keyerrors,
    IndexError: handle_indexerrors
}):
    async with trio.open_nursery() as nursery:
        nursery.start_soon(broken1)
        nursery.start_soon(broken2)</pre> <p>The semantics for the handler functions are equal to <code class="docutils literal notranslate"><span class="pre">except*</span></code> blocks, except for setting local variables. If you need to set local variables, you need to declare them inside the handler function(s) with the <code class="docutils literal notranslate"><span class="pre">nonlocal</span></code> keyword:</p> <pre data-language="python">def handle_keyerrors(excgroup):
    nonlocal myflag
    myflag = True

myflag = False
with catch({KeyError: handle_keyerrors}):
    async with trio.open_nursery() as nursery:
        nursery.start_soon(broken1)</pre> <p>For reasons of backwards compatibility, nurseries raise <code class="docutils literal notranslate"><span class="pre">trio.MultiError</span></code> and <code class="docutils literal notranslate"><span class="pre">trio.NonBaseMultiError</span></code> which inherit from <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#BaseExceptionGroup" title="(in Python v3.11)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BaseExceptionGroup</span></code></a> and <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ExceptionGroup" title="(in Python v3.11)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ExceptionGroup</span></code></a>, respectively. Users should refrain from attempting to raise or catch the Trio specific exceptions themselves, and treat them as if they were standard <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#BaseExceptionGroup" title="(in Python v3.11)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BaseExceptionGroup</span></code></a> or <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ExceptionGroup" title="(in Python v3.11)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ExceptionGroup</span></code></a> instances instead.</p> <section id="strict-versus-loose-exceptiongroup-semantics"> <h4>“Strict” versus “loose” ExceptionGroup semantics</h4> <p>Ideally, in some abstract sense we’d want everything that <em>can</em> raise an <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ExceptionGroup" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ExceptionGroup</span></code></a> to <em>always</em> raise an <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ExceptionGroup" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ExceptionGroup</span></code></a> (rather than, say, a single <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ValueError</span></code></a>). Otherwise, it would be easy to accidentally write something like <code class="docutils literal notranslate"><span class="pre">except</span>
<span class="pre">ValueError:</span></code> (not <code class="docutils literal notranslate"><span class="pre">except*</span></code>), which works if a single exception is raised but fails to catch _anything_ in the case of multiple simultaneous exceptions (even if one of them is a ValueError). However, this is not how Trio worked in the past: as a concession to practicality when the <code class="docutils literal notranslate"><span class="pre">except*</span></code> syntax hadn’t been dreamed up yet, the old <code class="docutils literal notranslate"><span class="pre">trio.MultiError</span></code> was raised only when at least two exceptions occurred simultaneously. Adding a layer of <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ExceptionGroup" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ExceptionGroup</span></code></a> around every nursery, while theoretically appealing, would probably break a lot of existing code in practice.</p> <p>Therefore, we’ve chosen to gate the newer, “stricter” behavior behind a parameter called <code class="docutils literal notranslate"><span class="pre">strict_exception_groups</span></code>. This is accepted as a parameter to <a class="reference internal" href="#trio.open_nursery" title="trio.open_nursery"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_nursery()</span></code></a>, to set the behavior for that nursery, and to <a class="reference internal" href="#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a>, to set the default behavior for any nursery in your program that doesn’t override it.</p> <ul class="simple"> <li><p>With <code class="docutils literal notranslate"><span class="pre">strict_exception_groups=True</span></code>, the exception(s) coming out of a nursery will always be wrapped in an <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ExceptionGroup" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ExceptionGroup</span></code></a>, so you’ll know that if you’re handling single errors correctly, multiple simultaneous errors will work as well.</p></li> <li><p>With <code class="docutils literal notranslate"><span class="pre">strict_exception_groups=False</span></code>, a nursery in which only one task has failed will raise that task’s exception without an additional layer of <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ExceptionGroup" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ExceptionGroup</span></code></a> wrapping, so you’ll get maximum compatibility with code that was written to support older versions of Trio.</p></li> </ul> <p>To maintain backwards compatibility, the default is <code class="docutils literal notranslate"><span class="pre">strict_exception_groups=False</span></code>. The default will eventually change to <code class="docutils literal notranslate"><span class="pre">True</span></code> in a future version of Trio, once Python 3.11 and later versions are in wide use.</p> </section> </section> <section id="spawning-tasks-without-becoming-a-parent"> <h3>Spawning tasks without becoming a parent</h3> <p>Sometimes it doesn’t make sense for the task that starts a child to take on responsibility for watching it. For example, a server task may want to start a new task for each connection, but it can’t listen for connections and supervise children at the same time.</p> <p>The solution here is simple once you see it: there’s no requirement that a nursery object stay in the task that created it! We can write code like this:</p> <pre data-language="python">async def new_connection_listener(handler, nursery):
    while True:
        conn = await get_new_connection()
        nursery.start_soon(handler, conn)

async def server(handler):
    async with trio.open_nursery() as nursery:
        nursery.start_soon(new_connection_listener, handler, nursery)</pre> <p>Notice that <code class="docutils literal notranslate"><span class="pre">server</span></code> opens a nursery and passes it to <code class="docutils literal notranslate"><span class="pre">new_connection_listener</span></code>, and then <code class="docutils literal notranslate"><span class="pre">new_connection_listener</span></code> is able to start new tasks as “siblings” of itself. Of course, in this case, we could just as well have written:</p> <pre data-language="python">async def server(handler):
    async with trio.open_nursery() as nursery:
        while True:
            conn = await get_new_connection()
            nursery.start_soon(handler, conn)</pre> <p>...but sometimes things aren’t so simple, and this trick comes in handy.</p> <p>One thing to remember, though: cancel scopes are inherited from the nursery, <strong>not</strong> from the task that calls <code class="docutils literal notranslate"><span class="pre">start_soon</span></code>. So in this example, the timeout does <em>not</em> apply to <code class="docutils literal notranslate"><span class="pre">child</span></code> (or to anything else):</p> <pre data-language="python">async def do_spawn(nursery):
    with trio.move_on_after(TIMEOUT):  # don't do this, it has no effect
        nursery.start_soon(child)

async with trio.open_nursery() as nursery:
    nursery.start_soon(do_spawn, nursery)</pre> </section> <section id="custom-supervisors"> <h3>Custom supervisors</h3> <p>The default cleanup logic is often sufficient for simple cases, but what if you want a more sophisticated supervisor? For example, maybe you have <a class="reference external" href="http://learnyousomeerlang.com/supervisors">Erlang envy</a> and want features like automatic restart of crashed tasks. Trio itself doesn’t provide these kinds of features, but you can build them on top; Trio’s goal is to enforce basic hygiene and then get out of your way. (Specifically: Trio won’t let you build a supervisor that exits and leaves orphaned tasks behind, and if you have an unhandled exception due to bugs or laziness then Trio will make sure they propagate.) And then you can wrap your fancy supervisor up in a library and put it on PyPI, because supervisors are tricky and there’s no reason everyone should have to write their own.</p> <p>For example, here’s a function that takes a list of functions, runs them all concurrently, and returns the result from the one that finishes first:</p> <pre data-language="python">async def race(*async_fns):
    if not async_fns:
        raise ValueError("must pass at least one argument")

    winner = None

    async def jockey(async_fn, cancel_scope):
        nonlocal winner
        winner = await async_fn()
        cancel_scope.cancel()

    async with trio.open_nursery() as nursery:
        for async_fn in async_fns:
            nursery.start_soon(jockey, async_fn, nursery.cancel_scope)

    return winner</pre> <p>This works by starting a set of tasks which each try to run their function. As soon as the first function completes its execution, the task will set the nonlocal variable <code class="docutils literal notranslate"><span class="pre">winner</span></code> from the outer scope to the result of the function, and cancel the other tasks using the passed in cancel scope. Once all tasks have been cancelled (which exits the nursery block), the variable <code class="docutils literal notranslate"><span class="pre">winner</span></code> will be returned.</p> <p>Here if one or more of the racing functions raises an unhandled exception then Trio’s normal handling kicks in: it cancels the others and then propagates the exception. If you want different behavior, you can get that by adding a <code class="docutils literal notranslate"><span class="pre">try</span></code> block to the <code class="docutils literal notranslate"><span class="pre">jockey</span></code> function to catch exceptions and handle them however you like.</p> </section> <section id="task-related-api-details"> <h3>Task-related API details</h3> <section id="the-nursery-api"> <h4>The nursery API</h4> <dl class="py function"> <h3 class="sig sig-object py" id="trio.open_nursery"><code><em>async with</em> trio.open_nursery(strict_exception_groups: bool | None = None) → AbstractAsyncContextManager[Nursery] as nursery</code></h3> <dd>
<p>Returns an async context manager which must be used to create a new <a class="reference internal" href="#trio.Nursery" title="trio.Nursery"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Nursery</span></code></a>.</p> <p>It does not block on entry; on exit it blocks until all child tasks have exited.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><strong>strict_exception_groups</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – If true, even a single raised exception will be wrapped in an exception group. This will eventually become the default behavior. If not specified, uses the value passed to <a class="reference internal" href="#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">run()</span></code></a>.</p> </dd> </dl> </dd>
</dl> <dl class="py class"> <h3 class="sig sig-object py" id="trio.Nursery"><code><em>class</em> trio.Nursery</code></h3> <dd>
<p>A context which may be used to spawn (or cancel) child tasks.</p> <p>Not constructed directly, use <a class="reference internal" href="#trio.open_nursery" title="trio.open_nursery"><code class="xref py py-obj docutils literal notranslate"><span class="pre">open_nursery</span></code></a> instead.</p> <p>The nursery will remain open until all child tasks have completed, or until it is cancelled, at which point it will cancel all its remaining child tasks and close.</p> <p>Nurseries ensure the absence of orphaned Tasks, since all running tasks will belong to an open Nursery.</p> <dl class="py attribute"> <h3 class="sig sig-object py" id="trio.Nursery.cancel_scope"><code>cancel_scope</code></h3> <dd>
<p>Creating a nursery also implicitly creates a cancellation scope, which is exposed as the <a class="reference internal" href="#trio.Nursery.cancel_scope" title="trio.Nursery.cancel_scope"><code class="xref py py-attr docutils literal notranslate"><span class="pre">cancel_scope</span></code></a> attribute. This is used internally to implement the logic where if an error occurs then <code class="docutils literal notranslate"><span class="pre">__aexit__</span></code> cancels all children, but you can use it for other things, e.g. if you want to explicitly cancel all children in response to some external event.</p> </dd>
</dl> <dl class="py property"> <h3 class="sig sig-object py" id="trio.Nursery.child_tasks"><code><em>property</em> child_tasks</code></h3> <dd>
<p>Contains all the child <a class="reference internal" href="reference-lowlevel.html#trio.lowlevel.Task" title="trio.lowlevel.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">Task</span></code></a> objects which are still running.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Type<span class="colon">:</span>
</h4> <dd class="field-odd">
<p>(<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#frozenset" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">frozenset</span></code></a>)</p> </dd> </dl> </dd>
</dl> <dl class="py property"> <h3 class="sig sig-object py" id="trio.Nursery.parent_task"><code><em>property</em> parent_task</code></h3> <dd>
<p>The Task that opened this nursery.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Type<span class="colon">:</span>
</h4> <dd class="field-odd">
<p>(<a class="reference internal" href="reference-lowlevel.html#trio.lowlevel.Task" title="trio.lowlevel.Task"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Task</span></code></a>)</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Nursery.start"><code><em>await</em> start(async_fn, *args, name=None)</code></h3> <dd>
<p>Creates and initializes a child task.</p> <p>Like <a class="reference internal" href="#trio.Nursery.start_soon" title="trio.Nursery.start_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">start_soon()</span></code></a>, but blocks until the new task has finished initializing itself, and optionally returns some information from it.</p> <p>The <code class="docutils literal notranslate"><span class="pre">async_fn</span></code> must accept a <code class="docutils literal notranslate"><span class="pre">task_status</span></code> keyword argument, and it must make sure that it (or someone) eventually calls <code class="docutils literal notranslate"><span class="pre">task_status.started()</span></code>.</p> <p>The conventional way to define <code class="docutils literal notranslate"><span class="pre">async_fn</span></code> is like:</p> <pre data-language="python">async def async_fn(arg1, arg2, *, task_status=trio.TASK_STATUS_IGNORED):
    ...  # Caller is blocked waiting for this code to run
    task_status.started()
    ...  # This async code can be interleaved with the caller</pre> <p><a class="reference internal" href="#trio.TASK_STATUS_IGNORED" title="trio.TASK_STATUS_IGNORED"><code class="xref py py-attr docutils literal notranslate"><span class="pre">trio.TASK_STATUS_IGNORED</span></code></a> is a special global object with a do-nothing <code class="docutils literal notranslate"><span class="pre">started</span></code> method. This way your function supports being called either like <code class="docutils literal notranslate"><span class="pre">await</span> <span class="pre">nursery.start(async_fn,</span> <span class="pre">arg1,</span>
<span class="pre">arg2)</span></code> or directly like <code class="docutils literal notranslate"><span class="pre">await</span> <span class="pre">async_fn(arg1,</span> <span class="pre">arg2)</span></code>, and either way it can call <code class="docutils literal notranslate"><span class="pre">task_status.started()</span></code> without worrying about which mode it’s in. Defining your function like this will make it obvious to readers that it supports being used in both modes.</p> <p>Before the child calls <code class="docutils literal notranslate"><span class="pre">task_status.started()</span></code>, it’s effectively run underneath the call to <a class="reference internal" href="#trio.Nursery.start" title="trio.Nursery.start"><code class="xref py py-meth docutils literal notranslate"><span class="pre">start()</span></code></a>: if it raises an exception then that exception is reported by <a class="reference internal" href="#trio.Nursery.start" title="trio.Nursery.start"><code class="xref py py-meth docutils literal notranslate"><span class="pre">start()</span></code></a>, and does <em>not</em> propagate out of the nursery. If <a class="reference internal" href="#trio.Nursery.start" title="trio.Nursery.start"><code class="xref py py-meth docutils literal notranslate"><span class="pre">start()</span></code></a> is cancelled, then the child task is also cancelled.</p> <p>When the child calls <code class="docutils literal notranslate"><span class="pre">task_status.started()</span></code>, it’s moved out from underneath <a class="reference internal" href="#trio.Nursery.start" title="trio.Nursery.start"><code class="xref py py-meth docutils literal notranslate"><span class="pre">start()</span></code></a> and into the given nursery.</p> <p>If the child task passes a value to <code class="docutils literal notranslate"><span class="pre">task_status.started(value)</span></code>, then <a class="reference internal" href="#trio.Nursery.start" title="trio.Nursery.start"><code class="xref py py-meth docutils literal notranslate"><span class="pre">start()</span></code></a> returns this value. Otherwise it returns <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Nursery.start_soon"><code>start_soon(async_fn, *args, name=None)</code></h3> <dd>
<p>Creates a child task, scheduling <code class="docutils literal notranslate"><span class="pre">await</span> <span class="pre">async_fn(*args)</span></code>.</p> <p>If you want to run a function and immediately wait for its result, then you don’t need a nursery; just use <code class="docutils literal notranslate"><span class="pre">await</span> <span class="pre">async_fn(*args)</span></code>. If you want to wait for the task to initialize itself before continuing, see <a class="reference internal" href="#trio.Nursery.start" title="trio.Nursery.start"><code class="xref py py-meth docutils literal notranslate"><span class="pre">start()</span></code></a>, the other fundamental method for creating concurrent tasks in Trio.</p> <p>Note that this is <em>not</em> an async function and you don’t use await when calling it. It sets up the new task, but then returns immediately, <em>before</em> the new task has a chance to do anything. New tasks may start running in any order, and at any checkpoint the scheduler chooses - at latest when the nursery is waiting to exit.</p> <p>It’s possible to pass a nursery object into another task, which allows that task to start new child tasks in the first task’s nursery.</p> <p>The child task inherits its parent nursery’s cancel scopes.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<ul class="simple"> <li><p><strong>async_fn</strong> – An async callable.</p></li> <li><p><strong>args</strong> – Positional arguments for <code class="docutils literal notranslate"><span class="pre">async_fn</span></code>. If you want to pass keyword arguments, use <a class="reference external" href="https://docs.python.org/3/library/functools.html#functools.partial" title="(in Python v3.11)"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.partial()</span></code></a>.</p></li> <li><p><strong>name</strong> – The name for this task. Only used for debugging/introspection (e.g. <code class="docutils literal notranslate"><span class="pre">repr(task_obj)</span></code>). If this isn’t a string, <a class="reference internal" href="#trio.Nursery.start_soon" title="trio.Nursery.start_soon"><code class="xref py py-meth docutils literal notranslate"><span class="pre">start_soon()</span></code></a> will try to make it one. A common use case is if you’re wrapping a function before spawning a new task, you might pass the original function as the <code class="docutils literal notranslate"><span class="pre">name=</span></code> to make debugging easier.</p></li> </ul> </dd> <h4 class="field-even" style="margin: 0">Raises<span class="colon">:</span>
</h4> <dd class="field-even">
<p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#RuntimeError" title="(in Python v3.11)"><strong>RuntimeError</strong></a> – If this nursery is no longer open (i.e. its <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> block has exited).</p> </dd> </dl> </dd>
</dl> </dd>
</dl> <dl class="py attribute"> <h3 class="sig sig-object py" id="trio.TASK_STATUS_IGNORED"><code>trio.TASK_STATUS_IGNORED</code></h3> <dd>
<p>See <a class="reference internal" href="#trio.Nursery.start" title="trio.Nursery.start"><code class="xref py py-meth docutils literal notranslate"><span class="pre">start()</span></code></a>.</p> </dd>
</dl> </section> </section> </section> <section id="task-local-storage"> <h2>Task-local storage</h2> <p>Suppose you’re writing a server that responds to network requests, and you log some information about each request as you process it. If the server is busy and there are multiple requests being handled at the same time, then you might end up with logs like this:</p> <pre>Request handler started
Request handler started
Request handler finished
Request handler finished</pre> <p>In this log, it’s hard to know which lines came from which request. (Did the request that started first also finish first, or not?) One way to solve this is to assign each request a unique identifier, and then include this identifier in each log message:</p> <pre>request 1: Request handler started
request 2: Request handler started
request 2: Request handler finished
request 1: Request handler finished</pre> <p>This way we can see that request 1 was slow: it started before request 2 but finished afterwards. (You can also get <a class="reference external" href="https://opentracing.io/docs/">much fancier</a>, but this is enough for an example.)</p> <p>Now, here’s the problem: how does the logging code know what the request identifier is? One approach would be to explicitly pass it around to every function that might want to emit logs… but that’s basically every function, because you never know when you might need to add a <code class="docutils literal notranslate"><span class="pre">log.debug(...)</span></code> call to some utility function buried deep in the call stack, and when you’re in the middle of a debugging a nasty problem that last thing you want is to have to stop first and refactor everything to pass through the request identifier! Sometimes this is the right solution, but other times it would be much more convenient if we could store the identifier in a global variable, so that the logging function could look it up whenever it needed it. Except… a global variable can only have one value at a time, so if we have multiple handlers running at once then this isn’t going to work. What we need is something that’s <em>like</em> a global variable, but that can have different values depending on which request handler is accessing it.</p> <p>To solve this problem, Python 3.7 added a new module to the standard library: <a class="reference external" href="https://docs.python.org/3/library/contextvars.html#module-contextvars" title="(in Python v3.11)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">contextvars</span></code></a>. And not only does Trio have built-in support for <a class="reference external" href="https://docs.python.org/3/library/contextvars.html#module-contextvars" title="(in Python v3.11)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">contextvars</span></code></a>, but if you’re using an earlier version of Python, then Trio makes sure that a backported version of <a class="reference external" href="https://docs.python.org/3/library/contextvars.html#module-contextvars" title="(in Python v3.11)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">contextvars</span></code></a> is installed. So you can assume <a class="reference external" href="https://docs.python.org/3/library/contextvars.html#module-contextvars" title="(in Python v3.11)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">contextvars</span></code></a> is there and works regardless of what version of Python you’re using.</p> <p>Here’s a toy example demonstrating how to use <a class="reference external" href="https://docs.python.org/3/library/contextvars.html#module-contextvars" title="(in Python v3.11)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">contextvars</span></code></a>:</p> <pre data-language="python">import random
import trio
import contextvars

request_info = contextvars.ContextVar("request_info")


# Example logging function that tags each line with the request identifier.
def log(msg):
    # Read from task-local storage:
    request_tag = request_info.get()

    print(f"request {request_tag}: {msg}")


# An example "request handler" that does some work itself and also
# spawns some helper tasks to do some concurrent work.
async def handle_request(tag):
    # Write to task-local storage:
    request_info.set(tag)

    log("Request handler started")
    await trio.sleep(random.random())
    async with trio.open_nursery() as nursery:
        nursery.start_soon(concurrent_helper, "a")
        nursery.start_soon(concurrent_helper, "b")
    await trio.sleep(random.random())
    log("Request received finished")


async def concurrent_helper(job):
    log(f"Helper task {job} started")
    await trio.sleep(random.random())
    log(f"Helper task {job} finished")


# Spawn several "request handlers" simultaneously, to simulate a
# busy server handling multiple requests at the same time.
async def main():
    async with trio.open_nursery() as nursery:
        for i in range(3):
            nursery.start_soon(handle_request, i)


trio.run(main)</pre> <p>Example output (yours may differ slightly):</p> <pre>request 1: Request handler started
request 2: Request handler started
request 0: Request handler started
request 2: Helper task a started
request 2: Helper task b started
request 1: Helper task a started
request 1: Helper task b started
request 0: Helper task b started
request 0: Helper task a started
request 2: Helper task b finished
request 2: Helper task a finished
request 2: Request received finished
request 0: Helper task a finished
request 1: Helper task a finished
request 1: Helper task b finished
request 1: Request received finished
request 0: Helper task b finished
request 0: Request received finished</pre> <p>For more information, read the <a class="reference external" href="https://docs.python.org/3.7/library/contextvars.html">contextvars docs</a>.</p> </section> <section id="synchronizing-and-communicating-between-tasks"> <h2>Synchronizing and communicating between tasks</h2> <p>Trio provides a standard set of synchronization and inter-task communication primitives. These objects’ APIs are generally modelled off of the analogous classes in the standard library, but with some differences.</p> <section id="blocking-and-non-blocking-methods"> <h3>Blocking and non-blocking methods</h3> <p>The standard library synchronization primitives have a variety of mechanisms for specifying timeouts and blocking behavior, and of signaling whether an operation returned due to success versus a timeout.</p> <p>In Trio, we standardize on the following conventions:</p> <ul class="simple"> <li><p>We don’t provide timeout arguments. If you want a timeout, then use a cancel scope.</p></li> <li><p>For operations that have a non-blocking variant, the blocking and non-blocking variants are different methods with names like <code class="docutils literal notranslate"><span class="pre">X</span></code> and <code class="docutils literal notranslate"><span class="pre">X_nowait</span></code>, respectively. (This is similar to <a class="reference external" href="https://docs.python.org/3/library/queue.html#queue.Queue" title="(in Python v3.11)"><code class="xref py py-class docutils literal notranslate"><span class="pre">queue.Queue</span></code></a>, but unlike most of the classes in <a class="reference external" href="https://docs.python.org/3/library/threading.html#module-threading" title="(in Python v3.11)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a>.) We like this approach because it allows us to make the blocking version async and the non-blocking version sync.</p></li> <li><p>When a non-blocking method cannot succeed (the channel is empty, the lock is already held, etc.), then it raises <a class="reference internal" href="#trio.WouldBlock" title="trio.WouldBlock"><code class="xref py py-exc docutils literal notranslate"><span class="pre">trio.WouldBlock</span></code></a>. There’s no equivalent to the <a class="reference external" href="https://docs.python.org/3/library/queue.html#queue.Empty" title="(in Python v3.11)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">queue.Empty</span></code></a> versus <a class="reference external" href="https://docs.python.org/3/library/queue.html#queue.Full" title="(in Python v3.11)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">queue.Full</span></code></a> distinction – we just have the one exception that we use consistently.</p></li> </ul> </section> <section id="fairness"> <h3>Fairness</h3> <p>These classes are all guaranteed to be “fair”, meaning that when it comes time to choose who will be next to acquire a lock, get an item from a queue, etc., then it always goes to the task which has been waiting longest. It’s <a class="reference external" href="https://github.com/python-trio/trio/issues/54">not entirely clear</a> whether this is the best choice, but for now that’s how it works.</p> <p>As an example of what this means, here’s a small program in which two tasks compete for a lock. Notice that the task which releases the lock always immediately attempts to re-acquire it, before the other task has a chance to run. (And remember that we’re doing cooperative multi-tasking here, so it’s actually <em>deterministic</em> that the task releasing the lock will call <a class="reference internal" href="#trio.Lock.acquire" title="trio.Lock.acquire"><code class="xref py py-meth docutils literal notranslate"><span class="pre">acquire()</span></code></a> before the other task wakes up; in Trio releasing a lock is not a checkpoint.) With an unfair lock, this would result in the same task holding the lock forever and the other task being starved out. But if you run this, you’ll see that the two tasks politely take turns:</p> <pre data-language="python"># fairness-demo.py

import trio

async def loopy_child(number, lock):
    while True:
        async with lock:
            print(f"Child {number} has the lock!")
            await trio.sleep(0.5)

async def main():
    async with trio.open_nursery() as nursery:
        lock = trio.Lock()
        nursery.start_soon(loopy_child, 1, lock)
        nursery.start_soon(loopy_child, 2, lock)

trio.run(main)</pre> </section> <section id="broadcasting-an-event-with-event"> <h3>Broadcasting an event with <a class="reference internal" href="#trio.Event" title="trio.Event"><code class="xref py py-class docutils literal notranslate"><span class="pre">Event</span></code></a>
</h3> <dl class="py class"> <h3 class="sig sig-object py" id="trio.Event"><code><em>class</em> trio.Event</code></h3> <dd>
<p>A waitable boolean value useful for inter-task synchronization, inspired by <a class="reference external" href="https://docs.python.org/3/library/threading.html#threading.Event" title="(in Python v3.11)"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.Event</span></code></a>.</p> <p>An event object has an internal boolean flag, representing whether the event has happened yet. The flag is initially False, and the <a class="reference internal" href="#trio.Event.wait" title="trio.Event.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait()</span></code></a> method waits until the flag is True. If the flag is already True, then <a class="reference internal" href="#trio.Event.wait" title="trio.Event.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait()</span></code></a> returns immediately. (If the event has already happened, there’s nothing to wait for.) The <a class="reference internal" href="#trio.Event.set" title="trio.Event.set"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set()</span></code></a> method sets the flag to True, and wakes up any waiters.</p> <p>This behavior is useful because it helps avoid race conditions and lost wakeups: it doesn’t matter whether <a class="reference internal" href="#trio.Event.set" title="trio.Event.set"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set()</span></code></a> gets called just before or after <a class="reference internal" href="#trio.Event.wait" title="trio.Event.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait()</span></code></a>. If you want a lower-level wakeup primitive that doesn’t have this protection, consider <a class="reference internal" href="#trio.Condition" title="trio.Condition"><code class="xref py py-class docutils literal notranslate"><span class="pre">Condition</span></code></a> or <a class="reference internal" href="reference-lowlevel.html#trio.lowlevel.ParkingLot" title="trio.lowlevel.ParkingLot"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.lowlevel.ParkingLot</span></code></a>.</p> <blockquote class="admonition note"> <h4 class="admonition-title">Note</h4> <p>Unlike <a class="reference external" href="https://docs.python.org/3/library/threading.html#threading.Event" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">threading.Event</span></code></a>, <a class="reference internal" href="#trio.Event" title="trio.Event"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.Event</span></code></a> has no <a class="reference external" href="https://docs.python.org/3/library/threading.html#threading.Event.clear" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">clear</span></code></a> method. In Trio, once an <a class="reference internal" href="#trio.Event" title="trio.Event"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Event</span></code></a> has happened, it cannot un-happen. If you need to represent a series of events, consider creating a new <a class="reference internal" href="#trio.Event" title="trio.Event"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Event</span></code></a> object for each one (they’re cheap!), or other synchronization methods like <a class="reference internal" href="#channels"><span class="std std-ref">channels</span></a> or <a class="reference internal" href="reference-lowlevel.html#trio.lowlevel.ParkingLot" title="trio.lowlevel.ParkingLot"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.lowlevel.ParkingLot</span></code></a>.</p> </blockquote> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Event.is_set"><code>is_set()</code></h3> <dd>
<p>Return the current value of the internal flag.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Event.set"><code>set()</code></h3> <dd>
<p>Set the internal flag value to True, and wake any waiting tasks.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Event.statistics"><code>statistics()</code></h3> <dd>
<p>Return an object containing debugging information.</p> <p>Currently the following fields are defined:</p> <ul class="simple"> <li><p><code class="docutils literal notranslate"><span class="pre">tasks_waiting</span></code>: The number of tasks blocked on this event’s <a class="reference internal" href="#trio.Event.wait" title="trio.Event.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait()</span></code></a> method.</p></li> </ul> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Event.wait"><code><em>await</em> wait()</code></h3> <dd>
<p>Block until the internal flag value becomes True.</p> <p>If it’s already True, then this method returns immediately.</p> </dd>
</dl> </dd>
</dl> </section> <section id="using-channels-to-pass-values-between-tasks"> <h3>Using channels to pass values between tasks</h3> <p><em>Channels</em> allow you to safely and conveniently send objects between different tasks. They’re particularly useful for implementing producer/consumer patterns.</p> <p>The core channel API is defined by the abstract base classes <a class="reference internal" href="reference-io.html#trio.abc.SendChannel" title="trio.abc.SendChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.abc.SendChannel</span></code></a> and <a class="reference internal" href="reference-io.html#trio.abc.ReceiveChannel" title="trio.abc.ReceiveChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.abc.ReceiveChannel</span></code></a>. You can use these to implement your own custom channels, that do things like pass objects between processes or over the network. But in many cases, you just want to pass objects between different tasks inside a single process, and for that you can use <a class="reference internal" href="#trio.open_memory_channel" title="trio.open_memory_channel"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.open_memory_channel()</span></code></a>:</p> <dl class="py function"> <h3 class="sig sig-object py" id="trio.open_memory_channel"><code>trio.open_memory_channel(max_buffer_size)</code></h3> <dd>
<p>Open a channel for passing objects between tasks within a process.</p> <p>Memory channels are lightweight, cheap to allocate, and entirely in-memory. They don’t involve any operating-system resources, or any kind of serialization. They just pass Python objects directly between tasks (with a possible stop in an internal buffer along the way).</p> <p>Channel objects can be closed by calling <a class="reference internal" href="reference-io.html#trio.abc.AsyncResource.aclose" title="trio.abc.AsyncResource.aclose"><code class="xref py py-obj docutils literal notranslate"><span class="pre">aclose</span></code></a> or using <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code>. They are <em>not</em> automatically closed when garbage collected. Closing memory channels isn’t mandatory, but it is generally a good idea, because it helps avoid situations where tasks get stuck waiting on a channel when there’s no-one on the other side. See <a class="reference internal" href="#channel-shutdown"><span class="std std-ref">Clean shutdown with channels</span></a> for details.</p> <p>Memory channel operations are all atomic with respect to cancellation, either <a class="reference internal" href="reference-io.html#trio.abc.ReceiveChannel.receive" title="trio.abc.ReceiveChannel.receive"><code class="xref py py-obj docutils literal notranslate"><span class="pre">receive</span></code></a> will successfully return an object, or it will raise <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> while leaving the channel unchanged.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><strong>max_buffer_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em> or </em><em>math.inf</em>) – The maximum number of items that can be buffered in the channel before <a class="reference internal" href="reference-io.html#trio.abc.SendChannel.send" title="trio.abc.SendChannel.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> blocks. Choosing a sensible value here is important to ensure that backpressure is communicated promptly and avoid unnecessary latency; see <a class="reference internal" href="#channel-buffering"><span class="std std-ref">Buffering in channels</span></a> for more details. If in doubt, use 0.</p> </dd> <h4 class="field-even" style="margin: 0">Returns<span class="colon">:</span>
</h4> <dd class="field-even">
<p>A pair <code class="docutils literal notranslate"><span class="pre">(send_channel,</span> <span class="pre">receive_channel)</span></code>. If you have trouble remembering which order these go in, remember: data flows from left → right.</p> </dd> </dl> <p>In addition to the standard channel methods, all memory channel objects provide a <code class="docutils literal notranslate"><span class="pre">statistics()</span></code> method, which returns an object with the following fields:</p> <ul class="simple"> <li><p><code class="docutils literal notranslate"><span class="pre">current_buffer_used</span></code>: The number of items currently stored in the channel buffer.</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">max_buffer_size</span></code>: The maximum number of items allowed in the buffer, as passed to <a class="reference internal" href="#trio.open_memory_channel" title="trio.open_memory_channel"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_memory_channel()</span></code></a>.</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">open_send_channels</span></code>: The number of open <a class="reference internal" href="#trio.MemorySendChannel" title="trio.MemorySendChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemorySendChannel</span></code></a> endpoints pointing to this channel. Initially 1, but can be increased by <a class="reference internal" href="#trio.MemorySendChannel.clone" title="trio.MemorySendChannel.clone"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MemorySendChannel.clone()</span></code></a>.</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">open_receive_channels</span></code>: Likewise, but for open <a class="reference internal" href="#trio.MemoryReceiveChannel" title="trio.MemoryReceiveChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemoryReceiveChannel</span></code></a> endpoints.</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">tasks_waiting_send</span></code>: The number of tasks blocked in <code class="docutils literal notranslate"><span class="pre">send</span></code> on this channel (summing over all clones).</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">tasks_waiting_receive</span></code>: The number of tasks blocked in <code class="docutils literal notranslate"><span class="pre">receive</span></code> on this channel (summing over all clones).</p></li> </ul> </dd>
</dl> <blockquote class="admonition note"> <h4 class="admonition-title">Note</h4> <p>If you’ve used the <a class="reference external" href="https://docs.python.org/3/library/threading.html#module-threading" title="(in Python v3.11)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a> or <a class="reference external" href="https://docs.python.org/3/library/asyncio.html#module-asyncio" title="(in Python v3.11)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">asyncio</span></code></a> modules, you may be familiar with <a class="reference external" href="https://docs.python.org/3/library/queue.html#queue.Queue" title="(in Python v3.11)"><code class="xref py py-class docutils literal notranslate"><span class="pre">queue.Queue</span></code></a> or <a class="reference external" href="https://docs.python.org/3/library/asyncio-queue.html#asyncio.Queue" title="(in Python v3.11)"><code class="xref py py-class docutils literal notranslate"><span class="pre">asyncio.Queue</span></code></a>. In Trio, <a class="reference internal" href="#trio.open_memory_channel" title="trio.open_memory_channel"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_memory_channel()</span></code></a> is what you use when you’re looking for a queue. The main difference is that Trio splits the classic queue interface up into two objects. The advantage of this is that it makes it possible to put the two ends in different processes without rewriting your code, and that we can close the two sides separately.</p> </blockquote> <p><a class="reference internal" href="#trio.MemorySendChannel" title="trio.MemorySendChannel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MemorySendChannel</span></code></a> and <a class="reference internal" href="#trio.MemoryReceiveChannel" title="trio.MemoryReceiveChannel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MemoryReceiveChannel</span></code></a> also expose several more features beyond the core channel interface:</p> <dl class="py class"> <h3 class="sig sig-object py" id="trio.MemorySendChannel"><code><em>class</em> trio.MemorySendChannel(*args: object, **kwargs: object)</code></h3> <dd>
<dl class="py method"> <h3 class="sig sig-object py" id="trio.MemorySendChannel.clone"><code>clone() → MemorySendChannel[SendType]</code></h3> <dd>
<p>Clone this send channel object.</p> <p>This returns a new <a class="reference internal" href="#trio.MemorySendChannel" title="trio.MemorySendChannel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MemorySendChannel</span></code></a> object, which acts as a duplicate of the original: sending on the new object does exactly the same thing as sending on the old object. (If you’re familiar with <a class="reference external" href="https://docs.python.org/3/library/os.html#os.dup" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">os.dup</span></code></a>, then this is a similar idea.)</p> <p>However, closing one of the objects does not close the other, and receivers don’t get <a class="reference internal" href="#trio.EndOfChannel" title="trio.EndOfChannel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">EndOfChannel</span></code></a> until <em>all</em> clones have been closed.</p> <p>This is useful for communication patterns that involve multiple producers all sending objects to the same destination. If you give each producer its own clone of the <a class="reference internal" href="#trio.MemorySendChannel" title="trio.MemorySendChannel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MemorySendChannel</span></code></a>, and then make sure to close each <a class="reference internal" href="#trio.MemorySendChannel" title="trio.MemorySendChannel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MemorySendChannel</span></code></a> when it’s finished, receivers will automatically get notified when all producers are finished. See <a class="reference internal" href="#channel-mpmc"><span class="std std-ref">Managing multiple producers and/or multiple consumers</span></a> for examples.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Raises<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><a class="reference internal" href="#trio.ClosedResourceError" title="trio.ClosedResourceError"><strong>trio.ClosedResourceError</strong></a> – if you already closed this <a class="reference internal" href="#trio.MemorySendChannel" title="trio.MemorySendChannel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MemorySendChannel</span></code></a> object.</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.MemorySendChannel.close"><code>close() → None</code></h3> <dd>
<p>Close this send channel object synchronously.</p> <p>All channel objects have an asynchronous <a class="reference internal" href="reference-io.html#trio.abc.AsyncResource.aclose" title="trio.abc.AsyncResource.aclose"><code class="xref py py-obj docutils literal notranslate"><span class="pre">aclose</span></code></a> method. Memory channels can also be closed synchronously. This has the same effect on the channel and other tasks using it, but <a class="reference internal" href="#trio.MemorySendChannel.close" title="trio.MemorySendChannel.close"><code class="xref py py-obj docutils literal notranslate"><span class="pre">close</span></code></a> is not a trio checkpoint. This simplifies cleaning up in cancelled tasks.</p> <p>Using <code class="docutils literal notranslate"><span class="pre">with</span> <span class="pre">send_channel:</span></code> will close the channel object on leaving the with block.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.MemorySendChannel.send"><code><em>await</em> send(value: SendType) → None</code></h3> <dd>
<p>See <a class="reference internal" href="reference-io.html#trio.abc.SendChannel.send" title="trio.abc.SendChannel.send"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SendChannel.send</span></code></a>.</p> <p>Memory channels allow multiple tasks to call <a class="reference internal" href="#trio.MemorySendChannel.send" title="trio.MemorySendChannel.send"><code class="xref py py-obj docutils literal notranslate"><span class="pre">send</span></code></a> at the same time.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.MemorySendChannel.send_nowait"><code>send_nowait(value: SendType) → None</code></h3> <dd>
<p>Like <a class="reference internal" href="reference-io.html#trio.abc.SendChannel.send" title="trio.abc.SendChannel.send"><code class="xref py py-obj docutils literal notranslate"><span class="pre">send</span></code></a>, but if the channel’s buffer is full, raises <a class="reference internal" href="#trio.WouldBlock" title="trio.WouldBlock"><code class="xref py py-obj docutils literal notranslate"><span class="pre">WouldBlock</span></code></a> instead of blocking.</p> </dd>
</dl> </dd>
</dl> <dl class="py class"> <h3 class="sig sig-object py" id="trio.MemoryReceiveChannel"><code><em>class</em> trio.MemoryReceiveChannel(*args: object, **kwargs: object)</code></h3> <dd>
<dl class="py method"> <h3 class="sig sig-object py" id="trio.MemoryReceiveChannel.clone"><code>clone() → MemoryReceiveChannel[ReceiveType]</code></h3> <dd>
<p>Clone this receive channel object.</p> <p>This returns a new <a class="reference internal" href="#trio.MemoryReceiveChannel" title="trio.MemoryReceiveChannel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MemoryReceiveChannel</span></code></a> object, which acts as a duplicate of the original: receiving on the new object does exactly the same thing as receiving on the old object.</p> <p>However, closing one of the objects does not close the other, and the underlying channel is not closed until all clones are closed. (If you’re familiar with <a class="reference external" href="https://docs.python.org/3/library/os.html#os.dup" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">os.dup</span></code></a>, then this is a similar idea.)</p> <p>This is useful for communication patterns that involve multiple consumers all receiving objects from the same underlying channel. See <a class="reference internal" href="#channel-mpmc"><span class="std std-ref">Managing multiple producers and/or multiple consumers</span></a> for examples.</p> <blockquote class="admonition warning"> <h4 class="admonition-title">Warning</h4> <p>The clones all share the same underlying channel. Whenever a clone <a class="reference internal" href="#trio.MemoryReceiveChannel.receive" title="trio.MemoryReceiveChannel.receive"><code class="xref py py-meth docutils literal notranslate"><span class="pre">receive()</span></code></a>s a value, it is removed from the channel and the other clones do <em>not</em> receive that value. If you want to send multiple copies of the same stream of values to multiple destinations, like <a class="reference external" href="https://docs.python.org/3/library/itertools.html#itertools.tee" title="(in Python v3.11)"><code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.tee()</span></code></a>, then you need to find some other solution; this method does <em>not</em> do that.</p> </blockquote> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Raises<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><a class="reference internal" href="#trio.ClosedResourceError" title="trio.ClosedResourceError"><strong>trio.ClosedResourceError</strong></a> – if you already closed this <a class="reference internal" href="#trio.MemoryReceiveChannel" title="trio.MemoryReceiveChannel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MemoryReceiveChannel</span></code></a> object.</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.MemoryReceiveChannel.close"><code>close() → None</code></h3> <dd>
<p>Close this receive channel object synchronously.</p> <p>All channel objects have an asynchronous <a class="reference internal" href="reference-io.html#trio.abc.AsyncResource.aclose" title="trio.abc.AsyncResource.aclose"><code class="xref py py-obj docutils literal notranslate"><span class="pre">aclose</span></code></a> method. Memory channels can also be closed synchronously. This has the same effect on the channel and other tasks using it, but <a class="reference internal" href="#trio.MemoryReceiveChannel.close" title="trio.MemoryReceiveChannel.close"><code class="xref py py-obj docutils literal notranslate"><span class="pre">close</span></code></a> is not a trio checkpoint. This simplifies cleaning up in cancelled tasks.</p> <p>Using <code class="docutils literal notranslate"><span class="pre">with</span> <span class="pre">receive_channel:</span></code> will close the channel object on leaving the with block.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.MemoryReceiveChannel.receive"><code><em>await</em> receive() → ReceiveType</code></h3> <dd>
<p>See <a class="reference internal" href="reference-io.html#trio.abc.ReceiveChannel.receive" title="trio.abc.ReceiveChannel.receive"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReceiveChannel.receive</span></code></a>.</p> <p>Memory channels allow multiple tasks to call <a class="reference internal" href="#trio.MemoryReceiveChannel.receive" title="trio.MemoryReceiveChannel.receive"><code class="xref py py-obj docutils literal notranslate"><span class="pre">receive</span></code></a> at the same time. The first task will get the first item sent, the second task will get the second item sent, and so on.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.MemoryReceiveChannel.receive_nowait"><code>receive_nowait() → ReceiveType</code></h3> <dd>
<p>Like <a class="reference internal" href="reference-io.html#trio.abc.ReceiveChannel.receive" title="trio.abc.ReceiveChannel.receive"><code class="xref py py-obj docutils literal notranslate"><span class="pre">receive</span></code></a>, but if there’s nothing ready to receive, raises <a class="reference internal" href="#trio.WouldBlock" title="trio.WouldBlock"><code class="xref py py-obj docutils literal notranslate"><span class="pre">WouldBlock</span></code></a> instead of blocking.</p> </dd>
</dl> </dd>
</dl> <section id="a-simple-channel-example"> <h4>A simple channel example</h4> <p>Here’s a simple example of how to use memory channels:</p> <pre data-language="python">import trio


async def main():
    async with trio.open_nursery() as nursery:
        # Open a channel:
        send_channel, receive_channel = trio.open_memory_channel(0)
        # Start a producer and a consumer, passing one end of the channel to
        # each of them:
        nursery.start_soon(producer, send_channel)
        nursery.start_soon(consumer, receive_channel)


async def producer(send_channel):
    # Producer sends 3 messages
    for i in range(3):
        # The producer sends using 'await send_channel.send(...)'
        await send_channel.send(f"message {i}")


async def consumer(receive_channel):
    # The consumer uses an 'async for' loop to receive the values:
    async for value in receive_channel:
        print(f"got value {value!r}")


trio.run(main)</pre> <p>If you run this, it prints:</p> <pre>got value "message 0"
got value "message 1"
got value "message 2"</pre> <p>And then it hangs forever. (Use control-C to quit.)</p> </section> <section id="clean-shutdown-with-channels"> <h4>Clean shutdown with channels</h4> <p>Of course we don’t generally like it when programs hang. What happened? The problem is that the producer sent 3 messages and then exited, but the consumer has no way to tell that the producer is gone: for all it knows, another message might be coming along any moment. So it hangs forever waiting for the 4th message.</p> <p>Here’s a new version that fixes this: it produces the same output as the previous version, and then exits cleanly. The only change is the addition of <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> blocks inside the producer and consumer:</p> <pre data-language="python">import trio


async def main():
    async with trio.open_nursery() as nursery:
        send_channel, receive_channel = trio.open_memory_channel(0)
        nursery.start_soon(producer, send_channel)
        nursery.start_soon(consumer, receive_channel)


async def producer(send_channel):
    async with send_channel:
        for i in range(3):
            await send_channel.send(f"message {i}")


async def consumer(receive_channel):
    async with receive_channel:
        async for value in receive_channel:
            print(f"got value {value!r}")


trio.run(main)</pre> <p>The really important thing here is the producer’s <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> . When the producer exits, this closes the <code class="docutils literal notranslate"><span class="pre">send_channel</span></code>, and that tells the consumer that no more messages are coming, so it can cleanly exit its <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> loop. Then the program shuts down because both tasks have exited.</p> <p>We also added an <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> to the consumer. This isn’t as important, but it can help us catch mistakes or other problems. For example, suppose that the consumer exited early for some reason – maybe because of a bug. Then the producer would be sending messages into the void, and might get stuck indefinitely. But, if the consumer closes its <code class="docutils literal notranslate"><span class="pre">receive_channel</span></code>, then the producer will get a <a class="reference internal" href="#trio.BrokenResourceError" title="trio.BrokenResourceError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BrokenResourceError</span></code></a> to alert it that it should stop sending messages because no-one is listening.</p> <p>If you want to see the effect of the consumer exiting early, try adding a <code class="docutils literal notranslate"><span class="pre">break</span></code> statement to the <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> loop – you should see a <a class="reference internal" href="#trio.BrokenResourceError" title="trio.BrokenResourceError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BrokenResourceError</span></code></a> from the producer.</p> </section> <section id="managing-multiple-producers-and-or-multiple-consumers"> <h4>Managing multiple producers and/or multiple consumers</h4> <p>You can also have multiple producers, and multiple consumers, all sharing the same channel. However, this makes shutdown a little more complicated.</p> <p>For example, consider this naive extension of our previous example, now with two producers and two consumers:</p> <pre data-language="python"># This example usually crashes!

import trio
import random


async def main():
    async with trio.open_nursery() as nursery:
        send_channel, receive_channel = trio.open_memory_channel(0)
        # Start two producers
        nursery.start_soon(producer, "A", send_channel)
        nursery.start_soon(producer, "B", send_channel)
        # And two consumers
        nursery.start_soon(consumer, "X", receive_channel)
        nursery.start_soon(consumer, "Y", receive_channel)


async def producer(name, send_channel):
    async with send_channel:
        for i in range(3):
            await send_channel.send(f"{i} from producer {name}")
            # Random sleeps help trigger the problem more reliably
            await trio.sleep(random.random())


async def consumer(name, receive_channel):
    async with receive_channel:
        async for value in receive_channel:
            print(f"consumer {name} got value {value!r}")
            # Random sleeps help trigger the problem more reliably
            await trio.sleep(random.random())


trio.run(main)</pre> <p>The two producers, A and B, send 3 messages apiece. These are then randomly distributed between the two consumers, X and Y. So we’re hoping to see some output like:</p> <pre>consumer Y got value '0 from producer B'
consumer X got value '0 from producer A'
consumer Y got value '1 from producer A'
consumer Y got value '1 from producer B'
consumer X got value '2 from producer B'
consumer X got value '2 from producer A'</pre> <p>However, on most runs, that’s not what happens – the first part of the output is OK, and then when we get to the end the program crashes with <a class="reference internal" href="#trio.ClosedResourceError" title="trio.ClosedResourceError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ClosedResourceError</span></code></a>. If you run the program a few times, you’ll see that sometimes the traceback shows <code class="docutils literal notranslate"><span class="pre">send</span></code> crashing, and other times it shows <code class="docutils literal notranslate"><span class="pre">receive</span></code> crashing, and you might even find that on some runs it doesn’t crash at all.</p> <p>Here’s what’s happening: suppose that producer A finishes first. It exits, and its <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> block closes the <code class="docutils literal notranslate"><span class="pre">send_channel</span></code>. But wait! Producer B was still using that <code class="docutils literal notranslate"><span class="pre">send_channel</span></code>… so the next time B calls <code class="docutils literal notranslate"><span class="pre">send</span></code>, it gets a <a class="reference internal" href="#trio.ClosedResourceError" title="trio.ClosedResourceError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ClosedResourceError</span></code></a>.</p> <p>Sometimes, though if we’re lucky, the two producers might finish at the same time (or close enough), so they both make their last <code class="docutils literal notranslate"><span class="pre">send</span></code> before either of them closes the <code class="docutils literal notranslate"><span class="pre">send_channel</span></code>.</p> <p>But, even if that happens, we’re not out of the woods yet! After the producers exit, the two consumers race to be the first to notice that the <code class="docutils literal notranslate"><span class="pre">send_channel</span></code> has closed. Suppose that X wins the race. It exits its <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> loop, then exits the <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> block… and closes the <code class="docutils literal notranslate"><span class="pre">receive_channel</span></code>, while Y is still using it. Again, this causes a crash.</p> <p>We could avoid this by using some complicated bookkeeping to make sure that only the <em>last</em> producer and the <em>last</em> consumer close their channel endpoints… but that would be tiresome and fragile. Fortunately, there’s a better way! Here’s a fixed version of our program above:</p> <pre data-language="python">import trio
import random


async def main():
    async with trio.open_nursery() as nursery:
        send_channel, receive_channel = trio.open_memory_channel(0)
        async with send_channel, receive_channel:
            # Start two producers, giving each its own private clone
            nursery.start_soon(producer, "A", send_channel.clone())
            nursery.start_soon(producer, "B", send_channel.clone())
            # And two consumers, giving each its own private clone
            nursery.start_soon(consumer, "X", receive_channel.clone())
            nursery.start_soon(consumer, "Y", receive_channel.clone())


async def producer(name, send_channel):
    async with send_channel:
        for i in range(3):
            await send_channel.send(f"{i} from producer {name}")
            # Random sleeps help trigger the problem more reliably
            await trio.sleep(random.random())


async def consumer(name, receive_channel):
    async with receive_channel:
        async for value in receive_channel:
            print(f"consumer {name} got value {value!r}")
            # Random sleeps help trigger the problem more reliably
            await trio.sleep(random.random())


trio.run(main)</pre> <p>This example demonstrates using the <a class="reference internal" href="#trio.MemorySendChannel.clone" title="trio.MemorySendChannel.clone"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MemorySendChannel.clone</span></code></a> and <a class="reference internal" href="#trio.MemoryReceiveChannel.clone" title="trio.MemoryReceiveChannel.clone"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MemoryReceiveChannel.clone</span></code></a> methods. What these do is create copies of our endpoints, that act just like the original – except that they can be closed independently. And the underlying channel is only closed after <em>all</em> the clones have been closed. So this completely solves our problem with shutdown, and if you run this program, you’ll see it print its six lines of output and then exits cleanly.</p> <p>Notice a small trick we use: the code in <code class="docutils literal notranslate"><span class="pre">main</span></code> creates clone objects to pass into all the child tasks, and then closes the original objects using <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code>. Another option is to pass clones into all-but-one of the child tasks, and then pass the original object into the last task, like:</p> <pre data-language="python"># Also works, but is more finicky:
send_channel, receive_channel = trio.open_memory_channel(0)
nursery.start_soon(producer, "A", send_channel.clone())
nursery.start_soon(producer, "B", send_channel)
nursery.start_soon(consumer, "X", receive_channel.clone())
nursery.start_soon(consumer, "Y", receive_channel)</pre> <p>But this is more error-prone, especially if you use a loop to spawn the producers/consumers.</p> <p>Just make sure that you don’t write:</p> <pre data-language="python"># Broken, will cause program to hang:
send_channel, receive_channel = trio.open_memory_channel(0)
nursery.start_soon(producer, "A", send_channel.clone())
nursery.start_soon(producer, "B", send_channel.clone())
nursery.start_soon(consumer, "X", receive_channel.clone())
nursery.start_soon(consumer, "Y", receive_channel.clone())</pre> <p>Here we pass clones into the tasks, but never close the original objects. That means we have 3 send channel objects (the original + two clones), but we only close 2 of them, so the consumers will hang around forever waiting for that last one to be closed.</p> </section> <section id="buffering-in-channels"> <h4>Buffering in channels</h4> <p>When you call <a class="reference internal" href="#trio.open_memory_channel" title="trio.open_memory_channel"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_memory_channel()</span></code></a>, you have to specify how many values can be buffered internally in the channel. If the buffer is full, then any task that calls <a class="reference internal" href="reference-io.html#trio.abc.SendChannel.send" title="trio.abc.SendChannel.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> will stop and wait for another task to call <a class="reference internal" href="reference-io.html#trio.abc.ReceiveChannel.receive" title="trio.abc.ReceiveChannel.receive"><code class="xref py py-meth docutils literal notranslate"><span class="pre">receive()</span></code></a>. This is useful because it produces <em>backpressure</em>: if the channel producers are running faster than the consumers, then it forces the producers to slow down.</p> <p>You can disable buffering entirely, by doing <code class="docutils literal notranslate"><span class="pre">open_memory_channel(0)</span></code>. In that case any task that calls <a class="reference internal" href="reference-io.html#trio.abc.SendChannel.send" title="trio.abc.SendChannel.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> will wait until another task calls <a class="reference internal" href="reference-io.html#trio.abc.ReceiveChannel.receive" title="trio.abc.ReceiveChannel.receive"><code class="xref py py-meth docutils literal notranslate"><span class="pre">receive()</span></code></a>, and vice versa. This is similar to how channels work in the <a class="reference external" href="https://en.wikipedia.org/wiki/Channel_(programming)">classic Communicating Sequential Processes model</a>, and is a reasonable default if you aren’t sure what size buffer to use. (That’s why we used it in the examples above.)</p> <p>At the other extreme, you can make the buffer unbounded by using <code class="docutils literal notranslate"><span class="pre">open_memory_channel(math.inf)</span></code>. In this case, <a class="reference internal" href="reference-io.html#trio.abc.SendChannel.send" title="trio.abc.SendChannel.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> <em>always</em> returns immediately. Normally, this is a bad idea. To see why, consider a program where the producer runs more quickly than the consumer:</p> <pre data-language="python"># Simulate a producer that generates values 10x faster than the
# consumer can handle them.

import trio
import math


async def producer(send_channel):
    count = 0
    while True:
        # Pretend that we have to do some work to create this message, and it
        # takes 0.1 seconds:
        await trio.sleep(0.1)
        await send_channel.send(count)
        print("Sent message:", count)
        count += 1


async def consumer(receive_channel):
    async for value in receive_channel:
        print("Received message:", value)
        # Pretend that we have to do some work to handle this message, and it
        # takes 1 second
        await trio.sleep(1)


async def main():
    send_channel, receive_channel = trio.open_memory_channel(math.inf)
    async with trio.open_nursery() as nursery:
        nursery.start_soon(producer, send_channel)
        nursery.start_soon(consumer, receive_channel)


trio.run(main)</pre> <p>If you run this program, you’ll see output like:</p> <pre>Sent message: 0
Received message: 0
Sent message: 1
Sent message: 2
Sent message: 3
Sent message: 4
Sent message: 5
Sent message: 6
Sent message: 7
Sent message: 8
Sent message: 9
Received message: 1
Sent message: 10
Sent message: 11
Sent message: 12
...</pre> <p>On average, the producer sends ten messages per second, but the consumer only calls <code class="docutils literal notranslate"><span class="pre">receive</span></code> once per second. That means that each second, the channel’s internal buffer has to grow to hold an extra nine items. After a minute, the buffer will have ~540 items in it; after an hour, that grows to ~32,400. Eventually, the program will run out of memory. And well before we run out of memory, our latency on handling individual messages will become abysmal. For example, at the one minute mark, the producer is sending message ~600, but the consumer is still processing message ~60. Message 600 will have to sit in the channel for ~9 minutes before the consumer catches up and processes it.</p> <p>Now try replacing <code class="docutils literal notranslate"><span class="pre">open_memory_channel(math.inf)</span></code> with <code class="docutils literal notranslate"><span class="pre">open_memory_channel(0)</span></code>, and run it again. We get output like:</p> <pre>Sent message: 0
Received message: 0
Received message: 1
Sent message: 1
Received message: 2
Sent message: 2
Sent message: 3
Received message: 3
...</pre> <p>Now the <code class="docutils literal notranslate"><span class="pre">send</span></code> calls wait for the <code class="docutils literal notranslate"><span class="pre">receive</span></code> calls to finish, which forces the producer to slow down to match the consumer’s speed. (It might look strange that some values are reported as “Received” before they’re reported as “Sent”; this happens because the actual send/receive happen at the same time, so which line gets printed first is random.)</p> <p>Now, let’s try setting a small but nonzero buffer size, like <code class="docutils literal notranslate"><span class="pre">open_memory_channel(3)</span></code>. what do you think will happen?</p> <p>I get:</p> <pre>Sent message: 0
Received message: 0
Sent message: 1
Sent message: 2
Sent message: 3
Received message: 1
Sent message: 4
Received message: 2
Sent message: 5
...</pre> <p>So you can see that the producer runs ahead by 3 messages, and then stops to wait: when the consumer reads message 1, it sends message 4, then when the consumer reads message 2, it sends message 5, and so on. Once it reaches the steady state, this version acts just like our previous version where we set the buffer size to 0, except that it uses a bit more memory and each message sits in the buffer for a bit longer before being processed (i.e., the message latency is higher).</p> <p>Of course real producers and consumers are usually more complicated than this, and in some situations, a modest amount of buffering might improve throughput. But too much buffering wastes memory and increases latency, so if you want to tune your application you should experiment to see what value works best for you.</p> <p><strong>Why do we even support unbounded buffers then?</strong> Good question! Despite everything we saw above, there are times when you actually do need an unbounded buffer. For example, consider a web crawler that uses a channel to keep track of all the URLs it still wants to crawl. Each crawler runs a loop where it takes a URL from the channel, fetches it, checks the HTML for outgoing links, and then adds the new URLs to the channel. This creates a <em>circular flow</em>, where each consumer is also a producer. In this case, if your channel buffer gets full, then the crawlers will block when they try to add new URLs to the channel, and if all the crawlers got blocked, then they aren’t taking any URLs out of the channel, so they’re stuck forever in a deadlock. Using an unbounded channel avoids this, because it means that <a class="reference internal" href="reference-io.html#trio.abc.SendChannel.send" title="trio.abc.SendChannel.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> never blocks.</p> </section> </section> <section id="lower-level-synchronization-primitives"> <h3>Lower-level synchronization primitives</h3> <p>Personally, I find that events and channels are usually enough to implement most things I care about, and lead to easier to read code than the lower-level primitives discussed in this section. But if you need them, they’re here. (If you find yourself reaching for these because you’re trying to implement a new higher-level synchronization primitive, then you might also want to check out the facilities in <a class="reference internal" href="reference-lowlevel.html#module-trio.lowlevel" title="trio.lowlevel"><code class="xref py py-mod docutils literal notranslate"><span class="pre">trio.lowlevel</span></code></a> for a more direct exposure of Trio’s underlying synchronization logic. All of classes discussed in this section are implemented on top of the public APIs in <a class="reference internal" href="reference-lowlevel.html#module-trio.lowlevel" title="trio.lowlevel"><code class="xref py py-mod docutils literal notranslate"><span class="pre">trio.lowlevel</span></code></a>; they don’t have any special access to Trio’s internals.)</p> <dl class="py class"> <h3 class="sig sig-object py" id="trio.CapacityLimiter"><code><em>class</em> trio.CapacityLimiter(total_tokens)</code></h3> <dd>
<p>An object for controlling access to a resource with limited capacity.</p> <p>Sometimes you need to put a limit on how many tasks can do something at the same time. For example, you might want to use some threads to run multiple blocking I/O operations in parallel… but if you use too many threads at once, then your system can become overloaded and it’ll actually make things slower. One popular solution is to impose a policy like “run up to 40 threads at the same time, but no more”. But how do you implement a policy like this?</p> <p>That’s what <a class="reference internal" href="#trio.CapacityLimiter" title="trio.CapacityLimiter"><code class="xref py py-class docutils literal notranslate"><span class="pre">CapacityLimiter</span></code></a> is for. You can think of a <a class="reference internal" href="#trio.CapacityLimiter" title="trio.CapacityLimiter"><code class="xref py py-class docutils literal notranslate"><span class="pre">CapacityLimiter</span></code></a> object as a sack that starts out holding some fixed number of tokens:</p> <pre data-language="python">limit = trio.CapacityLimiter(40)</pre> <p>Then tasks can come along and borrow a token out of the sack:</p> <pre data-language="python"># Borrow a token:
async with limit:
    # We are holding a token!
    await perform_expensive_operation()
# Exiting the 'async with' block puts the token back into the sack</pre> <p>And crucially, if you try to borrow a token but the sack is empty, then you have to wait for another task to finish what it’s doing and put its token back first before you can take it and continue.</p> <p>Another way to think of it: a <a class="reference internal" href="#trio.CapacityLimiter" title="trio.CapacityLimiter"><code class="xref py py-class docutils literal notranslate"><span class="pre">CapacityLimiter</span></code></a> is like a sofa with a fixed number of seats, and if they’re all taken then you have to wait for someone to get up before you can sit down.</p> <p>By default, <a class="reference internal" href="#trio.to_thread.run_sync" title="trio.to_thread.run_sync"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.to_thread.run_sync()</span></code></a> uses a <a class="reference internal" href="#trio.CapacityLimiter" title="trio.CapacityLimiter"><code class="xref py py-class docutils literal notranslate"><span class="pre">CapacityLimiter</span></code></a> to limit the number of threads running at once; see <a class="reference internal" href="#trio.to_thread.current_default_thread_limiter" title="trio.to_thread.current_default_thread_limiter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.to_thread.current_default_thread_limiter</span></code></a> for details.</p> <p>If you’re familiar with semaphores, then you can think of this as a restricted semaphore that’s specialized for one common use case, with additional error checking. For a more traditional semaphore, see <a class="reference internal" href="#trio.Semaphore" title="trio.Semaphore"><code class="xref py py-class docutils literal notranslate"><span class="pre">Semaphore</span></code></a>.</p> <blockquote class="admonition note"> <h4 class="admonition-title">Note</h4> <p>Don’t confuse this with the <a class="reference external" href="https://en.wikipedia.org/wiki/Leaky_bucket">“leaky bucket”</a> or <a class="reference external" href="https://en.wikipedia.org/wiki/Token_bucket">“token bucket”</a> algorithms used to limit bandwidth usage on networks. The basic idea of using tokens to track a resource limit is similar, but this is a very simple sack where tokens aren’t automatically created or destroyed over time; they’re just borrowed and then put back.</p> </blockquote> <dl class="py method"> <h3 class="sig sig-object py" id="trio.CapacityLimiter.acquire"><code><em>await</em> acquire()</code></h3> <dd>
<p>Borrow a token from the sack, blocking if necessary.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Raises<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#RuntimeError" title="(in Python v3.11)"><strong>RuntimeError</strong></a> – if the current task already holds one of this sack’s tokens.</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.CapacityLimiter.acquire_nowait"><code>acquire_nowait()</code></h3> <dd>
<p>Borrow a token from the sack, without blocking.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Raises<span class="colon">:</span>
</h4> <dd class="field-odd">
<ul class="simple"> <li><p><a class="reference internal" href="#trio.WouldBlock" title="trio.WouldBlock"><strong>WouldBlock</strong></a> – if no tokens are available.</p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#RuntimeError" title="(in Python v3.11)"><strong>RuntimeError</strong></a> – if the current task already holds one of this sack’s tokens.</p></li> </ul> </dd> </dl> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.CapacityLimiter.acquire_on_behalf_of"><code><em>await</em> acquire_on_behalf_of(borrower)</code></h3> <dd>
<p>Borrow a token from the sack on behalf of <code class="docutils literal notranslate"><span class="pre">borrower</span></code>, blocking if necessary.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><strong>borrower</strong> – A <a class="reference internal" href="reference-lowlevel.html#trio.lowlevel.Task" title="trio.lowlevel.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.lowlevel.Task</span></code></a> or arbitrary opaque object used to record who is borrowing this token; see <a class="reference internal" href="#trio.CapacityLimiter.acquire_on_behalf_of_nowait" title="trio.CapacityLimiter.acquire_on_behalf_of_nowait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">acquire_on_behalf_of_nowait()</span></code></a> for details.</p> </dd> <h4 class="field-even" style="margin: 0">Raises<span class="colon">:</span>
</h4> <dd class="field-even">
<p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#RuntimeError" title="(in Python v3.11)"><strong>RuntimeError</strong></a> – if <code class="docutils literal notranslate"><span class="pre">borrower</span></code> task already holds one of this sack’s tokens.</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.CapacityLimiter.acquire_on_behalf_of_nowait"><code>acquire_on_behalf_of_nowait(borrower)</code></h3> <dd>
<p>Borrow a token from the sack on behalf of <code class="docutils literal notranslate"><span class="pre">borrower</span></code>, without blocking.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><strong>borrower</strong> – A <a class="reference internal" href="reference-lowlevel.html#trio.lowlevel.Task" title="trio.lowlevel.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.lowlevel.Task</span></code></a> or arbitrary opaque object used to record who is borrowing this token. This is used by <a class="reference internal" href="#trio.to_thread.run_sync" title="trio.to_thread.run_sync"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.to_thread.run_sync()</span></code></a> to allow threads to “hold tokens”, with the intention in the future of using it to <a class="reference external" href="https://github.com/python-trio/trio/issues/182">allow deadlock detection and other useful things</a></p> </dd> <h4 class="field-even" style="margin: 0">Raises<span class="colon">:</span>
</h4> <dd class="field-even">
<ul class="simple"> <li><p><a class="reference internal" href="#trio.WouldBlock" title="trio.WouldBlock"><strong>WouldBlock</strong></a> – if no tokens are available.</p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#RuntimeError" title="(in Python v3.11)"><strong>RuntimeError</strong></a> – if <code class="docutils literal notranslate"><span class="pre">borrower</span></code> already holds one of this sack’s tokens.</p></li> </ul> </dd> </dl> </dd>
</dl> <dl class="py property"> <h3 class="sig sig-object py" id="trio.CapacityLimiter.available_tokens"><code><em>property</em> available_tokens</code></h3> <dd>
<p>The amount of capacity that’s available to use.</p> </dd>
</dl> <dl class="py property"> <h3 class="sig sig-object py" id="trio.CapacityLimiter.borrowed_tokens"><code><em>property</em> borrowed_tokens</code></h3> <dd>
<p>The amount of capacity that’s currently in use.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.CapacityLimiter.release"><code>release()</code></h3> <dd>
<p>Put a token back into the sack.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Raises<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#RuntimeError" title="(in Python v3.11)"><strong>RuntimeError</strong></a> – if the current task has not acquired one of this sack’s tokens.</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.CapacityLimiter.release_on_behalf_of"><code>release_on_behalf_of(borrower)</code></h3> <dd>
<p>Put a token back into the sack on behalf of <code class="docutils literal notranslate"><span class="pre">borrower</span></code>.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Raises<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#RuntimeError" title="(in Python v3.11)"><strong>RuntimeError</strong></a> – if the given borrower has not acquired one of this sack’s tokens.</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.CapacityLimiter.statistics"><code>statistics()</code></h3> <dd>
<p>Return an object containing debugging information.</p> <p>Currently the following fields are defined:</p> <ul class="simple"> <li><p><code class="docutils literal notranslate"><span class="pre">borrowed_tokens</span></code>: The number of tokens currently borrowed from the sack.</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">total_tokens</span></code>: The total number of tokens in the sack. Usually this will be larger than <code class="docutils literal notranslate"><span class="pre">borrowed_tokens</span></code>, but it’s possibly for it to be smaller if <a class="reference internal" href="#trio.CapacityLimiter.total_tokens" title="trio.CapacityLimiter.total_tokens"><code class="xref py py-attr docutils literal notranslate"><span class="pre">total_tokens</span></code></a> was recently decreased.</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">borrowers</span></code>: A list of all tasks or other entities that currently hold a token.</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">tasks_waiting</span></code>: The number of tasks blocked on this <a class="reference internal" href="#trio.CapacityLimiter" title="trio.CapacityLimiter"><code class="xref py py-class docutils literal notranslate"><span class="pre">CapacityLimiter</span></code></a>’s <a class="reference internal" href="#trio.CapacityLimiter.acquire" title="trio.CapacityLimiter.acquire"><code class="xref py py-meth docutils literal notranslate"><span class="pre">acquire()</span></code></a> or <a class="reference internal" href="#trio.CapacityLimiter.acquire_on_behalf_of" title="trio.CapacityLimiter.acquire_on_behalf_of"><code class="xref py py-meth docutils literal notranslate"><span class="pre">acquire_on_behalf_of()</span></code></a> methods.</p></li> </ul> </dd>
</dl> <dl class="py property"> <h3 class="sig sig-object py" id="trio.CapacityLimiter.total_tokens"><code><em>property</em> total_tokens</code></h3> <dd>
<p>The total capacity available.</p> <p>You can change <a class="reference internal" href="#trio.CapacityLimiter.total_tokens" title="trio.CapacityLimiter.total_tokens"><code class="xref py py-attr docutils literal notranslate"><span class="pre">total_tokens</span></code></a> by assigning to this attribute. If you make it larger, then the appropriate number of waiting tasks will be woken immediately to take the new tokens. If you decrease total_tokens below the number of tasks that are currently using the resource, then all current tasks will be allowed to finish as normal, but no new tasks will be allowed in until the total number of tasks drops below the new total_tokens.</p> </dd>
</dl> </dd>
</dl> <dl class="py class"> <h3 class="sig sig-object py" id="trio.Semaphore"><code><em>class</em> trio.Semaphore(initial_value, *, max_value=None)</code></h3> <dd>
<p>A <a class="reference external" href="https://en.wikipedia.org/wiki/Semaphore_(programming)">semaphore</a>.</p> <p>A semaphore holds an integer value, which can be incremented by calling <a class="reference internal" href="#trio.Semaphore.release" title="trio.Semaphore.release"><code class="xref py py-meth docutils literal notranslate"><span class="pre">release()</span></code></a> and decremented by calling <a class="reference internal" href="#trio.Semaphore.acquire" title="trio.Semaphore.acquire"><code class="xref py py-meth docutils literal notranslate"><span class="pre">acquire()</span></code></a> – but the value is never allowed to drop below zero. If the value is zero, then <a class="reference internal" href="#trio.Semaphore.acquire" title="trio.Semaphore.acquire"><code class="xref py py-meth docutils literal notranslate"><span class="pre">acquire()</span></code></a> will block until someone calls <a class="reference internal" href="#trio.Semaphore.release" title="trio.Semaphore.release"><code class="xref py py-meth docutils literal notranslate"><span class="pre">release()</span></code></a>.</p> <p>If you’re looking for a <a class="reference internal" href="#trio.Semaphore" title="trio.Semaphore"><code class="xref py py-class docutils literal notranslate"><span class="pre">Semaphore</span></code></a> to limit the number of tasks that can access some resource simultaneously, then consider using a <a class="reference internal" href="#trio.CapacityLimiter" title="trio.CapacityLimiter"><code class="xref py py-class docutils literal notranslate"><span class="pre">CapacityLimiter</span></code></a> instead.</p> <p>This object’s interface is similar to, but different from, that of <a class="reference external" href="https://docs.python.org/3/library/threading.html#threading.Semaphore" title="(in Python v3.11)"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.Semaphore</span></code></a>.</p> <p>A <a class="reference internal" href="#trio.Semaphore" title="trio.Semaphore"><code class="xref py py-class docutils literal notranslate"><span class="pre">Semaphore</span></code></a> object can be used as an async context manager; it blocks on entry but not on exit.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<ul class="simple"> <li><p><strong>initial_value</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a>) – A non-negative integer giving semaphore’s initial value.</p></li> <li><p><strong>max_value</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em> or </em><em>None</em>) – If given, makes this a “bounded” semaphore that raises an error if the value is about to exceed the given <code class="docutils literal notranslate"><span class="pre">max_value</span></code>.</p></li> </ul> </dd> </dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Semaphore.acquire"><code><em>await</em> acquire()</code></h3> <dd>
<p>Decrement the semaphore value, blocking if necessary to avoid letting it drop below zero.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Semaphore.acquire_nowait"><code>acquire_nowait()</code></h3> <dd>
<p>Attempt to decrement the semaphore value, without blocking.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Raises<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><a class="reference internal" href="#trio.WouldBlock" title="trio.WouldBlock"><strong>WouldBlock</strong></a> – if the value is zero.</p> </dd> </dl> </dd>
</dl> <dl class="py property"> <h3 class="sig sig-object py" id="trio.Semaphore.max_value"><code><em>property</em> max_value</code></h3> <dd>
<p>The maximum allowed value. May be None to indicate no limit.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Semaphore.release"><code>release()</code></h3> <dd>
<p>Increment the semaphore value, possibly waking a task blocked in <a class="reference internal" href="#trio.Semaphore.acquire" title="trio.Semaphore.acquire"><code class="xref py py-meth docutils literal notranslate"><span class="pre">acquire()</span></code></a>.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Raises<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.11)"><strong>ValueError</strong></a> – if incrementing the value would cause it to exceed <a class="reference internal" href="#trio.Semaphore.max_value" title="trio.Semaphore.max_value"><code class="xref py py-attr docutils literal notranslate"><span class="pre">max_value</span></code></a>.</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Semaphore.statistics"><code>statistics()</code></h3> <dd>
<p>Return an object containing debugging information.</p> <p>Currently the following fields are defined:</p> <ul class="simple"> <li><p><code class="docutils literal notranslate"><span class="pre">tasks_waiting</span></code>: The number of tasks blocked on this semaphore’s <a class="reference internal" href="#trio.Semaphore.acquire" title="trio.Semaphore.acquire"><code class="xref py py-meth docutils literal notranslate"><span class="pre">acquire()</span></code></a> method.</p></li> </ul> </dd>
</dl> <dl class="py property"> <h3 class="sig sig-object py" id="trio.Semaphore.value"><code><em>property</em> value</code></h3> <dd>
<p>The current value of the semaphore.</p> </dd>
</dl> </dd>
</dl> <dl class="py class"> <h3 class="sig sig-object py" id="trio.Lock"><code><em>class</em> trio.Lock</code></h3> <dd>
<p>A classic <a class="reference external" href="https://en.wikipedia.org/wiki/Lock_(computer_science)">mutex</a>.</p> <p>This is a non-reentrant, single-owner lock. Unlike <a class="reference external" href="https://docs.python.org/3/library/threading.html#threading.Lock" title="(in Python v3.11)"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.Lock</span></code></a>, only the owner of the lock is allowed to release it.</p> <p>A <a class="reference internal" href="#trio.Lock" title="trio.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lock</span></code></a> object can be used as an async context manager; it blocks on entry but not on exit.</p> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Lock.acquire"><code><em>await</em> acquire()</code></h3> <dd>
<p>Acquire the lock, blocking if necessary.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Lock.acquire_nowait"><code>acquire_nowait()</code></h3> <dd>
<p>Attempt to acquire the lock, without blocking.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Raises<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><a class="reference internal" href="#trio.WouldBlock" title="trio.WouldBlock"><strong>WouldBlock</strong></a> – if the lock is held.</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Lock.locked"><code>locked()</code></h3> <dd>
<p>Check whether the lock is currently held.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Returns<span class="colon">:</span>
</h4> <dd class="field-odd">
<p>True if the lock is held, False otherwise.</p> </dd> <h4 class="field-even" style="margin: 0">Return type<span class="colon">:</span>
</h4> <dd class="field-even">
<p><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)">bool</a></p> </dd> </dl> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Lock.release"><code>release()</code></h3> <dd>
<p>Release the lock.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Raises<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#RuntimeError" title="(in Python v3.11)"><strong>RuntimeError</strong></a> – if the calling task does not hold the lock.</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Lock.statistics"><code>statistics()</code></h3> <dd>
<p>Return an object containing debugging information.</p> <p>Currently the following fields are defined:</p> <ul class="simple"> <li><p><code class="docutils literal notranslate"><span class="pre">locked</span></code>: boolean indicating whether the lock is held.</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">owner</span></code>: the <a class="reference internal" href="reference-lowlevel.html#trio.lowlevel.Task" title="trio.lowlevel.Task"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.lowlevel.Task</span></code></a> currently holding the lock, or None if the lock is not held.</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">tasks_waiting</span></code>: The number of tasks blocked on this lock’s <a class="reference internal" href="#trio.Lock.acquire" title="trio.Lock.acquire"><code class="xref py py-meth docutils literal notranslate"><span class="pre">acquire()</span></code></a> method.</p></li> </ul> </dd>
</dl> </dd>
</dl> <dl class="py class"> <h3 class="sig sig-object py" id="trio.StrictFIFOLock"><code><em>class</em> trio.StrictFIFOLock</code></h3> <dd>
<p>A variant of <a class="reference internal" href="#trio.Lock" title="trio.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lock</span></code></a> where tasks are guaranteed to acquire the lock in strict first-come-first-served order.</p> <p>An example of when this is useful is if you’re implementing something like <a class="reference internal" href="reference-io.html#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.SSLStream</span></code></a> or an HTTP/2 server using <a class="reference external" href="https://hyper-h2.readthedocs.io/">h2</a>, where you have multiple concurrent tasks that are interacting with a shared state machine, and at unpredictable moments the state machine requests that a chunk of data be sent over the network. (For example, when using h2 simply reading incoming data can occasionally <a class="reference external" href="https://http2.github.io/http2-spec/#PING">create outgoing data to send</a>.) The challenge is to make sure that these chunks are sent in the correct order, without being garbled.</p> <p>One option would be to use a regular <a class="reference internal" href="#trio.Lock" title="trio.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lock</span></code></a>, and wrap it around every interaction with the state machine:</p> <pre data-language="python"># This approach is sometimes workable but often sub-optimal; see below
async with lock:
    state_machine.do_something()
    if state_machine.has_data_to_send():
        await conn.sendall(state_machine.get_data_to_send())</pre> <p>But this can be problematic. If you’re using h2 then <em>usually</em> reading incoming data doesn’t create the need to send any data, so we don’t want to force every task that tries to read from the network to sit and wait a potentially long time for <code class="docutils literal notranslate"><span class="pre">sendall</span></code> to finish. And in some situations this could even potentially cause a deadlock, if the remote peer is waiting for you to read some data before it accepts the data you’re sending.</p> <p><a class="reference internal" href="#trio.StrictFIFOLock" title="trio.StrictFIFOLock"><code class="xref py py-class docutils literal notranslate"><span class="pre">StrictFIFOLock</span></code></a> provides an alternative. We can rewrite our example like:</p> <pre data-language="python"># Note: no awaits between when we start using the state machine and
# when we block to take the lock!
state_machine.do_something()
if state_machine.has_data_to_send():
    # Notice that we fetch the data to send out of the state machine
    # *before* sleeping, so that other tasks won't see it.
    chunk = state_machine.get_data_to_send()
    async with strict_fifo_lock:
        await conn.sendall(chunk)</pre> <p>First we do all our interaction with the state machine in a single scheduling quantum (notice there are no <code class="docutils literal notranslate"><span class="pre">await</span></code>s in there), so it’s automatically atomic with respect to other tasks. And then if and only if we have data to send, we get in line to send it – and <a class="reference internal" href="#trio.StrictFIFOLock" title="trio.StrictFIFOLock"><code class="xref py py-class docutils literal notranslate"><span class="pre">StrictFIFOLock</span></code></a> guarantees that each task will send its data in the same order that the state machine generated it.</p> <p>Currently, <a class="reference internal" href="#trio.StrictFIFOLock" title="trio.StrictFIFOLock"><code class="xref py py-class docutils literal notranslate"><span class="pre">StrictFIFOLock</span></code></a> is identical to <a class="reference internal" href="#trio.Lock" title="trio.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lock</span></code></a>, but (a) this may not always be true in the future, especially if Trio ever implements <a class="reference external" href="https://github.com/python-trio/trio/issues/32">more sophisticated scheduling policies</a>, and (b) the above code is relying on a pretty subtle property of its lock. Using a <a class="reference internal" href="#trio.StrictFIFOLock" title="trio.StrictFIFOLock"><code class="xref py py-class docutils literal notranslate"><span class="pre">StrictFIFOLock</span></code></a> acts as an executable reminder that you’re relying on this property.</p> </dd>
</dl> <dl class="py class"> <h3 class="sig sig-object py" id="trio.Condition"><code><em>class</em> trio.Condition(lock=None)</code></h3> <dd>
<p>A classic <a class="reference external" href="https://en.wikipedia.org/wiki/Monitor_(synchronization)">condition variable</a>, similar to <a class="reference external" href="https://docs.python.org/3/library/threading.html#threading.Condition" title="(in Python v3.11)"><code class="xref py py-class docutils literal notranslate"><span class="pre">threading.Condition</span></code></a>.</p> <p>A <a class="reference internal" href="#trio.Condition" title="trio.Condition"><code class="xref py py-class docutils literal notranslate"><span class="pre">Condition</span></code></a> object can be used as an async context manager to acquire the underlying lock; it blocks on entry but not on exit.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><strong>lock</strong> (<a class="reference internal" href="#trio.Lock" title="trio.Lock"><em>Lock</em></a>) – the lock object to use. If given, must be a <a class="reference internal" href="#trio.Lock" title="trio.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.Lock</span></code></a>. If None, a new <a class="reference internal" href="#trio.Lock" title="trio.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lock</span></code></a> will be allocated and used.</p> </dd> </dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Condition.acquire"><code><em>await</em> acquire()</code></h3> <dd>
<p>Acquire the underlying lock, blocking if necessary.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Condition.acquire_nowait"><code>acquire_nowait()</code></h3> <dd>
<p>Attempt to acquire the underlying lock, without blocking.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Raises<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><a class="reference internal" href="#trio.WouldBlock" title="trio.WouldBlock"><strong>WouldBlock</strong></a> – if the lock is currently held.</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Condition.locked"><code>locked()</code></h3> <dd>
<p>Check whether the underlying lock is currently held.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Returns<span class="colon">:</span>
</h4> <dd class="field-odd">
<p>True if the lock is held, False otherwise.</p> </dd> <h4 class="field-even" style="margin: 0">Return type<span class="colon">:</span>
</h4> <dd class="field-even">
<p><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)">bool</a></p> </dd> </dl> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Condition.notify"><code>notify(n=1)</code></h3> <dd>
<p>Wake one or more tasks that are blocked in <a class="reference internal" href="#trio.Condition.wait" title="trio.Condition.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait()</span></code></a>.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><strong>n</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a>) – The number of tasks to wake.</p> </dd> <h4 class="field-even" style="margin: 0">Raises<span class="colon">:</span>
</h4> <dd class="field-even">
<p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#RuntimeError" title="(in Python v3.11)"><strong>RuntimeError</strong></a> – if the calling task does not hold the lock.</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Condition.notify_all"><code>notify_all()</code></h3> <dd>
<p>Wake all tasks that are currently blocked in <a class="reference internal" href="#trio.Condition.wait" title="trio.Condition.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait()</span></code></a>.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Raises<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#RuntimeError" title="(in Python v3.11)"><strong>RuntimeError</strong></a> – if the calling task does not hold the lock.</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Condition.release"><code>release()</code></h3> <dd>
<p>Release the underlying lock.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Condition.statistics"><code>statistics()</code></h3> <dd>
<p>Return an object containing debugging information.</p> <p>Currently the following fields are defined:</p> <ul class="simple"> <li><p><code class="docutils literal notranslate"><span class="pre">tasks_waiting</span></code>: The number of tasks blocked on this condition’s <a class="reference internal" href="#trio.Condition.wait" title="trio.Condition.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait()</span></code></a> method.</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">lock_statistics</span></code>: The result of calling the underlying <a class="reference internal" href="#trio.Lock" title="trio.Lock"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lock</span></code></a>s <a class="reference internal" href="#trio.Lock.statistics" title="trio.Lock.statistics"><code class="xref py py-meth docutils literal notranslate"><span class="pre">statistics()</span></code></a> method.</p></li> </ul> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Condition.wait"><code><em>await</em> wait()</code></h3> <dd>
<p>Wait for another task to call <a class="reference internal" href="#trio.Condition.notify" title="trio.Condition.notify"><code class="xref py py-meth docutils literal notranslate"><span class="pre">notify()</span></code></a> or <a class="reference internal" href="#trio.Condition.notify_all" title="trio.Condition.notify_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">notify_all()</span></code></a>.</p> <p>When calling this method, you must hold the lock. It releases the lock while waiting, and then re-acquires it before waking up.</p> <p>There is a subtlety with how this method interacts with cancellation: when cancelled it will block to re-acquire the lock before raising <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a>. This may cause cancellation to be less prompt than expected. The advantage is that it makes code like this work:</p> <pre data-language="python">async with condition:
    await condition.wait()</pre> <p>If we didn’t re-acquire the lock before waking up, and <a class="reference internal" href="#trio.Condition.wait" title="trio.Condition.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait()</span></code></a> were cancelled here, then we’d crash in <code class="docutils literal notranslate"><span class="pre">condition.__aexit__</span></code> when we tried to release the lock we no longer held.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Raises<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#RuntimeError" title="(in Python v3.11)"><strong>RuntimeError</strong></a> – if the calling task does not hold the lock.</p> </dd> </dl> </dd>
</dl> </dd>
</dl> </section> </section> <section id="notes-on-async-generators"> <h2>Notes on async generators</h2> <p>Python 3.6 added support for <em>async generators</em>, which can use <code class="docutils literal notranslate"><span class="pre">await</span></code>, <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code>, and <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> in between their <code class="docutils literal notranslate"><span class="pre">yield</span></code> statements. As you might expect, you use <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> to iterate over them. <a class="pep reference external" href="https://peps.python.org/pep-0525/"><strong>PEP 525</strong></a> has many more details if you want them.</p> <p>For example, the following is a roundabout way to print the numbers 0 through 9 with a 1-second delay before each one:</p> <pre data-language="python">async def range_slowly(*args):
    """Like range(), but adds a 1-second sleep before each value."""
    for value in range(*args):
        await trio.sleep(1)
        yield value

async def use_it():
    async for value in range_slowly(10):
        print(value)

trio.run(use_it)</pre> <p>Trio supports async generators, with some caveats described in this section.</p> <section id="finalization"> <h3>Finalization</h3> <p>If you iterate over an async generator in its entirety, like the example above does, then the execution of the async generator will occur completely in the context of the code that’s iterating over it, and there aren’t too many surprises.</p> <p>If you abandon a partially-completed async generator, though, such as by <code class="docutils literal notranslate"><span class="pre">break</span></code>ing out of the iteration, things aren’t so simple. The async generator iterator object is still alive, waiting for you to resume iterating it so it can produce more values. At some point, Python will realize that you’ve dropped all references to the iterator, and will call on Trio to throw in a <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#GeneratorExit" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GeneratorExit</span></code></a> exception so that any remaining cleanup code inside the generator has a chance to run: <code class="docutils literal notranslate"><span class="pre">finally</span></code> blocks, <code class="docutils literal notranslate"><span class="pre">__aexit__</span></code> handlers, and so on.</p> <p>So far, so good. Unfortunately, Python provides no guarantees about <em>when</em> this happens. It could be as soon as you break out of the <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> loop, or an arbitrary amount of time later. It could even be after the entire Trio run has finished! Just about the only guarantee is that it <em>won’t</em> happen in the task that was using the generator. That task will continue on with whatever else it’s doing, and the async generator cleanup will happen “sometime later, somewhere else”: potentially with different context variables, not subject to timeouts, and/or after any nurseries you’re using have been closed.</p> <p>If you don’t like that ambiguity, and you want to ensure that a generator’s <code class="docutils literal notranslate"><span class="pre">finally</span></code> blocks and <code class="docutils literal notranslate"><span class="pre">__aexit__</span></code> handlers execute as soon as you’re done using it, then you’ll need to wrap your use of the generator in something like <a class="reference external" href="https://async-generator.readthedocs.io/en/latest/reference.html#context-managers">async_generator.aclosing()</a>:</p> <pre data-language="python"># Instead of this:
async for value in my_generator():
    if value == 42:
        break

# Do this:
async with aclosing(my_generator()) as aiter:
    async for value in aiter:
        if value == 42:
            break</pre> <p>This is cumbersome, but Python unfortunately doesn’t provide any other reliable options. If you use <code class="docutils literal notranslate"><span class="pre">aclosing()</span></code>, then your generator’s cleanup code executes in the same context as the rest of its iterations, so timeouts, exceptions, and context variables work like you’d expect.</p> <p>If you don’t use <code class="docutils literal notranslate"><span class="pre">aclosing()</span></code>, then Trio will do its best anyway, but you’ll have to contend with the following semantics:</p> <ul class="simple"> <li><p>The cleanup of the generator occurs in a cancelled context, i.e., all blocking calls executed during cleanup will raise <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Cancelled</span></code></a>. This is to compensate for the fact that any timeouts surrounding the original use of the generator have been long since forgotten.</p></li> <li><p>The cleanup runs without access to any <a class="reference internal" href="#task-local-storage"><span class="std std-ref">context variables</span></a> that may have been present when the generator was originally being used.</p></li> <li><p>If the generator raises an exception during cleanup, then it’s printed to the <code class="docutils literal notranslate"><span class="pre">trio.async_generator_errors</span></code> logger and otherwise ignored.</p></li> <li><p>If an async generator is still alive at the end of the whole call to <a class="reference internal" href="#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a>, then it will be cleaned up after all tasks have exited and before <a class="reference internal" href="#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a> returns. Since the “system nursery” has already been closed at this point, Trio isn’t able to support any new calls to <a class="reference internal" href="reference-lowlevel.html#trio.lowlevel.spawn_system_task" title="trio.lowlevel.spawn_system_task"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.lowlevel.spawn_system_task()</span></code></a>.</p></li> </ul> <p>If you plan to run your code on PyPy to take advantage of its better performance, you should be aware that PyPy is <em>far more likely</em> than CPython to perform async generator cleanup at a time well after the last use of the generator. (This is a consequence of the fact that PyPy does not use reference counting to manage memory.) To help catch issues like this, Trio will issue a <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ResourceWarning" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ResourceWarning</span></code></a> (ignored by default, but enabled when running under <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">-X</span> <span class="pre">dev</span></code> for example) for each async generator that needs to be handled through the fallback finalization path.</p> </section> <section id="cancel-scopes-and-nurseries"> <h3>Cancel scopes and nurseries</h3> <blockquote class="admonition warning"> <h4 class="admonition-title">Warning</h4> <p>You may not write a <code class="docutils literal notranslate"><span class="pre">yield</span></code> statement that suspends an async generator inside a <a class="reference internal" href="#trio.CancelScope" title="trio.CancelScope"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CancelScope</span></code></a> or <a class="reference internal" href="#trio.Nursery" title="trio.Nursery"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Nursery</span></code></a> that was entered within the generator.</p> </blockquote> <p>That is, this is OK:</p> <pre data-language="python">async def some_agen():
    with trio.move_on_after(1):
        await long_operation()
    yield "first"
    async with trio.open_nursery() as nursery:
        nursery.start_soon(task1)
        nursery.start_soon(task2)
    yield "second"
    ...</pre> <p>But this is not:</p> <pre data-language="python">async def some_agen():
    with trio.move_on_after(1):
        yield "first"
    async with trio.open_nursery() as nursery:
        yield "second"
    ...</pre> <p>Async generators decorated with <code class="docutils literal notranslate"><span class="pre">@asynccontextmanager</span></code> to serve as the template for an async context manager are <em>not</em> subject to this constraint, because <code class="docutils literal notranslate"><span class="pre">@asynccontextmanager</span></code> uses them in a limited way that doesn’t create problems.</p> <p>Violating the rule described in this section will sometimes get you a useful error message, but Trio is not able to detect all such cases, so sometimes you’ll get an unhelpful <a class="reference internal" href="#trio.TrioInternalError" title="trio.TrioInternalError"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TrioInternalError</span></code></a>. (And sometimes it will seem to work, which is probably the worst outcome of all, since then you might not notice the issue until you perform some minor refactoring of the generator or the code that’s iterating it, or just get unlucky. There is a <a class="reference external" href="https://discuss.python.org/t/preventing-yield-inside-certain-context-managers/1091">proposed Python enhancement</a> that would at least make it fail consistently.)</p> <p>The reason for the restriction on cancel scopes has to do with the difficulty of noticing when a generator gets suspended and resumed. The cancel scopes inside the generator shouldn’t affect code running outside the generator, but Trio isn’t involved in the process of exiting and reentering the generator, so it would be hard pressed to keep its cancellation plumbing in the correct state. Nurseries use a cancel scope internally, so they have all the problems of cancel scopes plus a number of problems of their own: for example, when the generator is suspended, what should the background tasks do? There’s no good way to suspend them, but if they keep running and throw an exception, where can that exception be reraised?</p> <p>If you have an async generator that wants to <code class="docutils literal notranslate"><span class="pre">yield</span></code> from within a nursery or cancel scope, your best bet is to refactor it to be a separate task that communicates over memory channels. The <code class="docutils literal notranslate"><span class="pre">trio_util</span></code> package offers a <a class="reference external" href="https://trio-util.readthedocs.io/en/latest/#trio_util.trio_async_generator">decorator that does this for you transparently</a>.</p> <p>For more discussion, see Trio issues <a class="reference external" href="https://github.com/python-trio/trio/issues/264">264</a> (especially <a class="reference external" href="https://github.com/python-trio/trio/issues/264#issuecomment-418989328">this comment</a>) and <a class="reference external" href="https://github.com/python-trio/trio/issues/638">638</a>.</p> </section> </section> <section id="threads-if-you-must"> <h2>Threads (if you must)</h2> <p>In a perfect world, all third-party libraries and low-level APIs would be natively async and integrated into Trio, and all would be happiness and rainbows.</p> <p>That world, alas, does not (yet) exist. Until it does, you may find yourself needing to interact with non-Trio APIs that do rude things like “blocking”.</p> <p>In acknowledgment of this reality, Trio provides two useful utilities for working with real, operating-system level, <a class="reference external" href="https://docs.python.org/3/library/threading.html#module-threading" title="(in Python v3.11)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">threading</span></code></a>-module-style threads. First, if you’re in Trio but need to push some blocking I/O into a thread, there’s <a class="reference internal" href="#trio.to_thread.run_sync" title="trio.to_thread.run_sync"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.to_thread.run_sync</span></code></a>. And if you’re in a thread and need to communicate back with Trio, you can use <a class="reference internal" href="#trio.from_thread.run" title="trio.from_thread.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.from_thread.run()</span></code></a> and <a class="reference internal" href="#trio.from_thread.run_sync" title="trio.from_thread.run_sync"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.from_thread.run_sync()</span></code></a>.</p> <section id="trio-s-philosophy-about-managing-worker-threads"> <h3>Trio’s philosophy about managing worker threads</h3> <p>If you’ve used other I/O frameworks, you may have encountered the concept of a “thread pool”, which is most commonly implemented as a fixed size collection of threads that hang around waiting for jobs to be assigned to them. These solve two different problems: First, re-using the same threads over and over is more efficient than starting and stopping a new thread for every job you need done; basically, the pool acts as a kind of cache for idle threads. And second, having a fixed size avoids getting into a situation where 100,000 jobs are submitted simultaneously, and then 100,000 threads are spawned and the system gets overloaded and crashes. Instead, the N threads start executing the first N jobs, while the other (100,000 - N) jobs sit in a queue and wait their turn. Which is generally what you want, and this is how <a class="reference internal" href="#trio.to_thread.run_sync" title="trio.to_thread.run_sync"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.to_thread.run_sync()</span></code></a> works by default.</p> <p>The downside of this kind of thread pool is that sometimes, you need more sophisticated logic for controlling how many threads are run at once. For example, you might want a policy like “at most 20 threads total, but no more than 3 of those can be running jobs associated with the same user account”, or you might want a pool whose size is dynamically adjusted over time in response to system conditions.</p> <p>It’s even possible for a fixed-size policy to cause unexpected <a class="reference external" href="https://en.wikipedia.org/wiki/Deadlock">deadlocks</a>. Imagine a situation where we have two different types of blocking jobs that you want to run in the thread pool, type A and type B. Type A is pretty simple: it just runs and completes pretty quickly. But type B is more complicated: it has to stop in the middle and wait for some other work to finish, and that other work includes running a type A job. Now, suppose you submit N jobs of type B to the pool. They all start running, and then eventually end up submitting one or more jobs of type A. But since every thread in our pool is already busy, the type A jobs don’t actually start running – they just sit in a queue waiting for the type B jobs to finish. But the type B jobs will never finish, because they’re waiting for the type A jobs. Our system has deadlocked. The ideal solution to this problem is to avoid having type B jobs in the first place – generally it’s better to keep complex synchronization logic in the main Trio thread. But if you can’t do that, then you need a custom thread allocation policy that tracks separate limits for different types of jobs, and make it impossible for type B jobs to fill up all the slots that type A jobs need to run.</p> <p>So, we can see that it’s important to be able to change the policy controlling the allocation of threads to jobs. But in many frameworks, this requires implementing a new thread pool from scratch, which is highly non-trivial; and if different types of jobs need different policies, then you may have to create multiple pools, which is inefficient because now you effectively have two different thread caches that aren’t sharing resources.</p> <p>Trio’s solution to this problem is to split worker thread management into two layers. The lower layer is responsible for taking blocking I/O jobs and arranging for them to run immediately on some worker thread. It takes care of solving the tricky concurrency problems involved in managing threads and is responsible for optimizations like re-using threads, but has no admission control policy: if you give it 100,000 jobs, it will spawn 100,000 threads. The upper layer is responsible for providing the policy to make sure that this doesn’t happen – but since it <em>only</em> has to worry about policy, it can be much simpler. In fact, all there is to it is the <code class="docutils literal notranslate"><span class="pre">limiter=</span></code> argument passed to <a class="reference internal" href="#trio.to_thread.run_sync" title="trio.to_thread.run_sync"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.to_thread.run_sync()</span></code></a>. This defaults to a global <a class="reference internal" href="#trio.CapacityLimiter" title="trio.CapacityLimiter"><code class="xref py py-class docutils literal notranslate"><span class="pre">CapacityLimiter</span></code></a> object, which gives us the classic fixed-size thread pool behavior. (See <a class="reference internal" href="#trio.to_thread.current_default_thread_limiter" title="trio.to_thread.current_default_thread_limiter"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.to_thread.current_default_thread_limiter()</span></code></a>.) But if you want to use “separate pools” for type A jobs and type B jobs, then it’s just a matter of creating two separate <a class="reference internal" href="#trio.CapacityLimiter" title="trio.CapacityLimiter"><code class="xref py py-class docutils literal notranslate"><span class="pre">CapacityLimiter</span></code></a> objects and passing them in when running these jobs. Or here’s an example of defining a custom policy that respects the global thread limit, while making sure that no individual user can use more than 3 threads at a time:</p> <pre data-language="python">class CombinedLimiter:
     def __init__(self, first, second):
         self._first = first
         self._second = second

     async def acquire_on_behalf_of(self, borrower):
         # Acquire both, being careful to clean up properly on error
         await self._first.acquire_on_behalf_of(borrower)
         try:
             await self._second.acquire_on_behalf_of(borrower)
         except:
             self._first.release_on_behalf_of(borrower)
             raise

     def release_on_behalf_of(self, borrower):
         # Release both, being careful to clean up properly on error
         try:
             self._second.release_on_behalf_of(borrower)
         finally:
             self._first.release_on_behalf_of(borrower)


# Use a weak value dictionary, so that we don't waste memory holding
# limiter objects for users who don't have any worker threads running.
USER_LIMITERS = weakref.WeakValueDictionary()
MAX_THREADS_PER_USER = 3

def get_user_limiter(user_id):
    try:
        return USER_LIMITERS[user_id]
    except KeyError:
        per_user_limiter = trio.CapacityLimiter(MAX_THREADS_PER_USER)
        global_limiter = trio.current_default_thread_limiter()
        # IMPORTANT: acquire the per_user_limiter before the global_limiter.
        # If we get 100 jobs for a user at the same time, we want
        # to only allow 3 of them at a time to even compete for the
        # global thread slots.
        combined_limiter = CombinedLimiter(per_user_limiter, global_limiter)
        USER_LIMITERS[user_id] = combined_limiter
        return combined_limiter


async def run_sync_in_thread_for_user(user_id, sync_fn, *args):
    combined_limiter = get_user_limiter(user_id)
    return await trio.to_thread.run_sync(sync_fn, *args, limiter=combined_limiter)</pre> </section> <section id="putting-blocking-i-o-into-worker-threads"> <h3>Putting blocking I/O into worker threads</h3> <dl class="py function"> <h3 class="sig sig-object py" id="trio.to_thread.run_sync"><code><em>await</em> trio.to_thread.run_sync(sync_fn, *args, thread_name: str | None = None, cancellable=False, limiter=None)</code></h3> <dd>
<p>Convert a blocking operation into an async operation using a thread.</p> <p>These two lines are equivalent:</p> <pre data-language="python">sync_fn(*args)
await trio.to_thread.run_sync(sync_fn, *args)</pre> <p>except that if <code class="docutils literal notranslate"><span class="pre">sync_fn</span></code> takes a long time, then the first line will block the Trio loop while it runs, while the second line allows other Trio tasks to continue working while <code class="docutils literal notranslate"><span class="pre">sync_fn</span></code> runs. This is accomplished by pushing the call to <code class="docutils literal notranslate"><span class="pre">sync_fn(*args)</span></code> off into a worker thread.</p> <p>From inside the worker thread, you can get back into Trio using the functions in <a class="reference internal" href="#module-trio.from_thread" title="trio.from_thread"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.from_thread</span></code></a>.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<ul class="simple"> <li><p><strong>sync_fn</strong> – An arbitrary synchronous callable.</p></li> <li><p><strong>*args</strong> – Positional arguments to pass to sync_fn. If you need keyword arguments, use <a class="reference external" href="https://docs.python.org/3/library/functools.html#functools.partial" title="(in Python v3.11)"><code class="xref py py-func docutils literal notranslate"><span class="pre">functools.partial()</span></code></a>.</p></li> <li><p><strong>cancellable</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – Whether to allow cancellation of this operation. See discussion below.</p></li> <li><p><strong>thread_name</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)"><em>str</em></a>) – Optional string to set the name of the thread. Will always set <a class="reference external" href="https://docs.python.org/3/library/threading.html#threading.Thread.name" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">threading.Thread.name</span></code></a>, but only set the os name if pthread.h is available (i.e. most POSIX installations). pthread names are limited to 15 characters, and can be read from <code class="docutils literal notranslate"><span class="pre">/proc/&lt;PID&gt;/task/&lt;SPID&gt;/comm</span></code> or with <code class="docutils literal notranslate"><span class="pre">ps</span> <span class="pre">-eT</span></code>, among others. Defaults to <code class="docutils literal notranslate"><span class="pre">{sync_fn.__name__|None}</span> <span class="pre">from</span> <span class="pre">{trio.lowlevel.current_task().name}</span></code>.</p></li> <li>
<p><strong>limiter</strong> (<em>None</em><em>, or </em><em>CapacityLimiter-like object</em>) – </p>
<p>An object used to limit the number of simultaneous threads. Most commonly this will be a <a class="reference internal" href="#trio.CapacityLimiter" title="trio.CapacityLimiter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CapacityLimiter</span></code></a>, but it could be anything providing compatible <a class="reference internal" href="#trio.CapacityLimiter.acquire_on_behalf_of" title="trio.CapacityLimiter.acquire_on_behalf_of"><code class="xref py py-meth docutils literal notranslate"><span class="pre">acquire_on_behalf_of()</span></code></a> and <a class="reference internal" href="#trio.CapacityLimiter.release_on_behalf_of" title="trio.CapacityLimiter.release_on_behalf_of"><code class="xref py py-meth docutils literal notranslate"><span class="pre">release_on_behalf_of()</span></code></a> methods. This function will call <code class="docutils literal notranslate"><span class="pre">acquire_on_behalf_of</span></code> before starting the thread, and <code class="docutils literal notranslate"><span class="pre">release_on_behalf_of</span></code> after the thread has finished.</p> <p>If None (the default), uses the default <a class="reference internal" href="#trio.CapacityLimiter" title="trio.CapacityLimiter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CapacityLimiter</span></code></a>, as returned by <a class="reference internal" href="#trio.to_thread.current_default_thread_limiter" title="trio.to_thread.current_default_thread_limiter"><code class="xref py py-func docutils literal notranslate"><span class="pre">current_default_thread_limiter()</span></code></a>.</p> </li> </ul> </dd> </dl> <p><strong>Cancellation handling</strong>: Cancellation is a tricky issue here, because neither Python nor the operating systems it runs on provide any general mechanism for cancelling an arbitrary synchronous function running in a thread. This function will always check for cancellation on entry, before starting the thread. But once the thread is running, there are two ways it can handle being cancelled:</p> <ul> <li><p>If <code class="docutils literal notranslate"><span class="pre">cancellable=False</span></code>, the function ignores the cancellation and keeps going, just like if we had called <code class="docutils literal notranslate"><span class="pre">sync_fn</span></code> synchronously. This is the default behavior.</p></li> <li>
<p>If <code class="docutils literal notranslate"><span class="pre">cancellable=True</span></code>, then this function immediately raises <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Cancelled</span></code></a>. In this case <strong>the thread keeps running in background</strong> – we just abandon it to do whatever it’s going to do, and silently discard any return value or errors that it raises. Only use this if you know that the operation is safe and side-effect free. (For example: <a class="reference internal" href="reference-io.html#trio.socket.getaddrinfo" title="trio.socket.getaddrinfo"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.socket.getaddrinfo()</span></code></a> uses a thread with <code class="docutils literal notranslate"><span class="pre">cancellable=True</span></code>, because it doesn’t really affect anything if a stray hostname lookup keeps running in the background.)</p> <p>The <code class="docutils literal notranslate"><span class="pre">limiter</span></code> is only released after the thread has <em>actually</em> finished – which in the case of cancellation may be some time after this function has returned. If <a class="reference internal" href="#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a> finishes before the thread does, then the limiter release method will never be called at all.</p> </li> </ul> <blockquote class="admonition warning"> <h4 class="admonition-title">Warning</h4> <p>You should not use this function to call long-running CPU-bound functions! In addition to the usual GIL-related reasons why using threads for CPU-bound work is not very effective in Python, there is an additional problem: on CPython, <a class="reference external" href="https://bugs.python.org/issue7946">CPU-bound threads tend to “starve out” IO-bound threads</a>, so using threads for CPU-bound work is likely to adversely affect the main thread running Trio. If you need to do this, you’re better off using a worker process, or perhaps PyPy (which still has a GIL, but may do a better job of fairly allocating CPU time between threads).</p> </blockquote> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Returns<span class="colon">:</span>
</h4> <dd class="field-odd">
<p>Whatever <code class="docutils literal notranslate"><span class="pre">sync_fn(*args)</span></code> returns.</p> </dd> <h4 class="field-even" style="margin: 0">Raises<span class="colon">:</span>
</h4> <dd class="field-even">
<p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#Exception" title="(in Python v3.11)"><strong>Exception</strong></a> – Whatever <code class="docutils literal notranslate"><span class="pre">sync_fn(*args)</span></code> raises.</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 class="sig sig-object py" id="trio.to_thread.current_default_thread_limiter"><code>trio.to_thread.current_default_thread_limiter()</code></h3> <dd>
<p>Get the default <a class="reference internal" href="#trio.CapacityLimiter" title="trio.CapacityLimiter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CapacityLimiter</span></code></a> used by <a class="reference internal" href="#trio.to_thread.run_sync" title="trio.to_thread.run_sync"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.to_thread.run_sync</span></code></a>.</p> <p>The most common reason to call this would be if you want to modify its <a class="reference internal" href="#trio.CapacityLimiter.total_tokens" title="trio.CapacityLimiter.total_tokens"><code class="xref py py-attr docutils literal notranslate"><span class="pre">total_tokens</span></code></a> attribute.</p> </dd>
</dl> </section> <section id="getting-back-into-the-trio-thread-from-another-thread"> <h3>Getting back into the Trio thread from another thread</h3> <dl class="py function"> <h3 class="sig sig-object py" id="trio.from_thread.run"><code>trio.from_thread.run(afn, *args, trio_token=None)</code></h3> <dd>
<p>Run the given async function in the parent Trio thread, blocking until it is complete.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Returns<span class="colon">:</span>
</h4> <dd class="field-odd">
<p>Whatever <code class="docutils literal notranslate"><span class="pre">afn(*args)</span></code> returns.</p> </dd> </dl> <p>Returns or raises whatever the given function returns or raises. It can also raise exceptions of its own:</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Raises<span class="colon">:</span>
</h4> <dd class="field-odd">
<ul class="simple"> <li><p><a class="reference internal" href="#trio.RunFinishedError" title="trio.RunFinishedError"><strong>RunFinishedError</strong></a> – if the corresponding call to <a class="reference internal" href="#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a> has already completed, or if the run has started its final cleanup phase and can no longer spawn new system tasks.</p></li> <li><p><a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><strong>Cancelled</strong></a> – if the corresponding call to <a class="reference internal" href="#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a> completes while <code class="docutils literal notranslate"><span class="pre">afn(*args)</span></code> is running, then <code class="docutils literal notranslate"><span class="pre">afn</span></code> is likely to raise <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">trio.Cancelled</span></code></a>, and this will propagate out into</p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#RuntimeError" title="(in Python v3.11)"><strong>RuntimeError</strong></a> – if you try calling this from inside the Trio thread, which would otherwise cause a deadlock.</p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#AttributeError" title="(in Python v3.11)"><strong>AttributeError</strong></a> – if no <code class="docutils literal notranslate"><span class="pre">trio_token</span></code> was provided, and we can’t infer one from context.</p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#TypeError" title="(in Python v3.11)"><strong>TypeError</strong></a> – if <code class="docutils literal notranslate"><span class="pre">afn</span></code> is not an asynchronous function.</p></li> </ul> </dd> </dl> <p><strong>Locating a Trio Token</strong>: There are two ways to specify which <a class="reference internal" href="#trio.run" title="trio.run"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.run</span></code></a> loop to reenter:</p> <blockquote> <div>
<ul class="simple"> <li><p>Spawn this thread from <a class="reference internal" href="#trio.to_thread.run_sync" title="trio.to_thread.run_sync"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.to_thread.run_sync</span></code></a>. Trio will automatically capture the relevant Trio token and use it when you want to re-enter Trio.</p></li> <li><p>Pass a keyword argument, <code class="docutils literal notranslate"><span class="pre">trio_token</span></code> specifying a specific <a class="reference internal" href="#trio.run" title="trio.run"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.run</span></code></a> loop to re-enter. This is useful in case you have a “foreign” thread, spawned using some other framework, and still want to enter Trio.</p></li> </ul> </div>
</blockquote> </dd>
</dl> <dl class="py function"> <h3 class="sig sig-object py" id="trio.from_thread.run_sync"><code>trio.from_thread.run_sync(fn, *args, trio_token=None)</code></h3> <dd>
<p>Run the given sync function in the parent Trio thread, blocking until it is complete.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Returns<span class="colon">:</span>
</h4> <dd class="field-odd">
<p>Whatever <code class="docutils literal notranslate"><span class="pre">fn(*args)</span></code> returns.</p> </dd> </dl> <p>Returns or raises whatever the given function returns or raises. It can also raise exceptions of its own:</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Raises<span class="colon">:</span>
</h4> <dd class="field-odd">
<ul class="simple"> <li><p><a class="reference internal" href="#trio.RunFinishedError" title="trio.RunFinishedError"><strong>RunFinishedError</strong></a> – if the corresponding call to <a class="reference internal" href="#trio.run" title="trio.run"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.run</span></code></a> has already completed.</p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#RuntimeError" title="(in Python v3.11)"><strong>RuntimeError</strong></a> – if you try calling this from inside the Trio thread, which would otherwise cause a deadlock.</p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#AttributeError" title="(in Python v3.11)"><strong>AttributeError</strong></a> – if no <code class="docutils literal notranslate"><span class="pre">trio_token</span></code> was provided, and we can’t infer one from context.</p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#TypeError" title="(in Python v3.11)"><strong>TypeError</strong></a> – if <code class="docutils literal notranslate"><span class="pre">fn</span></code> is an async function.</p></li> </ul> </dd> </dl> <p><strong>Locating a Trio Token</strong>: There are two ways to specify which <a class="reference internal" href="#trio.run" title="trio.run"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.run</span></code></a> loop to reenter:</p> <blockquote> <div>
<ul class="simple"> <li><p>Spawn this thread from <a class="reference internal" href="#trio.to_thread.run_sync" title="trio.to_thread.run_sync"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.to_thread.run_sync</span></code></a>. Trio will automatically capture the relevant Trio token and use it when you want to re-enter Trio.</p></li> <li><p>Pass a keyword argument, <code class="docutils literal notranslate"><span class="pre">trio_token</span></code> specifying a specific <a class="reference internal" href="#trio.run" title="trio.run"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.run</span></code></a> loop to re-enter. This is useful in case you have a “foreign” thread, spawned using some other framework, and still want to enter Trio.</p></li> </ul> </div>
</blockquote> </dd>
</dl> <p>This will probably be clearer with an example. Here we demonstrate how to spawn a child thread, and then use a <a class="reference internal" href="#channels"><span class="std std-ref">memory channel</span></a> to send messages between the thread and a Trio task:</p> <pre data-language="python">import trio


def thread_fn(receive_from_trio, send_to_trio):
    while True:
        # Since we're in a thread, we can't call methods on Trio
        # objects directly -- so we use trio.from_thread to call them.
        try:
            request = trio.from_thread.run(receive_from_trio.receive)
        except trio.EndOfChannel:
            trio.from_thread.run(send_to_trio.aclose)
            return
        else:
            response = request + 1
            trio.from_thread.run(send_to_trio.send, response)


async def main():
    send_to_thread, receive_from_trio = trio.open_memory_channel(0)
    send_to_trio, receive_from_thread = trio.open_memory_channel(0)

    async with trio.open_nursery() as nursery:
        # In a background thread, run:
        #   thread_fn(receive_from_trio, send_to_trio)
        nursery.start_soon(
            trio.to_thread.run_sync, thread_fn, receive_from_trio, send_to_trio
        )

        # prints "1"
        await send_to_thread.send(0)
        print(await receive_from_thread.receive())

        # prints "2"
        await send_to_thread.send(1)
        print(await receive_from_thread.receive())

        # When we close the channel, it signals the thread to exit.
        await send_to_thread.aclose()

        # When we exit the nursery, it waits for the background thread to
        # exit.


trio.run(main)</pre> </section> <section id="threads-and-task-local-storage"> <h3>Threads and task-local storage</h3> <p>When working with threads, you can use the same <a class="reference external" href="https://docs.python.org/3/library/contextvars.html#module-contextvars" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">contextvars</span></code></a> we discussed above, because their values are preserved.</p> <p>This is done by automatically copying the <a class="reference external" href="https://docs.python.org/3/library/contextvars.html#module-contextvars" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">contextvars</span></code></a> context when you use any of:</p> <ul class="simple"> <li><p><a class="reference internal" href="#trio.to_thread.run_sync" title="trio.to_thread.run_sync"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.to_thread.run_sync</span></code></a></p></li> <li><p><a class="reference internal" href="#trio.from_thread.run" title="trio.from_thread.run"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.from_thread.run</span></code></a></p></li> <li><p><a class="reference internal" href="#trio.from_thread.run_sync" title="trio.from_thread.run_sync"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.from_thread.run_sync</span></code></a></p></li> </ul> <p>That means that the values of the context variables are accessible even in worker threads, or when sending a function to be run in the main/parent Trio thread using <a class="reference internal" href="#trio.from_thread.run" title="trio.from_thread.run"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.from_thread.run</span></code></a> <em>from</em> one of these worker threads.</p> <p>But it also means that as the context is not the same but a copy, if you <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#set" title="(in Python v3.11)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set</span></code></a> the context variable value <em>inside</em> one of these functions that work in threads, the new value will only be available in that context (that was copied). So, the new value will be available for that function and other internal/children tasks, but the value won’t be available in the parent thread.</p> <p>If you need to modify values that would live in the context variables and you need to make those modifications from the child threads, you can instead set a mutable object (e.g. a dictionary) in the context variable of the top level/parent Trio thread. Then in the children, instead of setting the context variable, you can <code class="docutils literal notranslate"><span class="pre">get</span></code> the same object, and modify its values. That way you keep the same object in the context variable and only mutate it in child threads.</p> <p>This way, you can modify the object content in child threads and still access the new content in the parent thread.</p> <p>Here’s an example:</p> <pre data-language="python">import contextvars
import time

import trio

request_state = contextvars.ContextVar("request_state")

# Blocking function that should be run on a thread
# It could be reading or writing files, communicating with a database
# with a driver not compatible with async / await, etc.
def work_in_thread(msg):
    # Only use request_state.get() inside the worker thread
    state_value = request_state.get()
    current_user_id = state_value["current_user_id"]
    time.sleep(3)  # this would be some blocking call, like reading a file
    print(f"Processed user {current_user_id} with message {msg} in a thread worker")
    # Modify/mutate the state object, without setting the entire
    # contextvar with request_state.set()
    state_value["msg"] = msg


# An example "request handler" that does some work itself and also
# spawns some helper tasks in threads to execute blocking code.
async def handle_request(current_user_id):
    # Write to task-local storage:
    current_state = {"current_user_id": current_user_id, "msg": ""}
    request_state.set(current_state)

    # Here the current implicit contextvars context will be automatically copied
    # inside the worker thread
    await trio.to_thread.run_sync(work_in_thread, f"Hello {current_user_id}")
    # Extract the value set inside the thread in the same object stored in a contextvar
    new_msg = current_state["msg"]
    print(
        f"New contextvar value from worker thread for user {current_user_id}: {new_msg}"
    )


# Spawn several "request handlers" simultaneously, to simulate a
# busy server handling multiple requests at the same time.
async def main():
    async with trio.open_nursery() as nursery:
        for i in range(3):
            nursery.start_soon(handle_request, i)


trio.run(main)</pre> <p>Running that script will result in the output:</p> <pre>Processed user 2 with message Hello 2 in a thread worker
Processed user 0 with message Hello 0 in a thread worker
Processed user 1 with message Hello 1 in a thread worker
New contextvar value from worker thread for user 2: Hello 2
New contextvar value from worker thread for user 1: Hello 1
New contextvar value from worker thread for user 0: Hello 0</pre> <p>If you are using <code class="docutils literal notranslate"><span class="pre">contextvars</span></code> or you are using a library that uses them, now you know how they interact when working with threads in Trio.</p> <p>But have in mind that in many cases it might be a lot simpler to <em>not</em> use context variables in your own code and instead pass values in arguments, as it might be more explicit and might be easier to reason about.</p> <blockquote class="admonition note"> <h4 class="admonition-title">Note</h4> <p>The context is automatically copied instead of using the same parent context because a single context can’t be used in more than one thread, it’s not supported by <code class="docutils literal notranslate"><span class="pre">contextvars</span></code>.</p> </blockquote> </section> </section> <section id="exceptions-and-warnings"> <h2>Exceptions and warnings</h2> <dl class="py exception"> <h3 class="sig sig-object py" id="trio.Cancelled"><code><em>exception</em> trio.Cancelled(*args: object, **kwargs: object)</code></h3> <dd>
<p>Raised by blocking calls if the surrounding scope has been cancelled.</p> <p>You should let this exception propagate, to be caught by the relevant cancel scope. To remind you of this, it inherits from <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#BaseException" title="(in Python v3.11)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BaseException</span></code></a> instead of <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#Exception" title="(in Python v3.11)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Exception</span></code></a>, just like <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#KeyboardInterrupt" title="(in Python v3.11)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">KeyboardInterrupt</span></code></a> and <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#SystemExit" title="(in Python v3.11)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">SystemExit</span></code></a> do. This means that if you write something like:</p> <pre data-language="python">try:
    ...
except Exception:
    ...</pre> <p>then this <em>won’t</em> catch a <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> exception.</p> <p>You cannot raise <a class="reference internal" href="#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a> yourself. Attempting to do so will produce a <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#TypeError" title="(in Python v3.11)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">TypeError</span></code></a>. Use <a class="reference internal" href="#trio.CancelScope.cancel" title="trio.CancelScope.cancel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cancel_scope.cancel()</span></code></a> instead.</p> <blockquote class="admonition note"> <h4 class="admonition-title">Note</h4> <p>In the US it’s also common to see this word spelled “canceled”, with only one “l”. This is a <a class="reference external" href="https://books.google.com/ngrams/graph?content=canceled%2Ccancelled&amp;year_start=1800&amp;year_end=2000&amp;corpus=5&amp;smoothing=3&amp;direct_url=t1%3B%2Ccanceled%3B%2Cc0%3B.t1%3B%2Ccancelled%3B%2Cc0">recent</a> and <a class="reference external" href="https://books.google.com/ngrams/graph?content=canceled%2Ccancelled&amp;year_start=1800&amp;year_end=2000&amp;corpus=18&amp;smoothing=3&amp;share=&amp;direct_url=t1%3B%2Ccanceled%3B%2Cc0%3B.t1%3B%2Ccancelled%3B%2Cc0">US-specific</a> innovation, and even in the US both forms are still commonly used. So for consistency with the rest of the world and with “cancellation” (which always has two “l”s), Trio uses the two “l” spelling everywhere.</p> </blockquote> </dd>
</dl> <dl class="py exception"> <h3 class="sig sig-object py" id="trio.TooSlowError"><code><em>exception</em> trio.TooSlowError</code></h3> <dd>
<p>Raised by <a class="reference internal" href="#trio.fail_after" title="trio.fail_after"><code class="xref py py-func docutils literal notranslate"><span class="pre">fail_after()</span></code></a> and <a class="reference internal" href="#trio.fail_at" title="trio.fail_at"><code class="xref py py-func docutils literal notranslate"><span class="pre">fail_at()</span></code></a> if the timeout expires.</p> </dd>
</dl> <dl class="py exception"> <h3 class="sig sig-object py" id="trio.WouldBlock"><code><em>exception</em> trio.WouldBlock</code></h3> <dd>
<p>Raised by <code class="docutils literal notranslate"><span class="pre">X_nowait</span></code> functions if <code class="docutils literal notranslate"><span class="pre">X</span></code> would block.</p> </dd>
</dl> <dl class="py exception"> <h3 class="sig sig-object py" id="trio.EndOfChannel"><code><em>exception</em> trio.EndOfChannel</code></h3> <dd>
<p>Raised when trying to receive from a <a class="reference internal" href="reference-io.html#trio.abc.ReceiveChannel" title="trio.abc.ReceiveChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.abc.ReceiveChannel</span></code></a> that has no more data to receive.</p> <p>This is analogous to an “end-of-file” condition, but for channels.</p> </dd>
</dl> <dl class="py exception"> <h3 class="sig sig-object py" id="trio.BusyResourceError"><code><em>exception</em> trio.BusyResourceError</code></h3> <dd>
<p>Raised when a task attempts to use a resource that some other task is already using, and this would lead to bugs and nonsense.</p> <p>For example, if two tasks try to send data through the same socket at the same time, Trio will raise <a class="reference internal" href="#trio.BusyResourceError" title="trio.BusyResourceError"><code class="xref py py-class docutils literal notranslate"><span class="pre">BusyResourceError</span></code></a> instead of letting the data get scrambled.</p> </dd>
</dl> <dl class="py exception"> <h3 class="sig sig-object py" id="trio.ClosedResourceError"><code><em>exception</em> trio.ClosedResourceError</code></h3> <dd>
<p>Raised when attempting to use a resource after it has been closed.</p> <p>Note that “closed” here means that <em>your</em> code closed the resource, generally by calling a method with a name like <code class="docutils literal notranslate"><span class="pre">close</span></code> or <code class="docutils literal notranslate"><span class="pre">aclose</span></code>, or by exiting a context manager. If a problem arises elsewhere – for example, because of a network failure, or because a remote peer closed their end of a connection – then that should be indicated by a different exception class, like <a class="reference internal" href="#trio.BrokenResourceError" title="trio.BrokenResourceError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BrokenResourceError</span></code></a> or an <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#OSError" title="(in Python v3.11)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">OSError</span></code></a> subclass.</p> </dd>
</dl> <dl class="py exception"> <h3 class="sig sig-object py" id="trio.BrokenResourceError"><code><em>exception</em> trio.BrokenResourceError</code></h3> <dd>
<p>Raised when an attempt to use a resource fails due to external circumstances.</p> <p>For example, you might get this if you try to send data on a stream where the remote side has already closed the connection.</p> <p>You <em>don’t</em> get this error if <em>you</em> closed the resource – in that case you get <a class="reference internal" href="#trio.ClosedResourceError" title="trio.ClosedResourceError"><code class="xref py py-class docutils literal notranslate"><span class="pre">ClosedResourceError</span></code></a>.</p> <p>This exception’s <code class="docutils literal notranslate"><span class="pre">__cause__</span></code> attribute will often contain more information about the underlying error.</p> </dd>
</dl> <dl class="py exception"> <h3 class="sig sig-object py" id="trio.RunFinishedError"><code><em>exception</em> trio.RunFinishedError</code></h3> <dd>
<p>Raised by <a class="reference internal" href="#trio.from_thread.run" title="trio.from_thread.run"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.from_thread.run</span></code></a> and similar functions if the corresponding call to <a class="reference internal" href="#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a> has already finished.</p> </dd>
</dl> <dl class="py exception"> <h3 class="sig sig-object py" id="trio.TrioInternalError"><code><em>exception</em> trio.TrioInternalError</code></h3> <dd>
<p>Raised by <a class="reference internal" href="#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">run()</span></code></a> if we encounter a bug in Trio, or (possibly) a misuse of one of the low-level <a class="reference internal" href="reference-lowlevel.html#module-trio.lowlevel" title="trio.lowlevel"><code class="xref py py-mod docutils literal notranslate"><span class="pre">trio.lowlevel</span></code></a> APIs.</p> <p>This should never happen! If you get this error, please file a bug.</p> <p>Unfortunately, if you get this error it also means that all bets are off – Trio doesn’t know what is going on and its normal invariants may be void. (For example, we might have “lost track” of a task. Or lost track of all tasks.) Again, though, this shouldn’t happen.</p> </dd>
</dl> <dl class="py exception"> <h3 class="sig sig-object py" id="trio.TrioDeprecationWarning"><code><em>exception</em> trio.TrioDeprecationWarning</code></h3> <dd>
<p>Bases: <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#FutureWarning" title="(in Python v3.11)"><code class="xref py py-class docutils literal notranslate"><span class="pre">FutureWarning</span></code></a></p> <p>Warning emitted if you use deprecated Trio functionality.</p> <p>As a young project, Trio is currently quite aggressive about deprecating and/or removing functionality that we realize was a bad idea. If you use Trio, you should subscribe to <a class="reference external" href="https://github.com/python-trio/trio/issues/1">issue #1</a> to get information about upcoming deprecations and other backwards compatibility breaking changes.</p> <p>Despite the name, this class currently inherits from <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#FutureWarning" title="(in Python v3.11)"><code class="xref py py-class docutils literal notranslate"><span class="pre">FutureWarning</span></code></a>, not <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#DeprecationWarning" title="(in Python v3.11)"><code class="xref py py-class docutils literal notranslate"><span class="pre">DeprecationWarning</span></code></a>, because while we’re in young-and-aggressive mode we want these warnings to be visible by default. You can hide them by installing a filter or with the <code class="docutils literal notranslate"><span class="pre">-W</span></code> switch: see the <a class="reference external" href="https://docs.python.org/3/library/warnings.html#module-warnings" title="(in Python v3.11)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">warnings</span></code></a> documentation for details.</p> </dd>
</dl> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2017 Nathaniel J. Smith<br>Licensed under the MIT License.<br>
    <a href="https://trio.readthedocs.io/en/v0.22.2/reference-core.html" class="_attribution-link">https://trio.readthedocs.io/en/v0.22.2/reference-core.html</a>
  </p>
</div>
