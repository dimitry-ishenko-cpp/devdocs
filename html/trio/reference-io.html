<section id="i-o-in-trio"> <h1>I/O in Trio</h1> <section id="the-abstract-stream-api"> <h2>The abstract Stream API</h2> <p>Trio provides a set of abstract base classes that define a standard interface for unidirectional and bidirectional byte streams.</p> <p>Why is this useful? Because it lets you write generic protocol implementations that can work over arbitrary transports, and easily create complex transport configurations. Here’s some examples:</p> <ul> <li><p><a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SocketStream" title="trio.SocketStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.SocketStream</span></code></a> wraps a raw socket (like a TCP connection over the network), and converts it to the standard stream interface.</p></li> <li><p><a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.SSLStream</span></code></a> is a “stream adapter” that can take any object that implements the <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.abc.Stream</span></code></a> interface, and convert it into an encrypted stream. In Trio the standard way to speak SSL over the network is to wrap an <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> around a <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SocketStream" title="trio.SocketStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketStream</span></code></a>.</p></li> <li>
<p>If you spawn a <a class="hxr-hoverxref hxr-tooltip reference internal" href="#subprocess"><span class="std std-ref">subprocess</span></a>, you can get a <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.SendStream" title="trio.abc.SendStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SendStream</span></code></a> that lets you write to its stdin, and a <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.ReceiveStream" title="trio.abc.ReceiveStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReceiveStream</span></code></a> that lets you read from its stdout. If for some reason you wanted to speak SSL to a subprocess, you could use a <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.StapledStream" title="trio.StapledStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">StapledStream</span></code></a> to combine its stdin/stdout into a single bidirectional <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a>, and then wrap that in an <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a>:</p> <pre>ssl_context = ssl.create_default_context()
ssl_context.check_hostname = False
s = SSLStream(StapledStream(process.stdin, process.stdout), ssl_context)</pre> </li> <li>
<p>It sometimes happens that you want to connect to an HTTPS server, but you have to go through a web proxy… and the proxy also uses HTTPS. So you end up having to do <a class="reference external" href="https://daniel.haxx.se/blog/2016/11/26/https-proxy-with-curl/">SSL-on-top-of-SSL</a>. In Trio this is trivial – just wrap your first <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> in a second <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a>:</p> <pre># Get a raw SocketStream connection to the proxy:
s0 = await open_tcp_stream("proxy", 443)

# Set up SSL connection to proxy:
s1 = SSLStream(s0, proxy_ssl_context, server_hostname="proxy")
# Request a connection to the website
await s1.send_all(b"CONNECT website:443 / HTTP/1.0\r\n\r\n")
await check_CONNECT_response(s1)

# Set up SSL connection to the real website. Notice that s1 is
# already an SSLStream object, and here we're wrapping a second
# SSLStream object around it.
s2 = SSLStream(s1, website_ssl_context, server_hostname="website")
# Make our request
await s2.send_all(b"GET /index.html HTTP/1.0\r\n\r\n")
...</pre> </li> <li><p>The <a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-testing.html#module-trio.testing" title="trio.testing"><code class="xref py py-mod docutils literal notranslate"><span class="pre">trio.testing</span></code></a> module provides a set of <a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-testing.html#testing-streams"><span class="std std-ref">flexible in-memory stream object implementations</span></a>, so if you have a protocol implementation to test then you can start two tasks, set up a virtual “socket” connecting them, and then do things like inject random-but-repeatable delays into the connection.</p></li> </ul> <section id="abstract-base-classes"> <h3>Abstract base classes</h3> <table class="docutils align-default" id="id1"> <caption><span class="caption-text">Overview: abstract base classes for I/O</span></caption> <thead> <tr class="row-odd">
<th class="head"><p>Abstract base class</p></th> <th class="head"><p>Inherits from…</p></th> <th class="head"><p>Adds these abstract methods…</p></th> <th class="head"><p>And these concrete methods.</p></th> <th class="head"><p>Example implementations</p></th> </tr> </thead> <tbody> <tr class="row-even">
<td><p><a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.AsyncResource" title="trio.abc.AsyncResource"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncResource</span></code></a></p></td> <td></td> <td><p><a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.AsyncResource.aclose" title="trio.abc.AsyncResource.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a></p></td> <td><p><code class="docutils literal notranslate"><span class="pre">__aenter__</span></code>, <code class="docutils literal notranslate"><span class="pre">__aexit__</span></code></p></td> <td><p><a class="hxr-hoverxref hxr-tooltip reference internal" href="#async-file-objects"><span class="std std-ref">Asynchronous file objects</span></a></p></td> </tr> <tr class="row-odd">
<td><p><a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.SendStream" title="trio.abc.SendStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SendStream</span></code></a></p></td> <td><p><a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.AsyncResource" title="trio.abc.AsyncResource"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncResource</span></code></a></p></td> <td><p><a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.SendStream.send_all" title="trio.abc.SendStream.send_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_all()</span></code></a>, <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.SendStream.wait_send_all_might_not_block" title="trio.abc.SendStream.wait_send_all_might_not_block"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait_send_all_might_not_block()</span></code></a></p></td> <td></td> <td><p><a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-testing.html#trio.testing.MemorySendStream" title="trio.testing.MemorySendStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemorySendStream</span></code></a></p></td> </tr> <tr class="row-even">
<td><p><a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.ReceiveStream" title="trio.abc.ReceiveStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReceiveStream</span></code></a></p></td> <td><p><a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.AsyncResource" title="trio.abc.AsyncResource"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncResource</span></code></a></p></td> <td><p><a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.ReceiveStream.receive_some" title="trio.abc.ReceiveStream.receive_some"><code class="xref py py-meth docutils literal notranslate"><span class="pre">receive_some()</span></code></a></p></td> <td><p><code class="docutils literal notranslate"><span class="pre">__aiter__</span></code>, <code class="docutils literal notranslate"><span class="pre">__anext__</span></code></p></td> <td><p><a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-testing.html#trio.testing.MemoryReceiveStream" title="trio.testing.MemoryReceiveStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemoryReceiveStream</span></code></a></p></td> </tr> <tr class="row-odd">
<td><p><a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a></p></td> <td><p><a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.SendStream" title="trio.abc.SendStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SendStream</span></code></a>, <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.ReceiveStream" title="trio.abc.ReceiveStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReceiveStream</span></code></a></p></td> <td></td> <td></td> <td><p><a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a></p></td> </tr> <tr class="row-even">
<td><p><a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.HalfCloseableStream" title="trio.abc.HalfCloseableStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">HalfCloseableStream</span></code></a></p></td> <td><p><a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a></p></td> <td><p><a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.HalfCloseableStream.send_eof" title="trio.abc.HalfCloseableStream.send_eof"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_eof()</span></code></a></p></td> <td></td> <td><p><a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SocketStream" title="trio.SocketStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketStream</span></code></a>, <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.StapledStream" title="trio.StapledStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">StapledStream</span></code></a></p></td> </tr> <tr class="row-odd">
<td><p><a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.Listener" title="trio.abc.Listener"><code class="xref py py-class docutils literal notranslate"><span class="pre">Listener</span></code></a></p></td> <td><p><a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.AsyncResource" title="trio.abc.AsyncResource"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncResource</span></code></a></p></td> <td><p><a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.Listener.accept" title="trio.abc.Listener.accept"><code class="xref py py-meth docutils literal notranslate"><span class="pre">accept()</span></code></a></p></td> <td></td> <td><p><a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SocketListener" title="trio.SocketListener"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketListener</span></code></a>, <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SSLListener" title="trio.SSLListener"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLListener</span></code></a></p></td> </tr> <tr class="row-even">
<td><p><a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.SendChannel" title="trio.abc.SendChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">SendChannel</span></code></a></p></td> <td><p><a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.AsyncResource" title="trio.abc.AsyncResource"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncResource</span></code></a></p></td> <td><p><a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.SendChannel.send" title="trio.abc.SendChannel.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a></p></td> <td></td> <td><p><a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-core.html#trio.MemorySendChannel" title="trio.MemorySendChannel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MemorySendChannel</span></code></a></p></td> </tr> <tr class="row-odd">
<td><p><a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.ReceiveChannel" title="trio.abc.ReceiveChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReceiveChannel</span></code></a></p></td> <td><p><a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.AsyncResource" title="trio.abc.AsyncResource"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncResource</span></code></a></p></td> <td><p><a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.ReceiveChannel.receive" title="trio.abc.ReceiveChannel.receive"><code class="xref py py-meth docutils literal notranslate"><span class="pre">receive()</span></code></a></p></td> <td><p><code class="docutils literal notranslate"><span class="pre">__aiter__</span></code>, <code class="docutils literal notranslate"><span class="pre">__anext__</span></code></p></td> <td><p><a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-core.html#trio.MemoryReceiveChannel" title="trio.MemoryReceiveChannel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MemoryReceiveChannel</span></code></a></p></td> </tr> <tr class="row-even">
<td><p><a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.Channel" title="trio.abc.Channel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Channel</span></code></a></p></td> <td><p><a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.SendChannel" title="trio.abc.SendChannel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SendChannel</span></code></a>, <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.ReceiveChannel" title="trio.abc.ReceiveChannel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReceiveChannel</span></code></a></p></td> <td></td> <td></td> <td></td> </tr> </tbody> </table> <dl class="py class"> <h3 class="sig sig-object py" id="trio.abc.AsyncResource"><code><em>class</em> trio.abc.AsyncResource</code></h3> <dd>
<p>A standard interface for resources that needs to be cleaned up, and where that cleanup may require blocking operations.</p> <p>This class distinguishes between “graceful” closes, which may perform I/O and thus block, and a “forceful” close, which cannot. For example, cleanly shutting down a TLS-encrypted connection requires sending a “goodbye” message; but if a peer has become non-responsive, then sending this message might block forever, so we may want to just drop the connection instead. Therefore the <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.AsyncResource.aclose" title="trio.abc.AsyncResource.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> method is unusual in that it should always close the connection (or at least make its best attempt) <em>even if it fails</em>; failure indicates a failure to achieve grace, not a failure to close the connection.</p> <p>Objects that implement this interface can be used as async context managers, i.e., you can write:</p> <pre data-language="python">async with create_resource() as some_async_resource:
    ...</pre> <p>Entering the context manager is synchronous (not a checkpoint); exiting it calls <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.AsyncResource.aclose" title="trio.abc.AsyncResource.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a>. The default implementations of <code class="docutils literal notranslate"><span class="pre">__aenter__</span></code> and <code class="docutils literal notranslate"><span class="pre">__aexit__</span></code> should be adequate for all subclasses.</p> <dl class="py method"> <h3 class="sig sig-object py" id="trio.abc.AsyncResource.aclose"><code><em>abstractmethod await</em> aclose() → None</code></h3> <dd>
<p>Close this resource, possibly blocking.</p> <p>IMPORTANT: This method may block in order to perform a “graceful” shutdown. But, if this fails, then it still <em>must</em> close any underlying resources before returning. An error from this method indicates a failure to achieve grace, <em>not</em> a failure to close the connection.</p> <p>For example, suppose we call <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.AsyncResource.aclose" title="trio.abc.AsyncResource.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> on a TLS-encrypted connection. This requires sending a “goodbye” message; but if the peer has become non-responsive, then our attempt to send this message might block forever, and eventually time out and be cancelled. In this case the <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.AsyncResource.aclose" title="trio.abc.AsyncResource.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> method on <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> will immediately close the underlying transport stream using <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.aclose_forcefully" title="trio.aclose_forcefully"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.aclose_forcefully()</span></code></a> before raising <a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-core.html#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a>.</p> <p>If the resource is already closed, then this method should silently succeed.</p> <p>Once this method completes, any other pending or future operations on this resource should generally raise <a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-core.html#trio.ClosedResourceError" title="trio.ClosedResourceError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ClosedResourceError</span></code></a>, unless there’s a good reason to do otherwise.</p> <p>See also: <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.aclose_forcefully" title="trio.aclose_forcefully"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.aclose_forcefully()</span></code></a>.</p> </dd>
</dl> </dd>
</dl> <dl class="py function"> <h3 class="sig sig-object py" id="trio.aclose_forcefully"><code><em>await</em> trio.aclose_forcefully(resource: AsyncResource) → None</code></h3> <dd>
<p>Close an async resource or async generator immediately, without blocking to do any graceful cleanup.</p> <p><a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.AsyncResource" title="trio.abc.AsyncResource"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncResource</span></code></a> objects guarantee that if their <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.AsyncResource.aclose" title="trio.abc.AsyncResource.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> method is cancelled, then they will still close the resource (albeit in a potentially ungraceful fashion). <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.aclose_forcefully" title="trio.aclose_forcefully"><code class="xref py py-func docutils literal notranslate"><span class="pre">aclose_forcefully()</span></code></a> is a convenience function that exploits this behavior to let you force a resource to be closed without blocking: it works by calling <code class="docutils literal notranslate"><span class="pre">await</span> <span class="pre">resource.aclose()</span></code> and then cancelling it immediately.</p> <p>Most users won’t need this, but it may be useful on cleanup paths where you can’t afford to block, or if you want to close a resource and don’t care about handling it gracefully. For example, if <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> encounters an error and cannot perform its own graceful close, then there’s no point in waiting to gracefully shut down the underlying transport either, so it calls <code class="docutils literal notranslate"><span class="pre">await</span>
<span class="pre">aclose_forcefully(self.transport_stream)</span></code>.</p> <p>Note that this function is async, and that it acts as a checkpoint, but unlike most async functions it cannot block indefinitely (at least, assuming the underlying resource object is correctly implemented).</p> </dd>
</dl> <dl class="py class"> <h3 class="sig sig-object py" id="trio.abc.SendStream"><code><em>class</em> trio.abc.SendStream</code></h3> <dd>
<p>Bases: <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.AsyncResource" title="trio.abc.AsyncResource"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncResource</span></code></a></p> <p>A standard interface for sending data on a byte stream.</p> <p>The underlying stream may be unidirectional, or bidirectional. If it’s bidirectional, then you probably want to also implement <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.ReceiveStream" title="trio.abc.ReceiveStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReceiveStream</span></code></a>, which makes your object a <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a>.</p> <p><a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.SendStream" title="trio.abc.SendStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SendStream</span></code></a> objects also implement the <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.AsyncResource" title="trio.abc.AsyncResource"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncResource</span></code></a> interface, so they can be closed by calling <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.AsyncResource.aclose" title="trio.abc.AsyncResource.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> or using an <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> block.</p> <p>If you want to send Python objects rather than raw bytes, see <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.SendChannel" title="trio.abc.SendChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">SendChannel</span></code></a>.</p> <dl class="py method"> <h3 class="sig sig-object py" id="trio.abc.SendStream.send_all"><code><em>abstractmethod await</em> send_all(data: bytes | bytearray | memoryview) → None</code></h3> <dd>
<p>Sends the given data through the stream, blocking if necessary.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><strong>data</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#bytes" title="(in Python v3.13)"><em>bytes</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#bytearray" title="(in Python v3.13)"><em>bytearray</em></a><em>, or </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#memoryview" title="(in Python v3.13)"><em>memoryview</em></a>) – The data to send.</p> </dd> <h4 class="field-even" style="margin: 0">Raises<span class="colon">:</span>
</h4> <dd class="field-even">
<ul class="simple"> <li><p><a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-core.html#trio.BusyResourceError" title="trio.BusyResourceError"><strong>trio.BusyResourceError</strong></a> – if another task is already executing a <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.SendStream.send_all" title="trio.abc.SendStream.send_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_all()</span></code></a>, <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.SendStream.wait_send_all_might_not_block" title="trio.abc.SendStream.wait_send_all_might_not_block"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait_send_all_might_not_block()</span></code></a>, or <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.HalfCloseableStream.send_eof" title="trio.abc.HalfCloseableStream.send_eof"><code class="xref py py-meth docutils literal notranslate"><span class="pre">HalfCloseableStream.send_eof()</span></code></a> on this stream.</p></li> <li><p><a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-core.html#trio.BrokenResourceError" title="trio.BrokenResourceError"><strong>trio.BrokenResourceError</strong></a> – if something has gone wrong, and the stream is broken.</p></li> <li><p><a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-core.html#trio.ClosedResourceError" title="trio.ClosedResourceError"><strong>trio.ClosedResourceError</strong></a> – if you previously closed this stream object, or if another task closes this stream object while <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.SendStream.send_all" title="trio.abc.SendStream.send_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_all()</span></code></a> is running.</p></li> </ul> </dd> </dl> <p>Most low-level operations in Trio provide a guarantee: if they raise <a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-core.html#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">trio.Cancelled</span></code></a>, this means that they had no effect, so the system remains in a known state. This is <strong>not true</strong> for <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.SendStream.send_all" title="trio.abc.SendStream.send_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_all()</span></code></a>. If this operation raises <a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-core.html#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">trio.Cancelled</span></code></a> (or any other exception for that matter), then it may have sent some, all, or none of the requested data, and there is no way to know which.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.abc.SendStream.wait_send_all_might_not_block"><code><em>abstractmethod await</em> wait_send_all_might_not_block() → None</code></h3> <dd>
<p>Block until it’s possible that <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.SendStream.send_all" title="trio.abc.SendStream.send_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_all()</span></code></a> might not block.</p> <p>This method may return early: it’s possible that after it returns, <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.SendStream.send_all" title="trio.abc.SendStream.send_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_all()</span></code></a> will still block. (In the worst case, if no better implementation is available, then it might always return immediately without blocking. It’s nice to do better than that when possible, though.)</p> <p>This method <strong>must not</strong> return <em>late</em>: if it’s possible for <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.SendStream.send_all" title="trio.abc.SendStream.send_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_all()</span></code></a> to complete without blocking, then it must return. When implementing it, err on the side of returning early.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Raises<span class="colon">:</span>
</h4> <dd class="field-odd">
<ul class="simple"> <li><p><a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-core.html#trio.BusyResourceError" title="trio.BusyResourceError"><strong>trio.BusyResourceError</strong></a> – if another task is already executing a <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.SendStream.send_all" title="trio.abc.SendStream.send_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_all()</span></code></a>, <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.SendStream.wait_send_all_might_not_block" title="trio.abc.SendStream.wait_send_all_might_not_block"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait_send_all_might_not_block()</span></code></a>, or <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.HalfCloseableStream.send_eof" title="trio.abc.HalfCloseableStream.send_eof"><code class="xref py py-meth docutils literal notranslate"><span class="pre">HalfCloseableStream.send_eof()</span></code></a> on this stream.</p></li> <li><p><a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-core.html#trio.BrokenResourceError" title="trio.BrokenResourceError"><strong>trio.BrokenResourceError</strong></a> – if something has gone wrong, and the stream is broken.</p></li> <li><p><a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-core.html#trio.ClosedResourceError" title="trio.ClosedResourceError"><strong>trio.ClosedResourceError</strong></a> – if you previously closed this stream object, or if another task closes this stream object while <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.SendStream.wait_send_all_might_not_block" title="trio.abc.SendStream.wait_send_all_might_not_block"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait_send_all_might_not_block()</span></code></a> is running.</p></li> </ul> </dd> </dl> <blockquote class="admonition note"> <h4 class="admonition-title">Note</h4> <p>This method is intended to aid in implementing protocols that want to delay choosing which data to send until the last moment. E.g., suppose you’re working on an implementation of a remote display server like <a class="reference external" href="https://en.wikipedia.org/wiki/Virtual_Network_Computing">VNC</a>, and the network connection is currently backed up so that if you call <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.SendStream.send_all" title="trio.abc.SendStream.send_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_all()</span></code></a> now then it will sit for 0.5 seconds before actually sending anything. In this case it doesn’t make sense to take a screenshot, then wait 0.5 seconds, and then send it, because the screen will keep changing while you wait; it’s better to wait 0.5 seconds, then take the screenshot, and then send it, because this way the data you deliver will be more up-to-date. Using <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.SendStream.wait_send_all_might_not_block" title="trio.abc.SendStream.wait_send_all_might_not_block"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait_send_all_might_not_block()</span></code></a> makes it possible to implement the better strategy.</p> <p>If you use this method, you might also want to read up on <code class="docutils literal notranslate"><span class="pre">TCP_NOTSENT_LOWAT</span></code>.</p> <p>Further reading:</p> <ul class="simple"> <li><p><a class="reference external" href="https://insouciant.org/tech/prioritization-only-works-when-theres-pending-data-to-prioritize/">Prioritization Only Works When There’s Pending Data to Prioritize</a></p></li> <li><p>WWDC 2015: Your App and Next Generation Networks: <a class="reference external" href="http://devstreaming.apple.com/videos/wwdc/2015/719ui2k57m/719/719_your_app_and_next_generation_networks.pdf?dl=1">slides</a>, <a class="reference external" href="https://developer.apple.com/videos/play/wwdc2015/719/">video and transcript</a></p></li> </ul> </blockquote> </dd>
</dl> </dd>
</dl> <dl class="py class"> <h3 class="sig sig-object py" id="trio.abc.ReceiveStream"><code><em>class</em> trio.abc.ReceiveStream</code></h3> <dd>
<p>Bases: <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.AsyncResource" title="trio.abc.AsyncResource"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncResource</span></code></a></p> <p>A standard interface for receiving data on a byte stream.</p> <p>The underlying stream may be unidirectional, or bidirectional. If it’s bidirectional, then you probably want to also implement <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.SendStream" title="trio.abc.SendStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SendStream</span></code></a>, which makes your object a <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a>.</p> <p><a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.ReceiveStream" title="trio.abc.ReceiveStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReceiveStream</span></code></a> objects also implement the <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.AsyncResource" title="trio.abc.AsyncResource"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncResource</span></code></a> interface, so they can be closed by calling <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.AsyncResource.aclose" title="trio.abc.AsyncResource.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> or using an <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> block.</p> <p>If you want to receive Python objects rather than raw bytes, see <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.ReceiveChannel" title="trio.abc.ReceiveChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReceiveChannel</span></code></a>.</p> <p><a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.ReceiveStream" title="trio.abc.ReceiveStream"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReceiveStream</span></code></a> objects can be used in <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> loops. Each iteration will produce an arbitrary sized chunk of bytes, like calling <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.ReceiveStream.receive_some" title="trio.abc.ReceiveStream.receive_some"><code class="xref py py-obj docutils literal notranslate"><span class="pre">receive_some</span></code></a> with no arguments. Every chunk will contain at least one byte, and the loop automatically exits when reaching end-of-file.</p> <dl class="py method"> <h3 class="sig sig-object py" id="trio.abc.ReceiveStream.receive_some"><code><em>abstractmethod await</em> receive_some(max_bytes: int | None = None) → bytes | bytearray</code></h3> <dd>
<p>Wait until there is data available on this stream, and then return some of it.</p> <p>A return value of <code class="docutils literal notranslate"><span class="pre">b""</span></code> (an empty bytestring) indicates that the stream has reached end-of-file. Implementations should be careful that they return <code class="docutils literal notranslate"><span class="pre">b""</span></code> if, and only if, the stream has reached end-of-file!</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><strong>max_bytes</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a>) – The maximum number of bytes to return. Must be greater than zero. Optional; if omitted, then the stream object is free to pick a reasonable default.</p> </dd> <h4 class="field-even" style="margin: 0">Returns<span class="colon">:</span>
</h4> <dd class="field-even">
<p>The data received.</p> </dd> <h4 class="field-odd" style="margin: 0">Return type<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#bytes" title="(in Python v3.13)">bytes</a> or <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#bytearray" title="(in Python v3.13)">bytearray</a></p> </dd> <h4 class="field-even" style="margin: 0">Raises<span class="colon">:</span>
</h4> <dd class="field-even">
<ul class="simple"> <li><p><a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-core.html#trio.BusyResourceError" title="trio.BusyResourceError"><strong>trio.BusyResourceError</strong></a> – if two tasks attempt to call <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.ReceiveStream.receive_some" title="trio.abc.ReceiveStream.receive_some"><code class="xref py py-meth docutils literal notranslate"><span class="pre">receive_some()</span></code></a> on the same stream at the same time.</p></li> <li><p><a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-core.html#trio.BrokenResourceError" title="trio.BrokenResourceError"><strong>trio.BrokenResourceError</strong></a> – if something has gone wrong, and the stream is broken.</p></li> <li><p><a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-core.html#trio.ClosedResourceError" title="trio.ClosedResourceError"><strong>trio.ClosedResourceError</strong></a> – if you previously closed this stream object, or if another task closes this stream object while <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.ReceiveStream.receive_some" title="trio.abc.ReceiveStream.receive_some"><code class="xref py py-meth docutils literal notranslate"><span class="pre">receive_some()</span></code></a> is running.</p></li> </ul> </dd> </dl> </dd>
</dl> </dd>
</dl> <dl class="py class"> <h3 class="sig sig-object py" id="trio.abc.Stream"><code><em>class</em> trio.abc.Stream</code></h3> <dd>
<p>Bases: <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.SendStream" title="trio.abc.SendStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SendStream</span></code></a>, <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.ReceiveStream" title="trio.abc.ReceiveStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReceiveStream</span></code></a></p> <p>A standard interface for interacting with bidirectional byte streams.</p> <p>A <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a> is an object that implements both the <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.SendStream" title="trio.abc.SendStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SendStream</span></code></a> and <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.ReceiveStream" title="trio.abc.ReceiveStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReceiveStream</span></code></a> interfaces.</p> <p>If implementing this interface, you should consider whether you can go one step further and implement <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.HalfCloseableStream" title="trio.abc.HalfCloseableStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">HalfCloseableStream</span></code></a>.</p> </dd>
</dl> <dl class="py class"> <h3 class="sig sig-object py" id="trio.abc.HalfCloseableStream"><code><em>class</em> trio.abc.HalfCloseableStream</code></h3> <dd>
<p>Bases: <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a></p> <p>This interface extends <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a> to also allow closing the send part of the stream without closing the receive part.</p> <dl class="py method"> <h3 class="sig sig-object py" id="trio.abc.HalfCloseableStream.send_eof"><code><em>abstractmethod await</em> send_eof() → None</code></h3> <dd>
<p>Send an end-of-file indication on this stream, if possible.</p> <p>The difference between <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.HalfCloseableStream.send_eof" title="trio.abc.HalfCloseableStream.send_eof"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_eof()</span></code></a> and <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.AsyncResource.aclose" title="trio.abc.AsyncResource.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> is that <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.HalfCloseableStream.send_eof" title="trio.abc.HalfCloseableStream.send_eof"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_eof()</span></code></a> is a <em>unidirectional</em> end-of-file indication. After you call this method, you shouldn’t try sending any more data on this stream, and your remote peer should receive an end-of-file indication (eventually, after receiving all the data you sent before that). But, they may continue to send data to you, and you can continue to receive it by calling <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.ReceiveStream.receive_some" title="trio.abc.ReceiveStream.receive_some"><code class="xref py py-meth docutils literal notranslate"><span class="pre">receive_some()</span></code></a>. You can think of it as calling <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.AsyncResource.aclose" title="trio.abc.AsyncResource.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> on just the <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.SendStream" title="trio.abc.SendStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SendStream</span></code></a> “half” of the stream object (and in fact that’s literally how <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.StapledStream" title="trio.StapledStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.StapledStream</span></code></a> implements it).</p> <p>Examples:</p> <ul class="simple"> <li><p>On a socket, this corresponds to <code class="docutils literal notranslate"><span class="pre">shutdown(...,</span> <span class="pre">SHUT_WR)</span></code> (<a class="reference external" href="https://linux.die.net/man/2/shutdown">man page</a>).</p></li> <li><p>The SSH protocol provides the ability to multiplex bidirectional “channels” on top of a single encrypted connection. A Trio implementation of SSH could expose these channels as <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.HalfCloseableStream" title="trio.abc.HalfCloseableStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">HalfCloseableStream</span></code></a> objects, and calling <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.HalfCloseableStream.send_eof" title="trio.abc.HalfCloseableStream.send_eof"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_eof()</span></code></a> would send an <code class="docutils literal notranslate"><span class="pre">SSH_MSG_CHANNEL_EOF</span></code> request (see <a class="reference external" href="https://tools.ietf.org/html/rfc4254#section-5.3">RFC 4254 §5.3</a>).</p></li> <li><p>On an SSL/TLS-encrypted connection, the protocol doesn’t provide any way to do a unidirectional shutdown without closing the connection entirely, so <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> implements <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a>, not <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.HalfCloseableStream" title="trio.abc.HalfCloseableStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">HalfCloseableStream</span></code></a>.</p></li> </ul> <p>If an EOF has already been sent, then this method should silently succeed.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Raises<span class="colon">:</span>
</h4> <dd class="field-odd">
<ul class="simple"> <li><p><a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-core.html#trio.BusyResourceError" title="trio.BusyResourceError"><strong>trio.BusyResourceError</strong></a> – if another task is already executing a <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.SendStream.send_all" title="trio.abc.SendStream.send_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_all()</span></code></a>, <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.SendStream.wait_send_all_might_not_block" title="trio.abc.SendStream.wait_send_all_might_not_block"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait_send_all_might_not_block()</span></code></a>, or <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.HalfCloseableStream.send_eof" title="trio.abc.HalfCloseableStream.send_eof"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_eof()</span></code></a> on this stream.</p></li> <li><p><a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-core.html#trio.BrokenResourceError" title="trio.BrokenResourceError"><strong>trio.BrokenResourceError</strong></a> – if something has gone wrong, and the stream is broken.</p></li> <li><p><a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-core.html#trio.ClosedResourceError" title="trio.ClosedResourceError"><strong>trio.ClosedResourceError</strong></a> – if you previously closed this stream object, or if another task closes this stream object while <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.HalfCloseableStream.send_eof" title="trio.abc.HalfCloseableStream.send_eof"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_eof()</span></code></a> is running.</p></li> </ul> </dd> </dl> </dd>
</dl> </dd>
</dl> <dl class="py class"> <h3 class="sig sig-object py" id="trio.abc.Listener"><code><em>class</em> trio.abc.Listener</code></h3> <dd>
<p>Bases: <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.AsyncResource" title="trio.abc.AsyncResource"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncResource</span></code></a>, <a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Generic" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a>[<a class="typevarref reference external" href="https://docs.python.org/3/library/typing.html#typing.TypeVar" title="(TypeVar, in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">T_resource</span></code></a>]</p> <p>A standard interface for listening for incoming connections.</p> <p><a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.Listener" title="trio.abc.Listener"><code class="xref py py-class docutils literal notranslate"><span class="pre">Listener</span></code></a> objects also implement the <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.AsyncResource" title="trio.abc.AsyncResource"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncResource</span></code></a> interface, so they can be closed by calling <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.AsyncResource.aclose" title="trio.abc.AsyncResource.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> or using an <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">with</span></code> block.</p> <dl class="py method"> <h3 class="sig sig-object py" id="trio.abc.Listener.accept"><code><em>abstractmethod await</em> accept() → T_resource</code></h3> <dd>
<p>Wait until an incoming connection arrives, and then return it.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Returns<span class="colon">:</span>
</h4> <dd class="field-odd">
<p>An object representing the incoming connection. In practice this is generally some kind of <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a>, but in principle you could also define a <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.Listener" title="trio.abc.Listener"><code class="xref py py-class docutils literal notranslate"><span class="pre">Listener</span></code></a> that returned, say, channel objects.</p> </dd> <h4 class="field-even" style="margin: 0">Return type<span class="colon">:</span>
</h4> <dd class="field-even">
<p><a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.AsyncResource" title="trio.abc.AsyncResource">AsyncResource</a></p> </dd> <h4 class="field-odd" style="margin: 0">Raises<span class="colon">:</span>
</h4> <dd class="field-odd">
<ul class="simple"> <li><p><a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-core.html#trio.BusyResourceError" title="trio.BusyResourceError"><strong>trio.BusyResourceError</strong></a> – if two tasks attempt to call <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.Listener.accept" title="trio.abc.Listener.accept"><code class="xref py py-meth docutils literal notranslate"><span class="pre">accept()</span></code></a> on the same listener at the same time.</p></li> <li><p><a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-core.html#trio.ClosedResourceError" title="trio.ClosedResourceError"><strong>trio.ClosedResourceError</strong></a> – if you previously closed this listener object, or if another task closes this listener object while <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.Listener.accept" title="trio.abc.Listener.accept"><code class="xref py py-meth docutils literal notranslate"><span class="pre">accept()</span></code></a> is running.</p></li> </ul> </dd> </dl> <p>Listeners don’t generally raise <a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-core.html#trio.BrokenResourceError" title="trio.BrokenResourceError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BrokenResourceError</span></code></a>, because for listeners there is no general condition of “the network/remote peer broke the connection” that can be handled in a generic way, like there is for streams. Other errors <em>can</em> occur and be raised from <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.Listener.accept" title="trio.abc.Listener.accept"><code class="xref py py-meth docutils literal notranslate"><span class="pre">accept()</span></code></a> – for example, if you run out of file descriptors then you might get an <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#OSError" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">OSError</span></code></a> with its errno set to <code class="docutils literal notranslate"><span class="pre">EMFILE</span></code>.</p> </dd>
</dl> </dd>
</dl> <dl class="py class"> <h3 class="sig sig-object py" id="trio.abc.SendChannel"><code><em>class</em> trio.abc.SendChannel</code></h3> <dd>
<p>Bases: <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.AsyncResource" title="trio.abc.AsyncResource"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncResource</span></code></a>, <a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Generic" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a>[<a class="typevarref reference external" href="https://docs.python.org/3/library/typing.html#typing.TypeVar" title="(TypeVar, in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SendType</span></code></a>]</p> <p>A standard interface for sending Python objects to some receiver.</p> <p><a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.SendChannel" title="trio.abc.SendChannel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SendChannel</span></code></a> objects also implement the <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.AsyncResource" title="trio.abc.AsyncResource"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AsyncResource</span></code></a> interface, so they can be closed by calling <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.AsyncResource.aclose" title="trio.abc.AsyncResource.aclose"><code class="xref py py-obj docutils literal notranslate"><span class="pre">aclose</span></code></a> or using an <code class="docutils literal notranslate"><span class="pre">async</span>
<span class="pre">with</span></code> block.</p> <p>If you want to send raw bytes rather than Python objects, see <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.SendStream" title="trio.abc.SendStream"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SendStream</span></code></a>.</p> <dl class="py method"> <h3 class="sig sig-object py" id="trio.abc.SendChannel.send"><code><em>abstractmethod await</em> send(value: SendType) → None</code></h3> <dd>
<p>Attempt to send an object through the channel, blocking if necessary.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><strong>value</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.13)"><em>object</em></a>) – The object to send.</p> </dd> <h4 class="field-even" style="margin: 0">Raises<span class="colon">:</span>
</h4> <dd class="field-even">
<ul class="simple"> <li><p><a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-core.html#trio.BrokenResourceError" title="trio.BrokenResourceError"><strong>trio.BrokenResourceError</strong></a> – if something has gone wrong, and the channel is broken. For example, you may get this if the receiver has already been closed.</p></li> <li><p><a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-core.html#trio.ClosedResourceError" title="trio.ClosedResourceError"><strong>trio.ClosedResourceError</strong></a> – if you previously closed this <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.SendChannel" title="trio.abc.SendChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">SendChannel</span></code></a> object, or if another task closes it while <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.SendChannel.send" title="trio.abc.SendChannel.send"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a> is running.</p></li> <li><p><a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-core.html#trio.BusyResourceError" title="trio.BusyResourceError"><strong>trio.BusyResourceError</strong></a> – some channels allow multiple tasks to call <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.SendChannel.send" title="trio.abc.SendChannel.send"><code class="xref py py-obj docutils literal notranslate"><span class="pre">send</span></code></a> at the same time, but others don’t. If you try to call <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.SendChannel.send" title="trio.abc.SendChannel.send"><code class="xref py py-obj docutils literal notranslate"><span class="pre">send</span></code></a> simultaneously from multiple tasks on a channel that doesn’t support it, then you can get <a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-core.html#trio.BusyResourceError" title="trio.BusyResourceError"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BusyResourceError</span></code></a>.</p></li> </ul> </dd> </dl> </dd>
</dl> </dd>
</dl> <dl class="py class"> <h3 class="sig sig-object py" id="trio.abc.ReceiveChannel"><code><em>class</em> trio.abc.ReceiveChannel</code></h3> <dd>
<p>Bases: <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.AsyncResource" title="trio.abc.AsyncResource"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncResource</span></code></a>, <a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Generic" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a>[<a class="typevarref reference external" href="https://docs.python.org/3/library/typing.html#typing.TypeVar" title="(TypeVar, in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReceiveType</span></code></a>]</p> <p>A standard interface for receiving Python objects from some sender.</p> <p>You can iterate over a <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.ReceiveChannel" title="trio.abc.ReceiveChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReceiveChannel</span></code></a> using an <code class="docutils literal notranslate"><span class="pre">async</span> <span class="pre">for</span></code> loop:</p> <pre data-language="python">async for value in receive_channel:
    ...</pre> <p>This is equivalent to calling <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.ReceiveChannel.receive" title="trio.abc.ReceiveChannel.receive"><code class="xref py py-meth docutils literal notranslate"><span class="pre">receive()</span></code></a> repeatedly. The loop exits without error when <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.ReceiveChannel.receive" title="trio.abc.ReceiveChannel.receive"><code class="xref py py-obj docutils literal notranslate"><span class="pre">receive</span></code></a> raises <a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-core.html#trio.EndOfChannel" title="trio.EndOfChannel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">EndOfChannel</span></code></a>.</p> <p><a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.ReceiveChannel" title="trio.abc.ReceiveChannel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReceiveChannel</span></code></a> objects also implement the <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.AsyncResource" title="trio.abc.AsyncResource"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AsyncResource</span></code></a> interface, so they can be closed by calling <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.AsyncResource.aclose" title="trio.abc.AsyncResource.aclose"><code class="xref py py-obj docutils literal notranslate"><span class="pre">aclose</span></code></a> or using an <code class="docutils literal notranslate"><span class="pre">async</span>
<span class="pre">with</span></code> block.</p> <p>If you want to receive raw bytes rather than Python objects, see <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.ReceiveStream" title="trio.abc.ReceiveStream"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReceiveStream</span></code></a>.</p> <dl class="py method"> <h3 class="sig sig-object py" id="trio.abc.ReceiveChannel.receive"><code><em>abstractmethod await</em> receive() → ReceiveType</code></h3> <dd>
<p>Attempt to receive an incoming object, blocking if necessary.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Returns<span class="colon">:</span>
</h4> <dd class="field-odd">
<p>Whatever object was received.</p> </dd> <h4 class="field-even" style="margin: 0">Return type<span class="colon">:</span>
</h4> <dd class="field-even">
<p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.13)">object</a></p> </dd> <h4 class="field-odd" style="margin: 0">Raises<span class="colon">:</span>
</h4> <dd class="field-odd">
<ul class="simple"> <li><p><a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-core.html#trio.EndOfChannel" title="trio.EndOfChannel"><strong>trio.EndOfChannel</strong></a> – if the sender has been closed cleanly, and no more objects are coming. This is not an error condition.</p></li> <li><p><a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-core.html#trio.ClosedResourceError" title="trio.ClosedResourceError"><strong>trio.ClosedResourceError</strong></a> – if you previously closed this <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.ReceiveChannel" title="trio.abc.ReceiveChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReceiveChannel</span></code></a> object.</p></li> <li><p><a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-core.html#trio.BrokenResourceError" title="trio.BrokenResourceError"><strong>trio.BrokenResourceError</strong></a> – if something has gone wrong, and the channel is broken.</p></li> <li><p><a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-core.html#trio.BusyResourceError" title="trio.BusyResourceError"><strong>trio.BusyResourceError</strong></a> – some channels allow multiple tasks to call <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.ReceiveChannel.receive" title="trio.abc.ReceiveChannel.receive"><code class="xref py py-obj docutils literal notranslate"><span class="pre">receive</span></code></a> at the same time, but others don’t. If you try to call <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.ReceiveChannel.receive" title="trio.abc.ReceiveChannel.receive"><code class="xref py py-obj docutils literal notranslate"><span class="pre">receive</span></code></a> simultaneously from multiple tasks on a channel that doesn’t support it, then you can get <a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-core.html#trio.BusyResourceError" title="trio.BusyResourceError"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BusyResourceError</span></code></a>.</p></li> </ul> </dd> </dl> </dd>
</dl> </dd>
</dl> <dl class="py class"> <h3 class="sig sig-object py" id="trio.abc.Channel"><code><em>class</em> trio.abc.Channel</code></h3> <dd>
<p>Bases: <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.SendChannel" title="trio.abc.SendChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">SendChannel</span></code></a>[<a class="typevarref reference external" href="https://docs.python.org/3/library/typing.html#typing.TypeVar" title="(TypeVar, in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">T</span></code></a>], <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.ReceiveChannel" title="trio.abc.ReceiveChannel"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReceiveChannel</span></code></a>[<a class="typevarref reference external" href="https://docs.python.org/3/library/typing.html#typing.TypeVar" title="(TypeVar, in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">T</span></code></a>]</p> <p>A standard interface for interacting with bidirectional channels.</p> <p>A <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.Channel" title="trio.abc.Channel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Channel</span></code></a> is an object that implements both the <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.SendChannel" title="trio.abc.SendChannel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SendChannel</span></code></a> and <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.ReceiveChannel" title="trio.abc.ReceiveChannel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReceiveChannel</span></code></a> interfaces, so you can both send and receive objects.</p> </dd>
</dl> </section> <section id="generic-stream-tools"> <h3>Generic stream tools</h3> <p>Trio currently provides a generic helper for writing servers that listen for connections using one or more <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.Listener" title="trio.abc.Listener"><code class="xref py py-class docutils literal notranslate"><span class="pre">Listener</span></code></a>s, and a generic utility class for working with streams. And if you want to test code that’s written against the streams interface, you should also check out <a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-testing.html#testing-streams"><span class="std std-ref">Streams</span></a> in <a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-testing.html#module-trio.testing" title="trio.testing"><code class="xref py py-mod docutils literal notranslate"><span class="pre">trio.testing</span></code></a>.</p> <dl class="py function"> <h3 class="sig sig-object py" id="trio.serve_listeners"><code><em>await</em> trio.serve_listeners(handler: Callable[[StreamT], Awaitable[object]], listeners: list[ListenerT], *, handler_nursery: Nursery | None = None, task_status: TaskStatus[list[ListenerT]] = TASK_STATUS_IGNORED) → NoReturn</code></h3> <dd>
<p>Listen for incoming connections on <code class="docutils literal notranslate"><span class="pre">listeners</span></code>, and for each one start a task running <code class="docutils literal notranslate"><span class="pre">handler(stream)</span></code>.</p> <blockquote class="admonition warning"> <h4 class="admonition-title">Warning</h4> <p>If <code class="docutils literal notranslate"><span class="pre">handler</span></code> raises an exception, then this function doesn’t do anything special to catch it – so by default the exception will propagate out and crash your server. If you don’t want this, then catch exceptions inside your <code class="docutils literal notranslate"><span class="pre">handler</span></code>, or use a <code class="docutils literal notranslate"><span class="pre">handler_nursery</span></code> object that responds to exceptions in some other way.</p> </blockquote> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<ul class="simple"> <li><p><strong>handler</strong> – An async callable, that will be invoked like <code class="docutils literal notranslate"><span class="pre">handler_nursery.start_soon(handler,</span> <span class="pre">stream)</span></code> for each incoming connection.</p></li> <li><p><strong>listeners</strong> – A list of <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.Listener" title="trio.abc.Listener"><code class="xref py py-class docutils literal notranslate"><span class="pre">Listener</span></code></a> objects. <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.serve_listeners" title="trio.serve_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">serve_listeners()</span></code></a> takes responsibility for closing them.</p></li> <li><p><strong>handler_nursery</strong> – The nursery used to start handlers, or any object with a <code class="docutils literal notranslate"><span class="pre">start_soon</span></code> method. If <code class="docutils literal notranslate"><span class="pre">None</span></code> (the default), then <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.serve_listeners" title="trio.serve_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">serve_listeners()</span></code></a> will create a new nursery internally and use that.</p></li> <li><p><strong>task_status</strong> – This function can be used with <code class="docutils literal notranslate"><span class="pre">nursery.start</span></code>, which will return <code class="docutils literal notranslate"><span class="pre">listeners</span></code>.</p></li> </ul> </dd> <h4 class="field-even" style="margin: 0">Returns<span class="colon">:</span>
</h4> <dd class="field-even">
<p>This function never returns unless cancelled.</p> </dd> </dl> <p>Resource handling:</p> <blockquote> <div>
<p>If <code class="docutils literal notranslate"><span class="pre">handler</span></code> neglects to close the <code class="docutils literal notranslate"><span class="pre">stream</span></code>, then it will be closed using <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.aclose_forcefully" title="trio.aclose_forcefully"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.aclose_forcefully()</span></code></a>.</p> </div>
</blockquote> <p>Error handling:</p> <blockquote> <div>
<p>Most errors coming from <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.Listener.accept" title="trio.abc.Listener.accept"><code class="xref py py-meth docutils literal notranslate"><span class="pre">accept()</span></code></a> are allowed to propagate out (crashing the server in the process). However, some errors – those which indicate that the server is temporarily overloaded – are handled specially. These are <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#OSError" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">OSError</span></code></a>s with one of the following errnos:</p> <ul class="simple"> <li><p><code class="docutils literal notranslate"><span class="pre">EMFILE</span></code>: process is out of file descriptors</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">ENFILE</span></code>: system is out of file descriptors</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">ENOBUFS</span></code>, <code class="docutils literal notranslate"><span class="pre">ENOMEM</span></code>: the kernel hit some sort of memory limitation when trying to create a socket object</p></li> </ul> <p>When <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.serve_listeners" title="trio.serve_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">serve_listeners()</span></code></a> gets one of these errors, then it:</p> <ul class="simple"> <li><p>Logs the error to the standard library logger <code class="docutils literal notranslate"><span class="pre">trio.serve_listeners</span></code> (level = ERROR, with exception information included). By default this causes it to be printed to stderr.</p></li> <li><p>Waits 100 ms before calling <code class="docutils literal notranslate"><span class="pre">accept</span></code> again, in hopes that the system will recover.</p></li> </ul> </div>
</blockquote> </dd>
</dl> <dl class="py class"> <h3 class="sig sig-object py" id="trio.StapledStream"><code><em>class</em> trio.StapledStream(send_stream: SendStreamT, receive_stream: ReceiveStreamT)</code></h3> <dd>
<p>Bases: <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.HalfCloseableStream" title="trio.abc.HalfCloseableStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">HalfCloseableStream</span></code></a>, <a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Generic" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a>[<a class="typevarref reference external" href="https://docs.python.org/3/library/typing.html#typing.TypeVar" title="(TypeVar, in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SendStreamT</span></code></a>, <a class="typevarref reference external" href="https://docs.python.org/3/library/typing.html#typing.TypeVar" title="(TypeVar, in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReceiveStreamT</span></code></a>]</p> <p>This class <a class="reference external" href="https://en.wikipedia.org/wiki/Staple_(fastener)">staples</a> together two unidirectional streams to make single bidirectional stream.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<ul class="simple"> <li><p><strong>send_stream</strong> (<a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.SendStream" title="trio.abc.SendStream"><em>SendStream</em></a>) – The stream to use for sending.</p></li> <li><p><strong>receive_stream</strong> (<a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.ReceiveStream" title="trio.abc.ReceiveStream"><em>ReceiveStream</em></a>) – The stream to use for receiving.</p></li> </ul> </dd> </dl> <p class="rubric">Example</p> <p>A silly way to make a stream that echoes back whatever you write to it:</p> <pre data-language="python">left, right = trio.testing.memory_stream_pair()
echo_stream = StapledStream(SocketStream(left), SocketStream(right))
await echo_stream.send_all(b"x")
assert await echo_stream.receive_some() == b"x"</pre> <p><a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.StapledStream" title="trio.StapledStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">StapledStream</span></code></a> objects implement the methods in the <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.HalfCloseableStream" title="trio.abc.HalfCloseableStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">HalfCloseableStream</span></code></a> interface. They also have two additional public attributes:</p> <dl class="py attribute"> <h3 class="sig sig-object py" id="trio.StapledStream.send_stream"><code>send_stream</code></h3> <dd>
<p>The underlying <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.SendStream" title="trio.abc.SendStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SendStream</span></code></a>. <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.StapledStream.send_all" title="trio.StapledStream.send_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_all()</span></code></a> and <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.StapledStream.wait_send_all_might_not_block" title="trio.StapledStream.wait_send_all_might_not_block"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait_send_all_might_not_block()</span></code></a> are delegated to this object.</p> </dd>
</dl> <dl class="py attribute"> <h3 class="sig sig-object py" id="trio.StapledStream.receive_stream"><code>receive_stream</code></h3> <dd>
<p>The underlying <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.ReceiveStream" title="trio.abc.ReceiveStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReceiveStream</span></code></a>. <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.StapledStream.receive_some" title="trio.StapledStream.receive_some"><code class="xref py py-meth docutils literal notranslate"><span class="pre">receive_some()</span></code></a> is delegated to this object.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.StapledStream.aclose"><code><em>await</em> aclose() → None</code></h3> <dd>
<p>Calls <code class="docutils literal notranslate"><span class="pre">aclose</span></code> on both underlying streams.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.StapledStream.receive_some"><code><em>await</em> receive_some(max_bytes: int | None = None) → bytes</code></h3> <dd>
<p>Calls <code class="docutils literal notranslate"><span class="pre">self.receive_stream.receive_some</span></code>.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.StapledStream.send_all"><code><em>await</em> send_all(data: bytes | bytearray | memoryview) → None</code></h3> <dd>
<p>Calls <code class="docutils literal notranslate"><span class="pre">self.send_stream.send_all</span></code>.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.StapledStream.send_eof"><code><em>await</em> send_eof() → None</code></h3> <dd>
<p>Shuts down the send side of the stream.</p> <p>If <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.HalfCloseableStream.send_eof" title="trio.abc.HalfCloseableStream.send_eof"><code class="xref py py-meth docutils literal notranslate"><span class="pre">self.send_stream.send_eof()</span></code></a> exists, then this calls it. Otherwise, this calls <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.AsyncResource.aclose" title="trio.abc.AsyncResource.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">self.send_stream.aclose()</span></code></a>.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.StapledStream.wait_send_all_might_not_block"><code><em>await</em> wait_send_all_might_not_block() → None</code></h3> <dd>
<p>Calls <code class="docutils literal notranslate"><span class="pre">self.send_stream.wait_send_all_might_not_block</span></code>.</p> </dd>
</dl> </dd>
</dl> </section> <section id="sockets-and-networking"> <h3>Sockets and networking</h3> <p>The high-level network interface is built on top of our stream abstraction.</p> <dl class="py function"> <h3 class="sig sig-object py" id="trio.open_tcp_stream"><code><em>await</em> trio.open_tcp_stream(host: str | bytes, port: int, *, happy_eyeballs_delay: float | None = 0.25, local_address: str | None = None) → SocketStream</code></h3> <dd>
<p>Connect to the given host and port over TCP.</p> <p>If the given <code class="docutils literal notranslate"><span class="pre">host</span></code> has multiple IP addresses associated with it, then we have a problem: which one do we use?</p> <p>One approach would be to attempt to connect to the first one, and then if that fails, attempt to connect to the second one … until we’ve tried all of them. But the problem with this is that if the first IP address is unreachable (for example, because it’s an IPv6 address and our network discards IPv6 packets), then we might end up waiting tens of seconds for the first connection attempt to timeout before we try the second address.</p> <p>Another approach would be to attempt to connect to all of the addresses at the same time, in parallel, and then use whichever connection succeeds first, abandoning the others. This would be fast, but create a lot of unnecessary load on the network and the remote server.</p> <p>This function strikes a balance between these two extremes: it works its way through the available addresses one at a time, like the first approach; but, if <code class="docutils literal notranslate"><span class="pre">happy_eyeballs_delay</span></code> seconds have passed and it’s still waiting for an attempt to succeed or fail, then it gets impatient and starts the next connection attempt in parallel. As soon as any one connection attempt succeeds, all the other attempts are cancelled. This avoids unnecessary load because most connections will succeed after just one or two attempts, but if one of the addresses is unreachable then it doesn’t slow us down too much.</p> <p>This is known as a “happy eyeballs” algorithm, and our particular variant is modelled after how Chrome connects to webservers; see <a class="reference external" href="https://tools.ietf.org/html/rfc6555">RFC 6555</a> for more details.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<ul class="simple"> <li><p><strong>host</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><em>str</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#bytes" title="(in Python v3.13)"><em>bytes</em></a>) – The host to connect to. Can be an IPv4 address, IPv6 address, or a hostname.</p></li> <li><p><strong>port</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a>) – The port to connect to.</p></li> <li><p><strong>happy_eyeballs_delay</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a><em> or </em><em>None</em>) – How many seconds to wait for each connection attempt to succeed or fail before getting impatient and starting another one in parallel. Set to <a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></a> if you want to limit to only one connection attempt at a time (like <a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.create_connection" title="(in Python v3.13)"><code class="xref py py-func docutils literal notranslate"><span class="pre">socket.create_connection()</span></code></a>). Default: 0.25 (250 ms).</p></li> <li>
<p><strong>local_address</strong> (<em>None</em><em> or </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><em>str</em></a>) – </p>
<p>The local IP address or hostname to use as the source for outgoing connections. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, we let the OS pick the source IP.</p> <p>This is useful in some exotic networking configurations where your host has multiple IP addresses, and you want to force the use of a specific one.</p> <p>Note that if you pass an IPv4 <code class="docutils literal notranslate"><span class="pre">local_address</span></code>, then you won’t be able to connect to IPv6 hosts, and vice-versa. If you want to take advantage of this to force the use of IPv4 or IPv6 without specifying an exact source address, you can use the IPv4 wildcard address <code class="docutils literal notranslate"><span class="pre">local_address="0.0.0.0"</span></code>, or the IPv6 wildcard address <code class="docutils literal notranslate"><span class="pre">local_address="::"</span></code>.</p> </li> </ul> </dd> <h4 class="field-even" style="margin: 0">Returns<span class="colon">:</span>
</h4> <dd class="field-even">
<p>a <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a> connected to the given server.</p> </dd> <h4 class="field-odd" style="margin: 0">Return type<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SocketStream" title="trio.SocketStream">SocketStream</a></p> </dd> <h4 class="field-even" style="margin: 0">Raises<span class="colon">:</span>
</h4> <dd class="field-even">
<p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#OSError" title="(in Python v3.13)"><strong>OSError</strong></a> – if the connection fails.</p> </dd> </dl> <blockquote class="admonition seealso"> <h4 class="admonition-title">See also</h4> <p>open_ssl_over_tcp_stream</p> </blockquote> </dd>
</dl> <dl class="py function"> <h3 class="sig sig-object py" id="trio.serve_tcp"><code><em>await</em> trio.serve_tcp(handler: Callable[[trio.SocketStream], Awaitable[object]], port: int, *, host: str | bytes | None = None, backlog: int | None = None, handler_nursery: trio.Nursery | None = None, task_status: TaskStatus[list[trio.SocketListener]] = TASK_STATUS_IGNORED) → None</code></h3> <dd>
<p>Listen for incoming TCP connections, and for each one start a task running <code class="docutils literal notranslate"><span class="pre">handler(stream)</span></code>.</p> <p>This is a thin convenience wrapper around <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.open_tcp_listeners" title="trio.open_tcp_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_tcp_listeners()</span></code></a> and <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.serve_listeners" title="trio.serve_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">serve_listeners()</span></code></a> – see them for full details.</p> <blockquote class="admonition warning"> <h4 class="admonition-title">Warning</h4> <p>If <code class="docutils literal notranslate"><span class="pre">handler</span></code> raises an exception, then this function doesn’t do anything special to catch it – so by default the exception will propagate out and crash your server. If you don’t want this, then catch exceptions inside your <code class="docutils literal notranslate"><span class="pre">handler</span></code>, or use a <code class="docutils literal notranslate"><span class="pre">handler_nursery</span></code> object that responds to exceptions in some other way.</p> </blockquote> <p>When used with <code class="docutils literal notranslate"><span class="pre">nursery.start</span></code> you get back the newly opened listeners. So, for example, if you want to start a server in your test suite and then connect to it to check that it’s working properly, you can use something like:</p> <pre data-language="python">from trio import SocketListener, SocketStream
from trio.testing import open_stream_to_socket_listener

async with trio.open_nursery() as nursery:
    listeners: list[SocketListener] = await nursery.start(serve_tcp, handler, 0)
    client_stream: SocketStream = await open_stream_to_socket_listener(listeners[0])

    # Then send and receive data on 'client_stream', for example:
    await client_stream.send_all(b"GET / HTTP/1.0\r\n\r\n")</pre> <p>This avoids several common pitfalls:</p> <ol class="arabic simple"> <li><p>It lets the kernel pick a random open port, so your test suite doesn’t depend on any particular port being open.</p></li> <li><p>It waits for the server to be accepting connections on that port before <code class="docutils literal notranslate"><span class="pre">start</span></code> returns, so there’s no race condition where the incoming connection arrives before the server is ready.</p></li> <li><p>It uses the Listener object to find out which port was picked, so it can connect to the right place.</p></li> </ol> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<ul class="simple"> <li><p><strong>handler</strong> – The handler to start for each incoming connection. Passed to <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.serve_listeners" title="trio.serve_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">serve_listeners()</span></code></a>.</p></li> <li><p><strong>port</strong> – The port to listen on. Use 0 to let the kernel pick an open port. Passed to <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.open_tcp_listeners" title="trio.open_tcp_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_tcp_listeners()</span></code></a>.</p></li> <li><p><strong>host</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><em>str</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#bytes" title="(in Python v3.13)"><em>bytes</em></a><em>, or </em><em>None</em>) – The host interface to listen on; use <code class="docutils literal notranslate"><span class="pre">None</span></code> to bind to the wildcard address. Passed to <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.open_tcp_listeners" title="trio.open_tcp_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_tcp_listeners()</span></code></a>.</p></li> <li><p><strong>backlog</strong> – The listen backlog, or None to have a good default picked. Passed to <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.open_tcp_listeners" title="trio.open_tcp_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_tcp_listeners()</span></code></a>.</p></li> <li><p><strong>handler_nursery</strong> – The nursery to start handlers in, or None to use an internal nursery. Passed to <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.serve_listeners" title="trio.serve_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">serve_listeners()</span></code></a>.</p></li> <li><p><strong>task_status</strong> – This function can be used with <code class="docutils literal notranslate"><span class="pre">nursery.start</span></code>.</p></li> </ul> </dd> <h4 class="field-even" style="margin: 0">Returns<span class="colon">:</span>
</h4> <dd class="field-even">
<p>This function only returns when cancelled.</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 class="sig sig-object py" id="trio.open_ssl_over_tcp_stream"><code><em>await</em> trio.open_ssl_over_tcp_stream(host: str | bytes, port: int, *, https_compatible: bool = False, ssl_context: ssl.SSLContext | None = None, happy_eyeballs_delay: float | None = 0.25) → trio.SSLStream[SocketStream]</code></h3> <dd>
<p>Make a TLS-encrypted Connection to the given host and port over TCP.</p> <p>This is a convenience wrapper that calls <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.open_tcp_stream" title="trio.open_tcp_stream"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_tcp_stream()</span></code></a> and wraps the result in an <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a>.</p> <p>This function does not perform the TLS handshake; you can do it manually by calling <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SSLStream.do_handshake" title="trio.SSLStream.do_handshake"><code class="xref py py-meth docutils literal notranslate"><span class="pre">do_handshake()</span></code></a>, or else it will be performed automatically the first time you send or receive data.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<ul class="simple"> <li><p><strong>host</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#bytes" title="(in Python v3.13)"><em>bytes</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><em>str</em></a>) – The host to connect to. We require the server to have a TLS certificate valid for this hostname.</p></li> <li><p><strong>port</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a>) – The port to connect to.</p></li> <li><p><strong>https_compatible</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a>) – Set this to True if you’re connecting to a web server. See <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> for details. Default: False.</p></li> <li><p><strong>ssl_context</strong> (<a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLContext" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> or None) – The SSL context to use. If None (the default), <a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.create_default_context" title="(in Python v3.13)"><code class="xref py py-func docutils literal notranslate"><span class="pre">ssl.create_default_context()</span></code></a> will be called to create a context.</p></li> <li><p><strong>happy_eyeballs_delay</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a>) – See <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.open_tcp_stream" title="trio.open_tcp_stream"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_tcp_stream()</span></code></a>.</p></li> </ul> </dd> <h4 class="field-even" style="margin: 0">Returns<span class="colon">:</span>
</h4> <dd class="field-even">
<p>the encrypted connection to the server.</p> </dd> <h4 class="field-odd" style="margin: 0">Return type<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SSLStream" title="trio.SSLStream">trio.SSLStream</a></p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 class="sig sig-object py" id="trio.serve_ssl_over_tcp"><code><em>await</em> trio.serve_ssl_over_tcp(handler: Callable[[trio.SSLStream[SocketStream]], Awaitable[object]], port: int, ssl_context: ssl.SSLContext, *, host: str | bytes | None = None, https_compatible: bool = False, backlog: int | None = None, handler_nursery: trio.Nursery | None = None, task_status: trio.TaskStatus[list[trio.SSLListener[SocketStream]]] = TASK_STATUS_IGNORED) → NoReturn</code></h3> <dd>
<p>Listen for incoming TCP connections, and for each one start a task running <code class="docutils literal notranslate"><span class="pre">handler(stream)</span></code>.</p> <p>This is a thin convenience wrapper around <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.open_ssl_over_tcp_listeners" title="trio.open_ssl_over_tcp_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_ssl_over_tcp_listeners()</span></code></a> and <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.serve_listeners" title="trio.serve_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">serve_listeners()</span></code></a> – see them for full details.</p> <blockquote class="admonition warning"> <h4 class="admonition-title">Warning</h4> <p>If <code class="docutils literal notranslate"><span class="pre">handler</span></code> raises an exception, then this function doesn’t do anything special to catch it – so by default the exception will propagate out and crash your server. If you don’t want this, then catch exceptions inside your <code class="docutils literal notranslate"><span class="pre">handler</span></code>, or use a <code class="docutils literal notranslate"><span class="pre">handler_nursery</span></code> object that responds to exceptions in some other way.</p> </blockquote> <p>When used with <code class="docutils literal notranslate"><span class="pre">nursery.start</span></code> you get back the newly opened listeners. See the documentation for <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.serve_tcp" title="trio.serve_tcp"><code class="xref py py-func docutils literal notranslate"><span class="pre">serve_tcp()</span></code></a> for an example where this is useful.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<ul class="simple"> <li><p><strong>handler</strong> – The handler to start for each incoming connection. Passed to <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.serve_listeners" title="trio.serve_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">serve_listeners()</span></code></a>.</p></li> <li><p><strong>port</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a>) – The port to listen on. Use 0 to let the kernel pick an open port. Ultimately passed to <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.open_tcp_listeners" title="trio.open_tcp_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_tcp_listeners()</span></code></a>.</p></li> <li><p><strong>ssl_context</strong> (<a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLContext" title="(in Python v3.13)"><em>SSLContext</em></a>) – The SSL context to use for all incoming connections. Passed to <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.open_ssl_over_tcp_listeners" title="trio.open_ssl_over_tcp_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_ssl_over_tcp_listeners()</span></code></a>.</p></li> <li><p><strong>host</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><em>str</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#bytes" title="(in Python v3.13)"><em>bytes</em></a><em>, or </em><em>None</em>) – The address to bind to; use <code class="docutils literal notranslate"><span class="pre">None</span></code> to bind to the wildcard address. Ultimately passed to <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.open_tcp_listeners" title="trio.open_tcp_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_tcp_listeners()</span></code></a>.</p></li> <li><p><strong>https_compatible</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a>) – Set this to True if you want to use “HTTPS-style” TLS. See <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> for details.</p></li> <li><p><strong>backlog</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em> or </em><em>None</em>) – See <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> for details.</p></li> <li><p><strong>handler_nursery</strong> – The nursery to start handlers in, or None to use an internal nursery. Passed to <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.serve_listeners" title="trio.serve_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">serve_listeners()</span></code></a>.</p></li> <li><p><strong>task_status</strong> – This function can be used with <code class="docutils literal notranslate"><span class="pre">nursery.start</span></code>.</p></li> </ul> </dd> <h4 class="field-even" style="margin: 0">Returns<span class="colon">:</span>
</h4> <dd class="field-even">
<p>This function only returns when cancelled.</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 class="sig sig-object py" id="trio.open_unix_socket"><code><em>await</em> trio.open_unix_socket(filename: str | bytes | PathLike[str] | PathLike[bytes]) → SocketStream</code></h3> <dd>
<p>Opens a connection to the specified <a class="reference external" href="https://en.wikipedia.org/wiki/Unix_domain_socket">Unix domain socket</a>.</p> <p>You must have read/write permission on the specified file to connect.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><strong>filename</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><em>str</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#bytes" title="(in Python v3.13)"><em>bytes</em></a>) – The filename to open the connection to.</p> </dd> <h4 class="field-even" style="margin: 0">Returns<span class="colon">:</span>
</h4> <dd class="field-even">
<p>a <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a> connected to the given file.</p> </dd> <h4 class="field-odd" style="margin: 0">Return type<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SocketStream" title="trio.SocketStream">SocketStream</a></p> </dd> <h4 class="field-even" style="margin: 0">Raises<span class="colon">:</span>
</h4> <dd class="field-even">
<ul class="simple"> <li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#OSError" title="(in Python v3.13)"><strong>OSError</strong></a> – If the socket file could not be connected to.</p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#RuntimeError" title="(in Python v3.13)"><strong>RuntimeError</strong></a> – If AF_UNIX sockets are not supported.</p></li> </ul> </dd> </dl> </dd>
</dl> <dl class="py class"> <h3 class="sig sig-object py" id="trio.SocketStream"><code><em>class</em> trio.SocketStream(socket: SocketType)</code></h3> <dd>
<p>Bases: <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.HalfCloseableStream" title="trio.abc.HalfCloseableStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">HalfCloseableStream</span></code></a></p> <p>An implementation of the <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.HalfCloseableStream" title="trio.abc.HalfCloseableStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.abc.HalfCloseableStream</span></code></a> interface based on a raw network socket.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><strong>socket</strong> – The Trio socket object to wrap. Must have type <code class="docutils literal notranslate"><span class="pre">SOCK_STREAM</span></code>, and be connected.</p> </dd> </dl> <p>By default for TCP sockets, <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SocketStream" title="trio.SocketStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketStream</span></code></a> enables <code class="docutils literal notranslate"><span class="pre">TCP_NODELAY</span></code>, and (on platforms where it’s supported) enables <code class="docutils literal notranslate"><span class="pre">TCP_NOTSENT_LOWAT</span></code> with a reasonable buffer size (currently 16 KiB) – see <a class="reference external" href="https://github.com/python-trio/trio/issues/72">issue #72</a> for discussion. You can of course override these defaults by calling <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SocketStream.setsockopt" title="trio.SocketStream.setsockopt"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setsockopt()</span></code></a>.</p> <p>Once a <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SocketStream" title="trio.SocketStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketStream</span></code></a> object is constructed, it implements the full <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.HalfCloseableStream" title="trio.abc.HalfCloseableStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.abc.HalfCloseableStream</span></code></a> interface. In addition, it provides a few extra features:</p> <dl class="py attribute"> <h3 class="sig sig-object py" id="trio.SocketStream.socket"><code>socket</code></h3> <dd>
<p>The Trio socket object that this stream wraps.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.SocketStream.aclose"><code><em>await</em> aclose() → None</code></h3> 
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.SocketStream.getsockopt"><code>getsockopt(level: int, option: int, buffersize: int = 0) → int | bytes</code></h3> <dd>
<p>Check the current value of an option on the underlying socket.</p> <p>See <a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.getsockopt" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.socket.getsockopt()</span></code></a> for details.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.SocketStream.receive_some"><code><em>await</em> receive_some(max_bytes: int | None = None) → bytes</code></h3> 
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.SocketStream.send_all"><code><em>await</em> send_all(data: bytes | bytearray | memoryview) → None</code></h3> 
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.SocketStream.send_eof"><code><em>await</em> send_eof() → None</code></h3> 
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.SocketStream.setsockopt"><code>setsockopt(level: int, option: int, value: int | Buffer | None, length: int | None = None) → None</code></h3> <dd>
<p>Set an option on the underlying socket.</p> <p>See <a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.setsockopt" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.socket.setsockopt()</span></code></a> for details.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.SocketStream.wait_send_all_might_not_block"><code><em>await</em> wait_send_all_might_not_block() → None</code></h3> 
</dl> </dd>
</dl> <dl class="py class"> <h3 class="sig sig-object py" id="trio.SocketListener"><code><em>class</em> trio.SocketListener(socket: SocketType)</code></h3> <dd>
<p>Bases: <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.Listener" title="trio.abc.Listener"><code class="xref py py-class docutils literal notranslate"><span class="pre">Listener</span></code></a>[<a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SocketStream" title="trio.SocketStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketStream</span></code></a>]</p> <p>A <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.Listener" title="trio.abc.Listener"><code class="xref py py-class docutils literal notranslate"><span class="pre">Listener</span></code></a> that uses a listening socket to accept incoming connections as <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SocketStream" title="trio.SocketStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketStream</span></code></a> objects.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><strong>socket</strong> – The Trio socket object to wrap. Must have type <code class="docutils literal notranslate"><span class="pre">SOCK_STREAM</span></code>, and be listening.</p> </dd> </dl> <p>Note that the <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SocketListener" title="trio.SocketListener"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketListener</span></code></a> “takes ownership” of the given socket; closing the <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SocketListener" title="trio.SocketListener"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketListener</span></code></a> will also close the socket.</p> <dl class="py attribute"> <h3 class="sig sig-object py" id="trio.SocketListener.socket"><code>socket</code></h3> <dd>
<p>The Trio socket object that this stream wraps.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.SocketListener.accept"><code><em>await</em> accept() → SocketStream</code></h3> <dd>
<p>Accept an incoming connection.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Returns<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SocketStream" title="trio.SocketStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketStream</span></code></a></p> </dd> <h4 class="field-even" style="margin: 0">Raises<span class="colon">:</span>
</h4> <dd class="field-even">
<ul class="simple"> <li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#OSError" title="(in Python v3.13)"><strong>OSError</strong></a> – if the underlying call to <code class="docutils literal notranslate"><span class="pre">accept</span></code> raises an unexpected error.</p></li> <li><p><a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-core.html#trio.ClosedResourceError" title="trio.ClosedResourceError"><strong>ClosedResourceError</strong></a> – if you already closed the socket.</p></li> </ul> </dd> </dl> <p>This method handles routine errors like <code class="docutils literal notranslate"><span class="pre">ECONNABORTED</span></code>, but passes other errors on to its caller. In particular, it does <em>not</em> make any special effort to handle resource exhaustion errors like <code class="docutils literal notranslate"><span class="pre">EMFILE</span></code>, <code class="docutils literal notranslate"><span class="pre">ENFILE</span></code>, <code class="docutils literal notranslate"><span class="pre">ENOBUFS</span></code>, <code class="docutils literal notranslate"><span class="pre">ENOMEM</span></code>.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.SocketListener.aclose"><code><em>await</em> aclose() → None</code></h3> <dd>
<p>Close this listener and its underlying socket.</p> </dd>
</dl> </dd>
</dl> <dl class="py function"> <h3 class="sig sig-object py" id="trio.open_tcp_listeners"><code><em>await</em> trio.open_tcp_listeners(port: int, *, host: str | bytes | None = None, backlog: int | None = None) → list[SocketListener]</code></h3> <dd>
<p>Create <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SocketListener" title="trio.SocketListener"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketListener</span></code></a> objects to listen for TCP connections.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<ul class="simple"> <li>
<p><strong>port</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a>) – </p>
<p>The port to listen on.</p> <p>If you use 0 as your port, then the kernel will automatically pick an arbitrary open port. But be careful: if you use this feature when binding to multiple IP addresses, then each IP address will get its own random port, and the returned listeners will probably be listening on different ports. In particular, this will happen if you use <code class="docutils literal notranslate"><span class="pre">host=None</span></code> – which is the default – because in this case <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.open_tcp_listeners" title="trio.open_tcp_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_tcp_listeners()</span></code></a> will bind to both the IPv4 wildcard address (<code class="docutils literal notranslate"><span class="pre">0.0.0.0</span></code>) and also the IPv6 wildcard address (<code class="docutils literal notranslate"><span class="pre">::</span></code>).</p> </li> <li>
<p><strong>host</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><em>str</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#bytes" title="(in Python v3.13)"><em>bytes</em></a><em>, or </em><em>None</em>) – </p>
<p>The local interface to bind to. This is passed to <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.socket.getaddrinfo" title="trio.socket.getaddrinfo"><code class="xref py py-func docutils literal notranslate"><span class="pre">getaddrinfo()</span></code></a> with the <code class="docutils literal notranslate"><span class="pre">AI_PASSIVE</span></code> flag set.</p> <p>If you want to bind to the wildcard address on both IPv4 and IPv6, in order to accept connections on all available interfaces, then pass <code class="docutils literal notranslate"><span class="pre">None</span></code>. This is the default.</p> <p>If you have a specific interface you want to bind to, pass its IP address or hostname here. If a hostname resolves to multiple IP addresses, this function will open one listener on each of them.</p> <p>If you want to use only IPv4, or only IPv6, but want to accept on all interfaces, pass the family-specific wildcard address: <code class="docutils literal notranslate"><span class="pre">"0.0.0.0"</span></code> for IPv4-only and <code class="docutils literal notranslate"><span class="pre">"::"</span></code> for IPv6-only.</p> </li> <li><p><strong>backlog</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em> or </em><em>None</em>) – The listen backlog to use. If you leave this as <code class="docutils literal notranslate"><span class="pre">None</span></code> then Trio will pick a good default. (Currently: whatever your system has configured as the maximum backlog.)</p></li> </ul> </dd> <h4 class="field-even" style="margin: 0">Returns<span class="colon">:</span>
</h4> <dd class="field-even">
<p>list of <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SocketListener" title="trio.SocketListener"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketListener</span></code></a></p> </dd> <h4 class="field-odd" style="margin: 0">Raises<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#TypeError" title="(in Python v3.13)"><strong>TypeError</strong></a> – </p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 class="sig sig-object py" id="trio.open_ssl_over_tcp_listeners"><code><em>await</em> trio.open_ssl_over_tcp_listeners(port: int, ssl_context: ssl.SSLContext, *, host: str | bytes | None = None, https_compatible: bool = False, backlog: int | None = None) → list[trio.SSLListener[SocketStream]]</code></h3> <dd>
<p>Start listening for SSL/TLS-encrypted TCP connections to the given port.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<ul class="simple"> <li><p><strong>port</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a>) – The port to listen on. See <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.open_tcp_listeners" title="trio.open_tcp_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_tcp_listeners()</span></code></a>.</p></li> <li><p><strong>ssl_context</strong> (<a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLContext" title="(in Python v3.13)"><em>SSLContext</em></a>) – The SSL context to use for all incoming connections.</p></li> <li><p><strong>host</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><em>str</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#bytes" title="(in Python v3.13)"><em>bytes</em></a><em>, or </em><em>None</em>) – The address to bind to; use <code class="docutils literal notranslate"><span class="pre">None</span></code> to bind to the wildcard address. See <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.open_tcp_listeners" title="trio.open_tcp_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_tcp_listeners()</span></code></a>.</p></li> <li><p><strong>https_compatible</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a>) – See <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> for details.</p></li> <li><p><strong>backlog</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a><em> or </em><em>None</em>) – See <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.open_tcp_listeners" title="trio.open_tcp_listeners"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_tcp_listeners()</span></code></a> for details.</p></li> </ul> </dd> </dl> </dd>
</dl> </section> <section id="ssl-tls-support"> <h3>SSL / TLS support</h3> <p>Trio provides SSL/TLS support based on the standard library <a class="reference external" href="https://docs.python.org/3/library/ssl.html#module-ssl" title="(in Python v3.13)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ssl</span></code></a> module. Trio’s <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> and <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SSLListener" title="trio.SSLListener"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLListener</span></code></a> take their configuration from a <a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLContext" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLContext</span></code></a>, which you can create using <a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.create_default_context" title="(in Python v3.13)"><code class="xref py py-func docutils literal notranslate"><span class="pre">ssl.create_default_context()</span></code></a> and customize using the other constants and functions in the <a class="reference external" href="https://docs.python.org/3/library/ssl.html#module-ssl" title="(in Python v3.13)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ssl</span></code></a> module.</p> <blockquote class="admonition warning"> <h4 class="admonition-title">Warning</h4> <p>Avoid instantiating <a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLContext" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLContext</span></code></a> directly. A newly constructed <a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLContext" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> has less secure defaults than one returned by <a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.create_default_context" title="(in Python v3.13)"><code class="xref py py-func docutils literal notranslate"><span class="pre">ssl.create_default_context()</span></code></a>.</p> </blockquote> <p>Instead of using <a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLContext.wrap_socket" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ssl.SSLContext.wrap_socket()</span></code></a>, you create a <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a>:</p> <dl class="py class"> <h3 class="sig sig-object py" id="trio.SSLStream"><code><em>class</em> trio.SSLStream(transport_stream: T_Stream, ssl_context: SSLContext, *, server_hostname: str | bytes | None = None, server_side: bool = False, https_compatible: bool = False)</code></h3> <dd>
<p>Bases: <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a>, <a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Generic" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Generic</span></code></a>[<a class="typevarref reference external" href="https://docs.python.org/3/library/typing.html#typing.TypeVar" title="(TypeVar, in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">T_Stream</span></code></a>]</p> <p>Encrypted communication using SSL/TLS.</p> <p><a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> wraps an arbitrary <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a>, and allows you to perform encrypted communication over it using the usual <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a> interface. You pass regular data to <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SSLStream.send_all" title="trio.SSLStream.send_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_all()</span></code></a>, then it encrypts it and sends the encrypted data on the underlying <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a>; <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SSLStream.receive_some" title="trio.SSLStream.receive_some"><code class="xref py py-meth docutils literal notranslate"><span class="pre">receive_some()</span></code></a> takes encrypted data out of the underlying <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a> and decrypts it before returning it.</p> <p>You should read the standard library’s <a class="reference external" href="https://docs.python.org/3/library/ssl.html#module-ssl" title="(in Python v3.13)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ssl</span></code></a> documentation carefully before attempting to use this class, and probably other general documentation on SSL/TLS as well. SSL/TLS is subtle and quick to anger. Really. I’m not kidding.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<ul class="simple"> <li><p><strong>transport_stream</strong> (<a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.Stream" title="trio.abc.Stream"><em>Stream</em></a>) – The stream used to transport encrypted data. Required.</p></li> <li><p><strong>ssl_context</strong> (<a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLContext" title="(in Python v3.13)"><em>SSLContext</em></a>) – The <a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLContext" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> used for this connection. Required. Usually created by calling <a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.create_default_context" title="(in Python v3.13)"><code class="xref py py-func docutils literal notranslate"><span class="pre">ssl.create_default_context()</span></code></a>.</p></li> <li><p><strong>server_hostname</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><em>str</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#bytes" title="(in Python v3.13)"><em>bytes</em></a><em>, or </em><em>None</em>) – The name of the server being connected to. Used for <a class="reference external" href="https://en.wikipedia.org/wiki/Server_Name_Indication">SNI</a> and for validating the server’s certificate (if hostname checking is enabled). This is effectively mandatory for clients, and actually mandatory if <code class="docutils literal notranslate"><span class="pre">ssl_context.check_hostname</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p></li> <li><p><strong>server_side</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a>) – Whether this stream is acting as a client or server. Defaults to False, i.e. client mode.</p></li> <li>
<p><strong>https_compatible</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a>) – </p>
<p>There are two versions of SSL/TLS commonly encountered in the wild: the standard version, and the version used for HTTPS (HTTP-over-SSL/TLS).</p> <p>Standard-compliant SSL/TLS implementations always send a cryptographically signed <code class="docutils literal notranslate"><span class="pre">close_notify</span></code> message before closing the connection. This is important because if the underlying transport were simply closed, then there wouldn’t be any way for the other side to know whether the connection was intentionally closed by the peer that they negotiated a cryptographic connection to, or by some <a class="reference external" href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack">man-in-the-middle</a> attacker who can’t manipulate the cryptographic stream, but can manipulate the transport layer (a so-called “truncation attack”).</p> <p>However, this part of the standard is widely ignored by real-world HTTPS implementations, which means that if you want to interoperate with them, then you NEED to ignore it too.</p> <p>Fortunately this isn’t as bad as it sounds, because the HTTP protocol already includes its own equivalent of <code class="docutils literal notranslate"><span class="pre">close_notify</span></code>, so doing this again at the SSL/TLS level is redundant. But not all protocols do! Therefore, by default Trio implements the safer standard-compliant version (<code class="docutils literal notranslate"><span class="pre">https_compatible=False</span></code>). But if you’re speaking HTTPS or some other protocol where <code class="docutils literal notranslate"><span class="pre">close_notify</span></code>s are commonly skipped, then you should set <code class="docutils literal notranslate"><span class="pre">https_compatible=True</span></code>; with this setting, Trio will neither expect nor send <code class="docutils literal notranslate"><span class="pre">close_notify</span></code> messages.</p> <p>If you have code that was written to use <a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLSocket" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLSocket</span></code></a> and now you’re porting it to Trio, then it may be useful to know that a difference between <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> and <a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLSocket" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLSocket</span></code></a> is that <a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLSocket" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLSocket</span></code></a> implements the <code class="docutils literal notranslate"><span class="pre">https_compatible=True</span></code> behavior by default.</p> </li> </ul> </dd> </dl> <dl class="py attribute"> <h3 class="sig sig-object py" id="trio.SSLStream.transport_stream"><code>transport_stream</code></h3> <dd>
<p>The underlying transport stream that was passed to <code class="docutils literal notranslate"><span class="pre">__init__</span></code>. An example of when this would be useful is if you’re using <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> over a <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SocketStream" title="trio.SocketStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketStream</span></code></a> and want to call the <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SocketStream" title="trio.SocketStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketStream</span></code></a>’s <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SocketStream.setsockopt" title="trio.SocketStream.setsockopt"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setsockopt()</span></code></a> method.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Type<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.Stream" title="trio.abc.Stream">trio.abc.Stream</a></p> </dd> </dl> </dd>
</dl> <p>Internally, this class is implemented using an instance of <a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLObject" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLObject</span></code></a>, and all of <a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLObject" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLObject</span></code></a>’s methods and attributes are re-exported as methods and attributes on this class. However, there is one difference: <a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLObject" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLObject</span></code></a> has several methods that return information about the encrypted connection, like <a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLSocket.cipher" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cipher()</span></code></a> or <a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLSocket.selected_alpn_protocol" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">selected_alpn_protocol()</span></code></a>. If you call them before the handshake, when they can’t possibly return useful data, then <a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLObject" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLObject</span></code></a> returns None, but <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.SSLStream</span></code></a> raises <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.NeedHandshakeError" title="trio.NeedHandshakeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NeedHandshakeError</span></code></a>.</p> <p>This also means that if you register a SNI callback using <a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLContext.sni_callback" title="(in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sni_callback</span></code></a>, then the first argument your callback receives will be a <a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLObject" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ssl.SSLObject</span></code></a>.</p> <dl class="py method"> <h3 class="sig sig-object py" id="trio.SSLStream.aclose"><code><em>await</em> aclose() → None</code></h3> <dd>
<p>Gracefully shut down this connection, and close the underlying transport.</p> <p>If <code class="docutils literal notranslate"><span class="pre">https_compatible</span></code> is False (the default), then this attempts to first send a <code class="docutils literal notranslate"><span class="pre">close_notify</span></code> and then close the underlying stream by calling its <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.AsyncResource.aclose" title="trio.abc.AsyncResource.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> method.</p> <p>If <code class="docutils literal notranslate"><span class="pre">https_compatible</span></code> is set to True, then this simply closes the underlying stream and marks this stream as closed.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.SSLStream.do_handshake"><code><em>await</em> do_handshake() → None</code></h3> <dd>
<p>Ensure that the initial handshake has completed.</p> <p>The SSL protocol requires an initial handshake to exchange certificates, select cryptographic keys, and so forth, before any actual data can be sent or received. You don’t have to call this method; if you don’t, then <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> will automatically perform the handshake as needed, the first time you try to send or receive data. But if you want to trigger it manually – for example, because you want to look at the peer’s certificate before you start talking to them – then you can call this method.</p> <p>If the initial handshake is already in progress in another task, this waits for it to complete and then returns.</p> <p>If the initial handshake has already completed, this returns immediately without doing anything (except executing a checkpoint).</p> <blockquote class="admonition warning"> <h4 class="admonition-title">Warning</h4> <p>If this method is cancelled, then it may leave the <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> in an unusable state. If this happens then any future attempt to use the object will raise <a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-core.html#trio.BrokenResourceError" title="trio.BrokenResourceError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">trio.BrokenResourceError</span></code></a>.</p> </blockquote> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.SSLStream.receive_some"><code><em>await</em> receive_some(max_bytes: int | None = None) → bytes | bytearray</code></h3> <dd>
<p>Read some data from the underlying transport, decrypt it, and return it.</p> <p>See <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.ReceiveStream.receive_some" title="trio.abc.ReceiveStream.receive_some"><code class="xref py py-meth docutils literal notranslate"><span class="pre">trio.abc.ReceiveStream.receive_some()</span></code></a> for details.</p> <blockquote class="admonition warning"> <h4 class="admonition-title">Warning</h4> <p>If this method is cancelled while the initial handshake or a renegotiation are in progress, then it may leave the <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> in an unusable state. If this happens then any future attempt to use the object will raise <a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-core.html#trio.BrokenResourceError" title="trio.BrokenResourceError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">trio.BrokenResourceError</span></code></a>.</p> </blockquote> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.SSLStream.send_all"><code><em>await</em> send_all(data: bytes | bytearray | memoryview) → None</code></h3> <dd>
<p>Encrypt some data and then send it on the underlying transport.</p> <p>See <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.SendStream.send_all" title="trio.abc.SendStream.send_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">trio.abc.SendStream.send_all()</span></code></a> for details.</p> <blockquote class="admonition warning"> <h4 class="admonition-title">Warning</h4> <p>If this method is cancelled, then it may leave the <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> in an unusable state. If this happens then any attempt to use the object will raise <a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-core.html#trio.BrokenResourceError" title="trio.BrokenResourceError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">trio.BrokenResourceError</span></code></a>.</p> </blockquote> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.SSLStream.unwrap"><code><em>await</em> unwrap() → tuple[Stream, bytes | bytearray]</code></h3> <dd>
<p>Cleanly close down the SSL/TLS encryption layer, allowing the underlying stream to be used for unencrypted communication.</p> <p>You almost certainly don’t need this.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Returns<span class="colon">:</span>
</h4> <dd class="field-odd">
<p>A pair <code class="docutils literal notranslate"><span class="pre">(transport_stream,</span> <span class="pre">trailing_bytes)</span></code>, where <code class="docutils literal notranslate"><span class="pre">transport_stream</span></code> is the underlying transport stream, and <code class="docutils literal notranslate"><span class="pre">trailing_bytes</span></code> is a byte string. Since <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> doesn’t necessarily know where the end of the encrypted data will be, it can happen that it accidentally reads too much from the underlying stream. <code class="docutils literal notranslate"><span class="pre">trailing_bytes</span></code> contains this extra data; you should process it as if it was returned from a call to <code class="docutils literal notranslate"><span class="pre">transport_stream.receive_some(...)</span></code>.</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.SSLStream.wait_send_all_might_not_block"><code><em>await</em> wait_send_all_might_not_block() → None</code></h3> <dd>
<p>See <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.SendStream.wait_send_all_might_not_block" title="trio.abc.SendStream.wait_send_all_might_not_block"><code class="xref py py-meth docutils literal notranslate"><span class="pre">trio.abc.SendStream.wait_send_all_might_not_block()</span></code></a>.</p> </dd>
</dl> </dd>
</dl> <p>And if you’re implementing a server, you can use <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SSLListener" title="trio.SSLListener"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLListener</span></code></a>:</p> <dl class="py class"> <h3 class="sig sig-object py" id="trio.SSLListener"><code><em>class</em> trio.SSLListener(transport_listener: Listener[T_Stream], ssl_context: SSLContext, *, https_compatible: bool = False)</code></h3> <dd>
<p>Bases: <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.Listener" title="trio.abc.Listener"><code class="xref py py-class docutils literal notranslate"><span class="pre">Listener</span></code></a>[<a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a>[<a class="typevarref reference external" href="https://docs.python.org/3/library/typing.html#typing.TypeVar" title="(TypeVar, in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">T_Stream</span></code></a>]]</p> <p>A <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.Listener" title="trio.abc.Listener"><code class="xref py py-class docutils literal notranslate"><span class="pre">Listener</span></code></a> for SSL/TLS-encrypted servers.</p> <p><a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SSLListener" title="trio.SSLListener"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLListener</span></code></a> wraps around another Listener, and converts all incoming connections to encrypted connections by wrapping them in a <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a>.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<ul class="simple"> <li><p><strong>transport_listener</strong> (<a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.Listener" title="trio.abc.Listener"><em>Listener</em></a>) – The listener whose incoming connections will be wrapped in <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a>.</p></li> <li><p><strong>ssl_context</strong> (<a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLContext" title="(in Python v3.13)"><em>SSLContext</em></a>) – The <a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLContext" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLContext</span></code></a> that will be used for incoming connections.</p></li> <li><p><strong>https_compatible</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a>) – Passed on to <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a>.</p></li> </ul> </dd> </dl> <dl class="py attribute"> <h3 class="sig sig-object py" id="trio.SSLListener.transport_listener"><code>transport_listener</code></h3> <dd>
<p>The underlying listener that was passed to <code class="docutils literal notranslate"><span class="pre">__init__</span></code>.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Type<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.Listener" title="trio.abc.Listener">trio.abc.Listener</a></p> </dd> </dl> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.SSLListener.accept"><code><em>await</em> accept() → SSLStream[T_Stream]</code></h3> <dd>
<p>Accept the next connection and wrap it in an <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a>.</p> <p>See <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.Listener.accept" title="trio.abc.Listener.accept"><code class="xref py py-meth docutils literal notranslate"><span class="pre">trio.abc.Listener.accept()</span></code></a> for details.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.SSLListener.aclose"><code><em>await</em> aclose() → None</code></h3> <dd>
<p>Close the transport listener.</p> </dd>
</dl> </dd>
</dl> <p>Some methods on <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> raise <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.NeedHandshakeError" title="trio.NeedHandshakeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">NeedHandshakeError</span></code></a> if you call them before the handshake completes:</p> <dl class="py exception"> <h3 class="sig sig-object py" id="trio.NeedHandshakeError"><code><em>exception</em> trio.NeedHandshakeError</code></h3> <dd>
<p>Some <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SSLStream" title="trio.SSLStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SSLStream</span></code></a> methods can’t return any meaningful data until after the handshake. If you call them before the handshake, they raise this error.</p> </dd>
</dl> </section> <section id="datagram-tls-support"> <h3>Datagram TLS support</h3> <p>Trio also has support for Datagram TLS (DTLS), which is like TLS but for unreliable UDP connections. This can be useful for applications where TCP’s reliable in-order delivery is problematic, like teleconferencing, latency-sensitive games, and VPNs.</p> <p>Currently, using DTLS with Trio requires PyOpenSSL. We hope to eventually allow the use of the stdlib <a class="reference external" href="https://docs.python.org/3/library/ssl.html#module-ssl" title="(in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ssl</span></code></a> module as well, but unfortunately that’s not yet possible.</p> <blockquote class="admonition warning"> <h4 class="admonition-title">Warning</h4> <p>Note that PyOpenSSL is in many ways lower-level than the <a class="reference external" href="https://docs.python.org/3/library/ssl.html#module-ssl" title="(in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ssl</span></code></a> module – in particular, it currently <strong>HAS NO BUILT-IN MECHANISM TO VALIDATE CERTIFICATES</strong>. We <em>strongly</em> recommend that you use the <a class="reference external" href="https://pypi.org/project/service-identity/">service-identity</a> library to validate hostnames and certificates.</p> </blockquote> <dl class="py class"> <h3 class="sig sig-object py" id="trio.DTLSEndpoint"><code><em>class</em> trio.DTLSEndpoint(socket: SocketType, *, incoming_packets_buffer: int = 10)</code></h3> <dd>
<p>A DTLS endpoint.</p> <p>A single UDP socket can handle arbitrarily many DTLS connections simultaneously, acting as a client or server as needed. A <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.DTLSEndpoint" title="trio.DTLSEndpoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DTLSEndpoint</span></code></a> object holds a UDP socket and manages these connections, which are represented as <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.DTLSChannel" title="trio.DTLSChannel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DTLSChannel</span></code></a> objects.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<ul class="simple"> <li><p><strong>socket</strong> – (trio.socket.SocketType): A <code class="docutils literal notranslate"><span class="pre">SOCK_DGRAM</span></code> socket. If you want to accept incoming connections in server mode, then you should probably bind the socket to some known port.</p></li> <li><p><strong>incoming_packets_buffer</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)"><em>int</em></a>) – Each <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.DTLSChannel" title="trio.DTLSChannel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DTLSChannel</span></code></a> using this socket has its own buffer that holds incoming packets until you call <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.DTLSChannel.receive" title="trio.DTLSChannel.receive"><code class="xref py py-obj docutils literal notranslate"><span class="pre">receive</span></code></a> to read them. This lets you adjust the size of this buffer. <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.DTLSChannel.statistics" title="trio.DTLSChannel.statistics"><code class="xref py py-obj docutils literal notranslate"><span class="pre">statistics</span></code></a> lets you check if the buffer has overflowed.</p></li> </ul> </dd> </dl> <dl class="py attribute"> <h3 class="sig sig-object py" id="trio.DTLSEndpoint.socket"><code>socket</code></h3> <h3 class="sig sig-object py" id="trio.DTLSEndpoint.incoming_packets_buffer"><code>incoming_packets_buffer</code></h3> <dd>
<p>Both constructor arguments are also exposed as attributes, in case you need to access them later.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.DTLSEndpoint.connect"><code>connect(address: tuple[str, int], ssl_context: OpenSSL.SSL.Context) → DTLSChannel</code></h3> <dd>
<p>Initiate an outgoing DTLS connection.</p> <p>Notice that this is a synchronous method. That’s because it doesn’t actually initiate any I/O – it just sets up a <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.DTLSChannel" title="trio.DTLSChannel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DTLSChannel</span></code></a> object. The actual handshake doesn’t occur until you start using the <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.DTLSChannel" title="trio.DTLSChannel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DTLSChannel</span></code></a>. This gives you a chance to do further configuration first, like setting MTU etc.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<ul class="simple"> <li><p><strong>address</strong> – The address to connect to. Usually a (host, port) tuple, like <code class="docutils literal notranslate"><span class="pre">("127.0.0.1",</span> <span class="pre">12345)</span></code>.</p></li> <li><p><strong>ssl_context</strong> (<a class="reference external" href="https://www.pyopenssl.org/en/stable/api/ssl.html#OpenSSL.SSL.Context" title="(in pyOpenSSL v25.0.0)"><em>OpenSSL.SSL.Context</em></a>) – The PyOpenSSL context object to use for this connection.</p></li> </ul> </dd> <h4 class="field-even" style="margin: 0">Returns<span class="colon">:</span>
</h4> <dd class="field-even">
<p>DTLSChannel</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.DTLSEndpoint.serve"><code><em>await</em> serve(ssl_context: OpenSSL.SSL.Context, async_fn: Callable[[DTLSChannel, Unpack[PosArgsT]], Awaitable[object]], *args: Unpack[PosArgsT], task_status: trio.TaskStatus[None] = TASK_STATUS_IGNORED) → None</code></h3> <dd>
<p>Listen for incoming connections, and spawn a handler for each using an internal nursery.</p> <p>Similar to <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.serve_tcp" title="trio.serve_tcp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">serve_tcp</span></code></a>, this function never returns until cancelled, or the <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.DTLSEndpoint" title="trio.DTLSEndpoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DTLSEndpoint</span></code></a> is closed and all handlers have exited.</p> <p>Usage commonly looks like:</p> <pre data-language="python">async def handler(dtls_channel):
    ...

async with trio.open_nursery() as nursery:
    await nursery.start(dtls_endpoint.serve, ssl_context, handler)
    # ... do other things here ...</pre> <p>The <code class="docutils literal notranslate"><span class="pre">dtls_channel</span></code> passed into the handler function has already performed the “cookie exchange” part of the DTLS handshake, so the peer address is trustworthy. But the actual cryptographic handshake doesn’t happen until you start using it, giving you a chance for any last minute configuration, and the option to catch and handle handshake errors.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<ul class="simple"> <li><p><strong>ssl_context</strong> (<a class="reference external" href="https://www.pyopenssl.org/en/stable/api/ssl.html#OpenSSL.SSL.Context" title="(in pyOpenSSL v25.0.0)"><em>OpenSSL.SSL.Context</em></a>) – The PyOpenSSL context object to use for incoming connections.</p></li> <li><p><strong>async_fn</strong> – The handler function that will be invoked for each incoming connection.</p></li> <li><p><strong>*args</strong> – Additional arguments to pass to the handler function.</p></li> </ul> </dd> </dl> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.DTLSEndpoint.close"><code>close() → None</code></h3> <dd>
<p>Close this socket, and all associated DTLS connections.</p> <p>This object can also be used as a context manager.</p> </dd>
</dl> </dd>
</dl> <dl class="py class"> <h3 class="sig sig-object py" id="trio.DTLSChannel"><code><em>class</em> trio.DTLSChannel(*args: object, **kwargs: object)</code></h3> <dd>
<p>Bases: <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.Channel" title="trio.abc.Channel"><code class="xref py py-class docutils literal notranslate"><span class="pre">Channel</span></code></a>[<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#bytes" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>]</p> <p>A DTLS connection.</p> <p>This class has no public constructor – you get instances by calling <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.DTLSEndpoint.serve" title="trio.DTLSEndpoint.serve"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DTLSEndpoint.serve</span></code></a> or <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.DTLSEndpoint.connect" title="trio.DTLSEndpoint.connect"><code class="xref py py-obj docutils literal notranslate"><span class="pre">connect</span></code></a>.</p> <dl class="py attribute"> <h3 class="sig sig-object py" id="trio.DTLSChannel.endpoint"><code>endpoint</code></h3> <dd>
<p>The <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.DTLSEndpoint" title="trio.DTLSEndpoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DTLSEndpoint</span></code></a> that this connection is using.</p> </dd>
</dl> <dl class="py attribute"> <h3 class="sig sig-object py" id="trio.DTLSChannel.peer_address"><code>peer_address</code></h3> <dd>
<p>The IP/port of the remote peer that this connection is associated with.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.DTLSChannel.do_handshake"><code><em>await</em> do_handshake(*, initial_retransmit_timeout: float = 1.0) → None</code></h3> <dd>
<p>Perform the handshake.</p> <p>Calling this is optional – if you don’t, then it will be automatically called the first time you call <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.DTLSChannel.send" title="trio.DTLSChannel.send"><code class="xref py py-obj docutils literal notranslate"><span class="pre">send</span></code></a> or <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.DTLSChannel.receive" title="trio.DTLSChannel.receive"><code class="xref py py-obj docutils literal notranslate"><span class="pre">receive</span></code></a>. But calling it explicitly can be useful in case you want to control the retransmit timeout, use a cancel scope to place an overall timeout on the handshake, or catch errors from the handshake specifically.</p> <p>It’s safe to call this multiple times, or call it simultaneously from multiple tasks – the first call will perform the handshake, and the rest will be no-ops.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><strong>initial_retransmit_timeout</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.13)"><em>float</em></a>) – </p>
<p>Since UDP is an unreliable protocol, it’s possible that some of the packets we send during the handshake will get lost. To handle this, DTLS uses a timer to automatically retransmit handshake packets that don’t receive a response. This lets you set the timeout we use to detect packet loss. Ideally, it should be set to ~1.5 times the round-trip time to your peer, but 1 second is a reasonable default. There’s <a class="reference external" href="https://tlswg.org/dtls13-spec/draft-ietf-tls-dtls13.html#name-timer-values">some useful guidance here</a>.</p> <p>This is the <em>initial</em> timeout, because if packets keep being lost then Trio will automatically back off to longer values, to avoid overloading the network.</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.DTLSChannel.send"><code><em>await</em> send(data: bytes) → None</code></h3> <dd>
<p>Send a packet of data, securely.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.DTLSChannel.receive"><code><em>await</em> receive() → bytes</code></h3> <dd>
<p>Fetch the next packet of data from this connection’s peer, waiting if necessary.</p> <p>This is safe to call from multiple tasks simultaneously, in case you have some reason to do that. And more importantly, it’s cancellation-safe, meaning that cancelling a call to <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.DTLSChannel.receive" title="trio.DTLSChannel.receive"><code class="xref py py-obj docutils literal notranslate"><span class="pre">receive</span></code></a> will never cause a packet to be lost or corrupt the underlying connection.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.DTLSChannel.close"><code>close() → None</code></h3> <dd>
<p>Close this connection.</p> <p><a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.DTLSChannel" title="trio.DTLSChannel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DTLSChannel</span></code></a>s don’t actually own any OS-level resources – the socket is owned by the <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.DTLSEndpoint" title="trio.DTLSEndpoint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DTLSEndpoint</span></code></a>, not the individual connections. So you don’t really <em>have</em> to call this. But it will interrupt any other tasks calling <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.DTLSChannel.receive" title="trio.DTLSChannel.receive"><code class="xref py py-obj docutils literal notranslate"><span class="pre">receive</span></code></a> with a <a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-core.html#trio.ClosedResourceError" title="trio.ClosedResourceError"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ClosedResourceError</span></code></a>, and cause future attempts to use this connection to fail.</p> <p>You can also use this object as a synchronous or asynchronous context manager.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.DTLSChannel.aclose"><code><em>await</em> aclose() → None</code></h3> <dd>
<p>Close this connection, but asynchronously.</p> <p>This is included to satisfy the <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.Channel" title="trio.abc.Channel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.abc.Channel</span></code></a> contract. It’s identical to <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.DTLSChannel.close" title="trio.DTLSChannel.close"><code class="xref py py-obj docutils literal notranslate"><span class="pre">close</span></code></a>, but async.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.DTLSChannel.set_ciphertext_mtu"><code>set_ciphertext_mtu(new_mtu: int) → None</code></h3> <dd>
<p>Tells Trio the <a class="reference external" href="https://en.wikipedia.org/wiki/Maximum_transmission_unit">largest amount of data that can be sent in a single packet to this peer</a>.</p> <p>Trio doesn’t actually enforce this limit – if you pass a huge packet to <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.DTLSChannel.send" title="trio.DTLSChannel.send"><code class="xref py py-obj docutils literal notranslate"><span class="pre">send</span></code></a>, then we’ll dutifully encrypt it and attempt to send it. But calling this method does have two useful effects:</p> <ul class="simple"> <li><p>If called before the handshake is performed, then Trio will automatically fragment handshake messages to fit within the given MTU. It also might fragment them even smaller, if it detects signs of packet loss, so setting this should never be necessary to make a successful connection. But, the packet loss detection only happens after multiple timeouts have expired, so if you have reason to believe that a smaller MTU is required, then you can set this to skip those timeouts and establish the connection more quickly.</p></li> <li><p>It changes the value returned from <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.DTLSChannel.get_cleartext_mtu" title="trio.DTLSChannel.get_cleartext_mtu"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_cleartext_mtu</span></code></a>. So if you have some kind of estimate of the network-level MTU, then you can use this to figure out how much overhead DTLS will need for hashes/padding/etc., and how much space you have left for your application data.</p></li> </ul> <p>The MTU here is measuring the largest UDP <em>payload</em> you think can be sent, the amount of encrypted data that can be handed to the operating system in a single call to <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.DTLSChannel.send" title="trio.DTLSChannel.send"><code class="xref py py-obj docutils literal notranslate"><span class="pre">send</span></code></a>. It should <em>not</em> include IP/UDP headers. Note that OS estimates of the MTU often are link-layer MTUs, so you have to subtract off 28 bytes on IPv4 and 48 bytes on IPv6 to get the ciphertext MTU.</p> <p>By default, Trio assumes an MTU of 1472 bytes on IPv4, and 1452 bytes on IPv6, which correspond to the common Ethernet MTU of 1500 bytes after accounting for IP/UDP overhead.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.DTLSChannel.get_cleartext_mtu"><code>get_cleartext_mtu() → int</code></h3> <dd>
<p>Returns the largest number of bytes that you can pass in a single call to <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.DTLSChannel.send" title="trio.DTLSChannel.send"><code class="xref py py-obj docutils literal notranslate"><span class="pre">send</span></code></a> while still fitting within the network-level MTU.</p> <p>See <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.DTLSChannel.set_ciphertext_mtu" title="trio.DTLSChannel.set_ciphertext_mtu"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_ciphertext_mtu</span></code></a> for more details.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.DTLSChannel.statistics"><code>statistics() → DTLSChannelStatistics</code></h3> <dd>
<p>Returns a <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.DTLSChannelStatistics" title="trio.DTLSChannelStatistics"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DTLSChannelStatistics</span></code></a> object with statistics about this connection.</p> </dd>
</dl> </dd>
</dl> <dl class="py class"> <h3 class="sig sig-object py" id="trio.DTLSChannelStatistics"><code><em>class</em> trio.DTLSChannelStatistics(incoming_packets_dropped_in_trio: int)</code></h3> <dd>
<p>Currently this has only one attribute:</p> <ul class="simple"> <li><p><code class="docutils literal notranslate"><span class="pre">incoming_packets_dropped_in_trio</span></code> (<code class="docutils literal notranslate"><span class="pre">int</span></code>): Gives a count of the number of incoming packets from this peer that Trio successfully received from the network, but then got dropped because the internal channel buffer was full. If this is non-zero, then you might want to call <code class="docutils literal notranslate"><span class="pre">receive</span></code> more often, or use a larger <code class="docutils literal notranslate"><span class="pre">incoming_packets_buffer</span></code>, or just not worry about it because your UDP-based protocol should be able to handle the occasional lost packet, right?</p></li> </ul> </dd>
</dl> </section> </section> <section id="low-level-networking-with-trio-socket"> <h2>Low-level networking with <a class="hxr-hoverxref hxr-tooltip reference internal" href="#module-trio.socket" title="trio.socket"><code class="xref py py-mod docutils literal notranslate"><span class="pre">trio.socket</span></code></a>
</h2> <p>The <a class="hxr-hoverxref hxr-tooltip reference internal" href="#module-trio.socket" title="trio.socket"><code class="xref py py-mod docutils literal notranslate"><span class="pre">trio.socket</span></code></a> module provides Trio’s basic low-level networking API. If you’re doing ordinary things with stream-oriented connections over IPv4/IPv6/Unix domain sockets, then you probably want to stick to the high-level API described above. If you want to use UDP, or exotic address families like <code class="docutils literal notranslate"><span class="pre">AF_BLUETOOTH</span></code>, or otherwise get direct access to all the quirky bits of your system’s networking API, then you’re in the right place.</p> <section id="top-level-exports"> <h3>Top-level exports</h3> <p>Generally, the API exposed by <a class="hxr-hoverxref hxr-tooltip reference internal" href="#module-trio.socket" title="trio.socket"><code class="xref py py-mod docutils literal notranslate"><span class="pre">trio.socket</span></code></a> mirrors that of the standard library <a class="reference external" href="https://docs.python.org/3/library/socket.html#module-socket" title="(in Python v3.13)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> module. Most constants (like <code class="docutils literal notranslate"><span class="pre">SOL_SOCKET</span></code>) and simple utilities (like <a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.inet_aton" title="(in Python v3.13)"><code class="xref py py-func docutils literal notranslate"><span class="pre">inet_aton()</span></code></a>) are simply re-exported unchanged. But there are also some differences, which are described here.</p> <p>First, Trio provides analogues to all the standard library functions that return socket objects; their interface is identical, except that they’re modified to return Trio socket objects instead:</p> <dl class="py function"> <h3 class="sig sig-object py" id="trio.socket.socket"><code>trio.socket.socket(family=-1, type=-1, proto=-1, fileno=None)</code></h3> <dd>
<p>Create a new Trio socket, like <a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a>.</p> <p>This function’s behavior can be customized using <a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-testing.html#trio.socket.set_custom_socket_factory" title="trio.socket.set_custom_socket_factory"><code class="xref py py-func docutils literal notranslate"><span class="pre">set_custom_socket_factory()</span></code></a>.</p> </dd>
</dl> <dl class="py function"> <h3 class="sig sig-object py" id="trio.socket.socketpair"><code>trio.socket.socketpair(family=None, type=SocketKind.SOCK_STREAM, proto=0)</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socketpair" title="(in Python v3.13)"><code class="xref py py-func docutils literal notranslate"><span class="pre">socket.socketpair()</span></code></a>, but returns a pair of Trio socket objects.</p> </dd>
</dl> <dl class="py function"> <h3 class="sig sig-object py" id="trio.socket.fromfd"><code>trio.socket.fromfd(fd, family, type, proto=0)</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.fromfd" title="(in Python v3.13)"><code class="xref py py-func docutils literal notranslate"><span class="pre">socket.fromfd()</span></code></a>, but returns a Trio socket object.</p> </dd>
</dl> <dl class="py function"> <h3 class="sig sig-object py" id="trio.socket.fromshare"><code>trio.socket.fromshare(data)</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.fromshare" title="(in Python v3.13)"><code class="xref py py-func docutils literal notranslate"><span class="pre">socket.fromshare()</span></code></a>, but returns a Trio socket object.</p> </dd>
</dl> <p>In addition, there is a new function to directly convert a standard library socket into a Trio socket:</p> <dl class="py function"> <h3 class="sig sig-object py" id="trio.socket.from_stdlib_socket"><code>trio.socket.from_stdlib_socket(sock: socket) → SocketType</code></h3> <dd>
<p>Convert a standard library <a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a> object into a Trio socket object.</p> </dd>
</dl> <p>Unlike <a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a>, <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.socket.socket" title="trio.socket.socket"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.socket.socket()</span></code></a> is a function, not a class; if you want to check whether an object is a Trio socket, use <code class="docutils literal notranslate"><span class="pre">isinstance(obj,</span> <span class="pre">trio.socket.SocketType)</span></code>.</p> <p>For name lookup, Trio provides the standard functions, but with some changes:</p> <dl class="py function"> <h3 class="sig sig-object py" id="trio.socket.getaddrinfo"><code><em>await</em> trio.socket.getaddrinfo(host: bytes | str | None, port: bytes | str | int | None, family: int = 0, type: int = 0, proto: int = 0, flags: int = 0) → list[tuple[AddressFamily, SocketKind, int, str, tuple[str, int] | tuple[str, int, int, int] | tuple[int, bytes]]]</code></h3> <dd>
<p>Look up a numeric address given a name.</p> <p>Arguments and return values are identical to <a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.getaddrinfo" title="(in Python v3.13)"><code class="xref py py-func docutils literal notranslate"><span class="pre">socket.getaddrinfo()</span></code></a>, except that this version is async.</p> <p>Also, <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.socket.getaddrinfo" title="trio.socket.getaddrinfo"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.socket.getaddrinfo()</span></code></a> correctly uses IDNA 2008 to process non-ASCII domain names. (<a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.getaddrinfo" title="(in Python v3.13)"><code class="xref py py-func docutils literal notranslate"><span class="pre">socket.getaddrinfo()</span></code></a> uses IDNA 2003, which can give the wrong result in some cases and cause you to connect to a different host than the one you intended; see <a class="reference external" href="https://bugs.python.org/issue17305">bpo-17305</a>.)</p> <p>This function’s behavior can be customized using <a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-testing.html#trio.socket.set_custom_hostname_resolver" title="trio.socket.set_custom_hostname_resolver"><code class="xref py py-func docutils literal notranslate"><span class="pre">set_custom_hostname_resolver()</span></code></a>.</p> </dd>
</dl> <dl class="py function"> <h3 class="sig sig-object py" id="trio.socket.getnameinfo"><code><em>await</em> trio.socket.getnameinfo(sockaddr: tuple[str, int] | tuple[str, int, int, int], flags: int) → tuple[str, str]</code></h3> <dd>
<p>Look up a name given a numeric address.</p> <p>Arguments and return values are identical to <a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.getnameinfo" title="(in Python v3.13)"><code class="xref py py-func docutils literal notranslate"><span class="pre">socket.getnameinfo()</span></code></a>, except that this version is async.</p> <p>This function’s behavior can be customized using <a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-testing.html#trio.socket.set_custom_hostname_resolver" title="trio.socket.set_custom_hostname_resolver"><code class="xref py py-func docutils literal notranslate"><span class="pre">set_custom_hostname_resolver()</span></code></a>.</p> </dd>
</dl> <dl class="py function"> <h3 class="sig sig-object py" id="trio.socket.getprotobyname"><code><em>await</em> trio.socket.getprotobyname(name: str) → int</code></h3> <dd>
<p>Look up a protocol number by name. (Rarely used.)</p> <p>Like <a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.getprotobyname" title="(in Python v3.13)"><code class="xref py py-func docutils literal notranslate"><span class="pre">socket.getprotobyname()</span></code></a>, but async.</p> </dd>
</dl> <p>Trio intentionally DOES NOT include some obsolete, redundant, or broken features:</p> <ul> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.gethostbyname" title="(in Python v3.13)"><code class="xref py py-func docutils literal notranslate"><span class="pre">gethostbyname()</span></code></a>, <a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.gethostbyname_ex" title="(in Python v3.13)"><code class="xref py py-func docutils literal notranslate"><span class="pre">gethostbyname_ex()</span></code></a>, <a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.gethostbyaddr" title="(in Python v3.13)"><code class="xref py py-func docutils literal notranslate"><span class="pre">gethostbyaddr()</span></code></a>: obsolete; use <a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.getaddrinfo" title="(in Python v3.13)"><code class="xref py py-func docutils literal notranslate"><span class="pre">getaddrinfo()</span></code></a> and <a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.getnameinfo" title="(in Python v3.13)"><code class="xref py py-func docutils literal notranslate"><span class="pre">getnameinfo()</span></code></a> instead.</p></li> <li>
<p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.getservbyport" title="(in Python v3.13)"><code class="xref py py-func docutils literal notranslate"><span class="pre">getservbyport()</span></code></a>: obsolete and <a class="reference external" href="https://bugs.python.org/issue30482">buggy</a>; instead, do:</p> <pre>_, service_name = await getnameinfo(('127.0.0.1', port), NI_NUMERICHOST)</pre> </li> <li>
<p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.getservbyname" title="(in Python v3.13)"><code class="xref py py-func docutils literal notranslate"><span class="pre">getservbyname()</span></code></a>: obsolete and <a class="reference external" href="https://bugs.python.org/issue30482">buggy</a>; instead, do:</p> <pre>await getaddrinfo(None, service_name)</pre> </li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.getfqdn" title="(in Python v3.13)"><code class="xref py py-func docutils literal notranslate"><span class="pre">getfqdn()</span></code></a>: obsolete; use <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.socket.getaddrinfo" title="trio.socket.getaddrinfo"><code class="xref py py-func docutils literal notranslate"><span class="pre">getaddrinfo()</span></code></a> with the <code class="docutils literal notranslate"><span class="pre">AI_CANONNAME</span></code> flag.</p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.getdefaulttimeout" title="(in Python v3.13)"><code class="xref py py-func docutils literal notranslate"><span class="pre">getdefaulttimeout()</span></code></a>, <a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.setdefaulttimeout" title="(in Python v3.13)"><code class="xref py py-func docutils literal notranslate"><span class="pre">setdefaulttimeout()</span></code></a>: instead, use Trio’s standard support for <a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-core.html#cancellation"><span class="std std-ref">Cancellation and timeouts</span></a>.</p></li> <li><p>On Windows, <code class="docutils literal notranslate"><span class="pre">SO_REUSEADDR</span></code> is not exported, because it’s a trap: the name is the same as Unix <code class="docutils literal notranslate"><span class="pre">SO_REUSEADDR</span></code>, but the semantics are <a class="reference external" href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms740621(v=vs.85).aspx">different and extremely broken</a>. In the very rare cases where you actually want <code class="docutils literal notranslate"><span class="pre">SO_REUSEADDR</span></code> on Windows, then it can still be accessed from the standard library’s <a class="reference external" href="https://docs.python.org/3/library/socket.html#module-socket" title="(in Python v3.13)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> module.</p></li> </ul> </section> <section id="socket-objects"> <h3>Socket objects</h3> <dl class="py class"> <h3 class="sig sig-object py" id="trio.socket.SocketType"><code><em>class</em> trio.socket.SocketType</code></h3> <dd>
<blockquote class="admonition note"> <h4 class="admonition-title">Note</h4> <p><a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.socket.SocketType" title="trio.socket.SocketType"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.socket.SocketType</span></code></a> is an abstract class and cannot be instantiated directly; you get concrete socket objects by calling constructors like <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.socket.socket" title="trio.socket.socket"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.socket.socket()</span></code></a>. However, you can use it to check if an object is a Trio socket via <code class="docutils literal notranslate"><span class="pre">isinstance(obj,</span> <span class="pre">trio.socket.SocketType)</span></code>.</p> </blockquote> <p>Trio socket objects are overall very similar to the <a class="reference external" href="https://docs.python.org/3/library/socket.html#socket-objects" title="(in Python v3.13)"><span class="xref std std-ref">standard library socket objects</span></a>, with a few important differences:</p> <p>First, and most obviously, everything is made “Trio-style”: blocking methods become async methods, and the following attributes are <em>not</em> supported:</p> <ul class="simple"> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.setblocking" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setblocking()</span></code></a>: Trio sockets always act like blocking sockets; if you need to read/write from multiple sockets at once, then create multiple tasks.</p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.settimeout" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">settimeout()</span></code></a>: see <a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-core.html#cancellation"><span class="std std-ref">Cancellation and timeouts</span></a> instead.</p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.makefile" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">makefile()</span></code></a>: Python’s file-like API is synchronous, so it can’t be implemented on top of an async socket.</p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.sendall" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sendall()</span></code></a>: Could be supported, but you’re better off using the higher-level <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SocketStream" title="trio.SocketStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketStream</span></code></a>, and specifically its <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SocketStream.send_all" title="trio.SocketStream.send_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_all()</span></code></a> method, which also does additional error checking.</p></li> </ul> <p>In addition, the following methods are similar to the equivalents in <a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a>, but have some Trio-specific quirks:</p> <dl class="py method"> <h3 class="sig sig-object py" id="trio.socket.SocketType.connect"><code><em>await</em> connect()</code></h3> <dd>
<p>Connect the socket to a remote address.</p> <p>Similar to <a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.connect" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">socket.socket.connect()</span></code></a>, except async.</p> <blockquote class="admonition warning"> <h4 class="admonition-title">Warning</h4> <p>Due to limitations of the underlying operating system APIs, it is not always possible to properly cancel a connection attempt once it has begun. If <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.socket.SocketType.connect" title="trio.socket.SocketType.connect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connect()</span></code></a> is cancelled, and is unable to abort the connection attempt, then it will:</p> <ol class="arabic simple"> <li><p>forcibly close the socket to prevent accidental reuse</p></li> <li><p>raise <a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-core.html#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Cancelled</span></code></a>.</p></li> </ol> <p>tl;dr: if <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.socket.SocketType.connect" title="trio.socket.SocketType.connect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connect()</span></code></a> is cancelled then the socket is left in an unknown state – possibly open, and possibly closed. The only reasonable thing to do is to close it.</p> </blockquote> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.socket.SocketType.is_readable"><code>is_readable()</code></h3> <dd>
<p>Check whether the socket is readable or not.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.socket.SocketType.sendfile"><code>sendfile()</code></h3> <dd>
<p><a class="reference external" href="https://github.com/python-trio/trio/issues/45">Not implemented yet!</a></p> </dd>
</dl> <p>We also keep track of an extra bit of state, because it turns out to be useful for <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.SocketStream" title="trio.SocketStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.SocketStream</span></code></a>:</p> <dl class="py attribute"> <h3 class="sig sig-object py" id="trio.socket.SocketType.did_shutdown_SHUT_WR"><code>did_shutdown_SHUT_WR</code></h3> <dd>
<p>This <a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a> attribute is True if you’ve called <code class="docutils literal notranslate"><span class="pre">sock.shutdown(SHUT_WR)</span></code> or <code class="docutils literal notranslate"><span class="pre">sock.shutdown(SHUT_RDWR)</span></code>, and False otherwise.</p> </dd>
</dl> <p>The following methods are identical to their equivalents in <a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a>, except async, and the ones that take address arguments require pre-resolved addresses:</p> <ul class="simple"> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.accept" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">accept()</span></code></a></p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.bind" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">bind()</span></code></a></p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.recv" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recv()</span></code></a></p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.recv_into" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recv_into()</span></code></a></p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.recvfrom" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recvfrom()</span></code></a></p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.recvfrom_into" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recvfrom_into()</span></code></a></p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.recvmsg" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recvmsg()</span></code></a> (if available)</p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.recvmsg_into" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">recvmsg_into()</span></code></a> (if available)</p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.send" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send()</span></code></a></p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.sendto" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sendto()</span></code></a></p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.sendmsg" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sendmsg()</span></code></a> (if available)</p></li> </ul> <p>All methods and attributes <em>not</em> mentioned above are identical to their equivalents in <a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">socket.socket</span></code></a>:</p> <ul class="simple"> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.family" title="(in Python v3.13)"><code class="xref py py-attr docutils literal notranslate"><span class="pre">family</span></code></a></p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.type" title="(in Python v3.13)"><code class="xref py py-attr docutils literal notranslate"><span class="pre">type</span></code></a></p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.proto" title="(in Python v3.13)"><code class="xref py py-attr docutils literal notranslate"><span class="pre">proto</span></code></a></p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.fileno" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fileno()</span></code></a></p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.listen" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">listen()</span></code></a></p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.getpeername" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getpeername()</span></code></a></p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.getsockname" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getsockname()</span></code></a></p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.close" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a></p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.shutdown" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">shutdown()</span></code></a></p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.setsockopt" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setsockopt()</span></code></a></p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.getsockopt" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getsockopt()</span></code></a></p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.dup" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dup()</span></code></a></p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.detach" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">detach()</span></code></a></p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.share" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">share()</span></code></a></p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.set_inheritable" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_inheritable()</span></code></a></p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socket.get_inheritable" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_inheritable()</span></code></a></p></li> </ul> </dd>
</dl> </section> </section> <section id="asynchronous-filesystem-i-o"> <h2>Asynchronous filesystem I/O</h2> <p>Trio provides built-in facilities for performing asynchronous filesystem operations like reading or renaming a file. Generally, we recommend that you use these instead of Python’s normal synchronous file APIs. But the tradeoffs here are somewhat subtle: sometimes people switch to async I/O, and then they’re surprised and confused when they find it doesn’t speed up their program. The next section explains the theory behind async file I/O, to help you better understand your code’s behavior. Or, if you just want to get started, you can <a class="hxr-hoverxref hxr-tooltip reference internal" href="#async-file-io-overview"><span class="std std-ref">jump down to the API overview</span></a>.</p> <section id="background-why-is-async-file-i-o-useful-the-answer-may-surprise-you"> <h3>Background: Why is async file I/O useful? The answer may surprise you</h3> <p>Many people expect that switching from synchronous file I/O to async file I/O will always make their program faster. This is not true! If we just look at total throughput, then async file I/O might be faster, slower, or about the same, and it depends in a complicated way on things like your exact patterns of disk access, or how much RAM you have. The main motivation for async file I/O is not to improve throughput, but to <strong>reduce the frequency of latency glitches.</strong></p> <p>To understand why, you need to know two things.</p> <p>First, right now no mainstream operating system offers a generic, reliable, native API for async file or filesystem operations, so we have to fake it by using threads (specifically, <a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-core.html#trio.to_thread.run_sync" title="trio.to_thread.run_sync"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.to_thread.run_sync()</span></code></a>). This is cheap but isn’t free: on a typical PC, dispatching to a worker thread adds something like ~100 µs of overhead to each operation. (“µs” is pronounced “microseconds”, and there are 1,000,000 µs in a second. Note that all the numbers here are going to be rough orders of magnitude to give you a sense of scale; if you need precise numbers for your environment, measure!)</p> <p>And second, the cost of a disk operation is incredibly bimodal. Sometimes, the data you need is already cached in RAM, and then accessing it is very, very fast – calling <a class="reference external" href="https://docs.python.org/3/library/io.html#io.FileIO" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.FileIO</span></code></a>'s <code class="docutils literal notranslate"><span class="pre">read</span></code> method on a cached file takes on the order of ~1 µs. But when the data isn’t cached, then accessing it is much, much slower: the average is ~100 µs for SSDs and ~10,000 µs for spinning disks, and if you look at tail latencies then for both types of storage you’ll see cases where occasionally some operation will be 10x or 100x slower than average. And that’s assuming your program is the only thing trying to use that disk – if you’re on some oversold cloud VM fighting for I/O with other tenants then who knows what will happen. And some operations can require multiple disk accesses.</p> <p>Putting these together: if your data is in RAM then it should be clear that using a thread is a terrible idea – if you add 100 µs of overhead to a 1 µs operation, then that’s a 100x slowdown! On the other hand, if your data’s on a spinning disk, then using a thread is <em>great</em> – instead of blocking the main thread and all tasks for 10,000 µs, we only block them for 100 µs and can spend the rest of that time running other tasks to get useful work done, which can effectively be a 100x speedup.</p> <p>But here’s the problem: for any individual I/O operation, there’s no way to know in advance whether it’s going to be one of the fast ones or one of the slow ones, so you can’t pick and choose. When you switch to async file I/O, it makes all the fast operations slower, and all the slow operations faster. Is that a win? In terms of overall speed, it’s hard to say: it depends what kind of disks you’re using and your kernel’s disk cache hit rate, which in turn depends on your file access patterns, how much spare RAM you have, the load on your service, … all kinds of things. If the answer is important to you, then there’s no substitute for measuring your code’s actual behavior in your actual deployment environment. But what we <em>can</em> say is that async disk I/O makes performance much more predictable across a wider range of runtime conditions.</p> <p><strong>If you’re not sure what to do, then we recommend that you use async disk I/O by default,</strong> because it makes your code more robust when conditions are bad, especially with regards to tail latencies; this improves the chances that what your users see matches what you saw in testing. Blocking the main thread stops <em>all</em> tasks from running for that time. 10,000 µs is 10 ms, and it doesn’t take many 10 ms glitches to start adding up to <a class="reference external" href="https://google.com/search?q=latency+cost">real money</a>; async disk I/O can help prevent those. Just don’t expect it to be magic, and be aware of the tradeoffs.</p> </section> <section id="api-overview"> <h3>API overview</h3> <p>If you want to perform general filesystem operations like creating and listing directories, renaming files, or checking file metadata – or if you just want a friendly way to work with filesystem paths – then you want <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.Path" title="trio.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.Path</span></code></a>. It’s an asyncified replacement for the standard library’s <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">pathlib.Path</span></code></a>, and provides the same comprehensive set of operations.</p> <p>For reading and writing to files and file-like objects, Trio also provides a mechanism for wrapping any synchronous file-like object into an asynchronous interface. If you have a <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.Path" title="trio.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.Path</span></code></a> object you can get one of these by calling its <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.Path.open" title="trio.Path.open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">open()</span></code></a> method; or if you know the file’s name you can open it directly with <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.open_file" title="trio.open_file"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.open_file()</span></code></a>. Alternatively, if you already have an open file-like object, you can wrap it with <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.wrap_file" title="trio.wrap_file"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.wrap_file()</span></code></a> – one case where this is especially useful is to wrap <a class="reference external" href="https://docs.python.org/3/library/io.html#io.BytesIO" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.BytesIO</span></code></a> or <a class="reference external" href="https://docs.python.org/3/library/io.html#io.StringIO" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.StringIO</span></code></a> when writing tests.</p> </section> <section id="asynchronous-path-objects"> <h3>Asynchronous path objects</h3> <dl class="py class"> <h3 class="sig sig-object py" id="trio.Path"><code><em>class</em> trio.Path(*args: str | os.PathLike[str])</code></h3> <dd>
<p>An async <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">pathlib.Path</span></code></a> that executes blocking methods in <a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-core.html#trio.to_thread.run_sync" title="trio.to_thread.run_sync"><code class="xref py py-meth docutils literal notranslate"><span class="pre">trio.to_thread.run_sync()</span></code></a>.</p> <p>Instantiating <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.Path" title="trio.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code></a> returns a concrete platform-specific subclass, one of <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.PosixPath" title="trio.PosixPath"><code class="xref py py-class docutils literal notranslate"><span class="pre">PosixPath</span></code></a> or <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.WindowsPath" title="trio.WindowsPath"><code class="xref py py-class docutils literal notranslate"><span class="pre">WindowsPath</span></code></a>.</p> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Path.absolute"><code><em>await</em> absolute()</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.absolute" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">absolute()</span></code></a>, but async.</p> <p>Return an absolute version of this path by prepending the current working directory. No normalization or symlink resolution is performed.</p> <p>Use resolve() to get the canonical path to a file.</p> </dd>
</dl> <dl class="py property"> <h3 class="sig sig-object py" id="trio.Path.anchor"><code><em>property</em> anchor</code></h3> <dd>
<p>The concatenation of the drive and root, or ‘’.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Path.as_posix"><code>as_posix()</code></h3> <dd>
<p>Return the string representation of the path with forward (/) slashes.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Path.as_uri"><code>as_uri()</code></h3> <dd>
<p>Return the path as a ‘file’ URI.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Path.chmod"><code><em>await</em> chmod(mode, *, follow_symlinks=True)</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.chmod" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">chmod()</span></code></a>, but async.</p> <p>Change the permissions of the path, like os.chmod().</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Path.cwd"><code><em>classmethod await</em> cwd()</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.cwd" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cwd()</span></code></a>, but async.</p> <p>Return a new path pointing to the current working directory (as returned by os.getcwd()).</p> </dd>
</dl> <dl class="py property"> <h3 class="sig sig-object py" id="trio.Path.drive"><code><em>property</em> drive</code></h3> <dd>
<p>The drive prefix (letter or UNC path), if any.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Path.exists"><code><em>await</em> exists()</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.exists" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">exists()</span></code></a>, but async.</p> <p>Whether this path exists.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Path.expanduser"><code><em>await</em> expanduser()</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.expanduser" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">expanduser()</span></code></a>, but async.</p> <p>Return a new path with expanded ~ and ~user constructs (as returned by os.path.expanduser)</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Path.glob"><code><em>await</em> glob(pattern)</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.glob" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">glob()</span></code></a>, but async.</p> <p>Iterate over this subtree and yield all existing files (of any kind, including directories) matching the given relative pattern.</p> <p>This is an async method that returns a synchronous iterator, so you use it like:</p> <pre>for subpath in await mypath.glob():
    ...</pre> <blockquote class="admonition note"> <h4 class="admonition-title">Note</h4> <p>The iterator is loaded into memory immediately during the initial call (see <a class="reference external" href="https://github.com/python-trio/trio/issues/501">issue #501</a> for discussion).</p> </blockquote> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Path.group"><code><em>await</em> group()</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.group" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">group()</span></code></a>, but async.</p> <p>Return the group name of the file gid.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Path.hardlink_to"><code><em>await</em> hardlink_to(target)</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.hardlink_to" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">hardlink_to()</span></code></a>, but async.</p> <p>Make this path a hard link pointing to the same file as <em>target</em>.</p> <p>Note the order of arguments (self, target) is the reverse of os.link’s.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Path.home"><code><em>classmethod await</em> home()</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.home" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">home()</span></code></a>, but async.</p> <p>Return a new path pointing to the user’s home directory (as returned by os.path.expanduser(‘~’)).</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Path.is_absolute"><code>is_absolute()</code></h3> <dd>
<p>True if the path is absolute (has both a root and, if applicable, a drive).</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Path.is_block_device"><code><em>await</em> is_block_device()</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_block_device" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_block_device()</span></code></a>, but async.</p> <p>Whether this path is a block device.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Path.is_char_device"><code><em>await</em> is_char_device()</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_char_device" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_char_device()</span></code></a>, but async.</p> <p>Whether this path is a character device.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Path.is_dir"><code><em>await</em> is_dir()</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_dir" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_dir()</span></code></a>, but async.</p> <p>Whether this path is a directory.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Path.is_fifo"><code><em>await</em> is_fifo()</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_fifo" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_fifo()</span></code></a>, but async.</p> <p>Whether this path is a FIFO.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Path.is_file"><code><em>await</em> is_file()</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_file" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_file()</span></code></a>, but async.</p> <p>Whether this path is a regular file (also True for symlinks pointing to regular files).</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Path.is_mount"><code><em>await</em> is_mount()</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_mount" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_mount()</span></code></a>, but async.</p> <p>Check if this path is a POSIX mount point</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Path.is_relative_to"><code>is_relative_to(*other)</code></h3> <dd>
<p>Return True if the path is relative to another path or False.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Path.is_reserved"><code>is_reserved()</code></h3> <dd>
<p>Return True if the path contains one of the special names reserved by the system, if any.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Path.is_socket"><code><em>await</em> is_socket()</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_socket" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_socket()</span></code></a>, but async.</p> <p>Whether this path is a socket.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Path.is_symlink"><code><em>await</em> is_symlink()</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.is_symlink" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_symlink()</span></code></a>, but async.</p> <p>Whether this path is a symbolic link.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Path.iterdir"><code><em>await</em> iterdir()</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.iterdir" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">iterdir()</span></code></a>, but async.</p> <p>Iterate over the files in this directory. Does not yield any result for the special paths ‘.’ and ‘..’.</p> <p>This is an async method that returns a synchronous iterator, so you use it like:</p> <pre>for subpath in await mypath.iterdir():
    ...</pre> <blockquote class="admonition note"> <h4 class="admonition-title">Note</h4> <p>The iterator is loaded into memory immediately during the initial call (see <a class="reference external" href="https://github.com/python-trio/trio/issues/501">issue #501</a> for discussion).</p> </blockquote> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Path.joinpath"><code>joinpath(*args)</code></h3> <dd>
<p>Combine this path with one or several arguments, and return a new path representing either a subpath (if all arguments are relative paths) or a totally different path (if one of the arguments is anchored).</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Path.lchmod"><code><em>await</em> lchmod(mode)</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.lchmod" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lchmod()</span></code></a>, but async.</p> <p>Like chmod(), except if the path points to a symlink, the symlink’s permissions are changed, rather than its target’s.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Path.link_to"><code><em>await</em> link_to(target)</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3.11/library/pathlib.html/Path.link_to" title="(in Python v3.11)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">link_to()</span></code></a>, but async.</p> <p>Make the target path a hard link pointing to this path.</p> <p>Note this function does not make this path a hard link to <em>target</em>, despite the implication of the function and argument names. The order of arguments (target, link) is the reverse of Path.symlink_to, but matches that of os.link.</p> <p>Deprecated since Python 3.10 and scheduled for removal in Python 3.12. Use <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.Path.hardlink_to" title="trio.Path.hardlink_to"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hardlink_to()</span></code></a> instead.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Path.lstat"><code><em>await</em> lstat()</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.lstat" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lstat()</span></code></a>, but async.</p> <p>Like stat(), except if the path points to a symlink, the symlink’s status information is returned, rather than its target’s.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Path.match"><code>match(path_pattern)</code></h3> <dd>
<p>Return True if this path matches the given pattern.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Path.mkdir"><code><em>await</em> mkdir(mode=511, parents=False, exist_ok=False)</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.mkdir" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">mkdir()</span></code></a>, but async.</p> <p>Create a new directory at this given path.</p> </dd>
</dl> <dl class="py property"> <h3 class="sig sig-object py" id="trio.Path.name"><code><em>property</em> name</code></h3> <dd>
<p>The final path component, if any.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Path.open"><code><em>await</em> open(mode='r', buffering=-1, encoding=None, errors=None, newline=None)</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.open" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">open()</span></code></a>, but async.</p> <p>Open the file pointed by this path and return a file object, as the built-in open() function does.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Path.owner"><code><em>await</em> owner()</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.owner" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">owner()</span></code></a>, but async.</p> <p>Return the login name of the file owner.</p> </dd>
</dl> <dl class="py property"> <h3 class="sig sig-object py" id="trio.Path.parent"><code><em>property</em> parent</code></h3> <dd>
<p>The logical parent of the path.</p> </dd>
</dl> <dl class="py property"> <h3 class="sig sig-object py" id="trio.Path.parents"><code><em>property</em> parents</code></h3> <dd>
<p>A sequence of this path’s logical parents.</p> </dd>
</dl> <dl class="py property"> <h3 class="sig sig-object py" id="trio.Path.parts"><code><em>property</em> parts</code></h3> <dd>
<p>An object providing sequence-like access to the components in the filesystem path.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Path.read_bytes"><code><em>await</em> read_bytes()</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.read_bytes" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read_bytes()</span></code></a>, but async.</p> <p>Open the file in bytes mode, read it, and close the file.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Path.read_text"><code><em>await</em> read_text(encoding=None, errors=None)</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.read_text" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">read_text()</span></code></a>, but async.</p> <p>Open the file in text mode, read it, and close the file.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Path.readlink"><code><em>await</em> readlink()</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.readlink" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">readlink()</span></code></a>, but async.</p> <p>Return the path to which the symbolic link points.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Path.relative_to"><code>relative_to(*other)</code></h3> <dd>
<p>Return the relative path to another path identified by the passed arguments. If the operation is not possible (because this is not a subpath of the other path), raise ValueError.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Path.rename"><code><em>await</em> rename(target)</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.rename" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rename()</span></code></a>, but async.</p> <p>Rename this path to the target path.</p> <p>The target path may be absolute or relative. Relative paths are interpreted relative to the current working directory, <em>not</em> the directory of the Path object.</p> <p>Returns the new Path instance pointing to the target path.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Path.replace"><code><em>await</em> replace(target)</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.replace" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">replace()</span></code></a>, but async.</p> <p>Rename this path to the target path, overwriting if that path exists.</p> <p>The target path may be absolute or relative. Relative paths are interpreted relative to the current working directory, <em>not</em> the directory of the Path object.</p> <p>Returns the new Path instance pointing to the target path.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Path.resolve"><code><em>await</em> resolve(strict=False)</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.resolve" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">resolve()</span></code></a>, but async.</p> <p>Make the path absolute, resolving all symlinks on the way and also normalizing it.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Path.rglob"><code><em>await</em> rglob(pattern)</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.rglob" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rglob()</span></code></a>, but async.</p> <p>Recursively yield all existing files (of any kind, including directories) matching the given relative pattern, anywhere in this subtree.</p> <p>This is an async method that returns a synchronous iterator, so you use it like:</p> <pre>for subpath in await mypath.rglob():
    ...</pre> <blockquote class="admonition note"> <h4 class="admonition-title">Note</h4> <p>The iterator is loaded into memory immediately during the initial call (see <a class="reference external" href="https://github.com/python-trio/trio/issues/501">issue #501</a> for discussion).</p> </blockquote> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Path.rmdir"><code><em>await</em> rmdir()</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.rmdir" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rmdir()</span></code></a>, but async.</p> <p>Remove this directory. The directory must be empty.</p> </dd>
</dl> <dl class="py property"> <h3 class="sig sig-object py" id="trio.Path.root"><code><em>property</em> root</code></h3> <dd>
<p>The root of the path, if any.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Path.samefile"><code><em>await</em> samefile(other_path)</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.samefile" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">samefile()</span></code></a>, but async.</p> <p>Return whether other_path is the same or not as this file (as returned by os.path.samefile()).</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Path.stat"><code><em>await</em> stat(*, follow_symlinks=True)</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.stat" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">stat()</span></code></a>, but async.</p> <p>Return the result of the stat() system call on this path, like os.stat() does.</p> </dd>
</dl> <dl class="py property"> <h3 class="sig sig-object py" id="trio.Path.stem"><code><em>property</em> stem</code></h3> <dd>
<p>The final path component, minus its last suffix.</p> </dd>
</dl> <dl class="py property"> <h3 class="sig sig-object py" id="trio.Path.suffix"><code><em>property</em> suffix</code></h3> <dd>
<p>The final component’s last suffix, if any.</p> <p>This includes the leading period. For example: ‘.txt’</p> </dd>
</dl> <dl class="py property"> <h3 class="sig sig-object py" id="trio.Path.suffixes"><code><em>property</em> suffixes</code></h3> <dd>
<p>A list of the final component’s suffixes, if any.</p> <p>These include the leading periods. For example: [‘.tar’, ‘.gz’]</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Path.symlink_to"><code><em>await</em> symlink_to(target, target_is_directory=False)</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.symlink_to" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">symlink_to()</span></code></a>, but async.</p> <p>Make this path a symlink pointing to the target path. Note the order of arguments (link, target) is the reverse of os.symlink.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Path.touch"><code><em>await</em> touch(mode=438, exist_ok=True)</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.touch" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">touch()</span></code></a>, but async.</p> <p>Create this file with the given access mode, if it doesn’t exist.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Path.unlink"><code><em>await</em> unlink(missing_ok=False)</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.unlink" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">unlink()</span></code></a>, but async.</p> <p>Remove this file or link. If the path is a directory, use rmdir() instead.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Path.with_name"><code>with_name(name)</code></h3> <dd>
<p>Return a new path with the file name changed.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Path.with_stem"><code>with_stem(stem)</code></h3> <dd>
<p>Return a new path with the stem changed.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Path.with_suffix"><code>with_suffix(suffix)</code></h3> <dd>
<p>Return a new path with the file suffix changed. If the path has no suffix, add given suffix. If the given suffix is an empty string, remove the suffix from the path.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Path.write_bytes"><code><em>await</em> write_bytes(data)</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.write_bytes" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">write_bytes()</span></code></a>, but async.</p> <p>Open the file in bytes mode, write to it, and close the file.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Path.write_text"><code><em>await</em> write_text(data, encoding=None, errors=None, newline=None)</code></h3> <dd>
<p>Like <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path.write_text" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">write_text()</span></code></a>, but async.</p> <p>Open the file in text mode, write to it, and close the file.</p> </dd>
</dl> </dd>
</dl> <dl class="py class"> <h3 class="sig sig-object py" id="trio.PosixPath"><code><em>class</em> trio.PosixPath(*args: str | os.PathLike[str])</code></h3> <dd>
<p>An async <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.PosixPath" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">pathlib.PosixPath</span></code></a> that executes blocking methods in <a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-core.html#trio.to_thread.run_sync" title="trio.to_thread.run_sync"><code class="xref py py-meth docutils literal notranslate"><span class="pre">trio.to_thread.run_sync()</span></code></a>.</p> </dd>
</dl> <dl class="py class"> <h3 class="sig sig-object py" id="trio.WindowsPath"><code><em>class</em> trio.WindowsPath(*args: str | os.PathLike[str])</code></h3> <dd>
<p>An async <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.WindowsPath" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">pathlib.WindowsPath</span></code></a> that executes blocking methods in <a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-core.html#trio.to_thread.run_sync" title="trio.to_thread.run_sync"><code class="xref py py-meth docutils literal notranslate"><span class="pre">trio.to_thread.run_sync()</span></code></a>.</p> </dd>
</dl> </section> <section id="asynchronous-file-objects"> <h3>Asynchronous file objects</h3> <dl class="py function"> <h3 class="sig sig-object py" id="trio.open_file"><code><em>await</em> trio.open_file(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=None, opener=None)</code></h3> <dd>
<p>Asynchronous version of <a class="reference external" href="https://docs.python.org/3/library/functions.html#open" title="(in Python v3.13)"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a>.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Returns<span class="colon">:</span>
</h4> <dd class="field-odd">
<p>An <a class="reference internal" href="https://trio.readthedocs.io/en/v0.29.0/glossary.html#term-asynchronous-file-object"><span class="xref std std-term">asynchronous file object</span></a></p> </dd> </dl> <p>Example:</p> <pre data-language="python">async with await trio.open_file(filename) as f:
    async for line in f:
        pass

assert f.closed</pre> <blockquote class="admonition seealso"> <h4 class="admonition-title">See also</h4> <p><a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.Path.open" title="trio.Path.open"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.Path.open()</span></code></a></p> </blockquote> </dd>
</dl> <dl class="py function"> <h3 class="sig sig-object py" id="trio.wrap_file"><code>trio.wrap_file(file)</code></h3> <dd>
<p>This wraps any file object in a wrapper that provides an asynchronous file object interface.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><strong>file</strong> – a <a class="reference external" href="https://docs.python.org/3/glossary.html#term-file-object" title="(in Python v3.13)"><span class="xref std std-term">file object</span></a></p> </dd> <h4 class="field-even" style="margin: 0">Returns<span class="colon">:</span>
</h4> <dd class="field-even">
<p>An <a class="reference internal" href="https://trio.readthedocs.io/en/v0.29.0/glossary.html#term-asynchronous-file-object"><span class="xref std std-term">asynchronous file object</span></a> that wraps <code class="docutils literal notranslate"><span class="pre">file</span></code></p> </dd> </dl> <p>Example:</p> <pre data-language="python">async_file = trio.wrap_file(StringIO('asdf'))

assert await async_file.read() == 'asdf'</pre> </dd>
</dl> <dl class="py interface"> <h3 class="sig sig-object py" id="trio.Asynchronous-file-interface"><code>Asynchronous file interface</code></h3> <dd>
<p>Trio’s asynchronous file objects have an interface that automatically adapts to the object being wrapped. Intuitively, you can mostly treat them like a regular <a class="reference external" href="https://docs.python.org/3/glossary.html#term-file-object" title="(in Python v3.13)"><span class="xref std std-term">file object</span></a>, except adding an <code class="docutils literal notranslate"><span class="pre">await</span></code> in front of any of methods that do I/O. The definition of <a class="reference external" href="https://docs.python.org/3/glossary.html#term-file-object" title="(in Python v3.13)"><span class="xref std std-term">file object</span></a> is a little vague in Python though, so here are the details:</p> <ul class="simple"> <li><p>Synchronous attributes/methods: if any of the following attributes or methods are present, then they’re re-exported unchanged: <code class="docutils literal notranslate"><span class="pre">closed</span></code>, <code class="docutils literal notranslate"><span class="pre">encoding</span></code>, <code class="docutils literal notranslate"><span class="pre">errors</span></code>, <code class="docutils literal notranslate"><span class="pre">fileno</span></code>, <code class="docutils literal notranslate"><span class="pre">isatty</span></code>, <code class="docutils literal notranslate"><span class="pre">newlines</span></code>, <code class="docutils literal notranslate"><span class="pre">readable</span></code>, <code class="docutils literal notranslate"><span class="pre">seekable</span></code>, <code class="docutils literal notranslate"><span class="pre">writable</span></code>, <code class="docutils literal notranslate"><span class="pre">buffer</span></code>, <code class="docutils literal notranslate"><span class="pre">raw</span></code>, <code class="docutils literal notranslate"><span class="pre">line_buffering</span></code>, <code class="docutils literal notranslate"><span class="pre">closefd</span></code>, <code class="docutils literal notranslate"><span class="pre">name</span></code>, <code class="docutils literal notranslate"><span class="pre">mode</span></code>, <code class="docutils literal notranslate"><span class="pre">getvalue</span></code>, <code class="docutils literal notranslate"><span class="pre">getbuffer</span></code>.</p></li> <li><p>Async methods: if any of the following methods are present, then they’re re-exported as an async method: <code class="docutils literal notranslate"><span class="pre">flush</span></code>, <code class="docutils literal notranslate"><span class="pre">read</span></code>, <code class="docutils literal notranslate"><span class="pre">read1</span></code>, <code class="docutils literal notranslate"><span class="pre">readall</span></code>, <code class="docutils literal notranslate"><span class="pre">readinto</span></code>, <code class="docutils literal notranslate"><span class="pre">readline</span></code>, <code class="docutils literal notranslate"><span class="pre">readlines</span></code>, <code class="docutils literal notranslate"><span class="pre">seek</span></code>, <code class="docutils literal notranslate"><span class="pre">tell</span></code>, <code class="docutils literal notranslate"><span class="pre">truncate</span></code>, <code class="docutils literal notranslate"><span class="pre">write</span></code>, <code class="docutils literal notranslate"><span class="pre">writelines</span></code>, <code class="docutils literal notranslate"><span class="pre">readinto1</span></code>, <code class="docutils literal notranslate"><span class="pre">peek</span></code>, <code class="docutils literal notranslate"><span class="pre">detach</span></code>.</p></li> </ul> <p>Special notes:</p> <ul> <li><p>Async file objects implement Trio’s <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.AsyncResource" title="trio.abc.AsyncResource"><code class="xref py py-class docutils literal notranslate"><span class="pre">AsyncResource</span></code></a> interface: you close them by calling <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.AsyncResource.aclose" title="trio.abc.AsyncResource.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> instead of <code class="docutils literal notranslate"><span class="pre">close</span></code> (!!), and they can be used as async context managers. Like all <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.AsyncResource.aclose" title="trio.abc.AsyncResource.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a> methods, the <code class="docutils literal notranslate"><span class="pre">aclose</span></code> method on async file objects is guaranteed to close the file before returning, even if it is cancelled or otherwise raises an error.</p></li> <li><p>Using the same async file object from multiple tasks simultaneously: because the async methods on async file objects are implemented using threads, it’s only safe to call two of them at the same time from different tasks IF the underlying synchronous file object is thread-safe. You should consult the documentation for the object you’re wrapping. For objects returned from <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.open_file" title="trio.open_file"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.open_file()</span></code></a> or <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.Path.open" title="trio.Path.open"><code class="xref py py-meth docutils literal notranslate"><span class="pre">trio.Path.open()</span></code></a>, it depends on whether you open the file in binary mode or text mode: <a class="reference external" href="https://docs.python.org/3/library/io.html#multi-threading">binary mode files are task-safe/thread-safe, text mode files are not</a>.</p></li> <li>
<p>Async file objects can be used as async iterators to iterate over the lines of the file:</p> <pre>async with await trio.open_file(...) as f:
    async for line in f:
        print(line)</pre> </li> <li><p>The <code class="docutils literal notranslate"><span class="pre">detach</span></code> method, if present, returns an async file object.</p></li> </ul> <p>This should include all the attributes exposed by classes in <a class="reference external" href="https://docs.python.org/3/library/io.html#module-io" title="(in Python v3.13)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">io</span></code></a>. But if you’re wrapping an object that has other attributes that aren’t on the list above, then you can access them via the <code class="docutils literal notranslate"><span class="pre">.wrapped</span></code> attribute:</p> <dl class="py attribute"> <h3 class="sig sig-object py" id="trio.Asynchronous-file-interface.wrapped"><code>wrapped</code></h3> <dd>
<p>The underlying synchronous file object.</p> </dd>
</dl> </dd>
</dl> </section> </section> <section id="spawning-subprocesses"> <h2>Spawning subprocesses</h2> <p>Trio provides support for spawning other programs as subprocesses, communicating with them via pipes, sending them signals, and waiting for them to exit.</p> <p>Most of the time, this is done through our high-level interface, <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.run_process" title="trio.run_process"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.run_process</span></code></a>. It lets you either run a process to completion while optionally capturing the output, or else run it in a background task and interact with it while it’s running:</p> <dl class="py function"> <h3 class="sig sig-object py" id="trio.run_process"><code><em>await</em> trio.run_process(command: str | bytes | os.PathLike | Sequence[str | bytes | os.PathLike], *, stdin: bytes | bytearray | memoryview | int | HasFileno | None = b'', capture_stdout: bool = False, capture_stderr: bool = False, check: bool = True, deliver_cancel: Callable[[Process], Awaitable[object]] | None = None, task_status: TaskStatus[Process] = TASK_STATUS_IGNORED, **options: object) → subprocess.CompletedProcess[bytes]</code></h3> <dd>
<p>Run <code class="docutils literal notranslate"><span class="pre">command</span></code> in a subprocess and wait for it to complete.</p> <p>This function can be called in two different ways.</p> <p>One option is a direct call, like:</p> <pre data-language="python">completed_process_info = await trio.run_process(...)</pre> <p>In this case, it returns a <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">subprocess.CompletedProcess</span></code></a> instance describing the results. Use this if you want to treat a process like a function call.</p> <p>The other option is to run it as a task using <a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-core.html#trio.Nursery.start" title="trio.Nursery.start"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Nursery.start</span></code></a> – the enhanced version of <a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-core.html#trio.Nursery.start_soon" title="trio.Nursery.start_soon"><code class="xref py py-obj docutils literal notranslate"><span class="pre">start_soon</span></code></a> that lets a task pass back a value during startup:</p> <pre data-language="python">process = await nursery.start(trio.run_process, ...)</pre> <p>In this case, <a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-core.html#trio.Nursery.start" title="trio.Nursery.start"><code class="xref py py-obj docutils literal notranslate"><span class="pre">start</span></code></a> returns a <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.Process" title="trio.Process"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Process</span></code></a> object that you can use to interact with the process while it’s running. Use this if you want to treat a process like a background task.</p> <p>Either way, <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.run_process" title="trio.run_process"><code class="xref py py-obj docutils literal notranslate"><span class="pre">run_process</span></code></a> makes sure that the process has exited before returning, handles cancellation, optionally checks for errors, and provides some convenient shorthands for dealing with the child’s input/output.</p> <p><strong>Input:</strong> <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.run_process" title="trio.run_process"><code class="xref py py-obj docutils literal notranslate"><span class="pre">run_process</span></code></a> supports all the same <code class="docutils literal notranslate"><span class="pre">stdin=</span></code> arguments as <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen" title="(in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subprocess.Popen</span></code></a>. In addition, if you simply want to pass in some fixed data, you can pass a plain <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#bytes" title="(in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bytes</span></code></a> object, and <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.run_process" title="trio.run_process"><code class="xref py py-obj docutils literal notranslate"><span class="pre">run_process</span></code></a> will take care of setting up a pipe, feeding in the data you gave, and then sending end-of-file. The default is <code class="docutils literal notranslate"><span class="pre">b""</span></code>, which means that the child will receive an empty stdin. If you want the child to instead read from the parent’s stdin, use <code class="docutils literal notranslate"><span class="pre">stdin=None</span></code>.</p> <p><strong>Output:</strong> By default, any output produced by the subprocess is passed through to the standard output and error streams of the parent Trio process.</p> <p>When calling <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.run_process" title="trio.run_process"><code class="xref py py-obj docutils literal notranslate"><span class="pre">run_process</span></code></a> directly, you can capture the subprocess’s output by passing <code class="docutils literal notranslate"><span class="pre">capture_stdout=True</span></code> to capture the subprocess’s standard output, and/or <code class="docutils literal notranslate"><span class="pre">capture_stderr=True</span></code> to capture its standard error. Captured data is collected up by Trio into an in-memory buffer, and then provided as the <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess.stdout" title="(in Python v3.13)"><code class="xref py py-attr docutils literal notranslate"><span class="pre">stdout</span></code></a> and/or <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess.stderr" title="(in Python v3.13)"><code class="xref py py-attr docutils literal notranslate"><span class="pre">stderr</span></code></a> attributes of the returned <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">CompletedProcess</span></code></a> object. The value for any stream that was not captured will be <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p> <p>If you want to capture both stdout and stderr while keeping them separate, pass <code class="docutils literal notranslate"><span class="pre">capture_stdout=True,</span> <span class="pre">capture_stderr=True</span></code>.</p> <p>If you want to capture both stdout and stderr but mixed together in the order they were printed, use: <code class="docutils literal notranslate"><span class="pre">capture_stdout=True,</span> <span class="pre">stderr=subprocess.STDOUT</span></code>. This directs the child’s stderr into its stdout, so the combined output will be available in the <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess.stdout" title="(in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stdout</span></code></a> attribute.</p> <p>If you’re using <code class="docutils literal notranslate"><span class="pre">await</span> <span class="pre">nursery.start(trio.run_process,</span> <span class="pre">...)</span></code> and want to capture the subprocess’s output for further processing, then use <code class="docutils literal notranslate"><span class="pre">stdout=subprocess.PIPE</span></code> and then make sure to read the data out of the <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.Process.stdout" title="trio.Process.stdout"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Process.stdout</span></code></a> stream. If you want to capture stderr separately, use <code class="docutils literal notranslate"><span class="pre">stderr=subprocess.PIPE</span></code>. If you want to capture both, but mixed together in the correct order, use <code class="docutils literal notranslate"><span class="pre">stdout=subprocess.PIPE,</span>
<span class="pre">stderr=subprocess.STDOUT</span></code>.</p> <p><strong>Error checking:</strong> If the subprocess exits with a nonzero status code, indicating failure, <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.run_process" title="trio.run_process"><code class="xref py py-func docutils literal notranslate"><span class="pre">run_process()</span></code></a> raises a <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#subprocess.CalledProcessError" title="(in Python v3.13)"><code class="xref py py-exc docutils literal notranslate"><span class="pre">subprocess.CalledProcessError</span></code></a> exception rather than returning normally. The captured outputs are still available as the <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#subprocess.CalledProcessError.stdout" title="(in Python v3.13)"><code class="xref py py-attr docutils literal notranslate"><span class="pre">stdout</span></code></a> and <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#subprocess.CalledProcessError.stderr" title="(in Python v3.13)"><code class="xref py py-attr docutils literal notranslate"><span class="pre">stderr</span></code></a> attributes of that exception. To disable this behavior, so that <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.run_process" title="trio.run_process"><code class="xref py py-func docutils literal notranslate"><span class="pre">run_process()</span></code></a> returns normally even if the subprocess exits abnormally, pass <code class="docutils literal notranslate"><span class="pre">check=False</span></code>.</p> <p>Note that this can make the <code class="docutils literal notranslate"><span class="pre">capture_stdout</span></code> and <code class="docutils literal notranslate"><span class="pre">capture_stderr</span></code> arguments useful even when starting <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.run_process" title="trio.run_process"><code class="xref py py-obj docutils literal notranslate"><span class="pre">run_process</span></code></a> as a task: if you only care about the output if the process fails, then you can enable capturing and then read the output off of the <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#subprocess.CalledProcessError" title="(in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CalledProcessError</span></code></a>.</p> <p><strong>Cancellation:</strong> If cancelled, <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.run_process" title="trio.run_process"><code class="xref py py-obj docutils literal notranslate"><span class="pre">run_process</span></code></a> sends a termination request to the subprocess, then waits for it to fully exit. The <code class="docutils literal notranslate"><span class="pre">deliver_cancel</span></code> argument lets you control how the process is terminated.</p> <blockquote class="admonition note"> <h4 class="admonition-title">Note</h4> <p><a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.run_process" title="trio.run_process"><code class="xref py py-obj docutils literal notranslate"><span class="pre">run_process</span></code></a> is intentionally similar to the standard library <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#subprocess.run" title="(in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subprocess.run</span></code></a>, but some of the defaults are different. Specifically, we default to:</p> <ul class="simple"> <li><p><code class="docutils literal notranslate"><span class="pre">check=True</span></code>, because <a class="reference external" href="https://www.python.org/dev/peps/pep-0020/">“errors should never pass silently / unless explicitly silenced”</a>.</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">stdin=b""</span></code>, because it produces less-confusing results if a subprocess unexpectedly tries to read from stdin.</p></li> </ul> <p>To get the <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#subprocess.run" title="(in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subprocess.run</span></code></a> semantics, use <code class="docutils literal notranslate"><span class="pre">check=False,</span> <span class="pre">stdin=None</span></code>.</p> </blockquote> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<ul class="simple"> <li><p><strong>command</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)"><em>list</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><em>str</em></a>) – The command to run. Typically this is a sequence of strings such as <code class="docutils literal notranslate"><span class="pre">['ls',</span> <span class="pre">'-l',</span> <span class="pre">'directory</span> <span class="pre">with</span> <span class="pre">spaces']</span></code>, where the first element names the executable to invoke and the other elements specify its arguments. With <code class="docutils literal notranslate"><span class="pre">shell=True</span></code> in the <code class="docutils literal notranslate"><span class="pre">**options</span></code>, or on Windows, <code class="docutils literal notranslate"><span class="pre">command</span></code> may alternatively be a string, which will be parsed following platform-dependent <a class="hxr-hoverxref hxr-tooltip reference internal" href="#subprocess-quoting"><span class="std std-ref">quoting rules</span></a>.</p></li> <li>
<p><strong>stdin</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#bytes" title="(in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bytes</span></code></a>, subprocess.PIPE, file descriptor, or None) – </p>
<p>The bytes to provide to the subprocess on its standard input stream, or <code class="docutils literal notranslate"><span class="pre">None</span></code> if the subprocess’s standard input should come from the same place as the parent Trio process’s standard input. As is the case with the <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#module-subprocess" title="(in Python v3.13)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">subprocess</span></code></a> module, you can also pass a file descriptor or an object with a <code class="docutils literal notranslate"><span class="pre">fileno()</span></code> method, in which case the subprocess’s standard input will come from that file.</p> <p>When starting <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.run_process" title="trio.run_process"><code class="xref py py-obj docutils literal notranslate"><span class="pre">run_process</span></code></a> as a background task, you can also use <code class="docutils literal notranslate"><span class="pre">stdin=subprocess.PIPE</span></code>, in which case <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.Process.stdin" title="trio.Process.stdin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Process.stdin</span></code></a> will be a <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.SendStream" title="trio.abc.SendStream"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SendStream</span></code></a> that you can use to send data to the child.</p> </li> <li><p><strong>capture_stdout</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a>) – If true, capture the bytes that the subprocess writes to its standard output stream and return them in the <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess.stdout" title="(in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stdout</span></code></a> attribute of the returned <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess" title="(in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subprocess.CompletedProcess</span></code></a> or <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#subprocess.CalledProcessError" title="(in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subprocess.CalledProcessError</span></code></a>.</p></li> <li><p><strong>capture_stderr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a>) – If true, capture the bytes that the subprocess writes to its standard error stream and return them in the <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess.stderr" title="(in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stderr</span></code></a> attribute of the returned <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess" title="(in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CompletedProcess</span></code></a> or <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#subprocess.CalledProcessError" title="(in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subprocess.CalledProcessError</span></code></a>.</p></li> <li><p><strong>check</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.13)"><em>bool</em></a>) – If false, don’t validate that the subprocess exits successfully. You should be sure to check the <code class="docutils literal notranslate"><span class="pre">returncode</span></code> attribute of the returned object if you pass <code class="docutils literal notranslate"><span class="pre">check=False</span></code>, so that errors don’t pass silently.</p></li> <li>
<p><strong>deliver_cancel</strong> (<em>async function</em><em> or </em><em>None</em>) – </p>
<p>If <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.run_process" title="trio.run_process"><code class="xref py py-obj docutils literal notranslate"><span class="pre">run_process</span></code></a> is cancelled, then it needs to kill the child process. There are multiple ways to do this, so we let you customize it.</p> <p>If you pass None (the default), then the behavior depends on the platform:</p> <ul> <li><p>On Windows, Trio calls <code class="docutils literal notranslate"><span class="pre">TerminateProcess</span></code>, which should kill the process immediately.</p></li> <li><p>On Unix-likes, the default behavior is to send a <code class="docutils literal notranslate"><span class="pre">SIGTERM</span></code>, wait 5 seconds, and send a <code class="docutils literal notranslate"><span class="pre">SIGKILL</span></code>.</p></li> </ul> <p>Alternatively, you can customize this behavior by passing in an arbitrary async function, which will be called with the <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.Process" title="trio.Process"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Process</span></code></a> object as an argument. For example, the default Unix behavior could be implemented like this:</p> <pre data-language="python">async def my_deliver_cancel(process):
    process.send_signal(signal.SIGTERM)
    await trio.sleep(5)
    process.send_signal(signal.SIGKILL)</pre> <p>When the process actually exits, the <code class="docutils literal notranslate"><span class="pre">deliver_cancel</span></code> function will automatically be cancelled – so if the process exits after <code class="docutils literal notranslate"><span class="pre">SIGTERM</span></code>, then we’ll never reach the <code class="docutils literal notranslate"><span class="pre">SIGKILL</span></code>.</p> <p>In any case, <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.run_process" title="trio.run_process"><code class="xref py py-obj docutils literal notranslate"><span class="pre">run_process</span></code></a> will always wait for the child process to exit before raising <a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-core.html#trio.Cancelled" title="trio.Cancelled"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Cancelled</span></code></a>.</p> </li> <li><p><strong>**options</strong> – <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.run_process" title="trio.run_process"><code class="xref py py-func docutils literal notranslate"><span class="pre">run_process()</span></code></a> also accepts any <a class="hxr-hoverxref hxr-tooltip reference internal" href="#subprocess-options"><span class="std std-ref">general subprocess options</span></a> and passes them on to the <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.Process" title="trio.Process"><code class="xref py py-class docutils literal notranslate"><span class="pre">Process</span></code></a> constructor. This includes the <code class="docutils literal notranslate"><span class="pre">stdout</span></code> and <code class="docutils literal notranslate"><span class="pre">stderr</span></code> options, which provide additional redirection possibilities such as <code class="docutils literal notranslate"><span class="pre">stderr=subprocess.STDOUT</span></code>, <code class="docutils literal notranslate"><span class="pre">stdout=subprocess.DEVNULL</span></code>, or file descriptors.</p></li> </ul> </dd> <h4 class="field-even" style="margin: 0">Returns<span class="colon">:</span>
</h4> <dd class="field-even">

<p>When called normally – a <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#subprocess.CompletedProcess" title="(in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subprocess.CompletedProcess</span></code></a> instance describing the return code and outputs.</p> <p>When called via <a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-core.html#trio.Nursery.start" title="trio.Nursery.start"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Nursery.start</span></code></a> – a <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.Process" title="trio.Process"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.Process</span></code></a> instance.</p> </dd> <h4 class="field-odd" style="margin: 0">Raises<span class="colon">:</span>
</h4> <dd class="field-odd">
<ul class="simple"> <li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#UnicodeError" title="(in Python v3.13)"><strong>UnicodeError</strong></a> – if <code class="docutils literal notranslate"><span class="pre">stdin</span></code> is specified as a Unicode string, rather than bytes</p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.13)"><strong>ValueError</strong></a> – if multiple redirections are specified for the same stream, e.g., both <code class="docutils literal notranslate"><span class="pre">capture_stdout=True</span></code> and <code class="docutils literal notranslate"><span class="pre">stdout=subprocess.DEVNULL</span></code></p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/subprocess.html#subprocess.CalledProcessError" title="(in Python v3.13)"><strong>subprocess.CalledProcessError</strong></a> – if <code class="docutils literal notranslate"><span class="pre">check=False</span></code> is not passed and the process exits with a nonzero exit status</p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#OSError" title="(in Python v3.13)"><strong>OSError</strong></a> – if an error is encountered starting or communicating with the process</p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ExceptionGroup" title="(in Python v3.13)"><strong>ExceptionGroup</strong></a> – if exceptions occur in <code class="docutils literal notranslate"><span class="pre">deliver_cancel</span></code>, or when exceptions occur when communicating with the subprocess. If strict_exception_groups is set to false in the global context, which is deprecated, then single exceptions will be collapsed.</p></li> </ul> </dd> </dl> <blockquote class="admonition note"> <h4 class="admonition-title">Note</h4> <p>The child process runs in the same process group as the parent Trio process, so a Ctrl+C will be delivered simultaneously to both parent and child. If you don’t want this behavior, consult your platform’s documentation for starting child processes in a different process group.</p> </blockquote> </dd>
</dl> <dl class="py class"> <h3 class="sig sig-object py" id="trio._subprocess.HasFileno"><code><em>class</em> trio._subprocess.HasFileno(Protocol)</code></h3> <dd>
<p>Represents any file-like object that has a file descriptor.</p> <dl class="py method"> <h3 class="sig sig-object py" id="trio._subprocess.HasFileno.fileno"><code>fileno() → int</code></h3> 
</dl> </dd>
</dl> <dl class="py attribute"> <h3 class="sig sig-object py" id="trio._subprocess.StrOrBytesPath"><code>trio._subprocess.StrOrBytesPath</code></h3> <dd>
<p>alias of <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> | <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#bytes" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> | <a class="reference external" href="https://docs.python.org/3/library/os.html#os.PathLike" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">PathLike</span></code></a>[<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>] | <a class="reference external" href="https://docs.python.org/3/library/os.html#os.PathLike" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">PathLike</span></code></a>[<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#bytes" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>]</p> </dd>
</dl> <dl class="py class"> <h3 class="sig sig-object py" id="trio.Process"><code><em>class</em> trio.Process</code></h3> <dd>
<p>A child process. Like <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">subprocess.Popen</span></code></a>, but async.</p> <p>This class has no public constructor. The most common way to get a <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.Process" title="trio.Process"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Process</span></code></a> object is to combine <a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-core.html#trio.Nursery.start" title="trio.Nursery.start"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Nursery.start</span></code></a> with <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.run_process" title="trio.run_process"><code class="xref py py-obj docutils literal notranslate"><span class="pre">run_process</span></code></a>:</p> <pre data-language="python">process_object = await nursery.start(run_process, ...)</pre> <p>This way, <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.run_process" title="trio.run_process"><code class="xref py py-obj docutils literal notranslate"><span class="pre">run_process</span></code></a> supervises the process and makes sure that it is cleaned up properly, while optionally checking the return value, feeding it input, and so on.</p> <p>If you need more control – for example, because you want to spawn a child process that outlives your program – then another option is to use <a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-lowlevel.html#trio.lowlevel.open_process" title="trio.lowlevel.open_process"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.lowlevel.open_process</span></code></a>:</p> <pre data-language="python">process_object = await trio.lowlevel.open_process(...)</pre> <dl class="py attribute"> <h3 class="sig sig-object py" id="trio.Process.args"><code>args</code></h3> <dd>
<p>The <code class="docutils literal notranslate"><span class="pre">command</span></code> passed at construction time, specifying the process to execute and its arguments.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Type<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)">str</a> or <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.13)">list</a></p> </dd> </dl> </dd>
</dl> <dl class="py attribute"> <h3 class="sig sig-object py" id="trio.Process.pid"><code>pid</code></h3> <dd>
<p>The process ID of the child process managed by this object.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Type<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.13)">int</a></p> </dd> </dl> </dd>
</dl> <dl class="py attribute"> <h3 class="sig sig-object py" id="trio.Process.stdin"><code>stdin</code></h3> <dd>
<p>A stream connected to the child’s standard input stream: when you write bytes here, they become available for the child to read. Only available if the <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.Process" title="trio.Process"><code class="xref py py-class docutils literal notranslate"><span class="pre">Process</span></code></a> was constructed using <code class="docutils literal notranslate"><span class="pre">stdin=PIPE</span></code>; otherwise this will be None.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Type<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.SendStream" title="trio.abc.SendStream">trio.abc.SendStream</a> or None</p> </dd> </dl> </dd>
</dl> <dl class="py attribute"> <h3 class="sig sig-object py" id="trio.Process.stdout"><code>stdout</code></h3> <dd>
<p>A stream connected to the child’s standard output stream: when the child writes to standard output, the written bytes become available for you to read here. Only available if the <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.Process" title="trio.Process"><code class="xref py py-class docutils literal notranslate"><span class="pre">Process</span></code></a> was constructed using <code class="docutils literal notranslate"><span class="pre">stdout=PIPE</span></code>; otherwise this will be None.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Type<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.ReceiveStream" title="trio.abc.ReceiveStream">trio.abc.ReceiveStream</a> or None</p> </dd> </dl> </dd>
</dl> <dl class="py attribute"> <h3 class="sig sig-object py" id="trio.Process.stderr"><code>stderr</code></h3> <dd>
<p>A stream connected to the child’s standard error stream: when the child writes to standard error, the written bytes become available for you to read here. Only available if the <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.Process" title="trio.Process"><code class="xref py py-class docutils literal notranslate"><span class="pre">Process</span></code></a> was constructed using <code class="docutils literal notranslate"><span class="pre">stderr=PIPE</span></code>; otherwise this will be None.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Type<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.abc.ReceiveStream" title="trio.abc.ReceiveStream">trio.abc.ReceiveStream</a> or None</p> </dd> </dl> </dd>
</dl> <dl class="py attribute"> <h3 class="sig sig-object py" id="trio.Process.stdio"><code>stdio</code></h3> <dd>
<p>A stream that sends data to the child’s standard input and receives from the child’s standard output. Only available if both <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.Process.stdin" title="trio.Process.stdin"><code class="xref py py-attr docutils literal notranslate"><span class="pre">stdin</span></code></a> and <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.Process.stdout" title="trio.Process.stdout"><code class="xref py py-attr docutils literal notranslate"><span class="pre">stdout</span></code></a> are available; otherwise this will be None.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Type<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.StapledStream" title="trio.StapledStream">trio.StapledStream</a> or None</p> </dd> </dl> </dd>
</dl> <dl class="py attribute"> <h3 class="sig sig-object py" id="trio.Process.returncode"><code>returncode</code></h3> <dd>
<p>The exit status of the process (an integer), or <code class="docutils literal notranslate"><span class="pre">None</span></code> if it’s still running.</p> <p>By convention, a return code of zero indicates success. On UNIX, negative values indicate termination due to a signal, e.g., -11 if terminated by signal 11 (<code class="docutils literal notranslate"><span class="pre">SIGSEGV</span></code>). On Windows, a process that exits due to a call to <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.Process.terminate" title="trio.Process.terminate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Process.terminate()</span></code></a> will have an exit status of 1.</p> <p>Unlike the standard library <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen.returncode" title="(in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subprocess.Popen.returncode</span></code></a>, you don’t have to call <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.Process.poll" title="trio.Process.poll"><code class="xref py py-obj docutils literal notranslate"><span class="pre">poll</span></code></a> or <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.Process.wait" title="trio.Process.wait"><code class="xref py py-obj docutils literal notranslate"><span class="pre">wait</span></code></a> to update this attribute; it’s automatically updated as needed, and will always give you the latest information.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Process.wait"><code><em>await</em> wait() → int</code></h3> <dd>
<p>Block until the process exits.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Returns<span class="colon">:</span>
</h4> <dd class="field-odd">
<p>The exit status of the process; see <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.Process.returncode" title="trio.Process.returncode"><code class="xref py py-attr docutils literal notranslate"><span class="pre">returncode</span></code></a>.</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Process.poll"><code>poll() → int | None</code></h3> <dd>
<p>Returns the exit status of the process (an integer), or <code class="docutils literal notranslate"><span class="pre">None</span></code> if it’s still running.</p> <p>Note that on Trio (unlike the standard library <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen" title="(in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subprocess.Popen</span></code></a>), <code class="docutils literal notranslate"><span class="pre">process.poll()</span></code> and <code class="docutils literal notranslate"><span class="pre">process.returncode</span></code> always give the same result. See <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.Process.returncode" title="trio.Process.returncode"><code class="xref py py-obj docutils literal notranslate"><span class="pre">returncode</span></code></a> for more details. This method is only included to make it easier to port code from <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#module-subprocess" title="(in Python v3.13)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subprocess</span></code></a>.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Process.kill"><code>kill() → None</code></h3> <dd>
<p>Immediately terminate the process.</p> <p>On UNIX, this is equivalent to <code class="docutils literal notranslate"><span class="pre">send_signal(signal.SIGKILL)</span></code>. On Windows, it calls <code class="docutils literal notranslate"><span class="pre">TerminateProcess</span></code>. In both cases, the process cannot prevent itself from being killed, but the termination will be delivered asynchronously; use <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.Process.wait" title="trio.Process.wait"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait()</span></code></a> if you want to ensure the process is actually dead before proceeding.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Process.terminate"><code>terminate() → None</code></h3> <dd>
<p>Terminate the process, politely if possible.</p> <p>On UNIX, this is equivalent to <code class="docutils literal notranslate"><span class="pre">send_signal(signal.SIGTERM)</span></code>; by convention this requests graceful termination, but a misbehaving or buggy process might ignore it. On Windows, <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.Process.terminate" title="trio.Process.terminate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">terminate()</span></code></a> forcibly terminates the process in the same manner as <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.Process.kill" title="trio.Process.kill"><code class="xref py py-meth docutils literal notranslate"><span class="pre">kill()</span></code></a>.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.Process.send_signal"><code>send_signal(sig: signal.Signals | int) → None</code></h3> <dd>
<p>Send signal <code class="docutils literal notranslate"><span class="pre">sig</span></code> to the process.</p> <p>On UNIX, <code class="docutils literal notranslate"><span class="pre">sig</span></code> may be any signal defined in the <a class="reference external" href="https://docs.python.org/3/library/signal.html#module-signal" title="(in Python v3.13)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">signal</span></code></a> module, such as <code class="docutils literal notranslate"><span class="pre">signal.SIGINT</span></code> or <code class="docutils literal notranslate"><span class="pre">signal.SIGTERM</span></code>. On Windows, it may be anything accepted by the standard library <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen.send_signal" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">subprocess.Popen.send_signal()</span></code></a>.</p> </dd>
</dl> <blockquote class="admonition note"> <h4 class="admonition-title">Note</h4> <p><a class="reference external" href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen.communicate" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">communicate()</span></code></a> is not provided as a method on <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.Process" title="trio.Process"><code class="xref py py-class docutils literal notranslate"><span class="pre">Process</span></code></a> objects; call <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.run_process" title="trio.run_process"><code class="xref py py-func docutils literal notranslate"><span class="pre">run_process()</span></code></a> normally for simple capturing, or write the loop yourself if you have unusual needs. <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen.communicate" title="(in Python v3.13)"><code class="xref py py-meth docutils literal notranslate"><span class="pre">communicate()</span></code></a> has quite unusual cancellation behavior in the standard library (on some platforms it spawns a background thread which continues to read from the child process even after the timeout has expired) and we wanted to provide an interface with fewer surprises.</p> </blockquote> </dd>
</dl> <p>If <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.run_process" title="trio.run_process"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.run_process</span></code></a> is too limiting, we also offer a low-level API, <a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-lowlevel.html#trio.lowlevel.open_process" title="trio.lowlevel.open_process"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trio.lowlevel.open_process</span></code></a>. For example, if you want to spawn a child process that will outlive the parent process and be orphaned, then <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.run_process" title="trio.run_process"><code class="xref py py-obj docutils literal notranslate"><span class="pre">run_process</span></code></a> can’t do that, but <a class="hxr-hoverxref hxr-tooltip reference internal" href="reference-lowlevel.html#trio.lowlevel.open_process" title="trio.lowlevel.open_process"><code class="xref py py-obj docutils literal notranslate"><span class="pre">open_process</span></code></a> can.</p> <section id="options-for-starting-subprocesses"> <h3>Options for starting subprocesses</h3> <p>All of Trio’s subprocess APIs accept the numerous keyword arguments used by the standard <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#module-subprocess" title="(in Python v3.13)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">subprocess</span></code></a> module to control the environment in which a process starts and the mechanisms used for communicating with it. These may be passed wherever you see <code class="docutils literal notranslate"><span class="pre">**options</span></code> in the documentation below. See the <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#popen-constructor">full list</a> or just the <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#frequently-used-arguments">frequently used ones</a> in the <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#module-subprocess" title="(in Python v3.13)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">subprocess</span></code></a> documentation. (You may need to <code class="docutils literal notranslate"><span class="pre">import</span>
<span class="pre">subprocess</span></code> in order to access constants such as <code class="docutils literal notranslate"><span class="pre">PIPE</span></code> or <code class="docutils literal notranslate"><span class="pre">DEVNULL</span></code>.)</p> <p>Currently, Trio always uses unbuffered byte streams for communicating with a process, so it does not support the <code class="docutils literal notranslate"><span class="pre">encoding</span></code>, <code class="docutils literal notranslate"><span class="pre">errors</span></code>, <code class="docutils literal notranslate"><span class="pre">universal_newlines</span></code> (alias <code class="docutils literal notranslate"><span class="pre">text</span></code>), and <code class="docutils literal notranslate"><span class="pre">bufsize</span></code> options.</p> </section> <section id="quoting-more-than-you-wanted-to-know"> <h3>Quoting: more than you wanted to know</h3> <p>The command to run and its arguments usually must be passed to Trio’s subprocess APIs as a sequence of strings, where the first element in the sequence specifies the command to run and the remaining elements specify its arguments, one argument per element. This form is used because it avoids potential quoting pitfalls; for example, you can run <code class="docutils literal notranslate"><span class="pre">["cp",</span> <span class="pre">"-f",</span> <span class="pre">source_file,</span> <span class="pre">dest_file]</span></code> without worrying about whether <code class="docutils literal notranslate"><span class="pre">source_file</span></code> or <code class="docutils literal notranslate"><span class="pre">dest_file</span></code> contains spaces.</p> <p>If you only run subprocesses without <code class="docutils literal notranslate"><span class="pre">shell=True</span></code> and on UNIX, that’s all you need to know about specifying the command. If you use <code class="docutils literal notranslate"><span class="pre">shell=True</span></code> or run on Windows, you probably should read the rest of this section to be aware of potential pitfalls.</p> <p>With <code class="docutils literal notranslate"><span class="pre">shell=True</span></code> on UNIX, you must specify the command as a single string, which will be passed to the shell as if you’d entered it at an interactive prompt. The advantage of this option is that it lets you use shell features like pipes and redirection without writing code to handle them. For example, you can write <code class="docutils literal notranslate"><span class="pre">Process("ls</span> <span class="pre">|</span> <span class="pre">grep</span>
<span class="pre">some_string",</span> <span class="pre">shell=True)</span></code>. The disadvantage is that you must account for the shell’s quoting rules, generally by wrapping in <a class="reference external" href="https://docs.python.org/3/library/shlex.html#shlex.quote" title="(in Python v3.13)"><code class="xref py py-func docutils literal notranslate"><span class="pre">shlex.quote()</span></code></a> any argument that might contain spaces, quotes, or other shell metacharacters. If you don’t do that, your safe-looking <code class="docutils literal notranslate"><span class="pre">f"ls</span> <span class="pre">|</span> <span class="pre">grep</span> <span class="pre">{some_string}"</span></code> might end in disaster when invoked with <code class="docutils literal notranslate"><span class="pre">some_string</span> <span class="pre">=</span> <span class="pre">"foo;</span> <span class="pre">rm</span> <span class="pre">-rf</span> <span class="pre">/"</span></code>.</p> <p>On Windows, the fundamental API for process spawning (the <code class="docutils literal notranslate"><span class="pre">CreateProcess()</span></code> system call) takes a string, not a list, and it’s actually up to the child process to decide how it wants to split that string into individual arguments. Since the C language specifies that <code class="docutils literal notranslate"><span class="pre">main()</span></code> should take a list of arguments, <em>most</em> programs you encounter will follow the rules used by the Microsoft C/C++ runtime. <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#subprocess.Popen" title="(in Python v3.13)"><code class="xref py py-class docutils literal notranslate"><span class="pre">subprocess.Popen</span></code></a>, and thus also Trio, uses these rules when it converts an argument sequence to a string, and they are <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#converting-argument-sequence">documented</a> alongside the <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#module-subprocess" title="(in Python v3.13)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">subprocess</span></code></a> module. There is no documented Python standard library function that can directly perform that conversion, so even on Windows, you almost always want to pass an argument sequence rather than a string. But if the program you’re spawning doesn’t split its command line back into individual arguments in the standard way, you might need to pass a string to work around this. (Or you might just be out of luck: as far as I can tell, there’s simply no way to pass an argument containing a double-quote to a Windows batch file.)</p> <p>On Windows with <code class="docutils literal notranslate"><span class="pre">shell=True</span></code>, things get even more chaotic. Now there are two separate sets of quoting rules applied, one by the Windows command shell <code class="docutils literal notranslate"><span class="pre">CMD.EXE</span></code> and one by the process being spawned, and they’re <em>different</em>. (And there’s no <a class="reference external" href="https://docs.python.org/3/library/shlex.html#shlex.quote" title="(in Python v3.13)"><code class="xref py py-func docutils literal notranslate"><span class="pre">shlex.quote()</span></code></a> to save you: it uses UNIX-style quoting rules, even on Windows.) Most special characters interpreted by the shell <code class="docutils literal notranslate"><span class="pre">&amp;&lt;&gt;()^|</span></code> are not treated as special if the shell thinks they’re inside double quotes, but <code class="docutils literal notranslate"><span class="pre">%FOO%</span></code> environment variable substitutions still are, and the shell doesn’t provide any way to write a double quote inside a double-quoted string. Outside double quotes, any character (including a double quote) can be escaped using a leading <code class="docutils literal notranslate"><span class="pre">^</span></code>. But since a pipeline is processed by running each command in the pipeline in a subshell, multiple layers of escaping can be needed:</p> <pre>echo ^^^&amp;x | find "x" | find "x"          # prints: &amp;x</pre> <p>And if you combine pipelines with () grouping, you can need even more levels of escaping:</p> <pre>(echo ^^^^^^^&amp;x | find "x") | find "x"    # prints: &amp;x</pre> <p>Since process creation takes a single arguments string, <code class="docutils literal notranslate"><span class="pre">CMD.EXE</span></code>'s quoting does not influence word splitting, and double quotes are not removed during CMD.EXE’s expansion pass. Double quotes are troublesome because CMD.EXE handles them differently from the MSVC runtime rules; in:</p> <pre>prog.exe "foo \"bar\" baz"</pre> <p>the program will see one argument <code class="docutils literal notranslate"><span class="pre">foo</span> <span class="pre">"bar"</span> <span class="pre">baz</span></code> but CMD.EXE thinks <code class="docutils literal notranslate"><span class="pre">bar\</span></code> is not quoted while <code class="docutils literal notranslate"><span class="pre">foo</span> <span class="pre">\</span></code> and <code class="docutils literal notranslate"><span class="pre">baz</span></code> are. All of this makes it a formidable task to reliably interpolate anything into a <code class="docutils literal notranslate"><span class="pre">shell=True</span></code> command line on Windows, and Trio falls back on the <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#module-subprocess" title="(in Python v3.13)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">subprocess</span></code></a> behavior: If you pass a sequence with <code class="docutils literal notranslate"><span class="pre">shell=True</span></code>, it’s quoted in the same way as a sequence with <code class="docutils literal notranslate"><span class="pre">shell=False</span></code>, and had better not contain any shell metacharacters you weren’t planning on.</p> <p>Further reading:</p> <ul class="simple"> <li><p><a class="reference external" href="https://stackoverflow.com/questions/30620876/how-to-properly-escape-filenames-in-windows-cmd-exe">https://stackoverflow.com/questions/30620876/how-to-properly-escape-filenames-in-windows-cmd-exe</a></p></li> <li><p><a class="reference external" href="https://stackoverflow.com/questions/4094699/how-does-the-windows-command-interpreter-cmd-exe-parse-scripts">https://stackoverflow.com/questions/4094699/how-does-the-windows-command-interpreter-cmd-exe-parse-scripts</a></p></li> </ul> </section> </section> <section id="signals"> <h2>Signals</h2> <dl class="py function"> <h3 class="sig sig-object py" id="trio.open_signal_receiver"><code><em>with</em> trio.open_signal_receiver(*signals: signal.Signals | int) → Generator[AsyncIterator[int], None, None] as signal_aiter</code></h3> <dd>
<p>A context manager for catching signals.</p> <p>Entering this context manager starts listening for the given signals and returns an async iterator; exiting the context manager stops listening.</p> <p>The async iterator blocks until a signal arrives, and then yields it.</p> <p>Note that if you leave the <code class="docutils literal notranslate"><span class="pre">with</span></code> block while the iterator has unextracted signals still pending inside it, then they will be re-delivered using Python’s regular signal handling logic. This avoids a race condition when signals arrives just before we exit the <code class="docutils literal notranslate"><span class="pre">with</span></code> block.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><strong>signals</strong> – the signals to listen for.</p> </dd> <h4 class="field-even" style="margin: 0">Raises<span class="colon">:</span>
</h4> <dd class="field-even">
<ul class="simple"> <li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#TypeError" title="(in Python v3.13)"><strong>TypeError</strong></a> – if no signals were provided.</p></li> <li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#RuntimeError" title="(in Python v3.13)"><strong>RuntimeError</strong></a> – if you try to use this anywhere except Python’s main thread. (This is a Python limitation.)</p></li> </ul> </dd> </dl> <p class="rubric">Example</p> <p>A common convention for Unix daemons is that they should reload their configuration when they receive a <code class="docutils literal notranslate"><span class="pre">SIGHUP</span></code>. Here’s a sketch of what that might look like using <a class="hxr-hoverxref hxr-tooltip reference internal" href="#trio.open_signal_receiver" title="trio.open_signal_receiver"><code class="xref py py-func docutils literal notranslate"><span class="pre">open_signal_receiver()</span></code></a>:</p> <pre data-language="python">with trio.open_signal_receiver(signal.SIGHUP) as signal_aiter:
    async for signum in signal_aiter:
        assert signum == signal.SIGHUP
        reload_configuration()</pre> </dd>
</dl> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2017 Nathaniel J. Smith<br>Licensed under the MIT License.<br>
    <a href="https://trio.readthedocs.io/en/v0.29.0/reference-io.html" class="_attribution-link">https://trio.readthedocs.io/en/v0.29.0/reference-io.html</a>
  </p>
</div>
