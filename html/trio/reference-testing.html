<section id="module-trio.testing"> <h1>Testing made easier with <code class="docutils literal notranslate"><span class="pre">trio.testing</span></code>
</h1> <p>The <a class="reference internal" href="#module-trio.testing" title="trio.testing"><code class="xref py py-mod docutils literal notranslate"><span class="pre">trio.testing</span></code></a> module provides various utilities to make it easier to test Trio code. Unlike the other submodules in the <a class="reference internal" href="reference-core.html#module-trio" title="trio"><code class="xref py py-mod docutils literal notranslate"><span class="pre">trio</span></code></a> namespace, <a class="reference internal" href="#module-trio.testing" title="trio.testing"><code class="xref py py-mod docutils literal notranslate"><span class="pre">trio.testing</span></code></a> is <em>not</em> automatically imported when you do <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">trio</span></code>; you must <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">trio.testing</span></code> explicitly.</p> <section id="test-harness-integration"> <h2>Test harness integration</h2> <dl class="py decorator"> <h3 class="sig sig-object py" id="trio.testing.trio_test"><code>@trio.testing.trio_test</code></h3> 
</dl> </section> <section id="time-and-timeouts"> <h2>Time and timeouts</h2> <p><a class="reference internal" href="#trio.testing.MockClock" title="trio.testing.MockClock"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.testing.MockClock</span></code></a> is a <a class="reference internal" href="reference-core.html#trio.abc.Clock" title="trio.abc.Clock"><code class="xref py py-class docutils literal notranslate"><span class="pre">Clock</span></code></a> with a few tricks up its sleeve to help you efficiently test code involving timeouts:</p> <ul class="simple"> <li><p>By default, it starts at time 0, and clock time only advances when you explicitly call <a class="reference internal" href="#trio.testing.MockClock.jump" title="trio.testing.MockClock.jump"><code class="xref py py-meth docutils literal notranslate"><span class="pre">jump()</span></code></a>. This provides an extremely controllable clock for testing.</p></li> <li><p>You can set <a class="reference internal" href="#trio.testing.MockClock.rate" title="trio.testing.MockClock.rate"><code class="xref py py-attr docutils literal notranslate"><span class="pre">rate</span></code></a> to 1.0 if you want it to start running in real time like a regular clock. You can stop and start the clock within a test. You can set <a class="reference internal" href="#trio.testing.MockClock.rate" title="trio.testing.MockClock.rate"><code class="xref py py-attr docutils literal notranslate"><span class="pre">rate</span></code></a> to 10.0 to make clock time pass at 10x real speed (so e.g. <code class="docutils literal notranslate"><span class="pre">await</span>
<span class="pre">trio.sleep(10)</span></code> returns after 1 second).</p></li> <li><p>But even more interestingly, you can set <a class="reference internal" href="#trio.testing.MockClock.autojump_threshold" title="trio.testing.MockClock.autojump_threshold"><code class="xref py py-attr docutils literal notranslate"><span class="pre">autojump_threshold</span></code></a> to zero or a small value, and then it will watch the execution of the run loop, and any time things have settled down and everyone’s waiting for a timeout, it jumps the clock forward to that timeout. In many cases this allows natural-looking code involving timeouts to be automatically run at near full CPU utilization with no changes. (Thanks to <a class="reference external" href="https://github.com/majek/fluxcapacitor">fluxcapacitor</a> for this awesome idea.)</p></li> <li><p>And of course these can be mixed and matched at will.</p></li> </ul> <p>Regardless of these shenanigans, from “inside” Trio the passage of time still seems normal so long as you restrict yourself to Trio’s time functions (see <a class="reference internal" href="reference-core.html#time-and-clocks"><span class="std std-ref">Time and clocks</span></a>). Below is an example demonstrating two different ways of making time pass quickly. Notice how in both cases, the two tasks keep a consistent view of reality and events happen in the expected order, despite being wildly divorced from real time:</p> <pre data-language="python"># across-realtime.py

import time
import trio
import trio.testing

YEAR = 365 * 24 * 60 * 60  # seconds


async def task1():
    start = trio.current_time()

    print("task1: sleeping for 1 year")
    await trio.sleep(YEAR)

    duration = trio.current_time() - start
    print(f"task1: woke up; clock says I've slept {duration / YEAR} years")

    print("task1: sleeping for 1 year, 100 times")
    for _ in range(100):
        await trio.sleep(YEAR)

    duration = trio.current_time() - start
    print(f"task1: slept {duration / YEAR} years total")


async def task2():
    start = trio.current_time()

    print("task2: sleeping for 5 years")
    await trio.sleep(5 * YEAR)

    duration = trio.current_time() - start
    print(f"task2: woke up; clock says I've slept {duration / YEAR} years")

    print("task2: sleeping for 500 years")
    await trio.sleep(500 * YEAR)

    duration = trio.current_time() - start
    print(f"task2: slept {duration / YEAR} years total")


async def main():
    async with trio.open_nursery() as nursery:
        nursery.start_soon(task1)
        nursery.start_soon(task2)


def run_example(clock):
    real_start = time.perf_counter()
    trio.run(main, clock=clock)
    real_duration = time.perf_counter() - real_start
    print(f"Total real time elapsed: {real_duration} seconds")


print("Clock where time passes at 100 years per second:\n")
run_example(trio.testing.MockClock(rate=100 * YEAR))

print("\nClock where time automatically skips past the boring parts:\n")
run_example(trio.testing.MockClock(autojump_threshold=0))</pre> <p>Output:</p> <pre>Clock where time passes at 100 years per second:

task2: sleeping for 5 years
task1: sleeping for 1 year
task1: woke up; clock says I've slept 1.0365006048232317 years
task1: sleeping for 1 year, 100 times
task2: woke up; clock says I've slept 5.0572111969813704 years
task2: sleeping for 500 years
task1: slept 104.77677842136472 years total
task2: slept 505.25014589075 years total
Total real time elapsed: 5.053582429885864 seconds

Clock where time automatically skips past the boring parts:

task2: sleeping for 5 years
task1: sleeping for 1 year
task1: woke up; clock says I've slept 1.0 years
task1: sleeping for 1 year, 100 times
task2: woke up; clock says I've slept 5.0 years
task2: sleeping for 500 years
task1: slept 101.0 years total
task2: slept 505.0 years total
Total real time elapsed: 0.019298791885375977 seconds</pre> <dl class="py class"> <h3 class="sig sig-object py" id="trio.testing.MockClock"><code><em>class</em> trio.testing.MockClock(rate=0.0, autojump_threshold=inf)</code></h3> <dd>
<p>A user-controllable clock suitable for writing tests.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<ul class="simple"> <li><p><strong>rate</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – the initial <a class="reference internal" href="#trio.testing.MockClock.rate" title="trio.testing.MockClock.rate"><code class="xref py py-attr docutils literal notranslate"><span class="pre">rate</span></code></a>.</p></li> <li><p><strong>autojump_threshold</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – the initial <a class="reference internal" href="#trio.testing.MockClock.autojump_threshold" title="trio.testing.MockClock.autojump_threshold"><code class="xref py py-attr docutils literal notranslate"><span class="pre">autojump_threshold</span></code></a>.</p></li> </ul> </dd> </dl> <dl class="py attribute"> <h3 class="sig sig-object py" id="trio.testing.MockClock.rate"><code>rate</code></h3> <dd>
<p>How many seconds of clock time pass per second of real time. Default is 0.0, i.e. the clock only advances through manuals calls to <a class="reference internal" href="#trio.testing.MockClock.jump" title="trio.testing.MockClock.jump"><code class="xref py py-meth docutils literal notranslate"><span class="pre">jump()</span></code></a> or when the <a class="reference internal" href="#trio.testing.MockClock.autojump_threshold" title="trio.testing.MockClock.autojump_threshold"><code class="xref py py-attr docutils literal notranslate"><span class="pre">autojump_threshold</span></code></a> is triggered. You can assign to this attribute to change it.</p> </dd>
</dl> <dl class="py attribute"> <h3 class="sig sig-object py" id="trio.testing.MockClock.autojump_threshold"><code>autojump_threshold</code></h3> <dd>
<p>The clock keeps an eye on the run loop, and if at any point it detects that all tasks have been blocked for this many real seconds (i.e., according to the actual clock, not this clock), then the clock automatically jumps ahead to the run loop’s next scheduled timeout. Default is <a class="reference external" href="https://docs.python.org/3/library/math.html#math.inf" title="(in Python v3.11)"><code class="xref py py-data docutils literal notranslate"><span class="pre">math.inf</span></code></a>, i.e., to never autojump. You can assign to this attribute to change it.</p> <p>Basically the idea is that if you have code or tests that use sleeps and timeouts, you can use this to make it run much faster, totally automatically. (At least, as long as those sleeps/timeouts are happening inside Trio; if your test involves talking to external service and waiting for it to timeout then obviously we can’t help you there.)</p> <p>You should set this to the smallest value that lets you reliably avoid “false alarms” where some I/O is in flight (e.g. between two halves of a socketpair) but the threshold gets triggered and time gets advanced anyway. This will depend on the details of your tests and test environment. If you aren’t doing any I/O (like in our sleeping example above) then just set it to zero, and the clock will jump whenever all tasks are blocked.</p> <blockquote class="admonition note"> <h4 class="admonition-title">Note</h4> <p>If you use <code class="docutils literal notranslate"><span class="pre">autojump_threshold</span></code> and <a class="reference internal" href="#trio.testing.wait_all_tasks_blocked" title="trio.testing.wait_all_tasks_blocked"><code class="xref py py-obj docutils literal notranslate"><span class="pre">wait_all_tasks_blocked</span></code></a> at the same time, then you might wonder how they interact, since they both cause things to happen after the run loop goes idle for some time. The answer is: <a class="reference internal" href="#trio.testing.wait_all_tasks_blocked" title="trio.testing.wait_all_tasks_blocked"><code class="xref py py-obj docutils literal notranslate"><span class="pre">wait_all_tasks_blocked</span></code></a> takes priority. If there’s a task blocked in <a class="reference internal" href="#trio.testing.wait_all_tasks_blocked" title="trio.testing.wait_all_tasks_blocked"><code class="xref py py-obj docutils literal notranslate"><span class="pre">wait_all_tasks_blocked</span></code></a>, then the autojump feature treats that as active task and does <em>not</em> jump the clock.</p> </blockquote> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.testing.MockClock.jump"><code>jump(seconds)</code></h3> <dd>
<p>Manually advance the clock by the given number of seconds.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><strong>seconds</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – the number of seconds to jump the clock forward.</p> </dd> <h4 class="field-even" style="margin: 0">Raises<span class="colon">:</span>
</h4> <dd class="field-even">
<p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.11)"><strong>ValueError</strong></a> – if you try to pass a negative value for <code class="docutils literal notranslate"><span class="pre">seconds</span></code>.</p> </dd> </dl> </dd>
</dl> </dd>
</dl> </section> <section id="inter-task-ordering"> <h2>Inter-task ordering</h2> <dl class="py class"> <h3 class="sig sig-object py" id="trio.testing.Sequencer"><code><em>class</em> trio.testing.Sequencer</code></h3> <dd>
<p>A convenience class for forcing code in different tasks to run in an explicit linear order.</p> <p>Instances of this class implement a <code class="docutils literal notranslate"><span class="pre">__call__</span></code> method which returns an async context manager. The idea is that you pass a sequence number to <code class="docutils literal notranslate"><span class="pre">__call__</span></code> to say where this block of code should go in the linear sequence. Block 0 starts immediately, and then block N doesn’t start until block N-1 has finished.</p> <p class="rubric">Example</p> <p>An extremely elaborate way to print the numbers 0-5, in order:</p> <pre data-language="python">async def worker1(seq):
    async with seq(0):
        print(0)
    async with seq(4):
        print(4)

async def worker2(seq):
    async with seq(2):
        print(2)
    async with seq(5):
        print(5)

async def worker3(seq):
    async with seq(1):
        print(1)
    async with seq(3):
        print(3)

async def main():
   seq = trio.testing.Sequencer()
   async with trio.open_nursery() as nursery:
       nursery.start_soon(worker1, seq)
       nursery.start_soon(worker2, seq)
       nursery.start_soon(worker3, seq)</pre> </dd>
</dl> <dl class="py function"> <h3 class="sig sig-object py" id="trio.testing.wait_all_tasks_blocked"><code><em>await</em> trio.testing.wait_all_tasks_blocked(cushion=0.0)</code></h3> <dd>
<p>Block until there are no runnable tasks.</p> <p>This is useful in testing code when you want to give other tasks a chance to “settle down”. The calling task is blocked, and doesn’t wake up until all other tasks are also blocked for at least <code class="docutils literal notranslate"><span class="pre">cushion</span></code> seconds. (Setting a non-zero <code class="docutils literal notranslate"><span class="pre">cushion</span></code> is intended to handle cases like two tasks talking to each other over a local socket, where we want to ignore the potential brief moment between a send and receive when all tasks are blocked.)</p> <p>Note that <code class="docutils literal notranslate"><span class="pre">cushion</span></code> is measured in <em>real</em> time, not the Trio clock time.</p> <p>If there are multiple tasks blocked in <a class="reference internal" href="#trio.testing.wait_all_tasks_blocked" title="trio.testing.wait_all_tasks_blocked"><code class="xref py py-func docutils literal notranslate"><span class="pre">wait_all_tasks_blocked()</span></code></a>, then the one with the shortest <code class="docutils literal notranslate"><span class="pre">cushion</span></code> is the one woken (and this task becoming unblocked resets the timers for the remaining tasks). If there are multiple tasks that have exactly the same <code class="docutils literal notranslate"><span class="pre">cushion</span></code>, then all are woken.</p> <p>You should also consider <a class="reference internal" href="#trio.testing.Sequencer" title="trio.testing.Sequencer"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.testing.Sequencer</span></code></a>, which provides a more explicit way to control execution ordering within a test, and will often produce more readable tests.</p> <p class="rubric">Example</p> <p>Here’s an example of one way to test that Trio’s locks are fair: we take the lock in the parent, start a child, wait for the child to be blocked waiting for the lock (!), and then check that we can’t release and immediately re-acquire the lock:</p> <pre data-language="python">async def lock_taker(lock):
    await lock.acquire()
    lock.release()

async def test_lock_fairness():
    lock = trio.Lock()
    await lock.acquire()
    async with trio.open_nursery() as nursery:
        nursery.start_soon(lock_taker, lock)
        # child hasn't run yet, we have the lock
        assert lock.locked()
        assert lock._owner is trio.lowlevel.current_task()
        await trio.testing.wait_all_tasks_blocked()
        # now the child has run and is blocked on lock.acquire(), we
        # still have the lock
        assert lock.locked()
        assert lock._owner is trio.lowlevel.current_task()
        lock.release()
        try:
            # The child has a prior claim, so we can't have it
            lock.acquire_nowait()
        except trio.WouldBlock:
            assert lock._owner is not trio.lowlevel.current_task()
            print("PASS")
        else:
            print("FAIL")</pre> </dd>
</dl> </section> <section id="streams"> <h2>Streams</h2> <section id="connecting-to-an-in-process-socket-server"> <h3>Connecting to an in-process socket server</h3> <dl class="py function"> <h3 class="sig sig-object py" id="trio.testing.open_stream_to_socket_listener"><code><em>await</em> trio.testing.open_stream_to_socket_listener(socket_listener)</code></h3> <dd>
<p>Connect to the given <a class="reference internal" href="reference-io.html#trio.SocketListener" title="trio.SocketListener"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketListener</span></code></a>.</p> <p>This is particularly useful in tests when you want to let a server pick its own port, and then connect to it:</p> <pre data-language="python">listeners = await trio.open_tcp_listeners(0)
client = await trio.testing.open_stream_to_socket_listener(listeners[0])</pre> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><strong>socket_listener</strong> (<a class="reference internal" href="reference-io.html#trio.SocketListener" title="trio.SocketListener"><em>SocketListener</em></a>) – The <a class="reference internal" href="reference-io.html#trio.SocketListener" title="trio.SocketListener"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketListener</span></code></a> to connect to.</p> </dd> <h4 class="field-even" style="margin: 0">Returns<span class="colon">:</span>
</h4> <dd class="field-even">
<p>a stream connected to the given listener.</p> </dd> <h4 class="field-odd" style="margin: 0">Return type<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><a class="reference internal" href="reference-io.html#trio.SocketStream" title="trio.SocketStream">SocketStream</a></p> </dd> </dl> </dd>
</dl> </section> <section id="virtual-controllable-streams"> <h3>Virtual, controllable streams</h3> <p>One particularly challenging problem when testing network protocols is making sure that your implementation can handle data whose flow gets broken up in weird ways and arrives with weird timings: localhost connections tend to be much better behaved than real networks, so if you only test on localhost then you might get bitten later. To help you out, Trio provides some fully in-memory implementations of the stream interfaces (see <a class="reference internal" href="reference-io.html#abstract-stream-api"><span class="std std-ref">The abstract Stream API</span></a>), that let you write all kinds of interestingly evil tests.</p> <p>There are a few pieces here, so here’s how they fit together:</p> <p><a class="reference internal" href="#trio.testing.memory_stream_pair" title="trio.testing.memory_stream_pair"><code class="xref py py-func docutils literal notranslate"><span class="pre">memory_stream_pair()</span></code></a> gives you a pair of connected, bidirectional streams. It’s like <a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socketpair" title="(in Python v3.11)"><code class="xref py py-func docutils literal notranslate"><span class="pre">socket.socketpair()</span></code></a>, but without any involvement from that pesky operating system and its networking stack.</p> <p>To build a bidirectional stream, <a class="reference internal" href="#trio.testing.memory_stream_pair" title="trio.testing.memory_stream_pair"><code class="xref py py-func docutils literal notranslate"><span class="pre">memory_stream_pair()</span></code></a> uses two unidirectional streams. It gets these by calling <a class="reference internal" href="#trio.testing.memory_stream_one_way_pair" title="trio.testing.memory_stream_one_way_pair"><code class="xref py py-func docutils literal notranslate"><span class="pre">memory_stream_one_way_pair()</span></code></a>.</p> <p><a class="reference internal" href="#trio.testing.memory_stream_one_way_pair" title="trio.testing.memory_stream_one_way_pair"><code class="xref py py-func docutils literal notranslate"><span class="pre">memory_stream_one_way_pair()</span></code></a>, in turn, is implemented using the low-ish level classes <a class="reference internal" href="#trio.testing.MemorySendStream" title="trio.testing.MemorySendStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemorySendStream</span></code></a> and <a class="reference internal" href="#trio.testing.MemoryReceiveStream" title="trio.testing.MemoryReceiveStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemoryReceiveStream</span></code></a>. These are implementations of (you guessed it) <a class="reference internal" href="reference-io.html#trio.abc.SendStream" title="trio.abc.SendStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.abc.SendStream</span></code></a> and <a class="reference internal" href="reference-io.html#trio.abc.ReceiveStream" title="trio.abc.ReceiveStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.abc.ReceiveStream</span></code></a> that on their own, aren’t attached to anything – “sending” and “receiving” just put data into and get data out of a private internal buffer that each object owns. They also have some interesting hooks you can set, that let you customize the behavior of their methods. This is where you can insert the evil, if you want it. <a class="reference internal" href="#trio.testing.memory_stream_one_way_pair" title="trio.testing.memory_stream_one_way_pair"><code class="xref py py-func docutils literal notranslate"><span class="pre">memory_stream_one_way_pair()</span></code></a> takes advantage of these hooks in a relatively boring way: it just sets it up so that when you call <code class="docutils literal notranslate"><span class="pre">send_all</span></code>, or when you close the send stream, then it automatically triggers a call to <a class="reference internal" href="#trio.testing.memory_stream_pump" title="trio.testing.memory_stream_pump"><code class="xref py py-func docutils literal notranslate"><span class="pre">memory_stream_pump()</span></code></a>, which is a convenience function that takes data out of a <a class="reference internal" href="#trio.testing.MemorySendStream" title="trio.testing.MemorySendStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemorySendStream</span></code></a>´s buffer and puts it into a <a class="reference internal" href="#trio.testing.MemoryReceiveStream" title="trio.testing.MemoryReceiveStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemoryReceiveStream</span></code></a>´s buffer. But that’s just the default – you can replace this with whatever arbitrary behavior you want.</p> <p>Trio also provides some specialized functions for testing completely <strong>un</strong>buffered streams: <a class="reference internal" href="#trio.testing.lockstep_stream_one_way_pair" title="trio.testing.lockstep_stream_one_way_pair"><code class="xref py py-func docutils literal notranslate"><span class="pre">lockstep_stream_one_way_pair()</span></code></a> and <a class="reference internal" href="#trio.testing.lockstep_stream_pair" title="trio.testing.lockstep_stream_pair"><code class="xref py py-func docutils literal notranslate"><span class="pre">lockstep_stream_pair()</span></code></a>. These aren’t customizable, but they do exhibit an extreme kind of behavior that’s good at catching out edge cases in protocol implementations.</p> </section> <section id="api-details"> <h3>API details</h3> <dl class="py class"> <h3 class="sig sig-object py" id="trio.testing.MemorySendStream"><code><em>class</em> trio.testing.MemorySendStream(send_all_hook=None, wait_send_all_might_not_block_hook=None, close_hook=None)</code></h3> <dd>
<p>An in-memory <a class="reference internal" href="reference-io.html#trio.abc.SendStream" title="trio.abc.SendStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SendStream</span></code></a>.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<ul class="simple"> <li><p><strong>send_all_hook</strong> – An async function, or None. Called from <a class="reference internal" href="#trio.testing.MemorySendStream.send_all" title="trio.testing.MemorySendStream.send_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_all()</span></code></a>. Can do whatever you like.</p></li> <li><p><strong>wait_send_all_might_not_block_hook</strong> – An async function, or None. Called from <a class="reference internal" href="#trio.testing.MemorySendStream.wait_send_all_might_not_block" title="trio.testing.MemorySendStream.wait_send_all_might_not_block"><code class="xref py py-meth docutils literal notranslate"><span class="pre">wait_send_all_might_not_block()</span></code></a>. Can do whatever you like.</p></li> <li><p><strong>close_hook</strong> – A synchronous function, or None. Called from <a class="reference internal" href="#trio.testing.MemorySendStream.close" title="trio.testing.MemorySendStream.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> and <a class="reference internal" href="#trio.testing.MemorySendStream.aclose" title="trio.testing.MemorySendStream.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a>. Can do whatever you like.</p></li> </ul> </dd> </dl> <dl class="py attribute"> <h3 class="sig sig-object py" id="trio.testing.MemorySendStream.send_all_hook"><code>send_all_hook</code></h3> <h3 class="sig sig-object py" id="trio.testing.MemorySendStream.wait_send_all_might_not_block_hook"><code>wait_send_all_might_not_block_hook</code></h3> <h3 class="sig sig-object py" id="trio.testing.MemorySendStream.close_hook"><code>close_hook</code></h3> <dd>
<p>All of these hooks are also exposed as attributes on the object, and you can change them at any time.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.testing.MemorySendStream.aclose"><code><em>await</em> aclose()</code></h3> <dd>
<p>Same as <a class="reference internal" href="#trio.testing.MemorySendStream.close" title="trio.testing.MemorySendStream.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a>, but async.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.testing.MemorySendStream.close"><code>close()</code></h3> <dd>
<p>Marks this stream as closed, and then calls the <a class="reference internal" href="#trio.testing.MemorySendStream.close_hook" title="trio.testing.MemorySendStream.close_hook"><code class="xref py py-attr docutils literal notranslate"><span class="pre">close_hook</span></code></a> (if any).</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.testing.MemorySendStream.get_data"><code><em>await</em> get_data(max_bytes=None)</code></h3> <dd>
<p>Retrieves data from the internal buffer, blocking if necessary.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><strong>max_bytes</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em> or </em><em>None</em>) – The maximum amount of data to retrieve. None (the default) means to retrieve all the data that’s present (but still blocks until at least one byte is available).</p> </dd> <h4 class="field-even" style="margin: 0">Returns<span class="colon">:</span>
</h4> <dd class="field-even">
<p>If this stream has been closed, an empty bytearray. Otherwise, the requested data.</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.testing.MemorySendStream.get_data_nowait"><code>get_data_nowait(max_bytes=None)</code></h3> <dd>
<p>Retrieves data from the internal buffer, but doesn’t block.</p> <p>See <a class="reference internal" href="#trio.testing.MemorySendStream.get_data" title="trio.testing.MemorySendStream.get_data"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_data()</span></code></a> for details.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Raises<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><a class="reference internal" href="reference-core.html#trio.WouldBlock" title="trio.WouldBlock"><strong>trio.WouldBlock</strong></a> – if no data is available to retrieve.</p> </dd> </dl> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.testing.MemorySendStream.send_all"><code><em>await</em> send_all(data)</code></h3> <dd>
<p>Places the given data into the object’s internal buffer, and then calls the <a class="reference internal" href="#trio.testing.MemorySendStream.send_all_hook" title="trio.testing.MemorySendStream.send_all_hook"><code class="xref py py-attr docutils literal notranslate"><span class="pre">send_all_hook</span></code></a> (if any).</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.testing.MemorySendStream.wait_send_all_might_not_block"><code><em>await</em> wait_send_all_might_not_block()</code></h3> <dd>
<p>Calls the <a class="reference internal" href="#trio.testing.MemorySendStream.wait_send_all_might_not_block_hook" title="trio.testing.MemorySendStream.wait_send_all_might_not_block_hook"><code class="xref py py-attr docutils literal notranslate"><span class="pre">wait_send_all_might_not_block_hook</span></code></a> (if any), and then returns immediately.</p> </dd>
</dl> </dd>
</dl> <dl class="py class"> <h3 class="sig sig-object py" id="trio.testing.MemoryReceiveStream"><code><em>class</em> trio.testing.MemoryReceiveStream(receive_some_hook=None, close_hook=None)</code></h3> <dd>
<p>An in-memory <a class="reference internal" href="reference-io.html#trio.abc.ReceiveStream" title="trio.abc.ReceiveStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReceiveStream</span></code></a>.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<ul class="simple"> <li><p><strong>receive_some_hook</strong> – An async function, or None. Called from <a class="reference internal" href="#trio.testing.MemoryReceiveStream.receive_some" title="trio.testing.MemoryReceiveStream.receive_some"><code class="xref py py-meth docutils literal notranslate"><span class="pre">receive_some()</span></code></a>. Can do whatever you like.</p></li> <li><p><strong>close_hook</strong> – A synchronous function, or None. Called from <a class="reference internal" href="#trio.testing.MemoryReceiveStream.close" title="trio.testing.MemoryReceiveStream.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a> and <a class="reference internal" href="#trio.testing.MemoryReceiveStream.aclose" title="trio.testing.MemoryReceiveStream.aclose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">aclose()</span></code></a>. Can do whatever you like.</p></li> </ul> </dd> </dl> <dl class="py attribute"> <h3 class="sig sig-object py" id="trio.testing.MemoryReceiveStream.receive_some_hook"><code>receive_some_hook</code></h3> <h3 class="sig sig-object py" id="trio.testing.MemoryReceiveStream.close_hook"><code>close_hook</code></h3> <dd>
<p>Both hooks are also exposed as attributes on the object, and you can change them at any time.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.testing.MemoryReceiveStream.aclose"><code><em>await</em> aclose()</code></h3> <dd>
<p>Same as <a class="reference internal" href="#trio.testing.MemoryReceiveStream.close" title="trio.testing.MemoryReceiveStream.close"><code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code></a>, but async.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.testing.MemoryReceiveStream.close"><code>close()</code></h3> <dd>
<p>Discards any pending data from the internal buffer, and marks this stream as closed.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.testing.MemoryReceiveStream.put_data"><code>put_data(data)</code></h3> <dd>
<p>Appends the given data to the internal buffer.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.testing.MemoryReceiveStream.put_eof"><code>put_eof()</code></h3> <dd>
<p>Adds an end-of-file marker to the internal buffer.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.testing.MemoryReceiveStream.receive_some"><code><em>await</em> receive_some(max_bytes=None)</code></h3> <dd>
<p>Calls the <a class="reference internal" href="#trio.testing.MemoryReceiveStream.receive_some_hook" title="trio.testing.MemoryReceiveStream.receive_some_hook"><code class="xref py py-attr docutils literal notranslate"><span class="pre">receive_some_hook</span></code></a> (if any), and then retrieves data from the internal buffer, blocking if necessary.</p> </dd>
</dl> </dd>
</dl> <dl class="py function"> <h3 class="sig sig-object py" id="trio.testing.memory_stream_pump"><code>trio.testing.memory_stream_pump(memory_send_stream, memory_receive_stream, *, max_bytes=None)</code></h3> <dd>
<p>Take data out of the given <a class="reference internal" href="#trio.testing.MemorySendStream" title="trio.testing.MemorySendStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemorySendStream</span></code></a>’s internal buffer, and put it into the given <a class="reference internal" href="#trio.testing.MemoryReceiveStream" title="trio.testing.MemoryReceiveStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemoryReceiveStream</span></code></a>’s internal buffer.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<ul class="simple"> <li><p><strong>memory_send_stream</strong> (<a class="reference internal" href="#trio.testing.MemorySendStream" title="trio.testing.MemorySendStream"><em>MemorySendStream</em></a>) – The stream to get data from.</p></li> <li><p><strong>memory_receive_stream</strong> (<a class="reference internal" href="#trio.testing.MemoryReceiveStream" title="trio.testing.MemoryReceiveStream"><em>MemoryReceiveStream</em></a>) – The stream to put data into.</p></li> <li><p><strong>max_bytes</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em> or </em><em>None</em>) – The maximum amount of data to transfer in this call, or None to transfer all available data.</p></li> </ul> </dd> <h4 class="field-even" style="margin: 0">Returns<span class="colon">:</span>
</h4> <dd class="field-even">
<p>True if it successfully transferred some data, or False if there was no data to transfer.</p> </dd> </dl> <p>This is used to implement <a class="reference internal" href="#trio.testing.memory_stream_one_way_pair" title="trio.testing.memory_stream_one_way_pair"><code class="xref py py-func docutils literal notranslate"><span class="pre">memory_stream_one_way_pair()</span></code></a> and <a class="reference internal" href="#trio.testing.memory_stream_pair" title="trio.testing.memory_stream_pair"><code class="xref py py-func docutils literal notranslate"><span class="pre">memory_stream_pair()</span></code></a>; see the latter’s docstring for an example of how you might use it yourself.</p> </dd>
</dl> <dl class="py function"> <h3 class="sig sig-object py" id="trio.testing.memory_stream_one_way_pair"><code>trio.testing.memory_stream_one_way_pair()</code></h3> <dd>
<p>Create a connected, pure-Python, unidirectional stream with infinite buffering and flexible configuration options.</p> <p>You can think of this as being a no-operating-system-involved Trio-streamsified version of <a class="reference external" href="https://docs.python.org/3/library/os.html#os.pipe" title="(in Python v3.11)"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.pipe()</span></code></a> (except that <a class="reference external" href="https://docs.python.org/3/library/os.html#os.pipe" title="(in Python v3.11)"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.pipe()</span></code></a> returns the streams in the wrong order – we follow the superior convention that data flows from left to right).</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Returns<span class="colon">:</span>
</h4> <dd class="field-odd">
<p>A tuple (<a class="reference internal" href="#trio.testing.MemorySendStream" title="trio.testing.MemorySendStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemorySendStream</span></code></a>, <a class="reference internal" href="#trio.testing.MemoryReceiveStream" title="trio.testing.MemoryReceiveStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemoryReceiveStream</span></code></a>), where the <a class="reference internal" href="#trio.testing.MemorySendStream" title="trio.testing.MemorySendStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemorySendStream</span></code></a> has its hooks set up so that it calls <a class="reference internal" href="#trio.testing.memory_stream_pump" title="trio.testing.memory_stream_pump"><code class="xref py py-func docutils literal notranslate"><span class="pre">memory_stream_pump()</span></code></a> from its <a class="reference internal" href="#trio.testing.MemorySendStream.send_all_hook" title="trio.testing.MemorySendStream.send_all_hook"><code class="xref py py-attr docutils literal notranslate"><span class="pre">send_all_hook</span></code></a> and <a class="reference internal" href="#trio.testing.MemorySendStream.close_hook" title="trio.testing.MemorySendStream.close_hook"><code class="xref py py-attr docutils literal notranslate"><span class="pre">close_hook</span></code></a>.</p> </dd> </dl> <p>The end result is that data automatically flows from the <a class="reference internal" href="#trio.testing.MemorySendStream" title="trio.testing.MemorySendStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemorySendStream</span></code></a> to the <a class="reference internal" href="#trio.testing.MemoryReceiveStream" title="trio.testing.MemoryReceiveStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemoryReceiveStream</span></code></a>. But you’re also free to rearrange things however you like. For example, you can temporarily set the <a class="reference internal" href="#trio.testing.MemorySendStream.send_all_hook" title="trio.testing.MemorySendStream.send_all_hook"><code class="xref py py-attr docutils literal notranslate"><span class="pre">send_all_hook</span></code></a> to None if you want to simulate a stall in data transmission. Or see <a class="reference internal" href="#trio.testing.memory_stream_pair" title="trio.testing.memory_stream_pair"><code class="xref py py-func docutils literal notranslate"><span class="pre">memory_stream_pair()</span></code></a> for a more elaborate example.</p> </dd>
</dl> <dl class="py function"> <h3 class="sig sig-object py" id="trio.testing.memory_stream_pair"><code>trio.testing.memory_stream_pair()</code></h3> <dd>
<p>Create a connected, pure-Python, bidirectional stream with infinite buffering and flexible configuration options.</p> <p>This is a convenience function that creates two one-way streams using <a class="reference internal" href="#trio.testing.memory_stream_one_way_pair" title="trio.testing.memory_stream_one_way_pair"><code class="xref py py-func docutils literal notranslate"><span class="pre">memory_stream_one_way_pair()</span></code></a>, and then uses <a class="reference internal" href="reference-io.html#trio.StapledStream" title="trio.StapledStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">StapledStream</span></code></a> to combine them into a single bidirectional stream.</p> <p>This is like a no-operating-system-involved, Trio-streamsified version of <a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.socketpair" title="(in Python v3.11)"><code class="xref py py-func docutils literal notranslate"><span class="pre">socket.socketpair()</span></code></a>.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Returns<span class="colon">:</span>
</h4> <dd class="field-odd">
<p>A pair of <a class="reference internal" href="reference-io.html#trio.StapledStream" title="trio.StapledStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">StapledStream</span></code></a> objects that are connected so that data automatically flows from one to the other in both directions.</p> </dd> </dl> <p>After creating a stream pair, you can send data back and forth, which is enough for simple tests:</p> <pre data-language="python">left, right = memory_stream_pair()
await left.send_all(b"123")
assert await right.receive_some() == b"123"
await right.send_all(b"456")
assert await left.receive_some() == b"456"</pre> <p>But if you read the docs for <a class="reference internal" href="reference-io.html#trio.StapledStream" title="trio.StapledStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">StapledStream</span></code></a> and <a class="reference internal" href="#trio.testing.memory_stream_one_way_pair" title="trio.testing.memory_stream_one_way_pair"><code class="xref py py-func docutils literal notranslate"><span class="pre">memory_stream_one_way_pair()</span></code></a>, you’ll see that all the pieces involved in wiring this up are public APIs, so you can adjust to suit the requirements of your tests. For example, here’s how to tweak a stream so that data flowing from left to right trickles in one byte at a time (but data flowing from right to left proceeds at full speed):</p> <pre data-language="python">left, right = memory_stream_pair()
async def trickle():
    # left is a StapledStream, and left.send_stream is a MemorySendStream
    # right is a StapledStream, and right.recv_stream is a MemoryReceiveStream
    while memory_stream_pump(left.send_stream, right.recv_stream, max_bytes=1):
        # Pause between each byte
        await trio.sleep(1)
# Normally this send_all_hook calls memory_stream_pump directly without
# passing in a max_bytes. We replace it with our custom version:
left.send_stream.send_all_hook = trickle</pre> <p>And here’s a simple test using our modified stream objects:</p> <pre data-language="python">async def sender():
    await left.send_all(b"12345")
    await left.send_eof()

async def receiver():
    async for data in right:
        print(data)

async with trio.open_nursery() as nursery:
    nursery.start_soon(sender)
    nursery.start_soon(receiver)</pre> <p>By default, this will print <code class="docutils literal notranslate"><span class="pre">b"12345"</span></code> and then immediately exit; with our trickle stream it instead sleeps 1 second, then prints <code class="docutils literal notranslate"><span class="pre">b"1"</span></code>, then sleeps 1 second, then prints <code class="docutils literal notranslate"><span class="pre">b"2"</span></code>, etc.</p> <p>Pro-tip: you can insert sleep calls (like in our example above) to manipulate the flow of data across tasks… and then use <a class="reference internal" href="#trio.testing.MockClock" title="trio.testing.MockClock"><code class="xref py py-class docutils literal notranslate"><span class="pre">MockClock</span></code></a> and its <a class="reference internal" href="#trio.testing.MockClock.autojump_threshold" title="trio.testing.MockClock.autojump_threshold"><code class="xref py py-attr docutils literal notranslate"><span class="pre">autojump_threshold</span></code></a> functionality to keep your test suite running quickly.</p> <p>If you want to stress test a protocol implementation, one nice trick is to use the <a class="reference external" href="https://docs.python.org/3/library/random.html#module-random" title="(in Python v3.11)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">random</span></code></a> module (preferably with a fixed seed) to move random numbers of bytes at a time, and insert random sleeps in between them. You can also set up a custom <a class="reference internal" href="#trio.testing.MemoryReceiveStream.receive_some_hook" title="trio.testing.MemoryReceiveStream.receive_some_hook"><code class="xref py py-attr docutils literal notranslate"><span class="pre">receive_some_hook</span></code></a> if you want to manipulate things on the receiving side, and not just the sending side.</p> </dd>
</dl> <dl class="py function"> <h3 class="sig sig-object py" id="trio.testing.lockstep_stream_one_way_pair"><code>trio.testing.lockstep_stream_one_way_pair()</code></h3> <dd>
<p>Create a connected, pure Python, unidirectional stream where data flows in lockstep.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Returns<span class="colon">:</span>
</h4> <dd class="field-odd">
<p>A tuple (<a class="reference internal" href="reference-io.html#trio.abc.SendStream" title="trio.abc.SendStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SendStream</span></code></a>, <a class="reference internal" href="reference-io.html#trio.abc.ReceiveStream" title="trio.abc.ReceiveStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReceiveStream</span></code></a>).</p> </dd> </dl> <p>This stream has <em>absolutely no</em> buffering. Each call to <a class="reference internal" href="reference-io.html#trio.abc.SendStream.send_all" title="trio.abc.SendStream.send_all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">send_all()</span></code></a> will block until all the given data has been returned by a call to <a class="reference internal" href="reference-io.html#trio.abc.ReceiveStream.receive_some" title="trio.abc.ReceiveStream.receive_some"><code class="xref py py-meth docutils literal notranslate"><span class="pre">receive_some()</span></code></a>.</p> <p>This can be useful for testing flow control mechanisms in an extreme case, or for setting up “clogged” streams to use with <a class="reference internal" href="#trio.testing.check_one_way_stream" title="trio.testing.check_one_way_stream"><code class="xref py py-func docutils literal notranslate"><span class="pre">check_one_way_stream()</span></code></a> and friends.</p> <p>In addition to fulfilling the <a class="reference internal" href="reference-io.html#trio.abc.SendStream" title="trio.abc.SendStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SendStream</span></code></a> and <a class="reference internal" href="reference-io.html#trio.abc.ReceiveStream" title="trio.abc.ReceiveStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReceiveStream</span></code></a> interfaces, the return objects also have a synchronous <code class="docutils literal notranslate"><span class="pre">close</span></code> method.</p> </dd>
</dl> <dl class="py function"> <h3 class="sig sig-object py" id="trio.testing.lockstep_stream_pair"><code>trio.testing.lockstep_stream_pair()</code></h3> <dd>
<p>Create a connected, pure-Python, bidirectional stream where data flows in lockstep.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Returns<span class="colon">:</span>
</h4> <dd class="field-odd">
<p>A tuple (<a class="reference internal" href="reference-io.html#trio.StapledStream" title="trio.StapledStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">StapledStream</span></code></a>, <a class="reference internal" href="reference-io.html#trio.StapledStream" title="trio.StapledStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">StapledStream</span></code></a>).</p> </dd> </dl> <p>This is a convenience function that creates two one-way streams using <a class="reference internal" href="#trio.testing.lockstep_stream_one_way_pair" title="trio.testing.lockstep_stream_one_way_pair"><code class="xref py py-func docutils literal notranslate"><span class="pre">lockstep_stream_one_way_pair()</span></code></a>, and then uses <a class="reference internal" href="reference-io.html#trio.StapledStream" title="trio.StapledStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">StapledStream</span></code></a> to combine them into a single bidirectional stream.</p> </dd>
</dl> </section> <section id="testing-custom-stream-implementations"> <h3>Testing custom stream implementations</h3> <p>Trio also provides some functions to help you test your custom stream implementations:</p> <dl class="py function"> <h3 class="sig sig-object py" id="trio.testing.check_one_way_stream"><code><em>await</em> trio.testing.check_one_way_stream(stream_maker, clogged_stream_maker)</code></h3> <dd>
<p>Perform a number of generic tests on a custom one-way stream implementation.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<ul class="simple"> <li><p><strong>stream_maker</strong> – An async (!) function which returns a connected (<a class="reference internal" href="reference-io.html#trio.abc.SendStream" title="trio.abc.SendStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">SendStream</span></code></a>, <a class="reference internal" href="reference-io.html#trio.abc.ReceiveStream" title="trio.abc.ReceiveStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">ReceiveStream</span></code></a>) pair.</p></li> <li><p><strong>clogged_stream_maker</strong> – Either None, or an async function similar to stream_maker, but with the extra property that the returned stream is in a state where <code class="docutils literal notranslate"><span class="pre">send_all</span></code> and <code class="docutils literal notranslate"><span class="pre">wait_send_all_might_not_block</span></code> will block until <code class="docutils literal notranslate"><span class="pre">receive_some</span></code> has been called. This allows for more thorough testing of some edge cases, especially around <code class="docutils literal notranslate"><span class="pre">wait_send_all_might_not_block</span></code>.</p></li> </ul> </dd> <h4 class="field-even" style="margin: 0">Raises<span class="colon">:</span>
</h4> <dd class="field-even">
<p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#AssertionError" title="(in Python v3.11)"><strong>AssertionError</strong></a> – if a test fails.</p> </dd> </dl> </dd>
</dl> <dl class="py function"> <h3 class="sig sig-object py" id="trio.testing.check_two_way_stream"><code><em>await</em> trio.testing.check_two_way_stream(stream_maker, clogged_stream_maker)</code></h3> <dd>
<p>Perform a number of generic tests on a custom two-way stream implementation.</p> <p>This is similar to <a class="reference internal" href="#trio.testing.check_one_way_stream" title="trio.testing.check_one_way_stream"><code class="xref py py-func docutils literal notranslate"><span class="pre">check_one_way_stream()</span></code></a>, except that the maker functions are expected to return objects implementing the <a class="reference internal" href="reference-io.html#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a> interface.</p> <p>This function tests a <em>superset</em> of what <a class="reference internal" href="#trio.testing.check_one_way_stream" title="trio.testing.check_one_way_stream"><code class="xref py py-func docutils literal notranslate"><span class="pre">check_one_way_stream()</span></code></a> checks – if you call this, then you don’t need to also call <a class="reference internal" href="#trio.testing.check_one_way_stream" title="trio.testing.check_one_way_stream"><code class="xref py py-func docutils literal notranslate"><span class="pre">check_one_way_stream()</span></code></a>.</p> </dd>
</dl> <dl class="py function"> <h3 class="sig sig-object py" id="trio.testing.check_half_closeable_stream"><code><em>await</em> trio.testing.check_half_closeable_stream(stream_maker, clogged_stream_maker)</code></h3> <dd>
<p>Perform a number of generic tests on a custom half-closeable stream implementation.</p> <p>This is similar to <a class="reference internal" href="#trio.testing.check_two_way_stream" title="trio.testing.check_two_way_stream"><code class="xref py py-func docutils literal notranslate"><span class="pre">check_two_way_stream()</span></code></a>, except that the maker functions are expected to return objects that implement the <a class="reference internal" href="reference-io.html#trio.abc.HalfCloseableStream" title="trio.abc.HalfCloseableStream"><code class="xref py py-class docutils literal notranslate"><span class="pre">HalfCloseableStream</span></code></a> interface.</p> <p>This function tests a <em>superset</em> of what <a class="reference internal" href="#trio.testing.check_two_way_stream" title="trio.testing.check_two_way_stream"><code class="xref py py-func docutils literal notranslate"><span class="pre">check_two_way_stream()</span></code></a> checks – if you call this, then you don’t need to also call <a class="reference internal" href="#trio.testing.check_two_way_stream" title="trio.testing.check_two_way_stream"><code class="xref py py-func docutils literal notranslate"><span class="pre">check_two_way_stream()</span></code></a>.</p> </dd>
</dl> </section> </section> <section id="virtual-networking-for-testing"> <h2>Virtual networking for testing</h2> <p>In the previous section you learned how to use virtual in-memory streams to test protocols that are written against Trio’s <a class="reference internal" href="reference-io.html#trio.abc.Stream" title="trio.abc.Stream"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stream</span></code></a> abstraction. But what if you have more complicated networking code – the kind of code that makes connections to multiple hosts, or opens a listening socket, or sends UDP packets?</p> <p>Trio doesn’t itself provide a virtual in-memory network implementation for testing – but <a class="reference internal" href="reference-io.html#module-trio.socket" title="trio.socket"><code class="xref py py-mod docutils literal notranslate"><span class="pre">trio.socket</span></code></a> module does provide the hooks you need to write your own! And if you’re interested in helping implement a reusable virtual network for testing, then <a class="reference external" href="https://github.com/python-trio/trio/issues/170">please get in touch</a>.</p> <p>Note that these APIs are actually in <a class="reference internal" href="reference-io.html#module-trio.socket" title="trio.socket"><code class="xref py py-mod docutils literal notranslate"><span class="pre">trio.socket</span></code></a> and <code class="xref py py-mod docutils literal notranslate"><span class="pre">trio.abc</span></code>, but we document them here because they’re primarily intended for testing.</p> <dl class="py function"> <h3 class="sig sig-object py" id="trio.socket.set_custom_hostname_resolver"><code>trio.socket.set_custom_hostname_resolver(hostname_resolver)</code></h3> <dd>
<p>Set a custom hostname resolver.</p> <p>By default, Trio’s <a class="reference internal" href="reference-io.html#trio.socket.getaddrinfo" title="trio.socket.getaddrinfo"><code class="xref py py-func docutils literal notranslate"><span class="pre">getaddrinfo()</span></code></a> and <a class="reference internal" href="reference-io.html#trio.socket.getnameinfo" title="trio.socket.getnameinfo"><code class="xref py py-func docutils literal notranslate"><span class="pre">getnameinfo()</span></code></a> functions use the standard system resolver functions. This function allows you to customize that behavior. The main intended use case is for testing, but it might also be useful for using third-party resolvers like <a class="reference external" href="https://c-ares.haxx.se/">c-ares</a> (though be warned that these rarely make perfect drop-in replacements for the system resolver). See <a class="reference internal" href="#trio.abc.HostnameResolver" title="trio.abc.HostnameResolver"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.abc.HostnameResolver</span></code></a> for more details.</p> <p>Setting a custom hostname resolver affects all future calls to <a class="reference internal" href="reference-io.html#trio.socket.getaddrinfo" title="trio.socket.getaddrinfo"><code class="xref py py-func docutils literal notranslate"><span class="pre">getaddrinfo()</span></code></a> and <a class="reference internal" href="reference-io.html#trio.socket.getnameinfo" title="trio.socket.getnameinfo"><code class="xref py py-func docutils literal notranslate"><span class="pre">getnameinfo()</span></code></a> within the enclosing call to <a class="reference internal" href="reference-core.html#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a>. All other hostname resolution in Trio is implemented in terms of these functions.</p> <p>Generally you should call this function just once, right at the beginning of your program.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><strong>hostname_resolver</strong> (<a class="reference internal" href="#trio.abc.HostnameResolver" title="trio.abc.HostnameResolver"><em>trio.abc.HostnameResolver</em></a><em> or </em><em>None</em>) – The new custom hostname resolver, or None to restore the default behavior.</p> </dd> <h4 class="field-even" style="margin: 0">Returns<span class="colon">:</span>
</h4> <dd class="field-even">
<p>The previous hostname resolver (which may be None).</p> </dd> </dl> </dd>
</dl> <dl class="py class"> <h3 class="sig sig-object py" id="trio.abc.HostnameResolver"><code><em>class</em> trio.abc.HostnameResolver</code></h3> <dd>
<p>If you have a custom hostname resolver, then implementing <a class="reference internal" href="#trio.abc.HostnameResolver" title="trio.abc.HostnameResolver"><code class="xref py py-class docutils literal notranslate"><span class="pre">HostnameResolver</span></code></a> allows you to register this to be used by Trio.</p> <p>See <a class="reference internal" href="#trio.socket.set_custom_hostname_resolver" title="trio.socket.set_custom_hostname_resolver"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.socket.set_custom_hostname_resolver()</span></code></a>.</p> <dl class="py method"> <h3 class="sig sig-object py" id="trio.abc.HostnameResolver.getaddrinfo"><code><em>abstractmethod await</em> getaddrinfo(host, port, family=0, type=0, proto=0, flags=0)</code></h3> <dd>
<p>A custom implementation of <a class="reference internal" href="reference-io.html#trio.socket.getaddrinfo" title="trio.socket.getaddrinfo"><code class="xref py py-func docutils literal notranslate"><span class="pre">getaddrinfo()</span></code></a>.</p> <p>Called by <a class="reference internal" href="reference-io.html#trio.socket.getaddrinfo" title="trio.socket.getaddrinfo"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.socket.getaddrinfo()</span></code></a>.</p> <p>If <code class="docutils literal notranslate"><span class="pre">host</span></code> is given as a numeric IP address, then <a class="reference internal" href="reference-io.html#trio.socket.getaddrinfo" title="trio.socket.getaddrinfo"><code class="xref py py-func docutils literal notranslate"><span class="pre">getaddrinfo()</span></code></a> may handle the request itself rather than calling this method.</p> <p>Any required IDNA encoding is handled before calling this function; your implementation can assume that it will never see U-labels like <code class="docutils literal notranslate"><span class="pre">"café.com"</span></code>, and only needs to handle A-labels like <code class="docutils literal notranslate"><span class="pre">b"xn--caf-dma.com"</span></code>.</p> </dd>
</dl> <dl class="py method"> <h3 class="sig sig-object py" id="trio.abc.HostnameResolver.getnameinfo"><code><em>abstractmethod await</em> getnameinfo(sockaddr, flags)</code></h3> <dd>
<p>A custom implementation of <a class="reference internal" href="reference-io.html#trio.socket.getnameinfo" title="trio.socket.getnameinfo"><code class="xref py py-func docutils literal notranslate"><span class="pre">getnameinfo()</span></code></a>.</p> <p>Called by <a class="reference internal" href="reference-io.html#trio.socket.getnameinfo" title="trio.socket.getnameinfo"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.socket.getnameinfo()</span></code></a>.</p> </dd>
</dl> </dd>
</dl> <dl class="py function"> <h3 class="sig sig-object py" id="trio.socket.set_custom_socket_factory"><code>trio.socket.set_custom_socket_factory(socket_factory)</code></h3> <dd>
<p>Set a custom socket object factory.</p> <p>This function allows you to replace Trio’s normal socket class with a custom class. This is very useful for testing, and probably a bad idea in any other circumstance. See <a class="reference internal" href="#trio.abc.HostnameResolver" title="trio.abc.HostnameResolver"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.abc.HostnameResolver</span></code></a> for more details.</p> <p>Setting a custom socket factory affects all future calls to <a class="reference internal" href="reference-io.html#trio.socket.socket" title="trio.socket.socket"><code class="xref py py-func docutils literal notranslate"><span class="pre">socket()</span></code></a> within the enclosing call to <a class="reference internal" href="reference-core.html#trio.run" title="trio.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.run()</span></code></a>.</p> <p>Generally you should call this function just once, right at the beginning of your program.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Parameters<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><strong>socket_factory</strong> (<a class="reference internal" href="#trio.abc.SocketFactory" title="trio.abc.SocketFactory"><em>trio.abc.SocketFactory</em></a><em> or </em><em>None</em>) – The new custom socket factory, or None to restore the default behavior.</p> </dd> <h4 class="field-even" style="margin: 0">Returns<span class="colon">:</span>
</h4> <dd class="field-even">
<p>The previous socket factory (which may be None).</p> </dd> </dl> </dd>
</dl> <dl class="py class"> <h3 class="sig sig-object py" id="trio.abc.SocketFactory"><code><em>class</em> trio.abc.SocketFactory</code></h3> <dd>
<p>If you write a custom class implementing the Trio socket interface, then you can use a <a class="reference internal" href="#trio.abc.SocketFactory" title="trio.abc.SocketFactory"><code class="xref py py-class docutils literal notranslate"><span class="pre">SocketFactory</span></code></a> to get Trio to use it.</p> <p>See <a class="reference internal" href="#trio.socket.set_custom_socket_factory" title="trio.socket.set_custom_socket_factory"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.socket.set_custom_socket_factory()</span></code></a>.</p> <dl class="py method"> <h3 class="sig sig-object py" id="trio.abc.SocketFactory.socket"><code><em>abstractmethod</em> socket(family=None, type=None, proto=None)</code></h3> <dd>
<p>Create and return a socket object.</p> <p>Your socket object must inherit from <a class="reference internal" href="reference-io.html#trio.socket.SocketType" title="trio.socket.SocketType"><code class="xref py py-class docutils literal notranslate"><span class="pre">trio.socket.SocketType</span></code></a>, which is an empty class whose only purpose is to “mark” which classes should be considered valid Trio sockets.</p> <p>Called by <a class="reference internal" href="reference-io.html#trio.socket.socket" title="trio.socket.socket"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.socket.socket()</span></code></a>.</p> <p>Note that unlike <a class="reference internal" href="reference-io.html#trio.socket.socket" title="trio.socket.socket"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.socket.socket()</span></code></a>, this does not take a <code class="docutils literal notranslate"><span class="pre">fileno=</span></code> argument. If a <code class="docutils literal notranslate"><span class="pre">fileno=</span></code> is specified, then <a class="reference internal" href="reference-io.html#trio.socket.socket" title="trio.socket.socket"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.socket.socket()</span></code></a> returns a regular Trio socket object instead of calling this method.</p> </dd>
</dl> </dd>
</dl> </section> <section id="testing-checkpoints"> <h2>Testing checkpoints</h2> <dl class="py function"> <h3 class="sig sig-object py" id="trio.testing.assert_checkpoints"><code><em>with</em> trio.testing.assert_checkpoints()</code></h3> <dd>
<p>Use as a context manager to check that the code inside the <code class="docutils literal notranslate"><span class="pre">with</span></code> block either exits with an exception or executes at least one <a class="reference internal" href="reference-core.html#checkpoints"><span class="std std-ref">checkpoint</span></a>.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Raises<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#AssertionError" title="(in Python v3.11)"><strong>AssertionError</strong></a> – if no checkpoint was executed.</p> </dd> </dl> <p class="rubric">Example</p> <p>Check that <a class="reference internal" href="reference-core.html#trio.sleep" title="trio.sleep"><code class="xref py py-func docutils literal notranslate"><span class="pre">trio.sleep()</span></code></a> is a checkpoint, even if it doesn’t block:</p> <pre data-language="python">with trio.testing.assert_checkpoints():
    await trio.sleep(0)</pre> </dd>
</dl> <dl class="py function"> <h3 class="sig sig-object py" id="trio.testing.assert_no_checkpoints"><code><em>with</em> trio.testing.assert_no_checkpoints()</code></h3> <dd>
<p>Use as a context manager to check that the code inside the <code class="docutils literal notranslate"><span class="pre">with</span></code> block does not execute any <a class="reference internal" href="reference-core.html#checkpoints"><span class="std std-ref">checkpoints</span></a>.</p> <dl class="field-list simple"> <h4 class="field-odd" style="margin: 0">Raises<span class="colon">:</span>
</h4> <dd class="field-odd">
<p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#AssertionError" title="(in Python v3.11)"><strong>AssertionError</strong></a> – if a checkpoint was executed.</p> </dd> </dl> <p class="rubric">Example</p> <p>Synchronous code never contains any checkpoints, but we can double-check that:</p> <pre data-language="python">send_channel, receive_channel = trio.open_memory_channel(10)
with trio.testing.assert_no_checkpoints():
    send_channel.send_nowait(None)</pre> </dd>
</dl> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2017 Nathaniel J. Smith<br>Licensed under the MIT License.<br>
    <a href="https://trio.readthedocs.io/en/v0.22.2/reference-testing.html" class="_attribution-link">https://trio.readthedocs.io/en/v0.22.2/reference-testing.html</a>
  </p>
</div>
