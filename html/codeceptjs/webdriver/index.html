<h1 id="testing-with-webdriver"> Testing with WebDriver</h1> <p>How does your client, manager, or tester, or any other non-technical person, know your web application is working? By opening the browser, accessing a site, clicking on links, filling in the forms, and actually seeing the content on a web page.</p> <p>End to End tests can cover standard but complex scenarios from a user's perspective. With e2e tests you can be confident that users, following all defined scenarios, won't get errors. We check <strong>functionality of application and a user interface</strong> (UI) as well.</p> <h2 id="what-is-selenium-webdriver"> What is Selenium WebDriver</h2> <p>The standard and proved way to run browser test automation over years is Selenium WebDriver. Over years this technology was standartized and works over all popular browsers and operating systems. There are cloud services like SauceLabs or BrowserStack which allow executing such browsers in the cloud. The superset of WebDriver protocol is also used to test <a href="https://codecept.io/mobile">native and hybrid mobile applications</a>.</p> <p>Let's clarify the terms:</p> <ul>
<li>Selenium - is a toolset for browser test automation</li> <li>WebDriver - a standard protocol for communicating between test framework and browsers</li> <li>JSON Wire - an older version of such protocol</li>
</ul> <p>We use <a href="https://webdriver.io" target="_blank" rel="noopener noreferrer">webdriverio<span> <span class="sr-only">(opens new window)</span></span></a> library to run tests over WebDriver.</p> <blockquote><p>Popular tool <a href="https://codecept.io/angular">Protractor</a> also uses WebDriver for running end 2 end tests.</p></blockquote> <p>To proceed you need to have <a href="https://codecept.io/quickstart#using-selenium-webdriver">CodeceptJS installed</a> and <code>WebDriver</code> helper selected.</p> <p>Selenium WebDriver may be complicated from start, as it requires following tools to be installed and started.</p> <ol>
<li>Selenium Server - to execute and send commands to browser</li> <li>ChromeDriver or GeckoDriver - to allow browsers to run in automated mode.</li>
</ol> <blockquote><p>Those tools can be easily installed via NPM. Use <a href="https://www.npmjs.com/package/selenium-standalone" target="_blank" rel="noopener noreferrer">selenium-standalone<span> <span class="sr-only">(opens new window)</span></span></a> to automatically install them.</p></blockquote> <p>You can also use <code>@wdio/selenium-standalone-service</code> package, to install and start Selenium Server for your tests automatically.</p> <div class="language- extra-class"><pre class="language-text">npm i @wdio/selenium-standalone-service --save-dev
</pre></div>
<p>Enable it in config inside plugins section:</p> <div class="language-js extra-class"><pre class="language-js">exports.config = {
  // ...
  // inside condecept.conf.js
  plugins: {
    wdio: {
      enabled: true,
      services: ['selenium-standalone']
    }
  }
}
</pre></div>
<blockquote><p>⚠ It is not recommended to use wdio plugin &amp; selenium-standalone when running tests in parallel. Consider <strong>switching to Selenoid</strong> if you need parallel run or using cloud services.</p></blockquote> <h2 id="configuring-webdriver"> Configuring WebDriver</h2> <p>WebDriver can be configured to run browser tests in window, headlessly, on a remote server or in a cloud.</p> <blockquote><p>By default CodeceptJS is already configured to run WebDriver tests locally with Chrome or Firefox. If you just need to start running tests - proceed to the next chapter.</p></blockquote> <p>Configuration for WebDriver should be provided inside <code>codecept.conf.js</code> file under <code>helpers: WebDriver</code> section:</p> <div class="language-js extra-class"><pre class="language-js">  helpers: {
    WebDriver: {
      url: 'https://myapp.com',
      browser: 'chrome',
      host: '127.0.0.1',
      port: 4444,
      restart: false,
      windowSize: '1920x1680',
      desiredCapabilities: {
        chromeOptions: {
          args: [ /*"--headless",*/ "--disable-gpu", "--no-sandbox" ]
        }
      }
    },
  }
</pre></div>
<p>By default CodeceptJS runs tests in the same browser window but clears cookies and local storage after each test. This behavior can be changed with these options:</p> <div class="language-js extra-class"><pre class="language-js">// change to true to restart browser between tests
restart: false,
// don't change browser state and not clear cookies between tests
keepBrowserState: true,
keepCookies: true,
</pre></div>
<blockquote><p>▶ More config options available on <a href="https://codecept.io/helpers/WebDriver#configuration">WebDriver helper reference</a></p></blockquote> <h3 id="chromedriver-without-selenium"> ChromeDriver without Selenium</h3> <p>If you want to run tests using raw ChromeDriver (which also supports WebDriver protocol) avoiding Selenium Server, you should provide following configuration:</p> <div class="language-js extra-class"><pre class="language-js">port: 9515,
browser: 'chrome',
path: '/',
</pre></div>
<blockquote><p>If you face issues connecting to WebDriver, please check that corresponding server is running on a specified port. If host is other than <code>localhost</code> or port is other than <code>4444</code>, update the configuration.</p></blockquote> <h3 id="selenium-in-docker-selenoid"> Selenium in Docker (Selenoid)</h3> <p>Browsers can be executed in Docker containers. This is useful when testing on Continous Integration server. We recommend using <a href="https://aerokube.com/selenoid/" target="_blank" rel="noopener noreferrer">Selenoid<span> <span class="sr-only">(opens new window)</span></span></a> to run browsers in container.</p> <p>CodeceptJS has <a href="https://codecept.io/plugins#selenoid">Selenoid plugin</a> which can automagically load browser container setup.</p> <h3 id="headless-mode"> Headless Mode</h3> <p>It is recommended to use <code>@codeceptjs/configure</code> package to easily toggle headless mode for WebDriver:</p> <div class="language-js extra-class"><pre class="language-js">// inside codecept.conf.js
const { setHeadlessWhen, setWindowSize } = require('@codeceptjs/configure');

setHeadlessWhen(process.env.HEADLESS); // enables headless mode when HEADLESS environment variable exists
</pre></div>
<p>This requires <code>@codeceptjs/configure</code> package to be installed.</p> <p>Alternatively, you can enable headless mode manually via desired capabilities.</p> <h3 id="desired-capabilities"> Desired Capabilities</h3> <p>Additional configuration can be passed via <code>desiredCapabilities</code> option. For instance, this is how we can set to <strong>run headless Chrome</strong>:</p> <div class="language-js extra-class"><pre class="language-js">desiredCapabilities: {
  chromeOptions: {
    args: [ "--headless", "--disable-gpu", "--window-size=1200,1000", "--no-sandbox" ]
  }
}
</pre></div>
<p>Next popular use case for capabilities is configuring what to do with unhandled alert popups.</p> <div class="language-js extra-class"><pre class="language-js">desiredCapabilities: {
  // close all unexpected popups
  unexpectedAlertBehaviour: 'dismiss',
}
</pre></div>
<h3 id="cloud-providers"> Cloud Providers</h3> <p>WebDriver protocol works over HTTP, so you need to have a Selenium Server to be running or any other service that will launch a browser for you. That's why you may need to specify <code>host</code>, <code>port</code>, <code>protocol</code>, and <code>path</code> parameters.</p> <p>By default, those parameters are set to connect to local Selenium Server but they should be changed if you want to run tests via <a href="https://codecept.io/helpers/WebDriver#cloud-providers">Cloud Providers</a>. You may also need <code>user</code> and <code>key</code> parameters to authenticate on cloud service.</p> <p>There are also <a href="https://github.com/SeleniumHQ/selenium/wiki/DesiredCapabilities" target="_blank" rel="noopener noreferrer">browser and platform specific capabilities<span> <span class="sr-only">(opens new window)</span></span></a>. Services like SauceLabs, BrowserStack or browser vendors can provide their own specific capabilities for more tuning.</p> <p>Here is a sample BrowserStack config for running tests on iOS mobile browser:</p> <div class="language-js extra-class"><pre class="language-js"> helpers: {
   WebDriver: {
     host: 'hub.browserstack.com',
     path: '/wd/hub',
     url: 'http://WEBSITE:8080/renderer',
     user: 'xx', // credentials
     key: 'xx', // credentials
     browser: 'iphone',
     desiredCapabilities: {
       'os_version' : '11',
       'device' : 'iPhone 8', // you can select device
       'real_mobile' : 'true', // real or emulated
       'browserstack.local' : 'true',
       'browserstack.debug' : 'true',
       'browserstack.networkLogs' : 'true',
       'browserstack.appium_version' : '1.9.1',
       'browserstack.user' : 'xx', // credentials
       'browserstack.key' : 'xx' // credentials
     }
   }
</pre></div>
<h2 id="writing-tests"> Writing Tests</h2> <p>CodeceptJS provides high-level API on top of WebDriver protocol. While most standard implementations focus on dealing with WebElements on page, CodeceptJS is about user scenarios and interactions. That's why you don't have a direct access to web elements inside a test, but it is proved that in majority of cases you don't need it. Tests written from user's perspective are simpler to write, understand, log and debug.</p> <blockquote><p>If you come from Java, Python or Ruby don't be afraid of a new syntax. It is more flexible than you think!</p></blockquote> <p>A typical test case may look like this:</p> <div class="language-js extra-class"><pre class="language-js">Feature('login');

Scenario('login test', ({ I }) =&gt; {
  I.amOnPage('/login');
  I.fillField('Username', 'john');
  I.fillField('Password', '123456');
  I.click('Login');
  I.see('Welcome, John');
});
</pre></div>
<blockquote><p>▶ Actions like <code>amOnPage</code>, <code>click</code>, <code>fillField</code> are not limited to WebDriver only. They work similarly for all available helpers. <a href="https://codecept.io/basics#writing-tests">Go to Basics guide to learn them</a>.</p></blockquote> <p>An empty test case can be created with <code>npx codeceptjs gt</code> command.</p> <div class="language- extra-class"><pre class="language-text">npx codeceptjs gt
</pre></div>
<p>It's easy to start writing a test if you use <a href="https://codecept.io/basics#debug">interactive pause</a>. Just open a web page and pause execution.</p> <div class="language-js extra-class"><pre class="language-js">Feature('Sample Test');

Scenario('open my website', ({ I }) =&gt; {
  I.amOnPage('/');
  pause();
});
</pre></div>
<p>This is just enough to run a test, open a browser, and think what to do next to write a test case.</p> <p>When you execute such test with <code>npx codeceptjs run</code> command you may see the browser is started</p> <div class="language- extra-class"><pre class="language-text">npx codeceptjs run --steps
</pre></div>
<p>After a page is opened a full control of a browser is given to a terminal. Type in different commands such as <code>click</code>, <code>see</code>, <code>fillField</code> to write the test. A successful commands will be saved to <code>./output/cli-history</code> file and can be copied into a test.</p> <blockquote><p>ℹ All actions are listed in <a href="https://codecept.io/helpers/WebDriver">WebDriver helper reference</a>.</p></blockquote> <p>An interactive shell output may look like this:</p> <div class="language- extra-class"><pre class="language-text"> Interactive shell started
 Use JavaScript syntax to try steps in action
 - Press ENTER to run the next step
 - Press TAB twice to see all available commands
 - Type exit + Enter to exit the interactive shell
 I.fillField('.new-todo', 'Write a test')
 I.pressKey('Enter')
 I.
 Commands have been saved to /home/davert/demos/codeceptjs/output/cli-history
</pre></div>
<p>After typing in successful commands you can copy them into a test.</p> <p>Here is a test checking basic <a href="http://todomvc.com/" target="_blank" rel="noopener noreferrer">todo application<span> <span class="sr-only">(opens new window)</span></span></a>.</p> <div class="language-js extra-class"><pre class="language-js">Feature('TodoMVC');

Scenario('create todo item', ({ I }) =&gt; {
  I.amOnPage('/examples/vue/');
  I.waitForElement('.new-todo');
  I.fillField('.new-todo', 'Write a test')
  I.pressKey('Enter');
  I.see('1 item left', '.todo-count');
});
</pre></div>
<blockquote><p><a href="https://github.com/DavertMik/codeceptjs-webdriver-example" target="_blank" rel="noopener noreferrer">▶ Working example of CodeceptJS WebDriver tests<span> <span class="sr-only">(opens new window)</span></span></a> for TodoMVC application.</p></blockquote> <p>WebDriver helper supports standard <a href="https://codecept.io/locators">CSS/XPath and text locators</a> as well as non-trivial <a href="https://codecept.io/react">React locators</a> and <a href="https://codecept.io/shadow">Shadow DOM</a>.</p> <h2 id="waiting"> Waiting</h2> <p>Web applications do not always respond instantly. That's why WebDriver protocol has methods to wait for changes on a page. CodeceptJS provides such commands prefixed with <code>wait*</code> so you could explicitly define what effects we wait for.</p> <p>Most popular "waiters" are:</p> <ul>
<li>
<code>waitForText</code> - wait for text to appear on a page</li> <li>
<code>waitForElement</code> - wait for element to appear on a page</li> <li>
<code>waitForInvisible</code> - wait element to become invisible.</li>
</ul> <p>By default, they will wait for 1 second. This number can be changed in WebDriver configuration:</p> <div class="language-js extra-class"><pre class="language-js">// inside codecept.conf.js
exports.config = {
  helpers: {
    WebDriver: {
      // WebDriver config goes here
      // wait for 5 seconds
      waitForTimeout: 5000
    }
  }
}
</pre></div>
<h2 id="smartwait"> SmartWait</h2> <p>It is possible to wait for elements pragmatically. If a test uses element which is not on a page yet, CodeceptJS will wait for few extra seconds before failing. This feature is based on <a href="http://www.seleniumhq.org/docs/04_webdriver_advanced.jsp#implicit-waits" target="_blank" rel="noopener noreferrer">Implicit Wait<span> <span class="sr-only">(opens new window)</span></span></a> of Selenium. CodeceptJS enables implicit wait only when searching for a specific element and disables in all other cases. Thus, the performance of a test is not affected.</p> <p>SmartWait can be enabled by setting wait option in WebDriver config. Add <code>smartWait: 5000</code> to wait for additional 5s.</p> <div class="language-js extra-class"><pre class="language-js">// inside codecept.conf.js
exports.config = {
  helpers: {
    WebDriver: {
      // WebDriver config goes here
      // smart wait for 5 seconds
      smartWait: 5000
    }
  }
}
</pre></div>
<p>SmartWait works with a CSS/XPath locators in <code>click</code>, <code>seeElement</code> and other methods. See where it is enabled and where is not:</p> <div class="language-js extra-class"><pre class="language-js">I.click('Login'); // DISABLED, not a locator
I.fillField('user', 'davert'); // DISABLED, not a specific locator
I.fillField({name: 'password'}, '123456'); // ENABLED, strict locator
I.click('#login'); // ENABLED, locator is CSS ID
I.see('Hello, Davert'); // DISABLED, Not a locator
I.seeElement('#userbar'); // ENABLED
I.dontSeeElement('#login'); // DISABLED, can't wait for element to hide
I.seeNumberOfElements('button.link', 5); // DISABLED, can wait only for one element

</pre></div>
<p>SmartWait doesn't check element for visibility, so tests may fail even element is on a page.</p> <p>Usage example:</p> <div class="language-js extra-class"><pre class="language-js">// we use smartWait: 5000 instead of
// I.waitForElement('#click-me', 5);
// to wait for element on page
I.click('#click-me');
</pre></div>
<p>If it's hard to define what to wait, it is recommended to use <a href="https://codecept.io/basics/#retries">retries</a> to rerun flaky steps.</p> <h2 id="configuring-ci"> Configuring CI</h2> <p>To develop tests it's fine to use local Selenium Server and window mode. Setting up WebDriver on remote CI (Continous Integration) server is different. If there is no desktop and no window mode on CI.</p> <p>There are following options available:</p> <ul>
<li>Use headless Chrome or Firefox.</li> <li>Use <a href="https://codecept.io/plugins/selenoid">Selenoid</a> to run browsers inside Docker containers.</li> <li>Use paid <a href="https://codecept.io/helpers/WebDriver#cloud-providers">cloud services (SauceLabs, BrowserStack, TestingBot)</a>.</li>
</ul> <h2 id="video-recording"> Video Recording</h2> <p>When <a href="https://codecept.io/plugins#selenoid">Selenoid Plugin</a> is enabled video can be automatically recorded for each test.</p> <h2 id="auto-login"> Auto Login</h2> <p>To share the same user session across different tests CodeceptJS provides <a href="https://codecept.io/plugins#autologin">autoLogin plugin</a>. It simplifies login management and reduces time consuming login operations. Instead of filling in login form before each test it saves the cookies of a valid user session and reuses it for next tests. If a session expires or doesn't exist, logs in a user again.</p> <p>This plugin requires some configuration but is very simple in use:</p> <div class="language-js extra-class"><pre class="language-js">Scenario('do something with logged in user', ({ I, login) }) =&gt; {
  login('user');
  I.see('Dashboard','h1');
});
</pre></div>
<p>With <code>autoLogin</code> plugin you can save cookies into a file and reuse same session on different runs.</p> <blockquote><p><a href="https://codecept.io/plugins#autologin">▶ How to set up autoLogin plugin</a></p></blockquote> <h2 id="multiple-windows"> Multiple Windows</h2> <p>CodeceptJS allows to use several browser windows inside a test. Sometimes we are testing the functionality of websites that we cannot control, such as a closed-source managed package, and there are popups that either remain open for configuring data on the screen, or close as a result of clicking a window. We can use these functions in order to gain more control over which page is being tested with Codecept at any given time. For example:</p> <div class="language-js extra-class"><pre class="language-js">const assert = require('assert');

Scenario('should open main page of configured site, open a popup, switch to main page, then switch to popup, close popup, and go back to main page', async ({ I }) =&gt; {
    I.amOnPage('/');
    const handleBeforePopup = await I.grabCurrentWindowHandle();
    const urlBeforePopup = await I.grabCurrentUrl();
    const allHandlesBeforePopup = await I.grabAllWindowHandles();
    assert.equal(allHandlesBeforePopup.length, 1, 'Single Window');

    await I.executeScript(() =&gt; {
        window.open('https://www.w3schools.com/', 'new window', 'toolbar=yes,scrollbars=yes,resizable=yes,width=400,height=400');
    });

    const allHandlesAfterPopup = await I.grabAllWindowHandles();
    assert.equal(allHandlesAfterPopup.length, 2, 'Two Windows');

    await I.switchToWindow(allHandlesAfterPopup[1]);
    const urlAfterPopup = await I.grabCurrentUrl();
    assert.equal(urlAfterPopup, 'https://www.w3schools.com/', 'Expected URL: Popup');

    assert.equal(handleBeforePopup, allHandlesAfterPopup[0], 'Expected Window: Main Window');
    await I.switchToWindow(handleBeforePopup);
    const currentURL = await I.grabCurrentUrl();
    assert.equal(currentURL, urlBeforePopup, 'Expected URL: Main URL');

    await I.switchToWindow(allHandlesAfterPopup[1]);
    const urlAfterSwitchBack = await I.grabCurrentUrl();
    assert.equal(urlAfterSwitchBack, 'https://www.w3schools.com/', 'Expected URL: Popup');
    await I.closeCurrentTab();

    const allHandlesAfterPopupClosed = await I.grabAllWindowHandles();
    assert.equal(allHandlesAfterPopupClosed.length, 1, 'Single Window');
    const currentWindowHandle = await I.grabCurrentWindowHandle();
    assert.equal(currentWindowHandle, allHandlesAfterPopup[0], 'Expected Window: Main Window');

});
</pre></div>
<h2 id="mocking-requests"> Mocking Requests</h2> <p>When testing web application you can disable some of external requests calls by enabling HTTP mocking. This is useful when you want to isolate application testing from a backend. For instance, if you don't want to save data to database, and you know the request which performs save, you can mock the request, so application will treat this as valid response, but no data will be actually saved.</p> <blockquote><p><strong>WebDriver has limited ability to mock requests</strong>, so you can only mock only requests performed after page is loaded. This means that you can't block Google Analytics, or CDN calls, but you can mock API requests performed on user action.</p></blockquote> <p>To mock requests enable additional helper <a href="https://codecept.io/helpers/MockRequest">MockRequest</a> (which is based on Polly.js).</p> <div class="language-js extra-class"><pre class="language-js">helpers: {
   WebDriver: {
     // regular WebDriver config here
   },
   MockRequest: {}
}
</pre></div>
<p>The function <code>mockRequest</code> will be added to <code>I</code> object. You can use it to explicitly define which requests to block and which response they should return instead:</p> <div class="language-js extra-class"><pre class="language-js">// block all Google Analytics calls
I.mockRequest('/google-analytics/*path', 200);
// return an empty successful response
I.mockRequest('GET', '/api/users', 200);
// block post requests to /api/users and return predefined object
I.mockRequest('POST', '/api/users', { user: 'davert' });
// return error request with body
I.mockRequest('GET', '/api/users/1', 404, { error: 'User not found' });
</pre></div>
<blockquote><p>In WebDriver mocking is disabled every time a new page is loaded. Hence, <code>startMocking</code> method should be called and the mocks should be updated, after navigating to a new page. This is a limitation of WebDriver. Consider using Puppeteer with MockRequest instead.</p></blockquote> <div class="language-js extra-class"><pre class="language-js">I.amOnPage('/xyz');
I.mockRequest({ ... })
I.click('Go to Next Page');
// new page is loaded, mocking is disabled now. We need to set it up again
// in WebDriver as we can't detect that the page was reloaded, so no mocking :(
</pre></div>
<blockquote><p>See <a href="https://codecept.io/helpers/MockRequest#mockrequest"><code>mockRequest</code> API</a></p></blockquote> <p>To see <code>mockRequest</code> method in intellisense auto completion don't forget to run <code>codeceptjs def</code> command:</p> <div class="language- extra-class"><pre class="language-text">npx codeceptjs def
</pre></div>
<p>Mocking rules will be kept while a test is running. To stop mocking use <code>I.stopMocking()</code> command</p> <h2 id="accessing-webdriverio-api"> Accessing webdriverio API</h2> <p>To get <a href="https://webdriver.io/docs/api" target="_blank" rel="noopener noreferrer">webdriverio browser API<span> <span class="sr-only">(opens new window)</span></span></a> inside a test use <a href="https://codecept.io/helpers/WebDriver/#usewebdriverto"><code>I.useWebDriverTo</code></a> method with a callback. To keep test readable provide a description of a callback inside the first parameter.</p> <div class="language-js extra-class"><pre class="language-js">I.useWebDriverTo('do something with native webdriverio api', async ({ browser }) =&gt; {
  // use browser object here
});
</pre></div>
<blockquote><p>webdriverio commands are asynchronous so a callback function must be async.</p></blockquote> <p>WebDriver helper can be obtained in this function as well. Use this to get full access to webdriverio elements inside the test.</p> <div class="language-js extra-class"><pre class="language-js">I.useWebDriverTo('click all Save buttons', async (WebDriver) =&gt; {
  const els = await WebDriver._locateClickable('Save');
  for (let el of els) {
    await el.click();
  }
});
</pre></div>
<h2 id="extending-webdriver"> Extending WebDriver</h2> <p>CodeceptJS doesn't aim to embrace all possible functionality of WebDriver. At some points you may find that some actions do not exist, however it is easy to add one. You will need to use WebDriver API from <a href="https://webdriver.io" target="_blank" rel="noopener noreferrer">webdriver.io<span> <span class="sr-only">(opens new window)</span></span></a> library.</p> <p>To create new actions which will be added into <code>I.</code> object you need to create a new helper. This can be done with <code>codeceptjs gh</code> command.</p> <div class="language- extra-class"><pre class="language-text">npx codeceptjs gh
</pre></div>
<p>Name a new helper "Web". Now each method of a created class can be added to I object. Be sure to enable this helper in config:</p> <div class="language-js extra-class"><pre class="language-js">exports.config = {
  helpers: {
    WebDriver: { /* WebDriver config goes here */ },
    WebHelper: {
      // load custom helper
      require: './web_helper.js'
    }
  }
}
</pre></div>
<blockquote><p>ℹ See <a href="https://codecept.io/helpers">Custom Helper</a> guide to see more examples.</p></blockquote> <p>While implementing custom actions using WebDriver API please note that, there is two versions of protocol: WebDriver and JSON Wire. Depending on a browser version one of those protocols can be used. We can't know for sure which protocol is going to used, so we will need to implement an action using both APIs.</p> <div class="language-js extra-class"><pre class="language-js">const Helper = codeceptjs.helper;

class Web extends Helper {

  // method to drag an item to coordinates
  async dragToPoint(el, x, y) {
    // access browser object from WebDriver
    const browser = this.helpers.WebDriver.browser;
    await this.helpers.WebDriver.moveCursorTo(el);

    if (browser.isW3C) {
      // we use WebDriver protocol
      return browser.performActions([
        {"type": "pointerDown", "button": 0},
        {"type": "pointerMove", "origin": "pointer", "duration": 1000, x, y },
        {"type": "pointerUp", "button": 0}
      ]);
    }

    // we use JSON Wire protocol
    await browser.buttonDown(0);
    await browser.moveToElement(null, x, y);
    await browser.buttonUp(0);
  }

  // method which restarts browser
  async restartBrowser() {
    const browser = this.helpers.WebDriver.browser;
    await browser.reloadSession();
    await browser.maximizeWindow();
  }

  // method which goes to previous page
  async backToPreviousPage() {
    const browser = this.helpers.WebDriver.browser;
    await browser.back();
  }
}
</pre></div>
<p>When a helper is created, regenerate your step definitions, so you could see those actions when using <a href="https://codecept.io/basics#intellisense">intellisense</a>:</p> <div class="language- extra-class"><pre class="language-text">npx codeceptjs def
</pre></div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2015 DavertMik &lt;davert@codegyre.com&gt; (http://codegyre.com)<br>Licensed under the MIT License.<br>
    <a href="https://codecept.io/webdriver/" class="_attribution-link">https://codecept.io/webdriver/</a>
  </p>
</div>
