<h1 id="execute">execute</h1>
<div class="api-docs-breadcrumbs">
<a href="../../../../../../index.html">kotlin-stdlib</a> / <a href="../index.html">kotlin.native.concurrent</a> / <a href="index.html">Worker</a> / <a href="execute.html">execute</a>
</div> <div class="node-page-main" data-kotlin-version="1.3" data-platform="Native">
<div data-kotlin-version="1.3" data-platform="Native">
<b>Platform and version requirements:</b> Native (1.3) </div>
<div data-kotlin-version="1.3" data-platform="Native">
 <pre class="signature" data-language="kotlin">fun &lt;T1, T2&gt; execute(
    mode: TransferMode, 
    producer: () -&gt; T1, 
    job: (T1) -&gt; T2
): Future&lt;T2&gt;</pre> </div>
<div data-kotlin-version="1.3" data-platform="Native"> <p>Plan job for further execution in the worker. Execute is a two-phase operation:</p> <ol>
<li>
<a href="execute.html#kotlin.native.concurrent.Worker$execute(kotlin.native.concurrent.TransferMode,%20kotlin.Function0((kotlin.native.concurrent.Worker.execute.T1)),%20kotlin.Function1((kotlin.native.concurrent.Worker.execute.T1,%20kotlin.native.concurrent.Worker.execute.T2)))/producer">producer</a> function is executed on the caller's thread.</li> <li>the result of <a href="execute.html#kotlin.native.concurrent.Worker$execute(kotlin.native.concurrent.TransferMode,%20kotlin.Function0((kotlin.native.concurrent.Worker.execute.T1)),%20kotlin.Function1((kotlin.native.concurrent.Worker.execute.T1,%20kotlin.native.concurrent.Worker.execute.T2)))/producer">producer</a> and <a href="execute.html#kotlin.native.concurrent.Worker$execute(kotlin.native.concurrent.TransferMode,%20kotlin.Function0((kotlin.native.concurrent.Worker.execute.T1)),%20kotlin.Function1((kotlin.native.concurrent.Worker.execute.T1,%20kotlin.native.concurrent.Worker.execute.T2)))/job">job</a> function pointer is being added to jobs queue of the selected worker. Note that <a href="execute.html#kotlin.native.concurrent.Worker$execute(kotlin.native.concurrent.TransferMode,%20kotlin.Function0((kotlin.native.concurrent.Worker.execute.T1)),%20kotlin.Function1((kotlin.native.concurrent.Worker.execute.T1,%20kotlin.native.concurrent.Worker.execute.T2)))/job">job</a> must not capture any state itself.</li> </ol> <p>Parameter <a href="execute.html#kotlin.native.concurrent.Worker$execute(kotlin.native.concurrent.TransferMode,%20kotlin.Function0((kotlin.native.concurrent.Worker.execute.T1)),%20kotlin.Function1((kotlin.native.concurrent.Worker.execute.T1,%20kotlin.native.concurrent.Worker.execute.T2)))/mode">mode</a> has no effect.</p> <p>Behavior is more complex in case of legacy memory manager:</p> <ul>
<li>first <a href="execute.html#kotlin.native.concurrent.Worker$execute(kotlin.native.concurrent.TransferMode,%20kotlin.Function0((kotlin.native.concurrent.Worker.execute.T1)),%20kotlin.Function1((kotlin.native.concurrent.Worker.execute.T1,%20kotlin.native.concurrent.Worker.execute.T2)))/producer">producer</a> function is executed, and resulting object and whatever it refers to is analyzed for being an isolated object subgraph, if in checked mode.</li> <li>Afterwards, this disconnected object graph and <a href="execute.html#kotlin.native.concurrent.Worker$execute(kotlin.native.concurrent.TransferMode,%20kotlin.Function0((kotlin.native.concurrent.Worker.execute.T1)),%20kotlin.Function1((kotlin.native.concurrent.Worker.execute.T1,%20kotlin.native.concurrent.Worker.execute.T2)))/job">job</a> function pointer is being added to jobs queue of the selected worker. Note that <a href="execute.html#kotlin.native.concurrent.Worker$execute(kotlin.native.concurrent.TransferMode,%20kotlin.Function0((kotlin.native.concurrent.Worker.execute.T1)),%20kotlin.Function1((kotlin.native.concurrent.Worker.execute.T1,%20kotlin.native.concurrent.Worker.execute.T2)))/job">job</a> must not capture any state itself, so that whole state is explicitly stored in object produced by <a href="execute.html#kotlin.native.concurrent.Worker$execute(kotlin.native.concurrent.TransferMode,%20kotlin.Function0((kotlin.native.concurrent.Worker.execute.T1)),%20kotlin.Function1((kotlin.native.concurrent.Worker.execute.T1,%20kotlin.native.concurrent.Worker.execute.T2)))/producer">producer</a>. Scheduled job is being executed by the worker, and result of such a execution is being disconnected from worker's object graph. Whoever will consume the future, can use result of worker's computations. Note, that some technically disjoint subgraphs may lead to <code>kotlin.IllegalStateException</code> so <code>kotlin.native.runtime.GC.collect()</code> could be called in the end of <code>producer</code> and <code>job</code> if garbage cyclic structures or other uncollected objects refer to the value being transferred.</li> </ul> <p><strong>Return</strong> the future with the computation result of <a href="execute.html#kotlin.native.concurrent.Worker$execute(kotlin.native.concurrent.TransferMode,%20kotlin.Function0((kotlin.native.concurrent.Worker.execute.T1)),%20kotlin.Function1((kotlin.native.concurrent.Worker.execute.T1,%20kotlin.native.concurrent.Worker.execute.T2)))/job">job</a>.</p> </div>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2023 JetBrains s.r.o. and Kotlin Programming Language contributors<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.native.concurrent/-worker/execute.html" class="_attribution-link">https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.native.concurrent/-worker/execute.html</a>
  </p>
</div>
