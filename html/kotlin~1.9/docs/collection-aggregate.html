<h1 data-toc="collection-aggregate" id="collection-aggregate.md">Aggregate operations</h1>
<p id="e8310502">Kotlin collections contain functions for commonly used <em id="ab5888d7" class="">aggregate operations</em> – operations that return a single value based on the collection content. Most of them are well known and work the same way as they do in other languages:</p>
<ul class="list _bullet" id="f0bd3e07">
<li class="list__item" id="82ea7683"><p><a href="../api/latest/jvm/stdlib/kotlin.collections/min-or-null.html" id="df9f2cb8" data-external="true" rel="noopener noreferrer"><code class="code ">minOrNull()</code></a> and <a href="../api/latest/jvm/stdlib/kotlin.collections/max-or-null.html" id="3ac8cf89" data-external="true" rel="noopener noreferrer"><code class="code ">maxOrNull()</code></a> return the smallest and the largest element respectively. On empty collections, they return <code class="code ">null</code>.</p></li>
<li class="list__item" id="2aefdac4"><p><a href="../api/latest/jvm/stdlib/kotlin.collections/average.html" id="73bfc8d8" data-external="true" rel="noopener noreferrer"><code class="code ">average()</code></a> returns the average value of elements in the collection of numbers.</p></li>
<li class="list__item" id="1ceaad15"><p><a href="../api/latest/jvm/stdlib/kotlin.collections/sum.html" id="73952363" data-external="true" rel="noopener noreferrer"><code class="code ">sum()</code></a> returns the sum of elements in the collection of numbers.</p></li>
<li class="list__item" id="d7ef5d67"><p><a href="../api/latest/jvm/stdlib/kotlin.collections/count.html" id="dc2711f8" data-external="true" rel="noopener noreferrer"><code class="code ">count()</code></a> returns the number of elements in a collection.</p></li>
</ul>
<pre class="code" data-language="kotlin">
fun main() {
    val numbers = listOf(6, 42, 10, 4)

    println("Count: ${numbers.count()}")
    println("Max: ${numbers.maxOrNull()}")
    println("Min: ${numbers.minOrNull()}")
    println("Average: ${numbers.average()}")
    println("Sum: ${numbers.sum()}")
}
</pre>
<p id="d15bf912">There are also functions for retrieving the smallest and the largest elements by certain selector function or custom <a href="../api/latest/jvm/stdlib/kotlin/-comparator/index.html" id="f8f9c923" data-external="true" rel="noopener noreferrer"><code class="code ">Comparator</code></a>:</p>
<ul class="list _bullet" id="a8644f88">
<li class="list__item" id="6503d785"><p><a href="../api/latest/jvm/stdlib/kotlin.collections/max-by-or-null.html" id="87e6a364" data-external="true" rel="noopener noreferrer"><code class="code ">maxByOrNull()</code></a> and <a href="../api/latest/jvm/stdlib/kotlin.collections/min-by-or-null.html" id="16b23dcb" data-external="true" rel="noopener noreferrer"><code class="code ">minByOrNull()</code></a> take a selector function and return the element for which it returns the largest or the smallest value.</p></li>
<li class="list__item" id="b48a1602"><p><a href="../api/latest/jvm/stdlib/kotlin.collections/max-with-or-null.html" id="46bd5901" data-external="true" rel="noopener noreferrer"><code class="code ">maxWithOrNull()</code></a> and <a href="../api/latest/jvm/stdlib/kotlin.collections/min-with-or-null.html" id="152270ba" data-external="true" rel="noopener noreferrer"><code class="code ">minWithOrNull()</code></a> take a <code class="code ">Comparator</code> object and return the largest or smallest element according to that <code class="code ">Comparator</code>.</p></li>
<li class="list__item" id="18642dc4"><p><a href="../api/latest/jvm/stdlib/kotlin.collections/max-of-or-null.html" id="aae42272" data-external="true" rel="noopener noreferrer"><code class="code ">maxOfOrNull()</code></a> and <a href="../api/latest/jvm/stdlib/kotlin.collections/min-of-or-null.html" id="7deaaab3" data-external="true" rel="noopener noreferrer"><code class="code ">minOfOrNull()</code></a> take a selector function and return the largest or the smallest return value of the selector itself.</p></li>
<li class="list__item" id="fa4bccfc"><p><a href="../api/latest/jvm/stdlib/kotlin.collections/max-of-with-or-null.html" id="5a2867d9" data-external="true" rel="noopener noreferrer"><code class="code ">maxOfWithOrNull()</code></a> and <a href="../api/latest/jvm/stdlib/kotlin.collections/min-of-with-or-null.html" id="26d5dae2" data-external="true" rel="noopener noreferrer"><code class="code ">minOfWithOrNull()</code></a> take a <code class="code ">Comparator</code> object and return the largest or smallest selector return value according to that <code class="code ">Comparator</code>.</p></li>
</ul>
<p id="88d2fae5">These functions return <code class="code ">null</code> on empty collections. There are also alternatives – <a href="../api/latest/jvm/stdlib/kotlin.collections/max-of.html" id="2ba8608c" data-external="true" rel="noopener noreferrer"><code class="code ">maxOf</code></a>, <a href="../api/latest/jvm/stdlib/kotlin.collections/min-of.html" id="3630721c" data-external="true" rel="noopener noreferrer"><code class="code ">minOf</code></a>, <a href="../api/latest/jvm/stdlib/kotlin.collections/max-of-with.html" id="9fdc7f8e" data-external="true" rel="noopener noreferrer"><code class="code ">maxOfWith</code></a>, and <a href="../api/latest/jvm/stdlib/kotlin.collections/min-of-with.html" id="6db83838" data-external="true" rel="noopener noreferrer"><code class="code ">minOfWith</code></a> – which do the same as their counterparts but throw a <code class="code ">NoSuchElementException</code> on empty collections.</p>
<pre class="code" data-language="kotlin">
fun main() {
//sampleStart
    val numbers = listOf(5, 42, 10, 4)
    val min3Remainder = numbers.minByOrNull { it % 3 }
    println(min3Remainder)

    val strings = listOf("one", "two", "three", "four")
    val longestString = strings.maxWithOrNull(compareBy { it.length })
    println(longestString)
//sampleEnd
}
</pre>
<p id="1d945a85">Besides regular <code class="code ">sum()</code>, there is an advanced summation function <a href="../api/latest/jvm/stdlib/kotlin.collections/sum-of.html" id="1053b4c1" data-external="true" rel="noopener noreferrer"><code class="code ">sumOf()</code></a> that takes a selector function and returns the sum of its application to all collection elements. Selector can return different numeric types: <code class="code ">Int</code>, <code class="code ">Long</code>, <code class="code ">Double</code>, <code class="code ">UInt</code>, and <code class="code ">ULong</code> (also <code class="code ">BigInteger</code> and <code class="code ">BigDecimal</code> on the JVM).</p>
<pre class="code" data-language="kotlin">
fun main() {
//sampleStart
    val numbers = listOf(5, 42, 10, 4)
    println(numbers.sumOf { it * 2 })
    println(numbers.sumOf { it.toDouble() / 2 })
//sampleEnd
}
</pre>
<section class="chapter"><h2 id="fold-and-reduce" data-toc="fold-and-reduce">Fold and reduce</h2>
<p id="47fc05e7">For more specific cases, there are the functions <a href="../api/latest/jvm/stdlib/kotlin.collections/reduce.html" id="d63d28d1" data-external="true" rel="noopener noreferrer"><code class="code ">reduce()</code></a> and <a href="../api/latest/jvm/stdlib/kotlin.collections/fold.html" id="2abad3b9" data-external="true" rel="noopener noreferrer"><code class="code ">fold()</code></a> that apply the provided operation to the collection elements sequentially and return the accumulated result. The operation takes two arguments: the previously accumulated value and the collection element.</p>
<p id="f5b7c094">The difference between the two functions is that <code class="code ">fold()</code> takes an initial value and uses it as the accumulated value on the first step, whereas the first step of <code class="code ">reduce()</code> uses the first and the second elements as operation arguments on the first step.</p>
<pre class="code" data-language="kotlin">fun main() {
//sampleStart
    val numbers = listOf(5, 2, 10, 4)

    val simpleSum = numbers.reduce { sum, element -&gt; sum + element }
    println(simpleSum)
    val sumDoubled = numbers.fold(0) { sum, element -&gt; sum + element * 2 }
    println(sumDoubled)

    //incorrect: the first element isn't doubled in the result
    //val sumDoubledReduce = numbers.reduce { sum, element -&gt; sum + element * 2 } 
    //println(sumDoubledReduce)
//sampleEnd
}
</pre>
<p id="4de84cce">The example above shows the difference: <code class="code ">fold()</code> is used for calculating the sum of doubled elements. If you pass the same function to <code class="code ">reduce()</code>, it will return another result because it uses the list's first and second elements as arguments on the first step, so the first element won't be doubled.</p>
<p id="9ec0819">To apply a function to elements in the reverse order, use functions <a href="../api/latest/jvm/stdlib/kotlin.collections/reduce-right.html" id="f5b9b3d" data-external="true" rel="noopener noreferrer"><code class="code ">reduceRight()</code></a> and <a href="../api/latest/jvm/stdlib/kotlin.collections/fold-right.html" id="a5a412d7" data-external="true" rel="noopener noreferrer"><code class="code ">foldRight()</code></a>. They work in a way similar to <code class="code ">fold()</code> and <code class="code ">reduce()</code> but start from the last element and then continue to previous. Note that when folding or reducing right, the operation arguments change their order: first goes the element, and then the accumulated value.</p>
<pre class="code" data-language="kotlin">
fun main() {
//sampleStart
    val numbers = listOf(5, 2, 10, 4)
    val sumDoubledRight = numbers.foldRight(0) { element, sum -&gt; sum + element * 2 }
    println(sumDoubledRight)
//sampleEnd
}
</pre>
<p id="67ba8b84">You can also apply operations that take element indices as parameters. For this purpose, use functions <a href="../api/latest/jvm/stdlib/kotlin.collections/reduce-indexed.html" id="bc7eb4b6" data-external="true" rel="noopener noreferrer"><code class="code ">reduceIndexed()</code></a> and <a href="../api/latest/jvm/stdlib/kotlin.collections/fold-indexed.html" id="fe6fe9a0" data-external="true" rel="noopener noreferrer"><code class="code ">foldIndexed()</code></a> passing element index as the first argument of the operation.</p>
<p id="741ef9f8">Finally, there are functions that apply such operations to collection elements from right to left - <a href="../api/latest/jvm/stdlib/kotlin.collections/reduce-right-indexed.html" id="1fe02e07" data-external="true" rel="noopener noreferrer"><code class="code ">reduceRightIndexed()</code></a> and <a href="../api/latest/jvm/stdlib/kotlin.collections/fold-right-indexed.html" id="a89f6d06" data-external="true" rel="noopener noreferrer"><code class="code ">foldRightIndexed()</code></a>.</p>
<pre class="code" data-language="kotlin">
fun main() {
//sampleStart
    val numbers = listOf(5, 2, 10, 4)
    val sumEven = numbers.foldIndexed(0) { idx, sum, element -&gt; if (idx % 2 == 0) sum + element else sum }
    println(sumEven)

    val sumEvenRight = numbers.foldRightIndexed(0) { idx, element, sum -&gt; if (idx % 2 == 0) sum + element else sum }
    println(sumEvenRight)
//sampleEnd
}
</pre>
<p id="1307738c">All reduce operations throw an exception on empty collections. To receive <code class="code ">null</code> instead, use their <code class="code ">*OrNull()</code> counterparts:</p>
<ul class="list _bullet" id="3adaae39">
<li class="list__item" id="12cfc958"><p><a href="../api/latest/jvm/stdlib/kotlin.collections/reduce-or-null.html" id="4415af6a" data-external="true" rel="noopener noreferrer"><code class="code ">reduceOrNull()</code></a></p></li>
<li class="list__item" id="dc9db712"><p><a href="../api/latest/jvm/stdlib/kotlin.collections/reduce-right-or-null.html" id="3f910c5d" data-external="true" rel="noopener noreferrer"><code class="code ">reduceRightOrNull()</code></a></p></li>
<li class="list__item" id="6f7e6cac"><p><a href="../api/latest/jvm/stdlib/kotlin.collections/reduce-indexed-or-null.html" id="552c647" data-external="true" rel="noopener noreferrer"><code class="code ">reduceIndexedOrNull()</code></a></p></li>
<li class="list__item" id="485da82f"><p><a href="../api/latest/jvm/stdlib/kotlin.collections/reduce-right-indexed-or-null.html" id="27ec12" data-external="true" rel="noopener noreferrer"><code class="code ">reduceRightIndexedOrNull()</code></a></p></li>
</ul>
<p id="ac10591a">For cases where you want to save intermediate accumulator values, there are functions <a href="../api/latest/jvm/stdlib/kotlin.collections/running-fold.html" id="b3c3ca04" data-external="true" rel="noopener noreferrer"><code class="code ">runningFold()</code></a> (or its synonym <a href="../api/latest/jvm/stdlib/kotlin.collections/scan.html" id="491cd8b8" data-external="true" rel="noopener noreferrer"><code class="code ">scan()</code></a>) and <a href="../api/latest/jvm/stdlib/kotlin.collections/running-reduce.html" id="81892207" data-external="true" rel="noopener noreferrer"><code class="code ">runningReduce()</code></a>.</p>
<pre class="code" data-language="kotlin">
fun main() {
//sampleStart
    val numbers = listOf(0, 1, 2, 3, 4, 5)
    val runningReduceSum = numbers.runningReduce { sum, item -&gt; sum + item }
    val runningFoldSum = numbers.runningFold(10) { sum, item -&gt; sum + item }
//sampleEnd
    val transform = { index: Int, element: Int -&gt; "N = ${index + 1}: $element" }
    println(runningReduceSum.mapIndexed(transform).joinToString("\n", "Sum of first N elements with runningReduce:\n"))
    println(runningFoldSum.mapIndexed(transform).joinToString("\n", "Sum of first N elements with runningFold:\n"))
}
</pre>
<p id="b64ac8f">If you need an index in the operation parameter, use <a href="../api/latest/jvm/stdlib/kotlin.collections/running-fold-indexed.html" id="26866427" data-external="true" rel="noopener noreferrer"><code class="code ">runningFoldIndexed()</code></a> or <a href="../api/latest/jvm/stdlib/kotlin.collections/running-reduce-indexed.html" id="ac1133ac" data-external="true" rel="noopener noreferrer"><code class="code ">runningReduceIndexed()</code></a>.</p></section><div class="last-modified"> Last modified: 07 December 2021</div>

<div class="navigation-links _bottom"> <a class="navigation-links__prev" href="collection-ordering.html">Ordering</a> <a class="navigation-links__next" href="collection-write.html">Collection write operations</a> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2023 JetBrains s.r.o. and Kotlin Programming Language contributors<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://kotlinlang.org/docs/collection-aggregate.html" class="_attribution-link">https://kotlinlang.org/docs/collection-aggregate.html</a>
  </p>
</div>
