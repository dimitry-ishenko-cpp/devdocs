  <h1 class="section">Chains of Implicit Rules</h1>   <p>Sometimes a file can be made by a sequence of implicit rules. For example, a file <samp><var>n</var>.o</samp> could be made from <samp><var>n</var>.y</samp> by running first Yacc and then <code>cc</code>. Such a sequence is called a <em>chain</em>. </p> <p>If the file <samp><var>n</var>.c</samp> exists, or is mentioned in the makefile, no special searching is required: <code>make</code> finds that the object file can be made by C compilation from <samp><var>n</var>.c</samp>; later on, when considering how to make <samp><var>n</var>.c</samp>, the rule for running Yacc is used. Ultimately both <samp><var>n</var>.c</samp> and <samp><var>n</var>.o</samp> are updated. </p>   <p>However, even if <samp><var>n</var>.c</samp> does not exist and is not mentioned, <code>make</code> knows how to envision it as the missing link between <samp><var>n</var>.o</samp> and <samp><var>n</var>.y</samp>! In this case, <samp><var>n</var>.c</samp> is called an <em>intermediate file</em>. Once <code>make</code> has decided to use the intermediate file, it is entered in the data base as if it had been mentioned in the makefile, along with the implicit rule that says how to create it. </p> <p>Intermediate files are remade using their rules just like all other files. But intermediate files are treated differently in two ways. </p> <p>The first difference is what happens if the intermediate file does not exist. If an ordinary file <var>b</var> does not exist, and <code>make</code> considers a target that depends on <var>b</var>, it invariably creates <var>b</var> and then updates the target from <var>b</var>. But if <var>b</var> is an intermediate file, then <code>make</code> can leave well enough alone: it won’t create <var>b</var> unless one of its prerequisites is out of date. This means the target depending on <var>b</var> won’t be rebuilt either, unless there is some other reason to update that target: for example the target doesn’t exist or a different prerequisite is newer than the target. </p> <p>The second difference is that if <code>make</code> <em>does</em> create <var>b</var> in order to update something else, it deletes <var>b</var> later on after it is no longer needed. Therefore, an intermediate file which did not exist before <code>make</code> also does not exist after <code>make</code>. <code>make</code> reports the deletion to you by printing a ‘<samp>rm</samp>’ command showing which file it is deleting. </p> <p>You can explicitly mark a file as intermediate by listing it as a prerequisite of the special target <code>.INTERMEDIATE</code>. This takes effect even if the file is mentioned explicitly in some other way. </p> <p>A file cannot be intermediate if it is mentioned in the makefile as a target or prerequisite, so one way to avoid the deletion of intermediate files is by adding it as a prerequisite to some target. However, doing so can cause make to do extra work when searching pattern rules (see <a href="implicit-rule-search.html">Implicit Rule Search Algorithm</a>). </p> <p>As an alternative, listing a file as a prerequisite of the special target <code>.NOTINTERMEDIATE</code> forces it to not be considered intermediate (just as any other mention of the file will do). Also, listing the target pattern of a pattern rule as a prerequisite of <code>.NOTINTERMEDIATE</code> ensures that no targets generated using that pattern rule are considered intermediate. </p> <p>You can disable intermediate files completely in your makefile by providing <code>.NOTINTERMEDIATE</code> as a target with no prerequisites: in that case it applies to every file in the makefile. </p>    <p>If you do not want <code>make</code> to create a file merely because it does not already exist, but you also do not want <code>make</code> to automatically delete the file, you can mark it as a <em>secondary</em> file. To do this, list it as a prerequisite of the special target <code>.SECONDARY</code>. Marking a file as secondary also marks it as intermediate. </p> <p>A chain can involve more than two implicit rules. For example, it is possible to make a file <samp>foo</samp> from <samp>RCS/foo.y,v</samp> by running RCS, Yacc and <code>cc</code>. Then both <samp>foo.y</samp> and <samp>foo.c</samp> are intermediate files that are deleted at the end. </p> <p>No single implicit rule can appear more than once in a chain. This means that <code>make</code> will not even consider such a ridiculous thing as making <samp>foo</samp> from <samp>foo.o.o</samp> by running the linker twice. This constraint has the added benefit of preventing any infinite loop in the search for an implicit rule chain. </p> <p>There are some special implicit rules to optimize certain cases that would otherwise be handled by rule chains. For example, making <samp>foo</samp> from <samp>foo.c</samp> could be handled by compiling and linking with separate chained rules, using <samp>foo.o</samp> as an intermediate file. But what actually happens is that a special rule for this case does the compilation and linking with a single <code>cc</code> command. The optimized rule is used in preference to the step-by-step chain because it comes earlier in the ordering of rules. </p> <p>Finally, for performance reasons <code>make</code> will not consider non-terminal match-anything rules (i.e., ‘<samp>%:</samp>’) when searching for a rule to build a prerequisite of an implicit rule (see <a href="match_002danything-rules.html">Match-Anything Rules</a>). </p><div class="_attribution">
  <p class="_attribution-p">
    Copyright © 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022 Free Software Foundation, Inc. <br>Licensed under the GNU Free Documentation License.<br>
    <a href="https://www.gnu.org/software/make/manual/html_node/Chained-Rules.html" class="_attribution-link">https://www.gnu.org/software/make/manual/html_node/Chained-Rules.html</a>
  </p>
</div>
