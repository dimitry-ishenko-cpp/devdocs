   <h1 id="shareconfig">ShareConfig</h1> <p><code class="api-type-label interface">interface</code> <code class="api-status-label stable">stable</code></p>   <aio-toc class="embedded"></aio-toc> <div class="api-body">   <pre data-language="typescript">interface ShareConfig&lt;T&gt; {
  connector?: () =&gt; SubjectLike&lt;T&gt;
  resetOnError?: boolean | ((error: any) =&gt; ObservableInput&lt;any&gt;)
  resetOnComplete?: boolean | (() =&gt; ObservableInput&lt;any&gt;)
  resetOnRefCountZero?: boolean | (() =&gt; ObservableInput&lt;any&gt;)
}</pre>   <h2 id="properties">Properties</h2> <table> <thead> <tr>
<th>Property</th>
<th>Type</th>
<th>Description</th>
</tr> </thead> <tbody> <tr class="instance-property"> <td>
<code class="">connector</code>
</td> <td><code class="property-type-label">() =&gt; <a href="https://rxjs.dev/api/index/interface/SubjectLike" class="code-anchor">SubjectLike</a>&lt;T&gt;</code></td> <td> <p>The factory used to create the subject that will connect the source observable to multicast consumers.</p> </td> </tr> <tr class="instance-property"> <td>
<code class="">resetOnError</code>
</td> <td><code class="property-type-label">boolean | ((error: any) =&gt; <a href="https://rxjs.dev/api/index/type-alias/ObservableInput" class="code-anchor">ObservableInput</a>&lt;any&gt;)</code></td> <td> <p>If <code>true</code>, the resulting observable will reset internal state on error from source and return to a "cold" state. This allows the resulting observable to be "retried" in the event of an error. If <code>false</code>, when an error comes from the source it will push the error into the connecting subject, and the subject will remain the connecting subject, meaning the resulting observable will not go "cold" again, and subsequent retries or resubscriptions will resubscribe to that same subject. In all cases, RxJS subjects will emit the same error again, however <a href="https://rxjs.dev/api/index/class/ReplaySubject"><code>ReplaySubject</code></a> will also push its buffered values before pushing the error. It is also possible to pass a notifier factory returning an <code><a href="https://rxjs.dev/api/index/type-alias/ObservableInput" class="code-anchor">ObservableInput</a></code> instead which grants more fine-grained control over how and when the reset should happen. This allows behaviors like conditional or delayed resets.</p> </td> </tr> <tr class="instance-property"> <td>
<code class="">resetOnComplete</code>
</td> <td><code class="property-type-label">boolean | (() =&gt; <a href="https://rxjs.dev/api/index/type-alias/ObservableInput" class="code-anchor">ObservableInput</a>&lt;any&gt;)</code></td> <td> <p>If <code>true</code>, the resulting observable will reset internal state on completion from source and return to a "cold" state. This allows the resulting observable to be "repeated" after it is done. If <code>false</code>, when the source completes, it will push the completion through the connecting subject, and the subject will remain the connecting subject, meaning the resulting observable will not go "cold" again, and subsequent repeats or resubscriptions will resubscribe to that same subject. It is also possible to pass a notifier factory returning an <code><a href="https://rxjs.dev/api/index/type-alias/ObservableInput" class="code-anchor">ObservableInput</a></code> instead which grants more fine-grained control over how and when the reset should happen. This allows behaviors like conditional or delayed resets.</p> </td> </tr> <tr class="instance-property"> <td>
<code class="">resetOnRefCountZero</code>
</td> <td><code class="property-type-label">boolean | (() =&gt; <a href="https://rxjs.dev/api/index/type-alias/ObservableInput" class="code-anchor">ObservableInput</a>&lt;any&gt;)</code></td> <td> <p>If <code>true</code>, when the number of subscribers to the resulting observable reaches zero due to those subscribers unsubscribing, the internal state will be reset and the resulting observable will return to a "cold" state. This means that the next time the resulting observable is subscribed to, a new subject will be created and the source will be subscribed to again. If <code>false</code>, when the number of subscribers to the resulting observable reaches zero due to unsubscription, the subject will remain connected to the source, and new subscriptions to the result will be connected through that same subject. It is also possible to pass a notifier factory returning an <code><a href="https://rxjs.dev/api/index/type-alias/ObservableInput" class="code-anchor">ObservableInput</a></code> instead which grants more fine-grained control over how and when the reset should happen. This allows behaviors like conditional or delayed resets.</p> </td> </tr> </tbody> </table>  </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2015&ndash;2022 Google, Inc., Netflix, Inc., Microsoft Corp. and contributors.<br>Code licensed under an Apache-2.0 License. Documentation licensed under CC BY 4.0.<br>
    <a href="https://rxjs.dev/api/operators/ShareConfig" class="_attribution-link">https://rxjs.dev/api/operators/ShareConfig</a>
  </p>
</div>
