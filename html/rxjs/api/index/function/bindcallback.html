   <h1 id="bindcallback">bindCallback</h1> <p><code class="api-type-label function">function</code> <code class="api-status-label stable">stable</code></p>   <aio-toc class="embedded"></aio-toc> <div class="api-body"> 
<p>Converts a callback API to a function that returns an Observable.</p>  <h3 data-language="typescript"><code>bindCallback(callbackFunc: (...args: any[]) =&gt; void, resultSelector: (...args: any[]) =&gt; any, scheduler?: SchedulerLike): (...args: any[]) =&gt; Observable&lt;any&gt;</code></h3> <h4 class="no-anchor" id="parameters">Parameters</h4> <table> <tbody> <tr class="function-overload-parameter"> <td class="param-name">  <code>callbackFunc</code> </td> <td class="param-type"><code>(...args: any[]) =&gt; void</code></td> <td class="param-description"> </td> </tr> <tr class="function-overload-parameter"> <td class="param-name">  <code>resultSelector</code> </td> <td class="param-type"><code>(...args: any[]) =&gt; any</code></td> <td class="param-description"> </td> </tr> <tr class="function-overload-parameter"> <td class="param-name">  <code>scheduler</code> </td> <td class="param-type"><code><a href="../interface/schedulerlike.html" class="code-anchor">SchedulerLike</a></code></td> <td class="param-description"> <p>Optional. Default is <code>undefined</code>.</p> </td> </tr> </tbody> </table> <h4 class="no-anchor" id="returns">Returns</h4> <p><code>(...args: any[]) =&gt; <a href="../class/observable.html" class="code-anchor">Observable</a>&lt;any&gt;</code></p>  <h3 data-language="typescript"><code>bindCallback(callbackFunc: (...args: [...A, (...res: R) =&gt; void]) =&gt; void, schedulerLike?: SchedulerLike): (...arg: A) =&gt; Observable&lt;R extends [
] ? void : R extends [
    any
] ? R[0] : R&gt;</code></h3> <h4 class="no-anchor" id="parameters-1">Parameters</h4> <table> <tbody> <tr class="function-overload-parameter"> <td class="param-name">  <code>callbackFunc</code> </td> <td class="param-type"><code>(...args: [...A, (...res: R) =&gt; void]) =&gt; void</code></td> <td class="param-description"> </td> </tr> <tr class="function-overload-parameter"> <td class="param-name">  <code>schedulerLike</code> </td> <td class="param-type"><code><a href="../interface/schedulerlike.html" class="code-anchor">SchedulerLike</a></code></td> <td class="param-description"> <p>Optional. Default is <code>undefined</code>.</p> </td> </tr> </tbody> </table> <h4 class="no-anchor" id="returns-1">Returns</h4> <p><code>(...arg: A) =&gt; <a href="../class/observable.html" class="code-anchor">Observable</a>&lt;R extends [ ] ? void : R extends [     any ] ? R[0] : R&gt;</code></p>  <h2 id="description">Description</h2> <p><span class="informal">Give it a function <code>f</code> of type <code>f(x, callback)</code> and it will return a function <code>g</code> that when called as <code>g(x)</code> will output an Observable.</span></p> <p><code><a href="bindcallback.html" class="code-anchor">bindCallback</a></code> is not an operator because its input and output are not Observables. The input is a function <code>func</code> with some parameters. The last parameter must be a callback function that <code>func</code> calls when it is done.</p> <p>The output of <code><a href="bindcallback.html" class="code-anchor">bindCallback</a></code> is a function that takes the same parameters as <code>func</code>, except the last one (the callback). When the output function is called with arguments it will return an Observable. If function <code>func</code> calls its callback with one argument, the Observable will emit that value. If on the other hand the callback is called with multiple values the resulting Observable will emit an array with said values as arguments.</p> <p>It is <strong>very important</strong> to remember that input function <code>func</code> is not called when the output function is, but rather when the Observable returned by the output function is subscribed. This means if <code>func</code> makes an AJAX request, that request will be made every time someone subscribes to the resulting Observable, but not before.</p> <p>The last optional parameter - <code>scheduler</code> - can be used to control when the call to <code>func</code> happens after someone subscribes to Observable, as well as when results passed to callback will be emitted. By default, the subscription to an Observable calls <code>func</code> synchronously, but using <a href="../const/asyncscheduler.html"><code>asyncScheduler</code></a> as the last parameter will defer the call to <code>func</code>, just like wrapping the call in <code>setTimeout</code> with a timeout of <code>0</code> would. If you were to use the async Scheduler and call <code>subscribe</code> on the output Observable, all function calls that are currently executing will end before <code>func</code> is invoked.</p> <p>By default, results passed to the callback are emitted immediately after <code>func</code> invokes the callback. In particular, if the callback is called synchronously, then the subscription of the resulting Observable will call the <code>next</code> function synchronously as well. If you want to defer that call, you may use <a href="../const/asyncscheduler.html"><code>asyncScheduler</code></a> just as before. This means that by using <code>Scheduler.async</code> you can ensure that <code>func</code> always calls its callback asynchronously, thus avoiding terrifying Zalgo.</p> <p>Note that the Observable created by the output function will always emit a single value and then complete immediately. If <code>func</code> calls the callback multiple times, values from subsequent calls will not appear in the stream. If you need to listen for multiple calls, you probably want to use <a href="fromevent.html"><code>fromEvent</code></a> or <a href="fromeventpattern.html"><code>fromEventPattern</code></a> instead.</p> <p>If <code>func</code> depends on some context (<code>this</code> property) and is not already bound, the context of <code>func</code> will be the context that the output function has at call time. In particular, if <code>func</code> is called as a method of some object and if <code>func</code> is not already bound, in order to preserve the context it is recommended that the context of the output function is set to that object as well.</p> <p>If the input function calls its callback in the "node style" (i.e. first argument to callback is optional error parameter signaling whether the call failed or not), <a href="bindnodecallback.html"><code>bindNodeCallback</code></a> provides convenient error handling and probably is a better choice. <code><a href="bindcallback.html" class="code-anchor">bindCallback</a></code> will treat such functions the same as any other and error parameters (whether passed or not) will always be interpreted as regular callback argument.</p> <h2 id="examples">Examples</h2> <p>Convert jQuery's getJSON to an Observable API</p> <pre data-language="typescript">import { bindCallback } from 'rxjs';
import * as jQuery from 'jquery';

// Suppose we have jQuery.getJSON('/my/url', callback)
const getJSONAsObservable = bindCallback(jQuery.getJSON);
const result = getJSONAsObservable('/my/url');
result.subscribe(x =&gt; console.log(x), e =&gt; console.error(e));</pre> <p>Receive an array of arguments passed to a callback</p> <pre data-language="typescript">import { bindCallback } from 'rxjs';

const someFunction = (n, s, cb) =&gt; {
  cb(n, s, { someProperty: 'someValue' });
};

const boundSomeFunction = bindCallback(someFunction);
boundSomeFunction(5, 'some string').subscribe((values) =&gt; {
  console.log(values); // [5, 'some string', {someProperty: 'someValue'}]
});</pre> <p>Compare behaviour with and without <code><a href="../const/asyncscheduler.html" class="code-anchor">asyncScheduler</a></code></p> <pre data-language="typescript">import { bindCallback, asyncScheduler } from 'rxjs';

function iCallMyCallbackSynchronously(cb) {
  cb();
}

const boundSyncFn = bindCallback(iCallMyCallbackSynchronously);
const boundAsyncFn = bindCallback(iCallMyCallbackSynchronously, null, asyncScheduler);

boundSyncFn().subscribe(() =&gt; console.log('I was sync!'));
boundAsyncFn().subscribe(() =&gt; console.log('I was async!'));
console.log('This happened...');

// Logs:
// I was sync!
// This happened...
// I was async!</pre> <p>Use <code><a href="bindcallback.html" class="code-anchor">bindCallback</a></code> on an object method</p> <pre data-language="typescript">import { bindCallback } from 'rxjs';

const boundMethod = bindCallback(someObject.methodWithCallback);
boundMethod
  .call(someObject) // make sure methodWithCallback has access to someObject
  .subscribe(subscriber);</pre>   <h2 id="see-also">See Also</h2> <ul> <li>
<a href="bindnodecallback.html"><code>bindNodeCallback</code></a> </li> <li>
<a href="from.html"><code>from</code></a> </li> </ul>  </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2015&ndash;2022 Google, Inc., Netflix, Inc., Microsoft Corp. and contributors.<br>Code licensed under an Apache-2.0 License. Documentation licensed under CC BY 4.0.<br>
    <a href="https://rxjs.dev/api/index/function/bindCallback" class="_attribution-link">https://rxjs.dev/api/index/function/bindCallback</a>
  </p>
</div>
