   <h1 id="bindnodecallback">bindNodeCallback</h1> <p><code class="api-type-label function">function</code> <code class="api-status-label stable">stable</code></p>   <aio-toc class="embedded"></aio-toc> <div class="api-body"> 
<p>Converts a Node.js-style callback API to a function that returns an Observable.</p>  <h3 data-language="typescript"><code>bindNodeCallback(callbackFunc: (...args: any[]) =&gt; void, resultSelector: (...args: any[]) =&gt; any, scheduler?: SchedulerLike): (...args: any[]) =&gt; Observable&lt;any&gt;</code></h3> <h4 class="no-anchor" id="parameters">Parameters</h4> <table> <tbody> <tr class="function-overload-parameter"> <td class="param-name">  <code>callbackFunc</code> </td> <td class="param-type"><code>(...args: any[]) =&gt; void</code></td> <td class="param-description"> </td> </tr> <tr class="function-overload-parameter"> <td class="param-name">  <code>resultSelector</code> </td> <td class="param-type"><code>(...args: any[]) =&gt; any</code></td> <td class="param-description"> </td> </tr> <tr class="function-overload-parameter"> <td class="param-name">  <code>scheduler</code> </td> <td class="param-type"><code><a href="../interface/schedulerlike.html" class="code-anchor">SchedulerLike</a></code></td> <td class="param-description"> <p>Optional. Default is <code>undefined</code>.</p> </td> </tr> </tbody> </table> <h4 class="no-anchor" id="returns">Returns</h4> <p><code>(...args: any[]) =&gt; <a href="../class/observable.html" class="code-anchor">Observable</a>&lt;any&gt;</code></p>  <h3 data-language="typescript"><code>bindNodeCallback(callbackFunc: (...args: [...A, (err: any, ...res: R) =&gt; void]) =&gt; void, schedulerLike?: SchedulerLike): (...arg: A) =&gt; Observable&lt;R extends [
] ? void : R extends [
    any
] ? R[0] : R&gt;</code></h3> <h4 class="no-anchor" id="parameters-1">Parameters</h4> <table> <tbody> <tr class="function-overload-parameter"> <td class="param-name">  <code>callbackFunc</code> </td> <td class="param-type"><code>(...args: [...A, (err: any, ...res: R) =&gt; void]) =&gt; void</code></td> <td class="param-description"> </td> </tr> <tr class="function-overload-parameter"> <td class="param-name">  <code>schedulerLike</code> </td> <td class="param-type"><code><a href="../interface/schedulerlike.html" class="code-anchor">SchedulerLike</a></code></td> <td class="param-description"> <p>Optional. Default is <code>undefined</code>.</p> </td> </tr> </tbody> </table> <h4 class="no-anchor" id="returns-1">Returns</h4> <p><code>(...arg: A) =&gt; <a href="../class/observable.html" class="code-anchor">Observable</a>&lt;R extends [ ] ? void : R extends [     any ] ? R[0] : R&gt;</code></p>  <h2 id="description">Description</h2> <p><span class="informal">It's just like <a href="bindcallback.html"><code>bindCallback</code></a>, but the callback is expected to be of type <code>callback(error, result)</code>.</span></p> <p><code><a href="bindnodecallback.html" class="code-anchor">bindNodeCallback</a></code> is not an operator because its input and output are not Observables. The input is a function <code>func</code> with some parameters, but the last parameter must be a callback function that <code>func</code> calls when it is done. The callback function is expected to follow Node.js conventions, where the first argument to the callback is an error object, signaling whether call was successful. If that object is passed to callback, it means something went wrong.</p> <p>The output of <code><a href="bindnodecallback.html" class="code-anchor">bindNodeCallback</a></code> is a function that takes the same parameters as <code>func</code>, except the last one (the callback). When the output function is called with arguments, it will return an Observable. If <code>func</code> calls its callback with error parameter present, Observable will error with that value as well. If error parameter is not passed, Observable will emit second parameter. If there are more parameters (third and so on), Observable will emit an array with all arguments, except first error argument.</p> <p>Note that <code>func</code> will not be called at the same time output function is, but rather whenever resulting Observable is subscribed. By default call to <code>func</code> will happen synchronously after subscription, but that can be changed with proper <code>scheduler</code> provided as optional third parameter. <a href="../interface/schedulerlike.html"><code>SchedulerLike</code></a> can also control when values from callback will be emitted by Observable. To find out more, check out documentation for <a href="bindcallback.html"><code>bindCallback</code></a>, where <a href="../interface/schedulerlike.html"><code>SchedulerLike</code></a> works exactly the same.</p> <p>As in <a href="bindcallback.html"><code>bindCallback</code></a>, context (<code>this</code> property) of input function will be set to context of returned function, when it is called.</p> <p>After Observable emits value, it will complete immediately. This means even if <code>func</code> calls callback again, values from second and consecutive calls will never appear on the stream. If you need to handle functions that call callbacks multiple times, check out <a href="fromevent.html"><code>fromEvent</code></a> or <a href="fromeventpattern.html"><code>fromEventPattern</code></a> instead.</p> <p>Note that <code><a href="bindnodecallback.html" class="code-anchor">bindNodeCallback</a></code> can be used in non-Node.js environments as well. "Node.js-style" callbacks are just a convention, so if you write for browsers or any other environment and API you use implements that callback style, <code><a href="bindnodecallback.html" class="code-anchor">bindNodeCallback</a></code> can be safely used on that API functions as well.</p> <p>Remember that Error object passed to callback does not have to be an instance of JavaScript built-in <code>Error</code> object. In fact, it does not even have to an object. Error parameter of callback function is interpreted as "present", when value of that parameter is truthy. It could be, for example, non-zero number, non-empty string or boolean <code>true</code>. In all of these cases resulting Observable would error with that value. This means usually regular style callbacks will fail very often when <code><a href="bindnodecallback.html" class="code-anchor">bindNodeCallback</a></code> is used. If your Observable errors much more often then you would expect, check if callback really is called in Node.js-style and, if not, switch to <a href="bindcallback.html"><code>bindCallback</code></a> instead.</p> <p>Note that even if error parameter is technically present in callback, but its value is falsy, it still won't appear in array emitted by Observable.</p> <h2 id="examples">Examples</h2> <p> Read a file from the filesystem and get the data as an Observable</p> <pre data-language="typescript">import * as fs from 'fs';
const readFileAsObservable = bindNodeCallback(fs.readFile);
const result = readFileAsObservable('./roadNames.txt', 'utf8');
result.subscribe(x =&gt; console.log(x), e =&gt; console.error(e));</pre> <p>Use on function calling callback with multiple arguments</p> <pre data-language="typescript">someFunction((err, a, b) =&gt; {
  console.log(err); // null
  console.log(a); // 5
  console.log(b); // "some string"
});
const boundSomeFunction = bindNodeCallback(someFunction);
boundSomeFunction()
.subscribe(value =&gt; {
  console.log(value); // [5, "some string"]
});</pre> <p>Use on function calling callback in regular style</p> <pre data-language="typescript">someFunction(a =&gt; {
  console.log(a); // 5
});
const boundSomeFunction = bindNodeCallback(someFunction);
boundSomeFunction()
.subscribe(
  value =&gt; {}             // never gets called
  err =&gt; console.log(err) // 5
);</pre>   <h2 id="see-also">See Also</h2> <ul> <li>
<a href="bindcallback.html"><code>bindCallback</code></a> </li> <li>
<a href="from.html"><code>from</code></a> </li> </ul>  </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2015&ndash;2022 Google, Inc., Netflix, Inc., Microsoft Corp. and contributors.<br>Code licensed under an Apache-2.0 License. Documentation licensed under CC BY 4.0.<br>
    <a href="https://rxjs.dev/api/index/function/bindNodeCallback" class="_attribution-link">https://rxjs.dev/api/index/function/bindNodeCallback</a>
  </p>
</div>
