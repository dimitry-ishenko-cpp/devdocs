   <h1 id="animationframes">animationFrames</h1> <p><code class="api-type-label function">function</code> <code class="api-status-label stable">stable</code></p>   <aio-toc class="embedded"></aio-toc> <div class="api-body"> 
<p>An observable of animation frames</p>  <h3 data-language="typescript"><code>animationFrames(timestampProvider?: TimestampProvider)</code></h3> <h4 class="no-anchor" id="parameters">Parameters</h4> <table> <tbody> <tr class="function-overload-parameter"> <td class="param-name">  <code>timestampProvider</code> </td> <td class="param-type"><code><a href="../interface/timestampprovider.html" class="code-anchor">TimestampProvider</a></code></td> <td class="param-description"> <p>Optional. Default is <code>undefined</code>.</p> <p>An object with a <code>now</code> method that provides a numeric timestamp</p> </td> </tr> </tbody> </table>  <h2 id="description">Description</h2> <p>Emits the amount of time elapsed since subscription and the timestamp on each animation frame. Defaults to milliseconds provided to the requestAnimationFrame's callback. Does not end on its own.</p> <p>Every subscription will start a separate animation loop. Since animation frames are always scheduled by the browser to occur directly before a repaint, scheduling more than one animation frame synchronously should not be much different or have more overhead than looping over an array of events during a single animation frame. However, if for some reason the developer would like to ensure the execution of animation-related handlers are all executed during the same task by the engine, the <code><a href="share.html" class="code-anchor">share</a></code> operator can be used.</p> <p>This is useful for setting up animations with RxJS.</p> <h2 id="examples">Examples</h2> <p>Tweening a div to move it on the screen</p> <pre data-language="typescript">import { animationFrames, map, takeWhile, endWith } from 'rxjs';

function tween(start: number, end: number, duration: number) {
  const diff = end - start;
  return animationFrames().pipe(
    // Figure out what percentage of time has passed
    map(({ elapsed }) =&gt; elapsed / duration),
    // Take the vector while less than 100%
    takeWhile(v =&gt; v &lt; 1),
    // Finish with 100%
    endWith(1),
    // Calculate the distance traveled between start and end
    map(v =&gt; v * diff + start)
  );
}

// Setup a div for us to move around
const div = document.createElement('div');
document.body.appendChild(div);
div.style.position = 'absolute';
div.style.width = '40px';
div.style.height = '40px';
div.style.backgroundColor = 'lime';
div.style.transform = 'translate3d(10px, 0, 0)';

tween(10, 200, 4000).subscribe(x =&gt; {
  div.style.transform = `translate3d(${ x }px, 0, 0)`;
});</pre> <p>Providing a custom timestamp provider</p> <pre data-language="typescript">import { animationFrames, TimestampProvider } from 'rxjs';

// A custom timestamp provider
let now = 0;
const customTSProvider: TimestampProvider = {
  now() { return now++; }
};

const source$ = animationFrames(customTSProvider);

// Log increasing numbers 0...1...2... on every animation frame.
source$.subscribe(({ elapsed }) =&gt; console.log(elapsed));</pre>  </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2015&ndash;2022 Google, Inc., Netflix, Inc., Microsoft Corp. and contributors.<br>Code licensed under an Apache-2.0 License. Documentation licensed under CC BY 4.0.<br>
    <a href="https://rxjs.dev/api/index/function/animationFrames" class="_attribution-link">https://rxjs.dev/api/index/function/animationFrames</a>
  </p>
</div>
