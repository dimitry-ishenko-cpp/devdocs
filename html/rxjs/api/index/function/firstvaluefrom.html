   <h1 id="firstvaluefrom">firstValueFrom</h1> <p><code class="api-type-label function">function</code> <code class="api-status-label stable">stable</code></p>   <aio-toc class="embedded"></aio-toc> <div class="api-body"> 
<p>Converts an observable to a promise by subscribing to the observable, and returning a promise that will resolve as soon as the first value arrives from the observable. The subscription will then be closed.</p>  <h3 data-language="typescript"><code>firstValueFrom&lt;T, D&gt;(source: Observable&lt;T&gt;, config?: FirstValueFromConfig&lt;D&gt;): Promise&lt;T | D&gt;</code></h3> <h4 class="no-anchor" id="parameters">Parameters</h4> <table> <tbody> <tr class="function-overload-parameter"> <td class="param-name">  <code>source</code> </td> <td class="param-type"><code><a href="../class/observable.html" class="code-anchor">Observable&lt;T&gt;</a></code></td> <td class="param-description"> <p>the observable to convert to a promise</p> </td> </tr> <tr class="function-overload-parameter"> <td class="param-name">  <code><a href="../const/config.html" class="code-anchor">config</a></code> </td> <td class="param-type"><code>FirstValueFromConfig&lt;D&gt;</code></td> <td class="param-description"> <p>Optional. Default is <code>undefined</code>.</p> <p>a configuration object to define the <code>defaultValue</code> to use if the source completes without emitting a value</p> </td> </tr> </tbody> </table> <h4 class="no-anchor" id="returns">Returns</h4> <p><code>Promise&lt;T | D&gt;</code></p>  <h2 id="description">Description</h2> <p>If the observable stream completes before any values were emitted, the returned promise will reject with <a href="../interface/emptyerror.html"><code>EmptyError</code></a> or will resolve with the default value if a default was specified.</p> <p>If the observable stream emits an error, the returned promise will reject with that error.</p> <p><strong>WARNING</strong>: Only use this with observables you <em>know</em> will emit at least one value, <em>OR</em> complete. If the source observable does not emit one value or complete, you will end up with a promise that is hung up, and potentially all of the state of an async function hanging out in memory. To avoid this situation, look into adding something like <a href="timeout.html"><code>timeout</code></a>, <a href="take.html"><code>take</code></a>, <a href="takewhile.html"><code>takeWhile</code></a>, or <a href="takeuntil.html"><code>takeUntil</code></a> amongst others.</p> <h2 id="example">Example</h2> <p>Wait for the first value from a stream and emit it from a promise in an async function</p> <pre data-language="typescript">import { interval, firstValueFrom } from 'rxjs';

async function execute() {
  const source$ = interval(2000);
  const firstNumber = await firstValueFrom(source$);
  console.log(`The first number is ${ firstNumber }`);
}

execute();

// Expected output:
// 'The first number is 0'</pre>   <h2 id="see-also">See Also</h2> <ul> <li>
<a href="lastvaluefrom.html"><code>lastValueFrom</code></a> </li> </ul>  </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2015&ndash;2022 Google, Inc., Netflix, Inc., Microsoft Corp. and contributors.<br>Code licensed under an Apache-2.0 License. Documentation licensed under CC BY 4.0.<br>
    <a href="https://rxjs.dev/api/index/function/firstValueFrom" class="_attribution-link">https://rxjs.dev/api/index/function/firstValueFrom</a>
  </p>
</div>
