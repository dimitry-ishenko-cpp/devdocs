   <h1 id="websocket">webSocket</h1> <p><code class="api-type-label function">function</code> <code class="api-status-label stable">stable</code></p>   <aio-toc class="embedded"></aio-toc> <div class="api-body"> 
<p>Wrapper around the w3c-compatible WebSocket object provided by the browser.</p>  <h3 data-language="typescript"><code>webSocket&lt;T&gt;(urlConfigOrSource: string | WebSocketSubjectConfig&lt;T&gt;): WebSocketSubject&lt;T&gt;</code></h3> <h4 class="no-anchor" id="parameters">Parameters</h4> <table> <tbody> <tr class="function-overload-parameter"> <td class="param-name">  <code>urlConfigOrSource</code> </td> <td class="param-type"><code>string | WebSocketSubjectConfig&lt;T&gt;</code></td> <td class="param-description"> <p> The WebSocket endpoint as an url or an object with configuration and additional Observers.</p> </td> </tr> </tbody> </table> <h4 class="no-anchor" id="returns">Returns</h4> <p><code><a href="websocketsubject.html" class="code-anchor">WebSocketSubject&lt;T&gt;</a></code>: Subject which allows to both send and receive messages via WebSocket connection.</p>  <h2 id="description">Description</h2> <p><span class="informal"><a href="../index/class/subject.html"><code>Subject</code></a> that communicates with a server via WebSocket</span></p> <p><code>webSocket</code> is a factory function that produces a <code><a href="websocketsubject.html" class="code-anchor">WebSocketSubject</a></code>, which can be used to make WebSocket connection with an arbitrary endpoint. <code>webSocket</code> accepts as an argument either a string with url of WebSocket endpoint, or an <a href="websocketsubjectconfig.html">WebSocketSubjectConfig</a> object for providing additional configuration, as well as Observers for tracking lifecycle of WebSocket connection.</p> <p>When <code><a href="websocketsubject.html" class="code-anchor">WebSocketSubject</a></code> is subscribed, it attempts to make a socket connection, unless there is one made already. This means that many subscribers will always listen on the same socket, thus saving resources. If however, two instances are made of <code><a href="websocketsubject.html" class="code-anchor">WebSocketSubject</a></code>, even if these two were provided with the same url, they will attempt to make separate connections. When consumer of a <code><a href="websocketsubject.html" class="code-anchor">WebSocketSubject</a></code> unsubscribes, socket connection is closed, only if there are no more subscribers still listening. If after some time a consumer starts subscribing again, connection is reestablished.</p> <p>Once connection is made, whenever a new message comes from the server, <code><a href="websocketsubject.html" class="code-anchor">WebSocketSubject</a></code> will emit that message as a value in the stream. By default, a message from the socket is parsed via <code>JSON.parse</code>. If you want to customize how deserialization is handled (if at all), you can provide custom <code>resultSelector</code> function in <a href="websocketsubject.html"><code>WebSocketSubject</code></a>. When connection closes, stream will complete, provided it happened without any errors. If at any point (starting, maintaining or closing a connection) there is an error, stream will also error with whatever WebSocket API has thrown.</p> <p>By virtue of being a <a href="../index/class/subject.html"><code>Subject</code></a>, <code><a href="websocketsubject.html" class="code-anchor">WebSocketSubject</a></code> allows for receiving and sending messages from the server. In order to communicate with a connected endpoint, use <code>next</code>, <code>error</code> and <code>complete</code> methods. <code>next</code> sends a value to the server, so bear in mind that this value will not be serialized beforehand. Because of This, <code>JSON.stringify</code> will have to be called on a value by hand, before calling <code>next</code> with a result. Note also that if at the moment of nexting value there is no socket connection (for example no one is subscribing), those values will be buffered, and sent when connection is finally established. <code>complete</code> method closes socket connection. <code>error</code> does the same, as well as notifying the server that something went wrong via status code and string with details of what happened. Since status code is required in WebSocket API, <code><a href="websocketsubject.html" class="code-anchor">WebSocketSubject</a></code> does not allow, like regular <code><a href="../index/class/subject.html" class="code-anchor">Subject</a></code>, arbitrary values being passed to the <code>error</code> method. It needs to be called with an object that has <code>code</code> property with status code number and optional <code>reason</code> property with string describing details of an error.</p> <p>Calling <code>next</code> does not affect subscribers of <code><a href="websocketsubject.html" class="code-anchor">WebSocketSubject</a></code> - they have no information that something was sent to the server (unless of course the server responds somehow to a message). On the other hand, since calling <code>complete</code> triggers an attempt to close socket connection. If that connection is closed without any errors, stream will complete, thus notifying all subscribers. And since calling <code>error</code> closes socket connection as well, just with a different status code for the server, if closing itself proceeds without errors, subscribed Observable will not error, as one might expect, but complete as usual. In both cases (calling <code>complete</code> or <code>error</code>), if process of closing socket connection results in some errors, <em>then</em> stream will error.</p> <p><strong>Multiplexing</strong></p> <p><code><a href="websocketsubject.html" class="code-anchor">WebSocketSubject</a></code> has an additional operator, not found in other Subjects. It is called <code>multiplex</code> and it is used to simulate opening several socket connections, while in reality maintaining only one. For example, an application has both chat panel and real-time notifications about sport news. Since these are two distinct functions, it would make sense to have two separate connections for each. Perhaps there could even be two separate services with WebSocket endpoints, running on separate machines with only GUI combining them together. Having a socket connection for each functionality could become too resource expensive. It is a common pattern to have single WebSocket endpoint that acts as a gateway for the other services (in this case chat and sport news services). Even though there is a single connection in a client app, having the ability to manipulate streams as if it were two separate sockets is desirable. This eliminates manually registering and unregistering in a gateway for given service and filter out messages of interest. This is exactly what <code>multiplex</code> method is for.</p> <p>Method accepts three parameters. First two are functions returning subscription and unsubscription messages respectively. These are messages that will be sent to the server, whenever consumer of resulting Observable subscribes and unsubscribes. Server can use them to verify that some kind of messages should start or stop being forwarded to the client. In case of the above example application, after getting subscription message with proper identifier, gateway server can decide that it should connect to real sport news service and start forwarding messages from it. Note that both messages will be sent as returned by the functions, they are by default serialized using JSON.stringify, just as messages pushed via <code>next</code>. Also bear in mind that these messages will be sent on <em>every</em> subscription and unsubscription. This is potentially dangerous, because one consumer of an Observable may unsubscribe and the server might stop sending messages, since it got unsubscription message. This needs to be handled on the server or using <a href="../index/function/publish.html"><code>publish</code></a> on a Observable returned from 'multiplex'.</p> <p>Last argument to <code>multiplex</code> is a <code>messageFilter</code> function which should return a boolean. It is used to filter out messages sent by the server to only those that belong to simulated WebSocket stream. For example, server might mark these messages with some kind of string identifier on a message object and <code>messageFilter</code> would return <code>true</code> if there is such identifier on an object emitted by the socket. Messages which returns <code>false</code> in <code>messageFilter</code> are simply skipped, and are not passed down the stream.</p> <p>Return value of <code>multiplex</code> is an Observable with messages incoming from emulated socket connection. Note that this is not a <code><a href="websocketsubject.html" class="code-anchor">WebSocketSubject</a></code>, so calling <code>next</code> or <code>multiplex</code> again will fail. For pushing values to the server, use root <code><a href="websocketsubject.html" class="code-anchor">WebSocketSubject</a></code>.</p> <h2 id="examples">Examples</h2> <p>Listening for messages from the server</p> <pre data-language="typescript">import { webSocket } from 'rxjs/webSocket';

const subject = webSocket('ws://localhost:8081');

subject.subscribe({
  next: msg =&gt; console.log('message received: ' + msg), // Called whenever there is a message from the server.
  error: err =&gt; console.log(err), // Called if at any point WebSocket API signals some kind of error.
  complete: () =&gt; console.log('complete') // Called when connection is closed (for whatever reason).
 });</pre> <p>Pushing messages to the server</p> <pre data-language="typescript">import { webSocket } from 'rxjs/webSocket';

const subject = webSocket('ws://localhost:8081');

subject.subscribe();
// Note that at least one consumer has to subscribe to the created subject - otherwise "nexted" values will be just buffered and not sent,
// since no connection was established!

subject.next({ message: 'some message' });
// This will send a message to the server once a connection is made. Remember value is serialized with JSON.stringify by default!

subject.complete(); // Closes the connection.

subject.error({ code: 4000, reason: 'I think our app just broke!' });
// Also closes the connection, but let's the server know that this closing is caused by some error.</pre> <p>Multiplexing WebSocket</p> <pre data-language="typescript">import { webSocket } from 'rxjs/webSocket';

const subject = webSocket('ws://localhost:8081');

const observableA = subject.multiplex(
  () =&gt; ({ subscribe: 'A' }), // When server gets this message, it will start sending messages for 'A'...
  () =&gt; ({ unsubscribe: 'A' }), // ...and when gets this one, it will stop.
  message =&gt; message.type === 'A' // If the function returns `true` message is passed down the stream. Skipped if the function returns false.
);

const observableB = subject.multiplex( // And the same goes for 'B'.
  () =&gt; ({ subscribe: 'B' }),
  () =&gt; ({ unsubscribe: 'B' }),
  message =&gt; message.type === 'B'
);

const subA = observableA.subscribe(messageForA =&gt; console.log(messageForA));
// At this moment WebSocket connection is established. Server gets '{"subscribe": "A"}' message and starts sending messages for 'A',
// which we log here.

const subB = observableB.subscribe(messageForB =&gt; console.log(messageForB));
// Since we already have a connection, we just send '{"subscribe": "B"}' message to the server. It starts sending messages for 'B',
// which we log here.

subB.unsubscribe();
// Message '{"unsubscribe": "B"}' is sent to the server, which stops sending 'B' messages.

subA.unsubscribe();
// Message '{"unsubscribe": "A"}' makes the server stop sending messages for 'A'. Since there is no more subscribers to root Subject,
// socket connection closes.</pre>  </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2015&ndash;2022 Google, Inc., Netflix, Inc., Microsoft Corp. and contributors.<br>Code licensed under an Apache-2.0 License. Documentation licensed under CC BY 4.0.<br>
    <a href="https://rxjs.dev/api/webSocket/webSocket" class="_attribution-link">https://rxjs.dev/api/webSocket/webSocket</a>
  </p>
</div>
