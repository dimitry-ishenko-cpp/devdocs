<h1>core.stdcpp.string</h1>  <p>D header file for interaction with C++ std::string. </p>
<dl>
<dt>License:</dt>
<dd>Distributed under the <a href="http://www.boost.org/LICENSE_1_0.txt">Boost Software License 1.0</a>. (See accompanying file LICENSE) </dd>
</dl> <dl>
<dt>Authors:</dt>
<dd>Guillaume Chatelet Manu Evans </dd>
</dl> <dl>
<dt>Source</dt>
<dd> <a href="https://github.com/dlang/druntime/blob/master/src/core/stdcpp/string.d">core/stdcpp/string.d</a>
</dd>
</dl> <dl>
<dt class="d_decl" id="Default">enum DefaultConstruct <strong id="Default">Default</strong>; </dt> <dd>
<p>Constructor argument for default construction</p> </dd> <dt class="d_decl" id="char_traits">struct <strong id="char_traits">char_traits</strong>(CharT); </dt> <dd>
<p>Character traits classes specify character properties and provide specific semantics for certain operations on characters and sequences of characters.</p> </dd> <dt class="d_decl" id="basic_string">struct <strong id="basic_string">basic_string</strong>(T, Traits = char_traits!T, Alloc = allocator!T); </dt> <dd>
<p>D language counterpart to C++ std::basic_string. </p>
<p>C++ reference: </p> <dl>
<dt class="d_decl" id="basic_string.npos">enum size_type <strong id="npos">npos</strong>; </dt>  <dt class="d_decl" id="basic_string.size_type">alias <strong id="size_type">size_type</strong> = size_t; </dt>  <dt class="d_decl" id="basic_string.difference_type">alias <strong id="difference_type">difference_type</strong> = ptrdiff_t; </dt>  <dt class="d_decl" id="basic_string.value_type">alias <strong id="value_type">value_type</strong> = T; </dt>  <dt class="d_decl" id="basic_string.traits_type">alias <strong id="traits_type">traits_type</strong> = Traits; </dt>  <dt class="d_decl" id="basic_string.allocator_type">alias <strong id="allocator_type">allocator_type</strong> = Alloc; </dt>  <dt class="d_decl" id="basic_string.pointer">alias <strong id="pointer">pointer</strong> = value_type*; </dt>  <dt class="d_decl" id="basic_string.const_pointer">alias <strong id="const_pointer">const_pointer</strong> = const(value_type)*; </dt>  <dt class="d_decl" id="basic_string.toString">alias <strong id="toString">toString</strong> = as_array; </dt>  <dt class="d_decl" id="basic_string.this">this(); </dt> <dd>
<p>MSVC allocates on default initialisation in debug, which can't be modelled by D <code>struct</code></p> </dd> <dt class="d_decl" id="basic_string.length">alias <strong id="length">length</strong> = size; </dt>  <dt class="d_decl" id="basic_string.opDollar">alias <strong id="opDollar">opDollar</strong> = length; </dt>  <dt class="d_decl" id="basic_string.empty">const nothrow @safe bool <strong id="empty">empty</strong>(); </dt>  <dt class="d_decl" id="basic_string.opSlice">const pure nothrow @nogc @safe size_t[2] <strong id="opSlice">opSlice</strong>(size_t dim : 0)(size_t start, size_t end); </dt>  <dt class="d_decl" id="basic_string.opIndex">inout pure nothrow @nogc ref @safe inout(T) <strong id="opIndex">opIndex</strong>(size_t index); </dt>  <dt class="d_decl" id="basic_string.opIndex.2">inout pure nothrow @nogc @safe inout(T)[] <strong id="opIndex">opIndex</strong>(size_t[2] slice); </dt>  <dt class="d_decl" id="basic_string.opIndex.3">inout pure nothrow @nogc @safe inout(T)[] <strong id="opIndex">opIndex</strong>(); </dt>  <dt class="d_decl" id="basic_string.opEquals">const pure nothrow @safe bool <strong id="opEquals">opEquals</strong>(ref scope const basic_string s); <br><br>const pure nothrow @safe bool <strong id="opEquals">opEquals</strong>(scope const T[] s); </dt> <dd>
<p>Two <code>basic_string</code>s are equal if they represent the same sequence of code units.</p> </dd> <dt class="d_decl" id="basic_string.opCmp">const pure nothrow @safe int <strong id="opCmp">opCmp</strong>(ref scope const basic_string rhs); <br><br>const pure nothrow @safe int <strong id="opCmp">opCmp</strong>(scope const T[] rhs); </dt> <dd>
<p>Performs lexicographical comparison.</p> </dd> <dt class="d_decl" id="basic_string.toHash">const pure nothrow @nogc @safe size_t <strong id="toHash">toHash</strong>(); </dt> <dd>
<p>Hash to allow <code>basic_string</code>s to be used as keys for built-in associative arrays. <strong>The result will generally not be the same as C++ <code>std::hash&lt;std::basic_string&lt;T&gt;&gt;</code>.</strong></p> </dd> <dt class="d_decl" id="basic_string.clear">void <strong id="clear">clear</strong>(); </dt>  <dt class="d_decl" id="basic_string.resize">@trusted void <strong id="resize">resize</strong>(size_type n, T c = T(0)); </dt>  <dt class="d_decl" id="basic_string.front">inout nothrow ref @safe inout(T) <strong id="front">front</strong>(); </dt>  <dt class="d_decl" id="basic_string.back">inout nothrow ref @safe inout(T) <strong id="back">back</strong>(); </dt>  <dt class="d_decl" id="basic_string.c_str">const nothrow @safe const(T)* <strong id="c_str">c_str</strong>(); </dt>  <dt class="d_decl" id="basic_string.opAssign">ref basic_string <strong id="opAssign">opAssign</strong>()(auto ref basic_string str); </dt>  <dt class="d_decl" id="basic_string.opAssign.2">ref basic_string <strong id="opAssign">opAssign</strong>(const(T)[] str); </dt>  <dt class="d_decl" id="basic_string.opAssign.3">ref basic_string <strong id="opAssign">opAssign</strong>(T c); </dt>  <dt class="d_decl" id="basic_string.opIndexAssign">ref basic_string <strong id="opIndexAssign">opIndexAssign</strong>(T c, size_t index); </dt>  <dt class="d_decl" id="basic_string.opIndexAssign.2">ref basic_string <strong id="opIndexAssign">opIndexAssign</strong>(T c, size_t[2] slice); </dt>  <dt class="d_decl" id="basic_string.opIndexAssign.3">ref basic_string <strong id="opIndexAssign">opIndexAssign</strong>(const(T)[] str, size_t[2] slice); </dt>  <dt class="d_decl" id="basic_string.opIndexAssign.4">ref basic_string <strong id="opIndexAssign">opIndexAssign</strong>(T c); </dt>  <dt class="d_decl" id="basic_string.opIndexAssign.5">ref basic_string <strong id="opIndexAssign">opIndexAssign</strong>(const(T)[] str); </dt>  <dt class="d_decl" id="basic_string.opIndexOpAssign">ref basic_string <strong id="opIndexOpAssign">opIndexOpAssign</strong>(string op)(T c, size_t index); </dt>  <dt class="d_decl" id="basic_string.opIndexOpAssign.2">ref basic_string <strong id="opIndexOpAssign">opIndexOpAssign</strong>(string op)(T c, size_t[2] slice); </dt>  <dt class="d_decl" id="basic_string.opIndexOpAssign.3">ref basic_string <strong id="opIndexOpAssign">opIndexOpAssign</strong>(string op)(const(T)[] str, size_t[2] slice); </dt>  <dt class="d_decl" id="basic_string.opIndexOpAssign.4">ref basic_string <strong id="opIndexOpAssign">opIndexOpAssign</strong>(string op)(T c); </dt>  <dt class="d_decl" id="basic_string.opIndexOpAssign.5">ref basic_string <strong id="opIndexOpAssign">opIndexOpAssign</strong>(string op)(const(T)[] str); </dt>  <dt class="d_decl" id="basic_string.append">ref basic_string <strong id="append">append</strong>(T c); </dt>  <dt class="d_decl" id="basic_string.opOpAssign">ref basic_string <strong id="opOpAssign">opOpAssign</strong>(string op : "~")(const(T)[] str); </dt>  <dt class="d_decl" id="basic_string.opOpAssign.2">ref basic_string <strong id="opOpAssign">opOpAssign</strong>(string op : "~")(T c); </dt>  <dt class="d_decl" id="basic_string.insert">ref basic_string <strong id="insert">insert</strong>(size_type pos, ref const(basic_string) str); </dt>  <dt class="d_decl" id="basic_string.insert.2">ref @trusted basic_string <strong id="insert">insert</strong>(size_type pos, ref const(basic_string) str, size_type subpos, size_type sublen); </dt>  <dt class="d_decl" id="basic_string.insert.3">ref basic_string <strong id="insert">insert</strong>(S : size_type)(S pos, const(T)* s); </dt>  <dt class="d_decl" id="basic_string.insert.4">ref basic_string <strong id="insert">insert</strong>(size_type pos, const(T)[] s); </dt>  <dt class="d_decl" id="basic_string.erase">ref basic_string <strong id="erase">erase</strong>(size_type pos = 0); </dt>  <dt class="d_decl" id="basic_string.erase.2">ref basic_string <strong id="erase">erase</strong>(size_type pos, size_type len); </dt>  <dt class="d_decl" id="basic_string.replace">ref basic_string <strong id="replace">replace</strong>()(size_type pos, size_type len, auto ref basic_string str); </dt>  <dt class="d_decl" id="basic_string.replace.2">ref basic_string <strong id="replace">replace</strong>()(size_type pos, size_type len, auto ref basic_string str, size_type subpos, size_type sublen = npos); </dt>  <dt class="d_decl" id="basic_string.replace.3">ref basic_string <strong id="replace">replace</strong>(size_type pos, size_type len, const(value_type)[] s); </dt>  <dt class="d_decl" id="basic_string.replace.4">ref basic_string <strong id="replace">replace</strong>(S : size_type)(S pos, size_type len, const(value_type)* s); </dt>  <dt class="d_decl" id="basic_string.push_back">@trusted void <strong id="push_back">push_back</strong>(T c); </dt>  <dt class="d_decl" id="basic_string.pop_back">void <strong id="pop_back">pop_back</strong>(); </dt>  <dt class="d_decl" id="basic_string.this.2">this(DefaultConstruct); </dt>  <dt class="d_decl" id="basic_string.this.3">this(const(T)[] str); </dt>  <dt class="d_decl" id="basic_string.this.4">this(const(T)[] str, ref const(allocator_type) al); </dt>  <dt class="d_decl" id="basic_string.get_allocator">inout ref inout(Alloc) <strong id="get_allocator">get_allocator</strong>(); </dt>  <dt class="d_decl" id="basic_string.max_size">const nothrow @safe size_type <strong id="max_size">max_size</strong>(); </dt>  <dt class="d_decl" id="basic_string.size">const nothrow @safe size_type <strong id="size">size</strong>(); </dt>  <dt class="d_decl" id="basic_string.capacity">const nothrow @safe size_type <strong id="capacity">capacity</strong>(); </dt>  <dt class="d_decl" id="basic_string.data">inout @safe inout(T)* <strong id="data">data</strong>(); </dt>  <dt class="d_decl" id="basic_string.as_array">inout nothrow @trusted inout(T)[] <strong id="as_array">as_array</strong>(); </dt>  <dt class="d_decl" id="basic_string.at">inout nothrow ref @trusted inout(T) <strong id="at">at</strong>(size_type i); </dt>  <dt class="d_decl" id="basic_string.assign">ref basic_string <strong id="assign">assign</strong>(const(T)[] str); </dt>  <dt class="d_decl" id="basic_string.assign.2">ref basic_string <strong id="assign">assign</strong>(ref const basic_string str); </dt>  <dt class="d_decl" id="basic_string.append.2">ref basic_string <strong id="append">append</strong>(const(T)[] str); </dt>  <dt class="d_decl" id="basic_string.append.3">ref basic_string <strong id="append">append</strong>(size_type n, T c); </dt>  <dt class="d_decl" id="basic_string.reserve">void <strong id="reserve">reserve</strong>(size_type _Newcap = 0); </dt>  <dt class="d_decl" id="basic_string.shrink_to_fit">void <strong id="shrink_to_fit">shrink_to_fit</strong>(); </dt>  <dt class="d_decl" id="basic_string.insert.5">ref basic_string <strong id="insert">insert</strong>(size_type pos, const(T)* s, size_type n); </dt>  <dt class="d_decl" id="basic_string.insert.6">ref basic_string <strong id="insert">insert</strong>(size_type pos, size_type n, T c); </dt>  <dt class="d_decl" id="basic_string.replace.5">ref basic_string <strong id="replace">replace</strong>(size_type pos, size_type len, const(T)* s, size_type slen); </dt>  <dt class="d_decl" id="basic_string.replace.6">ref basic_string <strong id="replace">replace</strong>(size_type _Off, size_type _N0, size_type _Count, T _Ch); </dt>  <dt class="d_decl" id="basic_string.swap">void <strong id="swap">swap</strong>(ref basic_string _Right); </dt>  </dl> </dd> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1999&ndash;2021 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/core_stdcpp_string.html" class="_attribution-link">https://dlang.org/phobos/core_stdcpp_string.html</a>
  </p>
</div>
