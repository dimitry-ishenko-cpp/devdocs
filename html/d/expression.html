<h1>Expressions</h1>       <b>Contents</b>  <ol> <li><a href="#definitions-and-terms">Definitions and Terms</a></li> <li><a href="#order-of-evaluation">Order Of Evaluation</a></li> <li><a href="#temporary-lifetime">Lifetime of Temporaries</a></li> <li><a href="#expression">Expressions</a></li> <li>
<a href="#assign_expressions">Assign Expressions</a><ol> <li><a href="#simple_assignment_expressions">Simple Assignment Expression</a></li> <li><a href="#assignment_operator_expressions">Assignment Operator Expressions</a></li> </ol>
</li> <li><a href="#conditional_expressions">Conditional Expressions</a></li> <li><a href="#oror_expressions">OrOr Expressions</a></li> <li><a href="#andand_expressions">AndAnd Expressions</a></li> <li>
<a href="#bitwise_expressions">Bitwise Expressions</a><ol> <li><a href="#or_expressions">Or Expressions</a></li> <li><a href="#xor_expressions">Xor Expressions</a></li> <li><a href="#and_expressions">And Expressions</a></li> </ol>
</li> <li><a href="#compare_expressions">Compare Expressions</a></li> <li>
<a href="#equality_expressions">Equality Expressions</a><ol> <li><a href="#identity_expressions">Identity Expressions</a></li> </ol>
</li> <li>
<a href="#relation_expressions">Relational Expressions</a><ol> <li><a href="#integer_comparisons">Integer comparisons</a></li> <li><a href="#floating-point-comparisons">Floating point comparisons</a></li> <li><a href="#class-comparisons">Class comparisons</a></li> </ol>
</li> <li><a href="#in_expressions">In Expressions</a></li> <li><a href="#shift_expressions">Shift Expressions</a></li> <li><a href="#add_expressions">Add Expressions</a></li> <li><a href="#cat_expressions">Cat Expressions</a></li> <li><a href="#mul_expressions">Mul Expressions</a></li> <li>
<a href="#unary-expression">Unary Expressions</a><ol> <li><a href="#complement_expressions">Complement Expressions</a></li> <li><a href="#new_expressions">New Expressions</a></li> <li><a href="#delete_expressions">Delete Expressions</a></li> <li><a href="#cast_expressions">Cast Expressions</a></li> </ol>
</li> <li><a href="#pow_expressions">Pow Expressions</a></li> <li><a href="#postfix_expressions">Postfix Expressions</a></li> <li><a href="#index_expressions">Index Expressions</a></li> <li><a href="#slice_expressions">Slice Expressions</a></li> <li>
<a href="#primary_expressions">Primary Expressions</a><ol> <li><a href="#identifier">.Identifier</a></li> <li><a href="#this">this</a></li> <li><a href="#super">super</a></li> <li><a href="#null">null</a></li> <li><a href="#true_false">true, false</a></li> <li><a href="#character-literal">Character Literals</a></li> <li><a href="#string_literals">String Literals</a></li> <li><a href="#array_literals">Array Literals</a></li> <li><a href="#associative_array_literals">Associative Array Literals</a></li> <li><a href="#function_literals">Function Literals</a></li> <li><a href="#uniform_construction_syntax">Uniform construction syntax for built-in scalar types</a></li> <li><a href="#assert_expressions">Assert Expressions</a></li> <li><a href="#mixin_expressions">Mixin Expressions</a></li> <li><a href="#import_expressions">Import Expressions</a></li> <li><a href="#typeid_expressions">Typeid Expressions</a></li> <li><a href="#is_expression">IsExpression</a></li> </ol>
</li> <li><a href="#specialkeywords">Special Keywords</a></li> <li><a href="#associativity">Associativity and Commutativity</a></li> </ol>   <p>An expression is a sequence of operators and operands that specifies an evaluation. The syntax, order of evaluation, and semantics of expressions are as follows.</p>  <p>Expressions are used to compute values with a resulting type. These values can then be assigned, tested, or ignored. Expressions can also have side effects. </p>  <h2 id="definitions-and-terms">Definitions and Terms</h2>  <p><b>Definition</b> (“Full expression”): For any expression <i>expr</i>, the full expression of <i>expr</i> is defined as follows. If <i>expr</i> parses as a subexpression of another expression <i>expr<sub>1</sub></i>, then the full expression of <i>expr</i> is the full expression of <i>expr<sub>1</sub></i>. Otherwise, <i>expr</i> is its own full expression.</p>  <p>Each expression has a unique full expression.</p>  <p>Example: in the statement <code>return f() + g() * 2;</code>, the full expression of <code>g() * 2</code> is <code>f() + g() * 2</code>, but not the full expression of <code>f() + g()</code> because the latter is not parsed as a subexpression.</p>  <p>Note: Although the definition is straightforward, a few subtleties exist related to function literals. In the statement <code>return (() =&gt; x + f())() * g();</code>, the full expression of <code>f()</code> is <code>x + f()</code>, not the expression passed to <code>return</code>. This is because the parent of <code>x + f()</code> has function literal type, not expression type.</p>  <p><b>Definition</b> (“Lvalue”): The following expressions, and no others, are called lvalue expressions or lvalues:</p> <ol>
<li>
<code>this</code> inside <code>struct</code> and <code>union</code> member functions;</li> <li>a variable or the result of the <i>DotIdentifier</i> grammatical construct <code>.</code> (left side may be missing) when the rightmost side of the dot is a variable, field (direct or <code>static</code>), function name, or invocation of a function that returns by reference;</li> <li>the result of the following expressions: <ul>
<li>built-in unary operators <code>+</code> (when applied to an lvalue), <code>*</code>, <code>++</code> (prefix only), <code>--</code> (prefix only);</li> <li>built-in indexing operator <code>[]</code> (but not the slicing operator);</li> <li>built-in assignment binary operators, i.e. <code>=</code>, <code>+=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, <code>&amp;=</code>, <code>|=</code>, <code>^=</code>, <code>~=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>, <code>&gt;&gt;&gt;=</code>, and <code>^^=</code>;</li> <li>the ternary operator <i>e</i> <code>?</code> <i>e<sub>1</sub></i> <code>:</code> <i>e<sub>2</sub></i> under the following circumstances:</li> </ul>
<ol> <li>
<i>e<sub>1</sub></i> and <i>e<sub>2</sub></i> are lvalues of the same type; OR</li> <li>One of <i>e<sub>1</sub></i> and <i>e<sub>2</sub></i> is an lvalue of type <code>T</code> and the other has and <code>alias this</code> converting it to <code>ref T</code>;</li>
</ol> </li>
<li>user-defined operators if and only if the function called as a result of lowering returns by reference;</li> <li>
<code>mixin</code> expressions if and only if the compilation of the expression resulting from compiling the argument(s) to <code>mixin</code> is an lvalue;</li> <li>
<code>cast(U)</code> expressions applied to lvalues of type <code>T</code> when <code>T*</code> is implicitly convertible to <code>U*</code>;</li> <li>
<code>cast()</code> and <code>cast(</code><i>qualifier list</i><code>)</code> when applied to an lvalue.</li> </ol>  <p><b>Definition</b> (“Rvalue”): Expressions that are not lvalues are rvalues.</p>  <p>Note: Rvalues include all literals, special value keywords such as <code>__FILE__</code> and <code>__LINE__</code>, <code>enum</code> values, and the result of expressions not defined as lvalues above.</p>  <p>The built-in address-of operator (unary <code>&amp;</code>) may only be applied to lvalues.</p>  <p><b>Definition</b> (“Smallest short-circuit expression”): Given an expression <i>expr</i> that is a subexpression of a full expression <i>fullexpr</i>, the smallest short-circuit expression, if any, is the shortest subexpression <i>scexpr</i> of <i>fullexpr</i> that is an <a href="#AndAndExpression"><i>AndAndExpression</i></a> (<code>&amp;&amp;</code>) or an <a href="#OrOrExpression"><i>OrOrExpression</i></a> (<code>||</code>), such that <i>expr</i> is a subexpression of <i>scexpr</i>.</p>  Example: in the expression <code>((f() * 2 &amp;&amp; g()) + 1) || h()</code>, the smallest short-circuit expression of the subexpression <code>f() * 2</code> is <code>f() * 2 &amp;&amp; g()</code>. In the expression <code>(f() &amp;&amp; g()) + h()</code>, the subexpression <code>h()</code> has no smallest short-circuit expression.  <h2 id="order-of-evaluation">Order Of Evaluation</h2>  <p>Built-in prefix unary expressions <code>++</code> and <code>--</code> are evaluated as if lowered (rewritten) to assignments as follows: <code>++expr</code> becomes <code>((expr) += 1)</code>, and <code>--expr</code> becomes <code>((expr) -= 1)</code>. Therefore, the result of prefix <code>++</code> and <code>--</code> is the lvalue after the side effect has been effected.</p>  <p>Built-in postfix unary expressions <code>++</code> and <code>--</code> are evaluated as if lowered (rewritten) to <a href="expression.html#function_literals">lambda</a> invocations as follows: <code>expr++</code> becomes <code>(ref T x){auto t = x; ++x; return t;}(expr)</code>, and <code>expr--</code> becomes <code>(ref T x){auto t = x; --x; return t;}(expr)</code>. Therefore, the result of postfix <code>++</code> and <code>--</code> is an rvalue just before the side effect has been effected.</p>  <p>Binary expressions except for <a href="#AssignExpression"><i>AssignExpression</i></a>, <a href="#OrOrExpression"><i>OrOrExpression</i></a>, and <a href="#AndAndExpression"><i>AndAndExpression</i></a> are evaluated in lexical order (left-to-right). Example:</p>   <pre data-language="d">int i = 2;
i = ++i * i++ + i;
assert(i == 3 * 3 + 4);
</pre>   <p><a href="#OrOrExpression"><i>OrOrExpression</i></a> and <a href="#AndAndExpression"><i>AndAndExpression</i></a> evaluate their left-hand side argument first. Then, <a href="#OrOrExpression"><i>OrOrExpression</i></a> evaluates its right-hand side if and only if its left-hand side does not evaluate to nonzero. <a href="#AndAndExpression"><i>AndAndExpression</i></a> evaluates its right-hand side if and only if its left-hand side evaluates to nonzero.</p>  <p><a href="#ConditionalExpression"><i>ConditionalExpression</i></a> evaluates its left-hand side argument first. Then, if the result is nonzero, the second operand is evaluated. Otherwise, the third operand is evaluated.</p>  <p>Calls to functions with <code>extern(D)</code> <a href="attribute.html#linkage">linkage</a> (which is the default linkage) are evaluated in the following order: first, if necessary, the address of the function to call is evaluated (e.g. in the case of a computed function pointer or delegate). Then, arguments are evaluated left to right. Finally, transfer is passed to the function. Example:</p>   <pre data-language="d">import std.stdio;
void function(int a, int b, int c) fun()
{
    writeln("fun() called");
    static void r(int a, int b, int c) { writeln("callee called"); }
    return &amp;r;
}
int f1() { writeln("f1() called"); return 1; }
int f2() { writeln("f2() called"); return 2; }
int f3(int x) { writeln("f3() called"); return x + 3; }
int f4() { writeln("f4() called"); return 4; }
// evaluates fun() then f1() then f2() then f3() then f4()
// after which control is transferred to the callee
fun()(f1(), f3(f2()), f4());
</pre>   <b>Implementation Defined:</b> <ol> <li>The order of evaluation of the operands of <a href="#AssignExpression"><i>AssignExpression</i></a>.</li> <li>The order of evaluation of function arguments for functions with linkage other than <code>extern (D)</code>.</li> </ol>  <b>Best Practices:</b> Even though the order of evaluation is well-defined, writing code that depends on it is rarely recommended.  <h2 id="temporary-lifetime">Lifetime of Temporaries</h2>  <p>Expressions and statements may create and/or consume rvalues. Such values are called <i>temporaries</i> and do not have a name or a visible scope. Their lifetime is managed automatically as defined in this section.</p>  <p>For each evaluation that yields a temporary value, the lifetime of that temporary begins at the evaluation point, similarly to creation of a usual named value initialized with an expression.</p>  <p>Termination of lifetime of temporaries does not obey the customary scoping rules and is defined as follows:</p>  <ul>
<li>If: <ol>
<li>the full expression has a smallest short-circuit expression <i>expr</i>; and</li> <li>the temporary is created on the right-hand side of the <code>&amp;&amp;</code> or <code>||</code> operator; and</li> <li>the right-hand side is evaluated,</li>
</ol> then temporary destructors are evaluated right after the right-hand side expression has been evaluated and converted to <code>bool</code>. Evaluation of destructors proceeds in reverse order of construction.</li>  <li>For all other cases, the temporaries generated for the purpose of invoking functions are deferred to the end of the full expression. The order of destruction is inverse to the order of construction.</li>
</ul>  <p>If a subexpression of an expression throws an exception, all temporaries created up to the evaluation of that subexpression will be destroyed per the rules above. No destructor calls will be issued for temporaries not yet constructed.</p>  <p>Note: An intuition behind these rules is that destructors of temporaries are deferred to the end of full expression and in reverse order of construction, with the exception that the right-hand side of <code>&amp;&amp;</code> and <code>||</code> are considered their own full expressions even when part of larger expressions.</p>  <p>Note: The ternary expression <i>e<sub>1</sub> ? e<sub>2</sub> : e<sub>3</sub></i> is not a special case although it evaluates expressions conditionally: <i>e<sub>1</sub></i> and one of <i>e<sub>2</sub></i> and <i>e<sub>3</sub></i> may create temporaries. Their destructors are inserted to the end of the full expression in the reverse order of creation.</p>  <p>Example:</p>   <pre data-language="d">import std.stdio;
struct S
{
    int x;
    this(int n) { x = n; writefln("S(%s)", x); }
    ~this() { writefln("~S(%s)", x); }
}
bool b = (S(1) == S(2) || S(3) != S(4)) &amp;&amp; S(5) == S(6);
</pre>   The output of the code above is:  <pre>S(1)
S(2)
S(3)
S(4)
~S(4)
~S(3)
S(5)
S(6)
~S(6)
~S(5)
~S(2)
~S(1)
</pre>  First, <code>S(1)</code> and <code>S(2)</code> are evaluated in lexical order. Per the rules, they will be destroyed at the end of the full expression and in reverse order. The comparison <code>S(1) == S(2)</code> yields <code>false</code>, so the right-hand side of the <code>||</code> is evaluated causing <code>S(3)</code> and <code>S(4)</code> to be evaluated, also in lexical order. However, their destruction is not deferred to the end of the full expression. Instead, <code>S(4)</code> and then <code>S(3)</code> are destroyed at the end of the <code>||</code> expression. Following their destruction, <code>S(5)</code> and <code>S(6)</code> are constructed in lexical order. Again they are not destroyed at the end of the full expression, but right at the end of the <code>&amp;&amp;</code> expression. Consequently, the destruction of <code>S(6)</code> and <code>S(5)</code> is carried before that of <code>S(2)</code> and <code>S(1)</code>.  <h2><span id="Expression">Expressions</span></h2>  <pre>Expression:
    CommaExpression

CommaExpression:
    AssignExpression
    AssignExpression , CommaExpression
</pre>  <p>The left operand of the <code>,</code> is evaluated, then the right operand is evaluated. The type of the expression is the type of the right operand, and the result is the result of the right operand. Using the result of comma expressions isn't allowed. </p>  <h2 id="assign_expressions">Assign Expressions</h2>  <pre>AssignExpression:
    ConditionalExpression
    ConditionalExpression = AssignExpression
    ConditionalExpression += AssignExpression
    ConditionalExpression -= AssignExpression
    ConditionalExpression *= AssignExpression
    ConditionalExpression /= AssignExpression
    ConditionalExpression %= AssignExpression
    ConditionalExpression &amp;= AssignExpression
    ConditionalExpression |= AssignExpression
    ConditionalExpression ^= AssignExpression
    ConditionalExpression ~= AssignExpression
    ConditionalExpression &lt;&lt;= AssignExpression
    ConditionalExpression &gt;&gt;= AssignExpression
    ConditionalExpression &gt;&gt;&gt;= AssignExpression
    ConditionalExpression ^^= AssignExpression
</pre>  <p>For all assign expressions, the left operand must be a modifiable lvalue. The type of the assign expression is the type of the left operand, and the value is the value of the left operand after assignment occurs. The resulting expression is a modifiable lvalue. </p>  <b>Undefined Behavior:</b> If either operand is a reference type and one of the following: <ol> <li>the operands have partially overlapping storage</li> <li>the operands' storage overlaps exactly but the types are different</li> </ol>  <b>Implementation Defined:</b> If neither operand is a reference type and one of the following: <ol> <li>the operands have partially overlapping storage</li> <li>the operands' storage overlaps exactly but the types are different</li> </ol>  <h3 id="simple_assignment_expressions">Simple Assignment Expression</h3>  <p>If the operator is <code>=</code> then it is simple assignment. The right operand is implicitly converted to the type of the left operand, and assigned to it.</p>  <p>If the left and right operands are of the same struct type, and the struct type has a <a href="struct.html#Postblit"><i>Postblit</i></a>, then the copy operation is as described in <a href="struct.html#struct-postblit">Struct Postblit</a>. </p>  <p>If the lvalue is the <code>.length</code> property of a dynamic array, the behavior is as described in <a href="array.html#resize">Setting Dynamic Array Length</a>. </p>  <p>If the lvalue is a static array or a slice, the behavior is as described in <a href="array.html#array-copying">Array Copying</a> and <a href="array.html#array-setting">Array Setting</a>. </p>  <p>If the lvalue is a user-defined property, the behavior is as described in <a href="function.html#property-functions">Property Functions</a>. </p>  <h3 id="assignment_operator_expressions">Assignment Operator Expressions</h3>  <p>For arguments of built-in types, assignment operator expressions such as</p>  <pre data-language="d">a op= b
</pre>  are semantically equivalent to:  <pre data-language="d">a = cast(typeof(a))(a op b)
</pre>  except that  <ul> <li>operand <code>a</code> is only evaluated once,</li> <li>overloading <i>op</i> uses a different function than overloading <i>op</i>= does, and</li> <li>the left operand of <code>&gt;&gt;&gt;=</code> does not undergo <a href="type.html#integer-promotions">Integer Promotions</a> before shifting.</li> </ul>  <p>For user-defined types, assignment operator expressions are overloaded separately from the binary operator. Still the left operand must be an lvalue. </p>  <h2 id="conditional_expressions">Conditional Expressions</h2>  <pre>ConditionalExpression:
    OrOrExpression
    OrOrExpression ? Expression : ConditionalExpression
</pre>  <p>The first expression is converted to <code>bool</code>, and is evaluated. </p>  <p>If it is <code>true</code>, then the second expression is evaluated, and its result is the result of the conditional expression. </p>  <p>If it is <code>false</code>, then the third expression is evaluated, and its result is the result of the conditional expression. </p>  <p>If either the second or third expressions are of type <code>void</code>, then the resulting type is <code>void</code>. Otherwise, the second and third expressions are implicitly converted to a common type which becomes the result type of the conditional expression. </p>  <p><b>Note:</b> When a conditional expression is the left operand of an <a href="#assign_expressions">assign expression</a>, parentheses are required for disambiguation: </p> <pre data-language="d">bool test;
int a, b, c;
...
test ? a = b : c = 2;   // Deprecated
(test ? a = b : c) = 2; // Equivalent
</pre>  <p>This makes the intent clearer, because the first statement can easily be misread as the following code: </p> <pre data-language="d">test ? a = b : (c = 2);
</pre>  <h2 id="oror_expressions">OrOr Expressions</h2>  <pre>OrOrExpression:
    AndAndExpression
    OrOrExpression || AndAndExpression
</pre>  <p>The result type of an <i>OrOrExpression</i> is <code>bool</code>, unless the right operand has type <code>void</code>, when the result is type <code>void</code>. </p>  <p>The <i>OrOrExpression</i> evaluates its left operand. </p>  <p>If the left operand, converted to type <code>bool</code>, evaluates to <code>true</code>, then the right operand is not evaluated. If the result type of the <i>OrOrExpression</i> is <code>bool</code> then the result of the expression is <code>true</code>. </p>  <p>If the left operand is <code>false</code>, then the right operand is evaluated. If the result type of the <i>OrOrExpression</i> is <code>bool</code> then the result of the expression is the right operand converted to type <code>bool</code>. </p>  <h2 id="andand_expressions">AndAnd Expressions</h2>  <pre>AndAndExpression:
    OrExpression
    AndAndExpression &amp;&amp; OrExpression
</pre>  <p>The result type of an <i>AndAndExpression</i> is <code>bool</code>, unless the right operand has type <code>void</code>, when the result is type <code>void</code>. </p>  <p>The <i>AndAndExpression</i> evaluates its left operand. </p>  <p>If the left operand, converted to type <code>bool</code>, evaluates to <code>false</code>, then the right operand is not evaluated. If the result type of the <i>AndAndExpression</i> is <code>bool</code> then the result of the expression is <code>false</code>. </p>  <p>If the left operand is <code>true</code>, then the right operand is evaluated. If the result type of the <i>AndAndExpression</i> is <code>bool</code> then the result of the expression is the right operand converted to type <code>bool</code>. </p>  <h2 id="bitwise_expressions">Bitwise Expressions</h2>  <p>Bit wise expressions perform a bitwise operation on their operands. Their operands must be integral types. First, the <a href="type.html#usual-arithmetic-conversions">Usual Arithmetic Conversions</a> are done. Then, the bitwise operation is done. </p>  <h3 id="or_expressions">Or Expressions</h3>  <pre>OrExpression:
    XorExpression
    OrExpression | XorExpression
</pre>  <p>The operands are OR'd together.</p>  <h3 id="xor_expressions">Xor Expressions</h3>  <pre>XorExpression:
    AndExpression
    XorExpression ^ AndExpression
</pre>  <p>The operands are XOR'd together.</p>  <h3 id="and_expressions">And Expressions</h3>  <pre>AndExpression:
    CmpExpression
    AndExpression &amp; CmpExpression
</pre>  <p>The operands are AND'd together.</p>  <h2 id="compare_expressions">Compare Expressions</h2>  <pre>CmpExpression:
    ShiftExpression
    EqualExpression
    IdentityExpression
    RelExpression
    InExpression
</pre>  <h2 id="equality_expressions">Equality Expressions</h2>  <pre>EqualExpression:
    ShiftExpression == ShiftExpression
    ShiftExpression != ShiftExpression
</pre>  <p>Equality expressions compare the two operands for equality (<code>==</code>) or inequality (<code>!=</code>). The type of the result is <code>bool</code>. </p>  <p>Inequality is defined as the logical negation of equality.</p>  <p>If the operands are integral values, the <a href="type.html#usual-arithmetic-conversions">Usual Arithmetic Conversions</a> are applied to bring them to a common type before comparison. Equality is defined as the bit patterns of the common type match exactly. </p>  <p>If the operands are pointers, equality is defined as the bit patterns of the operands match exactly. </p>  <p>For float, double, and real values, the <a href="type.html#usual-arithmetic-conversions">Usual Arithmetic Conversions</a> are applied to bring them to a common type before comparison. The values <code>-0</code> and <code>+0</code> are considered equal. If either or both operands are NAN, then <code>==</code> returns false and <code>!=</code> returns <code>true</code>. Otherwise, the bit patterns of the common type are compared for equality. </p>  <p>For complex numbers, equality is defined as equivalent to: </p> <pre data-language="d">x.re == y.re &amp;&amp; x.im == y.im
</pre>  <p>For struct objects, equality means the result of the <a href="operatoroverloading.html#equals"><code>opEquals()</code> member function</a>. If an <code>opEquals()</code> is not provided, equality is defined as the logical product of all equality results of the corresponding object fields. </p> <b>Implementation Defined:</b> The contents of any alignment gaps in the struct object.  <b>Best Practices:</b> If there are overlapping fields, which happens with unions, the default equality will compare each of the overlapping fields. An <code>opEquals()</code> can account for which of the overlapping fields contains valid data. An <code>opEquals()</code> can override the default behavior of floating point NaN values always comparing as unequal. Be careful using <code>memcmp()</code> to implement <code>opEquals()</code> if: <ul> <li>there are any alignment gaps</li> <li>if any fields have an <code>opEquals()</code>
</li> <li>there are any floating point fields that may contain NaN or <code>-0</code> values</li> </ul>   <p>For class and struct objects, the expression <code>(a == b)</code> is rewritten as <code>a.opEquals(b)</code>, and <code>(a != b)</code> is rewritten as <code>!a.opEquals(b)</code>. </p>  <p>For class objects, the <code>==</code> and <code>!=</code> operators are intended to compare the contents of the objects, however an appropriate <code>opEquals</code> override must be defined for this to work. The default <code>opEquals</code> provided by the root <code>Object</code> class is equivalent to the <code>is</code> operator. Comparing against <code>null</code> is invalid, as <code>null</code> has no contents. Use the <code>is</code> and <code>!is</code> operators instead.</p>  <pre data-language="d">class C;
C c;
if (c == null)  // error
    ...
if (c is null)  // ok
    ...
</pre>  <p>For static and dynamic arrays, equality is defined as the lengths of the arrays matching, and all the elements are equal. </p>  <h3 id="identity_expressions">Identity Expressions</h3>  <pre>IdentityExpression:
    ShiftExpression is ShiftExpression
    ShiftExpression !is ShiftExpression
</pre>  <p>The <code>is</code> compares for identity. To compare for nonidentity, use <code>e1 !is e2</code>. The type of the result is <code>bool</code>. The operands undergo the <a href="type.html#usual-arithmetic-conversions">Usual Arithmetic Conversions</a> to bring them to a common type before comparison. </p>  <p>For class objects, identity is defined as the object references are for the same object. Null class objects can be compared with <code>is</code>. </p>  <p>For struct objects and floating point values, identity is defined as the bits in the operands being identical. </p>  <p>For static and dynamic arrays, identity is defined as referring to the same array elements and the same number of elements. </p>  <p>For other operand types, identity is defined as being the same as equality. </p>  <p>The identity operator <code>is</code> cannot be overloaded. </p>  <h2 id="relation_expressions">Relational Expressions</h2>  <pre>RelExpression:
    ShiftExpression &lt; ShiftExpression
    ShiftExpression &lt;= ShiftExpression
    ShiftExpression &gt; ShiftExpression
    ShiftExpression &gt;= ShiftExpression
</pre>  <p>First, the <a href="type.html#usual-arithmetic-conversions">Usual Arithmetic Conversions</a> are done on the operands. The result type of a relational expression is <code>bool</code>. </p>  <p>For class objects, the result of Object.opCmp() forms the left operand, and 0 forms the right operand. The result of the relational expression (o1 op o2) is:</p>  <pre data-language="d">(o1.opCmp(o2) op 0)
</pre>  <p>It is an error to compare objects if one is <code>null</code>.</p>  <p>For static and dynamic arrays, the result of the relational op is the result of the operator applied to the first non-equal element of the array. If two arrays compare equal, but are of different lengths, the shorter array compares as "less" than the longer array. </p>  <h3 id="integer_comparisons">Integer comparisons</h3>  <p>Integer comparisons happen when both operands are integral types. </p>  <table>
<caption>Integer comparison operators</caption> <tr>
<th class="donthyphenate"><b>Operator</b></th>
<th class="donthyphenate"><b>Relation</b></th>
</tr> <tr>
<td><code>&lt;</code></td>
<td>less</td>
</tr> <tr>
<td><code>&gt;</code></td>
<td>greater</td>
</tr> <tr>
<td>
<code>&lt;</code><code>=</code>
</td>
<td>less or equal</td>
</tr> <tr>
<td><code>&gt;=</code></td>
<td>greater or equal</td>
</tr> <tr>
<td><code>==</code></td>
<td>equal</td>
</tr> <tr>
<td><code>!=</code></td>
<td>not equal</td>
</tr> </table>  <p>It is an error to have one operand be signed and the other unsigned for a <code>&lt;</code>, <code>&lt;</code><code>=</code>, <code>&gt;</code> or <code>&gt;</code><code>=</code> expression. Use casts to make both operands signed or both operands unsigned. </p>  <h3><span id="floating_point_comparisons">Floating point comparisons</span></h3>  <p>If one or both operands are floating point, then a floating point comparison is performed. </p>  <p>A relational operator can have <code>NaN</code> operands. If either or both operands is <code>NaN</code>, the floating point comparison operation returns as follows:</p>  <table>
<caption>Floating point comparison operators</caption> <tr>
<th class="donthyphenate"><b>Operator</b></th>
<th class="donthyphenate"><b>Relation</b></th>
<th class="donthyphenate"><b>Returns</b></th>
</tr> <tr>
<td><code>&lt;</code></td>
<td>less</td>
<td><code>false</code></td>
</tr> <tr>
<td><code>&gt;</code></td>
<td>greater</td>
<td><code>false</code></td>
</tr> <tr>
<td>
<code>&lt;</code><code>=</code>
</td>
<td>less or equal</td>
<td><code>false</code></td>
</tr> <tr>
<td><code>&gt;=</code></td>
<td>greater or equal</td>
<td><code>false</code></td>
</tr> <tr>
<td><code>==</code></td>
<td>equal</td>
<td><code>false</code></td>
</tr> <tr>
<td><code>!=</code></td>
<td>unordered, less, or greater</td>
<td><code>true</code></td>
</tr> </table>  <h3><span id="class_comparisons">Class comparisons</span></h3>  <p>For class objects, the relational operators compare the contents of the objects. Therefore, comparing against <code>null</code> is invalid, as <code>null</code> has no contents.</p>  <pre data-language="d">class C;
C c;
if (c &lt; null)  // error
    ...
</pre>  <h2 id="in_expressions">In Expressions</h2>  <pre>InExpression:
    ShiftExpression in ShiftExpression
    ShiftExpression !in ShiftExpression
</pre>  <p>An associative array can be tested to see if an element is in the array:</p>  <pre data-language="d">int foo[string];
...
if ("hello" in foo)
    ...
</pre>  <p>The <code>in</code> expression has the same precedence as the relational expressions <code>&lt;</code>, <code>&lt;</code><code>=</code>, etc. The return value of the <i>InExpression</i> is <code>null</code> if the element is not in the array; if it is in the array it is a pointer to the element. </p>  <p>The <code>!in</code> expression is the logical negation of the <code>in</code> operation. </p>  <h2 id="shift_expressions">Shift Expressions</h2>  <pre>ShiftExpression:
    AddExpression
    ShiftExpression &lt;&lt; AddExpression
    ShiftExpression &gt;&gt; AddExpression
    ShiftExpression &gt;&gt;&gt; AddExpression
</pre>  <p>The operands must be integral types, and undergo the <a href="type.html#integer-promotions">Integer Promotions</a>. The result type is the type of the left operand after the promotions. The result value is the result of shifting the bits by the right operand's value. </p>  <p><code>&lt;</code><code>&lt;</code> is a left shift. <code>&gt;</code><code>&gt;</code> is a signed right shift. <code>&gt;</code><code>&gt;</code><code>&gt;</code> is an unsigned right shift. </p>  <p>It's illegal to shift by the same or more bits than the size of the quantity being shifted:</p>  <pre data-language="d">int c;
auto x = c &lt;&lt; 33;        // error
</pre>  <h2 id="add_expressions">Add Expressions</h2>  <pre>AddExpression:
    MulExpression
    AddExpression + MulExpression
    AddExpression - MulExpression
    CatExpression
</pre>  <p>If the operands are of integral types, they undergo the <a href="type.html#usual-arithmetic-conversions">Usual Arithmetic Conversions</a>, and then are brought to a common type using the <a href="type.html#usual-arithmetic-conversions">Usual Arithmetic Conversions</a>. </p>  <p>If either operand is a floating point type, the other is implicitly converted to floating point and they are brought to a common type via the <a href="type.html#usual-arithmetic-conversions">Usual Arithmetic Conversions</a>. </p>  <p>If the operator is <code>+</code> or <code>-</code>, and the first operand is a pointer, and the second is an integral type, the resulting type is the type of the first operand, and the resulting value is the pointer plus (or minus) the second operand multiplied by the size of the type pointed to by the first operand. </p>  <p>If the second operand is a pointer, and the first is an integral type, and the operator is <code>+</code>, the operands are reversed and the pointer arithmetic just described is applied. </p>  <p>If both operands are pointers, and the operator is <code>+</code>, then it is illegal. </p>  <p>If both operands are pointers, and the operator is <code>-</code>, the pointers are subtracted and the result is divided by the size of the type pointed to by the operands. In this calculation the assumed size of <code>void</code> is one byte. It is an error if the pointers point to different types. The type of the result is <code>ptrdiff_t</code>. </p>  <p>If both operands are of integral types and an overflow or underflow occurs in the computation, wrapping will happen. For example, <code>uint.max + 1 == uint.min</code>, <code>uint.min - 1 == uint.max</code>, <code>int.max + 1 == int.min</code>, and <code>int.min - 1 == int.max</code>. </p>  <p>Add expressions for floating point operands are not associative. </p>  <h2 id="cat_expressions">Cat Expressions</h2>  <pre>CatExpression:
    AddExpression ~ MulExpression
</pre>  <p>A <i>CatExpression</i> concatenates arrays, producing a dynamic array with the result. The arrays must be arrays of the same element type. If one operand is an array and the other is of that array's element type, that element is converted to an array of length 1 of that element, and then the concatenation is performed. </p>  <h2 id="mul_expressions">Mul Expressions</h2>  <pre>MulExpression:
    UnaryExpression
    MulExpression * UnaryExpression
    MulExpression / UnaryExpression
    MulExpression % UnaryExpression
</pre>  <p>The operands must be arithmetic types. They undergo the <a href="type.html#usual-arithmetic-conversions">Usual Arithmetic Conversions</a>. </p>  <p>For integral operands, the <code>*</code>, <code>/</code>, and <code>%</code> correspond to multiply, divide, and modulus operations. For multiply, overflows are ignored and simply chopped to fit into the integral type. </p>  <p>For integral operands of the <code>/</code> and <code>%</code> operators, the quotient rounds towards zero and the remainder has the same sign as the dividend. </p>  <p>The following divide or modulus integral operands:</p>  <ul> <li>denominator is 0</li> <li>signed <code>int.min</code> is the numerator and <code>-1</code> is the denominator</li> <li>signed <code>long.min</code> is the numerator and <code>-1L</code> is the denominator</li> </ul>  <p>are illegal if encountered during Compile Time Execution.</p>  <b>Undefined Behavior:</b> is exhibited if they are encountered during run time. <a href="https://dlang.org/phobos/core_checkedint.html"><code>core.checkedint</code></a> can be used to check for them and select a defined behavior.   <p>For floating point operands, the * and / operations correspond to the IEEE 754 floating point equivalents. % is not the same as the IEEE 754 remainder. For example, 15.0 % 10.0 == 5.0, whereas for IEEE 754, remainder(15.0,10.0) == -5.0. </p>  <p>Mul expressions for floating point operands are not associative. </p>  <h2><span id="UnaryExpression">Unary Expressions</span></h2>  <pre>UnaryExpression:
    &amp; UnaryExpression
    ++ UnaryExpression
    -- UnaryExpression
    * UnaryExpression
    - UnaryExpression
    + UnaryExpression
    ! UnaryExpression
    ComplementExpression
    ( Type ) . Identifier
    ( Type ) . TemplateInstance
    DeleteExpression
    CastExpression
    PowExpression
</pre>  <h3 id="complement_expressions">Complement Expressions</h3>  <pre>ComplementExpression:
    ~ UnaryExpression
</pre>  <p><i>ComplementExpression</i>s work on integral types (except <code>bool</code>). All the bits in the value are complemented. </p>  <p><b>Note:</b> the usual <a href="type.html#integer-promotions">Integer Promotions</a> are not performed prior to the complement operation. </p>  <h3 id="new_expressions">New Expressions</h3>  <pre>NewExpression:
    new AllocatorArgumentsopt Type
    NewExpressionWithArgs

NewExpressionWithArgs:
    new AllocatorArgumentsopt Type [ AssignExpression ]
    new AllocatorArgumentsopt Type ( ArgumentListopt )
    NewAnonClassExpression

AllocatorArguments:
    ( ArgumentListopt )

ArgumentList:
    AssignExpression
    AssignExpression ,
    AssignExpression , ArgumentList
</pre>  <p><i>NewExpression</i>s are used to allocate memory on the garbage collected heap (default) or using a class or struct specific allocator. </p>  <p>To allocate multidimensional arrays, the declaration reads in the same order as the prefix array declaration order.</p>  <pre data-language="d">char[][] foo;   // dynamic array of strings
...
foo = new char[][30]; // allocate array of 30 strings
</pre>  <p>The above allocation can also be written as:</p>  <pre data-language="d">foo = new char[][](30); // allocate array of 30 strings
</pre>  <p>To allocate the nested arrays, multiple arguments can be used:</p>  <pre data-language="d">int[][][] bar;
...
bar = new int[][][](5, 20, 30);
</pre>  The code above is equivalent to:  <pre data-language="d">bar = new int[][][5];
foreach (ref a; bar)
{
    a = new int[][20];
    foreach (ref b; a)
    {
        b = new int[30];
    }
}
</pre>  <p>If there is a <code>new (</code> <a href="#ArgumentList"><i>ArgumentList</i></a> <code>)</code>, then those arguments are passed to the class or struct specific <a href="class.html#allocators">allocator function</a> after the size argument. </p>  <p>If a <i>NewExpression</i> is used as an initializer for a function local variable with <code>scope</code> storage class, and the <a href="#ArgumentList"><i>ArgumentList</i></a> to <code>new</code> is empty, then the instance is allocated on the stack rather than the heap or using the class specific allocator. </p>  <h3 id="delete_expressions">Delete Expressions</h3>  <pre>DeleteExpression:
    delete UnaryExpression
</pre> <p>NOTE: <code>delete</code> has been deprecated. Instead, please use <a href="https://dlang.org/phobos/object.html#destroy"><code>destroy</code></a> if feasible, or <a href="https://dlang.org/phobos/core_memory.html#__delete"><code>core.memory.__delete</code></a> as a last resort.</p>  <p>If the <i>UnaryExpression</i> is a class object reference, and there is a destructor for that class, the destructor is called for that object instance. </p>  <p>Next, if the <i>UnaryExpression</i> is a class object reference, or a pointer to a struct instance, and the class or struct has overloaded operator delete, then that operator delete is called for that class object instance or struct instance. </p>  <p>Otherwise, the garbage collector is called to immediately free the memory allocated for the class instance or struct instance. </p>  <p>If the <i>UnaryExpression</i> is a pointer or a dynamic array, the garbage collector is called to immediately release the memory. </p>  <p>The pointer, dynamic array, or reference is set to <code>null</code> after the delete is performed. Any attempt to reference the data after the deletion via another reference to it will result in undefined behavior. </p>  <p>If <i>UnaryExpression</i> is a variable allocated on the stack, the class destructor (if any) is called for that instance. Neither the garbage collector nor any class deallocator is called. </p>  <b>Undefined Behavior:</b> <ol> <li>Using <code>delete</code> to free memory not allocated by the garbage collector.</li> <li>Referring to data that has been the operand of <code>delete</code>.</li> </ol>  <h3 id="cast_expressions">Cast Expressions</h3>  <pre>CastExpression:
    cast ( Type ) UnaryExpression
    cast ( TypeCtorsopt ) UnaryExpression
</pre>  <p>A <i>CastExpression</i> converts the <i>UnaryExpression</i> to <a href="type.html#Type"><i>Type</i></a>.</p>  <pre data-language="d">cast(foo) -p; // cast (-p) to type foo
(foo) - p;      // subtract p from foo
</pre>  <p>Any casting of a class reference to a derived class reference is done with a runtime check to make sure it really is a downcast. <code>null</code> is the result if it isn't. </p>  <pre data-language="d">class A { ... }
class B : A { ... }

void test(A a, B b)
{
    B bx = a;         // error, need cast
    B bx = cast(B) a; // bx is null if a is not a B
    A ax = b;         // no cast needed
    A ax = cast(A) b; // no runtime check needed for upcast
}
</pre>  <p>In order to determine if an object <code>o</code> is an instance of a class <code>B</code> use a cast:</p>  <pre data-language="d">if (cast(B) o)
{
    // o is an instance of B
}
else
{
    // o is not an instance of B
}
</pre>  <p>Casting a pointer type to and from a class type is done as a type paint (i.e. a reinterpret cast). </p>  <p>Casting a dynamic array to another dynamic array is done only if the array lengths multiplied by the element sizes match. The cast is done as a type paint, with the array length adjusted to match any change in element size. If there's not a match, a runtime error is generated.</p>  <pre data-language="d">import std.stdio;

int main()
{
    byte[] a = [1,2,3];
    auto b = cast(int[])a; // runtime array cast misalignment

    int[] c = [1, 2, 3];
    auto d = cast(byte[])c; // ok
    // prints:
    // [1, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0]
    writeln(d);
    return 0;
}
</pre>   <p>Casting a static array to another static array is done only if the array lengths multiplied by the element sizes match; a mismatch is illegal. The cast is done as a type paint (aka a reinterpret cast). The contents of the array are not changed.</p>  <pre data-language="d">import core.stdc.stdio;

void main()
{
    byte[16] b = 3;
    int[4] ia = cast(int[4]) b;
    foreach (i; ia)
        printf("%x\n", i);
    /* prints:
       3030303
       3030303
       3030303
       3030303
     */
}
</pre>  <p>Casting a floating point literal from one type to another changes its type, but internally it is retained at full precision for the purposes of constant folding.</p>  <pre data-language="d">void test()
{
    real a = 3.40483L;
    real b;
    b = 3.40483;     // literal is not truncated to double precision
    assert(a == b);
    assert(a == 3.40483);
    assert(a == 3.40483L);
    assert(a == 3.40483F);
    double d = 3.40483; // truncate literal when assigned to variable
    assert(d != a);     // so it is no longer the same
    const double x = 3.40483; // assignment to const is not
    assert(x == a);     // truncated if the initializer is visible
}
</pre>  <p>Casting a floating point value to an integral type is the equivalent of converting to an integer using truncation.</p>  <pre data-language="d">void main()
{
    int a = cast(int) 0.8f;
    assert(a == 0);
    long b = cast(long) 1.5;
    assert(b == 1L);
    long c = cast(long) -1.5;
    assert(c == -1);
}
</pre>  <p>Casting a value <i>v</i> to a struct <i>S</i>, when value is not a struct of the same type, is equivalent to:</p>  <pre data-language="d">S(v)
</pre>  <p>Casting to a <a href="#CastQual"><i>CastQual</i></a> replaces the qualifiers to the type of the <a href="#UnaryExpression"><i>UnaryExpression</i></a>.</p>  <pre data-language="d">shared int x;
assert(is(typeof(cast(const)x) == const int));
</pre>  <p>Casting with no <a href="#Type"><i>Type</i></a> or <a href="#CastQual"><i>CastQual</i></a> removes any top level <code>const</code>, <code>immutable</code>, <code>shared</code> or <code>inout</code> type modifiers from the type of the <a href="#UnaryExpression"><i>UnaryExpression</i></a>.</p>  <pre data-language="d">shared int x;
assert(is(typeof(cast()x) == int));
</pre>  <p>Casting an expression to <code>void</code> type is allowed to mark that the result is unused. On <a href="statement.html#ExpressionStatement"><i>ExpressionStatement</i></a>, it could be used properly to avoid "has no effect" error.</p>  <pre data-language="d">void foo(lazy void exp) {}
void main()
{
    foo(10);            // NG - has no effect in expression '10'
    foo(cast(void)10);  // OK
}
</pre>  <h2 id="pow_expressions">Pow Expressions</h2>  <pre>PowExpression:
    PostfixExpression
    PostfixExpression ^^ UnaryExpression
</pre>  <p><i>PowExpression</i> raises its left operand to the power of its right operand. </p>  <h2 id="postfix_expressions">Postfix Expressions</h2>  <pre>PostfixExpression:
    PrimaryExpression
    PostfixExpression . Identifier
    PostfixExpression . TemplateInstance
    PostfixExpression . NewExpression
    PostfixExpression ++
    PostfixExpression --
    PostfixExpression ( ArgumentListopt )
    TypeCtorsopt BasicType ( ArgumentListopt )
    IndexExpression
    SliceExpression
</pre>  <h2 id="index_expressions">Index Expressions</h2>  <pre>IndexExpression:
    PostfixExpression [ ArgumentList ]
</pre>  <p><i>PostfixExpression</i> is evaluated. If <i>PostfixExpression</i> is an expression of type static array or dynamic array, the symbol &amp;dollar; is set to be the number of elements in the array. If <i>PostfixExpression</i> is a <i>ValueSeq</i>, the symbol &amp;dollar; is set to be the number of elements in the sequence. A new declaration scope is created for the evaluation of the <a href="#ArgumentList"><i>ArgumentList</i></a> and &amp;dollar; appears in that scope only.</p>  <p>If <i>PostfixExpression</i> is a <i>ValueSeq</i>, then the <a href="#ArgumentList"><i>ArgumentList</i></a> must consist of only one argument, and that must be statically evaluatable to an integral constant. That integral constant <i>n</i> then selects the <i>n</i>th expression in the <i>ValueSeq</i>, which is the result of the <i>IndexExpression</i>. It is an error if <i>n</i> is out of bounds of the <i>ValueSeq</i>. </p>  <h2 id="slice_expressions">Slice Expressions</h2>  <pre>SliceExpression:
    PostfixExpression [ ]
    PostfixExpression [ Slice ,opt ]
Slice:
    AssignExpression
    AssignExpression , Slice
    AssignExpression .. AssignExpression
    AssignExpression .. AssignExpression , Slice
</pre>  <p><i>PostfixExpression</i> is evaluated. if <i>PostfixExpression</i> is an expression of type static array or dynamic array, the special variable &amp;dollar; is declared and set to be the length of the array. A new declaration scope is created for the evaluation of the <a href="#AssignExpression"><i>AssignExpression</i></a>..<a href="#AssignExpression"><i>AssignExpression</i></a> and &amp;dollar; appears in that scope only. </p>  <p>The first <i>AssignExpression</i> is taken to be the inclusive lower bound of the slice, and the second <i>AssignExpression</i> is the exclusive upper bound. The result of the expression is a slice of the <i>PostfixExpression</i> array. </p>  <p>If the <code>[ ]</code> form is used, the slice is of the entire array. </p>  <p>The type of the slice is a dynamic array of the element type of the <i>PostfixExpression</i>. </p>  <p>A <i>SliceExpression</i> is not a modifiable lvalue.</p>  <p>If the slice bounds can be known at compile time, the slice expression is implicitly convertible to an lvalue of static array. For example:</p>  <pre data-language="d">arr[a .. b]     // typed T[]
</pre>  If both <code>a</code> and <code>b</code> are integers (may be constant-folded), the slice expression can be converted to a static array type <code>T[b - a]</code>.  <pre data-language="d">void foo(int[2] a)
{
    assert(a == [2, 3]);
}
void bar(ref int[2] a)
{
    assert(a == [2, 3]);
    a[0] = 4;
    a[1] = 5;
    assert(a == [4, 5]);
}
void baz(int[3] a) {}

void main()
{
    int[] arr = [1, 2, 3];

    foo(arr[1 .. 3]);
    assert(arr == [1, 2, 3]);

    bar(arr[1 .. 3]);
    assert(arr == [1, 4, 5]);

  //baz(arr[1 .. 3]); // cannot match length
}
</pre>  <p>The following forms of slice expression can be convertible to a static array type:</p>  <dl> <dt><code>e</code></dt> <dd>An expression that contains no side effects.</dd> <dt>
<code>a</code>, <code>b</code>
</dt> <dd>Integers (that may be constant-folded).</dd> </dl>  <table>
<caption>Computing array lengths during compilation</caption> <tr>
<th class="donthyphenate"><b>Form</b></th>
<th class="donthyphenate"><b>The length calculated at compile time</b></th>
</tr> <tr>
<td><code>arr[]</code></td>
<td>The compile time length of <code>arr</code> if it's known.</td>
</tr> <tr>
<td><code>arr[a .. b]</code></td>
<td> <code>b - a</code>
</td>
</tr> <tr>
<td><code>arr[e-a .. e]</code></td>
<td> <code>a</code>
</td>
</tr> <tr>
<td><code>arr[e .. e+b]</code></td>
<td> <code>b</code>
</td>
</tr> <tr>
<td><code>arr[e-a .. e+b]</code></td>
<td><code>a + b</code></td>
</tr> <tr>
<td><code>arr[e+a .. e+b]</code></td>
<td>
<code>b - a</code> <i>if</i> <code>a &lt;= b</code>
</td>
</tr> <tr>
<td><code>arr[e-a .. e-b]</code></td>
<td>
<code>a - b</code> <i>if</i> <code>a &gt;= b</code>
</td>
</tr> </table>  <p>If <i>PostfixExpression</i> is a <i>ValueSeq</i>, then the result of the slice is a new <i>ValueSeq</i> formed from the upper and lower bounds, which must statically evaluate to integral constants. It is an error if those bounds are out of range. </p>  <h2 id="primary_expressions">Primary Expressions</h2>  <pre>PrimaryExpression:
    Identifier
    . Identifier
    TemplateInstance
    . TemplateInstance
    this
    super
    null
    true
    false
    $
    IntegerLiteral
    FloatLiteral
    CharacterLiteral
    StringLiterals
    ArrayLiteral
    AssocArrayLiteral
    FunctionLiteral
    AssertExpression
    MixinExpression
    ImportExpression
    NewExpressionWithArgs
    FundamentalType . Identifier
    FundamentalType ( ArgumentListopt )
    TypeCtor ( Type ) . Identifier
    TypeCtor ( Type ) ( ArgumentListopt )
    Typeof
    TypeidExpression
    IsExpression
    ( Expression )
    SpecialKeyword
    TraitsExpression
</pre>  <h3 id="identifier">.Identifier</h3>  <p><a href="lex.html#Identifier"><i>Identifier</i></a> is looked up at module scope, rather than the current lexically nested scope. </p>  <h3 id="this">this</h3>  <p>Within a non-static member function, <code>this</code> resolves to a reference to the object for which the function was called. If the object is an instance of a struct, <code>this</code> will be a pointer to that instance. If a member function is called with an explicit reference to <code>typeof(this)</code>, a non-virtual call is made:</p>  <pre data-language="d">class A
{
    char get() { return 'A'; }

    char foo() { return typeof(this).get(); }
    char bar() { return this.get(); }
}

class B : A
{
    override char get() { return 'B'; }
}

void main()
{
    B b = new B();

    assert(b.foo() == 'A');
    assert(b.bar() == 'B');
}
</pre>  <p>Assignment to <code>this</code> is not allowed.</p>  <h3 id="super">super</h3>  <p><code>super</code> is identical to <code>this</code>, except that it is cast to <code>this</code>'s base class. It is an error if there is no base class. It is an error to use <code>super</code> within a struct member function. (Only class <code>Object</code> has no base class.) If a member function is called with an explicit reference to <code>super</code>, a non-virtual call is made. </p>  <p>Assignment to <code>super</code> is not allowed.</p>  <h3 id="null">null</h3>  <p><code>null</code> represents the null value for pointers, pointers to functions, delegates, dynamic arrays, associative arrays, and class objects. If it has not already been cast to a type, it is given the singular type <code>typeof(null)</code> and it is an exact conversion to convert it to the null value for pointers, pointers to functions, delegates, etc. After it is cast to a type, such conversions are implicit, but no longer exact. </p>  <h3 id="true_false">true, false</h3>  <p>These are of type <code>bool</code> and when cast to another integral type become the values 1 and 0, respectively. </p>  <h3><span id="CharacterLiteral">Character Literals</span></h3>  <p>Character literals are single characters and resolve to one of type <code>char</code>, <code>wchar</code>, or <code>dchar</code>. If the literal is a <code>\u</code> escape sequence, it resolves to type <code>wchar</code>. If the literal is a <code>\U</code> escape sequence, it resolves to type <code>dchar</code>. Otherwise, it resolves to the type with the smallest size it will fit into. </p>  <h3 id="string_literals">String Literals</h3>  <pre>StringLiterals:
    StringLiteral
    StringLiterals StringLiteral
</pre>  <p>String literals can implicitly convert to any of the following types, they have equal weight: </p>  <table> <tr><td><code>immutable(char)*</code></td></tr> <tr><td><code>immutable(wchar)*</code></td></tr> <tr><td><code>immutable(dchar)*</code></td></tr> <tr><td><code>immutable(char)[]</code></td></tr> <tr><td><code>immutable(wchar)[]</code></td></tr> <tr><td><code>immutable(dchar)[]</code></td></tr> </table>  <p>By default, a string literal is typed as a dynamic array, but the element count is known at compile time. So all string literals can be implicitly converted to static array types.</p>  <pre data-language="d">void foo(char[2] a)
{
    assert(a == "bc");
}
void bar(ref const char[2] a)
{
    assert(a == "bc");
}
void baz(const char[3] a) {}

void main()
{
    string str = "abc";
    foo(str[1 .. 3]);
    bar(str[1 .. 3]);
  //baz(str[1 .. 3]); // cannot match length
}
</pre>  <p>String literals have a 0 appended to them, which makes them easy to pass to C or C++ functions expecting a <code>const char*</code> string. The 0 is not included in the <code>.length</code> property of the string literal. </p>  <h3 id="array_literals">Array Literals</h3>  <pre>ArrayLiteral:
    [ ArgumentListopt ]
</pre>  <p>Array literals are a comma-separated list of <a href="#AssignExpression"><i>AssignExpression</i></a>s between square brackets <code>[</code> and <code>]</code>. The <i>AssignExpression</i>s form the elements of a dynamic array, the length of the array is the number of elements. The common type of the all elements is taken to be the type of the array element, and all elements are implicitly converted to that type.</p>  <pre data-language="d">auto a1 = [1,2,3];  // type is int[], with elements 1, 2 and 3
auto a2 = [1u,2,3]; // type is uint[], with elements 1u, 2u, and 3u
</pre>  <p>By default, an array literal is typed as a dynamic array, but the element count is known at compile time. So all array literals can be implicitly converted to static array types.</p>  <pre data-language="d">void foo(long[2] a)
{
    assert(a == [2, 3]);
}
void bar(ref long[2] a)
{
    assert(a == [2, 3]);
    a[0] = 4;
    a[1] = 5;
    assert(a == [4, 5]);
}
void baz(const char[3] a) {}

void main()
{
    long[] arr = [1, 2, 3];

    foo(arr[1 .. 3]);
    assert(arr == [1, 2, 3]);

    bar(arr[1 .. 3]);
    assert(arr == [1, 4, 5]);

  //baz(arr[1 .. 3]); // cannot match length
}
</pre>  <p>If any of the arguments in the <a href="#ArgumentList"><i>ArgumentList</i></a> are a <i>ValueSeq</i>, then the elements of the <i>ValueSeq</i> are inserted as arguments in place of the sequence. </p>  <p>Array literals are allocated on the memory managed heap. Thus, they can be returned safely from functions:</p>  <pre data-language="d">int[] foo()
{
    return [1, 2, 3];
}
</pre>  <p>When array literals are cast to another array type, each element of the array is cast to the new element type. When arrays that are not literals are cast, the array is reinterpreted as the new type, and the length is recomputed:</p>  <pre data-language="d">import std.stdio;

void main()
{
    // cast array literal
    const short[] ct = cast(short[]) [cast(byte)1, 1];
    // this is equivalent with:
    // const short[] ct = [cast(short)1, cast(short)1];
    writeln(ct);  // writes [1, 1]

    // cast other array expression
    // --&gt; normal behavior of CastExpression
    byte[] arr = [cast(byte)1, cast(byte)1];
    short[] rt = cast(short[]) arr;
    writeln(rt);  // writes [257]
}
</pre>  In other words, casting literal expression will change the literal type.  <h3 id="associative_array_literals">Associative Array Literals</h3>  <pre>AssocArrayLiteral:
    [ KeyValuePairs ]

KeyValuePairs:
    KeyValuePair
    KeyValuePair , KeyValuePairs

KeyValuePair:
    KeyExpression : ValueExpression

KeyExpression:
    AssignExpression

ValueExpression:
    AssignExpression
</pre>  <p>Associative array literals are a comma-separated list of <i>key</i><code>:</code><i>value</i> pairs between square brackets <code>[</code> and <code>]</code>. The list cannot be empty. The common type of the all keys is taken to be the key type of the associative array, and all keys are implicitly converted to that type. The common type of the all values is taken to be the value type of the associative array, and all values are implicitly converted to that type. An <i>AssocArrayLiteral</i> cannot be used to statically initialize anything.</p>  <pre data-language="d">[21u:"he", 38:"ho", 2:"hi"];  // type is string[uint],
                              // with keys 21u, 38u and 2u
                              // and values "he", "ho", and "hi"
</pre>  <p>If any of the keys or values in the <i>KeyValuePairs</i> are a <i>ValueSeq</i>, then the elements of the <i>ValueSeq</i> are inserted as arguments in place of the sequence. </p>  <h3 id="function_literals">Function Literals</h3>  <pre>FunctionLiteral:
    function refopt Typeopt ParameterWithAttributes opt FunctionLiteralBody2
    delegate refopt Typeopt ParameterWithMemberAttributes opt FunctionLiteralBody2
    refopt ParameterWithMemberAttributes FunctionLiteralBody2
    FunctionLiteralBody
    Identifier =&gt; AssignExpression

ParameterWithAttributes:
    Parameters FunctionAttributesopt

ParameterWithMemberAttributes:
    Parameters MemberFunctionAttributesopt

FunctionLiteralBody2:
    =&gt; AssignExpression
    FunctionLiteralBody

FunctionLiteralBody:
    BlockStatement
    FunctionContractsopt BodyStatement
</pre>  <p id="lambdas"><i>FunctionLiteral</i>s (also known as <i>Lambdas</i>) enable embedding anonymous functions and anonymous delegates directly into expressions. <i>Type</i> is the return type of the function or delegate, if omitted it is inferred from any <i>ReturnStatement</i>s in the <i>FunctionLiteralBody</i>. <a href="#ParameterWithAttributes"><i>ParameterWithAttributes</i></a> or <a href="#ParameterWithMemberAttributes"><i>ParameterWithMemberAttributes</i></a> can be used to specify the parameters for the function. If these are omitted, the function defaults to the empty parameter list <code>( )</code>. The type of a function literal is pointer to function or pointer to delegate. If the keywords <code>function</code> or <code>delegate</code> are omitted, it is inferred from whether <i>FunctionLiteralBody</i> is actually accessing to the outer context. </p>  <p>For example:</p>  <pre data-language="d">int function(char c) fp; // declare pointer to a function

void test()
{
    static int foo(char c) { return 6; }

    fp = &amp;foo;
}
</pre>  is exactly equivalent to:  <pre data-language="d">int function(char c) fp;

void test()
{
    fp = function int(char c) { return 6;} ;
}
</pre>  <p>Also:</p>  <pre data-language="d">int abc(int delegate(int i));

void test()
{
    int b = 3;
    int foo(int c) { return 6 + b; }

    abc(&amp;foo);
}
</pre>  is exactly equivalent to:  <pre data-language="d">int abc(int delegate(int i));

void test()
{
    int b = 3;

    abc( delegate int(int c) { return 6 + b; } );
}
</pre>  <p>and the following where the return type <code>int</code> and <code>function</code>/<code>delegate</code> are inferred:</p>  <pre data-language="d">int abc(int delegate(int i));
int def(int function(int s));

void test()
{
    int b = 3;

    abc( (int c) { return 6 + b; } );  // inferred to delegate
    def( (int c) { return c * 2; } );  // inferred to function
  //def( (int c) { return c * b; } );  // error!
    // Because the FunctionLiteralBody accesses b, then the function literal type
    // is inferred to delegate. But def cannot receive delegate.
}
</pre>  <p>If the type of a function literal can be uniquely determined from its context, the parameter type inference is possible.</p>  <pre data-language="d">void foo(int function(int) fp);

void test()
{
    int function(int) fp = (n) { return n * 2; };
    // The type of parameter n is inferred to int.

    foo((n) { return n * 2; });
    // The type of parameter n is inferred to int.
}
</pre>  <p>Anonymous delegates can behave like arbitrary statement literals. For example, here an arbitrary statement is executed by a loop:</p>  <pre data-language="d">double test()
{
    double d = 7.6;
    float f = 2.3;

    void loop(int k, int j, void delegate() statement)
    {
        for (int i = k; i &lt; j; i++)
        {
            statement();
        }
    }

    loop(5, 100, { d += 1; });
    loop(3, 10,  { f += 3; });

    return d + f;
}
</pre>  <p>The syntax <code>=&gt; AssignExpression</code> is equivalent to <code>{ return AssignExpression; }</code>.</p>  <p>The syntax <code>Identifier =&gt; AssignExpression</code> is equivalent to <code>(Identifier) { return AssignExpression; }</code>.</p>  <p>Example usage:</p>  <pre data-language="d">import std.stdio;

void main()
{
    auto i = 3;
    auto twice  = function (int x) =&gt; x * 2;
    auto square = delegate (int x) =&gt; x * x;

    auto n = 5;
    auto mul_n = (int x) =&gt; x * n;

    writeln(twice(i));   // prints 6
    writeln(square(i));  // prints 9
    writeln(mul_n(i));   // prints 15
}
</pre>   <p>When comparing with <a href="function.html#nested">nested functions</a>, the <code>function</code> form is analogous to static or non-nested functions, and the <code>delegate</code> form is analogous to non-static nested functions. In other words, a delegate literal can access stack variables in its enclosing function, a function literal cannot. </p>  <h3 id="uniform_construction_syntax">Uniform construction syntax for built-in scalar types</h3>  <p>The implicit conversions of built-in scalar types can be explicitly represented by using function call syntax. For example:</p>  <pre data-language="d">auto a = short(1);  // implicitly convert an integer literal '1' to short
auto b = double(a); // implicitly convert a short variable 'a' to double
auto c = byte(128); // error, 128 cannot be represented in a byte
</pre>  <p>If the argument is omitted, it means default construction of the scalar type:</p>  <pre data-language="d">auto a = ushort();  // same as: ushort.init
auto b = wchar();   // same as: wchar.init
auto c = creal();   // same as: creal.init
</pre>   <h3 id="assert_expressions">Assert Expressions</h3>  <pre>AssertExpression:
    assert ( AssertArguments )

AssertArguments:
    AssignExpression ,opt
    AssignExpression , AssignExpression ,opt
</pre>  <p>The first <i>AssignExpression</i> must evaluate to true. If it does not, an <i>Assert Failure</i> has occurred and the program enters an <i>Invalid State</i>. </p>  <p>If the first <i>AssignExpression</i> consists entirely of compile time constants, and evaluates to false, it is a special case; it signifies that it is unreachable code. Compile Time Function Execution (CTFE) is not attempted. </p>  <p><i>AssertExpression</i> has different semantics if it is in a <a href="unittest.html"><code>unittest</code></a> or <a href="contracts.html"><code>in</code> contract</a>. </p>  <p>The second <i>AssignExpression</i>, if present, must be implicitly convertible to type <code>const(char)[]</code>. </p>  <p>If the first <i>AssignExpression</i> is a reference to a class instance for which a <a href="class.html#invariants">Class Invariant</a> exists, the <i>Class Invariant</i> must hold. </p>  <p>If the first <i>AssignExpression</i> is a pointer to a struct instance for which a <i>Struct Invariant</i> exists, the <i>Struct Invariant</i> must hold. </p>  <p>The type of an <i>AssertExpression</i> is <code>void</code>. </p>  <b>Undefined Behavior:</b> Once in an <i>Invalid State</i> the behavior of the continuing execution of the program is undefined.  <b>Implementation Defined:</b> Whether the first <i>AssertExpression</i> is evaluated or not at runtime is typically set with a compiler switch. If it is not evaluated, any side effects specified by the <i>AssertExpression</i> may not occur. The behavior if the first <i>AssertExpression</i> is evaluated and is false is also typically set with a compiler switch and may include these options: <ol> <li>continuing execution</li> <li>immediately halting via execution of a special CPU instruction</li> <li>aborting the program</li> <li>calling the assert failure function in the corresponding C runtime library</li> <li>throwing the <code>AssertError</code> exception in the D runtime library</li> </ol> If the optional second <i>AssignExpression</i> is provided, the implementation may evaluate it and print the resulting message upon assert failure:  <pre data-language="d">void main()
{
    assert(0, "an" ~ " error message");
}
</pre>  <p>When compiled and run, it will produce the message:</p>  <pre>core.exception.AssertError@test.d(3) an error message</pre>  <p>The implementation may handle the case of the first <i>AssignExpression</i> evaluating at compile time to false differently in that in release mode it may simply generate a <code>HLT</code> instruction or equivalent. </p>   <b>Best Practices:</b> <ol> <li>Do not have side effects in either <i>AssignExpression</i> that subsequent code depends on.</li> <li>
<i>AssertExpressions</i> are intended to detect bugs in the program, do not use for detecting input or environmental errors.</li> <li>Do not attempt to resume normal execution after an <i>Assert Failure</i>.</li> </ol>   <h3 id="mixin_expressions">Mixin Expressions</h3>  <pre>MixinExpression:
    mixin ( ArgumentList )
</pre>  <p>Each <a href="#AssignExpression"><i>AssignExpression</i></a> in the <i>ArgumentList</i> is evaluated at compile time, and the result must be representable as a string. The resulting strings are concatenated to form a string. The text contents of the string must be compilable as a valid <a href="#Expression"><i>Expression</i></a>, and is compiled as such.</p>  <pre data-language="d">int foo(int x)
{
    return mixin("x +", 1) * 7;  // same as ((x + 1) * 7)
}
</pre>  <h3 id="import_expressions">Import Expressions</h3>  <pre>ImportExpression:
    import ( AssignExpression )
</pre>  <p>The <i>AssignExpression</i> must evaluate at compile time to a constant string. The text contents of the string are interpreted as a file name. The file is read, and the exact contents of the file become a string literal. </p>  <p>Implementations may restrict the file name in order to avoid directory traversal security vulnerabilities. A possible restriction might be to disallow any path components in the file name. </p>  <p>Note that by default an import expression will not compile unless one or more paths are passed via the <b>-J</b> switch. This tells the compiler where it should look for the files to import. This is a security feature.</p>  <pre data-language="d">void foo()
{
    // Prints contents of file foo.txt
    writeln(import("foo.txt"));
}
</pre>  <h3 id="typeid_expressions">Typeid Expressions</h3>  <pre>TypeidExpression:
    typeid ( Type )
    typeid ( Expression )
</pre>  <p>If <i>Type</i>, returns an instance of class <a href="https://dlang.org/phobos/object.html"><code>TypeInfo</code></a> corresponding to <i>Type</i>. </p>  <p>If <i>Expression</i>, returns an instance of class <a href="https://dlang.org/phobos/object.html"><code>TypeInfo</code></a> corresponding to the type of the <i>Expression</i>. If the type is a class, it returns the <code>TypeInfo</code> of the dynamic type (i.e. the most derived type). The <i>Expression</i> is always executed.</p>  <pre data-language="d">class A { }
class B : A { }

void main()
{
    writeln(typeid(int));        // int
    uint i;
    writeln(typeid(i++));        // uint
    writeln(i);                  // 1
    A a = new B();
    writeln(typeid(a));          // B
    writeln(typeid(typeof(a)));  // A
}
</pre>  <h3 id="is_expression">IsExpression</h3>  <pre>IsExpression:
    is ( Type )
    is ( Type : TypeSpecialization )
    is ( Type == TypeSpecialization )
    is ( Type : TypeSpecialization , TemplateParameterList )
    is ( Type == TypeSpecialization , TemplateParameterList )
    is ( Type Identifier )
    is ( Type Identifier : TypeSpecialization )
    is ( Type Identifier == TypeSpecialization )
    is ( Type Identifier : TypeSpecialization , TemplateParameterList )
    is ( Type Identifier == TypeSpecialization , TemplateParameterList )


TypeSpecialization:
    Type
    struct
    union
    class
    interface
    enum
    __vector
    function
    delegate
    super
    const
    immutable
    inout
    shared
    return
    __parameters
    module
    package
</pre>  <p><i>IsExpression</i>s are evaluated at compile time and are used for checking for valid types, comparing types for equivalence, determining if one type can be implicitly converted to another, and deducing the subtypes of a type. The result of an <i>IsExpression</i> is a boolean of value <code>true</code> if the condition is satisfied. If the condition is not satisfied, the result is a boolean of value <code>false</code>. </p>  <p><i>Type</i> is the type being tested. It must be syntactically correct, but it need not be semantically correct. If it is not semantically correct, the condition is not satisfied. </p>  <p><a href="lex.html#Identifier"><i>Identifier</i></a> is declared to be an alias of the resulting type if the condition is satisfied. The <a href="lex.html#Identifier"><i>Identifier</i></a> forms can only be used if the <i>IsExpression</i> appears in a <a href="version.html#StaticIfCondition"><i>StaticIfCondition</i></a>. </p>  <p><i>TypeSpecialization</i> is the type that <i>Type</i> is being compared against. </p>  <p>The forms of the <i>IsExpression</i> are: </p>  <ol> <li>
<code>is (</code> <i>Type</i> <code>)</code><br> The condition is satisfied if <code>Type</code> is semantically correct (it must be syntactically correct regardless).  <pre data-language="d">alias int func(int);    // func is a alias to a function type
void foo()
{
    if (is(func[]))     // not satisfied because arrays of
                        // functions are not allowed
        writeln("satisfied");
    else
        writeln("not satisfied");

    if (is([][]))       // error, [][] is not a syntactically valid type
        ...
}
</pre> </li>  <li>
<code>is (</code> <i>Type</i> <code>:</code> <i>TypeSpecialization</i> <code>)</code><br> The condition is satisfied if <i>Type</i> is semantically correct and it is the same as or can be implicitly converted to <i>TypeSpecialization</i>. <i>TypeSpecialization</i> is only allowed to be a <i>Type</i>.  <pre data-language="d">alias Bar = short;
void foo()
{
    if (is(Bar : int))   // satisfied because short can be
                         // implicitly converted to int
        writeln("satisfied");
    else
        writeln("not satisfied");
}
</pre> </li>  <li>
<code>is (</code> <i>Type</i> <code>==</code> <i>TypeSpecialization</i> <code>)</code><br>  The condition is satisfied if <i>Type</i> is semantically correct and is the same type as <i>TypeSpecialization</i>.  If <i>TypeSpecialization</i> is one of  <code>struct</code> <code>union</code> <code>class</code> <code>interface</code> <code>enum</code> <code>function</code> <code>delegate</code> <code>const</code> <code>immutable</code> <code>shared</code> <code>module</code> <code>package</code>  then the condition is satisfied if <i>Type</i> is one of those. <a href="https://dlang.org/%20%20%20%20%20%20%20%20spec/module.html#package-module">Package modules</a> are considered to be both packages and modules.  <pre data-language="d">alias Bar = short;
void foo()
{
    if (is(Bar == int))   // not satisfied because short is not
                          // the same type as int
        writeln("satisfied");
    else
        writeln("not satisfied");
}
</pre> </li>  <li>
<code>is (</code> <i>Type</i> <i>Identifier</i> <code>)</code><br> The condition is satisfied if <i>Type</i> is semantically correct. If so, <i>Identifier</i> is declared to be an alias of <i>Type</i>.  <pre data-language="d">alias Bar = short;
void foo()
{
    static if (is(Bar T))
        alias S = T;
    else
        alias S = long;

    writeln(typeid(S)); // prints "short"
    if (is(Bar T))      // error, Identifier T form can
                        // only be in StaticIfConditions
        ...
}
</pre> </li>  <li>
<code>is (</code> <i>Type</i> <i>Identifier</i> <code>:</code> <i>TypeSpecialization</i> <code>)</code><br>  The condition is satisfied if <i>Type</i> is the same as <i>TypeSpecialization</i>, or if <i>Type</i> is a class and <i>TypeSpecialization</i> is a base class or base interface of it. The <i>Identifier</i> is declared to be either an alias of the <i>TypeSpecialization</i> or, if <i>TypeSpecialization</i> is dependent on <i>Identifier</i>, the deduced type.  <pre data-language="d">alias Bar = int;
alias Abc = long*;
void foo()
{
    static if (is(Bar T : int))
        alias S = T;
    else
        alias S = long;

    writeln(typeid(S));  // prints "int"

    static if (is(Abc U : U*))
    {
        U u;
        writeln(typeid(typeof(u)));  // prints "long"
    }
}
</pre>  The way the type of <i>Identifier</i> is determined is analogous to the way template parameter types are determined by <a href="template.html#TemplateTypeParameterSpecialization"><i>TemplateTypeParameterSpecialization</i></a>. </li>  <li>
<code>is (</code> <i>Type</i> <i>Identifier</i> <code>==</code> <i>TypeSpecialization</i> <code>)</code><br>   The condition is satisfied if <i>Type</i> is semantically correct and is the same as <i>TypeSpecialization</i>. The <i>Identifier</i> is declared to be either an alias of the <i>TypeSpecialization</i> or, if <i>TypeSpecialization</i> is dependent on <i>Identifier</i>, the deduced type.  If <i>TypeSpecialization</i> is one of <code>struct</code> <code>union</code> <code>class</code> <code>interface</code> <code>enum</code> <code>function</code> <code>delegate</code> <code>const</code> <code>immutable</code> <code>shared</code>  then the condition is satisfied if <i>Type</i> is one of those. Furthermore, <i>Identifier</i> is set to be an alias of the type:  <table>
 <tr>
<th class="donthyphenate"><b>keyword</b></th>
<th class="donthyphenate"><b>alias type for <i>Identifier</i></b></th>
</tr>  <tr>
<td><code>struct</code></td>
<td><i>Type</i></td>
</tr> <tr>
<td><code>union</code></td>
<td><i>Type</i></td>
</tr> <tr>
<td><code>class</code></td>
<td><i>Type</i></td>
</tr> <tr>
<td><code>interface</code></td>
<td><i>Type</i></td>
</tr> <tr>
<td><code>super</code></td>
<td>
<i>TypeSeq</i> of base classes and interfaces</td>
</tr> <tr>
<td><code>enum</code></td>
<td>the base type of the enum</td>
</tr> <tr>
<td><code>function</code></td>
<td>
<i>TypeSeq</i> of the function parameter types. For C- and D-style variadic functions, only the non-variadic parameters are included. For typesafe variadic functions, the <code>...</code> is ignored.</td>
</tr> <tr>
<td><code>delegate</code></td>
<td>the function type of the delegate</td>
</tr> <tr>
<td><code>return</code></td>
<td>the return type of the function, delegate, or function pointer</td>
</tr> <tr>
<td><code>__parameters</code></td>
<td>the parameter sequence of a function, delegate, or function pointer. This includes the parameter types, names, and default values.</td>
</tr> <tr>
<td><code>const</code></td>
<td><i>Type</i></td>
</tr> <tr>
<td> <code>immutable</code>
</td>
<td> <i>Type</i> </td>
</tr> <tr>
<td> <code>shared</code>
</td>
<td> <i>Type</i> </td>
</tr>  </table>  <pre data-language="d">alias Bar = short;
enum E : byte { Emember }
void foo()
{
    static if (is(Bar T == int))   // not satisfied, short is not int
        alias S = T;
    alias U = T;                   // error, T is not defined

    static if (is(E V == enum))    // satisfied, E is an enum
        V v;                       // v is declared to be a byte
}
</pre>  </li>  <li>
<code>is (</code> <i>Type</i> <code>:</code> <i>TypeSpecialization</i> <code>,</code> <a href="template.html#TemplateParameterList"><i>TemplateParameterList</i></a> <code>)</code><br> <code>is (</code> <i>Type</i> <code>==</code> <i>TypeSpecialization</i> <code>,</code> <a href="template.html#TemplateParameterList"><i>TemplateParameterList</i></a> <code>)</code><br> <code>is (</code> <i>Type</i> <i>Identifier</i> <code>:</code> <i>TypeSpecialization</i> <code>,</code> <a href="template.html#TemplateParameterList"><i>TemplateParameterList</i></a> <code>)</code><br> <code>is (</code> <i>Type</i> <i>Identifier</i> <code>==</code> <i>TypeSpecialization</i> <code>,</code> <a href="template.html#TemplateParameterList"><i>TemplateParameterList</i></a> <code>)</code>  More complex types can be pattern matched; the <a href="template.html#TemplateParameterList"><i>TemplateParameterList</i></a> declares symbols based on the parts of the pattern that are matched, analogously to the way implied template parameters are matched.  <pre data-language="d">import std.stdio, std.typecons;

void main()
{
    alias Tup = Tuple!(int, string);
    alias AA = long[string];

    static if (is(Tup : Template!Args, alias Template, Args...))
    {
        writeln(__traits(isSame, Template, Tuple)); // true
        writeln(is(Template!(int, string) == Tup));  // true
        writeln(typeid(Args[0]));  // int
        writeln(typeid(Args[1]));  // immutable(char)[]
    }

    static if (is(AA T : T[U], U : string))
    {
        writeln(typeid(T));  // long
        writeln(typeid(U));  // string
    }

    static if (is(AA A : A[B], B : int))
    {
        assert(0);  // should not match, as B is not an int
    }

    static if (is(int[10] W : W[len], int len))
    {
        writeln(typeid(W));  // int
        writeln(len);        // 10
    }

    static if (is(int[10] X : X[len], int len : 5))
    {
        assert(0);  // should not match, len should be 10
    }
}
</pre>  </li>  </ol>  <h2 id="specialkeywords">Special Keywords</h2>  <pre>SpecialKeyword:
    __FILE__
    __FILE_FULL_PATH__
    __MODULE__
    __LINE__
    __FUNCTION__
    __PRETTY_FUNCTION__
</pre>   <p><code>__FILE__</code> and <code>__LINE__</code> expand to the source file name and line number at the point of instantiation. The path of the source file is left up to the compiler. </p>  <p><code>__FILE_FULL_PATH__</code> expands to the absolute source file name at the point of instantiation.</p>  <p><code>__MODULE__</code> expands to the module name at the point of instantiation.</p>  <p><code>__FUNCTION__</code> expands to the fully qualified name of the function at the point of instantiation.</p>  <p><code>__PRETTY_FUNCTION__</code> is similar to <code>__FUNCTION__</code>, but also expands the function return type, its parameter types, and its attributes.</p>  <p>Example:</p>  <pre data-language="d">module test;
import std.stdio;

void test(string file = __FILE__, size_t line = __LINE__,
        string mod = __MODULE__, string func = __FUNCTION__,
        string pretty = __PRETTY_FUNCTION__,
        string fileFullPath = __FILE_FULL_PATH__)
{
    writefln("file: '%s', line: '%s', module: '%s',\nfunction: '%s', " ~
        "pretty function: '%s',\nfile full path: '%s'",
        file, line, mod, func, pretty, fileFullPath);
}

int main(string[] args)
{
    test();
    return 0;
}
</pre>  <p>Assuming the file was at /example/test.d, this will output:</p>  <pre>file: 'test.d', line: '13', module: 'test',
function: 'test.main', pretty function: 'int test.main(string[] args)',
file full path: '/example/test.d'
</pre>  <h2 id="associativity">Associativity and Commutativity</h2>  <p>An implementation may rearrange the evaluation of expressions according to arithmetic associativity and commutativity rules as long as, within that thread of execution, no observable difference is possible. </p>  <p>This rule precludes any associative or commutative reordering of floating point expressions. </p>    <div class="_attribution">
  <p class="_attribution-p">
    &copy; 1999&ndash;2021 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/spec/expression.html" class="_attribution-link">https://dlang.org/spec/expression.html</a>
  </p>
</div>
