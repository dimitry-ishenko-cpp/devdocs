<h1>std.exception</h1>  <p>This module defines functions related to exceptions and general error handling. It also defines functions intended to aid in unit testing. </p>
<p> <table>

<tr>
<th scope="col">Category</th> <th scope="col">Functions</th>
</tr> <tr>
<td>Assumptions</td> <td> <a href="#assertNotThrown"><code>assertNotThrown</code></a> <a href="#assertThrown"><code>assertThrown</code></a> <a href="#assumeUnique"><code>assumeUnique</code></a> <a href="#assumeWontThrow"><code>assumeWontThrow</code></a> <a href="#mayPointTo"><code>mayPointTo</code></a> </td>
</tr> <tr>
<td>Enforce</td> <td> <a href="#doesPointTo"><code>doesPointTo</code></a> <a href="#enforce"><code>enforce</code></a> <a href="#errnoEnforce"><code>errnoEnforce</code></a> </td>
</tr> <tr>
<td>Handlers</td> <td> <a href="#collectException"><code>collectException</code></a> <a href="#collectExceptionMsg"><code>collectExceptionMsg</code></a> <a href="#ifThrown"><code>ifThrown</code></a> <a href="#handle"><code>handle</code></a> </td>
</tr> <tr>
<td>Other</td> <td> <a href="#basicExceptionCtors"><code>basicExceptionCtors</code></a> <a href="#emptyExceptionMsg"><code>emptyExceptionMsg</code></a> <a href="#ErrnoException"><code>ErrnoException</code></a> <a href="#RangePrimitive"><code>RangePrimitive</code></a> </td>
</tr> </table> </p> <dl>
<dt>License:</dt>
<dd>
<a href="http://boost.org/LICENSE_1_0.txt">Boost License 1.0</a> </dd>
</dl> <dl>
<dt>Authors:</dt>
<dd>
<a href="http://erdani.org">Andrei Alexandrescu</a> and <a href="http://jmdavisprog.com">Jonathan M Davis</a> </dd>
</dl> <dl>
<dt>Source</dt>
<dd> <span class="phobos_src"><a class="https" href="https://github.com/dlang/phobos/blob/master/std/exception.d">std/exception.d</a></span>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Synopis <pre data-language="d">import core.stdc.stdlib : malloc, free;
import std.algorithm.comparison : equal;
import std.algorithm.iteration : map, splitter;
import std.algorithm.searching : endsWith;
import std.conv : ConvException, to;
import std.range : front, retro;

// use enforce like assert
int a = 3;
enforce(a &gt; 2, "a needs to be higher than 2.");

// enforce can throw a custom exception
enforce!ConvException(a &gt; 2, "a needs to be higher than 2.");

// enforce will return it's input
enum size = 42;
auto memory = enforce(malloc(size), "malloc failed")[0 .. size];
scope(exit) free(memory.ptr);

// collectException can be used to test for exceptions
Exception e = collectException("abc".to!int);
assert(e.file.endsWith("conv.d"));

// and just for the exception message
string msg = collectExceptionMsg("abc".to!int);
writeln(msg); // "Unexpected 'a' when converting from type string to type int"

// assertThrown can be used to assert that an exception is thrown
assertThrown!ConvException("abc".to!int);

// ifThrown can be used to provide a default value if an exception is thrown
writeln("x".to!int().ifThrown(0)); // 0

// handle is a more advanced version of ifThrown for ranges
auto r = "12,1337z32,54".splitter(',').map!(a =&gt; to!int(a));
auto h = r.handle!(ConvException, RangePrimitive.front, (e, r) =&gt; 0);
assert(h.equal([12, 0, 54]));
assertThrown!ConvException(h.retro.equal([54, 0, 12]));

// basicExceptionCtors avoids the boilerplate when creating custom exceptions
static class MeaCulpa : Exception
{
    mixin basicExceptionCtors;
}
e = collectException((){throw new MeaCulpa("diagnostic message");}());
writeln(e.msg); // "diagnostic message"
writeln(e.file); // __FILE__
writeln(e.line); // __LINE__ - 3

// assumeWontThrow can be used to cast throwing code into `nothrow`
void exceptionFreeCode() nothrow
{
    // auto-decoding only throws if an invalid UTF char is given
    assumeWontThrow("abc".front);
}

// assumeUnique can be used to cast mutable instance to an `immutable` one
// use with care
char[] str = "  mutable".dup;
str[0 .. 2] = "im";
immutable res = assumeUnique(str);
writeln(res); // "immutable"
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="assertNotThrown">auto <strong id="assertNotThrown">assertNotThrown</strong>(T : Throwable = Exception, E)(lazy E expression, string msg = null, string file = __FILE__, size_t line = __LINE__); </dt> <dd>
<p>Asserts that the given expression does <i>not</i> throw the given type of <code>Throwable</code>. If a <code>Throwable</code> of the given type is thrown, it is caught and does not escape assertNotThrown. Rather, an <code>AssertError</code> is thrown. However, any other <code>Throwable</code>s will escape. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T</td> <td>The <code>Throwable</code> to test for.</td>
</tr> <tr>
<td>E <code>expression</code>
</td> <td>The expression to test.</td>
</tr> <tr>
<td>string <code>msg</code>
</td> <td>Optional message to output on test failure. If msg is empty, and the thrown exception has a non-empty msg field, the exception's msg field will be output on test failure.</td>
</tr> <tr>
<td>string <code>file</code>
</td> <td>The file where the error occurred. Defaults to <code>__FILE__</code>.</td>
</tr> <tr>
<td>size_t <code>line</code>
</td> <td>The line where the error occurred. Defaults to <code>__LINE__</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<code>AssertError</code> if the given <code>Throwable</code> is thrown. </dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>the result of <code>expression</code>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import core.exception : AssertError;

import std.string;
assertNotThrown!StringException(enforce!StringException(true, "Error!"));

//Exception is the default.
assertNotThrown(enforce!StringException(true, "Error!"));

assert(collectExceptionMsg!AssertError(assertNotThrown!StringException(
           enforce!StringException(false, "Error!"))) ==
       `assertNotThrown failed: StringException was thrown: Error!`);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="assertThrown">void <strong id="assertThrown">assertThrown</strong>(T : Throwable = Exception, E)(lazy E expression, string msg = null, string file = __FILE__, size_t line = __LINE__); </dt> <dd>
<p>Asserts that the given expression throws the given type of <code>Throwable</code>. The <code>Throwable</code> is caught and does not escape assertThrown. However, any other <code>Throwable</code>s <i>will</i> escape, and if no <code>Throwable</code> of the given type is thrown, then an <code>AssertError</code> is thrown. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T</td> <td>The <code>Throwable</code> to test for.</td>
</tr> <tr>
<td>E <code>expression</code>
</td> <td>The expression to test.</td>
</tr> <tr>
<td>string <code>msg</code>
</td> <td>Optional message to output on test failure.</td>
</tr> <tr>
<td>string <code>file</code>
</td> <td>The file where the error occurred. Defaults to <code>__FILE__</code>.</td>
</tr> <tr>
<td>size_t <code>line</code>
</td> <td>The line where the error occurred. Defaults to <code>__LINE__</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<code>AssertError</code> if the given <code>Throwable</code> is not thrown.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import core.exception : AssertError;
import std.string;

assertThrown!StringException(enforce!StringException(false, "Error!"));

//Exception is the default.
assertThrown(enforce!StringException(false, "Error!"));

assert(collectExceptionMsg!AssertError(assertThrown!StringException(
           enforce!StringException(true, "Error!"))) ==
       `assertThrown failed: No StringException was thrown.`);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="enforce">template <strong id="enforce">enforce</strong>(E : Throwable = Exception) if (is(typeof(new E("", string.init, size_t.init)) : Throwable) || is(typeof(new E(string.init, size_t.init)) : Throwable))<br><br>T <strong id="enforce">enforce</strong>(T, Dg, string file = __FILE__, size_t line = __LINE__)(T value, scope Dg dg)<br><small>  Constraints: if (isSomeFunction!Dg &amp;&amp; is(typeof(dg())) &amp;&amp; is(typeof(() { if (!value) { } } ))); </small><br><br>T <strong id="enforce">enforce</strong>(T)(T value, lazy Throwable ex); </dt> <dd>
<p>Enforces that the given value is true. If the given value is false, an exception is thrown. The <ul> <li>
<code>msg</code> - error message as a <code>string</code>
</li> <li>
<code>dg</code> - custom delegate that return a string and is only called if an exception occurred</li> <li>
<code>ex</code> - custom exception to be thrown. It is <code>lazy</code> and is only created if an exception occurred</li> </ul> </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T <code>value</code>
</td> <td>The value to test.</td>
</tr> <tr>
<td>E</td> <td>Exception type to throw if the value evaluates to false.</td>
</tr> <tr>
<td>const(char)[] msg</td> <td>The error message to put in the exception if it is thrown.</td>
</tr> <tr>
<td>Dg <code>dg</code>
</td> <td>The delegate to be called if the value evaluates to false.</td>
</tr> <tr>
<td>Throwable <code>ex</code>
</td> <td>The exception to throw if the value evaluates to false.</td>
</tr> <tr>
<td>string file</td> <td>The source file of the caller.</td>
</tr> <tr>
<td>size_t line</td> <td>The line number of the caller.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>value</code>, if <code>cast(bool) value</code> is true. Otherwise, depending on the chosen overload, <code>new Exception(msg)</code>, <code>dg()</code> or <code>ex</code> is thrown. </dd>
</dl> <dl>
<dt>Note</dt>
<dd> <code>enforce</code> is used to throw exceptions and is therefore intended to aid in error handling. It is <i>not</i> intended for verifying the logic of your program. That is what <code>assert</code> is for. Also, do not use <code>enforce</code> inside of contracts (i.e. inside of <code>in</code> and <code>out</code> blocks and <code>invariant</code>s), because contracts are compiled out when compiling with <i>-release</i>. </dd>
</dl> If a delegate is passed, the safety and purity of this function are inferred from <code>Dg</code>'s safety and purity. <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import core.stdc.stdlib : malloc, free;
import std.conv : ConvException, to;

// use enforce like assert
int a = 3;
enforce(a &gt; 2, "a needs to be higher than 2.");

// enforce can throw a custom exception
enforce!ConvException(a &gt; 2, "a needs to be higher than 2.");

// enforce will return it's input
enum size = 42;
auto memory = enforce(malloc(size), "malloc failed")[0 .. size];
scope(exit) free(memory.ptr);
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assertNotThrown(enforce(true, new Exception("this should not be thrown")));
assertThrown(enforce(false, new Exception("this should be thrown")));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(enforce(123)); // 123

try
{
    enforce(false, "error");
    assert(false);
}
catch (Exception e)
{
    writeln(e.msg); // "error"
    writeln(e.file); // __FILE__
    writeln(e.line); // __LINE__ - 7
}
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Alias your own enforce function <pre data-language="d">import std.conv : ConvException;
alias convEnforce = enforce!ConvException;
assertNotThrown(convEnforce(true));
assertThrown!ConvException(convEnforce(false, "blah"));
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="enforce.enforce">T <strong id="enforce">enforce</strong>(T)(T value, lazy const(char)[] msg = null, string file = __FILE__, size_t line = __LINE__)<br><small>  Constraints: if (is(typeof(() { if (!value) { } } ))); </small>
</dt>  </dl> </dd> <dt class="d_decl" id="errnoEnforce">alias <strong id="errnoEnforce">errnoEnforce</strong> = enforce!(ErrnoException).enforce(T)(T value, lazy const(char)[] msg = null, string file = __FILE__, size_t line = __LINE__) if (is(typeof(() { if (!value) { } } ))); </dt> <dd>
<p>Enforces that the given value is true, throwing an <code>ErrnoException</code> if it is not. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T value</td> <td>The value to test.</td>
</tr> <tr>
<td>const(char)[] msg</td> <td>The message to include in the <code>ErrnoException</code> if it is thrown.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>value</code>, if <code>cast(bool) value</code> is true. Otherwise, <code>new ErrnoException(msg)</code> is thrown. It is assumed that the last operation set <code>errno</code> to an error code corresponding with the failed condition.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import core.stdc.stdio : fclose, fgets, fopen;
import std.file : thisExePath;
import std.string : toStringz;

auto f = fopen(thisExePath.toStringz, "r").errnoEnforce;
scope(exit) fclose(f);
char[100] buf;
auto line = fgets(buf.ptr, buf.length, f);
enforce(line !is null); // expect a non-empty line
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="enforceEx">template <strong id="enforceEx">enforceEx</strong>(E : Throwable) if (is(typeof(new E("", string.init, size_t.init))))</dt> <dd>
<p><span class="red">Deprecated. Please use <a href="#enforce"><code>enforce</code></a> instead. This function will be removed 2.089.</span> </p>
<p>If <code>!value</code> is <code>false</code>, <code>value</code> is returned. Otherwise, <code>new E(msg, file, line)</code> is thrown. Or if <code>E</code> doesn't take a message and can be constructed with <code>new E(file, line)</code>, then <code>new E(file, line)</code> will be thrown. </p> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto f = enforceEx!FileMissingException(fopen("data.txt"));
auto line = readln(f);
enforceEx!DataCorruptionException(line.length);
</pre>  <dl>
<dt class="d_decl" id="enforceEx.enforceEx">T <strong id="enforceEx">enforceEx</strong>(T)(T value, lazy string msg = "", string file = __FILE__, size_t line = __LINE__); </dt> <dd>
<p>Ditto</p> </dd> </dl> </dd> <dt class="d_decl" id="collectException">T <strong id="collectException">collectException</strong>(T = Exception, E)(lazy E expression, ref E result); </dt> <dd>
<p>Catches and returns the exception thrown from the given expression. If no exception is thrown, then null is returned and <code>result</code> is set to the result of the expression. </p>
<p>Note that while <code>collectException</code> <i>can</i> be used to collect any <code>Throwable</code> and not just <code>Exception</code>s, it is generally ill-advised to catch anything that is neither an <code>Exception</code> nor a type derived from <code>Exception</code>. So, do not use <code>collectException</code> to collect non-<code>Exception</code>s unless you're sure that that's what you really want to do. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T</td> <td>The type of exception to catch.</td>
</tr> <tr>
<td>E <code>expression</code>
</td> <td>The expression which may throw an exception.</td>
</tr> <tr>
<td>E <code>result</code>
</td> <td>The result of the expression if no exception is thrown.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int b;
int foo() { throw new Exception("blah"); }
assert(collectException(foo(), b));

int[] a = new int[3];
import core.exception : RangeError;
assert(collectException!RangeError(a[4], b));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="collectException.2">T <strong id="collectException">collectException</strong>(T : Throwable = Exception, E)(lazy E expression); </dt> <dd>
<p>Catches and returns the exception thrown from the given expression. If no exception is thrown, then null is returned. <code>E</code> can be <code>void</code>. </p>
<p>Note that while <code>collectException</code> <i>can</i> be used to collect any <code>Throwable</code> and not just <code>Exception</code>s, it is generally ill-advised to catch anything that is neither an <code>Exception</code> nor a type derived from <code>Exception</code>. So, do not use <code>collectException</code> to collect non-<code>Exception</code>s unless you're sure that that's what you really want to do. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T</td> <td>The type of exception to catch.</td>
</tr> <tr>
<td>E <code>expression</code>
</td> <td>The expression which may throw an exception.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int foo() { throw new Exception("blah"); }
writeln(collectException(foo()).msg); // "blah"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="collectExceptionMsg">string <strong id="collectExceptionMsg">collectExceptionMsg</strong>(T = Exception, E)(lazy E expression); </dt> <dd>
<p>Catches the exception thrown from the given expression and returns the msg property of that exception. If no exception is thrown, then null is returned. <code>E</code> can be <code>void</code>. </p>
<p>If an exception is thrown but it has an empty message, then <code>emptyExceptionMsg</code> is returned. <br><br> Note that while <code>collectExceptionMsg</code> <i>can</i> be used to collect any <code>Throwable</code> and not just <code>Exception</code>s, it is generally ill-advised to catch anything that is neither an <code>Exception</code> nor a type derived from <code>Exception</code>. So, do not use <code>collectExceptionMsg</code> to collect non-<code>Exception</code>s unless you're sure that that's what you really want to do. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T</td> <td>The type of exception to catch.</td>
</tr> <tr>
<td>E <code>expression</code>
</td> <td>The expression which may throw an exception.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">void throwFunc() { throw new Exception("My Message."); }
writeln(collectExceptionMsg(throwFunc())); // "My Message."

void nothrowFunc() {}
assert(collectExceptionMsg(nothrowFunc()) is null);

void throwEmptyFunc() { throw new Exception(""); }
writeln(collectExceptionMsg(throwEmptyFunc())); // emptyExceptionMsg
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="emptyExceptionMsg">enum string <strong id="emptyExceptionMsg">emptyExceptionMsg</strong>; </dt> <dd>
<p>Value that collectExceptionMsg returns when it catches an exception with an empty exception message.</p> </dd> <dt class="d_decl" id="assumeUnique">pure nothrow immutable(T)[] <strong id="assumeUnique">assumeUnique</strong>(T)(T[] array); <br><br>pure nothrow immutable(T)[] <strong id="assumeUnique">assumeUnique</strong>(T)(ref T[] array); <br><br>pure nothrow immutable(T[U]) <strong id="assumeUnique">assumeUnique</strong>(T, U)(ref T[U] array); </dt> <dd>
<p>Casts a mutable array to an immutable array in an idiomatic manner. Technically, <code>assumeUnique</code> just inserts a cast, but its name documents assumptions on the part of the caller. <code>assumeUnique(arr)</code> should only be called when there are no more active mutable aliases to elements of <code> arr</code>. To strengthen this assumption, <code>assumeUnique(arr)</code> also clears <code>arr</code> before returning. Essentially <code> assumeUnique(arr)</code> indicates commitment from the caller that there is no more mutable access to any of <code>arr</code>'s elements (transitively), and that all future accesses will be done through the immutable array returned by <code>assumeUnique</code>. </p>
<p>Typically, <code>assumeUnique</code> is used to return arrays from functions that have allocated and built them. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T[] <code>array</code>
</td> <td>The array to cast to immutable.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The immutable array. </dd>
</dl> <dl>
<dt>Example</dt>

</dl> <pre data-language="d">string letters()
{
  char[] result = new char['z' - 'a' + 1];
  foreach (i, ref e; result)
  {
    e = cast(char)('a' + i);
  }
  return assumeUnique(result);
}
</pre>   The use in the example above is correct because <code>result</code> was private to <code>letters</code> and is inaccessible in writing after the function returns. The following example shows an incorrect use of <code>assumeUnique</code>.  <dl>
<dt>Bad</dt>

</dl> <pre data-language="d">private char[] buffer;
string letters(char first, char last)
{
  if (first &gt;= last) return null; // fine
  auto sneaky = buffer;
  sneaky.length = last - first + 1;
  foreach (i, ref e; sneaky)
  {
    e = cast(char)('a' + i);
  }
  return assumeUnique(sneaky); // BAD
}
</pre>   The example above wreaks havoc on client code because it is modifying arrays that callers considered immutable. To obtain an immutable array from the writable array <code>buffer</code>, replace the last line with:  <pre data-language="d">return to!(string)(sneaky); // not that sneaky anymore
</pre>  The call will duplicate the array appropriately.  Note that checking for uniqueness during compilation is possible in certain cases, especially when a function is marked as a pure function. The following example does not need to call assumeUnique because the compiler can infer the uniqueness of the array in the pure function:   <pre data-language="d">string letters() pure
{
  char[] result = new char['z' - 'a' + 1];
  foreach (i, ref e; result)
  {
    e = cast(char)('a' + i);
  }
  return result;
}
</pre>   For more on infering uniqueness see the <b>unique</b> and <b>lent</b> keywords in the <a href="http://www.cs.cmu.edu/~aldrich/papers/aldrich-dissertation.pdf">ArchJava</a> language.  The downside of using <code>assumeUnique</code>'s convention-based usage is that at this time there is no formal checking of the correctness of the assumption; on the upside, the idiomatic use of <code>assumeUnique</code> is simple and rare enough to be tolerable. <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int[] arr = new int[1];
auto arr1 = arr.assumeUnique;
static assert(is(typeof(arr1) == immutable(int)[]));
writeln(arr); // null
writeln(arr1); // [0]
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int[string] arr = ["a":1];
auto arr1 = arr.assumeUnique;
static assert(is(typeof(arr1) == immutable(int[string])));
writeln(arr); // null
writeln(arr1.keys); // ["a"]
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="assumeWontThrow">nothrow T <strong id="assumeWontThrow">assumeWontThrow</strong>(T)(lazy T expr, string msg = null, string file = __FILE__, size_t line = __LINE__); </dt> <dd>
<p>Wraps a possibly-throwing expression in a <code>nothrow</code> wrapper so that it can be called by a <code>nothrow</code> function. </p>
<p>This wrapper function documents commitment on the part of the caller that the appropriate steps have been taken to avoid whatever conditions may trigger an exception during the evaluation of <code>expr</code>. If it turns out that the expression <i>does</i> throw at runtime, the wrapper will throw an <code>AssertError</code>. <br><br> (Note that <code>Throwable</code> objects such as <code>AssertError</code> that do not subclass <code>Exception</code> may be thrown even from <code>nothrow</code> functions, since they are considered to be serious runtime problems that cannot be recovered from.) </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T <code>expr</code>
</td> <td>The expression asserted not to throw.</td>
</tr> <tr>
<td>string <code>msg</code>
</td> <td>The message to include in the <code>AssertError</code> if the assumption turns out to be false.</td>
</tr> <tr>
<td>string <code>file</code>
</td> <td>The source file name of the caller.</td>
</tr> <tr>
<td>size_t <code>line</code>
</td> <td>The line number of the caller.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The value of <code>expr</code>, if any.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.math : sqrt;

// This function may throw.
int squareRoot(int x)
{
    if (x &lt; 0)
        throw new Exception("Tried to take root of negative number");
    return cast(int) sqrt(cast(double) x);
}

// This function never throws.
int computeLength(int x, int y) nothrow
{
    // Since x*x + y*y is always positive, we can safely assume squareRoot
    // won't throw, and use it to implement this nothrow function. If it
    // does throw (e.g., if x*x + y*y overflows a 32-bit value), then the
    // program will terminate.
    return assumeWontThrow(squareRoot(x*x + y*y));
}

writeln(computeLength(3, 4)); // 5
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="doesPointTo">pure nothrow @nogc @trusted bool <strong id="doesPointTo">doesPointTo</strong>(S, T, Tdummy = void)(auto ref const S source, ref const T target)<br><small>  Constraints: if (__traits(isRef, source) || isDynamicArray!S || isPointer!S || is(S == class)); </small><br><br>pure nothrow @trusted bool <strong id="doesPointTo">doesPointTo</strong>(S, T)(auto ref const shared S source, ref const shared T target); <br><br>pure nothrow @trusted bool <strong id="mayPointTo">mayPointTo</strong>(S, T, Tdummy = void)(auto ref const S source, ref const T target)<br><small>  Constraints: if (__traits(isRef, source) || isDynamicArray!S || isPointer!S || is(S == class)); </small><br><br>pure nothrow @trusted bool <strong id="mayPointTo">mayPointTo</strong>(S, T)(auto ref const shared S source, ref const shared T target); </dt> <dd>
<p>Checks whether a given source object contains pointers or references to a given target object. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>S <code>source</code>
</td> <td>The source object</td>
</tr> <tr>
<td>T <code>target</code>
</td> <td>The target object</td>
</tr> </table></dd>
</dl> <dl>
<dt>Bugs:</dt>
<dd>The function is explicitly annotated <code>@nogc</code> because inference could fail, see <a href="https://issues.dlang.org/show_bug.cgi?id=17084">issue 17084</a>. </dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if <code>source</code>'s representation embeds a pointer that points to <code>target</code>'s representation or somewhere inside it.  If <code>source</code> is or contains a dynamic array, then, then these functions will check if there is overlap between the dynamic array and <code>target</code>'s representation.  If <code>source</code> is a class, then it will be handled as a pointer.  If <code>target</code> is a pointer, a dynamic array or a class, then these functions will only check if <code>source</code> points to <code>target</code>, <i>not</i> what <code>target</code> references.  If <code>source</code> is or contains a union or <code>void[n]</code>, then there may be either false positives or false negatives:  <code>doesPointTo</code> will return <code>true</code> if it is absolutely certain <code>source</code> points to <code>target</code>. It may produce false negatives, but never false positives. This function should be prefered when trying to validate input data.  <code>mayPointTo</code> will return <code>false</code> if it is absolutely certain <code>source</code> does not point to <code>target</code>. It may produce false positives, but never false negatives. This function should be prefered for defensively choosing a code path. </dd>
</dl> <dl>
<dt>Note</dt>
<dd> Evaluating <code>doesPointTo(x, x)</code> checks whether <code>x</code> has internal pointers. This should only be done as an assertive test, as the language is free to assume objects don't have internal pointers (TDPL 7.1.3.5).</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Pointers <pre data-language="d">int  i = 0;
int* p = null;
assert(!p.doesPointTo(i));
p = &amp;i;
assert( p.doesPointTo(i));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Structs and Unions <pre data-language="d">struct S
{
    int v;
    int* p;
}
int i;
auto s = S(0, &amp;i);

// structs and unions "own" their members
// pointsTo will answer true if one of the members pointsTo.
assert(!s.doesPointTo(s.v)); //s.v is just v member of s, so not pointed.
assert( s.p.doesPointTo(i)); //i is pointed by s.p.
assert( s  .doesPointTo(i)); //which means i is pointed by s itself.

// Unions will behave exactly the same. Points to will check each "member"
// individually, even if they share the same memory
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Arrays (dynamic and static) <pre data-language="d">int i;
 // trick the compiler when initializing slice
 // https://issues.dlang.org/show_bug.cgi?id=18637
int* p = &amp;i;
int[]  slice = [0, 1, 2, 3, 4];
int[5] arr   = [0, 1, 2, 3, 4];
int*[]  slicep = [p];
int*[1] arrp   = [&amp;i];

// A slice points to all of its members:
assert( slice.doesPointTo(slice[3]));
assert(!slice[0 .. 2].doesPointTo(slice[3])); // Object 3 is outside of the
                                              // slice [0 .. 2]

// Note that a slice will not take into account what its members point to.
assert( slicep[0].doesPointTo(i));
assert(!slicep   .doesPointTo(i));

// static arrays are objects that own their members, just like structs:
assert(!arr.doesPointTo(arr[0])); // arr[0] is just a member of arr, so not
                                  // pointed.
assert( arrp[0].doesPointTo(i));  // i is pointed by arrp[0].
assert( arrp   .doesPointTo(i));  // which means i is pointed by arrp
                                  // itself.

// Notice the difference between static and dynamic arrays:
assert(!arr  .doesPointTo(arr[0]));
assert( arr[].doesPointTo(arr[0]));
assert( arrp  .doesPointTo(i));
assert(!arrp[].doesPointTo(i));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Classes <pre data-language="d">class C
{
    this(int* p){this.p = p;}
    int* p;
}
int i;
C a = new C(&amp;i);
C b = a;

// Classes are a bit particular, as they are treated like simple pointers
// to a class payload.
assert( a.p.doesPointTo(i)); // a.p points to i.
assert(!a  .doesPointTo(i)); // Yet a itself does not point i.

//To check the class payload itself, iterate on its members:
()
{
    import std.traits : Fields;

    foreach (index, _; Fields!C)
        if (doesPointTo(a.tupleof[index], i))
            return;
    assert(0);
}();

// To check if a class points a specific payload, a direct memmory check
// can be done:
auto aLoc = cast(ubyte[__traits(classInstanceSize, C)]*) a;
assert(b.doesPointTo(*aLoc)); // b points to where a is pointing
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="ErrnoException">class <strong id="ErrnoException">ErrnoException</strong>: object.Exception; </dt> <dd>
<p>Thrown if errors that set <code>errno</code> occur.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import core.stdc.errno : EAGAIN;
auto ex = new ErrnoException("oh no", EAGAIN);
writeln(ex.errno); // EAGAIN
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>errno is used by default if no explicit error code is provided <pre data-language="d">import core.stdc.errno : errno, EAGAIN;

auto old = errno;
scope(exit) errno = old;

// fake that errno got set by the callee
errno = EAGAIN;
auto ex = new ErrnoException("oh no");
writeln(ex.errno); // EAGAIN
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="ErrnoException.errno">final pure nothrow @nogc @property @safe uint <strong id="errno">errno</strong>(); </dt> <dd>
<p>Operating system error code.</p> </dd> <dt class="d_decl" id="ErrnoException.this">@safe this(string msg, string file = null, size_t line = 0); </dt> <dd>
<p>Constructor which takes an error message. The current global <a href="core_stdc_errno.html#errno"><code>core.stdc.errno.errno</code></a> value is used as error code.</p> </dd> <dt class="d_decl" id="ErrnoException.this.2">@safe this(string msg, int errno, string file = null, size_t line = 0); </dt> <dd>
<p>Constructor which takes an error message and error code.</p> </dd> </dl> </dd> <dt class="d_decl" id="ifThrown">CommonType!(T1, T2) <strong id="ifThrown">ifThrown</strong>(E : Throwable = Exception, T1, T2)(lazy scope T1 expression, lazy scope T2 errorHandler); <br><br>CommonType!(T1, T2) <strong id="ifThrown">ifThrown</strong>(E : Throwable, T1, T2)(lazy scope T1 expression, scope T2 delegate(E) errorHandler); <br><br>CommonType!(T1, T2) <strong id="ifThrown">ifThrown</strong>(T1, T2)(lazy scope T1 expression, scope T2 delegate(Exception) errorHandler); </dt> <dd>
<p>ML-style functional exception handling. Runs the supplied expression and returns its result. If the expression throws a <code>Throwable</code>, runs the supplied error handler instead and return its result. The error handler's type must be the same as the expression's type. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>E</td> <td>The type of <code>Throwable</code>s to catch. Defaults to <code>Exception</code>
</td>
</tr> <tr>
<td>T1</td> <td>The type of the expression.</td>
</tr> <tr>
<td>T2</td> <td>The return type of the error handler.</td>
</tr> <tr>
<td>T1 <code>expression</code>
</td> <td>The expression to run and return its result.</td>
</tr> <tr>
<td>T2 <code>errorHandler</code>
</td> <td>The handler to run if the expression throwed.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>expression, if it does not throw. Otherwise, returns the result of errorHandler.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Revert to a default value upon an error: <pre data-language="d">import std.conv : to;
writeln("x".to!int.ifThrown(0)); // 0
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Chain multiple calls to ifThrown, each capturing errors from the entire preceding expression. <pre data-language="d">import std.conv : ConvException, to;
string s = "true";
assert(s.to!int.ifThrown(cast(int) s.to!double)
               .ifThrown(cast(int) s.to!bool) == 1);

s = "2.0";
assert(s.to!int.ifThrown(cast(int) s.to!double)
               .ifThrown(cast(int) s.to!bool) == 2);

// Respond differently to different types of errors
alias orFallback = (lazy a)  =&gt; a.ifThrown!ConvException("not a number")
                                 .ifThrown!Exception("number too small");

writeln(orFallback(enforce("x".to!int &lt; 1).to!string)); // "not a number"
writeln(orFallback(enforce("2".to!int &lt; 1).to!string)); // "number too small"
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>The expression and the errorHandler must have a common type they can both be implicitly casted to, and that type will be the type of the compound expression. <pre data-language="d">// null and new Object have a common type(Object).
static assert(is(typeof(null.ifThrown(new Object())) == Object));
static assert(is(typeof((new Object()).ifThrown(null)) == Object));

// 1 and new Object do not have a common type.
static assert(!__traits(compiles, 1.ifThrown(new Object())));
static assert(!__traits(compiles, (new Object()).ifThrown(1)));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Use a lambda to get the thrown object. <pre data-language="d">import std.format : format;
// "std.format.FormatException"
writeln("%s".format.ifThrown!Exception(e =&gt; e.classinfo.name));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="RangePrimitive">enum <strong id="RangePrimitive">RangePrimitive</strong>: int; </dt> <dd>
<p>This <code>enum</code> is used to select the primitives of the range to handle by the <a href="#handle"><code>handle</code></a> range wrapper. The values of the <code>enum</code> can be <code>OR</code>'d to select multiple primitives to be handled. </p>
<p><code>RangePrimitive.access</code> is a shortcut for the access primitives; <code>front</code>, <code>back</code> and <code>opIndex</code>. <br><br> <code>RangePrimitive.pop</code> is a shortcut for the mutating primitives; <code>popFront</code> and <code>popBack</code>.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.algorithm.iteration : map, splitter;
import std.conv : to, ConvException;

auto s = "12,1337z32,54,2,7,9,1z,6,8";

// The next line composition will throw when iterated
// as some elements of the input do not convert to integer
auto r = s.splitter(',').map!(a =&gt; to!int(a));

// Substitute 0 for cases of ConvException
auto h = r.handle!(ConvException, RangePrimitive.front, (e, r) =&gt; 0);
assert(h.equal([12, 0, 54, 2, 7, 9, 0, 6, 8]));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.range : retro;
import std.utf : UTFException;

auto str = "hello\xFFworld"; // 0xFF is an invalid UTF-8 code unit

auto handled = str.handle!(UTFException, RangePrimitive.access,
        (e, r) =&gt; ' '); // Replace invalid code points with spaces

assert(handled.equal("hello world")); // `front` is handled,
assert(handled.retro.equal("dlrow olleh")); // as well as `back`
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="RangePrimitive.front">
<strong id="front">front</strong><br><br><strong id="back">back</strong><br><br><strong id="popFront">popFront</strong><br><br><strong id="popBack">popBack</strong><br><br><strong id="empty">empty</strong><br><br><strong id="save">save</strong><br><br><strong id="length">length</strong><br><br><strong id="opDollar">opDollar</strong><br><br><strong id="opIndex">opIndex</strong><br><br><strong id="opSlice">opSlice</strong><br><br><strong id="access">access</strong><br><br><strong id="pop">pop</strong>
</dt>  </dl> </dd> <dt class="d_decl" id="handle">auto <strong id="handle">handle</strong>(E : Throwable, RangePrimitive primitivesToHandle, alias handler, Range)(Range input)<br><small>  Constraints: if (isInputRange!Range); </small>
</dt> <dd>
<p>Handle exceptions thrown from range primitives. </p>
<p>Use the <a href="#RangePrimitive"><code>RangePrimitive</code></a> enum to specify which primitives to handle. Multiple range primitives can be handled at once by using the <code>OR</code> operator or the pseudo-primitives <code>RangePrimitive.access</code> and <code>RangePrimitive.pop</code>. All handled primitives must have return types or values compatible with the user-supplied handler. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>E</td> <td>The type of <code>Throwable</code> to handle.</td>
</tr> <tr>
<td>primitivesToHandle</td> <td>Set of range primitives to handle.</td>
</tr> <tr>
<td>handler</td> <td>The callable that is called when a handled primitive throws a <code>Throwable</code> of type <code>E</code>. The handler must accept arguments of the form <code>E, ref IRange</code> and its return value is used as the primitive's return value whenever <code>E</code> is thrown. For <code>opIndex</code>, the handler can optionally recieve a third argument; the index that caused the exception.</td>
</tr> <tr>
<td>Range <code>input</code>
</td> <td>The range to handle.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A wrapper <code>struct</code> that preserves the range interface of <code>input</code>. </dd>
</dl> <dl>
<dt>Note</dt>
<dd> Infinite ranges with slicing support must return an instance of <a href="std_range.html#Take"><code>std.range.Take</code></a> when sliced with a specific lower and upper bound (see <a href="std_range_primitives.html#hasSlicing"><code>std.range.primitives.hasSlicing</code></a>); <code>handle</code> deals with this by <code>take</code>ing 0 from the return value of the handler function and returning that when an exception is caught.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.algorithm.iteration : map, splitter;
import std.conv : to, ConvException;

auto s = "12,1337z32,54,2,7,9,1z,6,8";

// The next line composition will throw when iterated
// as some elements of the input do not convert to integer
auto r = s.splitter(',').map!(a =&gt; to!int(a));

// Substitute 0 for cases of ConvException
auto h = r.handle!(ConvException, RangePrimitive.front, (e, r) =&gt; 0);
assert(h.equal([12, 0, 54, 2, 7, 9, 0, 6, 8]));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.range : retro;
import std.utf : UTFException;

auto str = "hello\xFFworld"; // 0xFF is an invalid UTF-8 code unit

auto handled = str.handle!(UTFException, RangePrimitive.access,
        (e, r) =&gt; ' '); // Replace invalid code points with spaces

assert(handled.equal("hello world")); // `front` is handled,
assert(handled.retro.equal("dlrow olleh")); // as well as `back`
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="basicExceptionCtors">template <strong id="basicExceptionCtors">basicExceptionCtors</strong>()</dt> <dd>
<p>Convenience mixin for trivially sub-classing exceptions </p>
<p>Even trivially sub-classing an exception involves writing boilerplate code for the constructor to: 1) correctly pass in the source file and line number the exception was thrown from; 2) be usable with <a href="#enforce"><code>enforce</code></a> which expects exception constructors to take arguments in a fixed order. This mixin provides that boilerplate code. <br><br> Note however that you need to mark the <b>mixin</b> line with at least a minimal (i.e. just <b>///</b>) DDoc comment if you want the mixed-in constructors to be documented in the newly created Exception subclass. <br><br> <span class="red">Current limitation</span>: Due to <a href="https://issues.dlang.org/show_bug.cgi?id=11500">bug #11500</a>, currently the constructors specified in this mixin cannot be overloaded with any other custom constructors. Thus this mixin can currently only be used when no such custom constructors need to be explicitly specified.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">class MeaCulpa: Exception
{
    ///
    mixin basicExceptionCtors;
}

try
    throw new MeaCulpa("test");
catch (MeaCulpa e)
{
    writeln(e.msg); // "test"
    writeln(e.file); // __FILE__
    writeln(e.line); // __LINE__ - 5
}
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="basicExceptionCtors.this">pure nothrow @nogc @safe this(string msg, string file = __FILE__, size_t line = __LINE__, Throwable next = null); </dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>string <code>msg</code>
</td> <td>The message for the exception.</td>
</tr> <tr>
<td>string <code>file</code>
</td> <td>The file where the exception occurred.</td>
</tr> <tr>
<td>size_t <code>line</code>
</td> <td>The line number where the exception occurred.</td>
</tr> <tr>
<td>Throwable <code>next</code>
</td> <td>The previous exception in the chain of exceptions, if any.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="basicExceptionCtors.this.2">pure nothrow @nogc @safe this(string msg, Throwable next, string file = __FILE__, size_t line = __LINE__); </dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>string <code>msg</code>
</td> <td>The message for the exception.</td>
</tr> <tr>
<td>Throwable <code>next</code>
</td> <td>The previous exception in the chain of exceptions.</td>
</tr> <tr>
<td>string <code>file</code>
</td> <td>The file where the exception occurred.</td>
</tr> <tr>
<td>size_t <code>line</code>
</td> <td>The line number where the exception occurred.</td>
</tr> </table></dd>
</dl> </dd> </dl> </dd> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1999&ndash;2021 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/std_exception.html" class="_attribution-link">https://dlang.org/phobos/std_exception.html</a>
  </p>
</div>
