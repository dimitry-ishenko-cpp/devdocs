<h1>core.volatile</h1>  <p>This module declares intrinsics for volatile operations. </p>
<dl>
<dt>License:</dt>
<dd>
<a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a> </dd>
</dl> <dl>
<dt>Authors:</dt>
<dd>Walter Bright, Ernesto Castellotti </dd>
</dl> <dl>
<dt>Source</dt>
<dd> <a href="https://github.com/dlang/druntime/blob/master/src/core/volatile.d">core/volatile.d</a>
</dd>
</dl> <dl>
<dt class="d_decl" id="volatileLoad">nothrow @nogc @safe ubyte <strong id="volatileLoad">volatileLoad</strong>(ubyte* ptr); <br><br>nothrow @nogc @safe ushort <strong id="volatileLoad">volatileLoad</strong>(ushort* ptr); <br><br>nothrow @nogc @safe uint <strong id="volatileLoad">volatileLoad</strong>(uint* ptr); <br><br>nothrow @nogc @safe ulong <strong id="volatileLoad">volatileLoad</strong>(ulong* ptr); <br><br>nothrow @nogc @safe void <strong id="volatileStore">volatileStore</strong>(ubyte* ptr, ubyte value); <br><br>nothrow @nogc @safe void <strong id="volatileStore">volatileStore</strong>(ushort* ptr, ushort value); <br><br>nothrow @nogc @safe void <strong id="volatileStore">volatileStore</strong>(uint* ptr, uint value); <br><br>nothrow @nogc @safe void <strong id="volatileStore">volatileStore</strong>(ulong* ptr, ulong value); </dt> <dd>
<p>Read/write value from/to the memory location indicated by ptr. </p>
<p>These functions are recognized by the compiler, and calls to them are guaranteed to not be removed (as dead assignment elimination or presumed to have no effect) or reordered in the same thread. <br><br> These reordering guarantees are only made with regards to other operations done through these functions; the compiler is free to reorder regular loads/stores with regards to loads/stores done through these functions. <br><br> This is useful when dealing with memory-mapped I/O (MMIO) where a store can have an effect other than just writing a value, or where sequential loads with no intervening stores can retrieve different values from the same location due to external stores to the location. <br><br> These functions will, when possible, do the load/store as a single operation. In general, this is possible when the size of the operation is less than or equal to <code>(void*).sizeof</code>, although some targets may support larger operations. If the load/store cannot be done as a single operation, multiple smaller operations will be used. <br><br> These are not to be conflated with atomic operations. They do not guarantee any atomicity. This may be provided by coincidence as a result of the instructions used on the target, but this should not be relied on for portable programs. Further, no memory fences are implied by these functions. They should not be used for communication between threads. They may be used to guarantee a write or read cycle occurs at a specified address.</p> </dd> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1999&ndash;2021 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/core_volatile.html" class="_attribution-link">https://dlang.org/phobos/core_volatile.html</a>
  </p>
</div>
