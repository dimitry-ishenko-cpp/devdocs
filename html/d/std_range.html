<h1>std.range</h1>  <p>This module defines the notion of a range. Ranges generalize the concept of arrays, lists, or anything that involves sequential access. This abstraction enables the same set of algorithms (see <a href="std_algorithm.html"><code>std.algorithm</code></a>) to be used with a vast variety of different concrete types. For example, a linear search algorithm such as <a href="std_algorithm_searching.html#find"><code>std.algorithm.searching.find</code></a> works not just for arrays, but for linked-lists, input files, incoming network data, etc. </p>
<dl>
<dt>Guides</dt>
<dd> There are many articles available that can bolster understanding ranges: </dd>
</dl> <ul> <li>Ali Ã‡ehreli's <a href="http://ddili.org/ders/d.en/ranges.html">tutorial on ranges</a> for the basics of working with and creating range-based code.</li> <li>Jonathan M. Davis <a href="http://dconf.org/2015/talks/davis.html"><i>Introduction to Ranges</i></a> talk at DConf 2015 a vivid introduction from its core constructs to practical advice.</li> <li>The DLang Tour's <a href="http://tour.dlang.org/tour/en/basics/ranges">chapter on ranges</a> for an interactive introduction.</li> <li>H. S. Teoh's <a href="http://wiki.dlang.org/Component_programming_with_ranges">tutorial on component programming with ranges</a> for a real-world showcase of the influence of range-based programming on complex algorithms.</li> <li>Andrei Alexandrescu's article <a href="http://www.informit.com/articles/printerfriendly.aspx?p=1407357&amp;rll=1"> <i>On Iteration</i></a> for conceptual aspect of ranges and the motivation </li> </ul>  <dl>
<dt>Submodules</dt>
<dd> This module has two submodules: </dd>
</dl> The <a href="std_range_primitives.html"><code>std.range.primitives</code></a> submodule provides basic range functionality. It defines several templates for testing whether a given object is a range, what kind of range it is, and provides some common range operations.  The <a href="std_range_interfaces.html"><code>std.range.interfaces</code></a> submodule provides object-based interfaces for working with ranges via runtime polymorphism.  The remainder of this module provides a rich set of range creation and composition templates that let you construct new ranges out of existing ranges:    <table>
 <tr>
<td><a href="#chain"><code>chain</code></a></td> <td>Concatenates several ranges into a single range. </td>
</tr> <tr>
<td><a href="#choose"><code>choose</code></a></td> <td>Chooses one of two ranges at runtime based on a boolean condition. </td>
</tr> <tr>
<td><a href="#chooseAmong"><code>chooseAmong</code></a></td> <td>Chooses one of several ranges at runtime based on an index. </td>
</tr> <tr>
<td><a href="#chunks"><code>chunks</code></a></td> <td>Creates a range that returns fixed-size chunks of the original range. </td>
</tr> <tr>
<td><a href="#cycle"><code>cycle</code></a></td> <td>Creates an infinite range that repeats the given forward range indefinitely. Good for implementing circular buffers. </td>
</tr> <tr>
<td><a href="#drop"><code>drop</code></a></td> <td>Creates the range that results from discarding the first <i>n</i> elements from the given range. </td>
</tr> <tr>
<td><a href="#dropBack"><code>dropBack</code></a></td> <td>Creates the range that results from discarding the last <i>n</i> elements from the given range. </td>
</tr> <tr>
<td><a href="#dropExactly"><code>dropExactly</code></a></td> <td>Creates the range that results from discarding exactly <i>n</i> of the first elements from the given range. </td>
</tr> <tr>
<td><a href="#dropBackExactly"><code>dropBackExactly</code></a></td> <td>Creates the range that results from discarding exactly <i>n</i> of the last elements from the given range. </td>
</tr> <tr>
<td><a href="#dropOne"><code>dropOne</code></a></td> <td>Creates the range that results from discarding the first element from the given range. </td>
</tr> <tr>
<td><code><a href="#dropBackOne">dropBackOne</a></code></td> <td>Creates the range that results from discarding the last element from the given range. </td>
</tr> <tr>
<td><a href="#enumerate"><code>enumerate</code></a></td> <td>Iterates a range with an attached index variable. </td>
</tr> <tr>
<td><a href="#evenChunks"><code>evenChunks</code></a></td> <td>Creates a range that returns a number of chunks of approximately equal length from the original range. </td>
</tr> <tr>
<td><a href="#frontTransversal"><code>frontTransversal</code></a></td> <td>Creates a range that iterates over the first elements of the given ranges. </td>
</tr> <tr>
<td><a href="#generate"><code>generate</code></a></td> <td>Creates a range by successive calls to a given function. This allows to create ranges as a single delegate. </td>
</tr> <tr>
<td><a href="#indexed"><code>indexed</code></a></td> <td>Creates a range that offers a view of a given range as though its elements were reordered according to a given range of indices. </td>
</tr> <tr>
<td><a href="#iota"><code>iota</code></a></td> <td>Creates a range consisting of numbers between a starting point and ending point, spaced apart by a given interval. </td>
</tr> <tr>
<td><a href="#lockstep"><code>lockstep</code></a></td> <td>Iterates <i>n</i> ranges in lockstep, for use in a <code>foreach</code> loop. Similar to <code>zip</code>, except that <code>lockstep</code> is designed especially for <code>foreach</code> loops. </td>
</tr> <tr>
<td><a href="#nullSink"><code>nullSink</code></a></td> <td>An output range that discards the data it receives. </td>
</tr> <tr>
<td><a href="#only"><code>only</code></a></td> <td>Creates a range that iterates over the given arguments. </td>
</tr> <tr>
<td><a href="#padLeft"><code>padLeft</code></a></td> <td>Pads a range to a specified length by adding a given element to the front of the range. Is lazy if the range has a known length. </td>
</tr> <tr>
<td><a href="#padRight"><code>padRight</code></a></td> <td>Lazily pads a range to a specified length by adding a given element to the back of the range. </td>
</tr> <tr>
<td><a href="#radial"><code>radial</code></a></td> <td>Given a random-access range and a starting point, creates a range that alternately returns the next left and next right element to the starting point. </td>
</tr> <tr>
<td><a href="#recurrence"><code>recurrence</code></a></td> <td>Creates a forward range whose values are defined by a mathematical recurrence relation. </td>
</tr> <tr>
<td><a href="#refRange"><code>refRange</code></a></td> <td>Pass a range by reference. Both the original range and the RefRange will always have the exact same elements. Any operation done on one will affect the other. </td>
</tr> <tr>
<td><a href="#repeat"><code>repeat</code></a></td> <td>Creates a range that consists of a single element repeated <i>n</i> times, or an infinite range repeating that element indefinitely. </td>
</tr> <tr>
<td><a href="#retro"><code>retro</code></a></td> <td>Iterates a bidirectional range backwards. </td>
</tr> <tr>
<td><a href="#roundRobin"><code>roundRobin</code></a></td> <td>Given <i>n</i> ranges, creates a new range that return the <i>n</i> first elements of each range, in turn, then the second element of each range, and so on, in a round-robin fashion. </td>
</tr> <tr>
<td><a href="#sequence"><code>sequence</code></a></td> <td>Similar to <code>recurrence</code>, except that a random-access range is created. </td>
</tr> <tr>
<td><code><a href="#slide">slide</a></code></td> <td>Creates a range that returns a fixed-size sliding window over the original range. Unlike chunks, it advances a configurable number of items at a time, not one chunk at a time. </td>
</tr> <tr>
<td><a href="#stride"><code>stride</code></a></td> <td>Iterates a range with stride <i>n</i>. </td>
</tr> <tr>
<td><a href="#tail"><code>tail</code></a></td> <td>Return a range advanced to within <code>n</code> elements of the end of the given range. </td>
</tr> <tr>
<td><a href="#take"><code>take</code></a></td> <td>Creates a sub-range consisting of only up to the first <i>n</i> elements of the given range. </td>
</tr> <tr>
<td><a href="#takeExactly"><code>takeExactly</code></a></td> <td>Like <code>take</code>, but assumes the given range actually has <i>n</i> elements, and therefore also defines the <code>length</code> property. </td>
</tr> <tr>
<td><a href="#takeNone"><code>takeNone</code></a></td> <td>Creates a random-access range consisting of zero elements of the given range. </td>
</tr> <tr>
<td><a href="#takeOne"><code>takeOne</code></a></td> <td>Creates a random-access range consisting of exactly the first element of the given range. </td>
</tr> <tr>
<td><a href="#tee"><code>tee</code></a></td> <td>Creates a range that wraps a given range, forwarding along its elements while also calling a provided function with each element. </td>
</tr> <tr>
<td><a href="#transposed"><code>transposed</code></a></td> <td>Transposes a range of ranges. </td>
</tr> <tr>
<td><a href="#transversal"><code>transversal</code></a></td> <td>Creates a range that iterates over the <i>n</i>'th elements of the given random-access ranges. </td>
</tr> <tr>
<td><a href="#zip"><code>zip</code></a></td> <td>Given <i>n</i> ranges, creates a range that successively returns a tuple of all the first elements, a tuple of all the second elements, etc. </td>
</tr> </table>  <dl>
<dt>Sortedness</dt>
<dd> Ranges whose elements are sorted afford better efficiency with certain operations. For this, the <a href="#assumeSorted"><code>assumeSorted</code></a> function can be used to construct a <a href="#SortedRange"><code>SortedRange</code></a> from a pre-sorted range. The <a href="std_algorithm_sorting.html#sort"><code>std.algorithm.sorting.sort</code></a> function also conveniently returns a <a href="#SortedRange"><code>SortedRange</code></a>. <a href="#SortedRange"><code>SortedRange</code></a> objects provide some additional range operations that take advantage of the fact that the range is sorted. </dd>
</dl> <dl>
<dt>Source</dt>
<dd> <span class="phobos_src"><a class="https" href="https://github.com/dlang/phobos/blob/master/std/range/package.d">std/range/package.d</a></span> </dd>
</dl> <dl>
<dt>License:</dt>
<dd>
<a href="http://boost.org/LICENSE_1_0.txt">Boost License 1.0</a>. </dd>
</dl> <dl>
<dt>Authors:</dt>
<dd>
<a href="http://erdani.com">Andrei Alexandrescu</a>, David Simcha, <a href="http://jmdavisprog.com">Jonathan M Davis</a>, and Jack Stouffer. Credit for some of the ideas in building this module goes to <a href="http://fantascienza.net/leonardo/so/">Leonardo Maffi</a>.</dd>
</dl> <dl>
<dt class="d_decl" id="retro">auto <strong id="retro">retro</strong>(Range)(Range r)<br><small>  Constraints: if (isBidirectionalRange!(Unqual!Range)); </small>
</dt> <dd>
<p>Iterates a bidirectional range backwards. The original range can be accessed by using the <code>source</code> property. Applying retro twice to the same range yields the original range. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>r</code>
</td> <td>the bidirectional range to iterate backwards</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A bidirectional range with length if <code>r</code> also provides a length. Or, if <code>r</code> is a random access range, then the return value will be random access as well. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="std_algorithm_mutation.html#reverse"><code>std.algorithm.mutation.reverse</code></a> for mutating the source range directly.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
int[5] a = [ 1, 2, 3, 4, 5 ];
int[5] b = [ 5, 4, 3, 2, 1 ];
assert(equal(retro(a[]), b[]));
assert(retro(a[]).source is a[]);
assert(retro(retro(a[])) is a[]);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="stride">auto <strong id="stride">stride</strong>(Range)(Range r, size_t n)<br><small>  Constraints: if (isInputRange!(Unqual!Range)); </small>
</dt> <dd>
<p>Iterates range <code>r</code> with stride <code>n</code>. If the range is a random-access range, moves by indexing into the range; otherwise, moves by successive calls to <code>popFront</code>. Applying stride twice to the same range results in a stride with a step that is the product of the two applications. It is an error for <code>n</code> to be 0. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>r</code>
</td> <td>the <a href="std_range_primitives.html#isInputRange">input range</a> to stride over</td>
</tr> <tr>
<td>size_t <code>n</code>
</td> <td>the number of elements to skip over</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>At minimum, an input range. The resulting range will adopt the range primitives of the underlying range as long as <a href="std_range_primitives.html#hasLength"><code>std.range.primitives.hasLength</code></a> is <code>true</code>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;

int[] a = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 ];
assert(equal(stride(a, 3), [ 1, 4, 7, 10 ][]));
writeln(stride(stride(a, 2), 3)); // stride(a, 6)
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="chain">auto <strong id="chain">chain</strong>(Ranges...)(Ranges rs)<br><small>  Constraints: if (Ranges.length &gt; 0 &amp;&amp; allSatisfy!(isInputRange, staticMap!(Unqual, Ranges)) &amp;&amp; !is(CommonType!(staticMap!(ElementType, staticMap!(Unqual, Ranges))) == void)); </small>
</dt> <dd>
<p>Spans multiple ranges in sequence. The function <code>chain</code> takes any number of ranges and returns a <code>Chain!(R1, R2,...)</code> object. The ranges may be different, but they must have the same element type. The result is a range that offers the <code>front</code>, <code>popFront</code>, and <code>empty</code> primitives. If all input ranges offer random access and <code>length</code>, <code>Chain</code> offers them as well. </p>
<p>If only one range is offered to <code>Chain</code> or <code>chain</code>, the <code>Chain</code> type exits the picture by aliasing itself directly to that range's type. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Ranges <code>rs</code>
</td> <td>the <a href="std_range_primitives.html#isInputRange">input ranges</a> to chain together</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>An input range at minimum. If all of the ranges in <code>rs</code> provide a range primitive, the returned range will also provide that range primitive. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="#only"><code>only</code></a> to chain values to a range</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;

int[] arr1 = [ 1, 2, 3, 4 ];
int[] arr2 = [ 5, 6 ];
int[] arr3 = [ 7 ];
auto s = chain(arr1, arr2, arr3);
writeln(s.length); // 7
writeln(s[5]); // 6
assert(equal(s, [1, 2, 3, 4, 5, 6, 7][]));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Range primitives are carried over to the returned range if all of the ranges provide them <pre data-language="d">import std.algorithm.comparison : equal;
import std.algorithm.sorting : sort;

int[] arr1 = [5, 2, 8];
int[] arr2 = [3, 7, 9];
int[] arr3 = [1, 4, 6];

// in-place sorting across all of the arrays
auto s = arr1.chain(arr2, arr3).sort;

assert(s.equal([1, 2, 3, 4, 5, 6, 7, 8, 9]));
assert(arr1.equal([1, 2, 3]));
assert(arr2.equal([4, 5, 6]));
assert(arr3.equal([7, 8, 9]));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Due to safe type promotion in D, chaining together different character ranges results in a <code>uint</code> range.  Use <a href="std_utf.html#byChar">byChar</a>, <a href="std_utf.html#byWchar">byWchar</a>, and <a href="std_utf.html#byDchar">byDchar</a> on the ranges to get the type you need. <pre data-language="d">import std.utf : byChar, byCodeUnit;

auto s1 = "string one";
auto s2 = "string two";
// s1 and s2 front is dchar because of auto-decoding
static assert(is(typeof(s1.front) == dchar) &amp;&amp; is(typeof(s2.front) == dchar));

auto r1 = s1.chain(s2);
// chains of ranges of the same character type give that same type
static assert(is(typeof(r1.front) == dchar));

auto s3 = "string three".byCodeUnit;
static assert(is(typeof(s3.front) == immutable char));
auto r2 = s1.chain(s3);
// chaining ranges of mixed character types gives `dchar`
static assert(is(typeof(r2.front) == dchar));

// use byChar on character ranges to correctly convert them to UTF-8
auto r3 = s1.byChar.chain(s3);
static assert(is(typeof(r3.front) == immutable char));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="choose">auto <strong id="choose">choose</strong>(R1, R2)(bool condition, return scope R1 r1, return scope R2 r2)<br><small>  Constraints: if (isInputRange!(Unqual!R1) &amp;&amp; isInputRange!(Unqual!R2) &amp;&amp; !is(CommonType!(ElementType!(Unqual!R1), ElementType!(Unqual!R2)) == void)); </small>
</dt> <dd>
<p>Choose one of two ranges at runtime depending on a Boolean condition. </p>
<p>The ranges may be different, but they must have compatible element types (i.e. <code>CommonType</code> must exist for the two element types). The result is a range that offers the weakest capabilities of the two (e.g. <code>ForwardRange</code> if <code>R1</code> is a random-access range and <code>R2</code> is a forward range). </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>bool <code>condition</code>
</td> <td>which range to choose: <code>r1</code> if <code>true</code>, <code>r2</code> otherwise</td>
</tr> <tr>
<td>R1 <code>r1</code>
</td> <td>the "true" range</td>
</tr> <tr>
<td>R2 <code>r2</code>
</td> <td>the "false" range</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A range type dependent on <code>R1</code> and <code>R2</code>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.algorithm.iteration : filter, map;

auto data1 = only(1, 2, 3, 4).filter!(a =&gt; a != 3);
auto data2 = only(5, 6, 7, 8).map!(a =&gt; a + 1);

// choose() is primarily useful when you need to select one of two ranges
// with different types at runtime.
static assert(!is(typeof(data1) == typeof(data2)));

auto chooseRange(bool pickFirst)
{
    // The returned range is a common wrapper type that can be used for
    // returning or storing either range without running into a type error.
    return choose(pickFirst, data1, data2);

    // Simply returning the chosen range without using choose() does not
    // work, because map() and filter() return different types.
    //return pickFirst ? data1 : data2; // does not compile
}

auto result = chooseRange(true);
assert(result.equal(only(1, 2, 4)));

result = chooseRange(false);
assert(result.equal(only(6, 7, 8, 9)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="chooseAmong">auto <strong id="chooseAmong">chooseAmong</strong>(Ranges...)(size_t index, return scope Ranges rs)<br><small>  Constraints: if (Ranges.length &gt;= 2 &amp;&amp; allSatisfy!(isInputRange, staticMap!(Unqual, Ranges)) &amp;&amp; !is(CommonType!(staticMap!(ElementType, Ranges)) == void)); </small>
</dt> <dd>
<p>Choose one of multiple ranges at runtime. </p>
<p>The ranges may be different, but they must have compatible element types. The result is a range that offers the weakest capabilities of all <code>Ranges</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>size_t <code>index</code>
</td> <td>which range to choose, must be less than the number of ranges</td>
</tr> <tr>
<td>Ranges <code>rs</code>
</td> <td>two or more ranges</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The indexed range. If rs consists of only one range, the return type is an alias of that range's type.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto test()
{
    import std.algorithm.comparison : equal;

    int[4] sarr1 = [1, 2, 3, 4];
    int[2] sarr2 = [5, 6];
    int[1] sarr3 = [7];
    auto arr1 = sarr1[];
    auto arr2 = sarr2[];
    auto arr3 = sarr3[];

    {
        auto s = chooseAmong(0, arr1, arr2, arr3);
        auto t = s.save;
        writeln(s.length); // 4
        writeln(s[2]); // 3
        s.popFront();
        assert(equal(t, only(1, 2, 3, 4)));
    }
    {
        auto s = chooseAmong(1, arr1, arr2, arr3);
        writeln(s.length); // 2
        s.front = 8;
        assert(equal(s, only(8, 6)));
    }
    {
        auto s = chooseAmong(1, arr1, arr2, arr3);
        writeln(s.length); // 2
        s[1] = 9;
        assert(equal(s, only(8, 9)));
    }
    {
        auto s = chooseAmong(1, arr2, arr1, arr3)[1 .. 3];
        writeln(s.length); // 2
        assert(equal(s, only(2, 3)));
    }
    {
        auto s = chooseAmong(0, arr1, arr2, arr3);
        writeln(s.length); // 4
        writeln(s.back); // 4
        s.popBack();
        s.back = 5;
        assert(equal(s, only(1, 2, 5)));
        s.back = 3;
        assert(equal(s, only(1, 2, 3)));
    }
    {
        uint[5] foo = [1, 2, 3, 4, 5];
        uint[5] bar = [6, 7, 8, 9, 10];
        auto c = chooseAmong(1, foo[], bar[]);
        writeln(c[3]); // 9
        c[3] = 42;
        writeln(c[3]); // 42
        writeln(c.moveFront()); // 6
        writeln(c.moveBack()); // 10
        writeln(c.moveAt(4)); // 10
    }
    {
        import std.range : cycle;
        auto s = chooseAmong(0, cycle(arr2), cycle(arr3));
        assert(isInfinite!(typeof(s)));
        assert(!s.empty);
        writeln(s[100]); // 8
        writeln(s[101]); // 9
        assert(s[0 .. 3].equal(only(8, 9, 8)));
    }
    return 0;
}
// works at runtime
auto a = test();
// and at compile time
static b = test();
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="roundRobin">auto <strong id="roundRobin">roundRobin</strong>(Rs...)(Rs rs)<br><small>  Constraints: if (Rs.length &gt; 1 &amp;&amp; allSatisfy!(isInputRange, staticMap!(Unqual, Rs))); </small>
</dt> <dd>
<p><code>roundRobin(r1, r2, r3)</code> yields <code>r1.front</code>, then <code>r2.front</code>, then <code>r3.front</code>, after which it pops off one element from each and continues again from <code>r1</code>. For example, if two ranges are involved, it alternately yields elements off the two ranges. <code>roundRobin</code> stops after it has consumed all ranges (skipping over the ones that finish early).</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;

int[] a = [ 1, 2, 3 ];
int[] b = [ 10, 20, 30, 40 ];
auto r = roundRobin(a, b);
assert(equal(r, [ 1, 10, 2, 20, 3, 30, 40 ]));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>roundRobin can be used to create "interleave" functionality which inserts an element between each element in a range. <pre data-language="d">import std.algorithm.comparison : equal;

auto interleave(R, E)(R range, E element)
if ((isInputRange!R &amp;&amp; hasLength!R) || isForwardRange!R)
{
    static if (hasLength!R)
        immutable len = range.length;
    else
        immutable len = range.save.walkLength;

    return roundRobin(
        range,
        element.repeat(len - 1)
    );
}

assert(interleave([1, 2, 3], 0).equal([1, 0, 2, 0, 3]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="radial">auto <strong id="radial">radial</strong>(Range, I)(Range r, I startingIndex)<br><small>  Constraints: if (isRandomAccessRange!(Unqual!Range) &amp;&amp; hasLength!(Unqual!Range) &amp;&amp; hasSlicing!(Unqual!Range) &amp;&amp; isIntegral!I); </small><br><br>auto <strong id="radial">radial</strong>(R)(R r)<br><small>  Constraints: if (isRandomAccessRange!(Unqual!R) &amp;&amp; hasLength!(Unqual!R) &amp;&amp; hasSlicing!(Unqual!R)); </small>
</dt> <dd>
<p>Iterates a random-access range starting from a given point and progressively extending left and right from that point. If no initial point is given, iteration starts from the middle of the range. Iteration spans the entire range. </p>
<p>When <code>startingIndex</code> is 0 the range will be fully iterated in order and in reverse order when <code>r.length</code> is given. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>r</code>
</td> <td>a random access range with length and slicing</td>
</tr> <tr>
<td>I <code>startingIndex</code>
</td> <td>the index to begin iteration from</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A forward range with length</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
int[] a = [ 1, 2, 3, 4, 5 ];
assert(equal(radial(a), [ 3, 4, 2, 5, 1 ]));
a = [ 1, 2, 3, 4 ];
assert(equal(radial(a), [ 2, 3, 1, 4 ]));

// If the left end is reached first, the remaining elements on the right
// are concatenated in order:
a = [ 0, 1, 2, 3, 4, 5 ];
assert(equal(radial(a, 1), [ 1, 2, 0, 3, 4, 5 ]));

// If the right end is reached first, the remaining elements on the left
// are concatenated in reverse order:
assert(equal(radial(a, 4), [ 4, 5, 3, 2, 1, 0 ]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="take">Take!R <strong id="take">take</strong>(R)(R input, size_t n)<br><small>  Constraints: if (isInputRange!(Unqual!R)); </small><br><br>struct <strong id="Take">Take</strong>(Range) if (isInputRange!(Unqual!Range) &amp;&amp; !(!isInfinite!(Unqual!Range) &amp;&amp; hasSlicing!(Unqual!Range) || is(Range T == <strong id="Take">Take</strong>!T))); <br><br>template <strong id="Take">Take</strong>(R) if (isInputRange!(Unqual!R) &amp;&amp; (!isInfinite!(Unqual!R) &amp;&amp; hasSlicing!(Unqual!R) || is(R T == <strong id="Take">Take</strong>!T)))</dt> <dd>
<p>Lazily takes only up to <code>n</code> elements of a range. This is particularly useful when using with infinite ranges. </p>
<p>Unlike <a href="#takeExactly"><code>takeExactly</code></a>, <code>take</code> does not require that there are <code>n</code> or more elements in <code>input</code>. As a consequence, length information is not applied to the result unless <code>input</code> also has length information. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>input</code>
</td> <td>an <a href="std_range_primitives.html#isInputRange">input range</a> to iterate over up to <code>n</code> times</td>
</tr> <tr>
<td>size_t <code>n</code>
</td> <td>the number of elements to take</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>At minimum, an input range. If the range offers random access and <code>length</code>, <code>take</code> offers them as well.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;

int[] arr1 = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];
auto s = take(arr1, 5);
writeln(s.length); // 5
writeln(s[4]); // 5
assert(equal(s, [ 1, 2, 3, 4, 5 ][]));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>If the range runs out before <code>n</code> elements, <code>take</code> simply returns the entire range (unlike <a href="#takeExactly"><code>takeExactly</code></a>, which will cause an assertion failure if the range ends prematurely): <pre data-language="d">import std.algorithm.comparison : equal;

int[] arr2 = [ 1, 2, 3 ];
auto t = take(arr2, 5);
writeln(t.length); // 3
assert(equal(t, [ 1, 2, 3 ]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="takeExactly">auto <strong id="takeExactly">takeExactly</strong>(R)(R range, size_t n)<br><small>  Constraints: if (isInputRange!R); </small>
</dt> <dd>
<p>Similar to <a href="#take"><code>take</code></a>, but assumes that <code>range</code> has at least <code>n</code> elements. Consequently, the result of <code>takeExactly(range, n)</code> always defines the <code>length</code> property (and initializes it to <code>n</code>) even when <code>range</code> itself does not define <code>length</code>. </p>
<p>The result of <code>takeExactly</code> is identical to that of <a href="#take"><code>take</code></a> in cases where the original range defines <code>length</code> or is infinite. <br><br> Unlike <a href="#take"><code>take</code></a>, however, it is illegal to pass a range with less than <code>n</code> elements to <code>takeExactly</code>; this will cause an assertion failure.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;

auto a = [ 1, 2, 3, 4, 5 ];

auto b = takeExactly(a, 3);
assert(equal(b, [1, 2, 3]));
static assert(is(typeof(b.length) == size_t));
writeln(b.length); // 3
writeln(b.front); // 1
writeln(b.back); // 3
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="takeOne">auto <strong id="takeOne">takeOne</strong>(R)(R source)<br><small>  Constraints: if (isInputRange!R); </small>
</dt> <dd>
<p>Returns a range with at most one element; for example, <code>takeOne([42, 43, 44])</code> returns a range consisting of the integer <code>42</code>. Calling <code>popFront()</code> off that range renders it empty. </p>
<p>In effect <code>takeOne(r)</code> is somewhat equivalent to <code>take(r, 1)</code> but in certain interfaces it is important to know statically that the range may only have at most one element. <br><br> The type returned by <code>takeOne</code> is a random-access range with length regardless of <code>R</code>'s capabilities, as long as it is a forward range. (another feature that distinguishes <code>takeOne</code> from <code>take</code>). If (D R) is an input range but not a forward range, return type is an input range with all random-access capabilities except save.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto s = takeOne([42, 43, 44]);
static assert(isRandomAccessRange!(typeof(s)));
writeln(s.length); // 1
assert(!s.empty);
writeln(s.front); // 42
s.front = 43;
writeln(s.front); // 43
writeln(s.back); // 43
writeln(s[0]); // 43
s.popFront();
writeln(s.length); // 0
assert(s.empty);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="takeNone">auto <strong id="takeNone">takeNone</strong>(R)()<br><small>  Constraints: if (isInputRange!R); </small>
</dt> <dd>
<p>Returns an empty range which is statically known to be empty and is guaranteed to have <code>length</code> and be random access regardless of <code>R</code>'s capabilities.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto range = takeNone!(int[])();
writeln(range.length); // 0
assert(range.empty);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="takeNone.2">auto <strong id="takeNone">takeNone</strong>(R)(R range)<br><small>  Constraints: if (isInputRange!R); </small>
</dt> <dd>
<p>Creates an empty range from the given range in <span class="bigoh">ÎŸ(<code>1</code>)</span>. If it can, it will return the same range type. If not, it will return <code>takeExactly(range, 0)</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.iteration : filter;
assert(takeNone([42, 27, 19]).empty);
assert(takeNone("dlang.org").empty);
assert(takeNone(filter!"true"([42, 27, 19])).empty);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="tail">auto <strong id="tail">tail</strong>(Range)(Range range, size_t n)<br><small>  Constraints: if (isInputRange!Range &amp;&amp; !isInfinite!Range &amp;&amp; (hasLength!Range || isForwardRange!Range)); </small>
</dt> <dd>
<p>Return a range advanced to within <code>_n</code> elements of the end of <code>range</code>. </p>
<p>Intended as the range equivalent of the Unix <a href="http://en.wikipedia.org/wiki/Tail_%28Unix%29">tail</a> utility. When the length of <code>range</code> is less than or equal to <code>_n</code>, <code>range</code> is returned as-is. <br><br> Completes in <span class="bigoh">ÎŸ(<code>1</code>)</span> steps for ranges that support slicing and have length. Completes in <span class="bigoh">ÎŸ(<code>range.length</code>)</span> time for all other ranges. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>range</code>
</td> <td>range to get tail of</td>
</tr> <tr>
<td>size_t <code>n</code>
</td> <td>maximum number of elements to include in tail</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>Returns the tail of <code>range</code> augmented with length information</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">// tail -c n
writeln([1, 2, 3].tail(1)); // [3]
writeln([1, 2, 3].tail(2)); // [2, 3]
writeln([1, 2, 3].tail(3)); // [1, 2, 3]
writeln([1, 2, 3].tail(4)); // [1, 2, 3]
writeln([1, 2, 3].tail(0).length); // 0

// tail --lines=n
import std.algorithm.comparison : equal;
import std.algorithm.iteration : joiner;
import std.exception : assumeWontThrow;
import std.string : lineSplitter;
assert("one\ntwo\nthree"
    .lineSplitter
    .tail(2)
    .joiner("\n")
    .equal("two\nthree")
    .assumeWontThrow);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="drop">R <strong id="drop">drop</strong>(R)(R range, size_t n)<br><small>  Constraints: if (isInputRange!R); </small><br><br>R <strong id="dropBack">dropBack</strong>(R)(R range, size_t n)<br><small>  Constraints: if (isBidirectionalRange!R); </small>
</dt> <dd>
<p>Convenience function which calls <a href="std_range_primitives.html#popFrontN"><code>std.range.primitives.popFrontN</code></a><code>(range, n)</code> and returns <code>range</code>. <code>drop</code> makes it easier to pop elements from a range and then pass it to another function within a single expression, whereas <code>popFrontN</code> would require multiple statements. </p>
<p><code>dropBack</code> provides the same functionality but instead calls <a href="std_range_primitives.html#popBackN"><code>std.range.primitives.popBackN</code></a><code>(range, n)</code> </p> <dl>
<dt>Note</dt>
<dd> <code>drop</code> and <code>dropBack</code> will only pop <i>up to</i> <code>n</code> elements but will stop if the range is empty first. In other languages this is sometimes called <code>skip</code>. </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>range</code>
</td> <td>the <a href="std_range_primitives.html#isInputRange">input range</a> to drop from</td>
</tr> <tr>
<td>size_t <code>n</code>
</td> <td>the number of elements to drop</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>range</code> with up to <code>n</code> elements dropped </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="std_range_primitives.html#popFront"><code>std.range.primitives.popFront</code></a>, <a href="std_range_primitives.html#popBackN"><code>std.range.primitives.popBackN</code></a>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;

writeln([0, 2, 1, 5, 0, 3].drop(3)); // [5, 0, 3]
writeln("hello world".drop(6)); // "world"
assert("hello world".drop(50).empty);
assert("hello world".take(6).drop(3).equal("lo "));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;

writeln([0, 2, 1, 5, 0, 3].dropBack(3)); // [0, 2, 1]
writeln("hello world".dropBack(6)); // "hello"
assert("hello world".dropBack(50).empty);
assert("hello world".drop(4).dropBack(4).equal("o w"));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="dropExactly">R <strong id="dropExactly">dropExactly</strong>(R)(R range, size_t n)<br><small>  Constraints: if (isInputRange!R); </small><br><br>R <strong id="dropBackExactly">dropBackExactly</strong>(R)(R range, size_t n)<br><small>  Constraints: if (isBidirectionalRange!R); </small>
</dt> <dd>
<p>Similar to <a href="#drop"><code>drop</code></a> and <code>dropBack</code> but they call <code>range.<a href="#popFrontExactly">popFrontExactly</a>(n)</code> and <code>range.popBackExactly(n)</code> instead. </p>
<dl>
<dt>Note</dt>
<dd> Unlike <code>drop</code>, <code>dropExactly</code> will assume that the range holds at least <code>n</code> elements. This makes <code>dropExactly</code> faster than <code>drop</code>, but it also means that if <code>range</code> does not contain at least <code>n</code> elements, it will attempt to call <code>popFront</code> on an empty range, which is undefined behavior. So, only use <code>popFrontExactly</code> when it is guaranteed that <code>range</code> holds at least <code>n</code> elements. </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>range</code>
</td> <td>the <a href="std_range_primitives.html#isInputRange">input range</a> to drop from</td>
</tr> <tr>
<td>size_t <code>n</code>
</td> <td>the number of elements to drop</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>range</code> with <code>n</code> elements dropped </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="std_range_primitives.html#popFrontExcatly"><code>std.range.primitives.popFrontExcatly</code></a>, <a href="std_range_primitives.html#popBackExcatly"><code>std.range.primitives.popBackExcatly</code></a>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.algorithm.iteration : filterBidirectional;

auto a = [1, 2, 3];
writeln(a.dropExactly(2)); // [3]
writeln(a.dropBackExactly(2)); // [1]

string s = "æ—¥æœ¬èªž";
writeln(s.dropExactly(2)); // "èªž"
writeln(s.dropBackExactly(2)); // "æ—¥"

auto bd = filterBidirectional!"true"([1, 2, 3]);
assert(bd.dropExactly(2).equal([3]));
assert(bd.dropBackExactly(2).equal([1]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="dropOne">R <strong id="dropOne">dropOne</strong>(R)(R range)<br><small>  Constraints: if (isInputRange!R); </small><br><br>R <strong id="dropBackOne">dropBackOne</strong>(R)(R range)<br><small>  Constraints: if (isBidirectionalRange!R); </small>
</dt> <dd>
<p>Convenience function which calls <code>range.popFront()</code> and returns <code>range</code>. <code>dropOne</code> makes it easier to pop an element from a range and then pass it to another function within a single expression, whereas <code>popFront</code> would require multiple statements. </p>
<p><code>dropBackOne</code> provides the same functionality but instead calls <code>range.popBack()</code>.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.algorithm.iteration : filterBidirectional;
import std.container.dlist : DList;

auto dl = DList!int(9, 1, 2, 3, 9);
assert(dl[].dropOne().dropBackOne().equal([1, 2, 3]));

auto a = [1, 2, 3];
writeln(a.dropOne()); // [2, 3]
writeln(a.dropBackOne()); // [1, 2]

string s = "æ—¥æœ¬èªž";
import std.exception : assumeWontThrow;
assert(assumeWontThrow(s.dropOne() == "æœ¬èªž"));
assert(assumeWontThrow(s.dropBackOne() == "æ—¥æœ¬"));

auto bd = filterBidirectional!"true"([1, 2, 3]);
assert(bd.dropOne().equal([2, 3]));
assert(bd.dropBackOne().equal([1, 2]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Repeat">struct <strong id="Repeat">Repeat</strong>(T); <br><br>Repeat!T <strong id="repeat">repeat</strong>(T)(T value); <br><br>Take!(Repeat!T) <strong id="repeat">repeat</strong>(T)(T value, size_t n); </dt> <dd>
<p>Create a range which repeats one value. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T <code>value</code>
</td> <td>the value to repeat</td>
</tr> <tr>
<td>size_t <code>n</code>
</td> <td>the number of times to repeat <code>value</code>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>If <code>n</code> is not defined, an infinite random access range with slicing.  If <code>n</code> is defined, a random access range with slicing.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;

assert(5.repeat().take(4).equal([5, 5, 5, 5]));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;

assert(5.repeat(4).equal([5, 5, 5, 5]));
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="Repeat.front">inout @property inout(T) <strong id="front">front</strong>(); <br><br>inout @property inout(T) <strong id="back">back</strong>(); <br><br>enum bool <strong id="empty">empty</strong>; <br><br>void <strong id="popFront">popFront</strong>(); <br><br>void <strong id="popBack">popBack</strong>(); <br><br>inout @property auto <strong id="save">save</strong>(); <br><br>inout inout(T) <strong id="opIndex">opIndex</strong>(size_t); <br><br>auto <strong id="opSlice">opSlice</strong>(size_t i, size_t j); <br><br>enum auto <strong id="opDollar">opDollar</strong>; <br><br>inout auto <strong id="opSlice">opSlice</strong>(size_t, DollarToken); </dt> <dd>
<p>Range primitives</p> </dd> </dl> </dd> <dt class="d_decl" id="generate">auto <strong id="generate">generate</strong>(Fun)(Fun fun)<br><small>  Constraints: if (isCallable!fun); </small><br><br>auto <strong id="generate">generate</strong>(alias fun)()<br><small>  Constraints: if (isCallable!fun); </small>
</dt> <dd>
<p>Given callable (<a href="std_traits.html#isCallable"><code>std.traits.isCallable</code></a>) <code>fun</code>, create as a range whose front is defined by successive calls to <code>fun()</code>. This is especially useful to call function with global side effects (random functions), or to create ranges expressed as a single delegate, rather than an entire <code>front</code>/<code>popFront</code>/<code>empty</code> structure. <code>fun</code> maybe be passed either a template alias parameter (existing function, delegate, struct type defining <code>static opCall</code>) or a run-time value argument (delegate, function object). The result range models an InputRange (<a href="std_range_primitives.html#isInputRange"><code>std.range.primitives.isInputRange</code></a>). The resulting range will call <code>fun()</code> on construction, and every call to <code>popFront</code>, and the cached value will be returned when <code>front</code> is called. </p>
<dl>
<dt>Returns:</dt>
<dd>an <code>inputRange</code> where each element represents another call to fun.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.algorithm.iteration : map;

int i = 1;
auto powersOfTwo = generate!(() =&gt; i *= 2)().take(10);
assert(equal(powersOfTwo, iota(1, 11).map!"2^^a"()));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;

//Returns a run-time delegate
auto infiniteIota(T)(T low, T high)
{
    T i = high;
    return (){if (i == high) i = low; return i++;};
}
//adapted as a range.
assert(equal(generate(infiniteIota(1, 4)).take(10), [1, 2, 3, 1, 2, 3, 1, 2, 3, 1]));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.format : format;
import std.random : uniform;

auto r = generate!(() =&gt; uniform(0, 6)).take(10);
format("%(%s %)", r);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Cycle">struct <strong id="Cycle">Cycle</strong>(R) if (isForwardRange!R &amp;&amp; !isInfinite!R); <br><br>template <strong id="Cycle">Cycle</strong>(R) if (isInfinite!R)<br><br>struct <strong id="Cycle">Cycle</strong>(R) if (isStaticArray!R); <br><br>auto <strong id="cycle">cycle</strong>(R)(R input)<br><small>  Constraints: if (isInputRange!R); </small><br><br>Cycle!R <strong id="cycle">cycle</strong>(R)(R input, size_t index = 0)<br><small>  Constraints: if (isRandomAccessRange!R &amp;&amp; !isInfinite!R); </small><br><br>@system Cycle!R <strong id="cycle">cycle</strong>(R)(ref R input, size_t index = 0)<br><small>  Constraints: if (isStaticArray!R); </small>
</dt> <dd>
<p>Repeats the given forward range ad infinitum. If the original range is infinite (fact that would make <code>Cycle</code> the identity application), <code>Cycle</code> detects that and aliases itself to the range type itself. That works for non-forward ranges too. If the original range has random access, <code>Cycle</code> offers random access and also offers a constructor taking an initial position <code>index</code>. <code>Cycle</code> works with static arrays in addition to ranges, mostly for performance reasons. </p>
<dl>
<dt>Note</dt>
<dd> The input range must not be empty. </dd>
</dl> <dl>
<dt>Tip</dt>
<dd> This is a great way to implement simple circular buffers.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.range : cycle, take;

// Here we create an infinitive cyclic sequence from [1, 2]
// (i.e. get here [1, 2, 1, 2, 1, 2 and so on]) then
// take 5 elements of this sequence (so we have [1, 2, 1, 2, 1])
// and compare them with the expected values for equality.
assert(cycle([1, 2]).take(5).equal([ 1, 2, 1, 2, 1 ]));
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="Cycle.this">this(R input, size_t index = 0); <br><br>@property ref auto <strong id="front">front</strong>(); <br><br>const @property ref auto <strong id="front">front</strong>(); <br><br>@property void <strong id="front">front</strong>(ElementType!R val); <br><br>enum bool <strong id="empty">empty</strong>; <br><br>void <strong id="popFront">popFront</strong>(); <br><br>ref auto <strong id="opIndex">opIndex</strong>(size_t n); <br><br>const ref auto <strong id="opIndex">opIndex</strong>(size_t n); <br><br>void <strong id="opIndexAssign">opIndexAssign</strong>(ElementType!R val, size_t n); <br><br>@property Cycle <strong id="save">save</strong>(); <br><br>enum auto <strong id="opDollar">opDollar</strong>; <br><br>auto <strong id="opSlice">opSlice</strong>(size_t i, size_t j); <br><br>auto <strong id="opSlice">opSlice</strong>(size_t i, DollarToken); </dt> <dd>
<p>Range primitives</p> </dd> </dl> </dd> <dt class="d_decl" id="Zip">struct <strong id="Zip">Zip</strong>(Ranges...) if (Ranges.length &amp;&amp; allSatisfy!(isInputRange, Ranges)); <br><br>auto <strong id="zip">zip</strong>(Ranges...)(Ranges ranges)<br><small>  Constraints: if (Ranges.length &amp;&amp; allSatisfy!(isInputRange, Ranges)); </small><br><br>auto <strong id="zip">zip</strong>(Ranges...)(StoppingPolicy sp, Ranges ranges)<br><small>  Constraints: if (Ranges.length &amp;&amp; allSatisfy!(isInputRange, Ranges)); </small>
</dt> <dd>
<p>Iterate several ranges in lockstep. The element type is a proxy tuple that allows accessing the current element in the <code>n</code>th range by using <code>e[n]</code>. </p>
<p><code>zip</code> is similar to <a href="#lockstep"><code>lockstep</code></a>, but <code>lockstep</code> doesn't bundle its elements and uses the <code>opApply</code> protocol. <code>lockstep</code> allows reference access to the elements in <code>foreach</code> iterations. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>StoppingPolicy <code>sp</code>
</td> <td>controls what <code>zip</code> will do if the ranges are different lengths</td>
</tr> <tr>
<td>Ranges <code>ranges</code>
</td> <td>the ranges to zip together</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>At minimum, an input range. <code>Zip</code> offers the lowest range facilities of all components, e.g. it offers random access iff all ranges offer random access, and also offers mutation and swapping if all ranges offer it. Due to this, <code>Zip</code> is extremely powerful because it allows manipulating several ranges in lockstep. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>An <code>Exception</code> if all of the ranges are not the same length and <code>sp</code> is set to <code>StoppingPolicy.requireSameLength</code>. </dd>
</dl> <dl>
<dt>Limitations</dt>
<dd> The <code>@nogc</code> and <code>nothrow</code> attributes cannot be inferred for the <code>Zip</code> struct because <a href="#StoppingPolicy"><code>StoppingPolicy</code></a> can vary at runtime. This limitation is not shared by the anonymous range returned by the <code>zip</code> function when not given an explicit <code>StoppingPolicy</code> as an argument.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.algorithm.iteration : map;

// pairwise sum
auto arr = only(0, 1, 2);
auto part1 = zip(arr, arr.dropOne).map!"a[0] + a[1]";
assert(part1.equal(only(1, 3)));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.conv : to;

int[] a = [ 1, 2, 3 ];
string[] b = [ "a", "b", "c" ];
string[] result;

foreach (tup; zip(a, b))
{
    result ~= tup[0].to!string ~ tup[1];
}

writeln(result); // ["1a", "2b", "3c"]

size_t idx = 0;
// unpacking tuple elements with foreach
foreach (e1, e2; zip(a, b))
{
    writeln(e1); // a[idx]
    writeln(e2); // b[idx]
    ++idx;
}
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<code>zip</code> is powerful - the following code sorts two arrays in parallel: <pre data-language="d">import std.algorithm.sorting : sort;

int[] a = [ 1, 2, 3 ];
string[] b = [ "a", "c", "b" ];
zip(a, b).sort!((t1, t2) =&gt; t1[0] &gt; t2[0]);

writeln(a); // [3, 2, 1]
// b is sorted according to a's sorting
writeln(b); // ["b", "c", "a"]
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="Zip.this">this(R rs, StoppingPolicy s = StoppingPolicy.shortest); </dt> <dd>
<p>Builds an object. Usually this is invoked indirectly by using the <a href="#zip"><code>zip</code></a> function.</p> </dd> <dt class="d_decl" id="Zip.empty">enum bool <strong id="empty">empty</strong>; </dt> <dd>
<p>Returns <code>true</code> if the range is at end. The test depends on the stopping policy.</p> </dd> <dt class="d_decl" id="Zip.save">@property Zip <strong id="save">save</strong>(); </dt>  <dt class="d_decl" id="Zip.front">@property ElementType <strong id="front">front</strong>(); </dt> <dd>
<p>Returns the current iterated element.</p> </dd> <dt class="d_decl" id="Zip.front.2">@property void <strong id="front">front</strong>(ElementType v); </dt> <dd>
<p>Sets the front of all iterated ranges.</p> </dd> <dt class="d_decl" id="Zip.moveFront">ElementType <strong id="moveFront">moveFront</strong>(); </dt> <dd>
<p>Moves out the front.</p> </dd> <dt class="d_decl" id="Zip.back">@property ElementType <strong id="back">back</strong>(); </dt> <dd>
<p>Returns the rightmost element.</p> </dd> <dt class="d_decl" id="Zip.moveBack">ElementType <strong id="moveBack">moveBack</strong>(); </dt> <dd>
<p>Moves out the back. </p>
<p>Returns the rightmost element.</p> </dd> <dt class="d_decl" id="Zip.back.2">@property void <strong id="back">back</strong>(ElementType v); </dt> <dd>
<p>Returns the current iterated element. </p>
<p>Returns the rightmost element.</p> </dd> <dt class="d_decl" id="Zip.popFront">void <strong id="popFront">popFront</strong>(); </dt> <dd>
<p>Advances to the next element in all controlled ranges.</p> </dd> <dt class="d_decl" id="Zip.popBack">void <strong id="popBack">popBack</strong>(); </dt> <dd>
<p>Calls <code>popBack</code> for all controlled ranges.</p> </dd> <dt class="d_decl" id="Zip.length">@property auto <strong id="length">length</strong>(); </dt> <dd>
<p>Returns the length of this range. Defined only if all ranges define <code>length</code>.</p> </dd> <dt class="d_decl" id="Zip.opDollar">alias <strong id="opDollar">opDollar</strong> = length; </dt> <dd>
<p>Returns the length of this range. Defined only if all ranges define <code>length</code>.</p> </dd> <dt class="d_decl" id="Zip.opSlice">auto <strong id="opSlice">opSlice</strong>(size_t from, size_t to); </dt> <dd>
<p>Returns a slice of the range. Defined only if all range define slicing.</p> </dd> <dt class="d_decl" id="Zip.opIndex">ElementType <strong id="opIndex">opIndex</strong>(size_t n); </dt> <dd>
<p>Returns the <code>n</code>th element in the composite range. Defined if all ranges offer random access.</p> </dd> <dt class="d_decl" id="Zip.opIndexAssign">void <strong id="opIndexAssign">opIndexAssign</strong>(ElementType v, size_t n); </dt> <dd>
<p>Assigns to the <code>n</code>th element in the composite range. Defined if all ranges offer random access. </p>
<p>Returns the <code>n</code>th element in the composite range. Defined if all ranges offer random access.</p> </dd> <dt class="d_decl" id="Zip.moveAt">ElementType <strong id="moveAt">moveAt</strong>(size_t n); </dt> <dd>
<p>Destructively reads the <code>n</code>th element in the composite range. Defined if all ranges offer random access. </p>
<p>Returns the <code>n</code>th element in the composite range. Defined if all ranges offer random access.</p> </dd> </dl> </dd> <dt class="d_decl" id="StoppingPolicy">enum <strong id="StoppingPolicy">StoppingPolicy</strong>: int; </dt> <dd>
<p>Dictates how iteration in a <a href="#zip"><code>zip</code></a> and <a href="#lockstep"><code>lockstep</code></a> should stop. By default stop at the end of the shortest of all ranges.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.exception : assertThrown;
import std.range.primitives;
import std.typecons : tuple;

auto a = [1, 2, 3];
auto b = [4, 5, 6, 7];

auto shortest = zip(StoppingPolicy.shortest, a, b);
assert(shortest.equal([
    tuple(1, 4),
    tuple(2, 5),
    tuple(3, 6)
]));

auto longest = zip(StoppingPolicy.longest, a, b);
assert(longest.equal([
    tuple(1, 4),
    tuple(2, 5),
    tuple(3, 6),
    tuple(0, 7)
]));

auto same = zip(StoppingPolicy.requireSameLength, a, b);
same.popFrontN(3);
assertThrown!Exception(same.popFront);
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="StoppingPolicy.shortest"><strong id="shortest">shortest</strong></dt> <dd>
<p>Stop when the shortest range is exhausted</p> </dd> <dt class="d_decl" id="StoppingPolicy.longest"><strong id="longest">longest</strong></dt> <dd>
<p>Stop when the longest range is exhausted</p> </dd> <dt class="d_decl" id="StoppingPolicy.requireSameLength"><strong id="requireSameLength">requireSameLength</strong></dt> <dd>
<p>Require that all ranges are equal</p> </dd> </dl> </dd> <dt class="d_decl" id="Lockstep">struct <strong id="Lockstep">Lockstep</strong>(Ranges...) if (Ranges.length &gt; 1 &amp;&amp; allSatisfy!(isInputRange, Ranges)); <br><br>Lockstep!Ranges <strong id="lockstep">lockstep</strong>(Ranges...)(Ranges ranges)<br><small>  Constraints: if (allSatisfy!(isInputRange, Ranges)); </small><br><br>Lockstep!Ranges <strong id="lockstep">lockstep</strong>(Ranges...)(Ranges ranges, StoppingPolicy s)<br><small>  Constraints: if (allSatisfy!(isInputRange, Ranges)); </small>
</dt> <dd>
<p>Iterate multiple ranges in lockstep using a <code>foreach</code> loop. In contrast to <a href="#zip"><code>zip</code></a> it allows reference access to its elements. If only a single range is passed in, the <code>Lockstep</code> aliases itself away. If the ranges are of different lengths and <code>s</code> == <code>StoppingPolicy.shortest</code> stop after the shortest range is empty. If the ranges are of different lengths and <code>s</code> == <code>StoppingPolicy.requireSameLength</code>, throw an exception. <code>s</code> may not be <code>StoppingPolicy.longest</code>, and passing this will throw an exception. </p>
<p>Iterating over <code>Lockstep</code> in reverse and with an index is only possible when <code>s</code> == <code>StoppingPolicy.requireSameLength</code>, in order to preserve indexes. If an attempt is made at iterating in reverse when <code>s</code> == <code>StoppingPolicy.shortest</code>, an exception will be thrown. <br><br> By default <code>StoppingPolicy</code> is set to <code>StoppingPolicy.shortest</code>. </p> <dl>
<dt>Limitations</dt>
<dd> The <code>pure</code>, <code>@safe</code>, <code>@nogc</code>, or <code>nothrow</code> attributes cannot be inferred for <code>lockstep</code> iteration. <a href="#zip"><code>zip</code></a> can infer the first two due to a different implementation. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="#zip"><code>zip</code></a>  <code>lockstep</code> is similar to <a href="#zip"><code>zip</code></a>, but <code>zip</code> bundles its elements and returns a range. <code>lockstep</code> also supports reference access. Use <code>zip</code> if you want to pass the result to a range function.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto arr1 = [1,2,3,4,5,100];
auto arr2 = [6,7,8,9,10];

foreach (ref a, b; lockstep(arr1, arr2))
{
    a += b;
}

writeln(arr1); // [7, 9, 11, 13, 15, 100]

/// Lockstep also supports iterating with an index variable:
foreach (index, a, b; lockstep(arr1, arr2))
{
    writeln(arr1[index]); // a
    writeln(arr2[index]); // b
}
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="Lockstep.this">this(R ranges, StoppingPolicy sp = StoppingPolicy.shortest); </dt>  </dl> </dd> <dt class="d_decl" id="Recurrence">struct <strong id="Recurrence">Recurrence</strong>(alias fun, StateType, size_t stateSize); <br><br>Recurrence!(fun, CommonType!State, State.length) <strong id="recurrence">recurrence</strong>(alias fun, State...)(State initial); </dt> <dd>
<p>Creates a mathematical sequence given the initial values and a recurrence function that computes the next value from the existing values. The sequence comes in the form of an infinite forward range. The type <code>Recurrence</code> itself is seldom used directly; most often, recurrences are obtained by calling the function <code>recurrence</code>. </p>
<p>When calling <code>recurrence</code>, the function that computes the next value is specified as a template argument, and the initial values in the recurrence are passed as regular arguments. For example, in a Fibonacci sequence, there are two initial values (and therefore a state size of 2) because computing the next Fibonacci value needs the past two values. <br><br> The signature of this function should be: <pre data-language="d">auto fun(R)(R state, size_t n)
</pre> where <code>n</code> will be the index of the current value, and <code>state</code> will be an opaque state vector that can be indexed with array-indexing notation <code>state[i]</code>, where valid values of <code>i</code> range from <code>(n - 1)</code> to <code>(n - State.length)</code>. <br><br> If the function is passed in string form, the state has name <code>"a"</code> and the zero-based index in the recurrence has name <code>"n"</code>. The given string must return the desired value for <code>a[n]</code> given <code>a[n - 1]</code>, <code>a[n - 2]</code>, <code>a[n - 3]</code>,..., <code>a[n - stateSize]</code>. The state size is dictated by the number of arguments passed to the call to <code>recurrence</code>. The <code>Recurrence</code> struct itself takes care of managing the recurrence's state and shifting it appropriately.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;

// The Fibonacci numbers, using function in string form:
// a[0] = 1, a[1] = 1, and compute a[n+1] = a[n-1] + a[n]
auto fib = recurrence!("a[n-1] + a[n-2]")(1, 1);
assert(fib.take(10).equal([1, 1, 2, 3, 5, 8, 13, 21, 34, 55]));

// The factorials, using function in lambda form:
auto fac = recurrence!((a,n) =&gt; a[n-1] * n)(1);
assert(take(fac, 10).equal([
    1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880
]));

// The triangular numbers, using function in explicit form:
static size_t genTriangular(R)(R state, size_t n)
{
    return state[n-1] + n;
}
auto tri = recurrence!genTriangular(0);
assert(take(tri, 10).equal([0, 1, 3, 6, 10, 15, 21, 28, 36, 45]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Sequence">struct <strong id="Sequence">Sequence</strong>(alias fun, State); <br><br>auto <strong id="sequence">sequence</strong>(alias fun, State...)(State args); </dt> <dd>
<p><code>Sequence</code> is similar to <code>Recurrence</code> except that iteration is presented in the so-called <a href="http://en.wikipedia.org/wiki/Closed_form"> closed form</a>. This means that the <code>n</code>th element in the series is computable directly from the initial values and <code>n</code> itself. This implies that the interface offered by <code>Sequence</code> is a random-access range, as opposed to the regular <code>Recurrence</code>, which only offers forward iteration. </p>
<p>The state of the sequence is stored as a <code>Tuple</code> so it can be heterogeneous.</p> <dl>
<dt>Examples:</dt>
<dd>Odd numbers, using function in string form: <pre data-language="d">auto odds = sequence!("a[0] + n * a[1]")(1, 2);
writeln(odds.front); // 1
odds.popFront();
writeln(odds.front); // 3
odds.popFront();
writeln(odds.front); // 5
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Triangular numbers, using function in lambda form: <pre data-language="d">auto tri = sequence!((a,n) =&gt; n*(n+1)/2)();

// Note random access
writeln(tri[0]); // 0
writeln(tri[3]); // 6
writeln(tri[1]); // 1
writeln(tri[4]); // 10
writeln(tri[2]); // 3
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Fibonacci numbers, using function in explicit form: <pre data-language="d">import std.math : pow, round, sqrt;
static ulong computeFib(S)(S state, size_t n)
{
    // Binet's formula
    return cast(ulong)(round((pow(state[0], n+1) - pow(state[1], n+1)) /
                             state[2]));
}
auto fib = sequence!computeFib(
    (1.0 + sqrt(5.0)) / 2.0,    // Golden Ratio
    (1.0 - sqrt(5.0)) / 2.0,    // Conjugate of Golden Ratio
    sqrt(5.0));

// Note random access with [] operator
writeln(fib[1]); // 1
writeln(fib[4]); // 5
writeln(fib[3]); // 3
writeln(fib[2]); // 2
writeln(fib[9]); // 55
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="iota">auto <strong id="iota">iota</strong>(B, E, S)(B begin, E end, S step)<br><small>  Constraints: if ((isIntegral!(CommonType!(B, E)) || isPointer!(CommonType!(B, E))) &amp;&amp; isIntegral!S); </small><br><br>auto <strong id="iota">iota</strong>(B, E)(B begin, E end)<br><small>  Constraints: if (isFloatingPoint!(CommonType!(B, E))); </small><br><br>auto <strong id="iota">iota</strong>(B, E)(B begin, E end)<br><small>  Constraints: if (isIntegral!(CommonType!(B, E)) || isPointer!(CommonType!(B, E))); </small><br><br>auto <strong id="iota">iota</strong>(E)(E end)<br><small>  Constraints: if (is(typeof(iota(E(0), end)))); </small><br><br>auto <strong id="iota">iota</strong>(B, E, S)(B begin, E end, S step)<br><small>  Constraints: if (isFloatingPoint!(CommonType!(B, E, S))); </small><br><br>auto <strong id="iota">iota</strong>(B, E)(B begin, E end)<br><small>  Constraints: if (!isIntegral!(CommonType!(B, E)) &amp;&amp; !isFloatingPoint!(CommonType!(B, E)) &amp;&amp; !isPointer!(CommonType!(B, E)) &amp;&amp; is(typeof((ref B b) { ++b; } )) &amp;&amp; (is(typeof(B.init &lt; E.init)) || is(typeof(B.init == E.init)))); </small>
</dt> <dd>
<p>Creates a range of values that span the given starting and stopping values. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>B <code>begin</code>
</td> <td>The starting value.</td>
</tr> <tr>
<td>E <code>end</code>
</td> <td>The value that serves as the stopping criterion. This value is not included in the range.</td>
</tr> <tr>
<td>S <code>step</code>
</td> <td>The value to add to the current value at each iteration.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A range that goes through the numbers <code>begin</code>, <code>begin + step</code>, <code>begin + 2 * step</code>, <code>...</code>, up to and excluding <code>end</code>.  The two-argument overloads have <code>step = 1</code>. If <code>begin &lt; end &amp;&amp; step &lt; 0</code> or <code>begin &gt; end &amp;&amp; step &gt; 0</code> or <code>begin == end</code>, then an empty range is returned. If <code>step == 0</code> then <code>begin == end</code> is an error.  For built-in types, the range returned is a random access range. For user-defined types that support <code>++</code>, the range is an input range.  An integral iota also supports <code>in</code> operator from the right. It takes the stepping into account, the integral won't be considered contained if it falls between two consecutive values of the range. <code>contains</code> does the same as in, but from lefthand side. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">void main()
{
    import std.stdio;

    // The following groups all produce the same output of:
    // 0 1 2 3 4

    foreach (i; 0 .. 5)
        writef("%s ", i);
    writeln();

    import std.range : iota;
    foreach (i; iota(0, 5))
        writef("%s ", i);
    writeln();

    writefln("%(%s %|%)", iota(0, 5));

    import std.algorithm.iteration : map;
    import std.algorithm.mutation : copy;
    import std.format;
    iota(0, 5).map!(i =&gt; format("%s ", i)).copy(stdout.lockingTextWriter());
    writeln();
}
</pre>  <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.math : approxEqual;

auto r = iota(0, 10, 1);
assert(equal(r, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]));
assert(equal(r, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]));
assert(3 in r);
assert(r.contains(3)); //Same as above
assert(!(10 in r));
assert(!(-8 in r));
r = iota(0, 11, 3);
assert(equal(r, [0, 3, 6, 9]));
writeln(r[2]); // 6
assert(!(2 in r));
auto rf = iota(0.0, 0.5, 0.1);
assert(approxEqual(rf, [0.0, 0.1, 0.2, 0.3, 0.4]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="TransverseOptions">enum <strong id="TransverseOptions">TransverseOptions</strong>: int; </dt> <dd>
<p>Options for the <a href="#FrontTransversal"><code>FrontTransversal</code></a> and <a href="#Transversal"><code>Transversal</code></a> ranges (below).</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.exception : assertThrown;

auto arr = [[1, 2], [3, 4, 5]];

auto r1 = arr.frontTransversal!(TransverseOptions.assumeJagged);
assert(r1.equal([1, 3]));

// throws on construction
assertThrown!Exception(arr.frontTransversal!(TransverseOptions.enforceNotJagged));

auto r2 = arr.frontTransversal!(TransverseOptions.assumeNotJagged);
assert(r2.equal([1, 3]));

// either assuming or checking for equal lengths makes
// the result a random access range
writeln(r2[0]); // 1
static assert(!__traits(compiles, r1[0]));
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="TransverseOptions.assumeJagged"><strong id="assumeJagged">assumeJagged</strong></dt> <dd>
<p>When transversed, the elements of a range of ranges are assumed to have different lengths (e.g. a jagged array).</p> </dd> <dt class="d_decl" id="TransverseOptions.enforceNotJagged"><strong id="enforceNotJagged">enforceNotJagged</strong></dt> <dd>
<p>The transversal enforces that the elements of a range of ranges have all the same length (e.g. an array of arrays, all having the same length). Checking is done once upon construction of the transversal range.</p> </dd> <dt class="d_decl" id="TransverseOptions.assumeNotJagged"><strong id="assumeNotJagged">assumeNotJagged</strong></dt> <dd>
<p>The transversal assumes, without verifying, that the elements of a range of ranges have all the same length. This option is useful if checking was already done from the outside of the range.</p> </dd> </dl> </dd> <dt class="d_decl" id="FrontTransversal">struct <strong id="FrontTransversal">FrontTransversal</strong>(Ror, TransverseOptions opt = TransverseOptions.assumeJagged); <br><br>FrontTransversal!(RangeOfRanges, opt) <strong id="frontTransversal">frontTransversal</strong>(TransverseOptions opt = TransverseOptions.assumeJagged, RangeOfRanges)(RangeOfRanges rr); </dt> <dd>
<p>Given a range of ranges, iterate transversally through the first elements of each of the enclosed ranges.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
int[][] x = new int[][2];
x[0] = [1, 2];
x[1] = [3, 4];
auto ror = frontTransversal(x);
assert(equal(ror, [ 1, 3 ][]));
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="FrontTransversal.this">this(RangeOfRanges input); </dt> <dd>
<p>Construction from an input.</p> </dd> <dt class="d_decl" id="FrontTransversal.empty">enum bool <strong id="empty">empty</strong>; <br><br>@property ref auto <strong id="front">front</strong>(); <br><br>ElementType <strong id="moveFront">moveFront</strong>(); <br><br>void <strong id="popFront">popFront</strong>(); </dt> <dd>
<p>Forward range primitives.</p> </dd> <dt class="d_decl" id="FrontTransversal.save">@property FrontTransversal <strong id="save">save</strong>(); </dt> <dd>
<p>Duplicates this <code>frontTransversal</code>. Note that only the encapsulating range of range will be duplicated. Underlying ranges will not be duplicated.</p> </dd> <dt class="d_decl" id="FrontTransversal.back">@property ref auto <strong id="back">back</strong>(); <br><br>void <strong id="popBack">popBack</strong>(); <br><br>ElementType <strong id="moveBack">moveBack</strong>(); </dt> <dd>
<p>Bidirectional primitives. They are offered if <code> isBidirectionalRange!RangeOfRanges</code>.</p> </dd> <dt class="d_decl" id="FrontTransversal.opIndex">ref auto <strong id="opIndex">opIndex</strong>(size_t n); <br><br>ElementType <strong id="moveAt">moveAt</strong>(size_t n); <br><br>void <strong id="opIndexAssign">opIndexAssign</strong>(ElementType val, size_t n); </dt> <dd>
<p>Random-access primitive. It is offered if <code> isRandomAccessRange!RangeOfRanges &amp;&amp; (opt == TransverseOptions.assumeNotJagged || opt == TransverseOptions.enforceNotJagged)</code>.</p> </dd> <dt class="d_decl" id="FrontTransversal.opSlice">typeof(this) <strong id="opSlice">opSlice</strong>(size_t lower, size_t upper); </dt> <dd>
<p>Slicing if offered if <code>RangeOfRanges</code> supports slicing and all the conditions for supporting indexing are met.</p> </dd> </dl> </dd> <dt class="d_decl" id="Transversal">struct <strong id="Transversal">Transversal</strong>(Ror, TransverseOptions opt = TransverseOptions.assumeJagged); <br><br>Transversal!(RangeOfRanges, opt) <strong id="transversal">transversal</strong>(TransverseOptions opt = TransverseOptions.assumeJagged, RangeOfRanges)(RangeOfRanges rr, size_t n); </dt> <dd>
<p>Given a range of ranges, iterate transversally through the <code>n</code>th element of each of the enclosed ranges. This function is similar to <code>unzip</code> in other languages. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>opt</td> <td>Controls the assumptions the function makes about the lengths of the ranges</td>
</tr> <tr>
<td>RangeOfRanges <code>rr</code>
</td> <td>An input range of random access ranges</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>At minimum, an input range. Range primitives such as bidirectionality and random access are given if the element type of <code>rr</code> provides them.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
int[][] x = new int[][2];
x[0] = [1, 2];
x[1] = [3, 4];
auto ror = transversal(x, 1);
assert(equal(ror, [ 2, 4 ]));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>The following code does a full unzip <pre data-language="d">import std.algorithm.comparison : equal;
import std.algorithm.iteration : map;
int[][] y = [[1, 2, 3], [4, 5, 6]];
auto z = y.front.walkLength.iota.map!(i =&gt; transversal(y, i));
assert(equal!equal(z, [[1, 4], [2, 5], [3, 6]]));
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="Transversal.this">this(RangeOfRanges input, size_t n); </dt> <dd>
<p>Construction from an input and an index.</p> </dd> <dt class="d_decl" id="Transversal.empty">enum bool <strong id="empty">empty</strong>; <br><br>@property ref auto <strong id="front">front</strong>(); <br><br>E <strong id="moveFront">moveFront</strong>(); <br><br>@property void <strong id="front">front</strong>(E val); <br><br>void <strong id="popFront">popFront</strong>(); <br><br>@property typeof(this) <strong id="save">save</strong>(); </dt> <dd>
<p>Forward range primitives.</p> </dd> <dt class="d_decl" id="Transversal.back">@property ref auto <strong id="back">back</strong>(); <br><br>void <strong id="popBack">popBack</strong>(); <br><br>E <strong id="moveBack">moveBack</strong>(); <br><br>@property void <strong id="back">back</strong>(E val); </dt> <dd>
<p>Bidirectional primitives. They are offered if <code> isBidirectionalRange!RangeOfRanges</code>.</p> </dd> <dt class="d_decl" id="Transversal.opIndex">ref auto <strong id="opIndex">opIndex</strong>(size_t n); <br><br>E <strong id="moveAt">moveAt</strong>(size_t n); <br><br>void <strong id="opIndexAssign">opIndexAssign</strong>(E val, size_t n); </dt> <dd>
<p>Random-access primitive. It is offered if <code> isRandomAccessRange!RangeOfRanges &amp;&amp; (opt == TransverseOptions.assumeNotJagged || opt == TransverseOptions.enforceNotJagged)</code>.</p> </dd> <dt class="d_decl" id="Transversal.opSlice">typeof(this) <strong id="opSlice">opSlice</strong>(size_t lower, size_t upper); </dt> <dd>
<p>Slicing if offered if <code>RangeOfRanges</code> supports slicing and all the conditions for supporting indexing are met.</p> </dd> </dl> </dd> <dt class="d_decl" id="transposed">Transposed!(RangeOfRanges, opt) <strong id="transposed">transposed</strong>(TransverseOptions opt = TransverseOptions.assumeJagged, RangeOfRanges)(RangeOfRanges rr)<br><small>  Constraints: if (isForwardRange!RangeOfRanges &amp;&amp; isInputRange!(ElementType!RangeOfRanges) &amp;&amp; hasAssignableElements!RangeOfRanges); </small>
</dt> <dd>
<p>Given a range of ranges, returns a range of ranges where the <i>i</i>'th subrange contains the <i>i</i>'th elements of the original subranges. </p>
<p><span class="red"><code>Transposed</code> currently defines <code>save</code>, but does not work as a forward range. Consuming a copy made with <code>save</code> will consume all copies, even the original sub-ranges fed into <code>Transposed</code>.</span> </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>opt</td> <td>Controls the assumptions the function makes about the lengths of the ranges (i.e. jagged or not)</td>
</tr> <tr>
<td>RangeOfRanges <code>rr</code>
</td> <td>Range of ranges</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
int[][] ror = [
    [1, 2, 3],
    [4, 5, 6]
];
auto xp = transposed(ror);
assert(equal!"a.equal(b)"(xp, [
    [1, 4],
    [2, 5],
    [3, 6]
]));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int[][] x = new int[][2];
x[0] = [1, 2];
x[1] = [3, 4];
auto tr = transposed(x);
int[][] witness = [ [ 1, 3 ], [ 2, 4 ] ];
uint i;

foreach (e; tr)
{
    writeln(array(e)); // witness[i++]
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Indexed">struct <strong id="Indexed">Indexed</strong>(Source, Indices) if (isRandomAccessRange!Source &amp;&amp; isInputRange!Indices &amp;&amp; is(typeof(Source.init[ElementType!Indices.init]))); <br><br>Indexed!(Source, Indices) <strong id="indexed">indexed</strong>(Source, Indices)(Source source, Indices indices); </dt> <dd>
<p>This struct takes two ranges, <code>source</code> and <code>indices</code>, and creates a view of <code>source</code> as if its elements were reordered according to <code>indices</code>. <code>indices</code> may include only a subset of the elements of <code>source</code> and may also repeat elements. </p>
<p><code>Source</code> must be a random access range. The returned range will be bidirectional or random-access if <code>Indices</code> is bidirectional or random-access, respectively.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
auto source = [1, 2, 3, 4, 5];
auto indices = [4, 3, 1, 2, 0, 4];
auto ind = indexed(source, indices);
assert(equal(ind, [5, 4, 2, 3, 1, 5]));
assert(equal(retro(ind), [5, 1, 3, 2, 4, 5]));
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="Indexed.front">@property ref auto <strong id="front">front</strong>(); <br><br>void <strong id="popFront">popFront</strong>(); <br><br>@property typeof(this) <strong id="save">save</strong>(); <br><br>@property ref auto <strong id="front">front</strong>(ElementType!Source newVal); <br><br>auto <strong id="moveFront">moveFront</strong>(); <br><br>@property ref auto <strong id="back">back</strong>(); <br><br>void <strong id="popBack">popBack</strong>(); <br><br>@property ref auto <strong id="back">back</strong>(ElementType!Source newVal); <br><br>auto <strong id="moveBack">moveBack</strong>(); <br><br>ref auto <strong id="opIndex">opIndex</strong>(size_t index); <br><br>typeof(this) <strong id="opSlice">opSlice</strong>(size_t a, size_t b); <br><br>auto <strong id="opIndexAssign">opIndexAssign</strong>(ElementType!Source newVal, size_t index); <br><br>auto <strong id="moveAt">moveAt</strong>(size_t index); </dt> <dd>
<p>Range primitives</p> </dd> <dt class="d_decl" id="Indexed.source">@property Source <strong id="source">source</strong>(); </dt> <dd>
<p>Returns the source range.</p> </dd> <dt class="d_decl" id="Indexed.indices">@property Indices <strong id="indices">indices</strong>(); </dt> <dd>
<p>Returns the indices range.</p> </dd> <dt class="d_decl" id="Indexed.physicalIndex">size_t <strong id="physicalIndex">physicalIndex</strong>(size_t logicalIndex); </dt> <dd>
<p>Returns the physical index into the source range corresponding to a given logical index. This is useful, for example, when indexing an <code>Indexed</code> without adding another layer of indirection.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto ind = indexed([1, 2, 3, 4, 5], [1, 3, 4]);
writeln(ind.physicalIndex(0)); // 1
</pre> </dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="Chunks">struct <strong id="Chunks">Chunks</strong>(Source) if (isInputRange!Source); <br><br>Chunks!Source <strong id="chunks">chunks</strong>(Source)(Source source, size_t chunkSize)<br><small>  Constraints: if (isInputRange!Source); </small>
</dt> <dd>
<p>This range iterates over fixed-sized chunks of size <code>chunkSize</code> of a <code>source</code> range. <code>Source</code> must be an <a href="std_range_primitives.html#isInputRange">input range</a>. <code>chunkSize</code> must be greater than zero. </p>
<p>If <code>!isInfinite!Source</code> and <code>source.walkLength</code> is not evenly divisible by <code>chunkSize</code>, the back element of this range will contain fewer than <code>chunkSize</code> elements. <br><br> If <code>Source</code> is a forward range, the resulting range will be forward ranges as well. Otherwise, the resulting chunks will be input ranges consuming the same input: iterating over <code>front</code> will shrink the chunk such that subsequent invocations of <code>front</code> will no longer return the full chunk, and calling <code>popFront</code> on the outer range will invalidate any lingering references to previous values of <code>front</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Source <code>source</code>
</td> <td>Range from which the chunks will be selected</td>
</tr> <tr>
<td>size_t <code>chunkSize</code>
</td> <td>Chunk size</td>
</tr> </table></dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="#slide"><code>slide</code></a> </dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>Range of chunks.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
auto source = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
auto chunks = chunks(source, 4);
writeln(chunks[0]); // [1, 2, 3, 4]
writeln(chunks[1]); // [5, 6, 7, 8]
writeln(chunks[2]); // [9, 10]
writeln(chunks.back); // chunks[2]
writeln(chunks.front); // chunks[0]
writeln(chunks.length); // 3
assert(equal(retro(array(chunks)), array(retro(chunks))));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Non-forward input ranges are supported, but with limited semantics. <pre data-language="d">import std.algorithm.comparison : equal;

int i;

// The generator doesn't save state, so it cannot be a forward range.
auto inputRange = generate!(() =&gt; ++i).take(10);

// We can still process it in chunks, but it will be single-pass only.
auto chunked = inputRange.chunks(2);

assert(chunked.front.equal([1, 2]));
assert(chunked.front.empty); // Iterating the chunk has consumed it
chunked.popFront;
assert(chunked.front.equal([3, 4]));
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="Chunks.this">this(Source source, size_t chunkSize); </dt> <dd>
<p>Standard constructor</p> </dd> <dt class="d_decl" id="Chunks.front">@property auto <strong id="front">front</strong>(); <br><br>void <strong id="popFront">popFront</strong>(); <br><br>@property bool <strong id="empty">empty</strong>(); </dt> <dd>
<p>Input range primitives. Always present.</p> </dd> <dt class="d_decl" id="Chunks.save">@property typeof(this) <strong id="save">save</strong>(); </dt> <dd>
<p>Forward range primitives. Only present if <code>Source</code> is a forward range.</p> </dd> <dt class="d_decl" id="Chunks.length">@property size_t <strong id="length">length</strong>(); </dt> <dd>
<p>Length. Only if <code>hasLength!Source</code> is <code>true</code></p> </dd> <dt class="d_decl" id="Chunks.opIndex">auto <strong id="opIndex">opIndex</strong>(size_t index); <br><br>typeof(this) <strong id="opSlice">opSlice</strong>(size_t lower, size_t upper); </dt> <dd>
<p>Indexing and slicing operations. Provided only if <code>hasSlicing!Source</code> is <code>true</code>.</p> </dd> <dt class="d_decl" id="Chunks.back">@property auto <strong id="back">back</strong>(); <br><br>void <strong id="popBack">popBack</strong>(); </dt> <dd>
<p>Bidirectional range primitives. Provided only if both <code>hasSlicing!Source</code> and <code>hasLength!Source</code> are <code>true</code>.</p> </dd> </dl> </dd> <dt class="d_decl" id="EvenChunks">struct <strong id="EvenChunks">EvenChunks</strong>(Source) if (isForwardRange!Source &amp;&amp; hasLength!Source); <br><br>EvenChunks!Source <strong id="evenChunks">evenChunks</strong>(Source)(Source source, size_t chunkCount)<br><small>  Constraints: if (isForwardRange!Source &amp;&amp; hasLength!Source); </small>
</dt> <dd>
<p>This range splits a <code>source</code> range into <code>chunkCount</code> chunks of approximately equal length. <code>Source</code> must be a forward range with known length. </p>
<p>Unlike <a href="#chunks"><code>chunks</code></a>, <code>evenChunks</code> takes a chunk count (not size). The returned range will contain zero or more <code>source.length / chunkCount + 1</code> elements followed by <code>source.length / chunkCount</code> elements. If <code>source.length &lt; chunkCount</code>, some chunks will be empty. <br><br> <code>chunkCount</code> must not be zero, unless <code>source</code> is also empty.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
auto source = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
auto chunks = evenChunks(source, 3);
writeln(chunks[0]); // [1, 2, 3, 4]
writeln(chunks[1]); // [5, 6, 7]
writeln(chunks[2]); // [8, 9, 10]
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="EvenChunks.this">this(Source source, size_t chunkCount); </dt> <dd>
<p>Standard constructor</p> </dd> <dt class="d_decl" id="EvenChunks.front">@property auto <strong id="front">front</strong>(); <br><br>void <strong id="popFront">popFront</strong>(); <br><br>@property bool <strong id="empty">empty</strong>(); <br><br>@property typeof(this) <strong id="save">save</strong>(); </dt> <dd>
<p>Forward range primitives. Always present.</p> </dd> <dt class="d_decl" id="EvenChunks.length">const @property size_t <strong id="length">length</strong>(); </dt> <dd>
<p>Length</p> </dd> <dt class="d_decl" id="EvenChunks.opIndex">auto <strong id="opIndex">opIndex</strong>(size_t index); <br><br>typeof(this) <strong id="opSlice">opSlice</strong>(size_t lower, size_t upper); <br><br>@property auto <strong id="back">back</strong>(); <br><br>void <strong id="popBack">popBack</strong>(); </dt> <dd>
<p>Indexing, slicing and bidirectional operations and range primitives. Provided only if <code>hasSlicing!Source</code> is <code>true</code>.</p> </dd> </dl> </dd> <dt class="d_decl" id="slide">auto <strong id="slide">slide</strong>(Flag!"withPartial" f = Yes.withPartial, Source)(Source source, size_t windowSize, size_t stepSize = 1)<br><small>  Constraints: if (isForwardRange!Source); </small>
</dt> <dd>
<p>A fixed-sized sliding window iteration of size <code>windowSize</code> over a <code>source</code> range by a custom <code>stepSize</code>. </p>
<p>The <code>Source</code> range must be at least a <a href="std_range_primitives.html#isForwardRange">ForwardRange</a> and the <code>windowSize</code> must be greater than zero. <br><br> For <code>windowSize = 1</code> it splits the range into single element groups (aka <code>unflatten</code>) For <code>windowSize = 2</code> it is similar to <code>zip(source, source.save.dropOne)</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>f</td> <td>Whether the last element has fewer elements than <code>windowSize</code> it should be be ignored (<code>No.withPartial</code>) or added (<code>Yes.withPartial</code>)</td>
</tr> <tr>
<td>Source <code>source</code>
</td> <td>Range from which the slide will be selected</td>
</tr> <tr>
<td>size_t <code>windowSize</code>
</td> <td>Sliding window size</td>
</tr> <tr>
<td>size_t <code>stepSize</code>
</td> <td>Steps between the windows (by default 1)</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>Range of all sliding windows with propagated bi-directionality, forwarding, random access, and slicing. </dd>
</dl> <dl>
<dt>Note</dt>
<dd> To avoid performance overhead, <a href="std_range_primitives.html#isBidirectionalRange">bi-directionality</a> is only available when <a href="std_range_primitives.html#hasSlicing"><code>std.range.primitives.hasSlicing</code></a> and <a href="std_range_primitives.html#hasLength"><code>std.range.primitives.hasLength</code></a> are true. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd><a href="#chunks"><code>chunks</code></a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Iterate over ranges with windows <pre data-language="d">import std.algorithm.comparison : equal;

assert([0, 1, 2, 3].slide(2).equal!equal(
    [[0, 1], [1, 2], [2, 3]]
));

assert(5.iota.slide(3).equal!equal(
    [[0, 1, 2], [1, 2, 3], [2, 3, 4]]
));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>set a custom stepsize (default 1) <pre data-language="d">import std.algorithm.comparison : equal;

assert(6.iota.slide(1, 2).equal!equal(
    [[0], [2], [4]]
));

assert(6.iota.slide(2, 4).equal!equal(
    [[0, 1], [4, 5]]
));

assert(iota(7).slide(2, 2).equal!equal(
    [[0, 1], [2, 3], [4, 5], [6]]
));

assert(iota(12).slide(2, 4).equal!equal(
    [[0, 1], [4, 5], [8, 9]]
));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Allow the last slide to have fewer elements than windowSize <pre data-language="d">import std.algorithm.comparison : equal;

assert(3.iota.slide!(No.withPartial)(4).empty);
assert(3.iota.slide!(Yes.withPartial)(4).equal!equal(
    [[0, 1, 2]]
));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Count all the possible substrings of length 2 <pre data-language="d">import std.algorithm.iteration : each;

int[dstring] d;
"AGAGA"d.slide!(Yes.withPartial)(2).each!(a =&gt; d[a]++);
writeln(d); // ["AG"d:2, "GA"d:2]
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>withPartial only has an effect if last element in the range doesn't have the full size <pre data-language="d">import std.algorithm.comparison : equal;

assert(5.iota.slide!(Yes.withPartial)(3, 4).equal!equal([[0, 1, 2], [4]]));
assert(6.iota.slide!(Yes.withPartial)(3, 4).equal!equal([[0, 1, 2], [4, 5]]));
assert(7.iota.slide!(Yes.withPartial)(3, 4).equal!equal([[0, 1, 2], [4, 5, 6]]));

assert(5.iota.slide!(No.withPartial)(3, 4).equal!equal([[0, 1, 2]]));
assert(6.iota.slide!(No.withPartial)(3, 4).equal!equal([[0, 1, 2]]));
assert(7.iota.slide!(No.withPartial)(3, 4).equal!equal([[0, 1, 2], [4, 5, 6]]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="only">auto <strong id="only">only</strong>(Values...)(return scope Values values)<br><small>  Constraints: if (!is(CommonType!Values == void) || Values.length == 0); </small>
</dt> <dd>
<p>Assemble <code>values</code> into a range that carries all its elements in-situ. </p>
<p>Useful when a single value or multiple disconnected values must be passed to an algorithm expecting a range, without having to perform dynamic memory allocation. <br><br> As copying the range means copying all elements, it can be safely returned from functions. For the same reason, copying the returned range may be expensive for a large number of arguments. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Values <code>values</code>
</td> <td>the values to assemble together</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A <code>RandomAccessRange</code> of the assembled values. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="#chain"><code>chain</code></a> to chain ranges</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.algorithm.iteration : filter, joiner, map;
import std.algorithm.searching : findSplitBefore;
import std.uni : isUpper;

assert(equal(only('â™¡'), "â™¡"));
writeln([1, 2, 3, 4].findSplitBefore(only(3))[0]); // [1, 2]

assert(only("one", "two", "three").joiner(" ").equal("one two three"));

string title = "The D Programming Language";
assert(title
    .filter!isUpper // take the upper case letters
    .map!only       // make each letter its own range
    .joiner(".")    // join the ranges together lazily
    .equal("T.D.P.L"));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="enumerate">auto <strong id="enumerate">enumerate</strong>(Enumerator = size_t, Range)(Range range, Enumerator start = 0)<br><small>  Constraints: if (isIntegral!Enumerator &amp;&amp; isInputRange!Range); </small>
</dt> <dd>
<p>Iterate over <code>range</code> with an attached index variable. </p>
<p>Each element is a <a href="std_typecons.html#Tuple"><code>std.typecons.Tuple</code></a> containing the index and the element, in that order, where the index member is named <code>index</code> and the element member is named <code>value</code>. <br><br> The index starts at <code>start</code> and is incremented by one on every iteration. </p> <dl>
<dt>Overflow</dt>
<dd> If <code>range</code> has length, then it is an error to pass a value for <code>start</code> so that <code>start + range.length</code> is bigger than <code>Enumerator.max</code>, thus it is ensured that overflow cannot happen. </dd>
</dl> If <code>range</code> does not have length, and <code>popFront</code> is called when <code>front.index == Enumerator.max</code>, the index will overflow and continue from <code>Enumerator.min</code>.  <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>range</code>
</td> <td>the <a href="std_range_primitives.html#isInputRange">input range</a> to attach indexes to</td>
</tr> <tr>
<td>Enumerator <code>start</code>
</td> <td>the number to start the index counter from</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>At minimum, an input range. All other range primitives are given in the resulting range if <code>range</code> has them. The exceptions are the bidirectional primitives, which are propagated only if <code>range</code> has length. </dd>
</dl> <dl>
<dt>Example</dt>
<dd> Useful for using <code>foreach</code> with an index loop variable: </dd>
</dl>
<pre data-language="d">    import std.stdio : stdin, stdout;
    import std.range : enumerate;

    foreach (lineNum, line; stdin.byLine().enumerate(1))
        stdout.writefln("line #%s: %s", lineNum, line);
</pre>  <dl>
<dt>Examples:</dt>
<dd>Can start enumeration from a negative position: <pre data-language="d">import std.array : assocArray;
import std.range : enumerate;

bool[int] aa = true.repeat(3).enumerate(-1).assocArray();
assert(aa[-1]);
assert(aa[0]);
assert(aa[1]);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isTwoWayCompatible">enum auto <strong id="isTwoWayCompatible">isTwoWayCompatible</strong>(alias fn, T1, T2); </dt> <dd>
<p> Returns true if <code>fn</code> accepts variables of type T1 and T2 in any order. The following code should compile: <pre data-language="d">(ref T1 a, ref T2 b)
{
  fn(a, b);
  fn(b, a);
}
</pre> </p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">void func1(int a, int b);
void func2(int a, float b);

static assert(isTwoWayCompatible!(func1, int, int));
static assert(isTwoWayCompatible!(func1, short, int));
static assert(!isTwoWayCompatible!(func2, int, float));

void func3(ref int a, ref int b);
static assert( isTwoWayCompatible!(func3, int, int));
static assert(!isTwoWayCompatible!(func3, short, int));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="SearchPolicy">enum <strong id="SearchPolicy">SearchPolicy</strong>: int; </dt> <dd>
<p>Policy used with the searching primitives <code>lowerBound</code>, <code> upperBound</code>, and <code>equalRange</code> of <a href="#SortedRange"><code>SortedRange</code></a> below.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;

auto a = assumeSorted([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);
auto p1 = a.upperBound!(SearchPolicy.binarySearch)(3);
assert(p1.equal([4, 5, 6, 7, 8, 9]));

auto p2 = a.lowerBound!(SearchPolicy.gallop)(4);
assert(p2.equal([0, 1, 2, 3]));
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="SearchPolicy.linear"><strong id="linear">linear</strong></dt> <dd>
<p>Searches in a linear fashion.</p> </dd> <dt class="d_decl" id="SearchPolicy.trot"><strong id="trot">trot</strong></dt> <dd>
<p>Searches with a step that is grows linearly (1, 2, 3,...) leading to a quadratic search schedule (indexes tried are 0, 1, 3, 6, 10, 15, 21, 28,...) Once the search overshoots its target, the remaining interval is searched using binary search. The search is completed in <span class="bigoh">ÎŸ(<code>sqrt(n)</code>)</span> time. Use it when you are reasonably confident that the value is around the beginning of the range.</p> </dd> <dt class="d_decl" id="SearchPolicy.gallop"><strong id="gallop">gallop</strong></dt> <dd>
<p>Performs a <a href="https://en.wikipedia.org/wiki/Exponential_search"> galloping search algorithm</a>, i.e. searches with a step that doubles every time, (1, 2, 4, 8, ...) leading to an exponential search schedule (indexes tried are 0, 1, 3, 7, 15, 31, 63,...) Once the search overshoots its target, the remaining interval is searched using binary search. A value is found in <span class="bigoh">ÎŸ(<code>log(n)</code>)</span> time.</p> </dd> <dt class="d_decl" id="SearchPolicy.binarySearch"><strong id="binarySearch">binarySearch</strong></dt> <dd>
<p>Searches using a classic interval halving policy. The search starts in the middle of the range, and each search step cuts the range in half. This policy finds a value in <span class="bigoh">ÎŸ(<code>log(n)</code>)</span> time but is less cache friendly than <code>gallop</code> for large ranges. The <code>binarySearch</code> policy is used as the last step of <code>trot</code>, <code>gallop</code>, <code>trotBackwards</code>, and <code> gallopBackwards</code> strategies.</p> </dd> <dt class="d_decl" id="SearchPolicy.trotBackwards"><strong id="trotBackwards">trotBackwards</strong></dt> <dd>
<p>Similar to <code>trot</code> but starts backwards. Use it when confident that the value is around the end of the range.</p> </dd> <dt class="d_decl" id="SearchPolicy.gallopBackwards"><strong id="gallopBackwards">gallopBackwards</strong></dt> <dd>
<p>Similar to <code>gallop</code> but starts backwards. Use it when confident that the value is around the end of the range.</p> </dd> </dl> </dd> <dt class="d_decl" id="SortedRangeOptions">enum <strong id="SortedRangeOptions">SortedRangeOptions</strong>: int; </dt> <dd>
<p>Options for <a href="#SortedRange"><code>SortedRange</code></a> ranges (below).</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">// create a SortedRange, that's checked strictly
SortedRange!(int[],"a &lt; b", SortedRangeOptions.checkStrictly)([ 1, 3, 5, 7, 9 ]);
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="SortedRangeOptions.assumeSorted"><strong id="assumeSorted">assumeSorted</strong></dt> <dd>
<p>Assume, that the range is sorted without checking.</p> </dd> <dt class="d_decl" id="SortedRangeOptions.checkStrictly"><strong id="checkStrictly">checkStrictly</strong></dt> <dd>
<p>All elements of the range are checked to be sorted. The check is performed in O(n) time.</p> </dd> <dt class="d_decl" id="SortedRangeOptions.checkRoughly"><strong id="checkRoughly">checkRoughly</strong></dt> <dd>
<p>Some elements of the range are checked to be sorted. For ranges with random order, this will almost surely detect, that it is not sorted. For almost sorted ranges it's more likely to fail. The checked elements are choosen in a deterministic manner, which makes this check reproducable. The check is performed in O(log(n)) time.</p> </dd> </dl> </dd> <dt class="d_decl" id="SortedRange">struct <strong id="SortedRange">SortedRange</strong>(Range, alias pred = "a &lt; b", SortedRangeOptions opt = SortedRangeOptions.assumeSorted) if (isInputRange!Range &amp;&amp; !isInstanceOf!(<strong id="SortedRange">SortedRange</strong>, Range)); <br><br>template <strong id="SortedRange">SortedRange</strong>(Range, alias pred = "a &lt; b", SortedRangeOptions opt = SortedRangeOptions.assumeSorted) if (isInstanceOf!(<strong id="SortedRange">SortedRange</strong>, Range))</dt> <dd>
<p>Represents a sorted range. In addition to the regular range primitives, supports additional operations that take advantage of the ordering, such as merge and binary search. To obtain a <code> SortedRange</code> from an unsorted range <code>r</code>, use <a href="std_algorithm_sorting.html#sort"><code>std.algorithm.sorting.sort</code></a> which sorts <code>r</code> in place and returns the corresponding <code>SortedRange</code>. To construct a <code>SortedRange</code> from a range <code>r</code> that is known to be already sorted, use <a href="#assumeSorted"><code>assumeSorted</code></a>. </p>
<dl>
<dt>Parameters:</dt>

</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.sorting : sort;
auto a = [ 1, 2, 3, 42, 52, 64 ];
auto r = assumeSorted(a);
assert(r.contains(3));
assert(!(32 in r));
auto r1 = sort!"a &gt; b"(a);
assert(3 in r1);
assert(!r1.contains(32));
writeln(r1.release()); // [64, 52, 42, 3, 2, 1]
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<code>SortedRange</code> could accept ranges weaker than random-access, but it is unable to provide interesting functionality for them. Therefore, <code>SortedRange</code> is currently restricted to random-access ranges.  No copy of the original range is ever made. If the underlying range is changed concurrently with its corresponding <code>SortedRange</code> in ways that break its sorted-ness, <code>SortedRange</code> will work erratically. <pre data-language="d">import std.algorithm.mutation : swap;
auto a = [ 1, 2, 3, 42, 52, 64 ];
auto r = assumeSorted(a);
assert(r.contains(42));
swap(a[3], a[5]);         // illegal to break sortedness of original range
assert(!r.contains(42));  // passes although it shouldn't
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="SortedRange.empty">@property bool <strong id="empty">empty</strong>(); <br><br>@property auto <strong id="save">save</strong>(); <br><br>@property ref auto <strong id="front">front</strong>(); <br><br>void <strong id="popFront">popFront</strong>(); <br><br>@property ref auto <strong id="back">back</strong>(); <br><br>void <strong id="popBack">popBack</strong>(); <br><br>ref auto <strong id="opIndex">opIndex</strong>(size_t i); <br><br>scope auto <strong id="opSlice">opSlice</strong>(size_t a, size_t b) return; </dt> <dd>
<p>Range primitives.</p> </dd> <dt class="d_decl" id="SortedRange.release">auto <strong id="release">release</strong>(); </dt> <dd>
<p>Releases the controlled range and returns it.</p> </dd> <dt class="d_decl" id="SortedRange.lowerBound">auto <strong id="lowerBound">lowerBound</strong>(SearchPolicy sp = SearchPolicy.binarySearch, V)(V value)<br><small>  Constraints: if (isTwoWayCompatible!(predFun, ElementType!Range, V) &amp;&amp; hasSlicing!Range); </small>
</dt> <dd>
<p>This function uses a search with policy <code>sp</code> to find the largest left subrange on which <code>pred(x, value)</code> is <code>true</code> for all <code>x</code> (e.g., if <code>pred</code> is "less than", returns the portion of the range with elements strictly smaller than <code>value</code>). The search schedule and its complexity are documented in <a href="#SearchPolicy"><code>SearchPolicy</code></a>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
auto a = assumeSorted([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]);
auto p = a.lowerBound(4);
assert(equal(p, [ 0, 1, 2, 3 ]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="SortedRange.upperBound">auto <strong id="upperBound">upperBound</strong>(SearchPolicy sp = SearchPolicy.binarySearch, V)(V value)<br><small>  Constraints: if (isTwoWayCompatible!(predFun, ElementType!Range, V)); </small>
</dt> <dd>
<p>This function searches with policy <code>sp</code> to find the largest right subrange on which <code>pred(value, x)</code> is <code>true</code> for all <code>x</code> (e.g., if <code>pred</code> is "less than", returns the portion of the range with elements strictly greater than <code>value</code>). The search schedule and its complexity are documented in <a href="#SearchPolicy"><code>SearchPolicy</code></a>. </p>
<p>For ranges that do not offer random access, <code>SearchPolicy.linear</code> is the only policy allowed (and it must be specified explicitly lest it exposes user code to unexpected inefficiencies). For random-access searches, all policies are allowed, and <code>SearchPolicy.binarySearch</code> is the default.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
auto a = assumeSorted([ 1, 2, 3, 3, 3, 4, 4, 5, 6 ]);
auto p = a.upperBound(3);
assert(equal(p, [4, 4, 5, 6]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="SortedRange.equalRange">auto <strong id="equalRange">equalRange</strong>(V)(V value)<br><small>  Constraints: if (isTwoWayCompatible!(predFun, ElementType!Range, V) &amp;&amp; isRandomAccessRange!Range); </small>
</dt> <dd>
<p>Returns the subrange containing all elements <code>e</code> for which both <code> pred(e, value)</code> and <code>pred(value, e)</code> evaluate to <code>false</code> (e.g., if <code>pred</code> is "less than", returns the portion of the range with elements equal to <code>value</code>). Uses a classic binary search with interval halving until it finds a value that satisfies the condition, then uses <code>SearchPolicy.gallopBackwards</code> to find the left boundary and <code>SearchPolicy.gallop</code> to find the right boundary. These policies are justified by the fact that the two boundaries are likely to be near the first found value (i.e., equal ranges are relatively small). Completes the entire search in <span class="bigoh">ÎŸ(<code>log(n)</code>)</span> time.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
auto a = [ 1, 2, 3, 3, 3, 4, 4, 5, 6 ];
auto r = a.assumeSorted.equalRange(3);
assert(equal(r, [ 3, 3, 3 ]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="SortedRange.trisect">auto <strong id="trisect">trisect</strong>(V)(V value)<br><small>  Constraints: if (isTwoWayCompatible!(predFun, ElementType!Range, V) &amp;&amp; isRandomAccessRange!Range &amp;&amp; hasLength!Range); </small>
</dt> <dd>
<p>Returns a tuple <code>r</code> such that <code>r[0]</code> is the same as the result of <code>lowerBound(value)</code>, <code>r[1]</code> is the same as the result of <code>equalRange(value)</code>, and <code>r[2]</code> is the same as the result of <code>upperBound(value)</code>. The call is faster than computing all three separately. Uses a search schedule similar to <code>equalRange</code>. Completes the entire search in <span class="bigoh">ÎŸ(<code>log(n)</code>)</span> time.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
auto a = [ 1, 2, 3, 3, 3, 4, 4, 5, 6 ];
auto r = assumeSorted(a).trisect(3);
assert(equal(r[0], [ 1, 2 ]));
assert(equal(r[1], [ 3, 3, 3 ]));
assert(equal(r[2], [ 4, 4, 5, 6 ]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="SortedRange.contains">bool <strong id="contains">contains</strong>(V)(V value)<br><small>  Constraints: if (isRandomAccessRange!Range); </small>
</dt> <dd>
<p>Returns <code>true</code> if and only if <code>value</code> can be found in <code>range</code>, which is assumed to be sorted. Performs <span class="bigoh">ÎŸ(<code>log(r.length)</code>)</span> evaluations of <code>pred</code>.</p> </dd> <dt class="d_decl" id="SortedRange.opBinaryRight">bool <strong id="opBinaryRight">opBinaryRight</strong>(string op, V)(V value)<br><small>  Constraints: if (op == "in" &amp;&amp; isRandomAccessRange!Range); </small>
</dt> <dd>
<p>Like <code>contains</code>, but the value is specified before the range.</p> </dd> <dt class="d_decl" id="SortedRange.groupBy">auto <strong id="groupBy">groupBy</strong>()(); </dt> <dd>
<p>Returns a range of subranges of elements that are equivalent according to the sorting relation.</p> </dd> </dl> </dd> <dt class="d_decl" id="assumeSorted">auto <strong id="assumeSorted">assumeSorted</strong>(alias pred = "a &lt; b", R)(R r)<br><small>  Constraints: if (isInputRange!(Unqual!R)); </small>
</dt> <dd>
<p>Assumes <code>r</code> is sorted by predicate <code>pred</code> and returns the corresponding <code>SortedRange!(pred, R)</code> having <code>r</code> as support. To check for sorted-ness at cost <span class="bigoh">ÎŸ(<code>n</code>)</span>, use <a href="std_algorithm_sorting.html#isSorted"><code>std.algorithm.sorting.isSorted</code></a>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;

int[] a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
auto p = assumeSorted(a);

assert(equal(p.lowerBound(4), [0, 1, 2, 3]));
assert(equal(p.lowerBound(5), [0, 1, 2, 3, 4]));
assert(equal(p.lowerBound(6), [0, 1, 2, 3, 4, 5]));
assert(equal(p.lowerBound(6.9), [0, 1, 2, 3, 4, 5, 6]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="RefRange">struct <strong id="RefRange">RefRange</strong>(R) if (isInputRange!R); <br><br>auto <strong id="refRange">refRange</strong>(R)(R* range)<br><small>  Constraints: if (isInputRange!R); </small>
</dt> <dd>
<p>Wrapper which effectively makes it possible to pass a range by reference. Both the original range and the RefRange will always have the exact same elements. Any operation done on one will affect the other. So, for instance, if it's passed to a function which would implicitly copy the original range if it were passed to it, the original range is <i>not</i> copied but is consumed as if it were a reference type. </p>
<dl>
<dt>Note</dt>
<dd> <code>save</code> works as normal and operates on a new range, so if <code>save</code> is ever called on the <code>RefRange</code>, then no operations on the saved range will affect the original. </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R* <code>range</code>
</td> <td>the range to construct the <code>RefRange</code> from</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A <code>RefRange</code>. If the given range is a class type (and thus is already a reference type), then the original range is returned rather than a <code>RefRange</code>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Basic Example <pre data-language="d">import std.algorithm.searching : find;
ubyte[] buffer = [1, 9, 45, 12, 22];
auto found1 = find(buffer, 45);
writeln(found1); // [45, 12, 22]
writeln(buffer); // [1, 9, 45, 12, 22]

auto wrapped1 = refRange(&amp;buffer);
auto found2 = find(wrapped1, 45);
writeln(*found2.ptr); // [45, 12, 22]
writeln(buffer); // [45, 12, 22]

auto found3 = find(wrapped1.save, 22);
writeln(*found3.ptr); // [22]
writeln(buffer); // [45, 12, 22]

string str = "hello world";
auto wrappedStr = refRange(&amp;str);
writeln(str.front); // 'h'
str.popFrontN(5);
writeln(str); // " world"
writeln(wrappedStr.front); // ' '
writeln(*wrappedStr.ptr); // " world"
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>opAssign Example. <pre data-language="d">ubyte[] buffer1 = [1, 2, 3, 4, 5];
ubyte[] buffer2 = [6, 7, 8, 9, 10];
auto wrapped1 = refRange(&amp;buffer1);
auto wrapped2 = refRange(&amp;buffer2);
assert(wrapped1.ptr is &amp;buffer1);
assert(wrapped2.ptr is &amp;buffer2);
assert(wrapped1.ptr !is wrapped2.ptr);
assert(buffer1 != buffer2);

wrapped1 = wrapped2;

//Everything points to the same stuff as before.
assert(wrapped1.ptr is &amp;buffer1);
assert(wrapped2.ptr is &amp;buffer2);
assert(wrapped1.ptr !is wrapped2.ptr);

//But buffer1 has changed due to the assignment.
writeln(buffer1); // [6, 7, 8, 9, 10]
writeln(buffer2); // [6, 7, 8, 9, 10]

buffer2 = [11, 12, 13, 14, 15];

//Everything points to the same stuff as before.
assert(wrapped1.ptr is &amp;buffer1);
assert(wrapped2.ptr is &amp;buffer2);
assert(wrapped1.ptr !is wrapped2.ptr);

//But buffer2 has changed due to the assignment.
writeln(buffer1); // [6, 7, 8, 9, 10]
writeln(buffer2); // [11, 12, 13, 14, 15]

wrapped2 = null;

//The pointer changed for wrapped2 but not wrapped1.
assert(wrapped1.ptr is &amp;buffer1);
assert(wrapped2.ptr is null);
assert(wrapped1.ptr !is wrapped2.ptr);

//buffer2 is not affected by the assignment.
writeln(buffer1); // [6, 7, 8, 9, 10]
writeln(buffer2); // [11, 12, 13, 14, 15]
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="RefRange.this">pure nothrow @safe this(R* range); </dt>  <dt class="d_decl" id="RefRange.opAssign">auto <strong id="opAssign">opAssign</strong>(RefRange rhs); </dt> <dd>
<p>This does not assign the pointer of <code>rhs</code> to this <code>RefRange</code>. Rather it assigns the range pointed to by <code>rhs</code> to the range pointed to by this <code>RefRange</code>. This is because <i>any</i> operation on a <code>RefRange</code> is the same is if it occurred to the original range. The one exception is when a <code>RefRange</code> is assigned <code>null</code> either directly or because <code>rhs</code> is <code>null</code>. In that case, <code>RefRange</code> no longer refers to the original range but is <code>null</code>.</p> </dd> <dt class="d_decl" id="RefRange.opAssign.2">void <strong id="opAssign">opAssign</strong>(typeof(null) rhs); </dt>  <dt class="d_decl" id="RefRange.ptr">inout pure nothrow @property @safe inout(R*) <strong id="ptr">ptr</strong>(); </dt> <dd>
<p>A pointer to the wrapped range.</p> </dd> <dt class="d_decl" id="RefRange.front">@property auto <strong id="front">front</strong>(); <br><br>const @property auto <strong id="front">front</strong>(); <br><br>@property auto <strong id="front">front</strong>(ElementType!R value); </dt>  <dt class="d_decl" id="RefRange.empty">@property bool <strong id="empty">empty</strong>(); <br><br>const @property bool <strong id="empty">empty</strong>(); </dt>  <dt class="d_decl" id="RefRange.popFront">void <strong id="popFront">popFront</strong>(); </dt>  <dt class="d_decl" id="RefRange.save">@property auto <strong id="save">save</strong>(); <br><br>const @property auto <strong id="save">save</strong>(); <br><br>auto <strong id="opSlice">opSlice</strong>(); <br><br>const auto <strong id="opSlice">opSlice</strong>(); </dt> <dd>
<p>Only defined if <code>isForwardRange!R</code> is <code>true</code>.</p> </dd> <dt class="d_decl" id="RefRange.back">@property auto <strong id="back">back</strong>(); <br><br>const @property auto <strong id="back">back</strong>(); <br><br>@property auto <strong id="back">back</strong>(ElementType!R value); <br><br>void <strong id="popBack">popBack</strong>(); </dt> <dd>
<p>Only defined if <code>isBidirectionalRange!R</code> is <code>true</code>.</p> </dd> <dt class="d_decl" id="RefRange.opIndex">ref auto <strong id="opIndex">opIndex</strong>(IndexType)(IndexType index); <br><br>const ref auto <strong id="opIndex">opIndex</strong>(IndexType)(IndexType index); </dt> <dd>
<p>Only defined if <code>isRandomAccesRange!R</code> is <code>true</code>.</p> </dd> <dt class="d_decl" id="RefRange.moveFront">auto <strong id="moveFront">moveFront</strong>(); </dt> <dd>
<p>Only defined if <code>hasMobileElements!R</code> and <code>isForwardRange!R</code> are <code>true</code>.</p> </dd> <dt class="d_decl" id="RefRange.moveBack">auto <strong id="moveBack">moveBack</strong>(); </dt> <dd>
<p>Only defined if <code>hasMobileElements!R</code> and <code>isBidirectionalRange!R</code> are <code>true</code>.</p> </dd> <dt class="d_decl" id="RefRange.moveAt">auto <strong id="moveAt">moveAt</strong>(size_t index); </dt> <dd>
<p>Only defined if <code>hasMobileElements!R</code> and <code>isRandomAccessRange!R</code> are <code>true</code>.</p> </dd> <dt class="d_decl" id="RefRange.length">@property size_t <strong id="length">length</strong>(); <br><br>const @property size_t <strong id="length">length</strong>(); <br><br>alias <strong id="opDollar">opDollar</strong> = length; </dt> <dd>
<p>Only defined if <code>hasLength!R</code> is <code>true</code>.</p> </dd> <dt class="d_decl" id="RefRange.opSlice.2">auto <strong id="opSlice">opSlice</strong>(IndexType1, IndexType2)(IndexType1 begin, IndexType2 end); <br><br>const auto <strong id="opSlice">opSlice</strong>(IndexType1, IndexType2)(IndexType1 begin, IndexType2 end); </dt> <dd>
<p>Only defined if <code>hasSlicing!R</code> is <code>true</code>.</p> </dd> </dl> </dd> <dt class="d_decl" id="bitwise">auto <strong id="bitwise">bitwise</strong>(R)(auto ref R range)<br><small>  Constraints: if (isInputRange!R &amp;&amp; isIntegral!(ElementType!R)); </small>
</dt> <dd>
<p>Bitwise adapter over an integral type range. Consumes the range elements bit by bit, from the least significant bit to the most significant bit. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R</td> <td>an integral <a href="std_range_primitives.html#isInputRange">input range</a> to iterate over</td>
</tr> <tr>
<td>R <code>range</code>
</td> <td>range to consume bit by by</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A <code>Bitwise</code> input range with propagated forward, bidirectional and random access capabilities</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.format : format;

// 00000011 00001001
ubyte[] arr = [3, 9];
auto r = arr.bitwise;

// iterate through it as with any other range
writeln(format("%(%d%)", r)); // "1100000010010000"
assert(format("%(%d%)", r.retro).equal("1100000010010000".retro));

auto r2 = r[5 .. $];
// set a bit
r[2] = 1;
writeln(arr[0]); // 7
writeln(r[5]); // r2[0]
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>You can use bitwise to implement an uniform bool generator <pre data-language="d">import std.algorithm.comparison : equal;
import std.random : rndGen;

auto rb = rndGen.bitwise;
static assert(isInfinite!(typeof(rb)));

auto rb2 = rndGen.bitwise;
// Don't forget that structs are passed by value
assert(rb.take(10).equal(rb2.take(10)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="NullSink">struct <strong id="NullSink">NullSink</strong>; <br><br>ref auto <strong id="nullSink">nullSink</strong>(); </dt> <dd>
<p>An OutputRange that discards the data it receives.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.iteration : map;
import std.algorithm.mutation : copy;
[4, 5, 6].map!(x =&gt; x * 2).copy(nullSink); // data is discarded
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.csv : csvNextToken;

string line = "a,b,c";

// ignore the first column
line.csvNextToken(nullSink, ',', '"');
line.popFront;

// look at the second column
Appender!string app;
line.csvNextToken(app, ',', '"');
writeln(app.data); // "b"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="tee">auto <strong id="tee">tee</strong>(Flag!"pipeOnPop" pipeOnPop = Yes.pipeOnPop, R1, R2)(R1 inputRange, R2 outputRange)<br><small>  Constraints: if (isInputRange!R1 &amp;&amp; isOutputRange!(R2, ElementType!R1)); </small><br><br>auto <strong id="tee">tee</strong>(alias fun, Flag!"pipeOnPop" pipeOnPop = Yes.pipeOnPop, R1)(R1 inputRange)<br><small>  Constraints: if (is(typeof(fun) == void) || isSomeFunction!fun); </small>
</dt> <dd>
<p>Implements a "tee" style pipe, wrapping an input range so that elements of the range can be passed to a provided function or <a href="#OutputRange"><code>OutputRange</code></a> as they are iterated over. This is useful for printing out intermediate values in a long chain of range code, performing some operation with side-effects on each call to <code>front</code> or <code>popFront</code>, or diverting the elements of a range into an auxiliary <a href="#OutputRange"><code>OutputRange</code></a>. </p>
<p>It is important to note that as the resultant range is evaluated lazily, in the case of the version of <code>tee</code> that takes a function, the function will not actually be executed until the range is "walked" using functions that evaluate ranges, such as <a href="std_array.html#array"><code>std.array.array</code></a> or <a href="std_algorithm_iteration.html#fold"><code>std.algorithm.iteration.fold</code></a>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>pipeOnPop</td> <td>If <code>Yes.pipeOnPop</code>, simply iterating the range without ever calling <code>front</code> is enough to have <code>tee</code> mirror elements to <code>outputRange</code> (or, respectively, <code>fun</code>). Note that each <code>popFront()</code> call will mirror the old <code>front</code> value, not the new one. This means that the last value will not be forwarded if the range isn't iterated until empty. If <code>No.pipeOnPop</code>, only elements for which <code>front</code> does get called will be also sent to <code>outputRange</code>/<code>fun</code>. If <code>front</code> is called twice for the same element, it will still be sent only once. If this caching is undesired, consider using <a href="std_algorithm_iteration.html#map"><code>std.algorithm.iteration.map</code></a> instead.</td>
</tr> <tr>
<td>R1 <code>inputRange</code>
</td> <td>The input range being passed through.</td>
</tr> <tr>
<td>R2 <code>outputRange</code>
</td> <td>This range will receive elements of <code>inputRange</code> progressively as iteration proceeds.</td>
</tr> <tr>
<td>fun</td> <td>This function will be called with elements of <code>inputRange</code> progressively as iteration proceeds.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>An input range that offers the elements of <code>inputRange</code>. Regardless of whether <code>inputRange</code> is a more powerful range (forward, bidirectional etc), the result is always an input range. Reading this causes <code>inputRange</code> to be iterated and returns its elements in turn. In addition, the same elements will be passed to <code>outputRange</code> or <code>fun</code> as well. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd><a href="std_algorithm_iteration.html#each"><code>std.algorithm.iteration.each</code></a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.algorithm.iteration : filter, map;

// Sum values while copying
int[] values = [1, 4, 9, 16, 25];
int sum = 0;
auto newValues = values.tee!(a =&gt; sum += a).array;
assert(equal(newValues, values));
writeln(sum); // 1 + 4 + 9 + 16 + 25

// Count values that pass the first filter
int count = 0;
auto newValues4 = values.filter!(a =&gt; a &lt; 10)
                        .tee!(a =&gt; count++)
                        .map!(a =&gt; a + 1)
                        .filter!(a =&gt; a &lt; 10);

//Fine, equal also evaluates any lazy ranges passed to it.
//count is not 3 until equal evaluates newValues4
assert(equal(newValues4, [2, 5]));
writeln(count); // 3
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="padLeft">auto <strong id="padLeft">padLeft</strong>(R, E)(R r, E e, size_t n)<br><small>  Constraints: if ((isInputRange!R &amp;&amp; hasLength!R || isForwardRange!R) &amp;&amp; !is(CommonType!(ElementType!R, E) == void)); </small>
</dt> <dd>
<p>Extends the length of the input range <code>r</code> by padding out the start of the range with the element <code>e</code>. The element <code>e</code> must be of a common type with the element type of the range <code>r</code> as defined by <a href="std_traits.html#CommonType"><code>std.traits.CommonType</code></a>. If <code>n</code> is less than the length of of <code>r</code>, then <code>r</code> is returned unmodified. </p>
<p>If <code>r</code> is a string with Unicode characters in it, <code>padLeft</code> follows D's rules about length for strings, which is not the number of characters, or graphemes, but instead the number of encoding units. If you want to treat each grapheme as only one encoding unit long, then call <a href="std_uni.html#byGrapheme"><code>std.uni.byGrapheme</code></a> before calling this function. <br><br> If <code>r</code> has a length, then this is <span class="bigoh">ÎŸ(<code>1</code>)</span>. Otherwise, it's <span class="bigoh">ÎŸ(<code>r.length</code>)</span>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>r</code>
</td> <td>an <a href="std_range_primitives.html#isInputRange">input range</a> with a length, or a forward range</td>
</tr> <tr>
<td>E <code>e</code>
</td> <td>element to pad the range with</td>
</tr> <tr>
<td>size_t <code>n</code>
</td> <td>the length to pad to</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A range containing the elements of the original range with the extra padding  See Also: <a href="std_string.html#leftJustifier"><code>std.string.leftJustifier</code></a>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;

assert([1, 2, 3, 4].padLeft(0, 6).equal([0, 0, 1, 2, 3, 4]));
assert([1, 2, 3, 4].padLeft(0, 3).equal([1, 2, 3, 4]));

assert("abc".padLeft('_', 6).equal("___abc"));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="padRight">auto <strong id="padRight">padRight</strong>(R, E)(R r, E e, size_t n)<br><small>  Constraints: if (isInputRange!R &amp;&amp; !isInfinite!R &amp;&amp; !is(CommonType!(ElementType!R, E) == void)); </small>
</dt> <dd>
<p>Extend the length of the input range <code>r</code> by padding out the end of the range with the element <code>e</code>. The element <code>e</code> must be of a common type with the element type of the range <code>r</code> as defined by <a href="std_traits.html#CommonType"><code>std.traits.CommonType</code></a>. If <code>n</code> is less than the length of of <code>r</code>, then the contents of <code>r</code> are returned. </p>
<p>The range primitives that the resulting range provides depends whether or not <code>r</code> provides them. Except the functions <code>back</code> and <code>popBack</code>, which also require the range to have a length as well as <code>back</code> and <code>popBack</code> </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>r</code>
</td> <td>an <a href="std_range_primitives.html#isInputRange">input range</a> with a length</td>
</tr> <tr>
<td>E <code>e</code>
</td> <td>element to pad the range with</td>
</tr> <tr>
<td>size_t <code>n</code>
</td> <td>the length to pad to</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A range containing the elements of the original range with the extra padding  See Also: <a href="std_string.html#rightJustifier"><code>std.string.rightJustifier</code></a>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;

assert([1, 2, 3, 4].padRight(0, 6).equal([1, 2, 3, 4, 0, 0]));
assert([1, 2, 3, 4].padRight(0, 4).equal([1, 2, 3, 4]));

assert("abc".padRight('_', 6).equal("abc___"));
</pre> </dd>
</dl> </dd> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1999&ndash;2021 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/std_range.html" class="_attribution-link">https://dlang.org/phobos/std_range.html</a>
  </p>
</div>
