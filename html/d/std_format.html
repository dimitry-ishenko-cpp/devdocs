<h1>std.format</h1>  <p>This module implements the formatting functionality for strings and I/O. It's comparable to C99's <code>vsprintf()</code> and uses a similar format encoding scheme. </p>
<p>For an introductory look at <b>std.format</b>'s capabilities and how to use this module see the dedicated <a href="http://wiki.dlang.org/Defining_custom_print_format_specifiers">DWiki article</a>. <br><br> This module centers around two functions: <br><br> <table>

<tr>
<th scope="col">Function Name</th> <th scope="col">Description</th> </tr> <tr>
<td><a href="#formattedRead"><code>formattedRead</code></a></td> <td>Reads values according to the format string from an InputRange. </td>
</tr> <tr>
<td><a href="#formattedWrite"><code>formattedWrite</code></a></td> <td>Formats its arguments according to the format string and puts them to an OutputRange. </td>
</tr> </table> <br><br> Please see the documentation of function <a href="#formattedWrite"><code>formattedWrite</code></a> for a description of the format string. <br><br> Two functions have been added for convenience: <br><br> <table>

<tr>
<th scope="col">Function Name</th> <th scope="col">Description</th> </tr> <tr>
<td><a href="#format"><code>format</code></a></td> <td>Returns a GC-allocated string with the formatting result. </td>
</tr> <tr>
<td><a href="#sformat"><code>sformat</code></a></td> <td>Puts the formatting result into a preallocated array. </td>
</tr> </table> <br><br> These two functions are publicly imported by <a href="std_string.html"><code>std.string</code></a> to be easily available. <br><br> The functions <a href="#formatValue"><code>formatValue</code></a> and <a href="#unformatValue"><code>unformatValue</code></a> are used for the plumbing. </p> <dl>
<dt>License:</dt>
<dd>
<a href="http://boost.org/LICENSE_1_0.txt">Boost License 1.0</a>. </dd>
</dl> <dl>
<dt>Authors:</dt>
<dd>
<a href="http://walterbright.com">Walter Bright</a>, <a href="http://erdani.com"> Andrei Alexandrescu</a>, and Kenji Hara </dd>
</dl> <dl>
<dt>Source</dt>
<dd> <span class="phobos_src"><a class="https" href="https://github.com/dlang/phobos/blob/master/std/format.d">std/format.d</a></span>
</dd>
</dl> <dl>
<dt class="d_decl" id="FormatException">class <strong id="FormatException">FormatException</strong>: object.Exception; </dt> <dd>
<p>Signals a mismatch between a format and its corresponding argument.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.exception : assertThrown;
assertThrown!FormatException(format("%d", "foo"));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="formattedWrite">uint <strong id="formattedWrite">formattedWrite</strong>(alias fmt, Writer, A...)(auto ref Writer w, A args)<br><small>  Constraints: if (isSomeString!(typeof(fmt))); </small><br><br>uint <strong id="formattedWrite">formattedWrite</strong>(Writer, Char, A...)(auto ref Writer w, scope const Char[] fmt, A args); </dt> <dd>
<p>Interprets variadic argument list <code>args</code>, formats them according to <code>fmt</code>, and sends the resulting characters to <code>w</code>. The encoding of the output is the same as <code>Char</code>. The type <code>Writer</code> must satisfy <code><a href="std_range_primitives.html#isOutputRange">std.range.primitives.isOutputRange</a>!(Writer, Char)</code>. </p>
<p>The variadic arguments are normally consumed in order. POSIX-style <a href="http://opengroup.org/onlinepubs/009695399/functions/printf.html"> positional parameter syntax</a> is also supported. Each argument is formatted into a sequence of chars according to the format specification, and the characters are passed to <code>w</code>. As many arguments as specified in the format string are consumed and formatted. If there are fewer arguments than format specifiers, a <code>FormatException</code> is thrown. If there are more remaining arguments than needed by the format specification, they are ignored but only if at least one argument was formatted. <br><br> The format string supports the formatting of array and nested array elements via the grouping format specifiers <b>%(</b> and <b>%)</b>. Each matching pair of <b>%(</b> and <b>%)</b> corresponds with a single array argument. The enclosed sub-format string is applied to individual array elements. The trailing portion of the sub-format string following the conversion specifier for the array element is interpreted as the array delimiter, and is therefore omitted following the last array element. The <b>%|</b> specifier may be used to explicitly indicate the start of the delimiter, so that the preceding portion of the string will be included following the last array element. (See below for explicit examples.) </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Writer <code>w</code>
</td> <td>Output is sent to this writer. Typical output writers include <a href="std_array.html#Appender!string"><code>std.array.Appender!string</code></a> and <a href="std_stdio.html#LockingTextWriter"><code>std.stdio.LockingTextWriter</code></a>.</td>
</tr> <tr>
<td>Char[] <code>fmt</code>
</td> <td>Format string.</td>
</tr> <tr>
<td>A <code>args</code>
</td> <td>Variadic argument list.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>Formatted number of arguments. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>Mismatched arguments and formats result in a <code> FormatException</code> being thrown. </dd>
</dl> <dl>
<dt>Format String</dt>
<dd> <a name="format-string"><i>Format strings</i></a> consist of characters interspersed with <i>format specifications</i>. Characters are simply copied to the output (such as putc) after any necessary conversion to the corresponding UTF-8 sequence. </dd>
</dl> The format string has the following grammar:  <pre>FormatString:
    FormatStringItem*
FormatStringItem:
    '%%'
    '%' Position Flags Width Separator Precision FormatChar
    '%(' FormatString '%)'
    '%-(' FormatString '%)'
    OtherCharacterExceptPercent
Position:
    empty
    Integer '$'
Flags:
    empty
    '-' Flags
    '+' Flags
    '#' Flags
    '0' Flags
    ' ' Flags
Width:
    empty
    Integer
    '*'
Separator:
    empty
    ','
    ',' '?'
    ',' '*' '?'
    ',' Integer '?'
    ',' '*'
    ',' Integer
Precision:
    empty
    '.'
    '.' Integer
    '.*'
Integer:
    Digit
    Digit Integer
Digit:
    '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'
FormatChar:
    's'|'c'|'b'|'d'|'o'|'x'|'X'|'e'|'E'|'f'|'F'|'g'|'G'|'a'|'A'|'|'
</pre>  <table>
<caption>Flags affect formatting depending on the specifier as follows.</caption>
<tr>
<th scope="col">Flag</th> <th scope="col">Types affected</th> <th scope="col">Semantics</th>
</tr>  <tr>
<td>'-'</td> <td>numeric, bool, null, char, string, enum, pointer</td> <td>Left justify the result in the field. It overrides any 0 flag.</td>
</tr>  <tr>
<td>'+'</td> <td>numeric</td> <td>Prefix positive numbers in a signed conversion with a +. It overrides any <i>space</i> flag.</td>
</tr>  <tr>
<td>'#'</td> <td>integral ('o')</td> <td>Add to precision as necessary so that the first digit of the octal formatting is a '0', even if both the argument and the <i> Precision</i> are zero.</td>
</tr>  <tr>
<td>'#'</td> <td>integral ('x', 'X')</td> <td>If non-zero, prefix result with 0x (0X).</td>
</tr>  <tr>
<td>'#'</td> <td>floating</td> <td>Always insert the decimal point and print trailing zeros.</td>
</tr>  <tr>
<td>'0'</td> <td>numeric</td> <td>Use leading zeros to pad rather than spaces (except for the floating point values <code>nan</code> and <code>infinity</code>). Ignore if there's a <i> Precision</i>.</td>
</tr>  <tr>
<td>' '</td> <td>numeric</td> <td>Prefix positive numbers in a signed conversion with a space.</td>
</tr>
</table>  <dl> <dt><i>Width</i></dt> <dd> Only used for numeric, bool, null, char, string, enum and pointer types. Specifies the minimum field width. If the width is a <b>*</b>, an additional argument of type <b>int</b>, preceding the actual argument, is taken as the width. If the width is negative, it is as if the <b>-</b> was given as a <i>Flags</i> character.</dd>  <dt><i>Precision</i></dt> <dd>Gives the precision for numeric conversions. If the precision is a <b>*</b>, an additional argument of type <b>int</b>, preceding the actual argument, is taken as the precision. If it is negative, it is as if there was no <i>Precision</i> specifier.</dd>  <dt><i>Separator</i></dt> <dd>Inserts the separator symbols ',' every <i>X</i> digits, from right to left, into numeric values to increase readability. The fractional part of floating point values inserts the separator from left to right. Entering an integer after the ',' allows to specify <i>X</i>. If a '*' is placed after the ',' then <i>X</i> is specified by an additional parameter to the format function. Adding a '?' after the ',' or <i>X</i> specifier allows to specify the separator character as an additional parameter. </dd>  <dt><i>FormatChar</i></dt> <dd> <dl> <dt><b>'s'</b></dt> <dd>The corresponding argument is formatted in a manner consistent with its type: <dl> <dt><b>bool</b></dt> <dd>The result is <code>"true"</code> or <code>"false"</code>.</dd> <dt>integral types</dt> <dd>The <b>%d</b> format is used.</dd> <dt>floating point types</dt> <dd>The <b>%g</b> format is used.</dd> <dt>string types</dt> <dd>The result is the string converted to UTF-8. A <i>Precision</i> specifies the maximum number of characters to use in the result.</dd> <dt>structs</dt> <dd>If the struct defines a <b>toString()</b> method the result is the string returned from this function. Otherwise the result is StructName(field<sub>0</sub>, field<sub>1</sub>, ...) where field<sub>n</sub> is the nth element formatted with the default format.</dd> <dt>classes derived from <b>Object</b>
</dt> <dd>The result is the string returned from the class instance's <b>.toString()</b> method. A <i>Precision</i> specifies the maximum number of characters to use in the result.</dd> <dt>unions</dt> <dd>If the union defines a <b>toString()</b> method the result is the string returned from this function. Otherwise the result is the name of the union, without its contents.</dd> <dt>non-string static and dynamic arrays</dt> <dd>The result is [s<sub>0</sub>, s<sub>1</sub>, ...] where s<sub>n</sub> is the nth element formatted with the default format.</dd> <dt>associative arrays</dt> <dd>The result is the equivalent of what the initializer would look like for the contents of the associative array, e.g.: ["red" : 10, "blue" : 20].</dd> </dl>
</dd>  <dt><b>'c'</b></dt> <dd>The corresponding argument must be a character type.</dd>  <dt><b>'b','d','o','x','X'</b></dt> <dd>The corresponding argument must be an integral type and is formatted as an integer. If the argument is a signed type and the <i>FormatChar</i> is <b>d</b> it is converted to a signed string of characters, otherwise it is treated as unsigned. An argument of type <b>bool</b> is formatted as '1' or '0'. The base used is binary for <b>b</b>, octal for <b>o</b>, decimal for <b>d</b>, and hexadecimal for <b>x</b> or <b>X</b>. <b>x</b> formats using lower case letters, <b>X</b> uppercase. If there are fewer resulting digits than the <i>Precision</i>, leading zeros are used as necessary. If the <i>Precision</i> is 0 and the number is 0, no digits result.</dd>  <dt><b>'e','E'</b></dt> <dd>A floating point number is formatted as one digit before the decimal point, <i>Precision</i> digits after, the <i>FormatChar</i>, ±, followed by at least a two digit exponent: <i>d.dddddd</i>e<i>±dd</i>. If there is no <i>Precision</i>, six digits are generated after the decimal point. If the <i>Precision</i> is 0, no decimal point is generated.</dd>  <dt><b>'f','F'</b></dt> <dd>A floating point number is formatted in decimal notation. The <i>Precision</i> specifies the number of digits generated after the decimal point. It defaults to six. At least one digit is generated before the decimal point. If the <i>Precision</i> is zero, no decimal point is generated.</dd>  <dt><b>'g','G'</b></dt> <dd>A floating point number is formatted in either <b>e</b> or <b>f</b> format for <b>g</b>; <b>E</b> or <b>F</b> format for <b>G</b>. The <b>f</b> format is used if the exponent for an <b>e</b> format is greater than -5 and less than the <i>Precision</i>. The <i>Precision</i> specifies the number of significant digits, and defaults to six. Trailing zeros are elided after the decimal point, if the fractional part is zero then no decimal point is generated.</dd>  <dt><b>'a','A'</b></dt> <dd>A floating point number is formatted in hexadecimal exponential notation 0x<i>h.hhhhhh</i>p<i>±d</i>. There is one hexadecimal digit before the decimal point, and as many after as specified by the <i>Precision</i>. If the <i>Precision</i> is zero, no decimal point is generated. If there is no <i>Precision</i>, as many hexadecimal digits as necessary to exactly represent the mantissa are generated. The exponent is written in as few digits as possible, but at least one, is in decimal, and represents a power of 2 as in <i>h.hhhhhh</i>*2<sup><i>±d</i></sup>. The exponent for zero is zero. The hexadecimal digits, x and p are in upper case if the <i>FormatChar</i> is upper case.</dd> </dl>
</dd> </dl>  Floating point NaN's are formatted as <b>nan</b> if the <i>FormatChar</i> is lower case, or <b>NAN</b> if upper. Floating point infinities are formatted as <b>inf</b> or <b>infinity</b> if the <i>FormatChar</i> is lower case, or <b>INF</b> or <b>INFINITY</b> if upper.  The positional and non-positional styles can be mixed in the same format string. (POSIX leaves this behavior undefined.) The internal counter for non-positional parameters tracks the next parameter after the largest positional parameter already used.  Example using array and nested array formatting: <pre data-language="d">import std.stdio;

void main()
{
    writefln("My items are %(%s %).", [1,2,3]);
    writefln("My items are %(%s, %).", [1,2,3]);
}
</pre> The output is: <pre>My items are 1 2 3.
My items are 1, 2, 3.
</pre>  The trailing end of the sub-format string following the specifier for each item is interpreted as the array delimiter, and is therefore omitted following the last array item. The <b>%|</b> delimiter specifier may be used to indicate where the delimiter begins, so that the portion of the format string prior to it will be retained in the last array element: <pre data-language="d">import std.stdio;

void main()
{
    writefln("My items are %(-%s-%|, %).", [1,2,3]);
}
</pre> which gives the output: <pre>My items are -1-, -2-, -3-.
</pre>  These compound format specifiers may be nested in the case of a nested array argument: <pre data-language="d">import std.stdio;
void main() {
     auto mat = [[1, 2, 3],
                 [4, 5, 6],
                 [7, 8, 9]];

     writefln("%(%(%d %)\n%)", mat);
     writeln();

     writefln("[%(%(%d %)\n %)]", mat);
     writeln();

     writefln("[%([%(%d %)]%|\n %)]", mat);
     writeln();
}
</pre> The output is: <pre>1 2 3
4 5 6
7 8 9


[1 2 3
 4 5 6
 7 8 9]


[[1 2 3]
 [4 5 6]
 [7 8 9]]
</pre>  Inside a compound format specifier, strings and characters are escaped automatically. To avoid this behavior, add <b>'-'</b> flag to <code>"%("</code>. <pre data-language="d">import std.stdio;

void main()
{
    writefln("My friends are %s.", ["John", "Nancy"]);
    writefln("My friends are %(%s, %).", ["John", "Nancy"]);
    writefln("My friends are %-(%s, %).", ["John", "Nancy"]);
}
</pre> which gives the output: <pre>My friends are ["John", "Nancy"].
My friends are "John", "Nancy".
My friends are John, Nancy.
</pre> <dl>
<dt>Examples:</dt>
<dd>The format string can be checked at compile-time (see <a href="#format"><code>format</code></a> for details): <pre data-language="d">import std.array : appender;

auto writer = appender!string();
writer.formattedWrite!"%s is the ultimate %s."(42, "answer");
writeln(writer.data); // "42 is the ultimate answer."

// Clear the writer
writer = appender!string();
formattedWrite(writer, "Date: %2&amp;dollar;s %1&amp;dollar;s", "October", 5);
writeln(writer.data); // "Date: 5 October"
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(format("%,d", 1000)); // "1,000"
writeln(format("%,f", 1234567.891011)); // "1,234,567.891011"
writeln(format("%,?d", '?', 1000)); // "1?000"
writeln(format("%,1d", 1000)); // "1,0,0,0"
writeln(format("%,*d", 4, -12345)); // "-1,2345"
writeln(format("%,*?d", 4, '_', -12345)); // "-1_2345"
writeln(format("%,6?d", '_', -12345678)); // "-12_345678"
assert(format("%12,3.3f", 1234.5678) == "   1,234.568", "'" ~
        format("%12,3.3f", 1234.5678) ~ "'");
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="formattedRead">uint <strong id="formattedRead">formattedRead</strong>(alias fmt, R, S...)(auto ref R r, auto ref S args)<br><small>  Constraints: if (isSomeString!(typeof(fmt))); </small><br><br>uint <strong id="formattedRead">formattedRead</strong>(R, Char, S...)(auto ref R r, const(Char)[] fmt, auto ref S args); </dt> <dd>
<p>Reads characters from <a href="std_range_primitives.html#isInputRange">input range</a> <code>r</code>, converts them according to <code>fmt</code>, and writes them to <code>args</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>r</code>
</td> <td>The range to read from.</td>
</tr> <tr>
<td>const(Char)[] <code>fmt</code>
</td> <td>The format of the data to read.</td>
</tr> <tr>
<td>S <code>args</code>
</td> <td>The drain of the data read.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>On success, the function returns the number of variables filled. This count can match the expected number of readings or fewer, even zero, if a matching failure happens. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>A <code>FormatException</code> if <code>S.length == 0</code> and <code>fmt</code> has format specifiers.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>The format string can be checked at compile-time (see <a href="#format"><code>format</code></a> for details): <pre data-language="d">string s = "hello!124:34.5";
string a;
int b;
double c;
s.formattedRead!"%s!%s:%s"(a, b, c);
assert(a == "hello" &amp;&amp; b == 124 &amp;&amp; c == 34.5);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="FormatSpec">struct <strong id="FormatSpec">FormatSpec</strong>(Char) if (is(Unqual!Char == Char)); </dt> <dd>
<p>A General handler for <code>printf</code> style format specifiers. Used for building more specific formatting functions.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.array;
auto a = appender!(string)();
auto fmt = "Number: %6.4e\nString: %s";
auto f = FormatSpec!char(fmt);

writeln(f.writeUpToNextSpec(a)); // true

writeln(a.data); // "Number: "
writeln(f.trailing); // "\nString: %s"
writeln(f.spec); // 'e'
writeln(f.width); // 6
writeln(f.precision); // 4

writeln(f.writeUpToNextSpec(a)); // true

writeln(a.data); // "Number: \nString: "
writeln(f.trailing); // ""
writeln(f.spec); // 's'

writeln(f.writeUpToNextSpec(a)); // false
writeln(a.data); // "Number: \nString: "
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="FormatSpec.width">int <strong id="width">width</strong>; </dt> <dd>
<p>Minimum width, default <code>0</code>.</p> </dd> <dt class="d_decl" id="FormatSpec.precision">int <strong id="precision">precision</strong>; </dt> <dd>
<p>Precision. Its semantics depends on the argument type. For floating point numbers, precision dictates the number of decimals printed.</p> </dd> <dt class="d_decl" id="FormatSpec.separators">int <strong id="separators">separators</strong>; </dt> <dd>
<p>Number of digits printed between separators.</p> </dd> <dt class="d_decl" id="FormatSpec.separatorCharPos">int <strong id="separatorCharPos">separatorCharPos</strong>; </dt> <dd>
<p>Set to <code>DYNAMIC</code> when the separator character is supplied at runtime.</p> </dd> <dt class="d_decl" id="FormatSpec.separatorChar">dchar <strong id="separatorChar">separatorChar</strong>; </dt> <dd>
<p>Character to insert between digits.</p> </dd> <dt class="d_decl" id="FormatSpec.DYNAMIC">enum int <strong id="DYNAMIC">DYNAMIC</strong>; </dt> <dd>
<p>Special value for width and precision. <code>DYNAMIC</code> width or precision means that they were specified with <code>'*'</code> in the format string and are passed at runtime through the varargs.</p> </dd> <dt class="d_decl" id="FormatSpec.UNSPECIFIED">enum int <strong id="UNSPECIFIED">UNSPECIFIED</strong>; </dt> <dd>
<p>Special value for precision, meaning the format specifier contained no explicit precision.</p> </dd> <dt class="d_decl" id="FormatSpec.spec">char <strong id="spec">spec</strong>; </dt> <dd>
<p>The actual format specifier, <code>'s'</code> by default.</p> </dd> <dt class="d_decl" id="FormatSpec.indexStart">ubyte <strong id="indexStart">indexStart</strong>; </dt> <dd>
<p>Index of the argument for positional parameters, from <code>1</code> to <code>ubyte.max</code>. (<code>0</code> means not used).</p> </dd> <dt class="d_decl" id="FormatSpec.indexEnd">ubyte <strong id="indexEnd">indexEnd</strong>; </dt> <dd>
<p>Index of the last argument for positional parameter range, from <code>1</code> to <code>ubyte.max</code>. (<code>0</code> means not used).</p> </dd> <dt class="d_decl" id="FormatSpec.flDash">bool <strong id="flDash">flDash</strong>; </dt> <dd>
<p>The format specifier contained a <code>'-'</code> (<code>printf</code> compatibility).</p> </dd> <dt class="d_decl" id="FormatSpec.flZero">bool <strong id="flZero">flZero</strong>; </dt> <dd>
<p>The format specifier contained a <code>'0'</code> (<code>printf</code> compatibility).</p> </dd> <dt class="d_decl" id="FormatSpec.flSpace">bool <strong id="flSpace">flSpace</strong>; </dt> <dd>
<p>The format specifier contained a <code>' '</code> (<code>printf</code> compatibility).</p> </dd> <dt class="d_decl" id="FormatSpec.flPlus">bool <strong id="flPlus">flPlus</strong>; </dt> <dd>
<p>The format specifier contained a <code>'+'</code> (<code>printf</code> compatibility).</p> </dd> <dt class="d_decl" id="FormatSpec.flHash">bool <strong id="flHash">flHash</strong>; </dt> <dd>
<p>The format specifier contained a <code>'#'</code> (<code>printf</code> compatibility).</p> </dd> <dt class="d_decl" id="FormatSpec.flSeparator">bool <strong id="flSeparator">flSeparator</strong>; </dt> <dd>
<p>The format specifier contained a <code>','</code></p> </dd> <dt class="d_decl" id="FormatSpec.nested">const(Char)[] <strong id="nested">nested</strong>; </dt> <dd>
<p>In case of a compound format specifier starting with <code> "%("</code> and ending with <code>"%)"</code>, <code>_nested</code> contains the string contained within the two separators.</p> </dd> <dt class="d_decl" id="FormatSpec.sep">const(Char)[] <strong id="sep">sep</strong>; </dt> <dd>
<p>In case of a compound format specifier, <code>_sep</code> contains the string positioning after <code>"%|"</code>. <code>sep is null</code> means no separator else <code>sep.empty</code> means 0 length separator.</p> </dd> <dt class="d_decl" id="FormatSpec.trailing">const(Char)[] <strong id="trailing">trailing</strong>; </dt> <dd>
<p><code>_trailing</code> contains the rest of the format string.</p> </dd> <dt class="d_decl" id="FormatSpec.this">pure @safe this(in Char[] fmt); </dt> <dd>
<p>Construct a new <code>FormatSpec</code> using the format string <code>fmt</code>, no processing is done until needed.</p> </dd> <dt class="d_decl" id="FormatSpec.writeUpToNextSpec">scope bool <strong id="writeUpToNextSpec">writeUpToNextSpec</strong>(OutputRange)(ref OutputRange writer); </dt> <dd>
<p>Write the format string to an output range until the next format specifier is found and parse that format specifier. </p>
<p>See <a href="#FormatSpec"><code>FormatSpec</code></a> for an example, how to use <code>writeUpToNextSpec</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>OutputRange <code>writer</code>
</td> <td>the <a href="std_range_primitives.html#isOutputRange">output range</a>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>True, when a format specifier is found. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>A <a href="#FormatException"><code>FormatException</code></a> when the found format specifier could not be parsed.</dd>
</dl> </dd> <dt class="d_decl" id="FormatSpec.toString">const pure @safe string <strong id="toString">toString</strong>(); <br><br>const void <strong id="toString">toString</strong>(OutputRange)(ref OutputRange writer)<br><small>  Constraints: if (isOutputRange!(OutputRange, char)); </small>
</dt> <dd>
<p>Gives a string containing all of the member variables on their own line. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>OutputRange <code>writer</code>
</td> <td>A <code>char</code> accepting <a href="std_range_primitives.html#isOutputRange">output range</a>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A <code>string</code> when not using an output range; <code>void</code> otherwise.</dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="singleSpec">FormatSpec!Char <strong id="singleSpec">singleSpec</strong>(Char)(Char[] fmt); </dt> <dd>
<p>Helper function that returns a <code>FormatSpec</code> for a single specifier given in <code>fmt</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Char[] <code>fmt</code>
</td> <td>A format specifier.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A <code>FormatSpec</code> with the specifier parsed. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>A <code>FormatException</code> when more than one specifier is given or the specifier is malformed.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.exception : assertThrown;
auto spec = singleSpec("%2.3e");

writeln(spec.trailing); // ""
writeln(spec.spec); // 'e'
writeln(spec.width); // 2
writeln(spec.precision); // 3

assertThrown!FormatException(singleSpec(""));
assertThrown!FormatException(singleSpec("2.3e"));
assertThrown!FormatException(singleSpec("%2.3eTest"));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="formatValue">void <strong id="formatValue">formatValue</strong>(Writer, T, Char)(auto ref Writer w, auto ref T val, ref scope const FormatSpec!Char f); </dt> <dd>
<p>Formats any value into <code>Char</code> accepting <code>OutputRange</code>, using the given <code>FormatSpec</code>. </p>
<dl>
<dt>Aggregates</dt>
<dd> <code>struct</code>, <code>union</code>, <code>class</code>, and <code>interface</code> are formatted by calling <code>toString</code>. </dd>
</dl> <code>toString</code> should have one of the following signatures:  <pre data-language="d">void toString(W)(ref W w, scope const ref FormatSpec fmt)
void toString(W)(ref W w)
string toString();
</pre>  Where <code>W</code> is an <a href="std_range_primitives.html#isOutputRange">output range</a> which accepts characters. The template type does not have to be called <code>W</code>.  The following overloads are also accepted for legacy reasons or for use in virtual functions. It's recommended that any new code forgo these overloads if possible for speed and attribute acceptance reasons.  <pre data-language="d">void toString(scope void delegate(const(char)[]) sink, const ref FormatSpec fmt);
void toString(scope void delegate(const(char)[]) sink, string fmt);
void toString(scope void delegate(const(char)[]) sink);
</pre>  For the class objects which have input range interface, <ul> <li>If the instance <code>toString</code> has overridden <code>Object.toString</code>, it is used.</li> <li>Otherwise, the objects are formatted as input range.</li> </ul>  For the <code>struct</code> and <code>union</code> objects which does not have <code>toString</code>, <ul> <li>If they have range interface, formatted as input range.</li> <li>Otherwise, they are formatted like <code>Type(field1, filed2, ...)</code>.</li> </ul>  Otherwise, are formatted just as their type name.  <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Writer <code>w</code>
</td> <td>The <a href="std_range_primitives.html#isOutputRange">output range</a> to write to.</td>
</tr> <tr>
<td>T <code>val</code>
</td> <td>The value to write.</td>
</tr> <tr>
<td>FormatSpec!Char <code>f</code>
</td> <td>The <a href="std_format.html#FormatSpec"><code>std.format.FormatSpec</code></a> defining how to write the value.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>The following code compares the use of <code>formatValue</code> and <code>formattedWrite</code>. <pre data-language="d">import std.array : appender;

auto writer1 = appender!string();
writer1.formattedWrite("%08b", 42);

auto writer2 = appender!string();
auto f = singleSpec("%08b");
writer2.formatValue(42, f);

assert(writer1.data == writer2.data &amp;&amp; writer1.data == "00101010");
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<code>bool</code>s are formatted as <code>"true"</code> or <code>"false"</code> with <code>%s</code> and as <code>1</code> or <code>0</code> with integral-specific format specs. <pre data-language="d">import std.array : appender;
auto w = appender!string();
auto spec = singleSpec("%s");
formatValue(w, true, spec);

writeln(w.data); // "true"
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<code>null</code> literal is formatted as <code>"null"</code>. <pre data-language="d">import std.array : appender;
auto w = appender!string();
auto spec = singleSpec("%s");
formatValue(w, null, spec);

writeln(w.data); // "null"
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Integrals are formatted like <a href="core_stdc_stdio.html#printf"><code>core.stdc.stdio.printf</code></a>. <pre data-language="d">import std.array : appender;
auto w = appender!string();
auto spec = singleSpec("%d");
formatValue(w, 1337, spec);

writeln(w.data); // "1337"
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Floating-point values are formatted like <a href="core_stdc_stdio.html#printf"><code>core.stdc.stdio.printf</code></a> <pre data-language="d">import std.array : appender;
auto w = appender!string();
auto spec = singleSpec("%.1f");
formatValue(w, 1337.7, spec);

writeln(w.data); // "1337.7"
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Individual characters (<code>char, </code>wchar<code>, or </code>dchar`) are formatted as Unicode characters with <code>%s</code> and as integers with integral-specific format specs. <pre data-language="d">import std.array : appender;
auto w = appender!string();
auto spec = singleSpec("%c");
formatValue(w, 'a', spec);

writeln(w.data); // "a"
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Strings are formatted like <a href="core_stdc_stdio.html#printf"><code>core.stdc.stdio.printf</code></a> <pre data-language="d">import std.array : appender;
auto w = appender!string();
auto spec = singleSpec("%s");
formatValue(w, "hello", spec);

writeln(w.data); // "hello"
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Static-size arrays are formatted as dynamic arrays. <pre data-language="d">import std.array : appender;
auto w = appender!string();
auto spec = singleSpec("%s");
char[2] two = ['a', 'b'];
formatValue(w, two, spec);

writeln(w.data); // "ab"
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Dynamic arrays are formatted as input ranges.  Specializations: <ul> <li>
<code>void[]</code> is formatted like <code>ubyte[]</code>.</li> <li>Const array is converted to input range by removing its qualifier.</li> </ul> <pre data-language="d">import std.array : appender;
auto w = appender!string();
auto spec = singleSpec("%s");
auto two = [1, 2];
formatValue(w, two, spec);

writeln(w.data); // "[1, 2]"
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Associative arrays are formatted by using <code>':'</code> and <code>", "</code> as separators, and enclosed by <code>'['</code> and <code>']'</code>. <pre data-language="d">import std.array : appender;
auto w = appender!string();
auto spec = singleSpec("%s");
auto aa = ["H":"W"];
formatValue(w, aa, spec);

writeln(w.data); // "[\"H\":\"W\"]"
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<code>enum</code>s are formatted like their base value <pre data-language="d">import std.array : appender;
auto w = appender!string();
auto spec = singleSpec("%s");

enum A { first, second, third }

formatValue(w, A.second, spec);

writeln(w.data); // "second"
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Formatting a struct by defining a method <code>toString</code>, which takes an output range.  It's recommended that any <code>toString</code> using <a href="std_range_primitives.html#isOutputRange">output ranges</a> use <a href="std_range_primitives.html#put"><code>std.range.primitives.put</code></a> rather than use the <code>put</code> method of the range directly. <pre data-language="d">import std.array : appender;
import std.range.primitives;

static struct Point
{
    int x, y;

    void toString(W)(ref W writer, scope const ref FormatSpec!char f)
    if (isOutputRange!(W, char))
    {
        // std.range.primitives.put
        put(writer, "(");
        formatValue(writer, x, f);
        put(writer, ",");
        formatValue(writer, y, f);
        put(writer, ")");
    }
}

auto w = appender!string();
auto spec = singleSpec("%s");
auto p = Point(16, 11);

formatValue(w, p, spec);
writeln(w.data); // "(16,11)"
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Another example of formatting a <code>struct</code> with a defined <code>toString</code>, this time using the <code>scope delegate</code> method.  <span class="red">This method is now discouraged for non-virtual functions</span>. If possible, please use the output range method instead. <pre data-language="d">static struct Point
{
    int x, y;

    void toString(scope void delegate(scope const(char)[]) @safe sink,
                  scope const FormatSpec!char fmt) const
    {
        sink("(");
        sink.formatValue(x, fmt);
        sink(",");
        sink.formatValue(y, fmt);
        sink(")");
    }
}

auto p = Point(16,11);
writeln(format("%03d", p)); // "(016,011)"
writeln(format("%02x", p)); // "(10,0b)"
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Pointers are formatted as hex integers. <pre data-language="d">import std.array : appender;
auto w = appender!string();
auto spec = singleSpec("%s");

auto q = cast(void*) 0xFFEECCAA;
formatValue(w, q, spec);

writeln(w.data); // "FFEECCAA"
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>SIMD vectors are formatted as arrays. <pre data-language="d">import core.simd;
import std.array : appender;
auto w = appender!string();
auto spec = singleSpec("%s");

static if (is(float4))
{
    version (X86) {}
    else
    {
        float4 f4;
        f4.array[0] = 1;
        f4.array[1] = 2;
        f4.array[2] = 3;
        f4.array[3] = 4;

        formatValue(w, f4, spec);
        writeln(w.data); // "[1, 2, 3, 4]"
    }
}
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Delegates are formatted by <code>ReturnType delegate(Parameters) FunctionAttributes</code> <pre data-language="d">import std.conv : to;

int i;

int foo(short k) @nogc
{
    return i + k;
}

@system int delegate(short) @nogc bar() nothrow pure
{
    int* p = new int(1);
    i = *p;
    return &amp;foo;
}

writeln(to!string(&amp;bar)); // "int delegate(short) @nogc delegate() pure nothrow @system"
writeln(() @trusted
{ return bar()(3);
}()); // 4
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="unformatValue">T <strong id="unformatValue">unformatValue</strong>(T, Range, Char)(ref Range input, ref scope const FormatSpec!Char spec); </dt> <dd>
<p>Reads a value from the given input range according to spec and returns it as type <code>T</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T</td> <td>the type to return</td>
</tr> <tr>
<td>Range <code>input</code>
</td> <td>the input range to read from</td>
</tr> <tr>
<td>FormatSpec!Char <code>spec</code>
</td> <td>the <code>FormatSpec</code> to use when reading from <code>input</code>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A value from <code>input</code> of type <code>T</code> </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>A <code>FormatException</code> if <code>spec</code> cannot read a type <code>T</code> </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="std_conv.html#parse"><code>std.conv.parse</code></a> and <a href="std_conv.html#to"><code>std.conv.to</code></a>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Booleans <pre data-language="d">auto str = "false";
auto spec = singleSpec("%s");
writeln(unformatValue!bool(str, spec)); // false

str = "1";
spec = singleSpec("%d");
assert(unformatValue!bool(str, spec));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Null values <pre data-language="d">auto str = "null";
auto spec = singleSpec("%s");
writeln(str.unformatValue!(typeof(null))(spec)); // null
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Integrals <pre data-language="d">auto str = "123";
auto spec = singleSpec("%s");
writeln(str.unformatValue!int(spec)); // 123

str = "ABC";
spec = singleSpec("%X");
writeln(str.unformatValue!int(spec)); // 2748

str = "11610";
spec = singleSpec("%o");
writeln(str.unformatValue!int(spec)); // 5000
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Floating point numbers <pre data-language="d">import std.math : approxEqual;

auto str = "123.456";
auto spec = singleSpec("%s");
assert(str.unformatValue!double(spec).approxEqual(123.456));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Character input ranges <pre data-language="d">auto str = "aaa";
auto spec = singleSpec("%s");
writeln(str.unformatValue!char(spec)); // 'a'

// Using a numerical format spec reads a Unicode value from a string
str = "65";
spec = singleSpec("%d");
writeln(str.unformatValue!char(spec)); // 'A'

str = "41";
spec = singleSpec("%x");
writeln(str.unformatValue!char(spec)); // 'A'

str = "10003";
spec = singleSpec("%d");
writeln(str.unformatValue!dchar(spec)); // '✓'
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Arrays and static arrays <pre data-language="d">string str = "aaa";
auto spec = singleSpec("%s");
writeln(str.unformatValue!(dchar[])(spec)); // "aaa"d

str = "aaa";
spec = singleSpec("%s");
dchar[3] ret = ['a', 'a', 'a'];
writeln(str.unformatValue!(dchar[3])(spec)); // ret

str = "[1, 2, 3, 4]";
spec = singleSpec("%s");
writeln(str.unformatValue!(int[])(spec)); // [1, 2, 3, 4]

str = "[1, 2, 3, 4]";
spec = singleSpec("%s");
int[4] ret2 = [1, 2, 3, 4];
writeln(str.unformatValue!(int[4])(spec)); // ret2
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Associative arrays <pre data-language="d">auto str = `["one": 1, "two": 2]`;
auto spec = singleSpec("%s");
writeln(str.unformatValue!(int[string])(spec)); // ["one":1, "two":2]
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="format">typeof(fmt) <strong id="format">format</strong>(alias fmt, Args...)(Args args)<br><small>  Constraints: if (isSomeString!(typeof(fmt))); </small><br><br>immutable(Char)[] <strong id="format">format</strong>(Char, Args...)(in Char[] fmt, Args args)<br><small>  Constraints: if (isSomeChar!Char); </small>
</dt> <dd>
<p>Format arguments into a string. </p>
<p>If the format string is fixed, passing it as a template parameter checks the type correctness of the parameters at compile-time. This also can result in better performance. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Char[] <code>fmt</code>
</td> <td>Format string. For detailed specification, see <a href="#formattedWrite"><code>formattedWrite</code></a>.</td>
</tr> <tr>
<td>Args <code>args</code>
</td> <td>Variadic list of arguments to format into returned string.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
 if the number of arguments doesn't match the number of format parameters and vice-versa.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Type checking can be done when fmt is known at compile-time: <pre data-language="d">auto s = format!"%s is %s"("Pi", 3.14);
writeln(s); // "Pi is 3.14"

static assert(!__traits(compiles, {s = format!"%l"();}));     // missing arg
static assert(!__traits(compiles, {s = format!""(404);}));    // surplus arg
static assert(!__traits(compiles, {s = format!"%d"(4.03);})); // incompatible arg
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="sformat">char[] <strong id="sformat">sformat</strong>(alias fmt, Args...)(char[] buf, Args args)<br><small>  Constraints: if (isSomeString!(typeof(fmt))); </small><br><br>char[] <strong id="sformat">sformat</strong>(Char, Args...)(return scope char[] buf, scope const(Char)[] fmt, Args args); </dt> <dd>
<p>Format arguments into buffer <i>buf</i> which must be large enough to hold the result. </p>
<dl>
<dt>Returns:</dt>
<dd>The slice of <code>buf</code> containing the formatted string. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>A <code>RangeError</code> if <code>buf</code> isn't large enough to hold the formatted string.  A <a href="#FormatException"><code>FormatException</code></a> if the length of <code>args</code> is different than the number of format specifiers in <code>fmt</code>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>The format string can be checked at compile-time (see <a href="#format"><code>format</code></a> for details): <pre data-language="d">char[10] buf;

writeln(buf[].sformat!"foo%s"('C')); // "fooC"
writeln(sformat(buf[], "%s foo", "bar")); // "bar foo"
</pre> </dd>
</dl> </dd> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1999&ndash;2021 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/std_format.html" class="_attribution-link">https://dlang.org/phobos/std_format.html</a>
  </p>
</div>
