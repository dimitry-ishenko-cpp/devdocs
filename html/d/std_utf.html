<h1>std.utf</h1>  <p>Encode and decode UTF-8, UTF-16 and UTF-32 strings. </p>
<p>UTF character support is restricted to <code>'\u0000' &lt;= character &lt;= '\U0010FFFF'</code>. <br><br>  <table>

<tr>
<th scope="col">Category</th> <th scope="col">Functions</th>
</tr> <tr>
<td>Decode</td> <td> <a href="#decode"><code>decode</code></a> <a href="#decodeFront"><code>decodeFront</code></a> </td>
</tr> <tr>
<td>Lazy decode</td> <td> <a href="#byCodeUnit"><code>byCodeUnit</code></a> <a href="#byChar"><code>byChar</code></a> <a href="#byWchar"><code>byWchar</code></a> <a href="#byDchar"><code>byDchar</code></a> <a href="#byUTF"><code>byUTF</code></a> </td>
</tr> <tr>
<td>Encode</td> <td> <a href="#encode"><code>encode</code></a> <a href="#toUTF8"><code>toUTF8</code></a> <a href="#toUTF16"><code>toUTF16</code></a> <a href="#toUTF32"><code>toUTF32</code></a> <a href="#toUTFz"><code>toUTFz</code></a> <a href="#toUTF16z"><code>toUTF16z</code></a> </td>
</tr> <tr>
<td>Length</td> <td> <a href="#codeLength"><code>codeLength</code></a> <a href="#count"><code>count</code></a> <a href="#stride"><code>stride</code></a> <a href="#strideBack"><code>strideBack</code></a> </td>
</tr> <tr>
<td>Index</td> <td> <a href="#toUCSindex"><code>toUCSindex</code></a> <a href="#toUTFindex"><code>toUTFindex</code></a> </td>
</tr> <tr>
<td>Validation</td> <td> <a href="#isValidDchar"><code>isValidDchar</code></a> <a href="#validate"><code>validate</code></a> </td>
</tr> <tr>
<td>Miscellaneous</td> <td> <a href="#replacementDchar"><code>replacementDchar</code></a> <a href="#UseReplacementDchar"><code>UseReplacementDchar</code></a> <a href="#UTFException"><code>UTFException</code></a> </td>
</tr> </table> </p> <dl>
<dt>See Also:</dt>
<dd>
<a href="http://en.wikipedia.org/wiki/Unicode">Wikipedia</a><br> <a href="http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8">http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8</a><br> <a href="http://anubis.dkuug.dk/JTC1/SC2/WG2/docs/n1335">http://anubis.dkuug.dk/JTC1/SC2/WG2/docs/n1335</a> </dd>
</dl> <dl>
<dt>License:</dt>
<dd>
<a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>. </dd>
</dl> <dl>
<dt>Authors:</dt>
<dd>
<a href="http://digitalmars.com">Walter Bright</a> and <a href="http://jmdavisprog.com">Jonathan M Davis</a> </dd>
</dl> <dl>
<dt>Source</dt>
<dd> <span class="phobos_src"><a class="https" href="https://github.com/dlang/phobos/blob/master/std/utf.d">std/utf.d</a></span>
</dd>
</dl> <dl>
<dt class="d_decl" id="UTFException">class <strong id="UTFException">UTFException</strong>: core.exception.UnicodeException; </dt> <dd>
<p>Exception thrown on errors in std.utf functions.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.exception : assertThrown;

char[4] buf;
assertThrown!UTFException(encode(buf, cast(dchar) 0xD800));
assertThrown!UTFException(encode(buf, cast(dchar) 0xDBFF));
assertThrown!UTFException(encode(buf, cast(dchar) 0xDC00));
assertThrown!UTFException(encode(buf, cast(dchar) 0xDFFF));
assertThrown!UTFException(encode(buf, cast(dchar) 0x110000));
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="UTFException.this">pure nothrow @nogc @safe this(string msg, string file = __FILE__, size_t line = __LINE__, Throwable next = null); <br><br>pure nothrow @safe this(string msg, size_t index, string file = __FILE__, size_t line = __LINE__, Throwable next = null); </dt> <dd>
<p>Standard exception constructors.</p> </dd> <dt class="d_decl" id="UTFException.toString">const string <strong id="toString">toString</strong>(); </dt> <dd>
<dl>
<dt>Returns:</dt>
<dd>A <code>string</code> detailing the invalid UTF sequence.</dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="isValidDchar">pure nothrow @nogc @safe bool <strong id="isValidDchar">isValidDchar</strong>(dchar c); </dt> <dd>
<p>Check whether the given Unicode code point is valid. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>dchar <code>c</code>
</td> <td>code point to check</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if and only if <code>c</code> is a valid Unicode code point </dd>
</dl> <dl>
<dt>Note</dt>
<dd> <code>'\uFFFE'</code> and <code>'\uFFFF'</code> are considered valid by <code>isValidDchar</code>, as they are permitted for internal use by an application, but they are not allowed for interchange by the Unicode standard.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert( isValidDchar(cast(dchar) 0x41));
assert( isValidDchar(cast(dchar) 0x00));
assert(!isValidDchar(cast(dchar) 0xD800));
assert(!isValidDchar(cast(dchar) 0x11FFFF));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="stride">uint <strong id="stride">stride</strong>(S)(auto ref S str, size_t index)<br><small>  Constraints: if (is(S : const(char[])) || isRandomAccessRange!S &amp;&amp; is(immutable(ElementType!S) == immutable(char))); </small><br><br>uint <strong id="stride">stride</strong>(S)(auto ref S str)<br><small>  Constraints: if (is(S : const(char[])) || isInputRange!S &amp;&amp; is(immutable(ElementType!S) == immutable(char))); </small><br><br>uint <strong id="stride">stride</strong>(S)(auto ref S str, size_t index)<br><small>  Constraints: if (is(S : const(wchar[])) || isRandomAccessRange!S &amp;&amp; is(immutable(ElementType!S) == immutable(wchar))); </small><br><br>pure @safe uint <strong id="stride">stride</strong>(S)(auto ref S str)<br><small>  Constraints: if (is(S : const(wchar[]))); </small><br><br>uint <strong id="stride">stride</strong>(S)(auto ref S str)<br><small>  Constraints: if (isInputRange!S &amp;&amp; is(immutable(ElementType!S) == immutable(wchar)) &amp;&amp; !is(S : const(wchar[]))); </small><br><br>uint <strong id="stride">stride</strong>(S)(auto ref S str, size_t index = 0)<br><small>  Constraints: if (is(S : const(dchar[])) || isInputRange!S &amp;&amp; is(immutable(ElementEncodingType!S) == immutable(dchar))); </small>
</dt> <dd>
<p>Calculate the length of the UTF sequence starting at <code>index</code> in <code>str</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>S <code>str</code>
</td> <td>
<a href="std_range_primitives.html#isInputRange">input range</a> of UTF code units. Must be random access if <code>index</code> is passed</td>
</tr> <tr>
<td>size_t <code>index</code>
</td> <td>starting index of UTF sequence (default: <code>0</code>)</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The number of code units in the UTF sequence. For UTF-8, this is a value between 1 and 4 (as per <a href="http://tools.ietf.org/html/rfc3629#section-3">RFC 3629, section 3</a>). For UTF-16, it is either 1 or 2. For UTF-32, it is always 1. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>May throw a <code>UTFException</code> if <code>str[index]</code> is not the start of a valid UTF sequence. </dd>
</dl> <dl>
<dt>Note</dt>
<dd> <code>stride</code> will only analyze the first <code>str[index]</code> element. It will not fully verify the validity of the UTF sequence, nor even verify the presence of the sequence: it will not actually guarantee that <code>index + stride(str, index) &lt;= str.length</code>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln("a".stride); // 1
writeln("Œª".stride); // 2
writeln("aŒª".stride); // 1
writeln("aŒª".stride(1)); // 2
writeln("êê∑".stride); // 4
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="strideBack">uint <strong id="strideBack">strideBack</strong>(S)(auto ref S str, size_t index)<br><small>  Constraints: if (is(S : const(char[])) || isRandomAccessRange!S &amp;&amp; is(immutable(ElementType!S) == immutable(char))); </small><br><br>uint <strong id="strideBack">strideBack</strong>(S)(auto ref S str)<br><small>  Constraints: if (is(S : const(char[])) || isRandomAccessRange!S &amp;&amp; hasLength!S &amp;&amp; is(immutable(ElementType!S) == immutable(char))); </small><br><br>uint <strong id="strideBack">strideBack</strong>(S)(auto ref S str)<br><small>  Constraints: if (isBidirectionalRange!S &amp;&amp; is(immutable(ElementType!S) == immutable(char)) &amp;&amp; !isRandomAccessRange!S); </small><br><br>uint <strong id="strideBack">strideBack</strong>(S)(auto ref S str, size_t index)<br><small>  Constraints: if (is(S : const(wchar[])) || isRandomAccessRange!S &amp;&amp; is(immutable(ElementType!S) == immutable(wchar))); </small><br><br>uint <strong id="strideBack">strideBack</strong>(S)(auto ref S str)<br><small>  Constraints: if (is(S : const(wchar[])) || isBidirectionalRange!S &amp;&amp; is(immutable(ElementType!S) == immutable(wchar))); </small><br><br>uint <strong id="strideBack">strideBack</strong>(S)(auto ref S str, size_t index)<br><small>  Constraints: if (isRandomAccessRange!S &amp;&amp; is(immutable(ElementEncodingType!S) == immutable(dchar))); </small><br><br>uint <strong id="strideBack">strideBack</strong>(S)(auto ref S str)<br><small>  Constraints: if (isBidirectionalRange!S &amp;&amp; is(immutable(ElementEncodingType!S) == immutable(dchar))); </small>
</dt> <dd>
<p>Calculate the length of the UTF sequence ending one code unit before <code>index</code> in <code>str</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>S <code>str</code>
</td> <td>bidirectional range of UTF code units. Must be random access if <code>index</code> is passed</td>
</tr> <tr>
<td>size_t <code>index</code>
</td> <td>index one past end of UTF sequence (default: <code>str.length</code>)</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The number of code units in the UTF sequence. For UTF-8, this is a value between 1 and 4 (as per <a href="http://tools.ietf.org/html/rfc3629#section-3">RFC 3629, section 3</a>). For UTF-16, it is either 1 or 2. For UTF-32, it is always 1. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>May throw a <code>UTFException</code> if <code>str[index]</code> is not one past the end of a valid UTF sequence. </dd>
</dl> <dl>
<dt>Note</dt>
<dd> <code>strideBack</code> will only analyze the element at <code>str[index - 1]</code> element. It will not fully verify the validity of the UTF sequence, nor even verify the presence of the sequence: it will not actually guarantee that <code>strideBack(str, index) &lt;= index</code>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln("a".strideBack); // 1
writeln("Œª".strideBack); // 2
writeln("aŒª".strideBack); // 2
writeln("aŒª".strideBack(1)); // 1
writeln("êê∑".strideBack); // 4
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="toUCSindex">pure @safe size_t <strong id="toUCSindex">toUCSindex</strong>(C)(const(C)[] str, size_t index)<br><small>  Constraints: if (isSomeChar!C); </small>
</dt> <dd>
<p>Given <code>index</code> into <code>str</code> and assuming that <code>index</code> is at the start of a UTF sequence, <code>toUCSindex</code> determines the number of UCS characters up to <code>index</code>. So, <code>index</code> is the index of a code unit at the beginning of a code point, and the return value is how many code points into the string that that code point is.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(toUCSindex(`hello world`, 7)); // 7
writeln(toUCSindex(`hello world`w, 7)); // 7
writeln(toUCSindex(`hello world`d, 7)); // 7

writeln(toUCSindex(`Ma Ch√©rie`, 7)); // 6
writeln(toUCSindex(`Ma Ch√©rie`w, 7)); // 7
writeln(toUCSindex(`Ma Ch√©rie`d, 7)); // 7

writeln(toUCSindex(`„Åï„ÅÑ„Åî„ÅÆÊûúÂÆü / „Éü„ÉÑ„Éê„ÉÅ„Å®ÁßëÂ≠¶ËÄÖ`, 9)); // 3
writeln(toUCSindex(`„Åï„ÅÑ„Åî„ÅÆÊûúÂÆü / „Éü„ÉÑ„Éê„ÉÅ„Å®ÁßëÂ≠¶ËÄÖ`w, 9)); // 9
writeln(toUCSindex(`„Åï„ÅÑ„Åî„ÅÆÊûúÂÆü / „Éü„ÉÑ„Éê„ÉÅ„Å®ÁßëÂ≠¶ËÄÖ`d, 9)); // 9
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="toUTFindex">pure @safe size_t <strong id="toUTFindex">toUTFindex</strong>(C)(const(C)[] str, size_t n)<br><small>  Constraints: if (isSomeChar!C); </small>
</dt> <dd>
<p>Given a UCS index <code>n</code> into <code>str</code>, returns the UTF index. So, <code>n</code> is how many code points into the string the code point is, and the array index of the code unit is returned.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(toUTFindex(`hello world`, 7)); // 7
writeln(toUTFindex(`hello world`w, 7)); // 7
writeln(toUTFindex(`hello world`d, 7)); // 7

writeln(toUTFindex(`Ma Ch√©rie`, 6)); // 7
writeln(toUTFindex(`Ma Ch√©rie`w, 7)); // 7
writeln(toUTFindex(`Ma Ch√©rie`d, 7)); // 7

writeln(toUTFindex(`„Åï„ÅÑ„Åî„ÅÆÊûúÂÆü / „Éü„ÉÑ„Éê„ÉÅ„Å®ÁßëÂ≠¶ËÄÖ`, 3)); // 9
writeln(toUTFindex(`„Åï„ÅÑ„Åî„ÅÆÊûúÂÆü / „Éü„ÉÑ„Éê„ÉÅ„Å®ÁßëÂ≠¶ËÄÖ`w, 9)); // 9
writeln(toUTFindex(`„Åï„ÅÑ„Åî„ÅÆÊûúÂÆü / „Éü„ÉÑ„Éê„ÉÅ„Å®ÁßëÂ≠¶ËÄÖ`d, 9)); // 9
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="UseReplacementDchar">alias <strong id="UseReplacementDchar">UseReplacementDchar</strong> = std.typecons.Flag!"useReplacementDchar".Flag; </dt> <dd>
<p>Whether or not to replace invalid UTF with <a href="#replacementDchar"><code>replacementDchar</code></a></p> </dd> <dt class="d_decl" id="decode">dchar <strong id="decode">decode</strong>(UseReplacementDchar useReplacementDchar = No.useReplacementDchar, S)(auto ref S str, ref size_t index)<br><small>  Constraints: if (!isSomeString!S &amp;&amp; isRandomAccessRange!S &amp;&amp; hasSlicing!S &amp;&amp; hasLength!S &amp;&amp; isSomeChar!(ElementType!S)); </small><br><br>pure @trusted dchar <strong id="decode">decode</strong>(UseReplacementDchar useReplacementDchar = No.useReplacementDchar, S)(auto ref S str, ref size_t index)<br><small>  Constraints: if (isSomeString!S); </small>
</dt> <dd>
<p>Decodes and returns the code point starting at <code>str[index]</code>. <code>index</code> is advanced to one past the decoded code point. If the code point is not well-formed, then a <code>UTFException</code> is thrown and <code>index</code> remains unchanged. </p>
<p>decode will only work with strings and random access ranges of code units with length and slicing, whereas <a href="#decodeFront"><code>decodeFront</code></a> will work with any input range of code units. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>useReplacementDchar</td> <td>if invalid UTF, return replacementDchar rather than throwing</td>
</tr> <tr>
<td>S <code>str</code>
</td> <td>input string or indexable Range</td>
</tr> <tr>
<td>size_t <code>index</code>
</td> <td>starting index into s[]; incremented by number of code units processed</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>decoded character </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="#UTFException"><code>UTFException</code></a> if <code>str[index]</code> is not the start of a valid UTF sequence and useReplacementDchar is <code>No.useReplacementDchar</code>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">size_t i;

assert("a".decode(i) == 'a' &amp;&amp; i == 1);
i = 0;
assert("√•".decode(i) == '√•' &amp;&amp; i == 2);
i = 1;
assert("a√•".decode(i) == '√•' &amp;&amp; i == 3);
i = 0;
assert("√•"w.decode(i) == '√•' &amp;&amp; i == 1);

// √´ as a multi-code point grapheme
i = 0;
assert("e\u0308".decode(i) == 'e' &amp;&amp; i == 1);
// √´ as a single code point grapheme
i = 0;
assert("√´".decode(i) == '√´' &amp;&amp; i == 2);
i = 0;
assert("√´"w.decode(i) == '√´' &amp;&amp; i == 1);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="decodeFront">dchar <strong id="decodeFront">decodeFront</strong>(UseReplacementDchar useReplacementDchar = No.useReplacementDchar, S)(ref S str, out size_t numCodeUnits)<br><small>  Constraints: if (!isSomeString!S &amp;&amp; isInputRange!S &amp;&amp; isSomeChar!(ElementType!S)); </small><br><br>pure @trusted dchar <strong id="decodeFront">decodeFront</strong>(UseReplacementDchar useReplacementDchar = No.useReplacementDchar, S)(ref S str, out size_t numCodeUnits)<br><small>  Constraints: if (isSomeString!S); </small><br><br>dchar <strong id="decodeFront">decodeFront</strong>(UseReplacementDchar useReplacementDchar = No.useReplacementDchar, S)(ref S str)<br><small>  Constraints: if (isInputRange!S &amp;&amp; isSomeChar!(ElementType!S)); </small>
</dt> <dd>
<p><code>decodeFront</code> is a variant of <a href="#decode"><code>decode</code></a> which specifically decodes the first code point. Unlike <a href="#decode"><code>decode</code></a>, <code>decodeFront</code> accepts any <a href="std_range_primitives.html#isInputRange">input range</a> of code units (rather than just a string or random access range). It also takes the range by <code>ref</code> and pops off the elements as it decodes them. If <code>numCodeUnits</code> is passed in, it gets set to the number of code units which were in the code point which was decoded. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>useReplacementDchar</td> <td>if invalid UTF, return replacementDchar rather than throwing</td>
</tr> <tr>
<td>S <code>str</code>
</td> <td>input string or indexable Range</td>
</tr> <tr>
<td>size_t <code>numCodeUnits</code>
</td> <td>set to number of code units processed</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>decoded character </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="#UTFException"><code>UTFException</code></a> if <code>str.front</code> is not the start of a valid UTF sequence. If an exception is thrown, then there is no guarantee as to the number of code units which were popped off, as it depends on the type of range being used and how many code units had to be popped off before the code point was determined to be invalid.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.range.primitives;
string str = "Hello, World!";

assert(str.decodeFront == 'H' &amp;&amp; str == "ello, World!");
str = "√•";
assert(str.decodeFront == '√•' &amp;&amp; str.empty);
str = "√•";
size_t i;
assert(str.decodeFront(i) == '√•' &amp;&amp; i == 2 &amp;&amp; str.empty);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="decodeBack">dchar <strong id="decodeBack">decodeBack</strong>(UseReplacementDchar useReplacementDchar = No.useReplacementDchar, S)(ref S str, out size_t numCodeUnits)<br><small>  Constraints: if (isSomeString!S); </small><br><br>dchar <strong id="decodeBack">decodeBack</strong>(UseReplacementDchar useReplacementDchar = No.useReplacementDchar, S)(ref S str, out size_t numCodeUnits)<br><small>  Constraints: if (!isSomeString!S &amp;&amp; isSomeChar!(ElementType!S) &amp;&amp; isBidirectionalRange!S &amp;&amp; (isRandomAccessRange!S &amp;&amp; hasLength!S || !isRandomAccessRange!S)); </small><br><br>dchar <strong id="decodeBack">decodeBack</strong>(UseReplacementDchar useReplacementDchar = No.useReplacementDchar, S)(ref S str)<br><small>  Constraints: if (isSomeString!S || isRandomAccessRange!S &amp;&amp; hasLength!S &amp;&amp; isSomeChar!(ElementType!S) || !isRandomAccessRange!S &amp;&amp; isBidirectionalRange!S &amp;&amp; isSomeChar!(ElementType!S)); </small>
</dt> <dd>
<p><code>decodeBack</code> is a variant of <a href="#decode"><code>decode</code></a> which specifically decodes the last code point. Unlike <a href="#decode"><code>decode</code></a>, <code>decodeBack</code> accepts any bidirectional range of code units (rather than just a string or random access range). It also takes the range by <code>ref</code> and pops off the elements as it decodes them. If <code>numCodeUnits</code> is passed in, it gets set to the number of code units which were in the code point which was decoded. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>useReplacementDchar</td> <td>if invalid UTF, return <code>replacementDchar</code> rather than throwing</td>
</tr> <tr>
<td>S <code>str</code>
</td> <td>input string or bidirectional Range</td>
</tr> <tr>
<td>size_t <code>numCodeUnits</code>
</td> <td>gives the number of code units processed</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A decoded UTF character. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="#UTFException"><code>UTFException</code></a> if <code>str.back</code> is not the end of a valid UTF sequence. If an exception is thrown, the <code>str</code> itself remains unchanged, but there is no guarantee as to the value of <code>numCodeUnits</code> (when passed).</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.range.primitives;
string str = "Hello, World!";

assert(str.decodeBack == '!' &amp;&amp; str == "Hello, World");
str = "√•";
assert(str.decodeBack == '√•' &amp;&amp; str.empty);
str = "√•";
size_t i;
assert(str.decodeBack(i) == '√•' &amp;&amp; i == 2 &amp;&amp; str.empty);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="encode">pure @safe size_t <strong id="encode">encode</strong>(UseReplacementDchar useReplacementDchar = No.useReplacementDchar)(out char[4] buf, dchar c); <br><br>pure @safe size_t <strong id="encode">encode</strong>(UseReplacementDchar useReplacementDchar = No.useReplacementDchar)(out wchar[2] buf, dchar c); <br><br>pure @safe size_t <strong id="encode">encode</strong>(UseReplacementDchar useReplacementDchar = No.useReplacementDchar)(out dchar[1] buf, dchar c); </dt> <dd>
<p>Encodes <code>c</code> into the static array, <code>buf</code>, and returns the actual length of the encoded character (a number between <code>1</code> and <code>4</code> for <code>char[4]</code> buffers and a number between <code>1</code> and <code>2</code> for <code>wchar[2]</code> buffers). </p>
<dl>
<dt>Throws:</dt>
<dd>
<code>UTFException</code> if <code>c</code> is not a valid UTF code point.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.exception : assertThrown;
import std.typecons : Yes;

char[4] buf;

assert(encode(buf, '\u0000') == 1 &amp;&amp; buf[0 .. 1] == "\u0000");
assert(encode(buf, '\u007F') == 1 &amp;&amp; buf[0 .. 1] == "\u007F");
assert(encode(buf, '\u0080') == 2 &amp;&amp; buf[0 .. 2] == "\u0080");
assert(encode(buf, '\uE000') == 3 &amp;&amp; buf[0 .. 3] == "\uE000");
assert(encode(buf, 0xFFFE) == 3 &amp;&amp; buf[0 .. 3] == "\xEF\xBF\xBE");
assertThrown!UTFException(encode(buf, cast(dchar) 0x110000));

encode!(Yes.useReplacementDchar)(buf, cast(dchar) 0x110000);
auto slice = buf[];
writeln(slice.decodeFront); // replacementDchar
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.exception : assertThrown;
import std.typecons : Yes;

wchar[2] buf;

assert(encode(buf, '\u0000') == 1 &amp;&amp; buf[0 .. 1] == "\u0000");
assert(encode(buf, '\uD7FF') == 1 &amp;&amp; buf[0 .. 1] == "\uD7FF");
assert(encode(buf, '\uE000') == 1 &amp;&amp; buf[0 .. 1] == "\uE000");
assert(encode(buf, '\U00010000') == 2 &amp;&amp; buf[0 .. 2] == "\U00010000");
assert(encode(buf, '\U0010FFFF') == 2 &amp;&amp; buf[0 .. 2] == "\U0010FFFF");
assertThrown!UTFException(encode(buf, cast(dchar) 0xD800));

encode!(Yes.useReplacementDchar)(buf, cast(dchar) 0x110000);
auto slice = buf[];
writeln(slice.decodeFront); // replacementDchar
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.exception : assertThrown;
import std.typecons : Yes;

dchar[1] buf;

assert(encode(buf, '\u0000') == 1 &amp;&amp; buf[0] == '\u0000');
assert(encode(buf, '\uD7FF') == 1 &amp;&amp; buf[0] == '\uD7FF');
assert(encode(buf, '\uE000') == 1 &amp;&amp; buf[0] == '\uE000');
assert(encode(buf, '\U0010FFFF') == 1 &amp;&amp; buf[0] == '\U0010FFFF');
assertThrown!UTFException(encode(buf, cast(dchar) 0xD800));

encode!(Yes.useReplacementDchar)(buf, cast(dchar) 0x110000);
writeln(buf[0]); // replacementDchar
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="encode.2">pure @safe void <strong id="encode">encode</strong>(UseReplacementDchar useReplacementDchar = No.useReplacementDchar)(ref char[] str, dchar c); <br><br>pure @safe void <strong id="encode">encode</strong>(UseReplacementDchar useReplacementDchar = No.useReplacementDchar)(ref wchar[] str, dchar c); <br><br>pure @safe void <strong id="encode">encode</strong>(UseReplacementDchar useReplacementDchar = No.useReplacementDchar)(ref dchar[] str, dchar c); </dt> <dd>
<p>Encodes <code>c</code> in <code>str</code>'s encoding and appends it to <code>str</code>. </p>
<dl>
<dt>Throws:</dt>
<dd>
<code>UTFException</code> if <code>c</code> is not a valid UTF code point.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">char[] s = "abcd".dup;
dchar d1 = 'a';
dchar d2 = '√∏';

encode(s, d1);
writeln(s.length); // 5
writeln(s); // "abcda"
encode(s, d2);
writeln(s.length); // 7
writeln(s); // "abcda√∏"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="codeLength">pure nothrow @nogc @safe ubyte <strong id="codeLength">codeLength</strong>(C)(dchar c)<br><small>  Constraints: if (isSomeChar!C); </small>
</dt> <dd>
<p>Returns the number of code units that are required to encode the code point <code>c</code> when <code>C</code> is the character type used to encode it.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(codeLength!char('a')); // 1
writeln(codeLength!wchar('a')); // 1
writeln(codeLength!dchar('a')); // 1

writeln(codeLength!char('\U0010FFFF')); // 4
writeln(codeLength!wchar('\U0010FFFF')); // 2
writeln(codeLength!dchar('\U0010FFFF')); // 1
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="codeLength.2">size_t <strong id="codeLength">codeLength</strong>(C, InputRange)(InputRange input)<br><small>  Constraints: if (isInputRange!InputRange &amp;&amp; !isInfinite!InputRange &amp;&amp; isSomeChar!(ElementType!InputRange)); </small>
</dt> <dd>
<p>Returns the number of code units that are required to encode <code>str</code> in a string whose character type is <code>C</code>. This is particularly useful when slicing one string with the length of another and the two string types use different character types. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>C</td> <td>the character type to get the encoding length for</td>
</tr> <tr>
<td>InputRange <code>input</code>
</td> <td>the <a href="std_range_primitives.html#isInputRange">input range</a> to calculate the encoding length from</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The number of code units in <code>input</code> when encoded to <code>C</code>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(codeLength!char("hello world") ==
       "hello world".length);
assert(codeLength!wchar("hello world") ==
       "hello world"w.length);
assert(codeLength!dchar("hello world") ==
       "hello world"d.length);

assert(codeLength!char(`„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞`) ==
       `„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞`.length);
assert(codeLength!wchar(`„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞`) ==
       `„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞`w.length);
assert(codeLength!dchar(`„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞`) ==
       `„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞`d.length);

string haystack = `√ätre sans la verit√©, √ßa, ce ne serait pas bien.`;
wstring needle = `√ätre sans la verit√©`;
assert(haystack[codeLength!char(needle) .. $] ==
       `, √ßa, ce ne serait pas bien.`);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="validate">pure @safe void <strong id="validate">validate</strong>(S)(in S str)<br><small>  Constraints: if (isSomeString!S); </small>
</dt> <dd>
<p>Checks to see if <code>str</code> is well-formed unicode or not. </p>
<dl>
<dt>Throws:</dt>
<dd>
<code>UTFException</code> if <code>str</code> is not well-formed.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.exception : assertThrown;
char[] a = [167, 133, 175];
assertThrown!UTFException(validate(a));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="toUTF8">string <strong id="toUTF8">toUTF8</strong>(S)(S s)<br><small>  Constraints: if (isInputRange!S &amp;&amp; !isInfinite!S &amp;&amp; isSomeChar!(ElementEncodingType!S)); </small>
</dt> <dd>
<p>Encodes the elements of <code>s</code> to UTF-8 and returns a newly allocated string of the elements. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>S <code>s</code>
</td> <td>the string to encode</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A UTF-8 string </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>For a lazy, non-allocating version of these functions, see <a href="#byUTF"><code>byUTF</code></a>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;

// The √∂ is represented by two UTF-8 code units
assert("Hell√∏"w.toUTF8.equal(['H', 'e', 'l', 'l', 0xC3, 0xB8]));

// êê∑ is four code units in UTF-8
assert("êê∑"d.toUTF8.equal([0xF0, 0x90, 0x90, 0xB7]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="toUTF16">wstring <strong id="toUTF16">toUTF16</strong>(S)(S s)<br><small>  Constraints: if (isInputRange!S &amp;&amp; !isInfinite!S &amp;&amp; isSomeChar!(ElementEncodingType!S)); </small>
</dt> <dd>
<p>Encodes the elements of <code>s</code> to UTF-16 and returns a newly GC allocated <code>wstring</code> of the elements. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>S <code>s</code>
</td> <td>the range to encode</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A UTF-16 string </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>For a lazy, non-allocating version of these functions, see <a href="#byUTF"><code>byUTF</code></a>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;

// these graphemes are two code units in UTF-16 and one in UTF-32
writeln("§≠¢"d.length); // 1
writeln("êê∑"d.length); // 1

assert("§≠¢"d.toUTF16.equal([0xD852, 0xDF62]));
assert("êê∑"d.toUTF16.equal([0xD801, 0xDC37]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="toUTF32">dstring <strong id="toUTF32">toUTF32</strong>(S)(S s)<br><small>  Constraints: if (isInputRange!S &amp;&amp; !isInfinite!S &amp;&amp; isSomeChar!(ElementEncodingType!S)); </small>
</dt> <dd>
<p>Encodes the elements of <code>s</code> to UTF-32 and returns a newly GC allocated <code>dstring</code> of the elements. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>S <code>s</code>
</td> <td>the range to encode</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A UTF-32 string </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>For a lazy, non-allocating version of these functions, see <a href="#byUTF"><code>byUTF</code></a>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;

// these graphemes are two code units in UTF-16 and one in UTF-32
writeln("§≠¢"w.length); // 2
writeln("êê∑"w.length); // 2

assert("§≠¢"w.toUTF32.equal([0x00024B62]));
assert("êê∑"w.toUTF32.equal([0x00010437]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="toUTFz">template <strong id="toUTFz">toUTFz</strong>(P) if (isPointer!P &amp;&amp; isSomeChar!(typeof(*P.init)))</dt> <dd>
<p>Returns a C-style zero-terminated string equivalent to <code>str</code>. <code>str</code> must not contain embedded <code>'\0'</code>'s as any C function will treat the first <code>'\0'</code> that it sees as the end of the string. If <code>str.empty</code> is <code>true</code>, then a string containing only <code>'\0'</code> is returned. </p>
<p><code>toUTFz</code> accepts any type of string and is templated on the type of character pointer that you wish to convert to. It will avoid allocating a new string if it can, but there's a decent chance that it will end up having to allocate a new string - particularly when dealing with character types other than <code>char</code>. <br><br> <span class="red">Warning 1:</span> If the result of <code>toUTFz</code> equals <code>str.ptr</code>, then if anything alters the character one past the end of <code>str</code> (which is the <code>'\0'</code> character terminating the string), then the string won't be zero-terminated anymore. The most likely scenarios for that are if you append to <code>str</code> and no reallocation takes place or when <code>str</code> is a slice of a larger array, and you alter the character in the larger array which is one character past the end of <code>str</code>. Another case where it could occur would be if you had a mutable character array immediately after <code>str</code> in memory (for example, if they're member variables in a user-defined type with one declared right after the other) and that character array happened to start with <code>'\0'</code>. Such scenarios will never occur if you immediately use the zero-terminated string after calling <code>toUTFz</code> and the C function using it doesn't keep a reference to it. Also, they are unlikely to occur even if you save the zero-terminated string (the cases above would be among the few examples of where it could happen). However, if you save the zero-terminate string and want to be absolutely certain that the string stays zero-terminated, then simply append a <code>'\0'</code> to the string and use its <code>ptr</code> property rather than calling <code>toUTFz</code>. <br><br> <span class="red">Warning 2:</span> When passing a character pointer to a C function, and the C function keeps it around for any reason, make sure that you keep a reference to it in your D code. Otherwise, it may go away during a garbage collection cycle and cause a nasty bug when the C code tries to use it.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto p1 = toUTFz!(char*)("hello world");
auto p2 = toUTFz!(const(char)*)("hello world");
auto p3 = toUTFz!(immutable(char)*)("hello world");
auto p4 = toUTFz!(char*)("hello world"d);
auto p5 = toUTFz!(const(wchar)*)("hello world");
auto p6 = toUTFz!(immutable(dchar)*)("hello world"w);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="toUTF16z">pure @safe const(wchar)* <strong id="toUTF16z">toUTF16z</strong>(C)(const(C)[] str)<br><small>  Constraints: if (isSomeChar!C); </small>
</dt> <dd>
<p><code>toUTF16z</code> is a convenience function for <code>toUTFz!(const(wchar)*)</code>. </p>
<p>Encodes string <code>s</code> into UTF-16 and returns the encoded string. <code>toUTF16z</code> is suitable for calling the 'W' functions in the Win32 API that take an <code>LPCWSTR</code> argument.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">string str = "Hello, World!";
const(wchar)* p = str.toUTF16z;
writeln(p[str.length]); // '\0'
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="count">pure nothrow @nogc @safe size_t <strong id="count">count</strong>(C)(const(C)[] str)<br><small>  Constraints: if (isSomeChar!C); </small>
</dt> <dd>
<p>Returns the total number of code points encoded in <code>str</code>. </p>
<dl>
<dt>Supercedes</dt>
<dd> This function supercedes <a href="#toUCSindex"><code>toUCSindex</code></a>. </dd>
</dl> <dl>
<dt>Standards:</dt>
<dd>Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252 </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<code>UTFException</code> if <code>str</code> is not well-formed.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(count("")); // 0
writeln(count("a")); // 1
writeln(count("abc")); // 3
writeln(count("\u20AC100")); // 4
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="replacementDchar">enum dchar <strong id="replacementDchar">replacementDchar</strong>; </dt> <dd>
<p>Inserted in place of invalid UTF sequences. </p>
<dl>
<dt>References</dt>
<dd> <a href="http://en.wikipedia.org/wiki/Replacement_character#Replacement_character">http://en.wikipedia.org/wiki/Replacement_character#Replacement_character</a>
</dd>
</dl> </dd> <dt class="d_decl" id="byCodeUnit">auto <strong id="byCodeUnit">byCodeUnit</strong>(R)(R r)<br><small>  Constraints: if (isConvertibleToString!R &amp;&amp; !isStaticArray!R || isInputRange!R &amp;&amp; isSomeChar!(ElementEncodingType!R)); </small>
</dt> <dd>
<p>Iterate a range of char, wchar, or dchars by code unit. </p>
<p>The purpose is to bypass the special case decoding that <a href="std_range_primitives.html#front"><code>std.range.primitives.front</code></a> does to character arrays. As a result, using ranges with <code>byCodeUnit</code> can be <code>nothrow</code> while <a href="std_range_primitives.html#front"><code>std.range.primitives.front</code></a> throws when it encounters invalid Unicode sequences. <br><br> A code unit is a building block of the UTF encodings. Generally, an individual code unit does not represent what's perceived as a full character (a.k.a. a grapheme cluster in Unicode terminology). Many characters are encoded with multiple code units. For example, the UTF-8 code units for <code>√∏</code> are <code>0xC3 0xB8</code>. That means, an individual element of <code>byCodeUnit</code> often does not form a character on its own. Attempting to treat it as one while iterating over the resulting range will give nonsensical results. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>r</code>
</td> <td>an <a href="std_range_primitives.html#isInputRange">input range</a> of characters (including strings) or a type that implicitly converts to a string type.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>If <code>r</code> is not an auto-decodable string (i.e. a narrow string or a user-defined type that implicits converts to a string type), then <code>r</code> is returned.  Otherwise, <code>r</code> is converted to its corresponding string type (if it's not already a string) and wrapped in a random-access range where the element encoding type of the string (its code unit) is the element type of the range, and that range returned. The range has slicing.  If <code>r</code> is quirky enough to be a struct or class which is an input range of characters on its own (i.e. it has the input range API as member functions), <i>and</i> it's implicitly convertible to a string type, then <code>r</code> is returned, and no implicit conversion takes place.  If <code>r</code> is wrapped in a new range, then that range has a <code>source</code> property for returning the string that's currently contained within that range. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>Refer to the <a href="std_uni.html"><code>std.uni</code></a> docs for a reference on Unicode terminology.  For a range that iterates by grapheme cluster (written character) see <a href="std_uni.html#byGrapheme"><code>std.uni.byGrapheme</code></a>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.range.primitives;
import std.traits : isAutodecodableString;

auto r = "Hello, World!".byCodeUnit();
static assert(hasLength!(typeof(r)));
static assert(hasSlicing!(typeof(r)));
static assert(isRandomAccessRange!(typeof(r)));
static assert(is(ElementType!(typeof(r)) == immutable char));

// contrast with the range capabilities of standard strings (with or
// without autodecoding enabled).
auto s = "Hello, World!";
static assert(isBidirectionalRange!(typeof(r)));
static if (isAutodecodableString!(typeof(s)))
{
    // with autodecoding enabled, strings are non-random-access ranges of
    // dchar.
    static assert(is(ElementType!(typeof(s)) == dchar));
    static assert(!isRandomAccessRange!(typeof(s)));
    static assert(!hasSlicing!(typeof(s)));
    static assert(!hasLength!(typeof(s)));
}
else
{
    // without autodecoding, strings are normal arrays.
    static assert(is(ElementType!(typeof(s)) == immutable char));
    static assert(isRandomAccessRange!(typeof(s)));
    static assert(hasSlicing!(typeof(s)));
    static assert(hasLength!(typeof(s)));
}
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<code>byCodeUnit</code> does no Unicode decoding <pre data-language="d">string noel1 = "noe\u0308l"; // no√´l using e + combining diaeresis
assert(noel1.byCodeUnit[2] != '√´');
writeln(noel1.byCodeUnit[2]); // 'e'

string noel2 = "no\u00EBl"; // no√´l using a precomposed √´ character
// Because string is UTF-8, the code unit at index 2 is just
// the first of a sequence that encodes '√´'
assert(noel2.byCodeUnit[2] != '√´');
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<code>byCodeUnit</code> exposes a <code>source</code> property when wrapping narrow strings. <pre data-language="d">import std.algorithm.comparison : equal;
import std.range : popFrontN;
import std.traits : isAutodecodableString;
{
    auto range = byCodeUnit("hello world");
    range.popFrontN(3);
    assert(equal(range.save, "lo world"));
    static if (isAutodecodableString!string) // only enabled with autodecoding
    {
        string str = range.source;
        writeln(str); // "lo world"
    }
}
// source only exists if the range was wrapped
{
    auto range = byCodeUnit("hello world"d);
    static assert(!__traits(compiles, range.source));
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="byChar">alias <strong id="byChar">byChar</strong> = byUTF!(char, Flag.yes).byUTF(R)(R r) if (isAutodecodableString!R &amp;&amp; isInputRange!R &amp;&amp; isSomeChar!(ElementEncodingType!R)); <br><br>alias <strong id="byWchar">byWchar</strong> = byUTF!(wchar, Flag.yes).byUTF(R)(R r) if (isAutodecodableString!R &amp;&amp; isInputRange!R &amp;&amp; isSomeChar!(ElementEncodingType!R)); <br><br>alias <strong id="byDchar">byDchar</strong> = byUTF!(dchar, Flag.yes).byUTF(R)(R r) if (isAutodecodableString!R &amp;&amp; isInputRange!R &amp;&amp; isSomeChar!(ElementEncodingType!R)); </dt> <dd>
<p>Iterate an <a href="std_range_primitives.html#isInputRange">input range</a> of characters by char, wchar, or dchar. These aliases simply forward to <a href="#byUTF"><code>byUTF</code></a> with the corresponding C argument. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R r</td> <td>input range of characters, or array of characters</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="byUTF">template <strong id="byUTF">byUTF</strong>(C, UseReplacementDchar useReplacementDchar = Yes.useReplacementDchar) if (isSomeChar!C)</dt> <dd>
<p>Iterate an <a href="std_range_primitives.html#isInputRange">input range</a> of characters by char type <code>C</code> by encoding the elements of the range. </p>
<p>UTF sequences that cannot be converted to the specified encoding are either replaced by U+FFFD per "5.22 Best Practice for U+FFFD Substitution" of the Unicode Standard 6.2 or result in a thrown UTFException. Hence byUTF is not symmetric. This algorithm is lazy, and does not allocate memory. <code>@nogc</code>, <code>pure</code>-ity, <code>nothrow</code>, and <code>@safe</code>-ty are inferred from the <code>r</code> parameter. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>C</td> <td>
<code>char</code>, <code>wchar</code>, or <code>dchar</code>
</td>
</tr> <tr>
<td>useReplacementDchar</td> <td>UseReplacementDchar.yes means replace invalid UTF with <code>replacementDchar</code>, UseReplacementDchar.no means throw <code>UTFException</code> for invalid UTF</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<code>UTFException</code> if invalid UTF sequence and <code>useReplacementDchar</code> is set to <code>UseReplacementDchar.yes</code> </dd>
</dl> <dl>
<dt>GC</dt>
<dd> Does not use GC if <code>useReplacementDchar</code> is set to <code>UseReplacementDchar.no</code> </dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A forward range if <code>R</code> is a range and not auto-decodable, as defined by <a href="std_traits.html#isAutodecodableString"><code>std.traits.isAutodecodableString</code></a>, and if the base range is also a forward range.  Or, if <code>R</code> is a range and it is auto-decodable and <code>is(ElementEncodingType!typeof(r) == C)</code>, then the range is passed to <a href="#byCodeUnit"><code>byCodeUnit</code></a>.  Otherwise, an input range of characters.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;

// hell√∂ as a range of `char`s, which are UTF-8
assert("hell\u00F6".byUTF!char().equal(['h', 'e', 'l', 'l', 0xC3, 0xB6]));

// `wchar`s are able to hold the √∂ in a single element (UTF-16 code unit)
assert("hell\u00F6".byUTF!wchar().equal(['h', 'e', 'l', 'l', '√∂']));

// êê∑ is four code units in UTF-8, two in UTF-16, and one in UTF-32
assert("êê∑".byUTF!char().equal([0xF0, 0x90, 0x90, 0xB7]));
assert("êê∑".byUTF!wchar().equal([0xD801, 0xDC37]));
assert("êê∑".byUTF!dchar().equal([0x00010437]));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.exception : assertThrown;

assert("hello\xF0betty".byChar.byUTF!(dchar, UseReplacementDchar.yes).equal("hello\uFFFDetty"));
assertThrown!UTFException("hello\xF0betty".byChar.byUTF!(dchar, UseReplacementDchar.no).equal("hello betty"));
</pre> </dd>
</dl> </dd> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1999&ndash;2021 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/std_utf.html" class="_attribution-link">https://dlang.org/phobos/std_utf.html</a>
  </p>
</div>
