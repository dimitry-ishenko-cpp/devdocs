<h1>std.algorithm.setops</h1>  <p>This is a submodule of <a href="std_algorithm.html"><code>std.algorithm</code></a>. It contains generic algorithms that implement set operations. </p>
<p>The functions <a href="#multiwayMerge"><code>multiwayMerge</code></a>, <a href="#multiwayUnion"><code>multiwayUnion</code></a>, <a href="#setDifference"><code>setDifference</code></a>, <a href="#setIntersection"><code>setIntersection</code></a>, <a href="#setSymmetricDifference"><code>setSymmetricDifference</code></a> expect a range of sorted ranges as input. <br><br> All algorithms are generalized to accept as input not only sets but also <a href="http://https//en.wikipedia.org/wiki/Multiset">multisets</a>. Each algorithm documents behaviour in the presence of duplicated inputs. <br><br>  <table>
<caption>Cheat Sheet</caption>
<tr>
<th scope="col">Function Name</th> <th scope="col">Description</th>
</tr> <tr>
<td><a href="#cartesianProduct"><code>cartesianProduct</code></a></td> <td> Computes Cartesian product of two ranges.</td>
</tr> <tr>
<td><a href="#largestPartialIntersection"><code>largestPartialIntersection</code></a></td> <td> Copies out the values that occur most frequently in a range of ranges.</td>
</tr> <tr>
<td><a href="#largestPartialIntersectionWeighted"><code>largestPartialIntersectionWeighted</code></a></td> <td> Copies out the values that occur most frequently (multiplied by per-value weights) in a range of ranges.</td>
</tr> <tr>
<td><a href="#multiwayMerge"><code>multiwayMerge</code></a></td> <td> Merges a range of sorted ranges.</td>
</tr> <tr>
<td><a href="#multiwayUnion"><code>multiwayUnion</code></a></td> <td> Computes the union of a range of sorted ranges.</td>
</tr> <tr>
<td><a href="#setDifference"><code>setDifference</code></a></td> <td> Lazily computes the set difference of two or more sorted ranges.</td>
</tr> <tr>
<td><a href="#setIntersection"><code>setIntersection</code></a></td> <td> Lazily computes the intersection of two or more sorted ranges.</td>
</tr> <tr>
<td><a href="#setSymmetricDifference"><code>setSymmetricDifference</code></a></td> <td> Lazily computes the symmetric set difference of two or more sorted ranges.</td>
</tr> </table> </p> <dl>
<dt>License:</dt>
<dd>
<a href="http://boost.org/LICENSE_1_0.txt">Boost License 1.0</a>. </dd>
</dl> <dl>
<dt>Authors:</dt>
<dd>
<a href="http://erdani.com">Andrei Alexandrescu</a> </dd>
</dl> <dl>
<dt>Source</dt>
<dd> <span class="phobos_src"><a class="https" href="https://github.com/dlang/phobos/blob/master/std/algorithm/setops.d">std/algorithm/setops.d</a></span> </dd>
</dl> <dl>
<dt class="d_decl" id="cartesianProduct">auto <strong id="cartesianProduct">cartesianProduct</strong>(R1, R2)(R1 range1, R2 range2)<br><small>  Constraints: if (!allSatisfy!(isForwardRange, R1, R2) || anySatisfy!(isInfinite, R1, R2)); </small><br><br>auto <strong id="cartesianProduct">cartesianProduct</strong>(RR...)(RR ranges)<br><small>  Constraints: if (ranges.length &gt;= 2 &amp;&amp; allSatisfy!(isForwardRange, RR) &amp;&amp; !anySatisfy!(isInfinite, RR)); </small><br><br>auto <strong id="cartesianProduct">cartesianProduct</strong>(R1, R2, RR...)(R1 range1, R2 range2, RR otherRanges)<br><small>  Constraints: if (!allSatisfy!(isForwardRange, R1, R2, RR) || anySatisfy!(isInfinite, R1, R2, RR)); </small>
</dt> <dd>
<p>Lazily computes the Cartesian product of two or more ranges. The product is a range of tuples of elements from each respective range. </p>
<p>The conditions for the two-range case are as follows: <br><br> If both ranges are finite, then one must be (at least) a <a href="std_range_primitives.html#isForwardRange">forward range</a> and the other an <a href="std_range_primitives.html#isInputRange">input range</a>. <br><br> If one range is infinite and the other finite, then the finite range must be a forward range, and the infinite range can be an input range. <br><br> If both ranges are infinite, then both must be forward ranges. <br><br> When there are more than two ranges, the above conditions apply to each adjacent pair of ranges. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R1 <code>range1</code>
</td> <td>The first range</td>
</tr> <tr>
<td>R2 <code>range2</code>
</td> <td>The second range</td>
</tr> <tr>
<td>RR <code>ranges</code>
</td> <td>Two or more non-infinite forward ranges</td>
</tr> <tr>
<td>RR <code>otherRanges</code>
</td> <td>Zero or more non-infinite forward ranges</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A forward range of <a href="std_typecons.html#Tuple"><code>std.typecons.Tuple</code></a> representing elements of the cartesian product of the given ranges.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.searching : canFind;
import std.range;
import std.typecons : tuple;

auto N = sequence!"n"(0);         // the range of natural numbers
auto N2 = cartesianProduct(N, N); // the range of all pairs of natural numbers

// Various arbitrary number pairs can be found in the range in finite time.
assert(canFind(N2, tuple(0, 0)));
assert(canFind(N2, tuple(123, 321)));
assert(canFind(N2, tuple(11, 35)));
assert(canFind(N2, tuple(279, 172)));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.searching : canFind;
import std.typecons : tuple;

auto B = [ 1, 2, 3 ];
auto C = [ 4, 5, 6 ];
auto BC = cartesianProduct(B, C);

foreach (n; [[1, 4], [2, 4], [3, 4], [1, 5], [2, 5], [3, 5], [1, 6],
             [2, 6], [3, 6]])
{
    assert(canFind(BC, tuple(n[0], n[1])));
}
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.typecons : tuple;

auto A = [ 1, 2, 3 ];
auto B = [ 'a', 'b', 'c' ];
auto C = [ "x", "y", "z" ];
auto ABC = cartesianProduct(A, B, C);

assert(ABC.equal([
    tuple(1, 'a', "x"), tuple(1, 'a', "y"), tuple(1, 'a', "z"),
    tuple(1, 'b', "x"), tuple(1, 'b', "y"), tuple(1, 'b', "z"),
    tuple(1, 'c', "x"), tuple(1, 'c', "y"), tuple(1, 'c', "z"),
    tuple(2, 'a', "x"), tuple(2, 'a', "y"), tuple(2, 'a', "z"),
    tuple(2, 'b', "x"), tuple(2, 'b', "y"), tuple(2, 'b', "z"),
    tuple(2, 'c', "x"), tuple(2, 'c', "y"), tuple(2, 'c', "z"),
    tuple(3, 'a', "x"), tuple(3, 'a', "y"), tuple(3, 'a', "z"),
    tuple(3, 'b', "x"), tuple(3, 'b', "y"), tuple(3, 'b', "z"),
    tuple(3, 'c', "x"), tuple(3, 'c', "y"), tuple(3, 'c', "z")
]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="largestPartialIntersection">void <strong id="largestPartialIntersection">largestPartialIntersection</strong>(alias less = "a &lt; b", RangeOfRanges, Range)(RangeOfRanges ror, Range tgt, SortOutput sorted = No.sortOutput); </dt> <dd>
<p>Given a range of sorted <a href="std_range_primitives.html#isForwardRange">forward ranges</a> <code>ror</code>, copies to <code>tgt</code> the elements that are common to most ranges, along with their number of occurrences. All ranges in <code>ror</code> are assumed to be sorted by <code>less</code>. Only the most frequent <code>tgt.length</code> elements are returned. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>less</td> <td>The predicate the ranges are sorted by.</td>
</tr> <tr>
<td>RangeOfRanges <code>ror</code>
</td> <td>A range of forward ranges sorted by <code>less</code>.</td>
</tr> <tr>
<td>Range <code>tgt</code>
</td> <td>The target range to copy common elements to.</td>
</tr> <tr>
<td>SortOutput <code>sorted</code>
</td> <td>Whether the elements copied should be in sorted order.  The function <code>largestPartialIntersection</code> is useful for e.g. searching an <a href="https://en.wikipedia.org/wiki/Inverted_index">inverted index</a> for the documents most likely to contain some terms of interest. The complexity of the search is <span class="bigoh">ÎŸ(<code>n * log(tgt.length)</code>)</span>, where <code>n</code> is the sum of lengths of all input ranges. This approach is faster than keeping an associative array of the occurrences and then selecting its top items, and also requires less memory (<code>largestPartialIntersection</code> builds its result directly in <code>tgt</code> and requires no extra memory).  If at least one of the ranges is a multiset, then all occurences of a duplicate element are taken into account. The result is equivalent to merging all ranges and picking the most frequent <code>tgt.length</code> elements.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Warning</dt>
<dd> Because <code>largestPartialIntersection</code> does not allocate extra memory, it will leave <code>ror</code> modified. Namely, <code>largestPartialIntersection</code> assumes ownership of <code>ror</code> and discretionarily swaps and advances elements of it. If you want <code>ror</code> to preserve its contents after the call, you may want to pass a duplicate to <code>largestPartialIntersection</code> (and perhaps cache the duplicate in between calls).</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.typecons : tuple, Tuple;

// Figure which number can be found in most arrays of the set of
// arrays below.
double[][] a =
[
    [ 1, 4, 7, 8 ],
    [ 1, 7 ],
    [ 1, 7, 8],
    [ 4 ],
    [ 7 ],
];
auto b = new Tuple!(double, uint)[1];
// it will modify the input range, hence we need to create a duplicate
largestPartialIntersection(a.dup, b);
// First member is the item, second is the occurrence count
writeln(b[0]); // tuple(7.0, 4u)
// 7.0 occurs in 4 out of 5 inputs, more than any other number

// If more of the top-frequent numbers are needed, just create a larger
// tgt range
auto c = new Tuple!(double, uint)[2];
largestPartialIntersection(a, c);
writeln(c[0]); // tuple(1.0, 3u)
// 1.0 occurs in 3 inputs

// multiset
double[][] x =
[
    [1, 1, 1, 1, 4, 7, 8],
    [1, 7],
    [1, 7, 8],
    [4, 7],
    [7]
];
auto y = new Tuple!(double, uint)[2];
largestPartialIntersection(x.dup, y);
// 7.0 occurs 5 times
writeln(y[0]); // tuple(7.0, 5u)
// 1.0 occurs 6 times
writeln(y[1]); // tuple(1.0, 6u)
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="largestPartialIntersectionWeighted">void <strong id="largestPartialIntersectionWeighted">largestPartialIntersectionWeighted</strong>(alias less = "a &lt; b", RangeOfRanges, Range, WeightsAA)(RangeOfRanges ror, Range tgt, WeightsAA weights, SortOutput sorted = No.sortOutput); </dt> <dd>
<p>Similar to <code>largestPartialIntersection</code>, but associates a weight with each distinct element in the intersection. </p>
<p>If at least one of the ranges is a multiset, then all occurences of a duplicate element are taken into account. The result is equivalent to merging all input ranges and picking the highest <code>tgt.length</code>, weight-based ranking elements. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>less</td> <td>The predicate the ranges are sorted by.</td>
</tr> <tr>
<td>RangeOfRanges <code>ror</code>
</td> <td>A range of <a href="std_range_primitives.html#isForwardRange">forward ranges</a> sorted by <code>less</code>.</td>
</tr> <tr>
<td>Range <code>tgt</code>
</td> <td>The target range to copy common elements to.</td>
</tr> <tr>
<td>WeightsAA <code>weights</code>
</td> <td>An associative array mapping elements to weights.</td>
</tr> <tr>
<td>SortOutput <code>sorted</code>
</td> <td>Whether the elements copied should be in sorted order.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.typecons : tuple, Tuple;

// Figure which number can be found in most arrays of the set of
// arrays below, with specific per-element weights
double[][] a =
[
    [ 1, 4, 7, 8 ],
    [ 1, 7 ],
    [ 1, 7, 8],
    [ 4 ],
    [ 7 ],
];
auto b = new Tuple!(double, uint)[1];
double[double] weights = [ 1:1.2, 4:2.3, 7:1.1, 8:1.1 ];
largestPartialIntersectionWeighted(a, b, weights);
// First member is the item, second is the occurrence count
writeln(b[0]); // tuple(4.0, 2u)
// 4.0 occurs 2 times -&gt; 4.6 (2 * 2.3)
// 7.0 occurs 3 times -&gt; 4.4 (3 * 1.1)

// multiset
double[][] x =
[
    [ 1, 1, 1, 4, 7, 8 ],
    [ 1, 7 ],
    [ 1, 7, 8],
    [ 4 ],
    [ 7 ],
];
auto y = new Tuple!(double, uint)[1];
largestPartialIntersectionWeighted(x, y, weights);
writeln(y[0]); // tuple(1.0, 5u)
// 1.0 occurs 5 times -&gt; 1.2 * 5 = 6
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="MultiwayMerge">struct <strong id="MultiwayMerge">MultiwayMerge</strong>(alias less, RangeOfRanges); <br><br>MultiwayMerge!(less, RangeOfRanges) <strong id="multiwayMerge">multiwayMerge</strong>(alias less = "a &lt; b", RangeOfRanges)(RangeOfRanges ror); </dt> <dd>
<p>Merges multiple sets. The input sets are passed as a range of ranges and each is assumed to be sorted by <code>less</code>. Computation is done lazily, one union element at a time. The complexity of one <code>popFront</code> operation is <span class="bigoh">ÎŸ(<code>log(ror.length)</code>)</span>. However, the length of <code>ror</code> decreases as ranges in it are exhausted, so the complexity of a full pass through <code>MultiwayMerge</code> is dependent on the distribution of the lengths of ranges contained within <code>ror</code>. If all ranges have the same length <code>n</code> (worst case scenario), the complexity of a full pass through <code>MultiwayMerge</code> is <span class="bigoh">ÎŸ(<code>n * ror.length * log(ror.length)</code>)</span>, i.e., <code>log(ror.length)</code> times worse than just spanning all ranges in turn. The output comes sorted (unstably) by <code>less</code>. </p>
<p>The length of the resulting range is the sum of all lengths of the ranges passed as input. This means that all elements (duplicates included) are transferred to the resulting range. <br><br> For backward compatibility, <code>multiwayMerge</code> is available under the name <code>nWayUnion</code> and <code>MultiwayMerge</code> under the name of <code>NWayUnion</code> . Future code should use <code>multiwayMerge</code> and <code>MultiwayMerge</code> as <code>nWayUnion</code> and <code>NWayUnion</code> will be deprecated. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>less</td> <td>Predicate the given ranges are sorted by.</td>
</tr> <tr>
<td>RangeOfRanges <code>ror</code>
</td> <td>A range of ranges sorted by <code>less</code> to compute the union for.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A range of the union of the ranges in <code>ror</code>. </dd>
</dl> <dl>
<dt>Warning</dt>
<dd> Because <code>MultiwayMerge</code> does not allocate extra memory, it will leave <code>ror</code> modified. Namely, <code>MultiwayMerge</code> assumes ownership of <code>ror</code> and discretionarily swaps and advances elements of it. If you want <code>ror</code> to preserve its contents after the call, you may want to pass a duplicate to <code>MultiwayMerge</code> (and perhaps cache the duplicate in between calls). </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="std_algorithm_sorting.html#merge"><code>std.algorithm.sorting.merge</code></a> for an analogous function that takes a static number of ranges of possibly disparate types.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;

double[][] a =
[
    [ 1, 4, 7, 8 ],
    [ 1, 7 ],
    [ 1, 7, 8],
    [ 4 ],
    [ 7 ],
];
auto witness = [
    1, 1, 1, 4, 4, 7, 7, 7, 7, 8, 8
];
assert(equal(multiwayMerge(a), witness));

double[][] b =
[
    // range with duplicates
    [ 1, 1, 4, 7, 8 ],
    [ 7 ],
    [ 1, 7, 8],
    [ 4 ],
    [ 7 ],
];
// duplicates are propagated to the resulting range
assert(equal(multiwayMerge(b), witness));
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="MultiwayMerge.compFront">static bool <strong id="compFront">compFront</strong>(.ElementType!RangeOfRanges a, .ElementType!RangeOfRanges b); </dt>  <dt class="d_decl" id="MultiwayMerge.this">this(RangeOfRanges ror); </dt>  <dt class="d_decl" id="MultiwayMerge.empty">@property bool <strong id="empty">empty</strong>(); </dt>  <dt class="d_decl" id="MultiwayMerge.front">@property ref auto <strong id="front">front</strong>(); </dt>  <dt class="d_decl" id="MultiwayMerge.popFront">void <strong id="popFront">popFront</strong>(); </dt>  </dl> </dd> <dt class="d_decl" id="multiwayUnion">auto <strong id="multiwayUnion">multiwayUnion</strong>(alias less = "a &lt; b", RangeOfRanges)(RangeOfRanges ror); </dt> <dd>
<p>Computes the union of multiple ranges. The <a href="std_range_primitives.html#isInputRange">input ranges</a> are passed as a range of ranges and each is assumed to be sorted by <code>less</code>. Computation is done lazily, one union element at a time. <code>multiwayUnion(ror)</code> is functionally equivalent to <code>multiwayMerge(ror).uniq</code>. </p>
<p>"The output of multiwayUnion has no duplicates even when its inputs contain duplicates." </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>less</td> <td>Predicate the given ranges are sorted by.</td>
</tr> <tr>
<td>RangeOfRanges <code>ror</code>
</td> <td>A range of ranges sorted by <code>less</code> to compute the intersection for.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A range of the union of the ranges in <code>ror</code>.  See also: <a href="#multiwayMerge"><code>multiwayMerge</code></a>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;

// sets
double[][] a =
[
    [ 1, 4, 7, 8 ],
    [ 1, 7 ],
    [ 1, 7, 8],
    [ 4 ],
    [ 7 ],
];

auto witness = [1, 4, 7, 8];
assert(equal(multiwayUnion(a), witness));

// multisets
double[][] b =
[
    [ 1, 1, 1, 4, 7, 8 ],
    [ 1, 7 ],
    [ 1, 7, 7, 8],
    [ 4 ],
    [ 7 ],
];
assert(equal(multiwayUnion(b), witness));

double[][] c =
[
    [9, 8, 8, 8, 7, 6],
    [9, 8, 6],
    [9, 8, 5]
];
auto witness2 = [9, 8, 7, 6, 5];
assert(equal(multiwayUnion!"a &gt; b"(c), witness2));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="SetDifference">struct <strong id="SetDifference">SetDifference</strong>(alias less = "a &lt; b", R1, R2) if (isInputRange!R1 &amp;&amp; isInputRange!R2); <br><br>SetDifference!(less, R1, R2) <strong id="setDifference">setDifference</strong>(alias less = "a &lt; b", R1, R2)(R1 r1, R2 r2); </dt> <dd>
<p>Lazily computes the difference of <code>r1</code> and <code>r2</code>. The two ranges are assumed to be sorted by <code>less</code>. The element types of the two ranges must have a common type. </p>
<p>In the case of multisets, considering that element <code>a</code> appears <code>x</code> times in <code>r1</code> and <code>y</code> times and <code>r2</code>, the number of occurences of <code>a</code> in the resulting range is going to be <code>x-y</code> if x &gt; y or 0 otherwise. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>less</td> <td>Predicate the given ranges are sorted by.</td>
</tr> <tr>
<td>R1 <code>r1</code>
</td> <td>The first range.</td>
</tr> <tr>
<td>R2 <code>r2</code>
</td> <td>The range to subtract from <code>r1</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A range of the difference of <code>r1</code> and <code>r2</code>. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd><a href="#setSymmetricDifference"><code>setSymmetricDifference</code></a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.range.primitives : isForwardRange;

//sets
int[] a = [ 1, 2, 4, 5, 7, 9 ];
int[] b = [ 0, 1, 2, 4, 7, 8 ];
assert(equal(setDifference(a, b), [5, 9]));
static assert(isForwardRange!(typeof(setDifference(a, b))));

// multisets
int[] x = [1, 1, 1, 2, 3];
int[] y = [1, 1, 2, 4, 5];
auto r = setDifference(x, y);
assert(equal(r, [1, 3]));
assert(setDifference(r, x).empty);
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="SetDifference.this">this(R1 r1, R2 r2); </dt>  <dt class="d_decl" id="SetDifference.popFront">void <strong id="popFront">popFront</strong>(); </dt>  <dt class="d_decl" id="SetDifference.front">@property ref auto <strong id="front">front</strong>(); </dt>  <dt class="d_decl" id="SetDifference.save">@property typeof(this) <strong id="save">save</strong>(); </dt>  <dt class="d_decl" id="SetDifference.empty">@property bool <strong id="empty">empty</strong>(); </dt>  </dl> </dd> <dt class="d_decl" id="SetIntersection">struct <strong id="SetIntersection">SetIntersection</strong>(alias less = "a &lt; b", Rs...) if (Rs.length &gt;= 2 &amp;&amp; allSatisfy!(isInputRange, Rs) &amp;&amp; !is(CommonType!(staticMap!(ElementType, Rs)) == void)); <br><br>SetIntersection!(less, Rs) <strong id="setIntersection">setIntersection</strong>(alias less = "a &lt; b", Rs...)(Rs ranges)<br><small>  Constraints: if (Rs.length &gt;= 2 &amp;&amp; allSatisfy!(isInputRange, Rs) &amp;&amp; !is(CommonType!(staticMap!(ElementType, Rs)) == void)); </small>
</dt> <dd>
<p>Lazily computes the intersection of two or more <a href="std_range_primitives.html#isInputRange">input ranges</a> <code>ranges</code>. The ranges are assumed to be sorted by <code>less</code>. The element types of the ranges must have a common type. </p>
<p>In the case of multisets, the range with the minimum number of occurences of a given element, propagates the number of occurences of this element to the resulting range. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>less</td> <td>Predicate the given ranges are sorted by.</td>
</tr> <tr>
<td>Rs <code>ranges</code>
</td> <td>The ranges to compute the intersection for.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A range containing the intersection of the given ranges.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;

// sets
int[] a = [ 1, 2, 4, 5, 7, 9 ];
int[] b = [ 0, 1, 2, 4, 7, 8 ];
int[] c = [ 0, 1, 4, 5, 7, 8 ];
assert(equal(setIntersection(a, a), a));
assert(equal(setIntersection(a, b), [1, 2, 4, 7]));
assert(equal(setIntersection(a, b, c), [1, 4, 7]));

// multisets
int[] d = [ 1, 1, 2, 2, 7, 7 ];
int[] e = [ 1, 1, 1, 7];
assert(equal(setIntersection(a, d), [1, 2, 7]));
assert(equal(setIntersection(d, e), [1, 1, 7]));
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="SetIntersection.this">this(Rs input); </dt>  <dt class="d_decl" id="SetIntersection.empty">@property bool <strong id="empty">empty</strong>(); </dt>  <dt class="d_decl" id="SetIntersection.popFront">void <strong id="popFront">popFront</strong>(); </dt>  <dt class="d_decl" id="SetIntersection.front">@property ElementType <strong id="front">front</strong>(); </dt>  <dt class="d_decl" id="SetIntersection.save">@property SetIntersection <strong id="save">save</strong>(); </dt>  </dl> </dd> <dt class="d_decl" id="SetSymmetricDifference">struct <strong id="SetSymmetricDifference">SetSymmetricDifference</strong>(alias less = "a &lt; b", R1, R2) if (isInputRange!R1 &amp;&amp; isInputRange!R2); <br><br>SetSymmetricDifference!(less, R1, R2) <strong id="setSymmetricDifference">setSymmetricDifference</strong>(alias less = "a &lt; b", R1, R2)(R1 r1, R2 r2); </dt> <dd>
<p>Lazily computes the symmetric difference of <code>r1</code> and <code>r2</code>, i.e. the elements that are present in exactly one of <code>r1</code> and <code>r2</code>. The two ranges are assumed to be sorted by <code>less</code>, and the output is also sorted by <code>less</code>. The element types of the two ranges must have a common type. </p>
<p>If both ranges are sets (without duplicated elements), the resulting range is going to be a set. If at least one of the ranges is a multiset, the number of occurences of an element <code>x</code> in the resulting range is <code>abs(a-b)</code> where <code>a</code> is the number of occurences of <code>x</code> in <code>r1</code>, <code>b</code> is the number of occurences of <code>x</code> in <code>r2</code>, and <code>abs</code> is the absolute value. <br><br> If both arguments are ranges of L-values of the same type then <code>SetSymmetricDifference</code> will also be a range of L-values of that type. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>less</td> <td>Predicate the given ranges are sorted by.</td>
</tr> <tr>
<td>R1 <code>r1</code>
</td> <td>The first range.</td>
</tr> <tr>
<td>R2 <code>r2</code>
</td> <td>The second range.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A range of the symmetric difference between <code>r1</code> and <code>r2</code>. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd><a href="#setDifference"><code>setDifference</code></a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.range.primitives : isForwardRange;

// sets
int[] a = [ 1, 2, 4, 5, 7, 9 ];
int[] b = [ 0, 1, 2, 4, 7, 8 ];
assert(equal(setSymmetricDifference(a, b), [0, 5, 8, 9][]));
static assert(isForwardRange!(typeof(setSymmetricDifference(a, b))));

//mutisets
int[] c = [1, 1, 1, 1, 2, 2, 2, 4, 5, 6];
int[] d = [1, 1, 2, 2, 2, 2, 4, 7, 9];
assert(equal(setSymmetricDifference(c, d), setSymmetricDifference(d, c)));
assert(equal(setSymmetricDifference(c, d), [1, 1, 2, 5, 6, 7, 9]));
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="SetSymmetricDifference.this">this(R1 r1, R2 r2); </dt>  <dt class="d_decl" id="SetSymmetricDifference.popFront">void <strong id="popFront">popFront</strong>(); </dt>  <dt class="d_decl" id="SetSymmetricDifference.front">@property ref auto <strong id="front">front</strong>(); </dt>  <dt class="d_decl" id="SetSymmetricDifference.save">@property typeof(this) <strong id="save">save</strong>(); </dt>  <dt class="d_decl" id="SetSymmetricDifference.opSlice">ref auto <strong id="opSlice">opSlice</strong>(); </dt>  <dt class="d_decl" id="SetSymmetricDifference.empty">@property bool <strong id="empty">empty</strong>(); </dt>  </dl> </dd> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1999&ndash;2021 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/std_algorithm_setops.html" class="_attribution-link">https://dlang.org/phobos/std_algorithm_setops.html</a>
  </p>
</div>
