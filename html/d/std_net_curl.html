<h1>std.net.curl</h1>  <p>Networking client functionality as provided by <a href="http://curl.haxx.se/libcurl">libcurl</a>. The libcurl library must be installed on the system in order to use this module. </p>
<table>

<tr>
<th scope="col">Category</th> <th scope="col">Functions</th> </tr> <tr>
<td>High level</td> <td>
<a href="#download"><em class="tt">download</em></a> <a href="#upload"><em class="tt">upload</em></a> <a href="#get"><em class="tt">get</em></a> <a href="#post"><em class="tt">post</em></a> <a href="#put"><em class="tt">put</em></a> <a href="#del"><em class="tt">del</em></a> <a href="#options"><em class="tt">options</em></a> <a href="#trace"><em class="tt">trace</em></a> <a href="#connect"><em class="tt">connect</em></a> <a href="#byLine"><em class="tt">byLine</em></a> <a href="#byChunk"><em class="tt">byChunk</em></a> <a href="#byLineAsync"><em class="tt">byLineAsync</em></a> <a href="#byChunkAsync"><em class="tt">byChunkAsync</em></a> </td> </tr> <tr>
<td>Low level</td> <td>
<a href="#HTTP"><em class="tt">HTTP</em></a> <a href="#FTP"><em class="tt">FTP</em></a> <a href="#SMTP"><em class="tt">SMTP</em></a> </td> </tr> </table>  <dl>
<dt>Note</dt>
<dd> You may need to link to the <b>curl</b> library, e.g. by adding <code>"libs": ["curl"]</code> to your <b>dub.json</b> file if you are using <a href="http://code.dlang.org">DUB</a>. </dd>
</dl> Windows x86 note: A DMD compatible libcurl static library can be downloaded from the dlang.org <a href="http://downloads.dlang.org/other/index.html">download archive page</a>.  This module is not available for iOS, tvOS or watchOS.  Compared to using libcurl directly this module allows simpler client code for common uses, requires no unsafe operations, and integrates better with the rest of the language. Futhermore it provides <a href="std_range.html">range</a> access to protocols supported by libcurl both synchronously and asynchronously.  A high level and a low level API are available. The high level API is built entirely on top of the low level one.  The high level API is for commonly used functionality such as HTTP/FTP get. The <a href="#byLineAsync"><code>byLineAsync</code></a> and <a href="#byChunkAsync"><code>byChunkAsync</code></a> provides asynchronous <a href="std_range.html">range</a> that performs the request in another thread while handling a line/chunk in the current thread.  The low level API allows for streaming and other advanced features.  <table>
<caption>Cheat Sheet</caption>
<tr>
<th scope="col">Function Name</th> <th scope="col">Description</th> </tr> <tr><td colspan="2"><em> High level</em></td></tr> <tr>
<td><a href="#download"><code>download</code></a></td> <td>
<code>download("ftp.digitalmars.com/sieve.ds", "/tmp/downloaded-ftp-file")</code> downloads file from URL to file system.</td> </tr> <tr>
<td><a href="#upload"><code>upload</code></a></td> <td>
<code>upload("/tmp/downloaded-ftp-file", "ftp.digitalmars.com/sieve.ds");</code> uploads file from file system to URL.</td> </tr> <tr>
<td><a href="#get"><code>get</code></a></td> <td>
<code>get("dlang.org")</code> returns a char[] containing the dlang.org web page.</td> </tr> <tr>
<td><a href="#put"><code>put</code></a></td> <td>
<code>put("dlang.org", "Hi")</code> returns a char[] containing the dlang.org web page. after a HTTP PUT of "hi"</td> </tr> <tr>
<td><a href="#post"><code>post</code></a></td> <td>
<code>post("dlang.org", "Hi")</code> returns a char[] containing the dlang.org web page. after a HTTP POST of "hi"</td> </tr> <tr>
<td><a href="#byLine"><code>byLine</code></a></td> <td>
<code>byLine("dlang.org")</code> returns a range of char[] containing the dlang.org web page.</td> </tr> <tr>
<td><a href="#byChunk"><code>byChunk</code></a></td> <td>
<code>byChunk("dlang.org", 10)</code> returns a range of ubyte[10] containing the dlang.org web page.</td> </tr> <tr>
<td><a href="#byLineAsync"><code>byLineAsync</code></a></td> <td>
<code>byLineAsync("dlang.org")</code> returns a range of char[] containing the dlang.org web page asynchronously.</td> </tr> <tr>
<td><a href="#byChunkAsync"><code>byChunkAsync</code></a></td> <td>
<code>byChunkAsync("dlang.org", 10)</code> returns a range of ubyte[10] containing the dlang.org web page asynchronously.</td> </tr> <tr><td colspan="2"><em> Low level </em></td></tr> <tr>
<td><a href="#HTTP"><code>HTTP</code></a></td> <td>
<code>HTTP</code> struct for advanced usage</td>
</tr> <tr>
<td><a href="#FTP"><code>FTP</code></a></td> <td>
<code>FTP</code> struct for advanced usage</td>
</tr> <tr>
<td><a href="#SMTP"><code>SMTP</code></a></td> <td>
<code>SMTP</code> struct for advanced usage</td>
</tr> </table>   <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">import std.net.curl, std.stdio;

// Return a char[] containing the content specified by a URL
auto content = get("dlang.org");

// Post data and return a char[] containing the content specified by a URL
auto content = post("mydomain.com/here.cgi", ["name1" : "value1", "name2" : "value2"]);

// Get content of file from ftp server
auto content = get("ftp.digitalmars.com/sieve.ds");

// Post and print out content line by line. The request is done in another thread.
foreach (line; byLineAsync("dlang.org", "Post data"))
    writeln(line);

// Get using a line range and proxy settings
auto client = HTTP();
client.proxy = "1.2.3.4";
foreach (line; byLine("dlang.org", client))
    writeln(line);
</pre>  For more control than the high level functions provide, use the low level API:  <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">import std.net.curl, std.stdio;

// GET with custom data receivers
auto http = HTTP("dlang.org");
http.onReceiveHeader =
    (in char[] key, in char[] value) { writeln(key, ": ", value); };
http.onReceive = (ubyte[] data) { /+ drop +/ return data.length; };
http.perform();
</pre>  First, an instance of the reference-counted HTTP struct is created. Then the custom delegates are set. These will be called whenever the HTTP instance receives a header and a data buffer, respectively. In this simple example, the headers are written to stdout and the data is ignored. If the request should be stopped before it has finished then return something less than data.length from the onReceive callback. See <a href="#onReceiveHeader"><code>onReceiveHeader</code></a>/<a href="#onReceive"><code>onReceive</code></a> for more information. Finally the HTTP request is effected by calling perform(), which is synchronous.  <dl>
<dt>Source</dt>
<dd> <span class="phobos_src"><a class="https" href="https://github.com/dlang/phobos/blob/master/std/net/curl.d">std/net/curl.d</a></span> </dd>
</dl> <dl>
<dt>License:</dt>
<dd>
<a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>. </dd>
</dl> <dl>
<dt>Authors:</dt>
<dd>Jonas Drewsen. Some of the SMTP code contributed by Jimmy Cao. </dd>
</dl> <dl>
<dt>Credits</dt>
<dd> The functionally is based on <a href="http://curl.haxx.se/libcurl">libcurl</a>. LibCurl is licensed under an MIT/X derivative license.</dd>
</dl> <dl>
<dt class="d_decl" id="AutoProtocol">struct <strong id="AutoProtocol">AutoProtocol</strong>; </dt> <dd>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">import std.net.curl;
// Two requests below will do the same.
char[] content;

// Explicit connection provided
content = get!HTTP("dlang.org");

// Guess connection type by looking at the URL
content = get!AutoProtocol("ftp://foo.com/file");
// and since AutoProtocol is default this is the same as
content = get("ftp://foo.com/file");
// and will end up detecting FTP from the url and be the same as
content = get!FTP("ftp://foo.com/file");
</pre>  </dd> <dt class="d_decl" id="download">void <strong id="download">download</strong>(Conn = AutoProtocol)(const(char)[] url, string saveToPath, Conn conn = Conn())<br><small>  Constraints: if (isCurlConn!Conn); </small>
</dt> <dd>
<p>HTTP/FTP download to local file system. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(char)[] <code>url</code>
</td> <td>resource to download</td>
</tr> <tr>
<td>string <code>saveToPath</code>
</td> <td>path to store the downloaded content on local disk</td>
</tr> <tr>
<td>Conn <code>conn</code>
</td> <td>connection to use e.g. FTP or HTTP. The default AutoProtocol will guess connection type and create a new instance for this call only.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">import std.net.curl;
download("https://httpbin.org/get", "/tmp/downloaded-http-file");
</pre>  </dd> <dt class="d_decl" id="upload">void <strong id="upload">upload</strong>(Conn = AutoProtocol)(string loadFromPath, const(char)[] url, Conn conn = Conn())<br><small>  Constraints: if (isCurlConn!Conn); </small>
</dt> <dd>
<p>Upload file from local files system using the HTTP or FTP protocol. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>string <code>loadFromPath</code>
</td> <td>path load data from local disk.</td>
</tr> <tr>
<td>const(char)[] <code>url</code>
</td> <td>resource to upload to</td>
</tr> <tr>
<td>Conn <code>conn</code>
</td> <td>connection to use e.g. FTP or HTTP. The default AutoProtocol will guess connection type and create a new instance for this call only.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">import std.net.curl;
upload("/tmp/downloaded-ftp-file", "ftp.digitalmars.com/sieve.ds");
upload("/tmp/downloaded-http-file", "https://httpbin.org/post");
</pre>  </dd> <dt class="d_decl" id="get">T[] <strong id="get">get</strong>(Conn = AutoProtocol, T = char)(const(char)[] url, Conn conn = Conn())<br><small>  Constraints: if (isCurlConn!Conn &amp;&amp; (is(T == char) || is(T == ubyte))); </small>
</dt> <dd>
<p>HTTP/FTP get content. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(char)[] <code>url</code>
</td> <td>resource to get</td>
</tr> <tr>
<td>Conn <code>conn</code>
</td> <td>connection to use e.g. FTP or HTTP. The default AutoProtocol will guess connection type and create a new instance for this call only.  The template parameter <code>T</code> specifies the type to return. Possible values are <code>char</code> and <code>ubyte</code> to return <code>char[]</code> or <code>ubyte[]</code>. If asking for <code>char</code>, content will be converted from the connection character set (specified in HTTP response headers or FTP connection properties, both ISO-8859-1 by default) to UTF-8.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">import std.net.curl;
auto content = get("https://httpbin.org/get");
</pre>  <dl>
<dt>Returns:</dt>
<dd>A T[] range containing the content of the resource pointed to by the URL. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<code>CurlException</code> on error. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd><a href="#HTTP.Method"><code>HTTP.Method</code></a></dd>
</dl> </dd> <dt class="d_decl" id="post">T[] <strong id="post">post</strong>(T = char, PostUnit)(const(char)[] url, const(PostUnit)[] postData, HTTP conn = HTTP())<br><small>  Constraints: if (is(T == char) || is(T == ubyte)); </small><br><br>T[] <strong id="post">post</strong>(T = char)(const(char)[] url, string[string] postDict, HTTP conn = HTTP())<br><small>  Constraints: if (is(T == char) || is(T == ubyte)); </small>
</dt> <dd>
<p>HTTP post content. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(char)[] <code>url</code>
</td> <td>resource to post to</td>
</tr> <tr>
<td>string[string] <code>postDict</code>
</td> <td>data to send as the body of the request. An associative array of <code>string</code> is accepted and will be encoded using www-form-urlencoding</td>
</tr> <tr>
<td>const(PostUnit)[] <code>postData</code>
</td> <td>data to send as the body of the request. An array of an arbitrary type is accepted and will be cast to ubyte[] before sending it.</td>
</tr> <tr>
<td>HTTP <code>conn</code>
</td> <td>HTTP connection to use</td>
</tr> <tr>
<td>T</td> <td>The template parameter <code>T</code> specifies the type to return. Possible values are <code>char</code> and <code>ubyte</code> to return <code>char[]</code> or <code>ubyte[]</code>. If asking for <code>char</code>, content will be converted from the connection character set (specified in HTTP response headers or FTP connection properties, both ISO-8859-1 by default) to UTF-8.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.net.curl;

auto content1 = post("https://httpbin.org/post", ["name1" : "value1", "name2" : "value2"]);
auto content2 = post("https://httpbin.org/post", [1,2,3,4]);
</pre> </dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A T[] range containing the content of the resource pointed to by the URL. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd><a href="#HTTP.Method"><code>HTTP.Method</code></a></dd>
</dl> </dd> <dt class="d_decl" id="put">T[] <strong id="put">put</strong>(Conn = AutoProtocol, T = char, PutUnit)(const(char)[] url, const(PutUnit)[] putData, Conn conn = Conn())<br><small>  Constraints: if (isCurlConn!Conn &amp;&amp; (is(T == char) || is(T == ubyte))); </small>
</dt> <dd>
<p>HTTP/FTP put content. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(char)[] <code>url</code>
</td> <td>resource to put</td>
</tr> <tr>
<td>const(PutUnit)[] <code>putData</code>
</td> <td>data to send as the body of the request. An array of an arbitrary type is accepted and will be cast to ubyte[] before sending it.</td>
</tr> <tr>
<td>Conn <code>conn</code>
</td> <td>connection to use e.g. FTP or HTTP. The default AutoProtocol will guess connection type and create a new instance for this call only.  The template parameter <code>T</code> specifies the type to return. Possible values are <code>char</code> and <code>ubyte</code> to return <code>char[]</code> or <code>ubyte[]</code>. If asking for <code>char</code>, content will be converted from the connection character set (specified in HTTP response headers or FTP connection properties, both ISO-8859-1 by default) to UTF-8.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">import std.net.curl;
auto content = put("https://httpbin.org/put",
                     "Putting this data");
</pre>  <dl>
<dt>Returns:</dt>
<dd>A T[] range containing the content of the resource pointed to by the URL. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd><a href="#HTTP.Method"><code>HTTP.Method</code></a></dd>
</dl> </dd> <dt class="d_decl" id="del">void <strong id="del">del</strong>(Conn = AutoProtocol)(const(char)[] url, Conn conn = Conn())<br><small>  Constraints: if (isCurlConn!Conn); </small>
</dt> <dd>
<p>HTTP/FTP delete content. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(char)[] <code>url</code>
</td> <td>resource to delete</td>
</tr> <tr>
<td>Conn <code>conn</code>
</td> <td>connection to use e.g. FTP or HTTP. The default AutoProtocol will guess connection type and create a new instance for this call only.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">import std.net.curl;
del("https://httpbin.org/delete");
</pre>  <dl>
<dt>See Also:</dt>
<dd><a href="#HTTP.Method"><code>HTTP.Method</code></a></dd>
</dl> </dd> <dt class="d_decl" id="options">T[] <strong id="options">options</strong>(T = char)(const(char)[] url, HTTP conn = HTTP())<br><small>  Constraints: if (is(T == char) || is(T == ubyte)); </small>
</dt> <dd>
<p>HTTP options request. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(char)[] <code>url</code>
</td> <td>resource make a option call to</td>
</tr> <tr>
<td>HTTP <code>conn</code>
</td> <td>connection to use e.g. FTP or HTTP. The default AutoProtocol will guess connection type and create a new instance for this call only.  The template parameter <code>T</code> specifies the type to return. Possible values are <code>char</code> and <code>ubyte</code> to return <code>char[]</code> or <code>ubyte[]</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">import std.net.curl;
auto http = HTTP();
options("https://httpbin.org/headers", http);
writeln("Allow set to " ~ http.responseHeaders["Allow"]);
</pre>  <dl>
<dt>Returns:</dt>
<dd>A T[] range containing the options of the resource pointed to by the URL. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd><a href="#HTTP.Method"><code>HTTP.Method</code></a></dd>
</dl> </dd> <dt class="d_decl" id="trace">T[] <strong id="trace">trace</strong>(T = char)(const(char)[] url, HTTP conn = HTTP())<br><small>  Constraints: if (is(T == char) || is(T == ubyte)); </small>
</dt> <dd>
<p>HTTP trace request. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(char)[] <code>url</code>
</td> <td>resource make a trace call to</td>
</tr> <tr>
<td>HTTP <code>conn</code>
</td> <td>connection to use e.g. FTP or HTTP. The default AutoProtocol will guess connection type and create a new instance for this call only.  The template parameter <code>T</code> specifies the type to return. Possible values are <code>char</code> and <code>ubyte</code> to return <code>char[]</code> or <code>ubyte[]</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">import std.net.curl;
trace("https://httpbin.org/headers");
</pre>  <dl>
<dt>Returns:</dt>
<dd>A T[] range containing the trace info of the resource pointed to by the URL. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd><a href="#HTTP.Method"><code>HTTP.Method</code></a></dd>
</dl> </dd> <dt class="d_decl" id="connect">T[] <strong id="connect">connect</strong>(T = char)(const(char)[] url, HTTP conn = HTTP())<br><small>  Constraints: if (is(T == char) || is(T == ubyte)); </small>
</dt> <dd>
<p>HTTP connect request. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(char)[] <code>url</code>
</td> <td>resource make a connect to</td>
</tr> <tr>
<td>HTTP <code>conn</code>
</td> <td>HTTP connection to use  The template parameter <code>T</code> specifies the type to return. Possible values are <code>char</code> and <code>ubyte</code> to return <code>char[]</code> or <code>ubyte[]</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">import std.net.curl;
connect("https://httpbin.org/headers");
</pre>  <dl>
<dt>Returns:</dt>
<dd>A T[] range containing the connect info of the resource pointed to by the URL. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd><a href="#HTTP.Method"><code>HTTP.Method</code></a></dd>
</dl> </dd> <dt class="d_decl" id="patch">T[] <strong id="patch">patch</strong>(T = char, PatchUnit)(const(char)[] url, const(PatchUnit)[] patchData, HTTP conn = HTTP())<br><small>  Constraints: if (is(T == char) || is(T == ubyte)); </small>
</dt> <dd>
<p>HTTP patch content. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(char)[] <code>url</code>
</td> <td>resource to patch</td>
</tr> <tr>
<td>const(PatchUnit)[] <code>patchData</code>
</td> <td>data to send as the body of the request. An array of an arbitrary type is accepted and will be cast to ubyte[] before sending it.</td>
</tr> <tr>
<td>HTTP <code>conn</code>
</td> <td>HTTP connection to use  The template parameter <code>T</code> specifies the type to return. Possible values are <code>char</code> and <code>ubyte</code> to return <code>char[]</code> or <code>ubyte[]</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto http = HTTP();
http.addRequestHeader("Content-Type", "application/json");
auto content = patch("https://httpbin.org/patch", `{"title": "Patched Title"}`, http);
</pre>  <dl>
<dt>Returns:</dt>
<dd>A T[] range containing the content of the resource pointed to by the URL. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd><a href="#HTTP.Method"><code>HTTP.Method</code></a></dd>
</dl> </dd> <dt class="d_decl" id="byLine">auto <strong id="byLine">byLine</strong>(Conn = AutoProtocol, Terminator = char, Char = char)(const(char)[] url, KeepTerminator keepTerminator = No.keepTerminator, Terminator terminator = '\x0a', Conn conn = Conn())<br><small>  Constraints: if (isCurlConn!Conn &amp;&amp; isSomeChar!Char &amp;&amp; isSomeChar!Terminator); </small>
</dt> <dd>
<p>HTTP/FTP fetch content as a range of lines. </p>
<p>A range of lines is returned when the request is complete. If the method or other request properties is to be customized then set the <code>conn</code> parameter with a HTTP/FTP instance that has these properties set. </p> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">import std.net.curl, std.stdio;
foreach (line; byLine("dlang.org"))
    writeln(line);
</pre>  <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(char)[] <code>url</code>
</td> <td>The url to receive content from</td>
</tr> <tr>
<td>KeepTerminator <code>keepTerminator</code>
</td> <td>
<code>Yes.keepTerminator</code> signals that the line terminator should be returned as part of the lines in the range.</td>
</tr> <tr>
<td>Terminator <code>terminator</code>
</td> <td>The character that terminates a line</td>
</tr> <tr>
<td>Conn <code>conn</code>
</td> <td>The connection to use e.g. HTTP or FTP.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A range of Char[] with the content of the resource pointer to by the URL</dd>
</dl> </dd> <dt class="d_decl" id="byChunk">auto <strong id="byChunk">byChunk</strong>(Conn = AutoProtocol)(const(char)[] url, size_t chunkSize = 1024, Conn conn = Conn())<br><small>  Constraints: if (isCurlConn!Conn); </small>
</dt> <dd>
<p>HTTP/FTP fetch content as a range of chunks. </p>
<p>A range of chunks is returned when the request is complete. If the method or other request properties is to be customized then set the <code>conn</code> parameter with a HTTP/FTP instance that has these properties set. </p> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">import std.net.curl, std.stdio;
foreach (chunk; byChunk("dlang.org", 100))
    writeln(chunk); // chunk is ubyte[100]
</pre>  <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(char)[] <code>url</code>
</td> <td>The url to receive content from</td>
</tr> <tr>
<td>size_t <code>chunkSize</code>
</td> <td>The size of each chunk</td>
</tr> <tr>
<td>Conn <code>conn</code>
</td> <td>The connection to use e.g. HTTP or FTP.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A range of ubyte[chunkSize] with the content of the resource pointer to by the URL</dd>
</dl> </dd> <dt class="d_decl" id="byLineAsync">auto <strong id="byLineAsync">byLineAsync</strong>(Conn = AutoProtocol, Terminator = char, Char = char, PostUnit)(const(char)[] url, const(PostUnit)[] postData, KeepTerminator keepTerminator = No.keepTerminator, Terminator terminator = '\x0a', size_t transmitBuffers = 10, Conn conn = Conn())<br><small>  Constraints: if (isCurlConn!Conn &amp;&amp; isSomeChar!Char &amp;&amp; isSomeChar!Terminator); </small><br><br>auto <strong id="byLineAsync">byLineAsync</strong>(Conn = AutoProtocol, Terminator = char, Char = char)(const(char)[] url, KeepTerminator keepTerminator = No.keepTerminator, Terminator terminator = '\x0a', size_t transmitBuffers = 10, Conn conn = Conn()); </dt> <dd>
<p>HTTP/FTP fetch content as a range of lines asynchronously. </p>
<p>A range of lines is returned immediately and the request that fetches the lines is performed in another thread. If the method or other request properties is to be customized then set the <code>conn</code> parameter with a HTTP/FTP instance that has these properties set. <br><br> If <code>postData</code> is non-null the method will be set to <code>post</code> for HTTP requests. <br><br> The background thread will buffer up to transmitBuffers number of lines before it stops receiving data from network. When the main thread reads the lines from the range it frees up buffers and allows for the background thread to receive more data from the network. <br><br> If no data is available and the main thread accesses the range it will block until data becomes available. An exception to this is the <code>wait(Duration)</code> method on the <a href="#LineInputRange"><code>LineInputRange</code></a>. This method will wait at maximum for the specified duration and return true if data is available. </p> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">import std.net.curl, std.stdio;
// Get some pages in the background
auto range1 = byLineAsync("www.google.com");
auto range2 = byLineAsync("www.wikipedia.org");
foreach (line; byLineAsync("dlang.org"))
    writeln(line);

// Lines already fetched in the background and ready
foreach (line; range1) writeln(line);
foreach (line; range2) writeln(line);
</pre>  <pre data-language="d">import std.net.curl, std.stdio;
// Get a line in a background thread and wait in
// main thread for 2 seconds for it to arrive.
auto range3 = byLineAsync("dlang.com");
if (range3.wait(dur!"seconds"(2)))
    writeln(range3.front);
else
    writeln("No line received after 2 seconds!");
</pre>  <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(char)[] <code>url</code>
</td> <td>The url to receive content from</td>
</tr> <tr>
<td>const(PostUnit)[] <code>postData</code>
</td> <td>Data to HTTP Post</td>
</tr> <tr>
<td>KeepTerminator <code>keepTerminator</code>
</td> <td>
<code>Yes.keepTerminator</code> signals that the line terminator should be returned as part of the lines in the range.</td>
</tr> <tr>
<td>Terminator <code>terminator</code>
</td> <td>The character that terminates a line</td>
</tr> <tr>
<td>size_t <code>transmitBuffers</code>
</td> <td>The number of lines buffered asynchronously</td>
</tr> <tr>
<td>Conn <code>conn</code>
</td> <td>The connection to use e.g. HTTP or FTP.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A range of Char[] with the content of the resource pointer to by the URL.</dd>
</dl> </dd> <dt class="d_decl" id="byChunkAsync">auto <strong id="byChunkAsync">byChunkAsync</strong>(Conn = AutoProtocol, PostUnit)(const(char)[] url, const(PostUnit)[] postData, size_t chunkSize = 1024, size_t transmitBuffers = 10, Conn conn = Conn())<br><small>  Constraints: if (isCurlConn!Conn); </small><br><br>auto <strong id="byChunkAsync">byChunkAsync</strong>(Conn = AutoProtocol)(const(char)[] url, size_t chunkSize = 1024, size_t transmitBuffers = 10, Conn conn = Conn())<br><small>  Constraints: if (isCurlConn!Conn); </small>
</dt> <dd>
<p>HTTP/FTP fetch content as a range of chunks asynchronously. </p>
<p>A range of chunks is returned immediately and the request that fetches the chunks is performed in another thread. If the method or other request properties is to be customized then set the <code>conn</code> parameter with a HTTP/FTP instance that has these properties set. <br><br> If <code>postData</code> is non-null the method will be set to <code>post</code> for HTTP requests. <br><br> The background thread will buffer up to transmitBuffers number of chunks before is stops receiving data from network. When the main thread reads the chunks from the range it frees up buffers and allows for the background thread to receive more data from the network. <br><br> If no data is available and the main thread access the range it will block until data becomes available. An exception to this is the <code>wait(Duration)</code> method on the <a href="#ChunkInputRange"><code>ChunkInputRange</code></a>. This method will wait at maximum for the specified duration and return true if data is available. </p> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">import std.net.curl, std.stdio;
// Get some pages in the background
auto range1 = byChunkAsync("www.google.com", 100);
auto range2 = byChunkAsync("www.wikipedia.org");
foreach (chunk; byChunkAsync("dlang.org"))
    writeln(chunk); // chunk is ubyte[100]

// Chunks already fetched in the background and ready
foreach (chunk; range1) writeln(chunk);
foreach (chunk; range2) writeln(chunk);
</pre>  <pre data-language="d">import std.net.curl, std.stdio;
// Get a line in a background thread and wait in
// main thread for 2 seconds for it to arrive.
auto range3 = byChunkAsync("dlang.com", 10);
if (range3.wait(dur!"seconds"(2)))
    writeln(range3.front);
else
    writeln("No chunk received after 2 seconds!");
</pre>  <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(char)[] <code>url</code>
</td> <td>The url to receive content from</td>
</tr> <tr>
<td>const(PostUnit)[] <code>postData</code>
</td> <td>Data to HTTP Post</td>
</tr> <tr>
<td>size_t <code>chunkSize</code>
</td> <td>The size of the chunks</td>
</tr> <tr>
<td>size_t <code>transmitBuffers</code>
</td> <td>The number of chunks buffered asynchronously</td>
</tr> <tr>
<td>Conn <code>conn</code>
</td> <td>The connection to use e.g. HTTP or FTP.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A range of ubyte[chunkSize] with the content of the resource pointer to by the URL.</dd>
</dl> </dd> <dt class="d_decl" id="HTTP">struct <strong id="HTTP">HTTP</strong>; </dt> <dd>
<p>HTTP client functionality. </p>
<dl>
<dt>Example</dt>
<dd> Get with custom data receivers: </dd>
</dl> <pre data-language="d">import std.net.curl, std.stdio;

auto http = HTTP("https://dlang.org");
http.onReceiveHeader =
    (in char[] key, in char[] value) { writeln(key ~ ": " ~ value); };
http.onReceive = (ubyte[] data) { /+ drop +/ return data.length; };
http.perform();
</pre>   Put with data senders:  <pre data-language="d">import std.net.curl, std.stdio;

auto http = HTTP("https://dlang.org");
auto msg = "Hello world";
http.contentLength = msg.length;
http.onSend = (void[] data)
{
    auto m = cast(void[]) msg;
    size_t len = m.length &gt; data.length ? data.length : m.length;
    if (len == 0) return len;
    data[0 .. len] = m[0 .. len];
    msg = msg[len..$];
    return len;
};
http.perform();
</pre>   Tracking progress:  <pre data-language="d">import std.net.curl, std.stdio;

auto http = HTTP();
http.method = HTTP.Method.get;
http.url = "http://upload.wikimedia.org/wikipedia/commons/" ~
           "5/53/Wikipedia-logo-en-big.png";
http.onReceive = (ubyte[] data) { return data.length; };
http.onProgress = (size_t dltotal, size_t dlnow,
                   size_t ultotal, size_t ulnow)
{
    writeln("Progress ", dltotal, ", ", dlnow, ", ", ultotal, ", ", ulnow);
    return 0;
};
http.perform();
</pre>  <dl>
<dt>See Also:</dt>
<dd><a href="http://www.ietf.org/rfc/rfc2616.txt">RFC2616</a></dd>
</dl> <dl>
<dt class="d_decl" id="HTTP.AuthMethod">alias <strong id="AuthMethod">AuthMethod</strong> = etc.c.curl.CurlAuth; </dt> <dd>
<p>Authentication method equal to <a href="etc_c_curl.html#CurlAuth"><code>etc.c.curl.CurlAuth</code></a></p> </dd> <dt class="d_decl" id="HTTP.TimeCond">alias <strong id="TimeCond">TimeCond</strong> = etc.c.curl.CurlTimeCond; </dt> <dd>
<p>Time condition enumeration as an alias of <a href="etc_c_curl.html#CurlTimeCond"><code>etc.c.curl.CurlTimeCond</code></a> </p>
<p><a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.25">RFC2616 Section 14.25</a></p> </dd> <dt class="d_decl" id="HTTP.opCall">static HTTP <strong id="opCall">opCall</strong>(const(char)[] url); </dt> <dd>
<p>Constructor taking the url as parameter.</p> </dd> <dt class="d_decl" id="HTTP.opCall.2">static HTTP <strong id="opCall">opCall</strong>(); </dt>  <dt class="d_decl" id="HTTP.dup">HTTP <strong id="dup">dup</strong>(); </dt>  <dt class="d_decl" id="HTTP.perform">CurlCode <strong id="perform">perform</strong>(ThrowOnError throwOnError = Yes.throwOnError); </dt> <dd>
<p>Perform a http request. </p>
<p>After the HTTP client has been setup and possibly assigned callbacks the <code>perform()</code> method will start performing the request towards the specified server. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>ThrowOnError <code>throwOnError</code>
</td> <td>whether to throw an exception or return a CurlCode on error</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="HTTP.url">@property void <strong id="url">url</strong>(const(char)[] <strong id="url">url</strong>); </dt> <dd>
<p>The URL to specify the location of the resource.</p> </dd> <dt class="d_decl" id="HTTP.caInfo">@property void <strong id="caInfo">caInfo</strong>(const(char)[] caFile); </dt> <dd>
<p>Set the CA certificate bundle file to use for SSL peer verification</p> </dd> <dt class="d_decl" id="HTTP.requestPause">alias <strong id="requestPause">requestPause</strong> = etc.c.curl.CurlReadFunc.pause; </dt> <dd>
<p>Value to return from <code>onSend</code>/<code>onReceive</code> delegates in order to pause a request</p> </dd> <dt class="d_decl" id="HTTP.requestAbort">alias <strong id="requestAbort">requestAbort</strong> = etc.c.curl.CurlReadFunc.abort; </dt> <dd>
<p>Value to return from onSend delegate in order to abort a request</p> </dd> <dt class="d_decl" id="HTTP.isStopped">@property bool <strong id="isStopped">isStopped</strong>(); </dt> <dd>
<p>True if the instance is stopped. A stopped instance is not usable.</p> </dd> <dt class="d_decl" id="HTTP.shutdown">void <strong id="shutdown">shutdown</strong>(); </dt> <dd>
<p>Stop and invalidate this instance.</p> </dd> <dt class="d_decl" id="HTTP.verbose">@property void <strong id="verbose">verbose</strong>(bool on); </dt> <dd>
<p>Set verbose. This will print request information to stderr.</p> </dd> <dt class="d_decl" id="HTTP.dataTimeout">@property void <strong id="dataTimeout">dataTimeout</strong>(Duration d); </dt> <dd>
<p>Set timeout for activity on connection.</p> </dd> <dt class="d_decl" id="HTTP.operationTimeout">@property void <strong id="operationTimeout">operationTimeout</strong>(Duration d); </dt> <dd>
<p>Set maximum time an operation is allowed to take. This includes dns resolution, connecting, data transfer, etc.</p> </dd> <dt class="d_decl" id="HTTP.connectTimeout">@property void <strong id="connectTimeout">connectTimeout</strong>(Duration d); </dt> <dd>
<p>Set timeout for connecting.</p> </dd> <dt class="d_decl" id="HTTP.proxy">@property void <strong id="proxy">proxy</strong>(const(char)[] host); </dt> <dd>
<p>Proxy </p>
<dl>
<dt>See</dt>
<dd> <a href="http://curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTPROXY">proxy</a>
</dd>
</dl> </dd> <dt class="d_decl" id="HTTP.proxyPort">@property void <strong id="proxyPort">proxyPort</strong>(ushort port); </dt> <dd>
<p>Proxy port </p>
<dl>
<dt>See</dt>
<dd> <a href="http://curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTPROXYPORT">proxy_port</a>
</dd>
</dl> </dd> <dt class="d_decl" id="HTTP.CurlProxy">alias <strong id="CurlProxy">CurlProxy</strong> = etc.c.curl.<strong id="CurlProxy">CurlProxy</strong>; </dt> <dd>
<p>Type of proxy</p> </dd> <dt class="d_decl" id="HTTP.proxyType">@property void <strong id="proxyType">proxyType</strong>(CurlProxy type); </dt> <dd>
<p>Proxy type </p>
<dl>
<dt>See</dt>
<dd> <a href="http://curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTPROXY">proxy_type</a>
</dd>
</dl> </dd> <dt class="d_decl" id="HTTP.dnsTimeout">@property void <strong id="dnsTimeout">dnsTimeout</strong>(Duration d); </dt> <dd>
<p>DNS lookup timeout.</p> </dd> <dt class="d_decl" id="HTTP.netInterface">@property void <strong id="netInterface">netInterface</strong>(const(char)[] i); <br><br>@property void <strong id="netInterface">netInterface</strong>(const(ubyte)[4] i); <br><br>@property void <strong id="netInterface">netInterface</strong>(InternetAddress i); </dt> <dd>
<p>The network interface to use in form of the the IP of the interface. </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">theprotocol.netInterface = "192.168.1.32";
theprotocol.netInterface = [ 192, 168, 1, 32 ];
</pre>  <dl>
<dt>See</dt>
<dd> <a href="std_socket.html#InternetAddress"><code>std.socket.InternetAddress</code></a>
</dd>
</dl> </dd> <dt class="d_decl" id="HTTP.localPort">@property void <strong id="localPort">localPort</strong>(ushort port); </dt> <dd>
<p>Set the local outgoing port to use. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>ushort <code>port</code>
</td> <td>the first outgoing port number to try and use</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="HTTP.localPortRange">@property void <strong id="localPortRange">localPortRange</strong>(ushort range); </dt> <dd>
<p>Set the local outgoing port range to use. This can be used together with the localPort property. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>ushort <code>range</code>
</td> <td>if the first port is occupied then try this many port number forwards</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="HTTP.tcpNoDelay">@property void <strong id="tcpNoDelay">tcpNoDelay</strong>(bool on); </dt> <dd>
<p>Set the tcp no-delay socket option on or off. </p>
<dl>
<dt>See</dt>
<dd> <a href="http://curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTTCPNODELAY">nodelay</a>
</dd>
</dl> </dd> <dt class="d_decl" id="HTTP.setAuthentication">void <strong id="setAuthentication">setAuthentication</strong>(const(char)[] username, const(char)[] password, const(char)[] domain = ""); </dt> <dd>
<p>Set the user name, password and optionally domain for authentication purposes. </p>
<p>Some protocols may need authentication in some cases. Use this function to provide credentials. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(char)[] <code>username</code>
</td> <td>the username</td>
</tr> <tr>
<td>const(char)[] <code>password</code>
</td> <td>the password</td>
</tr> <tr>
<td>const(char)[] <code>domain</code>
</td> <td>used for NTLM authentication only and is set to the NTLM domain name</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="HTTP.setProxyAuthentication">void <strong id="setProxyAuthentication">setProxyAuthentication</strong>(const(char)[] username, const(char)[] password); </dt> <dd>
<p>Set the user name and password for proxy authentication. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(char)[] <code>username</code>
</td> <td>the username</td>
</tr> <tr>
<td>const(char)[] <code>password</code>
</td> <td>the password</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="HTTP.onSend">@property void <strong id="onSend">onSend</strong>(size_t delegate(void[]) callback); </dt> <dd>
<p>The event handler that gets called when data is needed for sending. The length of the <code>void[]</code> specifies the maximum number of bytes that can be sent. </p>
<dl>
<dt>Returns:</dt>
<dd>The callback returns the number of elements in the buffer that have been filled and are ready to send. The special value <code>.abortRequest</code> can be returned in order to abort the current request. The special value <code>.pauseRequest</code> can be returned in order to pause the current request. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">import std.net.curl;
string msg = "Hello world";
auto client = HTTP("dlang.org");
client.onSend = delegate size_t(void[] data)
{
    auto m = cast(void[]) msg;
    size_t length = m.length &gt; data.length ? data.length : m.length;
    if (length == 0) return 0;
    data[0 .. length] = m[0 .. length];
    msg = msg[length..$];
    return length;
};
client.perform();
</pre>  </dd> <dt class="d_decl" id="HTTP.onReceive">@property void <strong id="onReceive">onReceive</strong>(size_t delegate(ubyte[]) callback); </dt> <dd>
<p>The event handler that receives incoming data. Be sure to copy the incoming ubyte[] since it is not guaranteed to be valid after the callback returns. </p>
<dl>
<dt>Returns:</dt>
<dd>The callback returns the incoming bytes read. If not the entire array is the request will abort. The special value .pauseRequest can be returned in order to pause the current request. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">import std.net.curl, std.stdio;
auto client = HTTP("dlang.org");
client.onReceive = (ubyte[] data)
{
    writeln("Got data", to!(const(char)[])(data));
    return data.length;
};
client.perform();
</pre>  </dd> <dt class="d_decl" id="HTTP.onProgress">@property void <strong id="onProgress">onProgress</strong>(int delegate(size_t dlTotal, size_t dlNow, size_t ulTotal, size_t ulNow) callback); </dt> <dd>
<p>Register an event handler that gets called to inform of upload/download progress. </p>
<dl>
<dt>Callback parameters</dt>

</dl>
<table>
 <tr> <td><code>dlTotal</code></td> <td>total bytes to download</td> </tr> <tr> <td><code>dlNow</code></td> <td>currently downloaded bytes</td> </tr> <tr> <td><code>ulTotal</code></td> <td>total bytes to upload</td> </tr> <tr> <td><code>ulNow</code></td> <td>currently uploaded bytes</td> </tr> </table> Connection type used when the URL should be used to auto detect the protocol. This struct is used as placeholder for the connection parameter when calling the high level API and the connection type (HTTP/FTP) should be guessed by inspecting the URL parameter. The rules for guessing the protocol are: 1, if URL starts with ftp://, ftps:// or ftp. then FTP connection is assumed. 2, HTTP connection otherwise.  <dl>
<dt>Callback returns</dt>
<dd> Return 0 to signal success, return non-zero to abort transfer. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">import std.net.curl, std.stdio;
auto client = HTTP("dlang.org");
client.onProgress = delegate int(size_t dl, size_t dln, size_t ul, size_t uln)
{
    writeln("Progress: downloaded ", dln, " of ", dl);
    writeln("Progress: uploaded ", uln, " of ", ul);
    return 0;
};
client.perform();
</pre>  </dd> <dt class="d_decl" id="HTTP.clearRequestHeaders">void <strong id="clearRequestHeaders">clearRequestHeaders</strong>(); </dt> <dd>
<p>Clear all outgoing headers.</p> </dd> <dt class="d_decl" id="HTTP.addRequestHeader">void <strong id="addRequestHeader">addRequestHeader</strong>(const(char)[] name, const(char)[] value); </dt> <dd>
<p>Add a header e.g. "X-CustomField: Something is fishy". </p>
<p>There is no remove header functionality. Do a <a href="#clearRequestHeaders"><code>clearRequestHeaders</code></a> and set the needed headers instead. </p> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">import std.net.curl;
auto client = HTTP();
client.addRequestHeader("X-Custom-ABC", "This is the custom value");
auto content = get("dlang.org", client);
</pre>  </dd> <dt class="d_decl" id="HTTP.defaultUserAgent">static @property string <strong id="defaultUserAgent">defaultUserAgent</strong>(); </dt> <dd>
<p>The default "User-Agent" value send with a request. It has the form "Phobos-std.net.curl/<i>PHOBOS_VERSION</i> (libcurl/<i>CURL_VERSION</i>)"</p> </dd> <dt class="d_decl" id="HTTP.setUserAgent">void <strong id="setUserAgent">setUserAgent</strong>(const(char)[] userAgent); </dt> <dd>
<p>Set the value of the user agent request header field. </p>
<p>By default a request has it's "User-Agent" field set to <a href="#%20defaultUserAgent"><code> defaultUserAgent</code></a> even if <code>setUserAgent</code> was never called. Pass an empty string to suppress the "User-Agent" field altogether.</p> </dd> <dt class="d_decl" id="HTTP.getTiming">CurlCode <strong id="getTiming">getTiming</strong>(CurlInfo timing, ref double val); </dt> <dd>
<p>Get various timings defined in <a href="etc_c_curl.html#CurlInfo"><code>etc.c.curl.CurlInfo</code></a>. The value is usable only if the return value is equal to <code>etc.c.curl.CurlError.ok</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>CurlInfo <code>timing</code>
</td> <td>one of the timings defined in <a href="etc_c_curl.html#CurlInfo"><code>etc.c.curl.CurlInfo</code></a>. The values are: <code>etc.c.curl.CurlInfo.namelookup_time</code>, <code>etc.c.curl.CurlInfo.connect_time</code>, <code>etc.c.curl.CurlInfo.pretransfer_time</code>, <code>etc.c.curl.CurlInfo.starttransfer_time</code>, <code>etc.c.curl.CurlInfo.redirect_time</code>, <code>etc.c.curl.CurlInfo.appconnect_time</code>, <code>etc.c.curl.CurlInfo.total_time</code>.</td>
</tr> <tr>
<td>double <code>val</code>
</td> <td>the actual value of the inquired timing.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The return code of the operation. The value stored in val should be used only if the return value is <code>etc.c.curl.CurlInfo.ok</code>. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">import std.net.curl;
import etc.c.curl : CurlError, CurlInfo;

auto client = HTTP("dlang.org");
client.perform();

double val;
CurlCode code;

code = client.getTiming(CurlInfo.namelookup_time, val);
assert(code == CurlError.ok);
</pre>  </dd> <dt class="d_decl" id="HTTP.responseHeaders">@property string[string] <strong id="responseHeaders">responseHeaders</strong>(); </dt> <dd>
<p>The headers read from a successful response. </p> </dd> <dt class="d_decl" id="HTTP.method">@property void <strong id="method">method</strong>(Method m); <br><br>@property Method <strong id="method">method</strong>(); </dt> <dd>
<p>HTTP method used.</p> </dd> <dt class="d_decl" id="HTTP.statusLine">@property StatusLine <strong id="statusLine">statusLine</strong>(); </dt> <dd>
<p>HTTP status line of last response. One call to perform may result in several requests because of redirection.</p> </dd> <dt class="d_decl" id="HTTP.setCookie">void <strong id="setCookie">setCookie</strong>(const(char)[] cookie); </dt> <dd>
<p>Set the active cookie string e.g. "name1=value1;name2=value2"</p> </dd> <dt class="d_decl" id="HTTP.setCookieJar">void <strong id="setCookieJar">setCookieJar</strong>(const(char)[] path); </dt> <dd>
<p>Set a file path to where a cookie jar should be read/stored.</p> </dd> <dt class="d_decl" id="HTTP.flushCookieJar">void <strong id="flushCookieJar">flushCookieJar</strong>(); </dt> <dd>
<p>Flush cookie jar to disk.</p> </dd> <dt class="d_decl" id="HTTP.clearSessionCookies">void <strong id="clearSessionCookies">clearSessionCookies</strong>(); </dt> <dd>
<p>Clear session cookies.</p> </dd> <dt class="d_decl" id="HTTP.clearAllCookies">void <strong id="clearAllCookies">clearAllCookies</strong>(); </dt> <dd>
<p>Clear all cookies.</p> </dd> <dt class="d_decl" id="HTTP.setTimeCondition">void <strong id="setTimeCondition">setTimeCondition</strong>(HTTP.TimeCond cond, SysTime timestamp); </dt> <dd>
<p>Set time condition on the request. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>HTTP.TimeCond <code>cond</code>
</td> <td><code>CurlTimeCond.{none,ifmodsince,ifunmodsince,lastmod}</code></td>
</tr> <tr>
<td>SysTime <code>timestamp</code>
</td> <td>Timestamp for the condition  <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.25">RFC2616 Section 14.25</a>
</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="HTTP.postData">@property void <strong id="postData">postData</strong>(const(void)[] data); </dt> <dd>
<p>Specifying data to post when not using the onSend callback. </p>
<p>The data is NOT copied by the library. Content-Type will default to application/octet-stream. Data is not converted or encoded by this method. </p> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">import std.net.curl, std.stdio;
auto http = HTTP("http://www.mydomain.com");
http.onReceive = (ubyte[] data) { writeln(to!(const(char)[])(data)); return data.length; };
http.postData = [1,2,3,4,5];
http.perform();
</pre>  </dd> <dt class="d_decl" id="HTTP.postData.2">@property void <strong id="postData">postData</strong>(const(char)[] data); </dt> <dd>
<p>Specifying data to post when not using the onSend callback. </p>
<p>The data is NOT copied by the library. Content-Type will default to text/plain. Data is not converted or encoded by this method. </p> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">import std.net.curl, std.stdio;
auto http = HTTP("http://www.mydomain.com");
http.onReceive = (ubyte[] data) { writeln(to!(const(char)[])(data)); return data.length; };
http.postData = "The quick....";
http.perform();
</pre>  </dd> <dt class="d_decl" id="HTTP.setPostData">void <strong id="setPostData">setPostData</strong>(const(void)[] data, string contentType); </dt> <dd>
<p>Specify data to post when not using the onSend callback, with user-specified Content-Type. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(void)[] <code>data</code>
</td> <td>Data to post.</td>
</tr> <tr>
<td>string <code>contentType</code>
</td> <td>MIME type of the data, for example, "text/plain" or "application/octet-stream". See also: <a href="http://en.wikipedia.org/wiki/Internet_media_type"> Internet media type</a> on Wikipedia. <pre data-language="d">import std.net.curl;
auto http = HTTP("http://onlineform.example.com");
auto data = "app=login&amp;username=bob&amp;password=s00perS3kret";
http.setPostData(data, "application/x-www-form-urlencoded");
http.onReceive = (ubyte[] data) { return data.length; };
http.perform();
</pre> </td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="HTTP.onReceiveHeader">@property void <strong id="onReceiveHeader">onReceiveHeader</strong>(void delegate(in char[] key, in char[] value) callback); </dt> <dd>
<p>Set the event handler that receives incoming headers. </p>
<p>The callback will receive a header field key, value as parameter. The <code>const(char)[]</code> arrays are not valid after the delegate has returned. </p> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">import std.net.curl, std.stdio;
auto http = HTTP("dlang.org");
http.onReceive = (ubyte[] data) { writeln(to!(const(char)[])(data)); return data.length; };
http.onReceiveHeader = (in char[] key, in char[] value) { writeln(key, " = ", value); };
http.perform();
</pre>  </dd> <dt class="d_decl" id="HTTP.onReceiveStatusLine">@property void <strong id="onReceiveStatusLine">onReceiveStatusLine</strong>(void delegate(StatusLine) callback); </dt> <dd>
<p>Callback for each received StatusLine. </p>
<p>Notice that several callbacks can be done for each call to <code>perform()</code> due to redirections. </p> <dl>
<dt>See Also:</dt>
<dd><a href="#StatusLine"><code>StatusLine</code></a></dd>
</dl> </dd> <dt class="d_decl" id="HTTP.contentLength">@property void <strong id="contentLength">contentLength</strong>(ulong len); </dt> <dd>
<p>The content length in bytes when using request that has content e.g. POST/PUT and not using chunked transfer. Is set as the "Content-Length" header. Set to ulong.max to reset to chunked transfer.</p> </dd> <dt class="d_decl" id="HTTP.authenticationMethod">@property void <strong id="authenticationMethod">authenticationMethod</strong>(AuthMethod authMethod); </dt> <dd>
<p>Authentication method as specified in <a href="#AuthMethod"><code>AuthMethod</code></a>.</p> </dd> <dt class="d_decl" id="HTTP.maxRedirects">@property void <strong id="maxRedirects">maxRedirects</strong>(uint maxRedirs); </dt> <dd>
<p>Set max allowed redirections using the location header. uint.max for infinite.</p> </dd> <dt class="d_decl" id="HTTP.Method">enum <strong id="Method">Method</strong>: int; </dt> <dd>
<p>The standard HTTP methods : <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1.1">RFC2616 Section 5.1.1</a></p> <dl>
<dt class="d_decl" id="HTTP.Method.head"><strong id="head">head</strong></dt>  <dt class="d_decl" id="HTTP.Method.get"><strong id="get">get</strong></dt>  <dt class="d_decl" id="HTTP.Method.post"><strong id="post">post</strong></dt>  <dt class="d_decl" id="HTTP.Method.put"><strong id="put">put</strong></dt>  <dt class="d_decl" id="HTTP.Method.del"><strong id="del">del</strong></dt>  <dt class="d_decl" id="HTTP.Method.options"><strong id="options">options</strong></dt>  <dt class="d_decl" id="HTTP.Method.trace"><strong id="trace">trace</strong></dt>  <dt class="d_decl" id="HTTP.Method.connect"><strong id="connect">connect</strong></dt>  <dt class="d_decl" id="HTTP.Method.patch"><strong id="patch">patch</strong></dt>  </dl> </dd> <dt class="d_decl" id="HTTP.StatusLine">struct <strong id="StatusLine">StatusLine</strong>; </dt> <dd>
<p>HTTP status line ie. the first line returned in an HTTP response. </p>
<p>If authentication or redirections are done then the status will be for the last response received.</p> <dl>
<dt class="d_decl" id="HTTP.StatusLine.majorVersion">ushort <strong id="majorVersion">majorVersion</strong>; </dt> <dd>
<p>Major HTTP version ie. 1 in HTTP/1.0.</p> </dd> <dt class="d_decl" id="HTTP.StatusLine.minorVersion">ushort <strong id="minorVersion">minorVersion</strong>; </dt> <dd>
<p>Minor HTTP version ie. 0 in HTTP/1.0.</p> </dd> <dt class="d_decl" id="HTTP.StatusLine.code">ushort <strong id="code">code</strong>; </dt> <dd>
<p>HTTP status line code e.g. 200.</p> </dd> <dt class="d_decl" id="HTTP.StatusLine.reason">string <strong id="reason">reason</strong>; </dt> <dd>
<p>HTTP status line reason string.</p> </dd> <dt class="d_decl" id="HTTP.StatusLine.reset">@safe void <strong id="reset">reset</strong>(); </dt> <dd>
<p>Reset this status line</p> </dd> <dt class="d_decl" id="HTTP.StatusLine.toString">const string <strong id="toString">toString</strong>(); </dt>  </dl> </dd> </dl> </dd> <dt class="d_decl" id="FTP">struct <strong id="FTP">FTP</strong>; </dt> <dd>
<p>FTP client functionality. </p>
<dl>
<dt>See Also:</dt>
<dd><a href="http://tools.ietf.org/html/rfc959">RFC959</a></dd>
</dl> <dl>
<dt class="d_decl" id="FTP.opCall">static FTP <strong id="opCall">opCall</strong>(const(char)[] url); </dt> <dd>
<p>FTP access to the specified url.</p> </dd> <dt class="d_decl" id="FTP.opCall.2">static FTP <strong id="opCall">opCall</strong>(); </dt>  <dt class="d_decl" id="FTP.dup">FTP <strong id="dup">dup</strong>(); </dt>  <dt class="d_decl" id="FTP.perform">CurlCode <strong id="perform">perform</strong>(ThrowOnError throwOnError = Yes.throwOnError); </dt> <dd>
<p>Performs the ftp request as it has been configured. </p>
<p>After a FTP client has been setup and possibly assigned callbacks the <code> perform()</code> method will start performing the actual communication with the server. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>ThrowOnError <code>throwOnError</code>
</td> <td>whether to throw an exception or return a CurlCode on error</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="FTP.url">@property void <strong id="url">url</strong>(const(char)[] <strong id="url">url</strong>); </dt> <dd>
<p>The URL to specify the location of the resource.</p> </dd> <dt class="d_decl" id="FTP.requestPause">alias <strong id="requestPause">requestPause</strong> = etc.c.curl.CurlReadFunc.pause; </dt> <dd>
<p>Value to return from <code>onSend</code>/<code>onReceive</code> delegates in order to pause a request</p> </dd> <dt class="d_decl" id="FTP.requestAbort">alias <strong id="requestAbort">requestAbort</strong> = etc.c.curl.CurlReadFunc.abort; </dt> <dd>
<p>Value to return from onSend delegate in order to abort a request</p> </dd> <dt class="d_decl" id="FTP.isStopped">@property bool <strong id="isStopped">isStopped</strong>(); </dt> <dd>
<p>True if the instance is stopped. A stopped instance is not usable.</p> </dd> <dt class="d_decl" id="FTP.shutdown">void <strong id="shutdown">shutdown</strong>(); </dt> <dd>
<p>Stop and invalidate this instance.</p> </dd> <dt class="d_decl" id="FTP.verbose">@property void <strong id="verbose">verbose</strong>(bool on); </dt> <dd>
<p>Set verbose. This will print request information to stderr.</p> </dd> <dt class="d_decl" id="FTP.dataTimeout">@property void <strong id="dataTimeout">dataTimeout</strong>(Duration d); </dt> <dd>
<p>Set timeout for activity on connection.</p> </dd> <dt class="d_decl" id="FTP.operationTimeout">@property void <strong id="operationTimeout">operationTimeout</strong>(Duration d); </dt> <dd>
<p>Set maximum time an operation is allowed to take. This includes dns resolution, connecting, data transfer, etc.</p> </dd> <dt class="d_decl" id="FTP.connectTimeout">@property void <strong id="connectTimeout">connectTimeout</strong>(Duration d); </dt> <dd>
<p>Set timeout for connecting.</p> </dd> <dt class="d_decl" id="FTP.proxy">@property void <strong id="proxy">proxy</strong>(const(char)[] host); </dt> <dd>
<p>Proxy </p>
<dl>
<dt>See</dt>
<dd> <a href="http://curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTPROXY">proxy</a>
</dd>
</dl> </dd> <dt class="d_decl" id="FTP.proxyPort">@property void <strong id="proxyPort">proxyPort</strong>(ushort port); </dt> <dd>
<p>Proxy port </p>
<dl>
<dt>See</dt>
<dd> <a href="http://curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTPROXYPORT">proxy_port</a>
</dd>
</dl> </dd> <dt class="d_decl" id="FTP.CurlProxy">alias <strong id="CurlProxy">CurlProxy</strong> = etc.c.curl.<strong id="CurlProxy">CurlProxy</strong>; </dt> <dd>
<p>Type of proxy</p> </dd> <dt class="d_decl" id="FTP.proxyType">@property void <strong id="proxyType">proxyType</strong>(CurlProxy type); </dt> <dd>
<p>Proxy type </p>
<dl>
<dt>See</dt>
<dd> <a href="http://curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTPROXY">proxy_type</a>
</dd>
</dl> </dd> <dt class="d_decl" id="FTP.dnsTimeout">@property void <strong id="dnsTimeout">dnsTimeout</strong>(Duration d); </dt> <dd>
<p>DNS lookup timeout.</p> </dd> <dt class="d_decl" id="FTP.netInterface">@property void <strong id="netInterface">netInterface</strong>(const(char)[] i); <br><br>@property void <strong id="netInterface">netInterface</strong>(const(ubyte)[4] i); <br><br>@property void <strong id="netInterface">netInterface</strong>(InternetAddress i); </dt> <dd>
<p>The network interface to use in form of the the IP of the interface. </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">theprotocol.netInterface = "192.168.1.32";
theprotocol.netInterface = [ 192, 168, 1, 32 ];
</pre>  <dl>
<dt>See</dt>
<dd> <a href="std_socket.html#InternetAddress"><code>std.socket.InternetAddress</code></a>
</dd>
</dl> </dd> <dt class="d_decl" id="FTP.localPort">@property void <strong id="localPort">localPort</strong>(ushort port); </dt> <dd>
<p>Set the local outgoing port to use. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>ushort <code>port</code>
</td> <td>the first outgoing port number to try and use</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="FTP.localPortRange">@property void <strong id="localPortRange">localPortRange</strong>(ushort range); </dt> <dd>
<p>Set the local outgoing port range to use. This can be used together with the localPort property. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>ushort <code>range</code>
</td> <td>if the first port is occupied then try this many port number forwards</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="FTP.tcpNoDelay">@property void <strong id="tcpNoDelay">tcpNoDelay</strong>(bool on); </dt> <dd>
<p>Set the tcp no-delay socket option on or off. </p>
<dl>
<dt>See</dt>
<dd> <a href="http://curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTTCPNODELAY">nodelay</a>
</dd>
</dl> </dd> <dt class="d_decl" id="FTP.setAuthentication">void <strong id="setAuthentication">setAuthentication</strong>(const(char)[] username, const(char)[] password, const(char)[] domain = ""); </dt> <dd>
<p>Set the user name, password and optionally domain for authentication purposes. </p>
<p>Some protocols may need authentication in some cases. Use this function to provide credentials. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(char)[] <code>username</code>
</td> <td>the username</td>
</tr> <tr>
<td>const(char)[] <code>password</code>
</td> <td>the password</td>
</tr> <tr>
<td>const(char)[] <code>domain</code>
</td> <td>used for NTLM authentication only and is set to the NTLM domain name</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="FTP.setProxyAuthentication">void <strong id="setProxyAuthentication">setProxyAuthentication</strong>(const(char)[] username, const(char)[] password); </dt> <dd>
<p>Set the user name and password for proxy authentication. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(char)[] <code>username</code>
</td> <td>the username</td>
</tr> <tr>
<td>const(char)[] <code>password</code>
</td> <td>the password</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="FTP.onSend">@property void <strong id="onSend">onSend</strong>(size_t delegate(void[]) callback); </dt> <dd>
<p>The event handler that gets called when data is needed for sending. The length of the <code>void[]</code> specifies the maximum number of bytes that can be sent. </p>
<dl>
<dt>Returns:</dt>
<dd>The callback returns the number of elements in the buffer that have been filled and are ready to send. The special value <code>.abortRequest</code> can be returned in order to abort the current request. The special value <code>.pauseRequest</code> can be returned in order to pause the current request.</dd>
</dl> </dd> <dt class="d_decl" id="FTP.onReceive">@property void <strong id="onReceive">onReceive</strong>(size_t delegate(ubyte[]) callback); </dt> <dd>
<p>The event handler that receives incoming data. Be sure to copy the incoming ubyte[] since it is not guaranteed to be valid after the callback returns. </p>
<dl>
<dt>Returns:</dt>
<dd>The callback returns the incoming bytes read. If not the entire array is the request will abort. The special value .pauseRequest can be returned in order to pause the current request.</dd>
</dl> </dd> <dt class="d_decl" id="FTP.onProgress">@property void <strong id="onProgress">onProgress</strong>(int delegate(size_t dlTotal, size_t dlNow, size_t ulTotal, size_t ulNow) callback); </dt> <dd>
<p>The event handler that gets called to inform of upload/download progress. </p>
<dl>
<dt>Callback parameters</dt>

</dl>
<table>
 <tr> <td><code>dlTotal</code></td> <td>total bytes to download</td> </tr> <tr> <td><code>dlNow</code></td> <td>currently downloaded bytes</td> </tr> <tr> <td><code>ulTotal</code></td> <td>total bytes to upload</td> </tr> <tr> <td><code>ulNow</code></td> <td>currently uploaded bytes</td> </tr> </table> Connection type used when the URL should be used to auto detect the protocol. This struct is used as placeholder for the connection parameter when calling the high level API and the connection type (HTTP/FTP) should be guessed by inspecting the URL parameter. The rules for guessing the protocol are: 1, if URL starts with ftp://, ftps:// or ftp. then FTP connection is assumed. 2, HTTP connection otherwise.  <dl>
<dt>Callback returns</dt>
<dd> Return 0 from the callback to signal success, return non-zero to abort transfer.</dd>
</dl> </dd> <dt class="d_decl" id="FTP.clearCommands">void <strong id="clearCommands">clearCommands</strong>(); </dt> <dd>
<p>Clear all commands send to ftp server.</p> </dd> <dt class="d_decl" id="FTP.addCommand">void <strong id="addCommand">addCommand</strong>(const(char)[] command); </dt> <dd>
<p>Add a command to send to ftp server. </p>
<p>There is no remove command functionality. Do a <a href="#clearCommands"><code>clearCommands</code></a> and set the needed commands instead. </p> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">import std.net.curl;
auto client = FTP();
client.addCommand("RNFR my_file.txt");
client.addCommand("RNTO my_renamed_file.txt");
upload("my_file.txt", "ftp.digitalmars.com", client);
</pre>  </dd> <dt class="d_decl" id="FTP.encoding">@property void <strong id="encoding">encoding</strong>(string name); <br><br>@property string <strong id="encoding">encoding</strong>(); </dt> <dd>
<p>Connection encoding. Defaults to ISO-8859-1.</p> </dd> <dt class="d_decl" id="FTP.contentLength">@property void <strong id="contentLength">contentLength</strong>(ulong len); </dt> <dd>
<p>The content length in bytes of the ftp data.</p> </dd> <dt class="d_decl" id="FTP.getTiming">CurlCode <strong id="getTiming">getTiming</strong>(CurlInfo timing, ref double val); </dt> <dd>
<p>Get various timings defined in <a href="etc_c_curl.html#CurlInfo"><code>etc.c.curl.CurlInfo</code></a>. The value is usable only if the return value is equal to <code>etc.c.curl.CurlError.ok</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>CurlInfo <code>timing</code>
</td> <td>one of the timings defined in <a href="etc_c_curl.html#CurlInfo"><code>etc.c.curl.CurlInfo</code></a>. The values are: <code>etc.c.curl.CurlInfo.namelookup_time</code>, <code>etc.c.curl.CurlInfo.connect_time</code>, <code>etc.c.curl.CurlInfo.pretransfer_time</code>, <code>etc.c.curl.CurlInfo.starttransfer_time</code>, <code>etc.c.curl.CurlInfo.redirect_time</code>, <code>etc.c.curl.CurlInfo.appconnect_time</code>, <code>etc.c.curl.CurlInfo.total_time</code>.</td>
</tr> <tr>
<td>double <code>val</code>
</td> <td>the actual value of the inquired timing.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The return code of the operation. The value stored in val should be used only if the return value is <code>etc.c.curl.CurlInfo.ok</code>. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">import std.net.curl;
import etc.c.curl : CurlError, CurlInfo;

auto client = FTP();
client.addCommand("RNFR my_file.txt");
client.addCommand("RNTO my_renamed_file.txt");
upload("my_file.txt", "ftp.digitalmars.com", client);

double val;
CurlCode code;

code = client.getTiming(CurlInfo.namelookup_time, val);
assert(code == CurlError.ok);
</pre>  </dd> </dl> </dd> <dt class="d_decl" id="SMTP">struct <strong id="SMTP">SMTP</strong>; </dt> <dd>
<p>Basic SMTP protocol support. </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">import std.net.curl;

// Send an email with SMTPS
auto smtp = SMTP("smtps://smtp.gmail.com");
smtp.setAuthentication("from.addr@gmail.com", "password");
smtp.mailTo = ["&lt;to.addr@gmail.com&gt;"];
smtp.mailFrom = "&lt;from.addr@gmail.com&gt;";
smtp.message = "Example Message";
smtp.perform();
</pre>  <dl>
<dt>See Also:</dt>
<dd><a href="http://www.ietf.org/rfc/rfc2821.txt">RFC2821</a></dd>
</dl> <dl>
<dt class="d_decl" id="SMTP.opCall">static SMTP <strong id="opCall">opCall</strong>(const(char)[] url); </dt> <dd>
<p>Sets to the URL of the SMTP server.</p> </dd> <dt class="d_decl" id="SMTP.opCall.2">static SMTP <strong id="opCall">opCall</strong>(); </dt>  <dt class="d_decl" id="SMTP.perform">CurlCode <strong id="perform">perform</strong>(ThrowOnError throwOnError = Yes.throwOnError); </dt> <dd>
<p>Performs the request as configured. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>ThrowOnError <code>throwOnError</code>
</td> <td>whether to throw an exception or return a CurlCode on error</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="SMTP.url">@property void <strong id="url">url</strong>(const(char)[] <strong id="url">url</strong>); </dt> <dd>
<p>The URL to specify the location of the resource.</p> </dd> <dt class="d_decl" id="SMTP.requestPause">alias <strong id="requestPause">requestPause</strong> = etc.c.curl.CurlReadFunc.pause; </dt> <dd>
<p>Value to return from <code>onSend</code>/<code>onReceive</code> delegates in order to pause a request</p> </dd> <dt class="d_decl" id="SMTP.requestAbort">alias <strong id="requestAbort">requestAbort</strong> = etc.c.curl.CurlReadFunc.abort; </dt> <dd>
<p>Value to return from onSend delegate in order to abort a request</p> </dd> <dt class="d_decl" id="SMTP.isStopped">@property bool <strong id="isStopped">isStopped</strong>(); </dt> <dd>
<p>True if the instance is stopped. A stopped instance is not usable.</p> </dd> <dt class="d_decl" id="SMTP.shutdown">void <strong id="shutdown">shutdown</strong>(); </dt> <dd>
<p>Stop and invalidate this instance.</p> </dd> <dt class="d_decl" id="SMTP.verbose">@property void <strong id="verbose">verbose</strong>(bool on); </dt> <dd>
<p>Set verbose. This will print request information to stderr.</p> </dd> <dt class="d_decl" id="SMTP.dataTimeout">@property void <strong id="dataTimeout">dataTimeout</strong>(Duration d); </dt> <dd>
<p>Set timeout for activity on connection.</p> </dd> <dt class="d_decl" id="SMTP.operationTimeout">@property void <strong id="operationTimeout">operationTimeout</strong>(Duration d); </dt> <dd>
<p>Set maximum time an operation is allowed to take. This includes dns resolution, connecting, data transfer, etc.</p> </dd> <dt class="d_decl" id="SMTP.connectTimeout">@property void <strong id="connectTimeout">connectTimeout</strong>(Duration d); </dt> <dd>
<p>Set timeout for connecting.</p> </dd> <dt class="d_decl" id="SMTP.proxy">@property void <strong id="proxy">proxy</strong>(const(char)[] host); </dt> <dd>
<p>Proxy </p>
<dl>
<dt>See</dt>
<dd> <a href="http://curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTPROXY">proxy</a>
</dd>
</dl> </dd> <dt class="d_decl" id="SMTP.proxyPort">@property void <strong id="proxyPort">proxyPort</strong>(ushort port); </dt> <dd>
<p>Proxy port </p>
<dl>
<dt>See</dt>
<dd> <a href="http://curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTPROXYPORT">proxy_port</a>
</dd>
</dl> </dd> <dt class="d_decl" id="SMTP.CurlProxy">alias <strong id="CurlProxy">CurlProxy</strong> = etc.c.curl.<strong id="CurlProxy">CurlProxy</strong>; </dt> <dd>
<p>Type of proxy</p> </dd> <dt class="d_decl" id="SMTP.proxyType">@property void <strong id="proxyType">proxyType</strong>(CurlProxy type); </dt> <dd>
<p>Proxy type </p>
<dl>
<dt>See</dt>
<dd> <a href="http://curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTPROXY">proxy_type</a>
</dd>
</dl> </dd> <dt class="d_decl" id="SMTP.dnsTimeout">@property void <strong id="dnsTimeout">dnsTimeout</strong>(Duration d); </dt> <dd>
<p>DNS lookup timeout.</p> </dd> <dt class="d_decl" id="SMTP.netInterface">@property void <strong id="netInterface">netInterface</strong>(const(char)[] i); <br><br>@property void <strong id="netInterface">netInterface</strong>(const(ubyte)[4] i); <br><br>@property void <strong id="netInterface">netInterface</strong>(InternetAddress i); </dt> <dd>
<p>The network interface to use in form of the the IP of the interface. </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">theprotocol.netInterface = "192.168.1.32";
theprotocol.netInterface = [ 192, 168, 1, 32 ];
</pre>  <dl>
<dt>See</dt>
<dd> <a href="std_socket.html#InternetAddress"><code>std.socket.InternetAddress</code></a>
</dd>
</dl> </dd> <dt class="d_decl" id="SMTP.localPort">@property void <strong id="localPort">localPort</strong>(ushort port); </dt> <dd>
<p>Set the local outgoing port to use. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>ushort <code>port</code>
</td> <td>the first outgoing port number to try and use</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="SMTP.localPortRange">@property void <strong id="localPortRange">localPortRange</strong>(ushort range); </dt> <dd>
<p>Set the local outgoing port range to use. This can be used together with the localPort property. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>ushort <code>range</code>
</td> <td>if the first port is occupied then try this many port number forwards</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="SMTP.tcpNoDelay">@property void <strong id="tcpNoDelay">tcpNoDelay</strong>(bool on); </dt> <dd>
<p>Set the tcp no-delay socket option on or off. </p>
<dl>
<dt>See</dt>
<dd> <a href="http://curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTTCPNODELAY">nodelay</a>
</dd>
</dl> </dd> <dt class="d_decl" id="SMTP.setAuthentication">void <strong id="setAuthentication">setAuthentication</strong>(const(char)[] username, const(char)[] password, const(char)[] domain = ""); </dt> <dd>
<p>Set the user name, password and optionally domain for authentication purposes. </p>
<p>Some protocols may need authentication in some cases. Use this function to provide credentials. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(char)[] <code>username</code>
</td> <td>the username</td>
</tr> <tr>
<td>const(char)[] <code>password</code>
</td> <td>the password</td>
</tr> <tr>
<td>const(char)[] <code>domain</code>
</td> <td>used for NTLM authentication only and is set to the NTLM domain name</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="SMTP.setProxyAuthentication">void <strong id="setProxyAuthentication">setProxyAuthentication</strong>(const(char)[] username, const(char)[] password); </dt> <dd>
<p>Set the user name and password for proxy authentication. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(char)[] <code>username</code>
</td> <td>the username</td>
</tr> <tr>
<td>const(char)[] <code>password</code>
</td> <td>the password</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="SMTP.onSend">@property void <strong id="onSend">onSend</strong>(size_t delegate(void[]) callback); </dt> <dd>
<p>The event handler that gets called when data is needed for sending. The length of the <code>void[]</code> specifies the maximum number of bytes that can be sent. </p>
<dl>
<dt>Returns:</dt>
<dd>The callback returns the number of elements in the buffer that have been filled and are ready to send. The special value <code>.abortRequest</code> can be returned in order to abort the current request. The special value <code>.pauseRequest</code> can be returned in order to pause the current request.</dd>
</dl> </dd> <dt class="d_decl" id="SMTP.onReceive">@property void <strong id="onReceive">onReceive</strong>(size_t delegate(ubyte[]) callback); </dt> <dd>
<p>The event handler that receives incoming data. Be sure to copy the incoming ubyte[] since it is not guaranteed to be valid after the callback returns. </p>
<dl>
<dt>Returns:</dt>
<dd>The callback returns the incoming bytes read. If not the entire array is the request will abort. The special value .pauseRequest can be returned in order to pause the current request.</dd>
</dl> </dd> <dt class="d_decl" id="SMTP.onProgress">@property void <strong id="onProgress">onProgress</strong>(int delegate(size_t dlTotal, size_t dlNow, size_t ulTotal, size_t ulNow) callback); </dt> <dd>
<p>The event handler that gets called to inform of upload/download progress. </p>
<dl>
<dt>Callback parameters</dt>

</dl>
<table>
 <tr> <td><code>dlTotal</code></td> <td>total bytes to download</td> </tr> <tr> <td><code>dlNow</code></td> <td>currently downloaded bytes</td> </tr> <tr> <td><code>ulTotal</code></td> <td>total bytes to upload</td> </tr> <tr> <td><code>ulNow</code></td> <td>currently uploaded bytes</td> </tr> </table> Connection type used when the URL should be used to auto detect the protocol. This struct is used as placeholder for the connection parameter when calling the high level API and the connection type (HTTP/FTP) should be guessed by inspecting the URL parameter. The rules for guessing the protocol are: 1, if URL starts with ftp://, ftps:// or ftp. then FTP connection is assumed. 2, HTTP connection otherwise.  <dl>
<dt>Callback returns</dt>
<dd> Return 0 from the callback to signal success, return non-zero to abort transfer.</dd>
</dl> </dd> <dt class="d_decl" id="SMTP.mailFrom">@property void <strong id="mailFrom">mailFrom</strong>()(const(char)[] sender); </dt> <dd>
<p>Setter for the sender's email address.</p> </dd> <dt class="d_decl" id="SMTP.mailTo">void <strong id="mailTo">mailTo</strong>()(const(char)[][] recipients...); </dt> <dd>
<p>Setter for the recipient email addresses.</p> </dd> <dt class="d_decl" id="SMTP.message">@property void <strong id="message">message</strong>(string msg); </dt> <dd>
<p>Sets the message body text.</p> </dd> </dl> </dd> <dt class="d_decl" id="CurlException">class <strong id="CurlException">CurlException</strong>: object.Exception; </dt> <dd>
<p>Exception thrown on errors in std.net.curl functions.</p> <dl>
<dt class="d_decl" id="CurlException.this">pure nothrow @safe this(string msg, string file = __FILE__, size_t line = __LINE__, Throwable next = null); </dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>string <code>msg</code>
</td> <td>The message for the exception.</td>
</tr> <tr>
<td>string <code>file</code>
</td> <td>The file where the exception occurred.</td>
</tr> <tr>
<td>size_t <code>line</code>
</td> <td>The line number where the exception occurred.</td>
</tr> <tr>
<td>Throwable <code>next</code>
</td> <td>The previous exception in the chain of exceptions, if any.</td>
</tr> </table></dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="CurlTimeoutException">class <strong id="CurlTimeoutException">CurlTimeoutException</strong>: std.net.curl.CurlException; </dt> <dd>
<p>Exception thrown on timeout errors in std.net.curl functions.</p> <dl>
<dt class="d_decl" id="CurlTimeoutException.this">pure nothrow @safe this(string msg, string file = __FILE__, size_t line = __LINE__, Throwable next = null); </dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>string <code>msg</code>
</td> <td>The message for the exception.</td>
</tr> <tr>
<td>string <code>file</code>
</td> <td>The file where the exception occurred.</td>
</tr> <tr>
<td>size_t <code>line</code>
</td> <td>The line number where the exception occurred.</td>
</tr> <tr>
<td>Throwable <code>next</code>
</td> <td>The previous exception in the chain of exceptions, if any.</td>
</tr> </table></dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="HTTPStatusException">class <strong id="HTTPStatusException">HTTPStatusException</strong>: std.net.curl.CurlException; </dt> <dd>
<p>Exception thrown on HTTP request failures, e.g. 404 Not Found.</p> <dl>
<dt class="d_decl" id="HTTPStatusException.this">pure nothrow @safe this(int status, string msg, string file = __FILE__, size_t line = __LINE__, Throwable next = null); </dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>int <code>status</code>
</td> <td>The HTTP status code.</td>
</tr> <tr>
<td>string <code>msg</code>
</td> <td>The message for the exception.</td>
</tr> <tr>
<td>string <code>file</code>
</td> <td>The file where the exception occurred.</td>
</tr> <tr>
<td>size_t <code>line</code>
</td> <td>The line number where the exception occurred.</td>
</tr> <tr>
<td>Throwable <code>next</code>
</td> <td>The previous exception in the chain of exceptions, if any.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="HTTPStatusException.status">immutable int <strong id="status">status</strong>; </dt> <dd>
<p>The HTTP status code</p> </dd> </dl> </dd> <dt class="d_decl" id="CurlCode">alias <strong id="CurlCode">CurlCode</strong> = int; </dt> <dd>
<p>Equal to <a href="etc_c_curl.html#CURLcode"><code>etc.c.curl.CURLcode</code></a></p> </dd> <dt class="d_decl" id="ThrowOnError">alias <strong id="ThrowOnError">ThrowOnError</strong> = std.typecons.Flag!"throwOnError".Flag; </dt> <dd>
<p>Flag to specify whether or not an exception is thrown on error.</p> </dd> <dt class="d_decl" id="Curl">struct <strong id="Curl">Curl</strong>; </dt> <dd>
<p>Wrapper to provide a better interface to libcurl than using the plain C API. It is recommended to use the <code>HTTP</code>/<code>FTP</code> etc. structs instead unless raw access to libcurl is needed. </p>
<dl>
<dt>Warning</dt>
<dd> This struct uses interior pointers for callbacks. Only allocate it on the stack if you never move or copy it. This also means passing by reference when passing Curl to other functions. Otherwise always allocate on the heap.</dd>
</dl> <dl>
<dt class="d_decl" id="Curl.initialize">void <strong id="initialize">initialize</strong>(); </dt> <dd>
<p>Initialize the instance by creating a working curl handle.</p> </dd> <dt class="d_decl" id="Curl.stopped">const @property bool <strong id="stopped">stopped</strong>(); </dt>  <dt class="d_decl" id="Curl.dup">Curl <strong id="dup">dup</strong>(); </dt> <dd>
<p>Duplicate this handle. </p>
<p>The new handle will have all options set as the one it was duplicated from. An exception to this is that all options that cannot be shared across threads are reset thereby making it safe to use the duplicate in a new thread.</p> </dd> <dt class="d_decl" id="Curl.shutdown">void <strong id="shutdown">shutdown</strong>(); </dt> <dd>
<p>Stop and invalidate this curl instance. </p>
<dl>
<dt>Warning</dt>
<dd> Do not call this from inside a callback handler e.g. <code>onReceive</code>.</dd>
</dl> </dd> <dt class="d_decl" id="Curl.pause">void <strong id="pause">pause</strong>(bool sendingPaused, bool receivingPaused); </dt> <dd>
<p>Pausing and continuing transfers.</p> </dd> <dt class="d_decl" id="Curl.set">void <strong id="set">set</strong>(CurlOption option, const(char)[] value); </dt> <dd>
<p>Set a string curl option. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>CurlOption <code>option</code>
</td> <td>A <a href="etc_c_curl.html#CurlOption"><code>etc.c.curl.CurlOption</code></a> as found in the curl documentation</td>
</tr> <tr>
<td>const(char)[] <code>value</code>
</td> <td>The string</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="Curl.set.2">void <strong id="set">set</strong>(CurlOption option, long value); </dt> <dd>
<p>Set a long curl option. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>CurlOption <code>option</code>
</td> <td>A <a href="etc_c_curl.html#CurlOption"><code>etc.c.curl.CurlOption</code></a> as found in the curl documentation</td>
</tr> <tr>
<td>long <code>value</code>
</td> <td>The long</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="Curl.set.3">void <strong id="set">set</strong>(CurlOption option, void* value); </dt> <dd>
<p>Set a void* curl option. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>CurlOption <code>option</code>
</td> <td>A <a href="etc_c_curl.html#CurlOption"><code>etc.c.curl.CurlOption</code></a> as found in the curl documentation</td>
</tr> <tr>
<td>void* <code>value</code>
</td> <td>The pointer</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="Curl.clear">void <strong id="clear">clear</strong>(CurlOption option); </dt> <dd>
<p>Clear a pointer option. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>CurlOption <code>option</code>
</td> <td>A <a href="etc_c_curl.html#CurlOption"><code>etc.c.curl.CurlOption</code></a> as found in the curl documentation</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="Curl.clearIfSupported">void <strong id="clearIfSupported">clearIfSupported</strong>(CurlOption option); </dt> <dd>
<p>Clear a pointer option. Does not raise an exception if the underlying libcurl does not support the option. Use sparingly. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>CurlOption <code>option</code>
</td> <td>A <a href="etc_c_curl.html#CurlOption"><code>etc.c.curl.CurlOption</code></a> as found in the curl documentation</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="Curl.perform">CurlCode <strong id="perform">perform</strong>(ThrowOnError throwOnError = Yes.throwOnError); </dt> <dd>
<p>perform the curl request by doing the HTTP,FTP etc. as it has been setup beforehand. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>ThrowOnError <code>throwOnError</code>
</td> <td>whether to throw an exception or return a CurlCode on error</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="Curl.getTiming">CurlCode <strong id="getTiming">getTiming</strong>(CurlInfo timing, ref double val); </dt> <dd>
<p>Get the various timings like name lookup time, total time, connect time etc. The timed category is passed through the timing parameter while the timing value is stored at val. The value is usable only if res is equal to <code>etc.c.curl.CurlError.ok</code>.</p> </dd> <dt class="d_decl" id="Curl.onReceive">@property void <strong id="onReceive">onReceive</strong>(size_t delegate(InData) callback); </dt> <dd>
<p>The event handler that receives incoming data. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>size_t delegate(InData) <code>callback</code>
</td> <td>the callback that receives the <code>ubyte[]</code> data. Be sure to copy the incoming data and not store a slice.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The callback returns the incoming bytes read. If not the entire array is the request will abort. The special value HTTP.pauseRequest can be returned in order to pause the current request. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">import std.net.curl, std.stdio;
Curl curl;
curl.initialize();
curl.set(CurlOption.url, "http://dlang.org");
curl.onReceive = (ubyte[] data) { writeln("Got data", to!(const(char)[])(data)); return data.length;};
curl.perform();
</pre>  </dd> <dt class="d_decl" id="Curl.onReceiveHeader">@property void <strong id="onReceiveHeader">onReceiveHeader</strong>(void delegate(in char[]) callback); </dt> <dd>
<p>The event handler that receives incoming headers for protocols that uses headers. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>void delegate(in char[]) <code>callback</code>
</td> <td>the callback that receives the header string. Make sure the callback copies the incoming params if it needs to store it because they are references into the backend and may very likely change.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">import std.net.curl, std.stdio;
Curl curl;
curl.initialize();
curl.set(CurlOption.url, "http://dlang.org");
curl.onReceiveHeader = (in char[] header) { writeln(header); };
curl.perform();
</pre>  </dd> <dt class="d_decl" id="Curl.onSend">@property void <strong id="onSend">onSend</strong>(size_t delegate(OutData) callback); </dt> <dd>
<p>The event handler that gets called when data is needed for sending. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>size_t delegate(OutData) <code>callback</code>
</td> <td>the callback that has a <code>void[]</code> buffer to be filled</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The callback returns the number of elements in the buffer that have been filled and are ready to send. The special value <code>Curl.abortRequest</code> can be returned in order to abort the current request. The special value <code>Curl.pauseRequest</code> can be returned in order to pause the current request. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">import std.net.curl;
Curl curl;
curl.initialize();
curl.set(CurlOption.url, "http://dlang.org");

string msg = "Hello world";
curl.onSend = (void[] data)
{
    auto m = cast(void[]) msg;
    size_t length = m.length &gt; data.length ? data.length : m.length;
    if (length == 0) return 0;
    data[0 .. length] = m[0 .. length];
    msg = msg[length..$];
    return length;
};
curl.perform();
</pre>  </dd> <dt class="d_decl" id="Curl.onSeek">@property void <strong id="onSeek">onSeek</strong>(CurlSeek delegate(long, CurlSeekPos) callback); </dt> <dd>
<p>The event handler that gets called when the curl backend needs to seek the data to be sent. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>CurlSeek delegate(long, CurlSeekPos) <code>callback</code>
</td> <td>the callback that receives a seek offset and a seek position <a href="etc_c_curl.html#CurlSeekPos"><code>etc.c.curl.CurlSeekPos</code></a>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The callback returns the success state of the seeking <a href="etc_c_curl.html#CurlSeek"><code>etc.c.curl.CurlSeek</code></a> </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">import std.net.curl;
Curl curl;
curl.initialize();
curl.set(CurlOption.url, "http://dlang.org");
curl.onSeek = (long p, CurlSeekPos sp)
{
    return CurlSeek.cantseek;
};
curl.perform();
</pre>  </dd> <dt class="d_decl" id="Curl.onSocketOption">@property void <strong id="onSocketOption">onSocketOption</strong>(int delegate(curl_socket_t, CurlSockType) callback); </dt> <dd>
<p>The event handler that gets called when the net socket has been created but a <code>connect()</code> call has not yet been done. This makes it possible to set misc. socket options. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>int delegate(curl_socket_t, CurlSockType) <code>callback</code>
</td> <td>the callback that receives the socket and socket type <a href="etc_c_curl.html#CurlSockType"><code>etc.c.curl.CurlSockType</code></a>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>Return 0 from the callback to signal success, return 1 to signal error and make curl close the socket </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">import std.net.curl;
Curl curl;
curl.initialize();
curl.set(CurlOption.url, "http://dlang.org");
curl.onSocketOption = delegate int(curl_socket_t s, CurlSockType t) { /+ do stuff +/ };
curl.perform();
</pre>  </dd> <dt class="d_decl" id="Curl.onProgress">@property void <strong id="onProgress">onProgress</strong>(int delegate(size_t dlTotal, size_t dlNow, size_t ulTotal, size_t ulNow) callback); </dt> <dd>
<p>The event handler that gets called to inform of upload/download progress. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>int delegate(size_t dlTotal, size_t dlNow, size_t ulTotal, size_t ulNow) <code>callback</code>
</td> <td>the callback that receives the (total bytes to download, currently downloaded bytes, total bytes to upload, currently uploaded bytes).</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>Return 0 from the callback to signal success, return non-zero to abort transfer </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">import std.net.curl, std.stdio;
Curl curl;
curl.initialize();
curl.set(CurlOption.url, "http://dlang.org");
curl.onProgress = delegate int(size_t dltotal, size_t dlnow, size_t ultotal, size_t ulnow)
{
    writeln("Progress: downloaded bytes ", dlnow, " of ", dltotal);
    writeln("Progress: uploaded bytes ", ulnow, " of ", ultotal);
    return 0;
};
curl.perform();
</pre>  </dd> </dl> </dd> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1999&ndash;2021 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/std_net_curl.html" class="_attribution-link">https://dlang.org/phobos/std_net_curl.html</a>
  </p>
</div>
