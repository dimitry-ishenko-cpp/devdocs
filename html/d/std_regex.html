<h1>std.regex</h1>  <p><a href="https://en.wikipedia.org/wiki/Regular_expression">Regular expressions</a> are a commonly used method of pattern matching on strings, with <i>regex</i> being a catchy word for a pattern in this domain specific language. Typical problems usually solved by regular expressions include validation of user input and the ubiquitous find &amp; replace in text processing utilities. </p>
<p> <table>

<tr>
<th scope="col">Category</th> <th scope="col">Functions</th>
</tr> <tr>
<td>Matching</td> <td> <a href="#bmatch"><code>bmatch</code></a> <a href="#match"><code>match</code></a> <a href="#matchAll"><code>matchAll</code></a> <a href="#matchFirst"><code>matchFirst</code></a> </td>
</tr> <tr>
<td>Building</td> <td> <a href="#ctRegex"><code>ctRegex</code></a> <a href="#escaper"><code>escaper</code></a> <a href="#regex"><code>regex</code></a> </td>
</tr> <tr>
<td>Replace</td> <td> <a href="#replace"><code>replace</code></a> <a href="#replaceAll"><code>replaceAll</code></a> <a href="#replaceAllInto"><code>replaceAllInto</code></a> <a href="#replaceFirst"><code>replaceFirst</code></a> <a href="#replaceFirstInto"><code>replaceFirstInto</code></a> </td>
</tr> <tr>
<td>Split</td> <td> <a href="#split"><code>split</code></a> <a href="#splitter"><code>splitter</code></a> </td>
</tr> <tr>
<td>Objects</td> <td> <a href="#Captures"><code>Captures</code></a> <a href="#Regex"><code>Regex</code></a> <a href="#RegexException"><code>RegexException</code></a> <a href="#RegexMatch"><code>RegexMatch</code></a> <a href="#Splitter"><code>Splitter</code></a> <a href="#StaticRegex"><code>StaticRegex</code></a> </td>
</tr> </table> <br><br> <h3><a id="Synopsis" href="#Synopsis" class="anchor">Synopsis</a></h3> <pre data-language="d">import std.regex;
import std.stdio;
void main()
{
    // Print out all possible dd/mm/yy(yy) dates found in user input.
    auto r = regex(r"\b[0-9][0-9]?/[0-9][0-9]?/[0-9][0-9](?:[0-9][0-9])?\b");
    foreach (line; stdin.byLine)
    {
      // matchAll() returns a range that can be iterated
      // to get all subsequent matches.
      foreach (c; matchAll(line, r))
          writeln(c.hit);
    }
}
...

// Create a static regex at compile-time, which contains fast native code.
auto ctr = ctRegex!(`^.*/([^/]+)/?&amp;dollar;`);

// It works just like a normal regex:
auto c2 = matchFirst("foo/bar", ctr);   // First match found here, if any
assert(!c2.empty);   // Be sure to check if there is a match before examining contents!
assert(c2[1] == "bar");   // Captures is a range of submatches: 0 = full match.

...
// multi-pattern regex
auto multi = regex([`\d+,\d+`,`(a-z]+):(\d+)`]);
auto m = "abc:43 12,34".matchAll(multi);
assert(m.front.whichPattern == 2);
assert(m.front[1] == "abc");
assert(m.front[2] == "43");
m.popFront();
assert(m.front.whichPattern == 1);
assert(m.front[1] == "12");
...

// The result of the `matchAll/matchFirst` is directly testable with if/assert/while.
// e.g. test if a string consists of letters:
assert(matchFirst("Letter", `^\p{L}+&amp;dollar;`));
</pre> <br><br> <h3><a id="Syntax and general information" href="#Syntax%20and%20general%20information" class="anchor">Syntax and general information</a></h3> The general usage guideline is to keep regex complexity on the side of simplicity, as its capabilities reside in purely character-level manipulation. As such it's ill-suited for tasks involving higher level invariants like matching an integer number <em class="u">bounded</em> in an [a,b] interval. Checks of this sort of are better addressed by additional post-processing. <br><br> The basic syntax shouldn't surprise experienced users of regular expressions. For an introduction to <code>std.regex</code> see a <a href="http://dlang.org/regular-expression.html">short tour</a> of the module API and its abilities. <br><br> There are other web resources on regular expressions to help newcomers, and a good <a href="http://www.regular-expressions.info">reference with tutorial</a> can easily be found. <br><br> This library uses a remarkably common ECMAScript syntax flavor with the following extensions: <ul> <li>Named subexpressions, with Python syntax. </li> <li>Unicode properties such as Scripts, Blocks and common binary properties e.g Alphabetic, White_Space, Hex_Digit etc.</li> <li>Arbitrary length and complexity lookbehind, including lookahead in lookbehind and vise-versa.</li> </ul> <br><br> <h3> Pattern syntax </h3> <i>std.regex operates on codepoint level, 'character' in this table denotes a single Unicode codepoint.</i> <table> <tr>
<td>Pattern element</td> <td>Semantics </td> </tr> <tr>
<td>Atoms</td> <td>Match single characters </td> </tr> <tr>
<td><i>any character except [{|*+?()^$ </i></td> <td>Matches the character itself. </td> </tr> <tr>
<td><i>. </i></td> <td>In single line mode matches any character. Otherwise it matches any character except '\n' and '\r'. </td> </tr> <tr>
<td><i>[class] </i></td> <td>Matches a single character that belongs to this character class. </td> </tr> <tr>
<td><i>[^class] </i></td> <td>Matches a single character that does <em class="u">not</em> belong to this character class.</td> </tr> <tr>
<td><i>\cC </i></td> <td>Matches the control character corresponding to letter C</td> </tr> <tr>
<td><i>\xXX </i></td> <td>Matches a character with hexadecimal value of XX. </td> </tr> <tr>
<td><i>\uXXXX </i></td> <td>Matches a character with hexadecimal value of XXXX. </td> </tr> <tr>
<td><i>\U00YYYYYY </i></td> <td>Matches a character with hexadecimal value of YYYYYY. </td> </tr> <tr>
<td><i>\f </i></td> <td>Matches a formfeed character. </td> </tr> <tr>
<td><i>\n </i></td> <td>Matches a linefeed character. </td> </tr> <tr>
<td><i>\r </i></td> <td>Matches a carriage return character. </td> </tr> <tr>
<td><i>\t </i></td> <td>Matches a tab character. </td> </tr> <tr>
<td><i>\v </i></td> <td>Matches a vertical tab character. </td> </tr> <tr>
<td><i>\d </i></td> <td>Matches any Unicode digit. </td> </tr> <tr>
<td><i>\D </i></td> <td>Matches any character except Unicode digits. </td> </tr> <tr>
<td><i>\w </i></td> <td>Matches any word character (note: this includes numbers).</td> </tr> <tr>
<td><i>\W </i></td> <td>Matches any non-word character.</td> </tr> <tr>
<td><i>\s </i></td> <td>Matches whitespace, same as \p{White_Space}.</td> </tr> <tr>
<td><i>\S </i></td> <td>Matches any character except those recognized as <i>\s </i>. </td> </tr> <tr>
<td><i>\\ </i></td> <td>Matches \ character. </td> </tr> <tr>
<td><i>\c where c is one of [|*+?() </i></td> <td>Matches the character c itself. </td> </tr> <tr>
<td><i>\p{PropertyName} </i></td> <td>Matches a character that belongs to the Unicode PropertyName set. Single letter abbreviations can be used without surrounding {,}. </td> </tr> <tr>
<td><i> \P{PropertyName} </i></td> <td>Matches a character that does not belong to the Unicode PropertyName set. Single letter abbreviations can be used without surrounding {,}. </td> </tr> <tr>
<td><i>\p{InBasicLatin} </i></td> <td>Matches any character that is part of the BasicLatin Unicode <em class="u">block</em>.</td> </tr> <tr>
<td><i>\P{InBasicLatin} </i></td> <td>Matches any character except ones in the BasicLatin Unicode <em class="u">block</em>.</td> </tr> <tr>
<td><i>\p{Cyrillic} </i></td> <td>Matches any character that is part of Cyrillic <em class="u">script</em>.</td> </tr> <tr>
<td><i>\P{Cyrillic} </i></td> <td>Matches any character except ones in Cyrillic <em class="u">script</em>.</td> </tr> <tr>
<td>Quantifiers</td> <td>Specify repetition of other elements</td> </tr> <tr>
<td><i>* </i></td> <td>Matches previous character/subexpression 0 or more times. Greedy version - tries as many times as possible.</td> </tr> <tr>
<td><i>*? </i></td> <td>Matches previous character/subexpression 0 or more times. Lazy version - stops as early as possible.</td> </tr> <tr>
<td><i>+ </i></td> <td>Matches previous character/subexpression 1 or more times. Greedy version - tries as many times as possible.</td> </tr> <tr>
<td><i>+? </i></td> <td>Matches previous character/subexpression 1 or more times. Lazy version - stops as early as possible.</td> </tr> <tr>
<td><i>{n} </i></td> <td>Matches previous character/subexpression exactly n times. </td> </tr> <tr>
<td><i>{n,} </i></td> <td>Matches previous character/subexpression n times or more. Greedy version - tries as many times as possible. </td> </tr> <tr>
<td><i>{n,}? </i></td> <td>Matches previous character/subexpression n times or more. Lazy version - stops as early as possible.</td> </tr> <tr>
<td><i>{n,m} </i></td> <td>Matches previous character/subexpression n to m times. Greedy version - tries as many times as possible, but no more than m times. </td> </tr> <tr>
<td><i>{n,m}? </i></td> <td>Matches previous character/subexpression n to m times. Lazy version - stops as early as possible, but no less then n times.</td> </tr> <tr>
<td>Other</td> <td>Subexpressions &amp; alternations </td> </tr> <tr>
<td><i>(regex) </i></td> <td> Matches subexpression regex, saving matched portion of text for later retrieval. </td> </tr> <tr>
<td><i>(?#comment) </i></td> <td>An inline comment that is ignored while matching.</td> </tr> <tr>
<td><i>(?:regex) </i></td> <td>Matches subexpression regex, <em class="u">not</em> saving matched portion of text. Useful to speed up matching. </td> </tr> <tr>
<td><i>A|B </i></td> <td>Matches subexpression A, or failing that, matches B. </td> </tr> <tr>
<td><i>(?P&lt;name&gt;regex) </i></td> <td>Matches named subexpression regex labeling it with name 'name'. When referring to a matched portion of text, names work like aliases in addition to direct numbers. </td> </tr> <tr>
<td>Assertions</td> <td>Match position rather than character </td> </tr> <tr>
<td><i>^ </i></td> <td>Matches at the begining of input or line (in multiline mode).</td> </tr> <tr>
<td><i>$ </i></td> <td>Matches at the end of input or line (in multiline mode). </td> </tr> <tr>
<td><i>\b </i></td> <td>Matches at word boundary. </td> </tr> <tr>
<td><i>\B </i></td> <td>Matches when <em class="u">not</em> at word boundary. </td> </tr> <tr>
<td><i>(?=regex) </i></td> <td>Zero-width lookahead assertion. Matches at a point where the subexpression regex could be matched starting from the current position. </td> </tr> <tr>
<td><i>(?!regex) </i></td> <td>Zero-width negative lookahead assertion. Matches at a point where the subexpression regex could <em class="u">not</em> be matched starting from the current position. </td> </tr> <tr>
<td><i>(?&lt;=regex) </i></td> <td>Zero-width lookbehind assertion. Matches at a point where the subexpression regex could be matched ending at the current position (matching goes backwards). </td> </tr> <tr>
<td><i> (?&lt;!regex) </i></td> <td>Zero-width negative lookbehind assertion. Matches at a point where the subexpression regex could <em class="u">not</em> be matched ending at the current position (matching goes backwards). </td> </tr> </table> <br><br> <h3> Character classes </h3> <table> <tr>
<td>Pattern element</td> <td>Semantics </td> </tr> <tr>
<td><i>Any atom </i></td> <td>Has the same meaning as outside of a character class, except for ] which must be written as \]</td> </tr> <tr>
<td><i>a-z </i></td> <td>Includes characters a, b, c, ..., z. </td> </tr> <tr>
<td><i>[a||b], [a--b], [a~~b], [a&amp;&amp;b] </i></td> <td> Where a, b are arbitrary classes, means union, set difference, symmetric set difference, and intersection respectively. <i>Any sequence of character class elements implicitly forms a union.</i> </td> </tr> </table> <br><br> <h3> Regex flags </h3> <table> <tr>
<td>Flag</td> <td>Semantics </td> </tr> <tr>
<td><i>g </i></td> <td>Global regex, repeat over the whole input. </td> </tr> <tr>
<td><i>i </i></td> <td>Case insensitive matching. </td> </tr> <tr>
<td><i>m </i></td> <td>Multi-line mode, match ^, $ on start and end line separators as well as start and end of input.</td> </tr> <tr>
<td><i>s </i></td> <td>Single-line mode, makes . match '\n' and '\r' as well. </td> </tr> <tr>
<td><i>x </i></td> <td>Free-form syntax, ignores whitespace in pattern, useful for formatting complex regular expressions. </td> </tr> </table> <br><br> <h3><a id="Unicode support" href="#Unicode%20support" class="anchor">Unicode support</a></h3> <br><br> This library provides full Level 1 support* according to <a href="http://unicode.org/reports/tr18/">UTS 18</a>. Specifically: <ul> <li>1.1 Hex notation via any of \uxxxx, \U00YYYYYY, \xZZ.</li> <li>1.2 Unicode properties.</li> <li>1.3 Character classes with set operations.</li> <li>1.4 Word boundaries use the full set of "word" characters.</li> <li>1.5 Using simple casefolding to match case insensitively across the full range of codepoints.</li> <li>1.6 Respecting line breaks as any of \u000A | \u000B | \u000C | \u000D | \u0085 | \u2028 | \u2029 | \u000D\u000A.</li> <li>1.7 Operating on codepoint level.</li> </ul> *With exception of point 1.1.1, as of yet, normalization of input is expected to be enforced by user. <br><br> <h3><a id="Replace format string" href="#Replace%20format%20string" class="anchor">Replace format string</a></h3> <br><br> A set of functions in this module that do the substitution rely on a simple format to guide the process. In particular the table below applies to the <code>format</code> argument of <a href="#replaceFirst"><code>replaceFirst</code></a> and <a href="#replaceAll"><code>replaceAll</code></a>. <br><br> The format string can reference parts of match using the following notation. <table> <tr>
<td>Format specifier</td> <td>Replaced by </td> </tr> <tr>
<td><i>&amp;dollar;&amp; </i></td> <td>the whole match. </td> </tr> <tr>
<td><i>&amp;dollar;` </i></td> <td>part of input <i>preceding</i> the match. </td> </tr> <tr>
<td><i>$' </i></td> <td>part of input <i>following</i> the match. </td> </tr> <tr>
<td><i>$$ </i></td> <td>'$' character. </td> </tr> <tr>
<td><i>\c , where c is any character </i></td> <td>the character c itself. </td> </tr> <tr>
<td><i>\\ </i></td> <td>'\' character. </td> </tr> <tr>
<td><i>&amp;dollar;1 .. &amp;dollar;99 </i></td> <td>submatch number 1 to 99 respectively. </td> </tr> </table> <br><br> <h3><a id="Slicing and zero memory allocations orientation" href="#Slicing%20and%20zero%20memory%20allocations%20orientation" class="anchor">Slicing and zero memory allocations orientation</a></h3> <br><br> All matches returned by pattern matching functionality in this library are slices of the original input. The notable exception is the <code>replace</code> family of functions that generate a new string from the input. <br><br> In cases where producing the replacement is the ultimate goal <a href="#replaceFirstInto"><code>replaceFirstInto</code></a> and <a href="#replaceAllInto"><code>replaceAllInto</code></a> could come in handy as functions that avoid allocations even for replacement. </p> <dl>
<dt>License:</dt>
<dd>
<a href="http://boost.org/LICENSE_1_0.txt">Boost License 1.0</a>. </dd>
</dl> <dl>
<dt>Authors:</dt>
<dd>Dmitry Olshansky,  API and utility constructs are modeled after the original <code>std.regex</code> by Walter Bright and Andrei Alexandrescu. </dd>
</dl> <dl>
<dt>Source</dt>
<dd> <span class="phobos_src"><a class="https" href="https://github.com/dlang/phobos/blob/master/std/regex/package.d">std/regex/package.d</a></span> </dd>
</dl> <dl>
<dt class="d_decl" id="Regex">template <strong id="Regex">Regex</strong>(Char)</dt> <dd>
<p><code>Regex</code> object holds regular expression pattern in compiled form. </p>
<p>Instances of this object are constructed via calls to <code>regex</code>. This is an intended form for caching and storage of frequently used regular expressions. </p> <dl>
<dt>Example</dt>
<dd> Test if this object doesn't contain any compiled pattern. </dd>
</dl>
<pre data-language="d">Regex!char r;
assert(r.empty);
r = regex(""); // Note: "" is a valid regex pattern.
assert(!r.empty);
</pre>  Getting a range of all the named captures in the regex. <pre data-language="d">import std.range;
import std.algorithm;

auto re = regex(`(?P&lt;name&gt;\w+) = (?P&lt;var&gt;\d+)`);
auto nc = re.namedCaptures;
static assert(isRandomAccessRange!(typeof(nc)));
assert(!nc.empty);
assert(nc.length == 2);
assert(nc.equal(["name", "var"]));
assert(nc[0] == "name");
assert(nc[1..$].equal(["var"]));
</pre>  </dd> <dt class="d_decl" id="StaticRegex">alias <strong id="StaticRegex">StaticRegex</strong> = Regex(Char); </dt> <dd>
<p>A <code>StaticRegex</code> is <code>Regex</code> object that contains D code specially generated at compile-time to speed up matching. </p>
<p>No longer used, kept as alias to Regex for backwards compatibility.</p> </dd> <dt class="d_decl" id="regex">@trusted auto <strong id="regex">regex</strong>(S : C[], C)(const S[] patterns, const(char)[] flags = "")<br><small>  Constraints: if (isSomeString!S); </small><br><br>@trusted auto <strong id="regex">regex</strong>(S)(S pattern, const(char)[] flags = "")<br><small>  Constraints: if (isSomeString!S); </small>
</dt> <dd>
<p>Compile regular expression pattern for the later execution. </p>
<dl>
<dt>Returns:</dt>
<dd>
<code>Regex</code> object that works on inputs having the same character width as <code>pattern</code>. </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>S <code>pattern</code>
</td> <td>A single regular expression to match.</td>
</tr> <tr>
<td>S[] <code>patterns</code>
</td> <td>An array of regular expression strings. The resulting <code>Regex</code> object will match any expression; use <a href="#whichPattern"><code>whichPattern</code></a> to know which.</td>
</tr> <tr>
<td>const(char)[] <code>flags</code>
</td> <td>The attributes (g, i, m, s and x accepted)</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<code>RegexException</code> if there were any errors during compilation.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">void test(S)()
{
    // multi-pattern regex example
    S[] arr = [`([a-z]+):(\d+)`, `(\d+),\d+`];
    auto multi = regex(arr); // multi regex
    S str = "abc:43 12,34";
    auto m = str.matchAll(multi);
    writeln(m.front.whichPattern); // 1
    writeln(m.front[1]); // "abc"
    writeln(m.front[2]); // "43"
    m.popFront();
    writeln(m.front.whichPattern); // 2
    writeln(m.front[1]); // "12"
}

import std.meta : AliasSeq;
static foreach (C; AliasSeq!(string, wstring, dstring))
    // Test with const array of patterns - see https://issues.dlang.org/show_bug.cgi?id=20301
    static foreach (S; AliasSeq!(C, const C, immutable C))
        test!S();
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="ctRegex">enum auto <strong id="ctRegex">ctRegex</strong>(alias pattern, alias flags = []); </dt> <dd>
<p>Compile regular expression using CTFE and generate optimized native machine code for matching it. </p>
<dl>
<dt>Returns:</dt>
<dd>StaticRegex object for faster matching. </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>pattern</td> <td>Regular expression</td>
</tr> <tr>
<td>flags</td> <td>The attributes (g, i, m, s and x accepted)</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="Captures">struct <strong id="Captures">Captures</strong>(R) if (isSomeString!R); </dt> <dd>
<p><code>Captures</code> object contains submatches captured during a call to <code>match</code> or iteration over <code>RegexMatch</code> range. </p>
<p>First element of range is the whole match.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.range.primitives : popFrontN;

auto c = matchFirst("@abc#", regex(`(\w)(\w)(\w)`));
assert(c.pre == "@"); // Part of input preceding match
assert(c.post == "#"); // Immediately after match
assert(c.hit == c[0] &amp;&amp; c.hit == "abc"); // The whole match
writeln(c[2]); // "b"
writeln(c.front); // "abc"
c.popFront();
writeln(c.front); // "a"
writeln(c.back); // "c"
c.popBack();
writeln(c.back); // "b"
popFrontN(c, 2);
assert(c.empty);

assert(!matchFirst("nothing", "something"));

// Captures that are not matched will be null.
c = matchFirst("ac", regex(`a(b)?c`));
assert(c);
assert(!c[1]);
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="Captures.pre">@property R <strong id="pre">pre</strong>(); </dt> <dd>
<p>Slice of input prior to the match.</p> </dd> <dt class="d_decl" id="Captures.post">@property R <strong id="post">post</strong>(); </dt> <dd>
<p>Slice of input immediately after the match.</p> </dd> <dt class="d_decl" id="Captures.hit">@property R <strong id="hit">hit</strong>(); </dt> <dd>
<p>Slice of matched portion of input.</p> </dd> <dt class="d_decl" id="Captures.front">@property R <strong id="front">front</strong>(); <br><br>@property R <strong id="back">back</strong>(); <br><br>void <strong id="popFront">popFront</strong>(); <br><br>void <strong id="popBack">popBack</strong>(); <br><br>const @property bool <strong id="empty">empty</strong>(); <br><br>inout inout(R) <strong id="opIndex">opIndex</strong>()(size_t i); </dt> <dd>
<p>Range interface.</p> </dd> <dt class="d_decl" id="Captures.opCast">const nothrow @safe bool <strong id="opCast">opCast</strong>(T : bool)(); </dt> <dd>
<p>Explicit cast to bool. Useful as a shorthand for !(x.empty) in if and assert statements. </p>
<p><pre data-language="d">import std.regex;

assert(!matchFirst("nothing", "something"));
</pre> </p> </dd> <dt class="d_decl" id="Captures.whichPattern">const nothrow @property @safe int <strong id="whichPattern">whichPattern</strong>(); </dt> <dd>
<p>Number of pattern matched counting, where 1 - the first pattern. Returns 0 on no match.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.regex;
writeln(matchFirst("abc", "[0-9]+", "[a-z]+").whichPattern); // 2
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Captures.opIndex.2">R <strong id="opIndex">opIndex</strong>(String)(String i)<br><small>  Constraints: if (isSomeString!String); </small>
</dt> <dd>
<p>Lookup named submatch. </p>
<p><pre data-language="d">import std.regex;
import std.range;

auto c = matchFirst("a = 42;", regex(`(?P&lt;var&gt;\w+)\s*=\s*(?P&lt;value&gt;\d+);`));
assert(c["var"] == "a");
assert(c["value"] == "42");
popFrontN(c, 2);
//named groups are unaffected by range primitives
assert(c["var"] =="a");
assert(c.front == "42");
</pre> </p> </dd> <dt class="d_decl" id="Captures.length">const @property size_t <strong id="length">length</strong>(); </dt> <dd>
<p>Number of matches in this object.</p> </dd> <dt class="d_decl" id="Captures.captures">@property ref auto <strong id="captures">captures</strong>(); </dt> <dd>
<p>A hook for compatibility with original std.regex.</p> </dd> </dl> </dd> <dt class="d_decl" id="RegexMatch">struct <strong id="RegexMatch">RegexMatch</strong>(R) if (isSomeString!R); </dt> <dd>
<p>A regex engine state, as returned by <code>match</code> family of functions. </p>
<p>Effectively it's a forward range of Captures!R, produced by lazily searching for matches in a given input.</p> <dl>
<dt class="d_decl" id="RegexMatch.pre">@property R <strong id="pre">pre</strong>(); <br><br>@property R <strong id="post">post</strong>(); <br><br>@property R <strong id="hit">hit</strong>(); </dt> <dd>
<p>Shorthands for front.pre, front.post, front.hit.</p> </dd> <dt class="d_decl" id="RegexMatch.front">inout @property inout(Captures!R) <strong id="front">front</strong>(); <br><br>void <strong id="popFront">popFront</strong>(); <br><br>auto <strong id="save">save</strong>(); </dt> <dd>
<p> Functionality for processing subsequent matches of global regexes via range interface: <pre data-language="d">import std.regex;
auto m = matchAll("Hello, world!", regex(`\w+`));
assert(m.front.hit == "Hello");
m.popFront();
assert(m.front.hit == "world");
m.popFront();
assert(m.empty);
</pre> </p> </dd> <dt class="d_decl" id="RegexMatch.empty">const @property bool <strong id="empty">empty</strong>(); </dt> <dd>
<p>Test if this match object is empty.</p> </dd> <dt class="d_decl" id="RegexMatch.opCast">T <strong id="opCast">opCast</strong>(T : bool)(); </dt> <dd>
<p>Same as !(x.empty), provided for its convenience in conditional statements.</p> </dd> <dt class="d_decl" id="RegexMatch.captures">inout @property inout(Captures!R) <strong id="captures">captures</strong>(); </dt> <dd>
<p>Same as .front, provided for compatibility with original std.regex.</p> </dd> </dl> </dd> <dt class="d_decl" id="match">auto <strong id="match">match</strong>(R, RegEx)(R input, RegEx re)<br><small>  Constraints: if (isSomeString!R &amp;&amp; isRegexFor!(RegEx, R)); </small><br><br>auto <strong id="match">match</strong>(R, String)(R input, String re)<br><small>  Constraints: if (isSomeString!R &amp;&amp; isSomeString!String); </small>
</dt> <dd>
<p>Start matching <code>input</code> to regex pattern <code>re</code>, using Thompson NFA matching scheme. </p>
<p>The use of this function is <span class="red">discouraged</span> - use either of <a href="#matchAll"><code>matchAll</code></a> or <a href="#matchFirst"><code>matchFirst</code></a>. <br><br> Delegating the kind of operation to "g" flag is soon to be phased out along with the ability to choose the exact matching scheme. The choice of matching scheme to use depends highly on the pattern kind and can done automatically on case by case basis. </p> <dl>
<dt>Returns:</dt>
<dd>a <code>RegexMatch</code> object holding engine state after first match.</dd>
</dl> </dd> <dt class="d_decl" id="matchFirst">auto <strong id="matchFirst">matchFirst</strong>(R, RegEx)(R input, RegEx re)<br><small>  Constraints: if (isSomeString!R &amp;&amp; isRegexFor!(RegEx, R)); </small><br><br>auto <strong id="matchFirst">matchFirst</strong>(R, String)(R input, String re)<br><small>  Constraints: if (isSomeString!R &amp;&amp; isSomeString!String); </small><br><br>auto <strong id="matchFirst">matchFirst</strong>(R, String)(R input, String[] re...)<br><small>  Constraints: if (isSomeString!R &amp;&amp; isSomeString!String); </small>
</dt> <dd>
<p>Find the first (leftmost) slice of the <code>input</code> that matches the pattern <code>re</code>. This function picks the most suitable regular expression engine depending on the pattern properties. </p>
<p><code>re</code> parameter can be one of three types: <ul> <li>Plain string(s), in which case it's compiled to bytecode before matching. </li> <li>Regex!char (wchar/dchar) that contains a pattern in the form of compiled bytecode. </li> <li>StaticRegex!char (wchar/dchar) that contains a pattern in the form of compiled native machine code. </li> </ul> </p> <dl>
<dt>Returns:</dt>
<dd>
<a href="#Captures"><code>Captures</code></a> containing the extent of a match together with all submatches if there was a match, otherwise an empty <a href="#Captures"><code>Captures</code></a> object.</dd>
</dl> </dd> <dt class="d_decl" id="matchAll">auto <strong id="matchAll">matchAll</strong>(R, RegEx)(R input, RegEx re)<br><small>  Constraints: if (isSomeString!R &amp;&amp; isRegexFor!(RegEx, R)); </small><br><br>auto <strong id="matchAll">matchAll</strong>(R, String)(R input, String re)<br><small>  Constraints: if (isSomeString!R &amp;&amp; isSomeString!String); </small><br><br>auto <strong id="matchAll">matchAll</strong>(R, String)(R input, String[] re...)<br><small>  Constraints: if (isSomeString!R &amp;&amp; isSomeString!String); </small>
</dt> <dd>
<p>Initiate a search for all non-overlapping matches to the pattern <code>re</code> in the given <code>input</code>. The result is a lazy range of matches generated as they are encountered in the input going left to right. </p>
<p>This function picks the most suitable regular expression engine depending on the pattern properties. <br><br> <code>re</code> parameter can be one of three types: <ul> <li>Plain string(s), in which case it's compiled to bytecode before matching. </li> <li>Regex!char (wchar/dchar) that contains a pattern in the form of compiled bytecode. </li> <li>StaticRegex!char (wchar/dchar) that contains a pattern in the form of compiled native machine code. </li> </ul> </p> <dl>
<dt>Returns:</dt>
<dd>
<a href="#RegexMatch"><code>RegexMatch</code></a> object that represents matcher state after the first match was found or an empty one if not present.</dd>
</dl> </dd> <dt class="d_decl" id="bmatch">auto <strong id="bmatch">bmatch</strong>(R, RegEx)(R input, RegEx re)<br><small>  Constraints: if (isSomeString!R &amp;&amp; isRegexFor!(RegEx, R)); </small><br><br>auto <strong id="bmatch">bmatch</strong>(R, String)(R input, String re)<br><small>  Constraints: if (isSomeString!R &amp;&amp; isSomeString!String); </small>
</dt> <dd>
<p>Start matching of <code>input</code> to regex pattern <code>re</code>, using traditional <a href="https://en.wikipedia.org/wiki/Backtracking"> backtracking</a> matching scheme. </p>
<p>The use of this function is <span class="red">discouraged</span> - use either of <a href="#matchAll"><code>matchAll</code></a> or <a href="#matchFirst"><code>matchFirst</code></a>. <br><br> Delegating the kind of operation to "g" flag is soon to be phased out along with the ability to choose the exact matching scheme. The choice of matching scheme to use depends highly on the pattern kind and can done automatically on case by case basis. </p> <dl>
<dt>Returns:</dt>
<dd>a <code>RegexMatch</code> object holding engine state after first match.</dd>
</dl> </dd> <dt class="d_decl" id="replaceFirst">R <strong id="replaceFirst">replaceFirst</strong>(R, C, RegEx)(R input, RegEx re, const(C)[] format)<br><small>  Constraints: if (isSomeString!R &amp;&amp; is(C : dchar) &amp;&amp; isRegexFor!(RegEx, R)); </small>
</dt> <dd>
<p>Construct a new string from <code>input</code> by replacing the first match with a string generated from it according to the <code>format</code> specifier. </p>
<p>To replace all matches use <a href="#replaceAll"><code>replaceAll</code></a>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>input</code>
</td> <td>string to search</td>
</tr> <tr>
<td>RegEx <code>re</code>
</td> <td>compiled regular expression to use</td>
</tr> <tr>
<td>const(C)[] <code>format</code>
</td> <td>format string to generate replacements from, see <a href="#Replace%20format%20string">the format string</a>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A string of the same type with the first match (if any) replaced. If no match is found returns the input string itself.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(replaceFirst("noon", regex("n"), "[&amp;dollar;&amp;]")); // "[n]oon"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="replaceFirst">R <strong id="replaceFirst">replaceFirst</strong>(alias fun, R, RegEx)(R input, RegEx re)<br><small>  Constraints: if (isSomeString!R &amp;&amp; isRegexFor!(RegEx, R)); </small>
</dt> <dd>
<p>This is a general replacement tool that construct a new string by replacing matches of pattern <code>re</code> in the <code>input</code>. Unlike the other overload there is no format string instead captures are passed to to a user-defined functor <code>fun</code> that returns a new string to use as replacement. </p>
<p>This version replaces the first match in <code>input</code>, see <a href="#replaceAll"><code>replaceAll</code></a> to replace the all of the matches. </p> <dl>
<dt>Returns:</dt>
<dd>A new string of the same type as <code>input</code> with all matches replaced by return values of <code>fun</code>. If no matches found returns the <code>input</code> itself.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.conv : to;
string list = "#21 out of 46";
string newList = replaceFirst!(cap =&gt; to!string(to!int(cap.hit)+1))
    (list, regex(`[0-9]+`));
writeln(newList); // "#22 out of 46"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="replaceFirstInto">@trusted void <strong id="replaceFirstInto">replaceFirstInto</strong>(Sink, R, C, RegEx)(ref Sink sink, R input, RegEx re, const(C)[] format)<br><small>  Constraints: if (isOutputRange!(Sink, dchar) &amp;&amp; isSomeString!R &amp;&amp; is(C : dchar) &amp;&amp; isRegexFor!(RegEx, R)); </small><br><br>@trusted void <strong id="replaceFirstInto">replaceFirstInto</strong>(alias fun, Sink, R, RegEx)(Sink sink, R input, RegEx re)<br><small>  Constraints: if (isOutputRange!(Sink, dchar) &amp;&amp; isSomeString!R &amp;&amp; isRegexFor!(RegEx, R)); </small>
</dt> <dd>
<p>A variation on <a href="#replaceFirst"><code>replaceFirst</code></a> that instead of allocating a new string on each call outputs the result piece-wise to the <code>sink</code>. In particular this enables efficient construction of a final output incrementally. </p>
<p>Like in <a href="#replaceFirst"><code>replaceFirst</code></a> family of functions there is an overload for the substitution guided by the <code>format</code> string and the one with the user defined callback.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.array;
string m1 = "first message\n";
string m2 = "second message\n";
auto result = appender!string();
replaceFirstInto(result, m1, regex(`([a-z]+) message`), "&amp;dollar;1");
//equivalent of the above with user-defined callback
replaceFirstInto!(cap=&gt;cap[1])(result, m2, regex(`([a-z]+) message`));
writeln(result.data); // "first\nsecond\n"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="replaceAll">@trusted R <strong id="replaceAll">replaceAll</strong>(R, C, RegEx)(R input, RegEx re, const(C)[] format)<br><small>  Constraints: if (isSomeString!R &amp;&amp; is(C : dchar) &amp;&amp; isRegexFor!(RegEx, R)); </small>
</dt> <dd>
<p>Construct a new string from <code>input</code> by replacing all of the fragments that match a pattern <code>re</code> with a string generated from the match according to the <code>format</code> specifier. </p>
<p>To replace only the first match use <a href="#replaceFirst"><code>replaceFirst</code></a>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>input</code>
</td> <td>string to search</td>
</tr> <tr>
<td>RegEx <code>re</code>
</td> <td>compiled regular expression to use</td>
</tr> <tr>
<td>const(C)[] <code>format</code>
</td> <td>format string to generate replacements from, see <a href="#Replace%20format%20string">the format string</a>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A string of the same type as <code>input</code> with the all of the matches (if any) replaced. If no match is found returns the input string itself.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">// insert comma as thousands delimiter
auto re = regex(r"(?&lt;=\d)(?=(\d\d\d)+\b)","g");
writeln(replaceAll("12000 + 42100 = 54100", re, ",")); // "12,000 + 42,100 = 54,100"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="replaceAll">@trusted R <strong id="replaceAll">replaceAll</strong>(alias fun, R, RegEx)(R input, RegEx re)<br><small>  Constraints: if (isSomeString!R &amp;&amp; isRegexFor!(RegEx, R)); </small>
</dt> <dd>
<p>This is a general replacement tool that construct a new string by replacing matches of pattern <code>re</code> in the <code>input</code>. Unlike the other overload there is no format string instead captures are passed to to a user-defined functor <code>fun</code> that returns a new string to use as replacement. </p>
<p>This version replaces all of the matches found in <code>input</code>, see <a href="#replaceFirst"><code>replaceFirst</code></a> to replace the first match only. </p> <dl>
<dt>Returns:</dt>
<dd>A new string of the same type as <code>input</code> with all matches replaced by return values of <code>fun</code>. If no matches found returns the <code>input</code> itself. </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>input</code>
</td> <td>string to search</td>
</tr> <tr>
<td>RegEx <code>re</code>
</td> <td>compiled regular expression</td>
</tr> <tr>
<td>fun</td> <td>delegate to use</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">string baz(Captures!(string) m)
{
    import std.string : toUpper;
    return toUpper(m.hit);
}
// Capitalize the letters 'a' and 'r':
auto s = replaceAll!(baz)("Strap a rocket engine on a chicken.",
        regex("[ar]"));
writeln(s); // "StRAp A Rocket engine on A chicken."
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="replaceAllInto">@trusted void <strong id="replaceAllInto">replaceAllInto</strong>(Sink, R, C, RegEx)(Sink sink, R input, RegEx re, const(C)[] format)<br><small>  Constraints: if (isOutputRange!(Sink, dchar) &amp;&amp; isSomeString!R &amp;&amp; is(C : dchar) &amp;&amp; isRegexFor!(RegEx, R)); </small><br><br>@trusted void <strong id="replaceAllInto">replaceAllInto</strong>(alias fun, Sink, R, RegEx)(Sink sink, R input, RegEx re)<br><small>  Constraints: if (isOutputRange!(Sink, dchar) &amp;&amp; isSomeString!R &amp;&amp; isRegexFor!(RegEx, R)); </small>
</dt> <dd>
<p>A variation on <a href="#replaceAll"><code>replaceAll</code></a> that instead of allocating a new string on each call outputs the result piece-wise to the <code>sink</code>. In particular this enables efficient construction of a final output incrementally. </p>
<p>As with <a href="#replaceAll"><code>replaceAll</code></a> there are 2 overloads - one with a format string, the other one with a user defined functor.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">// insert comma as thousands delimiter in fifty randomly produced big numbers
import std.array, std.conv, std.random, std.range;
static re = regex(`(?&lt;=\d)(?=(\d\d\d)+\b)`, "g");
auto sink = appender!(char [])();
enum ulong min = 10UL ^^ 10, max = 10UL ^^ 19;
foreach (i; 0 .. 50)
{
    sink.clear();
    replaceAllInto(sink, text(uniform(min, max)), re, ",");
    foreach (pos; iota(sink.data.length - 4, 0, -4))
        writeln(sink.data[pos]); // ','
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="replace">R <strong id="replace">replace</strong>(alias scheme = match, R, C, RegEx)(R input, RegEx re, const(C)[] format)<br><small>  Constraints: if (isSomeString!R &amp;&amp; isRegexFor!(RegEx, R)); </small><br><br>R <strong id="replace">replace</strong>(alias fun, R, RegEx)(R input, RegEx re)<br><small>  Constraints: if (isSomeString!R &amp;&amp; isRegexFor!(RegEx, R)); </small>
</dt> <dd>
<p>Old API for replacement, operation depends on flags of pattern <code>re</code>. With "g" flag it performs the equivalent of <a href="#replaceAll"><code>replaceAll</code></a> otherwise it works the same as <a href="#replaceFirst"><code>replaceFirst</code></a>. </p>
<p>The use of this function is <span class="red">discouraged</span>, please use <a href="#replaceAll"><code>replaceAll</code></a> or <a href="#replaceFirst"><code>replaceFirst</code></a> explicitly.</p> </dd> <dt class="d_decl" id="Splitter">struct <strong id="Splitter">Splitter</strong>(Flag!"keepSeparators" keepSeparators = No.keepSeparators, Range, alias RegEx = Regex) if (isSomeString!Range &amp;&amp; isRegexFor!(RegEx, Range)); <br><br>Splitter!(keepSeparators, Range, RegEx) <strong id="splitter">splitter</strong>(Flag!"keepSeparators" keepSeparators = No.keepSeparators, Range, RegEx)(Range r, RegEx pat)<br><small>  Constraints: if (is(BasicElementOf!Range : dchar) &amp;&amp; isRegexFor!(RegEx, Range)); </small>
</dt> <dd>
<p>Splits a string <code>r</code> using a regular expression <code>pat</code> as a separator. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>keepSeparators</td> <td>flag to specify if the matches should be in the resulting range</td>
</tr> <tr>
<td>Range <code>r</code>
</td> <td>the string to split</td>
</tr> <tr>
<td>RegEx <code>pat</code>
</td> <td>the pattern to split on</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A lazy range of strings</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
auto s1 = ", abc, de,  fg, hi, ";
assert(equal(splitter(s1, regex(", *")),
    ["", "abc", "de", "fg", "hi", ""]));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Split on a pattern, but keep the matches in the resulting range <pre data-language="d">import std.algorithm.comparison : equal;
import std.typecons : Yes;

auto pattern = regex(`([\.,])`);

assert("2003.04.05"
    .splitter!(Yes.keepSeparators)(pattern)
    .equal(["2003", ".", "04", ".", "05"]));

assert(",1,2,3"
    .splitter!(Yes.keepSeparators)(pattern)
    .equal([",", "1", ",", "2", ",", "3"]));
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="Splitter.front">@property Range <strong id="front">front</strong>(); <br><br>@property bool <strong id="empty">empty</strong>(); <br><br>void <strong id="popFront">popFront</strong>(); <br><br>@property auto <strong id="save">save</strong>(); </dt> <dd>
<p>Forward range primitives.</p> </dd> </dl> </dd> <dt class="d_decl" id="split">@trusted String[] <strong id="split">split</strong>(String, RegEx)(String input, RegEx rx)<br><small>  Constraints: if (isSomeString!String &amp;&amp; isRegexFor!(RegEx, String)); </small>
</dt> <dd>
<p>An eager version of <code>splitter</code> that creates an array with splitted slices of <code>input</code>.</p> </dd> <dt class="d_decl" id="RegexException">alias <strong id="RegexException">RegexException</strong> = std.regex.internal.ir.<strong id="RegexException">RegexException</strong>; </dt> <dd>
<p>Exception object thrown in case of errors during regex compilation.</p> </dd> <dt class="d_decl" id="escaper">auto <strong id="escaper">escaper</strong>(Range)(Range r); </dt> <dd>
<p>A range that lazily produces a string output escaped to be used inside of a regular expression.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison;
import std.regex;
string s = `This is {unfriendly} to *regex*`;
assert(s.escaper.equal(`This is \{unfriendly\} to \*regex\*`));
</pre> </dd>
</dl> </dd> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1999&ndash;2021 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/std_regex.html" class="_attribution-link">https://dlang.org/phobos/std_regex.html</a>
  </p>
</div>
