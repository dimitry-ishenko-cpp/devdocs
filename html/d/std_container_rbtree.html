<h1>std.container.rbtree</h1>  <p>This module implements a red-black tree container. </p>
<p>This module is a submodule of <a href="std_container.html"><code>std.container</code></a>. </p> <dl>
<dt>Source</dt>
<dd> <span class="phobos_src"><a class="https" href="https://github.com/dlang/phobos/blob/master/std/container/rbtree.d">std/container/rbtree.d</a></span> </dd>
</dl> <dl>
<dt>License:</dt>
<dd>Distributed under the Boost Software License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at <a href="http://boost.org/LICENSE_1_0.txt">boost.org/LICENSE_1_0.txt</a>). </dd>
</dl> <dl>
<dt>Authors:</dt>
<dd>Steven Schveighoffer, <a href="http://erdani.com">Andrei Alexandrescu</a>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.container.rbtree;

auto rbt = redBlackTree(3, 1, 4, 2, 5);
writeln(rbt.front); // 1
assert(equal(rbt[], [1, 2, 3, 4, 5]));

rbt.removeKey(1, 4);
assert(equal(rbt[], [2, 3, 5]));

rbt.removeFront();
assert(equal(rbt[], [3, 5]));

rbt.insert([1, 2, 4]);
assert(equal(rbt[], [1, 2, 3, 4, 5]));

// Query bounds in O(log(n))
assert(rbt.lowerBound(3).equal([1, 2]));
assert(rbt.equalRange(3).equal([3]));
assert(rbt.upperBound(3).equal([4, 5]));

// A Red Black tree with the highest element at front:
import std.range : iota;
auto maxTree = redBlackTree!"a &gt; b"(iota(5));
assert(equal(maxTree[], [4, 3, 2, 1, 0]));

// adding duplicates will not add them, but return 0
auto rbt2 = redBlackTree(1, 3);
writeln(rbt2.insert(1)); // 0
assert(equal(rbt2[], [1, 3]));
writeln(rbt2.insert(2)); // 1

// however you can allow duplicates
auto ubt = redBlackTree!true([0, 1, 0, 1]);
assert(equal(ubt[], [0, 0, 1, 1]));
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="RedBlackTree">class <strong id="RedBlackTree">RedBlackTree</strong>(T, alias less = "a &lt; b", bool allowDuplicates = false) if (is(typeof(binaryFun!less(T.init, T.init)))); </dt> <dd>
<p>Implementation of a <a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree"> red-black tree</a> container. </p>
<p>All inserts, removes, searches, and any function in general has complexity of <span class="bigoh">Ο(<code>lg(n)</code>)</span>. <br><br> To use a different comparison than <code>"a &lt; b"</code>, pass a different operator string that can be used by <a href="std_functional.html#binaryFun"><code>std.functional.binaryFun</code></a>, or pass in a function, delegate, functor, or any type where <code>less(a, b)</code> results in a <code>bool</code> value. <br><br> Note that less should produce a strict ordering. That is, for two unequal elements <code>a</code> and <code>b</code>, <code>less(a, b) == !less(b, a)</code>. <code>less(a, a)</code> should always equal <code>false</code>. <br><br> If <code>allowDuplicates</code> is set to <code>true</code>, then inserting the same element more than once continues to add more elements. If it is <code>false</code>, duplicate elements are ignored on insertion. If duplicates are allowed, then new elements are inserted after all existing duplicate elements.</p> <dl>
<dt class="d_decl" id="RedBlackTree.Elem">alias <strong id="Elem">Elem</strong> = T; </dt> <dd>
<p>Element type for the tree</p> </dd> <dt class="d_decl" id="RedBlackTree.Range">alias <strong id="Range">Range</strong> = RBRange!(RBNode*); <br><br>alias <strong id="ConstRange">ConstRange</strong> = RBRange!(const(RBNode)*); <br><br>alias <strong id="ImmutableRange">ImmutableRange</strong> = RBRange!(immutable(RBNode)*); </dt> <dd>
<p>The range types for <code>RedBlackTree</code></p> </dd> <dt class="d_decl" id="RedBlackTree.empty">const @property bool <strong id="empty">empty</strong>(); </dt> <dd>
<p>Check if any elements exist in the container. Returns <code>false</code> if at least one element exists.</p> </dd> <dt class="d_decl" id="RedBlackTree.length">const @property size_t <strong id="length">length</strong>(); </dt> <dd>
<p>Returns the number of elements in the container. </p>
<dl>
<dt>Complexity</dt>
<dd> <span class="bigoh">Ο(<code>1</code>)</span>.</dd>
</dl> </dd> <dt class="d_decl" id="RedBlackTree.dup">@property RedBlackTree <strong id="dup">dup</strong>(); </dt> <dd>
<p>Duplicate this container. The resulting container contains a shallow copy of the elements. </p>
<dl>
<dt>Complexity</dt>
<dd> <span class="bigoh">Ο(<code>n</code>)</span>
</dd>
</dl> </dd> <dt class="d_decl" id="RedBlackTree.opSlice">Range <strong id="opSlice">opSlice</strong>(); <br><br>const ConstRange <strong id="opSlice">opSlice</strong>(); <br><br>immutable ImmutableRange <strong id="opSlice">opSlice</strong>(); </dt> <dd>
<p>Fetch a range that spans all the elements in the container. </p>
<dl>
<dt>Complexity</dt>
<dd> <span class="bigoh">Ο(<code>1</code>)</span>
</dd>
</dl> </dd> <dt class="d_decl" id="RedBlackTree.front">inout inout(Elem) <strong id="front">front</strong>(); </dt> <dd>
<p>The front element in the container </p>
<dl>
<dt>Complexity</dt>
<dd> <span class="bigoh">Ο(<code>1</code>)</span>
</dd>
</dl> </dd> <dt class="d_decl" id="RedBlackTree.back">inout inout(Elem) <strong id="back">back</strong>(); </dt> <dd>
<p>The last element in the container </p>
<dl>
<dt>Complexity</dt>
<dd> <span class="bigoh">Ο(<code>log(n)</code>)</span>
</dd>
</dl> </dd> <dt class="d_decl" id="RedBlackTree.opBinaryRight">const bool <strong id="opBinaryRight">opBinaryRight</strong>(string op)(Elem e)<br><small>  Constraints: if (op == "in"); </small>
</dt> <dd>
<p><code>in</code> operator. Check to see if the given element exists in the container. </p>
<dl>
<dt>Complexity</dt>
<dd> <span class="bigoh">Ο(<code>log(n)</code>)</span>
</dd>
</dl> </dd> <dt class="d_decl" id="RedBlackTree.opEquals">bool <strong id="opEquals">opEquals</strong>(Object rhs); </dt> <dd>
<p>Compares two trees for equality. </p>
<dl>
<dt>Complexity</dt>
<dd> <span class="bigoh">Ο(<code>n</code>)</span>
</dd>
</dl> </dd> <dt class="d_decl" id="RedBlackTree.toHash">nothrow @safe size_t <strong id="toHash">toHash</strong>(); </dt> <dd>
<p>Generates a hash for the tree. Note that with a custom comparison function it may not hold that if two rbtrees are equal, the hashes of the trees will be equal.</p> </dd> <dt class="d_decl" id="RedBlackTree.clear">void <strong id="clear">clear</strong>(); </dt> <dd>
<p>Removes all elements from the container. </p>
<dl>
<dt>Complexity</dt>
<dd> <span class="bigoh">Ο(<code>1</code>)</span>
</dd>
</dl> </dd> <dt class="d_decl" id="RedBlackTree.stableInsert">size_t <strong id="stableInsert">stableInsert</strong>(Stuff)(Stuff stuff)<br><small>  Constraints: if (isImplicitlyConvertible!(Stuff, Elem)); </small>
</dt> <dd>
<p>Insert a single element in the container. Note that this does not invalidate any ranges currently iterating the container. </p>
<dl>
<dt>Returns:</dt>
<dd>The number of elements inserted. </dd>
</dl> <dl>
<dt>Complexity</dt>
<dd> <span class="bigoh">Ο(<code>log(n)</code>)</span>
</dd>
</dl> </dd> <dt class="d_decl" id="RedBlackTree.stableInsert.2">size_t <strong id="stableInsert">stableInsert</strong>(Stuff)(scope Stuff stuff)<br><small>  Constraints: if (isInputRange!Stuff &amp;&amp; isImplicitlyConvertible!(ElementType!Stuff, Elem)); </small><br><br>alias <strong id="insert">insert</strong> = stableInsert; </dt> <dd>
<p>Insert a range of elements in the container. Note that this does not invalidate any ranges currently iterating the container. </p>
<dl>
<dt>Returns:</dt>
<dd>The number of elements inserted. </dd>
</dl> <dl>
<dt>Complexity</dt>
<dd> <span class="bigoh">Ο(<code>m * log(n)</code>)</span>
</dd>
</dl> </dd> <dt class="d_decl" id="RedBlackTree.removeAny">Elem <strong id="removeAny">removeAny</strong>(); </dt> <dd>
<p>Remove an element from the container and return its value. </p>
<dl>
<dt>Complexity</dt>
<dd> <span class="bigoh">Ο(<code>log(n)</code>)</span>
</dd>
</dl> </dd> <dt class="d_decl" id="RedBlackTree.removeFront">void <strong id="removeFront">removeFront</strong>(); </dt> <dd>
<p>Remove the front element from the container. </p>
<dl>
<dt>Complexity</dt>
<dd> <span class="bigoh">Ο(<code>log(n)</code>)</span>
</dd>
</dl> </dd> <dt class="d_decl" id="RedBlackTree.removeBack">void <strong id="removeBack">removeBack</strong>(); </dt> <dd>
<p>Remove the back element from the container. </p>
<dl>
<dt>Complexity</dt>
<dd> <span class="bigoh">Ο(<code>log(n)</code>)</span>
</dd>
</dl> </dd> <dt class="d_decl" id="RedBlackTree.remove">Range <strong id="remove">remove</strong>(Range r); </dt> <dd>
<p>Removes the given range from the container. </p>
<dl>
<dt>Returns:</dt>
<dd>A range containing all of the elements that were after the given range. </dd>
</dl> <dl>
<dt>Complexity</dt>
<dd> <span class="bigoh">Ο(<code>m * log(n)</code>)</span> (where m is the number of elements in the range)</dd>
</dl> </dd> <dt class="d_decl" id="RedBlackTree.remove.2">Range <strong id="remove">remove</strong>(Take!Range r); </dt> <dd>
<p>Removes the given <code>Take!Range</code> from the container </p>
<dl>
<dt>Returns:</dt>
<dd>A range containing all of the elements that were after the given range. </dd>
</dl> <dl>
<dt>Complexity</dt>
<dd> <span class="bigoh">Ο(<code>m * log(n)</code>)</span> (where m is the number of elements in the range)</dd>
</dl> </dd> <dt class="d_decl" id="RedBlackTree.removeKey">size_t <strong id="removeKey">removeKey</strong>(U...)(U elems)<br><small>  Constraints: if (allSatisfy!(isImplicitlyConvertibleToElem, U)); </small><br><br>size_t <strong id="removeKey">removeKey</strong>(U)(scope U[] elems)<br><small>  Constraints: if (isImplicitlyConvertible!(U, Elem)); </small><br><br>size_t <strong id="removeKey">removeKey</strong>(Stuff)(Stuff stuff)<br><small>  Constraints: if (isInputRange!Stuff &amp;&amp; isImplicitlyConvertible!(ElementType!Stuff, Elem) &amp;&amp; !isDynamicArray!Stuff); </small>
</dt> <dd>
<p>Removes elements from the container that are equal to the given values according to the less comparator. One element is removed for each value given which is in the container. If <code>allowDuplicates</code> is true, duplicates are removed only if duplicate values are given. </p>
<dl>
<dt>Returns:</dt>
<dd>The number of elements removed. </dd>
</dl> <dl>
<dt>Complexity</dt>
<dd> <span class="bigoh">Ο(<code>m log(n)</code>)</span> (where m is the number of elements to remove) </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto rbt = redBlackTree!true(0, 1, 1, 1, 4, 5, 7);
rbt.removeKey(1, 4, 7);
assert(equal(rbt[], [0, 1, 1, 5]));
rbt.removeKey(1, 1, 0);
assert(equal(rbt[], [5]));
</pre>  </dd> <dt class="d_decl" id="RedBlackTree.upperBound">Range <strong id="upperBound">upperBound</strong>(Elem e); <br><br>const ConstRange <strong id="upperBound">upperBound</strong>(Elem e); <br><br>immutable ImmutableRange <strong id="upperBound">upperBound</strong>(Elem e); </dt> <dd>
<p>Get a range from the container with all elements that are &gt; e according to the less comparator </p>
<dl>
<dt>Complexity</dt>
<dd> <span class="bigoh">Ο(<code>log(n)</code>)</span>
</dd>
</dl> </dd> <dt class="d_decl" id="RedBlackTree.lowerBound">Range <strong id="lowerBound">lowerBound</strong>(Elem e); <br><br>const ConstRange <strong id="lowerBound">lowerBound</strong>(Elem e); <br><br>immutable ImmutableRange <strong id="lowerBound">lowerBound</strong>(Elem e); </dt> <dd>
<p>Get a range from the container with all elements that are &lt; e according to the less comparator </p>
<dl>
<dt>Complexity</dt>
<dd> <span class="bigoh">Ο(<code>log(n)</code>)</span>
</dd>
</dl> </dd> <dt class="d_decl" id="RedBlackTree.equalRange">auto <strong id="equalRange">equalRange</strong>(this This)(Elem e); </dt> <dd>
<p>Get a range from the container with all elements that are == e according to the less comparator </p>
<dl>
<dt>Complexity</dt>
<dd> <span class="bigoh">Ο(<code>log(n)</code>)</span>
</dd>
</dl> </dd> <dt class="d_decl" id="RedBlackTree.toString">const void <strong id="toString">toString</strong>(scope void delegate(const(char)[]) sink, ref scope const FormatSpec!char fmt); </dt> <dd>
<p>Formats the RedBlackTree into a sink function. For more info see <code> std.format.formatValue</code>. Note that this only is available when the element type can be formatted. Otherwise, the default toString from Object is used.</p> </dd> <dt class="d_decl" id="RedBlackTree.this">this(Elem[] elems...); </dt> <dd>
<p>Constructor. Pass in an array of elements, or individual elements to initialize the tree with.</p> </dd> <dt class="d_decl" id="RedBlackTree.this.2">this(Stuff)(Stuff stuff)<br><small>  Constraints: if (isInputRange!Stuff &amp;&amp; isImplicitlyConvertible!(ElementType!Stuff, Elem)); </small>
</dt> <dd>
<p>Constructor. Pass in a range of elements to initialize the tree with.</p> </dd> <dt class="d_decl" id="RedBlackTree.this.3">this(); </dt>  </dl> </dd> <dt class="d_decl" id="redBlackTree">auto <strong id="redBlackTree">redBlackTree</strong>(E)(E[] elems...); <br><br>auto <strong id="redBlackTree">redBlackTree</strong>(bool allowDuplicates, E)(E[] elems...); <br><br>auto <strong id="redBlackTree">redBlackTree</strong>(alias less, E)(E[] elems...)<br><small>  Constraints: if (is(typeof(binaryFun!less(E.init, E.init)))); </small><br><br>auto <strong id="redBlackTree">redBlackTree</strong>(alias less, bool allowDuplicates, E)(E[] elems...)<br><small>  Constraints: if (is(typeof(binaryFun!less(E.init, E.init)))); </small><br><br>auto <strong id="redBlackTree">redBlackTree</strong>(Stuff)(Stuff range)<br><small>  Constraints: if (isInputRange!Stuff &amp;&amp; !isArray!Stuff); </small><br><br>auto <strong id="redBlackTree">redBlackTree</strong>(bool allowDuplicates, Stuff)(Stuff range)<br><small>  Constraints: if (isInputRange!Stuff &amp;&amp; !isArray!Stuff); </small><br><br>auto <strong id="redBlackTree">redBlackTree</strong>(alias less, Stuff)(Stuff range)<br><small>  Constraints: if (is(typeof(binaryFun!less((ElementType!Stuff).init, (ElementType!Stuff).init))) &amp;&amp; isInputRange!Stuff &amp;&amp; !isArray!Stuff); </small><br><br>auto <strong id="redBlackTree">redBlackTree</strong>(alias less, bool allowDuplicates, Stuff)(Stuff range)<br><small>  Constraints: if (is(typeof(binaryFun!less((ElementType!Stuff).init, (ElementType!Stuff).init))) &amp;&amp; isInputRange!Stuff &amp;&amp; !isArray!Stuff); </small>
</dt> <dd>
<p>Convenience function for creating a <code>RedBlackTree!E</code> from a list of values. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>allowDuplicates</td> <td>Whether duplicates should be allowed (optional, default: false)</td>
</tr> <tr>
<td>less</td> <td>predicate to sort by (optional)</td>
</tr> <tr>
<td>E[] <code>elems</code>
</td> <td>elements to insert into the rbtree (variadic arguments)</td>
</tr> <tr>
<td>Stuff <code>range</code>
</td> <td>range elements to insert into the rbtree (alternative to elems)</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.range : iota;

auto rbt1 = redBlackTree(0, 1, 5, 7);
auto rbt2 = redBlackTree!string("hello", "world");
auto rbt3 = redBlackTree!true(0, 1, 5, 7, 5);
auto rbt4 = redBlackTree!"a &gt; b"(0, 1, 5, 7);
auto rbt5 = redBlackTree!("a &gt; b", true)(0.1, 1.3, 5.9, 7.2, 5.9);

// also works with ranges
auto rbt6 = redBlackTree(iota(3));
auto rbt7 = redBlackTree!true(iota(3));
auto rbt8 = redBlackTree!"a &gt; b"(iota(3));
auto rbt9 = redBlackTree!("a &gt; b", true)(iota(3));
</pre> </dd>
</dl> </dd> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1999&ndash;2021 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/std_container_rbtree.html" class="_attribution-link">https://dlang.org/phobos/std_container_rbtree.html</a>
  </p>
</div>
