<h1>std.uni</h1>  <p>The <code>std.uni</code> module provides an implementation of fundamental Unicode algorithms and data structures. This doesn't include UTF encoding and decoding primitives, see <a href="std_utf.html#decode"><code>std.utf.decode</code></a> and <a href="std_utf.html#encode"><code>std.utf.encode</code></a> in <a href="std_utf.html"><code>std.utf</code></a> for this functionality. </p>  <table>

<tr>
<th scope="col">Category</th> <th scope="col">Functions</th>
</tr> <tr>
<td>Decode</td> <td> <a href="#byCodePoint"><code>byCodePoint</code></a> <a href="#byGrapheme"><code>byGrapheme</code></a> <a href="#decodeGrapheme"><code>decodeGrapheme</code></a> <a href="#graphemeStride"><code>graphemeStride</code></a> </td>
</tr> <tr>
<td>Comparison</td> <td> <a href="#icmp"><code>icmp</code></a> <a href="#sicmp"><code>sicmp</code></a> </td>
</tr> <tr>
<td>Classification</td> <td> <a href="#isAlpha"><code>isAlpha</code></a> <a href="#isAlphaNum"><code>isAlphaNum</code></a> <a href="#isCodepointSet"><code>isCodepointSet</code></a> <a href="#isControl"><code>isControl</code></a> <a href="#isFormat"><code>isFormat</code></a> <a href="#isGraphical"><code>isGraphical</code></a> <a href="#isIntegralPair"><code>isIntegralPair</code></a> <a href="#isMark"><code>isMark</code></a> <a href="#isNonCharacter"><code>isNonCharacter</code></a> <a href="#isNumber"><code>isNumber</code></a> <a href="#isPrivateUse"><code>isPrivateUse</code></a> <a href="#isPunctuation"><code>isPunctuation</code></a> <a href="#isSpace"><code>isSpace</code></a> <a href="#isSurrogate"><code>isSurrogate</code></a> <a href="#isSurrogateHi"><code>isSurrogateHi</code></a> <a href="#isSurrogateLo"><code>isSurrogateLo</code></a> <a href="#isSymbol"><code>isSymbol</code></a> <a href="#isWhite"><code>isWhite</code></a> </td>
</tr> <tr>
<td>Normalization</td> <td> <a href="#NFC"><code>NFC</code></a> <a href="#NFD"><code>NFD</code></a> <a href="#NFKD"><code>NFKD</code></a> <a href="#NormalizationForm"><code>NormalizationForm</code></a> <a href="#normalize"><code>normalize</code></a> </td>
</tr> <tr>
<td>Decompose</td> <td> <a href="#decompose"><code>decompose</code></a> <a href="#decomposeHangul"><code>decomposeHangul</code></a> <a href="#UnicodeDecomposition"><code>UnicodeDecomposition</code></a> </td>
</tr> <tr>
<td>Compose</td> <td> <a href="#compose"><code>compose</code></a> <a href="#composeJamo"><code>composeJamo</code></a> </td>
</tr> <tr>
<td>Sets</td> <td> <a href="#CodepointInterval"><code>CodepointInterval</code></a> <a href="#CodepointSet"><code>CodepointSet</code></a> <a href="#InversionList"><code>InversionList</code></a> <a href="#unicode"><code>unicode</code></a> </td>
</tr> <tr>
<td>Trie</td> <td> <a href="#codepointSetTrie"><code>codepointSetTrie</code></a> <a href="#CodepointSetTrie"><code>CodepointSetTrie</code></a> <a href="#codepointTrie"><code>codepointTrie</code></a> <a href="#CodepointTrie"><code>CodepointTrie</code></a> <a href="#toTrie"><code>toTrie</code></a> <a href="#toDelegate"><code>toDelegate</code></a> </td>
</tr> <tr>
<td>Casing</td> <td> <a href="#asCapitalized"><code>asCapitalized</code></a> <a href="#asLowerCase"><code>asLowerCase</code></a> <a href="#asUpperCase"><code>asUpperCase</code></a> <a href="#isLower"><code>isLower</code></a> <a href="#isUpper"><code>isUpper</code></a> <a href="#toLower"><code>toLower</code></a> <a href="#toLowerInPlace"><code>toLowerInPlace</code></a> <a href="#toUpper"><code>toUpper</code></a> <a href="#toUpperInPlace"><code>toUpperInPlace</code></a> </td>
</tr> <tr>
<td>Utf8Matcher</td> <td> <a href="#isUtfMatcher"><code>isUtfMatcher</code></a> <a href="#MatcherConcept"><code>MatcherConcept</code></a> <a href="#utfMatcher"><code>utfMatcher</code></a> </td>
</tr> <tr>
<td>Separators</td> <td> <a href="#lineSep"><code>lineSep</code></a> <a href="#nelSep"><code>nelSep</code></a> <a href="#paraSep"><code>paraSep</code></a> </td>
</tr> <tr>
<td>Building blocks</td> <td> <a href="#allowedIn"><code>allowedIn</code></a> <a href="#combiningClass"><code>combiningClass</code></a> <a href="#Grapheme"><code>Grapheme</code></a> </td>
</tr> </table> <br><br> <p>All primitives listed operate on Unicode characters and sets of characters. For functions which operate on ASCII characters and ignore Unicode <a href="#Character">characters</a>, see <a href="std_ascii.html"><code>std.ascii</code></a>. For definitions of Unicode <a href="#Character">character</a>, <a href="#Code%20point">code point</a> and other terms used throughout this module see the <a href="#Terminology">terminology</a> section below. </p> <p>The focus of this module is the core needs of developing Unicode-aware applications. To that effect it provides the following optimized primitives: </p> <ul> <li>Character classification by category and common properties: <a href="#isAlpha"><code>isAlpha</code></a>, <a href="#isWhite"><code>isWhite</code></a> and others. </li> <li> Case-insensitive string comparison (<a href="#sicmp"><code>sicmp</code></a>, <a href="#icmp"><code>icmp</code></a>). </li> <li> Converting text to any of the four normalization forms via <a href="#normalize"><code>normalize</code></a>. </li> <li> Decoding (<a href="#decodeGrapheme"><code>decodeGrapheme</code></a>) and iteration (<a href="#byGrapheme"><code>byGrapheme</code></a>, <a href="#graphemeStride"><code>graphemeStride</code></a>) by user-perceived characters, that is by <a href="#Grapheme"><code>Grapheme</code></a> clusters. </li> <li> Decomposing and composing of individual character(s) according to canonical or compatibility rules, see <a href="#compose"><code>compose</code></a> and <a href="#decompose"><code>decompose</code></a>, including the specific version for Hangul syllables <a href="#composeJamo"><code>composeJamo</code></a> and <a href="#decomposeHangul"><code>decomposeHangul</code></a>. </li> </ul> <p>It's recognized that an application may need further enhancements and extensions, such as less commonly known algorithms, or tailoring existing ones for region specific needs. To help users with building any extra functionality beyond the core primitives, the module provides: </p> <ul> <li> <a href="#CodepointSet"><code>CodepointSet</code></a>, a type for easy manipulation of sets of characters. Besides the typical set algebra it provides an unusual feature: a D source code generator for detection of <a href="#Code%20point">code points</a> in this set. This is a boon for meta-programming parser frameworks, and is used internally to power classification in small sets like <a href="#isWhite"><code>isWhite</code></a>. </li> <li> A way to construct optimal packed multi-stage tables also known as a special case of <a href="https://en.wikipedia.org/wiki/Trie">Trie</a>. The functions <a href="#codepointTrie"><code>codepointTrie</code></a>, <a href="#codepointSetTrie"><code>codepointSetTrie</code></a> construct custom tries that map dchar to value. The end result is a fast and predictable <span class="bigoh">Ο(<code>1</code>)</span> lookup that powers functions like <a href="#isAlpha"><code>isAlpha</code></a> and <a href="#combiningClass"><code>combiningClass</code></a>, but for user-defined data sets. </li> <li> A useful technique for Unicode-aware parsers that perform character classification of encoded <a href="#Code%20point">code points</a> is to avoid unnecassary decoding at all costs. <a href="#utfMatcher"><code>utfMatcher</code></a> provides an improvement over the usual workflow of decode-classify-process, combining the decoding and classification steps. By extracting necessary bits directly from encoded <a href="#Code%20unit">code units</a> matchers achieve significant performance improvements. See <a href="#MatcherConcept"><code>MatcherConcept</code></a> for the common interface of UTF matchers. </li> <li> Generally useful building blocks for customized normalization: <a href="#combiningClass"><code>combiningClass</code></a> for querying combining class and <a href="#allowedIn"><code>allowedIn</code></a> for testing the Quick_Check property of a given normalization form. </li> <li> Access to a large selection of commonly used sets of <a href="#Code%20point">code points</a>. <a href="#Unicode%20properties">Supported sets</a> include Script, Block and General Category. The exact contents of a set can be observed in the CLDR utility, on the <a href="http://www.unicode.org/cldr/utility/properties.jsp">property index</a> page of the Unicode website. See <a href="#unicode"><code>unicode</code></a> for easy and (optionally) compile-time checked set queries. </li> </ul> <h3><a id="Synopsis">Synopsis</a></h3> <pre data-language="d">import std.uni;
void main()
{
    // initialize code point sets using script/block or property name
    // now 'set' contains code points from both scripts.
    auto set = unicode("Cyrillic") | unicode("Armenian");
    // same thing but simpler and checked at compile-time
    auto ascii = unicode.ASCII;
    auto currency = unicode.Currency_Symbol;

    // easy set ops
    auto a = set &amp; ascii;
    assert(a.empty); // as it has no intersection with ascii
    a = set | ascii;
    auto b = currency - a; // subtract all ASCII, Cyrillic and Armenian

    // some properties of code point sets
    assert(b.length &gt; 45); // 46 items in Unicode 6.1, even more in 6.2
    // testing presence of a code point in a set
    // is just fine, it is O(logN)
    assert(!b['$']);
    assert(!b['\u058F']); // Armenian dram sign
    assert(b['¥']);

    // building fast lookup tables, these guarantee O(1) complexity
    // 1-level Trie lookup table essentially a huge bit-set ~262Kb
    auto oneTrie = toTrie!1(b);
    // 2-level far more compact but typically slightly slower
    auto twoTrie = toTrie!2(b);
    // 3-level even smaller, and a bit slower yet
    auto threeTrie = toTrie!3(b);
    assert(oneTrie['£']);
    assert(twoTrie['£']);
    assert(threeTrie['£']);

    // build the trie with the most sensible trie level
    // and bind it as a functor
    auto cyrillicOrArmenian = toDelegate(set);
    auto balance = find!(cyrillicOrArmenian)("Hello ընկեր!");
    assert(balance == "ընկեր!");
    // compatible with bool delegate(dchar)
    bool delegate(dchar) bindIt = cyrillicOrArmenian;

    // Normalization
    string s = "Plain ascii (and not only), is always normalized!";
    assert(s is normalize(s));// is the same string

    string nonS = "A\u0308ffin"; // A ligature
    auto nS = normalize(nonS); // to NFC, the W3C endorsed standard
    assert(nS == "Äffin");
    assert(nS != nonS);
    string composed = "Äffin";

    assert(normalize!NFD(composed) == "A\u0308ffin");
    // to NFKD, compatibility decomposition useful for fuzzy matching/searching
    assert(normalize!NFKD("2¹⁰") == "210");
}
</pre> <h3><a id="Terminology">Terminology</a></h3> <p>The following is a list of important Unicode notions and definitions. Any conventions used specifically in this module alone are marked as such. The descriptions are based on the formal definition as found in <a href="http://www.unicode.org/versions/Unicode6.2.0/ch03.pdf"> chapter three of The Unicode Standard Core Specification.</a> </p> 
<a id="Abstract character"><i>Abstract character</i></a> A unit of information used for the organization, control, or representation of textual data. Note that: <ul> <li>When representing data, the nature of that data is generally symbolic as opposed to some other kind of data (for example, visual). </li> <li>An abstract character has no concrete form and should not be confused with a <a href="#Glyph">glyph</a>. </li> <li>An abstract character does not necessarily correspond to what a user thinks of as a “character” and should not be confused with a <a href="#Grapheme"><code>Grapheme</code></a>. </li> <li>The abstract characters encoded (see Encoded character) are known as Unicode abstract characters. </li> <li>Abstract characters not directly encoded by the Unicode Standard can often be represented by the use of combining character sequences. </li> </ul> 
<a id="Canonical decomposition"><i>Canonical decomposition</i></a> The decomposition of a character or character sequence that results from recursively applying the canonical mappings found in the Unicode Character Database and these described in Conjoining Jamo Behavior (section 12 of <a href="http://www.unicode.org/uni2book/ch03.pdf">Unicode Conformance</a>). 
<a id="Canonical composition"><i>Canonical composition</i></a> The precise definition of the Canonical composition is the algorithm as specified in <a href="http://www.unicode.org/uni2book/ch03.pdf"> Unicode Conformance</a> section 11. Informally it's the process that does the reverse of the canonical decomposition with the addition of certain rules that e.g. prevent legacy characters from appearing in the composed result. 
<a id="Canonical equivalent"><i>Canonical equivalent</i></a> Two character sequences are said to be canonical equivalents if their full canonical decompositions are identical. 
<a id="Character"><i>Character</i></a> Typically differs by context. For the purpose of this documentation the term <i>character</i> implies <i>encoded character</i>, that is, a code point having an assigned abstract character (a symbolic meaning). 
<a id="Code point"><i>Code point</i></a> Any value in the Unicode codespace; that is, the range of integers from 0 to 10FFFF (hex). Not all code points are assigned to encoded characters. 
<a id="Code unit"><i>Code unit</i></a> The minimal bit combination that can represent a unit of encoded text for processing or interchange. Depending on the encoding this could be: 8-bit code units in the UTF-8 (<code>char</code>), 16-bit code units in the UTF-16 (<code>wchar</code>), and 32-bit code units in the UTF-32 (<code>dchar</code>). <i>Note that in UTF-32, a code unit is a code point and is represented by the D <code>dchar</code> type.</i> 
<a id="Combining character"><i>Combining character</i></a> A character with the General Category of Combining Mark(M). <ul> <li>All characters with non-zero canonical combining class are combining characters, but the reverse is not the case: there are combining characters with a zero combining class. </li> <li>These characters are not normally used in isolation unless they are being described. They include such characters as accents, diacritics, Hebrew points, Arabic vowel signs, and Indic matras. </li> </ul> 
<a id="Combining class"><i>Combining class</i></a> A numerical value used by the Unicode Canonical Ordering Algorithm to determine which sequences of combining marks are to be considered canonically equivalent and which are not. 
<a id="Compatibility decomposition"><i>Compatibility decomposition</i></a> The decomposition of a character or character sequence that results from recursively applying both the compatibility mappings and the canonical mappings found in the Unicode Character Database, and those described in Conjoining Jamo Behavior no characters can be further decomposed. 
<a id="Compatibility equivalent"><i>Compatibility equivalent</i></a> Two character sequences are said to be compatibility equivalents if their full compatibility decompositions are identical. 
<a id="Encoded character"><i>Encoded character</i></a> An association (or mapping) between an abstract character and a code point. 
<a id="Glyph"><i>Glyph</i></a> The actual, concrete image of a glyph representation having been rasterized or otherwise imaged onto some display surface. 
<a id="Grapheme base"><i>Grapheme base</i></a> A character with the property Grapheme_Base, or any standard Korean syllable block. 
<a id="Grapheme cluster"><i>Grapheme cluster</i></a> Defined as the text between grapheme boundaries as specified by Unicode Standard Annex #29, <a href="http://www.unicode.org/reports/tr29/">Unicode text segmentation</a>. Important general properties of a grapheme: <ul> <li>The grapheme cluster represents a horizontally segmentable unit of text, consisting of some grapheme base (which may consist of a Korean syllable) together with any number of nonspacing marks applied to it. </li> <li> A grapheme cluster typically starts with a grapheme base and then extends across any subsequent sequence of nonspacing marks. A grapheme cluster is most directly relevant to text rendering and processes such as cursor placement and text selection in editing, but may also be relevant to comparison and searching. </li> <li>For many processes, a grapheme cluster behaves as if it was a single character with the same properties as its grapheme base. Effectively, nonspacing marks apply <i>graphically</i> to the base, but do not change its properties. </li> </ul> <p>This module defines a number of primitives that work with graphemes: <a href="#Grapheme"><code>Grapheme</code></a>, <a href="#decodeGrapheme"><code>decodeGrapheme</code></a> and <a href="#graphemeStride"><code>graphemeStride</code></a>. All of them are using <i>extended grapheme</i> boundaries as defined in the aforementioned standard annex. </p> 
<a id="Nonspacing mark"><i>Nonspacing mark</i></a> A combining character with the General Category of Nonspacing Mark (Mn) or Enclosing Mark (Me). 
<a id="Spacing mark"><i>Spacing mark</i></a> A combining character that is not a nonspacing mark. <h3><a id="Normalization">Normalization</a></h3> <p>The concepts of <a href="#Canonical%20equivalent">canonical equivalent</a> or <a href="#Compatibility%20equivalent">compatibility equivalent</a> characters in the Unicode Standard make it necessary to have a full, formal definition of equivalence for Unicode strings. String equivalence is determined by a process called normalization, whereby strings are converted into forms which are compared directly for identity. This is the primary goal of the normalization process, see the function <a href="#normalize"><code>normalize</code></a> to convert into any of the four defined forms. </p> <p>A very important attribute of the Unicode Normalization Forms is that they must remain stable between versions of the Unicode Standard. A Unicode string normalized to a particular Unicode Normalization Form in one version of the standard is guaranteed to remain in that Normalization Form for implementations of future versions of the standard. </p> <p>The Unicode Standard specifies four normalization forms. Informally, two of these forms are defined by maximal decomposition of equivalent sequences, and two of these forms are defined by maximal <i>composition</i> of equivalent sequences. </p>
<ul> <li>Normalization Form D (NFD): The <a href="#Canonical%20decomposition"> canonical decomposition</a> of a character sequence.</li> <li>Normalization Form KD (NFKD): The <a href="#Compatibility%20decomposition"> compatibility decomposition</a> of a character sequence.</li> <li>Normalization Form C (NFC): The canonical composition of the <a href="#Canonical%20decomposition">canonical decomposition</a> of a coded character sequence.</li> <li>Normalization Form KC (NFKC): The canonical composition of the <a href="#Compatibility%20decomposition"> compatibility decomposition</a> of a character sequence</li> </ul> <p>The choice of the normalization form depends on the particular use case. NFC is the best form for general text, since it's more compatible with strings converted from legacy encodings. NFKC is the preferred form for identifiers, especially where there are security concerns. NFD and NFKD are the most useful for internal processing. </p> <h3><a id="Construction of lookup tables">Construction of lookup tables</a></h3> <p>The Unicode standard describes a set of algorithms that depend on having the ability to quickly look up various properties of a code point. Given the the codespace of about 1 million <a href="#Code%20point">code points</a>, it is not a trivial task to provide a space-efficient solution for the multitude of properties. </p> <p>Common approaches such as hash-tables or binary search over sorted code point intervals (as in <a href="#InversionList"><code>InversionList</code></a>) are insufficient. Hash-tables have enormous memory footprint and binary search over intervals is not fast enough for some heavy-duty algorithms. </p> <p>The recommended solution (see Unicode Implementation Guidelines) is using multi-stage tables that are an implementation of the <a href="http://en.wikipedia.org/wiki/Trie">Trie</a> data structure with integer keys and a fixed number of stages. For the remainder of the section this will be called a fixed trie. The following describes a particular implementation that is aimed for the speed of access at the expense of ideal size savings. </p> <p>Taking a 2-level Trie as an example the principle of operation is as follows. Split the number of bits in a key (code point, 21 bits) into 2 components (e.g. 15 and 8). The first is the number of bits in the index of the trie and the other is number of bits in each page of the trie. The layout of the trie is then an array of size 2^^bits-of-index followed an array of memory chunks of size 2^^bits-of-page/bits-per-element. </p> <p>The number of pages is variable (but not less then 1) unlike the number of entries in the index. The slots of the index all have to contain a number of a page that is present. The lookup is then just a couple of operations - slice the upper bits, lookup an index for these, take a page at this index and use the lower bits as an offset within this page. </p>
<br><br> Assuming that pages are laid out consequently in one array at <code>pages</code>, the pseudo-code is: <pre data-language="d">auto elemsPerPage = (2 ^^ bits_per_page) / Value.sizeOfInBits;
pages[index[n &gt;&gt; bits_per_page]][n &amp; (elemsPerPage - 1)];
</pre> <p>Where if <code>elemsPerPage</code> is a power of 2 the whole process is a handful of simple instructions and 2 array reads. Subsequent levels of the trie are introduced by recursing on this notion - the index array is treated as values. The number of bits in index is then again split into 2 parts, with pages over 'current-index' and the new 'upper-index'. </p> <br><br> <p>For completeness a level 1 trie is simply an array. The current implementation takes advantage of bit-packing values when the range is known to be limited in advance (such as <code>bool</code>). See also <a href="#BitPacked"><code>BitPacked</code></a> for enforcing it manually. The major size advantage however comes from the fact that multiple <b>identical pages on every level are merged</b> by construction. </p> <p>The process of constructing a trie is more involved and is hidden from the user in a form of the convenience functions <a href="#codepointTrie"><code>codepointTrie</code></a>, <a href="#codepointSetTrie"><code>codepointSetTrie</code></a> and the even more convenient <a href="#toTrie"><code>toTrie</code></a>. In general a set or built-in AA with <code>dchar</code> type can be turned into a trie. The trie object in this module is read-only (immutable); it's effectively frozen after construction. </p> <h3><a id="Unicode properties">Unicode properties</a></h3> <p>This is a full list of Unicode properties accessible through <a href="#unicode"><code>unicode</code></a> with specific helpers per category nested within. Consult the <a href="http://www.unicode.org/cldr/utility/properties.jsp">CLDR utility</a> when in doubt about the contents of a particular set. </p> <p>General category sets listed below are only accessible with the <a href="#unicode"><code>unicode</code></a> shorthand accessor.</p> <table>
<caption><b>General category </b></caption> <tr>
<th scope="col">Abb.</th> <th scope="col">Long form</th> <th scope="col">Abb.</th> <th scope="col">Long form</th>
<th scope="col">Abb.</th> <th scope="col">Long form</th>
</tr> <tr>
<td>L</td> <td>Letter</td> <td>Cn</td> <td>Unassigned</td> <td>Po</td> <td>Other_Punctuation</td>
</tr> <tr>
<td>Ll</td> <td>Lowercase_Letter</td> <td>Co</td> <td>Private_Use</td> <td>Ps</td> <td>Open_Punctuation</td>
</tr> <tr>
<td>Lm</td> <td>Modifier_Letter</td> <td>Cs</td> <td>Surrogate</td> <td>S</td> <td>Symbol</td>
</tr> <tr>
<td>Lo</td> <td>Other_Letter</td> <td>N</td> <td>Number</td> <td>Sc</td> <td>Currency_Symbol</td>
</tr> <tr>
<td>Lt</td> <td>Titlecase_Letter</td> <td>Nd</td> <td>Decimal_Number</td> <td>Sk</td> <td>Modifier_Symbol</td>
</tr> <tr>
<td>Lu</td> <td>Uppercase_Letter</td> <td>Nl</td> <td>Letter_Number</td> <td>Sm</td> <td>Math_Symbol</td>
</tr> <tr>
<td>M</td> <td>Mark</td> <td>No</td> <td>Other_Number</td> <td>So</td> <td>Other_Symbol</td>
</tr> <tr>
<td>Mc</td> <td>Spacing_Mark</td> <td>P</td> <td>Punctuation</td> <td>Z</td> <td>Separator</td>
</tr> <tr>
<td>Me</td> <td>Enclosing_Mark</td> <td>Pc</td> <td>Connector_Punctuation</td> <td>Zl</td> <td>Line_Separator</td>
</tr> <tr>
<td>Mn</td> <td>Nonspacing_Mark</td> <td>Pd</td> <td>Dash_Punctuation</td> <td>Zp</td> <td>Paragraph_Separator</td>
</tr> <tr>
<td>C</td> <td>Other</td> <td>Pe</td> <td>Close_Punctuation</td> <td>Zs</td> <td>Space_Separator</td>
</tr> <tr>
<td>Cc</td> <td>Control</td> <td>Pf</td> <td>Final_Punctuation</td> <td>-</td> <td>Any</td>
</tr> <tr>
<td>Cf</td> <td>Format</td> <td>Pi</td> <td>Initial_Punctuation</td> <td>-</td> <td>ASCII</td>
</tr> </table> <p>Sets for other commonly useful properties that are accessible with <a href="#unicode"><code>unicode</code></a>:</p> <table>
<caption><b>Common binary properties</b></caption> <tr>
<th scope="col">Name</th> <th scope="col">Name</th> <th scope="col">Name</th>
</tr> <tr>
<td>Alphabetic</td> <td>Ideographic</td> <td>Other_Uppercase</td>
</tr> <tr>
<td>ASCII_Hex_Digit</td> <td>IDS_Binary_Operator</td> <td>Pattern_Syntax</td>
</tr> <tr>
<td>Bidi_Control</td> <td>ID_Start</td> <td>Pattern_White_Space</td>
</tr> <tr>
<td>Cased</td> <td>IDS_Trinary_Operator</td> <td>Quotation_Mark</td>
</tr> <tr>
<td>Case_Ignorable</td> <td>Join_Control</td> <td>Radical</td>
</tr> <tr>
<td>Dash</td> <td>Logical_Order_Exception</td> <td>Soft_Dotted</td>
</tr> <tr>
<td>Default_Ignorable_Code_Point</td> <td>Lowercase</td> <td>STerm</td>
</tr> <tr>
<td>Deprecated</td> <td>Math</td> <td>Terminal_Punctuation</td>
</tr> <tr>
<td>Diacritic</td> <td>Noncharacter_Code_Point</td> <td>Unified_Ideograph</td>
</tr> <tr>
<td>Extender</td> <td>Other_Alphabetic</td> <td>Uppercase</td>
</tr> <tr>
<td>Grapheme_Base</td> <td>Other_Default_Ignorable_Code_Point</td> <td>Variation_Selector</td>
</tr> <tr>
<td>Grapheme_Extend</td> <td>Other_Grapheme_Extend</td> <td>White_Space</td>
</tr> <tr>
<td>Grapheme_Link</td> <td>Other_ID_Continue</td> <td>XID_Continue</td>
</tr> <tr>
<td>Hex_Digit</td> <td>Other_ID_Start</td> <td>XID_Start</td>
</tr> <tr>
<td>Hyphen</td> <td>Other_Lowercase</td> </tr> <tr>
<td>ID_Continue</td> <td>Other_Math</td> </tr> </table> <p>Below is the table with block names accepted by <a href="#unicode.block"><code>unicode.block</code></a>. Note that the shorthand version <a href="#unicode"><code>unicode</code></a> requires "In" to be prepended to the names of blocks so as to disambiguate scripts and blocks. </p> <table>
<caption><b>Blocks</b></caption> <tr>
<td>Aegean Numbers</td> <td>Ethiopic Extended</td> <td>Mongolian</td>
</tr> <tr>
<td>Alchemical Symbols</td> <td>Ethiopic Extended-A</td> <td>Musical Symbols</td>
</tr> <tr>
<td>Alphabetic Presentation Forms</td> <td>Ethiopic Supplement</td> <td>Myanmar</td>
</tr> <tr>
<td>Ancient Greek Musical Notation</td> <td>General Punctuation</td> <td>Myanmar Extended-A</td>
</tr> <tr>
<td>Ancient Greek Numbers</td> <td>Geometric Shapes</td> <td>New Tai Lue</td>
</tr> <tr>
<td>Ancient Symbols</td> <td>Georgian</td> <td>NKo</td>
</tr> <tr>
<td>Arabic</td> <td>Georgian Supplement</td> <td>Number Forms</td>
</tr> <tr>
<td>Arabic Extended-A</td> <td>Glagolitic</td> <td>Ogham</td>
</tr> <tr>
<td>Arabic Mathematical Alphabetic Symbols</td> <td>Gothic</td> <td>Ol Chiki</td>
</tr> <tr>
<td>Arabic Presentation Forms-A</td> <td>Greek and Coptic</td> <td>Old Italic</td>
</tr> <tr>
<td>Arabic Presentation Forms-B</td> <td>Greek Extended</td> <td>Old Persian</td>
</tr> <tr>
<td>Arabic Supplement</td> <td>Gujarati</td> <td>Old South Arabian</td>
</tr> <tr>
<td>Armenian</td> <td>Gurmukhi</td> <td>Old Turkic</td>
</tr> <tr>
<td>Arrows</td> <td>Halfwidth and Fullwidth Forms</td> <td>Optical Character Recognition</td>
</tr> <tr>
<td>Avestan</td> <td>Hangul Compatibility Jamo</td> <td>Oriya</td>
</tr> <tr>
<td>Balinese</td> <td>Hangul Jamo</td> <td>Osmanya</td>
</tr> <tr>
<td>Bamum</td> <td>Hangul Jamo Extended-A</td> <td>Phags-pa</td>
</tr> <tr>
<td>Bamum Supplement</td> <td>Hangul Jamo Extended-B</td> <td>Phaistos Disc</td>
</tr> <tr>
<td>Basic Latin</td> <td>Hangul Syllables</td> <td>Phoenician</td>
</tr> <tr>
<td>Batak</td> <td>Hanunoo</td> <td>Phonetic Extensions</td>
</tr> <tr>
<td>Bengali</td> <td>Hebrew</td> <td>Phonetic Extensions Supplement</td>
</tr> <tr>
<td>Block Elements</td> <td>High Private Use Surrogates</td> <td>Playing Cards</td>
</tr> <tr>
<td>Bopomofo</td> <td>High Surrogates</td> <td>Private Use Area</td>
</tr> <tr>
<td>Bopomofo Extended</td> <td>Hiragana</td> <td>Rejang</td>
</tr> <tr>
<td>Box Drawing</td> <td>Ideographic Description Characters</td> <td>Rumi Numeral Symbols</td>
</tr> <tr>
<td>Brahmi</td> <td>Imperial Aramaic</td> <td>Runic</td>
</tr> <tr>
<td>Braille Patterns</td> <td>Inscriptional Pahlavi</td> <td>Samaritan</td>
</tr> <tr>
<td>Buginese</td> <td>Inscriptional Parthian</td> <td>Saurashtra</td>
</tr> <tr>
<td>Buhid</td> <td>IPA Extensions</td> <td>Sharada</td>
</tr> <tr>
<td>Byzantine Musical Symbols</td> <td>Javanese</td> <td>Shavian</td>
</tr> <tr>
<td>Carian</td> <td>Kaithi</td> <td>Sinhala</td>
</tr> <tr>
<td>Chakma</td> <td>Kana Supplement</td> <td>Small Form Variants</td>
</tr> <tr>
<td>Cham</td> <td>Kanbun</td> <td>Sora Sompeng</td>
</tr> <tr>
<td>Cherokee</td> <td>Kangxi Radicals</td> <td>Spacing Modifier Letters</td>
</tr> <tr>
<td>CJK Compatibility</td> <td>Kannada</td> <td>Specials</td>
</tr> <tr>
<td>CJK Compatibility Forms</td> <td>Katakana</td> <td>Sundanese</td>
</tr> <tr>
<td>CJK Compatibility Ideographs</td> <td>Katakana Phonetic Extensions</td> <td>Sundanese Supplement</td>
</tr> <tr>
<td>CJK Compatibility Ideographs Supplement</td> <td>Kayah Li</td> <td>Superscripts and Subscripts</td>
</tr> <tr>
<td>CJK Radicals Supplement</td> <td>Kharoshthi</td> <td>Supplemental Arrows-A</td>
</tr> <tr>
<td>CJK Strokes</td> <td>Khmer</td> <td>Supplemental Arrows-B</td>
</tr> <tr>
<td>CJK Symbols and Punctuation</td> <td>Khmer Symbols</td> <td>Supplemental Mathematical Operators</td>
</tr> <tr>
<td>CJK Unified Ideographs</td> <td>Lao</td> <td>Supplemental Punctuation</td>
</tr> <tr>
<td>CJK Unified Ideographs Extension A</td> <td>Latin-1 Supplement</td> <td>Supplementary Private Use Area-A</td>
</tr> <tr>
<td>CJK Unified Ideographs Extension B</td> <td>Latin Extended-A</td> <td>Supplementary Private Use Area-B</td>
</tr> <tr>
<td>CJK Unified Ideographs Extension C</td> <td>Latin Extended Additional</td> <td>Syloti Nagri</td>
</tr> <tr>
<td>CJK Unified Ideographs Extension D</td> <td>Latin Extended-B</td> <td>Syriac</td>
</tr> <tr>
<td>Combining Diacritical Marks</td> <td>Latin Extended-C</td> <td>Tagalog</td>
</tr> <tr>
<td>Combining Diacritical Marks for Symbols</td> <td>Latin Extended-D</td> <td>Tagbanwa</td>
</tr> <tr>
<td>Combining Diacritical Marks Supplement</td> <td>Lepcha</td> <td>Tags</td>
</tr> <tr>
<td>Combining Half Marks</td> <td>Letterlike Symbols</td> <td>Tai Le</td>
</tr> <tr>
<td>Common Indic Number Forms</td> <td>Limbu</td> <td>Tai Tham</td>
</tr> <tr>
<td>Control Pictures</td> <td>Linear B Ideograms</td> <td>Tai Viet</td>
</tr> <tr>
<td>Coptic</td> <td>Linear B Syllabary</td> <td>Tai Xuan Jing Symbols</td>
</tr> <tr>
<td>Counting Rod Numerals</td> <td>Lisu</td> <td>Takri</td>
</tr> <tr>
<td>Cuneiform</td> <td>Low Surrogates</td> <td>Tamil</td>
</tr> <tr>
<td>Cuneiform Numbers and Punctuation</td> <td>Lycian</td> <td>Telugu</td>
</tr> <tr>
<td>Currency Symbols</td> <td>Lydian</td> <td>Thaana</td>
</tr> <tr>
<td>Cypriot Syllabary</td> <td>Mahjong Tiles</td> <td>Thai</td>
</tr> <tr>
<td>Cyrillic</td> <td>Malayalam</td> <td>Tibetan</td>
</tr> <tr>
<td>Cyrillic Extended-A</td> <td>Mandaic</td> <td>Tifinagh</td>
</tr> <tr>
<td>Cyrillic Extended-B</td> <td>Mathematical Alphanumeric Symbols</td> <td>Transport And Map Symbols</td>
</tr> <tr>
<td>Cyrillic Supplement</td> <td>Mathematical Operators</td> <td>Ugaritic</td>
</tr> <tr>
<td>Deseret</td> <td>Meetei Mayek</td> <td>Unified Canadian Aboriginal Syllabics</td>
</tr> <tr>
<td>Devanagari</td> <td>Meetei Mayek Extensions</td> <td>Unified Canadian Aboriginal Syllabics Extended</td>
</tr> <tr>
<td>Devanagari Extended</td> <td>Meroitic Cursive</td> <td>Vai</td>
</tr> <tr>
<td>Dingbats</td> <td>Meroitic Hieroglyphs</td> <td>Variation Selectors</td>
</tr> <tr>
<td>Domino Tiles</td> <td>Miao</td> <td>Variation Selectors Supplement</td>
</tr> <tr>
<td>Egyptian Hieroglyphs</td> <td>Miscellaneous Mathematical Symbols-A</td> <td>Vedic Extensions</td>
</tr> <tr>
<td>Emoticons</td> <td>Miscellaneous Mathematical Symbols-B</td> <td>Vertical Forms</td>
</tr> <tr>
<td>Enclosed Alphanumerics</td> <td>Miscellaneous Symbols</td> <td>Yijing Hexagram Symbols</td>
</tr> <tr>
<td>Enclosed Alphanumeric Supplement</td> <td>Miscellaneous Symbols and Arrows</td> <td>Yi Radicals</td>
</tr> <tr>
<td>Enclosed CJK Letters and Months</td> <td>Miscellaneous Symbols And Pictographs</td> <td>Yi Syllables</td>
</tr> <tr>
<td>Enclosed Ideographic Supplement</td> <td>Miscellaneous Technical</td> </tr> <tr>
<td>Ethiopic</td> <td>Modifier Tone Letters</td> </tr> </table> <p>Below is the table with script names accepted by <a href="#unicode.script"><code>unicode.script</code></a> and by the shorthand version <a href="#unicode"><code>unicode</code></a>:</p> <table>
<caption><b>Scripts</b></caption> <tr>
<td>Arabic</td> <td>Hanunoo</td> <td>Old_Italic</td>
</tr> <tr>
<td>Armenian</td> <td>Hebrew</td> <td>Old_Persian</td>
</tr> <tr>
<td>Avestan</td> <td>Hiragana</td> <td>Old_South_Arabian</td>
</tr> <tr>
<td>Balinese</td> <td>Imperial_Aramaic</td> <td>Old_Turkic</td>
</tr> <tr>
<td>Bamum</td> <td>Inherited</td> <td>Oriya</td>
</tr> <tr>
<td>Batak</td> <td>Inscriptional_Pahlavi</td> <td>Osmanya</td>
</tr> <tr>
<td>Bengali</td> <td>Inscriptional_Parthian</td> <td>Phags_Pa</td>
</tr> <tr>
<td>Bopomofo</td> <td>Javanese</td> <td>Phoenician</td>
</tr> <tr>
<td>Brahmi</td> <td>Kaithi</td> <td>Rejang</td>
</tr> <tr>
<td>Braille</td> <td>Kannada</td> <td>Runic</td>
</tr> <tr>
<td>Buginese</td> <td>Katakana</td> <td>Samaritan</td>
</tr> <tr>
<td>Buhid</td> <td>Kayah_Li</td> <td>Saurashtra</td>
</tr> <tr>
<td>Canadian_Aboriginal</td> <td>Kharoshthi</td> <td>Sharada</td>
</tr> <tr>
<td>Carian</td> <td>Khmer</td> <td>Shavian</td>
</tr> <tr>
<td>Chakma</td> <td>Lao</td> <td>Sinhala</td>
</tr> <tr>
<td>Cham</td> <td>Latin</td> <td>Sora_Sompeng</td>
</tr> <tr>
<td>Cherokee</td> <td>Lepcha</td> <td>Sundanese</td>
</tr> <tr>
<td>Common</td> <td>Limbu</td> <td>Syloti_Nagri</td>
</tr> <tr>
<td>Coptic</td> <td>Linear_B</td> <td>Syriac</td>
</tr> <tr>
<td>Cuneiform</td> <td>Lisu</td> <td>Tagalog</td>
</tr> <tr>
<td>Cypriot</td> <td>Lycian</td> <td>Tagbanwa</td>
</tr> <tr>
<td>Cyrillic</td> <td>Lydian</td> <td>Tai_Le</td>
</tr> <tr>
<td>Deseret</td> <td>Malayalam</td> <td>Tai_Tham</td>
</tr> <tr>
<td>Devanagari</td> <td>Mandaic</td> <td>Tai_Viet</td>
</tr> <tr>
<td>Egyptian_Hieroglyphs</td> <td>Meetei_Mayek</td> <td>Takri</td>
</tr> <tr>
<td>Ethiopic</td> <td>Meroitic_Cursive</td> <td>Tamil</td>
</tr> <tr>
<td>Georgian</td> <td>Meroitic_Hieroglyphs</td> <td>Telugu</td>
</tr> <tr>
<td>Glagolitic</td> <td>Miao</td> <td>Thaana</td>
</tr> <tr>
<td>Gothic</td> <td>Mongolian</td> <td>Thai</td>
</tr> <tr>
<td>Greek</td> <td>Myanmar</td> <td>Tibetan</td>
</tr> <tr>
<td>Gujarati</td> <td>New_Tai_Lue</td> <td>Tifinagh</td>
</tr> <tr>
<td>Gurmukhi</td> <td>Nko</td> <td>Ugaritic</td>
</tr> <tr>
<td>Han</td> <td>Ogham</td> <td>Vai</td>
</tr> <tr>
<td>Hangul</td> <td>Ol_Chiki</td> <td>Yi</td>
</tr> </table> <p>Below is the table of names accepted by <a href="#unicode.hangulSyllableType"><code>unicode.hangulSyllableType</code></a>.</p> <table>
<caption><b>Hangul syllable type</b></caption> <tr>
<th scope="col">Abb.</th> <th scope="col">Long form</th>
</tr> <tr>
<td>L</td> <td>Leading_Jamo</td>
</tr> <tr>
<td>LV</td> <td>LV_Syllable</td>
</tr> <tr>
<td>LVT</td> <td>LVT_Syllable</td> </tr> <tr>
<td>T</td> <td>Trailing_Jamo</td>
</tr> <tr>
<td>V</td> <td>Vowel_Jamo</td>
</tr> </table>  <dl>
<dt>References</dt>
<dd> <a href="http://www.digitalmars.com/d/ascii-table.html">ASCII Table</a>, <a href="http://en.wikipedia.org/wiki/Unicode">Wikipedia</a>, <a href="http://www.unicode.org">The Unicode Consortium</a>, <a href="http://www.unicode.org/reports/tr15/">Unicode normalization forms</a>, <a href="http://www.unicode.org/reports/tr29/">Unicode text segmentation</a> <a href="http://www.unicode.org/uni2book/ch05.pdf"> Unicode Implementation Guidelines</a> <a href="http://www.unicode.org/uni2book/ch03.pdf"> Unicode Conformance</a> </dd>
</dl> <dl>
<dt>Trademarks</dt>
<dd> Unicode(tm) is a trademark of Unicode, Inc. </dd>
</dl> <dl>
<dt>License:</dt>
<dd>
<a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>. </dd>
</dl> <dl>
<dt>Authors:</dt>
<dd>Dmitry Olshansky </dd>
</dl> <dl>
<dt>Source</dt>
<dd> <span class="phobos_src"><a class="https" href="https://github.com/dlang/phobos/blob/master/std/uni/package.d">std/uni/package.d</a></span> </dd>
</dl> <dl>
<dt>Standards:</dt>
<dd>
<a href="http://www.unicode.org/versions/Unicode6.2.0/">Unicode v6.2</a> </dd>
</dl> <dl>
<dt class="d_decl" id="lineSep">enum dchar <strong id="lineSep">lineSep</strong>; </dt> <dd>
<p>Constant <a href="#Code%20point">code point</a> (0x2028) - line separator.</p> </dd> <dt class="d_decl" id="paraSep">enum dchar <strong id="paraSep">paraSep</strong>; </dt> <dd>
<p>Constant <a href="#Code%20point">code point</a> (0x2029) - paragraph separator.</p> </dd> <dt class="d_decl" id="nelSep">enum dchar <strong id="nelSep">nelSep</strong>; </dt> <dd>
<p>Constant <a href="#Code%20point">code point</a> (0x0085) - next line.</p> </dd> <dt class="d_decl" id="isCodepointSet">template <strong id="isCodepointSet">isCodepointSet</strong>(T)</dt> <dd>
<p>Tests if T is some kind a set of code points. Intended for template constraints.</p> </dd> <dt class="d_decl" id="isIntegralPair">enum auto <strong id="isIntegralPair">isIntegralPair</strong>(T, V = uint); </dt> <dd>
<p> Tests if <code>T</code> is a pair of integers that implicitly convert to <code>V</code>. The following code must compile for any pair <code>T</code>: <pre data-language="d">(T x){ V a = x[0]; V b = x[1];}
</pre> The following must not compile: <pre data-language="d">(T x){ V c = x[2];}
</pre> </p> </dd> <dt class="d_decl" id="CodepointSet">alias <strong id="CodepointSet">CodepointSet</strong> = InversionList!(GcPolicy).InversionList; </dt> <dd>
<p>The recommended default type for set of <a href="#Code%20point">code points</a>. For details, see the current implementation: <a href="#InversionList"><code>InversionList</code></a>.</p> </dd> <dt class="d_decl" id="CodepointInterval">struct <strong id="CodepointInterval">CodepointInterval</strong>; </dt> <dd>
<p>The recommended type of <a href="std_typecons.html#Tuple"><code>std.typecons.Tuple</code></a> to represent [a, b) intervals of <a href="#Code%20point">code points</a>. As used in <a href="#InversionList"><code>InversionList</code></a>. Any interval type should pass <a href="#isIntegralPair"><code>isIntegralPair</code></a> trait.</p> </dd> <dt class="d_decl" id="InversionList">struct <strong id="InversionList">InversionList</strong>(SP = GcPolicy); </dt> <dd> <p> <code>InversionList</code> is a set of <a href="#Code%20point">code points</a> represented as an array of open-right [a, b) intervals (see <a href="#CodepointInterval"><code>CodepointInterval</code></a> above). The name comes from the way the representation reads left to right. For instance a set of all values [10, 50), [80, 90), plus a singular value 60 looks like this: </p> <pre data-language="d">10, 50, 60, 61, 80, 90
</pre> <p> The way to read this is: start with negative meaning that all numbers smaller then the next one are not present in this set (and positive - the contrary). Then switch positive/negative after each number passed from left to right. </p> <p>This way negative spans until 10, then positive until 50, then negative until 60, then positive until 61, and so on. As seen this provides a space-efficient storage of highly redundant data that comes in long runs. A description which Unicode <a href="#Character">character</a> properties fit nicely. The technique itself could be seen as a variation on <a href="https://en.wikipedia.org/wiki/Run-length_encoding">RLE encoding</a>. </p> <p>Sets are value types (just like <code>int</code> is) thus they are never aliased. </p>  <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto a = CodepointSet('a', 'z'+1);
auto b = CodepointSet('A', 'Z'+1);
auto c = a;
a = a | b;
assert(a == CodepointSet('A', 'Z'+1, 'a', 'z'+1));
assert(a != c);
</pre> <p>See also <a href="#unicode"><code>unicode</code></a> for simpler construction of sets from predefined ones. </p>  <p>Memory usage is 8 bytes per each contiguous interval in a set. The value semantics are achieved by using the <a href="http://en.wikipedia.org/wiki/Copy-on-write">COW</a> technique and thus it's <span class="red">not</span> safe to cast this type to <span class="d_keyword">shared</span>. </p>  <dl>
<dt>Note</dt>

</dl>
<p>It's not recommended to rely on the template parameters or the exact type of a current <a href="#Code%20point">code point</a> set in <code>std.uni</code>. The type and parameters may change when the standard allocators design is finalized. Use <a href="#isCodepointSet"><code>isCodepointSet</code></a> with templates or just stick with the default alias <a href="#CodepointSet"><code>CodepointSet</code></a> throughout the whole code base. </p> <dl>
<dt class="d_decl" id="InversionList.this">pure this(Set)(Set set)<br><small>  Constraints: if (isCodepointSet!Set); </small>
</dt> <dd>
<p>Construct from another code point set of any type.</p> </dd> <dt class="d_decl" id="InversionList.this.2">pure this(Range)(Range intervals)<br><small>  Constraints: if (isForwardRange!Range &amp;&amp; isIntegralPair!(ElementType!Range)); </small>
</dt> <dd>
<p>Construct a set from a forward range of code point intervals.</p> </dd> <dt class="d_decl" id="InversionList.this.3">this()(uint[] intervals...); </dt> <dd>
<p>Construct a set from plain values of code point intervals.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;

auto set = CodepointSet('a', 'z'+1, 'а', 'я'+1);
foreach (v; 'a'..'z'+1)
    assert(set[v]);
// Cyrillic lowercase interval
foreach (v; 'а'..'я'+1)
    assert(set[v]);
//specific order is not required, intervals may interesect
auto set2 = CodepointSet('а', 'я'+1, 'a', 'd', 'b', 'z'+1);
//the same end result
assert(set2.byInterval.equal(set.byInterval));
// test constructor this(Range)(Range intervals)
auto chessPiecesWhite = CodepointInterval(9812, 9818);
auto chessPiecesBlack = CodepointInterval(9818, 9824);
auto set3 = CodepointSet([chessPiecesWhite, chessPiecesBlack]);
foreach (v; '♔'..'♟'+1)
    assert(set3[v]);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="InversionList.byInterval">@property scope auto <strong id="byInterval">byInterval</strong>(); </dt> <dd>
<p>Get range that spans all of the <a href="#Code%20point">code point</a> intervals in this <a href="#InversionList"><code>InversionList</code></a>.</p> </dd> <dt class="d_decl" id="InversionList.opIndex">const bool <strong id="opIndex">opIndex</strong>(uint val); </dt> <dd>
<p>Tests the presence of code point <code>val</code> in this set.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto gothic = unicode.Gothic;
// Gothic letter ahsa
assert(gothic['\U00010330']);
// no ascii in Gothic obviously
assert(!gothic['$']);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="InversionList.length">@property size_t <strong id="length">length</strong>(); </dt> <dd>
<p>Number of <a href="#Code%20point">code points</a> in this set</p> </dd> <dt class="d_decl" id="InversionList.opBinary">This <strong id="opBinary">opBinary</strong>(string op, U)(U rhs)<br><small>  Constraints: if (isCodepointSet!U || is(U : dchar)); </small>
</dt> <dd>
<p>Sets support natural syntax for set algebra, namely: </p> <table>
 <tr>
<th scope="col">Operator</th> <th scope="col">Math notation</th> <th scope="col">Description</th> </tr> <tr>
<td>&amp;</td> <td>a ∩ b</td> <td>intersection</td> </tr> <tr>
<td>|</td> <td>a ∪ b</td> <td>union</td> </tr> <tr>
<td>-</td> <td>a ∖ b</td> <td>subtraction</td> </tr> <tr>
<td>~</td> <td>a ~ b</td> <td>symmetric set difference i.e. (a ∪ b) \ (a ∩ b)</td> </tr> </table>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.range : iota;

auto lower = unicode.LowerCase;
auto upper = unicode.UpperCase;
auto ascii = unicode.ASCII;

assert((lower &amp; upper).empty); // no intersection
auto lowerASCII = lower &amp; ascii;
assert(lowerASCII.byCodepoint.equal(iota('a', 'z'+1)));
// throw away all of the lowercase ASCII
writeln((ascii - lower).length); // 128 - 26

auto onlyOneOf = lower ~ ascii;
assert(!onlyOneOf['Δ']); // not ASCII and not lowercase
assert(onlyOneOf['$']); // ASCII and not lowercase
assert(!onlyOneOf['a']); // ASCII and lowercase
assert(onlyOneOf['я']); // not ASCII but lowercase

// throw away all cased letters from ASCII
auto noLetters = ascii - (lower | upper);
writeln(noLetters.length); // 128 - 26 * 2
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="InversionList.opOpAssign">ref This <strong id="opOpAssign">opOpAssign</strong>(string op, U)(U rhs)<br><small>  Constraints: if (isCodepointSet!U || is(U : dchar)); </small>
</dt> <dd>
<p>The 'op=' versions of the above overloaded operators.</p> </dd> <dt class="d_decl" id="InversionList.opBinaryRight">const bool <strong id="opBinaryRight">opBinaryRight</strong>(string op : "in", U)(U ch)<br><small>  Constraints: if (is(U : dchar)); </small>
</dt> <dd>
<p>Tests the presence of codepoint <code>ch</code> in this set, the same as <a href="#opIndex"><code>opIndex</code></a>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert('я' in unicode.Cyrillic);
assert(!('z' in unicode.Cyrillic));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="InversionList.opUnary">auto <strong id="opUnary">opUnary</strong>(string op : "!")(); </dt> <dd>
<p>Obtains a set that is the inversion of this set. </p>
<dl>
<dt>See Also:</dt>
<dd><a href="#inverted"><code>inverted</code></a></dd>
</dl> </dd> <dt class="d_decl" id="InversionList.byCodepoint">@property auto <strong id="byCodepoint">byCodepoint</strong>(); </dt> <dd>
<p>A range that spans each <a href="#Code%20point">code point</a> in this set.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.range : iota;

auto set = unicode.ASCII;
set.byCodepoint.equal(iota(0, 0x80));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="InversionList.toString">void <strong id="toString">toString</strong>(Writer)(scope Writer sink, ref scope const FormatSpec!char fmt); </dt> <dd>
<p>Obtain a textual representation of this InversionList in form of open-right intervals. </p>
<p>The formatting flag is applied individually to each value, for example: <li>
<b>%s</b> and <b>%d</b> format the intervals as a [low .. high) range of integrals</li> <li>
<b>%x</b> formats the intervals as a [low .. high) range of lowercase hex characters</li> <li>
<b>%X</b> formats the intervals as a [low .. high) range of uppercase hex characters</li></p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.conv : to;
import std.format : format;
import std.uni : unicode;

assert(unicode.Cyrillic.to!string ==
    "[1024..1157) [1159..1320) [7467..7468) [7544..7545) [11744..11776) [42560..42648) [42655..42656)");

// The specs '%s' and '%d' are equivalent to the to!string call above.
writeln(format("%d", unicode.Cyrillic)); // unicode.Cyrillic.to!string

assert(format("%#x", unicode.Cyrillic) ==
    "[0x400..0x485) [0x487..0x528) [0x1d2b..0x1d2c) [0x1d78..0x1d79) [0x2de0..0x2e00) "
    ~"[0xa640..0xa698) [0xa69f..0xa6a0)");

assert(format("%#X", unicode.Cyrillic) ==
    "[0X400..0X485) [0X487..0X528) [0X1D2B..0X1D2C) [0X1D78..0X1D79) [0X2DE0..0X2E00) "
    ~"[0XA640..0XA698) [0XA69F..0XA6A0)");
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="InversionList.add">ref auto <strong id="add">add</strong>()(uint a, uint b); </dt> <dd>
<p>Add an interval [a, b) to this set.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">CodepointSet someSet;
someSet.add('0', '5').add('A','Z'+1);
someSet.add('5', '9'+1);
assert(someSet['0']);
assert(someSet['5']);
assert(someSet['9']);
assert(someSet['Z']);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="InversionList.inverted">@property auto <strong id="inverted">inverted</strong>(); </dt> <dd>
<p>Obtains a set that is the inversion of this set. </p>
<p>See the '!' <a href="#opUnary"><code>opUnary</code></a> for the same but using operators.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto set = unicode.ASCII;
// union with the inverse gets all of the code points in the Unicode
writeln((set | set.inverted).length); // 0x110000
// no intersection with the inverse
assert((set &amp; set.inverted).empty);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="InversionList.toSourceCode">string <strong id="toSourceCode">toSourceCode</strong>(string funcName = ""); </dt> <dd>
<p>Generates string with D source code of unary function with name of <code>funcName</code> taking a single <code>dchar</code> argument. If <code>funcName</code> is empty the code is adjusted to be a lambda function. </p>
<p>The function generated tests if the <a href="#Code%20point">code point</a> passed belongs to this set or not. The result is to be used with string mixin. The intended usage area is aggressive optimization via meta programming in parser generators and the like. </p> <dl>
<dt>Note</dt>
<dd> Use with care for relatively small or regular sets. It could end up being slower then just using multi-staged tables. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">import std.stdio;

// construct set directly from [a, b&amp;dollar;RPAREN intervals
auto set = CodepointSet(10, 12, 45, 65, 100, 200);
writeln(set);
writeln(set.toSourceCode("func"));
</pre>  The above outputs something along the lines of: <pre data-language="d">bool func(dchar ch)  @safe pure nothrow @nogc
{
    if (ch &lt; 45)
    {
        if (ch == 10 || ch == 11) return true;
        return false;
    }
    else if (ch &lt; 65) return true;
    else
    {
        if (ch &lt; 100) return false;
        if (ch &lt; 200) return true;
        return false;
    }
}
</pre>  </dd> <dt class="d_decl" id="InversionList.empty">const @property bool <strong id="empty">empty</strong>(); </dt> <dd>
<p>True if this set doesn't contain any <a href="#Code%20point">code points</a>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">CodepointSet emptySet;
writeln(emptySet.length); // 0
assert(emptySet.empty);
</pre> </dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="codepointSetTrie">template <strong id="codepointSetTrie">codepointSetTrie</strong>(sizes...) if (sumOfIntegerTuple!sizes == 21)</dt> <dd>
<p>A shorthand for creating a custom multi-level fixed Trie from a <code>CodepointSet</code>. <code>sizes</code> are numbers of bits per level, with the most significant bits used first. </p>
<dl>
<dt>Note</dt>
<dd> The sum of <code>sizes</code> must be equal 21. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="#toTrie"><code>toTrie</code></a>, which is even simpler. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">{
    import std.stdio;
    auto set = unicode("Number");
    auto trie = codepointSetTrie!(8, 5, 8)(set);
    writeln("Input code points to test:");
    foreach (line; stdin.byLine)
    {
        int count=0;
        foreach (dchar ch; line)
            if (trie[ch])// is number
                count++;
        writefln("Contains %d number code points.", count);
    }
}
</pre>  </dd> <dt class="d_decl" id="CodepointSetTrie">template <strong id="CodepointSetTrie">CodepointSetTrie</strong>(sizes...) if (sumOfIntegerTuple!sizes == 21)</dt> <dd>
<p>Type of Trie generated by codepointSetTrie function.</p> </dd> <dt class="d_decl" id="codepointTrie">template <strong id="codepointTrie">codepointTrie</strong>(T, sizes...) if (sumOfIntegerTuple!sizes == 21)<br><br>template <strong id="CodepointTrie">CodepointTrie</strong>(T, sizes...) if (sumOfIntegerTuple!sizes == 21)</dt> <dd>
<p>A slightly more general tool for building fixed <code>Trie</code> for the Unicode data. </p>
<p>Specifically unlike <code>codepointSetTrie</code> it's allows creating mappings of <code>dchar</code> to an arbitrary type <code>T</code>. </p> <dl>
<dt>Note</dt>
<dd> Overload taking <code>CodepointSet</code>s will naturally convert only to bool mapping <code>Trie</code>s. </dd>
</dl> CodepointTrie is the type of Trie as generated by codepointTrie function. <dl>
<dt class="d_decl" id="codepointTrie.codepointTrie">auto <strong id="codepointTrie">codepointTrie</strong>()(T[dchar] map, T defValue = T.init); </dt>  <dt class="d_decl" id="codepointTrie.codepointTrie.2">auto <strong id="codepointTrie">codepointTrie</strong>(R)(R range, T defValue = T.init)<br><small>  Constraints: if (isInputRange!R &amp;&amp; is(typeof(ElementType!R.init[0]) : T) &amp;&amp; is(typeof(ElementType!R.init[1]) : dchar)); </small>
</dt>  </dl> </dd> <dt class="d_decl" id="MatcherConcept">struct <strong id="MatcherConcept">MatcherConcept</strong>; </dt> <dd>
<p>Conceptual type that outlines the common properties of all UTF Matchers. </p>
<dl>
<dt>Note</dt>
<dd> For illustration purposes only, every method call results in assertion failure. Use <a href="#utfMatcher"><code>utfMatcher</code></a> to obtain a concrete matcher for UTF-8 or UTF-16 encodings.</dd>
</dl> <dl>
<dt class="d_decl" id="MatcherConcept.match">bool <strong id="match">match</strong>(Range)(ref Range inp)<br><small>  Constraints: if (isRandomAccessRange!Range &amp;&amp; is(ElementType!Range : char)); </small><br><br>bool <strong id="skip">skip</strong>(Range)(ref Range inp)<br><small>  Constraints: if (isRandomAccessRange!Range &amp;&amp; is(ElementType!Range : char)); </small><br><br>bool <strong id="test">test</strong>(Range)(ref Range inp)<br><small>  Constraints: if (isRandomAccessRange!Range &amp;&amp; is(ElementType!Range : char)); </small>
</dt> <dd>
<p>Perform a semantic equivalent 2 operations: decoding a <a href="#Code%20point">code point</a> at front of <code>inp</code> and testing if it belongs to the set of <a href="#Code%20point">code points</a> of this matcher. </p> <p>The effect on <code>inp</code> depends on the kind of function called:</p> <br><br> <p>Match. If the codepoint is found in the set then range <code>inp</code> is advanced by its size in <a href="#Code%20unit">code units</a>, otherwise the range is not modifed.</p> <br><br> <p>Skip. The range is always advanced by the size of the tested <a href="#Code%20point">code point</a> regardless of the result of test.</p> <br><br> <p>Test. The range is left unaffected regardless of the result of test.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">string truth = "2² = 4";
auto m = utfMatcher!char(unicode.Number);
assert(m.match(truth)); // '2' is a number all right
assert(truth == "² = 4"); // skips on match
assert(m.match(truth)); // so is the superscript '2'
assert(!m.match(truth)); // space is not a number
assert(truth == " = 4"); // unaffected on no match
assert(!m.skip(truth)); // same test ...
assert(truth == "= 4"); // but skips a codepoint regardless
assert(!m.test(truth)); // '=' is not a number
assert(truth == "= 4"); // test never affects argument
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="MatcherConcept.subMatcher">@property auto <strong id="subMatcher">subMatcher</strong>(Lengths...)(); </dt> <dd>
<p>Advanced feature - provide direct access to a subset of matcher based a set of known encoding lengths. Lengths are provided in <a href="#Code%20unit">code units</a>. The sub-matcher then may do less operations per any <code>test</code>/<code>match</code>. </p>
<p>Use with care as the sub-matcher won't match any <a href="#Code%20point">code points</a> that have encoded length that doesn't belong to the selected set of lengths. Also the sub-matcher object references the parent matcher and must not be used past the liftetime of the latter. <br><br> Another caveat of using sub-matcher is that skip is not available preciesly because sub-matcher doesn't detect all lengths.</p> </dd> </dl> </dd> <dt class="d_decl" id="isUtfMatcher">enum auto <strong id="isUtfMatcher">isUtfMatcher</strong>(M, C); </dt> <dd>
<p>Test if <code>M</code> is an UTF Matcher for ranges of <code>Char</code>.</p> </dd> <dt class="d_decl" id="utfMatcher">auto <strong id="utfMatcher">utfMatcher</strong>(Char, Set)(Set set)<br><small>  Constraints: if (isCodepointSet!Set); </small>
</dt> <dd>
<p>Constructs a matcher object to classify <a href="#Code%20point">code points</a> from the <code>set</code> for encoding that has <code>Char</code> as code unit. </p>
<p>See <a href="#MatcherConcept"><code>MatcherConcept</code></a> for API outline.</p> </dd> <dt class="d_decl" id="toTrie">auto <strong id="toTrie">toTrie</strong>(size_t level, Set)(Set set)<br><small>  Constraints: if (isCodepointSet!Set); </small>
</dt> <dd>
<p>Convenience function to construct optimal configurations for packed Trie from any <code>set</code> of <a href="#Code%20point">code points</a>. </p>The parameter <code>level</code> indicates the number of trie levels to use, allowed values are: 1, 2, 3 or 4. Levels represent different trade-offs speed-size wise. <br><br> <p>Level 1 is fastest and the most memory hungry (a bit array). </p> <p>Level 4 is the slowest and has the smallest footprint. </p> <br><br> See the <a href="#Synopsis">Synopsis</a> section for example.  <dl>
<dt>Note</dt>
<dd> Level 4 stays very practical (being faster and more predictable) compared to using direct lookup on the <code>set</code> itself.</dd>
</dl> </dd> <dt class="d_decl" id="toDelegate">auto <strong id="toDelegate">toDelegate</strong>(Set)(Set set)<br><small>  Constraints: if (isCodepointSet!Set); </small>
</dt> <dd>
<p>Builds a <code>Trie</code> with typically optimal speed-size trade-off and wraps it into a delegate of the following type: <code>bool delegate(dchar ch)</code>. </p> <p>Effectively this creates a 'tester' lambda suitable for algorithms like std.algorithm.find that take unary predicates. </p> <br><br> See the <a href="#Synopsis">Synopsis</a> section for example. </dd> <dt class="d_decl" id="unicode">struct <strong id="unicode">unicode</strong>; </dt> <dd>
<p>A single entry point to lookup Unicode <a href="#Code%20point">code point</a> sets by name or alias of a block, script or general category. </p>
<p>It uses well defined standard rules of property name lookup. This includes fuzzy matching of names, so that 'White_Space', 'white-SpAce' and 'whitespace' are all considered equal and yield the same set of white space <a href="#Character">characters</a>.</p> <dl>
<dt class="d_decl" id="unicode.opDispatch">pure @property auto <strong id="opDispatch">opDispatch</strong>(string name)(); </dt> <dd>
<p>Performs the lookup of set of <a href="#Code%20point">code points</a> with compile-time correctness checking. This short-cut version combines 3 searches: across blocks, scripts, and common binary properties. </p>
<p>Note that since scripts and blocks overlap the usual trick to disambiguate is used - to get a block use <code>unicode.InBlockName</code>, to search a script use <code>unicode.ScriptName</code>. </p> <dl>
<dt>See Also:</dt>
<dd>
<a href="#block"><code>block</code></a>, <a href="#script"><code>script</code></a> and (not included in this search) <a href="#hangulSyllableType"><code>hangulSyllableType</code></a>.</dd>
</dl> </dd> <dt class="d_decl" id="unicode.opCall">auto <strong id="opCall">opCall</strong>(C)(scope const C[] name)<br><small>  Constraints: if (is(C : dchar)); </small>
</dt> <dd>
<p>The same lookup across blocks, scripts, or binary properties, but performed at run-time. This version is provided for cases where <code>name</code> is not known beforehand; otherwise compile-time checked <a href="#opDispatch"><code>opDispatch</code></a> is typically a better choice. </p>
<p>See the <a href="#Unicode%20properties">table of properties</a> for available sets.</p> </dd> <dt class="d_decl" id="unicode.block">struct <strong id="block">block</strong>; </dt> <dd>
<p>Narrows down the search for sets of <a href="#Code%20point">code points</a> to all Unicode blocks. </p>
<dl>
<dt>Note</dt>
<dd> Here block names are unambiguous as no scripts are searched and thus to search use simply <code>unicode.block.BlockName</code> notation. </dd>
</dl> See <a href="#Unicode%20properties">table of properties</a> for available sets.  <dl>
<dt>See Also:</dt>
<dd>
<a href="#Unicode%20properties">table of properties</a>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">// use .block for explicitness
writeln(unicode.block.Greek_and_Coptic); // unicode.InGreek_and_Coptic
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="unicode.script">struct <strong id="script">script</strong>; </dt> <dd>
<p>Narrows down the search for sets of <a href="#Code%20point">code points</a> to all Unicode scripts. </p>
<p>See the <a href="#Unicode%20properties">table of properties</a> for available sets.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto arabicScript = unicode.script.arabic;
auto arabicBlock = unicode.block.arabic;
// there is an intersection between script and block
assert(arabicBlock['؁']);
assert(arabicScript['؁']);
// but they are different
assert(arabicBlock != arabicScript);
writeln(arabicBlock); // unicode.inArabic
writeln(arabicScript); // unicode.arabic
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="unicode.hangulSyllableType">struct <strong id="hangulSyllableType">hangulSyllableType</strong>; </dt> <dd>
<p>Fetch a set of <a href="#Code%20point">code points</a> that have the given hangul syllable type. </p>
<p>Other non-binary properties (once supported) follow the same notation - <code>unicode.propertyName.propertyValue</code> for compile-time checked access and <code>unicode.propertyName(propertyValue)</code> for run-time checked one. <br><br> See the <a href="#Unicode%20properties">table of properties</a> for available sets.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">// L here is syllable type not Letter as in unicode.L short-cut
auto leadingVowel = unicode.hangulSyllableType("L");
// check that some leading vowels are present
foreach (vowel; '\u1110'..'\u115F')
    assert(leadingVowel[vowel]);
writeln(leadingVowel); // unicode.hangulSyllableType.L
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="unicode.parseSet">CodepointSet <strong id="parseSet">parseSet</strong>(Range)(ref Range range, bool casefold = false)<br><small>  Constraints: if (isInputRange!Range &amp;&amp; is(ElementType!Range : dchar)); </small>
</dt> <dd>
<p>Parse unicode codepoint set from given <code>range</code> using standard regex syntax '[...]'. The range is advanced skiping over regex set definition. <code>casefold</code> parameter determines if the set should be casefolded - that is include both lower and upper case versions for any letters in the set.</p> </dd> </dl> </dd> <dt class="d_decl" id="graphemeStride">pure @safe size_t <strong id="graphemeStride">graphemeStride</strong>(C)(scope const C[] input, size_t index)<br><small>  Constraints: if (is(C : dchar)); </small>
</dt> <dd>
<p>Computes the length of grapheme cluster starting at <code>index</code>. Both the resulting length and the <code>index</code> are measured in <a href="#Code%20unit">code units</a>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>C</td> <td>type that is implicitly convertible to <code>dchars</code>
</td>
</tr> <tr>
<td>C[] <code>input</code>
</td> <td>array of grapheme clusters</td>
</tr> <tr>
<td>size_t <code>index</code>
</td> <td>starting index into <code>input[]</code>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>length of grapheme cluster</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(graphemeStride("  ", 1)); // 1
// A + combing ring above
string city = "A\u030Arhus";
size_t first = graphemeStride(city, 0);
assert(first == 3); //\u030A has 2 UTF-8 code units
writeln(city[0 .. first]); // "A\u030A"
writeln(city[first .. $]); // "rhus"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="decodeGrapheme">Grapheme <strong id="decodeGrapheme">decodeGrapheme</strong>(Input)(ref Input inp)<br><small>  Constraints: if (isInputRange!Input &amp;&amp; is(immutable(ElementType!Input) == immutable(dchar))); </small>
</dt> <dd>
<p>Reads one full grapheme cluster from an <a href="std_range_primitives.html#isInputRange">input range</a> of dchar <code>inp</code>. </p>
<p>For examples see the <a href="#Grapheme"><code>Grapheme</code></a> below. </p> <dl>
<dt>Note</dt>
<dd> This function modifies <code>inp</code> and thus <code>inp</code> must be an L-value.</dd>
</dl> </dd> <dt class="d_decl" id="byGrapheme">auto <strong id="byGrapheme">byGrapheme</strong>(Range)(Range range)<br><small>  Constraints: if (isInputRange!Range &amp;&amp; is(immutable(ElementType!Range) == immutable(dchar))); </small>
</dt> <dd>
<p>Iterate a string by <a href="#Grapheme"><code>Grapheme</code></a>.</p> <p>Useful for doing string manipulation that needs to be aware of graphemes.</p>  <dl>
<dt>See Also:</dt>
<dd><a href="#byCodePoint"><code>byCodePoint</code></a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.range.primitives : walkLength;
import std.range : take, drop;
auto text = "noe\u0308l"; // noël using e + combining diaeresis
assert(text.walkLength == 5); // 5 code points

auto gText = text.byGrapheme;
assert(gText.walkLength == 4); // 4 graphemes

assert(gText.take(3).equal("noe\u0308".byGrapheme));
assert(gText.drop(3).equal("l".byGrapheme));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="byCodePoint">auto <strong id="byCodePoint">byCodePoint</strong>(Range)(Range range)<br><small>  Constraints: if (isInputRange!Range &amp;&amp; is(immutable(ElementType!Range) == immutable(Grapheme))); </small><br><br>auto <strong id="byCodePoint">byCodePoint</strong>(Range)(Range range)<br><small>  Constraints: if (isInputRange!Range &amp;&amp; is(immutable(ElementType!Range) == immutable(dchar))); </small>
</dt> <dd>
<p>Lazily transform a range of <a href="#Grapheme"><code>Grapheme</code></a>s to a range of code points.</p> <p>Useful for converting the result to a string after doing operations on graphemes.</p> <br><br> <p>If passed in a range of code points, returns a range with equivalent capabilities.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.array : array;
import std.conv : text;
import std.range : retro;

string s = "noe\u0308l"; // noël

// reverse it and convert the result to a string
string reverse = s.byGrapheme
    .array
    .retro
    .byCodePoint
    .text;

assert(reverse == "le\u0308on"); // lëon
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Grapheme">struct <strong id="Grapheme">Grapheme</strong>; </dt> <dd>
<p>A structure designed to effectively pack <a href="#Character">characters</a> of a <a href="#Grapheme%20cluster">grapheme cluster</a>. </p> <p><code>Grapheme</code> has value semantics so 2 copies of a <code>Grapheme</code> always refer to distinct objects. In most actual scenarios a <code>Grapheme</code> fits on the stack and avoids memory allocation overhead for all but quite long clusters. </p>  <dl>
<dt>See Also:</dt>
<dd>
<a href="#decodeGrapheme"><code>decodeGrapheme</code></a>, <a href="#graphemeStride"><code>graphemeStride</code></a>
</dd>
</dl> <dl>
<dt class="d_decl" id="Grapheme.this">this(C)(scope const C[] chars...)<br><small>  Constraints: if (is(C : dchar)); </small><br><br>this(Input)(Input seq)<br><small>  Constraints: if (!isDynamicArray!Input &amp;&amp; isInputRange!Input &amp;&amp; is(ElementType!Input : dchar)); </small>
</dt> <dd>
<p>Ctor</p> </dd> <dt class="d_decl" id="Grapheme.opIndex">const pure nothrow @nogc @trusted dchar <strong id="opIndex">opIndex</strong>(size_t index); </dt> <dd>
<p>Gets a <a href="#Code%20point">code point</a> at the given index in this cluster.</p> </dd> <dt class="d_decl" id="Grapheme.opIndexAssign">pure nothrow @nogc @trusted void <strong id="opIndexAssign">opIndexAssign</strong>(dchar ch, size_t index); </dt> <dd>
<p>Writes a <a href="#Code%20point">code point</a> <code>ch</code> at given index in this cluster. </p>
<dl>
<dt>Warning</dt>
<dd> Use of this facility may invalidate grapheme cluster, see also <a href="#Grapheme.valid"><code>Grapheme.valid</code></a>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto g = Grapheme("A\u0302");
writeln(g[0]); // 'A'
assert(g.valid);
g[1] = '~'; // ASCII tilda is not a combining mark
writeln(g[1]); // '~'
assert(!g.valid);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Grapheme.opSlice">pure nothrow @nogc @safe SliceOverIndexed!Grapheme <strong id="opSlice">opSlice</strong>(size_t a, size_t b) return; <br><br>pure nothrow @nogc @safe SliceOverIndexed!Grapheme <strong id="opSlice">opSlice</strong>() return; </dt> <dd>
<p>Random-access range over Grapheme's <a href="#Character">characters</a>. </p>
<dl>
<dt>Warning</dt>
<dd> Invalidates when this Grapheme leaves the scope, attempts to use it then would lead to memory corruption.</dd>
</dl> </dd> <dt class="d_decl" id="Grapheme.length">const pure nothrow @nogc @property @safe size_t <strong id="length">length</strong>(); </dt> <dd>
<p>Grapheme cluster length in <a href="#Code%20point">code points</a>.</p> </dd> <dt class="d_decl" id="Grapheme.opOpAssign">ref @trusted auto <strong id="opOpAssign">opOpAssign</strong>(string op)(dchar ch); </dt> <dd>
<p>Append <a href="#Character">character</a> <code>ch</code> to this grapheme. </p>
<dl>
<dt>Warning</dt>
<dd> Use of this facility may invalidate grapheme cluster, see also <code>valid</code>. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd><a href="#Grapheme.valid"><code>Grapheme.valid</code></a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
auto g = Grapheme("A");
assert(g.valid);
g ~= '\u0301';
assert(g[].equal("A\u0301"));
assert(g.valid);
g ~= "B";
// not a valid grapheme cluster anymore
assert(!g.valid);
// still could be useful though
assert(g[].equal("A\u0301B"));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Grapheme.opOpAssign.2">ref auto <strong id="opOpAssign">opOpAssign</strong>(string op, Input)(scope Input inp)<br><small>  Constraints: if (isInputRange!Input &amp;&amp; is(ElementType!Input : dchar)); </small>
</dt> <dd>
<p>Append all <a href="#Character">characters</a> from the input range <code>inp</code> to this Grapheme.</p> </dd> <dt class="d_decl" id="Grapheme.valid">@property bool <strong id="valid">valid</strong>()(); </dt> <dd>
<p>True if this object contains valid extended grapheme cluster. Decoding primitives of this module always return a valid <code>Grapheme</code>. </p>
<p>Appending to and direct manipulation of grapheme's <a href="#Character">characters</a> may render it no longer valid. Certain applications may chose to use Grapheme as a "small string" of any <a href="#Code%20point">code points</a> and ignore this property entirely.</p> </dd> </dl> </dd> <dt class="d_decl" id="sicmp">int <strong id="sicmp">sicmp</strong>(S1, S2)(scope S1 r1, scope S2 r2)<br><small>  Constraints: if (isInputRange!S1 &amp;&amp; isSomeChar!(ElementEncodingType!S1) &amp;&amp; isInputRange!S2 &amp;&amp; isSomeChar!(ElementEncodingType!S2)); </small>
</dt> <dd>
<p>Does basic case-insensitive comparison of <code>r1</code> and <code>r2</code>. This function uses simpler comparison rule thus achieving better performance than <a href="#icmp"><code>icmp</code></a>. However keep in mind the warning below.</p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>S1 <code>r1</code>
</td> <td>an <a href="std_range_primitives.html#isInputRange">input range</a> of characters</td>
</tr> <tr>
<td>S2 <code>r2</code>
</td> <td>an <a href="std_range_primitives.html#isInputRange">input range</a> of characters</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>An <code>int</code> that is 0 if the strings match, &lt;0 if <code>r1</code> is lexicographically "less" than <code>r2</code>, &gt;0 if <code>r1</code> is lexicographically "greater" than <code>r2</code> </dd>
</dl> <dl>
<dt>Warning</dt>
<dd> This function only handles 1:1 <a href="#Code%20point">code point</a> mapping and thus is not sufficient for certain alphabets like German, Greek and few others. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="#icmp"><code>icmp</code></a> <a href="std_algorithm_comparison.html#cmp"><code>std.algorithm.comparison.cmp</code></a>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(sicmp("Август", "авгусТ")); // 0
// Greek also works as long as there is no 1:M mapping in sight
writeln(sicmp("ΌΎ", "όύ")); // 0
// things like the following won't get matched as equal
// Greek small letter iota with dialytika and tonos
assert(sicmp("ΐ", "\u03B9\u0308\u0301") != 0);

// while icmp has no problem with that
writeln(icmp("ΐ", "\u03B9\u0308\u0301")); // 0
writeln(icmp("ΌΎ", "όύ")); // 0
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="icmp">int <strong id="icmp">icmp</strong>(S1, S2)(S1 r1, S2 r2)<br><small>  Constraints: if (isForwardRange!S1 &amp;&amp; isSomeChar!(ElementEncodingType!S1) &amp;&amp; isForwardRange!S2 &amp;&amp; isSomeChar!(ElementEncodingType!S2)); </small>
</dt> <dd>
<p>Does case insensitive comparison of <code>r1</code> and <code>r2</code>. Follows the rules of full case-folding mapping. This includes matching as equal german ß with "ss" and other 1:M <a href="#Code%20point">code point</a> mappings unlike <a href="#sicmp"><code>sicmp</code></a>. The cost of <code>icmp</code> being pedantically correct is slightly worse performance. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>S1 <code>r1</code>
</td> <td>a forward range of characters</td>
</tr> <tr>
<td>S2 <code>r2</code>
</td> <td>a forward range of characters</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>An <code>int</code> that is 0 if the strings match, &lt;0 if <code>str1</code> is lexicographically "less" than <code>str2</code>, &gt;0 if <code>str1</code> is lexicographically "greater" than <code>str2</code> </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="#sicmp"><code>sicmp</code></a> <a href="std_algorithm_comparison.html#cmp"><code>std.algorithm.comparison.cmp</code></a>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(icmp("Rußland", "Russland")); // 0
writeln(icmp("ᾩ -&gt; \u1F70\u03B9", "\u1F61\u03B9 -&gt; ᾲ")); // 0
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>By using <a href="std_utf.html#byUTF"><code>std.utf.byUTF</code></a> and its aliases, GC allocations via auto-decoding and thrown exceptions can be avoided, making <code>icmp</code> <code>@safe @nogc nothrow pure</code>. <pre data-language="d">import std.utf : byDchar;

writeln(icmp("Rußland".byDchar, "Russland".byDchar)); // 0
writeln(icmp("ᾩ -&gt; \u1F70\u03B9".byDchar, "\u1F61\u03B9 -&gt; ᾲ".byDchar)); // 0
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="combiningClass">pure nothrow @nogc @safe ubyte <strong id="combiningClass">combiningClass</strong>(dchar ch); </dt> <dd>
<p>Returns the <a href="#Combining%20class">combining class</a> of <code>ch</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">// shorten the code
alias CC = combiningClass;

// combining tilda
writeln(CC('\u0303')); // 230
// combining ring below
writeln(CC('\u0325')); // 220
// the simple consequence is that  "tilda" should be
// placed after a "ring below" in a sequence
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="UnicodeDecomposition">enum <strong id="UnicodeDecomposition">UnicodeDecomposition</strong>: int; </dt> <dd>
<p>Unicode character decomposition type.</p> <dl>
<dt class="d_decl" id="UnicodeDecomposition.Canonical"><strong id="Canonical">Canonical</strong></dt> <dd>
<p>Canonical decomposition. The result is canonically equivalent sequence.</p> </dd> <dt class="d_decl" id="UnicodeDecomposition.Compatibility"><strong id="Compatibility">Compatibility</strong></dt> <dd>
<p>Compatibility decomposition. The result is compatibility equivalent sequence. </p>
<dl>
<dt>Note</dt>
<dd> Compatibility decomposition is a <b>lossy</b> conversion, typically suitable only for fuzzy matching and internal processing.</dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="compose">pure nothrow @safe dchar <strong id="compose">compose</strong>(dchar first, dchar second); </dt> <dd>
<p>Try to canonically compose 2 <a href="#Character">characters</a>. Returns the composed <a href="#Character">character</a> if they do compose and dchar.init otherwise. </p>
<p>The assumption is that <code>first</code> comes before <code>second</code> in the original text, usually meaning that the first is a starter. </p> <dl>
<dt>Note</dt>
<dd> Hangul syllables are not covered by this function. See <code>composeJamo</code> below.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(compose('A', '\u0308')); // '\u00C4'
writeln(compose('A', 'B')); // dchar.init
writeln(compose('C', '\u0301')); // '\u0106'
// note that the starter is the first one
// thus the following doesn't compose
writeln(compose('\u0308', 'A')); // dchar.init
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="decompose">@safe Grapheme <strong id="decompose">decompose</strong>(UnicodeDecomposition decompType = Canonical)(dchar ch); </dt> <dd>
<p>Returns a full <a href="#Canonical%20decomposition">Canonical</a> (by default) or <a href="#Compatibility%20decomposition">Compatibility</a> decomposition of <a href="#Character">character</a> <code>ch</code>. If no decomposition is available returns a <a href="#Grapheme"><code>Grapheme</code></a> with the <code>ch</code> itself. </p>
<dl>
<dt>Note</dt>
<dd> This function also decomposes hangul syllables as prescribed by the standard. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="#decomposeHangul"><code>decomposeHangul</code></a> for a restricted version that takes into account only hangul syllables but no other decompositions.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;

writeln(compose('A', '\u0308')); // '\u00C4'
writeln(compose('A', 'B')); // dchar.init
writeln(compose('C', '\u0301')); // '\u0106'
// note that the starter is the first one
// thus the following doesn't compose
writeln(compose('\u0308', 'A')); // dchar.init

assert(decompose('Ĉ')[].equal("C\u0302"));
assert(decompose('D')[].equal("D"));
assert(decompose('\uD4DC')[].equal("\u1111\u1171\u11B7"));
assert(decompose!Compatibility('¹')[].equal("1"));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="decomposeHangul">@safe Grapheme <strong id="decomposeHangul">decomposeHangul</strong>(dchar ch); </dt> <dd>
<p>Decomposes a Hangul syllable. If <code>ch</code> is not a composed syllable then this function returns <a href="#Grapheme"><code>Grapheme</code></a> containing only <code>ch</code> as is.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
assert(decomposeHangul('\uD4DB')[].equal("\u1111\u1171\u11B6"));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="composeJamo">pure nothrow @nogc @safe dchar <strong id="composeJamo">composeJamo</strong>(dchar lead, dchar vowel, dchar trailing = (dchar).init); </dt> <dd>
<p>Try to compose hangul syllable out of a leading consonant (<code>lead</code>), a <code>vowel</code> and optional <code>trailing</code> consonant jamos. </p>
<p>On success returns the composed LV or LVT hangul syllable. <br><br> If any of <code>lead</code> and <code>vowel</code> are not a valid hangul jamo of the respective <a href="#Character">character</a> class returns dchar.init.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(composeJamo('\u1111', '\u1171', '\u11B6')); // '\uD4DB'
// leaving out T-vowel, or passing any codepoint
// that is not trailing consonant composes an LV-syllable
writeln(composeJamo('\u1111', '\u1171')); // '\uD4CC'
writeln(composeJamo('\u1111', '\u1171', ' ')); // '\uD4CC'
writeln(composeJamo('\u1111', 'A')); // dchar.init
writeln(composeJamo('A', '\u1171')); // dchar.init
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="NormalizationForm">enum <strong id="NormalizationForm">NormalizationForm</strong>: int; </dt> <dd>
<p>Enumeration type for normalization forms, passed as template parameter for functions like <a href="#normalize"><code>normalize</code></a>.</p> </dd> <dt class="d_decl" id="NFC">
<strong id="NFC">NFC</strong><br><br><strong id="NFD">NFD</strong><br><br><strong id="NFKC">NFKC</strong><br><br><strong id="NFKD">NFKD</strong>
</dt> <dd>
<p>Shorthand aliases from values indicating normalization forms.</p> </dd> <dt class="d_decl" id="normalize">inout(C)[] <strong id="normalize">normalize</strong>(NormalizationForm norm = NFC, C)(inout(C)[] input); </dt> <dd>
<p>Returns <code>input</code> string normalized to the chosen form. Form C is used by default. </p>
<p>For more information on normalization forms see the <a href="#Normalization">normalization section</a>. </p> <dl>
<dt>Note</dt>
<dd> In cases where the string in question is already normalized, it is returned unmodified and no memory allocation happens.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">// any encoding works
wstring greet = "Hello world";
assert(normalize(greet) is greet); // the same exact slice

// An example of a character with all 4 forms being different:
// Greek upsilon with acute and hook symbol (code point 0x03D3)
writeln(normalize!NFC("ϓ")); // "\u03D3"
writeln(normalize!NFD("ϓ")); // "\u03D2\u0301"
writeln(normalize!NFKC("ϓ")); // "\u038E"
writeln(normalize!NFKD("ϓ")); // "\u03A5\u0301"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="allowedIn">bool <strong id="allowedIn">allowedIn</strong>(NormalizationForm norm)(dchar ch); </dt> <dd>
<p>Tests if dchar <code>ch</code> is always allowed (Quick_Check=YES) in normalization form <code>norm</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">// e.g. Cyrillic is always allowed, so is ASCII
assert(allowedIn!NFC('я'));
assert(allowedIn!NFD('я'));
assert(allowedIn!NFKC('я'));
assert(allowedIn!NFKD('я'));
assert(allowedIn!NFC('Z'));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isWhite">pure nothrow @nogc @safe bool <strong id="isWhite">isWhite</strong>(dchar c); </dt> <dd>
<p>Whether or not <code>c</code> is a Unicode whitespace <a href="#Character">character</a>. (general Unicode category: Part of C0(tab, vertical tab, form feed, carriage return, and linefeed characters), Zs, Zl, Zp, and NEL(U+0085))</p> </dd> <dt class="d_decl" id="isLower">pure nothrow @nogc @safe bool <strong id="isLower">isLower</strong>(dchar c); </dt> <dd>
<p>Return whether <code>c</code> is a Unicode lowercase <a href="#Character">character</a>.</p> </dd> <dt class="d_decl" id="isUpper">pure nothrow @nogc @safe bool <strong id="isUpper">isUpper</strong>(dchar c); </dt> <dd>
<p>Return whether <code>c</code> is a Unicode uppercase <a href="#Character">character</a>.</p> </dd> <dt class="d_decl" id="asLowerCase">auto <strong id="asLowerCase">asLowerCase</strong>(Range)(Range str)<br><small>  Constraints: if (isInputRange!Range &amp;&amp; isSomeChar!(ElementEncodingType!Range) &amp;&amp; !isConvertibleToString!Range); </small><br><br>auto <strong id="asUpperCase">asUpperCase</strong>(Range)(Range str)<br><small>  Constraints: if (isInputRange!Range &amp;&amp; isSomeChar!(ElementEncodingType!Range) &amp;&amp; !isConvertibleToString!Range); </small>
</dt> <dd>
<p>Convert an <a href="std_range_primitives.html#isInputRange">input range</a> or a string to upper or lower case. </p>
<p>Does not allocate memory. Characters in UTF-8 or UTF-16 format that cannot be decoded are treated as <a href="std_utf.html#replacementDchar"><code>std.utf.replacementDchar</code></a>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>str</code>
</td> <td>string or range of characters</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>an input range of <code>dchar</code>s </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="#toUpper"><code>toUpper</code></a>, <a href="#toLower"><code>toLower</code></a>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;

assert("hEllo".asUpperCase.equal("HELLO"));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="asCapitalized">auto <strong id="asCapitalized">asCapitalized</strong>(Range)(Range str)<br><small>  Constraints: if (isInputRange!Range &amp;&amp; isSomeChar!(ElementEncodingType!Range) &amp;&amp; !isConvertibleToString!Range); </small>
</dt> <dd>
<p>Capitalize an <a href="std_range_primitives.html#isInputRange">input range</a> or string, meaning convert the first character to upper case and subsequent characters to lower case. </p>
<p>Does not allocate memory. Characters in UTF-8 or UTF-16 format that cannot be decoded are treated as <a href="std_utf.html#replacementDchar"><code>std.utf.replacementDchar</code></a>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>str</code>
</td> <td>string or range of characters</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>an InputRange of dchars </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="#toUpper"><code>toUpper</code></a>, <a href="#toLower"><code>toLower</code></a> <a href="#asUpperCase"><code>asUpperCase</code></a>, <a href="#asLowerCase"><code>asLowerCase</code></a>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;

assert("hEllo".asCapitalized.equal("Hello"));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="toLowerInPlace">pure @trusted void <strong id="toLowerInPlace">toLowerInPlace</strong>(C)(ref C[] s)<br><small>  Constraints: if (is(C == char) || is(C == wchar) || is(C == dchar)); </small>
</dt> <dd>
<p>Converts <code>s</code> to lowercase (by performing Unicode lowercase mapping) in place. For a few characters string length may increase after the transformation, in such a case the function reallocates exactly once. If <code>s</code> does not have any uppercase characters, then <code>s</code> is unaltered.</p> </dd> <dt class="d_decl" id="toUpperInPlace">pure @trusted void <strong id="toUpperInPlace">toUpperInPlace</strong>(C)(ref C[] s)<br><small>  Constraints: if (is(C == char) || is(C == wchar) || is(C == dchar)); </small>
</dt> <dd>
<p>Converts <code>s</code> to uppercase (by performing Unicode uppercase mapping) in place. For a few characters string length may increase after the transformation, in such a case the function reallocates exactly once. If <code>s</code> does not have any lowercase characters, then <code>s</code> is unaltered.</p> </dd> <dt class="d_decl" id="toLower">pure nothrow @nogc @safe dchar <strong id="toLower">toLower</strong>(dchar c); </dt> <dd>
<p>If <code>c</code> is a Unicode uppercase <a href="#Character">character</a>, then its lowercase equivalent is returned. Otherwise <code>c</code> is returned. </p>
<dl>
<dt>Warning</dt>
<dd> certain alphabets like German and Greek have no 1:1 upper-lower mapping. Use overload of toLower which takes full string instead.</dd>
</dl> </dd> <dt class="d_decl" id="toLower.2">ElementEncodingType!S[] <strong id="toLower">toLower</strong>(S)(S s)<br><small>  Constraints: if (isSomeString!S || isRandomAccessRange!S &amp;&amp; hasLength!S &amp;&amp; hasSlicing!S &amp;&amp; isSomeChar!(ElementType!S)); </small>
</dt> <dd>
<p>Creates a new array which is identical to <code>s</code> except that all of its characters are converted to lowercase (by preforming Unicode lowercase mapping). If none of <code>s</code> characters were affected, then <code>s</code> itself is returned if <code>s</code> is a <code>string</code>-like type. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>S <code>s</code>
</td> <td>A <a href="std_range_primitives.html#isRandomAccessRange">random access range</a> of characters</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>An array with the same element type as <code>s</code>.</dd>
</dl> </dd> <dt class="d_decl" id="toUpper">pure nothrow @nogc @safe dchar <strong id="toUpper">toUpper</strong>(dchar c); </dt> <dd>
<p>If <code>c</code> is a Unicode lowercase <a href="#Character">character</a>, then its uppercase equivalent is returned. Otherwise <code>c</code> is returned. </p>
<dl>
<dt>Warning</dt>
<dd> Certain alphabets like German and Greek have no 1:1 upper-lower mapping. Use overload of toUpper which takes full string instead. </dd>
</dl> toUpper can be used as an argument to <a href="std_algorithm_iteration.html#map"><code>std.algorithm.iteration.map</code></a> to produce an algorithm that can convert a range of characters to upper case without allocating memory. A string can then be produced by using <a href="std_algorithm_mutation.html#copy"><code>std.algorithm.mutation.copy</code></a> to send it to an <a href="std_array.html#appender"><code>std.array.appender</code></a>. <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.iteration : map;
import std.algorithm.mutation : copy;
import std.array : appender;

auto abuf = appender!(char[])();
"hello".map!toUpper.copy(abuf);
writeln(abuf.data); // "HELLO"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="toUpper.2">ElementEncodingType!S[] <strong id="toUpper">toUpper</strong>(S)(S s)<br><small>  Constraints: if (isSomeString!S || isRandomAccessRange!S &amp;&amp; hasLength!S &amp;&amp; hasSlicing!S &amp;&amp; isSomeChar!(ElementType!S)); </small>
</dt> <dd>
<p>Allocates a new array which is identical to <code>s</code> except that all of its characters are converted to uppercase (by preforming Unicode uppercase mapping). If none of <code>s</code> characters were affected, then <code>s</code> itself is returned if <code>s</code> is a <code>string</code>-like type. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>S <code>s</code>
</td> <td>A <a href="std_range_primitives.html#isRandomAccessRange">random access range</a> of characters</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>An new array with the same element type as <code>s</code>.</dd>
</dl> </dd> <dt class="d_decl" id="isAlpha">pure nothrow @nogc @safe bool <strong id="isAlpha">isAlpha</strong>(dchar c); </dt> <dd>
<p>Returns whether <code>c</code> is a Unicode alphabetic <a href="#Character">character</a> (general Unicode category: Alphabetic).</p> </dd> <dt class="d_decl" id="isMark">pure nothrow @nogc @safe bool <strong id="isMark">isMark</strong>(dchar c); </dt> <dd>
<p>Returns whether <code>c</code> is a Unicode mark (general Unicode category: Mn, Me, Mc).</p> </dd> <dt class="d_decl" id="isNumber">pure nothrow @nogc @safe bool <strong id="isNumber">isNumber</strong>(dchar c); </dt> <dd>
<p>Returns whether <code>c</code> is a Unicode numerical <a href="#Character">character</a> (general Unicode category: Nd, Nl, No).</p> </dd> <dt class="d_decl" id="isAlphaNum">pure nothrow @nogc @safe bool <strong id="isAlphaNum">isAlphaNum</strong>(dchar c); </dt> <dd>
<p>Returns whether <code>c</code> is a Unicode alphabetic <a href="#Character">character</a> or number. (general Unicode category: Alphabetic, Nd, Nl, No). </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>dchar <code>c</code>
</td> <td>any Unicode character</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if the character is in the Alphabetic, Nd, Nl, or No Unicode categories</dd>
</dl> </dd> <dt class="d_decl" id="isPunctuation">pure nothrow @nogc @safe bool <strong id="isPunctuation">isPunctuation</strong>(dchar c); </dt> <dd>
<p>Returns whether <code>c</code> is a Unicode punctuation <a href="#Character">character</a> (general Unicode category: Pd, Ps, Pe, Pc, Po, Pi, Pf).</p> </dd> <dt class="d_decl" id="isSymbol">pure nothrow @nogc @safe bool <strong id="isSymbol">isSymbol</strong>(dchar c); </dt> <dd>
<p>Returns whether <code>c</code> is a Unicode symbol <a href="#Character">character</a> (general Unicode category: Sm, Sc, Sk, So).</p> </dd> <dt class="d_decl" id="isSpace">pure nothrow @nogc @safe bool <strong id="isSpace">isSpace</strong>(dchar c); </dt> <dd>
<p>Returns whether <code>c</code> is a Unicode space <a href="#Character">character</a> (general Unicode category: Zs) </p>
<dl>
<dt>Note</dt>
<dd> This doesn't include '\n', '\r', \t' and other non-space <a href="#Character">character</a>. For commonly used less strict semantics see <a href="#isWhite"><code>isWhite</code></a>.</dd>
</dl> </dd> <dt class="d_decl" id="isGraphical">pure nothrow @nogc @safe bool <strong id="isGraphical">isGraphical</strong>(dchar c); </dt> <dd>
<p>Returns whether <code>c</code> is a Unicode graphical <a href="#Character">character</a> (general Unicode category: L, M, N, P, S, Zs). </p> </dd> <dt class="d_decl" id="isControl">pure nothrow @nogc @safe bool <strong id="isControl">isControl</strong>(dchar c); </dt> <dd>
<p>Returns whether <code>c</code> is a Unicode control <a href="#Character">character</a> (general Unicode category: Cc).</p> </dd> <dt class="d_decl" id="isFormat">pure nothrow @nogc @safe bool <strong id="isFormat">isFormat</strong>(dchar c); </dt> <dd>
<p>Returns whether <code>c</code> is a Unicode formatting <a href="#Character">character</a> (general Unicode category: Cf).</p> </dd> <dt class="d_decl" id="isPrivateUse">pure nothrow @nogc @safe bool <strong id="isPrivateUse">isPrivateUse</strong>(dchar c); </dt> <dd>
<p>Returns whether <code>c</code> is a Unicode Private Use <a href="#Code%20point">code point</a> (general Unicode category: Co).</p> </dd> <dt class="d_decl" id="isSurrogate">pure nothrow @nogc @safe bool <strong id="isSurrogate">isSurrogate</strong>(dchar c); </dt> <dd>
<p>Returns whether <code>c</code> is a Unicode surrogate <a href="#Code%20point">code point</a> (general Unicode category: Cs).</p> </dd> <dt class="d_decl" id="isSurrogateHi">pure nothrow @nogc @safe bool <strong id="isSurrogateHi">isSurrogateHi</strong>(dchar c); </dt> <dd>
<p>Returns whether <code>c</code> is a Unicode high surrogate (lead surrogate).</p> </dd> <dt class="d_decl" id="isSurrogateLo">pure nothrow @nogc @safe bool <strong id="isSurrogateLo">isSurrogateLo</strong>(dchar c); </dt> <dd>
<p>Returns whether <code>c</code> is a Unicode low surrogate (trail surrogate).</p> </dd> <dt class="d_decl" id="isNonCharacter">pure nothrow @nogc @safe bool <strong id="isNonCharacter">isNonCharacter</strong>(dchar c); </dt> <dd>
<p>Returns whether <code>c</code> is a Unicode non-character i.e. a <a href="#Code%20point">code point</a> with no assigned abstract character. (general Unicode category: Cn)</p> </dd> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1999&ndash;2021 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/std_uni.html" class="_attribution-link">https://dlang.org/phobos/std_uni.html</a>
  </p>
</div>
