<h1>std.process</h1>  <p>Functions for starting and interacting with other processes, and for working with the current process' execution environment. </p>
<dl>
<dt>Process handling</dt>

</dl>
<ul>
<li> <a href="#spawnProcess"><code>spawnProcess</code></a> spawns a new process, optionally assigning it an arbitrary set of standard input, output, and error streams. The function returns immediately, leaving the child process to execute in parallel with its parent. All other functions in this module that spawn processes are built around <code>spawnProcess</code>.</li> <li> <a href="#wait"><code>wait</code></a> makes the parent process wait for a child process to terminate. In general one should always do this, to avoid child processes becoming "zombies" when the parent process exits. Scope guards are perfect for this â€“ see the <a href="#spawnProcess"><code>spawnProcess</code></a> documentation for examples. <a href="#tryWait"><code>tryWait</code></a> is similar to <code>wait</code>, but does not block if the process has not yet terminated.</li> <li> <a href="#pipeProcess"><code>pipeProcess</code></a> also spawns a child process which runs in parallel with its parent. However, instead of taking arbitrary streams, it automatically creates a set of pipes that allow the parent to communicate with the child through the child's standard input, output, and/or error streams. This function corresponds roughly to C's <code>popen</code> function.</li> <li> <a href="#execute"><code>execute</code></a> starts a new process and waits for it to complete before returning. Additionally, it captures the process' standard output and error streams and returns the output of these as a string.</li> <li> <a href="#spawnShell"><code>spawnShell</code></a>, <a href="#pipeShell"><code>pipeShell</code></a> and <a href="#executeShell"><code>executeShell</code></a> work like <code>spawnProcess</code>, <code>pipeProcess</code> and <code>execute</code>, respectively, except that they take a single command string and run it through the current user's default command interpreter. <code>executeShell</code> corresponds roughly to C's <code>system</code> function.</li> <li> <a href="#kill"><code>kill</code></a> attempts to terminate a running process.</li> </ul>  The following table compactly summarises the different process creation functions and how they relate to each other: <table>
 <tr>
<th scope="col"></th> <th scope="col">Runs program directly</th> <th scope="col">Runs shell command</th>
</tr> <tr>
<td>Low-level process creation</td> <td><a href="#spawnProcess"><code>spawnProcess</code></a></td> <td><a href="#spawnShell"><code>spawnShell</code></a></td>
</tr> <tr>
<td>Automatic input/output redirection using pipes</td> <td><a href="#pipeProcess"><code>pipeProcess</code></a></td> <td><a href="#pipeShell"><code>pipeShell</code></a></td>
</tr> <tr>
<td>Execute and wait for completion, collect output</td> <td><a href="#execute"><code>execute</code></a></td> <td><a href="#executeShell"><code>executeShell</code></a></td>
</tr> </table>  <dl>
<dt>Other functionality</dt>

</dl>
<ul>
<li> <a href="#pipe"><code>pipe</code></a> is used to create unidirectional pipes.</li> <li> <a href="#environment"><code>environment</code></a> is an interface through which the current process' environment variables can be read and manipulated.</li> <li> <a href="#escapeShellCommand"><code>escapeShellCommand</code></a> and <a href="#escapeShellFileName"><code>escapeShellFileName</code></a> are useful for constructing shell command lines in a portable way.</li> </ul>  <dl>
<dt>Authors:</dt>
<dd>
<a href="https://github.com/kyllingstad">Lars Tandle Kyllingstad</a>, <a href="https://github.com/schveiguy">Steven Schveighoffer</a>, <a href="http://thecybershadow.net">Vladimir Panteleev</a> </dd>
</dl> <dl>
<dt>License:</dt>
<dd>
<a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>. </dd>
</dl> <dl>
<dt>Source</dt>
<dd> <span class="phobos_src"><a class="https" href="https://github.com/dlang/phobos/blob/master/std/process.d">std/process.d</a></span> </dd>
</dl> <dl>
<dt>Note</dt>
<dd> Most of the functionality in this module is not available on iOS, tvOS and watchOS. The only functions available on those platforms are: <a href="#environment"><code>environment</code></a>, <a href="#thisProcessID"><code>thisProcessID</code></a> and <a href="#thisThreadID"><code>thisThreadID</code></a>.</dd>
</dl> <dl>
<dt class="d_decl" id="environment">abstract class <strong id="environment">environment</strong>; </dt> <dd>
<p>Manipulates environment variables using an associative-array-like interface. </p>
<p>This class contains only static methods, and cannot be instantiated. See below for examples of use.</p> <dl>
<dt class="d_decl" id="environment.opIndex">static @safe string <strong id="opIndex">opIndex</strong>(scope const(char)[] name); </dt> <dd>
<p> Retrieves the value of the environment variable with the given <code>name</code>. <pre data-language="d">auto path = environment["PATH"];
</pre> </p>
<dl>
<dt>Throws:</dt>
<dd>
<a href="object.html#Exception"><code>Exception</code></a> if the environment variable does not exist, or <a href="std_utf.html#UTFException"><code>std.utf.UTFException</code></a> if the variable contains invalid UTF-16 characters (Windows only). </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="#environment.get"><code>environment.get</code></a>, which doesn't throw on failure.</dd>
</dl> </dd> <dt class="d_decl" id="environment.get">static @safe string <strong id="get">get</strong>(scope const(char)[] name, string defaultValue = null); </dt> <dd>
<p>Retrieves the value of the environment variable with the given <code>name</code>, or a default value if the variable doesn't exist. </p>
<p> Unlike <a href="#environment.opIndex"><code>environment.opIndex</code></a>, this function never throws on Posix. <pre data-language="d">auto sh = environment.get("SHELL", "/bin/sh");
</pre> This function is also useful in checking for the existence of an environment variable. <pre data-language="d">auto myVar = environment.get("MYVAR");
if (myVar is null)
{
    // Environment variable doesn't exist.
    // Note that we have to use 'is' for the comparison, since
    // myVar == null is also true if the variable exists but is
    // empty.
}
</pre> </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(char)[] <code>name</code>
</td> <td>name of the environment variable to retrieve</td>
</tr> <tr>
<td>string <code>defaultValue</code>
</td> <td>default value to return if the environment variable doesn't exist.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>the value of the environment variable if found, otherwise <code>null</code> if the environment doesn't exist. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_utf.html#UTFException"><code>std.utf.UTFException</code></a> if the variable contains invalid UTF-16 characters (Windows only).</dd>
</dl> </dd> <dt class="d_decl" id="environment.opIndexAssign">static @trusted inout(char)[] <strong id="opIndexAssign">opIndexAssign</strong>(inout char[] value, scope const(char)[] name); </dt> <dd>
<p>Assigns the given <code>value</code> to the environment variable with the given <code>name</code>. If <code>value</code> is null the variable is removed from environment. </p>
<p> If the variable does not exist, it will be created. If it already exists, it will be overwritten. <pre data-language="d">environment["foo"] = "bar";
</pre> </p> <dl>
<dt>Throws:</dt>
<dd>
<a href="object.html#Exception"><code>Exception</code></a> if the environment variable could not be added (e.g. if the name is invalid). </dd>
</dl> <dl>
<dt>Note</dt>
<dd> On some platforms, modifying environment variables may not be allowed in multi-threaded programs. See e.g. <a href="https://www.gnu.org/software/libc/manual/html_node/Environment-Access.html#Environment-Access">glibc</a>.</dd>
</dl> </dd> <dt class="d_decl" id="environment.remove">static nothrow @nogc @trusted void <strong id="remove">remove</strong>(scope const(char)[] name); </dt> <dd>
<p>Removes the environment variable with the given <code>name</code>. </p>
<p>If the variable isn't in the environment, this function returns successfully without doing anything. </p> <dl>
<dt>Note</dt>
<dd> On some platforms, modifying environment variables may not be allowed in multi-threaded programs. See e.g. <a href="https://www.gnu.org/software/libc/manual/html_node/Environment-Access.html#Environment-Access">glibc</a>.</dd>
</dl> </dd> <dt class="d_decl" id="environment.opBinaryRight">@trusted bool <strong id="opBinaryRight">opBinaryRight</strong>(string op : "in")(scope const(char)[] name); </dt> <dd>
<p>Identify whether a variable is defined in the environment. </p>
<p>Because it doesn't return the value, this function is cheaper than <code>get</code>. However, if you do need the value as well, you should just check the return of <code>get</code> for <code>null</code> instead of using this function first. </p> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">// good usage
if ("MY_ENV_FLAG" in environment)
    doSomething();

// bad usage
if ("MY_ENV_VAR" in environment)
    doSomething(environment["MY_ENV_VAR"]);

// do this instead
if (auto var = environment.get("MY_ENV_VAR"))
    doSomething(var);
</pre>  </dd> <dt class="d_decl" id="environment.toAA">static @trusted string[string] <strong id="toAA">toAA</strong>(); </dt> <dd>
<p>Copies all environment variables into an associative array. </p>
<dl>
<dt>Windows specific</dt>
<dd> While Windows environment variable names are case insensitive, D's built-in associative arrays are not. This function will store all variable names in uppercase (e.g. <code>PATH</code>). </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="object.html#Exception"><code>Exception</code></a> if the environment variables could not be retrieved (Windows only).</dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="thisProcessID">nothrow @property @trusted int <strong id="thisProcessID">thisProcessID</strong>(); </dt> <dd>
<p>Returns the process ID of the current process, which is guaranteed to be unique on the system. </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">writefln("Current process ID: %d", thisProcessID);
</pre>  </dd> <dt class="d_decl" id="thisThreadID">nothrow @property @trusted ThreadID <strong id="thisThreadID">thisThreadID</strong>(); </dt> <dd>
<p>Returns the process ID of the current thread, which is guaranteed to be unique within the current process. </p>
<dl>
<dt>Returns:</dt>
<dd>A <a href="core_thread.html#ThreadID"><code>core.thread.ThreadID</code></a> value for the calling thread. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">writefln("Current thread ID: %s", thisThreadID);
</pre>  </dd> <dt class="d_decl" id="spawnProcess">@safe Pid <strong id="spawnProcess">spawnProcess</strong>(scope const(char[])[] args, File stdin = std.stdio.stdin, File stdout = std.stdio.stdout, File stderr = std.stdio.stderr, const string[string] env = null, Config config = Config.none, scope const char[] workDir = null); <br><br>@trusted Pid <strong id="spawnProcess">spawnProcess</strong>(scope const(char[])[] args, const string[string] env, Config config = Config.none, scope const(char)[] workDir = null); <br><br>@trusted Pid <strong id="spawnProcess">spawnProcess</strong>(scope const(char)[] program, File stdin = std.stdio.stdin, File stdout = std.stdio.stdout, File stderr = std.stdio.stderr, const string[string] env = null, Config config = Config.none, scope const(char)[] workDir = null); <br><br>@trusted Pid <strong id="spawnProcess">spawnProcess</strong>(scope const(char)[] program, const string[string] env, Config config = Config.none, scope const(char)[] workDir = null); </dt> <dd>
<p>Spawns a new process, optionally assigning it an arbitrary set of standard input, output, and error streams. </p>
<p>The function returns immediately, leaving the child process to execute in parallel with its parent. It is recommended to always call <a href="#wait"><code>wait</code></a> on the returned <a href="#Pid"><code>Pid</code></a> unless the process was spawned with <code>Config.detached</code> flag, as detailed in the documentation for <code>wait</code>. </p> <dl>
<dt>Command line</dt>
<dd> There are four overloads of this function. The first two take an array of strings, <code>args</code>, which should contain the program name as the zeroth element and any command-line arguments in subsequent elements. The third and fourth versions are included for convenience, and may be used when there are no command-line arguments. They take a single string, <code>program</code>, which specifies the program name. </dd>
</dl> Unless a directory is specified in <code>args[0]</code> or <code>program</code>, <code>spawnProcess</code> will search for the program in a platform-dependent manner. On POSIX systems, it will look for the executable in the directories listed in the PATH environment variable, in the order they are listed. On Windows, it will search for the executable in the following sequence: <ol> <li>The directory from which the application loaded.</li> <li>The current directory for the parent process.</li> <li>The 32-bit Windows system directory.</li> <li>The 16-bit Windows system directory.</li> <li>The Windows directory.</li> <li>The directories listed in the PATH environment variable.</li> </ol> <pre data-language="d">// Run an executable called "prog" located in the current working
// directory:
auto pid = spawnProcess("./prog");
scope(exit) wait(pid);
// We can do something else while the program runs.  The scope guard
// ensures that the process is waited for at the end of the scope.
...

// Run DMD on the file "myprog.d", specifying a few compiler switches:
auto dmdPid = spawnProcess(["dmd", "-O", "-release", "-inline", "myprog.d" ]);
if (wait(dmdPid) != 0)
    writeln("Compilation failed!");
</pre>  <dl>
<dt>Environment variables</dt>
<dd> By default, the child process inherits the environment of the parent process, along with any additional variables specified in the <code>env</code> parameter. If the same variable exists in both the parent's environment and in <code>env</code>, the latter takes precedence. </dd>
</dl> If the <a href="#Config.newEnv"><code>Config.newEnv</code></a> flag is set in <code>config</code>, the child process will <i>not</i> inherit the parent's environment. Its entire environment will then be determined by <code>env</code>. <pre data-language="d">wait(spawnProcess("myapp", ["foo" : "bar"], Config.newEnv));
</pre>  <dl>
<dt>Standard streams</dt>
<dd> The optional arguments <code>stdin</code>, <code>stdout</code> and <code>stderr</code> may be used to assign arbitrary <a href="std_stdio.html#File"><code>std.stdio.File</code></a> objects as the standard input, output and error streams, respectively, of the child process. The former must be opened for reading, while the latter two must be opened for writing. The default is for the child process to inherit the standard streams of its parent. </dd>
</dl>
<pre data-language="d">// Run DMD on the file myprog.d, logging any error messages to a
// file named errors.log.
auto logFile = File("errors.log", "w");
auto pid = spawnProcess(["dmd", "myprog.d"],
                        std.stdio.stdin,
                        std.stdio.stdout,
                        logFile);
if (wait(pid) != 0)
    writeln("Compilation failed. See errors.log for details.");
</pre>  Note that if you pass a <code>File</code> object that is <i>not</i> one of the standard input/output/error streams of the parent process, that stream will by default be <i>closed</i> in the parent process when this function returns. See the <a href="#Config"><code>Config</code></a> documentation below for information about how to disable this behaviour.  Beware of buffering issues when passing <code>File</code> objects to <code>spawnProcess</code>. The child process will inherit the low-level raw read/write offset associated with the underlying file descriptor, but it will not be aware of any buffered data. In cases where this matters (e.g. when a file should be aligned before being passed on to the child process), it may be a good idea to use unbuffered streams, or at least ensure all relevant buffers are flushed.  <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(char[])[] <code>args</code>
</td> <td>An array which contains the program name as the zeroth element and any command-line arguments in the following elements.</td>
</tr> <tr>
<td>File <code>stdin</code>
</td> <td>The standard input stream of the child process. This can be any <a href="std_stdio.html#File"><code>std.stdio.File</code></a> that is opened for reading. By default the child process inherits the parent's input stream.</td>
</tr> <tr>
<td>File <code>stdout</code>
</td> <td>The standard output stream of the child process. This can be any <a href="std_stdio.html#File"><code>std.stdio.File</code></a> that is opened for writing. By default the child process inherits the parent's output stream.</td>
</tr> <tr>
<td>File <code>stderr</code>
</td> <td>The standard error stream of the child process. This can be any <a href="std_stdio.html#File"><code>std.stdio.File</code></a> that is opened for writing. By default the child process inherits the parent's error stream.</td>
</tr> <tr>
<td>string[string] <code>env</code>
</td> <td>Additional environment variables for the child process.</td>
</tr> <tr>
<td>Config <code>config</code>
</td> <td>Flags that control process creation. See <a href="#Config"><code>Config</code></a> for an overview of available flags.</td>
</tr> <tr>
<td>char[] <code>workDir</code>
</td> <td>The working directory for the new process. By default the child process inherits the parent's working directory.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A <a href="#Pid"><code>Pid</code></a> object that corresponds to the spawned process. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="#ProcessException"><code>ProcessException</code></a> on failure to start the process.<br> <a href="std_stdio.html#StdioException"><code>std.stdio.StdioException</code></a> on failure to pass one of the streams to the child process (Windows only).<br> <a href="core_exception.html#RangeError"><code>core.exception.RangeError</code></a> if <code>args</code> is empty.</dd>
</dl> </dd> <dt class="d_decl" id="spawnShell">@safe Pid <strong id="spawnShell">spawnShell</strong>(scope const(char)[] command, File stdin = std.stdio.stdin, File stdout = std.stdio.stdout, File stderr = std.stdio.stderr, scope const string[string] env = null, Config config = Config.none, scope const(char)[] workDir = null, scope string shellPath = nativeShell); <br><br>@trusted Pid <strong id="spawnShell">spawnShell</strong>(scope const(char)[] command, scope const string[string] env, Config config = Config.none, scope const(char)[] workDir = null, scope string shellPath = nativeShell); </dt> <dd>
<p>A variation on <a href="#spawnProcess"><code>spawnProcess</code></a> that runs the given command through the current user's preferred command interpreter (aka. shell). </p>
<p>The string <code>command</code> is passed verbatim to the shell, and is therefore subject to its rules about command structure, argument/filename quoting and escaping of special characters. The path to the shell executable defaults to <a href="#nativeShell"><code>nativeShell</code></a>. <br><br> In all other respects this function works just like <code>spawnProcess</code>. Please refer to the <a href="#spawnProcess"><code>spawnProcess</code></a> documentation for descriptions of the other function parameters, the return value and any exceptions that may be thrown. <pre data-language="d">// Run the command/program "foo" on the file named "my file.txt", and
// redirect its output into foo.log.
auto pid = spawnShell(`foo "my file.txt" &gt; foo.log`);
wait(pid);
</pre> </p> <dl>
<dt>See Also:</dt>
<dd>
<a href="#escapeShellCommand"><code>escapeShellCommand</code></a>, which may be helpful in constructing a properly quoted and escaped shell command line for the current platform.</dd>
</dl> </dd> <dt class="d_decl" id="Config">enum <strong id="Config">Config</strong>: int; </dt> <dd>
<p>Flags that control the behaviour of process creation functions in this module. Most flags only apply to <a href="#spawnProcess"><code>spawnProcess</code></a> and <a href="#spawnShell"><code>spawnShell</code></a>. </p>
<p>Use bitwise OR to combine flags. </p> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto logFile = File("myapp_error.log", "w");

// Start program, suppressing the console window (Windows only),
// redirect its error stream to logFile, and leave logFile open
// in the parent process as well.
auto pid = spawnProcess("myapp", stdin, stdout, logFile,
                        Config.retainStderr | Config.suppressConsole);
scope(exit)
{
    auto exitCode = wait(pid);
    logFile.writeln("myapp exited with code ", exitCode);
    logFile.close();
}
</pre>  <dl>
<dt class="d_decl" id="Config.newEnv"><strong id="newEnv">newEnv</strong></dt> <dd>
<p>By default, the child process inherits the parent's environment, and any environment variables passed to <a href="#spawnProcess"><code>spawnProcess</code></a> will be added to it. If this flag is set, the only variables in the child process' environment will be those given to spawnProcess.</p> </dd> <dt class="d_decl" id="Config.retainStdin">
<strong id="retainStdin">retainStdin</strong><br><br><strong id="retainStdout">retainStdout</strong><br><br><strong id="retainStderr">retainStderr</strong>
</dt> <dd>
<p>Unless the child process inherits the standard input/output/error streams of its parent, one almost always wants the streams closed in the parent when <a href="#spawnProcess"><code>spawnProcess</code></a> returns. Therefore, by default, this is done. If this is not desirable, pass any of these options to spawnProcess.</p> </dd> <dt class="d_decl" id="Config.suppressConsole"><strong id="suppressConsole">suppressConsole</strong></dt> <dd>
<p>On Windows, if the child process is a console application, this flag will prevent the creation of a console window. Otherwise, it will be ignored. On POSIX, <code>suppressConsole</code> has no effect.</p> </dd> <dt class="d_decl" id="Config.inheritFDs"><strong id="inheritFDs">inheritFDs</strong></dt> <dd>
<p>On POSIX, open <a href="http://en.wikipedia.org/wiki/File_descriptor">file descriptors</a> are by default inherited by the child process. As this may lead to subtle bugs when pipes or multiple threads are involved, <a href="#spawnProcess"><code>spawnProcess</code></a> ensures that all file descriptors except the ones that correspond to standard input/output/error are closed in the child process when it starts. Use <code>inheritFDs</code> to prevent this. </p>
<p>On Windows, this option has no effect, and any handles which have been explicitly marked as inheritable will always be inherited by the child process.</p> </dd> <dt class="d_decl" id="Config.detached"><strong id="detached">detached</strong></dt> <dd>
<p>Spawn process in detached state. This removes the need in calling <a href="#wait"><code>wait</code></a> to clean up the process resources. </p>
<dl>
<dt>Note</dt>
<dd> Calling <a href="#wait"><code>wait</code></a> or <a href="#kill"><code>kill</code></a> with the resulting <code>Pid</code> is invalid.</dd>
</dl> </dd> <dt class="d_decl" id="Config.stderrPassThrough"><strong id="stderrPassThrough">stderrPassThrough</strong></dt> <dd>
<p>By default, the <a href="#execute"><code>execute</code></a> and <a href="#executeShell"><code>executeShell</code></a> functions will capture child processes' both stdout and stderr. This can be undesirable if the standard output is to be processed or otherwise used by the invoking program, as <code>execute</code>'s result would then contain a mix of output and warning/error messages. </p>
<p>Specify this flag when calling <code>execute</code> or <code>executeShell</code> to cause invoked processes' stderr stream to be sent to <a href="std_stdio.html#stderr"><code> std.stdio.stderr</code></a>, and only capture and return standard output. <br><br> This flag has no effect on <a href="#spawnProcess"><code>spawnProcess</code></a> or <a href="#spawnShell"><code>spawnShell</code></a>.</p> </dd> </dl> </dd> <dt class="d_decl" id="Pid">class <strong id="Pid">Pid</strong>; </dt> <dd>
<p>A handle that corresponds to a spawned process.</p> <dl>
<dt class="d_decl" id="Pid.processID">const pure nothrow @property @safe int <strong id="processID">processID</strong>(); </dt> <dd>
<p>The process ID number. </p>
<p>This is a number that uniquely identifies the process on the operating system, for at least as long as the process is running. Once <a href="#wait"><code>wait</code></a> has been called on the <a href="#Pid"><code>Pid</code></a>, this method will return an invalid (negative) process ID.</p> </dd> <dt class="d_decl" id="Pid.osHandle">pure nothrow @nogc @property @safe pid_t <strong id="osHandle">osHandle</strong>(); </dt> <dd>
<p>An operating system handle to the process. </p>
<p>This handle is used to specify the process in OS-specific APIs. On POSIX, this function returns a <code>core.sys.posix.sys.types.pid_t</code> with the same value as <a href="#Pid.processID"><code>Pid.processID</code></a>, while on Windows it returns a <code>core.sys.windows.windows.HANDLE</code>. <br><br> Once <a href="#wait"><code>wait</code></a> has been called on the <a href="#Pid"><code>Pid</code></a>, this method will return an invalid handle.</p> </dd> </dl> </dd> <dt class="d_decl" id="wait">@safe int <strong id="wait">wait</strong>(Pid pid); </dt> <dd>
<p>Waits for the process associated with <code>pid</code> to terminate, and returns its exit status. </p>
<p>In general one should always wait for child processes to terminate before exiting the parent process unless the process was spawned as detached (that was spawned with <code>Config.detached</code> flag). Otherwise, they may become "<a href="http://en.wikipedia.org/wiki/Zombie_process">zombies</a>" â€“ processes that are defunct, yet still occupy a slot in the OS process table. You should not and must not wait for detached processes, since you don't own them. <br><br> If the process has already terminated, this function returns directly. The exit code is cached, so that if wait() is called multiple times on the same <a href="#Pid"><code>Pid</code></a> it will always return the same value. </p> <dl>
<dt>POSIX specific</dt>
<dd> If the process is terminated by a signal, this function returns a negative number whose absolute value is the signal number. Since POSIX restricts normal exit codes to the range 0-255, a negative return value will always indicate termination by signal. Signal codes are defined in the <code>core.sys.posix.signal</code> module (which corresponds to the <code>signal.h</code> POSIX header). </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="#ProcessException"><code>ProcessException</code></a> on failure or on attempt to wait for detached process. </dd>
</dl> <dl>
<dt>Example</dt>
<dd> See the <a href="#spawnProcess"><code>spawnProcess</code></a> documentation. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="#tryWait"><code>tryWait</code></a>, for a non-blocking function.</dd>
</dl> </dd> <dt class="d_decl" id="tryWait">@safe auto <strong id="tryWait">tryWait</strong>(Pid pid); </dt> <dd>
<p>A non-blocking version of <a href="#wait"><code>wait</code></a>. </p>
<p>If the process associated with <code>pid</code> has already terminated, <code>tryWait</code> has the exact same effect as <code>wait</code>. In this case, it returns a tuple where the <code>terminated</code> field is set to <code>true</code> and the <code>status</code> field has the same interpretation as the return value of <code>wait</code>. <br><br> If the process has <i>not</i> yet terminated, this function differs from <code>wait</code> in that does not wait for this to happen, but instead returns immediately. The <code>terminated</code> field of the returned tuple will then be set to <code>false</code>, while the <code>status</code> field will always be 0 (zero). <code>wait</code> or <code>tryWait</code> should then be called again on the same <code>Pid</code> at some later time; not only to get the exit code, but also to avoid the process becoming a "zombie" when it finally terminates. (See <a href="#wait"><code>wait</code></a> for details). </p> <dl>
<dt>Returns:</dt>
<dd>An <code>std.typecons.Tuple!(bool, "terminated", int, "status")</code>. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="#ProcessException"><code>ProcessException</code></a> on failure or on attempt to wait for detached process. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto pid = spawnProcess("dmd myapp.d");
scope(exit) wait(pid);
...
auto dmd = tryWait(pid);
if (dmd.terminated)
{
    if (dmd.status == 0) writeln("Compilation succeeded!");
    else writeln("Compilation failed");
}
else writeln("Still compiling...");
...
</pre> Note that in this example, the first <code>wait</code> call will have no effect if the process has already terminated by the time <code>tryWait</code> is called. In the opposite case, however, the <code>scope</code> statement ensures that we always wait for the process if it hasn't terminated by the time we reach the end of the scope. </dd> <dt class="d_decl" id="kill">void <strong id="kill">kill</strong>(Pid pid); <br><br>void <strong id="kill">kill</strong>(Pid pid, int codeOrSignal); </dt> <dd>
<p>Attempts to terminate the process associated with <code>pid</code>. </p>
<p>The effect of this function, as well as the meaning of <code>codeOrSignal</code>, is highly platform dependent. Details are given below. Common to all platforms is that this function only <i>initiates</i> termination of the process, and returns immediately. It does not wait for the process to end, nor does it guarantee that the process does in fact get terminated. <br><br> Always call <a href="#wait"><code>wait</code></a> to wait for a process to complete, even if <code>kill</code> has been called on it. </p> <dl>
<dt>Windows specific</dt>
<dd> The process will be <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms686714%28v=vs.100%29.aspx">forcefully and abruptly terminated</a>. If <code>codeOrSignal</code> is specified, it must be a nonnegative number which will be used as the exit code of the process. If not, the process wil exit with code 1. Do not use <code>codeOrSignal = 259</code>, as this is a special value (aka. <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms683189.aspx">STILL_ACTIVE</a>) used by Windows to signal that a process has in fact <i>not</i> terminated yet. </dd>
</dl>
<pre data-language="d">auto pid = spawnProcess("some_app");
kill(pid, 10);
assert(wait(pid) == 10);
</pre>  <dl>
<dt>POSIX specific</dt>
<dd> A <a href="http://en.wikipedia.org/wiki/Unix_signal">signal</a> will be sent to the process, whose value is given by <code>codeOrSignal</code>. Depending on the signal sent, this may or may not terminate the process. Symbolic constants for various <a href="http://en.wikipedia.org/wiki/Unix_signal#POSIX_signals">POSIX signals</a> are defined in <code>core.sys.posix.signal</code>, which corresponds to the <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/signal.h.html"><code>signal.h</code> POSIX header</a>. If <code>codeOrSignal</code> is omitted, the <code>SIGTERM</code> signal will be sent. (This matches the behaviour of the <a href="http://pubs.opengroup.org/onlinepubs/9699919799/utilities/kill.html"><code>_kill</code></a> shell command.) </dd>
</dl>
<pre data-language="d">import core.sys.posix.signal : SIGKILL;
auto pid = spawnProcess("some_app");
kill(pid, SIGKILL);
assert(wait(pid) == -SIGKILL); // Negative return value on POSIX!
</pre>  <dl>
<dt>Throws:</dt>
<dd>
<a href="#ProcessException"><code>ProcessException</code></a> on error (e.g. if codeOrSignal is invalid). or on attempt to kill detached process. Note that failure to terminate the process is considered a "normal" outcome, not an error.<br>
</dd>
</dl> </dd> <dt class="d_decl" id="pipe">@trusted Pipe <strong id="pipe">pipe</strong>(); </dt> <dd>
<p>Creates a unidirectional pipe. </p>
<p>Data is written to one end of the pipe and read from the other. <pre data-language="d">auto p = pipe();
p.writeEnd.writeln("Hello World");
p.writeEnd.flush();
assert(p.readEnd.readln().chomp() == "Hello World");
</pre> Pipes can, for example, be used for interprocess communication by spawning a new process and passing one end of the pipe to the child, while the parent uses the other end. (See also <a href="#pipeProcess"><code>pipeProcess</code></a> and <a href="#pipeShell"><code>pipeShell</code></a> for an easier way of doing this.) <pre data-language="d">// Use cURL to download the dlang.org front page, pipe its
// output to grep to extract a list of links to ZIP files,
// and write the list to the file "D downloads.txt":
auto p = pipe();
auto outFile = File("D downloads.txt", "w");
auto cpid = spawnProcess(["curl", "http://dlang.org/download.html"],
                         std.stdio.stdin, p.writeEnd);
scope(exit) wait(cpid);
auto gpid = spawnProcess(["grep", "-o", `http://\S*\.zip`],
                         p.readEnd, outFile);
scope(exit) wait(gpid);
</pre> </p> <dl>
<dt>Returns:</dt>
<dd>A <a href="#Pipe"><code>Pipe</code></a> object that corresponds to the created pipe. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_stdio.html#StdioException"><code>std.stdio.StdioException</code></a> on failure.</dd>
</dl> </dd> <dt class="d_decl" id="Pipe">struct <strong id="Pipe">Pipe</strong>; </dt> <dd>
<p>An interface to a pipe created by the <a href="#pipe"><code>pipe</code></a> function.</p> <dl>
<dt class="d_decl" id="Pipe.readEnd">nothrow @property @safe File <strong id="readEnd">readEnd</strong>(); </dt> <dd>
<p>The read end of the pipe.</p> </dd> <dt class="d_decl" id="Pipe.writeEnd">nothrow @property @safe File <strong id="writeEnd">writeEnd</strong>(); </dt> <dd>
<p>The write end of the pipe.</p> </dd> <dt class="d_decl" id="Pipe.close">@safe void <strong id="close">close</strong>(); </dt> <dd>
<p>Closes both ends of the pipe. </p>
<p>Normally it is not necessary to do this manually, as <a href="std_stdio.html#File"><code>std.stdio.File</code></a> objects are automatically closed when there are no more references to them. <br><br> Note that if either end of the pipe has been passed to a child process, it will only be closed in the parent process. (What happens in the child process is platform dependent.) </p> <dl>
<dt>Throws:</dt>
<dd>
<a href="std_exception.html#ErrnoException"><code>std.exception.ErrnoException</code></a> if an error occurs.</dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="pipeProcess">@safe ProcessPipes <strong id="pipeProcess">pipeProcess</strong>(scope const(char[])[] args, Redirect redirect = Redirect.all, const string[string] env = null, Config config = Config.none, scope const(char)[] workDir = null); <br><br>@safe ProcessPipes <strong id="pipeProcess">pipeProcess</strong>(scope const(char)[] program, Redirect redirect = Redirect.all, const string[string] env = null, Config config = Config.none, scope const(char)[] workDir = null); <br><br>@safe ProcessPipes <strong id="pipeShell">pipeShell</strong>(scope const(char)[] command, Redirect redirect = Redirect.all, const string[string] env = null, Config config = Config.none, scope const(char)[] workDir = null, string shellPath = nativeShell); </dt> <dd>
<p>Starts a new process, creating pipes to redirect its standard input, output and/or error streams. </p>
<p><code>pipeProcess</code> and <code>pipeShell</code> are convenient wrappers around <a href="#spawnProcess"><code>spawnProcess</code></a> and <a href="#spawnShell"><code>spawnShell</code></a>, respectively, and automate the task of redirecting one or more of the child process' standard streams through pipes. Like the functions they wrap, these functions return immediately, leaving the child process to execute in parallel with the invoking process. It is recommended to always call <a href="#wait"><code>wait</code></a> on the returned <a href="#ProcessPipes.pid"><code>ProcessPipes.pid</code></a>, as detailed in the documentation for <code>wait</code>. <br><br> The <code>args</code>/<code>program</code>/<code>command</code>, <code>env</code> and <code>config</code> parameters are forwarded straight to the underlying spawn functions, and we refer to their documentation for details. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(char[])[] <code>args</code>
</td> <td>An array which contains the program name as the zeroth element and any command-line arguments in the following elements. (See <a href="#spawnProcess"><code>spawnProcess</code></a> for details.)</td>
</tr> <tr>
<td>const(char)[] <code>program</code>
</td> <td>The program name, <i>without</i> command-line arguments. (See <a href="#spawnProcess"><code>spawnProcess</code></a> for details.)</td>
</tr> <tr>
<td>const(char)[] <code>command</code>
</td> <td>A shell command which is passed verbatim to the command interpreter. (See <a href="#spawnShell"><code>spawnShell</code></a> for details.)</td>
</tr> <tr>
<td>Redirect <code>redirect</code>
</td> <td>Flags that determine which streams are redirected, and how. See <a href="#Redirect"><code>Redirect</code></a> for an overview of available flags.</td>
</tr> <tr>
<td>string[string] <code>env</code>
</td> <td>Additional environment variables for the child process. (See <a href="#spawnProcess"><code>spawnProcess</code></a> for details.)</td>
</tr> <tr>
<td>Config <code>config</code>
</td> <td>Flags that control process creation. See <a href="#Config"><code>Config</code></a> for an overview of available flags, and note that the <code>retainStd...</code> flags have no effect in this function.</td>
</tr> <tr>
<td>const(char)[] <code>workDir</code>
</td> <td>The working directory for the new process. By default the child process inherits the parent's working directory.</td>
</tr> <tr>
<td>string <code>shellPath</code>
</td> <td>The path to the shell to use to run the specified program. By default this is <a href="#nativeShell"><code>nativeShell</code></a>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A <a href="#ProcessPipes"><code>ProcessPipes</code></a> object which contains <a href="std_stdio.html#File"><code>std.stdio.File</code></a> handles that communicate with the redirected streams of the child process, along with a <a href="#Pid"><code>Pid</code></a> object that corresponds to the spawned process. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="#ProcessException"><code>ProcessException</code></a> on failure to start the process.<br> <a href="std_stdio.html#StdioException"><code>std.stdio.StdioException</code></a> on failure to redirect any of the streams.<br> </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">// my_application writes to stdout and might write to stderr
auto pipes = pipeProcess("my_application", Redirect.stdout | Redirect.stderr);
scope(exit) wait(pipes.pid);

// Store lines of output.
string[] output;
foreach (line; pipes.stdout.byLine) output ~= line.idup;

// Store lines of errors.
string[] errors;
foreach (line; pipes.stderr.byLine) errors ~= line.idup;


// sendmail expects to read from stdin
pipes = pipeProcess(["/usr/bin/sendmail", "-t"], Redirect.stdin);
pipes.stdin.writeln("To: you");
pipes.stdin.writeln("From: me");
pipes.stdin.writeln("Subject: dlang");
pipes.stdin.writeln("");
pipes.stdin.writeln(message);

// a single period tells sendmail we are finished
pipes.stdin.writeln(".");

// but at this point sendmail might not see it, we need to flush
pipes.stdin.flush();

// sendmail happens to exit on ".", but some you have to close the file:
pipes.stdin.close();

// otherwise this wait will wait forever
wait(pipes.pid);

</pre>  </dd> <dt class="d_decl" id="Redirect">enum <strong id="Redirect">Redirect</strong>: int; </dt> <dd>
<p>Flags that can be passed to <a href="#pipeProcess"><code>pipeProcess</code></a> and <a href="#pipeShell"><code>pipeShell</code></a> to specify which of the child process' standard streams are redirected. Use bitwise OR to combine flags.</p> <dl>
<dt class="d_decl" id="Redirect.stdin">
<strong id="stdin">stdin</strong><br><br><strong id="stdout">stdout</strong><br><br><strong id="stderr">stderr</strong>
</dt> <dd>
<p>Redirect the standard input, output or error streams, respectively.</p> </dd> <dt class="d_decl" id="Redirect.all"><strong id="all">all</strong></dt> <dd>
<p>Redirect all three streams. This is equivalent to <code>Redirect.stdin | Redirect.stdout | Redirect.stderr</code>.</p> </dd> <dt class="d_decl" id="Redirect.stderrToStdout"><strong id="stderrToStdout">stderrToStdout</strong></dt> <dd>
<p>Redirect the standard error stream into the standard output stream. This can not be combined with <code>Redirect.stderr</code>.</p> </dd> <dt class="d_decl" id="Redirect.stdoutToStderr"><strong id="stdoutToStderr">stdoutToStderr</strong></dt> <dd>
<p>Redirect the standard output stream into the standard error stream. This can not be combined with <code>Redirect.stdout</code>.</p> </dd> </dl> </dd> <dt class="d_decl" id="ProcessPipes">struct <strong id="ProcessPipes">ProcessPipes</strong>; </dt> <dd>
<p>Object which contains <a href="std_stdio.html#File"><code>std.stdio.File</code></a> handles that allow communication with a child process through its standard streams.</p> <dl>
<dt class="d_decl" id="ProcessPipes.pid">nothrow @property @safe Pid <strong id="pid">pid</strong>(); </dt> <dd>
<p>The <a href="#Pid"><code>Pid</code></a> of the child process.</p> </dd> <dt class="d_decl" id="ProcessPipes.stdin">nothrow @property @safe File <strong id="stdin">stdin</strong>(); </dt> <dd>
<p>An <a href="std_stdio.html#File"><code>std.stdio.File</code></a> that allows writing to the child process' standard input stream. </p>
<dl>
<dt>Throws:</dt>
<dd>
<a href="object.html#Error"><code>Error</code></a> if the child process' standard input stream hasn't been redirected.</dd>
</dl> </dd> <dt class="d_decl" id="ProcessPipes.stdout">nothrow @property @safe File <strong id="stdout">stdout</strong>(); </dt> <dd>
<p>An <a href="std_stdio.html#File"><code>std.stdio.File</code></a> that allows reading from the child process' standard output stream. </p>
<dl>
<dt>Throws:</dt>
<dd>
<a href="object.html#Error"><code>Error</code></a> if the child process' standard output stream hasn't been redirected.</dd>
</dl> </dd> <dt class="d_decl" id="ProcessPipes.stderr">nothrow @property @safe File <strong id="stderr">stderr</strong>(); </dt> <dd>
<p>An <a href="std_stdio.html#File"><code>std.stdio.File</code></a> that allows reading from the child process' standard error stream. </p>
<dl>
<dt>Throws:</dt>
<dd>
<a href="object.html#Error"><code>Error</code></a> if the child process' standard error stream hasn't been redirected.</dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="execute">@safe auto <strong id="execute">execute</strong>(scope const(char[])[] args, const string[string] env = null, Config config = Config.none, size_t maxOutput = size_t.max, scope const(char)[] workDir = null); <br><br>@safe auto <strong id="execute">execute</strong>(scope const(char)[] program, const string[string] env = null, Config config = Config.none, size_t maxOutput = size_t.max, scope const(char)[] workDir = null); <br><br>@safe auto <strong id="executeShell">executeShell</strong>(scope const(char)[] command, const string[string] env = null, Config config = Config.none, size_t maxOutput = size_t.max, scope const(char)[] workDir = null, string shellPath = nativeShell); </dt> <dd>
<p>Executes the given program or shell command and returns its exit code and output. </p>
<p><code>execute</code> and <code>executeShell</code> start a new process using <a href="#spawnProcess"><code>spawnProcess</code></a> and <a href="#spawnShell"><code>spawnShell</code></a>, respectively, and wait for the process to complete before returning. The functions capture what the child process prints to both its standard output and standard error streams, and return this together with its exit code. <pre data-language="d">auto dmd = execute(["dmd", "myapp.d"]);
if (dmd.status != 0) writeln("Compilation failed:\n", dmd.output);

auto ls = executeShell("ls -l");
if (ls.status != 0) writeln("Failed to retrieve file listing");
else writeln(ls.output);
</pre> <br><br> The <code>args</code>/<code>program</code>/<code>command</code>, <code>env</code> and <code>config</code> parameters are forwarded straight to the underlying spawn functions, and we refer to their documentation for details. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(char[])[] <code>args</code>
</td> <td>An array which contains the program name as the zeroth element and any command-line arguments in the following elements. (See <a href="#spawnProcess"><code>spawnProcess</code></a> for details.)</td>
</tr> <tr>
<td>const(char)[] <code>program</code>
</td> <td>The program name, <i>without</i> command-line arguments. (See <a href="#spawnProcess"><code>spawnProcess</code></a> for details.)</td>
</tr> <tr>
<td>const(char)[] <code>command</code>
</td> <td>A shell command which is passed verbatim to the command interpreter. (See <a href="#spawnShell"><code>spawnShell</code></a> for details.)</td>
</tr> <tr>
<td>string[string] <code>env</code>
</td> <td>Additional environment variables for the child process. (See <a href="#spawnProcess"><code>spawnProcess</code></a> for details.)</td>
</tr> <tr>
<td>Config <code>config</code>
</td> <td>Flags that control process creation. See <a href="#Config"><code>Config</code></a> for an overview of available flags, and note that the <code>retainStd...</code> flags have no effect in this function.</td>
</tr> <tr>
<td>size_t <code>maxOutput</code>
</td> <td>The maximum number of bytes of output that should be captured.</td>
</tr> <tr>
<td>const(char)[] <code>workDir</code>
</td> <td>The working directory for the new process. By default the child process inherits the parent's working directory.</td>
</tr> <tr>
<td>string <code>shellPath</code>
</td> <td>The path to the shell to use to run the specified program. By default this is <a href="#nativeShell"><code>nativeShell</code></a>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>An <code>std.typecons.Tuple!(int, "status", string, "output")</code>. </dd>
</dl> <dl>
<dt>POSIX specific</dt>
<dd> If the process is terminated by a signal, the <code>status</code> field of the return value will contain a negative number whose absolute value is the signal number. (See <a href="#wait"><code>wait</code></a> for details.) </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="#ProcessException"><code>ProcessException</code></a> on failure to start the process.<br> <a href="std_stdio.html#StdioException"><code>std.stdio.StdioException</code></a> on failure to capture output.</dd>
</dl> </dd> <dt class="d_decl" id="ProcessException">class <strong id="ProcessException">ProcessException</strong>: object.Exception; </dt> <dd>
<p>An exception that signals a problem with starting or waiting for a process.</p> </dd> <dt class="d_decl" id="userShell">@property @safe string <strong id="userShell">userShell</strong>(); </dt> <dd>
<p>Determines the path to the current user's preferred command interpreter. </p>
<p>On Windows, this function returns the contents of the COMSPEC environment variable, if it exists. Otherwise, it returns the result of <a href="#nativeShell"><code>nativeShell</code></a>. <br><br> On POSIX, <code>userShell</code> returns the contents of the SHELL environment variable, if it exists and is non-empty. Otherwise, it returns the result of <a href="#nativeShell"><code>nativeShell</code></a>.</p> </dd> <dt class="d_decl" id="nativeShell">pure nothrow @nogc @property @safe string <strong id="nativeShell">nativeShell</strong>(); </dt> <dd>
<p>The platform-specific native shell path. </p>
<p>This function returns <code>"cmd.exe"</code> on Windows, <code>"/bin/sh"</code> on POSIX, and <code>"/system/bin/sh"</code> on Android.</p> </dd> <dt class="d_decl" id="escapeShellCommand">pure @safe string <strong id="escapeShellCommand">escapeShellCommand</strong>(scope const(char[])[] args...); </dt> <dd>
<p>Escapes an argv-style argument array to be used with <a href="#spawnShell"><code>spawnShell</code></a>, <a href="#pipeShell"><code>pipeShell</code></a> or <a href="#executeShell"><code>executeShell</code></a>. <pre data-language="d">string url = "http://dlang.org/";
executeShell(escapeShellCommand("wget", url, "-O", "dlang-index.html"));
</pre> </p>
<p>Concatenate multiple <code>escapeShellCommand</code> and <a href="#escapeShellFileName"><code>escapeShellFileName</code></a> results to use shell redirection or piping operators. <pre data-language="d">executeShell(
    escapeShellCommand("curl", "http://dlang.org/download.html") ~
    "|" ~
    escapeShellCommand("grep", "-o", `http://\S*\.zip`) ~
    "&gt;" ~
    escapeShellFileName("D download links.txt"));
</pre> </p> <dl>
<dt>Throws:</dt>
<dd>
<a href="object.html#Exception"><code>Exception</code></a> if any part of the command line contains unescapable characters (NUL on all platforms, as well as CR and LF on Windows).</dd>
</dl> </dd> <dt class="d_decl" id="escapeWindowsArgument">pure nothrow @trusted string <strong id="escapeWindowsArgument">escapeWindowsArgument</strong>(scope const(char)[] arg); </dt> <dd>
<p>Quotes a command-line argument in a manner conforming to the behavior of <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/bb776391(v=vs.85).aspx">CommandLineToArgvW</a>.</p> </dd> <dt class="d_decl" id="escapeShellFileName">pure nothrow @trusted string <strong id="escapeShellFileName">escapeShellFileName</strong>(scope const(char)[] fileName); </dt> <dd>
<p>Escapes a filename to be used for shell redirection with <a href="#spawnShell"><code>spawnShell</code></a>, <a href="#pipeShell"><code>pipeShell</code></a> or <a href="#executeShell"><code>executeShell</code></a>.</p> </dd> <dt class="d_decl" id="execv">int <strong id="execv">execv</strong>(in string pathname, in string[] argv); <br><br>int <strong id="execve">execve</strong>(in string pathname, in string[] argv, in string[] envp); <br><br>int <strong id="execvp">execvp</strong>(in string pathname, in string[] argv); <br><br>int <strong id="execvpe">execvpe</strong>(in string pathname, in string[] argv, in string[] envp); </dt> <dd>
<p>Replaces the current process by executing a command, <code>pathname</code>, with the arguments in <code>argv</code>. </p>
<p><span class="blue">This function is Posix-Only.</span> <br><br> Typically, the first element of <code>argv</code> is the command being executed, i.e. <code>argv[0] == pathname</code>. The 'p' versions of <code>exec</code> search the PATH environment variable for <code> pathname</code>. The 'e' versions additionally take the new process' environment variables as an array of strings of the form key=value. <br><br> Does not return on success (the current process will have been replaced). Returns -1 on failure with no indication of the underlying error. </p> <dl>
<dt>Windows specific</dt>
<dd> These functions are only supported on POSIX platforms, as the Windows operating systems do not provide the ability to overwrite the current process image with another. In single-threaded programs it is possible to approximate the effect of <code>execv*</code> by using <a href="#spawnProcess"><code>spawnProcess</code></a> and terminating the current process once the child process has returned. For example: </dd>
</dl>
<pre data-language="d">auto commandLine = [ "program", "arg1", "arg2" ];
version (Posix)
{
    execv(commandLine[0], commandLine);
    throw new Exception("Failed to execute program");
}
else version (Windows)
{
    import core.stdc.stdlib : _Exit;
    _Exit(wait(spawnProcess(commandLine)));
}
</pre> This is, however, NOT equivalent to POSIX' <code>execv*</code>. For one thing, the executed program is started as a separate process, with all this entails. Secondly, in a multithreaded program, other threads will continue to do work while the current thread is waiting for the child process to complete.  A better option may sometimes be to terminate the current program immediately after spawning the child process. This is the behaviour exhibited by the <a href="http://msdn.microsoft.com/en-us/library/431x4c1w.aspx"><code>__exec</code></a> functions in Microsoft's C runtime library, and it is how D's now-deprecated Windows <code>execv*</code> functions work. Example: <pre data-language="d">auto commandLine = [ "program", "arg1", "arg2" ];
version (Posix)
{
    execv(commandLine[0], commandLine);
    throw new Exception("Failed to execute program");
}
else version (Windows)
{
    spawnProcess(commandLine);
    import core.stdc.stdlib : _exit;
    _exit(0);
}
</pre>  </dd> <dt class="d_decl" id="browse">void <strong id="browse">browse</strong>(scope const(char)[] url); </dt> <dd>
<p>Start up the browser and set it to viewing the page at url.</p> </dd> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1999&ndash;2021 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/std_process.html" class="_attribution-link">https://dlang.org/phobos/std_process.html</a>
  </p>
</div>
