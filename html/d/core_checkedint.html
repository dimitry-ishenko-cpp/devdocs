<h1>core.checkedint</h1>  <p>This module implements integral arithmetic primitives that check for out-of-range results. </p>
<p>Integral arithmetic operators operate on fixed width types. Results that are not representable in those fixed widths are silently truncated to fit. This module offers integral arithmetic primitives that produce the same results, but set an 'overflow' flag when such truncation occurs. The setting is sticky, meaning that numerous operations can be cascaded and then the flag need only be checked at the end. Whether the operation is signed or unsigned is indicated by an 's' or 'u' suffix, respectively. While this could be achieved without such suffixes by using overloading on the signedness of the types, the suffix makes it clear which is happening without needing to examine the types. <br><br> While the generic versions of these functions are computationally expensive relative to the cost of the operation itself, compiler implementations are free to recognize them and generate equivalent and faster code. </p> <dl>
<dt>References</dt>
<dd> <a href="http://blog.regehr.org/archives/1139">Fast Integer Overflow Checks</a> </dd>
</dl> <dl>
<dt>License:</dt>
<dd>
<a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a> </dd>
</dl> <dl>
<dt>Authors:</dt>
<dd>Walter Bright </dd>
</dl> <dl>
<dt>Source</dt>
<dd> <a href="https://github.com/dlang/druntime/blob/master/src/core/checkedint.d">core/checkedint.d</a>
</dd>
</dl> <dl>
<dt class="d_decl" id="adds">int <strong id="adds">adds</strong>()(int x, int y, ref bool overflow); <br><br>long <strong id="adds">adds</strong>()(long x, long y, ref bool overflow); </dt> <dd>
<p>Add two signed integers, checking for overflow. </p>
<p>The overflow is sticky, meaning a sequence of operations can be done and overflow need only be checked at the end. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>int <code>x</code>
</td> <td>left operand</td>
</tr> <tr>
<td>int <code>y</code>
</td> <td>right operand</td>
</tr> <tr>
<td>bool <code>overflow</code>
</td> <td>set if an overflow occurs, is not affected otherwise</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>the sum</dd>
</dl> </dd> <dt class="d_decl" id="addu">uint <strong id="addu">addu</strong>()(uint x, uint y, ref bool overflow); <br><br>ulong <strong id="addu">addu</strong>()(ulong x, ulong y, ref bool overflow); </dt> <dd>
<p>Add two unsigned integers, checking for overflow (aka carry). </p>
<p>The overflow is sticky, meaning a sequence of operations can be done and overflow need only be checked at the end. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>uint <code>x</code>
</td> <td>left operand</td>
</tr> <tr>
<td>uint <code>y</code>
</td> <td>right operand</td>
</tr> <tr>
<td>bool <code>overflow</code>
</td> <td>set if an overflow occurs, is not affected otherwise</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>the sum</dd>
</dl> </dd> <dt class="d_decl" id="subs">int <strong id="subs">subs</strong>()(int x, int y, ref bool overflow); <br><br>long <strong id="subs">subs</strong>()(long x, long y, ref bool overflow); </dt> <dd>
<p>Subtract two signed integers, checking for overflow. </p>
<p>The overflow is sticky, meaning a sequence of operations can be done and overflow need only be checked at the end. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>int <code>x</code>
</td> <td>left operand</td>
</tr> <tr>
<td>int <code>y</code>
</td> <td>right operand</td>
</tr> <tr>
<td>bool <code>overflow</code>
</td> <td>set if an overflow occurs, is not affected otherwise</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>the difference</dd>
</dl> </dd> <dt class="d_decl" id="subu">uint <strong id="subu">subu</strong>()(uint x, uint y, ref bool overflow); <br><br>ulong <strong id="subu">subu</strong>()(ulong x, ulong y, ref bool overflow); </dt> <dd>
<p>Subtract two unsigned integers, checking for overflow (aka borrow). </p>
<p>The overflow is sticky, meaning a sequence of operations can be done and overflow need only be checked at the end. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>uint <code>x</code>
</td> <td>left operand</td>
</tr> <tr>
<td>uint <code>y</code>
</td> <td>right operand</td>
</tr> <tr>
<td>bool <code>overflow</code>
</td> <td>set if an overflow occurs, is not affected otherwise</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>the difference</dd>
</dl> </dd> <dt class="d_decl" id="negs">int <strong id="negs">negs</strong>()(int x, ref bool overflow); <br><br>long <strong id="negs">negs</strong>()(long x, ref bool overflow); </dt> <dd>
<p>Negate an integer. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>int <code>x</code>
</td> <td>operand</td>
</tr> <tr>
<td>bool <code>overflow</code>
</td> <td>set if x cannot be negated, is not affected otherwise</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>the negation of x</dd>
</dl> </dd> <dt class="d_decl" id="muls">int <strong id="muls">muls</strong>()(int x, int y, ref bool overflow); <br><br>long <strong id="muls">muls</strong>()(long x, long y, ref bool overflow); </dt> <dd>
<p>Multiply two signed integers, checking for overflow. </p>
<p>The overflow is sticky, meaning a sequence of operations can be done and overflow need only be checked at the end. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>int <code>x</code>
</td> <td>left operand</td>
</tr> <tr>
<td>int <code>y</code>
</td> <td>right operand</td>
</tr> <tr>
<td>bool <code>overflow</code>
</td> <td>set if an overflow occurs, is not affected otherwise</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>the product</dd>
</dl> </dd> <dt class="d_decl" id="mulu">uint <strong id="mulu">mulu</strong>()(uint x, uint y, ref bool overflow); <br><br>ulong <strong id="mulu">mulu</strong>()(ulong x, uint y, ref bool overflow); <br><br>ulong <strong id="mulu">mulu</strong>()(ulong x, ulong y, ref bool overflow); </dt> <dd>
<p>Multiply two unsigned integers, checking for overflow (aka carry). </p>
<p>The overflow is sticky, meaning a sequence of operations can be done and overflow need only be checked at the end. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>uint <code>x</code>
</td> <td>left operand</td>
</tr> <tr>
<td>uint <code>y</code>
</td> <td>right operand</td>
</tr> <tr>
<td>bool <code>overflow</code>
</td> <td>set if an overflow occurs, is not affected otherwise</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>the product</dd>
</dl> </dd> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1999&ndash;2021 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/core_checkedint.html" class="_attribution-link">https://dlang.org/phobos/core_checkedint.html</a>
  </p>
</div>
