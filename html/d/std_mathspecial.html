<h1>std.mathspecial</h1>  <p>Mathematical Special Functions </p>
<p>The technical term 'Special Functions' includes several families of transcendental functions, which have important applications in particular branches of mathematics and physics. <br><br> The gamma and related functions, and the error function are crucial for mathematical statistics. The Bessel and related functions arise in problems involving wave propagation (especially in optics). Other major categories of special functions include the elliptic integrals (related to the arc length of an ellipse), and the hypergeometric functions. </p> <dl>
<dt>Status</dt>
<dd> Many more functions will be added to this module. The naming convention for the distribution functions (gammaIncomplete, etc) is not yet finalized and will probably change. </dd>
</dl> <dl>
<dt>License:</dt>
<dd>
<a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>. </dd>
</dl> <dl>
<dt>Authors:</dt>
<dd>Stephen L. Moshier (original C code). Conversion to D by Don Clugston </dd>
</dl> <dl>
<dt>Source</dt>
<dd> <span class="phobos_src"><a class="https" href="https://github.com/dlang/phobos/blob/master/std/mathspecial.d">std/mathspecial.d</a></span>
</dd>
</dl> <dl>
<dt class="d_decl" id="gamma">pure nothrow @nogc @safe real <strong id="gamma">gamma</strong>(real x); </dt> <dd>
<p>The Gamma function, Γ(x) </p>
<p>Γ(x) is a generalisation of the factorial function to real and complex numbers. Like x!, Γ(x+1) = x * Γ(x). <br><br> Mathematically, if z.re &gt; 0 then Γ(z) = <em class="big">∫<sub><small>0</small></sub><sup>∞</sup></em> t<sup>z-1</sup>e<sup>-t</sup> dt <br><br> <table> <caption>Special Values</caption> <tr>
<th scope="col"> x</th> <th scope="col"> Γ(x) </th>
</tr> <tr>
<td> <span class="red">NAN</span>
</td> <td> <span class="red">NAN</span> </td>
</tr> <tr>
<td> ±0.0</td> <td>±∞</td>
</tr> <tr>
<td>integer &gt; 0</td> <td> (x-1)! </td>
</tr> <tr>
<td>integer &lt; 0</td> <td> <span class="red">NAN</span> </td>
</tr> <tr>
<td>+∞</td> <td> +∞ </td>
</tr> <tr>
<td>-∞</td> <td> <span class="red">NAN</span> </td>
</tr> </table></p> </dd> <dt class="d_decl" id="logGamma">pure nothrow @nogc @safe real <strong id="logGamma">logGamma</strong>(real x); </dt> <dd>
<p>Natural logarithm of the gamma function, Γ(x) </p>
<p>Returns the base e (2.718...) logarithm of the absolute value of the gamma function of the argument. <br><br> For reals, logGamma is equivalent to log(fabs(gamma(x))). <br><br> <table> <caption>Special Values</caption> <tr>
<th scope="col"> x</th> <th scope="col"> logGamma(x) </th>
</tr> <tr>
<td> <span class="red">NAN</span>
</td> <td> <span class="red">NAN</span> </td>
</tr> <tr>
<td>integer &lt;= 0</td> <td> +∞ </td>
</tr> <tr>
<td>±∞</td> <td> +∞ </td>
</tr> </table></p> </dd> <dt class="d_decl" id="sgnGamma">pure nothrow @nogc @safe real <strong id="sgnGamma">sgnGamma</strong>(real x); </dt> <dd>
<p>The sign of Γ(x). </p>
<p>Returns -1 if Γ(x) &lt; 0, +1 if Γ(x) &gt; 0, <span class="red">NAN</span> if sign is indeterminate. <br><br> Note that this function can be used in conjunction with logGamma(x) to evaluate gamma for very large values of x.</p> </dd> <dt class="d_decl" id="beta">pure nothrow @nogc @safe real <strong id="beta">beta</strong>(real x, real y); </dt> <dd>
<p>Beta function </p>
<p>The beta function is defined as <br><br> beta(x, y) = (Γ(x) * Γ(y)) / Γ(x + y)</p> </dd> <dt class="d_decl" id="digamma">pure nothrow @nogc @safe real <strong id="digamma">digamma</strong>(real x); </dt> <dd>
<p>Digamma function </p>
<p>The digamma function is the logarithmic derivative of the gamma function. <br><br> digamma(x) = d/dx logGamma(x) </p> <dl>
<dt>See Also:</dt>
<dd>
<a href="#logmdigamma"><code>logmdigamma</code></a>, <a href="#logmdigammaInverse"><code>logmdigammaInverse</code></a>.</dd>
</dl> </dd> <dt class="d_decl" id="logmdigamma">pure nothrow @nogc @safe real <strong id="logmdigamma">logmdigamma</strong>(real x); </dt> <dd>
<p>Log Minus Digamma function </p>
<p>logmdigamma(x) = log(x) - digamma(x) </p> <dl>
<dt>See Also:</dt>
<dd>
<a href="#digamma"><code>digamma</code></a>, <a href="#logmdigammaInverse"><code>logmdigammaInverse</code></a>.</dd>
</dl> </dd> <dt class="d_decl" id="logmdigammaInverse">pure nothrow @nogc @safe real <strong id="logmdigammaInverse">logmdigammaInverse</strong>(real x); </dt> <dd>
<p>Inverse of the Log Minus Digamma function </p>
<p>Given y, the function finds x such log(x) - digamma(x) = y. </p> <dl>
<dt>See Also:</dt>
<dd>
<a href="#logmdigamma"><code>logmdigamma</code></a>, <a href="#digamma"><code>digamma</code></a>.</dd>
</dl> </dd> <dt class="d_decl" id="betaIncomplete">pure nothrow @nogc @safe real <strong id="betaIncomplete">betaIncomplete</strong>(real a, real b, real x); </dt> <dd>
<p>Incomplete beta integral </p>
<p>Returns incomplete beta integral of the arguments, evaluated from zero to x. The regularized incomplete beta function is defined as <br><br> betaIncomplete(a, b, x) = Γ(a + b) / ( Γ(a) Γ(b) ) * <em class="big">∫<sub><small>0</small></sub><sup>x</sup></em> t<sup>a-1</sup>(1-t)<sup>b-1</sup> dt <br><br> and is the same as the the cumulative distribution function. <br><br> The domain of definition is 0 &lt;= x &lt;= 1. In this implementation a and b are restricted to positive values. The integral from x to 1 may be obtained by the symmetry relation <br><br> betaIncompleteCompl(a, b, x ) = betaIncomplete( b, a, 1-x ) <br><br> The integral is evaluated by a continued fraction expansion or, when b * x is small, by a power series.</p> </dd> <dt class="d_decl" id="betaIncompleteInverse">pure nothrow @nogc @safe real <strong id="betaIncompleteInverse">betaIncompleteInverse</strong>(real a, real b, real y); </dt> <dd>
<p>Inverse of incomplete beta integral </p>
<p>Given y, the function finds x such that <br><br> betaIncomplete(a, b, x) == y <br><br> Newton iterations or interval halving is used.</p> </dd> <dt class="d_decl" id="gammaIncomplete">pure nothrow @nogc @safe real <strong id="gammaIncomplete">gammaIncomplete</strong>(real a, real x); <br><br>pure nothrow @nogc @safe real <strong id="gammaIncompleteCompl">gammaIncompleteCompl</strong>(real a, real x); </dt> <dd>
<p>Incomplete gamma integral and its complement </p>
<p>These functions are defined by <br><br> gammaIncomplete = ( <em class="big">∫<sub><small>0</small></sub><sup>x</sup></em> e<sup>-t</sup> t<sup>a-1</sup> dt )/ Γ(a) <br><br> gammaIncompleteCompl(a,x) = 1 - gammaIncomplete(a,x) = (<em class="big">∫<sub><small>x</small></sub><sup>∞</sup></em> e<sup>-t</sup> t<sup>a-1</sup> dt )/ Γ(a) <br><br> In this implementation both arguments must be positive. The integral is evaluated by either a power series or continued fraction expansion, depending on the relative values of a and x.</p> </dd> <dt class="d_decl" id="gammaIncompleteComplInverse">pure nothrow @nogc @safe real <strong id="gammaIncompleteComplInverse">gammaIncompleteComplInverse</strong>(real a, real p); </dt> <dd>
<p>Inverse of complemented incomplete gamma integral </p>
<p>Given a and p, the function finds x such that <br><br> gammaIncompleteCompl( a, x ) = p.</p> </dd> <dt class="d_decl" id="erf">pure nothrow @nogc @safe real <strong id="erf">erf</strong>(real x); </dt> <dd>
<p>Error function </p>
<p>The integral is <br><br> erf(x) = 2/ √(π) <em class="big">∫<sub><small>0</small></sub><sup>x</sup></em> exp( - t<sup>2</sup>) dt <br><br> The magnitude of x is limited to about 106.56 for IEEE 80-bit arithmetic; 1 or -1 is returned outside this range.</p> </dd> <dt class="d_decl" id="erfc">pure nothrow @nogc @safe real <strong id="erfc">erfc</strong>(real x); </dt> <dd>
<p>Complementary error function </p>
<p>erfc(x) = 1 - erf(x) = 2/ √(π) <em class="big">∫<sub><small>x</small></sub><sup>∞</sup></em> exp( - t<sup>2</sup>) dt <br><br> This function has high relative accuracy for values of x far from zero. (For values near zero, use erf(x)).</p> </dd> <dt class="d_decl" id="normalDistribution">pure nothrow @nogc @safe real <strong id="normalDistribution">normalDistribution</strong>(real x); </dt> <dd>
<p>Standard normal distribution function. </p>
<p>The normal (or Gaussian, or bell-shaped) distribution is defined as: <br><br> normalDist(x) = 1/√(2π) <em class="big">∫<sub><small>-∞</small></sub><sup>x</sup></em> exp( - t<sup>2</sup>/2) dt = 0.5 + 0.5 * erf(x/sqrt(2)) = 0.5 * erfc(- x/sqrt(2)) <br><br> To maintain accuracy at values of x near 1.0, use normalDistribution(x) = 1.0 - normalDistribution(-x). </p> <dl>
<dt>References</dt>
<dd> <a href="http://www.netlib.org/cephes/ldoubdoc.html">http://www.netlib.org/cephes/ldoubdoc.html</a>, G. Marsaglia, "Evaluating the Normal Distribution", Journal of Statistical Software <b>11</b>, (July 2004).</dd>
</dl> </dd> <dt class="d_decl" id="normalDistributionInverse">pure nothrow @nogc @safe real <strong id="normalDistributionInverse">normalDistributionInverse</strong>(real p); </dt> <dd>
<p>Inverse of Standard normal distribution function </p>
<p>Returns the argument, x, for which the area under the Normal probability density function (integrated from minus infinity to x) is equal to p. </p> <dl>
<dt>Note</dt>
<dd> This function is only implemented to 80 bit precision.</dd>
</dl> </dd> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1999&ndash;2021 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/std_mathspecial.html" class="_attribution-link">https://dlang.org/phobos/std_mathspecial.html</a>
  </p>
</div>
