<h1>std.uuid</h1>  <p>A <a href="http://en.wikipedia.org/wiki/Universally_unique_identifier">UUID</a>, or <a href="http://en.wikipedia.org/wiki/Universally_unique_identifier">Universally unique identifier</a>, is intended to uniquely identify information in a distributed environment without significant central coordination. It can be used to tag objects with very short lifetimes, or to reliably identify very persistent objects across a network. </p>
<table>

<tr>
<th scope="col">Category</th> <th scope="col">Functions</th> </tr> <tr>
<td>Parsing UUIDs</td> <td>
<a href="#parseUUID"><em class="tt">parseUUID</em></a> <a href="#UUID"><em class="tt">UUID</em></a> <a href="#UUIDParsingException"><em class="tt">UUIDParsingException</em></a> <a href="#uuidRegex"><em class="tt">uuidRegex</em></a> </td> </tr> <tr>
<td>Generating UUIDs</td> <td>
<a href="#sha1UUID"><em class="tt">sha1UUID</em></a> <a href="#randomUUID"><em class="tt">randomUUID</em></a> <a href="#md5UUID"><em class="tt">md5UUID</em></a> </td> </tr> <tr>
<td>Using UUIDs</td> <td>
<a href="#uuidVersion"><em class="tt">UUID.uuidVersion</em></a> <a href="#variant"><em class="tt">UUID.variant</em></a> <a href="#toString"><em class="tt">UUID.toString</em></a> <a href="#data"><em class="tt">UUID.data</em></a> <a href="#swap"><em class="tt">UUID.swap</em></a> <a href="#opEquals"><em class="tt">UUID.opEquals</em></a> <a href="#opCmp"><em class="tt">UUID.opCmp</em></a> <a href="#toHash"><em class="tt">UUID.toHash</em></a> </td> </tr> <tr>
<td>UUID namespaces</td> <td>
<a href="#dnsNamespace"><em class="tt">dnsNamespace</em></a> <a href="#urlNamespace"><em class="tt">urlNamespace</em></a> <a href="#oidNamespace"><em class="tt">oidNamespace</em></a> <a href="#x500Namespace"><em class="tt">x500Namespace</em></a> </td> </tr> </table> <p>    UUIDs have many applications. Some examples follow: Databases may use UUIDs to identify rows or records in order to ensure that they are unique across different databases, or for publication/subscription services. Network messages may be identified with a UUID to ensure that different parts of a message are put back together again. Distributed computing may use UUIDs to identify a remote procedure call. Transactions and classes involved in serialization may be identified by UUIDs. Microsoft's component object model (COM) uses UUIDs to distinguish different software component interfaces. UUIDs are inserted into documents from Microsoft Office programs. UUIDs identify audio or video streams in the Advanced Systems Format (ASF). UUIDs are also a basis for OIDs (object identifiers), and URNs (uniform resource name). <br><br> An attractive feature of UUIDs when compared to alternatives is their relative small size, of 128 bits, or 16 bytes. Another is that the creation of UUIDs does not require a centralized authority. <br><br> When UUIDs are generated by one of the defined mechanisms, they are either guaranteed to be unique, different from all other generated UUIDs (that is, it has never been generated before and it will never be generated again), or it is extremely likely to be unique (depending on the mechanism). <br><br> For efficiency, UUID is implemented as a struct. UUIDs are therefore empty if not explicitly initialized. An UUID is empty if <a href="#empty">`UUID.empty`</a> is true. Empty UUIDs are equal to <code>UUID.init</code>, which is a UUID with all 16 bytes set to 0. Use UUID's constructors or the UUID generator functions to get an initialized UUID. <br><br> This is a port of <a href="http://www.boost.org/doc/libs/1_42_0/libs/uuid/uuid.html"> boost.uuid</a> from the Boost project with some minor additions and API changes for a more D-like API. </p> <dl>
<dt>Standards:</dt>
<dd>
<a href="http://www.ietf.org/rfc/rfc4122.txt">RFC 4122</a> </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="http://en.wikipedia.org/wiki/Universally_unique_identifier">http://en.wikipedia.org/wiki/Universally_unique_identifier</a> </dd>
</dl> <dl>
<dt>License:</dt>
<dd>
<a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>. </dd>
</dl> <dl>
<dt>Authors:</dt>
<dd>Johannes Pfau </dd>
</dl> <dl>
<dt>Source</dt>
<dd> <span class="phobos_src"><a class="https" href="https://github.com/dlang/phobos/blob/master/std/uuid.d">std/uuid.d</a></span> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.uuid;

UUID[] ids;
ids ~= randomUUID();
ids ~= md5UUID("test.name.123");
ids ~= sha1UUID("test.name.123");

foreach (entry; ids)
{
    writeln(entry.variant); // UUID.Variant.rfc4122
}
writeln(ids[0].uuidVersion); // UUID.Version.randomNumberBased
writeln(ids[1].toString()); // "22390768-cced-325f-8f0f-cfeaa19d0ccd"
assert(ids[1].data == [34, 57, 7, 104, 204, 237, 50, 95, 143, 15, 207,
    234, 161, 157, 12, 205]);
UUID id;
assert(id.empty);
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="UUID">struct <strong id="UUID">UUID</strong>; </dt> <dd>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">UUID id;
assert(id.empty);

id = randomUUID;
assert(!id.empty);

id = UUID(cast(ubyte[16]) [138, 179, 6, 14, 44, 186, 79,
    35, 183, 76, 181, 45, 179, 189, 251, 70]);
writeln(id.toString()); // "8ab3060e-2cba-4f23-b74c-b52db3bdfb46"
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="UUID.Variant">enum <strong id="Variant">Variant</strong>: int; </dt> <dd>
<p>RFC 4122 defines different internal data layouts for UUIDs. These are the UUID formats supported by this module. It's possible to read, compare and use all these Variants, but UUIDs generated by this module will always be in rfc4122 format. </p>
<dl>
<dt>Note</dt>
<dd> Do not confuse this with <a href="std_variant.html#Variant"><code>std.variant.Variant</code></a>.</dd>
</dl> <dl>
<dt class="d_decl" id="UUID.Variant.ncs"><strong id="ncs">ncs</strong></dt> <dd>
<p>NCS backward compatibility</p> </dd> <dt class="d_decl" id="UUID.Variant.rfc4122"><strong id="rfc4122">rfc4122</strong></dt> <dd>
<p>Defined in RFC 4122 document</p> </dd> <dt class="d_decl" id="UUID.Variant.microsoft"><strong id="microsoft">microsoft</strong></dt> <dd>
<p>Microsoft Corporation backward compatibility</p> </dd> <dt class="d_decl" id="UUID.Variant.future"><strong id="future">future</strong></dt> <dd>
<p>Reserved for future use</p> </dd> </dl> </dd> <dt class="d_decl" id="UUID.Version">enum <strong id="Version">Version</strong>: int; </dt> <dd>
<p>RFC 4122 defines different UUID versions. The version shows how a UUID was generated, e.g. a version 4 UUID was generated from a random number, a version 3 UUID from an MD5 hash of a name. </p>
<dl>
<dt>Note</dt>
<dd> All of these UUID versions can be read and processed by <code>std.uuid</code>, but only version 3, 4 and 5 UUIDs can be generated.</dd>
</dl> <dl>
<dt class="d_decl" id="UUID.Version.unknown"><strong id="unknown">unknown</strong></dt> <dd>
<p>Unknown version</p> </dd> <dt class="d_decl" id="UUID.Version.timeBased"><strong id="timeBased">timeBased</strong></dt> <dd>
<p>Version 1</p> </dd> <dt class="d_decl" id="UUID.Version.dceSecurity"><strong id="dceSecurity">dceSecurity</strong></dt> <dd>
<p>Version 2</p> </dd> <dt class="d_decl" id="UUID.Version.nameBasedMD5"><strong id="nameBasedMD5">nameBasedMD5</strong></dt> <dd>
<p>Version 3 (Name based + MD5)</p> </dd> <dt class="d_decl" id="UUID.Version.randomNumberBased"><strong id="randomNumberBased">randomNumberBased</strong></dt> <dd>
<p>Version 4 (Random)</p> </dd> <dt class="d_decl" id="UUID.Version.nameBasedSHA1"><strong id="nameBasedSHA1">nameBasedSHA1</strong></dt> <dd>
<p>Version 5 (Name based + SHA-1)</p> </dd> </dl> </dd> <dt class="d_decl" id="UUID.data">ubyte[16] <strong id="data">data</strong>; </dt> <dd>
<p>It is sometimes useful to get or set the 16 bytes of a UUID directly. </p>
<dl>
<dt>Note</dt>
<dd> UUID uses a 16-ubyte representation for the UUID data. RFC 4122 defines a UUID as a special structure in big-endian format. These 16-ubytes always equal the big-endian structure defined in RFC 4122. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto rawData = uuid.data; //get data
rawData[0] = 1; //modify
uuid.data = rawData; //set data
uuid.data[1] = 2; //modify directly
</pre>  </dd> <dt class="d_decl" id="UUID.this">pure nothrow @nogc @safe this(ref scope const ubyte[16] uuidData); <br><br>pure nothrow @nogc @safe this(const ubyte[16] uuidData); </dt> <dd>
<p>Construct a UUID struct from the 16 byte representation of a UUID.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">enum ubyte[16] data = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15];
auto uuid = UUID(data);
enum ctfe = UUID(data);
writeln(uuid.data); // data
writeln(ctfe.data); // data
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="UUID.this.2">pure @safe this(T...)(T uuidData)<br><small>  Constraints: if (uuidData.length == 16 &amp;&amp; allSatisfy!(isIntegral, T)); </small>
</dt> <dd>
<p>Construct a UUID struct from the 16 byte representation of a UUID. Variadic constructor to allow a simpler syntax, see examples. You need to pass exactly 16 ubytes.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto tmp = UUID(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15);
assert(tmp.data == cast(ubyte[16])[0,1,2,3,4,5,6,7,8,9,10,11,
    12,13,14,15]);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="UUID.this.3">this(T)(in T[] uuid)<br><small>  Constraints: if (isSomeChar!(Unqual!T)); </small>
</dt> <dd>
<p> Parse a UUID from its canonical string form. An UUID in its canonical form looks like this: 8ab3060e-2cba-4f23-b74c-b52db3bdfb46 </p>
<dl>
<dt>Throws:</dt>
<dd>
<a href="#UUIDParsingException"><code>UUIDParsingException</code></a> if the input is invalid </dd>
</dl> <dl>
<dt>CTFE</dt>
<dd> This function is supported in CTFE code. Note that error messages caused by a malformed UUID parsed at compile time can be cryptic, but errors are detected and reported at compile time. </dd>
</dl> <dl>
<dt>Note</dt>
<dd> This is a strict parser. It only accepts the pattern above. It doesn't support any leading or trailing characters. It only accepts characters used for hex numbers and the string must have hyphens exactly like above. </dd>
</dl> For a less strict parser, see <a href="#parseUUID"><code>parseUUID</code></a> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto id = UUID("8AB3060E-2cba-4f23-b74c-b52db3bdfb46");
assert(id.data == [138, 179, 6, 14, 44, 186, 79, 35, 183, 76,
   181, 45, 179, 189, 251, 70]);
writeln(id.toString()); // "8ab3060e-2cba-4f23-b74c-b52db3bdfb46"

//Can also be used in CTFE, for example as UUID literals:
enum ctfeID = UUID("8ab3060e-2cba-4f23-b74c-b52db3bdfb46");
//here parsing is done at compile time, no runtime overhead!
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="UUID.empty">const pure nothrow @nogc @property @trusted bool <strong id="empty">empty</strong>(); </dt> <dd>
<p>Returns true if and only if the UUID is equal to {00000000-0000-0000-0000-000000000000}</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">UUID id;
assert(id.empty);
id = UUID("00000000-0000-0000-0000-000000000001");
assert(!id.empty);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="UUID.variant">const pure nothrow @nogc @property @safe Variant <strong id="variant">variant</strong>(); </dt> <dd>
<p>RFC 4122 defines different internal data layouts for UUIDs. Returns the format used by this UUID. </p>
<dl>
<dt>Note</dt>
<dd> Do not confuse this with <a href="std_variant.html#Variant"><code>std.variant.Variant</code></a>. The type of this property is <a href="#Variant">`std.uuid.UUID.Variant`</a>. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd><a href="#Variant">`UUID.Variant`</a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(UUID("8ab3060e-2cba-4f23-b74c-b52db3bdfb46").variant
   == UUID.Variant.rfc4122);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="UUID.uuidVersion">const pure nothrow @nogc @property @safe Version <strong id="uuidVersion">uuidVersion</strong>(); </dt> <dd>
<p>RFC 4122 defines different UUID versions. The version shows how a UUID was generated, e.g. a version 4 UUID was generated from a random number, a version 3 UUID from an MD5 hash of a name. Returns the version used by this UUID. </p>
<dl>
<dt>See Also:</dt>
<dd><a href="#Version">`UUID.Version`</a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(UUID("8ab3060e-2cba-4f23-b74c-b52db3bdfb46").uuidVersion
    == UUID.Version.randomNumberBased);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="UUID.swap">pure nothrow @nogc @safe void <strong id="swap">swap</strong>(ref UUID rhs); </dt> <dd>
<p>Swap the data of this UUID with the data of rhs.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">immutable ubyte[16] data = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15];
UUID u1;
UUID u2 = UUID(data);
u1.swap(u2);

writeln(u1); // UUID(data)
writeln(u2); // UUID.init
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="UUID.opEquals">const pure nothrow @nogc @safe bool <strong id="opEquals">opEquals</strong>(const UUID s); <br><br>const pure nothrow @nogc @safe bool <strong id="opEquals">opEquals</strong>(ref scope const UUID s); <br><br>const pure nothrow @nogc @safe int <strong id="opCmp">opCmp</strong>(const UUID s); <br><br>const pure nothrow @nogc @safe int <strong id="opCmp">opCmp</strong>(ref scope const UUID s); <br><br>pure nothrow @nogc @safe UUID <strong id="opAssign">opAssign</strong>(const UUID s); <br><br>pure nothrow @nogc @safe UUID <strong id="opAssign">opAssign</strong>(ref scope const UUID s); <br><br>const pure nothrow @nogc @safe size_t <strong id="toHash">toHash</strong>(); </dt> <dd>
<p>All of the standard numeric operators are defined for the UUID struct.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">//compare UUIDs
writeln(UUID("00000000-0000-0000-0000-000000000000")); // UUID.init

//UUIDs in associative arrays:
int[UUID] test = [UUID("8a94f585-d180-44f7-8929-6fca0189c7d0") : 1,
    UUID("7c351fd4-b860-4ee3-bbdc-7f79f3dfb00a") : 2,
    UUID("9ac0a4e5-10ee-493a-86fc-d29eeb82ecc1") : 3];

writeln(test[UUID("9ac0a4e5-10ee-493a-86fc-d29eeb82ecc1")]); // 3

//UUIDS can be sorted:
import std.algorithm;
UUID[] ids = [UUID("8a94f585-d180-44f7-8929-6fca0189c7d0"),
              UUID("7c351fd4-b860-4ee3-bbdc-7f79f3dfb00a"),
              UUID("9ac0a4e5-10ee-493a-86fc-d29eeb82ecc1")];
sort(ids);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="UUID.toString">const void <strong id="toString">toString</strong>(Writer)(scope Writer sink); </dt> <dd>
<p>Write the UUID into <code>sink</code> as an ASCII string in the canonical form, which is 36 characters in the form "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx" </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Writer <code>sink</code>
</td> <td>OutputRange or writeable array at least 36 entries long</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="UUID.toString.2">const pure nothrow @trusted string <strong id="toString">toString</strong>(); </dt> <dd>
<p>Return the UUID as a string in the canonical form.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">immutable str = "8ab3060e-2cba-4f23-b74c-b52db3bdfb46";
auto id = UUID(str);
writeln(id.toString()); // str
</pre> </dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="md5UUID">pure nothrow @nogc @safe UUID <strong id="md5UUID">md5UUID</strong>(const(char[]) name, const UUID namespace = UUID.init); <br><br>pure nothrow @nogc @safe UUID <strong id="md5UUID">md5UUID</strong>(const(ubyte[]) data, const UUID namespace = UUID.init); </dt> <dd>
<p>This function generates a name based (Version 3) UUID from a namespace UUID and a name. If no namespace UUID was passed, the empty UUID <code>UUID.init</code> is used. </p>
<dl>
<dt>Note</dt>
<dd> The default namespaces (<a href="#dnsNamespace"><code>dnsNamespace</code></a>, ...) defined by this module should be used when appropriate. </dd>
</dl> RFC 4122 recommends to use Version 5 UUIDs (SHA-1) instead of Version 3 UUIDs (MD5) for new applications.  <dl>
<dt>CTFE</dt>
<dd> CTFE is not supported. </dd>
</dl> <dl>
<dt>Note</dt>
<dd> RFC 4122 isn't very clear on how UUIDs should be generated from names. It is possible that different implementations return different UUIDs for the same input, so be warned. The implementation for UTF-8 strings and byte arrays used by <code>std.uuid</code> is compatible with Boost's implementation. <code>std.uuid</code> guarantees that the same input to this function will generate the same output at any time, on any system (this especially means endianness doesn't matter). </dd>
</dl> <dl>
<dt>Note</dt>
<dd> This function does not provide overloads for wstring and dstring, as there's no clear answer on how that should be implemented. It could be argued, that string, wstring and dstring input should have the same output, but that wouldn't be compatible with Boost, which generates different output for strings and wstrings. It's always possible to pass wstrings and dstrings by using the ubyte[] function overload (but be aware of endianness issues!).</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">//Use default UUID.init namespace
auto simpleID = md5UUID("test.uuid.any.string");

//use a name-based id as namespace
auto namespace = md5UUID("my.app");
auto id = md5UUID("some-description", namespace);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="sha1UUID">pure nothrow @nogc @safe UUID <strong id="sha1UUID">sha1UUID</strong>(scope const(char)[] name, scope const UUID namespace = UUID.init); <br><br>pure nothrow @nogc @safe UUID <strong id="sha1UUID">sha1UUID</strong>(scope const(ubyte)[] data, scope const UUID namespace = UUID.init); </dt> <dd>
<p>This function generates a name based (Version 5) UUID from a namespace UUID and a name. If no namespace UUID was passed, the empty UUID <code>UUID.init</code> is used. </p>
<dl>
<dt>Note</dt>
<dd> The default namespaces (<a href="#dnsNamespace"><code>dnsNamespace</code></a>, ...) defined by this module should be used when appropriate. </dd>
</dl> <dl>
<dt>CTFE</dt>
<dd> CTFE is not supported. </dd>
</dl> <dl>
<dt>Note</dt>
<dd> RFC 4122 isn't very clear on how UUIDs should be generated from names. It is possible that different implementations return different UUIDs for the same input, so be warned. The implementation for UTF-8 strings and byte arrays used by <code>std.uuid</code> is compatible with Boost's implementation. <code>std.uuid</code> guarantees that the same input to this function will generate the same output at any time, on any system (this especially means endianness doesn't matter). </dd>
</dl> <dl>
<dt>Note</dt>
<dd> This function does not provide overloads for wstring and dstring, as there's no clear answer on how that should be implemented. It could be argued, that string, wstring and dstring input should have the same output, but that wouldn't be compatible with Boost, which generates different output for strings and wstrings. It's always possible to pass wstrings and dstrings by using the ubyte[] function overload (but be aware of endianness issues!).</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">//Use default UUID.init namespace
auto simpleID = sha1UUID("test.uuid.any.string");

//use a name-based id as namespace
auto namespace = sha1UUID("my.app");
auto id = sha1UUID("some-description", namespace);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="randomUUID">@safe UUID <strong id="randomUUID">randomUUID</strong>(); <br><br>UUID <strong id="randomUUID">randomUUID</strong>(RNG)(ref RNG randomGen)<br><small>  Constraints: if (isInputRange!RNG &amp;&amp; isIntegral!(ElementType!RNG)); </small>
</dt> <dd>
<p>This function generates a random number based UUID from a random number generator. </p>
<p>This function is not supported at compile time. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>RNG <code>randomGen</code>
</td> <td>uniform RNG</td>
</tr> </table></dd>
</dl> <dl>
<dt>See Also:</dt>
<dd><a href="std_random.html#isUniformRNG"><code>std.random.isUniformRNG</code></a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.random : Xorshift192, unpredictableSeed;

//simple call
auto uuid = randomUUID();

//provide a custom RNG. Must be seeded manually.
Xorshift192 gen;

gen.seed(unpredictableSeed);
auto uuid3 = randomUUID(gen);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="parseUUID">UUID <strong id="parseUUID">parseUUID</strong>(T)(T uuidString)<br><small>  Constraints: if (isSomeString!T); </small><br><br>UUID <strong id="parseUUID">parseUUID</strong>(Range)(ref Range uuidRange)<br><small>  Constraints: if (isInputRange!Range &amp;&amp; isSomeChar!(ElementType!Range)); </small>
</dt> <dd>
<p>This is a less strict parser compared to the parser used in the UUID constructor. It enforces the following rules: </p>
<p><ul> <li>hex numbers are always two hexdigits([0-9a-fA-F])</li> <li>there must be exactly 16 such pairs in the input, not less, not more</li> <li>there can be exactly one dash between two hex-pairs, but not more</li> <li>there can be multiple characters enclosing the 16 hex pairs, as long as these characters do not contain [0-9a-fA-F]</li> </ul> </p> <dl>
<dt>Note</dt>
<dd> Like most parsers, it consumes its argument. This means: </dd>
</dl>
<pre data-language="d">string s = "8AB3060E-2CBA-4F23-b74c-B52Db3BDFB46";
parseUUID(s);
assert(s == "");
</pre>  <dl>
<dt>Throws:</dt>
<dd>
<a href="#UUIDParsingException"><code>UUIDParsingException</code></a> if the input is invalid </dd>
</dl> <dl>
<dt>CTFE</dt>
<dd> This function is supported in CTFE code. Note that error messages caused by a malformed UUID parsed at compile time can be cryptic, but errors are detected and reported at compile time.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto id = parseUUID("8AB3060E-2CBA-4F23-b74c-B52Db3BDFB46");
//no dashes
id = parseUUID("8ab3060e2cba4f23b74cb52db3bdfb46");
//dashes at different positions
id = parseUUID("8a-b3-06-0e2cba4f23b74c-b52db3bdfb-46");
//leading / trailing characters
id = parseUUID("{8ab3060e-2cba-4f23-b74c-b52db3bdfb46}");
//unicode
id = parseUUID("ü8ab3060e2cba4f23b74cb52db3bdfb46ü");
//multiple trailing/leading characters
id = parseUUID("///8ab3060e2cba4f23b74cb52db3bdfb46||");

//Can also be used in CTFE, for example as UUID literals:
enum ctfeID = parseUUID("8ab3060e-2cba-4f23-b74c-b52db3bdfb46");
//here parsing is done at compile time, no runtime overhead!
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="dnsNamespace">enum UUID <strong id="dnsNamespace">dnsNamespace</strong>; </dt> <dd>
<p>Default namespace from RFC 4122 </p>
<p>Name string is a fully-qualified domain name</p> </dd> <dt class="d_decl" id="urlNamespace">enum UUID <strong id="urlNamespace">urlNamespace</strong>; </dt> <dd>
<p>Default namespace from RFC 4122 </p>
<p>Name string is a URL</p> </dd> <dt class="d_decl" id="oidNamespace">enum UUID <strong id="oidNamespace">oidNamespace</strong>; </dt> <dd>
<p>Default namespace from RFC 4122 </p>
<p>Name string is an ISO OID</p> </dd> <dt class="d_decl" id="x500Namespace">enum UUID <strong id="x500Namespace">x500Namespace</strong>; </dt> <dd>
<p>Default namespace from RFC 4122 </p>
<p>Name string is an X.500 DN (in DER or a text output format)</p> </dd> <dt class="d_decl" id="uuidRegex">enum string <strong id="uuidRegex">uuidRegex</strong>; </dt> <dd>
<p>Regex string to extract UUIDs from text.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm;
import std.regex;

string test = "Lorem ipsum dolor sit amet, consetetur "~
"6ba7b814-9dad-11d1-80b4-00c04fd430c8 sadipscing \n"~
"elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore \r\n"~
"magna aliquyam erat, sed diam voluptua. "~
"8ab3060e-2cba-4f23-b74c-b52db3bdfb46 At vero eos et accusam et "~
"justo duo dolores et ea rebum.";

auto r = regex(uuidRegex, "g");
UUID[] found;
foreach (c; match(test, r))
{
    found ~= UUID(c.hit);
}
assert(found == [
    UUID("6ba7b814-9dad-11d1-80b4-00c04fd430c8"),
    UUID("8ab3060e-2cba-4f23-b74c-b52db3bdfb46"),
]);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="UUIDParsingException">class <strong id="UUIDParsingException">UUIDParsingException</strong>: object.Exception; </dt> <dd>
<p>This exception is thrown if an error occurs when parsing a UUID from a string.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.exception : collectException;

const inputUUID = "this-is-an-invalid-uuid";
auto ex = collectException!UUIDParsingException(UUID(inputUUID));
assert(ex !is null); // check that exception was thrown
writeln(ex.input); // inputUUID
writeln(ex.position); // 0
writeln(ex.reason); // UUIDParsingException.Reason.tooLittle
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="UUIDParsingException.Reason">enum <strong id="Reason">Reason</strong>: int; <br><br>Reason <strong id="reason">reason</strong>; </dt> <dd>
<p>The reason why parsing the UUID string failed (if known)</p> <dl>
<dt class="d_decl" id="UUIDParsingException.Reason.unknown"><strong id="unknown">unknown</strong></dt>  <dt class="d_decl" id="UUIDParsingException.Reason.tooLittle"><strong id="tooLittle">tooLittle</strong></dt> <dd>
<p>The passed in input was correct, but more input was expected.</p> </dd> <dt class="d_decl" id="UUIDParsingException.Reason.tooMuch"><strong id="tooMuch">tooMuch</strong></dt> <dd>
<p>The input data is too long (There's no guarantee the first part of the data is valid)</p> </dd> <dt class="d_decl" id="UUIDParsingException.Reason.invalidChar"><strong id="invalidChar">invalidChar</strong></dt> <dd>
<p>Encountered an invalid character</p> </dd> </dl> </dd> <dt class="d_decl" id="UUIDParsingException.input">string <strong id="input">input</strong>; </dt> <dd>
<p>The original input string which should have been parsed.</p> </dd> <dt class="d_decl" id="UUIDParsingException.position">size_t <strong id="position">position</strong>; </dt> <dd>
<p>The position in the input string where the error occurred.</p> </dd> </dl> </dd> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1999&ndash;2021 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/std_uuid.html" class="_attribution-link">https://dlang.org/phobos/std_uuid.html</a>
  </p>
</div>
