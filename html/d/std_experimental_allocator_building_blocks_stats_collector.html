<h1>std.experimental.allocator.building_blocks.stats_collector</h1>  <p>Allocator that collects useful statistics about allocations, both global and per calling point. The statistics collected can be configured statically by choosing combinations of <code>Options</code> appropriately. </p>
<dl>
<dt>Source</dt>
<dd> <span class="phobos_src"><a class="https" href="https://github.com/dlang/phobos/blob/master/std/experimental/allocator/building_blocks/stats_collector.d">std/experimental/allocator/building_blocks/stats_collector.d</a></span>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.experimental.allocator.gc_allocator : GCAllocator;
import std.experimental.allocator.building_blocks.free_list : FreeList;
alias Allocator = StatsCollector!(GCAllocator, Options.bytesUsed);
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="Options">enum <strong id="Options">Options</strong>: ulong; </dt> <dd>
<p>Options for <code>StatsCollector</code> defined below. Each enables during compilation one specific counter, statistic, or other piece of information.</p> <dl>
<dt class="d_decl" id="Options.numOwns"><strong id="numOwns">numOwns</strong></dt> <dd>
<p>Counts the number of calls to <code>owns</code>.</p> </dd> <dt class="d_decl" id="Options.numAllocate"><strong id="numAllocate">numAllocate</strong></dt> <dd>
<p>Counts the number of calls to <code>allocate</code>. All calls are counted, including requests for zero bytes or failed requests.</p> </dd> <dt class="d_decl" id="Options.numAllocateOK"><strong id="numAllocateOK">numAllocateOK</strong></dt> <dd>
<p>Counts the number of calls to <code>allocate</code> that succeeded, i.e. they returned a block as large as requested. (N.B. requests for zero bytes count as successful.)</p> </dd> <dt class="d_decl" id="Options.numExpand"><strong id="numExpand">numExpand</strong></dt> <dd>
<p>Counts the number of calls to <code>expand</code>, regardless of arguments or result.</p> </dd> <dt class="d_decl" id="Options.numExpandOK"><strong id="numExpandOK">numExpandOK</strong></dt> <dd>
<p>Counts the number of calls to <code>expand</code> that resulted in a successful expansion.</p> </dd> <dt class="d_decl" id="Options.numReallocate"><strong id="numReallocate">numReallocate</strong></dt> <dd>
<p>Counts the number of calls to <code>reallocate</code>, regardless of arguments or result.</p> </dd> <dt class="d_decl" id="Options.numReallocateOK"><strong id="numReallocateOK">numReallocateOK</strong></dt> <dd>
<p>Counts the number of calls to <code>reallocate</code> that succeeded. (Reallocations to zero bytes count as successful.)</p> </dd> <dt class="d_decl" id="Options.numReallocateInPlace"><strong id="numReallocateInPlace">numReallocateInPlace</strong></dt> <dd>
<p>Counts the number of calls to <code>reallocate</code> that resulted in an in-place reallocation (no memory moved). If this number is close to the total number of reallocations, that indicates the allocator finds room at the current block's end in a large fraction of the cases, but also that internal fragmentation may be high (the size of the unit of allocation is large compared to the typical allocation size of the application).</p> </dd> <dt class="d_decl" id="Options.numDeallocate"><strong id="numDeallocate">numDeallocate</strong></dt> <dd>
<p>Counts the number of calls to <code>deallocate</code>.</p> </dd> <dt class="d_decl" id="Options.numDeallocateAll"><strong id="numDeallocateAll">numDeallocateAll</strong></dt> <dd>
<p>Counts the number of calls to <code>deallocateAll</code>.</p> </dd> <dt class="d_decl" id="Options.numAlignedAllocate"><strong id="numAlignedAllocate">numAlignedAllocate</strong></dt> <dd>
<p>Counts the number of calls to <code>alignedAllocate</code>. All calls are counted, including requests for zero bytes or failed requests.</p> </dd> <dt class="d_decl" id="Options.numAlignedAllocateOk"><strong id="numAlignedAllocateOk">numAlignedAllocateOk</strong></dt> <dd>
<p>Counts the number of calls to <code>alignedAllocate</code> that succeeded, i.e. they returned a block as large as requested. (N.B. requests for zero bytes count as successful.)</p> </dd> <dt class="d_decl" id="Options.numAll"><strong id="numAll">numAll</strong></dt> <dd>
<p>Chooses all <code>numXxx</code> flags.</p> </dd> <dt class="d_decl" id="Options.bytesUsed"><strong id="bytesUsed">bytesUsed</strong></dt> <dd>
<p>Tracks bytes currently allocated by this allocator. This number goes up and down as memory is allocated and deallocated, and is zero if the allocator currently has no active allocation.</p> </dd> <dt class="d_decl" id="Options.bytesAllocated"><strong id="bytesAllocated">bytesAllocated</strong></dt> <dd>
<p>Tracks total cumulative bytes allocated by means of <code>allocate</code>, <code>expand</code>, and <code>reallocate</code> (when resulting in an expansion). This number always grows and indicates allocation traffic. To compute bytes deallocated cumulatively, subtract <code>bytesUsed</code> from <code>bytesAllocated</code>.</p> </dd> <dt class="d_decl" id="Options.bytesExpanded"><strong id="bytesExpanded">bytesExpanded</strong></dt> <dd>
<p>Tracks the sum of all <code>delta</code> values in calls of the form <code>expand(b, delta)</code> that succeed (return <code>true</code>).</p> </dd> <dt class="d_decl" id="Options.bytesContracted"><strong id="bytesContracted">bytesContracted</strong></dt> <dd>
<p>Tracks the sum of all <code>b.length - s</code> with <code>b.length &gt; s</code> in calls of the form <code>realloc(b, s)</code> that succeed (return <code>true</code>). In per-call statistics, also unambiguously counts the bytes deallocated with <code>deallocate</code>.</p> </dd> <dt class="d_decl" id="Options.bytesMoved"><strong id="bytesMoved">bytesMoved</strong></dt> <dd>
<p>Tracks the sum of all bytes moved as a result of calls to <code>realloc</code> that were unable to reallocate in place. A large number (relative to <code> bytesAllocated</code>) indicates that the application should use larger preallocations.</p> </dd> <dt class="d_decl" id="Options.bytesNotMoved"><strong id="bytesNotMoved">bytesNotMoved</strong></dt> <dd>
<p>Tracks the sum of all bytes NOT moved as result of calls to <code>realloc</code> that managed to reallocate in place. A large number (relative to <code> bytesAllocated</code>) indicates that the application is expansion-intensive and is saving a good amount of moves. However, if this number is relatively small and <code>bytesSlack</code> is high, it means the application is overallocating for little benefit.</p> </dd> <dt class="d_decl" id="Options.bytesSlack"><strong id="bytesSlack">bytesSlack</strong></dt> <dd>
<p>Measures the sum of extra bytes allocated beyond the bytes requested, i.e. the <a href="http://goo.gl/YoKffF">internal fragmentation</a>. This is the current effective number of slack bytes, and it goes up and down with time.</p> </dd> <dt class="d_decl" id="Options.bytesHighTide"><strong id="bytesHighTide">bytesHighTide</strong></dt> <dd>
<p>Measures the maximum bytes allocated over the time. This is useful for dimensioning allocators.</p> </dd> <dt class="d_decl" id="Options.bytesAll"><strong id="bytesAll">bytesAll</strong></dt> <dd>
<p>Chooses all <code>byteXxx</code> flags.</p> </dd> <dt class="d_decl" id="Options.all"><strong id="all">all</strong></dt> <dd>
<p>Combines all flags above.</p> </dd> </dl> </dd> <dt class="d_decl" id="StatsCollector">struct <strong id="StatsCollector">StatsCollector</strong>(Allocator, ulong flags = Options.all, ulong perCallFlags = 0); </dt> <dd>
<p>Allocator that collects extra data about allocations. Since each piece of information adds size and time overhead, statistics can be individually enabled or disabled through compile-time <code>flags</code>. </p>
<p>All stats of the form <code>numXxx</code> record counts of events occurring, such as calls to functions and specific results. The stats of the form <code>bytesXxx</code> collect cumulative sizes. <br><br> In addition, the data <code>callerSize</code>, <code>callerModule</code>, <code>callerFile</code>, <code>callerLine</code>, and <code>callerTime</code> is associated with each specific allocation. This data prefixes each allocation.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.experimental.allocator.building_blocks.free_list : FreeList;
import std.experimental.allocator.gc_allocator : GCAllocator;
alias Allocator = StatsCollector!(GCAllocator, Options.all, Options.all);

Allocator alloc;
auto b = alloc.allocate(10);
alloc.reallocate(b, 20);
alloc.deallocate(b);

import std.file : deleteme, remove;
import std.range : walkLength;
import std.stdio : File;

auto f = deleteme ~ "-dlang.std.experimental.allocator.stats_collector.txt";
scope(exit) remove(f);
Allocator.reportPerCallStatistics(File(f, "w"));
alloc.reportStatistics(File(f, "a"));
writeln(File(f).byLine.walkLength); // 24
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="StatsCollector.parent">Allocator <strong id="parent">parent</strong>; </dt> <dd>
<p>The parent allocator is publicly accessible either as a direct member if it holds state, or as an alias to <code>Allocator.instance</code> otherwise. One may use it for making calls that won't count toward statistics collection.</p> </dd> <dt class="d_decl" id="StatsCollector.alignment">alias <strong id="alignment">alignment</strong> = Allocator.<strong id="alignment">alignment</strong>; </dt> <dd>
<p>Alignment offered is equal to <code>Allocator.alignment</code>.</p> </dd> <dt class="d_decl" id="StatsCollector.owns">Ternary <strong id="owns">owns</strong>(void[] b); </dt> <dd>
<p>Increments <code>numOwns</code> (per instance and and per call) and forwards to <code> parent.owns(b)</code>.</p> </dd> <dt class="d_decl" id="StatsCollector.allocate">void[] <strong id="allocate">allocate</strong>(size_t n); </dt> <dd>
<p>Forwards to <code>parent.allocate</code>. Affects per instance: <code>numAllocate</code>, <code>bytesUsed</code>, <code>bytesAllocated</code>, <code>bytesSlack</code>, <code>numAllocateOK</code>, and <code>bytesHighTide</code>. Affects per call: <code>numAllocate</code>, <code> numAllocateOK</code>, and <code>bytesAllocated</code>.</p> </dd> <dt class="d_decl" id="StatsCollector.alignedAllocate">void[] <strong id="alignedAllocate">alignedAllocate</strong>(size_t n, uint a); </dt> <dd>
<p>Forwards to <code>parent.alignedAllocate</code>. Affects per instance: <code>numAlignedAllocate</code>, <code>bytesUsed</code>, <code>bytesAllocated</code>, <code>bytesSlack</code>, <code>numAlignedAllocateOk</code>, and <code>bytesHighTide</code>. Affects per call: <code>numAlignedAllocate</code>, <code>numAlignedAllocateOk</code>, and <code>bytesAllocated</code>.</p> </dd> <dt class="d_decl" id="StatsCollector.expand">bool <strong id="expand">expand</strong>(ref void[] b, size_t delta); </dt> <dd>
<p>Defined whether or not <code>Allocator.expand</code> is defined. Affects per instance: <code>numExpand</code>, <code>numExpandOK</code>, <code>bytesExpanded</code>, <code>bytesSlack</code>, <code>bytesAllocated</code>, and <code>bytesUsed</code>. Affects per call: <code>numExpand</code>, <code>numExpandOK</code>, <code>bytesExpanded</code>, and <code>bytesAllocated</code>.</p> </dd> <dt class="d_decl" id="StatsCollector.reallocate">bool <strong id="reallocate">reallocate</strong>(ref void[] b, size_t s); </dt> <dd>
<p>Defined whether or not <code>Allocator.reallocate</code> is defined. Affects per instance: <code>numReallocate</code>, <code>numReallocateOK</code>, <code> numReallocateInPlace</code>, <code>bytesNotMoved</code>, <code>bytesAllocated</code>, <code> bytesSlack</code>, <code>bytesExpanded</code>, and <code>bytesContracted</code>. Affects per call: <code>numReallocate</code>, <code>numReallocateOK</code>, <code>numReallocateInPlace</code>, <code>bytesNotMoved</code>, <code>bytesExpanded</code>, <code>bytesContracted</code>, and <code>bytesMoved</code>.</p> </dd> <dt class="d_decl" id="StatsCollector.deallocate">bool <strong id="deallocate">deallocate</strong>(void[] b); </dt> <dd>
<p>Defined whether or not <code>Allocator.deallocate</code> is defined. Affects per instance: <code>numDeallocate</code>, <code>bytesUsed</code>, and <code>bytesSlack</code>. Affects per call: <code>numDeallocate</code> and <code>bytesContracted</code>.</p> </dd> <dt class="d_decl" id="StatsCollector.deallocateAll">bool <strong id="deallocateAll">deallocateAll</strong>(); </dt> <dd>
<p>Defined only if <code>Allocator.deallocateAll</code> is defined. Affects per instance and per call <code>numDeallocateAll</code>.</p> </dd> <dt class="d_decl" id="StatsCollector.empty">pure nothrow @nogc @safe Ternary <strong id="empty">empty</strong>(); </dt> <dd>
<p>Defined only if <code>Options.bytesUsed</code> is defined. Returns <code>bytesUsed == 0</code>.</p> </dd> <dt class="d_decl" id="StatsCollector.reportStatistics">void <strong id="reportStatistics">reportStatistics</strong>(R)(auto ref R output); </dt> <dd>
<p>Reports per instance statistics to <code>output</code> (e.g. <code>stdout</code>). The format is simple: one kind and value per line, separated by a colon, e.g. <code>bytesAllocated:7395404</code></p> </dd> <dt class="d_decl" id="StatsCollector.PerCallStatistics">struct <strong id="PerCallStatistics">PerCallStatistics</strong>; </dt> <dd>
<p>Defined if <code>perCallFlags</code> is nonzero.</p> <dl>
<dt class="d_decl" id="StatsCollector.PerCallStatistics.file">string <strong id="file">file</strong>; <br><br>uint <strong id="line">line</strong>; </dt> <dd>
<p>The file and line of the call.</p> </dd> <dt class="d_decl" id="StatsCollector.PerCallStatistics.opts">Options[] <strong id="opts">opts</strong>; </dt> <dd>
<p>The options corresponding to the statistics collected.</p> </dd> <dt class="d_decl" id="StatsCollector.PerCallStatistics.values">ulong[] <strong id="values">values</strong>; </dt> <dd>
<p>The values of the statistics. Has the same length as <code>opts</code>.</p> </dd> <dt class="d_decl" id="StatsCollector.PerCallStatistics.toString">const string <strong id="toString">toString</strong>(); </dt> <dd>
<p>Format to a string such as: <code>mymodule.d(655): [numAllocate:21, numAllocateOK:21, bytesAllocated:324202]</code>.</p> </dd> </dl> </dd> <dt class="d_decl" id="StatsCollector.byFileLine">static auto <strong id="byFileLine">byFileLine</strong>(); </dt> <dd>
<p>Defined if <code>perCallFlags</code> is nonzero. Iterates all monitored file/line instances. The order of iteration is not meaningful (items are inserted at the front of a list upon the first call), so preprocessing the statistics after collection might be appropriate.</p> </dd> <dt class="d_decl" id="StatsCollector.reportPerCallStatistics">void <strong id="reportPerCallStatistics">reportPerCallStatistics</strong>(R)(auto ref R output); </dt> <dd>
<p>Defined if <code>perCallFlags</code> is nonzero. Outputs (e.g. to a <code>File</code>) a simple report of the collected per-call statistics.</p> </dd> </dl> </dd> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1999&ndash;2021 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/std_experimental_allocator_building_blocks_stats_collector.html" class="_attribution-link">https://dlang.org/phobos/std_experimental_allocator_building_blocks_stats_collector.html</a>
  </p>
</div>
