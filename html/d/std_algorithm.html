<h1>std.algorithm</h1>  <p>This package implements generic algorithms oriented towards the processing of sequences. Sequences processed by these functions define range-based interfaces. See also <a href="std_range.html">Reference on ranges</a> and <a href="http://ddili.org/ders/d.en/ranges.html">tutorial on ranges</a>. </p>
<p> <br><br> Algorithms are categorized into the following submodules: <br><br> <table>

<tr>
<th scope="col">Submodule</th> <th scope="col">Functions</th> </tr> <tr> <td><a href="std_algorithm_searching.html">Searching</a></td> <td> <a href="std_algorithm_searching.html#all"><em class="tt">all</em></a> <a href="std_algorithm_searching.html#any"><em class="tt">any</em></a> <a href="std_algorithm_searching.html#balancedParens"><em class="tt">balancedParens</em></a> <a href="std_algorithm_searching.html#boyerMooreFinder"><em class="tt">boyerMooreFinder</em></a> <a href="std_algorithm_searching.html#canFind"><em class="tt">canFind</em></a> <a href="std_algorithm_searching.html#commonPrefix"><em class="tt">commonPrefix</em></a> <a href="std_algorithm_searching.html#count"><em class="tt">count</em></a> <a href="std_algorithm_searching.html#countUntil"><em class="tt">countUntil</em></a> <a href="std_algorithm_searching.html#endsWith"><em class="tt">endsWith</em></a> <a href="std_algorithm_searching.html#find"><em class="tt">find</em></a> <a href="std_algorithm_searching.html#findAdjacent"><em class="tt">findAdjacent</em></a> <a href="std_algorithm_searching.html#findAmong"><em class="tt">findAmong</em></a> <a href="std_algorithm_searching.html#findSkip"><em class="tt">findSkip</em></a> <a href="std_algorithm_searching.html#findSplit"><em class="tt">findSplit</em></a> <a href="std_algorithm_searching.html#findSplitAfter"><em class="tt">findSplitAfter</em></a> <a href="std_algorithm_searching.html#findSplitBefore"><em class="tt">findSplitBefore</em></a> <a href="std_algorithm_searching.html#minCount"><em class="tt">minCount</em></a> <a href="std_algorithm_searching.html#maxCount"><em class="tt">maxCount</em></a> <a href="std_algorithm_searching.html#minElement"><em class="tt">minElement</em></a> <a href="std_algorithm_searching.html#maxElement"><em class="tt">maxElement</em></a> <a href="std_algorithm_searching.html#minIndex"><em class="tt">minIndex</em></a> <a href="std_algorithm_searching.html#maxIndex"><em class="tt">maxIndex</em></a> <a href="std_algorithm_searching.html#minPos"><em class="tt">minPos</em></a> <a href="std_algorithm_searching.html#maxPos"><em class="tt">maxPos</em></a> <a href="std_algorithm_searching.html#skipOver"><em class="tt">skipOver</em></a> <a href="std_algorithm_searching.html#startsWith"><em class="tt">startsWith</em></a> <a href="std_algorithm_searching.html#until"><em class="tt">until</em></a> </td> </tr> <tr> <td><a href="std_algorithm_comparison.html">Comparison</a></td> <td> <a href="std_algorithm_comparison.html#among"><em class="tt">among</em></a> <a href="std_algorithm_comparison.html#castSwitch"><em class="tt">castSwitch</em></a> <a href="std_algorithm_comparison.html#clamp"><em class="tt">clamp</em></a> <a href="std_algorithm_comparison.html#cmp"><em class="tt">cmp</em></a> <a href="std_algorithm_comparison.html#either"><em class="tt">either</em></a> <a href="std_algorithm_comparison.html#equal"><em class="tt">equal</em></a> <a href="std_algorithm_comparison.html#isPermutation"><em class="tt">isPermutation</em></a> <a href="std_algorithm_comparison.html#isSameLength"><em class="tt">isSameLength</em></a> <a href="std_algorithm_comparison.html#levenshteinDistance"><em class="tt">levenshteinDistance</em></a> <a href="std_algorithm_comparison.html#levenshteinDistanceAndPath"><em class="tt">levenshteinDistanceAndPath</em></a> <a href="std_algorithm_comparison.html#max"><em class="tt">max</em></a> <a href="std_algorithm_comparison.html#min"><em class="tt">min</em></a> <a href="std_algorithm_comparison.html#mismatch"><em class="tt">mismatch</em></a> <a href="std_algorithm_comparison.html#predSwitch"><em class="tt">predSwitch</em></a> </td> </tr> <tr> <td><a href="std_algorithm_iteration.html">Iteration</a></td> <td> <a href="std_algorithm_iteration.html#cache"><em class="tt">cache</em></a> <a href="std_algorithm_iteration.html#cacheBidirectional"><em class="tt">cacheBidirectional</em></a> <a href="std_algorithm_iteration.html#chunkBy"><em class="tt">chunkBy</em></a> <a href="std_algorithm_iteration.html#cumulativeFold"><em class="tt">cumulativeFold</em></a> <a href="std_algorithm_iteration.html#each"><em class="tt">each</em></a> <a href="std_algorithm_iteration.html#filter"><em class="tt">filter</em></a> <a href="std_algorithm_iteration.html#filterBidirectional"><em class="tt">filterBidirectional</em></a> <a href="std_algorithm_iteration.html#fold"><em class="tt">fold</em></a> <a href="std_algorithm_iteration.html#group"><em class="tt">group</em></a> <a href="std_algorithm_iteration.html#joiner"><em class="tt">joiner</em></a> <a href="std_algorithm_iteration.html#map"><em class="tt">map</em></a> <a href="std_algorithm_iteration.html#mean"><em class="tt">mean</em></a> <a href="std_algorithm_iteration.html#permutations"><em class="tt">permutations</em></a> <a href="std_algorithm_iteration.html#reduce"><em class="tt">reduce</em></a> <a href="std_algorithm_iteration.html#splitter"><em class="tt">splitter</em></a> <a href="std_algorithm_iteration.html#substitute"><em class="tt">substitute</em></a> <a href="std_algorithm_iteration.html#sum"><em class="tt">sum</em></a> <a href="std_algorithm_iteration.html#uniq"><em class="tt">uniq</em></a> </td> </tr> <tr> <td><a href="std_algorithm_sorting.html">Sorting</a></td> <td> <a href="std_algorithm_sorting.html#completeSort"><em class="tt">completeSort</em></a> <a href="std_algorithm_sorting.html#isPartitioned"><em class="tt">isPartitioned</em></a> <a href="std_algorithm_sorting.html#isSorted"><em class="tt">isSorted</em></a> <a href="std_algorithm_sorting.html#isStrictlyMonotonic"><em class="tt">isStrictlyMonotonic</em></a> <a href="std_algorithm_sorting.html#ordered"><em class="tt">ordered</em></a> <a href="std_algorithm_sorting.html#strictlyOrdered"><em class="tt">strictlyOrdered</em></a> <a href="std_algorithm_sorting.html#makeIndex"><em class="tt">makeIndex</em></a> <a href="std_algorithm_sorting.html#merge"><em class="tt">merge</em></a> <a href="std_algorithm_sorting.html#multiSort"><em class="tt">multiSort</em></a> <a href="std_algorithm_sorting.html#nextEvenPermutation"><em class="tt">nextEvenPermutation</em></a> <a href="std_algorithm_sorting.html#nextPermutation"><em class="tt">nextPermutation</em></a> <a href="std_algorithm_sorting.html#partialSort"><em class="tt">partialSort</em></a> <a href="std_algorithm_sorting.html#partition"><em class="tt">partition</em></a> <a href="std_algorithm_sorting.html#partition3"><em class="tt">partition3</em></a> <a href="std_algorithm_sorting.html#schwartzSort"><em class="tt">schwartzSort</em></a> <a href="std_algorithm_sorting.html#sort"><em class="tt">sort</em></a> <a href="std_algorithm_sorting.html#topN"><em class="tt">topN</em></a> <a href="std_algorithm_sorting.html#topNCopy"><em class="tt">topNCopy</em></a> <a href="std_algorithm_sorting.html#topNIndex"><em class="tt">topNIndex</em></a> </td> </tr> <tr> <td>Set operations <br>(<a href="std_algorithm_setops.html">setops</a>)</td> <td> <a href="std_algorithm_setops.html#cartesianProduct"><em class="tt">cartesianProduct</em></a> <a href="std_algorithm_setops.html#largestPartialIntersection"><em class="tt">largestPartialIntersection</em></a> <a href="std_algorithm_setops.html#largestPartialIntersectionWeighted"><em class="tt">largestPartialIntersectionWeighted</em></a> <a href="std_algorithm_setops.html#multiwayMerge"><em class="tt">multiwayMerge</em></a> <a href="std_algorithm_setops.html#multiwayUnion"><em class="tt">multiwayUnion</em></a> <a href="std_algorithm_setops.html#setDifference"><em class="tt">setDifference</em></a> <a href="std_algorithm_setops.html#setIntersection"><em class="tt">setIntersection</em></a> <a href="std_algorithm_setops.html#setSymmetricDifference"><em class="tt">setSymmetricDifference</em></a> </td> </tr> <tr> <td><a href="std_algorithm_mutation.html">Mutation</a></td> <td> <a href="std_algorithm_mutation.html#bringToFront"><em class="tt">bringToFront</em></a> <a href="std_algorithm_mutation.html#copy"><em class="tt">copy</em></a> <a href="std_algorithm_mutation.html#fill"><em class="tt">fill</em></a> <a href="std_algorithm_mutation.html#initializeAll"><em class="tt">initializeAll</em></a> <a href="std_algorithm_mutation.html#move"><em class="tt">move</em></a> <a href="std_algorithm_mutation.html#moveAll"><em class="tt">moveAll</em></a> <a href="std_algorithm_mutation.html#moveSome"><em class="tt">moveSome</em></a> <a href="std_algorithm_mutation.html#moveEmplace"><em class="tt">moveEmplace</em></a> <a href="std_algorithm_mutation.html#moveEmplaceAll"><em class="tt">moveEmplaceAll</em></a> <a href="std_algorithm_mutation.html#moveEmplaceSome"><em class="tt">moveEmplaceSome</em></a> <a href="std_algorithm_mutation.html#remove"><em class="tt">remove</em></a> <a href="std_algorithm_mutation.html#reverse"><em class="tt">reverse</em></a> <a href="std_algorithm_mutation.html#strip"><em class="tt">strip</em></a> <a href="std_algorithm_mutation.html#stripLeft"><em class="tt">stripLeft</em></a> <a href="std_algorithm_mutation.html#stripRight"><em class="tt">stripRight</em></a> <a href="std_algorithm_mutation.html#swap"><em class="tt">swap</em></a> <a href="std_algorithm_mutation.html#swapRanges"><em class="tt">swapRanges</em></a> <a href="std_algorithm_mutation.html#uninitializedFill"><em class="tt">uninitializedFill</em></a> </td> </tr> </table> <br><br> Many functions in this package are parameterized with a <a href="http://dlang.org/glossary.html#predicate">predicate</a>. The predicate may be any suitable callable type (a function, a delegate, a <a href="http://dlang.org/glossary.html#functor">functor</a>, or a lambda), or a compile-time string. The string may consist of <b>any</b> legal D expression that uses the symbol <code>a</code> (for unary functions) or the symbols <code>a</code> and <code>b</code> (for binary functions). These names will NOT interfere with other homonym symbols in user code because they are evaluated in a different context. The default for all binary comparison predicates is <code>"a == b"</code> for unordered operations and <code>"a &lt; b"</code> for ordered operations. </p> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">int[] a = ...;
static bool greater(int a, int b)
{
    return a &gt; b;
}
sort!greater(a);           // predicate as alias
sort!((a, b) =&gt; a &gt; b)(a); // predicate as a lambda.
sort!"a &gt; b"(a);           // predicate as string
                           // (no ambiguity with array name)
sort(a);                   // no predicate, "a &lt; b" is implicit
</pre>  <dl>
<dt>License:</dt>
<dd>
<a href="http://boost.org/LICENSE_1_0.txt">Boost License 1.0</a>. </dd>
</dl> <dl>
<dt>Authors:</dt>
<dd>
<a href="http://erdani.com">Andrei Alexandrescu</a> </dd>
</dl> <dl>
<dt>Source</dt>
<dd> <span class="phobos_src"><a class="https" href="https://github.com/dlang/phobos/blob/master/std/algorithm/package.d">std/algorithm/package.d</a></span>
</dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1999&ndash;2021 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/std_algorithm.html" class="_attribution-link">https://dlang.org/phobos/std_algorithm.html</a>
  </p>
</div>
