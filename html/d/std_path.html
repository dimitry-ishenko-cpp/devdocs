<h1>std.path</h1>  <p>This module is used to manipulate path strings. </p>
<p>All functions, with the exception of <a href="#expandTilde"><code>expandTilde</code></a> (and in some cases <a href="#absolutePath"><code>absolutePath</code></a> and <a href="#relativePath"><code>relativePath</code></a>), are pure string manipulation functions; they don't depend on any state outside the program, nor do they perform any actual file system actions. This has the consequence that the module does not make any distinction between a path that points to a directory and a path that points to a file, and it does not know whether or not the object pointed to by the path actually exists in the file system. To differentiate between these cases, use <a href="std_file.html#isDir"><code>std.file.isDir</code></a> and <a href="std_file.html#exists"><code>std.file.exists</code></a>. <br><br> Note that on Windows, both the backslash (<code>\</code>) and the slash (<code>/</code>) are in principle valid directory separators. This module treats them both on equal footing, but in cases where a <i>new</i> separator is added, a backslash will be used. Furthermore, the <a href="#buildNormalizedPath"><code>buildNormalizedPath</code></a> function will replace all slashes with backslashes on that platform. <br><br> In general, the functions in this module assume that the input paths are well-formed. (That is, they should not contain invalid characters, they should follow the file system's path format, etc.) The result of calling a function on an ill-formed path is undefined. When there is a chance that a path or a file name is invalid (for instance, when it has been input by the user), it may sometimes be desirable to use the <a href="#isValidFilename"><code>isValidFilename</code></a> and <a href="#isValidPath"><code>isValidPath</code></a> functions to check this. <br><br> Most functions do not perform any memory allocations, and if a string is returned, it is usually a slice of an input string. If a function allocates, this is explicitly mentioned in the documentation. <br><br>  <table>

<tr>
<th scope="col">Category</th> <th scope="col">Functions</th>
</tr> <tr>
<td>Normalization</td> <td> <a href="#absolutePath"><code>absolutePath</code></a> <a href="#asAbsolutePath"><code>asAbsolutePath</code></a> <a href="#asNormalizedPath"><code>asNormalizedPath</code></a> <a href="#asRelativePath"><code>asRelativePath</code></a> <a href="#buildNormalizedPath"><code>buildNormalizedPath</code></a> <a href="#buildPath"><code>buildPath</code></a> <a href="#chainPath"><code>chainPath</code></a> <a href="#expandTilde"><code>expandTilde</code></a> </td>
</tr> <tr>
<td>Partitioning</td> <td> <a href="#baseName"><code>baseName</code></a> <a href="#dirName"><code>dirName</code></a> <a href="#dirSeparator"><code>dirSeparator</code></a> <a href="#driveName"><code>driveName</code></a> <a href="#pathSeparator"><code>pathSeparator</code></a> <a href="#pathSplitter"><code>pathSplitter</code></a> <a href="#relativePath"><code>relativePath</code></a> <a href="#rootName"><code>rootName</code></a> <a href="#stripDrive"><code>stripDrive</code></a> </td>
</tr> <tr>
<td>Validation</td> <td> <a href="#isAbsolute"><code>isAbsolute</code></a> <a href="#isDirSeparator"><code>isDirSeparator</code></a> <a href="#isRooted"><code>isRooted</code></a> <a href="#isValidFilename"><code>isValidFilename</code></a> <a href="#isValidPath"><code>isValidPath</code></a> </td>
</tr> <tr>
<td>Extension</td> <td> <a href="#defaultExtension"><code>defaultExtension</code></a> <a href="#extension"><code>extension</code></a> <a href="#setExtension"><code>setExtension</code></a> <a href="#stripExtension"><code>stripExtension</code></a> <a href="#withDefaultExtension"><code>withDefaultExtension</code></a> <a href="#withExtension"><code>withExtension</code></a> </td>
</tr> <tr>
<td>Other</td> <td> <a href="#filenameCharCmp"><code>filenameCharCmp</code></a> <a href="#filenameCmp"><code>filenameCmp</code></a> <a href="#globMatch"><code>globMatch</code></a> <a href="#CaseSensitive"><code>CaseSensitive</code></a> </td>
</tr> </table> </p> <dl>
<dt>Authors:</dt>
<dd>Lars Tandle Kyllingstad, <a href="http://digitalmars.com">Walter Bright</a>, Grzegorz Adam Hankiewicz, Thomas KÃ¼hne, <a href="http://erdani.org">Andrei Alexandrescu</a> </dd>
</dl> <dl>
<dt>License:</dt>
<dd>
<a href="http://boost.org/LICENSE_1_0.txt">Boost License 1.0</a> </dd>
</dl> <dl>
<dt>Source</dt>
<dd> <span class="phobos_src"><a class="https" href="https://github.com/dlang/phobos/blob/master/std/path.d">std/path.d</a></span>
</dd>
</dl> <dl>
<dt class="d_decl" id="dirSeparator">enum string <strong id="dirSeparator">dirSeparator</strong>; </dt> <dd>
<p>String used to separate directory names in a path. Under POSIX this is a slash, under Windows a backslash.</p> </dd> <dt class="d_decl" id="pathSeparator">enum string <strong id="pathSeparator">pathSeparator</strong>; </dt> <dd>
<p>Path separator string. A colon under POSIX, a semicolon under Windows.</p> </dd> <dt class="d_decl" id="isDirSeparator">pure nothrow @nogc @safe bool <strong id="isDirSeparator">isDirSeparator</strong>(dchar c); </dt> <dd>
<p>Determines whether the given character is a directory separator. </p>
<p>On Windows, this includes both <code>\</code> and <code>/</code>. On POSIX, it's just <code>/</code>.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">version (Windows)
{
    assert( '/'.isDirSeparator);
    assert( '\\'.isDirSeparator);
}
else
{
    assert( '/'.isDirSeparator);
    assert(!'\\'.isDirSeparator);
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="CaseSensitive">enum <strong id="CaseSensitive">CaseSensitive</strong>: bool; </dt> <dd>
<p>This <code>enum</code> is used as a template argument to functions which compare file names, and determines whether the comparison is case sensitive or not.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(baseName!(CaseSensitive.no)("dir/file.EXT", ".ext")); // "file"
assert(baseName!(CaseSensitive.yes)("dir/file.EXT", ".ext") != "file");

version (Posix)
    writeln(relativePath!(CaseSensitive.no)("/FOO/bar", "/foo/baz")); // "../bar"
else
    writeln(relativePath!(CaseSensitive.no)(`c:\FOO\bar`, `c:\foo\baz`)); // `..\bar`
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="CaseSensitive.no"><strong id="no">no</strong></dt> <dd>
<p>File names are case insensitive</p> </dd> <dt class="d_decl" id="CaseSensitive.yes"><strong id="yes">yes</strong></dt> <dd>
<p>File names are case sensitive</p> </dd> <dt class="d_decl" id="CaseSensitive.osDefault"><strong id="osDefault">osDefault</strong></dt> <dd>
<p>The default (or most common) setting for the current platform. That is, <code>no</code> on Windows and Mac OS X, and <code>yes</code> on all POSIX systems except Darwin (Linux, *BSD, etc.).</p> </dd> </dl> </dd> <dt class="d_decl" id="baseName">auto <strong id="baseName">baseName</strong>(R)(R path)<br><small>  Constraints: if (isRandomAccessRange!R &amp;&amp; hasSlicing!R &amp;&amp; isSomeChar!(ElementType!R) &amp;&amp; !isSomeString!R); </small><br><br>auto <strong id="baseName">baseName</strong>(C)(C[] path)<br><small>  Constraints: if (isSomeChar!C); </small><br><br>pure @safe inout(C)[] <strong id="baseName">baseName</strong>(CaseSensitive cs = CaseSensitive.osDefault, C, C1)(inout(C)[] path, in C1[] suffix)<br><small>  Constraints: if (isSomeChar!C &amp;&amp; isSomeChar!C1); </small>
</dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>cs</td> <td>Whether or not suffix matching is case-sensitive.</td>
</tr> <tr>
<td>R <code>path</code>
</td> <td>A path name. It can be a string, or any random-access range of characters.</td>
</tr> <tr>
<td>C1[] <code>suffix</code>
</td> <td>An optional suffix to be removed from the file name.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The name of the file in the path name, without any leading directory and with an optional suffix chopped off.  If <code>suffix</code> is specified, it will be compared to <code>path</code> using <code>filenameCmp!cs</code>, where <code>cs</code> is an optional template parameter determining whether the comparison is case sensitive or not. See the <a href="#filenameCmp"><code>filenameCmp</code></a> documentation for details. </dd>
</dl> <dl>
<dt>Note</dt>
<dd> This function <i>only</i> strips away the specified suffix, which doesn't necessarily have to represent an extension. To remove the extension from a path, regardless of what the extension is, use <a href="#stripExtension"><code>stripExtension</code></a>. To obtain the filename without leading directories and without an extension, combine the functions like this: </dd>
</dl>
<pre data-language="d">assert(baseName(stripExtension("dir/file.ext")) == "file");
</pre>  <dl>
<dt>Standards:</dt>
<dd>This function complies with <a href="http://pubs.opengroup.org/onlinepubs/9699919799/utilities/basename.html"> the POSIX requirements for the 'basename' shell utility</a> (with suitable adaptations for Windows paths).</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(baseName("dir/file.ext")); // "file.ext"
writeln(baseName("dir/file.ext", ".ext")); // "file"
writeln(baseName("dir/file.ext", ".xyz")); // "file.ext"
writeln(baseName("dir/filename", "name")); // "file"
writeln(baseName("dir/subdir/")); // "subdir"

version (Windows)
{
    writeln(baseName(`d:file.ext`)); // "file.ext"
    writeln(baseName(`d:\dir\file.ext`)); // "file.ext"
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="dirName">auto <strong id="dirName">dirName</strong>(R)(R path)<br><small>  Constraints: if (isRandomAccessRange!R &amp;&amp; hasSlicing!R &amp;&amp; hasLength!R &amp;&amp; isSomeChar!(ElementType!R) &amp;&amp; !isSomeString!R); </small><br><br>auto <strong id="dirName">dirName</strong>(C)(C[] path)<br><small>  Constraints: if (isSomeChar!C); </small>
</dt> <dd>
<p>Returns the parent directory of <code>path</code>. On Windows, this includes the drive letter if present. If <code>path</code> is a relative path and the parent directory is the current working directory, returns <code>"."</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>path</code>
</td> <td>A path name.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A slice of <code>path</code> or <code>"."</code>. </dd>
</dl> <dl>
<dt>Standards:</dt>
<dd>This function complies with <a href="http://pubs.opengroup.org/onlinepubs/9699919799/utilities/dirname.html"> the POSIX requirements for the 'dirname' shell utility</a> (with suitable adaptations for Windows paths).</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(dirName("")); // "."
writeln(dirName("file"w)); // "."
writeln(dirName("dir/"d)); // "."
writeln(dirName("dir///")); // "."
writeln(dirName("dir/file"w.dup)); // "dir"
writeln(dirName("dir///file"d.dup)); // "dir"
writeln(dirName("dir/subdir/")); // "dir"
writeln(dirName("/dir/file"w)); // "/dir"
writeln(dirName("/file"d)); // "/"
writeln(dirName("/")); // "/"
writeln(dirName("///")); // "/"

version (Windows)
{
    writeln(dirName(`dir\`)); // `.`
    writeln(dirName(`dir\\\`)); // `.`
    writeln(dirName(`dir\file`)); // `dir`
    writeln(dirName(`dir\\\file`)); // `dir`
    writeln(dirName(`dir\subdir\`)); // `dir`
    writeln(dirName(`\dir\file`)); // `\dir`
    writeln(dirName(`\file`)); // `\`
    writeln(dirName(`\`)); // `\`
    writeln(dirName(`\\\`)); // `\`
    writeln(dirName(`d:`)); // `d:`
    writeln(dirName(`d:file`)); // `d:`
    writeln(dirName(`d:\`)); // `d:\`
    writeln(dirName(`d:\file`)); // `d:\`
    writeln(dirName(`d:\dir\file`)); // `d:\dir`
    writeln(dirName(`\\server\share\dir\file`)); // `\\server\share\dir`
    writeln(dirName(`\\server\share\file`)); // `\\server\share`
    writeln(dirName(`\\server\share\`)); // `\\server\share`
    writeln(dirName(`\\server\share`)); // `\\server\share`
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="rootName">auto <strong id="rootName">rootName</strong>(R)(R path)<br><small>  Constraints: if (isRandomAccessRange!R &amp;&amp; hasSlicing!R &amp;&amp; hasLength!R &amp;&amp; isSomeChar!(ElementType!R) &amp;&amp; !isSomeString!R); </small><br><br>auto <strong id="rootName">rootName</strong>(C)(C[] path)<br><small>  Constraints: if (isSomeChar!C); </small>
</dt> <dd>
<p>Returns the root directory of the specified path, or <code>null</code> if the path is not rooted. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>path</code>
</td> <td>A path name.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A slice of <code>path</code>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(rootName("") is null);
assert(rootName("foo") is null);
writeln(rootName("/")); // "/"
writeln(rootName("/foo/bar")); // "/"

version (Windows)
{
    assert(rootName("d:foo") is null);
    writeln(rootName(`d:\foo`)); // `d:\`
    writeln(rootName(`\\server\share\foo`)); // `\\server\share`
    writeln(rootName(`\\server\share`)); // `\\server\share`
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="driveName">auto <strong id="driveName">driveName</strong>(R)(R path)<br><small>  Constraints: if (isRandomAccessRange!R &amp;&amp; hasSlicing!R &amp;&amp; hasLength!R &amp;&amp; isSomeChar!(ElementType!R) &amp;&amp; !isSomeString!R); </small><br><br>auto <strong id="driveName">driveName</strong>(C)(C[] path)<br><small>  Constraints: if (isSomeChar!C); </small>
</dt> <dd>
<p>Get the drive portion of a path. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>path</code>
</td> <td>string or range of characters</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A slice of <code>path</code> that is the drive, or an empty range if the drive is not specified. In the case of UNC paths, the network share is returned.  Always returns an empty range on POSIX.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.range : empty;
version (Posix)  assert(driveName("c:/foo").empty);
version (Windows)
{
    assert(driveName(`dir\file`).empty);
    writeln(driveName(`d:file`)); // "d:"
    writeln(driveName(`d:\file`)); // "d:"
    writeln(driveName("d:")); // "d:"
    writeln(driveName(`\\server\share\file`)); // `\\server\share`
    writeln(driveName(`\\server\share\`)); // `\\server\share`
    writeln(driveName(`\\server\share`)); // `\\server\share`

    static assert(driveName(`d:\file`) == "d:");
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="stripDrive">auto <strong id="stripDrive">stripDrive</strong>(R)(R path)<br><small>  Constraints: if (isRandomAccessRange!R &amp;&amp; hasSlicing!R &amp;&amp; isSomeChar!(ElementType!R) &amp;&amp; !isSomeString!R); </small><br><br>auto <strong id="stripDrive">stripDrive</strong>(C)(C[] path)<br><small>  Constraints: if (isSomeChar!C); </small>
</dt> <dd>
<p>Strips the drive from a Windows path. On POSIX, the path is returned unaltered. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>path</code>
</td> <td>A pathname</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A slice of path without the drive component.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">version (Windows)
{
    writeln(stripDrive(`d:\dir\file`)); // `\dir\file`
    writeln(stripDrive(`\\server\share\dir\file`)); // `\dir\file`
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="extension">auto <strong id="extension">extension</strong>(R)(R path)<br><small>  Constraints: if (isRandomAccessRange!R &amp;&amp; hasSlicing!R &amp;&amp; isSomeChar!(ElementType!R) || is(StringTypeOf!R)); </small>
</dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>path</code>
</td> <td>A path name.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The extension part of a file name, including the dot.  If there is no extension, <code>null</code> is returned.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.range : empty;
assert(extension("file").empty);
writeln(extension("file.")); // "."
writeln(extension("file.ext"w)); // ".ext"
writeln(extension("file.ext1.ext2"d)); // ".ext2"
assert(extension(".foo".dup).empty);
writeln(extension(".foo.ext"w.dup)); // ".ext"

static assert(extension("file").empty);
static assert(extension("file.ext") == ".ext");
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="stripExtension">auto <strong id="stripExtension">stripExtension</strong>(R)(R path)<br><small>  Constraints: if (isRandomAccessRange!R &amp;&amp; hasSlicing!R &amp;&amp; hasLength!R &amp;&amp; isSomeChar!(ElementType!R) &amp;&amp; !isSomeString!R); </small><br><br>auto <strong id="stripExtension">stripExtension</strong>(C)(C[] path)<br><small>  Constraints: if (isSomeChar!C); </small>
</dt> <dd>
<p>Remove extension from path. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>path</code>
</td> <td>string or range to be sliced</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>slice of path with the extension (if any) stripped off</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(stripExtension("file")); // "file"
writeln(stripExtension("file.ext")); // "file"
writeln(stripExtension("file.ext1.ext2")); // "file.ext1"
writeln(stripExtension("file.")); // "file"
writeln(stripExtension(".file")); // ".file"
writeln(stripExtension(".file.ext")); // ".file"
writeln(stripExtension("dir/file.ext")); // "dir/file"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="setExtension">immutable(C1)[] <strong id="setExtension">setExtension</strong>(C1, C2)(in C1[] path, in C2[] ext)<br><small>  Constraints: if (isSomeChar!C1 &amp;&amp; !is(C1 == immutable) &amp;&amp; is(immutable(C1) == immutable(C2))); </small><br><br>immutable(C1)[] <strong id="setExtension">setExtension</strong>(C1, C2)(immutable(C1)[] path, const(C2)[] ext)<br><small>  Constraints: if (isSomeChar!C1 &amp;&amp; is(immutable(C1) == immutable(C2))); </small>
</dt> <dd>
<p>Sets or replaces an extension. </p>
<p>If the filename already has an extension, it is replaced. If not, the extension is simply appended to the filename. Including a leading dot in <code>ext</code> is optional. <br><br> If the extension is empty, this function is equivalent to <a href="#stripExtension"><code>stripExtension</code></a>. <br><br> This function normally allocates a new string (the possible exception being the case when path is immutable and doesn't already have an extension). </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>C1[] <code>path</code>
</td> <td>A path name</td>
</tr> <tr>
<td>C2[] <code>ext</code>
</td> <td>The new extension</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A string containing the path given by <code>path</code>, but where the extension has been set to <code>ext</code>. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="#withExtension"><code>withExtension</code></a> which does not allocate and returns a lazy range.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(setExtension("file", "ext")); // "file.ext"
writeln(setExtension("file"w, ".ext"w)); // "file.ext"
writeln(setExtension("file."d, "ext"d)); // "file.ext"
writeln(setExtension("file.", ".ext")); // "file.ext"
writeln(setExtension("file.old"w, "new"w)); // "file.new"
writeln(setExtension("file.old"d, ".new"d)); // "file.new"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="withExtension">auto <strong id="withExtension">withExtension</strong>(R, C)(R path, C[] ext)<br><small>  Constraints: if (isRandomAccessRange!R &amp;&amp; hasSlicing!R &amp;&amp; hasLength!R &amp;&amp; isSomeChar!(ElementType!R) &amp;&amp; !isSomeString!R &amp;&amp; isSomeChar!C); </small><br><br>auto <strong id="withExtension">withExtension</strong>(C1, C2)(C1[] path, C2[] ext)<br><small>  Constraints: if (isSomeChar!C1 &amp;&amp; isSomeChar!C2); </small>
</dt> <dd>
<p>Replace existing extension on filespec with new one. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>path</code>
</td> <td>string or random access range representing a filespec</td>
</tr> <tr>
<td>C[] <code>ext</code>
</td> <td>the new extension</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>Range with <code>path</code>'s extension (if any) replaced with <code>ext</code>. The element encoding type of the returned range will be the same as <code>path</code>'s. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd><a href="#setExtension"><code>setExtension</code></a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.array;
writeln(withExtension("file", "ext").array); // "file.ext"
writeln(withExtension("file"w, ".ext"w).array); // "file.ext"
writeln(withExtension("file.ext"w, ".").array); // "file."

import std.utf : byChar, byWchar;
writeln(withExtension("file".byChar, "ext").array); // "file.ext"
writeln(withExtension("file"w.byWchar, ".ext"w).array); // "file.ext"w
writeln(withExtension("file.ext"w.byWchar, ".").array); // "file."w
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="defaultExtension">immutable(C1)[] <strong id="defaultExtension">defaultExtension</strong>(C1, C2)(in C1[] path, in C2[] ext)<br><small>  Constraints: if (isSomeChar!C1 &amp;&amp; is(immutable(C1) == immutable(C2))); </small>
</dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>C1[] <code>path</code>
</td> <td>A path name.</td>
</tr> <tr>
<td>C2[] <code>ext</code>
</td> <td>The default extension to use.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The path given by <code>path</code>, with the extension given by <code>ext</code> appended if the path doesn't already have one.  Including the dot in the extension is optional.  This function always allocates a new string, except in the case when path is immutable and already has an extension.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(defaultExtension("file", "ext")); // "file.ext"
writeln(defaultExtension("file", ".ext")); // "file.ext"
writeln(defaultExtension("file.", "ext")); // "file."
writeln(defaultExtension("file.old", "new")); // "file.old"
writeln(defaultExtension("file.old", ".new")); // "file.old"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="withDefaultExtension">auto <strong id="withDefaultExtension">withDefaultExtension</strong>(R, C)(R path, C[] ext)<br><small>  Constraints: if (isRandomAccessRange!R &amp;&amp; hasSlicing!R &amp;&amp; hasLength!R &amp;&amp; isSomeChar!(ElementType!R) &amp;&amp; !isSomeString!R &amp;&amp; isSomeChar!C); </small><br><br>auto <strong id="withDefaultExtension">withDefaultExtension</strong>(C1, C2)(C1[] path, C2[] ext)<br><small>  Constraints: if (isSomeChar!C1 &amp;&amp; isSomeChar!C2); </small>
</dt> <dd>
<p>Set the extension of <code>path</code> to <code>ext</code> if <code>path</code> doesn't have one. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>path</code>
</td> <td>filespec as string or range</td>
</tr> <tr>
<td>C[] <code>ext</code>
</td> <td>extension, may have leading '.'</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>range with the result</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.array;
writeln(withDefaultExtension("file", "ext").array); // "file.ext"
writeln(withDefaultExtension("file"w, ".ext").array); // "file.ext"w
writeln(withDefaultExtension("file.", "ext").array); // "file."
writeln(withDefaultExtension("file", "").array); // "file."

import std.utf : byChar, byWchar;
writeln(withDefaultExtension("file".byChar, "ext").array); // "file.ext"
writeln(withDefaultExtension("file"w.byWchar, ".ext").array); // "file.ext"w
writeln(withDefaultExtension("file.".byChar, "ext"d).array); // "file."
writeln(withDefaultExtension("file".byChar, "").array); // "file."
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="buildPath">immutable(ElementEncodingType!(ElementType!Range))[] <strong id="buildPath">buildPath</strong>(Range)(Range segments)<br><small>  Constraints: if (isInputRange!Range &amp;&amp; !isInfinite!Range &amp;&amp; isSomeString!(ElementType!Range)); </small><br><br>pure nothrow @safe immutable(C)[] <strong id="buildPath">buildPath</strong>(C)(const(C)[][] paths...)<br><small>  Constraints: if (isSomeChar!C); </small>
</dt> <dd>
<p>Combines one or more path segments. </p>
<p>This function takes a set of path segments, given as an input range of string elements or as a set of string arguments, and concatenates them with each other. Directory separators are inserted between segments if necessary. If any of the path segments are absolute (as defined by <a href="#isAbsolute"><code>isAbsolute</code></a>), the preceding segments will be dropped. <br><br> On Windows, if one of the path segments are rooted, but not absolute (e.g. <code>\foo</code>), all preceding path segments down to the previous root will be dropped. (See below for an example.) <br><br> This function always allocates memory to hold the resulting path. The variadic overload is guaranteed to only perform a single allocation, as is the range version if <code>paths</code> is a forward range. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>segments</code>
</td> <td>An <a href="std_range_primitives.html#isInputRange">input range</a> of segments to assemble the path from.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The assembled path.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">version (Posix)
{
    writeln(buildPath("foo", "bar", "baz")); // "foo/bar/baz"
    writeln(buildPath("/foo/", "bar/baz")); // "/foo/bar/baz"
    writeln(buildPath("/foo", "/bar")); // "/bar"
}

version (Windows)
{
    writeln(buildPath("foo", "bar", "baz")); // `foo\bar\baz`
    writeln(buildPath(`c:\foo`, `bar\baz`)); // `c:\foo\bar\baz`
    writeln(buildPath("foo", `d:\bar`)); // `d:\bar`
    writeln(buildPath("foo", `\bar`)); // `\bar`
    writeln(buildPath(`c:\foo`, `\bar`)); // `c:\bar`
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="chainPath">auto <strong id="chainPath">chainPath</strong>(R1, R2, Ranges...)(R1 r1, R2 r2, Ranges ranges)<br><small>  Constraints: if ((isRandomAccessRange!R1 &amp;&amp; hasSlicing!R1 &amp;&amp; hasLength!R1 &amp;&amp; isSomeChar!(ElementType!R1) || isNarrowString!R1 &amp;&amp; !isConvertibleToString!R1) &amp;&amp; (isRandomAccessRange!R2 &amp;&amp; hasSlicing!R2 &amp;&amp; hasLength!R2 &amp;&amp; isSomeChar!(ElementType!R2) || isNarrowString!R2 &amp;&amp; !isConvertibleToString!R2) &amp;&amp; (Ranges.length == 0 || is(typeof(chainPath(r2, ranges))))); </small>
</dt> <dd>
<p>Concatenate path segments together to form one path. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R1 <code>r1</code>
</td> <td>first segment</td>
</tr> <tr>
<td>R2 <code>r2</code>
</td> <td>second segment</td>
</tr> <tr>
<td>Ranges <code>ranges</code>
</td> <td>0 or more segments</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>Lazy range which is the concatenation of r1, r2 and ranges with path separators. The resulting element type is that of r1. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd><a href="#buildPath"><code>buildPath</code></a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.array;
version (Posix)
{
    writeln(chainPath("foo", "bar", "baz").array); // "foo/bar/baz"
    writeln(chainPath("/foo/", "bar/baz").array); // "/foo/bar/baz"
    writeln(chainPath("/foo", "/bar").array); // "/bar"
}

version (Windows)
{
    writeln(chainPath("foo", "bar", "baz").array); // `foo\bar\baz`
    writeln(chainPath(`c:\foo`, `bar\baz`).array); // `c:\foo\bar\baz`
    writeln(chainPath("foo", `d:\bar`).array); // `d:\bar`
    writeln(chainPath("foo", `\bar`).array); // `\bar`
    writeln(chainPath(`c:\foo`, `\bar`).array); // `c:\bar`
}

import std.utf : byChar;
version (Posix)
{
    writeln(chainPath("foo", "bar", "baz").array); // "foo/bar/baz"
    writeln(chainPath("/foo/".byChar, "bar/baz").array); // "/foo/bar/baz"
    writeln(chainPath("/foo", "/bar".byChar).array); // "/bar"
}

version (Windows)
{
    writeln(chainPath("foo", "bar", "baz").array); // `foo\bar\baz`
    writeln(chainPath(`c:\foo`.byChar, `bar\baz`).array); // `c:\foo\bar\baz`
    writeln(chainPath("foo", `d:\bar`).array); // `d:\bar`
    writeln(chainPath("foo", `\bar`.byChar).array); // `\bar`
    writeln(chainPath(`c:\foo`, `\bar`w).array); // `c:\bar`
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="buildNormalizedPath">pure nothrow @safe immutable(C)[] <strong id="buildNormalizedPath">buildNormalizedPath</strong>(C)(const(C[])[] paths...)<br><small>  Constraints: if (isSomeChar!C); </small>
</dt> <dd>
<p>Performs the same task as <a href="#buildPath"><code>buildPath</code></a>, while at the same time resolving current/parent directory symbols (<code>"."</code> and <code>".."</code>) and removing superfluous directory separators. It will return "." if the path leads to the starting directory. On Windows, slashes are replaced with backslashes. </p>
<p>Using buildNormalizedPath on null paths will always return null. <br><br> Note that this function does not resolve symbolic links. <br><br> This function always allocates memory to hold the resulting path. Use <a href="#asNormalizedPath"><code>asNormalizedPath</code></a> to not allocate memory. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(C[])[] <code>paths</code>
</td> <td>An array of paths to assemble.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The assembled path.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(buildNormalizedPath("foo", "..")); // "."

version (Posix)
{
    writeln(buildNormalizedPath("/foo/./bar/..//baz/")); // "/foo/baz"
    writeln(buildNormalizedPath("../foo/.")); // "../foo"
    writeln(buildNormalizedPath("/foo", "bar/baz/")); // "/foo/bar/baz"
    writeln(buildNormalizedPath("/foo", "/bar/..", "baz")); // "/baz"
    writeln(buildNormalizedPath("foo/./bar", "../../", "../baz")); // "../baz"
    writeln(buildNormalizedPath("/foo/./bar", "../../baz")); // "/baz"
}

version (Windows)
{
    writeln(buildNormalizedPath(`c:\foo\.\bar/..\\baz\`)); // `c:\foo\baz`
    writeln(buildNormalizedPath(`..\foo\.`)); // `..\foo`
    writeln(buildNormalizedPath(`c:\foo`, `bar\baz\`)); // `c:\foo\bar\baz`
    writeln(buildNormalizedPath(`c:\foo`, `bar/..`)); // `c:\foo`
    assert(buildNormalizedPath(`\\server\share\foo`, `..\bar`) ==
            `\\server\share\bar`);
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="asNormalizedPath">auto <strong id="asNormalizedPath">asNormalizedPath</strong>(R)(R path)<br><small>  Constraints: if (isSomeChar!(ElementEncodingType!R) &amp;&amp; (isRandomAccessRange!R &amp;&amp; hasSlicing!R &amp;&amp; hasLength!R || isNarrowString!R) &amp;&amp; !isConvertibleToString!R); </small>
</dt> <dd>
<p>Normalize a path by resolving current/parent directory symbols (<code>"."</code> and <code>".."</code>) and removing superfluous directory separators. It will return "." if the path leads to the starting directory. On Windows, slashes are replaced with backslashes. </p>
<p>Using asNormalizedPath on empty paths will always return an empty path. <br><br> Does not resolve symbolic links. <br><br> This function always allocates memory to hold the resulting path. Use <a href="#buildNormalizedPath"><code>buildNormalizedPath</code></a> to allocate memory and return a string. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>path</code>
</td> <td>string or random access range representing the path to normalize</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>normalized path as a forward range</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.array;
writeln(asNormalizedPath("foo/..").array); // "."

version (Posix)
{
    writeln(asNormalizedPath("/foo/./bar/..//baz/").array); // "/foo/baz"
    writeln(asNormalizedPath("../foo/.").array); // "../foo"
    writeln(asNormalizedPath("/foo/bar/baz/").array); // "/foo/bar/baz"
    writeln(asNormalizedPath("/foo/./bar/../../baz").array); // "/baz"
}

version (Windows)
{
    writeln(asNormalizedPath(`c:\foo\.\bar/..\\baz\`).array); // `c:\foo\baz`
    writeln(asNormalizedPath(`..\foo\.`).array); // `..\foo`
    writeln(asNormalizedPath(`c:\foo\bar\baz\`).array); // `c:\foo\bar\baz`
    writeln(asNormalizedPath(`c:\foo\bar/..`).array); // `c:\foo`
    assert(asNormalizedPath(`\\server\share\foo\..\bar`).array ==
            `\\server\share\bar`);
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="pathSplitter">auto <strong id="pathSplitter">pathSplitter</strong>(R)(R path)<br><small>  Constraints: if ((isRandomAccessRange!R &amp;&amp; hasSlicing!R || isNarrowString!R) &amp;&amp; !isConvertibleToString!R); </small>
</dt> <dd>
<p>Slice up a path into its elements. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>path</code>
</td> <td>string or slicable random access range</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>bidirectional range of slices of <code>path</code>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.conv : to;

assert(equal(pathSplitter("/"), ["/"]));
assert(equal(pathSplitter("/foo/bar"), ["/", "foo", "bar"]));
assert(equal(pathSplitter("foo/../bar//./"), ["foo", "..", "bar", "."]));

version (Posix)
{
    assert(equal(pathSplitter("//foo/bar"), ["/", "foo", "bar"]));
}

version (Windows)
{
    assert(equal(pathSplitter(`foo\..\bar\/.\`), ["foo", "..", "bar", "."]));
    assert(equal(pathSplitter("c:"), ["c:"]));
    assert(equal(pathSplitter(`c:\foo\bar`), [`c:\`, "foo", "bar"]));
    assert(equal(pathSplitter(`c:foo\bar`), ["c:foo", "bar"]));
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isRooted">bool <strong id="isRooted">isRooted</strong>(R)(R path)<br><small>  Constraints: if (isRandomAccessRange!R &amp;&amp; isSomeChar!(ElementType!R) || is(StringTypeOf!R)); </small>
</dt> <dd>
<p>Determines whether a path starts at a root directory. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>path</code>
</td> <td>A path name.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>Whether a path starts at a root directory.  On POSIX, this function returns true if and only if the path starts with a slash (/).  On Windows, this function returns true if the path starts at the root directory of the current drive, of some other drive, or of a network drive.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">version (Posix)
{
    assert( isRooted("/"));
    assert( isRooted("/foo"));
    assert(!isRooted("foo"));
    assert(!isRooted("../foo"));
}

version (Windows)
{
    assert( isRooted(`\`));
    assert( isRooted(`\foo`));
    assert( isRooted(`d:\foo`));
    assert( isRooted(`\\foo\bar`));
    assert(!isRooted("foo"));
    assert(!isRooted("d:foo"));
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isAbsolute">pure nothrow @safe bool <strong id="isAbsolute">isAbsolute</strong>(R)(R path)<br><small>  Constraints: if (isRandomAccessRange!R &amp;&amp; isSomeChar!(ElementType!R) || is(StringTypeOf!R)); </small>
</dt> <dd>
<p>Determines whether a path is absolute or not. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>path</code>
</td> <td>A path name.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>Whether a path is absolute or not. </dd>
</dl> <dl>
<dt>Example</dt>
<dd> On POSIX, an absolute path starts at the root directory. (In fact, <code>_isAbsolute</code> is just an alias for <a href="#isRooted"><code>isRooted</code></a>.) </dd>
</dl>
<pre data-language="d">version (Posix)
{
    assert(isAbsolute("/"));
    assert(isAbsolute("/foo"));
    assert(!isAbsolute("foo"));
    assert(!isAbsolute("../foo"));
}
</pre>  On Windows, an absolute path starts at the root directory of a specific drive. Hence, it must start with <code>d:\</code> or <code>d:/</code>, where <code>d</code> is the drive letter. Alternatively, it may be a network path, i.e. a path starting with a double (back)slash. <pre data-language="d">version (Windows)
{
    assert(isAbsolute(`d:\`));
    assert(isAbsolute(`d:\foo`));
    assert(isAbsolute(`\\foo\bar`));
    assert(!isAbsolute(`\`));
    assert(!isAbsolute(`\foo`));
    assert(!isAbsolute("d:foo"));
}
</pre>  </dd> <dt class="d_decl" id="absolutePath">pure @safe string <strong id="absolutePath">absolutePath</strong>(string path, lazy string base = getcwd()); </dt> <dd>
<p>Transforms <code>path</code> into an absolute path. </p>
<p>The following algorithm is used: <ol> <li>If <code>path</code> is empty, return <code>null</code>.</li> <li>If <code>path</code> is already absolute, return it.</li> <li>Otherwise, append <code>path</code> to <code>base</code> and return the result. If <code>base</code> is not specified, the current working directory is used.</li> </ol> The function allocates memory if and only if it gets to the third stage of this algorithm. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>string <code>path</code>
</td> <td>the relative path to transform</td>
</tr> <tr>
<td>string <code>base</code>
</td> <td>the base directory of the relative path</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>string of transformed path </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<code>Exception</code> if the specified base directory is not absolute. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="#asAbsolutePath"><code>asAbsolutePath</code></a> which does not allocate</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">version (Posix)
{
    writeln(absolutePath("some/file", "/foo/bar")); // "/foo/bar/some/file"
    writeln(absolutePath("../file", "/foo/bar")); // "/foo/bar/../file"
    writeln(absolutePath("/some/file", "/foo/bar")); // "/some/file"
}

version (Windows)
{
    writeln(absolutePath(`some\file`, `c:\foo\bar`)); // `c:\foo\bar\some\file`
    writeln(absolutePath(`..\file`, `c:\foo\bar`)); // `c:\foo\bar\..\file`
    writeln(absolutePath(`c:\some\file`, `c:\foo\bar`)); // `c:\some\file`
    writeln(absolutePath(`\`, `c:\`)); // `c:\`
    writeln(absolutePath(`\some\file`, `c:\foo\bar`)); // `c:\some\file`
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="asAbsolutePath">auto <strong id="asAbsolutePath">asAbsolutePath</strong>(R)(R path)<br><small>  Constraints: if ((isRandomAccessRange!R &amp;&amp; isSomeChar!(ElementType!R) || isNarrowString!R) &amp;&amp; !isConvertibleToString!R); </small>
</dt> <dd>
<p>Transforms <code>path</code> into an absolute path. </p>
<p>The following algorithm is used: <ol> <li>If <code>path</code> is empty, return <code>null</code>.</li> <li>If <code>path</code> is already absolute, return it.</li> <li>Otherwise, append <code>path</code> to the current working directory, which allocates memory.</li> </ol> </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>path</code>
</td> <td>the relative path to transform</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>the transformed path as a lazy range </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="#absolutePath"><code>absolutePath</code></a> which returns an allocated string</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.array;
writeln(asAbsolutePath(cast(string)null).array); // ""
version (Posix)
{
    writeln(asAbsolutePath("/foo").array); // "/foo"
}
version (Windows)
{
    writeln(asAbsolutePath("c:/foo").array); // "c:/foo"
}
asAbsolutePath("foo");
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="relativePath">string <strong id="relativePath">relativePath</strong>(CaseSensitive cs = CaseSensitive.osDefault)(string path, lazy string base = getcwd()); </dt> <dd>
<p>Translates <code>path</code> into a relative path. </p>
<p>The returned path is relative to <code>base</code>, which is by default taken to be the current working directory. If specified, <code>base</code> must be an absolute path, and it is always assumed to refer to a directory. If <code>path</code> and <code>base</code> refer to the same directory, the function returns <code>.</code>. <br><br> The following algorithm is used: <ol> <li>If <code>path</code> is a relative directory, return it unaltered.</li> <li>Find a common root between <code>path</code> and <code>base</code>. If there is no common root, return <code>path</code> unaltered.</li> <li>Prepare a string with as many <code>../</code> or <code>..\</code> as necessary to reach the common root from base path.</li> <li>Append the remaining segments of <code>path</code> to the string and return.</li> </ol> <br><br> In the second step, path components are compared using <code>filenameCmp!cs</code>, where <code>cs</code> is an optional template parameter determining whether the comparison is case sensitive or not. See the <a href="#filenameCmp"><code>filenameCmp</code></a> documentation for details. <br><br> This function allocates memory. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>cs</td> <td>Whether matching path name components against the base path should be case-sensitive or not.</td>
</tr> <tr>
<td>string <code>path</code>
</td> <td>A path name.</td>
</tr> <tr>
<td>string <code>base</code>
</td> <td>The base path to construct the relative path from.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The relative path. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="#asRelativePath"><code>asRelativePath</code></a> which does not allocate memory </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<code>Exception</code> if the specified base directory is not absolute.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(relativePath("foo")); // "foo"

version (Posix)
{
    writeln(relativePath("foo", "/bar")); // "foo"
    writeln(relativePath("/foo/bar", "/foo/bar")); // "."
    writeln(relativePath("/foo/bar", "/foo/baz")); // "../bar"
    writeln(relativePath("/foo/bar/baz", "/foo/woo/wee")); // "../../bar/baz"
    writeln(relativePath("/foo/bar/baz", "/foo/bar")); // "baz"
}
version (Windows)
{
    writeln(relativePath("foo", `c:\bar`)); // "foo"
    writeln(relativePath(`c:\foo\bar`, `c:\foo\bar`)); // "."
    writeln(relativePath(`c:\foo\bar`, `c:\foo\baz`)); // `..\bar`
    writeln(relativePath(`c:\foo\bar\baz`, `c:\foo\woo\wee`)); // `..\..\bar\baz`
    writeln(relativePath(`c:\foo\bar\baz`, `c:\foo\bar`)); // "baz"
    writeln(relativePath(`c:\foo\bar`, `d:\foo`)); // `c:\foo\bar`
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="asRelativePath">auto <strong id="asRelativePath">asRelativePath</strong>(CaseSensitive cs = CaseSensitive.osDefault, R1, R2)(R1 path, R2 base)<br><small>  Constraints: if ((isNarrowString!R1 || isRandomAccessRange!R1 &amp;&amp; hasSlicing!R1 &amp;&amp; isSomeChar!(ElementType!R1) &amp;&amp; !isConvertibleToString!R1) &amp;&amp; (isNarrowString!R2 || isRandomAccessRange!R2 &amp;&amp; hasSlicing!R2 &amp;&amp; isSomeChar!(ElementType!R2) &amp;&amp; !isConvertibleToString!R2)); </small>
</dt> <dd>
<p>Transforms <code>path</code> into a path relative to <code>base</code>. </p>
<p>The returned path is relative to <code>base</code>, which is usually the current working directory. <code>base</code> must be an absolute path, and it is always assumed to refer to a directory. If <code>path</code> and <code>base</code> refer to the same directory, the function returns <code>'.'</code>. <br><br> The following algorithm is used: <ol> <li>If <code>path</code> is a relative directory, return it unaltered.</li> <li>Find a common root between <code>path</code> and <code>base</code>. If there is no common root, return <code>path</code> unaltered.</li> <li>Prepare a string with as many <code>../</code> or <code>..\</code> as necessary to reach the common root from base path.</li> <li>Append the remaining segments of <code>path</code> to the string and return.</li> </ol> <br><br> In the second step, path components are compared using <code>filenameCmp!cs</code>, where <code>cs</code> is an optional template parameter determining whether the comparison is case sensitive or not. See the <a href="#filenameCmp"><code>filenameCmp</code></a> documentation for details. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R1 <code>path</code>
</td> <td>path to transform</td>
</tr> <tr>
<td>R2 <code>base</code>
</td> <td>absolute path</td>
</tr> <tr>
<td>cs</td> <td>whether filespec comparisons are sensitive or not; defaults to <code>CaseSensitive.osDefault</code>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>a random access range of the transformed path </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd><a href="#relativePath"><code>relativePath</code></a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.array;
version (Posix)
{
    writeln(asRelativePath("foo", "/bar").array); // "foo"
    writeln(asRelativePath("/foo/bar", "/foo/bar").array); // "."
    writeln(asRelativePath("/foo/bar", "/foo/baz").array); // "../bar"
    writeln(asRelativePath("/foo/bar/baz", "/foo/woo/wee").array); // "../../bar/baz"
    writeln(asRelativePath("/foo/bar/baz", "/foo/bar").array); // "baz"
}
else version (Windows)
{
    writeln(asRelativePath("foo", `c:\bar`).array); // "foo"
    writeln(asRelativePath(`c:\foo\bar`, `c:\foo\bar`).array); // "."
    writeln(asRelativePath(`c:\foo\bar`, `c:\foo\baz`).array); // `..\bar`
    writeln(asRelativePath(`c:\foo\bar\baz`, `c:\foo\woo\wee`).array); // `..\..\bar\baz`
    writeln(asRelativePath(`c:/foo/bar/baz`, `c:\foo\woo\wee`).array); // `..\..\bar\baz`
    writeln(asRelativePath(`c:\foo\bar\baz`, `c:\foo\bar`).array); // "baz"
    writeln(asRelativePath(`c:\foo\bar`, `d:\foo`).array); // `c:\foo\bar`
    writeln(asRelativePath(`\\foo\bar`, `c:\foo`).array); // `\\foo\bar`
}
else
    static assert(0);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="filenameCharCmp">pure nothrow @safe int <strong id="filenameCharCmp">filenameCharCmp</strong>(CaseSensitive cs = CaseSensitive.osDefault)(dchar a, dchar b); </dt> <dd>
<p>Compares filename characters. </p>
<p>This function can perform a case-sensitive or a case-insensitive comparison. This is controlled through the <code>cs</code> template parameter which, if not specified, is given by <a href="#CaseSensitive"><code>CaseSensitive</code></a><code>.osDefault</code>. <br><br> On Windows, the backslash and slash characters (<code>\</code> and <code>/</code>) are considered equal. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>cs</td> <td>Case-sensitivity of the comparison.</td>
</tr> <tr>
<td>dchar <code>a</code>
</td> <td>A filename character.</td>
</tr> <tr>
<td>dchar <code>b</code>
</td> <td>A filename character.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>&lt; 0</code> if <code>a &lt; b</code>, <code>0</code> if <code>a == b</code>, and <code>&gt; 0</code> if <code>a &gt; b</code>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(filenameCharCmp('a', 'a')); // 0
assert(filenameCharCmp('a', 'b') &lt; 0);
assert(filenameCharCmp('b', 'a') &gt; 0);

version (linux)
{
    // Same as calling filenameCharCmp!(CaseSensitive.yes)(a, b)
    assert(filenameCharCmp('A', 'a') &lt; 0);
    assert(filenameCharCmp('a', 'A') &gt; 0);
}
version (Windows)
{
    // Same as calling filenameCharCmp!(CaseSensitive.no)(a, b)
    writeln(filenameCharCmp('a', 'A')); // 0
    assert(filenameCharCmp('a', 'B') &lt; 0);
    assert(filenameCharCmp('A', 'b') &lt; 0);
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="filenameCmp">int <strong id="filenameCmp">filenameCmp</strong>(CaseSensitive cs = CaseSensitive.osDefault, Range1, Range2)(Range1 filename1, Range2 filename2)<br><small>  Constraints: if (isInputRange!Range1 &amp;&amp; !isInfinite!Range1 &amp;&amp; isSomeChar!(ElementEncodingType!Range1) &amp;&amp; !isConvertibleToString!Range1 &amp;&amp; isInputRange!Range2 &amp;&amp; !isInfinite!Range2 &amp;&amp; isSomeChar!(ElementEncodingType!Range2) &amp;&amp; !isConvertibleToString!Range2); </small>
</dt> <dd>
<p>Compares file names and returns </p>
<p>Individual characters are compared using <code>filenameCharCmp!cs</code>, where <code>cs</code> is an optional template parameter determining whether the comparison is case sensitive or not. <br><br> Treatment of invalid UTF encodings is implementation defined. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>cs</td> <td>case sensitivity</td>
</tr> <tr>
<td>Range1 <code>filename1</code>
</td> <td>range for first file name</td>
</tr> <tr>
<td>Range2 <code>filename2</code>
</td> <td>range for second file name</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>&lt; 0</code> if <code>filename1 &lt; filename2</code>, <code>0</code> if <code>filename1 == filename2</code> and <code>&gt; 0</code> if <code>filename1 &gt; filename2</code>. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd><a href="#filenameCharCmp"><code>filenameCharCmp</code></a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(filenameCmp("abc", "abc")); // 0
assert(filenameCmp("abc", "abd") &lt; 0);
assert(filenameCmp("abc", "abb") &gt; 0);
assert(filenameCmp("abc", "abcd") &lt; 0);
assert(filenameCmp("abcd", "abc") &gt; 0);

version (linux)
{
    // Same as calling filenameCmp!(CaseSensitive.yes)(filename1, filename2)
    assert(filenameCmp("Abc", "abc") &lt; 0);
    assert(filenameCmp("abc", "Abc") &gt; 0);
}
version (Windows)
{
    // Same as calling filenameCmp!(CaseSensitive.no)(filename1, filename2)
    writeln(filenameCmp("Abc", "abc")); // 0
    writeln(filenameCmp("abc", "Abc")); // 0
    assert(filenameCmp("Abc", "abD") &lt; 0);
    assert(filenameCmp("abc", "AbB") &gt; 0);
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="globMatch">pure nothrow @safe bool <strong id="globMatch">globMatch</strong>(CaseSensitive cs = CaseSensitive.osDefault, C, Range)(Range path, const(C)[] pattern)<br><small>  Constraints: if (isForwardRange!Range &amp;&amp; !isInfinite!Range &amp;&amp; isSomeChar!(ElementEncodingType!Range) &amp;&amp; !isConvertibleToString!Range &amp;&amp; isSomeChar!C &amp;&amp; is(immutable(C) == immutable(ElementEncodingType!Range))); </small>
</dt> <dd>
<p>Matches a pattern against a path. </p>
<p>Some characters of pattern have a special meaning (they are <i>meta-characters</i>) and can't be escaped. These are: <br><br> <table>
 <tr>
<td><code>*</code></td> <td>Matches 0 or more instances of any character.</td>
</tr> <tr>
<td><code>?</code></td> <td>Matches exactly one instance of any character.</td>
</tr> <tr>
<td>
<code>[</code><i>chars</i><code>]</code>
</td> <td>Matches one instance of any character that appears between the brackets.</td>
</tr> <tr>
<td>
<code>[!</code><i>chars</i><code>]</code>
</td> <td>Matches one instance of any character that does not appear between the brackets after the exclamation mark.</td>
</tr> <tr>
<td>
<code>{</code><i>string1</i><code>,</code><i>string2</i><code>,</code>â¦<code>}</code>
</td> <td>Matches either of the specified strings.</td>
</tr> </table> <br><br> Individual characters are compared using <code>filenameCharCmp!cs</code>, where <code>cs</code> is an optional template parameter determining whether the comparison is case sensitive or not. See the <a href="#filenameCharCmp"><code>filenameCharCmp</code></a> documentation for details. <br><br> Note that directory separators and dots don't stop a meta-character from matching further portions of the path. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>cs</td> <td>Whether the matching should be case-sensitive</td>
</tr> <tr>
<td>Range <code>path</code>
</td> <td>The path to be matched against</td>
</tr> <tr>
<td>const(C)[] <code>pattern</code>
</td> <td>The glob pattern</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if pattern matches path, <code>false</code> otherwise. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd><a href="http://en.wikipedia.org/wiki/Glob_%28programming%29">Wikipedia: glob (programming)</a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(globMatch("foo.bar", "*"));
assert(globMatch("foo.bar", "*.*"));
assert(globMatch(`foo/foo\bar`, "f*b*r"));
assert(globMatch("foo.bar", "f???bar"));
assert(globMatch("foo.bar", "[fg]???bar"));
assert(globMatch("foo.bar", "[!gh]*bar"));
assert(globMatch("bar.fooz", "bar.{foo,bif}z"));
assert(globMatch("bar.bifz", "bar.{foo,bif}z"));

version (Windows)
{
    // Same as calling globMatch!(CaseSensitive.no)(path, pattern)
    assert(globMatch("foo", "Foo"));
    assert(globMatch("Goo.bar", "[fg]???bar"));
}
version (linux)
{
    // Same as calling globMatch!(CaseSensitive.yes)(path, pattern)
    assert(!globMatch("foo", "Foo"));
    assert(!globMatch("Goo.bar", "[fg]???bar"));
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isValidFilename">bool <strong id="isValidFilename">isValidFilename</strong>(Range)(Range filename)<br><small>  Constraints: if ((isRandomAccessRange!Range &amp;&amp; hasLength!Range &amp;&amp; hasSlicing!Range &amp;&amp; isSomeChar!(ElementEncodingType!Range) || isNarrowString!Range) &amp;&amp; !isConvertibleToString!Range); </small>
</dt> <dd>
<p>Checks that the given file or directory name is valid. </p>
<p>The maximum length of <code>filename</code> is given by the constant <code>core.stdc.stdio.FILENAME_MAX</code>. (On Windows, this number is defined as the maximum number of UTF-16 code points, and the test will therefore only yield strictly correct results when <code>filename</code> is a string of <code>wchar</code>s.) <br><br> On Windows, the following criteria must be satisfied (<a href="http://msdn.microsoft.com/en-us/library/aa365247(v=vs.85).aspx">source</a>): <ul> <li>
<code>filename</code> must not contain any characters whose integer representation is in the range 0-31.</li> <li>
<code>filename</code> must not contain any of the following <i>reserved characters</i>: <code>&lt;&gt;:"/\|?*</code>
</li> <li>
<code>filename</code> may not end with a space (<code>' '</code>) or a period (<code>'.'</code>).</li> </ul> <br><br> On POSIX, <code>filename</code> may not contain a forward slash (<code>'/'</code>) or the null character (<code>'\0'</code>). </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>filename</code>
</td> <td>string to check</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if and only if <code>filename</code> is not empty, not too long, and does not contain invalid characters.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.utf : byCodeUnit;

assert(isValidFilename("hello.exe".byCodeUnit));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isValidPath">bool <strong id="isValidPath">isValidPath</strong>(Range)(Range path)<br><small>  Constraints: if ((isRandomAccessRange!Range &amp;&amp; hasLength!Range &amp;&amp; hasSlicing!Range &amp;&amp; isSomeChar!(ElementEncodingType!Range) || isNarrowString!Range) &amp;&amp; !isConvertibleToString!Range); </small>
</dt> <dd>
<p>Checks whether <code>path</code> is a valid path. </p>
<p>Generally, this function checks that <code>path</code> is not empty, and that each component of the path either satisfies <a href="#isValidFilename"><code>isValidFilename</code></a> or is equal to <code>"."</code> or <code>".."</code>. <br><br> <b>It does <i>not</i> check whether the path points to an existing file or directory; use <a href="std_file.html#exists"><code>std.file.exists</code></a> for this purpose.</b> <br><br> On Windows, some special rules apply: <ul> <li>If the second character of <code>path</code> is a colon (<code>':'</code>), the first character is interpreted as a drive letter, and must be in the range A-Z (case insensitive).</li> <li>If <code>path</code> is on the form <code>\\<i>server</i>\<i>share</i>\...</code> (UNC path), <a href="#isValidFilename"><code>isValidFilename</code></a> is applied to <i>server</i> and <i>share</i> as well.</li> <li>If <code>path</code> starts with <code>\\?\</code> (long UNC path), the only requirement for the rest of the string is that it does not contain the null character.</li> <li>If <code>path</code> starts with <code>\\.\</code> (Win32 device namespace) this function returns <code>false</code>; such paths are beyond the scope of this module.</li> </ul> </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>path</code>
</td> <td>string or Range of characters to check</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>true if <code>path</code> is a valid path.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(isValidPath("/foo/bar"));
assert(!isValidPath("/foo\0/bar"));
assert(isValidPath("/"));
assert(isValidPath("a"));

version (Windows)
{
    assert(isValidPath(`c:\`));
    assert(isValidPath(`c:\foo`));
    assert(isValidPath(`c:\foo\.\bar\\\..\`));
    assert(!isValidPath(`!:\foo`));
    assert(!isValidPath(`c::\foo`));
    assert(!isValidPath(`c:\foo?`));
    assert(!isValidPath(`c:\foo.`));

    assert(isValidPath(`\\server\share`));
    assert(isValidPath(`\\server\share\foo`));
    assert(isValidPath(`\\server\share\\foo`));
    assert(!isValidPath(`\\\server\share\foo`));
    assert(!isValidPath(`\\server\\share\foo`));
    assert(!isValidPath(`\\ser*er\share\foo`));
    assert(!isValidPath(`\\server\sha?e\foo`));
    assert(!isValidPath(`\\server\share\|oo`));

    assert(isValidPath(`\\?\&lt;&gt;:"?*|/\..\.`));
    assert(!isValidPath("\\\\?\\foo\0bar"));

    assert(!isValidPath(`\\.\PhysicalDisk1`));
    assert(!isValidPath(`\\`));
}

import std.utf : byCodeUnit;
assert(isValidPath("/foo/bar".byCodeUnit));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="expandTilde">nothrow @safe string <strong id="expandTilde">expandTilde</strong>(string inputPath); </dt> <dd>
<p>Performs tilde expansion in paths on POSIX systems. On Windows, this function does nothing. </p>
<p>There are two ways of using tilde expansion in a path. One involves using the tilde alone or followed by a path separator. In this case, the tilde will be expanded with the value of the environment variable <code>HOME</code>. The second way is putting a username after the tilde (i.e. <code>~john/Mail</code>). Here, the username will be searched for in the user database (i.e. <code>/etc/passwd</code> on Unix systems) and will expand to whatever path is stored there. The username is considered the string after the tilde ending at the first instance of a path separator. <br><br> Note that using the <code>~user</code> syntax may give different values from just <code>~</code> if the environment variable doesn't match the value stored in the user database. <br><br> When the environment variable version is used, the path won't be modified if the environment variable doesn't exist or it is empty. When the database version is used, the path won't be modified if the user doesn't exist in the database or there is not enough memory to perform the query. <br><br> This function performs several memory allocations. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>string <code>inputPath</code>
</td> <td>The path name to expand.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>inputPath</code> with the tilde expanded, or just <code>inputPath</code> if it could not be expanded. For Windows, <code>expandTilde</code> merely returns its argument <code>inputPath</code>. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">void processFile(string path)
{
    // Allow calling this function with paths such as ~/foo
    auto fullPath = expandTilde(path);
    ...
}
</pre>  <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">version (Posix)
{
    import std.process : environment;

    auto oldHome = environment["HOME"];
    scope(exit) environment["HOME"] = oldHome;

    environment["HOME"] = "dmd/test";
    writeln(expandTilde("~/")); // "dmd/test/"
    writeln(expandTilde("~")); // "dmd/test"
}
</pre> </dd>
</dl> </dd> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1999&ndash;2021 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/std_path.html" class="_attribution-link">https://dlang.org/phobos/std_path.html</a>
  </p>
</div>
