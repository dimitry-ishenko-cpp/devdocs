<h1>std.range.primitives</h1>  <p>This module is a submodule of <a href="std_range.html"><code>std.range</code></a>. </p>
<p>It defines the bidirectional and forward range primitives for arrays: <a href="#empty"><code>empty</code></a>, <a href="#front"><code>front</code></a>, <a href="#back"><code>back</code></a>, <a href="#popFront"><code>popFront</code></a>, <a href="#popBack"><code>popBack</code></a> and <a href="#save"><code>save</code></a>. <br><br> It provides basic range functionality by defining several templates for testing whether a given object is a range, and what kind of range it is: <br><br>  <table>
 <tr>
<td><a href="#isInputRange"><code>isInputRange</code></a></td> <td>Tests if something is an <i>input range</i>, defined to be something from which one can sequentially read data using the primitives <code>front</code>, <code>popFront</code>, and <code>empty</code>. </td>
</tr> <tr>
<td><a href="#isOutputRange"><code>isOutputRange</code></a></td> <td>Tests if something is an <i>output range</i>, defined to be something to which one can sequentially write data using the <a href="#put"><code>put</code></a> primitive. </td>
</tr> <tr>
<td><a href="#isForwardRange"><code>isForwardRange</code></a></td> <td>Tests if something is a <i>forward range</i>, defined to be an input range with the additional capability that one can save one's current position with the <code>save</code> primitive, thus allowing one to iterate over the same range multiple times. </td>
</tr> <tr>
<td><a href="#isBidirectionalRange"><code>isBidirectionalRange</code></a></td> <td>Tests if something is a <i>bidirectional range</i>, that is, a forward range that allows reverse traversal using the primitives <code> back</code> and <code>popBack</code>. </td>
</tr> <tr>
<td><a href="#isRandomAccessRange"><code>isRandomAccessRange</code></a></td> <td>Tests if something is a <i>random access range</i>, which is a bidirectional range that also supports the array subscripting operation via the primitive <code>opIndex</code>. </td>
</tr> </table> <br><br> It also provides number of templates that test for various range capabilities: <br><br> <table>
 <tr>
<td><a href="#hasMobileElements"><code>hasMobileElements</code></a></td> <td>Tests if a given range's elements can be moved around using the primitives <code>moveFront</code>, <code>moveBack</code>, or <code>moveAt</code>. </td>
</tr> <tr>
<td><a href="#ElementType"><code>ElementType</code></a></td> <td>Returns the element type of a given range. </td>
</tr> <tr>
<td><a href="#ElementEncodingType"><code>ElementEncodingType</code></a></td> <td>Returns the encoding element type of a given range. </td>
</tr> <tr>
<td><a href="#hasSwappableElements"><code>hasSwappableElements</code></a></td> <td>Tests if a range is a forward range with swappable elements. </td>
</tr> <tr>
<td><a href="#hasAssignableElements"><code>hasAssignableElements</code></a></td> <td>Tests if a range is a forward range with mutable elements. </td>
</tr> <tr>
<td><a href="#hasLvalueElements"><code>hasLvalueElements</code></a></td> <td>Tests if a range is a forward range with elements that can be passed by reference and have their address taken. </td>
</tr> <tr>
<td><a href="#hasLength"><code>hasLength</code></a></td> <td>Tests if a given range has the <code>length</code> attribute. </td>
</tr> <tr>
<td><a href="#isInfinite"><code>isInfinite</code></a></td> <td>Tests if a given range is an <i>infinite range</i>. </td>
</tr> <tr>
<td><a href="#hasSlicing"><code>hasSlicing</code></a></td> <td>Tests if a given range supports the array slicing operation <code> R[x .. y]</code>. </td>
</tr> </table> <br><br> Finally, it includes some convenience functions for manipulating ranges: <br><br> <table>
 <tr>
<td><a href="#popFrontN"><code>popFrontN</code></a></td> <td>Advances a given range by up to <i>n</i> elements. </td>
</tr> <tr>
<td><a href="#popBackN"><code>popBackN</code></a></td> <td>Advances a given bidirectional range from the right by up to <i>n</i> elements. </td>
</tr> <tr>
<td><a href="#popFrontExactly"><code>popFrontExactly</code></a></td> <td>Advances a given range by up exactly <i>n</i> elements. </td>
</tr> <tr>
<td><a href="#popBackExactly"><code>popBackExactly</code></a></td> <td>Advances a given bidirectional range from the right by exactly <i>n</i> elements. </td>
</tr> <tr>
<td><a href="#moveFront"><code>moveFront</code></a></td> <td>Removes the front element of a range. </td>
</tr> <tr>
<td><a href="#moveBack"><code>moveBack</code></a></td> <td>Removes the back element of a bidirectional range. </td>
</tr> <tr>
<td><a href="#moveAt"><code>moveAt</code></a></td> <td>Removes the <i>i</i>'th element of a random-access range. </td>
</tr> <tr>
<td><a href="#walkLength"><code>walkLength</code></a></td> <td>Computes the length of any range in O(n) time. </td>
</tr> <tr>
<td><a href="#put"><code>put</code></a></td> <td>Outputs element <code>e</code> to a range. </td>
</tr> </table> </p> <dl>
<dt>Source</dt>
<dd> <span class="phobos_src"><a class="https" href="https://github.com/dlang/phobos/blob/master/std/range/primitives.d">std/range/primitives.d</a></span> </dd>
</dl> <dl>
<dt>License:</dt>
<dd>
<a href="http://boost.org/LICENSE_1_0.txt">Boost License 1.0</a>. </dd>
</dl> <dl>
<dt>Authors:</dt>
<dd>
<a href="http://erdani.com">Andrei Alexandrescu</a>, David Simcha, and <a href="http://jmdavisprog.com">Jonathan M Davis</a>. Credit for some of the ideas in building this module goes to <a href="http://fantascienza.net/leonardo/so/">Leonardo Maffi</a>.</dd>
</dl> <dl>
<dt class="d_decl" id="isInputRange">enum bool <strong id="isInputRange">isInputRange</strong>(R); </dt> <dd>
<p>Returns <code>true</code> if <code>R</code> is an input range. An input range must define the primitives <code>empty</code>, <code>popFront</code>, and <code>front</code>. The following code should compile for any input range. </p>
<p><pre data-language="d">R r;              // can define a range object
if (r.empty) {}   // can test for empty
r.popFront();     // can invoke popFront()
auto h = r.front; // can get the front of the range of non-void type
</pre> <br><br> The following are rules of input ranges are assumed to hold true in all Phobos code. These rules are not checkable at compile-time, so not conforming to these rules when writing ranges or range based code will result in undefined behavior. <br><br> <ul> <li>
<code>r.empty</code> returns <code>false</code> if and only if there is more data available in the range.</li> <li>
<code>r.empty</code> evaluated multiple times, without calling <code>r.popFront</code>, or otherwise mutating the range object or the underlying data, yields the same result for every evaluation.</li> <li>
<code>r.front</code> returns the current element in the range. It may return by value or by reference.</li> <li>
<code>r.front</code> can be legally evaluated if and only if evaluating <code>r.empty</code> has, or would have, equaled <code>false</code>.</li> <li>
<code>r.front</code> evaluated multiple times, without calling <code>r.popFront</code>, or otherwise mutating the range object or the underlying data, yields the same result for every evaluation.</li> <li>
<code>r.popFront</code> advances to the next element in the range.</li> <li>
<code>r.popFront</code> can be called if and only if evaluating <code>r.empty</code> has, or would have, equaled <code>false</code>.</li> </ul> <br><br> Also, note that Phobos code assumes that the primitives <code>r.front</code> and <code>r.empty</code> are <span class="bigoh">Ο(<code>1</code>)</span> time complexity wise or "cheap" in terms of running time. <span class="bigoh">Ο()</span> statements in the documentation of range functions are made with this assumption. </p> <dl>
<dt>See Also:</dt>
<dd>The header of <a href="std_range.html"><code>std.range</code></a> for tutorials on ranges. </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R</td> <td>type to be tested</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if R is an input range, <code>false</code> if not</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">struct A {}
struct B
{
    void popFront();
    @property bool empty();
    @property int front();
}
static assert(!isInputRange!A);
static assert( isInputRange!B);
static assert( isInputRange!(int[]));
static assert( isInputRange!(char[]));
static assert(!isInputRange!(char[4]));
static assert( isInputRange!(inout(int)[]));

static struct NotDefaultConstructible
{
    @disable this();
    void popFront();
    @property bool empty();
    @property int front();
}
static assert( isInputRange!NotDefaultConstructible);

static struct NotDefaultConstructibleOrCopyable
{
    @disable this();
    @disable this(this);
    void popFront();
    @property bool empty();
    @property int front();
}
static assert(isInputRange!NotDefaultConstructibleOrCopyable);

static struct Frontless
{
    void popFront();
    @property bool empty();
}
static assert(!isInputRange!Frontless);

static struct VoidFront
{
    void popFront();
    @property bool empty();
    void front();
}
static assert(!isInputRange!VoidFront);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="put">void <strong id="put">put</strong>(R, E)(ref R r, E e); </dt> <dd>
<p>Outputs <code>e</code> to <code>r</code>. The exact effect is dependent upon the two types. Several cases are accepted, as described below. The code snippets are attempted in order, and the first to compile "wins" and gets evaluated. </p>
<p>In this table "doPut" is a method that places <code>e</code> into <code>r</code>, using the correct primitive: <code>r.put(e)</code> if <code>R</code> defines <code>put</code>, <code>r.front = e</code> if <code>r</code> is an input range (followed by <code>r.popFront()</code>), or <code>r(e)</code> otherwise. <br><br> <table>
 <tr> <th scope="col">Code Snippet</th> <th scope="col">Scenario</th> </tr> <tr> <td><code>r.doPut(e);</code></td> <td>
<code>R</code> specifically accepts an <code>E</code>.</td> </tr> <tr> <td><code>r.doPut([ e ]);</code></td> <td>
<code>R</code> specifically accepts an <code>E[]</code>.</td> </tr> <tr> <td><code>r.putChar(e);</code></td> <td>
<code>R</code> accepts some form of string or character. put will transcode the character <code>e</code> accordingly.</td> </tr> <tr> <td><code>for (; !e.empty; e.popFront()) put(r, e.front);</code></td> <td>Copying range <code>E</code> into <code>R</code>.</td> </tr> </table> </p> <dl>
<dt>Tip</dt>
<dd> <code>put</code> should <i>not</i> be used "UFCS-style", e.g. <code>r.put(e)</code>. Doing this may call <code>R.put</code> directly, by-passing any transformation feature provided by <code>Range.put</code>. <code>put(r, e)</code> is prefered.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>When an output range's <code>put</code> method only accepts elements of type <code>T</code>, use the global <code>put</code> to handle outputting a <code>T[]</code> to the range or vice-versa. <pre data-language="d">import std.traits : isSomeChar;

static struct A
{
    string data;

    void put(C)(C c) if (isSomeChar!C)
    {
        data ~= c;
    }
}
static assert(isOutputRange!(A, char));

auto a = A();
put(a, "Hello");
writeln(a.data); // "Hello"
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<code>put</code> treats dynamic arrays as array slices, and will call <code>popFront</code> on the slice after an element has been copied.  Be sure to save the position of the array before calling <code>put</code>. <pre data-language="d">int[] a = [1, 2, 3], b = [10, 20];
auto c = a;
put(a, b);
writeln(c); // [10, 20, 3]
// at this point, a was advanced twice, so it only contains
// its last element while c represents the whole array
writeln(a); // [3]
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>It's also possible to <code>put</code> any width strings or characters into narrow strings -- put does the conversion for you.  Note that putting the same width character as the target buffer type is <code>nothrow</code>, but transcoding can throw a <a href="std_utf.html#UTFException"><code>std.utf.UTFException</code></a>. <pre data-language="d">// the elements must be mutable, so using string or const(char)[]
// won't compile
char[] s1 = new char[13];
auto r1 = s1;
put(r1, "Hello, World!"w);
writeln(s1); // "Hello, World!"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isOutputRange">enum bool <strong id="isOutputRange">isOutputRange</strong>(R, E); </dt> <dd>
<p>Returns <code>true</code> if <code>R</code> is an output range for elements of type <code>E</code>. An output range is defined functionally as a range that supports the operation <code>put(r, e)</code> as defined above. </p>
<dl>
<dt>See Also:</dt>
<dd>The header of <a href="std_range.html"><code>std.range</code></a> for tutorials on ranges.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">void myprint(scope const(char)[] s) { }
static assert(isOutputRange!(typeof(&amp;myprint), char));

static assert( isOutputRange!(char[], char));
static assert( isOutputRange!(dchar[], wchar));
static assert( isOutputRange!(dchar[], dchar));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isForwardRange">enum bool <strong id="isForwardRange">isForwardRange</strong>(R); </dt> <dd>
<p>Returns <code>true</code> if <code>R</code> is a forward range. A forward range is an input range <code>r</code> that can save "checkpoints" by saving <code>r.save</code> to another value of type <code>R</code>. Notable examples of input ranges that are <i>not</i> forward ranges are file/socket ranges; copying such a range will not save the position in the stream, and they most likely reuse an internal buffer as the entire stream does not sit in memory. Subsequently, advancing either the original or the copy will advance the stream, so the copies are not independent. </p>
<p>The following code should compile for any forward range. <br><br> <pre data-language="d">static assert(isInputRange!R);
R r1;
auto s1 = r1.save;
static assert(is(typeof(s1) == R));
</pre> <br><br> Saving a range is not duplicating it; in the example above, <code>r1</code> and <code>r2</code> still refer to the same underlying data. They just navigate that data independently. <br><br> The semantics of a forward range (not checkable during compilation) are the same as for an input range, with the additional requirement that backtracking must be possible by saving a copy of the range object with <code>save</code> and using it later. </p> <dl>
<dt>See Also:</dt>
<dd>The header of <a href="std_range.html"><code>std.range</code></a> for tutorials on ranges.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(!isForwardRange!(int));
static assert( isForwardRange!(int[]));
static assert( isForwardRange!(inout(int)[]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isBidirectionalRange">enum bool <strong id="isBidirectionalRange">isBidirectionalRange</strong>(R); </dt> <dd>
<p>Returns <code>true</code> if <code>R</code> is a bidirectional range. A bidirectional range is a forward range that also offers the primitives <code>back</code> and <code>popBack</code>. The following code should compile for any bidirectional range. </p>
<p>The semantics of a bidirectional range (not checkable during compilation) are assumed to be the following (<code>r</code> is an object of type <code>R</code>): <br><br> <ul><li>
<code>r.back</code> returns (possibly a reference to) the last element in the range. Calling <code>r.back</code> is allowed only if calling <code>r.empty</code> has, or would have, returned <code>false</code>.</li></ul> </p> <dl>
<dt>See Also:</dt>
<dd>The header of <a href="std_range.html"><code>std.range</code></a> for tutorials on ranges.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">alias R = int[];
R r = [0,1];
static assert(isForwardRange!R);           // is forward range
r.popBack();                               // can invoke popBack
auto t = r.back;                           // can get the back of the range
auto w = r.front;
static assert(is(typeof(t) == typeof(w))); // same type for front and back
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isRandomAccessRange">enum bool <strong id="isRandomAccessRange">isRandomAccessRange</strong>(R); </dt> <dd>
<p>Returns <code>true</code> if <code>R</code> is a random-access range. A random-access range is a bidirectional range that also offers the primitive <code>opIndex</code>, OR an infinite forward range that offers <code>opIndex</code>. In either case, the range must either offer <code>length</code> or be infinite. The following code should compile for any random-access range. </p>
<p>The semantics of a random-access range (not checkable during compilation) are assumed to be the following (<code>r</code> is an object of type <code>R</code>): <ul><li>
<code>r.opIndex(n)</code> returns a reference to the <code>n</code>th element in the range.</li></ul> <br><br> Although <code>char[]</code> and <code>wchar[]</code> (as well as their qualified versions including <code>string</code> and <code>wstring</code>) are arrays, <code>isRandomAccessRange</code> yields <code>false</code> for them because they use variable-length encodings (UTF-8 and UTF-16 respectively). These types are bidirectional ranges only. </p> <dl>
<dt>See Also:</dt>
<dd>The header of <a href="std_range.html"><code>std.range</code></a> for tutorials on ranges.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.traits : isAggregateType, isAutodecodableString;

alias R = int[];

// range is finite and bidirectional or infinite and forward.
static assert(isBidirectionalRange!R ||
              isForwardRange!R &amp;&amp; isInfinite!R);

R r = [0,1];
auto e = r[1]; // can index
auto f = r.front;
static assert(is(typeof(e) == typeof(f))); // same type for indexed and front
static assert(!(isAutodecodableString!R &amp;&amp; !isAggregateType!R)); // narrow strings cannot be indexed as ranges
static assert(hasLength!R || isInfinite!R); // must have length or be infinite

// &amp;dollar; must work as it does with arrays if opIndex works with &amp;dollar;
static if (is(typeof(r[$])))
{
    static assert(is(typeof(f) == typeof(r[$])));

    // &amp;dollar; - 1 doesn't make sense with infinite ranges but needs to work
    // with finite ones.
    static if (!isInfinite!R)
        static assert(is(typeof(f) == typeof(r[$ - 1])));
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="hasMobileElements">enum bool <strong id="hasMobileElements">hasMobileElements</strong>(R); </dt> <dd>
<p>Returns <code>true</code> iff <code>R</code> is an input range that supports the <code>moveFront</code> primitive, as well as <code>moveBack</code> and <code>moveAt</code> if it's a bidirectional or random access range. These may be explicitly implemented, or may work via the default behavior of the module level functions <code>moveFront</code> and friends. The following code should compile for any range with mobile elements. </p>
<p><pre data-language="d">alias E = ElementType!R;
R r;
static assert(isInputRange!R);
static assert(is(typeof(moveFront(r)) == E));
static if (isBidirectionalRange!R)
    static assert(is(typeof(moveBack(r)) == E));
static if (isRandomAccessRange!R)
    static assert(is(typeof(moveAt(r, 0)) == E));
</pre> </p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.iteration : map;
import std.range : iota, repeat;

static struct HasPostblit
{
    this(this) {}
}

auto nonMobile = map!"a"(repeat(HasPostblit.init));
static assert(!hasMobileElements!(typeof(nonMobile)));
static assert( hasMobileElements!(int[]));
static assert( hasMobileElements!(inout(int)[]));
static assert( hasMobileElements!(typeof(iota(1000))));

static assert( hasMobileElements!( string));
static assert( hasMobileElements!(dstring));
static assert( hasMobileElements!( char[]));
static assert( hasMobileElements!(dchar[]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="ElementType">template <strong id="ElementType">ElementType</strong>(R)</dt> <dd>
<p>The element type of <code>R</code>. <code>R</code> does not have to be a range. The element type is determined as the type yielded by <code>r.front</code> for an object <code>r</code> of type <code>R</code>. For example, <code>ElementType!(T[])</code> is <code>T</code> if <code>T[]</code> isn't a narrow string; if it is, the element type is <code>dchar</code>. If <code>R</code> doesn't have <code>front</code>, <code>ElementType!R</code> is <code>void</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.range : iota;

// Standard arrays: returns the type of the elements of the array
static assert(is(ElementType!(int[]) == int));

// Accessing .front retrieves the decoded dchar
static assert(is(ElementType!(char[])  == dchar)); // rvalue
static assert(is(ElementType!(dchar[]) == dchar)); // lvalue

// Ditto
static assert(is(ElementType!(string) == dchar));
static assert(is(ElementType!(dstring) == immutable(dchar)));

// For ranges it gets the type of .front.
auto range = iota(0, 10);
static assert(is(ElementType!(typeof(range)) == int));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="ElementEncodingType">template <strong id="ElementEncodingType">ElementEncodingType</strong>(R)</dt> <dd>
<p>The encoding element type of <code>R</code>. For narrow strings (<code>char[]</code>, <code>wchar[]</code> and their qualified variants including <code>string</code> and <code>wstring</code>), <code>ElementEncodingType</code> is the character type of the string. For all other types, <code>ElementEncodingType</code> is the same as <code>ElementType</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.range : iota;
// internally the range stores the encoded type
static assert(is(ElementEncodingType!(char[])  == char));

static assert(is(ElementEncodingType!(wstring) == immutable(wchar)));

static assert(is(ElementEncodingType!(byte[]) == byte));

auto range = iota(0, 10);
static assert(is(ElementEncodingType!(typeof(range)) == int));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="hasSwappableElements">enum bool <strong id="hasSwappableElements">hasSwappableElements</strong>(R); </dt> <dd>
<p>Returns <code>true</code> if <code>R</code> is an input range and has swappable elements. The following code should compile for any range with swappable elements. </p>
<p><pre data-language="d">R r;
static assert(isInputRange!R);
swap(r.front, r.front);
static if (isBidirectionalRange!R) swap(r.back, r.front);
static if (isRandomAccessRange!R) swap(r[0], r.front);
</pre> </p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(!hasSwappableElements!(const int[]));
static assert(!hasSwappableElements!(const(int)[]));
static assert(!hasSwappableElements!(inout(int)[]));
static assert( hasSwappableElements!(int[]));

static assert(!hasSwappableElements!( string));
static assert(!hasSwappableElements!(dstring));
static assert(!hasSwappableElements!( char[]));
static assert( hasSwappableElements!(dchar[]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="hasAssignableElements">enum bool <strong id="hasAssignableElements">hasAssignableElements</strong>(R); </dt> <dd>
<p>Returns <code>true</code> if <code>R</code> is an input range and has mutable elements. The following code should compile for any range with assignable elements. </p>
<p><pre data-language="d">R r;
static assert(isInputRange!R);
r.front = r.front;
static if (isBidirectionalRange!R) r.back = r.front;
static if (isRandomAccessRange!R) r[0] = r.front;
</pre> </p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(!hasAssignableElements!(const int[]));
static assert(!hasAssignableElements!(const(int)[]));
static assert( hasAssignableElements!(int[]));
static assert(!hasAssignableElements!(inout(int)[]));

static assert(!hasAssignableElements!( string));
static assert(!hasAssignableElements!(dstring));
static assert(!hasAssignableElements!( char[]));
static assert( hasAssignableElements!(dchar[]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="hasLvalueElements">enum bool <strong id="hasLvalueElements">hasLvalueElements</strong>(R); </dt> <dd>
<p>Tests whether the range <code>R</code> has lvalue elements. These are defined as elements that can be passed by reference and have their address taken. The following code should compile for any range with lvalue elements. <pre data-language="d">void passByRef(ref ElementType!R stuff);
...
static assert(isInputRange!R);
passByRef(r.front);
static if (isBidirectionalRange!R) passByRef(r.back);
static if (isRandomAccessRange!R) passByRef(r[0]);
</pre> </p> </dd> <dt class="d_decl" id="hasLength">template <strong id="hasLength">hasLength</strong>(R)</dt> <dd>
<p>Yields <code>true</code> if <code>R</code> has a <code>length</code> member that returns a value of <code>size_t</code> type. <code>R</code> does not have to be a range. If <code>R</code> is a range, algorithms in the standard library are only guaranteed to support <code>length</code> with type <code>size_t</code>. </p>
<p>Note that <code>length</code> is an optional primitive as no range must implement it. Some ranges do not store their length explicitly, some cannot compute it without actually exhausting the range (e.g. socket streams), and some other ranges may be infinite. <br><br> Although narrow string types (<code>char[]</code>, <code>wchar[]</code>, and their qualified derivatives) do define a <code>length</code> property, <code>hasLength</code> yields <code>false</code> for them. This is because a narrow string's length does not reflect the number of characters, but instead the number of encoding units, and as such is not useful with range-oriented algorithms. To use strings as random-access ranges with length, use <a href="std_string.html#representation"><code>std.string.representation</code></a> or <a href="std_utf.html#byCodeUnit"><code>std.utf.byCodeUnit</code></a>.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(!hasLength!(char[]));
static assert( hasLength!(int[]));
static assert( hasLength!(inout(int)[]));

struct A { size_t length() { return 0; } }
struct B { @property size_t length() { return 0; } }
static assert( hasLength!(A));
static assert( hasLength!(B));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isInfinite">template <strong id="isInfinite">isInfinite</strong>(R)</dt> <dd>
<p>Returns <code>true</code> if <code>R</code> is an infinite input range. An infinite input range is an input range that has a statically-defined enumerated member called <code>empty</code> that is always <code>false</code>, for example: </p>
<p><pre data-language="d">struct MyInfiniteRange
{
    enum bool empty = false;
    ...
}
</pre> </p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.range : Repeat;
static assert(!isInfinite!(int[]));
static assert( isInfinite!(Repeat!(int)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="hasSlicing">enum bool <strong id="hasSlicing">hasSlicing</strong>(R); </dt> <dd>
<p>Returns <code>true</code> if <code>R</code> offers a slicing operator with integral boundaries that returns a forward range type. </p>
<p>For finite ranges, the result of <code>opSlice</code> must be of the same type as the original range type. If the range defines <code>opDollar</code>, then it must support subtraction. <br><br> For infinite ranges, when <i>not</i> using <code>opDollar</code>, the result of <code>opSlice</code> must be the result of <a href="#take"><code>take</code></a> or <a href="#takeExactly"><code>takeExactly</code></a> on the original range (they both return the same type for infinite ranges). However, when using <code>opDollar</code>, the result of <code>opSlice</code> must be that of the original range type. <br><br> The following expression must be true for <code>hasSlicing</code> to be <code>true</code>: <br><br> <pre data-language="d">    isForwardRange!R
    &amp;&amp; !isNarrowString!R
    &amp;&amp; is(ReturnType!((R r) =&gt; r[1 .. 1].length) == size_t)
    &amp;&amp; (is(typeof(lvalueOf!R[1 .. 1]) == R) || isInfinite!R)
    &amp;&amp; (!is(typeof(lvalueOf!R[0 .. $])) || is(typeof(lvalueOf!R[0 .. $]) == R))
    &amp;&amp; (!is(typeof(lvalueOf!R[0 .. $])) || isInfinite!R
        || is(typeof(lvalueOf!R[0 .. $ - 1]) == R))
    &amp;&amp; is(typeof((ref R r)
    {
        static assert(isForwardRange!(typeof(r[1 .. 2])));
    }));
</pre> </p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.range : takeExactly;
static assert( hasSlicing!(int[]));
static assert( hasSlicing!(const(int)[]));
static assert(!hasSlicing!(const int[]));
static assert( hasSlicing!(inout(int)[]));
static assert(!hasSlicing!(inout int []));
static assert( hasSlicing!(immutable(int)[]));
static assert(!hasSlicing!(immutable int[]));
static assert(!hasSlicing!string);
static assert( hasSlicing!dstring);

enum rangeFuncs = "@property int front();" ~
                  "void popFront();" ~
                  "@property bool empty();" ~
                  "@property auto save() { return this; }" ~
                  "@property size_t length();";

struct A { mixin(rangeFuncs); int opSlice(size_t, size_t); }
struct B { mixin(rangeFuncs); B opSlice(size_t, size_t); }
struct C { mixin(rangeFuncs); @disable this(); C opSlice(size_t, size_t); }
struct D { mixin(rangeFuncs); int[] opSlice(size_t, size_t); }
static assert(!hasSlicing!(A));
static assert( hasSlicing!(B));
static assert( hasSlicing!(C));
static assert(!hasSlicing!(D));

struct InfOnes
{
    enum empty = false;
    void popFront() {}
    @property int front() { return 1; }
    @property InfOnes save() { return this; }
    auto opSlice(size_t i, size_t j) { return takeExactly(this, j - i); }
    auto opSlice(size_t i, Dollar d) { return this; }

    struct Dollar {}
    Dollar opDollar() const { return Dollar.init; }
}

static assert(hasSlicing!InfOnes);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="walkLength">auto <strong id="walkLength">walkLength</strong>(Range)(Range range)<br><small>  Constraints: if (isInputRange!Range &amp;&amp; !isInfinite!Range); </small><br><br>auto <strong id="walkLength">walkLength</strong>(Range)(Range range, const size_t upTo)<br><small>  Constraints: if (isInputRange!Range); </small>
</dt> <dd>
<p>This is a best-effort implementation of <code>length</code> for any kind of range. </p>
<p>If <code>hasLength!Range</code>, simply returns <code>range.length</code> without checking <code>upTo</code> (when specified). <br><br> Otherwise, walks the range through its length and returns the number of elements seen. Performes <span class="bigoh">Ο(<code>n</code>)</span> evaluations of <code>range.empty</code> and <code>range.popFront()</code>, where <code>n</code> is the effective length of <code>range</code>. <br><br> The <code>upTo</code> parameter is useful to "cut the losses" in case the interest is in seeing whether the range has at least some number of elements. If the parameter <code>upTo</code> is specified, stops if <code>upTo</code> steps have been taken and returns <code>upTo</code>. <br><br> Infinite ranges are compatible, provided the parameter <code>upTo</code> is specified, in which case the implementation simply returns upTo.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.range : iota;

writeln(10.iota.walkLength); // 10
// iota has a length function, and therefore the
// doesn't have to be walked, and the upTo
// parameter is ignored
writeln(10.iota.walkLength(5)); // 10
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="popFrontN">size_t <strong id="popFrontN">popFrontN</strong>(Range)(ref Range r, size_t n)<br><small>  Constraints: if (isInputRange!Range); </small><br><br>size_t <strong id="popBackN">popBackN</strong>(Range)(ref Range r, size_t n)<br><small>  Constraints: if (isBidirectionalRange!Range); </small>
</dt> <dd>
<p><code>popFrontN</code> eagerly advances <code>r</code> itself (not a copy) up to <code>n</code> times (by calling <code>r.popFront</code>). <code>popFrontN</code> takes <code>r</code> by <code>ref</code>, so it mutates the original range. Completes in <span class="bigoh">Ο(<code>1</code>)</span> steps for ranges that support slicing and have length. Completes in <span class="bigoh">Ο(<code>n</code>)</span> time for all other ranges. </p>
<p><code>popBackN</code> behaves the same as <code>popFrontN</code> but instead removes elements from the back of the (bidirectional) range instead of the front. </p> <dl>
<dt>Returns:</dt>
<dd>How much <code>r</code> was actually advanced, which may be less than <code>n</code> if <code>r</code> did not have at least <code>n</code> elements. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="std_range.html#drop"><code>std.range.drop</code></a>, <a href="std_range.html#dropBack"><code>std.range.dropBack</code></a>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int[] a = [ 1, 2, 3, 4, 5 ];
a.popFrontN(2);
writeln(a); // [3, 4, 5]
a.popFrontN(7);
writeln(a); // []
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.range : iota;
auto LL = iota(1L, 7L);
auto r = popFrontN(LL, 2);
assert(equal(LL, [3L, 4L, 5L, 6L]));
writeln(r); // 2
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int[] a = [ 1, 2, 3, 4, 5 ];
a.popBackN(2);
writeln(a); // [1, 2, 3]
a.popBackN(7);
writeln(a); // []
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.range : iota;
auto LL = iota(1L, 7L);
auto r = popBackN(LL, 2);
assert(equal(LL, [1L, 2L, 3L, 4L]));
writeln(r); // 2
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="popFrontExactly">void <strong id="popFrontExactly">popFrontExactly</strong>(Range)(ref Range r, size_t n)<br><small>  Constraints: if (isInputRange!Range); </small><br><br>void <strong id="popBackExactly">popBackExactly</strong>(Range)(ref Range r, size_t n)<br><small>  Constraints: if (isBidirectionalRange!Range); </small>
</dt> <dd>
<p>Eagerly advances <code>r</code> itself (not a copy) exactly <code>n</code> times (by calling <code>r.popFront</code>). <code>popFrontExactly</code> takes <code>r</code> by <code>ref</code>, so it mutates the original range. Completes in <span class="bigoh">Ο(<code>1</code>)</span> steps for ranges that support slicing, and have either length or are infinite. Completes in <span class="bigoh">Ο(<code>n</code>)</span> time for all other ranges. </p>
<dl>
<dt>Note</dt>
<dd> Unlike <a href="#popFrontN"><code>popFrontN</code></a>, <code>popFrontExactly</code> will assume that the range holds at least <code>n</code> elements. This makes <code>popFrontExactly</code> faster than <code>popFrontN</code>, but it also means that if <code>range</code> does not contain at least <code>n</code> elements, it will attempt to call <code>popFront</code> on an empty range, which is undefined behavior. So, only use <code>popFrontExactly</code> when it is guaranteed that <code>range</code> holds at least <code>n</code> elements. </dd>
</dl> <code>popBackExactly</code> will behave the same but instead removes elements from the back of the (bidirectional) range instead of the front.  <dl>
<dt>See Also:</dt>
<dd>
<a href="std_range.html#dropExactly"><code>std.range.dropExactly</code></a>, <a href="std_range.html#dropBackExactly"><code>std.range.dropBackExactly</code></a>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.algorithm.iteration : filterBidirectional;

auto a = [1, 2, 3];
a.popFrontExactly(1);
writeln(a); // [2, 3]
a.popBackExactly(1);
writeln(a); // [2]

string s = "日本語";
s.popFrontExactly(1);
writeln(s); // "本語"
s.popBackExactly(1);
writeln(s); // "本"

auto bd = filterBidirectional!"true"([1, 2, 3]);
bd.popFrontExactly(1);
assert(bd.equal([2, 3]));
bd.popBackExactly(1);
assert(bd.equal([2]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="moveFront">ElementType!R <strong id="moveFront">moveFront</strong>(R)(R r); </dt> <dd>
<p>Moves the front of <code>r</code> out and returns it. Leaves <code>r.front</code> in a destroyable state that does not allocate any resources (usually equal to its <code>.init</code> value).</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto a = [ 1, 2, 3 ];
writeln(moveFront(a)); // 1
writeln(a.length); // 3

// define a perfunctory input range
struct InputRange
{
    enum bool empty = false;
    enum int front = 7;
    void popFront() {}
    int moveFront() { return 43; }
}
InputRange r;
// calls r.moveFront
writeln(moveFront(r)); // 43
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="moveBack">ElementType!R <strong id="moveBack">moveBack</strong>(R)(R r); </dt> <dd>
<p>Moves the back of <code>r</code> out and returns it. Leaves <code>r.back</code> in a destroyable state that does not allocate any resources (usually equal to its <code>.init</code> value).</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">struct TestRange
{
    int payload = 5;
    @property bool empty() { return false; }
    @property TestRange save() { return this; }
    @property ref int front() return { return payload; }
    @property ref int back() return { return payload; }
    void popFront() { }
    void popBack() { }
}
static assert(isBidirectionalRange!TestRange);
TestRange r;
auto x = moveBack(r);
writeln(x); // 5
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="moveAt">ElementType!R <strong id="moveAt">moveAt</strong>(R)(R r, size_t i); </dt> <dd>
<p>Moves element at index <code>i</code> of <code>r</code> out and returns it. Leaves <code> r[i]</code> in a destroyable state that does not allocate any resources (usually equal to its <code>.init</code> value).</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto a = [1,2,3,4];
foreach (idx, it; a)
{
    writeln(it); // moveAt(a, idx)
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="empty">@property bool <strong id="empty">empty</strong>(T)(auto ref scope T a)<br><small>  Constraints: if (is(typeof(a.length) : size_t)); </small>
</dt> <dd>
<p>Implements the range interface primitive <code>empty</code> for types that obey <a href="#hasLength"><code>hasLength</code></a> property and for narrow strings. Due to the fact that nonmember functions can be called with the first argument using the dot notation, <code>a.empty</code> is equivalent to <code>empty(a)</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto a = [ 1, 2, 3 ];
assert(!a.empty);
assert(a[3 .. $].empty);

int[string] b;
assert(b.empty);
b["zero"] = 0;
assert(!b.empty);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="save">pure nothrow @nogc @property @safe inout(T)[] <strong id="save">save</strong>(T)(return scope inout(T)[] a); </dt> <dd>
<p>Implements the range interface primitive <code>save</code> for built-in arrays. Due to the fact that nonmember functions can be called with the first argument using the dot notation, <code>array.save</code> is equivalent to <code>save(array)</code>. The function does not duplicate the content of the array, it simply returns its argument.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto a = [ 1, 2, 3 ];
auto b = a.save;
assert(b is a);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="popFront">pure nothrow @nogc @safe void <strong id="popFront">popFront</strong>(T)(ref scope inout(T)[] a)<br><small>  Constraints: if (!isAutodecodableString!(T[]) &amp;&amp; !is(T[] == void[])); </small><br><br>pure nothrow @trusted void <strong id="popFront">popFront</strong>(C)(ref scope inout(C)[] str)<br><small>  Constraints: if (isAutodecodableString!(C[])); </small>
</dt> <dd>
<p>Implements the range interface primitive <code>popFront</code> for built-in arrays. Due to the fact that nonmember functions can be called with the first argument using the dot notation, <code>array.popFront</code> is equivalent to <code>popFront(array)</code>. For <a href="http://dlang.org/glossary.html#narrow%20strings">narrow strings</a>, <code>popFront</code> automatically advances to the next <a href="#">code point</a>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto a = [ 1, 2, 3 ];
a.popFront();
writeln(a); // [2, 3]
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="popBack">pure nothrow @nogc @safe void <strong id="popBack">popBack</strong>(T)(ref scope inout(T)[] a)<br><small>  Constraints: if (!isAutodecodableString!(T[]) &amp;&amp; !is(T[] == void[])); </small><br><br>pure @safe void <strong id="popBack">popBack</strong>(T)(ref scope inout(T)[] a)<br><small>  Constraints: if (isAutodecodableString!(T[])); </small>
</dt> <dd>
<p>Implements the range interface primitive <code>popBack</code> for built-in arrays. Due to the fact that nonmember functions can be called with the first argument using the dot notation, <code>array.popBack</code> is equivalent to <code>popBack(array)</code>. For <a href="http://dlang.org/glossary.html#narrow%20strings">narrow strings</a>, <code>popFront</code> automatically eliminates the last <a href="http://dlang.org/glossary.html#code%20point">code point</a>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto a = [ 1, 2, 3 ];
a.popBack();
writeln(a); // [1, 2]
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="autodecodeStrings">enum bool <strong id="autodecodeStrings">autodecodeStrings</strong>; </dt> <dd>
<dl>
<dt>EXPERIMENTAL</dt>
<dd> to try out removing autodecoding, set the version <code>NoAutodecodeStrings</code>. Most things are expected to fail with this version currently.</dd>
</dl> </dd> <dt class="d_decl" id="front">pure nothrow @nogc @property ref @safe inout(T) <strong id="front">front</strong>(T)(return scope inout(T)[] a)<br><small>  Constraints: if (!isAutodecodableString!(T[]) &amp;&amp; !is(T[] == void[])); </small><br><br>pure @property @safe dchar <strong id="front">front</strong>(T)(scope const(T)[] a)<br><small>  Constraints: if (isAutodecodableString!(T[])); </small>
</dt> <dd>
<p>Implements the range interface primitive <code>front</code> for built-in arrays. Due to the fact that nonmember functions can be called with the first argument using the dot notation, <code>array.front</code> is equivalent to <code>front(array)</code>. For <a href="http://dlang.org/glossary.html#narrow%20strings">narrow strings</a>, <code>front</code> automatically returns the first <a href="http://dlang.org/glossary.html#code%20point">code point</a> as a <code>dchar</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int[] a = [ 1, 2, 3 ];
writeln(a.front); // 1
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="back">pure nothrow @nogc @property ref @safe inout(T) <strong id="back">back</strong>(T)(return scope inout(T)[] a)<br><small>  Constraints: if (!isAutodecodableString!(T[]) &amp;&amp; !is(T[] == void[])); </small><br><br>pure @property @safe dchar <strong id="back">back</strong>(T)(scope const(T)[] a)<br><small>  Constraints: if (isAutodecodableString!(T[])); </small>
</dt> <dd>
<p>Implements the range interface primitive <code>back</code> for built-in arrays. Due to the fact that nonmember functions can be called with the first argument using the dot notation, <code>array.back</code> is equivalent to <code>back(array)</code>. For <a href="http://dlang.org/glossary.html#narrow%20strings">narrow strings</a>, <code>back</code> automatically returns the last <a href="http://dlang.org/glossary.html#code%20point">code point</a> as a <code>dchar</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int[] a = [ 1, 2, 3 ];
writeln(a.back); // 3
a.back += 4;
writeln(a.back); // 7
</pre> </dd>
</dl> </dd> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1999&ndash;2021 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/std_range_primitives.html" class="_attribution-link">https://dlang.org/phobos/std_range_primitives.html</a>
  </p>
</div>
