<h1>Functions</h1>       <b>Contents</b>  <ol> <li><a href="#grammar">Grammar</a></li> <li>
<a href="#contracts">Function Contracts</a><ol> <li><a href="#in_out_inheritance">In, Out and Inheritance</a></li> </ol>
</li> <li><a href="#function-return-values">Function Return Values</a></li> <li><a href="#function-declarations">Functions Without Bodies</a></li> <li><a href="#pure-functions">Pure Functions</a></li> <li><a href="#nothrow-functions">Nothrow Functions</a></li> <li><a href="#ref-functions">Ref Functions</a></li> <li><a href="#auto-functions">Auto Functions</a></li> <li><a href="#auto-ref-functions">Auto Ref Functions</a></li> <li>
<a href="#inout-functions">Inout Functions</a><ol> <li><a href="#matching-an-inout-parameter">Matching an <code>inout</code> Parameter</a></li> </ol>
</li> <li><a href="#optional-parenthesis">Optional Parentheses</a></li> <li><a href="#property-functions">Property Functions</a></li> <li>
<a href="#virtual-functions">Virtual Functions</a><ol> <li><a href="#function-inheritance">Function Inheritance and Overriding</a></li> </ol>
</li> <li><a href="#inline-functions">Inline Functions</a></li> <li>
<a href="#function-overloading">Function Overloading</a><ol> <li><a href="#overload-sets">Overload Sets</a></li> </ol>
</li> <li>
<a href="#parameters">Function Parameters</a><ol> <li><a href="#param-storage">Parameter Storage Classes</a></li> <li><a href="#in-params">In Parameters</a></li> <li><a href="#ref-params">Ref and Out Parameters</a></li> <li><a href="#lazy-params">Lazy Parameters</a></li> <li><a href="#function-default-args">Function Default Arguments</a></li> <li><a href="#return-ref-parameters">Return Ref Parameters</a></li> <li><a href="#scope-parameters">Scope Parameters</a></li> <li><a href="#return-scope-parameters">Return Scope Parameters</a></li> <li><a href="#ref-return-scope-parameters">Ref Return Scope Parameters</a></li> <li><a href="#udas-parameters">User-Defined Attributes for Parameters</a></li> <li><a href="#variadic">Variadic Functions</a></li> </ol>
</li> <li>
<a href="#local-variables">Local Variables</a><ol> <li><a href="#local-static-variables">Local Static Variables</a></li> </ol>
</li> <li><a href="#nested">Nested Functions</a></li> <li>
<a href="#closures">Delegates, Function Pointers, and Closures</a><ol> <li><a href="#anonymous">Anonymous Functions and Anonymous Delegates</a></li> </ol>
</li> <li>
<a href="#main"><code>main()</code> Function</a><ol> <li><a href="#betterc-main">BetterC <code>main()</code> Function</a></li> </ol>
</li> <li><a href="#function-templates">Function Templates</a></li> <li>
<a href="#interpretation">Compile Time Function Execution (CTFE)</a><ol> <li><a href="#string-mixins">String Mixins and Compile Time Function Execution</a></li> </ol>
</li> <li><a href="#nogc-functions">No-GC Functions</a></li> <li>
<a href="#function-safety">Function Safety</a><ol> <li><a href="#safe-functions">Safe Functions</a></li> <li><a href="#trusted-functions">Trusted Functions</a></li> <li><a href="#system-functions">System Functions</a></li> <li><a href="#safe-interfaces">Safe Interfaces</a></li> <li><a href="#safe-values">Safe Values</a></li> <li><a href="#safe-aliasing">Safe Aliasing</a></li> </ol>
</li> <li><a href="#function-attribute-inference">Function Attribute Inference</a></li> <li><a href="#pseudo-member">Uniform Function Call Syntax (UFCS)</a></li> </ol>   <h2 id="grammar">Grammar</h2>  <h3>Function declaration</h3>  <pre>FuncDeclaration:
    StorageClassesopt BasicType FuncDeclarator FunctionBody
    AutoFuncDeclaration

AutoFuncDeclaration:
    StorageClasses Identifier FuncDeclaratorSuffix FunctionBody

FuncDeclarator:
    TypeSuffixesopt Identifier FuncDeclaratorSuffix

FuncDeclaratorSuffix:
    Parameters MemberFunctionAttributesopt
    TemplateParameters Parameters MemberFunctionAttributesopt Constraintopt
</pre>  <h3>Parameters</h3>  <pre>Parameters:
    ( ParameterListopt )

ParameterList:
    Parameter
    Parameter , ParameterList
    VariadicArgumentsAttributes ...

Parameter:
    ParameterAttributesopt BasicType Declarator
    ParameterAttributesopt BasicType Declarator ...
    ParameterAttributesopt BasicType Declarator = AssignExpression
    ParameterAttributesopt Type
    ParameterAttributesopt Type ...

ParameterAttributes:
    InOut
    UserDefinedAttribute
    ParameterAttributes InOut
    ParameterAttributes UserDefinedAttribute
    ParameterAttributes

InOut:
    auto
    TypeCtor
    final
    in
    lazy
    out
    ref
    return ref
    scope

VariadicArgumentsAttributes:
    VariadicArgumentsAttribute
    VariadicArgumentsAttribute VariadicArgumentsAttributes

VariadicArgumentsAttribute:
    const
    immutable
    return
    scope
    shared
</pre>  <h3>Function attributes</h3>  <pre>FunctionAttributes:
    FunctionAttribute
    FunctionAttribute FunctionAttributes

FunctionAttribute:
    FunctionAttributeKwd
    Property

MemberFunctionAttributes:
    MemberFunctionAttribute
    MemberFunctionAttribute MemberFunctionAttributes

MemberFunctionAttribute:
    const
    immutable
    inout
    return
    shared
    FunctionAttribute
</pre>  <h3>Function body</h3>  <pre>FunctionBody:
    SpecifiedFunctionBody
    MissingFunctionBody
    ShortenedFunctionBody

FunctionLiteralBody:
    SpecifiedFunctionBody

SpecifiedFunctionBody:
    doopt BlockStatement
    FunctionContractsopt InOutContractExpression doopt BlockStatement
    FunctionContractsopt InOutStatement do BlockStatement

MissingFunctionBody:
    ;
    FunctionContractsopt InOutContractExpression ;
    FunctionContractsopt InOutStatement

ShortenedFunctionBody:
    =&gt; AssignExpression ;
</pre>  <p>Examples:</p>  <pre data-language="d">int hasSpecifiedBody() { return 1; }
int hasMissingBody();
int hasShortenedBody() =&gt; 1;
</pre>  <p><b>Note:</b> The <code>ShortenedFunctionBody</code> form requires the <code>-preview=shortenedMethods</code> command-line switch, which is available starting in v2.096.0.</p>  <h2 id="contracts">Function Contracts</h2>  <pre>FunctionContracts:
    FunctionContract
    FunctionContract FunctionContracts

FunctionContract:
    InOutContractExpression
    InOutStatement

InOutContractExpression:
    InContractExpression
    OutContractExpression

InOutStatement:
    InStatement
    OutStatement

InContractExpression:
    in ( AssertArguments )

OutContractExpression:
    out ( ; AssertArguments )
    out ( Identifier ; AssertArguments )

InStatement:
    in BlockStatement

OutStatement:
    out BlockStatement
    out ( Identifier ) BlockStatement
</pre>  <p>Function Contracts specify the preconditions and postconditions of a function. They are used in <a href="contracts.html">Contract Programming</a>. </p>  <p>Preconditions and postconditions do not affect the type of the function.</p>  <h3>Preconditions</h3>  <p>An <a href="#InContractExpression"><i>InContractExpression</i></a> is a precondition.</p>  <p>The first <a href="expression.html#AssignExpression"><i>AssignExpression</i></a> of the <a href="expression.html#AssertArguments"><i>AssertArguments</i></a> must evaluate to true. If it does not, the precondition has failed.</p>  <p>The second <i>AssignExpression</i>, if present, must be implicitly convertible to type <code>const(char)[]</code>. </p>  <p>An <a href="#InStatement"><i>InStatement</i></a> is also a precondition. Any <a href="expression.html#AssertExpression"><i>AssertExpression</i></a> appearing in an <i>InStatement</i> will be an <i>InContractExpression</i>. </p>  <p>Preconditions must semantically be satisfied before the function starts executing. If it is not, the program enters an <i>Invalid State</i>. </p>  <b>Implementation Defined:</b> Whether the preconditions are actually run or not is implementation defined. This is usually selectable with a compiler switch. Its behavior upon precondition failure is also usually selectable with a compiler switch. One option is to throw an <code>AssertError</code> with a message consisting of the optional second <i>AssignExpression</i>.   <b>Best Practices:</b> Use preconditions to validate that input arguments have values that are expected by the function.  <b>Best Practices:</b> Since preconditions may or may not be actually checked at runtime, avoid using preconditions that have side effects.  <p>The expression form is:</p>  <pre data-language="d">in (expression)
in (expression, "failure string")
{
    ...function body...
}
</pre>  <p>The block statement form is:</p>  <pre data-language="d">in
{
    ...contract preconditions...
}
do
{
    ...function body...
}
</pre>   <h3>Postconditions</h3>  <p>An <a href="#OutContractExpression"><i>OutContractExpression</i></a> is a postcondition.</p>  <p>The first <a href="expression.html#AssignExpression"><i>AssignExpression</i></a> of the <a href="expression.html#AssertArguments"><i>AssertArguments</i></a> must evaluate to true. If it does not, the postcondition has failed.</p>  <p>The second <i>AssignExpression</i>, if present, must be implicitly convertible to type <code>const(char)[]</code>. </p>  <p>An <a href="#OutStatement"><i>OutStatement</i></a> is also a postcondition. Any <a href="expression.html#AssertExpression"><i>AssertExpression</i></a> appearing in an <i>OutStatement</i> will be an <i>OutContractExpression</i>. </p>  <p>Postconditions must semantically be satisfied after the function finishes executing. If it is not, the program enters an <i>Invalid State</i>. </p>  <b>Implementation Defined:</b> Whether the postconditions are actually run or not is implementation defined. This is usually selectable with a compiler switch. Its behavior upon postcondition failure is also usually selectable with a compiler switch. One option is to throw an <code>AssertError</code> with a message consisting of the optional second <i>AssignExpression</i>.   <b>Best Practices:</b> Use postconditions to validate that the input arguments and return value have values that are expected by the function.  <b>Best Practices:</b> Since postconditions may or may not be actually checked at runtime, avoid using postconditions that have side effects.  <p>The expression form is:</p>  <pre data-language="d">out (identifier; expression)
out (identifier; expression, "failure string")
out (; expression)
out (; expression, "failure string")
{
    ...function body...
}
</pre>  <p>The block statement form is:</p>  <pre data-language="d">out
{
    ...contract postconditions...
}
out (identifier)
{
    ...contract postconditions...
}
do
{
    ...function body...
}
</pre>  <p>The optional identifier in either type of postcondition is set to the return value of the function, and can be accessed from within the postcondition.</p>  <h3>Example</h3>  <pre data-language="d">int fun(ref int a, int b)
in (a &gt; 0)
in (b &gt;= 0, "b cannot be negative!")
out (r; r &gt; 0, "return must be positive")
out (; a != 0)
{
    // function body
}
</pre>  <pre data-language="d">int fun(ref int a, int b)
in
{
    assert(a &gt; 0);
    assert(b &gt;= 0, "b cannot be negative!");
}
out (r)
{
    assert(r &gt; 0, "return must be positive");
    assert(a != 0);
}
do
{
    // function body
}
</pre>  <p>The two functions are identical semantically.</p>  <h3 id="in_out_inheritance">In, Out and Inheritance</h3>  <p>If a function in a derived class overrides a function from its super class, then only the preconditions of one of the function and its overridden functions must be satisfied. Overriding functions then becomes a process of <i>loosening</i> the preconditions. </p>  <p>A function without preconditions means its precondition is always satisfied. Therefore if any function in an inheritance hierarchy has no preconditions, then any preconditions on functions overriding it have no meaningful effect. </p>  <p>Conversely, all of the postconditions of the function and its overridden functions must to be satisfied. Adding overriding functions then becomes a processes of <i>tightening</i> the postconditions. </p>   <h2 id="function-return-values">Function Return Values</h2>  <p>Function return values not marked as <code>ref</code> are considered to be rvalues. This means they cannot be passed by reference to other functions. </p>  <h2 id="function-declarations">Functions Without Bodies</h2>  <p>Functions without bodies:</p>  <pre data-language="d">int foo();
</pre>  <p>that are not declared as <code>abstract</code> are expected to have their implementations elsewhere, and that implementation will be provided at the link step. This enables an implementation of a function to be completely hidden from the user of it, and the implementation may be in another language such as C, assembler, etc. </p>  <h2 id="pure-functions">Pure Functions</h2>  <p>Pure functions are annotated with the <code>pure</code> attribute. </p>  <p>Pure functions cannot directly access global or static mutable state. </p>  <p>Pure functions can only call pure functions.</p>  <p>A pure function can override an impure function, but cannot be overridden by an impure function. I.e. it is covariant with an impure function. </p>  <p>A <i>weakly pure function</i> has parameters with mutable indirections. Program state can be modified transitively through the matching argument. </p>  <pre data-language="d">pure int foo(int[] arr) { arr[] += 1; return arr.length; }
int[] a = [1, 2, 3];
foo(a);
assert(a == [2, 3, 4]);
</pre>  <p>A <i>strongly pure function</i> has no parameters with mutable indirections and cannot modify any program state external to the function. </p>  <pre data-language="d">struct S { double x; }
pure int foo(immutable(int)[] arr, int num, S val)
{
    //arr[num] = 1; // compile error
    num = 2;        // has no side effect to the caller side
    val.x = 3.14;   // ditto
    return arr.length;
}
</pre>  <p>A strongly pure function can call a weakly pure function.</p>  <p>Pure functions can modify the local state of the function.</p>  <p>A pure function can:</p>  <ul> <li>read and write the floating point exception flags</li> <li>read and write the floating point mode flags, as long as those flags are restored to their initial state upon function entry</li> </ul>  <b>Undefined Behavior:</b> occurs if these flags are not restored to their initial state upon function exit. It is the programmer's responsibility to ensure this.  <p>A pure function can perform impure operations in statements that are in a <a href="version.html#ConditionalStatement"><i>ConditionalStatement</i></a> controlled by a <a href="version.html#DebugCondition"><i>DebugCondition</i></a>. </p>  <b>Best Practices:</b> this relaxation of purity checks in DebugConditions is intended solely to make debugging programs easier.  <p>A pure function can throw exceptions.</p>  <pre data-language="d">import std.stdio;
int x;
immutable int y;
const int* pz;

pure int foo(int i,
             char* p,
             const char* q,
             immutable int* s)
{
    debug writeln("in foo()"); // ok, impure code allowed in debug statement
    x = i;   // error, modifying global state
    i = x;   // error, reading mutable global state
    i = y;   // ok, reading immutable global state
    i = *pz; // error, reading const global state
    return i;
}
</pre>  <p><a href="#variadicnested">Nested functions</a> inside a pure function are implicitly marked as pure.</p>  <pre data-language="d">pure int foo(int x, immutable int y)
{
    int bar()
    // implicitly marked as pure, to be "weakly pure"
    // since hidden context pointer to foo stack context is mutable
    {
        x = 10;     // can access states in enclosing scope
                    // through the mutable context pointer
        return x;
    }
    pragma(msg, typeof(&amp;bar));  // int delegate() pure

    int baz() immutable
    // qualifies hidden context pointer with immutable,
    // and has no other parameters, therefore "strongly pure"
    {
        //return x; // error, cannot access mutable data
                    // through the immutable context pointer
        return y;   // ok
    }

    // can call pure nested functions
    return bar() + baz();
}
</pre>  <p>A <i>pure factory function</i> is a strongly pure function that returns a result that has mutable indirections. All mutable memory returned by the call may not be referenced by any other part of the program, i.e. it is newly allocated by the function. Nor may the mutable references of the result refer to any object that existed before the function call. For example:</p>   <pre data-language="d">struct List { int payload; List* next; }
pure List* make(int a, int b)
{
    auto result = new List(a, null);
    result.next = new List(b, result);
    return result;
}
</pre>   <p>All references in <code>make</code>'s result refer to other <code>List</code> objects created by <code>make</code>, and no other part of the program refers to any of these objects. This restriction does not apply to any Exception or Error thrown from the function. </p>   <p>Pure destructors do not benefit of special elision.</p>  <b>Implementation Defined:</b> An implementation may assume that a strongly pure function that returns a result without mutable indirections will have the same effect for all invocations with equivalent arguments. It is allowed to memoize the result of the function under the assumption that equivalent parameters always produce equivalent results. A strongly pure function may still have behavior inconsistent with memoization by e.g. using <code>cast</code>s or by changing behavior depending on the address of its parameters. An implementation is currently not required to enforce validity of memoization in all cases. If a strongly pure function throws an Exception or an Error, the assumptions related to memoization do not carry to the thrown exception.    <h2 id="nothrow-functions">Nothrow Functions</h2>  <p>Nothrow functions can only throw exceptions derived from <a href="https://dlang.org/phobos/object.html#Error"><code>class Error</code></a>. </p>  <p>Nothrow functions are covariant with throwing ones.</p>  <h2 id="ref-functions">Ref Functions</h2>  <p>Ref functions allow functions to return by reference, meaning that the return value must be an lvalue, and the lvalue is returned, not the rvalue. </p>  <pre data-language="d">ref int foo()
{
    auto p = new int(2);
    return *p;
}
...
int i = foo(); // i is set to 2
foo() = 3;     // reference returns can be lvalues
</pre>  <p>Returning a reference to an expired function context is not allowed. This includes local variables, temporaries and parameters that are part of an expired function context. </p>  <pre data-language="d">ref int sun()
{
    int i;
    return i;  // error, escaping a reference to local variable i
}
</pre>  <p>A <code>ref</code> parameter may not be returned by <code>ref</code>.</p> <pre data-language="d">ref int moon(ref int i)
{
    return i; // error
}
</pre>   <h2 id="auto-functions">Auto Functions</h2>  <p>Auto functions have their return type inferred from any <a href="statement.html#ReturnStatement"><i>ReturnStatement</i></a>s in the function body. </p>  <p>An auto function is declared without a return type. If it does not already have a storage class, use the <span class="d_keyword">auto</span> storage class. </p>  <p>If there are multiple <i>ReturnStatement</i>s, the types of them must be implicitly convertible to a common type. If there are no <i>ReturnStatement</i>s, the return type is inferred to be <span class="d_keyword">void</span>.</p>   <pre data-language="d">auto foo(int x) { return x + 3; }          // inferred to be int
auto bar(int x) { return x; return 2.5; }  // inferred to be double
</pre>   <h2 id="auto-ref-functions">Auto Ref Functions</h2>  <p>Auto ref functions infer their return type just as <a href="#auto-functions">auto functions</a> do. In addition, they become <a href="#ref-functions">ref functions</a> if all return expressions are lvalues, and it would not be a reference to a local or a parameter.</p>   <pre data-language="d">auto ref f1(int x)     { return x; }  // value return
auto ref f2()          { return 3; }  // value return
auto ref f3(ref int x) { return x; }  // ref return
auto ref f4(out int x) { return x; }  // ref return
auto ref f5() { static int x; return x; }  // ref return
</pre>   <p>The ref-ness of a function is determined from all <a href="statement.html#ReturnStatement"><i>ReturnStatement</i></a>s in the function body:</p>   <pre data-language="d">auto ref f1(ref int x) { return 3; return x; }  // ok, value return
auto ref f2(ref int x) { return x; return 3; }  // ok, value return
auto ref f3(ref int x, ref double y)
{
    return x; return y;
    // The return type is deduced to double, but cast(double)x is not an lvalue,
    // then become a value return.
}
</pre>   <p>Auto ref function can have explicit return type.</p>  <pre data-language="d">auto ref int (ref int x) { return x; }  // ok, ref return
auto ref int foo(double x) { return x; }   // error, cannot convert double to int
</pre>  <h2 id="inout-functions">Inout Functions</h2>  <p>Functions that differ only in whether the parameters are mutable, <code>const</code> or <code>immutable</code>, and have corresponding mutable, <code>const</code> or <code>immutable</code> return types, can be combined into one function using the <code>inout</code> type constructor. Consider the following overload set: </p> <pre data-language="d">int[] slice(int[] a, int x, int y) { return a[x .. y]; }

const(int)[] slice(const(int)[] a, int x, int y) { return a[x .. y]; }

immutable(int)[] slice(immutable(int)[] a, int x, int y) { return a[x .. y]; }
</pre>  <p>The code generated by each of these functions is identical. The <span class="d_keyword">inout</span> type constructor can combine them into one function:</p>   <pre data-language="d">inout(int)[] slice(inout(int)[] a, int x, int y) { return a[x .. y]; }
</pre>   <p>The <span class="d_keyword">inout</span> keyword forms a wildcard that stands in for mutable, <code>const</code>, <code>immutable</code>, <code>inout</code>, or <code>inout const</code>. When calling the function, the <code>inout</code> state of the return type is changed to match that of the argument type passed to the <code>inout</code> parameter. </p>  <p><code>inout</code> can also be used as a type constructor inside a function that has a parameter declared with <code>inout</code>. The <code>inout</code> state of a type declared with <code>inout</code> is changed to match that of the argument type passed to the <code>inout</code> parameter: </p>   <pre data-language="d">inout(int)[] asymmetric(inout(int)[] input_data)
{
    inout(int)[] r = input_data;
    while (r.length &gt; 1 &amp;&amp; r[0] == r[$-1])
        r = r[1..$-1];
    return r;
}
</pre>   <p>Inout types can be implicitly converted to <code>const</code> or <code>inout const</code>, but to nothing else. Other types cannot be implicitly converted to <code>inout</code>. Casting to or from <code>inout</code> is not allowed in <code>@safe</code> functions. </p>   <pre data-language="d">void f(inout int* ptr)
{
    const int* p = ptr;
    int* q = ptr; // error
    immutable int* r = ptr; // error
}
</pre>   <h3 id="matching-an-inout-parameter">Matching an <code>inout</code> Parameter</h3>  <p>A set of arguments to a function with <code>inout</code> parameters is considered a match if any <code>inout</code> argument types match exactly, or:</p>  <ol> <li>No argument types are composed of <code>inout</code> types.</li> <li>A mutable, <code>const</code> or <code>immutable</code> argument type can be matched against each corresponding parameter <code>inout</code> type.</li> </ol>  <p>If such a match occurs, <code>inout</code> is considered the common qualifier of the matched qualifiers. If more than two parameters exist, the common qualifier calculation is recursively applied. </p>  <table>
<caption>Common qualifier of the two type qualifiers</caption> <tr>
<td></td>
<td><i>mutable</i></td>
<td><code>const</code></td>
<td><code>immutable</code></td>
<td><code>inout</code></td>
<td><code>inout const</code></td>
</tr> <tr>
<td>
<i>mutable</i> (= m)</td>
<td>m</td>
<td>c</td>
<td>c</td>
<td>c</td>
<td>c</td>
</tr> <tr>
<td>
<code>const</code> (= c)</td>
<td>c</td>
<td>c</td>
<td>c</td>
<td>c</td>
<td>c</td>
</tr> <tr>
<td>
<code>immutable</code> (= i)</td>
<td>c</td>
<td>c</td>
<td>i</td>
<td>wc</td>
<td>wc</td>
</tr> <tr>
<td>
<code>inout</code> (= w)</td>
<td>c</td>
<td>c</td>
<td>wc</td>
<td>w</td>
<td>wc</td>
</tr> <tr>
<td>
<code>inout const</code> (= wc)</td>
<td>c</td>
<td>c</td>
<td>wc</td>
<td>wc</td>
<td>wc</td>
</tr> </table>  <p>The <code>inout</code> in the return type is then rewritten to match the <code>inout</code> qualifiers:</p>   <pre data-language="d">int[] ma;
const(int)[] ca;
immutable(int)[] ia;

inout(int)[] foo(inout(int)[] a) { return a; }
void test1()
{
    // inout matches to mutable, so inout(int)[] is
    // rewritten to int[]
    int[] x = foo(ma);

    // inout matches to const, so inout(int)[] is
    // rewritten to const(int)[]
    const(int)[] y = foo(ca);

    // inout matches to immutable, so inout(int)[] is
    // rewritten to immutable(int)[]
    immutable(int)[] z = foo(ia);
}

inout(const(int))[] bar(inout(int)[] a) { return a; }
void test2()
{
    // inout matches to mutable, so inout(const(int))[] is
    // rewritten to const(int)[]
    const(int)[] x = bar(ma);

    // inout matches to const, so inout(const(int))[] is
    // rewritten to const(int)[]
    const(int)[] y = bar(ca);

    // inout matches to immutable, so inout(int)[] is
    // rewritten to immutable(int)[]
    immutable(int)[] z = bar(ia);
}
</pre>   <p><b>Note:</b> Shared types cannot be matched with <code>inout</code>. </p>  <h2 id="optional-parenthesis">Optional Parentheses</h2>  <p>If a function call passes no explicit argument, i.e. it would syntactically use <code>()</code>, then these parentheses may be omitted, similar to a getter invocation of a <a href="#property-functions">property function</a>. </p>   <pre data-language="d">void foo() {}   // no arguments
void fun(int x = 10) { }
void bar(int[] arr) {}  // for UFCS

void main()
{
    foo();      // OK
    foo;        // also OK
    fun;        // OK

    int[] arr;
    arr.bar();  // OK
    arr.bar;    // also OK
}
</pre>   <p>Optional parentheses are not applied to delegates or function pointers.</p>  <pre data-language="d">void main()
{
    int function() fp;

    assert(fp == 6);    // Error, incompatible types int function() and int
    assert(*fp == 6);   // Error, incompatible types int() and int

    int delegate() dg;
    assert(dg == 6);    // Error, incompatible types int delegate() and int
}
</pre>  <p>If a function returns a delegate or function pointer, the parentheses are required if the returned value is to be called. </p>   <pre data-language="d">struct S {
    int function() callfp() { return &amp;numfp; }
    int delegate() calldg() return { return &amp;numdg; }
    int numdg() { return 6; }
}

int numfp() { return 6; }

void main()
{
    S s;
    int function() fp;

    fp = s.callfp;
    assert(fp() == 6);

    fp = s.callfp();
    assert(fp() == 6);

    int x = s.callfp()();
    assert(x == 6);

    int delegate() dg;

    dg = s.calldg;
    assert(dg() == 6);

    dg = s.calldg();
    assert(dg() == 6);

    int y = s.calldg()();
    assert(y == 6);
}
</pre>   <h2 id="property-functions">Property Functions</h2>  <p>WARNING: The definition and usefulness of property functions is being reviewed, and the implementation is currently incomplete. Using property functions is not recommended until the definition is more certain and implementation more mature.</p>  <p>Properties are functions that can be syntactically treated as if they were fields or variables. Properties can be read from or written to. A property is read by calling a method or function with no arguments; a property is written by calling a method or function with its argument being the value it is set to. </p>  <p>Simple getter and setter properties can be written using <a href="#pseudo-member">UFCS</a>. These can be enhanced with the additon of the <code>@property</code> attribute to the function, which adds the following behaviors: </p>  <ul> <li>
<code>@property</code> functions cannot be overloaded with non-<code>@property</code> functions with the same name.</li> <li>
<code>@property</code> functions can only have zero, one or two parameters.</li> <li>
<code>@property</code> functions cannot have variadic parameters.</li> <li>For the expression <code>typeof(exp)</code> where <code>exp</code> is an <code>@property</code> function, the type is the return type of the function, rather than the type of the function.</li> <li>For the expression <code>__traits(compiles, exp)</code> where <code>exp</code> is an <code>@property</code> function, a further check is made to see if the function can be called.</li> <li>
<code>@property</code> are mangled differently, meaning that <code>@property</code> must be consistently used across different compilation units.</li> <li>The ObjectiveC interface recognizes <code>@property</code> setter functions as special and modifies them accordingly.</li> </ul>  <p>A simple property would be:</p>    <pre data-language="d">struct Foo
{
    @property int data() { return m_data; } // read property

    @property int data(int value) { return m_data = value; } // write property

  private:
    int m_data;
}
</pre>   <p>To use it:</p>  <pre data-language="d">int test()
{
    Foo f;

    f.data = 3;        // same as f.data(3);
    return f.data + 3; // same as return f.data() + 3;
}
</pre>  <p>The absence of a read method means that the property is write-only. The absence of a write method means that the property is read-only. Multiple write methods can exist; the correct one is selected using the usual function overloading rules. </p>  <p>In all the other respects, these methods are like any other methods. They can be static, have different linkages, have their address taken, etc. </p>  <p>The built in properties <code>.sizeof</code>, <code>.alignof</code>, and <code>.mangleof</code> may not be declared as fields or methods in structs, unions, classes or enums. </p>  <p>If a property function has no parameters, it works as a getter. If has exactly one parameter, it works as a setter. </p>   <h2 id="virtual-functions">Virtual Functions</h2>  <p>Virtual functions are class member functions that are called indirectly through a function pointer table, called a <code>vtbl[]</code>, rather than directly. </p>  <p>Member functions that are virtual can be overridden, unless they are <code>final</code>. </p>  <p>Struct and union member functions are not virtual. </p>  <p>Static member functions are not virtual. </p>  <p>Member functions which are <code>private</code> or <code>package</code> are not virtual. </p>  <p>Member template functions are not virtual. </p>  <p>Member functions with <code>Objective-C</code> linkage are virtual even if marked with <code>final</code> or <code>static</code>. </p>  <pre data-language="d">class A
{
    int def() { ... }
    final int foo() { ... }
    final private int bar() { ... }
    private int abc() { ... }
}

class B : A
{
    override int def() { ... }  // ok, overrides A.def
    override int foo() { ... }  // error, A.foo is final
    int bar() { ... }  // ok, A.bar is final private, but not virtual
    int abc() { ... }  // ok, A.abc is not virtual, B.abc is virtual
}

void test(A a)
{
    a.def();    // calls B.def
    a.foo();    // calls A.foo
    a.bar();    // calls A.bar
    a.abc();    // calls A.abc
}

void func()
{
    B b = new B();
    test(b);
}
</pre>  <p>The overriding function may be covariant with the overridden function. A covariant function has a type that is implicitly convertible to the type of the overridden function. </p>   <pre data-language="d">class A { }
class B : A { }

class Foo
{
    A test() { return null; }
}

class Bar : Foo
{
    // overrides and is covariant with Foo.test()
    override B test() { return null; }
}
</pre>   <p>Virtual functions all have a hidden parameter called the <i>this</i> reference, which refers to the class object instance for which the function is called. </p>  <p> Functions with <code>Objective-C</code> linkage have an additional hidden, unnamed, parameter which is the selector it was called with. </p>  <p>To directly call a base member function, insert base class name before the member function name. For example: </p>   <pre data-language="d">class B
{
    int foo() { return 1; }
}
class C : B
{
    override int foo() { return 2; }

    void test()
    {
        assert(B.foo() == 1);  // translated to this.B.foo(), and
                               // calls B.foo statically.
        assert(C.foo() == 2);  // calls C.foo statically, even if
                               // the actual instance of 'this' is D.
    }
}
class D : C
{
    override int foo() { return 3; }
}
void main()
{
    auto d = new D();
    assert(d.foo() == 3);    // calls D.foo
    assert(d.B.foo() == 1);  // calls B.foo
    assert(d.C.foo() == 2);  // calls C.foo
    d.test();
}
</pre>   <b>Implementation Defined:</b> Normally calling a virtual function implies getting the address of the function at runtime by indexing into the class's <code>vtbl[]</code>. If the implementation can determine that the called virtual function will be statically known, such as if it is <code>final</code>, it can use a direct call instead.   <h3 id="function-inheritance">Function Inheritance and Overriding</h3>  <p>A function in a derived class with the same name and covariant with a function in a base class overrides that function:</p>  <pre data-language="d">class A
{
    int foo(int x) { ... }
}

class B : A
{
    override int foo(int x) { ... }
}

void test()
{
    B b = new B();
    bar(b);
}

void bar(A a)
{
    a.foo(1);   // calls B.foo(int)
}
</pre>  <p>When doing overload resolution, the functions in the base class are not considered, as they are not in the same <a href="#overload-sets">Overload Set</a>: </p>  <pre data-language="d">class A
{
    int foo(int x) { ... }
    int foo(long y) { ... }
}

class B : A
{
    override int foo(long x) { ... }
}

void test()
{
    B b = new B();
    b.foo(1);  // calls B.foo(long), since A.foo(int) not considered
    A a = b;

    a.foo(1);  // issues runtime error (instead of calling A.foo(int))
}
</pre>  <p>To include the base class's functions in the overload resolution process, use an <a href="declaration.html#AliasDeclaration"><i>AliasDeclaration</i></a>: </p>  <pre data-language="d">class A
{
    int foo(int x) { ... }
    int foo(long y) { ... }
}

class B : A
{
    alias foo = A.foo;
    override int foo(long x) { ... }
}

void test()
{
    B b = new B();
    bar(b);
}

void bar(A a)
{
    a.foo(1);      // calls A.foo(int)
    B b = new B();
    b.foo(1);      // calls A.foo(int)
}
</pre>  <p>If such an <i>AliasDeclaration</i> is not used, the derived class's functions completely override all the functions of the same name in the base class, even if the types of the parameters in the base class functions are different. It is illegal if, through implicit conversions to the base class, those other functions do get called: </p> <pre data-language="d">class A
{
    void set(long i) { }
    void set(int i)  { }
}
class B : A
{
    void set(long i) { }
}

void foo(A a)
{
    int i;
    a.set(3);   // error, use of A.set(int) is hidden by B
                // use 'alias set = A.set;' to introduce base class overload set
    assert(i == 1);
}

void main()
{
    foo(new B);
}
</pre>  <p>A function parameter's default value is not inherited:</p>  <pre data-language="d">class A
{
    void foo(int x = 5) { ... }
}

class B : A
{
    void foo(int x = 7) { ... }
}

class C : B
{
    void foo(int x) { ... }
}

void test()
{
    A a = new A();
    a.foo();       // calls A.foo(5)

    B b = new B();
    b.foo();       // calls B.foo(7)

    C c = new C();
    c.foo();       // error, need an argument for C.foo
}
</pre>  <p>An overriding function inherits any unspecified <a href="#FunctionAttributes"><i>FunctionAttributes</i></a> from the attributes of the overridden function.</p>   <pre data-language="d">class B
{
    void foo() pure nothrow @safe {}
}
class D : B
{
    override void foo() {}
}
void main()
{
    auto d = new D();
    pragma(msg, typeof(&amp;d.foo));
    // prints "void delegate() pure nothrow @safe" in compile time
}
</pre>   <p>The attributes <a href="attribute.html#disable"><code>@disable</code></a> and <a href="attribute.html#deprecated"><code>deprecated</code></a> are not allowed on overriding functions. </p>  <b>Rationale:</b> To stop the compilation or to output the deprecation message, the implementation must be able to determine the target of the call, which can't be guaranteed when it is virtual.   <pre data-language="d">class B
{
    void foo() {}
}

class D : B
{
    @disable override void foo() {}  // error, can't apply @disable to overriding function
}
</pre>  <p>Static functions with <code>Objective-C</code> linkage are overridable.</p>  <h2 id="inline-functions">Inline Functions</h2>  <p>The compiler makes the decision whether to inline a function or not. This decision may be controlled by <a href="pragma.html#inline"><code>pragma(inline)</code></a>.</p>  <b>Implementation Defined:</b> Whether a function is inlined or not is implementation defined, though any <a href="expression.html#FunctionLiteral"><i>FunctionLiteral</i></a> should be inlined when used in its declaration scope.   <h2 id="function-overloading">Function Overloading</h2>  <p><i>Function overloading</i> occurs when two or more functions in the same scope have the same name. The function selected is the one that is the <i>best match</i> to the arguments. The matching levels are: </p>  <ol> <li>no match</li> <li>match with implicit conversions</li> <li>match with qualifier conversion (if the argument type is <a href="http://dlang.org/glossary.html#qualifier-convertible">qualifier-convertible</a> to the parameter type)</li> <li>exact match</li> </ol>  <p>Each argument (including any <code>this</code> reference) is compared against the function's corresponding parameter to determine the match level for that argument. The match level for a function is the <i>worst</i> match level of each of its arguments.</p>  <p>Literals do not match <code>ref</code> or <code>out</code> parameters.</p>  <p id="partial-ordering">If two or more functions have the same match level, then <i>partial ordering</i> is used to disambiguate to find the best match. Partial ordering finds the most specialized function. If neither function is more specialized than the other, then it is an ambiguity error. Partial ordering is determined for functions <i>f</i> and <i>g</i> by taking the parameter types of <i>f</i>, constructing a list of arguments by taking the default values of those types, and attempting to match them against <i>g</i>. If it succeeds, then <i>g</i> is at least as specialized as <i>f</i>. For example: </p> <pre data-language="d">class A { }
class B : A { }
class C : B { }
void foo(A);
void foo(B);

void test()
{
    C c;
    /* Both foo(A) and foo(B) match with implicit conversions (level 2).
     * Applying partial ordering rules,
     * foo(B) cannot be called with an A, and foo(A) can be called
     * with a B. Therefore, foo(B) is more specialized, and is selected.
     */
    foo(c); // calls foo(B)
}
</pre> <p>A function with a variadic argument is considered less specialized than a function without. </p>   <h3 id="overload-sets">Overload Sets</h3>  <p>Functions declared at the same scope overload against each other, and are called an <i>Overload Set</i>. An example of an overload set are functions defined at module level: </p>   <pre data-language="d">module A;
void foo() { }
void foo(long i) { }
</pre>   <p><code>A.foo()</code> and <code>A.foo(long)</code> form an overload set. A different module can also define another overload set of functions with the same name: </p>   <pre data-language="d">module B;
class C { }
void foo(C) { }
void foo(int i) { }
</pre>   <p>and A and B can be imported by a third module, C. Both overload sets, the <code>A.foo</code> overload set and the <code>B.foo</code> overload set, are found when searching for symbol <code>foo</code>. An instance of <code>foo</code> is selected based on it matching in exactly one overload set: </p>  <pre data-language="d">import A;
import B;

void bar(C c , long i)
{
    foo();    // calls A.foo()
    foo(i);  // calls A.foo(long)
    foo(c);   // calls B.foo(C)
    foo(1,2); // error, does not match any foo
    foo(1);   // error, matches A.foo(long) and B.foo(int)
    A.foo(1); // calls A.foo(long)
}
</pre>  <p>Even though <code>B.foo(int)</code> is a better match than <code> A.foo(long)</code> for <code>foo(1)</code>, it is an error because the two matches are in different overload sets. </p>  <p>Overload sets can be merged with an alias declaration:</p>  <pre data-language="d">import A;
import B;

alias foo = A.foo;
alias foo = B.foo;

void bar(C c)
{
    foo();    // calls A.foo()
    foo(1L);  // calls A.foo(long)
    foo(c);   // calls B.foo(C)
    foo(1,2); // error, does not match any foo
    foo(1);   // calls B.foo(int)
    A.foo(1); // calls A.foo(long)
}
</pre>   <h2 id="parameters">Function Parameters</h2>  <h3 id="param-storage">Parameter Storage Classes</h3>  <p>Parameter storage classes are <code>in</code>, <code>out</code>, <code>ref</code>, <code>lazy</code>, <code>return</code> and <code>scope</code>. Parameters can also take the type constructors <code>const</code>, <code>immutable</code>, <code>shared</code> and <code>inout</code>. </p>  <p><code>in</code>, <code>out</code>, <code>ref</code> and <code>lazy</code> are mutually exclusive. The first three are used to denote input, input/output, and output parameters, respectively. For example: </p>  <pre data-language="d">int read(in char[] input, ref size_t count, out int errno);

void main()
{
    size_t a = 42;
    int b;
    int r = read("Hello World", a, b);
}
</pre>  <p><code>read</code> has three parameters. <code>input</code> will only be read and no reference to it will be retained. <code>count</code> may be read and written to, and <code>errno</code> will be set to a value from within the function.</p>  <p>The argument <code>"Hello World"</code> gets bound to parameter <code>input</code>, <code>a</code> gets bound to <code>count</code> and <code>b</code> to <code>errno</code>. </p>  <table>
<caption>Parameter Storage Class and Type Constructor Overview</caption> <tr>
<th class="donthyphenate"><b>Storage Class</b></th>
<th class="donthyphenate"><b>Description</b></th>
</tr>  <tr>
<td><i>none</i></td>
<td>The parameter will be a mutable copy of its argument.</td>
</tr>  <tr>
<td><code>in</code></td>
<td>The parameter is an input to the function.</td>
</tr>  <tr>
<td><code>out</code></td>
<td>The argument must be an lvalue, which will be passed by reference and initialized upon function entry with the default value (<code>T.init</code>) of its type. </td>
</tr>  <tr>
<td><code>ref</code></td>
<td>The parameter is an <i>input/output</i> parameter, passed by reference. </td>
</tr>  <tr>
<td><code>scope</code></td>
<td> The parameter must not escape the function call (e.g. by being assigned to a global variable). Ignored for any parameter that is not a reference type. </td>
</tr>  <tr>
<td><code>return</code></td>
<td>Parameter may be returned or copied to the first parameter, but otherwise does not escape from the function. Such copies are required not to outlive the argument(s) they were derived from. Ignored for parameters with no references. See <a href="memory-safe-d.html#scope-return-params">Scope Parameters</a>.</td>
</tr>  <tr>
<td><code>lazy</code></td>
<td>argument is evaluated by the called function and not by the caller</td>
</tr>  <tr>
<th class="donthyphenate"><b>Type Constructor</b></th>
<th class="donthyphenate"><b>Description</b></th>
</tr>  <tr>
<td><code>const</code></td>
<td>argument is implicitly converted to a const type</td>
</tr> <tr>
<td><code>immutable</code></td>
<td>argument is implicitly converted to an immutable type</td>
</tr> <tr>
<td><code>shared</code></td>
<td>argument is implicitly converted to a shared type</td>
</tr> <tr>
<td><code>inout</code></td>
<td>argument is implicitly converted to an inout type</td>
</tr> </table>  <h3 id="in-params">In Parameters</h3>  <b>Note: The following requires the <code>-preview=in</code> switch, available in <a href="https://dlang.org/changelog/2.094.0.html#preview-in">v2.094.0</a> or higher. When not in use, <code>in</code> is equivalent to <code>const</code>.</b> <p>The parameter is an input to the function. Input parameters behave as if they have the <code>const scope</code> storage classes. Input parameters may also be passed by reference by the compiler.</p> <p>Unlike <code>ref</code> parameters, <code>in</code> parameters can bind to both lvalues and rvalues (such as literals).</p> <p>Types that would trigger a side effect if passed by value (such as types with copy constructor, postblit, or destructor), and types which cannot be copied (e.g. if their copy constructor is marked as <code>@disable</code>) will always be passed by reference. Dynamic arrays, classes, associative arrays, function pointers, and delegates will always be passed by value.</p> <b>Implementation Defined:</b> If the type of the parameter does not fall in one of those categories, whether or not it is passed by reference is implementation defined, and the backend is free to choose the method that will best fit the ABI of the platform.    <h3 id="ref-params">Ref and Out Parameters</h3>  <p>By default, parameters take rvalue arguments. A <code>ref</code> parameter takes an lvalue argument, so changes to its value will operate on the caller's argument.</p>   <pre data-language="d">void inc(ref int x)
{
    x += 1;
}

void seattle()
{
    int z = 3;
    inc(z);
    assert(z == 4);
}
</pre>   <p>A <code>ref</code> parameter can also be returned by reference, see <a href="#return-ref-parameters">Return Ref Parameters.</a></p>  <p>An <code>out</code> parameter is similar to a <code>ref</code> parameter, except it is initialized with <code>x.init</code> upon function invocation.</p>   <pre data-language="d">void zero(out int x)
{
    assert(x == 0);
}

void two(out int x)
{
    x = 2;
}

void tacoma()
{
    int a = 3;
    zero(a);
    assert(a == 0);

    int y = 3;
    two(y);
    assert(y == 2);
}
</pre>   <p>For dynamic array and class object parameters, which are always passed by reference, <code>out</code> and <code>ref</code> apply only to the reference and not the contents. </p>  <h3 id="lazy-params">Lazy Parameters</h3>  <p>An argument to a <code>lazy</code> parameter is not evaluated before the function is called. The argument is only evaluated if/when the parameter is evaluated within the function. Hence, a <code>lazy</code> argument can be executed 0 or more times. </p>   <pre data-language="d">import std.stdio : writeln;

void main()
{
    int x;
    3.times(writeln(x++));
    writeln("-");
    writeln(x);
}

void times(int n, lazy void exp)
{
    while (n--)
        exp();
}
</pre>   <p>prints to the console:</p>  <pre>0
1
2
−
3
</pre>  <p>A <code>lazy</code> parameter cannot be an lvalue.</p>  <p>The underlying delegate of the <code>lazy</code> parameter may be extracted by using the <code>&amp;</code> operator:</p>   <pre data-language="d">void test(lazy int dg)
{
    int delegate() dg_ = &amp;dg;
    assert(dg_() == 7);
    assert(dg == dg_());
}

void main()
{
    int a = 7;
    test(a);
}
</pre>   <p>A <code>lazy</code> parameter of type <code>void</code> can accept an argument of any type.</p>  <p>See Also: <a href="#lazy_variadic_functions">Lazy Variadic Functions</a></p>  <h3 id="function-default-args">Function Default Arguments</h3>  <p>Function parameter declarations can have default values:</p>  <pre data-language="d">void foo(int x, int y = 3)
{
    ...
}
...
foo(4);   // same as foo(4, 3);
</pre>  <p>Default parameters are resolved and semantically checked in the context of the function declaration.</p> <pre data-language="d">module m;
private immutable int b;
pure void g(int a=b){}
</pre> <pre data-language="d">import m;
int b;
pure void f()
{
  g();  // ok, uses m.b
}
</pre>  <p>The attributes of the <a href="expression.html#AssignExpression"><i>AssignExpression</i></a> are applied where the default expression is used.</p> <pre data-language="d">module m;
int b;
pure void g(int a=b){}
</pre> <pre data-language="d">import m;
enum int b = 3;
pure void f()
{
  g();  // error, cannot access mutable global `m.b` in pure function
}
</pre>  <p>If the default value for a parameter is given, all following parameters must also have default values. </p>  <h3 id="return-ref-parameters">Return Ref Parameters</h3>  <p>Return ref parameters are used with <a href="#ref-functions">ref functions</a> to ensure that the returned reference will not outlive the matching argument's lifetime. </p>  <pre data-language="d">ref int identity(return ref int x) {
  return x; // pass-through function that does nothing
}

ref int fun() {
  int x;
  return identity(x); // Error: escaping reference to local variable x
}

ref int gun(return ref int x) {
  return identity(x); // OK
}
</pre>  <p>Struct non-static methods marked with the <code>return</code> attribute ensure the returned reference will not outlive the struct instance. </p>  <pre data-language="d">struct S
{
    private int x;
    ref int get() return { return x; }
}

ref int escape()
{
    S s;
    return s.get(); // Error: escaping reference to local variable s
}
</pre>  <p>Returning the address of a <code>ref</code> variable is also checked.</p>  <pre data-language="d">int* pluto(ref int i)
{
    return &amp;i; // error: returning &amp;i escapes a reference to parameter i
}

int* mars(return ref int i)
{
    return &amp;i;  // ok
}
</pre>  <p>If the function returns <code>void</code>, and the first parameter is <code>ref</code> or <code>out</code>, then all subsequent <code>return ref</code> parameters are considered as being assigned to the first parameter for lifetime checking. The <code>this</code> reference parameter to a struct non-static member function is considered the first parameter.</p>  <p>If there are multiple <code>return ref</code> parameters, the lifetime of the return value is the smallest lifetime of the corresponding arguments.</p>  <p>Neither the type of the <code>return ref</code> parameter(s) nor the type of the return value is considered when determining the lifetime of the return value.</p>  <p>It is not an error if the return type does not contain any indirections.</p>  <pre data-language="d">int mercury(return ref int i)
{
    return i; // ok
}
</pre>  <p>Template functions, auto functions, nested functions and <a href="expression.html#function_literals">lambdas</a> can deduce the <code>return</code> attribute.</p>  <pre data-language="d">ref int templateFunction()(ref int i)
{
    return i; // ok
}

ref auto autoFunction(ref int i)
{
    return i; // ok
}

void uranus()
{
    ref int nestedFunction(ref int i)
    {
        return i; // ok
    }
}

void venus()
{
    auto lambdaFunction =
        (ref int i)
        {
            return &amp;i; // ok
        };
}
</pre>  <p><code>inout ref</code> parameters imply the <code>return</code> attribute.</p>  <pre data-language="d">inout(int)* neptune(inout ref int i)
{
    return &amp;i;  // ok
}
</pre>  <h3 id="scope-parameters">Scope Parameters</h3>  <p>A <code>scope</code> parameter of reference type must not escape the function call (e.g. by being assigned to a global variable). It has no effect for non-reference types. <code>scope</code> escape analysis is only done for <code>@safe</code> functions. For other functions <code>scope</code> semantics must be manually enforced.</p> <b>Note:</b> <code>scope</code> escape analysis is currently only done by the <code>dmd</code> compiler when the <code>-dip1000</code> switch is passed.  <pre data-language="d">@safe:

int* gp;
void thorin(scope int*);
void gloin(int*);
int* balin(scope int* q, int* r)
{
     gp = q; // error, q escapes to global gp
     gp = r; // ok

     thorin(q); // ok, q does not escape thorin()
     thorin(r); // ok

     gloin(q); // error, gloin() escapes q
     gloin(r); // ok that gloin() escapes r

     return q; // error, cannot return 'scope' q
     return r; // ok
}
</pre>  <p>As a <code>scope</code> parameter must not escape, the compiler can potentially avoid heap-allocating a unique argument to a <code>scope</code> parameter. Due to this, passing an array literal, delegate literal or a <a href="expression.html#NewExpression"><i>NewExpression</i></a> to a scope parameter may be allowed in a <code>@nogc</code> context, depending on the compiler implementation.</p>  <h3 id="return-scope-parameters">Return Scope Parameters</h3>  <p>Parameters marked as <code>return scope</code> that contain indirections can only escape those indirections via the function's return value.</p>  <pre data-language="d">@safe:

int* gp;
void thorin(scope int*);
void gloin(int*);
int* balin(return scope int* p)
{
     gp = p; // error, p escapes to global gp
     thorin(p); // ok, p does not escape thorin()
     gloin(p); // error, gloin() escapes p
     return p; // ok
}
</pre>  <p>Class references are considered pointers that are subject to <code>scope</code>.</p>  <pre data-language="d">@safe:

class C { }
C gp;
void thorin(scope C);
void gloin(C);
C balin(return scope C p, scope C q, C r)
{
     gp = p; // error, p escapes to global gp
     gp = q; // error, q escapes to global gp
     gp = r; // ok

     thorin(p); // ok, p does not escape thorin()
     thorin(q); // ok
     thorin(r); // ok

     gloin(p); // error, gloin() escapes p
     gloin(q); // error, gloin() escapes q
     gloin(r); // ok that gloin() escapes r

     return p; // ok
     return q; // error, cannot return 'scope' q
     return r; // ok
}
</pre>  <p><code>return scope</code> can be applied to the <code>this</code> of class and interface member functions.</p>  <pre data-language="d">class C
{
    C bofur() return scope { return this; }
}
</pre>  <p>Template functions, auto functions, nested functions and <a href="expression.html#function_literals">lambdas</a> can deduce the <code>return scope</code> attribute.</p>  <h3 id="ref-return-scope-parameters">Ref Return Scope Parameters</h3>  <p>Parameters marked as <code>ref return scope</code> come in two forms:</p>  <pre data-language="d">U xerxes(ref return scope V v);      // (1) ref and return scope
ref U sargon(ref return scope V v);  // (2) return ref and scope
</pre>  <p>The first form attaches the <code>return</code> to the <code>scope</code>, and has <a href="#return-scope-parameters">return scope parameter</a> semantics for the value of the <code>ref</code> parameter.</p>  <p>The second form attaches the <code>return</code> to the <code>ref</code>, and has <a href="#return-ref-parameters">return ref parameter</a> semantics with additional <a href="memory-safe-d.html#scope-return-params">scope parameter</a> semantics.</p>  <p>Although a struct constructor returns a reference to the instance being constructed, it is treated as form (1).</p>  <p>The lexical order of the attributes <code>ref</code>, <code>return</code>, and <code>scope</code> is not significant.</p>  <p>It is not possible to have both <code>return ref</code> and <code>return scope</code> semantics for the same parameter.</p>  <pre data-language="d">@safe:

struct S
{
    this(return scope ref int* p) { ptr = p; }

    int  val;
    int* ptr;
}

int* foo1(ref return scope S s);
int  foo2(ref return scope S s);

ref int* foo3(ref return scope S s);
ref int  foo4(ref return scope S s);

int* test1(scope S s)
{
    return foo1(s);  // Error: scope variable `s` may not be returned
    return foo3(s);  // Error: scope variable `s` may not be returned
}

int test2(S s)
{
    return foo2(s);
    return foo4(s);
}

ref int* test3(S s)
{
    return foo3(s);  // Error: returning `foo3(s)` escapes a reference to parameter `s`
}

ref int test4(S s)
{
    return foo4(s);  // Error: returning `foo4(s)` escapes a reference to parameter `s`
}

S test5(ref scope int* p)
{
    return S(p); // Error: scope variable `p` may not be returned
}

S test6(ref return scope int* p)
{
    return S(p);
}
</pre>  <h3 id="udas-parameters">User-Defined Attributes for Parameters</h3>  See also: <a href="attribute.html#UserDefinedAttribute"><i>User-Defined Attributes</i></a>  <h3 id="variadic">Variadic Functions</h3>  <p><i>Variadic Functions</i> take a variable number of arguments. There are three forms:</p>  <ol> <li><a href="#c_style_variadic_functions">C-style variadic functions</a></li> <li><a href="#d_style_variadic_functions">Variadic functions with type info</a></li> <li><a href="#typesafe-variadic_functions">Typesafe variadic functions</a></li> </ol>   <h4 id="c_style_variadic_functions">C-style Variadic Functions</h4>  <p>A C-style variadic function is declared with a parameter <code>...</code> as the last function parameter. It has non-D linkage, such as <code>extern (C)</code>.</p>  <p>To access the variadic arguments, import the standard library module <a href="https://dlang.org/phobos/core_stdc_stdarg.html"><code>core.stdc.stdarg</code></a>. </p>  <pre data-language="d">import core.stdc.stdarg;

extern (C) void dry(int x, int y, ...); // C-style Variadic Function

void spin()
{
    dry(3, 4);      // ok, no variadic arguments
    dry(3, 4, 6.8); // ok, one variadic argument
    dry(2);         // error, no argument for parameter y
}
</pre>  <p>There must be at least one non-variadic parameter declared.</p>  <pre data-language="d">extern (C) int def(...); // error, must have at least one parameter
</pre>  <p> C-style variadic functions match the C calling convention for variadic functions, and can call C Standard library functions like <code>printf</code>. </p>  <pre data-language="d">extern (C) int printf(const(char)*, ...);

void main()
{
    printf("hello world\n");
}
</pre>  <p>C-style variadic functions cannot be marked as <code>@safe</code>.</p>   <pre data-language="d">void wash()
{
    rinse(3, 4, 5);   // first variadic argument is 5
}

import core.stdc.stdarg;
extern (C) void rinse(int x, int y, ...)
{
    va_list args;
    va_start(args, y); // y is the last named parameter
    int z;
    va_arg(args, z);   // z is set to 5
    va_end(args);
}
</pre>   <h4 id="d_style_variadic_functions">D-style Variadic Functions</h4>  <p>D-style variadic functions have D linkage and <code>...</code> as the last parameter.</p>  <p><code>...</code> can be the only parameter.</p>  <p>If there are parameters preceding the <code>...</code> parameter, there must be a comma separating them from the <code>...</code>.</p>  <b>Note:</b> If the comma is ommitted, it is a <a href="#variadic">TypeSafe Variadic Function</a>.   <pre data-language="d">int abc(char c, ...);   // one required parameter: c
int def(...);           // no required parameters
int ghi(int i ...);     // a typesafe variadic function
//int boo(, ...);       // error
</pre>    <p>Two hidden arguments are passed to the function:</p>  <ul> <li><code>void* _argptr</code></li> <li><code>TypeInfo[] _arguments</code></li> </ul>  <p><code>_argptr</code> is a reference to the first of the variadic arguments. To access the variadic arguments, import <a href="https://dlang.org/phobos/core_vararg.html"><code>core.vararg</code></a>. Use <code>_argptr</code> in conjunction with <code>core.va_arg</code>:</p>  <pre data-language="d">import core.vararg;

void test()
{
    foo(3, 4, 5);   // first variadic argument is 5
}

@system void foo(int x, int y, ...)
{
    int z = va_arg!int(_argptr); // z is set to 5 and _argptr is advanced
                                 // to the next argument
}
</pre>  <code>_arguments</code> gives the number of arguments and the <code>typeid</code> of each, enabling type safety to be checked at run time.   <pre data-language="d">import std.stdio;

void main()
{
    Foo f = new Foo();
    Bar b = new Bar();

    writefln("%s", f);
    printargs(1, 2, 3L, 4.5, f, b);
}

class Foo { int x = 3; }
class Bar { long y = 4; }

import core.vararg;

@system void printargs(int x, ...)
{
    writefln("%d arguments", _arguments.length);
    for (int i = 0; i &lt; _arguments.length; i++)
    {
        writeln(_arguments[i]);

        if (_arguments[i] == typeid(int))
        {
            int j = va_arg!(int)(_argptr);
            writefln("\t%d", j);
        }
        else if (_arguments[i] == typeid(long))
        {
            long j = va_arg!(long)(_argptr);
            writefln("\t%d", j);
        }
        else if (_arguments[i] == typeid(double))
        {
            double d = va_arg!(double)(_argptr);
            writefln("\t%g", d);
        }
        else if (_arguments[i] == typeid(Foo))
        {
            Foo f = va_arg!(Foo)(_argptr);
            writefln("\t%s", f);
        }
        else if (_arguments[i] == typeid(Bar))
        {
            Bar b = va_arg!(Bar)(_argptr);
            writefln("\t%s", b);
        }
        else
            assert(0);
    }
}
</pre>   which prints:  <pre data-language="d">0x00870FE0
5 arguments
int
        2
long
        3
double
        4.5
Foo
        0x00870FE0
Bar
        0x00870FD0
</pre>  <p>D-style variadic functions cannot be marked as <code>@safe</code>.</p>   <h4 id="typesafe_variadic_functions">Typesafe Variadic Functions</h4>  <p>A typesafe variadic function has D linkage and a variadic parameter declared as either an array or a class. The array or class is constructed from the arguments, and is passed as an array or class object. </p>  <p>For dynamic arrays:</p>   <pre data-language="d">int sum(int[] ar ...) // typesafe variadic function
{
    int s;
    foreach (int x; ar)
        s += x;
    return s;
}

import std.stdio;

void main()
{
    writeln(stan());  // 6
    writeln(ollie()); // 15
}

int stan()
{
    return sum(1, 2, 3) + sum(); // returns 6+0
}

int ollie()
{
    int[3] ii = [4, 5, 6];
    return sum(ii);             // returns 15
}
</pre>   <p>For static arrays, the number of arguments must match the array dimension.</p>  <pre data-language="d">int sum(int[3] ar ...) // typesafe variadic function
{
    int s;
    foreach (int x; ar)
        s += x;
    return s;
}

int frank()
{
    return sum(2, 3);    // error, need 3 values for array
    return sum(1, 2, 3); // returns 6
}

int dave()
{
    int[3] ii = [4, 5, 6];
    int[] jj = ii;
    return sum(ii); // returns 15
    return sum(jj); // error, type mismatch
}
</pre>  <p>For class objects:</p>  <pre data-language="d">int tesla(int x, C c ...)
{
    return x + c.x;
}

class C
{
    int x;
    string s;

    this(int x, string s)
    {
        this.x = x;
        this.s = s;
    }
}

void edison()
{
    C g = new C(3, "abc");
    tesla(1, c);         // ok, since c is an instance of C
    tesla(1, 4, "def");  // ok
    tesla(1, 5);         // error, no matching constructor for C
}
</pre>  <p>The lifetime of the variadic class object or array instance ends at the end of the function. </p>  <pre data-language="d">C orville(C c ...)
{
    return c;   // error, c instance contents invalid after return
}

int[] wilbur(int[] a ...)
{
    return a;       // error, array contents invalid after return
    return a[0..1]; // error, array contents invalid after return
    return a.dup;   // ok, since copy is made
}
</pre>  <b>Implementation Defined:</b> the variadic object or array instance may be constructed on the stack.  <p>For other types, the argument is passed by value.</p>  <pre data-language="d">int neil(int i ...)
{
    return i;
}

void buzz()
{
    neil(3);    // returns 3
    neil(3, 4); // error, too many arguments
    int[] x;
    neil(x);    // error, type mismatch
}
</pre>  <h4 id="lazy_variadic_functions">Lazy Variadic Functions</h4>  <p>If the variadic parameter of a function is an array of delegates with no parameters, then each of the arguments whose type does not match that of the delegate is converted to a delegate of that type. </p>  <pre data-language="d">void hal(scope int delegate()[] dgs ...);

void dave()
{
    int delegate() dg;
    hal(1, 3+x, dg, cast(int delegate())null);   // (1)
    hal( { return 1; }, { return 3+x; }, dg, null ); // same as (1)
}
</pre>  <p>The variadic delegate array differs from using a lazy variadic array. With the former each array element access would evaluate every array element. With the latter, only the element being accessed would be evaluated.</p>  <pre data-language="d">import std.stdio;

void main()
{
    int x;
    ming(++x, ++x);

    int y;
    flash(++y, ++y);
}

// lazy variadic array
void ming(lazy int[] arr...)
{
    writeln(arr[0]); // 1
    writeln(arr[1]); // 4
}

// variadic delegate array
void flash(scope int delegate()[] arr ...)
{
    writeln(arr[0]); // 1
    writeln(arr[1]); // 2
}
</pre>  <b>Best Practices:</b> Use <code>scope</code> when declaring the array of delegates parameter. This will prevent a closure being generated for the delegate, as <code>scope</code> means the delegate will not escape the function.   <h2><span id="Local Variables">Local Variables</span></h2>  <p>Local variables are declared within the scope of a function. Function parameters are included.</p>  <p>A local variable cannot be read without first assigning it a value.</p>  <b>Implementation Defined:</b> The implementation may not always be able to detect these cases.   <p>The address of or reference to a local non-static variable cannot be returned from the function. </p>  <p>A local variable and a label in the same function cannot have the same name. </p>  <p>A local variable cannot hide another local variable in the same function. </p>  <b>Rationale:</b> whenever this is done it often is a bug or at least looks like a bug.   <pre data-language="d">ref double func(int x)
{
    int x;       // error, hides previous definition of x
    double y;
    {
        char y;  // error, hides previous definition of y
        int z;
    }
    {
        wchar z; // Ok, previous z is out of scope
    }
  z:             // error, z is a local variable and a label
    return y;    // error, returning ref to local
}
</pre>   <h3><span id="Local Static Variables">Local Static Variables</span></h3>  <p>Local variables in functions declared as <code>static</code>, <code>shared static</code> or <code>__gshared</code> are statically allocated rather than being allocated on the stack. The lifetime of <code>__gshared</code> and <code>shared static</code> variables begins when the function is first executed and ends when the program ends. The lifetime of <code>static</code> variables begins when the function is first executed within the thread and ends when that thread terminates. </p>   <pre data-language="d">void foo()
{
    static int n;
    if (++n == 100)
        writeln("called 100 times");
}
</pre>   <p>The initializer for a static variable must be evaluatable at compile time. There are no static constructors or static destructors for static local variables. </p>  <p>Although static variable name visibility follows the usual scoping rules, the names of them must be unique within a particular function. </p>  <pre data-language="d">void main()
{
    { static int x; }
    { static int x; } // error
    { int i; }
    { int i; } // ok
}
</pre>  <h2 id="nested">Nested Functions</h2>  <p>Functions may be nested within other functions:</p>   <pre data-language="d">int bar(int a)
{
    int foo(int b)
    {
        int abc() { return 1; }

        return b + abc();
    }
    return foo(a);
}

void test()
{
    int i = bar(3); // i is assigned 4
}
</pre>   <p>Nested functions can be accessed only if the name is in scope.</p>  <pre data-language="d">void foo()
{
    void A()
    {
        B(); // error, B() is forward referenced
        C(); // error, C undefined
    }
    void B()
    {
        A(); // ok, in scope
        void C()
        {
            void D()
            {
                A();      // ok
                B();      // ok
                C();      // ok
                D();      // ok
            }
        }
    }
    A(); // ok
    B(); // ok
    C(); // error, C undefined
}
</pre>  and:  <pre data-language="d">int bar(int a)
{
    int foo(int b) { return b + 1; }
    int abc(int b) { return foo(b); }   // ok
    return foo(a);
}

void test()
{
    int i = bar(3);     // ok
    int j = bar.foo(3); // error, bar.foo not visible
}
</pre>  <p>Nested functions have access to the variables and other symbols defined by the lexically enclosing function. This access includes both the ability to read and write them. </p>   <pre data-language="d">int bar(int a)
{
    int c = 3;

    int foo(int b)
    {
        b += c;       // 4 is added to b
        c++;          // bar.c is now 5
        return b + c; // 12 is returned
    }
    c = 4;
    int i = foo(a); // i is set to 12
    return i + c;   // returns 17
}

void test()
{
    int i = bar(3); // i is assigned 17
}
</pre>   <p>This access can span multiple nesting levels:</p>   <pre data-language="d">int bar(int a)
{
    int c = 3;

    int foo(int b)
    {
        int abc()
        {
            return c;   // access bar.c
        }
        return b + c + abc();
    }
    return foo(3);
}
</pre>   <p>Static nested functions cannot access any stack variables of any lexically enclosing function, but can access static variables. This is analogous to how static member functions behave. </p>  <pre data-language="d">int bar(int a)
{
    int c;
    static int d;

    static int foo(int b)
    {
        b = d;          // ok
        b = c;          // error, foo() cannot access frame of bar()
        return b + 1;
    }
    return foo(a);
}
</pre>  <p>Functions can be nested within member functions:</p>   <pre data-language="d">struct Foo
{
    int a;

    int bar()
    {
        int c;

        int foo()
        {
            return c + a;
        }
        return 0;
    }
}
</pre>   <p>Nested functions always have the D function linkage type. </p>  <p>Unlike module level declarations, declarations within function scope are processed in order. This means that two nested functions cannot mutually call each other: </p>  <pre data-language="d">void test()
{
    void foo() { bar(); } // error, bar not defined
    void bar() { foo(); } // ok
}
</pre>  <p>There are several workarounds for this limitation:</p>  <ul> <li>Declare the functions to be static members of a nested struct:</li>  </ul>
<pre data-language="d">void test()
{
    static struct S
    {
        static void foo() { bar(); } // ok
        static void bar() { foo(); } // ok
    }

    S.foo();  // compiles (but note the infinite runtime loop)
}
</pre>  <li>Declare one or more of the functions to be function templates even if they take no specific template arguments:</li>   <pre data-language="d">void test()
{
    void foo()() { bar(); } // ok (foo is a function template)
    void bar()   { foo(); } // ok
}
</pre>   <li>Declare the functions inside of a mixin template:</li>   <pre data-language="d">mixin template T()
{
    void foo() { bar(); } // ok
    void bar() { foo(); } // ok
}

void main()
{
    mixin T!();
}
</pre>   <li>Use a delegate:</li>   <pre data-language="d">void test()
{
    void delegate() fp;
    void foo() { fp(); }
    void bar() { foo(); }
    fp = &amp;bar;
}
</pre>    <p>Nested functions cannot be overloaded.</p>  <h2 id="closures">Delegates, Function Pointers, and Closures</h2>  <p>A function pointer can point to a static nested function:</p>   <pre data-language="d">int function() fp;  // fp is a pointer to a function returning an int

void test()
{
    static int a = 7;
    static int foo() { return a + 3; }

    fp = &amp;foo;
}

void bar()
{
    test();
    int i = fp();       // i is set to 10
}
</pre>   <b>Implementation Defined:</b> Two functions with identical bodies, or two functions that compile to identical assembly code, are not guaranteed to have distinct function pointer values. The implementation may merge functions bodies into one if they compile to identical code.   <pre data-language="d">int abc(int x)   { return x + 1; }
uint def(uint y) { return y + 1; }

int delegate(int)   fp1 = &amp;abc;
uint delegate(uint) fp2 = &amp;def;
// Do not rely on fp1 and fp2 being different values; the compiler may merge
// them.
</pre>   <p>A delegate can be set to a non-static nested function:</p>   <pre data-language="d">int delegate() dg;

void test()
{
    int a = 7;
    int foo() { return a + 3; }

    dg = &amp;foo;
    int i = dg(); // i is set to 10
}
</pre>   <p>The stack variables referenced by a nested function are still valid even after the function exits (NOTE this is different from D 1.0.) This is called a <i>closure</i>. </p>  <p>Those referenced stack variables that make up the closure are allocated on the GC heap. Closures are not allowed for <code>@nogc</code> functions.</p>  <b>Note:</b> Returning addresses of stack variables, however, is not a closure and is an error.   <pre data-language="d">void bar()
{
    int b;
    test();
    int i = dg(); // ok, test.a is in a closure and still exists
}
</pre>  <p>Delegates to non-static nested functions contain two pieces of data: the pointer to the stack frame of the lexically enclosing function (called the <i>context pointer</i>) and the address of the function. This is analogous to struct/class non-static member function delegates consisting of a <i>this</i> pointer and the address of the member function. Both forms of delegates are indistinguishable, and are the same type. </p>   <pre data-language="d">struct Foo
{
    int a = 7;
    int bar() { return a; }
}

int foo(int delegate() dg)
{
    return dg() + 1;
}

void test()
{
    int x = 27;
    int abc() { return x; }
    Foo f;
    int i;

    i = foo(&amp;abc);   // i is set to 28
    i = foo(&amp;f.bar); // i is set to 8
}
</pre>   <p>This combining of the environment and the function is called a <i>dynamic closure</i>. </p>  <p>The <code>.ptr</code> property of a delegate will return the <i>context pointer</i> value as a <code>void*</code>. </p>  <p>The <code>.funcptr</code> property of a delegate will return the <i>function pointer</i> value as a function type. </p>  <p>Function pointers are zero-initialized by default. They can be initialized to the address of any function (including a function literal). Initialization with the address of a function that requires a context pointer is not allowed in @safe functions. </p>  <pre data-language="d">struct S
{
    static int sfunc();
    int member();   // has hidden `this` reference parameter
}

@safe void sun()
{
    int function() fp = &amp;S.sfunc;
    fp(); // Ok
    fp = &amp;S.member; // error
}

@system void moon()
{
    int function() fp = &amp;S.member; // Ok because @system
    fp(); // undefined behavior
}
</pre>  <p>Delegates are zero-initialized by default. They can be initialized by taking the address of a non-static member function, but a context pointer must be supplied. They can be initialized by taking the address of a non-static nested function or function literal, where the context pointer will be set to point to the stack frame, closure, or <code>null</code>. </p>  <p>Delegates cannot be initialized by taking the address of a global function, a static member function, or a static nested function. </p>  <pre data-language="d">struct S
{
    static int sfunc();
    int member() { return 1; }
}

void main()
{
    S s;
    int delegate() dg = &amp;s.member; // Ok, s supplies context pointer
    assert(dg() == 1);

    dg = &amp;S.sfunc;  // error
    dg = &amp;S.member; // error

    int moon() { return 2; }
    dg = &amp;moon;     // Ok
    assert(dg() == 2);

    static int mars() { return 3; }
    dg = &amp;mars;     // error

    dg = () { return 4; }; // Ok
    assert(dg() == 4);
}
</pre>  <b>Note:</b> Function pointers can be passed to functions taking a delegate argument by passing them through the <a href="https://dlang.org/phobos/std_functional.html#toDelegate"><code>std.functional.toDelegate</code></a> template, which converts any callable to a delegate with a <code>null</code> context pointer.    <h3 id="anonymous">Anonymous Functions and Anonymous Delegates</h3>  <p>See <a href="expression.html#FunctionLiteral"><i>FunctionLiteral</i></a>s. </p>  <h2 id="main">
<code>main()</code> Function</h2>  <p>For console programs, <code>main()</code> serves as the entry point. It gets called after all the module initializers are run, and after any unittests are run. After it returns, all the module destructors are run. <code>main()</code> must be declared using one of the following forms: </p>  <ul> <li><code>void main() { ... }</code></li> <li><code>void main(string[] args) { ... }</code></li> <li><code>int main() { ... }</code></li> <li><code>int main(string[] args) { ... }</code></li> </ul>  <p>The main function must have D linkage.</p>  <p>Attributes may be added as needed, e.g. <code>@safe</code>, <code>@nogc</code>, <code>nothrow</code>, etc.</p>  <h3 id="betterc-main">BetterC <code>main()</code> Function</h3>  <p>For <b>BetterC</b> programs, the main function is declared using one of the following forms:</p>  <ul> <li><code>extern (C) int main() { ... }</code></li> <li><code>extern (C) int main(int argc, char** argv) { ... }</code></li> </ul>  <p>This takes the place of the C main function and serves the identical purpose.</p>  <p>Module constructors, module destructors, and unittests are not run.</p>  <b>Implementation Defined:</b> Other system-specific entry points may exist, such as <code>WinMain</code> and <code>DllMain</code> on Windows systems.    <h2 id="function-templates">Function Templates</h2>  <p>Functions can have compile time arguments in the form of a template. See <a href="template.html#function-templates">function templates</a>.</p>   <h2 id="interpretation">Compile Time Function Execution (CTFE)</h2>  <p>In contexts where a compile time value is required, functions can be used to compute those values. This is called <i>Compile Time Function Execution</i>, or <i>CTFE</i>.</p>  <p>These contexts are:</p>  <ul> <li>initialization of a static variable or a <a href="enum.html#manifest_constants">manifest constant</a>
</li> <li>static initializers of struct/class members</li> <li>dimension of a <a href="arrays.html#static-arrays">static array</a>
</li> <li>argument for a <a href="template.html#template_value_parameter"> template value parameter</a>
</li> <li><a href="version.html#staticif"><code>static if</code></a></li> <li><a href="version.html#staticforeach"><code>static foreach</code></a></li> <li><a href="version.html#static-assert"><code>static assert</code></a></li> <li><a href="statement.html#mixin-statement"> <code>mixin</code> statement</a></li> <li><a href="pragma.html"><code>pragma</code> argument</a></li> <li><a href="traits.html"><code>__traits</code> argument</a></li> </ul>   <pre data-language="d">enum eval(Args...) = Args[0];

int square(int i)
{
    return i * i;
}

void foo()
{
    static j = square(3);      // CTFE
    writeln(j);
    assert(square(4));         // run time
    static assert(square(3) == 9); // CTFE
    writeln(eval!(square(5))); // CTFE
}
</pre>   <p>The function must have a <a href="#SpecifiedFunctionBody"><i>SpecifiedFunctionBody</i></a>.</p>  <p>CTFE is subject to the following restrictions:</p>  <ol> <li>Expressions may not reference any global or local static variables.</li>  <li>
<a href="https://dlang.org/iasm.html#asmstatements">AsmStatements</a> are not permitted</li>  <li>Non-portable casts (eg, from <code>int[]</code> to <code>float[]</code>), including casts which depend on endianness, are not permitted. Casts between signed and unsigned types are permitted.</li>  <li>Reinterpretation of overlapped fields in a union is not permitted.</li> </ol>  <p>Pointers are permitted in CTFE, provided they are used safely:</p>  <ul> <li> Pointer arithmetic is permitted only on pointers which point to static or dynamic array elements. A pointer may also point to the first element past the array, although such pointers cannot be dereferenced. Pointer arithmetic on pointers which are null, or which point to a non-array, is not allowed. </li>  <li> Ordered comparison (<code>&lt;</code>, <code>&lt;</code><code>=</code>, <code>&gt;</code>, <code>&gt;=</code>) between two pointers is permitted when both pointers point to the same array, or when at least one pointer is <code>null</code>. </li>  <li> Pointer comparisons between discontiguous memory blocks are illegal, unless two such comparisons are combined using <code>&amp;&amp;</code> or <code>|</code><code>|</code> to yield a result which is independent of the ordering of memory blocks. Each comparison must consist of two pointer expressions compared with <code>&lt;</code>, <code>&lt;</code><code>=</code>, <code>&gt;</code>, or <code>&gt;</code><code>=</code>, and may optionally be negated with <code>!</code>. For example, the expression <code>(p1 &gt; q1 &amp;&amp; p2 &lt;= q2)</code> is permitted when <code>p1</code>, <code>p2</code> are expressions yielding pointers to memory block <i>P</i>, and <code>q1</code>, <code>q2</code> are expressions yielding pointers to memory block <i>Q</i>, even when <i>P</i> and <i>Q</i> are unrelated memory blocks. It returns true if <code>[p1..p2]</code> lies inside <code>[q1..q2]</code>, and false otherwise. Similarly, the expression <code>(p1 &lt; q1 || p2 &gt; q2)</code> is true if <code>[p1..p2]</code> lies outside <code>[q1..q2]</code>, and false otherwise. </li>  <li> Equality comparisons (==, !=, <span class="d_keyword">is</span>, <span class="d_keyword">!is</span>) are permitted between all pointers, without restriction. </li>  <li> Any pointer may be cast to <code>void*</code> and from <code>void*</code> back to its original type. Casting between pointer and non-pointer types is illegal. </li> </ul>  <p>The above restrictions apply only to expressions which are actually executed. For example: </p> <pre data-language="d">static int y = 0;

int countTen(int x)
{
    if (x &gt; 10)
        ++y;    // access static variable
    return x;
}

static assert(countTen(6) == 6);    // OK
static assert(countTen(12) == 12);  // invalid, modifies y.
</pre> <p>The <code>__ctfe</code> boolean pseudo-variable evaluates to <span class="d_keyword">true</span> during CTFE but <span class="d_keyword">false</span> otherwise. </p>  <b>Note:</b> <code>__ctfe</code> can be used to provide an alternative execution path to avoid operations which are forbidden in CTFE. Every usage of <code>__ctfe</code> is statically evaluated and has no run-time cost. )  <p>Non-recoverable errors (such as <span class="d_keyword">assert</span> failures) are illegal. </p>  <b>Implementation Defined:</b> Executing functions via CTFE can take considerably longer than executing it at run time. If the function goes into an infinite loop, it may cause the compiler to hang.   <b>Implementation Defined:</b> Functions executed via CTFE can give different results from run time when implementation-defined or undefined-behavior occurs.    <h3 id="string-mixins">String Mixins and Compile Time Function Execution</h3>  <p>All functions that execute in CTFE must also be executable at run time. The compile time evaluation of a function does the equivalent of running the function at run time. The semantics of a function cannot depend on compile time values of the function. For example:</p>  <pre data-language="d">int foo(string s)
{
    return mixin(s);
}

const int x = foo("1");
</pre>   is illegal, because the runtime code for <code>foo</code> cannot be generated.  <b>Best Practices:</b> A function template, where <code>s</code> is a template argument, would be the appropriate method to implement this sort of thing.    <h2 id="nogc-functions">No-GC Functions</h2>  <p>No-GC functions are functions marked with the <code>@nogc</code> attribute. Those functions do not allocate memory on the GC heap. These operations are not allowed in No-GC functions: </p>  <ol> <li>
<a href="https://dlang.org/expression.html#ArrayLiteral">constructing an array</a> on the heap</li> <li>resizing an array by writing to its <code>.length</code> property</li> <li><a href="https://dlang.org/expression.html#CatExpression">array concatenation</a></li> <li><a href="https://dlang.org/expression.html#simple_assignment_expressions">array appending</a></li> <li><a href="https://dlang.org/expression.html#AssocArrayLiteral">constructing an associative array</a></li> <li>
<a href="https://dlang.org/expression.html#IndexExpression">indexing</a> an associative array <b>Note:</b> because it may throw <code>RangeError</code> if the specified key is not present</li> <li>
<a href="https://dlang.org/expression.html#NewExpression">allocating an object with <code>new</code></a> on the heap</li> <li>calling functions that are not <code>@nogc</code>, unless the call is in a <a href="version.html#ConditionalStatement"><i>ConditionalStatement</i></a> controlled by a <a href="version.html#DebugCondition"><i>DebugCondition</i></a>
</li> </ol>  <pre data-language="d">@nogc void foo()
{
    auto a = ['a'];    // (1) error, allocates
    a.length = 1;      // (2) error, array resizing allocates
    a = a ~ a;         // (3) error, arrays concatenation allocates
    a ~= 'c';          // (4) error, appending to arrays allocates

    auto aa = ["x":1]; // (5) error, allocates
    aa["abc"];         // (6) error, indexing may allocate and throws

    auto p = new int;  // (7) error, operator new allocates
    bar();             // (8) error, bar() may allocate
    debug bar();       // (8) Ok
}
void bar() { }
</pre>  <p>No-GC functions cannot be closures. </p>  <pre data-language="d">@nogc int delegate() foo()
{
    int n;              // error, variable n cannot be allocated on heap
    return (){ return n; } // since `n` escapes `foo()`, a closure is required
}
</pre>  <p><code>@nogc</code> affects the type of the function. A <code>@nogc</code> function is covariant with a non-<code>@nogc</code> function. </p>  <pre data-language="d">void function() fp;
void function() @nogc gp;  // pointer to @nogc function

void foo();
@nogc void bar();

void test()
{
    fp = &amp;foo; // ok
    fp = &amp;bar; // ok, it's covariant
    gp = &amp;foo; // error, not contravariant
    gp = &amp;bar; // ok
}
</pre>   <h2 id="function-safety">Function Safety</h2>  <h3 id="safe-functions">Safe Functions</h3>  <p>Safe functions are marked with the <code>@safe</code> attribute. <code>@safe</code> can be inferred, see <a href="#function-attribute-inference">Function Attribute Inference</a>.</p>  <p>Safe functions have <a href="#safe-interfaces">safe interfaces</a>. An implementation must enforce this by restricting the function's body to operations that are known safe.</p>  <p>The following operations are not allowed in safe functions:</p>  <ul> <li>No casting from a pointer type to any type with pointers other than <code>void*</code>.</li> <li>No casting from any non-pointer type to a pointer type.</li> <li>No pointer arithmetic (including pointer indexing).</li> <li>Cannot access unions that have pointers or references overlapping with other types.</li> <li>Calling any <a href="#system-functions">System Functions</a>.</li> <li>No catching of exceptions that are not derived from <a href="https://dlang.org/phobos/object.html#Exception"><code>class Exception</code></a>.</li> <li>No inline assembler.</li> <li>No explicit casting of mutable objects to immutable.</li> <li>No explicit casting of immutable objects to mutable.</li> <li>No explicit casting of thread local objects to shared.</li> <li>No explicit casting of shared objects to thread local.</li> <li>Cannot access <code>__gshared</code> variables.</li> <li>Cannot use <code>void</code> initializers for pointers.</li> <li>Cannot use <code>void</code> initializers for class or interface references.</li> </ul>  <p>When indexing or slicing an array, an out of bounds access will cause a runtime error.</p> )  <p>Functions nested inside safe functions default to being safe functions. </p>  <p>Safe functions are covariant with trusted or system functions.</p>  <b>Best Practices:</b> Mark as many functions <code>@safe</code> as practical.  <h4>Safe External Functions</h4>  <p>External functions don't have a function body visible to the compiler: </p> <pre data-language="d">@safe extern (C) void play();
</pre> and so safety cannot be verified automatically.  <b>Best Practices:</b> Explicitly set an attribute for external functions rather than relying on default settings.  <h3 id="trusted-functions">Trusted Functions</h3>  <p>Trusted functions are marked with the <code>@trusted</code> attribute.</p>  <p>Like <a href="#safe-functions">safe functions</a>, trusted functions have <a href="#safe-interfaces">safe interfaces</a>. Unlike safe functions, this is not enforced by restrictions on the function body. Instead, it is the responsibility of the programmer to ensure that the interface of a trusted function is safe.</p>  <p>Example:</p>  <pre data-language="d">immutable(int)* f(int* p) @trusted
{
    version (none) p[2] = 13;
    // Invalid. p[2] is out of bounds. This line would exhibit undefined
    // behavior.

    version (none) p[1] = 13;
    // Invalid. In this program, p[1] happens to be in-bounds, so the
    // line would not exhibit undefined behavior, but a trusted function
    // is not allowed to rely on this.

    version (none) return cast(immutable) p;
    // Invalid. @safe code still has mutable access and could trigger
    // undefined behavior by overwriting the value later on.

    int* p2 = new int;
    *p2 = 42;
    return cast(immutable) p2;
    // Valid. After f returns, no mutable aliases of p2 can exist.
}

void main() @safe
{
    int[2] a = [10, 20];
    int* mp = &amp;a[0];
    immutable(int)* ip = f(mp);
    assert(a[1] == 20); // Guaranteed. f cannot access a[1].
    assert(ip !is mp); // Guaranteed. f cannot introduce unsafe aliasing.
}
</pre>  <p>Trusted functions may call safe, trusted, or system functions. </p>  <p>Trusted functions are covariant with safe or system functions.</p>  <b>Best Practices:</b> Trusted functions should be kept small so that they are easier to manually verify.   <h3 id="system-functions">System Functions</h3>  <p>System functions are functions not marked with <code>@safe</code> or <code>@trusted</code> and are not nested inside <code>@safe</code> functions. System functions may be marked with the <code>@system</code> attribute. A function being system does not mean it actually is unsafe, it just means that its safety must be manually verified. </p>  <p>System functions are <b>not</b> covariant with trusted or safe functions. </p>  <p>System functions can call safe and trusted functions.</p>  <b>Best Practices:</b> When in doubt, mark <code>extern (C)</code> and <code>extern (C++)</code> functions as <code>@system</code> when their implementations are not in D, as the D compiler will be unable to check them. Most of them are <code>@safe</code>, but will need to be manually checked.  <b>Best Practices:</b> The number and size of system functions should be minimized. This minimizes the work necessary to manually check for safety.  <h3 id="safe-interfaces">Safe Interfaces</h3>  <p>When it is only called with <a href="#safe-values">safe values</a> and <a href="#safe-aliasing">safe aliasing</a>, a function has a safe interface when:</p> <ol> <li>it cannot exhibit <a href="https://dlang.org/glossary.html#undefined_behavior">undefined behavior</a>, and</li> <li>it cannot create unsafe values that are accessible from other parts of the program (e.g., via return values, global variables, or <code>ref</code> parameters), and</li> <li>it cannot introduce unsafe aliasing that is accessible from other parts of the program.</li> </ol>  <p>Functions that meet these requirements may be <a href="#safe-functions"><code>@safe</code></a> or <a href="#trusted-functions"><code>@trusted</code></a>. Function that do not meet these requirements can only be <a href="#system-functions"><code>@system</code></a>.</p>  <p>Examples:</p>  <ul> <li> C's <code>free</code> does not have a safe interface: <pre data-language="d">extern (C) @system void free(void* ptr);
</pre> because <code>free(p)</code> invalidates <code>p</code>, making its value unsafe. <code>free</code> can only be <code>@system</code>. </li> <li> C's <code>strlen</code> and <code>memcpy</code> do not have safe interfaces: <pre data-language="d">extern (C) @system size_t strlen(char* s);
extern (C) @system void* memcpy(void* dst, void* src, size_t nbytes);
</pre> because they iterate pointers based on unverified assumptions (<code>strlen</code> assumes that <code>s</code> is zero-terminated; <code>memcpy</code> assumes that the memory objects pointed to by <code>dst</code> and <code>src</code> are at least <code>nbytes</code> big). Any function that traverses a C string passed as an argument can only be <code>@system</code>. Any function that trusts a separate parameter for array bounds can only be <code>@system</code>. </li> <li> C's <code>malloc</code> does have a safe interface: <pre data-language="d">extern (C) @trusted void* malloc(size_t sz);
</pre> It does not exhibit undefined behavior for any input. It returns either a valid pointer, which is safe, or <code>null</code> which is also safe. It returns a pointer to a fresh allocation, so it cannot introduce any unsafe aliasing. <b>Note:</b> The implementation of <code>malloc</code> is most likely @system code. </li> <li> A D version of <code>memcpy</code> can have a safe interface:  <pre data-language="d">@safe void memcpy(E)(E[] src, E[] dst)
{
    import std.math : min;
    foreach (i; 0 .. min(src.length, dst.length))
    {
        dst[i] = src[i];
    }
}
</pre>  because the rules for <a href="#safe-values">safe values</a> ensure that the lengths of the arrays are correct. </li> </ul>  <h3 id="safe-values">Safe Values</h3>  <p>For <a href="type.html#basic-data-types">basic data types</a>, all possible bit patterns are safe.</p>  <p>A pointer is a safe value when it is one of:</p> <ol> <li><code>null</code></li> <li>it points to a memory object that is live and the pointed to value in that memory object is safe.</li> </ol> <p>Examples:</p>  <pre data-language="d">int* n = null; /* n is safe because dereferencing null is a well-defined
    crash. */
int* x = cast(int*) 0xDEADBEEF; /* x is (most likely) unsafe because it
    is not a valid pointer and cannot be dereferenced. */

import core.stdc.stdlib: malloc, free;
int* p1 = cast(int*) malloc(int.sizeof); /* p1 is safe because the
    pointer is valid and *p1 is safe regardless of its actual value. */
free(p1); /* This makes p1 unsafe. */
int** p2 = &amp;p1; /* While it can be dereferenced, p2 is unsafe because p1
    is unsafe. */
p1 = null; /* This makes p1 and p2 safe. */
</pre>   <p>A dynamic array is safe when:</p> <ol> <li>its pointer is safe, and</li> <li>its length is in-bounds with the corresponding memory object, and</li> <li>all its elements are safe.</li> </ol>  <p>Examples:</p>  <pre data-language="d">int[] f() @system
{
    int[3] a;
    int[] d1 = a[0 .. 2]; /* d1 is safe. */
    int[] d2 = a.ptr[0 .. 3]; /* d2 is unsafe because it goes beyond a's
        bounds. */
    int*[] d3 = [cast(int*) 0xDEADBEEF]; /* d3 is unsafe because the
        element is unsafe. */
    return d1; /* Up to here, d1 was safe, but its pointer becomes
        invalid when the function returns, so the returned dynamic array
        is unsafe. */
}
</pre>   <p>A static array is safe when all its elements are safe. Regardless of the element type, a static array with length zero is always safe.</p>  <p>An associative array is safe when all its keys and elements are safe.</p>  <p>A struct/union instance is safe when:</p> <ol> <li>the values of its accessible fields are safe, and</li> <li>it does not introduce <a href="#safe-aliasing">unsafe aliasing</a> with unions.</li> </ol>  <p>Examples:</p>  <pre data-language="d">struct S { int* p; }
S s1 = S(new int); /* s1 is safe. */
S s2 = S(cast(int*) 0xDEADBEEF); /* s2 is unsafe, because s2.p is
    unsafe. */

union U { int* p; size_t x; }
U u = U(new int); /* Even though both u.p and u.x are safe, u is unsafe
    because of unsafe aliasing. */
</pre>   <p>A class reference is safe when it is <code>null</code> or:</p> <ol> <li>it refers to a valid class instance of the class type or a type derived from the class type, and</li> <li>the values of the instance's accessible fields are safe, and</li> <li>it does not introduce unsafe aliasing with unions.</li> </ol>  <p>A function pointer is safe when it is <code>null</code> or it refers to a valid function that has the same or a covariant signature.</p>  <p>A <code>delegate</code> is safe when:</p> <ol> <li>its <code>.funcptr</code> property is <code>null</code> or refers to a function that matches or is covariant with the delegate type, and</li> <li>its <code>.ptr</code> property is <code>null</code> or refers to a memory object that is in a form expected by the function.</li> </ol>  <h3 id="safe-aliasing">Safe Aliasing</h3>  <p>When one memory location is accessible with two different types, that aliasing is considered safe if:</p> <ol> <li>both types are <code>const</code> or <code>immutable</code>; or</li> <li>one of the types is mutable while the other is a <code>const</code>-qualified <a href="type.html#basic-data-types">basic data type</a>; or</li> <li>both types are mutable basic data types; or</li> <li>one of the types is a static array type with length zero; or</li> <li>one of the types is a static array type with non-zero length, and aliasing of the array's element type and the other type is safe; or</li> <li>both types are pointer types, and aliasing of the target types is safe, and the target types have the same size.</li> </ol>  <p>All other cases of aliasing are considered unsafe.</p>  <b>Note:</b> Safe aliasing may be exposed to functions with <a href="#safe-interfaces">safe interfaces</a> without affecting their guaranteed safety. Unsafe aliasing does not guarantee safety.  <b>Note:</b> Safe aliasing does not imply that all aliased views of the data have <a href="#safe-values">safe values</a>. Those must examined separately for safety.  <p>Examples:</p>  <pre data-language="d">void f1(ref ubyte x, ref float y) @safe { x = 0; y = float.init; }
union U1 { ubyte x; float y; } // safe aliasing
U1 u1;
f1(u1.x, u1.y); // Ok

void f2(ref int* x, ref int y) @trusted { x = new int; y = 0xDEADBEEF; }
union U2 { int* x; int y; } // unsafe aliasing
U2 u2;
version (none) f1(u2.x, u2.y); // not safe
</pre>   <h2 id="function-attribute-inference">Function Attribute Inference</h2>  <p><a href="expression.html#FunctionLiteral"><i>FunctionLiteral</i></a>s, <a href="#auto-functions">Auto Functions</a>, <a href="#auto-ref-functions">Auto Ref Functions</a>, <a href="#nested">nested functions</a> and <a href="template.html#function-templates">function templates</a>, since their function bodies are always present, infer the <a href="#pure-functions"><code>pure</code></a>, <a href="#nothrow-functions"><code>nothrow</code></a>, <a href="#safe-functions"><code>@safe</code></a>, <a href="#nogc-functions"><code>@nogc</code></a>, <a href="#return-ref-parameters">return ref parameters</a>, <a href="#scope-parameters">scope parameters</a>, <a href="#return-scope-parameters">return scope parameters</a> and <a href="#ref-return-scope-parameters">ref return scope parameters</a> attributes unless specifically overridden. </p>  <p>Attribute inference is not done for other functions, even if the function body is present. </p>  <p>The inference is done by determining if the function body follows the rules of the particular attribute. </p>  <p>Cyclic functions (i.e. functions that wind up directly or indirectly calling themselves) are inferred as being impure, throwing, and @system. </p>  <p>If a function attempts to test itself for those attributes, then the function is inferred as not having those attributes. </p>  <b>Rationale:</b> Function attribute inference greatly reduces the need for the user to add attributes to functions, especially for templates.  <h2 id="pseudo-member">Uniform Function Call Syntax (UFCS)</h2>  <p>A free function can be called with a syntax equivalent to that of a member function of its first parameter type. The free function is called a <i>UFCS function</i>. </p>  <pre data-language="d">void sun(T, int);

void moon(T t)
{
    t.sun(1);
    // If `T` does not have member function `sun`,
    // `t.sun(1)` is interpreted as if it were written `sun(t, 1)`
}
</pre>  <b>Rationale:</b> This provides a way to add external functions to a class as if they were public final member functions. This enables minimizing the number of functions in a class to only the essentials that are needed to take care of the object's private state, without the temptation to add a kitchen-sink's worth of member functions. It also enables <a href="http://www.drdobbs.com/architecture-and-design/component-programming-in-d/240008321"> function chaining and component programming</a>.   <p>A more complex example:</p>  <pre data-language="d">stdin.byLine(KeepTerminator.yes)
    .map!(a =&gt; a.idup)
    .array
    .sort
    .copy(stdout.lockingTextWriter());
</pre>  <p>is the equivalent of:</p>  <pre data-language="d">copy(sort(array(map!(a =&gt; a.idup)(byLine(stdin, KeepTerminator.yes))), lockingTextWriter(stdout));
</pre>  <p>UFCS works with <code>@property</code> functions:</p>  <pre data-language="d">@property prop(X thisObj);
@property prop(X thisObj, int value);

X obj;
obj.prop;      // if X does not have member prop, reinterpret as prop(obj);
obj.prop = 1;  // similarly, reinterpret as prop(obj, 1);
</pre>  <p>Functions declared in a local scope are not found when searching for a matching UFCS function.</p>  <p>Member functions are not found when searching for a matching UFCS function.</p>  <p>Otherwise, UFCS function lookup proceeds normally.</p>  <pre data-language="d">module a;
void foo(X);
alias boo = foo;
void main()
{
    void bar(X);     // bar declared in local scope
    import b : baz;  // void baz(X);

    X obj;
    obj.foo();    // OK, calls a.foo;
    //obj.bar();  // NG, UFCS does not see nested functions
    obj.baz();    // OK, calls b.baz, because it is declared at the
                  // top level scope of module b

    import b : boo = baz;
    obj.boo();    // OK, calls aliased b.baz instead of a.boo (== a.foo),
                  // because the declared alias name 'boo' in local scope
                  // overrides module scope name
}
class C
{
    void mfoo(X);           // member function
    static void sbar(X);    // static member function
    import b : ibaz = baz;  // void baz(X);
    void test()
    {
        X obj;
        //obj.mfoo();  // NG, UFCS does not see member functions
        //obj.sbar();  // NG, UFCS does not see static member functions
        obj.ibaz();    // OK, ibaz is an alias of baz which declared at
                       //     the top level scope of module b
    }
}
</pre>  <b>Rationale:</b> Local function symbols are not considered by UFCS to avoid unexpected name conflicts. See below problematic examples.  <pre data-language="d">int front(int[] arr) { return arr[0]; }

void main()
{
    int[] a = [1,2,3];
    auto x = a.front();   // call .front by UFCS

    auto front = x;       // front is now a variable
    auto y = a.front();   // Error, front is not a function
}

class C
{
    int[] arr;
    int front()
    {
        return arr.front(); // Error, C.front is not callable
                            // using argument types (int[])
    }
}
</pre>       )<div class="_attribution">
  <p class="_attribution-p">
    &copy; 1999&ndash;2021 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/spec/function" class="_attribution-link">https://dlang.org/spec/function</a>
  </p>
</div>
