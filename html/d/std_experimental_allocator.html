<h1>std.experimental.allocator</h1>  <p>High-level interface for allocators. Implements bundled allocation/creation and destruction/deallocation of data including <code>struct</code>s and <code>class</code>es, and also array primitives related to allocation. This module is the entry point for both making use of allocators and for their documentation. </p>
<p> <table>

<tr>
<th scope="col">Category</th> <th scope="col">Functions</th>
</tr> <tr>
<td>Make</td> <td> <a href="#make"><code>make</code></a> <a href="#makeArray"><code>makeArray</code></a> <a href="#makeMultidimensionalArray"><code>makeMultidimensionalArray</code></a> </td>
</tr> <tr>
<td>Dispose</td> <td> <a href="#dispose"><code>dispose</code></a> <a href="#disposeMultidimensionalArray"><code>disposeMultidimensionalArray</code></a> </td>
</tr> <tr>
<td>Modify</td> <td> <a href="#expandArray"><code>expandArray</code></a> <a href="#shrinkArray"><code>shrinkArray</code></a> </td>
</tr> <tr>
<td>Global</td> <td> <a href="#processAllocator"><code>processAllocator</code></a> <a href="#theAllocator"><code>theAllocator</code></a> </td>
</tr> <tr>
<td>Class interface</td> <td> <a href="#allocatorObject"><code>allocatorObject</code></a> <a href="#CAllocatorImpl"><code>CAllocatorImpl</code></a> <a href="#IAllocator"><code>IAllocator</code></a> </td>
</tr> </table> </p> <dl>
<dt>Synopsis</dt>

</dl>
<pre data-language="d">// Allocate an int, initialize it with 42
int* p = theAllocator.make!int(42);
assert(*p == 42);
// Destroy and deallocate it
theAllocator.dispose(p);

// Allocate using the global process allocator
p = processAllocator.make!int(100);
assert(*p == 100);
// Destroy and deallocate
processAllocator.dispose(p);

// Create an array of 50 doubles initialized to -1.0
double[] arr = theAllocator.makeArray!double(50, -1.0);
// Append two zeros to it
theAllocator.expandArray(arr, 2, 0.0);
// On second thought, take that back
theAllocator.shrinkArray(arr, 2);
// Destroy and deallocate
theAllocator.dispose(arr);
</pre>  <h2>Layered Structure</h2>  D's allocators have a layered structure in both implementation and documentation:  <ol>
<li>A high-level, dynamically-typed layer (described further down in this module). It consists of an interface called <a href="#IAllocator"><code>IAllocator</code></a>, which concrete allocators need to implement. The interface primitives themselves are oblivious to the type of the objects being allocated; they only deal in <code>void[]</code>, by necessity of the interface being dynamic (as opposed to type-parameterized). Each thread has a current allocator it uses by default, which is a thread-local variable <a href="#theAllocator"><code>theAllocator</code></a> of type <a href="#IAllocator"><code>IAllocator</code></a>. The process has a global allocator called <a href="#processAllocator"><code>processAllocator</code></a>, also of type <a href="#IAllocator"><code>IAllocator</code></a>. When a new thread is created, <a href="#processAllocator"><code>processAllocator</code></a> is copied into <a href="#theAllocator"><code>theAllocator</code></a>. An application can change the objects to which these references point. By default, at application startup, <a href="#processAllocator"><code>processAllocator</code></a> refers to an object that uses D's garbage collected heap. This layer also include high-level functions such as <a href="#make"><code>make</code></a> and <a href="#dispose"><code>dispose</code></a> that comfortably allocate/create and respectively destroy/deallocate objects. This layer is all needed for most casual uses of allocation primitives.</li>  <li>A mid-level, statically-typed layer for assembling several allocators into one. It uses properties of the type of the objects being created to route allocation requests to possibly specialized allocators. This layer is relatively thin and implemented and documented in the <a href="std_experimental_allocator_typed.html"><code>std.experimental.allocator.typed</code></a> module. It allows an interested user to e.g. use different allocators for arrays versus fixed-sized objects, to the end of better overall performance.</li>  <li>A low-level collection of highly generic <i>heap building blocks</i><nobr> — </nobr> Lego-like pieces that can be used to assemble application-specific allocators. The real allocation smarts are occurring at this level. This layer is of interest to advanced applications that want to configure their own allocators. A good illustration of typical uses of these building blocks is module <a href="std_experimental_allocator_showcase.html"><code>std.experimental.allocator.showcase</code></a> which defines a collection of frequently- used preassembled allocator objects. The implementation and documentation entry point is <a href="std_experimental_allocator_building_blocks.html"><code>std.experimental.allocator.building_blocks</code></a>. By design, the primitives of the static interface have the same signatures as the <a href="#IAllocator"><code>IAllocator</code></a> primitives but are for the most part optional and driven by static introspection. The parameterized class <a href="#CAllocatorImpl"><code>CAllocatorImpl</code></a> offers an immediate and useful means to package a static low-level allocator into an implementation of <a href="#IAllocator"><code>IAllocator</code></a>.</li>  <li>Core allocator objects that interface with D's garbage collected heap (<a href="std_experimental_allocator_gc_allocator.html"><code>std.experimental.allocator.gc_allocator</code></a>), the C <code>malloc</code> family (<a href="std_experimental_allocator_mallocator.html"><code>std.experimental.allocator.mallocator</code></a>), and the OS (<a href="std_experimental_allocator_mmap_allocator.html"><code>std.experimental.allocator.mmap_allocator</code></a>). Most custom allocators would ultimately obtain memory from one of these core allocators.</li> </ol>  <h2>Idiomatic Use of <code>std.experimental.allocator</code>
</h2>  As of this time, <code>std.experimental.allocator</code> is not integrated with D's built-in operators that allocate memory, such as <code>new</code>, array literals, or array concatenation operators. That means <code>std.experimental.allocator</code> is opt-in<nobr> — </nobr>applications need to make explicit use of it.  For casual creation and disposal of dynamically-allocated objects, use <a href="#make"><code>make</code></a>, <a href="#dispose"><code>dispose</code></a>, and the array-specific functions <a href="#makeArray"><code>makeArray</code></a>, <a href="#expandArray"><code>expandArray</code></a>, and <a href="#shrinkArray"><code>shrinkArray</code></a>. These use by default D's garbage collected heap, but open the application to better configuration options. These primitives work either with <code>theAllocator</code> but also with any allocator obtained by combining heap building blocks. For example:  <pre data-language="d">void fun(size_t n)
{
    // Use the current allocator
    int[] a1 = theAllocator.makeArray!int(n);
    scope(exit) theAllocator.dispose(a1);
    ...
}
</pre>  To experiment with alternative allocators, set <a href="#theAllocator"><code>theAllocator</code></a> for the current thread. For example, consider an application that allocates many 8-byte objects. These are not well supported by the default allocator, so a <a href="std_experimental_allocator_building_blocks_free_list.html">free list allocator</a> would be recommended. To install one in <code>main</code>, the application would use:  <pre data-language="d">void main()
{
    import std.experimental.allocator.building_blocks.free_list
        : FreeList;
    theAllocator = allocatorObject(FreeList!8());
    ...
}
</pre>  <h3>Saving the <code>IAllocator</code> Reference For Later Use</h3>  As with any global resource, setting <code>theAllocator</code> and <code>processAllocator</code> should not be done often and casually. In particular, allocating memory with one allocator and deallocating with another causes undefined behavior. Typically, these variables are set during application initialization phase and last through the application.  To avoid this, long-lived objects that need to perform allocations, reallocations, and deallocations relatively often may want to store a reference to the allocator object they use throughout their lifetime. Then, instead of using <code>theAllocator</code> for internal allocation-related tasks, they'd use the internally held reference. For example, consider a user-defined hash table:  <pre data-language="d">struct HashTable
{
    private IAllocator allocator;
    this(size_t buckets, IAllocator allocator = theAllocator) {
        this.allocator = allocator;
        ...
    }
    // Getter and setter
    IAllocator allocator() { return allocator; }
    void allocator(IAllocator a) { assert(empty); allocator = a; }
}
</pre>  Following initialization, the <code>HashTable</code> object would consistently use its <code>allocator</code> object for acquiring memory. Furthermore, setting <code>HashTable.allocator</code> to point to a different allocator should be legal but only if the object is empty; otherwise, the object wouldn't be able to deallocate its existing state.  <h3>Using Allocators without <code>IAllocator</code>
</h3>  Allocators assembled from the heap building blocks don't need to go through <code>IAllocator</code> to be usable. They have the same primitives as <code>IAllocator</code> and they work with <a href="#make"><code>make</code></a>, <a href="#makeArray"><code>makeArray</code></a>, <a href="#dispose"><code>dispose</code></a> etc. So it suffice to create allocator objects wherever fit and use them appropriately:  <pre data-language="d">void fun(size_t n)
{
    // Use a stack-installed allocator for up to 64KB
    StackFront!65536 myAllocator;
    int[] a2 = myAllocator.makeArray!int(n);
    scope(exit) myAllocator.dispose(a2);
    ...
}
</pre>  In this case, <code>myAllocator</code> does not obey the <code>IAllocator</code> interface, but implements its primitives so it can work with <code>makeArray</code> by means of duck typing.  One important thing to note about this setup is that statically-typed assembled allocators are almost always faster than allocators that go through <code>IAllocator</code>. An important rule of thumb is: "assemble allocator first, adapt to <code>IAllocator</code> after". A good allocator implements intricate logic by means of template assembly, and gets wrapped with <code>IAllocator</code> (usually by means of <a href="#allocatorObject"><code>allocatorObject</code></a>) only once, at client level.  <dl>
<dt>License:</dt>
<dd>
<a href="http://boost.org/LICENSE_1_0.txt">Boost License 1.0</a>. </dd>
</dl> <dl>
<dt>Authors:</dt>
<dd>
<a href="http://erdani.com">Andrei Alexandrescu</a> </dd>
</dl> <dl>
<dt>Source</dt>
<dd> <span class="phobos_src"><a class="https" href="https://github.com/dlang/phobos/blob/master/std/experimental/allocator">std/experimental/allocator</a></span>
</dd>
</dl> <dl>
<dt class="d_decl" id="IAllocator">interface <strong id="IAllocator">IAllocator</strong>; </dt> <dd>
<p>Dynamic allocator interface. Code that defines allocators ultimately implements this interface. This should be used wherever a uniform type is required for encapsulating various allocator implementations. </p>
<p>Composition of allocators is not recommended at this level due to inflexibility of dynamic interfaces and inefficiencies caused by cascaded multiple calls. Instead, compose allocators using the static interface defined in <a href="std_experimental_allocator_building_blocks.html"><code>std.experimental.allocator.building_blocks</code></a>, then adapt the composed allocator to <code>IAllocator</code> (possibly by using <a href="#CAllocatorImpl"><code>CAllocatorImpl</code></a> below). <br><br> Methods returning <code>Ternary</code> return <code>Ternary.yes</code> upon success, <code>Ternary.no</code> upon failure, and <code>Ternary.unknown</code> if the primitive is not implemented by the allocator instance.</p> <dl>
<dt class="d_decl" id="IAllocator.alignment">abstract nothrow @property uint <strong id="alignment">alignment</strong>(); </dt> <dd>
<p>Returns the alignment offered.</p> </dd> <dt class="d_decl" id="IAllocator.goodAllocSize">abstract nothrow size_t <strong id="goodAllocSize">goodAllocSize</strong>(size_t s); </dt> <dd>
<p>Returns the good allocation size that guarantees zero internal fragmentation.</p> </dd> <dt class="d_decl" id="IAllocator.allocate">abstract nothrow void[] <strong id="allocate">allocate</strong>(size_t, TypeInfo ti = null); </dt> <dd>
<p>Allocates <code>n</code> bytes of memory.</p> </dd> <dt class="d_decl" id="IAllocator.alignedAllocate">abstract nothrow void[] <strong id="alignedAllocate">alignedAllocate</strong>(size_t n, uint a); </dt> <dd>
<p>Allocates <code>n</code> bytes of memory with specified alignment <code>a</code>. Implementations that do not support this primitive should always return <code>null</code>.</p> </dd> <dt class="d_decl" id="IAllocator.allocateAll">abstract nothrow void[] <strong id="allocateAll">allocateAll</strong>(); </dt> <dd>
<p>Allocates and returns all memory available to this allocator. Implementations that do not support this primitive should always return <code>null</code>.</p> </dd> <dt class="d_decl" id="IAllocator.expand">abstract nothrow bool <strong id="expand">expand</strong>(ref void[], size_t); </dt> <dd>
<p>Expands a memory block in place and returns <code>true</code> if successful. Implementations that don't support this primitive should always return <code>false</code>.</p> </dd> <dt class="d_decl" id="IAllocator.reallocate">abstract nothrow bool <strong id="reallocate">reallocate</strong>(ref void[], size_t); </dt> <dd>
<p>Reallocates a memory block.</p> </dd> <dt class="d_decl" id="IAllocator.alignedReallocate">abstract nothrow bool <strong id="alignedReallocate">alignedReallocate</strong>(ref void[] b, size_t size, uint alignment); </dt> <dd>
<p>Reallocates a memory block with specified alignment.</p> </dd> <dt class="d_decl" id="IAllocator.owns">abstract nothrow Ternary <strong id="owns">owns</strong>(void[] b); </dt> <dd>
<p>Returns <code>Ternary.yes</code> if the allocator owns <code>b</code>, <code>Ternary.no</code> if the allocator doesn't own <code>b</code>, and <code>Ternary.unknown</code> if ownership cannot be determined. Implementations that don't support this primitive should always return <code>Ternary.unknown</code>.</p> </dd> <dt class="d_decl" id="IAllocator.resolveInternalPointer">abstract nothrow Ternary <strong id="resolveInternalPointer">resolveInternalPointer</strong>(const void* p, ref void[] result); </dt> <dd>
<p>Resolves an internal pointer to the full block allocated. Implementations that don't support this primitive should always return <code>Ternary.unknown</code>.</p> </dd> <dt class="d_decl" id="IAllocator.deallocate">abstract nothrow bool <strong id="deallocate">deallocate</strong>(void[] b); </dt> <dd>
<p>Deallocates a memory block. Implementations that don't support this primitive should always return <code>false</code>. A simple way to check that an allocator supports deallocation is to call <code>deallocate(null)</code>.</p> </dd> <dt class="d_decl" id="IAllocator.deallocateAll">abstract nothrow bool <strong id="deallocateAll">deallocateAll</strong>(); </dt> <dd>
<p>Deallocates all memory. Implementations that don't support this primitive should always return <code>false</code>.</p> </dd> <dt class="d_decl" id="IAllocator.empty">abstract nothrow Ternary <strong id="empty">empty</strong>(); </dt> <dd>
<p>Returns <code>Ternary.yes</code> if no memory is currently allocated from this allocator, <code>Ternary.no</code> if some allocations are currently active, or <code>Ternary.unknown</code> if not supported.</p> </dd> <dt class="d_decl" id="IAllocator.incRef">abstract pure nothrow @nogc @safe void <strong id="incRef">incRef</strong>(); </dt> <dd>
<p>Increases the reference count of the concrete class that implements this interface. </p>
<p>For stateless allocators, this does nothing.</p> </dd> <dt class="d_decl" id="IAllocator.decRef">abstract pure nothrow @nogc @safe bool <strong id="decRef">decRef</strong>(); </dt> <dd>
<p>Decreases the reference count of the concrete class that implements this interface. When the reference count is <code>0</code>, the object self-destructs. </p>
<dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if the reference count is greater than <code>0</code> and <code>false</code> when it hits <code>0</code>. For stateless allocators, it always returns <code>true</code>.</dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="RCIAllocator">struct <strong id="RCIAllocator">RCIAllocator</strong>; </dt> <dd>
<p>A reference counted struct that wraps the dynamic allocator interface. This should be used wherever a uniform type is required for encapsulating various allocator implementations. </p>
<p>Code that defines allocators ultimately implements the <a href="#IAllocator"><code>IAllocator</code></a> interface, possibly by using <a href="#CAllocatorImpl"><code>CAllocatorImpl</code></a> below, and then build a <code>RCIAllocator</code> out of this. <br><br> Composition of allocators is not recommended at this level due to inflexibility of dynamic interfaces and inefficiencies caused by cascaded multiple calls. Instead, compose allocators using the static interface defined in <a href="std_experimental_allocator_building_blocks.html"><code>std.experimental.allocator.building_blocks</code></a>, then adapt the composed allocator to <code>RCIAllocator</code> (possibly by using <a href="#allocatorObject"><code>allocatorObject</code></a> below).</p> </dd> <dt class="d_decl" id="ISharedAllocator">interface <strong id="ISharedAllocator">ISharedAllocator</strong>; </dt> <dd>
<p>Dynamic shared allocator interface. Code that defines allocators shareable across threads ultimately implements this interface. This should be used wherever a uniform type is required for encapsulating various allocator implementations. </p>
<p>Composition of allocators is not recommended at this level due to inflexibility of dynamic interfaces and inefficiencies caused by cascaded multiple calls. Instead, compose allocators using the static interface defined in <a href="std_experimental_allocator_building_blocks.html"><code>std.experimental.allocator.building_blocks</code></a>, then adapt the composed allocator to <code>ISharedAllocator</code> (possibly by using <a href="#CSharedAllocatorImpl"><code>CSharedAllocatorImpl</code></a> below). <br><br> Methods returning <code>Ternary</code> return <code>Ternary.yes</code> upon success, <code>Ternary.no</code> upon failure, and <code>Ternary.unknown</code> if the primitive is not implemented by the allocator instance.</p> <dl>
<dt class="d_decl" id="ISharedAllocator.alignment">abstract shared nothrow @property uint <strong id="alignment">alignment</strong>(); </dt> <dd>
<p>Returns the alignment offered.</p> </dd> <dt class="d_decl" id="ISharedAllocator.goodAllocSize">abstract shared nothrow size_t <strong id="goodAllocSize">goodAllocSize</strong>(size_t s); </dt> <dd>
<p>Returns the good allocation size that guarantees zero internal fragmentation.</p> </dd> <dt class="d_decl" id="ISharedAllocator.allocate">abstract shared nothrow void[] <strong id="allocate">allocate</strong>(size_t, TypeInfo ti = null); </dt> <dd>
<p>Allocates <code>n</code> bytes of memory.</p> </dd> <dt class="d_decl" id="ISharedAllocator.alignedAllocate">abstract shared nothrow void[] <strong id="alignedAllocate">alignedAllocate</strong>(size_t n, uint a); </dt> <dd>
<p>Allocates <code>n</code> bytes of memory with specified alignment <code>a</code>. Implementations that do not support this primitive should always return <code>null</code>.</p> </dd> <dt class="d_decl" id="ISharedAllocator.allocateAll">abstract shared nothrow void[] <strong id="allocateAll">allocateAll</strong>(); </dt> <dd>
<p>Allocates and returns all memory available to this allocator. Implementations that do not support this primitive should always return <code>null</code>.</p> </dd> <dt class="d_decl" id="ISharedAllocator.expand">abstract shared nothrow bool <strong id="expand">expand</strong>(ref void[], size_t); </dt> <dd>
<p>Expands a memory block in place and returns <code>true</code> if successful. Implementations that don't support this primitive should always return <code>false</code>.</p> </dd> <dt class="d_decl" id="ISharedAllocator.reallocate">abstract shared nothrow bool <strong id="reallocate">reallocate</strong>(ref void[], size_t); </dt> <dd>
<p>Reallocates a memory block.</p> </dd> <dt class="d_decl" id="ISharedAllocator.alignedReallocate">abstract shared nothrow bool <strong id="alignedReallocate">alignedReallocate</strong>(ref void[] b, size_t size, uint alignment); </dt> <dd>
<p>Reallocates a memory block with specified alignment.</p> </dd> <dt class="d_decl" id="ISharedAllocator.owns">abstract shared nothrow Ternary <strong id="owns">owns</strong>(void[] b); </dt> <dd>
<p>Returns <code>Ternary.yes</code> if the allocator owns <code>b</code>, <code>Ternary.no</code> if the allocator doesn't own <code>b</code>, and <code>Ternary.unknown</code> if ownership cannot be determined. Implementations that don't support this primitive should always return <code>Ternary.unknown</code>.</p> </dd> <dt class="d_decl" id="ISharedAllocator.resolveInternalPointer">abstract shared nothrow Ternary <strong id="resolveInternalPointer">resolveInternalPointer</strong>(const void* p, ref void[] result); </dt> <dd>
<p>Resolves an internal pointer to the full block allocated. Implementations that don't support this primitive should always return <code>Ternary.unknown</code>.</p> </dd> <dt class="d_decl" id="ISharedAllocator.deallocate">abstract shared nothrow bool <strong id="deallocate">deallocate</strong>(void[] b); </dt> <dd>
<p>Deallocates a memory block. Implementations that don't support this primitive should always return <code>false</code>. A simple way to check that an allocator supports deallocation is to call <code>deallocate(null)</code>.</p> </dd> <dt class="d_decl" id="ISharedAllocator.deallocateAll">abstract shared nothrow bool <strong id="deallocateAll">deallocateAll</strong>(); </dt> <dd>
<p>Deallocates all memory. Implementations that don't support this primitive should always return <code>false</code>.</p> </dd> <dt class="d_decl" id="ISharedAllocator.empty">abstract shared nothrow Ternary <strong id="empty">empty</strong>(); </dt> <dd>
<p>Returns <code>Ternary.yes</code> if no memory is currently allocated from this allocator, <code>Ternary.no</code> if some allocations are currently active, or <code>Ternary.unknown</code> if not supported.</p> </dd> <dt class="d_decl" id="ISharedAllocator.incRef">abstract shared pure nothrow @nogc @safe void <strong id="incRef">incRef</strong>(); </dt> <dd>
<p>Increases the reference count of the concrete class that implements this interface. </p>
<p>For stateless allocators, this does nothing.</p> </dd> <dt class="d_decl" id="ISharedAllocator.decRef">abstract shared pure nothrow @nogc @safe bool <strong id="decRef">decRef</strong>(); </dt> <dd>
<p>Decreases the reference count of the concrete class that implements this interface. When the reference count is <code>0</code>, the object self-destructs. </p>
<p>For stateless allocators, this does nothing. </p> <dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if the reference count is greater than <code>0</code> and <code>false</code> when it hits <code>0</code>. For stateless allocators, it always returns <code>true</code>.</dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="RCISharedAllocator">struct <strong id="RCISharedAllocator">RCISharedAllocator</strong>; </dt> <dd>
<p>A reference counted struct that wraps the dynamic shared allocator interface. This should be used wherever a uniform type is required for encapsulating various allocator implementations. </p>
<p>Code that defines allocators shareable across threads ultimately implements the <a href="#ISharedAllocator"><code>ISharedAllocator</code></a> interface, possibly by using <a href="#CSharedAllocatorImpl"><code>CSharedAllocatorImpl</code></a> below, and then build a <code>RCISharedAllocator</code> out of this. <br><br> Composition of allocators is not recommended at this level due to inflexibility of dynamic interfaces and inefficiencies caused by cascaded multiple calls. Instead, compose allocators using the static interface defined in <a href="std_experimental_allocator_building_blocks.html"><code>std.experimental.allocator.building_blocks</code></a>, then adapt the composed allocator to <code>RCISharedAllocator</code> (possibly by using <a href="#sharedAllocatorObject"><code>sharedAllocatorObject</code></a> below).</p> </dd> <dt class="d_decl" id="theAllocator">nothrow @nogc @property ref @safe RCIAllocator <strong id="theAllocator">theAllocator</strong>(); <br><br>nothrow @nogc @property @system void <strong id="theAllocator">theAllocator</strong>(RCIAllocator a); </dt> <dd>
<p>Gets/sets the allocator for the current thread. This is the default allocator that should be used for allocating thread-local memory. For allocating memory to be shared across threads, use <code>processAllocator</code> (below). By default, <code>theAllocator</code> ultimately fetches memory from <code>processAllocator</code>, which in turn uses the garbage collected heap.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">// Install a new allocator that is faster for 128-byte allocations.
import std.experimental.allocator.building_blocks.free_list : FreeList;
import std.experimental.allocator.gc_allocator : GCAllocator;
auto oldAllocator = theAllocator;
scope(exit) theAllocator = oldAllocator;
theAllocator = allocatorObject(FreeList!(GCAllocator, 128)());
// Use the now changed allocator to allocate an array
const ubyte[] arr = theAllocator.makeArray!ubyte(128);
assert(arr.ptr);
//...
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="processAllocator">nothrow @nogc @property ref @trusted RCISharedAllocator <strong id="processAllocator">processAllocator</strong>(); <br><br>nothrow @nogc @property @system void <strong id="processAllocator">processAllocator</strong>(ref RCISharedAllocator a); </dt> <dd>
<p>Gets/sets the allocator for the current process. This allocator must be used for allocating memory shared across threads. Objects created using this allocator can be cast to <code>shared</code>.</p> </dd> <dt class="d_decl" id="make">auto <strong id="make">make</strong>(T, Allocator, A...)(auto ref Allocator alloc, auto ref A args); </dt> <dd>
<p>Dynamically allocates (using <code>alloc</code>) and then creates in the memory allocated an object of type <code>T</code>, using <code>args</code> (if any) for its initialization. Initialization occurs in the memory allocated and is otherwise semantically the same as <code>T(args)</code>. (Note that using <code>alloc.make!(T[])</code> creates a pointer to an (empty) array of <code>T</code>s, not an array. To use an allocator to allocate and initialize an array, use <code>alloc.makeArray!T</code> described below.) </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T</td> <td>Type of the object being created.</td>
</tr> <tr>
<td>Allocator <code>alloc</code>
</td> <td>The allocator used for getting the needed memory. It may be an object implementing the static interface for allocators, or an <code>IAllocator</code> reference.</td>
</tr> <tr>
<td>A <code>args</code>
</td> <td>Optional arguments used for initializing the created object. If not present, the object is default constructed.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>If <code>T</code> is a class type, returns a reference to the created <code>T</code> object. Otherwise, returns a <code>T*</code> pointing to the created object. In all cases, returns <code>null</code> if allocation failed. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>If <code>T</code>'s constructor throws, deallocates the allocated memory and propagates the exception.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">// Dynamically allocate one integer
const int* p1 = theAllocator.make!int;
// It's implicitly initialized with its .init value
writeln(*p1); // 0
// Dynamically allocate one double, initialize to 42.5
const double* p2 = theAllocator.make!double(42.5);
writeln(*p2); // 42.5

// Dynamically allocate a struct
static struct Point
{
    int x, y, z;
}
// Use the generated constructor taking field values in order
const Point* p = theAllocator.make!Point(1, 2);
assert(p.x == 1 &amp;&amp; p.y == 2 &amp;&amp; p.z == 0);

// Dynamically allocate a class object
static class Customer
{
    uint id = uint.max;
    this() {}
    this(uint id) { this.id = id; }
    // ...
}
Customer cust = theAllocator.make!Customer;
assert(cust.id == uint.max); // default initialized
cust = theAllocator.make!Customer(42);
writeln(cust.id); // 42

// explicit passing of outer pointer
static class Outer
{
    int x = 3;
    class Inner
    {
        auto getX() { return x; }
    }
}
auto outer = theAllocator.make!Outer();
auto inner = theAllocator.make!(Outer.Inner)(outer);
writeln(outer.x); // inner.getX
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="makeArray">T[] <strong id="makeArray">makeArray</strong>(T, Allocator)(auto ref Allocator alloc, size_t length); <br><br>T[] <strong id="makeArray">makeArray</strong>(T, Allocator)(auto ref Allocator alloc, size_t length, T init); <br><br>Unqual!(ElementEncodingType!R)[] <strong id="makeArray">makeArray</strong>(Allocator, R)(auto ref Allocator alloc, R range)<br><small>  Constraints: if (isInputRange!R &amp;&amp; !isInfinite!R); </small><br><br>T[] <strong id="makeArray">makeArray</strong>(T, Allocator, R)(auto ref Allocator alloc, R range)<br><small>  Constraints: if (isInputRange!R &amp;&amp; !isInfinite!R); </small>
</dt> <dd>
<p>Create an array of <code>T</code> with <code>length</code> elements using <code>alloc</code>. The array is either default-initialized, filled with copies of <code>init</code>, or initialized with values fetched from <code>range</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T</td> <td>element type of the array being created</td>
</tr> <tr>
<td>Allocator <code>alloc</code>
</td> <td>the allocator used for getting memory</td>
</tr> <tr>
<td>size_t <code>length</code>
</td> <td>length of the newly created array</td>
</tr> <tr>
<td>T <code>init</code>
</td> <td>element used for filling the array</td>
</tr> <tr>
<td>R <code>range</code>
</td> <td>range used for initializing the array elements</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The newly-created array, or <code>null</code> if either <code>length</code> was <code>0</code> or allocation failed. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>The first two overloads throw only if <code>alloc</code>'s primitives do. The overloads that involve copy initialization deallocate memory and propagate the exception if the copy operation throws.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
static void test(T)()
{
    T[] a = theAllocator.makeArray!T(2);
    assert(a.equal([0, 0]));
    a = theAllocator.makeArray!T(3, 42);
    assert(a.equal([42, 42, 42]));
    import std.range : only;
    a = theAllocator.makeArray!T(only(42, 43, 44));
    assert(a.equal([42, 43, 44]));
}
test!int();
test!(shared int)();
test!(const int)();
test!(immutable int)();
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="expandArray">bool <strong id="expandArray">expandArray</strong>(T, Allocator)(auto ref Allocator alloc, ref T[] array, size_t delta); <br><br>bool <strong id="expandArray">expandArray</strong>(T, Allocator)(auto ref Allocator alloc, ref T[] array, size_t delta, auto ref T init); <br><br>bool <strong id="expandArray">expandArray</strong>(T, Allocator, R)(auto ref Allocator alloc, ref T[] array, R range)<br><small>  Constraints: if (isInputRange!R); </small>
</dt> <dd>
<p>Grows <code>array</code> by appending <code>delta</code> more elements. The needed memory is allocated using <code>alloc</code>. The extra elements added are either default- initialized, filled with copies of <code>init</code>, or initialized with values fetched from <code>range</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T</td> <td>element type of the array being created</td>
</tr> <tr>
<td>Allocator <code>alloc</code>
</td> <td>the allocator used for getting memory</td>
</tr> <tr>
<td>T[] <code>array</code>
</td> <td>a reference to the array being grown</td>
</tr> <tr>
<td>size_t <code>delta</code>
</td> <td>number of elements to add (upon success the new length of <code>array</code> is <code>array.length + delta</code>)</td>
</tr> <tr>
<td>T <code>init</code>
</td> <td>element used for filling the array</td>
</tr> <tr>
<td>R <code>range</code>
</td> <td>range used for initializing the array elements</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>true</code> upon success, <code>false</code> if memory could not be allocated. In the latter case <code>array</code> is left unaffected. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>The first two overloads throw only if <code>alloc</code>'s primitives do. The overloads that involve copy initialization deallocate memory and propagate the exception if the copy operation throws.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto arr = theAllocator.makeArray!int([1, 2, 3]);
assert(theAllocator.expandArray(arr, 2));
writeln(arr); // [1, 2, 3, 0, 0]
import std.range : only;
assert(theAllocator.expandArray(arr, only(4, 5)));
writeln(arr); // [1, 2, 3, 0, 0, 4, 5]
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="shrinkArray">bool <strong id="shrinkArray">shrinkArray</strong>(T, Allocator)(auto ref Allocator alloc, ref T[] array, size_t delta); </dt> <dd>
<p>Shrinks an array by <code>delta</code> elements. </p>
<p>If <code>array.length &lt; delta</code>, does nothing and returns <code>false</code>. Otherwise, destroys the last <code>array.length - delta</code> elements in the array and then reallocates the array's buffer. If reallocation fails, fills the array with default-initialized data. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T</td> <td>element type of the array being created</td>
</tr> <tr>
<td>Allocator <code>alloc</code>
</td> <td>the allocator used for getting memory</td>
</tr> <tr>
<td>T[] <code>array</code>
</td> <td>a reference to the array being shrunk</td>
</tr> <tr>
<td>size_t <code>delta</code>
</td> <td>number of elements to remove (upon success the new length of <code>array</code> is <code>array.length - delta</code>)</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>true</code> upon success, <code>false</code> if memory could not be reallocated. In the latter case, the slice <code>array[$ - delta .. $]</code> is left with default-initialized elements. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>The first two overloads throw only if <code>alloc</code>'s primitives do. The overloads that involve copy initialization deallocate memory and propagate the exception if the copy operation throws.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int[] a = theAllocator.makeArray!int(100, 42);
writeln(a.length); // 100
assert(theAllocator.shrinkArray(a, 98));
writeln(a.length); // 2
writeln(a); // [42, 42]
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="dispose">void <strong id="dispose">dispose</strong>(A, T)(auto ref A alloc, auto ref T* p); <br><br>void <strong id="dispose">dispose</strong>(A, T)(auto ref A alloc, auto ref T p)<br><small>  Constraints: if (is(T == class) || is(T == interface)); </small><br><br>void <strong id="dispose">dispose</strong>(A, T)(auto ref A alloc, auto ref T[] array); </dt> <dd>
<p>Destroys and then deallocates (using <code>alloc</code>) the object pointed to by a pointer, the class object referred to by a <code>class</code> or <code>interface</code> reference, or an entire array. It is assumed the respective entities had been allocated with the same allocator. </p> </dd> <dt class="d_decl" id="makeMultidimensionalArray">auto <strong id="makeMultidimensionalArray">makeMultidimensionalArray</strong>(T, Allocator, size_t N)(auto ref Allocator alloc, size_t[N] lengths...); </dt> <dd>
<p>Allocates a multidimensional array of elements of type T. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>N</td> <td>number of dimensions</td>
</tr> <tr>
<td>T</td> <td>element type of an element of the multidimensional arrat</td>
</tr> <tr>
<td>Allocator <code>alloc</code>
</td> <td>the allocator used for getting memory</td>
</tr> <tr>
<td>size_t[N] <code>lengths</code>
</td> <td>static array containing the size of each dimension</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>An N-dimensional array with individual elements of type T.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.experimental.allocator.mallocator : Mallocator;

auto mArray = Mallocator.instance.makeMultidimensionalArray!int(2, 3, 6);

// deallocate when exiting scope
scope(exit)
{
    Mallocator.instance.disposeMultidimensionalArray(mArray);
}

writeln(mArray.length); // 2
foreach (lvl2Array; mArray)
{
    writeln(lvl2Array.length); // 3
    foreach (lvl3Array; lvl2Array)
        writeln(lvl3Array.length); // 6
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="disposeMultidimensionalArray">void <strong id="disposeMultidimensionalArray">disposeMultidimensionalArray</strong>(T, Allocator)(auto ref Allocator alloc, auto ref T[] array); </dt> <dd>
<p>Destroys and then deallocates a multidimensional array, assuming it was created with makeMultidimensionalArray and the same allocator was used. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T</td> <td>element type of an element of the multidimensional array</td>
</tr> <tr>
<td>Allocator <code>alloc</code>
</td> <td>the allocator used for getting memory</td>
</tr> <tr>
<td>T[] <code>array</code>
</td> <td>the multidimensional array that is to be deallocated</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">struct TestAllocator
{
    import std.experimental.allocator.common : platformAlignment;
    import std.experimental.allocator.mallocator : Mallocator;

    alias allocator = Mallocator.instance;

    private static struct ByteRange
    {
        void* ptr;
        size_t length;
    }

    private ByteRange[] _allocations;

    enum uint alignment = platformAlignment;

    void[] allocate(size_t numBytes)
    {
         auto ret = allocator.allocate(numBytes);
         _allocations ~= ByteRange(ret.ptr, ret.length);
         return ret;
    }

    bool deallocate(void[] bytes)
    {
        import std.algorithm.mutation : remove;
        import std.algorithm.searching : canFind;

        bool pred(ByteRange other)
        { return other.ptr == bytes.ptr &amp;&amp; other.length == bytes.length; }

        assert(_allocations.canFind!pred);

         _allocations = _allocations.remove!pred;
         return allocator.deallocate(bytes);
    }

    ~this()
    {
        assert(!_allocations.length);
    }
}

TestAllocator allocator;

auto mArray = allocator.makeMultidimensionalArray!int(2, 3, 5, 6, 7, 2);

allocator.disposeMultidimensionalArray(mArray);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="allocatorObject">RCIAllocator <strong id="allocatorObject">allocatorObject</strong>(A)(auto ref A a)<br><small>  Constraints: if (!isPointer!A); </small><br><br>RCIAllocator <strong id="allocatorObject">allocatorObject</strong>(A)(A* pa); </dt> <dd>
<p>Returns a dynamically-typed <code>CAllocator</code> built around a given statically- typed allocator <code>a</code> of type <code>A</code>. Passing a pointer to the allocator creates a dynamic allocator around the allocator pointed to by the pointer, without attempting to copy or move it. Passing the allocator by value or reference behaves as follows. </p>
<p><ul>
<li>If <code>A</code> has no state, the resulting object is allocated in static shared storage.</li> <li>If <code>A</code> has state, the result will <a href="std_algorithm_mutation.html#move"><code>std.algorithm.mutation.move</code></a> the supplied allocator <code>A a</code> within. The result itself is allocated in its own statically-typed allocator.</li> </ul></p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.experimental.allocator.mallocator : Mallocator;

RCIAllocator a = allocatorObject(Mallocator.instance);
auto b = a.allocate(100);
writeln(b.length); // 100
assert(a.deallocate(b));

// The in-situ region must be used by pointer
import std.experimental.allocator.building_blocks.region : InSituRegion;
auto r = InSituRegion!1024();
a = allocatorObject(&amp;r);
b = a.allocate(200);
writeln(b.length); // 200
// In-situ regions can deallocate the last allocation
assert(a.deallocate(b));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="sharedAllocatorObject">nothrow RCISharedAllocator <strong id="sharedAllocatorObject">sharedAllocatorObject</strong>(A)(auto ref A a)<br><small>  Constraints: if (!isPointer!A); </small><br><br>RCISharedAllocator <strong id="sharedAllocatorObject">sharedAllocatorObject</strong>(A)(A* pa); </dt> <dd>
<p>Returns a dynamically-typed <code>CSharedAllocator</code> built around a given statically- typed allocator <code>a</code> of type <code>A</code>. Passing a pointer to the allocator creates a dynamic allocator around the allocator pointed to by the pointer, without attempting to copy or move it. Passing the allocator by value or reference behaves as follows. </p>
<p><ul>
<li>If <code>A</code> has no state, the resulting object is allocated in static shared storage.</li> <li>If <code>A</code> has state and is copyable, the result will <a href="std_algorithm_mutation.html#move"><code>std.algorithm.mutation.move</code></a> the supplied allocator <code>A a</code> within. The result itself is allocated in its own statically-typed allocator.</li> <li>If <code>A</code> has state and is not copyable, the result will move the passed-in argument into the result. The result itself is allocated in its own statically-typed allocator.</li> </ul></p> </dd> <dt class="d_decl" id="CAllocatorImpl">class <strong id="CAllocatorImpl">CAllocatorImpl</strong>(Allocator, Flag!"indirect" indirect = No.indirect): IAllocator; </dt> <dd>
<p>Implementation of <code>IAllocator</code> using <code>Allocator</code>. This adapts a statically-built allocator type to <code>IAllocator</code> that is directly usable by non-templated code. </p>
<p>Usually <code>CAllocatorImpl</code> is used indirectly by calling <a href="#theAllocator"><code>theAllocator</code></a>.</p> <dl>
<dt class="d_decl" id="CAllocatorImpl.impl">pure @nogc ref @safe Allocator <strong id="impl">impl</strong>(); </dt> <dd>
<p>The implementation is available as a public member.</p> </dd> <dt class="d_decl" id="CAllocatorImpl.this">pure @nogc @safe this(Allocator* pa); </dt> <dd>
<p>The implementation is available as a public member.</p> </dd> <dt class="d_decl" id="CAllocatorImpl.alignment">@property uint <strong id="alignment">alignment</strong>(); </dt> <dd>
<p>Returns <code>impl.alignment</code>.</p> </dd> <dt class="d_decl" id="CAllocatorImpl.goodAllocSize">size_t <strong id="goodAllocSize">goodAllocSize</strong>(size_t s); </dt> <dd>
<p>Returns <code>impl.goodAllocSize(s)</code>.</p> </dd> <dt class="d_decl" id="CAllocatorImpl.allocate">void[] <strong id="allocate">allocate</strong>(size_t s, TypeInfo ti = null); </dt> <dd>
<p>Returns <code>impl.allocate(s)</code>.</p> </dd> <dt class="d_decl" id="CAllocatorImpl.alignedAllocate">void[] <strong id="alignedAllocate">alignedAllocate</strong>(size_t s, uint a); </dt> <dd>
<p>If <code>impl.alignedAllocate</code> exists, calls it and returns the result. Otherwise, always returns <code>null</code>.</p> </dd> <dt class="d_decl" id="CAllocatorImpl.owns">Ternary <strong id="owns">owns</strong>(void[] b); </dt> <dd>
<p>If <code>Allocator</code> implements <code>owns</code>, forwards to it. Otherwise, returns <code>Ternary.unknown</code>.</p> </dd> <dt class="d_decl" id="CAllocatorImpl.expand">bool <strong id="expand">expand</strong>(ref void[] b, size_t s); </dt> <dd>
<p>Returns <code>impl.expand(b, s)</code> if defined, <code>false</code> otherwise.</p> </dd> <dt class="d_decl" id="CAllocatorImpl.reallocate">bool <strong id="reallocate">reallocate</strong>(ref void[] b, size_t s); </dt> <dd>
<p>Returns <code>impl.reallocate(b, s)</code>.</p> </dd> <dt class="d_decl" id="CAllocatorImpl.alignedReallocate">bool <strong id="alignedReallocate">alignedReallocate</strong>(ref void[] b, size_t s, uint a); </dt> <dd>
<p>Forwards to <code>impl.alignedReallocate</code> if defined, <code>false</code> otherwise.</p> </dd> <dt class="d_decl" id="CAllocatorImpl.deallocate">bool <strong id="deallocate">deallocate</strong>(void[] b); </dt> <dd>
<p>If <code>impl.deallocate</code> is not defined, returns <code>false</code>. Otherwise it forwards the call.</p> </dd> <dt class="d_decl" id="CAllocatorImpl.deallocateAll">bool <strong id="deallocateAll">deallocateAll</strong>(); </dt> <dd>
<p>Calls <code>impl.deallocateAll()</code> and returns the result if defined, otherwise returns <code>false</code>.</p> </dd> <dt class="d_decl" id="CAllocatorImpl.empty">Ternary <strong id="empty">empty</strong>(); </dt> <dd>
<p>Forwards to <code>impl.empty()</code> if defined, otherwise returns <code>Ternary.unknown</code>.</p> </dd> <dt class="d_decl" id="CAllocatorImpl.allocateAll">void[] <strong id="allocateAll">allocateAll</strong>(); </dt> <dd>
<p>Returns <code>impl.allocateAll()</code> if present, <code>null</code> otherwise.</p> </dd> </dl> </dd> <dt class="d_decl" id="CSharedAllocatorImpl">class <strong id="CSharedAllocatorImpl">CSharedAllocatorImpl</strong>(Allocator, Flag!"indirect" indirect = No.indirect): ISharedAllocator; </dt> <dd>
<p>Implementation of <code>ISharedAllocator</code> using <code>Allocator</code>. This adapts a statically-built, shareable across threads, allocator type to <code>ISharedAllocator</code> that is directly usable by non-templated code. </p>
<p>Usually <code>CSharedAllocatorImpl</code> is used indirectly by calling <a href="#processAllocator"><code>processAllocator</code></a>.</p> <dl>
<dt class="d_decl" id="CSharedAllocatorImpl.impl">shared pure @nogc ref @safe Allocator <strong id="impl">impl</strong>(); </dt> <dd>
<p>The implementation is available as a public member.</p> </dd> <dt class="d_decl" id="CSharedAllocatorImpl.this">shared pure @nogc @safe this(Allocator* pa); </dt> <dd>
<p>The implementation is available as a public member.</p> </dd> <dt class="d_decl" id="CSharedAllocatorImpl.alignment">shared @property uint <strong id="alignment">alignment</strong>(); </dt> <dd>
<p>Returns <code>impl.alignment</code>.</p> </dd> <dt class="d_decl" id="CSharedAllocatorImpl.goodAllocSize">shared size_t <strong id="goodAllocSize">goodAllocSize</strong>(size_t s); </dt> <dd>
<p>Returns <code>impl.goodAllocSize(s)</code>.</p> </dd> <dt class="d_decl" id="CSharedAllocatorImpl.allocate">shared void[] <strong id="allocate">allocate</strong>(size_t s, TypeInfo ti = null); </dt> <dd>
<p>Returns <code>impl.allocate(s)</code>.</p> </dd> <dt class="d_decl" id="CSharedAllocatorImpl.alignedAllocate">shared void[] <strong id="alignedAllocate">alignedAllocate</strong>(size_t s, uint a); </dt> <dd>
<p>If <code>impl.alignedAllocate</code> exists, calls it and returns the result. Otherwise, always returns <code>null</code>.</p> </dd> <dt class="d_decl" id="CSharedAllocatorImpl.owns">shared Ternary <strong id="owns">owns</strong>(void[] b); </dt> <dd>
<p>If <code>Allocator</code> implements <code>owns</code>, forwards to it. Otherwise, returns <code>Ternary.unknown</code>.</p> </dd> <dt class="d_decl" id="CSharedAllocatorImpl.expand">shared bool <strong id="expand">expand</strong>(ref void[] b, size_t s); </dt> <dd>
<p>Returns <code>impl.expand(b, s)</code> if defined, <code>false</code> otherwise.</p> </dd> <dt class="d_decl" id="CSharedAllocatorImpl.reallocate">shared bool <strong id="reallocate">reallocate</strong>(ref void[] b, size_t s); </dt> <dd>
<p>Returns <code>impl.reallocate(b, s)</code>.</p> </dd> <dt class="d_decl" id="CSharedAllocatorImpl.alignedReallocate">shared bool <strong id="alignedReallocate">alignedReallocate</strong>(ref void[] b, size_t s, uint a); </dt> <dd>
<p>Forwards to <code>impl.alignedReallocate</code> if defined, <code>false</code> otherwise.</p> </dd> <dt class="d_decl" id="CSharedAllocatorImpl.deallocate">shared bool <strong id="deallocate">deallocate</strong>(void[] b); </dt> <dd>
<p>If <code>impl.deallocate</code> is not defined, returns <code>false</code>. Otherwise it forwards the call.</p> </dd> <dt class="d_decl" id="CSharedAllocatorImpl.deallocateAll">shared bool <strong id="deallocateAll">deallocateAll</strong>(); </dt> <dd>
<p>Calls <code>impl.deallocateAll()</code> and returns the result if defined, otherwise returns <code>false</code>.</p> </dd> <dt class="d_decl" id="CSharedAllocatorImpl.empty">shared Ternary <strong id="empty">empty</strong>(); </dt> <dd>
<p>Forwards to <code>impl.empty()</code> if defined, otherwise returns <code>Ternary.unknown</code>.</p> </dd> <dt class="d_decl" id="CSharedAllocatorImpl.allocateAll">shared void[] <strong id="allocateAll">allocateAll</strong>(); </dt> <dd>
<p>Returns <code>impl.allocateAll()</code> if present, <code>null</code> otherwise.</p> </dd> </dl> </dd> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1999&ndash;2021 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/std_experimental_allocator.html" class="_attribution-link">https://dlang.org/phobos/std_experimental_allocator.html</a>
  </p>
</div>
