<h1>std.experimental.checkedint</h1>  
<p>This module defines facilities for efficient checking of integral operations against overflow, casting with loss of precision, unexpected change of sign, etc. The checking (and possibly correction) can be done at operation level, for example <a href="#opChecked"><code>opChecked</code></a><code>!"+"(x, y, overflow)</code> adds two integrals <code>x</code> and <code>y</code> and sets <code>overflow</code> to <code>true</code> if an overflow occurred. The flag <code>overflow</code> (a <code>bool</code> passed by reference) is not touched if the operation succeeded, so the same flag can be reused for a sequence of operations and tested at the end. <br><br> Issuing individual checked operations is flexible and efficient but often tedious. The <a href="#Checked"><code>Checked</code></a> facility offers encapsulated integral wrappers that do all checking internally and have configurable behavior upon erroneous results. For example, <code>Checked!int</code> is a type that behaves like <code>int</code> but aborts execution immediately whenever involved in an operation that produces the arithmetically wrong result. The accompanying convenience function <a href="#checked"><code>checked</code></a> uses type deduction to convert a value <code>x</code> of integral type <code>T</code> to <code>Checked!T</code> by means of <code>checked(x)</code>. For example: <br><br> <pre data-language="d">void main()
{
    import std.experimental.checkedint, std.stdio;
    writeln((checked(5) + 7).get); // 12
    writeln((checked(10) * 1000 * 1000 * 1000).get); // Overflow
}
</pre> <br><br> Similarly, <code>checked(-1) &gt; uint(0)</code> aborts execution (even though the built-in comparison <code>int(-1) &gt; uint(0)</code> is surprisingly true due to language's conversion rules modeled after C). Thus, <code>Checked!int</code> is a virtually drop-in replacement for <code>int</code> useable in debug builds, to be replaced by <code>int</code> in release mode if efficiency demands it. <br><br> <code>Checked</code> has customizable behavior with the help of a second type parameter, <code>Hook</code>. Depending on what methods <code>Hook</code> defines, core operations on the underlying integral may be verified for overflow or completely redefined. If <code>Hook</code> defines no method at all and carries no state, there is no change in behavior, i.e. <code>Checked!(int, void)</code> is a wrapper around <code>int</code> that adds no customization at all. <br><br> This module provides a few predefined hooks (below) that add useful behavior to <code>Checked</code>: <br><br> <table>
 <tr>
<td><a href="#Abort"><code>Abort</code></a></td> <td> fails every incorrect operation with a message to <a href="std_stdio.html#%20%20%20%20%20%20%20%20stderr"><code>std.stdio. stderr</code></a> followed by a call to <code>assert(0)</code>. It is the default second parameter, i.e. <code>Checked!short</code> is the same as <code>Checked!(short, Abort)</code>. </td>
</tr> <tr>
<td><a href="#Throw"><code>Throw</code></a></td> <td> fails every incorrect operation by throwing an exception. </td>
</tr> <tr>
<td><a href="#Warn"><code>Warn</code></a></td> <td> prints incorrect operations to <a href="std_stdio.html#stderr"><code>std.stdio.stderr</code></a> but otherwise preserves the built-in behavior. </td>
</tr> <tr>
<td><a href="#ProperCompare"><code>ProperCompare</code></a></td> <td> fixes the comparison operators <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code> to return correct results in all circumstances, at a slight cost in efficiency. For example, <code>Checked!(uint, ProperCompare)(1) &gt; -1</code> is <code>true</code>, which is not the case for the built-in comparison. Also, comparing numbers for equality with floating-point numbers only passes if the integral can be converted to the floating-point number precisely, so as to preserve transitivity of equality. </td>
</tr> <tr>
<td><a href="#WithNaN"><code>WithNaN</code></a></td> <td> reserves a special "Not a Number" (NaN) value akin to the homonym value reserved for floating-point values. Once a <code>Checked!(X, WithNaN)</code> gets this special value, it preserves and propagates it until reassigned. <a href="#isNaN"><code>isNaN</code></a> can be used to query whether the object is not a number. </td>
</tr> <tr>
<td><a href="#Saturate"><code>Saturate</code></a></td> <td> implements saturating arithmetic, i.e. <code>Checked!(int, Saturate)</code> "stops" at <code>int.max</code> for all operations that would cause an <code>int</code> to overflow toward infinity, and at <code>int.min</code> for all operations that would correspondingly overflow toward negative infinity. </td>
</tr> </table> <br><br> <br><br> These policies may be used alone, e.g. <code>Checked!(uint, WithNaN)</code> defines a <code>uint</code>-like type that reaches a stable NaN state for all erroneous operations. They may also be "stacked" on top of each other, owing to the property that a checked integral emulates an actual integral, which means another checked integral can be built on top of it. Some combinations of interest include: <br><br> <table>
 <tr><td><code>Checked!(Checked!int, ProperCompare)</code></td></tr> <tr><td>defines an <code>int</code> with fixed comparison operators that will fail with <code>assert(0)</code> upon overflow. (Recall that <code>Abort</code> is the default policy.) The order in which policies are combined is important because the outermost policy (<code>ProperCompare</code> in this case) has the first crack at intercepting an operator. The converse combination <code>Checked!(Checked!(int, ProperCompare))</code> is meaningless because <code>Abort</code> will intercept comparison and will fail without giving <code>ProperCompare</code> a chance to intervene. </td></tr> <tr><td></td></tr> <tr><td><code>Checked!(Checked!(int, ProperCompare), WithNaN)</code></td></tr> <tr><td>defines an <code>int</code>-like type that supports a NaN value. For values that are not NaN, comparison works properly. Again the composition order is important; <code>Checked!(Checked!(int, WithNaN), ProperCompare)</code> does not have good semantics because <code>ProperCompare</code> intercepts comparisons before the numbers involved are tested for NaN. </td></tr> </table> <br><br> The hook's members are looked up statically in a Design by Introspection manner and are all optional. The table below illustrates the members that a hook type may define and their influence over the behavior of the <code>Checked</code> type using it. In the table, <code>hook</code> is an alias for <code>Hook</code> if the type <code>Hook</code> does not introduce any state, or an object of type <code>Hook</code> otherwise. <br><br> <table>

<tr>
<th scope="col">
<code>Hook</code> member</th> <th scope="col">Semantics in <code>Checked!(T, Hook)</code>
</th> </tr> <tr>
<td><code>defaultValue</code></td> <td>If defined, <code>Hook.defaultValue!T</code> is used as the default initializer of the payload.</td> </tr> <tr>
<td><code>min</code></td> <td>If defined, <code>Hook.min!T</code> is used as the minimum value of the payload.</td> </tr> <tr>
<td><code>max</code></td> <td>If defined, <code>Hook.max!T</code> is used as the maximum value of the payload.</td> </tr> <tr>
<td><code>hookOpCast</code></td> <td>If defined, <code>hook.hookOpCast!U(get)</code> is forwarded to unconditionally when the payload is to be cast to type <code>U</code>.</td> </tr> <tr>
<td><code>onBadCast</code></td> <td>If defined and <code>hookOpCast</code> is <i>not</i> defined, <code>onBadCast!U(get)</code> is forwarded to when the payload is to be cast to type <code>U</code> and the cast would lose information or force a change of sign.</td> </tr> <tr>
<td><code>hookOpEquals</code></td> <td>If defined, <code>hook.hookOpEquals(get, rhs)</code> is forwarded to unconditionally when the payload is compared for equality against value <code>rhs</code> of integral, floating point, or Boolean type.</td> </tr> <tr>
<td><code>hookOpCmp</code></td> <td>If defined, <code>hook.hookOpCmp(get, rhs)</code> is forwarded to unconditionally when the payload is compared for ordering against value <code>rhs</code> of integral, floating point, or Boolean type.</td> </tr> <tr>
<td><code>hookOpUnary</code></td> <td>If defined, <code>hook.hookOpUnary!op(get)</code> (where <code>op</code> is the operator symbol) is forwarded to for unary operators <code>-</code> and <code>~</code>. In addition, for unary operators <code>++</code> and <code>--</code>, <code>hook.hookOpUnary!op(payload)</code> is called, where <code>payload</code> is a reference to the value wrapped by <code>Checked</code> so the hook can change it.</td> </tr> <tr>
<td><code>hookOpBinary</code></td> <td>If defined, <code>hook.hookOpBinary!op(get, rhs)</code> (where <code>op</code> is the operator symbol and <code>rhs</code> is the right-hand side operand) is forwarded to unconditionally for binary operators <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>^^</code>, <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, and <code>&gt;&gt;&gt;</code>.</td> </tr> <tr>
<td><code>hookOpBinaryRight</code></td> <td>If defined, <code>hook.hookOpBinaryRight!op(lhs, get)</code> (where <code>op</code> is the operator symbol and <code>lhs</code> is the left-hand side operand) is forwarded to unconditionally for binary operators <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>^^</code>, <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, and <code>&gt;&gt;&gt;</code>.</td> </tr> <tr>
<td><code>onOverflow</code></td> <td>If defined, <code>hook.onOverflow!op(get)</code> is forwarded to for unary operators that overflow but only if <code>hookOpUnary</code> is not defined. Unary <code>~</code> does not overflow; unary <code>-</code> overflows only when the most negative value of a signed type is negated, and the result of the hook call is returned. When the increment or decrement operators overflow, the payload is assigned the result of <code>hook.onOverflow!op(get)</code>. When a binary operator overflows, the result of <code>hook.onOverflow!op(get, rhs)</code> is returned, but only if <code>Hook</code> does not define <code>hookOpBinary</code>.</td> </tr> <tr>
<td><code>hookOpOpAssign</code></td> <td>If defined, <code>hook.hookOpOpAssign!op(payload, rhs)</code> (where <code>op</code> is the operator symbol and <code>rhs</code> is the right-hand side operand) is forwarded to unconditionally for binary operators <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, <code>^^=</code>, <code>&amp;=</code>, <code>|=</code>, <code>^=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>, and <code>&gt;&gt;&gt;=</code>.</td> </tr> <tr>
<td><code>onLowerBound</code></td> <td>If defined, <code>hook.onLowerBound(value, bound)</code> (where <code>value</code> is the value being assigned) is forwarded to when the result of binary operators <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, <code>^^=</code>, <code>&amp;=</code>, <code>|=</code>, <code>^=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>, and <code>&gt;&gt;&gt;=</code> is smaller than the smallest value representable by <code>T</code>.</td> </tr> <tr>
<td><code>onUpperBound</code></td> <td>If defined, <code>hook.onUpperBound(value, bound)</code> (where <code>value</code> is the value being assigned) is forwarded to when the result of binary operators <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, <code>^^=</code>, <code>&amp;=</code>, <code>|=</code>, <code>^=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>, and <code>&gt;&gt;&gt;=</code> is larger than the largest value representable by <code>T</code>.</td> </tr> <tr>
<td><code>hookToHash</code></td> <td>If defined, <code>hook.hookToHash(payload)</code> (where <code>payload</code> is a reference to the value wrapped by Checked) is forwarded to when <code>toHash</code> is called on a Checked type. Custom hashing can be implemented in a <code>Hook</code>, otherwise the built-in hashing is used.</td> </tr> </table> </p> <dl>
<dt>Source</dt>
<dd> <span class="phobos_src"><a class="https" href="https://github.com/dlang/phobos/blob/master/std/experimental/checkedint.d">std/experimental/checkedint.d</a></span>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int[] concatAndAdd(int[] a, int[] b, int offset)
{
    // Aborts on overflow on size computation
    auto r = new int[(checked(a.length) + b.length).get];
    // Aborts on overflow on element computation
    foreach (i; 0 .. a.length)
        r[i] = (a[i] + checked(offset)).get;
    foreach (i; 0 .. b.length)
        r[i + a.length] = (b[i] + checked(offset)).get;
    return r;
}
writeln(concatAndAdd([1, 2, 3], [4, 5], -1)); // [0, 1, 2, 3, 4]
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<code>Saturate</code> stops at an overflow <pre data-language="d">auto x = (cast(byte) 127).checked!Saturate;
writeln(x); // 127
x++;
writeln(x); // 127
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<code>WithNaN</code> has a special "Not a Number" (NaN) value akin to the homonym value reserved for floating-point values <pre data-language="d">auto x = 100.checked!WithNaN;
writeln(x); // 100
x /= 0;
assert(x.isNaN);
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<code>ProperCompare</code> fixes the comparison operators ==, !=, &lt;, &lt;=, &gt;, and &gt;= to return correct results <pre data-language="d">uint x = 1;
auto y = x.checked!ProperCompare;
assert(x &lt; -1); // built-in comparison
assert(y &gt; -1); // ProperCompare
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<code>Throw</code> fails every incorrect operation by throwing an exception <pre data-language="d">import std.exception : assertThrown;
auto x = -1.checked!Throw;
assertThrown(x / 0);
assertThrown(x + int.min);
assertThrown(x == uint.max);
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="Checked">struct <strong id="Checked">Checked</strong>(T, Hook = Abort) if (isIntegral!T || is(T == <strong id="Checked">Checked</strong>!(U, H), U, H)); </dt> <dd>
<p>Checked integral type wraps an integral <code>T</code> and customizes its behavior with the help of a <code>Hook</code> type. The type wrapped must be one of the predefined integrals (unqualified), or another instance of <code>Checked</code>.</p> <dl>
<dt class="d_decl" id="Checked.Representation">alias <strong id="Representation">Representation</strong> = T; </dt> <dd>
<p>The type of the integral subject to checking.</p> </dd> <dt class="d_decl" id="Checked.hook">Hook <strong id="hook">hook</strong>; </dt> <dd>
<p><code>hook</code> is a member variable if it has state, or an alias for <code>Hook</code> otherwise.</p> </dd> <dt class="d_decl" id="Checked.get">inout auto <strong id="get">get</strong>(); </dt> <dd>
<p>Returns a copy of the underlying value.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto x = checked(ubyte(42));
static assert(is(typeof(x.get()) == ubyte));
writeln(x.get); // 42
const y = checked(ubyte(42));
static assert(is(typeof(y.get()) == const ubyte));
writeln(y.get); // 42
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Checked.min">enum Checked!(T, Hook) <strong id="min">min</strong>; <br><br>enum Checked!(T, Hook) <strong id="max">max</strong>; </dt> <dd>
<p>Defines the minimum and maximum. These values are hookable by defining <code>Hook.min</code> and/or <code>Hook.max</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>Defines the minimum and maximum. These values are hookable by defining <code>Hook.min</code> and/or <code>Hook.max</code>. <pre data-language="d">writeln(Checked!short.min); // -32768
writeln(Checked!(short, WithNaN).min); // -32767
writeln(Checked!(uint, WithNaN).max); // uint.max - 1
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Checked.this">this(U)(U rhs)<br><small>  Constraints: if (valueConvertible!(U, T) || !isIntegral!T &amp;&amp; is(typeof(T(rhs))) || is(U == Checked!(V, W), V, W) &amp;&amp; is(typeof(Checked!(T, Hook)(rhs.get)))); </small>
</dt> <dd>
<p>Constructor taking a value properly convertible to the underlying type. <code>U</code> may be either an integral that can be converted to <code>T</code> without a loss, or another <code>Checked</code> instance whose representation may be in turn converted to <code>T</code> without a loss.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto a = checked(42L);
writeln(a); // 42
auto b = Checked!long(4242); // convert 4242 to long
writeln(b); // 4242
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Checked.opAssign">ref Checked <strong id="opAssign">opAssign</strong>(U)(U rhs) return<br><small>  Constraints: if (is(typeof(Checked!(T, Hook)(rhs)))); </small>
</dt> <dd>
<p>Assignment operator. Has the same constraints as the constructor.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">Checked!long a;
a = 42L;
writeln(a); // 42
a = 4242;
writeln(a); // 4242
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">Checked!long a, b;
a = b = 3;
assert(a == 3 &amp;&amp; b == 3);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Checked.opCast">U <strong id="opCast">opCast</strong>(U, this _)()<br><small>  Constraints: if (isIntegral!U || isFloatingPoint!U || is(U == bool)); </small>
</dt> <dd>
<p>Casting operator to integral, <code>bool</code>, or floating point type. If <code>Hook</code> defines <code>hookOpCast</code>, the call immediately returns <code>hook.hookOpCast!U(get)</code>. Otherwise, casting to <code>bool</code> yields <code> get != 0</code> and casting to another integral that can represent all values of <code>T</code> returns <code>get</code> promoted to <code>U</code>. </p>
<p>If a cast to a floating-point type is requested and <code>Hook</code> defines <code>onBadCast</code>, the cast is verified by ensuring <code>get == cast(T) U(get)</code>. If that is not <code>true</code>, <code>hook.onBadCast!U(get)</code> is returned. <br><br> If a cast to an integral type is requested and <code>Hook</code> defines <code>onBadCast</code>, the cast is verified by ensuring <code>get</code> and <code>cast(U) get</code> are the same arithmetic number. (Note that <code>int(-1)</code> and <code>uint(1)</code> are different values arithmetically although they have the same bitwise representation and compare equal by language rules.) If the numbers are not arithmetically equal, <code>hook.onBadCast!U(get)</code> is returned.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(cast(uint)checked(42)); // 42
writeln(cast(uint)checked!WithNaN(-42)); // uint.max
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Checked.opEquals">bool <strong id="opEquals">opEquals</strong>(U, this _)(U rhs)<br><small>  Constraints: if (isIntegral!U || isFloatingPoint!U || is(U == bool) || is(U == Checked!(V, W), V, W) &amp;&amp; is(typeof(this == rhs.payload))); </small>
</dt> <dd>
<p>Compares <code>this</code> against <code>rhs</code> for equality. If <code>Hook</code> defines <code>hookOpEquals</code>, the function forwards to <code> hook.hookOpEquals(get, rhs)</code>. Otherwise, the result of the built-in operation <code>get == rhs</code> is returned. </p>
<p>If <code>U</code> is also an instance of <code>Checked</code>, both hooks (left- and right-hand side) are introspected for the method <code>hookOpEquals</code>. If both define it, priority is given to the left-hand side.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.traits : isUnsigned;

static struct MyHook
{
    static bool thereWereErrors;
    static bool hookOpEquals(L, R)(L lhs, R rhs)
    {
        if (lhs != rhs) return false;
        static if (isUnsigned!L &amp;&amp; !isUnsigned!R)
        {
            if (lhs &gt; 0 &amp;&amp; rhs &lt; 0) thereWereErrors = true;
        }
        else static if (isUnsigned!R &amp;&amp; !isUnsigned!L)
            if (lhs &lt; 0 &amp;&amp; rhs &gt; 0) thereWereErrors = true;
        // Preserve built-in behavior.
        return true;
    }
}
auto a = checked!MyHook(-42);
writeln(a); // uint(-42)
assert(MyHook.thereWereErrors);
MyHook.thereWereErrors = false;
writeln(checked!MyHook(uint(-42))); // -42
assert(MyHook.thereWereErrors);
static struct MyHook2
{
    static bool hookOpEquals(L, R)(L lhs, R rhs)
    {
        return lhs == rhs;
    }
}
MyHook.thereWereErrors = false;
writeln(checked!MyHook2(uint(-42))); // a
// Hook on left hand side takes precedence, so no errors
assert(!MyHook.thereWereErrors);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Checked.toHash">const nothrow @safe size_t <strong id="toHash">toHash</strong>(); </dt> <dd>
<p>Generates a hash for <code>this</code>. If <code>Hook</code> defines <code>hookToHash</code>, the call immediately returns <code>hook.hookToHash(payload)</code>. If <code>Hook</code> does not implement <code>hookToHash</code>, but it has state, a hash will be generated for the <code>Hook</code> using the built-in function and it will be xored with the hash of the <code>payload</code>.</p> </dd> <dt class="d_decl" id="Checked.opCmp">auto <strong id="opCmp">opCmp</strong>(U, this _)(const U rhs)<br><small>  Constraints: if (isIntegral!U || isFloatingPoint!U || is(U == bool)); </small><br><br>auto <strong id="opCmp">opCmp</strong>(U, Hook1, this _)(Checked!(U, Hook1) rhs); </dt> <dd>
<p>Compares <code>this</code> against <code>rhs</code> for ordering. If <code>Hook</code> defines <code>hookOpCmp</code>, the function forwards to <code>hook.hookOpCmp(get, rhs)</code>. Otherwise, the result of the built-in comparison operation is returned. </p>
<p>If <code>U</code> is also an instance of <code>Checked</code>, both hooks (left- and right-hand side) are introspected for the method <code>hookOpCmp</code>. If both define it, priority is given to the left-hand side.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.traits : isUnsigned;

static struct MyHook
{
    static bool thereWereErrors;
    static int hookOpCmp(L, R)(L lhs, R rhs)
    {
        static if (isUnsigned!L &amp;&amp; !isUnsigned!R)
        {
            if (rhs &lt; 0 &amp;&amp; rhs &gt;= lhs)
                thereWereErrors = true;
        }
        else static if (isUnsigned!R &amp;&amp; !isUnsigned!L)
        {
            if (lhs &lt; 0 &amp;&amp; lhs &gt;= rhs)
                thereWereErrors = true;
        }
        // Preserve built-in behavior.
        return lhs &lt; rhs ? -1 : lhs &gt; rhs;
    }
}
auto a = checked!MyHook(-42);
assert(a &gt; uint(42));
assert(MyHook.thereWereErrors);
static struct MyHook2
{
    static int hookOpCmp(L, R)(L lhs, R rhs)
    {
        // Default behavior
        return lhs &lt; rhs ? -1 : lhs &gt; rhs;
    }
}
MyHook.thereWereErrors = false;
assert(Checked!(uint, MyHook2)(uint(-42)) &lt;= a);
//assert(Checked!(uint, MyHook2)(uint(-42)) &gt;= a);
// Hook on left hand side takes precedence, so no errors
assert(!MyHook.thereWereErrors);
assert(a &lt;= Checked!(uint, MyHook2)(uint(-42)));
assert(MyHook.thereWereErrors);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Checked.opUnary">auto <strong id="opUnary">opUnary</strong>(string op, this _)()<br><small>  Constraints: if (op == "+" || op == "-" || op == "~"); </small><br><br>ref Checked <strong id="opUnary">opUnary</strong>(string op)() return<br><small>  Constraints: if (op == "++" || op == "--"); </small>
</dt> <dd>
<p>Defines unary operators <code>+</code>, <code>-</code>, <code>~</code>, <code>++</code>, and <code>--</code>. Unary <code>+</code> is not overridable and always has built-in behavior (returns <code>this</code>). For the others, if <code>Hook</code> defines <code>hookOpUnary</code>, <code>opUnary</code> forwards to <code> Checked!(typeof(hook.hookOpUnary!op(get)), Hook)(hook.hookOpUnary!op(get))</code>. </p>
<p>If <code>Hook</code> does not define <code>hookOpUnary</code> but defines <code>onOverflow</code>, <code>opUnary</code> forwards to <code>hook.onOverflow!op(get)</code> in case an overflow occurs. For <code>++</code> and <code>--</code>, the payload is assigned from the result of the call to <code>onOverflow</code>. <br><br> Note that unary <code>-</code> is considered to overflow if <code>T</code> is a signed integral of 32 or 64 bits and is equal to the most negative value. This is because that value has no positive negation.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static struct MyHook
{
    static bool thereWereErrors;
    static L hookOpUnary(string x, L)(L lhs)
    {
        if (x == "-" &amp;&amp; lhs == -lhs) thereWereErrors = true;
        return -lhs;
    }
}
auto a = checked!MyHook(long.min);
writeln(a); // -a
assert(MyHook.thereWereErrors);
auto b = checked!void(42);
writeln(++b); // 43
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Checked.opBinary">auto <strong id="opBinary">opBinary</strong>(string op, Rhs)(const Rhs rhs)<br><small>  Constraints: if (isIntegral!Rhs || isFloatingPoint!Rhs || is(Rhs == bool)); </small><br><br>const auto <strong id="opBinary">opBinary</strong>(string op, Rhs)(const Rhs rhs)<br><small>  Constraints: if (isIntegral!Rhs || isFloatingPoint!Rhs || is(Rhs == bool)); </small><br><br>auto <strong id="opBinary">opBinary</strong>(string op, U, Hook1)(Checked!(U, Hook1) rhs); <br><br>const auto <strong id="opBinary">opBinary</strong>(string op, U, Hook1)(Checked!(U, Hook1) rhs); </dt> <dd>
<p>Defines binary operators <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>^^</code>, <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, and <code>&gt;&gt;&gt;</code>. If <code>Hook</code> defines <code>hookOpBinary</code>, <code>opBinary</code> forwards to <code> Checked!(typeof(hook.hookOpBinary!op(get, rhs)), Hook)(hook.hookOpBinary!op(get, rhs))</code>. </p>
<p>If <code>Hook</code> does not define <code>hookOpBinary</code> but defines <code>onOverflow</code>, <code>opBinary</code> forwards to <code>hook.onOverflow!op(get, rhs)</code> in case an overflow occurs. <br><br> If two <code>Checked</code> instances are involved in a binary operation and both define <code>hookOpBinary</code>, the left-hand side hook has priority. If both define <code>onOverflow</code>, a compile-time error occurs.</p> </dd> <dt class="d_decl" id="Checked.opBinaryRight">auto <strong id="opBinaryRight">opBinaryRight</strong>(string op, Lhs)(const Lhs lhs)<br><small>  Constraints: if (isIntegral!Lhs || isFloatingPoint!Lhs || is(Lhs == bool)); </small><br><br>const auto <strong id="opBinaryRight">opBinaryRight</strong>(string op, Lhs)(const Lhs lhs)<br><small>  Constraints: if (isIntegral!Lhs || isFloatingPoint!Lhs || is(Lhs == bool)); </small>
</dt> <dd>
<p>Defines binary operators <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>^^</code>, <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, and <code>&gt;&gt;&gt;</code> for the case when a built-in numeric or Boolean type is on the left-hand side, and a <code>Checked</code> instance is on the right-hand side. </p> </dd> <dt class="d_decl" id="Checked.opOpAssign">ref Checked <strong id="opOpAssign">opOpAssign</strong>(string op, Rhs)(const Rhs rhs) return<br><small>  Constraints: if (isIntegral!Rhs || isFloatingPoint!Rhs || is(Rhs == bool)); </small><br><br>ref Checked <strong id="opOpAssign">opOpAssign</strong>(string op, Rhs)(const Rhs rhs) return<br><small>  Constraints: if (is(Rhs == Checked!(RhsT, RhsHook), RhsT, RhsHook)); </small>
</dt> <dd>
<p>Defines operators <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, <code>^^=</code>, <code>&amp;=</code>, <code>|=</code>, <code>^=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>, and <code>&gt;&gt;&gt;=</code>. </p>
<p>If <code>Hook</code> defines <code>hookOpOpAssign</code>, <code>opOpAssign</code> forwards to <code>hook.hookOpOpAssign!op(payload, rhs)</code>, where <code>payload</code> is a reference to the internally held data so the hook can change it. <br><br> Otherwise, the operator first evaluates <code>auto result = opBinary!op(payload, rhs).payload</code>, which is subject to the hooks in <code>opBinary</code>. Then, if <code>result</code> is less than <code>Checked!(T, Hook).min</code> and if <code>Hook</code> defines <code>onLowerBound</code>, the payload is assigned from <code> hook.onLowerBound(result, min)</code>. If <code>result</code> is greater than <code>Checked!(T, Hook).max</code> and if <code>Hook</code> defines <code>onUpperBound</code>, the payload is assigned from <code>hook.onUpperBound(result, min)</code>. <br><br> If the right-hand side is also a Checked but with a different hook or underlying type, the hook and underlying type of this Checked takes precedence. <br><br> In all other cases, the built-in behavior is carried out. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>op</td> <td>The operator involved (without the <code>"="</code>, e.g. <code>"+"</code> for <code>"+="</code> etc)</td>
</tr> <tr>
<td>Rhs <code>rhs</code>
</td> <td>The right-hand side of the operator (left-hand side is <code>this</code>)</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A reference to <code>this</code>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static struct MyHook
{
    static bool thereWereErrors;
    static T onLowerBound(Rhs, T)(Rhs rhs, T bound)
    {
        thereWereErrors = true;
        return bound;
    }
    static T onUpperBound(Rhs, T)(Rhs rhs, T bound)
    {
        thereWereErrors = true;
        return bound;
    }
}
auto x = checked!MyHook(byte.min);
x -= 1;
assert(MyHook.thereWereErrors);
MyHook.thereWereErrors = false;
x = byte.max;
x += 1;
assert(MyHook.thereWereErrors);
</pre> </dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="checked">Checked!(T, Hook) <strong id="checked">checked</strong>(Hook = Abort, T)(const T value)<br><small>  Constraints: if (is(typeof(Checked!(T, Hook)(value)))); </small>
</dt> <dd>
<p>Convenience function that turns an integral into the corresponding <code>Checked</code> instance by using template argument deduction. The hook type may be specified (by default <code>Abort</code>). </p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(is(typeof(checked(42)) == Checked!int));
writeln(checked(42)); // Checked!int(42)
static assert(is(typeof(checked!WithNaN(42)) == Checked!(int, WithNaN)));
writeln(checked!WithNaN(42)); // Checked!(int, WithNaN)(42)
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Abort">struct <strong id="Abort">Abort</strong>; </dt> <dd>
<p>Force all integral errors to fail by printing an error message to <code>stderr</code> and then abort the program. <code>Abort</code> is the default second argument for <code>Checked</code>. </p> <dl>
<dt class="d_decl" id="Abort.onBadCast">Dst <strong id="onBadCast">onBadCast</strong>(Dst, Src)(Src src); </dt> <dd>
<p>Called automatically upon a bad cast (one that loses precision or attempts to convert a negative value to an unsigned type). The source type is <code>Src</code> and the destination type is <code>Dst</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Src <code>src</code>
</td> <td>The source of the cast</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>Nominally the result is the desired value of the cast operation, which will be forwarded as the result of the cast. For <code>Abort</code>, the function never returns because it aborts the program.</dd>
</dl> </dd> <dt class="d_decl" id="Abort.onLowerBound">T <strong id="onLowerBound">onLowerBound</strong>(Rhs, T)(Rhs rhs, T bound); <br><br>T <strong id="onUpperBound">onUpperBound</strong>(Rhs, T)(Rhs rhs, T bound); </dt> <dd>
<p>Called automatically upon a bounds error. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Rhs <code>rhs</code>
</td> <td>The right-hand side value in the assignment, after the operator has been evaluated</td>
</tr> <tr>
<td>T <code>bound</code>
</td> <td>The value of the bound being violated</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>Nominally the result is the desired value of the operator, which will be forwarded as result. For <code>Abort</code>, the function never returns because it aborts the program.</dd>
</dl> </dd> <dt class="d_decl" id="Abort.hookOpEquals">bool <strong id="hookOpEquals">hookOpEquals</strong>(Lhs, Rhs)(Lhs lhs, Rhs rhs); </dt> <dd>
<p>Called automatically upon a comparison for equality. In case of a erroneous comparison (one that would make a signed negative value appear equal to an unsigned positive value), this hook issues <code>assert(0)</code> which terminates the application. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Lhs <code>lhs</code>
</td> <td>The first argument of <code>Checked</code>, e.g. <code>int</code> if the left-hand side of the operator is <code>Checked!int</code>
</td>
</tr> <tr>
<td>Rhs <code>rhs</code>
</td> <td>The right-hand side type involved in the operator</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>Upon a correct comparison, returns the result of the comparison. Otherwise, the function terminates the application so it never returns.</dd>
</dl> </dd> <dt class="d_decl" id="Abort.hookOpCmp">int <strong id="hookOpCmp">hookOpCmp</strong>(Lhs, Rhs)(Lhs lhs, Rhs rhs); </dt> <dd>
<p>Called automatically upon a comparison for ordering using one of the operators <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, or <code>&gt;=</code>. In case the comparison is erroneous (i.e. it would make a signed negative value appear greater than or equal to an unsigned positive value), then application is terminated with <code>assert(0)</code>. Otherwise, the three-state result is returned (positive if <code>lhs &gt; rhs</code>, negative if <code>lhs &lt; rhs</code>, <code>0</code> otherwise). </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Lhs <code>lhs</code>
</td> <td>The first argument of <code>Checked</code>, e.g. <code>int</code> if the left-hand side of the operator is <code>Checked!int</code>
</td>
</tr> <tr>
<td>Rhs <code>rhs</code>
</td> <td>The right-hand side type involved in the operator</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>For correct comparisons, returns a positive integer if <code>lhs &gt; rhs</code>, a negative integer if <code>lhs &lt; rhs</code>, <code>0</code> if the two are equal. Upon a mistaken comparison such as <code>int(-1) &lt; uint(0)</code>, the function never returns because it aborts the program.</dd>
</dl> </dd> <dt class="d_decl" id="Abort.onOverflow">typeof(~Lhs()) <strong id="onOverflow">onOverflow</strong>(string x, Lhs)(Lhs lhs); <br><br>typeof(Lhs() + Rhs()) <strong id="onOverflow">onOverflow</strong>(string x, Lhs, Rhs)(Lhs lhs, Rhs rhs); </dt> <dd>
<p>Called automatically upon an overflow during a unary or binary operation. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>x</td> <td>The operator, e.g. <code>-</code>
</td>
</tr> <tr>
<td>Lhs <code>lhs</code>
</td> <td>The left-hand side (or sole) argument</td>
</tr> <tr>
<td>Rhs <code>rhs</code>
</td> <td>The right-hand side type involved in the operator</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>Nominally the result is the desired value of the operator, which will be forwarded as result. For <code>Abort</code>, the function never returns because it aborts the program.</dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="Throw">struct <strong id="Throw">Throw</strong>; </dt> <dd>
<p>Force all integral errors to fail by throwing an exception of type <code>Throw.CheckFailure</code>. The message coming with the error is similar to the one printed by <code>Warn</code>. </p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">void test(T)()
{
    Checked!(int, Throw) x;
    x = 42;
    auto x1 = cast(T) x;
    writeln(x1); // 42
    x = T.max + 1;
    import std.exception : assertThrown, assertNotThrown;
    assertThrown(cast(T) x);
    x = x.max;
    assertThrown(x += 42);
    assertThrown(x += 42L);
    x = x.min;
    assertThrown(-x);
    assertThrown(x -= 42);
    assertThrown(x -= 42L);
    x = -1;
    assertNotThrown(x == -1);
    assertThrown(x == uint(-1));
    assertNotThrown(x &lt;= -1);
    assertThrown(x &lt;= uint(-1));
}
test!short;
test!(const short);
test!(immutable short);
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="Throw.CheckFailure">class <strong id="CheckFailure">CheckFailure</strong>: object.Exception; </dt> <dd>
<p>Exception type thrown upon any failure.</p> </dd> <dt class="d_decl" id="Throw.onBadCast">Dst <strong id="onBadCast">onBadCast</strong>(Dst, Src)(Src src); </dt> <dd>
<p>Called automatically upon a bad cast (one that loses precision or attempts to convert a negative value to an unsigned type). The source type is <code>Src</code> and the destination type is <code>Dst</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Src <code>src</code>
</td> <td>The source of the cast</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>Nominally the result is the desired value of the cast operation, which will be forwarded as the result of the cast. For <code>Throw</code>, the function never returns because it throws an exception.</dd>
</dl> </dd> <dt class="d_decl" id="Throw.onLowerBound">T <strong id="onLowerBound">onLowerBound</strong>(Rhs, T)(Rhs rhs, T bound); <br><br>T <strong id="onUpperBound">onUpperBound</strong>(Rhs, T)(Rhs rhs, T bound); </dt> <dd>
<p>Called automatically upon a bounds error. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Rhs <code>rhs</code>
</td> <td>The right-hand side value in the assignment, after the operator has been evaluated</td>
</tr> <tr>
<td>T <code>bound</code>
</td> <td>The value of the bound being violated</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>Nominally the result is the desired value of the operator, which will be forwarded as result. For <code>Throw</code>, the function never returns because it throws.</dd>
</dl> </dd> <dt class="d_decl" id="Throw.hookOpEquals">bool <strong id="hookOpEquals">hookOpEquals</strong>(L, R)(L lhs, R rhs); </dt> <dd>
<p>Called automatically upon a comparison for equality. Throws upon an erroneous comparison (one that would make a signed negative value appear equal to an unsigned positive value). </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>L <code>lhs</code>
</td> <td>The first argument of <code>Checked</code>, e.g. <code>int</code> if the left-hand side of the operator is <code>Checked!int</code>
</td>
</tr> <tr>
<td>R <code>rhs</code>
</td> <td>The right-hand side type involved in the operator</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The result of the comparison. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<code>CheckFailure</code> if the comparison is mathematically erroneous.</dd>
</dl> </dd> <dt class="d_decl" id="Throw.hookOpCmp">int <strong id="hookOpCmp">hookOpCmp</strong>(Lhs, Rhs)(Lhs lhs, Rhs rhs); </dt> <dd>
<p>Called automatically upon a comparison for ordering using one of the operators <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, or <code>&gt;=</code>. In case the comparison is erroneous (i.e. it would make a signed negative value appear greater than or equal to an unsigned positive value), throws a <code>Throw.CheckFailure</code> exception. Otherwise, the three-state result is returned (positive if <code>lhs &gt; rhs</code>, negative if <code>lhs &lt; rhs</code>, <code>0</code> otherwise). </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Lhs <code>lhs</code>
</td> <td>The first argument of <code>Checked</code>, e.g. <code>int</code> if the left-hand side of the operator is <code>Checked!int</code>
</td>
</tr> <tr>
<td>Rhs <code>rhs</code>
</td> <td>The right-hand side type involved in the operator</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>For correct comparisons, returns a positive integer if <code>lhs &gt; rhs</code>, a negative integer if <code>lhs &lt; rhs</code>, <code>0</code> if the two are equal. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>Upon a mistaken comparison such as <code>int(-1) &lt; uint(0)</code>, the function never returns because it throws a <code>Throw.CheckedFailure</code> exception.</dd>
</dl> </dd> <dt class="d_decl" id="Throw.onOverflow">typeof(~Lhs()) <strong id="onOverflow">onOverflow</strong>(string x, Lhs)(Lhs lhs); <br><br>typeof(Lhs() + Rhs()) <strong id="onOverflow">onOverflow</strong>(string x, Lhs, Rhs)(Lhs lhs, Rhs rhs); </dt> <dd>
<p>Called automatically upon an overflow during a unary or binary operation. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>x</td> <td>The operator, e.g. <code>-</code>
</td>
</tr> <tr>
<td>Lhs <code>lhs</code>
</td> <td>The left-hand side (or sole) argument</td>
</tr> <tr>
<td>Rhs <code>rhs</code>
</td> <td>The right-hand side type involved in the operator</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>Nominally the result is the desired value of the operator, which will be forwarded as result. For <code>Throw</code>, the function never returns because it throws an exception.</dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="Warn">struct <strong id="Warn">Warn</strong>; </dt> <dd>
<p>Hook that prints to <code>stderr</code> a trace of all integral errors, without affecting default behavior.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto x = checked!Warn(42);
short x1 = cast(short) x;
//x += long(int.max);
auto y = checked!Warn(cast(const int) 42);
short y1 = cast(const byte) y;
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="Warn.onBadCast">Dst <strong id="onBadCast">onBadCast</strong>(Dst, Src)(Src src); </dt> <dd>
<p>Called automatically upon a bad cast from <code>src</code> to type <code>Dst</code> (one that loses precision or attempts to convert a negative value to an unsigned type). </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Src <code>src</code>
</td> <td>The source of the cast</td>
</tr> <tr>
<td>Dst</td> <td>The target type of the cast</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd><code>cast(Dst) src</code></dd>
</dl> </dd> <dt class="d_decl" id="Warn.onLowerBound">Lhs <strong id="onLowerBound">onLowerBound</strong>(Rhs, T)(Rhs rhs, T bound); <br><br>T <strong id="onUpperBound">onUpperBound</strong>(Rhs, T)(Rhs rhs, T bound); </dt> <dd>
<p>Called automatically upon a bad <code>opOpAssign</code> call (one that loses precision or attempts to convert a negative value to an unsigned type). </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Rhs <code>rhs</code>
</td> <td>The right-hand side value in the assignment, after the operator has been evaluated</td>
</tr> <tr>
<td>T <code>bound</code>
</td> <td>The bound being violated</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd><code>cast(Lhs) rhs</code></dd>
</dl> </dd> <dt class="d_decl" id="Warn.hookOpEquals">bool <strong id="hookOpEquals">hookOpEquals</strong>(Lhs, Rhs)(Lhs lhs, Rhs rhs); </dt> <dd>
<p>Called automatically upon a comparison for equality. In case of an Erroneous comparison (one that would make a signed negative value appear equal to an unsigned positive value), writes a warning message to <code>stderr</code> as a side effect. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Lhs <code>lhs</code>
</td> <td>The first argument of <code>Checked</code>, e.g. <code>int</code> if the left-hand side of the operator is <code>Checked!int</code>
</td>
</tr> <tr>
<td>Rhs <code>rhs</code>
</td> <td>The right-hand side type involved in the operator</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>In all cases the function returns the built-in result of <code>lhs == rhs</code>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto x = checked!Warn(-42);
// Passes
writeln(x); // -42
// Passes but prints a warning
// assert(x == uint(-42));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Warn.hookOpCmp">int <strong id="hookOpCmp">hookOpCmp</strong>(Lhs, Rhs)(Lhs lhs, Rhs rhs); </dt> <dd>
<p>Called automatically upon a comparison for ordering using one of the operators <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, or <code>&gt;=</code>. In case the comparison is erroneous (i.e. it would make a signed negative value appear greater than or equal to an unsigned positive value), then a warning message is printed to <code>stderr</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Lhs <code>lhs</code>
</td> <td>The first argument of <code>Checked</code>, e.g. <code>int</code> if the left-hand side of the operator is <code>Checked!int</code>
</td>
</tr> <tr>
<td>Rhs <code>rhs</code>
</td> <td>The right-hand side type involved in the operator</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>In all cases, returns <code>lhs &lt; rhs ? -1 : lhs &gt; rhs</code>. The result is not autocorrected in case of an erroneous comparison.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto x = checked!Warn(-42);
// Passes
assert(x &lt;= -42);
// Passes but prints a warning
// assert(x &lt;= uint(-42));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Warn.onOverflow">typeof(~Lhs()) <strong id="onOverflow">onOverflow</strong>(string x, Lhs)(ref Lhs lhs); <br><br>typeof(Lhs() + Rhs()) <strong id="onOverflow">onOverflow</strong>(string x, Lhs, Rhs)(Lhs lhs, Rhs rhs); </dt> <dd>
<p>Called automatically upon an overflow during a unary or binary operation. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>x</td> <td>The operator involved</td>
</tr> <tr>
<td>Lhs</td> <td>The first argument of <code>Checked</code>, e.g. <code>int</code> if the left-hand side of the operator is <code>Checked!int</code>
</td>
</tr> <tr>
<td>Rhs</td> <td>The right-hand side type involved in the operator</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>mixin(x ~ "lhs")</code> for unary, <code>mixin("lhs" ~ x ~ "rhs")</code> for binary</dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="ProperCompare">struct <strong id="ProperCompare">ProperCompare</strong>; </dt> <dd>
<p>Hook that provides arithmetically correct comparisons for equality and ordering. Comparing an object of type <code>Checked!(X, ProperCompare)</code> against another integral (for equality or ordering) ensures that no surprising conversions from signed to unsigned integral occur before the comparison. Using <code>Checked!(X, ProperCompare)</code> on either side of a comparison for equality against a floating-point number makes sure the integral can be properly converted to the floating point type, thus making sure equality is transitive. </p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">alias opEqualsProper = ProperCompare.hookOpEquals;
assert(opEqualsProper(42, 42));
assert(opEqualsProper(42.0, 42.0));
assert(opEqualsProper(42u, 42));
assert(opEqualsProper(42, 42u));
writeln(-1); // 4294967295u
assert(!opEqualsProper(-1, 4294967295u));
assert(!opEqualsProper(const uint(-1), -1));
assert(!opEqualsProper(uint(-1), -1.0));
writeln(3_000_000_000U); // -1_294_967_296
assert(!opEqualsProper(3_000_000_000U, -1_294_967_296));
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="ProperCompare.hookOpEquals">bool <strong id="hookOpEquals">hookOpEquals</strong>(L, R)(L lhs, R rhs); </dt> <dd>
<p>Hook for <code>==</code> and <code>!=</code> that ensures comparison against integral values has the behavior expected by the usual arithmetic rules. The built-in semantics yield surprising behavior when comparing signed values against unsigned values for equality, for example <code>uint.max == -1</code> or <code>-1_294_967_296 == 3_000_000_000u</code>. The call <code>hookOpEquals(x, y)</code> returns <code>true</code> if and only if <code>x</code> and <code>y</code> represent the same arithmetic number. </p>
<p>If one of the numbers is an integral and the other is a floating-point number, <code>hookOpEquals(x, y)</code> returns <code>true</code> if and only if the integral can be converted exactly (without approximation) to the floating-point number. This is in order to preserve transitivity of equality: if <code> hookOpEquals(x, y)</code> and <code>hookOpEquals(y, z)</code> then <code>hookOpEquals(y, z)</code>, in case <code>x</code>, <code>y</code>, and <code>z</code> are a mix of integral and floating-point numbers. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>L <code>lhs</code>
</td> <td>The left-hand side of the comparison for equality</td>
</tr> <tr>
<td>R <code>rhs</code>
</td> <td>The right-hand side of the comparison for equality</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The result of the comparison, <code>true</code> if the values are equal</dd>
</dl> </dd> <dt class="d_decl" id="ProperCompare.hookOpCmp">auto <strong id="hookOpCmp">hookOpCmp</strong>(L, R)(L lhs, R rhs); </dt> <dd>
<p>Hook for <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code> that ensures comparison against integral values has the behavior expected by the usual arithmetic rules. The built-in semantics yield surprising behavior when comparing signed values against unsigned values, for example <code>0u &lt; -1</code>. The call <code>hookOpCmp(x, y)</code> returns <code>-1</code> if and only if <code>x</code> is smaller than <code>y</code> in abstract arithmetic sense. </p>
<p>If one of the numbers is an integral and the other is a floating-point number, <code>hookOpEquals(x, y)</code> returns a floating-point number that is <code>-1</code> if <code>x &lt; y</code>, <code>0</code> if <code>x == y</code>, <code>1</code> if <code>x &gt; y</code>, and <code>NaN</code> if the floating-point number is <code>NaN</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>L <code>lhs</code>
</td> <td>The left-hand side of the comparison for ordering</td>
</tr> <tr>
<td>R <code>rhs</code>
</td> <td>The right-hand side of the comparison for ordering</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The result of the comparison (negative if <code>lhs &lt; rhs</code>, positive if <code> lhs &gt; rhs</code>, <code>0</code> if the values are equal)</dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="WithNaN">struct <strong id="WithNaN">WithNaN</strong>; </dt> <dd>
<p>Hook that reserves a special value as a "Not a Number" representative. For signed integrals, the reserved value is <code>T.min</code>. For signed integrals, the reserved value is <code>T.max</code>. </p>
<p>The default value of a <code>Checked!(X, WithNaN)</code> is its NaN value, so care must be taken that all variables are explicitly initialized. Any arithmetic and logic operation involving at least on NaN becomes NaN itself. All of <code>a == b</code>, <code>a &lt; b</code>, <code>a &gt; b</code>, <code>a &lt;= b</code>, <code>a &gt;= b</code> yield <code>false</code> if at least one of <code>a</code> and <code>b</code> is NaN.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto x1 = Checked!(int, WithNaN)();
assert(x1.isNaN);
writeln(x1.get); // int.min
assert(x1 != x1);
assert(!(x1 &lt; x1));
assert(!(x1 &gt; x1));
assert(!(x1 == x1));
++x1;
assert(x1.isNaN);
writeln(x1.get); // int.min
--x1;
assert(x1.isNaN);
writeln(x1.get); // int.min
x1 = 42;
assert(!x1.isNaN);
writeln(x1); // x1
assert(x1 &lt;= x1);
assert(x1 &gt;= x1);
static assert(x1.min == int.min + 1);
x1 += long(int.max);
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="WithNaN.defaultValue">enum T <strong id="defaultValue">defaultValue</strong>(T); </dt> <dd>
<p>The default value used for values not explicitly initialized. It is the NaN value, i.e. <code>T.min</code> for signed integrals and <code>T.max</code> for unsigned integrals.</p> </dd> <dt class="d_decl" id="WithNaN.max">enum T <strong id="max">max</strong>(T); <br><br>enum T <strong id="min">min</strong>(T); </dt> <dd>
<p>The maximum value representable is <code>T.max</code> for signed integrals, <code> T.max - 1</code> for unsigned integrals. The minimum value representable is <code> T.min + 1</code> for signed integrals, <code>0</code> for unsigned integrals.</p> </dd> <dt class="d_decl" id="WithNaN.hookOpCast">Lhs <strong id="hookOpCast">hookOpCast</strong>(Lhs, Rhs)(Rhs rhs); </dt> <dd>
<p>If <code>rhs</code> is <code>WithNaN.defaultValue!Rhs</code>, returns <code>WithNaN.defaultValue!Lhs</code>. Otherwise, returns <code>cast(Lhs) rhs</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Rhs <code>rhs</code>
</td> <td>the value being cast (<code>Rhs</code> is the first argument to <code>Checked</code>)</td>
</tr> <tr>
<td>Lhs</td> <td>the target type of the cast</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The result of the cast operation.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto x = checked!WithNaN(422);
writeln((cast(ubyte)x)); // 255
x = checked!WithNaN(-422);
writeln((cast(byte)x)); // -128
writeln(cast(short)x); // -422
assert(cast(bool) x);
x = x.init; // set back to NaN
assert(x != true);
assert(x != false);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="WithNaN.hookOpEquals">bool <strong id="hookOpEquals">hookOpEquals</strong>(Lhs, Rhs)(Lhs lhs, Rhs rhs); </dt> <dd>
<p>Returns <code>false</code> if <code>lhs == WithNaN.defaultValue!Lhs</code>, <code>lhs == rhs</code> otherwise. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Lhs <code>lhs</code>
</td> <td>The left-hand side of the comparison (<code>Lhs</code> is the first argument to <code>Checked</code>)</td>
</tr> <tr>
<td>Rhs <code>rhs</code>
</td> <td>The right-hand side of the comparison</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd><code>lhs != WithNaN.defaultValue!Lhs &amp;&amp; lhs == rhs</code></dd>
</dl> </dd> <dt class="d_decl" id="WithNaN.hookOpCmp">double <strong id="hookOpCmp">hookOpCmp</strong>(Lhs, Rhs)(Lhs lhs, Rhs rhs); </dt> <dd>
<p>If <code>lhs == WithNaN.defaultValue!Lhs</code>, returns <code>double.init</code>. Otherwise, has the same semantics as the default comparison. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Lhs <code>lhs</code>
</td> <td>The left-hand side of the comparison (<code>Lhs</code> is the first argument to <code>Checked</code>)</td>
</tr> <tr>
<td>Rhs <code>rhs</code>
</td> <td>The right-hand side of the comparison</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>double.init</code> if <code>lhs == WitnNaN.defaultValue!Lhs</code>, <code>-1.0</code> if <code> lhs &lt; rhs</code>, <code>0.0</code> if <code>lhs == rhs</code>, <code>1.0</code> if <code>lhs &gt; rhs</code>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">Checked!(int, WithNaN) x;
assert(!(x &lt; 0) &amp;&amp; !(x &gt; 0) &amp;&amp; !(x == 0));
x = 1;
assert(x &gt; 0 &amp;&amp; !(x &lt; 0) &amp;&amp; !(x == 0));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="WithNaN.hookOpUnary">auto <strong id="hookOpUnary">hookOpUnary</strong>(string x, T)(ref T v); </dt> <dd>
<p>Defines hooks for unary operators <code>-</code>, <code>~</code>, <code>++</code>, and <code>--</code>. </p>
<p>For <code>-</code> and <code>~</code>, if <code>v == WithNaN.defaultValue!T</code>, returns <code>WithNaN.defaultValue!T</code>. Otherwise, the semantics is the same as for the built-in operator. <br><br> For <code>++</code> and <code>--</code>, if <code>v == WithNaN.defaultValue!Lhs</code> or the operation would result in an overflow, sets <code>v</code> to <code>WithNaN.defaultValue!T</code>. Otherwise, the semantics is the same as for the built-in operator. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>x</td> <td>The operator symbol</td>
</tr> <tr>
<td>T <code>v</code>
</td> <td>The left-hand side of the comparison (<code>T</code> is the first argument to <code>Checked</code>)</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd><ul>
<li>For <code>x == "-" || x == "~"</code>: If <code>v == WithNaN.defaultValue!T</code>, the function returns <code>WithNaN.defaultValue!T</code>. Otherwise it returns the normal result of the operator.</li> <li>For <code>x == "++" || x == "--"</code>: The function returns <code>void</code>.</li>
</ul></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">Checked!(int, WithNaN) x;
++x;
assert(x.isNaN);
x = 1;
assert(!x.isNaN);
x = -x;
++x;
assert(!x.isNaN);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="WithNaN.hookOpBinary">auto <strong id="hookOpBinary">hookOpBinary</strong>(string x, L, R)(L lhs, R rhs); </dt> <dd>
<p>Defines hooks for binary operators <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>^^</code>, <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, and <code>&gt;&gt;&gt;</code> for cases where a <code>Checked</code> object is the left-hand side operand. If <code>lhs == WithNaN.defaultValue!Lhs</code>, returns <code>WithNaN.defaultValue!(typeof(lhs + rhs))</code> without evaluating the operand. Otherwise, evaluates the operand. If evaluation does not overflow, returns the result. Otherwise, returns <code>WithNaN.defaultValue!(typeof(lhs + rhs))</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>x</td> <td>The operator symbol</td>
</tr> <tr>
<td>L <code>lhs</code>
</td> <td>The left-hand side operand (<code>Lhs</code> is the first argument to <code>Checked</code>)</td>
</tr> <tr>
<td>R <code>rhs</code>
</td> <td>The right-hand side operand</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>If <code>lhs != WithNaN.defaultValue!Lhs</code> and the operator does not overflow, the function returns the same result as the built-in operator. In all other cases, returns <code>WithNaN.defaultValue!(typeof(lhs + rhs))</code>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">Checked!(int, WithNaN) x;
assert((x + 1).isNaN);
x = 100;
assert(!(x + 1).isNaN);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="WithNaN.hookOpBinaryRight">auto <strong id="hookOpBinaryRight">hookOpBinaryRight</strong>(string x, L, R)(L lhs, R rhs); </dt> <dd>
<p>Defines hooks for binary operators <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>^^</code>, <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, and <code>&gt;&gt;&gt;</code> for cases where a <code>Checked</code> object is the right-hand side operand. If <code>rhs == WithNaN.defaultValue!Rhs</code>, returns <code>WithNaN.defaultValue!(typeof(lhs + rhs))</code> without evaluating the operand. Otherwise, evaluates the operand. If evaluation does not overflow, returns the result. Otherwise, returns <code>WithNaN.defaultValue!(typeof(lhs + rhs))</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>x</td> <td>The operator symbol</td>
</tr> <tr>
<td>L <code>lhs</code>
</td> <td>The left-hand side operand</td>
</tr> <tr>
<td>R <code>rhs</code>
</td> <td>The right-hand side operand (<code>Rhs</code> is the first argument to <code>Checked</code>)</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>If <code>rhs != WithNaN.defaultValue!Rhs</code> and the operator does not overflow, the function returns the same result as the built-in operator. In all other cases, returns <code>WithNaN.defaultValue!(typeof(lhs + rhs))</code>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">Checked!(int, WithNaN) x;
assert((1 + x).isNaN);
x = 100;
assert(!(1 + x).isNaN);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="WithNaN.hookOpOpAssign">void <strong id="hookOpOpAssign">hookOpOpAssign</strong>(string x, L, R)(ref L lhs, R rhs); </dt> <dd>
<p>Defines hooks for binary operators <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, <code>^^=</code>, <code>&amp;=</code>, <code>|=</code>, <code>^=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>, and <code>&gt;&gt;&gt;=</code> for cases where a <code>Checked</code> object is the left-hand side operand. If <code>lhs == WithNaN.defaultValue!Lhs</code>, no action is carried. Otherwise, evaluates the operand. If evaluation does not overflow and fits in <code>Lhs</code> without loss of information or change of sign, sets <code>lhs</code> to the result. Otherwise, sets <code>lhs</code> to <code>WithNaN.defaultValue!Lhs</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>x</td> <td>The operator symbol (without the <code>=</code>)</td>
</tr> <tr>
<td>L <code>lhs</code>
</td> <td>The left-hand side operand (<code>Lhs</code> is the first argument to <code>Checked</code>)</td>
</tr> <tr>
<td>R <code>rhs</code>
</td> <td>The right-hand side operand</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd><code>void</code></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">Checked!(int, WithNaN) x;
x += 4;
assert(x.isNaN);
x = 0;
x += 4;
assert(!x.isNaN);
x += int.max;
assert(x.isNaN);
</pre> </dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="isNaN">bool <strong id="isNaN">isNaN</strong>(T)(const Checked!(T, WithNaN) x); </dt> <dd>
<p>Queries whether a <code>Checked!(T, WithNaN)</code> object is not a number (NaN). </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Checked!(T, WithNaN) <code>x</code>
</td> <td>the <code>Checked</code> instance queried</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if <code>x</code> is a NaN, <code>false</code> otherwise</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto x1 = Checked!(int, WithNaN)();
assert(x1.isNaN);
x1 = 1;
assert(!x1.isNaN);
x1 = x1.init;
assert(x1.isNaN);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Saturate">struct <strong id="Saturate">Saturate</strong>; </dt> <dd>
<p>Hook that implements <i>saturation</i>, i.e. any arithmetic operation that would overflow leaves the result at its extreme value (<code>min</code> or <code>max</code> depending on the direction of the overflow). </p>
<p>Saturation is not sticky; if a value reaches its saturation value, another operation may take it back to normal range.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto x = checked!Saturate(int.max);
++x;
writeln(x); // int.max
--x;
writeln(x); // int.max - 1
x = int.min;
writeln(-x); // int.max
x -= 42;
writeln(x); // int.min
writeln(x * -2); // int.max
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="Saturate.onLowerBound">T <strong id="onLowerBound">onLowerBound</strong>(Rhs, T)(Rhs rhs, T bound); <br><br>T <strong id="onUpperBound">onUpperBound</strong>(Rhs, T)(Rhs rhs, T bound); </dt> <dd>
<p>Implements saturation for operators <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, <code>^^=</code>, <code>&amp;=</code>, <code>|=</code>, <code>^=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>, and <code>&gt;&gt;&gt;=</code>. This hook is called if the result of the binary operation does not fit in <code>Lhs</code> without loss of information or a change in sign. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Rhs</td> <td>The right-hand side type in the assignment, after the operation has been computed</td>
</tr> <tr>
<td>T <code>bound</code>
</td> <td>The bound being violated</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>Lhs.max</code> if <code>rhs &gt;= 0</code>, <code>Lhs.min</code> otherwise.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto x = checked!Saturate(short(100));
x += 33000;
writeln(x); // short.max
x -= 70000;
writeln(x); // short.min
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Saturate.onOverflow">auto <strong id="onOverflow">onOverflow</strong>(string x, Lhs)(Lhs lhs); <br><br>typeof(Lhs() + Rhs()) <strong id="onOverflow">onOverflow</strong>(string x, Lhs, Rhs)(Lhs lhs, Rhs rhs); </dt> <dd>
<p>Implements saturation for operators <code>+</code>, <code>-</code> (unary and binary), <code>*</code>, <code>/</code>, <code>%</code>, <code>^^</code>, <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, and <code>&gt;&gt;&gt;</code>. </p>
<p>For unary <code>-</code>, <code>onOverflow</code> is called if <code>lhs == Lhs.min</code> and <code>Lhs</code> is a signed type. The function returns <code>Lhs.max</code>. <br><br> For binary operators, the result is as follows: <ul>
<li>
<code>Lhs.max</code> if the result overflows in the positive direction, on division by <code>0</code>, or on shifting right by a negative value</li> <li>
<code>Lhs.min</code> if the result overflows in the negative direction</li> <li>
<code>0</code> if <code>lhs</code> is being shifted left by a negative value, or shifted right by a large positive value</li>
</ul> </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>x</td> <td>The operator involved in the <code>opAssign</code> operation</td>
</tr> <tr>
<td>Lhs</td> <td>The left-hand side of the operator (<code>Lhs</code> is the first argument to <code>Checked</code>)</td>
</tr> <tr>
<td>Rhs</td> <td>The right-hand side type in the operator</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The saturated result of the operator.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(checked!Saturate(int.max) + 1); // int.max
writeln(checked!Saturate(100)^^10); // int.max
writeln(checked!Saturate(-100)^^10); // int.max
writeln(checked!Saturate(100) / 0); // int.max
writeln(checked!Saturate(100) &lt;&lt; -1); // 0
writeln(checked!Saturate(100) &lt;&lt; 33); // int.max
writeln(checked!Saturate(100) &gt;&gt; -1); // int.max
writeln(checked!Saturate(100) &gt;&gt; 33); // 0
</pre> </dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="opChecked">typeof(mixin(x == "cmp" ? "0" : "L() " ~ x ~ " R()")) <strong id="opChecked">opChecked</strong>(string x, L, R)(const L lhs, const R rhs, ref bool overflow)<br><small>  Constraints: if (isIntegral!L &amp;&amp; isIntegral!R); </small>
</dt> <dd>
<p>Defines binary operations with overflow checking for any two integral types. The result type obeys the language rules (even when they may be counterintuitive), and <code>overflow</code> is set if an overflow occurs (including inadvertent change of signedness, e.g. <code>-1</code> is converted to <code>uint</code>). Conceptually the behavior is: </p>
<p><ol>
<li>Perform the operation in infinite precision</li> <li>If the infinite-precision result fits in the result type, return it and do not touch <code>overflow</code>
</li> <li>Otherwise, set <code>overflow</code> to <code>true</code> and return an unspecified value</li> </ol> <br><br> The implementation exploits properties of types and operations to minimize additional work. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>x</td> <td>The binary operator involved, e.g. <code>/</code>
</td>
</tr> <tr>
<td>L <code>lhs</code>
</td> <td>The left-hand side of the operator</td>
</tr> <tr>
<td>R <code>rhs</code>
</td> <td>The right-hand side of the operator</td>
</tr> <tr>
<td>bool <code>overflow</code>
</td> <td>The overflow indicator (assigned <code>true</code> in case there's an error)</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The result of the operation, which is the same as the built-in operator</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">bool overflow;
assert(opChecked!"+"(const short(1), short(1), overflow) == 2 &amp;&amp; !overflow);
assert(opChecked!"+"(1, 1, overflow) == 2 &amp;&amp; !overflow);
assert(opChecked!"+"(1, 1u, overflow) == 2 &amp;&amp; !overflow);
assert(opChecked!"+"(-1, 1u, overflow) == 0 &amp;&amp; !overflow);
assert(opChecked!"+"(1u, -1, overflow) == 0 &amp;&amp; !overflow);
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">bool overflow;
assert(opChecked!"-"(1, 1, overflow) == 0 &amp;&amp; !overflow);
assert(opChecked!"-"(1, 1u, overflow) == 0 &amp;&amp; !overflow);
assert(opChecked!"-"(1u, -1, overflow) == 2 &amp;&amp; !overflow);
assert(opChecked!"-"(-1, 1u, overflow) == 0 &amp;&amp; overflow);
</pre> </dd>
</dl> </dd> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1999&ndash;2021 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/std_experimental_checkedint.html" class="_attribution-link">https://dlang.org/phobos/std_experimental_checkedint.html</a>
  </p>
</div>
