<h1>std.ascii</h1>  <p>Functions which operate on ASCII characters. </p>
<p>All of the functions in std.ascii accept Unicode characters but effectively ignore them if they're not ASCII. All <code>isX</code> functions return <code>false</code> for non-ASCII characters, and all <code>toX</code> functions do nothing to non-ASCII characters. <br><br> For functions which operate on Unicode characters, see <a href="std_uni.html"><code>std.uni</code></a>. <br><br>  <table>

<tr>
<th scope="col">Category</th> <th scope="col">Functions</th>
</tr> <tr>
<td>Validation</td> <td> <a href="#isAlpha"><code>isAlpha</code></a> <a href="#isAlphaNum"><code>isAlphaNum</code></a> <a href="#isASCII"><code>isASCII</code></a> <a href="#isControl"><code>isControl</code></a> <a href="#isDigit"><code>isDigit</code></a> <a href="#isGraphical"><code>isGraphical</code></a> <a href="#isHexDigit"><code>isHexDigit</code></a> <a href="#isOctalDigit"><code>isOctalDigit</code></a> <a href="#isPrintable"><code>isPrintable</code></a> <a href="#isPunctuation"><code>isPunctuation</code></a> <a href="#isUpper"><code>isUpper</code></a> <a href="#isWhite"><code>isWhite</code></a> </td>
</tr> <tr>
<td>Conversions</td> <td> <a href="#toLower"><code>toLower</code></a> <a href="#toUpper"><code>toUpper</code></a> </td>
</tr> <tr>
<td>Constants</td> <td> <a href="#digits"><code>digits</code></a> <a href="#fullHexDigits"><code>fullHexDigits</code></a> <a href="#hexDigits"><code>hexDigits</code></a> <a href="#letters"><code>letters</code></a> <a href="#lowercase"><code>lowercase</code></a> <a href="#lowerHexDigits"><code>lowerHexDigits</code></a> <a href="#newline"><code>newline</code></a> <a href="#octalDigits"><code>octalDigits</code></a> <a href="#uppercase"><code>uppercase</code></a> <a href="#whitespace"><code>whitespace</code></a> </td>
</tr> <tr>
<td>Enums</td> <td> <a href="#ControlChar"><code>ControlChar</code></a> <a href="#LetterCase"><code>LetterCase</code></a> </td>
</tr> </table> </p> <dl>
<dt>References</dt>
<dd> <a href="http://www.digitalmars.com/d/ascii-table.html">ASCII Table</a>, <a href="http://en.wikipedia.org/wiki/Ascii">Wikipedia</a> </dd>
</dl> <dl>
<dt>License:</dt>
<dd>
<a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>. </dd>
</dl> <dl>
<dt>Authors:</dt>
<dd>
<a href="http://digitalmars.com">Walter Bright</a> and <a href="http://jmdavisprog.com">Jonathan M Davis</a> </dd>
</dl> <dl>
<dt>Source</dt>
<dd> <span class="phobos_src"><a class="https" href="https://github.com/dlang/phobos/blob/master/std/ascii.d">std/ascii.d</a></span>
</dd>
</dl> <dl>
<dt class="d_decl" id="fullHexDigits">immutable string <strong id="fullHexDigits">fullHexDigits</strong>; </dt> <dd>
<p>0 .. 9A .. Fa .. f</p> </dd> <dt class="d_decl" id="hexDigits">immutable string <strong id="hexDigits">hexDigits</strong>; </dt> <dd>
<p>0 .. 9A .. F</p> </dd> <dt class="d_decl" id="lowerHexDigits">immutable string <strong id="lowerHexDigits">lowerHexDigits</strong>; </dt> <dd>
<p>0 .. 9a .. f</p> </dd> <dt class="d_decl" id="digits">immutable string <strong id="digits">digits</strong>; </dt> <dd>
<p>0 .. 9</p> </dd> <dt class="d_decl" id="octalDigits">immutable string <strong id="octalDigits">octalDigits</strong>; </dt> <dd>
<p>0 .. 7</p> </dd> <dt class="d_decl" id="letters">immutable string <strong id="letters">letters</strong>; </dt> <dd>
<p>A .. Za .. z</p> </dd> <dt class="d_decl" id="uppercase">immutable string <strong id="uppercase">uppercase</strong>; </dt> <dd>
<p>A .. Z</p> </dd> <dt class="d_decl" id="lowercase">immutable string <strong id="lowercase">lowercase</strong>; </dt> <dd>
<p>a .. z</p> </dd> <dt class="d_decl" id="whitespace">immutable string <strong id="whitespace">whitespace</strong>; </dt> <dd>
<p>ASCII whitespace</p> </dd> <dt class="d_decl" id="LetterCase">enum <strong id="LetterCase">LetterCase</strong>: bool; </dt> <dd>
<p>Letter case specifier.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.conv : to;

writeln(42.to!string(16, LetterCase.upper)); // "2A"
writeln(42.to!string(16, LetterCase.lower)); // "2a"
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.digest.hmac : hmac;
import std.digest : toHexString;
import std.digest.sha : SHA1;
import std.string : representation;

const sha1HMAC = "A very long phrase".representation
    .hmac!SHA1("secret".representation)
    .toHexString!(LetterCase.lower);
writeln(sha1HMAC); // "49f2073c7bf58577e8c9ae59fe8cfd37c9ab94e5"
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="LetterCase.upper"><strong id="upper">upper</strong></dt> <dd>
<p>Upper case letters</p> </dd> <dt class="d_decl" id="LetterCase.lower"><strong id="lower">lower</strong></dt> <dd>
<p>Lower case letters</p> </dd> </dl> </dd> <dt class="d_decl" id="ControlChar">enum <strong id="ControlChar">ControlChar</strong>: char; </dt> <dd>
<p>All control characters in the ASCII table (<a href="https://www.asciitable.com">source</a>).</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison, std.algorithm.searching, std.range, std.traits;

// Because all ASCII characters fit in char, so do these
static assert(ControlChar.ack.sizeof == 1);

// All control characters except del are in row starting from 0
static assert(EnumMembers!ControlChar.only.until(ControlChar.del).equal(iota(32)));

static assert(ControlChar.nul == '\0');
static assert(ControlChar.bel == '\a');
static assert(ControlChar.bs  == '\b');
static assert(ControlChar.ff  == '\f');
static assert(ControlChar.lf  == '\n');
static assert(ControlChar.cr  == '\r');
static assert(ControlChar.tab == '\t');
static assert(ControlChar.vt  == '\v');
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.conv;
//Control character table can be used in place of hexcodes.
with (ControlChar) assert(text("Phobos", us, "Deimos", us, "Tango", rs) == "Phobos\x1FDeimos\x1FTango\x1E");
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="ControlChar.nul"><strong id="nul">nul</strong></dt> <dd>
<p>Null</p> </dd> <dt class="d_decl" id="ControlChar.soh"><strong id="soh">soh</strong></dt> <dd>
<p>Start of heading</p> </dd> <dt class="d_decl" id="ControlChar.stx"><strong id="stx">stx</strong></dt> <dd>
<p>Start of text</p> </dd> <dt class="d_decl" id="ControlChar.etx"><strong id="etx">etx</strong></dt> <dd>
<p>End of text</p> </dd> <dt class="d_decl" id="ControlChar.eot"><strong id="eot">eot</strong></dt> <dd>
<p>End of transmission</p> </dd> <dt class="d_decl" id="ControlChar.enq"><strong id="enq">enq</strong></dt> <dd>
<p>Enquiry</p> </dd> <dt class="d_decl" id="ControlChar.ack"><strong id="ack">ack</strong></dt> <dd>
<p>Acknowledge</p> </dd> <dt class="d_decl" id="ControlChar.bel"><strong id="bel">bel</strong></dt> <dd>
<p>Bell</p> </dd> <dt class="d_decl" id="ControlChar.bs"><strong id="bs">bs</strong></dt> <dd>
<p>Backspace</p> </dd> <dt class="d_decl" id="ControlChar.tab"><strong id="tab">tab</strong></dt> <dd>
<p>Horizontal tab</p> </dd> <dt class="d_decl" id="ControlChar.lf"><strong id="lf">lf</strong></dt> <dd>
<p>NL line feed, new line</p> </dd> <dt class="d_decl" id="ControlChar.vt"><strong id="vt">vt</strong></dt> <dd>
<p>Vertical tab</p> </dd> <dt class="d_decl" id="ControlChar.ff"><strong id="ff">ff</strong></dt> <dd>
<p>NP form feed, new page</p> </dd> <dt class="d_decl" id="ControlChar.cr"><strong id="cr">cr</strong></dt> <dd>
<p>Carriage return</p> </dd> <dt class="d_decl" id="ControlChar.so"><strong id="so">so</strong></dt> <dd>
<p>Shift out</p> </dd> <dt class="d_decl" id="ControlChar.si"><strong id="si">si</strong></dt> <dd>
<p>Shift in</p> </dd> <dt class="d_decl" id="ControlChar.dle"><strong id="dle">dle</strong></dt> <dd>
<p>Data link escape</p> </dd> <dt class="d_decl" id="ControlChar.dc1"><strong id="dc1">dc1</strong></dt> <dd>
<p>Device control 1</p> </dd> <dt class="d_decl" id="ControlChar.dc2"><strong id="dc2">dc2</strong></dt> <dd>
<p>Device control 2</p> </dd> <dt class="d_decl" id="ControlChar.dc3"><strong id="dc3">dc3</strong></dt> <dd>
<p>Device control 3</p> </dd> <dt class="d_decl" id="ControlChar.dc4"><strong id="dc4">dc4</strong></dt> <dd>
<p>Device control 4</p> </dd> <dt class="d_decl" id="ControlChar.nak"><strong id="nak">nak</strong></dt> <dd>
<p>Negative acknowledge</p> </dd> <dt class="d_decl" id="ControlChar.syn"><strong id="syn">syn</strong></dt> <dd>
<p>Synchronous idle</p> </dd> <dt class="d_decl" id="ControlChar.etb"><strong id="etb">etb</strong></dt> <dd>
<p>End of transmission block</p> </dd> <dt class="d_decl" id="ControlChar.can"><strong id="can">can</strong></dt> <dd>
<p>Cancel</p> </dd> <dt class="d_decl" id="ControlChar.em"><strong id="em">em</strong></dt> <dd>
<p>End of medium</p> </dd> <dt class="d_decl" id="ControlChar.sub"><strong id="sub">sub</strong></dt> <dd>
<p>Substitute</p> </dd> <dt class="d_decl" id="ControlChar.esc"><strong id="esc">esc</strong></dt> <dd>
<p>Escape</p> </dd> <dt class="d_decl" id="ControlChar.fs"><strong id="fs">fs</strong></dt> <dd>
<p>File separator</p> </dd> <dt class="d_decl" id="ControlChar.gs"><strong id="gs">gs</strong></dt> <dd>
<p>Group separator</p> </dd> <dt class="d_decl" id="ControlChar.rs"><strong id="rs">rs</strong></dt> <dd>
<p>Record separator</p> </dd> <dt class="d_decl" id="ControlChar.us"><strong id="us">us</strong></dt> <dd>
<p>Unit separator</p> </dd> <dt class="d_decl" id="ControlChar.del"><strong id="del">del</strong></dt> <dd>
<p>Delete</p> </dd> </dl> </dd> <dt class="d_decl" id="newline">immutable string <strong id="newline">newline</strong>; </dt> <dd>
<p>Newline sequence for this system.</p> </dd> <dt class="d_decl" id="isAlphaNum">pure nothrow @nogc @safe bool <strong id="isAlphaNum">isAlphaNum</strong>(dchar c); </dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>dchar <code>c</code>
</td> <td>The character to test.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>Whether <code>c</code> is a letter or a number (0 .. 9, a .. z, A .. Z).</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert( isAlphaNum('A'));
assert( isAlphaNum('1'));
assert(!isAlphaNum('#'));

// N.B.: does not return true for non-ASCII Unicode alphanumerics:
assert(!isAlphaNum('á'));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isAlpha">pure nothrow @nogc @safe bool <strong id="isAlpha">isAlpha</strong>(dchar c); </dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>dchar <code>c</code>
</td> <td>The character to test.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>Whether <code>c</code> is an ASCII letter (A .. Z, a .. z).</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert( isAlpha('A'));
assert(!isAlpha('1'));
assert(!isAlpha('#'));

// N.B.: does not return true for non-ASCII Unicode alphabetic characters:
assert(!isAlpha('á'));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isLower">pure nothrow @nogc @safe bool <strong id="isLower">isLower</strong>(dchar c); </dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>dchar <code>c</code>
</td> <td>The character to test.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>Whether <code>c</code> is a lowercase ASCII letter (a .. z).</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert( isLower('a'));
assert(!isLower('A'));
assert(!isLower('#'));

// N.B.: does not return true for non-ASCII Unicode lowercase letters
assert(!isLower('á'));
assert(!isLower('Á'));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isUpper">pure nothrow @nogc @safe bool <strong id="isUpper">isUpper</strong>(dchar c); </dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>dchar <code>c</code>
</td> <td>The character to test.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>Whether <code>c</code> is an uppercase ASCII letter (A .. Z).</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert( isUpper('A'));
assert(!isUpper('a'));
assert(!isUpper('#'));

// N.B.: does not return true for non-ASCII Unicode uppercase letters
assert(!isUpper('á'));
assert(!isUpper('Á'));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isDigit">pure nothrow @nogc @safe bool <strong id="isDigit">isDigit</strong>(dchar c); </dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>dchar <code>c</code>
</td> <td>The character to test.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>Whether <code>c</code> is a digit (0 .. 9).</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert( isDigit('3'));
assert( isDigit('8'));
assert(!isDigit('B'));
assert(!isDigit('#'));

// N.B.: does not return true for non-ASCII Unicode numbers
assert(!isDigit('０')); // full-width digit zero (U+FF10)
assert(!isDigit('４')); // full-width digit four (U+FF14)
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isOctalDigit">pure nothrow @nogc @safe bool <strong id="isOctalDigit">isOctalDigit</strong>(dchar c); </dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>dchar <code>c</code>
</td> <td>The character to test.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>Whether <code>c</code> is a digit in base 8 (0 .. 7).</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert( isOctalDigit('0'));
assert( isOctalDigit('7'));
assert(!isOctalDigit('8'));
assert(!isOctalDigit('A'));
assert(!isOctalDigit('#'));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isHexDigit">pure nothrow @nogc @safe bool <strong id="isHexDigit">isHexDigit</strong>(dchar c); </dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>dchar <code>c</code>
</td> <td>The character to test.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>Whether <code>c</code> is a digit in base 16 (0 .. 9, A .. F, a .. f).</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert( isHexDigit('0'));
assert( isHexDigit('A'));
assert( isHexDigit('f')); // lowercase hex digits are accepted
assert(!isHexDigit('g'));
assert(!isHexDigit('G'));
assert(!isHexDigit('#'));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isWhite">pure nothrow @nogc @safe bool <strong id="isWhite">isWhite</strong>(dchar c); </dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>dchar <code>c</code>
</td> <td>The character to test.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>Whether or not <code>c</code> is a whitespace character. That includes the space, tab, vertical tab, form feed, carriage return, and linefeed characters.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert( isWhite(' '));
assert( isWhite('\t'));
assert( isWhite('\n'));
assert(!isWhite('1'));
assert(!isWhite('a'));
assert(!isWhite('#'));

// N.B.: Does not return true for non-ASCII Unicode whitespace characters.
static import std.uni;
assert(std.uni.isWhite('\u00A0'));
assert(!isWhite('\u00A0')); // std.ascii.isWhite
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isControl">pure nothrow @nogc @safe bool <strong id="isControl">isControl</strong>(dchar c); </dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>dchar <code>c</code>
</td> <td>The character to test.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>Whether <code>c</code> is a control character.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert( isControl('\0'));
assert( isControl('\022'));
assert( isControl('\n')); // newline is both whitespace and control
assert(!isControl(' '));
assert(!isControl('1'));
assert(!isControl('a'));
assert(!isControl('#'));

// N.B.: non-ASCII Unicode control characters are not recognized:
assert(!isControl('\u0080'));
assert(!isControl('\u2028'));
assert(!isControl('\u2029'));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isPunctuation">pure nothrow @nogc @safe bool <strong id="isPunctuation">isPunctuation</strong>(dchar c); </dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>dchar <code>c</code>
</td> <td>The character to test.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>Whether or not <code>c</code> is a punctuation character. That includes all ASCII characters which are not control characters, letters, digits, or whitespace.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert( isPunctuation('.'));
assert( isPunctuation(','));
assert( isPunctuation(':'));
assert( isPunctuation('!'));
assert( isPunctuation('#'));
assert( isPunctuation('~'));
assert( isPunctuation('+'));
assert( isPunctuation('_'));

assert(!isPunctuation('1'));
assert(!isPunctuation('a'));
assert(!isPunctuation(' '));
assert(!isPunctuation('\n'));
assert(!isPunctuation('\0'));

// N.B.: Non-ASCII Unicode punctuation characters are not recognized.
assert(!isPunctuation('\u2012')); // (U+2012 = en-dash)
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isGraphical">pure nothrow @nogc @safe bool <strong id="isGraphical">isGraphical</strong>(dchar c); </dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>dchar <code>c</code>
</td> <td>The character to test.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>Whether or not <code>c</code> is a printable character other than the space character.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert( isGraphical('1'));
assert( isGraphical('a'));
assert( isGraphical('#'));
assert(!isGraphical(' ')); // whitespace is not graphical
assert(!isGraphical('\n'));
assert(!isGraphical('\0'));

// N.B.: Unicode graphical characters are not regarded as such.
assert(!isGraphical('á'));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isPrintable">pure nothrow @nogc @safe bool <strong id="isPrintable">isPrintable</strong>(dchar c); </dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>dchar <code>c</code>
</td> <td>The character to test.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>Whether or not <code>c</code> is a printable character - including the space character.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert( isPrintable(' '));  // whitespace is printable
assert( isPrintable('1'));
assert( isPrintable('a'));
assert( isPrintable('#'));
assert(!isPrintable('\0')); // control characters are not printable

// N.B.: Printable non-ASCII Unicode characters are not recognized.
assert(!isPrintable('á'));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isASCII">pure nothrow @nogc @safe bool <strong id="isASCII">isASCII</strong>(dchar c); </dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>dchar <code>c</code>
</td> <td>The character to test.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>Whether or not <code>c</code> is in the ASCII character set - i.e. in the range 0 .. 0x7F.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert( isASCII('a'));
assert(!isASCII('á'));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="toLower">auto <strong id="toLower">toLower</strong>(C)(C c)<br><small>  Constraints: if (is(C : dchar)); </small>
</dt> <dd>
<p>Converts an ASCII letter to lowercase. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>C <code>c</code>
</td> <td>A character of any type that implicitly converts to <code>dchar</code>. In the case where it's a built-in type, or an enum of a built-in type, <code>Unqual!(OriginalType!C)</code> is returned, whereas if it's a user-defined type, <code>dchar</code> is returned.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The corresponding lowercase letter, if <code>c</code> is an uppercase ASCII character, otherwise <code>c</code> itself.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(toLower('a')); // 'a'
writeln(toLower('A')); // 'a'
writeln(toLower('#')); // '#'

// N.B.: Non-ASCII Unicode uppercase letters are not converted.
writeln(toLower('Á')); // 'Á'
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="toUpper">auto <strong id="toUpper">toUpper</strong>(C)(C c)<br><small>  Constraints: if (is(C : dchar)); </small>
</dt> <dd>
<p>Converts an ASCII letter to uppercase. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>C <code>c</code>
</td> <td>Any type which implicitly converts to <code>dchar</code>. In the case where it's a built-in type, or an enum of a built-in type, <code>Unqual!(OriginalType!C)</code> is returned, whereas if it's a user-defined type, <code>dchar</code> is returned.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The corresponding uppercase letter, if <code>c</code> is a lowercase ASCII character, otherwise <code>c</code> itself.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(toUpper('a')); // 'A'
writeln(toUpper('A')); // 'A'
writeln(toUpper('#')); // '#'

// N.B.: Non-ASCII Unicode lowercase letters are not converted.
writeln(toUpper('á')); // 'á'
</pre> </dd>
</dl> </dd> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1999&ndash;2021 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/std_ascii.html" class="_attribution-link">https://dlang.org/phobos/std_ascii.html</a>
  </p>
</div>
