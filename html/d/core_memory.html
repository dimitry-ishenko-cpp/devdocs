<h1>core.memory</h1>  <p>This module provides an interface to the garbage collector used by applications written in the D programming language. It allows the garbage collector in the runtime to be swapped without affecting binary compatibility of applications. </p>
<p>Using this module is not necessary in typical D code. It is mostly useful when doing low-level memory management. </p> <dl>
<dt>Notes to users</dt>

</dl>
<ol> <li>The GC is a conservative mark-and-sweep collector. It only runs a collection cycle when an allocation is requested of it, never otherwise. Hence, if the program is not doing allocations, there will be no GC collection pauses. The pauses occur because all threads the GC knows about are halted so the threads' stacks and registers can be scanned for references to GC allocated data. </li>  <li>The GC does not know about threads that were created by directly calling the OS/C runtime thread creation APIs and D threads that were detached from the D runtime after creation. Such threads will not be paused for a GC collection, and the GC might not detect references to GC allocated data held by them. This can cause memory corruption. There are several ways to resolve this issue: <ol> <li>Do not hold references to GC allocated data in such threads.</li> <li>Register/unregister such data with calls to <a href="#addRoot"><code>addRoot</code></a>/<a href="#removeRoot"><code>removeRoot</code></a> and <a href="#addRange"><code>addRange</code></a>/<a href="#removeRange"><code>removeRange</code></a>.</li> <li>Maintain another reference to that same data in another thread that the GC does know about.</li> <li>Disable GC collection cycles while that thread is active with <a href="#disable"><code>disable</code></a>/<a href="#enable"><code>enable</code></a>.</li> <li>Register the thread with the GC using <a href="core_thread.html#thread_attachThis"><code>core.thread.thread_attachThis</code></a>/<a href="core_thread.html#thread_detachThis"><code>core.thread.thread_detachThis</code></a>.</li> </ol> </li> </ol>  <dl>
<dt>Notes to implementors</dt>

</dl>
<ul> <li>On POSIX systems, the signals SIGUSR1 and SIGUSR2 are reserved by this module for use in the garbage collector implementation. Typically, they will be used to stop and resume other threads when performing a collection, but an implementation may choose not to use this mechanism (or not stop the world at all, in the case of concurrent garbage collectors).</li>  <li>Registers, the stack, and any other memory locations added through the <code>GC.<a href="#addRange">addRange</a></code> function are always scanned conservatively. This means that even if a variable is e.g. of type <code>float</code>, it will still be scanned for possible GC pointers. And, if the word-interpreted representation of the variable matches a GC-managed memory block's address, that memory block is considered live.</li>  <li>Implementations are free to scan the non-root heap in a precise manner, so that fields of types like <code>float</code> will not be considered relevant when scanning the heap. Thus, casting a GC pointer to an integral type (e.g. <code>size_t</code>) and storing it in a field of that type inside the GC heap may mean that it will not be recognized if the memory block was allocated with precise type info or with the <code>GC.BlkAttr.<a href="#NO_SCAN">NO_SCAN</a></code> attribute.</li>  <li>Destructors will always be executed while other threads are active; that is, an implementation that stops the world must not execute destructors until the world has been resumed.</li>  <li>A destructor of an object must not access object references within the object. This means that an implementation is free to optimize based on this rule.</li>  <li>An implementation is free to perform heap compaction and copying so long as no valid GC pointers are invalidated in the process. However, memory allocated with <code>GC.BlkAttr.<a href="#NO_MOVE">NO_MOVE</a></code> must not be moved/copied.</li>  <li>Implementations must support interior pointers. That is, if the only reference to a GC-managed memory block points into the middle of the block rather than the beginning (for example), the GC must consider the memory block live. The exception to this rule is when a memory block is allocated with the <code>GC.BlkAttr.<a href="#NO_INTERIOR">NO_INTERIOR</a></code> attribute; it is the user's responsibility to make sure such memory blocks have a proper pointer to them when they should be considered live.</li>  <li>It is acceptable for an implementation to store bit flags into pointer values and GC-managed memory blocks, so long as such a trick is not visible to the application. In practice, this means that only a stop-the-world collector can do this.</li>  <li>Implementations are free to assume that GC pointers are only stored on word boundaries. Unaligned pointers may be ignored entirely.</li>  <li>Implementations are free to run collections at any point. It is, however, recommendable to only do so when an allocation attempt happens and there is insufficient memory available.</li> </ul>  <dl>
<dt>License:</dt>
<dd>
<a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a> </dd>
</dl> <dl>
<dt>Authors:</dt>
<dd>Sean Kelly, Alex RÃ¸nne Petersen </dd>
</dl> <dl>
<dt>Source</dt>
<dd> <a href="https://github.com/dlang/druntime/blob/master/src/core/memory.d">core/memory.d</a>
</dd>
</dl> <dl>
<dt class="d_decl" id="pageSize">immutable size_t <strong id="pageSize">pageSize</strong>; </dt> <dd>
<p>The size of a system page in bytes. </p>
<p>This value is set at startup time of the application. It's safe to use early in the start process, like in shared module constructors and initialization of the D runtime itself.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">ubyte[] buffer = new ubyte[pageSize];
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="GC">struct <strong id="GC">GC</strong>; </dt> <dd>
<p>This struct encapsulates all garbage collection functionality for the D programming language.</p> <dl>
<dt class="d_decl" id="GC.Stats">struct <strong id="Stats">Stats</strong>; </dt> <dd>
<p>Aggregation of GC stats to be exposed via public API</p> <dl>
<dt class="d_decl" id="GC.Stats.usedSize">size_t <strong id="usedSize">usedSize</strong>; </dt> <dd>
<p>number of used bytes on the GC heap (might only get updated after a collection)</p> </dd> <dt class="d_decl" id="GC.Stats.freeSize">size_t <strong id="freeSize">freeSize</strong>; </dt> <dd>
<p>number of free bytes on the GC heap (might only get updated after a collection)</p> </dd> <dt class="d_decl" id="GC.Stats.allocatedInCurrentThread">ulong <strong id="allocatedInCurrentThread">allocatedInCurrentThread</strong>; </dt> <dd>
<p>number of bytes allocated for current thread since program start</p> </dd> </dl> </dd> <dt class="d_decl" id="GC.ProfileStats">struct <strong id="ProfileStats">ProfileStats</strong>; </dt> <dd>
<p>Aggregation of current profile information</p> <dl>
<dt class="d_decl" id="GC.ProfileStats.numCollections">size_t <strong id="numCollections">numCollections</strong>; </dt> <dd>
<p>total number of GC cycles</p> </dd> <dt class="d_decl" id="GC.ProfileStats.totalCollectionTime">Duration <strong id="totalCollectionTime">totalCollectionTime</strong>; </dt> <dd>
<p>total time spent doing GC</p> </dd> <dt class="d_decl" id="GC.ProfileStats.totalPauseTime">Duration <strong id="totalPauseTime">totalPauseTime</strong>; </dt> <dd>
<p>total time threads were paused doing GC</p> </dd> <dt class="d_decl" id="GC.ProfileStats.maxPauseTime">Duration <strong id="maxPauseTime">maxPauseTime</strong>; </dt> <dd>
<p>largest time threads were paused during one GC cycle</p> </dd> <dt class="d_decl" id="GC.ProfileStats.maxCollectionTime">Duration <strong id="maxCollectionTime">maxCollectionTime</strong>; </dt> <dd>
<p>largest time spent doing one GC cycle</p> </dd> </dl> </dd> <dt class="d_decl" id="GC.enable">static nothrow void <strong id="enable">enable</strong>(); </dt> <dd>
<p>Enables automatic garbage collection behavior if collections have previously been suspended by a call to disable. This function is reentrant, and must be called once for every call to disable before automatic collections are enabled.</p> </dd> <dt class="d_decl" id="GC.disable">static nothrow void <strong id="disable">disable</strong>(); </dt> <dd>
<p>Disables automatic garbage collections performed to minimize the process footprint. Collections may continue to occur in instances where the implementation deems necessary for correct program behavior, such as during an out of memory condition. This function is reentrant, but enable must be called once for each call to disable.</p> </dd> <dt class="d_decl" id="GC.collect">static nothrow void <strong id="collect">collect</strong>(); </dt> <dd>
<p>Begins a full collection. While the meaning of this may change based on the garbage collector implementation, typical behavior is to scan all stack segments for roots, mark accessible memory blocks as alive, and then to reclaim free space. This action may need to suspend all running threads for at least part of the collection process.</p> </dd> <dt class="d_decl" id="GC.minimize">static nothrow void <strong id="minimize">minimize</strong>(); </dt> <dd>
<p>Indicates that the managed memory space be minimized by returning free physical memory to the operating system. The amount of free memory returned depends on the allocator design and on program behavior.</p> </dd> <dt class="d_decl" id="GC.BlkAttr">enum <strong id="BlkAttr">BlkAttr</strong>: uint; </dt> <dd>
<p>Elements for a bit field representing memory block attributes. These are manipulated via the getAttr, setAttr, clrAttr functions.</p> <dl>
<dt class="d_decl" id="GC.BlkAttr.NONE"><strong id="NONE">NONE</strong></dt> <dd>
<p>No attributes set.</p> </dd> <dt class="d_decl" id="GC.BlkAttr.FINALIZE"><strong id="FINALIZE">FINALIZE</strong></dt> <dd>
<p>Finalize the data in this block on collect.</p> </dd> <dt class="d_decl" id="GC.BlkAttr.NO_SCAN"><strong id="NO_SCAN">NO_SCAN</strong></dt> <dd>
<p>Do not scan through this block on collect.</p> </dd> <dt class="d_decl" id="GC.BlkAttr.NO_MOVE"><strong id="NO_MOVE">NO_MOVE</strong></dt> <dd>
<p>Do not move this memory block on collect.</p> </dd> <dt class="d_decl" id="GC.BlkAttr.APPENDABLE"><strong id="APPENDABLE">APPENDABLE</strong></dt> <dd>
<p>This block contains the info to allow appending. </p>
<p>This can be used to manually allocate arrays. Initial slice size is 0. </p> <dl>
<dt>Note</dt>
<dd> The slice's usable size will not match the block size. Use <a href="#capacity"><code>capacity</code></a> to retrieve actual usable capacity. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">// Allocate the underlying array.
int*  pToArray = cast(int*)GC.malloc(10 * int.sizeof, GC.BlkAttr.NO_SCAN | GC.BlkAttr.APPENDABLE);
// Bind a slice. Check the slice has capacity information.
int[] slice = pToArray[0 .. 0];
assert(capacity(slice) &gt; 0);
// Appending to the slice will not relocate it.
slice.length = 5;
slice ~= 1;
assert(slice.ptr == p);
</pre>  </dd> <dt class="d_decl" id="GC.BlkAttr.NO_INTERIOR"><strong id="NO_INTERIOR">NO_INTERIOR</strong></dt> <dd>
<p>This block is guaranteed to have a pointer to its base while it is alive. Interior pointers can be safely ignored. This attribute is useful for eliminating false pointers in very large data structures and is only implemented for data structures at least a page in size.</p> </dd> </dl> </dd> <dt class="d_decl" id="GC.BlkInfo">alias <strong id="BlkInfo">BlkInfo</strong> = .BlkInfo_; </dt> <dd>
<p>Contains aggregate information about a block of managed memory. The purpose of this struct is to support a more efficient query style in instances where detailed information is needed. </p>
<p>base = A pointer to the base of the block in question. size = The size of the block, calculated from base. attr = Attribute bits set on the memory block.</p> </dd> <dt class="d_decl" id="GC.getAttr">static nothrow uint <strong id="getAttr">getAttr</strong>(scope const void* p); <br><br>static pure nothrow uint <strong id="getAttr">getAttr</strong>(void* p); </dt> <dd>
<p>Returns a bit field representing all block attributes set for the memory referenced by p. If p references memory not originally allocated by this garbage collector, points to the interior of a memory block, or if p is null, zero will be returned. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>void* <code>p</code>
</td> <td>A pointer to the root of a valid memory block or to null.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A bit field containing any bits set for the memory block referenced by p or zero on error.</dd>
</dl> </dd> <dt class="d_decl" id="GC.setAttr">static nothrow uint <strong id="setAttr">setAttr</strong>(scope const void* p, uint a); <br><br>static pure nothrow uint <strong id="setAttr">setAttr</strong>(void* p, uint a); </dt> <dd>
<p>Sets the specified bits for the memory references by p. If p references memory not originally allocated by this garbage collector, points to the interior of a memory block, or if p is null, no action will be performed. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>void* <code>p</code>
</td> <td>A pointer to the root of a valid memory block or to null.</td>
</tr> <tr>
<td>uint <code>a</code>
</td> <td>A bit field containing any bits to set for this memory block.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The result of a call to getAttr after the specified bits have been set.</dd>
</dl> </dd> <dt class="d_decl" id="GC.clrAttr">static nothrow uint <strong id="clrAttr">clrAttr</strong>(scope const void* p, uint a); <br><br>static pure nothrow uint <strong id="clrAttr">clrAttr</strong>(void* p, uint a); </dt> <dd>
<p>Clears the specified bits for the memory references by p. If p references memory not originally allocated by this garbage collector, points to the interior of a memory block, or if p is null, no action will be performed. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>void* <code>p</code>
</td> <td>A pointer to the root of a valid memory block or to null.</td>
</tr> <tr>
<td>uint <code>a</code>
</td> <td>A bit field containing any bits to clear for this memory block.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The result of a call to getAttr after the specified bits have been cleared.</dd>
</dl> </dd> <dt class="d_decl" id="GC.malloc">static pure nothrow void* <strong id="malloc">malloc</strong>(size_t sz, uint ba = 0, const TypeInfo ti = null); </dt> <dd>
<p>Requests an aligned block of managed memory from the garbage collector. This memory may be deleted at will with a call to free, or it may be discarded and cleaned up automatically during a collection run. If allocation fails, this function will call onOutOfMemory which is expected to throw an OutOfMemoryError. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>size_t <code>sz</code>
</td> <td>The desired allocation size in bytes.</td>
</tr> <tr>
<td>uint <code>ba</code>
</td> <td>A bitmask of the attributes to set on this block.</td>
</tr> <tr>
<td>TypeInfo <code>ti</code>
</td> <td>TypeInfo to describe the memory. The GC might use this information to improve scanning for pointers or to call finalizers.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A reference to the allocated memory or null if insufficient memory is available. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>OutOfMemoryError on allocation failure.</dd>
</dl> </dd> <dt class="d_decl" id="GC.qalloc">static pure nothrow BlkInfo <strong id="qalloc">qalloc</strong>(size_t sz, uint ba = 0, const TypeInfo ti = null); </dt> <dd>
<p>Requests an aligned block of managed memory from the garbage collector. This memory may be deleted at will with a call to free, or it may be discarded and cleaned up automatically during a collection run. If allocation fails, this function will call onOutOfMemory which is expected to throw an OutOfMemoryError. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>size_t <code>sz</code>
</td> <td>The desired allocation size in bytes.</td>
</tr> <tr>
<td>uint <code>ba</code>
</td> <td>A bitmask of the attributes to set on this block.</td>
</tr> <tr>
<td>TypeInfo <code>ti</code>
</td> <td>TypeInfo to describe the memory. The GC might use this information to improve scanning for pointers or to call finalizers.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>Information regarding the allocated memory block or BlkInfo.init on error. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>OutOfMemoryError on allocation failure.</dd>
</dl> </dd> <dt class="d_decl" id="GC.calloc">static pure nothrow void* <strong id="calloc">calloc</strong>(size_t sz, uint ba = 0, const TypeInfo ti = null); </dt> <dd>
<p>Requests an aligned block of managed memory from the garbage collector, which is initialized with all bits set to zero. This memory may be deleted at will with a call to free, or it may be discarded and cleaned up automatically during a collection run. If allocation fails, this function will call onOutOfMemory which is expected to throw an OutOfMemoryError. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>size_t <code>sz</code>
</td> <td>The desired allocation size in bytes.</td>
</tr> <tr>
<td>uint <code>ba</code>
</td> <td>A bitmask of the attributes to set on this block.</td>
</tr> <tr>
<td>TypeInfo <code>ti</code>
</td> <td>TypeInfo to describe the memory. The GC might use this information to improve scanning for pointers or to call finalizers.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A reference to the allocated memory or null if insufficient memory is available. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>OutOfMemoryError on allocation failure.</dd>
</dl> </dd> <dt class="d_decl" id="GC.realloc">static pure nothrow void* <strong id="realloc">realloc</strong>(void* p, size_t sz, uint ba = 0, const TypeInfo ti = null); </dt> <dd>
<p>Extend, shrink or allocate a new block of memory keeping the contents of an existing block </p>
<p>If <code>sz</code> is zero, the memory referenced by p will be deallocated as if by a call to <code>free</code>. If <code>p</code> is <code>null</code>, new memory will be allocated via <code>malloc</code>. If <code>p</code> is pointing to memory not allocated from the GC or to the interior of an allocated memory block, no operation is performed and null is returned. <br><br> Otherwise, a new memory block of size <code>sz</code> will be allocated as if by a call to <code>malloc</code>, or the implementation may instead resize or shrink the memory block in place. The contents of the new memory block will be the same as the contents of the old memory block, up to the lesser of the new and old sizes. <br><br> The caller guarantees that there are no other live pointers to the passed memory block, still it might not be freed immediately by <code>realloc</code>. The garbage collector can reclaim the memory block in a later collection if it is unused. If allocation fails, this function will throw an <code>OutOfMemoryError</code>. <br><br> If <code>ba</code> is zero (the default) the attributes of the existing memory will be used for an allocation. If <code>ba</code> is not zero and no new memory is allocated, the bits in ba will replace those of the current memory block. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>void* <code>p</code>
</td> <td>A pointer to the base of a valid memory block or to <code>null</code>.</td>
</tr> <tr>
<td>size_t <code>sz</code>
</td> <td>The desired allocation size in bytes.</td>
</tr> <tr>
<td>uint <code>ba</code>
</td> <td>A bitmask of the BlkAttr attributes to set on this block.</td>
</tr> <tr>
<td>TypeInfo <code>ti</code>
</td> <td>TypeInfo to describe the memory. The GC might use this information to improve scanning for pointers or to call finalizers.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A reference to the allocated memory on success or <code>null</code> if <code>sz</code> is zero or the pointer does not point to the base of an GC allocated memory block. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<code>OutOfMemoryError</code> on allocation failure.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">enum size1 = 1 &lt;&lt; 11 + 1; // page in large object pool
enum size2 = 1 &lt;&lt; 22 + 1; // larger than large object pool size

auto data1 = cast(ubyte*)GC.calloc(size1);
auto data2 = cast(ubyte*)GC.realloc(data1, size2);

GC.BlkInfo info = GC.query(data2);
assert(info.size &gt;= size2);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="GC.extend">static pure nothrow size_t <strong id="extend">extend</strong>(void* p, size_t mx, size_t sz, const TypeInfo ti = null); </dt> <dd>
<p>Requests that the managed memory block referenced by p be extended in place by at least mx bytes, with a desired extension of sz bytes. If an extension of the required size is not possible or if p references memory not originally allocated by this garbage collector, no action will be taken. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>void* <code>p</code>
</td> <td>A pointer to the root of a valid memory block or to null.</td>
</tr> <tr>
<td>size_t <code>mx</code>
</td> <td>The minimum extension size in bytes.</td>
</tr> <tr>
<td>size_t <code>sz</code>
</td> <td>The desired extension size in bytes.</td>
</tr> <tr>
<td>TypeInfo <code>ti</code>
</td> <td>TypeInfo to describe the full memory block. The GC might use this information to improve scanning for pointers or to call finalizers.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The size in bytes of the extended memory block referenced by p or zero if no extension occurred. </dd>
</dl> <dl>
<dt>Note</dt>
<dd> Extend may also be used to extend slices (or memory blocks with <a href="#APPENDABLE"><code>APPENDABLE</code></a> info). However, use the return value only as an indicator of success. <a href="#capacity"><code>capacity</code></a> should be used to retrieve actual usable slice capacity.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Standard extending <pre data-language="d">size_t size = 1000;
int* p = cast(int*)GC.malloc(size * int.sizeof, GC.BlkAttr.NO_SCAN);

//Try to extend the allocated data by 1000 elements, preferred 2000.
size_t u = GC.extend(p, 1000 * int.sizeof, 2000 * int.sizeof);
if (u != 0)
    size = u / int.sizeof;
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>slice extending <pre data-language="d">int[] slice = new int[](1000);
int*  p     = slice.ptr;

//Check we have access to capacity before attempting the extend
if (slice.capacity)
{
    //Try to extend slice by 1000 elements, preferred 2000.
    size_t u = GC.extend(p, 1000 * int.sizeof, 2000 * int.sizeof);
    if (u != 0)
    {
        slice.length = slice.capacity;
        assert(slice.length &gt;= 2000);
    }
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="GC.reserve">static nothrow size_t <strong id="reserve">reserve</strong>(size_t sz); </dt> <dd>
<p>Requests that at least sz bytes of memory be obtained from the operating system and marked as free. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>size_t <code>sz</code>
</td> <td>The desired size in bytes.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The actual number of bytes reserved or zero on error.</dd>
</dl> </dd> <dt class="d_decl" id="GC.free">static pure nothrow @nogc void <strong id="free">free</strong>(void* p); </dt> <dd>
<p>Deallocates the memory referenced by p. If p is null, no action occurs. If p references memory not originally allocated by this garbage collector, if p points to the interior of a memory block, or if this method is called from a finalizer, no action will be taken. The block will not be finalized regardless of whether the FINALIZE attribute is set. If finalization is desired, call <a href="object.html#destroy"><code>destroy</code></a> prior to <code>GC.free</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>void* <code>p</code>
</td> <td>A pointer to the root of a valid memory block or to null.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="GC.addrOf">static nothrow @nogc inout(void)* <strong id="addrOf">addrOf</strong>(inout(void)* p); <br><br>static pure nothrow @nogc void* <strong id="addrOf">addrOf</strong>(void* p); </dt> <dd>
<p>Returns the base address of the memory block containing p. This value is useful to determine whether p is an interior pointer, and the result may be passed to routines such as sizeOf which may otherwise fail. If p references memory not originally allocated by this garbage collector, if p is null, or if the garbage collector does not support this operation, null will be returned. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>inout(void)* <code>p</code>
</td> <td>A pointer to the root or the interior of a valid memory block or to null.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The base address of the memory block referenced by p or null on error.</dd>
</dl> </dd> <dt class="d_decl" id="GC.sizeOf">static nothrow @nogc size_t <strong id="sizeOf">sizeOf</strong>(scope const void* p); <br><br>static pure nothrow @nogc size_t <strong id="sizeOf">sizeOf</strong>(void* p); </dt> <dd>
<p>Returns the true size of the memory block referenced by p. This value represents the maximum number of bytes for which a call to realloc may resize the existing block in place. If p references memory not originally allocated by this garbage collector, points to the interior of a memory block, or if p is null, zero will be returned. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>void* <code>p</code>
</td> <td>A pointer to the root of a valid memory block or to null.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The size in bytes of the memory block referenced by p or zero on error.</dd>
</dl> </dd> <dt class="d_decl" id="GC.query">static nothrow BlkInfo <strong id="query">query</strong>(scope const void* p); <br><br>static pure nothrow BlkInfo <strong id="query">query</strong>(void* p); </dt> <dd>
<p>Returns aggregate information about the memory block containing p. If p references memory not originally allocated by this garbage collector, if p is null, or if the garbage collector does not support this operation, BlkInfo.init will be returned. Typically, support for this operation is dependent on support for addrOf. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>void* <code>p</code>
</td> <td>A pointer to the root or the interior of a valid memory block or to null.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>Information regarding the memory block referenced by p or BlkInfo.init on error.</dd>
</dl> </dd> <dt class="d_decl" id="GC.stats">static nothrow Stats <strong id="stats">stats</strong>(); </dt> <dd>
<p>Returns runtime stats for currently active GC implementation See <code>core.memory.GC.Stats</code> for list of available metrics.</p> </dd> <dt class="d_decl" id="GC.profileStats">static nothrow @nogc @safe ProfileStats <strong id="profileStats">profileStats</strong>(); </dt> <dd>
<p>Returns runtime profile stats for currently active GC implementation See <code>core.memory.GC.ProfileStats</code> for list of available metrics.</p> </dd> <dt class="d_decl" id="GC.addRoot">static nothrow @nogc void <strong id="addRoot">addRoot</strong>(const void* p); </dt> <dd>
<p>Adds an internal root pointing to the GC memory block referenced by p. As a result, the block referenced by p itself and any blocks accessible via it will be considered live until the root is removed again. </p>
<p>If p is null, no operation is performed. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>void* <code>p</code>
</td> <td>A pointer into a GC-managed memory block or null.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">// Typical C-style callback mechanism; the passed function
// is invoked with the user-supplied context pointer at a
// later point.
extern(C) void addCallback(void function(void*), void*);

// Allocate an object on the GC heap (this would usually be
// some application-specific context data).
auto context = new Object;

// Make sure that it is not collected even if it is no
// longer referenced from D code (stack, GC heap, â¦).
GC.addRoot(cast(void*)context);

// Also ensure that a moving collector does not relocate
// the object.
GC.setAttr(cast(void*)context, GC.BlkAttr.NO_MOVE);

// Now context can be safely passed to the C library.
addCallback(&amp;myHandler, cast(void*)context);

extern(C) void myHandler(void* ctx)
{
    // Assuming that the callback is invoked only once, the
    // added root can be removed again now to allow the GC
    // to collect it later.
    GC.removeRoot(ctx);
    GC.clrAttr(ctx, GC.BlkAttr.NO_MOVE);

    auto context = cast(Object)ctx;
    // Use context hereâ¦
}
</pre>  </dd> <dt class="d_decl" id="GC.removeRoot">static nothrow @nogc void <strong id="removeRoot">removeRoot</strong>(const void* p); </dt> <dd>
<p>Removes the memory block referenced by p from an internal list of roots to be scanned during a collection. If p is null or is not a value previously passed to addRoot() then no operation is performed. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>void* <code>p</code>
</td> <td>A pointer into a GC-managed memory block or null.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="GC.addRange">static nothrow @nogc void <strong id="addRange">addRange</strong>(const void* p, size_t sz, const TypeInfo ti = null); </dt> <dd>
<p>Adds <code>p[0 .. sz]</code> to the list of memory ranges to be scanned for pointers during a collection. If p is null, no operation is performed. </p>
<p>Note that <code>p[0 .. sz]</code> is treated as an opaque range of memory assumed to be suitably managed by the caller. In particular, if p points into a GC-managed memory block, addRange does <i>not</i> mark this block as live. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>void* <code>p</code>
</td> <td>A pointer to a valid memory address or to null.</td>
</tr> <tr>
<td>size_t <code>sz</code>
</td> <td>The size in bytes of the block to add. If sz is zero then the no operation will occur. If p is null then sz must be zero.</td>
</tr> <tr>
<td>TypeInfo <code>ti</code>
</td> <td>TypeInfo to describe the memory. The GC might use this information to improve scanning for pointers or to call finalizers</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">// Allocate a piece of memory on the C heap.
enum size = 1_000;
auto rawMemory = core.stdc.stdlib.malloc(size);

// Add it as a GC range.
GC.addRange(rawMemory, size);

// Now, pointers to GC-managed memory stored in
// rawMemory will be recognized on collection.
</pre>  </dd> <dt class="d_decl" id="GC.removeRange">static nothrow @nogc void <strong id="removeRange">removeRange</strong>(const void* p); </dt> <dd>
<p>Removes the memory range starting at p from an internal list of ranges to be scanned during a collection. If p is null or does not represent a value previously passed to addRange() then no operation is performed. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>void* <code>p</code>
</td> <td>A pointer to a valid memory address or to null.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="GC.runFinalizers">static void <strong id="runFinalizers">runFinalizers</strong>(scope const void[] segment); </dt> <dd>
<p>Runs any finalizer that is located in address range of the given code segment. This is used before unloading shared libraries. All matching objects which have a finalizer in this code segment are assumed to be dead, using them while or after calling this method has undefined behavior. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>void[] <code>segment</code>
</td> <td>address range of a code segment.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="GC.inFinalizer">static nothrow @nogc @safe bool <strong id="inFinalizer">inFinalizer</strong>(); </dt> <dd>
<p>Queries the GC whether the current thread is running object finalization as part of a GC collection, or an explicit call to runFinalizers. </p>
<p>As some GC implementations (such as the current conservative one) don't support GC memory allocation during object finalization, this function can be used to guard against such programming errors. </p> <dl>
<dt>Returns:</dt>
<dd>true if the current thread is in a finalizer, a destructor invoked by the GC.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">// Only code called from a destructor is executed during finalization.
assert(!GC.inFinalizer);
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">enum Outcome
{
    notCalled,
    calledManually,
    calledFromDruntime
}

static class Resource
{
    static Outcome outcome;

    this()
    {
        outcome = Outcome.notCalled;
    }

    ~this()
    {
        if (GC.inFinalizer)
        {
            outcome = Outcome.calledFromDruntime;

            import core.exception : InvalidMemoryOperationError;
            try
            {
                /*
                 * Presently, allocating GC memory during finalization
                 * is forbidden and leads to
                 * `InvalidMemoryOperationError` being thrown.
                 *
                 * `GC.inFinalizer` can be used to guard against
                 * programming erros such as these and is also a more
                 * efficient way to verify whether a destructor was
                 * invoked by the GC.
                 */
                cast(void) GC.malloc(1);
                assert(false);
            }
            catch (InvalidMemoryOperationError e)
            {
                return;
            }
            assert(false);
        }
        else
            outcome = Outcome.calledManually;
    }
}

static void createGarbage()
{
    auto r = new Resource;
    r = null;
}

assert(Resource.outcome == Outcome.notCalled);
createGarbage();
GC.collect;
assert(
    Resource.outcome == Outcome.notCalled ||
    Resource.outcome == Outcome.calledFromDruntime);

auto r = new Resource;
GC.runFinalizers((cast(const void*)typeid(Resource).destructor)[0..1]);
assert(Resource.outcome == Outcome.calledFromDruntime);
Resource.outcome = Outcome.notCalled;

debug(MEMSTOMP) {} else
{
    // assume Resource data is still available
    r.destroy;
    assert(Resource.outcome == Outcome.notCalled);
}

r = new Resource;
assert(Resource.outcome == Outcome.notCalled);
r.destroy;
assert(Resource.outcome == Outcome.calledManually);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="GC.allocatedInCurrentThread">static nothrow ulong <strong id="allocatedInCurrentThread">allocatedInCurrentThread</strong>(); </dt> <dd>
<p>Returns the number of bytes allocated for the current thread since program start. It is the same as GC.stats().allocatedInCurrentThread, but faster.</p>
<dl>
<dt>Examples:</dt>
<dd>Using allocatedInCurrentThread <pre data-language="d">ulong currentlyAllocated = GC.allocatedInCurrentThread();
struct DataStruct
{
    long l1;
    long l2;
    long l3;
    long l4;
}
DataStruct* unused = new DataStruct;
assert(GC.allocatedInCurrentThread() == currentlyAllocated + 32);
assert(GC.stats().allocatedInCurrentThread == currentlyAllocated + 32);
</pre> </dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="pureMalloc">pure nothrow @nogc @trusted void* <strong id="pureMalloc">pureMalloc</strong>()(size_t size); <br><br>pure nothrow @nogc @trusted void* <strong id="pureCalloc">pureCalloc</strong>()(size_t nmemb, size_t size); <br><br>pure nothrow @nogc @system void* <strong id="pureRealloc">pureRealloc</strong>()(void* ptr, size_t size); <br><br>pure nothrow @nogc @system void <strong id="pureFree">pureFree</strong>()(void* ptr); </dt> <dd>
<p>Pure variants of C's memory allocation functions <code>malloc</code>, <code>calloc</code>, and <code>realloc</code> and deallocation function <code>free</code>. </p>
<p>UNIX 98 requires that errno be set to ENOMEM upon failure. Purity is achieved by saving and restoring the value of <code>errno</code>, thus behaving as if it were never changed. </p> <dl>
<dt>See Also:</dt>
<dd>
<a href="https://dlang.org/spec/function.html#pure-functions">D's rules for purity</a>, which allow for memory allocation under specific circumstances.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">ubyte[] fun(size_t n) pure
{
    void* p = pureMalloc(n);
    p !is null || n == 0 || assert(0);
    scope(failure) p = pureRealloc(p, 0);
    p = pureRealloc(p, n *= 2);
    p !is null || n == 0 || assert(0);
    return cast(ubyte[]) p[0 .. n];
}

auto buf = fun(100);
assert(buf.length == 200);
pureFree(buf.ptr);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="__delete">@system void <strong id="__delete">__delete</strong>(T)(ref T x); </dt> <dd>
<p>Destroys and then deallocates an object. </p>
<p>In detail, <code>__delete(x)</code> returns with no effect if <code>x</code> is <code>null</code>. Otherwise, it performs the following actions in sequence: <ul> <li> Calls the destructor <code>~this()</code> for the object referred to by <code>x</code> (if <code>x</code> is a class or interface reference) or for the object pointed to by <code>x</code> (if <code>x</code> is a pointer to a <code>struct</code>). Arrays of structs call the destructor, if defined, for each element in the array. If no destructor is defined, this step has no effect. </li> <li> Frees the memory allocated for <code>x</code>. If <code>x</code> is a reference to a class or interface, the memory allocated for the underlying instance is freed. If <code>x</code> is a pointer, the memory allocated for the pointed-to object is freed. If <code>x</code> is a built-in array, the memory allocated for the array is freed. If <code>x</code> does not refer to memory previously allocated with <code>new</code> (or the lower-level equivalents in the GC API), the behavior is undefined. </li> <li> Lastly, <code>x</code> is set to <code>null</code>. Any attempt to read or write the freed memory via other references will result in undefined behavior. </li> </ul> </p> <dl>
<dt>Note</dt>
<dd> Users should prefer <a href="object.html#destroy"><code>destroy</code></a> to explicitly finalize objects, and only resort to <a href="core_memory.html#_delete"><code>core.memory._delete</code></a> when <a href="object_.html#destroy"><code>object.destroy</code></a> wouldn't be a feasible option. </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T <code>x</code>
</td> <td>aggregate object that should be destroyed</td>
</tr> </table></dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="object.html#destroy"><code>destroy</code></a>, <a href="core_gc.html#free"><code>core.GC.free</code></a> </dd>
</dl> <dl>
<dt>History:</dt>
<dd>The <code>delete</code> keyword allowed to free GC-allocated memory. As this is inherently not <code>@safe</code>, it has been deprecated. This function has been added to provide an easy transition from <code>delete</code>. It performs the same functionality as the former <code>delete</code> keyword.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Deleting classes <pre data-language="d">bool dtorCalled;
class B
{
    int test;
    ~this()
    {
        dtorCalled = true;
    }
}
B b = new B();
B a = b;
b.test = 10;

assert(GC.addrOf(cast(void*) b) != null);
__delete(b);
assert(b is null);
assert(dtorCalled);
assert(GC.addrOf(cast(void*) b) == null);
// but be careful, a still points to it
assert(a !is null);
assert(GC.addrOf(cast(void*) a) == null); // but not a valid GC pointer
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Deleting interfaces <pre data-language="d">bool dtorCalled;
interface A
{
    int quack();
}
class B : A
{
    int a;
    int quack()
    {
        a++;
        return a;
    }
    ~this()
    {
        dtorCalled = true;
    }
}
A a = new B();
a.quack();

assert(GC.addrOf(cast(void*) a) != null);
__delete(a);
assert(a is null);
assert(dtorCalled);
assert(GC.addrOf(cast(void*) a) == null);
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Deleting structs <pre data-language="d">bool dtorCalled;
struct A
{
    string test;
    ~this()
    {
        dtorCalled = true;
    }
}
auto a = new A("foo");

assert(GC.addrOf(cast(void*) a) != null);
__delete(a);
assert(a is null);
assert(dtorCalled);
assert(GC.addrOf(cast(void*) a) == null);
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Deleting arrays <pre data-language="d">int[] a = [1, 2, 3];
auto b = a;

assert(GC.addrOf(b.ptr) != null);
__delete(b);
assert(b is null);
assert(GC.addrOf(b.ptr) == null);
// but be careful, a still points to it
assert(a !is null);
assert(GC.addrOf(a.ptr) == null); // but not a valid GC pointer
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Deleting arrays of structs <pre data-language="d">int dtorCalled;
struct A
{
    int a;
    ~this()
    {
        assert(dtorCalled == a);
        dtorCalled++;
    }
}
auto arr = [A(1), A(2), A(3)];
arr[0].a = 2;
arr[1].a = 1;
arr[2].a = 0;

assert(GC.addrOf(arr.ptr) != null);
__delete(arr);
assert(dtorCalled == 3);
assert(GC.addrOf(arr.ptr) == null);
</pre> </dd>
</dl> </dd> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1999&ndash;2021 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/core_memory.html" class="_attribution-link">https://dlang.org/phobos/core_memory.html</a>
  </p>
</div>
