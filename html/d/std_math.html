<h1>std.math</h1>  <p>Contains the elementary mathematical functions (powers, roots, and trigonometric functions), and low-level floating-point operations. Mathematical special functions are available in <code>std.mathspecial</code>. </p>
<table>

<tr>
<th scope="col">Category</th> <th scope="col">Members</th> </tr> <tr>
<td>Constants</td> <td> <a href="#E"><em class="tt">E</em></a> <a href="#PI"><em class="tt">PI</em></a> <a href="#PI_2"><em class="tt">PI_2</em></a> <a href="#PI_4"><em class="tt">PI_4</em></a> <a href="#M_1_PI"><em class="tt">M_1_PI</em></a> <a href="#M_2_PI"><em class="tt">M_2_PI</em></a> <a href="#M_2_SQRTPI"><em class="tt">M_2_SQRTPI</em></a> <a href="#LN10"><em class="tt">LN10</em></a> <a href="#LN2"><em class="tt">LN2</em></a> <a href="#LOG2"><em class="tt">LOG2</em></a> <a href="#LOG2E"><em class="tt">LOG2E</em></a> <a href="#LOG2T"><em class="tt">LOG2T</em></a> <a href="#LOG10E"><em class="tt">LOG10E</em></a> <a href="#SQRT2"><em class="tt">SQRT2</em></a> <a href="#SQRT1_2"><em class="tt">SQRT1_2</em></a> </td>
</tr> <tr>
<td>Classics</td> <td> <a href="#abs"><em class="tt">abs</em></a> <a href="#fabs"><em class="tt">fabs</em></a> <a href="#sqrt"><em class="tt">sqrt</em></a> <a href="#cbrt"><em class="tt">cbrt</em></a> <a href="#hypot"><em class="tt">hypot</em></a> <a href="#poly"><em class="tt">poly</em></a> <a href="#nextPow2"><em class="tt">nextPow2</em></a> <a href="#truncPow2"><em class="tt">truncPow2</em></a> </td>
</tr> <tr>
<td>Trigonometry</td> <td> <a href="#sin"><em class="tt">sin</em></a> <a href="#cos"><em class="tt">cos</em></a> <a href="#tan"><em class="tt">tan</em></a> <a href="#asin"><em class="tt">asin</em></a> <a href="#acos"><em class="tt">acos</em></a> <a href="#atan"><em class="tt">atan</em></a> <a href="#atan2"><em class="tt">atan2</em></a> <a href="#sinh"><em class="tt">sinh</em></a> <a href="#cosh"><em class="tt">cosh</em></a> <a href="#tanh"><em class="tt">tanh</em></a> <a href="#asinh"><em class="tt">asinh</em></a> <a href="#acosh"><em class="tt">acosh</em></a> <a href="#atanh"><em class="tt">atanh</em></a> </td>
</tr> <tr>
<td>Rounding</td> <td> <a href="#ceil"><em class="tt">ceil</em></a> <a href="#floor"><em class="tt">floor</em></a> <a href="#round"><em class="tt">round</em></a> <a href="#lround"><em class="tt">lround</em></a> <a href="#trunc"><em class="tt">trunc</em></a> <a href="#rint"><em class="tt">rint</em></a> <a href="#lrint"><em class="tt">lrint</em></a> <a href="#nearbyint"><em class="tt">nearbyint</em></a> <a href="#rndtol"><em class="tt">rndtol</em></a> <a href="#quantize"><em class="tt">quantize</em></a> </td>
</tr> <tr>
<td>Exponentiation &amp; Logarithms</td> <td> <a href="#pow"><em class="tt">pow</em></a> <a href="#exp"><em class="tt">exp</em></a> <a href="#exp2"><em class="tt">exp2</em></a> <a href="#expm1"><em class="tt">expm1</em></a> <a href="#ldexp"><em class="tt">ldexp</em></a> <a href="#frexp"><em class="tt">frexp</em></a> <a href="#log"><em class="tt">log</em></a> <a href="#log2"><em class="tt">log2</em></a> <a href="#log10"><em class="tt">log10</em></a> <a href="#logb"><em class="tt">logb</em></a> <a href="#ilogb"><em class="tt">ilogb</em></a> <a href="#log1p"><em class="tt">log1p</em></a> <a href="#scalbn"><em class="tt">scalbn</em></a> </td>
</tr> <tr>
<td>Modulus</td> <td> <a href="#fmod"><em class="tt">fmod</em></a> <a href="#modf"><em class="tt">modf</em></a> <a href="#remainder"><em class="tt">remainder</em></a> </td>
</tr> <tr>
<td>Floating-point operations</td> <td> <a href="#approxEqual"><em class="tt">approxEqual</em></a> <a href="#feqrel"><em class="tt">feqrel</em></a> <a href="#fdim"><em class="tt">fdim</em></a> <a href="#fmax"><em class="tt">fmax</em></a> <a href="#fmin"><em class="tt">fmin</em></a> <a href="#fma"><em class="tt">fma</em></a> <a href="#isClose"><em class="tt">isClose</em></a> <a href="#nextDown"><em class="tt">nextDown</em></a> <a href="#nextUp"><em class="tt">nextUp</em></a> <a href="#nextafter"><em class="tt">nextafter</em></a> <a href="#NaN"><em class="tt">NaN</em></a> <a href="#getNaNPayload"><em class="tt">getNaNPayload</em></a> <a href="#cmp"><em class="tt">cmp</em></a> </td>
</tr> <tr>
<td>Introspection</td> <td> <a href="#isFinite"><em class="tt">isFinite</em></a> <a href="#isIdentical"><em class="tt">isIdentical</em></a> <a href="#isInfinity"><em class="tt">isInfinity</em></a> <a href="#isNaN"><em class="tt">isNaN</em></a> <a href="#isNormal"><em class="tt">isNormal</em></a> <a href="#isSubnormal"><em class="tt">isSubnormal</em></a> <a href="#signbit"><em class="tt">signbit</em></a> <a href="#sgn"><em class="tt">sgn</em></a> <a href="#copysign"><em class="tt">copysign</em></a> <a href="#isPowerOf2"><em class="tt">isPowerOf2</em></a> </td>
</tr> <tr>
<td>Hardware Control</td> <td> <a href="#IeeeFlags"><em class="tt">IeeeFlags</em></a> <a href="#FloatingPointControl"><em class="tt">FloatingPointControl</em></a> </td>
</tr> </table> <p>    The functionality closely follows the IEEE754-2008 standard for floating-point arithmetic, including the use of camelCase names rather than C99-style lower case names. All of these functions behave correctly when presented with an infinity or NaN. <br><br> The following IEEE 'real' formats are currently supported: <ul> <li>64 bit Big-endian 'double' (eg PowerPC)</li> <li>128 bit Big-endian 'quadruple' (eg SPARC)</li> <li>64 bit Little-endian 'double' (eg x86-SSE2)</li> <li>80 bit Little-endian, with implied bit 'real80' (eg x87, Itanium)</li> <li>128 bit Little-endian 'quadruple' (not implemented on any known processor!)</li> <li>Non-IEEE 128 bit Big-endian 'doubledouble' (eg PowerPC) has partial support</li> </ul> Unlike C, there is no global 'errno' variable. Consequently, almost all of these functions are pure nothrow. </p> <dl>
<dt>License:</dt>
<dd>
<a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>. </dd>
</dl> <dl>
<dt>Authors:</dt>
<dd>
<a href="http://digitalmars.com">Walter Bright</a>, Don Clugston, Conversion of CEPHES math library to D by Iain Buclaw and David Nadlinger </dd>
</dl> <dl>
<dt>Source</dt>
<dd> <span class="phobos_src"><a class="https" href="https://github.com/dlang/phobos/blob/master/std/math.d">std/math.d</a></span>
</dd>
</dl> <dl>
<dt class="d_decl" id="E">enum real <strong id="E">E</strong>; </dt> <dd>
<p>e = 2.718281...</p> </dd> <dt class="d_decl" id="LOG2T">enum real <strong id="LOG2T">LOG2T</strong>; </dt> <dd>
<p>log<sub>2</sub>10 = 3.321928...</p> </dd> <dt class="d_decl" id="LOG2E">enum real <strong id="LOG2E">LOG2E</strong>; </dt> <dd>
<p>log<sub>2</sub>e = 1.442695...</p> </dd> <dt class="d_decl" id="LOG2">enum real <strong id="LOG2">LOG2</strong>; </dt> <dd>
<p>log<sub>10</sub>2 = 0.301029...</p> </dd> <dt class="d_decl" id="LOG10E">enum real <strong id="LOG10E">LOG10E</strong>; </dt> <dd>
<p>log<sub>10</sub>e = 0.434294...</p> </dd> <dt class="d_decl" id="LN2">enum real <strong id="LN2">LN2</strong>; </dt> <dd>
<p>ln 2 = 0.693147...</p> </dd> <dt class="d_decl" id="LN10">enum real <strong id="LN10">LN10</strong>; </dt> <dd>
<p>ln 10 = 2.302585...</p> </dd> <dt class="d_decl" id="PI">enum real <strong id="PI">PI</strong>; </dt> <dd>
<p>π = 3.141592...</p> </dd> <dt class="d_decl" id="PI_2">enum real <strong id="PI_2">PI_2</strong>; </dt> <dd>
<p>π / 2 = 1.570796...</p> </dd> <dt class="d_decl" id="PI_4">enum real <strong id="PI_4">PI_4</strong>; </dt> <dd>
<p>π / 4 = 0.785398...</p> </dd> <dt class="d_decl" id="M_1_PI">enum real <strong id="M_1_PI">M_1_PI</strong>; </dt> <dd>
<p>1 / π = 0.318309...</p> </dd> <dt class="d_decl" id="M_2_PI">enum real <strong id="M_2_PI">M_2_PI</strong>; </dt> <dd>
<p>2 / π = 0.636619...</p> </dd> <dt class="d_decl" id="M_2_SQRTPI">enum real <strong id="M_2_SQRTPI">M_2_SQRTPI</strong>; </dt> <dd>
<p>2 / √π = 1.128379...</p> </dd> <dt class="d_decl" id="SQRT2">enum real <strong id="SQRT2">SQRT2</strong>; </dt> <dd>
<p>√2 = 1.414213...</p> </dd> <dt class="d_decl" id="SQRT1_2">enum real <strong id="SQRT1_2">SQRT1_2</strong>; </dt> <dd>
<p>√½ = 0.707106...</p> </dd> <dt class="d_decl" id="abs">pure nothrow @nogc auto <strong id="abs">abs</strong>(Num)(Num x)<br><small>  Constraints: if (is(immutable(Num) == immutable(short)) || is(immutable(Num) == immutable(byte)) || is(typeof(Num.init &gt;= 0)) &amp;&amp; is(typeof(-Num.init))); </small>
</dt> <dd>
<p>Calculates the absolute value of a number. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Num</td> <td>(template parameter) type of number</td>
</tr> <tr>
<td>Num <code>x</code>
</td> <td>real number value</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The absolute value of the number. If floating-point or integral, the return type will be the same as the input. </dd>
</dl> <dl>
<dt>Limitations</dt>
<dd> Does not work correctly for signed intergal types and value <code>Num</code>.min.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>ditto <pre data-language="d">assert(isIdentical(abs(-0.0L), 0.0L));
assert(isNaN(abs(real.nan)));
writeln(abs(-real.infinity)); // real.infinity
writeln(abs(-56)); // 56
writeln(abs(2321312L)); // 2321312L
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="cos">pure nothrow @nogc @safe real <strong id="cos">cos</strong>(real x); <br><br>pure nothrow @nogc @safe double <strong id="cos">cos</strong>(double x); <br><br>pure nothrow @nogc @safe float <strong id="cos">cos</strong>(float x); </dt> <dd>
<p>Returns cosine of x. x is in radians. </p>
<p><table> <caption>Special Values</caption> <tr>
<th scope="col">x</th> <th scope="col">cos(x)</th> <th scope="col">invalid?</th>
</tr> <tr>
<td><span class="red">NAN</span></td> <td><span class="red">NAN</span></td> <td>yes</td> </tr> <tr>
<td>±∞</td> <td><span class="red">NAN</span></td> <td>yes</td> </tr> </table> </p> <dl>
<dt>Bugs:</dt>
<dd>Results are undefined if |x| &gt;= 2<sup>64</sup>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(cos(0.0)); // 1.0
assert(cos(1.0).approxEqual(0.540));
assert(cos(3.0).approxEqual(-0.989));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="sin">pure nothrow @nogc @safe real <strong id="sin">sin</strong>(real x); <br><br>pure nothrow @nogc @safe double <strong id="sin">sin</strong>(double x); <br><br>pure nothrow @nogc @safe float <strong id="sin">sin</strong>(float x); </dt> <dd>
<p>Returns <a href="http://en.wikipedia.org/wiki/Sine">sine</a> of x. x is in <a href="http://en.wikipedia.org/wiki/Radian">radians</a>. </p>
<p><table> <caption>Special Values</caption> <tr>
<th scope="col">x </th> <th scope="col"> sin(x) </th> <th scope="col"> invalid?</th>
</tr> <tr>
<td>
<span class="red">NAN</span> </td> <td> <span class="red">NAN</span> </td> <td> yes </td>
</tr> <tr>
<td>±0.0</td> <td> ±0.0</td> <td> no </td>
</tr> <tr>
<td>±∞</td> <td> <span class="red">NAN</span> </td> <td> yes </td>
</tr> </table> </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>real <code>x</code>
</td> <td>angle in radians (not degrees)</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>sine of x </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="#cos"><em class="tt">cos</em></a> , <a href="#tan"><em class="tt">tan</em></a> , <a href="#asin"><em class="tt">asin</em></a> </dd>
</dl> <dl>
<dt>Bugs:</dt>
<dd>Results are undefined if |x| &gt;= 2<sup>64</sup>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.math : sin, PI;
import std.stdio : writefln;

void someFunc()
{
  real x = 30.0;
  auto result = sin(x * (PI / 180)); // convert degrees to radians
  writefln("The sine of %s degrees is %s", x, result);
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="tan">pure nothrow @nogc @safe real <strong id="tan">tan</strong>(real x); <br><br>pure nothrow @nogc @safe double <strong id="tan">tan</strong>(double x); <br><br>pure nothrow @nogc @safe float <strong id="tan">tan</strong>(float x); </dt> <dd>
<p>Returns tangent of x. x is in radians. </p>
<p><table> <caption>Special Values</caption> <tr>
<th scope="col">x</th> <th scope="col">tan(x)</th> <th scope="col">invalid?</th>
</tr> <tr>
<td><span class="red">NAN</span></td> <td><span class="red">NAN</span></td> <td>yes</td>
</tr> <tr>
<td>±0.0</td> <td>±0.0</td> <td>no</td>
</tr> <tr>
<td>±∞</td> <td><span class="red">NAN</span></td> <td>yes</td>
</tr> </table></p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(isIdentical(tan(0.0), 0.0));
assert(tan(PI).approxEqual(0));
assert(tan(PI / 3).approxEqual(sqrt(3.0)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="acos">pure nothrow @nogc @safe real <strong id="acos">acos</strong>(real x); <br><br>pure nothrow @nogc @safe double <strong id="acos">acos</strong>(double x); <br><br>pure nothrow @nogc @safe float <strong id="acos">acos</strong>(float x); </dt> <dd>
<p>Calculates the arc cosine of x, returning a value ranging from 0 to π. </p>
<p><table> <caption>Special Values</caption> <tr>
<th scope="col">x</th> <th scope="col">acos(x)</th> <th scope="col">invalid?</th>
</tr> <tr>
<td>&gt;1.0</td> <td><span class="red">NAN</span></td> <td>yes</td>
</tr> <tr>
<td>&lt;-1.0</td> <td><span class="red">NAN</span></td> <td>yes</td>
</tr> <tr>
<td><span class="red">NAN</span></td> <td><span class="red">NAN</span></td> <td>yes</td>
</tr> </table></p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(acos(0.0).approxEqual(1.570));
assert(acos(0.5).approxEqual(std.math.PI / 3));
assert(acos(PI).isNaN);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="asin">pure nothrow @nogc @safe real <strong id="asin">asin</strong>(real x); <br><br>pure nothrow @nogc @safe double <strong id="asin">asin</strong>(double x); <br><br>pure nothrow @nogc @safe float <strong id="asin">asin</strong>(float x); </dt> <dd>
<p>Calculates the arc sine of x, returning a value ranging from -π/2 to π/2. </p>
<p><table> <caption>Special Values</caption> <tr>
<th scope="col">x</th> <th scope="col">asin(x)</th> <th scope="col">invalid?</th>
</tr> <tr>
<td>±0.0</td> <td>±0.0</td> <td>no</td>
</tr> <tr>
<td>&gt;1.0</td> <td><span class="red">NAN</span></td> <td>yes</td>
</tr> <tr>
<td>&lt;-1.0</td> <td><span class="red">NAN</span></td> <td>yes</td>
</tr> </table></p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(isIdentical(asin(0.0), 0.0));
assert(asin(0.5).approxEqual(PI / 6));
assert(asin(PI).isNaN);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="atan">pure nothrow @nogc @safe real <strong id="atan">atan</strong>(real x); <br><br>pure nothrow @nogc @safe double <strong id="atan">atan</strong>(double x); <br><br>pure nothrow @nogc @safe float <strong id="atan">atan</strong>(float x); </dt> <dd>
<p>Calculates the arc tangent of x, returning a value ranging from -π/2 to π/2. </p>
<p><table> <caption>Special Values</caption> <tr>
<th scope="col">x</th> <th scope="col">atan(x)</th> <th scope="col">invalid?</th>
</tr> <tr>
<td>±0.0</td> <td>±0.0</td> <td>no</td>
</tr> <tr>
<td>±∞</td> <td><span class="red">NAN</span></td> <td>yes</td>
</tr> </table></p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(isIdentical(atan(0.0), 0.0));
assert(atan(sqrt(3.0)).approxEqual(PI / 3));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="atan2">pure nothrow @nogc @trusted real <strong id="atan2">atan2</strong>(real y, real x); <br><br>pure nothrow @nogc @safe double <strong id="atan2">atan2</strong>(double y, double x); <br><br>pure nothrow @nogc @safe float <strong id="atan2">atan2</strong>(float y, float x); </dt> <dd>
<p>Calculates the arc tangent of y / x, returning a value ranging from -π to π. </p>
<p><table> <caption>Special Values</caption> <tr>
<th scope="col">y</th> <th scope="col">x</th> <th scope="col">atan(y, x)</th>
</tr> <tr>
<td><span class="red">NAN</span></td> <td>anything</td> <td><span class="red">NAN</span></td> </tr> <tr>
<td>anything</td> <td><span class="red">NAN</span></td> <td><span class="red">NAN</span></td> </tr> <tr>
<td>±0.0</td> <td>&gt;0.0</td> <td>±0.0</td> </tr> <tr>
<td>±0.0</td> <td>+0.0</td> <td>±0.0</td> </tr> <tr>
<td>±0.0</td> <td>&lt;0.0</td> <td>±π</td>
</tr> <tr>
<td>±0.0</td> <td>-0.0</td> <td>±π</td>
</tr> <tr>
<td>&gt;0.0</td> <td>±0.0</td> <td>π/2</td> </tr> <tr>
<td>&lt;0.0</td> <td>±0.0</td> <td>-π/2</td> </tr> <tr>
<td>&gt;0.0</td> <td>∞</td> <td>±0.0</td> </tr> <tr>
<td>±∞</td> <td>anything</td> <td>±π/2</td>
</tr> <tr>
<td>&gt;0.0</td> <td>-∞</td> <td>±π</td> </tr> <tr>
<td>±∞</td> <td>∞</td> <td>±π/4</td>
</tr> <tr>
<td>±∞</td> <td>-∞</td> <td>±3π/4</td>
</tr> </table></p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(atan2(1.0, sqrt(3.0)).approxEqual(PI / 6));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="cosh">pure nothrow @nogc @safe real <strong id="cosh">cosh</strong>(real x); <br><br>pure nothrow @nogc @safe double <strong id="cosh">cosh</strong>(double x); <br><br>pure nothrow @nogc @safe float <strong id="cosh">cosh</strong>(float x); </dt> <dd>
<p>Calculates the hyperbolic cosine of x. </p>
<p><table> <caption>Special Values</caption> <tr>
<th scope="col">x</th> <th scope="col">cosh(x)</th> <th scope="col">invalid?</th>
</tr> <tr>
<td>±∞</td> <td>±0.0</td> <td>no</td> </tr> </table></p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(cosh(0.0)); // 1.0
assert(cosh(1.0).approxEqual((E + 1.0 / E) / 2));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="sinh">pure nothrow @nogc @safe real <strong id="sinh">sinh</strong>(real x); <br><br>pure nothrow @nogc @safe double <strong id="sinh">sinh</strong>(double x); <br><br>pure nothrow @nogc @safe float <strong id="sinh">sinh</strong>(float x); </dt> <dd>
<p>Calculates the hyperbolic sine of x. </p>
<p><table> <caption>Special Values</caption> <tr>
<th scope="col">x</th> <th scope="col">sinh(x)</th> <th scope="col">invalid?</th>
</tr> <tr>
<td>±0.0</td> <td>±0.0</td> <td>no</td>
</tr> <tr>
<td>±∞</td> <td>±∞</td> <td>no</td>
</tr> </table></p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">enum sinh1 = (E - 1.0 / E) / 2;
import std.meta : AliasSeq;
static foreach (F; AliasSeq!(float, double, real))
{
    assert(isIdentical(sinh(F(0.0)), F(0.0)));
    assert(sinh(F(1.0)).approxEqual(F(sinh1)));
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="tanh">pure nothrow @nogc @safe real <strong id="tanh">tanh</strong>(real x); <br><br>pure nothrow @nogc @safe double <strong id="tanh">tanh</strong>(double x); <br><br>pure nothrow @nogc @safe float <strong id="tanh">tanh</strong>(float x); </dt> <dd>
<p>Calculates the hyperbolic tangent of x. </p>
<p><table> <caption>Special Values</caption> <tr>
<th scope="col">x</th> <th scope="col">tanh(x)</th> <th scope="col">invalid?</th>
</tr> <tr>
<td>±0.0</td> <td>±0.0</td> <td>no</td> </tr> <tr>
<td>±∞</td> <td>±1.0</td> <td>no</td>
</tr> </table></p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(isIdentical(tanh(0.0), 0.0));
assert(tanh(1.0).approxEqual(sinh(1.0) / cosh(1.0)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="acosh">pure nothrow @nogc @safe real <strong id="acosh">acosh</strong>(real x); <br><br>pure nothrow @nogc @safe double <strong id="acosh">acosh</strong>(double x); <br><br>pure nothrow @nogc @safe float <strong id="acosh">acosh</strong>(float x); </dt> <dd>
<p>Calculates the inverse hyperbolic cosine of x. </p>
<p>Mathematically, acosh(x) = log(x + sqrt( x*x - 1)) <br><br> <table> <tr>
<th scope="col">Domain X</th> <th scope="col">Range Y</th>
</tr> <tr>
<td> 1..∞</td> <td> 0..∞ </td>
</tr> </table> <br><br> <table> <caption>Special Values</caption> <tr>
<th scope="col"> x</th> <th scope="col"> acosh(x) </th>
</tr> <tr>
<td> <span class="red">NAN</span>
</td> <td>
<span class="red">NAN</span> </td>
</tr> <tr>
<td> &lt;1</td> <td> <span class="red">NAN</span> </td>
</tr> <tr>
<td> 1</td> <td> 0 </td>
</tr> <tr>
<td> +∞</td> <td>+∞</td>
</tr> </table></p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(isNaN(acosh(0.9)));
assert(isNaN(acosh(real.nan)));
assert(isIdentical(acosh(1.0), 0.0));
writeln(acosh(real.infinity)); // real.infinity
assert(isNaN(acosh(0.5)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="asinh">pure nothrow @nogc @safe real <strong id="asinh">asinh</strong>(real x); <br><br>pure nothrow @nogc @safe double <strong id="asinh">asinh</strong>(double x); <br><br>pure nothrow @nogc @safe float <strong id="asinh">asinh</strong>(float x); </dt> <dd>
<p>Calculates the inverse hyperbolic sine of x. </p>
<p> Mathematically, <pre data-language="d">asinh(x) =  log( x + sqrt( x*x + 1 )) // if x &gt;= +0
asinh(x) = -log(-x + sqrt( x*x + 1 )) // if x &lt;= -0
</pre> <br><br> <table> <caption>Special Values</caption> <tr>
<th scope="col">x</th> <th scope="col"> asinh(x) </th>
</tr> <tr>
<td> <span class="red">NAN</span>
</td> <td> <span class="red">NAN</span> </td>
</tr> <tr>
<td> ±0</td> <td> ±0 </td>
</tr> <tr>
<td> ±∞</td> <td>±∞</td>
</tr> </table></p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(isIdentical(asinh(0.0), 0.0));
assert(isIdentical(asinh(-0.0), -0.0));
writeln(asinh(real.infinity)); // real.infinity
writeln(asinh(-real.infinity)); // -real.infinity
assert(isNaN(asinh(real.nan)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="atanh">pure nothrow @nogc @safe real <strong id="atanh">atanh</strong>(real x); <br><br>pure nothrow @nogc @safe double <strong id="atanh">atanh</strong>(double x); <br><br>pure nothrow @nogc @safe float <strong id="atanh">atanh</strong>(float x); </dt> <dd>
<p>Calculates the inverse hyperbolic tangent of x, returning a value from ranging from -1 to 1. </p>
<p>Mathematically, atanh(x) = log( (1+x)/(1-x) ) / 2 <br><br> <table> <tr>
<th scope="col">Domain X</th> <th scope="col">Range Y</th>
</tr> <tr>
<td> -∞..∞</td> <td> -1 .. 1 </td>
</tr> </table> <br> <table> <caption>Special Values</caption> <tr>
<th scope="col"> x</th> <th scope="col"> acosh(x) </th>
</tr> <tr>
<td> <span class="red">NAN</span>
</td> <td>
<span class="red">NAN</span> </td>
</tr> <tr>
<td> ±0</td> <td>±0</td>
</tr> <tr>
<td> -∞</td> <td>-0</td>
</tr> </table></p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(isIdentical(atanh(0.0), 0.0));
assert(isIdentical(atanh(-0.0),-0.0));
assert(isNaN(atanh(real.nan)));
assert(isNaN(atanh(-real.infinity)));
writeln(atanh(0.0)); // 0
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="rndtol">pure nothrow @nogc @safe long <strong id="rndtol">rndtol</strong>(real x); <br><br>pure nothrow @nogc @safe long <strong id="rndtol">rndtol</strong>(double x); <br><br>pure nothrow @nogc @safe long <strong id="rndtol">rndtol</strong>(float x); </dt> <dd>
<p>Returns x rounded to a long value using the current rounding mode. If the integer value of x is greater than long.max, the result is indeterminate.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(rndtol(1.0)); // 1L
writeln(rndtol(1.2)); // 1L
writeln(rndtol(1.7)); // 2L
writeln(rndtol(1.0001)); // 1L
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="sqrt">pure nothrow @nogc @safe float <strong id="sqrt">sqrt</strong>(float x); <br><br>pure nothrow @nogc @safe double <strong id="sqrt">sqrt</strong>(double x); <br><br>pure nothrow @nogc @safe real <strong id="sqrt">sqrt</strong>(real x); </dt> <dd>
<p>Compute square root of x. </p>
<p><table> <caption>Special Values</caption> <tr>
<th scope="col">x</th> <th scope="col">sqrt(x)</th> <th scope="col">invalid?</th>
</tr> <tr>
<td>-0.0</td> <td>-0.0</td> <td>no</td>
</tr> <tr>
<td>&lt;0.0</td> <td><span class="red">NAN</span></td> <td>yes</td>
</tr> <tr>
<td>+∞</td> <td>+∞</td> <td>no</td>
</tr> </table></p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(sqrt(2.0).feqrel(1.4142) &gt; 16);
assert(sqrt(9.0).feqrel(3.0) &gt; 16);

assert(isNaN(sqrt(-1.0f)));
assert(isNaN(sqrt(-1.0)));
assert(isNaN(sqrt(-1.0L)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="exp">pure nothrow @nogc @trusted real <strong id="exp">exp</strong>(real x); <br><br>pure nothrow @nogc @safe double <strong id="exp">exp</strong>(double x); <br><br>pure nothrow @nogc @safe float <strong id="exp">exp</strong>(float x); </dt> <dd>
<p>Calculates e<sup>x</sup>. </p>
<p><table> <caption>Special Values</caption> <tr>
<th scope="col">x</th> <th scope="col">e<sup>x</sup>
</th> </tr> <tr>
<td>+∞</td> <td>+∞</td> </tr> <tr>
<td>-∞</td> <td>+0.0</td> </tr> <tr>
<td><span class="red">NAN</span></td> <td><span class="red">NAN</span></td> </tr> </table></p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(exp(0.0)); // 1.0
assert(exp(3.0).feqrel(E * E * E) &gt; 16);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="expm1">pure nothrow @nogc @trusted real <strong id="expm1">expm1</strong>(real x); <br><br>pure nothrow @nogc @safe double <strong id="expm1">expm1</strong>(double x); <br><br>pure nothrow @nogc @safe float <strong id="expm1">expm1</strong>(float x); </dt> <dd>
<p>Calculates the value of the natural logarithm base (e) raised to the power of x, minus 1. </p>
<p>For very small x, expm1(x) is more accurate than exp(x)-1. <br><br> <table> <caption>Special Values</caption> <tr>
<th scope="col">x</th> <th scope="col">e<sup>x</sup>-1</th> </tr> <tr>
<td>±0.0</td> <td>±0.0</td> </tr> <tr>
<td>+∞</td> <td>+∞</td> </tr> <tr>
<td>-∞</td> <td>-1.0</td> </tr> <tr>
<td><span class="red">NAN</span></td> <td><span class="red">NAN</span></td> </tr> </table></p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(isIdentical(expm1(0.0), 0.0));
assert(expm1(1.0).feqrel(1.71828) &gt; 16);
assert(expm1(2.0).feqrel(6.3890) &gt; 16);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="exp2">pure nothrow @nogc @trusted real <strong id="exp2">exp2</strong>(real x); <br><br>pure nothrow @nogc @safe double <strong id="exp2">exp2</strong>(double x); <br><br>pure nothrow @nogc @safe float <strong id="exp2">exp2</strong>(float x); </dt> <dd>
<p>Calculates 2<sup>x</sup>. </p>
<p><table> <caption>Special Values</caption> <tr>
<th scope="col">x</th> <th scope="col">exp2(x)</th> </tr> <tr>
<td>+∞</td> <td>+∞</td> </tr> <tr>
<td>-∞</td> <td>+0.0</td> </tr> <tr>
<td><span class="red">NAN</span></td> <td><span class="red">NAN</span></td> </tr> </table></p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(isIdentical(exp2(0.0), 1.0));
assert(exp2(2.0).feqrel(4.0) &gt; 16);
assert(exp2(8.0).feqrel(256.0) &gt; 16);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="frexp">pure nothrow @nogc @trusted T <strong id="frexp">frexp</strong>(T)(const T value, out int exp)<br><small>  Constraints: if (isFloatingPoint!T); </small>
</dt> <dd>
<p>Separate floating point value into significand and exponent. </p>
<dl>
<dt>Returns:</dt>
<dd>Calculate and return <i>x</i> and <i>exp</i> such that value =<i>x</i>*2<sup>exp</sup> and .5 &lt;= |<i>x</i>| &lt; 1.0  <i>x</i> has same sign as value.  <table> <caption>Special Values</caption> <tr>
<th scope="col">value</th> <th scope="col">returns</th> <th scope="col">exp</th>
</tr> <tr>
<td>±0.0</td> <td>±0.0</td> <td>0</td>
</tr> <tr>
<td>+∞</td> <td>+∞</td> <td>int.max</td>
</tr> <tr>
<td>-∞</td> <td>-∞</td> <td>int.min</td>
</tr> <tr>
<td>±<span class="red">NAN</span>
</td> <td>±<span class="red">NAN</span>
</td> <td>int.min</td>
</tr> </table>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int exp;
real mantissa = frexp(123.456L, exp);

assert(approxEqual(mantissa * pow(2.0L, cast(real) exp), 123.456L));

assert(frexp(-real.nan, exp) &amp;&amp; exp == int.min);
assert(frexp(real.nan, exp) &amp;&amp; exp == int.min);
assert(frexp(-real.infinity, exp) == -real.infinity &amp;&amp; exp == int.min);
assert(frexp(real.infinity, exp) == real.infinity &amp;&amp; exp == int.max);
assert(frexp(-0.0, exp) == -0.0 &amp;&amp; exp == 0);
assert(frexp(0.0, exp) == 0.0 &amp;&amp; exp == 0);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="ilogb">pure nothrow @nogc @trusted int <strong id="ilogb">ilogb</strong>(T)(const T x)<br><small>  Constraints: if (isFloatingPoint!T); </small><br><br>pure nothrow @nogc @safe int <strong id="ilogb">ilogb</strong>(T)(const T x)<br><small>  Constraints: if (isIntegral!T &amp;&amp; isUnsigned!T); </small><br><br>pure nothrow @nogc @safe int <strong id="ilogb">ilogb</strong>(T)(const T x)<br><small>  Constraints: if (isIntegral!T &amp;&amp; isSigned!T); </small>
</dt> <dd>
<p>Extracts the exponent of x as a signed integral value. </p>
<p>If x is not a special value, the result is the same as <code>cast(int) logb(x)</code>. <br><br> <table> <caption>Special Values</caption> <tr>
<th scope="col">x</th> <th scope="col">ilogb(x)</th> <th scope="col">Range error?</th>
</tr> <tr>
<td>0</td> <td>FP_ILOGB0</td> <td>yes</td>
</tr> <tr>
<td>±∞</td> <td>int.max</td> <td>no</td>
</tr> <tr>
<td><span class="red">NAN</span></td> <td>FP_ILOGBNAN</td> <td>no</td>
</tr> </table></p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(ilogb(1)); // 0
writeln(ilogb(3)); // 1
writeln(ilogb(3.0)); // 1
writeln(ilogb(100_000_000)); // 26

writeln(ilogb(0)); // FP_ILOGB0
writeln(ilogb(0.0)); // FP_ILOGB0
writeln(ilogb(double.nan)); // FP_ILOGBNAN
writeln(ilogb(double.infinity)); // int.max
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="FP_ILOGB0">alias <strong id="FP_ILOGB0">FP_ILOGB0</strong> = core.stdc.math.<strong id="FP_ILOGB0">FP_ILOGB0</strong>; <br><br>alias <strong id="FP_ILOGBNAN">FP_ILOGBNAN</strong> = core.stdc.math.<strong id="FP_ILOGBNAN">FP_ILOGBNAN</strong>; </dt> <dd>
<p>Special return values of <a href="#ilogb"><code>ilogb</code></a>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(ilogb(0)); // FP_ILOGB0
writeln(ilogb(0.0)); // FP_ILOGB0
writeln(ilogb(double.nan)); // FP_ILOGBNAN
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="ldexp">pure nothrow @nogc @safe real <strong id="ldexp">ldexp</strong>(real n, int exp); <br><br>pure nothrow @nogc @safe double <strong id="ldexp">ldexp</strong>(double n, int exp); <br><br>pure nothrow @nogc @safe float <strong id="ldexp">ldexp</strong>(float n, int exp); </dt> <dd>
<p>Compute n * 2<sup>exp</sup> </p>
<dl>
<dt>References</dt>
<dd> frexp</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.meta : AliasSeq;
static foreach (T; AliasSeq!(float, double, real))
{{
    T r;

    r = ldexp(3.0L, 3);
    writeln(r); // 24

    r = ldexp(cast(T) 3.0, cast(int) 3);
    writeln(r); // 24

    T n = 3.0;
    int exp = 3;
    r = ldexp(n, exp);
    writeln(r); // 24
}}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="log">pure nothrow @nogc @safe real <strong id="log">log</strong>(real x); </dt> <dd>
<p>Calculate the natural logarithm of x. </p>
<p><table> <caption>Special Values</caption> <tr>
<th scope="col">x</th> <th scope="col">log(x)</th> <th scope="col">divide by 0?</th> <th scope="col">invalid?</th>
</tr> <tr>
<td>±0.0</td> <td>-∞</td> <td>yes</td> <td>no</td>
</tr> <tr>
<td>&lt;0.0</td> <td><span class="red">NAN</span></td> <td>no</td> <td>yes</td>
</tr> <tr>
<td>+∞</td> <td>+∞</td> <td>no</td> <td>no</td>
</tr> </table></p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(feqrel(log(E), 1) &gt;= real.mant_dig - 1);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="log10">pure nothrow @nogc @safe real <strong id="log10">log10</strong>(real x); </dt> <dd>
<p>Calculate the base-10 logarithm of x. </p>
<p><table> <caption>Special Values</caption> <tr>
<th scope="col">x</th> <th scope="col">log10(x)</th> <th scope="col">divide by 0?</th> <th scope="col">invalid?</th>
</tr> <tr>
<td>±0.0</td> <td>-∞</td> <td>yes</td> <td>no</td>
</tr> <tr>
<td>&lt;0.0</td> <td><span class="red">NAN</span></td> <td>no</td> <td>yes</td>
</tr> <tr>
<td>+∞</td> <td>+∞</td> <td>no</td> <td>no</td>
</tr> </table></p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(fabs(log10(1000) - 3) &lt; .000001);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="log1p">pure nothrow @nogc @safe real <strong id="log1p">log1p</strong>(real x); </dt> <dd>
<p>Calculates the natural logarithm of 1 + x. </p>
<p>For very small x, log1p(x) will be more accurate than log(1 + x). <br><br> <table> <caption>Special Values</caption> <tr>
<th scope="col">x</th> <th scope="col">log1p(x)</th> <th scope="col">divide by 0?</th> <th scope="col">invalid?</th>
</tr> <tr>
<td>±0.0</td> <td>±0.0</td> <td>no</td> <td>no</td>
</tr> <tr>
<td>-1.0</td> <td>-∞</td> <td>yes</td> <td>no</td>
</tr> <tr>
<td>&lt;-1.0</td> <td>-<span class="red">NAN</span>
</td> <td>no</td> <td>yes</td>
</tr> <tr>
<td>+∞</td> <td>+∞</td> <td>no</td> <td>no</td>
</tr> </table></p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(isIdentical(log1p(0.0), 0.0));
assert(log1p(1.0).feqrel(0.69314) &gt; 16);

writeln(log1p(-1.0)); // -real.infinity
assert(isNaN(log1p(-2.0)));
assert(log1p(real.nan) is real.nan);
assert(log1p(-real.nan) is -real.nan);
writeln(log1p(real.infinity)); // real.infinity
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="log2">pure nothrow @nogc @safe real <strong id="log2">log2</strong>(real x); </dt> <dd>
<p>Calculates the base-2 logarithm of x: log<sub>2</sub>x </p>
<p><table> <caption>Special Values</caption> <tr>
<th scope="col">x</th> <th scope="col">log2(x)</th> <th scope="col">divide by 0?</th> <th scope="col">invalid?</th>
</tr> <tr>
<td>±0.0</td> <td>-∞</td> <td>yes</td> <td>no</td> </tr> <tr>
<td>&lt;0.0</td> <td><span class="red">NAN</span></td> <td>no</td> <td>yes</td> </tr> <tr>
<td>+∞</td> <td>+∞</td> <td>no</td> <td>no</td> </tr> </table></p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(approxEqual(log2(1024.0L), 10));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="logb">nothrow @nogc @trusted real <strong id="logb">logb</strong>(real x); </dt> <dd>
<p>Extracts the exponent of x as a signed integral value. </p>
<p>If x is subnormal, it is treated as if it were normalized. For a positive, finite x: <br><br> 1 &lt;= <i>x</i> * FLT_RADIX<sup>-logb(x)</sup> &lt; FLT_RADIX <br><br> <table> <caption>Special Values</caption> <tr>
<th scope="col">x</th> <th scope="col">logb(x)</th> <th scope="col">divide by 0?</th> </tr> <tr>
<td>±∞</td> <td>+∞</td> <td>no</td>
</tr> <tr>
<td>±0.0</td> <td>-∞</td> <td>yes</td> </tr> </table></p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(logb(1.0)); // 0
writeln(logb(100.0)); // 6

writeln(logb(0.0)); // -real.infinity
writeln(logb(real.infinity)); // real.infinity
writeln(logb(-real.infinity)); // real.infinity
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="fmod">nothrow @nogc @trusted real <strong id="fmod">fmod</strong>(real x, real y); </dt> <dd>
<p>Calculates the remainder from the calculation x/y. </p>
<dl>
<dt>Returns:</dt>
<dd>The value of x - i * y, where i is the number of times that y can be completely subtracted from x. The result has the same sign as x.  <table> <caption>Special Values</caption> <tr>
<th scope="col">x</th> <th scope="col">y</th> <th scope="col">fmod(x, y)</th> <th scope="col">invalid?</th>
</tr> <tr>
<td>±0.0</td> <td>not 0.0</td> <td>±0.0</td> <td>no</td>
</tr> <tr>
<td>±∞</td> <td>anything</td> <td><span class="red">NAN</span></td> <td>yes</td>
</tr> <tr>
<td>anything</td> <td>±0.0</td> <td><span class="red">NAN</span></td> <td>yes</td>
</tr> <tr>
<td>!=±∞</td> <td>±∞</td> <td>x</td> <td>no</td>
</tr> </table>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(isIdentical(fmod(0.0, 1.0), 0.0));
assert(fmod(5.0, 3.0).feqrel(2.0) &gt; 16);
assert(isNaN(fmod(5.0, 0.0)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="modf">nothrow @nogc @trusted real <strong id="modf">modf</strong>(real x, ref real i); </dt> <dd>
<p>Breaks x into an integral part and a fractional part, each of which has the same sign as x. The integral part is stored in i. </p>
<dl>
<dt>Returns:</dt>
<dd>The fractional part of x.  <table> <caption>Special Values</caption> <tr>
<th scope="col">x</th> <th scope="col">i (on input)</th> <th scope="col">modf(x, i)</th> <th scope="col">i (on return)</th>
</tr> <tr>
<td>±∞</td> <td>anything</td> <td>±0.0</td> <td>±∞</td>
</tr> </table>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">real frac;
real intpart;

frac = modf(3.14159, intpart);
assert(intpart.feqrel(3.0) &gt; 16);
assert(frac.feqrel(0.14159) &gt; 16);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="scalbn">pure nothrow @nogc @safe real <strong id="scalbn">scalbn</strong>(real x, int n); <br><br>pure nothrow @nogc @safe double <strong id="scalbn">scalbn</strong>(double x, int n); <br><br>pure nothrow @nogc @safe float <strong id="scalbn">scalbn</strong>(float x, int n); </dt> <dd>
<p>Efficiently calculates x * 2<sup>n</sup>. </p>
<p>scalbn handles underflow and overflow in the same fashion as the basic arithmetic operators. <br><br> <table> <caption>Special Values</caption> <tr>
<th scope="col">x</th> <th scope="col">scalb(x)</th>
</tr> <tr>
<td>±∞</td> <td>±∞</td> </tr> <tr>
<td>±0.0</td> <td>±0.0</td> </tr> </table></p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(scalbn(0x1.2345678abcdefp0L, 999)); // 0x1.2345678abcdefp999L
writeln(scalbn(-real.infinity, 5)); // -real.infinity
writeln(scalbn(2.0, 10)); // 2048.0
writeln(scalbn(2048.0f, -10)); // 2.0f
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="cbrt">nothrow @nogc @trusted real <strong id="cbrt">cbrt</strong>(real x); </dt> <dd>
<p>Calculates the cube root of x. </p>
<p><table> <caption>Special Values</caption> <tr>
<th scope="col"><i>x</i></th> <th scope="col">cbrt(x)</th> <th scope="col">invalid?</th>
</tr> <tr>
<td>±0.0</td> <td>±0.0</td> <td>no</td> </tr> <tr>
<td><span class="red">NAN</span></td> <td><span class="red">NAN</span></td> <td>yes</td> </tr> <tr>
<td>±∞</td> <td>±∞</td> <td>no</td> </tr> </table></p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(cbrt(1.0).feqrel(1.0) &gt; 16);
assert(cbrt(27.0).feqrel(3.0) &gt; 16);
assert(cbrt(15.625).feqrel(2.5) &gt; 16);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="fabs">pure nothrow @nogc @safe real <strong id="fabs">fabs</strong>(real x); <br><br>pure nothrow @nogc @trusted double <strong id="fabs">fabs</strong>(double d); <br><br>pure nothrow @nogc @trusted float <strong id="fabs">fabs</strong>(float f); </dt> <dd>
<p>Returns |x| </p>
<p><table> <caption>Special Values</caption> <tr>
<th scope="col">x</th> <th scope="col">fabs(x)</th>
</tr> <tr>
<td>±0.0</td> <td>+0.0</td> </tr> <tr>
<td>±∞</td> <td>+∞</td> </tr> </table></p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(isIdentical(fabs(0.0f), 0.0f));
assert(isIdentical(fabs(-0.0f), 0.0f));
writeln(fabs(-10.0f)); // 10.0f

assert(isIdentical(fabs(0.0), 0.0));
assert(isIdentical(fabs(-0.0), 0.0));
writeln(fabs(-10.0)); // 10.0

assert(isIdentical(fabs(0.0L), 0.0L));
assert(isIdentical(fabs(-0.0L), 0.0L));
writeln(fabs(-10.0L)); // 10.0L
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="hypot">pure nothrow @nogc @safe real <strong id="hypot">hypot</strong>(real x, real y); </dt> <dd>
<p>Calculates the length of the hypotenuse of a right-angled triangle with sides of length x and y. The hypotenuse is the value of the square root of the sums of the squares of x and y: </p>
<p>sqrt(x<sup>2</sup> + y<sup>2</sup>) <br><br> Note that hypot(x, y), hypot(y, x) and hypot(x, -y) are equivalent. <br><br> <table> <caption>Special Values</caption> <tr>
<th scope="col">x</th> <th scope="col">y</th> <th scope="col">hypot(x, y)</th> <th scope="col">invalid?</th>
</tr> <tr>
<td>x</td> <td>±0.0</td> <td>|x|</td> <td>no</td>
</tr> <tr>
<td>±∞</td> <td>y</td> <td>+∞</td> <td>no</td>
</tr> <tr>
<td>±∞</td> <td><span class="red">NAN</span></td> <td>+∞</td> <td>no</td>
</tr> </table></p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(hypot(1.0, 1.0).feqrel(1.4142) &gt; 16);
assert(hypot(3.0, 4.0).feqrel(5.0) &gt; 16);
writeln(hypot(real.infinity, 1.0)); // real.infinity
writeln(hypot(real.infinity, real.nan)); // real.infinity
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="ceil">pure nothrow @nogc @trusted real <strong id="ceil">ceil</strong>(real x); <br><br>pure nothrow @nogc @trusted double <strong id="ceil">ceil</strong>(double x); <br><br>pure nothrow @nogc @trusted float <strong id="ceil">ceil</strong>(float x); </dt> <dd>
<p>Returns the value of x rounded upward to the next integer (toward positive infinity).</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(ceil(+123.456L)); // +124
writeln(ceil(-123.456L)); // -123
writeln(ceil(-1.234L)); // -1
writeln(ceil(-0.123L)); // 0
writeln(ceil(0.0L)); // 0
writeln(ceil(+0.123L)); // 1
writeln(ceil(+1.234L)); // 2
writeln(ceil(real.infinity)); // real.infinity
assert(isNaN(ceil(real.nan)));
assert(isNaN(ceil(real.init)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="floor">pure nothrow @nogc @trusted real <strong id="floor">floor</strong>(real x); <br><br>pure nothrow @nogc @trusted double <strong id="floor">floor</strong>(double x); <br><br>pure nothrow @nogc @trusted float <strong id="floor">floor</strong>(float x); </dt> <dd>
<p>Returns the value of x rounded downward to the next integer (toward negative infinity).</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(floor(+123.456L)); // +123
writeln(floor(-123.456L)); // -124
writeln(floor(+123.0L)); // +123
writeln(floor(-124.0L)); // -124
writeln(floor(-1.234L)); // -2
writeln(floor(-0.123L)); // -1
writeln(floor(0.0L)); // 0
writeln(floor(+0.123L)); // 0
writeln(floor(+1.234L)); // 1
writeln(floor(real.infinity)); // real.infinity
assert(isNaN(floor(real.nan)));
assert(isNaN(floor(real.init)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="quantize">Unqual!F <strong id="quantize">quantize</strong>(alias rfunc = rint, F)(const F val, const F unit)<br><small>  Constraints: if (is(typeof(rfunc(F.init)) : F) &amp;&amp; isFloatingPoint!F); </small>
</dt> <dd>
<p>Round <code>val</code> to a multiple of <code>unit</code>. <code>rfunc</code> specifies the rounding function to use; by default this is <code>rint</code>, which uses the current rounding mode.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(12345.6789L.quantize(0.01L)); // 12345.68L
writeln(12345.6789L.quantize!floor(0.01L)); // 12345.67L
writeln(12345.6789L.quantize(22.0L)); // 12342.0L
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(12345.6789L.quantize(0)); // 12345.6789L
assert(12345.6789L.quantize(real.infinity).isNaN);
assert(12345.6789L.quantize(real.nan).isNaN);
writeln(real.infinity.quantize(0.01L)); // real.infinity
assert(real.infinity.quantize(real.nan).isNaN);
assert(real.nan.quantize(0.01L).isNaN);
assert(real.nan.quantize(real.infinity).isNaN);
assert(real.nan.quantize(real.nan).isNaN);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="quantize.2">Unqual!F <strong id="quantize">quantize</strong>(real base, alias rfunc = rint, F, E)(const F val, const E exp)<br><small>  Constraints: if (is(typeof(rfunc(F.init)) : F) &amp;&amp; isFloatingPoint!F &amp;&amp; isIntegral!E); </small><br><br>Unqual!F <strong id="quantize">quantize</strong>(real base, long exp = 1, alias rfunc = rint, F)(const F val)<br><small>  Constraints: if (is(typeof(rfunc(F.init)) : F) &amp;&amp; isFloatingPoint!F); </small>
</dt> <dd>
<p>Round <code>val</code> to a multiple of <code>pow(base, exp)</code>. <code>rfunc</code> specifies the rounding function to use; by default this is <code>rint</code>, which uses the current rounding mode.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(12345.6789L.quantize!10(-2)); // 12345.68L
writeln(12345.6789L.quantize!(10, -2)); // 12345.68L
writeln(12345.6789L.quantize!(10, floor)(-2)); // 12345.67L
writeln(12345.6789L.quantize!(10, -2, floor)); // 12345.67L

writeln(12345.6789L.quantize!22(1)); // 12342.0L
writeln(12345.6789L.quantize!22); // 12342.0L
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="nearbyint">pure nothrow @nogc @safe real <strong id="nearbyint">nearbyint</strong>(real x); </dt> <dd>
<p>Rounds x to the nearest integer value, using the current rounding mode. </p>
<p>Unlike the rint functions, nearbyint does not raise the FE_INEXACT exception.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(nearbyint(0.4)); // 0
writeln(nearbyint(0.5)); // 0
writeln(nearbyint(0.6)); // 1
writeln(nearbyint(100.0)); // 100

assert(isNaN(nearbyint(real.nan)));
writeln(nearbyint(real.infinity)); // real.infinity
writeln(nearbyint(-real.infinity)); // -real.infinity
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="rint">pure nothrow @nogc @safe real <strong id="rint">rint</strong>(real x); <br><br>pure nothrow @nogc @safe double <strong id="rint">rint</strong>(double x); <br><br>pure nothrow @nogc @safe float <strong id="rint">rint</strong>(float x); </dt> <dd>
<p>Rounds x to the nearest integer value, using the current rounding mode. </p>
<p>If the return value is not equal to x, the FE_INEXACT exception is raised. <br><br> <a href="#nearbyint"><code>nearbyint</code></a> performs the same operation, but does not set the FE_INEXACT exception.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">version (IeeeFlagsSupport) resetIeeeFlags();
writeln(rint(0.4)); // 0
version (IeeeFlagsSupport) assert(ieeeFlags.inexact);

writeln(rint(0.5)); // 0
writeln(rint(0.6)); // 1
writeln(rint(100.0)); // 100

assert(isNaN(rint(real.nan)));
writeln(rint(real.infinity)); // real.infinity
writeln(rint(-real.infinity)); // -real.infinity
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="lrint">pure nothrow @nogc @trusted long <strong id="lrint">lrint</strong>(real x); </dt> <dd>
<p>Rounds x to the nearest integer value, using the current rounding mode. </p>
<p>This is generally the fastest method to convert a floating-point number to an integer. Note that the results from this function depend on the rounding mode, if the fractional part of x is exactly 0.5. If using the default rounding mode (ties round to even integers) lrint(4.5) == 4, lrint(5.5)==6.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(lrint(4.5)); // 4
writeln(lrint(5.5)); // 6
writeln(lrint(-4.5)); // -4
writeln(lrint(-5.5)); // -6

writeln(lrint(int.max - 0.5)); // 2147483646L
writeln(lrint(int.max + 0.5)); // 2147483648L
writeln(lrint(int.min - 0.5)); // -2147483648L
writeln(lrint(int.min + 0.5)); // -2147483648L
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="round">nothrow @nogc @trusted auto <strong id="round">round</strong>(real x); </dt> <dd>
<p>Return the value of x rounded to the nearest integer. If the fractional part of x is exactly 0.5, the return value is rounded away from zero. </p>
<dl>
<dt>Returns:</dt>
<dd>A <code>real</code>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(round(4.5)); // 5
writeln(round(5.4)); // 5
writeln(round(-4.5)); // -5
writeln(round(-5.1)); // -5
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="lround">nothrow @nogc @trusted long <strong id="lround">lround</strong>(real x); </dt> <dd>
<p>Return the value of x rounded to the nearest integer. </p>
<p>If the fractional part of x is exactly 0.5, the return value is rounded away from zero. <br><br> <span class="blue">This function is not implemented for Digital Mars C runtime.</span></p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">version (CRuntime_DigitalMars) {}
else
{
    writeln(lround(0.49)); // 0
    writeln(lround(0.5)); // 1
    writeln(lround(1.5)); // 2
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="trunc">pure nothrow @nogc @trusted real <strong id="trunc">trunc</strong>(real x); </dt> <dd>
<p>Returns the integer portion of x, dropping the fractional portion. This is also known as "chop" rounding. <code>pure</code> on all platforms.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(trunc(0.01)); // 0
writeln(trunc(0.49)); // 0
writeln(trunc(0.5)); // 0
writeln(trunc(1.5)); // 1
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="remainder">nothrow @nogc @trusted real <strong id="remainder">remainder</strong>(real x, real y); <br><br>nothrow @nogc @trusted real <strong id="remquo">remquo</strong>(real x, real y, out int n); </dt> <dd>
<p>Calculate the remainder x REM y, following IEC 60559. </p>
<p>REM is the value of x - y * n, where n is the integer nearest the exact value of x / y. If |n - x / y| == 0.5, n is even. If the result is zero, it has the same sign as x. Otherwise, the sign of the result is the sign of x / y. Precision mode has no effect on the remainder functions. <br><br> remquo returns <code>n</code> in the parameter <code>n</code>. <br><br> <table> <caption>Special Values</caption> <tr>
<th scope="col">x</th> <th scope="col">y</th> <th scope="col">remainder(x, y)</th> <th scope="col">n</th> <th scope="col">invalid?</th>
</tr> <tr>
<td>±0.0</td> <td>not 0.0</td> <td>±0.0</td> <td>0.0</td> <td>no</td>
</tr> <tr>
<td>±∞</td> <td>anything</td> <td>-<span class="red">NAN</span>
</td> <td>?</td> <td>yes</td>
</tr> <tr>
<td>anything</td> <td>±0.0</td> <td>±<span class="red">NAN</span>
</td> <td>?</td> <td>yes</td>
</tr> <tr>
<td>!= ±∞</td> <td>±∞</td> <td>x</td> <td>?</td> <td>no</td>
</tr> </table></p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(remainder(5.1, 3.0).feqrel(-0.9) &gt; 16);
assert(remainder(-5.1, 3.0).feqrel(0.9) &gt; 16);
writeln(remainder(0.0, 3.0)); // 0.0

assert(isNaN(remainder(1.0, 0.0)));
assert(isNaN(remainder(-1.0, 0.0)));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int n;

assert(remquo(5.1, 3.0, n).feqrel(-0.9) &gt; 16 &amp;&amp; n == 2);
assert(remquo(-5.1, 3.0, n).feqrel(0.9) &gt; 16 &amp;&amp; n == -2);
assert(remquo(0.0, 3.0, n) == 0.0 &amp;&amp; n == 0);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="IeeeFlags">struct <strong id="IeeeFlags">IeeeFlags</strong>; </dt> <dd>
<p>IEEE exception status flags ('sticky bits') </p>
<p>These flags indicate that an exceptional floating-point condition has occurred. They indicate that a NaN or an infinity has been generated, that a result is inexact, or that a signalling NaN has been encountered. If floating-point exceptions are enabled (unmasked), a hardware exception will be generated instead of setting these flags.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static void func() {
    int a = 10 * 10;
}
pragma(inline, false) static void blockopt(ref real x) {}
real a = 3.5;
// Set all the flags to zero
resetIeeeFlags();
assert(!ieeeFlags.divByZero);
blockopt(a); // avoid constant propagation by the optimizer
// Perform a division by zero.
a /= 0.0L;
writeln(a); // real.infinity
assert(ieeeFlags.divByZero);
blockopt(a); // avoid constant propagation by the optimizer
// Create a NaN
a *= 0.0L;
assert(ieeeFlags.invalid);
assert(isNaN(a));

// Check that calling func() has no effect on the
// status flags.
IeeeFlags f = ieeeFlags;
func();
writeln(ieeeFlags); // f
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="IeeeFlags.inexact">const nothrow @nogc @property @safe bool <strong id="inexact">inexact</strong>(); </dt> <dd>
<p>The result cannot be represented exactly, so rounding occurred. </p>
<dl>
<dt>Example</dt>
<dd> <code>x = sin(0.1);</code>
</dd>
</dl> </dd> <dt class="d_decl" id="IeeeFlags.underflow">const nothrow @nogc @property @safe bool <strong id="underflow">underflow</strong>(); </dt> <dd>
<p>A zero was generated by underflow </p>
<dl>
<dt>Example</dt>
<dd> <code>x = real.min*real.epsilon/2;</code>
</dd>
</dl> </dd> <dt class="d_decl" id="IeeeFlags.overflow">const nothrow @nogc @property @safe bool <strong id="overflow">overflow</strong>(); </dt> <dd>
<p>An infinity was generated by overflow </p>
<dl>
<dt>Example</dt>
<dd> <code>x = real.max*2;</code>
</dd>
</dl> </dd> <dt class="d_decl" id="IeeeFlags.divByZero">const nothrow @nogc @property @safe bool <strong id="divByZero">divByZero</strong>(); </dt> <dd>
<p>An infinity was generated by division by zero </p>
<dl>
<dt>Example</dt>
<dd> <code>x = 3/0.0;</code>
</dd>
</dl> </dd> <dt class="d_decl" id="IeeeFlags.invalid">const nothrow @nogc @property @safe bool <strong id="invalid">invalid</strong>(); </dt> <dd>
<p>A machine NaN was generated. </p>
<dl>
<dt>Example</dt>
<dd> <code>x = real.infinity * 0.0;</code>
</dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="resetIeeeFlags">nothrow @nogc @trusted void <strong id="resetIeeeFlags">resetIeeeFlags</strong>(); </dt> <dd>
<p>Set all of the floating-point status flags to false.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">pragma(inline, false) static void blockopt(ref real x) {}
resetIeeeFlags();
real a = 3.5;
blockopt(a); // avoid constant propagation by the optimizer
a /= 0.0L;
blockopt(a); // avoid constant propagation by the optimizer
writeln(a); // real.infinity
assert(ieeeFlags.divByZero);

resetIeeeFlags();
assert(!ieeeFlags.divByZero);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="ieeeFlags">pure nothrow @nogc @property @trusted IeeeFlags <strong id="ieeeFlags">ieeeFlags</strong>(); </dt> <dd>
<dl>
<dt>Returns:</dt>
<dd>snapshot of the current state of the floating-point status flags</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">pragma(inline, false) static void blockopt(ref real x) {}
resetIeeeFlags();
real a = 3.5;
blockopt(a); // avoid constant propagation by the optimizer

a /= 0.0L;
writeln(a); // real.infinity
assert(ieeeFlags.divByZero);
blockopt(a); // avoid constant propagation by the optimizer

a *= 0.0L;
assert(isNaN(a));
assert(ieeeFlags.invalid);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="FloatingPointControl">struct <strong id="FloatingPointControl">FloatingPointControl</strong>; </dt> <dd>
<p>Control the Floating point hardware </p>
<p>Change the IEEE754 floating-point rounding mode and the floating-point hardware exceptions. <br><br> By default, the rounding mode is roundToNearest and all hardware exceptions are disabled. For most applications, debugging is easier if the <i>division by zero</i>, <i>overflow</i>, and <i>invalid operation</i> exceptions are enabled. These three are combined into a <i>severeExceptions</i> value for convenience. Note in particular that if <i>invalidException</i> is enabled, a hardware trap will be generated whenever an uninitialized floating-point variable is used. <br><br> All changes are temporary. The previous state is restored at the end of the scope. <br><br> </p> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">{
    FloatingPointControl fpctrl;

    // Enable hardware exceptions for division by zero, overflow to infinity,
    // invalid operations, and uninitialized floating-point variables.
    fpctrl.enableExceptions(FloatingPointControl.severeExceptions);

    // This will generate a hardware exception, if x is a
    // default-initialized floating point variable:
    real x; // Add `= 0` or even `= real.nan` to not throw the exception.
    real y = x * 3.0;

    // The exception is only thrown for default-uninitialized NaN-s.
    // NaN-s with other payload are valid:
    real z = y * real.nan; // ok

    // The set hardware exceptions and rounding modes will be disabled when
    // leaving this scope.
}
</pre>  <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">FloatingPointControl fpctrl;

fpctrl.rounding = FloatingPointControl.roundDown;
writeln(lrint(1.5)); // 1.0

fpctrl.rounding = FloatingPointControl.roundUp;
writeln(lrint(1.4)); // 2.0

fpctrl.rounding = FloatingPointControl.roundToNearest;
writeln(lrint(1.5)); // 2.0
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="FloatingPointControl.RoundingMode">alias <strong id="RoundingMode">RoundingMode</strong> = uint; </dt>  <dt class="d_decl" id="FloatingPointControl.roundToNearest">
<strong id="roundToNearest">roundToNearest</strong><br><br><strong id="roundDown">roundDown</strong><br><br><strong id="roundUp">roundUp</strong><br><br><strong id="roundToZero">roundToZero</strong><br><br><strong id="roundingMask">roundingMask</strong>
</dt> <dd>
<p>IEEE rounding modes. The default mode is roundToNearest. </p>
<p>roundingMask = A mask of all rounding modes.</p> </dd> <dt class="d_decl" id="FloatingPointControl.rounding">nothrow @nogc @property @trusted void <strong id="rounding">rounding</strong>(RoundingMode newMode); </dt> <dd>
<p>Change the floating-point hardware rounding mode </p>
<p> Changing the rounding mode in the middle of a function can interfere with optimizations of floating point expressions, as the optimizer assumes that the rounding mode does not change. It is best to change the rounding mode only at the beginning of the function, and keep it until the function returns. It is also best to add the line: <pre data-language="d">pragma(inline, false);
</pre> as the first line of the function so it will not get inlined. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>RoundingMode <code>newMode</code>
</td> <td>the new rounding mode</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="FloatingPointControl.rounding.2">static pure nothrow @nogc @property @trusted RoundingMode <strong id="rounding">rounding</strong>(); </dt> <dd>
<dl>
<dt>Returns:</dt>
<dd>the currently active rounding mode</dd>
</dl> </dd> <dt class="d_decl" id="FloatingPointControl.ExceptionMask">alias <strong id="ExceptionMask">ExceptionMask</strong> = uint; </dt>  <dt class="d_decl" id="FloatingPointControl.subnormalException">
<strong id="subnormalException">subnormalException</strong><br><br><strong id="inexactException">inexactException</strong><br><br><strong id="underflowException">underflowException</strong><br><br><strong id="overflowException">overflowException</strong><br><br><strong id="divByZeroException">divByZeroException</strong><br><br><strong id="invalidException">invalidException</strong><br><br><strong id="severeExceptions">severeExceptions</strong><br><br><strong id="allExceptions">allExceptions</strong>
</dt> <dd>
<p>IEEE hardware exceptions. By default, all exceptions are masked (disabled). </p>
<p>severeExceptions = The overflow, division by zero, and invalid exceptions.</p> </dd> <dt class="d_decl" id="FloatingPointControl.hasExceptionTraps">static pure nothrow @nogc @property @safe bool <strong id="hasExceptionTraps">hasExceptionTraps</strong>(); </dt> <dd>
<dl>
<dt>Returns:</dt>
<dd>true if the current FPU supports exception trapping</dd>
</dl> </dd> <dt class="d_decl" id="FloatingPointControl.enableExceptions">nothrow @nogc @trusted void <strong id="enableExceptions">enableExceptions</strong>(ExceptionMask exceptions); </dt> <dd>
<p>Enable (unmask) specific hardware exceptions. Multiple exceptions may be ORed together.</p> </dd> <dt class="d_decl" id="FloatingPointControl.disableExceptions">nothrow @nogc @trusted void <strong id="disableExceptions">disableExceptions</strong>(ExceptionMask exceptions); </dt> <dd>
<p>Disable (mask) specific hardware exceptions. Multiple exceptions may be ORed together.</p> </dd> <dt class="d_decl" id="FloatingPointControl.enabledExceptions">static pure nothrow @nogc @property @trusted ExceptionMask <strong id="enabledExceptions">enabledExceptions</strong>(); </dt> <dd>
<dl>
<dt>Returns:</dt>
<dd>the exceptions which are currently enabled (unmasked)</dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="isNaN">pure nothrow @nogc @trusted bool <strong id="isNaN">isNaN</strong>(X)(X x)<br><small>  Constraints: if (isFloatingPoint!X); </small>
</dt> <dd>
<p>Determines if <span class="d_param">x</span> is NaN. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>X <code>x</code>
</td> <td>a floating point number.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if <span class="d_param">x</span> is Nan.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert( isNaN(float.init));
assert( isNaN(-double.init));
assert( isNaN(real.nan));
assert( isNaN(-real.nan));
assert(!isNaN(cast(float) 53.6));
assert(!isNaN(cast(real)-53.6));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isFinite">pure nothrow @nogc @trusted bool <strong id="isFinite">isFinite</strong>(X)(X x); </dt> <dd>
<p>Determines if <span class="d_param">x</span> is finite. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>X <code>x</code>
</td> <td>a floating point number.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if <span class="d_param">x</span> is finite.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert( isFinite(1.23f));
assert( isFinite(float.max));
assert( isFinite(float.min_normal));
assert(!isFinite(float.nan));
assert(!isFinite(float.infinity));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isNormal">pure nothrow @nogc @trusted bool <strong id="isNormal">isNormal</strong>(X)(X x); </dt> <dd>
<p>Determines if <span class="d_param">x</span> is normalized. </p>
<p>A normalized number must not be zero, subnormal, infinite nor <span class="red">NAN</span>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>X <code>x</code>
</td> <td>a floating point number.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if <span class="d_param">x</span> is normalized.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">float f = 3;
double d = 500;
real e = 10e+48;

assert(isNormal(f));
assert(isNormal(d));
assert(isNormal(e));
f = d = e = 0;
assert(!isNormal(f));
assert(!isNormal(d));
assert(!isNormal(e));
assert(!isNormal(real.infinity));
assert(isNormal(-real.max));
assert(!isNormal(real.min_normal/4));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isSubnormal">pure nothrow @nogc @trusted bool <strong id="isSubnormal">isSubnormal</strong>(X)(X x); </dt> <dd>
<p>Determines if <span class="d_param">x</span> is subnormal. </p>
<p>Subnormals (also known as "denormal number"), have a 0 exponent and a 0 most significant mantissa bit. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>X <code>x</code>
</td> <td>a floating point number.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if <span class="d_param">x</span> is a denormal number.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.meta : AliasSeq;

static foreach (T; AliasSeq!(float, double, real))
{{
    T f;
    for (f = 1.0; !isSubnormal(f); f /= 2)
        assert(f != 0);
}}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isInfinity">pure nothrow @nogc @trusted bool <strong id="isInfinity">isInfinity</strong>(X)(X x)<br><small>  Constraints: if (isFloatingPoint!X); </small>
</dt> <dd>
<p>Determines if <span class="d_param">x</span> is ±∞. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>X <code>x</code>
</td> <td>a floating point number.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if <span class="d_param">x</span> is ±∞.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(!isInfinity(float.init));
assert(!isInfinity(-float.init));
assert(!isInfinity(float.nan));
assert(!isInfinity(-float.nan));
assert(isInfinity(float.infinity));
assert(isInfinity(-float.infinity));
assert(isInfinity(-1.0f / 0.0f));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isIdentical">pure nothrow @nogc @trusted bool <strong id="isIdentical">isIdentical</strong>(real x, real y); </dt> <dd>
<p>Is the binary representation of x identical to y?</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert( isIdentical(0.0, 0.0));
assert( isIdentical(1.0, 1.0));
assert( isIdentical(real.infinity, real.infinity));
assert( isIdentical(-real.infinity, -real.infinity));

assert(!isIdentical(0.0, -0.0));
assert(!isIdentical(real.nan, -real.nan));
assert(!isIdentical(real.infinity, -real.infinity));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="signbit">pure nothrow @nogc @trusted int <strong id="signbit">signbit</strong>(X)(X x); </dt> <dd>
<p>Return 1 if sign bit of e is set, 0 if not.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(!signbit(float.nan));
assert(signbit(-float.nan));
assert(!signbit(168.1234f));
assert(signbit(-168.1234f));
assert(!signbit(0.0f));
assert(signbit(-0.0f));
assert(signbit(-float.max));
assert(!signbit(float.max));

assert(!signbit(double.nan));
assert(signbit(-double.nan));
assert(!signbit(168.1234));
assert(signbit(-168.1234));
assert(!signbit(0.0));
assert(signbit(-0.0));
assert(signbit(-double.max));
assert(!signbit(double.max));

assert(!signbit(real.nan));
assert(signbit(-real.nan));
assert(!signbit(168.1234L));
assert(signbit(-168.1234L));
assert(!signbit(0.0L));
assert(signbit(-0.0L));
assert(signbit(-real.max));
assert(!signbit(real.max));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="copysign">pure nothrow @nogc @trusted R <strong id="copysign">copysign</strong>(R, X)(R to, X from)<br><small>  Constraints: if (isFloatingPoint!R &amp;&amp; isFloatingPoint!X); </small><br><br>pure nothrow @nogc @trusted R <strong id="copysign">copysign</strong>(R, X)(X to, R from)<br><small>  Constraints: if (isIntegral!X &amp;&amp; isFloatingPoint!R); </small>
</dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>to</code>
</td> <td>the numeric value to use</td>
</tr> <tr>
<td>X <code>from</code>
</td> <td>the sign value to use</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>a value composed of to with from's sign bit.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(copysign(1.0, 1.0)); // 1.0
writeln(copysign(1.0, -0.0)); // -1.0
writeln(copysign(1UL, -1.0)); // -1.0
writeln(copysign(-1.0, -1.0)); // -1.0

writeln(copysign(real.infinity, -1.0)); // -real.infinity
assert(copysign(real.nan, 1.0) is real.nan);
assert(copysign(-real.nan, 1.0) is real.nan);
assert(copysign(real.nan, -1.0) is -real.nan);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="sgn">pure nothrow @nogc @safe F <strong id="sgn">sgn</strong>(F)(F x)<br><small>  Constraints: if (isFloatingPoint!F || isIntegral!F); </small>
</dt> <dd>
<p>Returns <code>-1</code> if <code>x &lt; 0</code>, <code>x</code> if <code>x == 0</code>, <code>1</code> if <code>x &gt; 0</code>, and <span class="red">NAN</span> if x==<span class="red">NAN</span>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(sgn(168.1234)); // 1
writeln(sgn(-168.1234)); // -1
writeln(sgn(0.0)); // 0
writeln(sgn(-0.0)); // 0
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="NaN">pure nothrow @nogc @trusted real <strong id="NaN">NaN</strong>(ulong payload); </dt> <dd>
<p>Create a quiet <span class="red">NAN</span>, storing an integer inside the payload. </p>
<p>For floats, the largest possible payload is 0x3F_FFFF. For doubles, it is 0x3_FFFF_FFFF_FFFF. For 80-bit or 128-bit reals, it is 0x3FFF_FFFF_FFFF_FFFF.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">real a = NaN(1_000_000);
assert(isNaN(a));
writeln(getNaNPayload(a)); // 1_000_000
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="getNaNPayload">pure nothrow @nogc @trusted ulong <strong id="getNaNPayload">getNaNPayload</strong>(real x); </dt> <dd>
<p>Extract an integral payload from a <span class="red">NAN</span>. </p>
<dl>
<dt>Returns:</dt>
<dd>the integer payload as a ulong.  For floats, the largest possible payload is 0x3F_FFFF. For doubles, it is 0x3_FFFF_FFFF_FFFF. For 80-bit or 128-bit reals, it is 0x3FFF_FFFF_FFFF_FFFF.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">real a = NaN(1_000_000);
assert(isNaN(a));
writeln(getNaNPayload(a)); // 1_000_000
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="nextUp">pure nothrow @nogc @trusted real <strong id="nextUp">nextUp</strong>(real x); <br><br>pure nothrow @nogc @trusted double <strong id="nextUp">nextUp</strong>(double x); <br><br>pure nothrow @nogc @trusted float <strong id="nextUp">nextUp</strong>(float x); </dt> <dd>
<p>Calculate the next largest floating point value after x. </p>
<p>Return the least number greater than x that is representable as a real; thus, it gives the next point on the IEEE number line. <br><br> <table> <caption>Special Values</caption> <tr>
<th scope="col">x</th> <th scope="col"> nextUp(x) </th>
</tr> <tr>
<td> -∞</td> <td> -real.max </td>
</tr> <tr>
<td> ±0.0</td> <td>real.min_normal*real.epsilon </td>
</tr> <tr>
<td> real.max</td> <td> ∞ </td>
</tr> <tr>
<td> ∞</td> <td> ∞ </td>
</tr> <tr>
<td> <span class="red">NAN</span>
</td> <td> <span class="red">NAN</span> </td>
</tr> </table></p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(nextUp(1.0 - 1.0e-6).feqrel(0.999999) &gt; 16);
assert(nextUp(1.0 - real.epsilon).feqrel(1.0) &gt; 16);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="nextDown">pure nothrow @nogc @safe real <strong id="nextDown">nextDown</strong>(real x); <br><br>pure nothrow @nogc @safe double <strong id="nextDown">nextDown</strong>(double x); <br><br>pure nothrow @nogc @safe float <strong id="nextDown">nextDown</strong>(float x); </dt> <dd>
<p>Calculate the next smallest floating point value before x. </p>
<p>Return the greatest number less than x that is representable as a real; thus, it gives the previous point on the IEEE number line. <br><br> <table> <caption>Special Values</caption> <tr>
<th scope="col">x</th> <th scope="col"> nextDown(x) </th>
</tr> <tr>
<td> ∞</td> <td> real.max </td>
</tr> <tr>
<td> ±0.0</td> <td>-real.min_normal*real.epsilon </td>
</tr> <tr>
<td> -real.max</td> <td> -∞ </td>
</tr> <tr>
<td> -∞</td> <td> -∞ </td>
</tr> <tr>
<td> <span class="red">NAN</span>
</td> <td> <span class="red">NAN</span> </td>
</tr> </table></p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(nextDown(1.0 + real.epsilon)); // 1.0
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="nextafter">pure nothrow @nogc @safe T <strong id="nextafter">nextafter</strong>(T)(const T x, const T y); </dt> <dd>
<p>Calculates the next representable value after x in the direction of y. </p>
<p>If y &gt; x, the result will be the next largest floating-point value; if y &lt; x, the result will be the next smallest value. If x == y, the result is y. If x or y is a NaN, the result is a NaN. </p> <dl>
<dt>Remarks</dt>
<dd> This function is not generally very useful; it's almost always better to use the faster functions nextUp() or nextDown() instead. </dd>
</dl> The FE_INEXACT and FE_OVERFLOW exceptions will be raised if x is finite and the function result is infinite. The FE_INEXACT and FE_UNDERFLOW exceptions will be raised if the function value is subnormal, and x is not equal to y. <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">float a = 1;
assert(is(typeof(nextafter(a, a)) == float));
assert(nextafter(a, a.infinity) &gt; a);
assert(isNaN(nextafter(a, a.nan)));
assert(isNaN(nextafter(a.nan, a)));

double b = 2;
assert(is(typeof(nextafter(b, b)) == double));
assert(nextafter(b, b.infinity) &gt; b);
assert(isNaN(nextafter(b, b.nan)));
assert(isNaN(nextafter(b.nan, b)));

real c = 3;
assert(is(typeof(nextafter(c, c)) == real));
assert(nextafter(c, c.infinity) &gt; c);
assert(isNaN(nextafter(c, c.nan)));
assert(isNaN(nextafter(c.nan, c)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="fdim">pure nothrow @nogc @safe real <strong id="fdim">fdim</strong>(real x, real y); </dt> <dd>
<p>Returns the positive difference between x and y. </p>
<p>Equivalent to <code>fmax(x-y, 0)</code>. </p> <dl>
<dt>Returns:</dt>
<dd><table> <caption>Special Values</caption> <tr>
<th scope="col">x, y</th> <th scope="col">fdim(x, y)</th>
</tr> <tr>
<td>x &gt; y</td> <td>x - y</td>
</tr> <tr>
<td>x &lt;= y</td> <td>+0.0</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(fdim(2.0, 0.0)); // 2.0
writeln(fdim(-2.0, 0.0)); // 0.0
writeln(fdim(real.infinity, 2.0)); // real.infinity
assert(isNaN(fdim(real.nan, 2.0)));
assert(isNaN(fdim(2.0, real.nan)));
assert(isNaN(fdim(real.nan, real.nan)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="fmax">pure nothrow @nogc @safe F <strong id="fmax">fmax</strong>(F)(const F x, const F y)<br><small>  Constraints: if (__traits(isFloating, F)); </small>
</dt> <dd>
<p>Returns the larger of <code>x</code> and <code>y</code>. </p>
<p>If one of the arguments is a <code>NaN</code>, the other is returned. </p> <dl>
<dt>See Also:</dt>
<dd>
<a href="std_algorithm_comparison.html#max"><code>std.algorithm.comparison.max</code></a> is faster because it does not perform the <code>isNaN</code> test.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.meta : AliasSeq;
static foreach (F; AliasSeq!(float, double, real))
{
    writeln(fmax(F(0.0), F(2.0))); // 2.0
    writeln(fmax(F(-2.0), 0.0)); // F(0.0)
    writeln(fmax(F.infinity, F(2.0))); // F.infinity
    writeln(fmax(F.nan, F(2.0))); // F(2.0)
    writeln(fmax(F(2.0), F.nan)); // F(2.0)
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="fmin">pure nothrow @nogc @safe F <strong id="fmin">fmin</strong>(F)(const F x, const F y)<br><small>  Constraints: if (__traits(isFloating, F)); </small>
</dt> <dd>
<p>Returns the smaller of <code>x</code> and <code>y</code>. </p>
<p>If one of the arguments is a <code>NaN</code>, the other is returned. </p> <dl>
<dt>See Also:</dt>
<dd>
<a href="std_algorithm_comparison.html#min"><code>std.algorithm.comparison.min</code></a> is faster because it does not perform the <code>isNaN</code> test.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.meta : AliasSeq;
static foreach (F; AliasSeq!(float, double, real))
{
    writeln(fmin(F(0.0), F(2.0))); // 0.0
    writeln(fmin(F(-2.0), F(0.0))); // -2.0
    writeln(fmin(F.infinity, F(2.0))); // 2.0
    writeln(fmin(F.nan, F(2.0))); // 2.0
    writeln(fmin(F(2.0), F.nan)); // 2.0
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="fma">pure nothrow @nogc @safe real <strong id="fma">fma</strong>(real x, real y, real z); </dt> <dd>
<p>Returns (x * y) + z, rounding only once according to the current rounding mode. </p>
<dl>
<dt>Bugs:</dt>
<dd>Not currently implemented - rounds twice.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(fma(0.0, 2.0, 2.0)); // 2.0
writeln(fma(2.0, 2.0, 2.0)); // 6.0
writeln(fma(real.infinity, 2.0, 2.0)); // real.infinity
assert(fma(real.nan, 2.0, 2.0) is real.nan);
assert(fma(2.0, 2.0, real.nan) is real.nan);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="pow">pure nothrow @nogc @trusted Unqual!F <strong id="pow">pow</strong>(F, G)(F x, G n)<br><small>  Constraints: if (isFloatingPoint!F &amp;&amp; isIntegral!G); </small>
</dt> <dd>
<p>Compute the value of x <sup>n</sup>, where n is an integer</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(pow(2.0, 5)); // 32.0
assert(pow(1.5, 9).feqrel(38.4433) &gt; 16);
assert(pow(real.nan, 2) is real.nan);
writeln(pow(real.infinity, 2)); // real.infinity
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="pow.2">pure nothrow @nogc @trusted typeof(Unqual!F.init * Unqual!G.init) <strong id="pow">pow</strong>(F, G)(F x, G n)<br><small>  Constraints: if (isIntegral!F &amp;&amp; isIntegral!G); </small>
</dt> <dd>
<p>Compute the power of two integral numbers. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>F <code>x</code>
</td> <td>base</td>
</tr> <tr>
<td>G <code>n</code>
</td> <td>exponent</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>x raised to the power of n. If n is negative the result is 1 / pow(x, -n), which is calculated as integer division with remainder. This may result in a division by zero error.  If both x and n are 0, the result is 1. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>If x is 0 and n is negative, the result is the same as the result of a division by zero.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(pow(2, 3)); // 8
writeln(pow(3, 2)); // 9

writeln(pow(2, 10)); // 1_024
writeln(pow(2, 20)); // 1_048_576
writeln(pow(2, 30)); // 1_073_741_824

writeln(pow(0, 0)); // 1

writeln(pow(1, -5)); // 1
writeln(pow(1, -6)); // 1
writeln(pow(-1, -5)); // -1
writeln(pow(-1, -6)); // 1

writeln(pow(-2, 5)); // -32
writeln(pow(-2, -5)); // 0
writeln(pow(cast(double)-2, -5)); // -0.03125
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="pow.3">pure nothrow @nogc @trusted real <strong id="pow">pow</strong>(I, F)(I x, F y)<br><small>  Constraints: if (isIntegral!I &amp;&amp; isFloatingPoint!F); </small>
</dt> <dd>
<p>Computes integer to floating point powers.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(pow(2, 5.0)); // 32.0
writeln(pow(7, 3.0)); // 343.0
assert(pow(2, real.nan) is real.nan);
writeln(pow(2, real.infinity)); // real.infinity
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="pow.4">pure nothrow @nogc @trusted Unqual!(Largest!(F, G)) <strong id="pow">pow</strong>(F, G)(F x, G y)<br><small>  Constraints: if (isFloatingPoint!F &amp;&amp; isFloatingPoint!G); </small>
</dt> <dd>
<p>Calculates x<sup>y</sup>. </p>
<p><table> <caption>Special Values</caption> <tr>
<th scope="col">x</th> <th scope="col">y</th> <th scope="col">pow(x, y)</th> <th scope="col">div 0</th> <th scope="col">invalid?</th>
</tr> <tr>
<td>anything</td> <td>±0.0</td> <td>1.0</td> <td>no</td> <td>no</td> </tr> <tr>
<td>|x| &gt; 1</td> <td>+∞</td> <td>+∞</td> <td>no</td> <td>no</td> </tr> <tr>
<td>|x| &lt; 1</td> <td>+∞</td> <td>+0.0</td> <td>no</td> <td>no</td> </tr> <tr>
<td>|x| &gt; 1</td> <td>-∞</td> <td>+0.0</td> <td>no</td> <td>no</td> </tr> <tr>
<td>|x| &lt; 1</td> <td>-∞</td> <td>+∞</td> <td>no</td> <td>no</td> </tr> <tr>
<td>+∞</td> <td>&gt; 0.0</td> <td>+∞</td> <td>no</td> <td>no</td> </tr> <tr>
<td>+∞</td> <td>&lt; 0.0</td> <td>+0.0</td> <td>no</td> <td>no</td> </tr> <tr>
<td>-∞</td> <td>odd integer &gt; 0.0</td> <td>-∞</td> <td>no</td> <td>no</td> </tr> <tr>
<td>-∞</td> <td>&gt; 0.0, not odd integer</td> <td>+∞</td> <td>no</td> <td>no</td>
</tr> <tr>
<td>-∞</td> <td>odd integer &lt; 0.0</td> <td>-0.0</td> <td>no</td> <td>no</td> </tr> <tr>
<td>-∞</td> <td>&lt; 0.0, not odd integer</td> <td>+0.0</td> <td>no</td> <td>no</td> </tr> <tr>
<td>±1.0</td> <td>±∞</td> <td>-<span class="red">NAN</span>
</td> <td>no</td> <td>yes</td> </tr> <tr>
<td>&lt; 0.0</td> <td>finite, nonintegral</td> <td><span class="red">NAN</span></td> <td>no</td> <td>yes</td>
</tr> <tr>
<td>±0.0</td> <td>odd integer &lt; 0.0</td> <td>±∞</td> <td>yes</td> <td>no</td> </tr> <tr>
<td>±0.0</td> <td>&lt; 0.0, not odd integer</td> <td>+∞</td> <td>yes</td> <td>no</td>
</tr> <tr>
<td>±0.0</td> <td>odd integer &gt; 0.0</td> <td>±0.0</td> <td>no</td> <td>no</td> </tr> <tr>
<td>±0.0</td> <td>&gt; 0.0, not odd integer</td> <td>+0.0</td> <td>no</td> <td>no</td> </tr> </table></p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(pow(1.0, 2.0)); // 1.0
writeln(pow(0.0, 0.0)); // 1.0
assert(pow(1.5, 10.0).feqrel(57.665) &gt; 16);

// special values
writeln(pow(1.5, real.infinity)); // real.infinity
writeln(pow(0.5, real.infinity)); // 0.0
writeln(pow(1.5, -real.infinity)); // 0.0
writeln(pow(0.5, -real.infinity)); // real.infinity
writeln(pow(real.infinity, 1.0)); // real.infinity
writeln(pow(real.infinity, -1.0)); // 0.0
writeln(pow(-real.infinity, 1.0)); // -real.infinity
writeln(pow(-real.infinity, 2.0)); // real.infinity
writeln(pow(-real.infinity, -1.0)); // -0.0
writeln(pow(-real.infinity, -2.0)); // 0.0
assert(pow(1.0, real.infinity) is -real.nan);
writeln(pow(0.0, -1.0)); // real.infinity
writeln(pow(real.nan, 0.0)); // 1.0
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="powmod">Unqual!(Largest!(F, H)) <strong id="powmod">powmod</strong>(F, G, H)(F x, G n, H m)<br><small>  Constraints: if (isUnsigned!F &amp;&amp; isUnsigned!G &amp;&amp; isUnsigned!H); </small>
</dt> <dd>
<p>Computes the value of a positive integer <code>x</code>, raised to the power <code>n</code>, modulo <code>m</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>F <code>x</code>
</td> <td>base</td>
</tr> <tr>
<td>G <code>n</code>
</td> <td>exponent</td>
</tr> <tr>
<td>H <code>m</code>
</td> <td>modulus</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>x</code> to the power <code>n</code>, modulo <code>m</code>. The return type is the largest of <code>x</code>'s and <code>m</code>'s type.  The function requires that all values have unsigned types.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(powmod(1U, 10U, 3U)); // 1
writeln(powmod(3U, 2U, 6U)); // 3
writeln(powmod(5U, 5U, 15U)); // 5
writeln(powmod(2U, 3U, 5U)); // 3
writeln(powmod(2U, 4U, 5U)); // 1
writeln(powmod(2U, 5U, 5U)); // 2
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="feqrel">pure nothrow @nogc @trusted int <strong id="feqrel">feqrel</strong>(X)(const X x, const X y)<br><small>  Constraints: if (isFloatingPoint!X); </small>
</dt> <dd>
<p>To what precision is x equal to y? </p>
<dl>
<dt>Returns:</dt>
<dd>the number of mantissa bits which are equal in x and y. eg, 0x1.F8p+60 and 0x1.F1p+60 are equal to 5 bits of precision.  <table> <caption>Special Values</caption> <tr>
<th scope="col">x</th> <th scope="col">y</th> <th scope="col">feqrel(x, y)</th>
</tr> <tr>
<td>x</td> <td>x</td> <td>real.mant_dig</td>
</tr> <tr>
<td>x</td> <td>&gt;= 2*x</td> <td>0</td>
</tr> <tr>
<td>x</td> <td>&lt;= x/2</td> <td>0</td>
</tr> <tr>
<td><span class="red">NAN</span></td> <td>any</td> <td>0</td>
</tr> <tr>
<td>any</td> <td><span class="red">NAN</span></td> <td>0</td>
</tr> </table>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(feqrel(2.0, 2.0)); // 53
writeln(feqrel(2.0f, 2.0f)); // 24
writeln(feqrel(2.0, double.nan)); // 0

// Test that numbers are within n digits of each
// other by testing if feqrel &gt; n * log2(10)

// five digits
assert(feqrel(2.0, 2.00001) &gt; 16);
// ten digits
assert(feqrel(2.0, 2.00000000001) &gt; 33);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="poly">pure nothrow @nogc @trusted Unqual!(CommonType!(T1, T2)) <strong id="poly">poly</strong>(T1, T2)(T1 x, in T2[] A)<br><small>  Constraints: if (isFloatingPoint!T1 &amp;&amp; isFloatingPoint!T2); </small><br><br>pure nothrow @nogc @safe Unqual!(CommonType!(T1, T2)) <strong id="poly">poly</strong>(T1, T2, int N)(T1 x, ref const T2[N] A)<br><small>  Constraints: if (isFloatingPoint!T1 &amp;&amp; isFloatingPoint!T2 &amp;&amp; (N &gt; 0) &amp;&amp; (N &lt;= 10)); </small>
</dt> <dd>
<p>Evaluate polynomial A(x) = a<sub>0</sub> + a<sub>1</sub>x + a<sub>2</sub>x<sup>2</sup> + a<sub>3</sub>x<sup>3</sup>; ... </p>
<p>Uses Horner's rule A(x) = a<sub>0</sub> + x(a<sub>1</sub> + x(a<sub>2</sub> + x(a<sub>3</sub> + ...))) </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T1 <code>x</code>
</td> <td>the value to evaluate.</td>
</tr> <tr>
<td>T2[] <code>A</code>
</td> <td>array of coefficients a<sub>0</sub>, a<sub>1</sub>, etc.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">real x = 3.1L;
static real[] pp = [56.1L, 32.7L, 6];

writeln(poly(x, pp)); // (56.1L + (32.7L + 6.0L * x) * x)
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="approxEqual">bool <strong id="approxEqual">approxEqual</strong>(T, U, V)(T value, U reference, V maxRelDiff = 0.01, V maxAbsDiff = 1e-05); </dt> <dd>
<p>Computes whether a values is approximately equal to a reference value, admitting a maximum relative difference, and a maximum absolute difference. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T <code>value</code>
</td> <td>Value to compare.</td>
</tr> <tr>
<td>U <code>reference</code>
</td> <td>Reference value.</td>
</tr> <tr>
<td>V <code>maxRelDiff</code>
</td> <td>Maximum allowable difference relative to <code>reference</code>. Setting to 0.0 disables this check. Defaults to <code>1e-2</code>.</td>
</tr> <tr>
<td>V <code>maxAbsDiff</code>
</td> <td>Maximum absolute difference. This is mainly usefull for comparing values to zero. Setting to 0.0 disables this check. Defaults to <code>1e-5</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if <code>value</code> is approximately equal to <code>reference</code> under either criterium. It is sufficient, when <code>value </code> satisfies one of the two criteria.  If one item is a range, and the other is a single value, then the result is the logical and-ing of calling <code>approxEqual</code> on each element of the ranged item against the single item. If both items are ranges, then <code>approxEqual</code> returns <code>true</code> if and only if the ranges have the same number of elements and if <code>approxEqual</code> evaluates to <code>true</code> for each pair of elements. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>Use <a href="#feqrel"><code>feqrel</code></a> to get the number of equal bits in the mantissa.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(approxEqual(1.0, 1.0099));
assert(!approxEqual(1.0, 1.011));
assert(approxEqual(0.00001, 0.0));
assert(!approxEqual(0.00002, 0.0));

assert(approxEqual(3.0, [3, 3.01, 2.99])); // several reference values is strange
assert(approxEqual([3, 3.01, 2.99], 3.0)); // better

float[] arr1 = [ 1.0, 2.0, 3.0 ];
double[] arr2 = [ 1.001, 1.999, 3 ];
assert(approxEqual(arr1, arr2));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">// relative comparison depends on reference, make sure proper
// side is used when comparing range to single value. Based on
// https://issues.dlang.org/show_bug.cgi?id=15763
auto a = [2e-3 - 1e-5];
auto b = 2e-3 + 1e-5;
assert(a[0].approxEqual(b));
assert(!b.approxEqual(a[0]));
assert(a.approxEqual(b));
assert(!b.approxEqual(a));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(!approxEqual(0.0,1e-15,1e-9,0.0));
assert(approxEqual(0.0,1e-15,1e-9,1e-9));
assert(!approxEqual(1.0,3.0,0.0,1.0));

assert(approxEqual(1.00000000099,1.0,1e-9,0.0));
assert(!approxEqual(1.0000000011,1.0,1e-9,0.0));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">// maybe unintuitive behavior
assert(approxEqual(1000.0,1010.0));
assert(approxEqual(9_090_000_000.0,9_000_000_000.0));
assert(approxEqual(0.0,1e30,1.0));
assert(approxEqual(0.00001,1e-30));
assert(!approxEqual(-1e-30,1e-30,1e-2,0.0));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isClose">bool <strong id="isClose">isClose</strong>(T, U, V = CommonType!(FloatingPointBaseType!T, FloatingPointBaseType!U))(T lhs, U rhs, V maxRelDiff = CommonDefaultFor!(T, U), V maxAbsDiff = 0.0); </dt> <dd>
<p>Computes whether two values are approximately equal, admitting a maximum relative difference, and a maximum absolute difference. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T <code>lhs</code>
</td> <td>First item to compare.</td>
</tr> <tr>
<td>U <code>rhs</code>
</td> <td>Second item to compare.</td>
</tr> <tr>
<td>V <code>maxRelDiff</code>
</td> <td>Maximum allowable relative difference. Setting to 0.0 disables this check. Default depends on the type of <code>lhs</code> and <code>rhs</code>: It is approximately half the number of decimal digits of precision of the smaller type.</td>
</tr> <tr>
<td>V <code>maxAbsDiff</code>
</td> <td>Maximum absolute difference. This is mainly usefull for comparing values to zero. Setting to 0.0 disables this check. Defaults to <code>0.0</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if the two items are approximately equal under either criterium. It is sufficient, when <code>value </code> satisfies one of the two criteria.  If one item is a range, and the other is a single value, then the result is the logical and-ing of calling <code>isClose</code> on each element of the ranged item against the single item. If both items are ranges, then <code>isClose</code> returns <code>true</code> if and only if the ranges have the same number of elements and if <code>isClose</code> evaluates to <code>true</code> for each pair of elements. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>Use <a href="#feqrel"><code>feqrel</code></a> to get the number of equal bits in the mantissa.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(isClose(1.0,0.999_999_999));
assert(isClose(0.001, 0.000_999_999_999));
assert(isClose(1_000_000_000.0,999_999_999.0));

assert(isClose(17.123_456_789, 17.123_456_78));
assert(!isClose(17.123_456_789, 17.123_45));

// use explicit 3rd parameter for less (or more) accuracy
assert(isClose(17.123_456_789, 17.123_45, 1e-6));
assert(!isClose(17.123_456_789, 17.123_45, 1e-7));

// use 4th parameter when comparing close to zero
assert(!isClose(1e-100, 0.0));
assert(isClose(1e-100, 0.0, 0.0, 1e-90));
assert(!isClose(1e-10, -1e-10));
assert(isClose(1e-10, -1e-10, 0.0, 1e-9));
assert(!isClose(1e-300, 1e-298));
assert(isClose(1e-300, 1e-298, 0.0, 1e-200));

// different default limits for different floating point types
assert(isClose(1.0f, 0.999_99f));
assert(!isClose(1.0, 0.999_99));
static if (real.sizeof &gt; double.sizeof)
    assert(!isClose(1.0L, 0.999_999_999L));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(isClose([1.0, 2.0, 3.0], [0.999_999_999, 2.000_000_001, 3.0]));
assert(!isClose([1.0, 2.0], [0.999_999_999, 2.000_000_001, 3.0]));
assert(!isClose([1.0, 2.0, 3.0], [0.999_999_999, 2.000_000_001]));

assert(isClose([2.0, 1.999_999_999, 2.000_000_001], 2.0));
assert(isClose(2.0, [2.0, 1.999_999_999, 2.000_000_001]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="cmp">pure nothrow @nogc @trusted int <strong id="cmp">cmp</strong>(T)(const(T) x, const(T) y)<br><small>  Constraints: if (isFloatingPoint!T); </small>
</dt> <dd>
<p>Defines a total order on all floating-point numbers. </p>
<p>The order is defined as follows: <ul> <li>All numbers in [-∞, +∞] are ordered the same way as by built-in comparison, with the exception of -0.0, which is less than +0.0;</li> <li>If the sign bit is set (that is, it's 'negative'), <span class="red">NAN</span> is less than any number; if the sign bit is not set (it is 'positive'), <span class="red">NAN</span> is greater than any number;</li> <li>
<span class="red">NAN</span>s of the same sign are ordered by the payload ('negative' ones - in reverse order).</li> </ul> </p> <dl>
<dt>Returns:</dt>
<dd>negative value if <code>x</code> precedes <code>y</code> in the order specified above; 0 if <code>x</code> and <code>y</code> are identical, and positive value otherwise. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="#isIdentical"><em class="tt">isIdentical</em></a> </dd>
</dl> <dl>
<dt>Standards:</dt>
<dd>Conforms to IEEE 754-2008</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Most numbers are ordered naturally. <pre data-language="d">assert(cmp(-double.infinity, -double.max) &lt; 0);
assert(cmp(-double.max, -100.0) &lt; 0);
assert(cmp(-100.0, -0.5) &lt; 0);
assert(cmp(-0.5, 0.0) &lt; 0);
assert(cmp(0.0, 0.5) &lt; 0);
assert(cmp(0.5, 100.0) &lt; 0);
assert(cmp(100.0, double.max) &lt; 0);
assert(cmp(double.max, double.infinity) &lt; 0);

writeln(cmp(1.0, 1.0)); // 0
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Positive and negative zeroes are distinct. <pre data-language="d">assert(cmp(-0.0, +0.0) &lt; 0);
assert(cmp(+0.0, -0.0) &gt; 0);
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Depending on the sign, <span class="red">NAN</span>s go to either end of the spectrum. <pre data-language="d">assert(cmp(-double.nan, -double.infinity) &lt; 0);
assert(cmp(double.infinity, double.nan) &lt; 0);
assert(cmp(-double.nan, double.nan) &lt; 0);
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<span class="red">NAN</span>s of the same sign are ordered by the payload. <pre data-language="d">assert(cmp(NaN(10), NaN(20)) &lt; 0);
assert(cmp(-NaN(20), -NaN(10)) &lt; 0);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="nextPow2">T <strong id="nextPow2">nextPow2</strong>(T)(const T val)<br><small>  Constraints: if (isIntegral!T); </small><br><br>T <strong id="nextPow2">nextPow2</strong>(T)(const T val)<br><small>  Constraints: if (isFloatingPoint!T); </small>
</dt> <dd>
<p>Gives the next power of two after <code>val</code>. <code>T</code> can be any built-in numerical type. </p>
<p>If the operation would lead to an over/underflow, this function will return <code>0</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T <code>val</code>
</td> <td>any number</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>the next power of two after <code>val</code>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(nextPow2(2)); // 4
writeln(nextPow2(10)); // 16
writeln(nextPow2(4000)); // 4096

writeln(nextPow2(-2)); // -4
writeln(nextPow2(-10)); // -16

writeln(nextPow2(uint.max)); // 0
writeln(nextPow2(uint.min)); // 0
writeln(nextPow2(size_t.max)); // 0
writeln(nextPow2(size_t.min)); // 0

writeln(nextPow2(int.max)); // 0
writeln(nextPow2(int.min)); // 0
writeln(nextPow2(long.max)); // 0
writeln(nextPow2(long.min)); // 0
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(nextPow2(2.1)); // 4.0
writeln(nextPow2(-2.0)); // -4.0
writeln(nextPow2(0.25)); // 0.5
writeln(nextPow2(-4.0)); // -8.0

writeln(nextPow2(double.max)); // 0.0
writeln(nextPow2(double.infinity)); // double.infinity
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="truncPow2">T <strong id="truncPow2">truncPow2</strong>(T)(const T val)<br><small>  Constraints: if (isIntegral!T); </small><br><br>T <strong id="truncPow2">truncPow2</strong>(T)(const T val)<br><small>  Constraints: if (isFloatingPoint!T); </small>
</dt> <dd>
<p>Gives the last power of two before <code>val</code>. &lt;&gt;&gt; can be any built-in numerical type. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T <code>val</code>
</td> <td>any number</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>the last power of two before <code>val</code>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(truncPow2(3)); // 2
writeln(truncPow2(4)); // 4
writeln(truncPow2(10)); // 8
writeln(truncPow2(4000)); // 2048

writeln(truncPow2(-5)); // -4
writeln(truncPow2(-20)); // -16

writeln(truncPow2(uint.max)); // int.max + 1
writeln(truncPow2(uint.min)); // 0
writeln(truncPow2(ulong.max)); // long.max + 1
writeln(truncPow2(ulong.min)); // 0

writeln(truncPow2(int.max)); // (int.max / 2) + 1
writeln(truncPow2(int.min)); // int.min
writeln(truncPow2(long.max)); // (long.max / 2) + 1
writeln(truncPow2(long.min)); // long.min
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(truncPow2(2.1)); // 2.0
writeln(truncPow2(7.0)); // 4.0
writeln(truncPow2(-1.9)); // -1.0
writeln(truncPow2(0.24)); // 0.125
writeln(truncPow2(-7.0)); // -4.0

writeln(truncPow2(double.infinity)); // double.infinity
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isPowerOf2">pure nothrow @nogc @safe bool <strong id="isPowerOf2">isPowerOf2</strong>(X)(const X x)<br><small>  Constraints: if (isNumeric!X); </small>
</dt> <dd>
<p>Check whether a number is an integer power of two. </p>
<p>Note that only positive numbers can be integer powers of two. This function always return <code>false</code> if <code>x</code> is negative or zero. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>X <code>x</code>
</td> <td>the number to test</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if <code>x</code> is an integer power of two.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert( isPowerOf2(1.0L));
assert( isPowerOf2(2.0L));
assert( isPowerOf2(0.5L));
assert( isPowerOf2(pow(2.0L, 96)));
assert( isPowerOf2(pow(2.0L, -77)));

assert(!isPowerOf2(-2.0L));
assert(!isPowerOf2(-0.5L));
assert(!isPowerOf2(0.0L));
assert(!isPowerOf2(4.315));
assert(!isPowerOf2(1.0L / 3.0L));

assert(!isPowerOf2(real.nan));
assert(!isPowerOf2(real.infinity));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert( isPowerOf2(1));
assert( isPowerOf2(2));
assert( isPowerOf2(1uL &lt;&lt; 63));

assert(!isPowerOf2(-4));
assert(!isPowerOf2(0));
assert(!isPowerOf2(1337u));
</pre> </dd>
</dl> </dd> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1999&ndash;2021 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/std_math.html" class="_attribution-link">https://dlang.org/phobos/std_math.html</a>
  </p>
</div>
