<h1>rt.lifetime</h1>  <p>This module contains all functions related to an object's lifetime: allocation, resizing, deallocation, and finalization. </p>
<dl>
<dt>License:</dt>
<dd>Distributed under the <a href="http://www.boost.org/LICENSE_1_0.txt">Boost Software License 1.0</a>. (See accompanying file LICENSE) </dd>
</dl> <dl>
<dt>Authors:</dt>
<dd>Walter Bright, Sean Kelly, Steven Schveighoffer </dd>
</dl> <dl>
<dt>Source</dt>
<dd> <a href="https://github.com/dlang/druntime/blob/master/src/rt/lifetime.d">rt/lifetime.d</a>
</dd>
</dl> <dl>
<dt class="d_decl" id="_d_allocmemory">void* <strong id="_d_allocmemory">_d_allocmemory</strong>(size_t sz); </dt>  <dt class="d_decl" id="_d_newclass">Object <strong id="_d_newclass">_d_newclass</strong>(const ClassInfo ci); </dt>  <dt class="d_decl" id="_d_delinterface">void <strong id="_d_delinterface">_d_delinterface</strong>(void** p); </dt>  <dt class="d_decl" id="_d_delclass">void <strong id="_d_delclass">_d_delclass</strong>(Object* p); </dt>  <dt class="d_decl" id="_d_delstruct">void <strong id="_d_delstruct">_d_delstruct</strong>(void** p, TypeInfo_Struct inf); </dt> <dd>
<p>This is called for a delete statement where the value being deleted is a pointer to a struct with a destructor but doesn't have an overloaded delete operator.</p> </dd> <dt class="d_decl" id="__setArrayAllocLength">pure nothrow bool <strong id="__setArrayAllocLength">__setArrayAllocLength</strong>(ref BlkInfo info, size_t newlength, bool isshared, const TypeInfo tinext, size_t oldlength = ~0); </dt> <dd>
<p>Set the allocated length of the array block. This is called any time an array is appended to or its length is set. </p>
<p>The allocated block looks like this for blocks &lt; PAGESIZE: <br><br> |elem0|elem1|elem2|...|elemN-1|emptyspace|N*elemsize| <br><br> <br><br> The size of the allocated length at the end depends on the block size: <br><br> a block of 16 to 256 bytes has an 8-bit length. <br><br> a block with 512 to pagesize/2 bytes has a 16-bit length. <br><br> For blocks &gt;= pagesize, the length is a size_t and is at the beginning of the block. The reason we have to do this is because the block can extend into more pages, so we cannot trust the block length if it sits at the end of the block, because it might have just been extended. If we can prove in the future that the block is unshared, we may be able to change this, but I'm not sure it's important. <br><br> In order to do put the length at the front, we have to provide 16 bytes buffer space in case the block has to be aligned properly. In x86, certain SSE instructions will only work if the data is 16-byte aligned. In addition, we need the sentinel byte to prevent accidental pointers to the next block. Because of the extra overhead, we only do this for page size and above, where the overhead is minimal compared to the block size. <br><br> So for those blocks, it looks like: <br><br> |N*elemsize|padding|elem0|elem1|...|elemN-1|emptyspace|sentinelbyte| <br><br> where elem0 starts 16 bytes after the first byte.</p> </dd> <dt class="d_decl" id="__arrayAllocLength">pure nothrow size_t <strong id="__arrayAllocLength">__arrayAllocLength</strong>(ref BlkInfo info, const TypeInfo tinext); </dt> <dd>
<p>get the allocation size of the array for the given block (without padding or type info)</p> </dd> <dt class="d_decl" id="__arrayStart">pure nothrow void* <strong id="__arrayStart">__arrayStart</strong>(return BlkInfo info); </dt> <dd>
<p>get the start of the array for the given block</p> </dd> <dt class="d_decl" id="__arrayPad">pure nothrow @trusted size_t <strong id="__arrayPad">__arrayPad</strong>(size_t size, const TypeInfo tinext); </dt> <dd>
<p>get the padding required to allocate size bytes. Note that the padding is NOT included in the passed in size. Therefore, do NOT call this function with the size of an allocated block.</p> </dd> <dt class="d_decl" id="__arrayAlloc">pure nothrow BlkInfo <strong id="__arrayAlloc">__arrayAlloc</strong>(size_t arrsize, const TypeInfo ti, const TypeInfo tinext); </dt> <dd>
<p>allocate an array memory block by applying the proper padding and assigning block attributes if not inherited from the existing block</p> </dd> <dt class="d_decl" id="N_CACHE_BLOCKS">enum int <strong id="N_CACHE_BLOCKS">N_CACHE_BLOCKS</strong>; </dt> <dd>
<p>cache for the lookup of the block info</p> </dd> <dt class="d_decl" id="__getBlkInfo">nothrow BlkInfo* <strong id="__getBlkInfo">__getBlkInfo</strong>(void* interior); </dt> <dd>
<p>Get the cached block info of an interior pointer. Returns null if the interior pointer's block is not cached. </p>
<dl>
<dt>NOTE</dt>
<dd> The base ptr in this struct can be cleared asynchronously by the GC, so any use of the returned BlkInfo should copy it and then check the base ptr of the copy before actually using it. </dd>
</dl> <dl>
<dt>TODO</dt>
<dd> Change this function so the caller doesn't have to be aware of this issue. Either return by value and expect the caller to always check the base ptr as an indication of whether the struct is valid, or set the BlkInfo as a side-effect and return a bool to indicate success.</dd>
</dl> </dd> <dt class="d_decl" id="_d_arrayshrinkfit">void <strong id="_d_arrayshrinkfit">_d_arrayshrinkfit</strong>(const TypeInfo ti, void[] arr); </dt> <dd>
<p>Shrink the "allocated" length of an array to be the exact size of the array. It doesn't matter what the current allocated length of the array is, the user is telling the runtime that he knows what he is doing.</p> </dd> <dt class="d_decl" id="_d_arraysetcapacity">size_t <strong id="_d_arraysetcapacity">_d_arraysetcapacity</strong>(const TypeInfo ti, size_t newcapacity, void[]* p); </dt> <dd>
<p>set the array capacity. If the array capacity isn't currently large enough to hold the requested capacity (in number of elements), then the array is resized/reallocated to the appropriate size. Pass in a requested capacity of 0 to get the current capacity. Returns the number of elements that can actually be stored once the resizing is done.</p> </dd> <dt class="d_decl" id="_d_newarrayU">pure nothrow void[] <strong id="_d_newarrayU">_d_newarrayU</strong>(const TypeInfo ti, size_t length); </dt> <dd>
<p>Allocate a new uninitialized array of length elements. ti is the type of the resulting array, or pointer to element.</p> </dd> <dt class="d_decl" id="_d_newarrayT">pure nothrow void[] <strong id="_d_newarrayT">_d_newarrayT</strong>(const TypeInfo ti, size_t length); </dt> <dd>
<p>Allocate a new array of length elements. ti is the type of the resulting array, or pointer to element. (For when the array is initialized to 0)</p> </dd> <dt class="d_decl" id="_d_newarrayiT">pure nothrow void[] <strong id="_d_newarrayiT">_d_newarrayiT</strong>(const TypeInfo ti, size_t length); </dt> <dd>
<p>For when the array has a non-zero initializer.</p> </dd> <dt class="d_decl" id="_d_newarrayOpT">void[] <strong id="_d_newarrayOpT">_d_newarrayOpT</strong>(alias op)(const TypeInfo ti, size_t[] dims); </dt>  <dt class="d_decl" id="_d_newarraymTX">void[] <strong id="_d_newarraymTX">_d_newarraymTX</strong>(const TypeInfo ti, size_t[] dims); </dt>  <dt class="d_decl" id="_d_newarraymiTX">void[] <strong id="_d_newarraymiTX">_d_newarraymiTX</strong>(const TypeInfo ti, size_t[] dims); </dt>  <dt class="d_decl" id="_d_newitemU">void* <strong id="_d_newitemU">_d_newitemU</strong>(in TypeInfo _ti); </dt> <dd>
<p>Allocate an uninitialized non-array item. This is an optimization to avoid things needed for arrays like the _arrayPad(size).</p> </dd> <dt class="d_decl" id="_d_newitemT">void* <strong id="_d_newitemT">_d_newitemT</strong>(in TypeInfo _ti); </dt> <dd>
<p>Same as above, zero initializes the item.</p> </dd> <dt class="d_decl" id="_d_newitemiT">void* <strong id="_d_newitemiT">_d_newitemiT</strong>(in TypeInfo _ti); </dt> <dd>
<p>Same as above, for item with non-zero initializer.</p> </dd> <dt class="d_decl" id="Array">struct <strong id="Array">Array</strong>; </dt>  <dt class="d_decl" id="_d_delarray_t">void <strong id="_d_delarray_t">_d_delarray_t</strong>(void[]* p, const TypeInfo_Struct ti); </dt>  <dt class="d_decl" id="_d_delmemory">void <strong id="_d_delmemory">_d_delmemory</strong>(void** p); </dt>  <dt class="d_decl" id="_d_callinterfacefinalizer">void <strong id="_d_callinterfacefinalizer">_d_callinterfacefinalizer</strong>(void* p); </dt>  <dt class="d_decl" id="_d_callfinalizer">void <strong id="_d_callfinalizer">_d_callfinalizer</strong>(void* p); </dt>  <dt class="d_decl" id="rt_setCollectHandler">void <strong id="rt_setCollectHandler">rt_setCollectHandler</strong>(CollectHandler h); </dt>  <dt class="d_decl" id="rt_getCollectHandler">CollectHandler <strong id="rt_getCollectHandler">rt_getCollectHandler</strong>(); </dt>  <dt class="d_decl" id="rt_hasFinalizerInSegment">nothrow int <strong id="rt_hasFinalizerInSegment">rt_hasFinalizerInSegment</strong>(void* p, size_t size, uint attr, in void[] segment); </dt>  <dt class="d_decl" id="rt_finalize2">nothrow void <strong id="rt_finalize2">rt_finalize2</strong>(void* p, bool det = true, bool resetMemory = true); </dt>  <dt class="d_decl" id="_d_arraysetlengthT">void[] <strong id="_d_arraysetlengthT">_d_arraysetlengthT</strong>(const TypeInfo ti, size_t newlength, void[]* p); </dt> <dd>
<p>Resize dynamic arrays with 0 initializers.</p> </dd> <dt class="d_decl" id="_d_arraysetlengthiT">void[] <strong id="_d_arraysetlengthiT">_d_arraysetlengthiT</strong>(const TypeInfo ti, size_t newlength, void[]* p); </dt> <dd>
<p>Resize arrays for non-zero initializers. p pointer to array lvalue to be updated newlength new .length property of array sizeelem size of each element of array initsize size of initializer ... initializer</p> </dd> <dt class="d_decl" id="_d_arrayappendT">void[] <strong id="_d_arrayappendT">_d_arrayappendT</strong>(const TypeInfo ti, ref byte[] x, byte[] y); </dt> <dd>
<p>Append y[] to array x[]</p> </dd> <dt class="d_decl" id="newCapacity">size_t <strong id="newCapacity">newCapacity</strong>(size_t newlength, size_t size); </dt>  <dt class="d_decl" id="_d_arrayappendcTX">byte[] <strong id="_d_arrayappendcTX">_d_arrayappendcTX</strong>(const TypeInfo ti, ref byte[] px, size_t n); </dt> <dd>
<p>Extend an array by n elements. Caller must initialize those elements.</p> </dd> <dt class="d_decl" id="_d_arrayappendcd">void[] <strong id="_d_arrayappendcd">_d_arrayappendcd</strong>(ref byte[] x, dchar c); </dt> <dd>
<p>Append dchar to char[]</p> </dd> <dt class="d_decl" id="_d_arrayappendwd">void[] <strong id="_d_arrayappendwd">_d_arrayappendwd</strong>(ref byte[] x, dchar c); </dt> <dd>
<p>Append dchar to wchar[]</p> </dd> <dt class="d_decl" id="_d_arraycatT">byte[] <strong id="_d_arraycatT">_d_arraycatT</strong>(const TypeInfo ti, byte[] x, byte[] y); </dt>  <dt class="d_decl" id="_d_arraycatnTX">void[] <strong id="_d_arraycatnTX">_d_arraycatnTX</strong>(const TypeInfo ti, byte[][] arrs); </dt>  <dt class="d_decl" id="_d_arrayliteralTX">void* <strong id="_d_arrayliteralTX">_d_arrayliteralTX</strong>(const TypeInfo ti, size_t length); </dt> <dd>
<p>Allocate the array, rely on the caller to do the initialization of the array.</p> </dd> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1999&ndash;2021 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/rt_lifetime.html" class="_attribution-link">https://dlang.org/phobos/rt_lifetime.html</a>
  </p>
</div>
