<h1>std.string</h1>  <p>String handling functions. </p>
<table>

<tr>
<th scope="col">Category</th> <th scope="col">Functions</th> </tr> <tr>
<td>Searching</td> <td> <a href="#column"><em class="tt">column</em></a> <a href="#indexOf"><em class="tt">indexOf</em></a> <a href="#indexOfAny"><em class="tt">indexOfAny</em></a> <a href="#indexOfNeither"><em class="tt">indexOfNeither</em></a> <a href="#lastIndexOf"><em class="tt">lastIndexOf</em></a> <a href="#lastIndexOfAny"><em class="tt">lastIndexOfAny</em></a> <a href="#lastIndexOfNeither"><em class="tt">lastIndexOfNeither</em></a> </td> </tr> <tr>
<td>Comparison</td> <td> <a href="#isNumeric"><em class="tt">isNumeric</em></a> </td> </tr> <tr>
<td>Mutation</td> <td> <a href="#capitalize"><em class="tt">capitalize</em></a> </td> </tr> <tr>
<td>Pruning and Filling</td> <td> <a href="#center"><em class="tt">center</em></a> <a href="#chomp"><em class="tt">chomp</em></a> <a href="#chompPrefix"><em class="tt">chompPrefix</em></a> <a href="#chop"><em class="tt">chop</em></a> <a href="#detabber"><em class="tt">detabber</em></a> <a href="#detab"><em class="tt">detab</em></a> <a href="#entab"><em class="tt">entab</em></a> <a href="#entabber"><em class="tt">entabber</em></a> <a href="#leftJustify"><em class="tt">leftJustify</em></a> <a href="#outdent"><em class="tt">outdent</em></a> <a href="#rightJustify"><em class="tt">rightJustify</em></a> <a href="#strip"><em class="tt">strip</em></a> <a href="#stripLeft"><em class="tt">stripLeft</em></a> <a href="#stripRight"><em class="tt">stripRight</em></a> <a href="#wrap"><em class="tt">wrap</em></a> </td> </tr> <tr>
<td>Substitution</td> <td> <a href="#abbrev"><em class="tt">abbrev</em></a> <a href="#soundex"><em class="tt">soundex</em></a> <a href="#soundexer"><em class="tt">soundexer</em></a> <a href="#succ"><em class="tt">succ</em></a> <a href="#tr"><em class="tt">tr</em></a> <a href="#translate"><em class="tt">translate</em></a> </td> </tr> <tr>
<td>Miscellaneous</td> <td> <a href="#assumeUTF"><em class="tt">assumeUTF</em></a> <a href="#fromStringz"><em class="tt">fromStringz</em></a> <a href="#lineSplitter"><em class="tt">lineSplitter</em></a> <a href="#representation"><em class="tt">representation</em></a> <a href="#splitLines"><em class="tt">splitLines</em></a> <a href="#toStringz"><em class="tt">toStringz</em></a> </td> </tr>
</table>
<p>    Objects of types <code>string</code>, <code>wstring</code>, and <code>dstring</code> are value types and cannot be mutated element-by-element. For using mutation during building strings, use <code>char[]</code>, <code>wchar[]</code>, or <code>dchar[]</code>. The <code>xxxstring</code> types are preferable because they don't exhibit undesired aliasing, thus making code more robust. <br><br> The following functions are publicly imported: <br><br> <table>

<tr>
<th scope="col">Module</th> <th scope="col">Functions</th> </tr> <tr><td colspan="2"><em> Publicly imported functions</em></td></tr> <tr>
<td>std.algorithm</td> <td> <a href="std_algorithm_comparison.html#cmp"><code>cmp</code></a> <a href="std_algorithm_searching.html#count"><code>count</code></a> <a href="std_algorithm_searching.html#endsWith"><code>endsWith</code></a> <a href="std_algorithm_searching.html#startsWith"><code>startsWith</code></a> </td>
</tr> <tr>
<td>std.array</td> <td> <a href="std_array.html#join"><code>join</code></a> <a href="std_array.html#replace"><code>replace</code></a> <a href="std_array.html#replaceInPlace"><code>replaceInPlace</code></a> <a href="std_array.html#split"><code>split</code></a> <a href="std_array.html#empty"><code>empty</code></a> </td>
</tr> <tr>
<td>std.format</td> <td> <a href="std_format.html#format"><code>format</code></a> <a href="std_format.html#sformat"><code>sformat</code></a> </td>
</tr> <tr>
<td>std.uni</td> <td> <a href="std_uni.html#icmp"><code>icmp</code></a> <a href="std_uni.html#toLower"><code>toLower</code></a> <a href="std_uni.html#toLowerInPlace"><code>toLowerInPlace</code></a> <a href="std_uni.html#toUpper"><code>toUpper</code></a> <a href="std_uni.html#toUpperInPlace"><code>toUpperInPlace</code></a> </td>
</tr> </table> <br><br> There is a rich set of functions for string handling defined in other modules. Functions related to Unicode and ASCII are found in <a href="std_uni.html"><code>std.uni</code></a> and <a href="std_ascii.html"><code>std.ascii</code></a>, respectively. Other functions that have a wider generality than just strings can be found in <a href="std_algorithm.html"><code>std.algorithm</code></a> and <a href="std_range.html"><code>std.range</code></a>. </p> <dl>
<dt>See Also:</dt>
<dd>
<ul>
<li> <a href="std_algorithm.html"><code>std.algorithm</code></a> and <a href="std_range.html"><code>std.range</code></a> for generic range algorithms </li>
<li> <a href="std_ascii.html"><code>std.ascii</code></a> for functions that work with ASCII strings </li>
<li> <a href="std_uni.html"><code>std.uni</code></a> for functions that work with unicode strings </li>
</ul> </dd>
</dl> <dl>
<dt>License:</dt>
<dd>
<a href="http://boost.org/LICENSE_1_0.txt">Boost License 1.0</a>. </dd>
</dl> <dl>
<dt>Authors:</dt>
<dd>
<a href="http://digitalmars.com">Walter Bright</a>, <a href="http://erdani.org">Andrei Alexandrescu</a>, <a href="http://jmdavisprog.com">Jonathan M Davis</a>, and David L. 'SpottedTiger' Davis </dd>
</dl> <dl>
<dt>Source</dt>
<dd> <span class="phobos_src"><a class="https" href="https://github.com/dlang/phobos/blob/master/std/string.d">std/string.d</a></span>
</dd>
</dl> <dl>
<dt class="d_decl" id="StringException">class <strong id="StringException">StringException</strong>: object.Exception; </dt> <dd>
<p>Exception thrown on errors in std.string functions.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.exception : assertThrown;
auto bad = "      a\n\tb\n   c";
assertThrown!StringException(bad.outdent);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="fromStringz">pure nothrow @nogc @system inout(Char)[] <strong id="fromStringz">fromStringz</strong>(Char)(return scope inout(Char)* cString)<br><small>  Constraints: if (isSomeChar!Char); </small>
</dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>inout<span class="template_param_list" title="Template parameter list">(Char)</span>* <code>cString</code>
</td> <td>A null-terminated c-style string.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A D-style array of <code>char</code>, <code>wchar</code> or <code>dchar</code> referencing the same string. The returned array will retain the same type qualifiers as the input.  <span class="red">Important Note:</span> The returned array is a slice of the original buffer. The original data is not changed and not copied.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(fromStringz("foo\0"c.ptr)); // "foo"c
writeln(fromStringz("foo\0"w.ptr)); // "foo"w
writeln(fromStringz("foo\0"d.ptr)); // "foo"d

writeln(fromStringz("福\0"c.ptr)); // "福"c
writeln(fromStringz("福\0"w.ptr)); // "福"w
writeln(fromStringz("福\0"d.ptr)); // "福"d
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="toStringz">pure nothrow @trusted immutable(char)* <strong id="toStringz">toStringz</strong>(scope const(char)[] s); <br><br>pure nothrow @trusted immutable(char)* <strong id="toStringz">toStringz</strong>(return scope string s); </dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(char)[] <code>s</code>
</td> <td>A D-style string.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A C-style null-terminated string equivalent to <code>s</code>. <code>s</code> must not contain embedded <code>'\0'</code>'s as any C function will treat the first <code>'\0'</code> that it sees as the end of the string. If <code>s.empty</code> is <code>true</code>, then a string containing only <code>'\0'</code> is returned.  <span class="red">Important Note:</span> When passing a <code>char*</code> to a C function, and the C function keeps it around for any reason, make sure that you keep a reference to it in your D code. Otherwise, it may become invalid during a garbage collection cycle and cause a nasty bug when the C code tries to use it.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import core.stdc.string : strlen;
import std.conv : to;

auto p = toStringz("foo");
writeln(strlen(p)); // 3
const(char)[] foo = "abbzxyzzy";
p = toStringz(foo[3 .. 5]);
writeln(strlen(p)); // 2

string test = "";
p = toStringz(test);
writeln(*p); // 0

test = "\0";
p = toStringz(test);
writeln(*p); // 0

test = "foo\0";
p = toStringz(test);
assert(p[0] == 'f' &amp;&amp; p[1] == 'o' &amp;&amp; p[2] == 'o' &amp;&amp; p[3] == 0);

const string test2 = "";
p = toStringz(test2);
writeln(*p); // 0
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="CaseSensitive">alias <strong id="CaseSensitive">CaseSensitive</strong> = std.typecons.Flag!"caseSensitive".Flag; </dt> <dd>
<p>Flag indicating whether a search is case-sensitive.</p> </dd> <dt class="d_decl" id="indexOf">ptrdiff_t <strong id="indexOf">indexOf</strong>(Range)(Range s, dchar c, CaseSensitive cs = Yes.caseSensitive)<br><small>  Constraints: if (isInputRange!Range &amp;&amp; isSomeChar!(ElementType!Range) &amp;&amp; !isSomeString!Range); </small><br><br>ptrdiff_t <strong id="indexOf">indexOf</strong>(C)(scope const(C)[] s, dchar c, CaseSensitive cs = Yes.caseSensitive)<br><small>  Constraints: if (isSomeChar!C); </small><br><br>ptrdiff_t <strong id="indexOf">indexOf</strong>(Range)(Range s, dchar c, size_t startIdx, CaseSensitive cs = Yes.caseSensitive)<br><small>  Constraints: if (isInputRange!Range &amp;&amp; isSomeChar!(ElementType!Range) &amp;&amp; !isSomeString!Range); </small><br><br>ptrdiff_t <strong id="indexOf">indexOf</strong>(C)(scope const(C)[] s, dchar c, size_t startIdx, CaseSensitive cs = Yes.caseSensitive)<br><small>  Constraints: if (isSomeChar!C); </small>
</dt> <dd>
<p>Searches for character in range. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>s</code>
</td> <td>string or InputRange of characters to search in correct UTF format</td>
</tr> <tr>
<td>dchar <code>c</code>
</td> <td>character to search for</td>
</tr> <tr>
<td>size_t <code>startIdx</code>
</td> <td>starting index to a well-formed code point</td>
</tr> <tr>
<td>CaseSensitive <code>cs</code>
</td> <td>
<code>Yes.caseSensitive</code> or <code>No.caseSensitive</code>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>the index of the first occurrence of <code>c</code> in <code>s</code> with respect to the start index <code>startIdx</code>. If <code>c</code> is not found, then <code>-1</code> is returned. If <code>c</code> is found the value of the returned index is at least <code>startIdx</code>. If the parameters are not valid UTF, the result will still be in the range [-1 .. s.length], but will not be reliable otherwise. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>If the sequence starting at <code>startIdx</code> does not represent a well formed codepoint, then a <a href="std_utf.html#UTFException"><code>std.utf.UTFException</code></a> may be thrown. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd><a href="std_algorithm_searching.html#countUntil"><code>std.algorithm.searching.countUntil</code></a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.typecons : No;

string s = "Hello World";
writeln(indexOf(s, 'W')); // 6
writeln(indexOf(s, 'Z')); // -1
writeln(indexOf(s, 'w', No.caseSensitive)); // 6
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.typecons : No;

string s = "Hello World";
writeln(indexOf(s, 'W', 4)); // 6
writeln(indexOf(s, 'Z', 100)); // -1
writeln(indexOf(s, 'w', 3, No.caseSensitive)); // 6
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="indexOf.2">ptrdiff_t <strong id="indexOf">indexOf</strong>(Range, Char)(Range s, const(Char)[] sub)<br><small>  Constraints: if (isForwardRange!Range &amp;&amp; isSomeChar!(ElementEncodingType!Range) &amp;&amp; isSomeChar!Char); </small><br><br>ptrdiff_t <strong id="indexOf">indexOf</strong>(Range, Char)(Range s, const(Char)[] sub, in CaseSensitive cs)<br><small>  Constraints: if (isForwardRange!Range &amp;&amp; isSomeChar!(ElementEncodingType!Range) &amp;&amp; isSomeChar!Char); </small><br><br>@safe ptrdiff_t <strong id="indexOf">indexOf</strong>(Char1, Char2)(const(Char1)[] s, const(Char2)[] sub, in size_t startIdx)<br><small>  Constraints: if (isSomeChar!Char1 &amp;&amp; isSomeChar!Char2); </small><br><br>@safe ptrdiff_t <strong id="indexOf">indexOf</strong>(Char1, Char2)(const(Char1)[] s, const(Char2)[] sub, in size_t startIdx, in CaseSensitive cs)<br><small>  Constraints: if (isSomeChar!Char1 &amp;&amp; isSomeChar!Char2); </small>
</dt> <dd>
<p>Searches for substring in <code>s</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>s</code>
</td> <td>string or ForwardRange of characters to search in correct UTF format</td>
</tr> <tr>
<td>const(Char)[] <code>sub</code>
</td> <td>substring to search for</td>
</tr> <tr>
<td>size_t <code>startIdx</code>
</td> <td>the index into s to start searching from</td>
</tr> <tr>
<td>CaseSensitive <code>cs</code>
</td> <td>
<code>Yes.caseSensitive</code> (default) or <code>No.caseSensitive</code>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>the index of the first occurrence of <code>sub</code> in <code>s</code> with respect to the start index <code>startIdx</code>. If <code>sub</code> is not found, then <code>-1</code> is returned. If the arguments are not valid UTF, the result will still be in the range [-1 .. s.length], but will not be reliable otherwise. If <code>sub</code> is found the value of the returned index is at least <code>startIdx</code>. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>If the sequence starting at <code>startIdx</code> does not represent a well formed codepoint, then a <a href="std_utf.html#UTFException"><code>std.utf.UTFException</code></a> may be thrown. </dd>
</dl> <dl>
<dt>Bugs:</dt>
<dd>Does not work with case insensitive strings where the mapping of tolower and toupper is not 1:1.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.typecons : No;

string s = "Hello World";
writeln(indexOf(s, "Wo", 4)); // 6
writeln(indexOf(s, "Zo", 100)); // -1
writeln(indexOf(s, "wo", 3, No.caseSensitive)); // 6
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.typecons : No;

string s = "Hello World";
writeln(indexOf(s, "Wo")); // 6
writeln(indexOf(s, "Zo")); // -1
writeln(indexOf(s, "wO", No.caseSensitive)); // 6
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="lastIndexOf">pure @safe ptrdiff_t <strong id="lastIndexOf">lastIndexOf</strong>(Char)(const(Char)[] s, in dchar c, in CaseSensitive cs = Yes.caseSensitive)<br><small>  Constraints: if (isSomeChar!Char); </small><br><br>pure @safe ptrdiff_t <strong id="lastIndexOf">lastIndexOf</strong>(Char)(const(Char)[] s, in dchar c, in size_t startIdx, in CaseSensitive cs = Yes.caseSensitive)<br><small>  Constraints: if (isSomeChar!Char); </small>
</dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const<span class="template_param_list" title="Template parameter list">(Char)</span>[] <code>s</code>
</td> <td>string to search</td>
</tr> <tr>
<td>dchar <code>c</code>
</td> <td>character to search for</td>
</tr> <tr>
<td>size_t <code>startIdx</code>
</td> <td>the index into s to start searching from</td>
</tr> <tr>
<td>CaseSensitive <code>cs</code>
</td> <td>
<code>Yes.caseSensitive</code> or <code>No.caseSensitive</code>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The index of the last occurrence of <code>c</code> in <code>s</code>. If <code>c</code> is not found, then <code>-1</code> is returned. The <code>startIdx</code> slices <code>s</code> in the following way <code>s[0 .. startIdx]</code>. <code>startIdx</code> represents a codeunit index in <code>s</code>. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>If the sequence ending at <code>startIdx</code> does not represent a well formed codepoint, then a <a href="std_utf.html#UTFException"><code>std.utf.UTFException</code></a> may be thrown.  <code>cs</code> indicates whether the comparisons are case sensitive.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.typecons : No;

string s = "Hello World";
writeln(lastIndexOf(s, 'l')); // 9
writeln(lastIndexOf(s, 'Z')); // -1
writeln(lastIndexOf(s, 'L', No.caseSensitive)); // 9
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.typecons : No;

string s = "Hello World";
writeln(lastIndexOf(s, 'l', 4)); // 3
writeln(lastIndexOf(s, 'Z', 1337)); // -1
writeln(lastIndexOf(s, 'L', 7, No.caseSensitive)); // 3
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="lastIndexOf.2">pure @safe ptrdiff_t <strong id="lastIndexOf">lastIndexOf</strong>(Char1, Char2)(const(Char1)[] s, const(Char2)[] sub, in CaseSensitive cs = Yes.caseSensitive)<br><small>  Constraints: if (isSomeChar!Char1 &amp;&amp; isSomeChar!Char2); </small><br><br>pure @safe ptrdiff_t <strong id="lastIndexOf">lastIndexOf</strong>(Char1, Char2)(const(Char1)[] s, const(Char2)[] sub, in size_t startIdx, in CaseSensitive cs = Yes.caseSensitive)<br><small>  Constraints: if (isSomeChar!Char1 &amp;&amp; isSomeChar!Char2); </small>
</dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(Char1)[] <code>s</code>
</td> <td>string to search</td>
</tr> <tr>
<td>const(Char2)[] <code>sub</code>
</td> <td>substring to search for</td>
</tr> <tr>
<td>size_t <code>startIdx</code>
</td> <td>the index into s to start searching from</td>
</tr> <tr>
<td>CaseSensitive <code>cs</code>
</td> <td>
<code>Yes.caseSensitive</code> or <code>No.caseSensitive</code>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>the index of the last occurrence of <code>sub</code> in <code>s</code>. If <code>sub</code> is not found, then <code>-1</code> is returned. The <code>startIdx</code> slices <code>s</code> in the following way <code>s[0 .. startIdx]</code>. <code>startIdx</code> represents a codeunit index in <code>s</code>. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>If the sequence ending at <code>startIdx</code> does not represent a well formed codepoint, then a <a href="std_utf.html#UTFException"><code>std.utf.UTFException</code></a> may be thrown.  <code>cs</code> indicates whether the comparisons are case sensitive.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.typecons : No;

string s = "Hello World";
writeln(lastIndexOf(s, "ll")); // 2
writeln(lastIndexOf(s, "Zo")); // -1
writeln(lastIndexOf(s, "lL", No.caseSensitive)); // 2
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.typecons : No;

string s = "Hello World";
writeln(lastIndexOf(s, "ll", 4)); // 2
writeln(lastIndexOf(s, "Zo", 128)); // -1
writeln(lastIndexOf(s, "lL", 3, No.caseSensitive)); // -1
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="indexOfAny">pure @safe ptrdiff_t <strong id="indexOfAny">indexOfAny</strong>(Char, Char2)(const(Char)[] haystack, const(Char2)[] needles, in CaseSensitive cs = Yes.caseSensitive)<br><small>  Constraints: if (isSomeChar!Char &amp;&amp; isSomeChar!Char2); </small><br><br>pure @safe ptrdiff_t <strong id="indexOfAny">indexOfAny</strong>(Char, Char2)(const(Char)[] haystack, const(Char2)[] needles, in size_t startIdx, in CaseSensitive cs = Yes.caseSensitive)<br><small>  Constraints: if (isSomeChar!Char &amp;&amp; isSomeChar!Char2); </small>
</dt> <dd>
<p>Returns the index of the first occurrence of any of the elements in <code> needles</code> in <code>haystack</code>. If no element of <code>needles</code> is found, then <code>-1</code> is returned. The <code>startIdx</code> slices <code>haystack</code> in the following way <code>haystack[startIdx .. $]</code>. <code>startIdx</code> represents a codeunit index in <code>haystack</code>. If the sequence ending at <code>startIdx</code> does not represent a well formed codepoint, then a <a href="std_utf.html#UTFException"><code>std.utf.UTFException</code></a> may be thrown. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(Char)[] <code>haystack</code>
</td> <td>String to search for needles in.</td>
</tr> <tr>
<td>const(Char2)[] <code>needles</code>
</td> <td>Strings to search for in haystack.</td>
</tr> <tr>
<td>size_t <code>startIdx</code>
</td> <td>slices haystack like this <code>haystack[startIdx .. $]</code>. If the startIdx is greater equal the length of haystack the functions returns <code>-1</code>.</td>
</tr> <tr>
<td>CaseSensitive <code>cs</code>
</td> <td>Indicates whether the comparisons are case sensitive.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.conv : to;

ptrdiff_t i = "helloWorld".indexOfAny("Wr");
writeln(i); // 5
i = "öällo world".indexOfAny("lo ");
writeln(i); // 4
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.conv : to;

ptrdiff_t i = "helloWorld".indexOfAny("Wr", 4);
writeln(i); // 5

i = "Foo öällo world".indexOfAny("lh", 3);
writeln(i); // 8
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="lastIndexOfAny">pure @safe ptrdiff_t <strong id="lastIndexOfAny">lastIndexOfAny</strong>(Char, Char2)(const(Char)[] haystack, const(Char2)[] needles, in CaseSensitive cs = Yes.caseSensitive)<br><small>  Constraints: if (isSomeChar!Char &amp;&amp; isSomeChar!Char2); </small><br><br>pure @safe ptrdiff_t <strong id="lastIndexOfAny">lastIndexOfAny</strong>(Char, Char2)(const(Char)[] haystack, const(Char2)[] needles, in size_t stopIdx, in CaseSensitive cs = Yes.caseSensitive)<br><small>  Constraints: if (isSomeChar!Char &amp;&amp; isSomeChar!Char2); </small>
</dt> <dd>
<p>Returns the index of the last occurrence of any of the elements in <code> needles</code> in <code>haystack</code>. If no element of <code>needles</code> is found, then <code>-1</code> is returned. The <code>stopIdx</code> slices <code>haystack</code> in the following way <code>s[0 .. stopIdx]</code>. <code>stopIdx</code> represents a codeunit index in <code>haystack</code>. If the sequence ending at <code>startIdx</code> does not represent a well formed codepoint, then a <a href="std_utf.html#UTFException"><code>std.utf.UTFException</code></a> may be thrown. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(Char)[] <code>haystack</code>
</td> <td>String to search for needles in.</td>
</tr> <tr>
<td>const(Char2)[] <code>needles</code>
</td> <td>Strings to search for in haystack.</td>
</tr> <tr>
<td>size_t <code>stopIdx</code>
</td> <td>slices haystack like this <code>haystack[0 .. stopIdx]</code>. If the stopIdx is greater equal the length of haystack the functions returns <code>-1</code>.</td>
</tr> <tr>
<td>CaseSensitive <code>cs</code>
</td> <td>Indicates whether the comparisons are case sensitive.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">ptrdiff_t i = "helloWorld".lastIndexOfAny("Wlo");
writeln(i); // 8

i = "Foo öäöllo world".lastIndexOfAny("öF");
writeln(i); // 8
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.conv : to;

ptrdiff_t i = "helloWorld".lastIndexOfAny("Wlo", 4);
writeln(i); // 3

i = "Foo öäöllo world".lastIndexOfAny("öF", 3);
writeln(i); // 0
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="indexOfNeither">pure @safe ptrdiff_t <strong id="indexOfNeither">indexOfNeither</strong>(Char, Char2)(const(Char)[] haystack, const(Char2)[] needles, in CaseSensitive cs = Yes.caseSensitive)<br><small>  Constraints: if (isSomeChar!Char &amp;&amp; isSomeChar!Char2); </small><br><br>pure @safe ptrdiff_t <strong id="indexOfNeither">indexOfNeither</strong>(Char, Char2)(const(Char)[] haystack, const(Char2)[] needles, in size_t startIdx, in CaseSensitive cs = Yes.caseSensitive)<br><small>  Constraints: if (isSomeChar!Char &amp;&amp; isSomeChar!Char2); </small>
</dt> <dd>
<p>Returns the index of the first occurrence of any character not an elements in <code>needles</code> in <code>haystack</code>. If all element of <code>haystack</code> are element of <code>needles</code> <code>-1</code> is returned. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(Char)[] <code>haystack</code>
</td> <td>String to search for needles in.</td>
</tr> <tr>
<td>const(Char2)[] <code>needles</code>
</td> <td>Strings to search for in haystack.</td>
</tr> <tr>
<td>size_t <code>startIdx</code>
</td> <td>slices haystack like this <code>haystack[startIdx .. $]</code>. If the startIdx is greater equal the length of haystack the functions returns <code>-1</code>.</td>
</tr> <tr>
<td>CaseSensitive <code>cs</code>
</td> <td>Indicates whether the comparisons are case sensitive.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(indexOfNeither("abba", "a", 2)); // 2
writeln(indexOfNeither("def", "de", 1)); // 2
writeln(indexOfNeither("dfefffg", "dfe", 4)); // 6
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(indexOfNeither("def", "a")); // 0
writeln(indexOfNeither("def", "de")); // 2
writeln(indexOfNeither("dfefffg", "dfe")); // 6
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="lastIndexOfNeither">pure @safe ptrdiff_t <strong id="lastIndexOfNeither">lastIndexOfNeither</strong>(Char, Char2)(const(Char)[] haystack, const(Char2)[] needles, in CaseSensitive cs = Yes.caseSensitive)<br><small>  Constraints: if (isSomeChar!Char &amp;&amp; isSomeChar!Char2); </small><br><br>pure @safe ptrdiff_t <strong id="lastIndexOfNeither">lastIndexOfNeither</strong>(Char, Char2)(const(Char)[] haystack, const(Char2)[] needles, in size_t stopIdx, in CaseSensitive cs = Yes.caseSensitive)<br><small>  Constraints: if (isSomeChar!Char &amp;&amp; isSomeChar!Char2); </small>
</dt> <dd>
<p>Returns the last index of the first occurence of any character that is not an elements in <code>needles</code> in <code>haystack</code>. If all element of <code>haystack</code> are element of <code>needles</code> <code>-1</code> is returned. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(Char)[] <code>haystack</code>
</td> <td>String to search for needles in.</td>
</tr> <tr>
<td>const(Char2)[] <code>needles</code>
</td> <td>Strings to search for in haystack.</td>
</tr> <tr>
<td>size_t <code>stopIdx</code>
</td> <td>slices haystack like this <code>haystack[0 .. stopIdx]</code> If the stopIdx is greater equal the length of haystack the functions returns <code>-1</code>.</td>
</tr> <tr>
<td>CaseSensitive <code>cs</code>
</td> <td>Indicates whether the comparisons are case sensitive.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(lastIndexOfNeither("abba", "a")); // 2
writeln(lastIndexOfNeither("def", "f")); // 1
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(lastIndexOfNeither("def", "rsa", 3)); // -1
writeln(lastIndexOfNeither("abba", "a", 2)); // 1
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="representation">pure nothrow @nogc @safe auto <strong id="representation">representation</strong>(Char)(Char[] s)<br><small>  Constraints: if (isSomeChar!Char); </small>
</dt> <dd>
<p>Returns the representation of a string, which has the same type as the string except the character type is replaced by <code>ubyte</code>, <code>ushort</code>, or <code>uint</code> depending on the character width. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Char[] <code>s</code>
</td> <td>The string to return the representation of.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The representation of the passed string.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">string s = "hello";
static assert(is(typeof(representation(s)) == immutable(ubyte)[]));
assert(representation(s) is cast(immutable(ubyte)[]) s);
writeln(representation(s)); // [0x68, 0x65, 0x6c, 0x6c, 0x6f]
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="capitalize">pure @trusted S <strong id="capitalize">capitalize</strong>(S)(S input)<br><small>  Constraints: if (isSomeString!S); </small>
</dt> <dd>
<p>Capitalize the first character of <code>s</code> and convert the rest of <code>s</code> to lowercase. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>S <code>input</code>
</td> <td>The string to capitalize.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The capitalized string. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="std_uni.html#asCapitalized"><code>std.uni.asCapitalized</code></a> for a lazy range version that doesn't allocate memory</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(capitalize("hello")); // "Hello"
writeln(capitalize("World")); // "World"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="KeepTerminator">alias <strong id="KeepTerminator">KeepTerminator</strong> = std.typecons.Flag!"keepTerminator".Flag; <br><br>pure @safe C[][] <strong id="splitLines">splitLines</strong>(C)(C[] s, KeepTerminator keepTerm = No.keepTerminator)<br><small>  Constraints: if (isSomeChar!C); </small>
</dt> <dd>
<p>Split <code>s</code> into an array of lines according to the unicode standard using <code>'\r'</code>, <code>'\n'</code>, <code>"\r\n"</code>, <a href="std_uni.html#lineSep"><code>std.uni.lineSep</code></a>, <a href="std_uni.html#paraSep"><code>std.uni.paraSep</code></a>, <code>U+0085</code> (NEL), <code>'\v'</code> and <code>'\f'</code> as delimiters. If <code>keepTerm</code> is set to <code>KeepTerminator.yes</code>, then the delimiter is included in the strings returned. </p>
<p>Does not throw on invalid UTF; such is simply passed unchanged to the output. <br><br> Allocates memory; use <a href="#lineSplitter"><code>lineSplitter</code></a> for an alternative that does not. <br><br> Adheres to <a href="http://www.unicode.org/versions/Unicode7.0.0/ch05.pdf">Unicode 7.0</a>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>C[] <code>s</code>
</td> <td>a string of <code>chars</code>, <code>wchars</code>, or <code>dchars</code>, or any custom type that casts to a <code>string</code> type</td>
</tr> <tr>
<td>
<code>KeepTerminator</code> <code>keepTerm</code>
</td> <td>whether delimiter is included or not in the results</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>array of strings, each element is a line that is a slice of <code>s</code> </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="#lineSplitter"><code>lineSplitter</code></a> <a href="std_algorithm.html#splitter"><code>std.algorithm.splitter</code></a> <a href="std_regex.html#splitter"><code>std.regex.splitter</code></a>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">string s = "Hello\nmy\rname\nis";
writeln(splitLines(s)); // ["Hello", "my", "name", "is"]
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="lineSplitter">auto <strong id="lineSplitter">lineSplitter</strong>(KeepTerminator keepTerm = No.keepTerminator, Range)(Range r)<br><small>  Constraints: if (hasSlicing!Range &amp;&amp; hasLength!Range &amp;&amp; isSomeChar!(ElementType!Range) &amp;&amp; !isSomeString!Range); </small><br><br>auto <strong id="lineSplitter">lineSplitter</strong>(KeepTerminator keepTerm = No.keepTerminator, C)(C[] r)<br><small>  Constraints: if (isSomeChar!C); </small>
</dt> <dd>
<p>Split an array or slicable range of characters into a range of lines using <code>'\r'</code>, <code>'\n'</code>, <code>'\v'</code>, <code>'\f'</code>, <code>"\r\n"</code>, <a href="std_uni.html#lineSep"><code>std.uni.lineSep</code></a>, <a href="std_uni.html#paraSep"><code>std.uni.paraSep</code></a> and <code>'\u0085'</code> (NEL) as delimiters. If <code>keepTerm</code> is set to <code>Yes.keepTerminator</code>, then the delimiter is included in the slices returned. </p>
<p>Does not throw on invalid UTF; such is simply passed unchanged to the output. <br><br> Adheres to <a href="http://www.unicode.org/versions/Unicode7.0.0/ch05.pdf">Unicode 7.0</a>. <br><br> Does not allocate memory. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>r</code>
</td> <td>array of <code>chars</code>, <code>wchars</code>, or <code>dchars</code> or a slicable range</td>
</tr> <tr>
<td>keepTerm</td> <td>whether delimiter is included or not in the results</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>range of slices of the input range <code>r</code> </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="#splitLines"><code>splitLines</code></a> <a href="std_algorithm.html#splitter"><code>std.algorithm.splitter</code></a> <a href="std_regex.html#splitter"><code>std.regex.splitter</code></a>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.array : array;

string s = "Hello\nmy\rname\nis";

/* notice the call to 'array' to turn the lazy range created by
lineSplitter comparable to the string[] created by splitLines.
*/
writeln(lineSplitter(s).array); // splitLines(s)
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto s = "\rpeter\n\rpaul\r\njerry\u2028ice\u2029cream\n\nsunday\nmon\u2030day\n";
auto lines = s.lineSplitter();
static immutable witness = ["", "peter", "", "paul", "jerry", "ice", "cream", "", "sunday", "mon\u2030day"];
uint i;
foreach (line; lines)
{
    writeln(line); // witness[i++]
}
writeln(i); // witness.length
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="stripLeft">auto <strong id="stripLeft">stripLeft</strong>(Range)(Range input)<br><small>  Constraints: if (isForwardRange!Range &amp;&amp; isSomeChar!(ElementEncodingType!Range) &amp;&amp; !isInfinite!Range &amp;&amp; !isConvertibleToString!Range); </small><br><br>auto <strong id="stripLeft">stripLeft</strong>(Range, Char)(Range input, const(Char)[] chars)<br><small>  Constraints: if ((isForwardRange!Range &amp;&amp; isSomeChar!(ElementEncodingType!Range) || isConvertibleToString!Range) &amp;&amp; isSomeChar!Char); </small>
</dt> <dd>
<p>Strips leading whitespace (as defined by <a href="std_uni.html#isWhite"><code>std.uni.isWhite</code></a>) or as specified in the second argument. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>input</code>
</td> <td>string or <a href="std_range_primitives.html#isForwardRange">forward range</a> of characters</td>
</tr> <tr>
<td>const(Char)[] <code>chars</code>
</td> <td>string of characters to be stripped</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>input</code> stripped of leading whitespace or characters specified in the second argument. </dd>
</dl> <dl>
<dt>Postconditions</dt>
<dd> <code>input</code> and the returned value will share the same tail (see <a href="std_array.html#sameTail"><code>std.array.sameTail</code></a>). </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>Generic stripping on ranges: <a href="std_algorithm_mutation.html#stripLeft"><code>std.algorithm.mutation.stripLeft</code></a>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.uni : lineSep, paraSep;
assert(stripLeft("     hello world     ") ==
       "hello world     ");
assert(stripLeft("\n\t\v\rhello world\n\t\v\r") ==
       "hello world\n\t\v\r");
assert(stripLeft(" \u2028hello world") ==
       "hello world");
assert(stripLeft("hello world") ==
       "hello world");
assert(stripLeft([lineSep] ~ "hello world" ~ lineSep) ==
       "hello world" ~ [lineSep]);
assert(stripLeft([paraSep] ~ "hello world" ~ paraSep) ==
       "hello world" ~ [paraSep]);

import std.array : array;
import std.utf : byChar;
assert(stripLeft("     hello world     "w.byChar).array ==
       "hello world     ");
assert(stripLeft("     \u2022hello world     ".byChar).array ==
       "\u2022hello world     ");
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(stripLeft("     hello world     ", " ") ==
       "hello world     ");
assert(stripLeft("xxxxxhello world     ", "x") ==
       "hello world     ");
assert(stripLeft("xxxyy    hello world     ", "xy ") ==
       "hello world     ");
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.array : array;
import std.utf : byChar, byWchar, byDchar;

assert(stripLeft("  xxxyy hello world     "w.byChar, "xy ").array ==
       "hello world     ");

assert(stripLeft("\u2028\u2020hello world\u2028"w.byWchar,
                 "\u2028").array == "\u2020hello world\u2028");
assert(stripLeft("\U00010001hello world"w.byWchar, " ").array ==
       "\U00010001hello world"w);
assert(stripLeft("\U00010001 xyhello world"d.byDchar,
                 "\U00010001 xy").array == "hello world"d);

writeln(stripLeft("\u2020hello"w, "\u2020"w)); // "hello"w
writeln(stripLeft("\U00010001hello"d, "\U00010001"d)); // "hello"d
writeln(stripLeft(" hello ", "")); // " hello "
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="stripRight">auto <strong id="stripRight">stripRight</strong>(Range)(Range str)<br><small>  Constraints: if (isSomeString!Range || isRandomAccessRange!Range &amp;&amp; hasLength!Range &amp;&amp; hasSlicing!Range &amp;&amp; !isConvertibleToString!Range &amp;&amp; isSomeChar!(ElementEncodingType!Range)); </small><br><br>auto <strong id="stripRight">stripRight</strong>(Range, Char)(Range str, const(Char)[] chars)<br><small>  Constraints: if ((isBidirectionalRange!Range &amp;&amp; isSomeChar!(ElementEncodingType!Range) || isConvertibleToString!Range) &amp;&amp; isSomeChar!Char); </small>
</dt> <dd>
<p>Strips trailing whitespace (as defined by <a href="std_uni.html#isWhite"><code>std.uni.isWhite</code></a>) or as specified in the second argument. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>str</code>
</td> <td>string or random access range of characters</td>
</tr> <tr>
<td>const(Char)[] <code>chars</code>
</td> <td>string of characters to be stripped</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>slice of <code>str</code> stripped of trailing whitespace or characters specified in the second argument. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>Generic stripping on ranges: <a href="std_algorithm_mutation.html#stripRight"><code>std.algorithm.mutation.stripRight</code></a>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.uni : lineSep, paraSep;
assert(stripRight("     hello world     ") ==
       "     hello world");
assert(stripRight("\n\t\v\rhello world\n\t\v\r") ==
       "\n\t\v\rhello world");
assert(stripRight("hello world") ==
       "hello world");
assert(stripRight([lineSep] ~ "hello world" ~ lineSep) ==
       [lineSep] ~ "hello world");
assert(stripRight([paraSep] ~ "hello world" ~ paraSep) ==
       [paraSep] ~ "hello world");
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(stripRight("     hello world     ", "x") ==
       "     hello world     ");
assert(stripRight("     hello world     ", " ") ==
       "     hello world");
assert(stripRight("     hello worldxy     ", "xy ") ==
       "     hello world");
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="strip">auto <strong id="strip">strip</strong>(Range)(Range str)<br><small>  Constraints: if (isSomeString!Range || isRandomAccessRange!Range &amp;&amp; hasLength!Range &amp;&amp; hasSlicing!Range &amp;&amp; !isConvertibleToString!Range &amp;&amp; isSomeChar!(ElementEncodingType!Range)); </small><br><br>auto <strong id="strip">strip</strong>(Range, Char)(Range str, const(Char)[] chars)<br><small>  Constraints: if ((isBidirectionalRange!Range &amp;&amp; isSomeChar!(ElementEncodingType!Range) || isConvertibleToString!Range) &amp;&amp; isSomeChar!Char); </small><br><br>auto <strong id="strip">strip</strong>(Range, Char)(Range str, const(Char)[] leftChars, const(Char)[] rightChars)<br><small>  Constraints: if ((isBidirectionalRange!Range &amp;&amp; isSomeChar!(ElementEncodingType!Range) || isConvertibleToString!Range) &amp;&amp; isSomeChar!Char); </small>
</dt> <dd>
<p>Strips both leading and trailing whitespace (as defined by <a href="std_uni.html#isWhite"><code>std.uni.isWhite</code></a>) or as specified in the second argument. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>str</code>
</td> <td>string or random access range of characters</td>
</tr> <tr>
<td>const(Char)[] <code>chars</code>
</td> <td>string of characters to be stripped</td>
</tr> <tr>
<td>const(Char)[] <code>leftChars</code>
</td> <td>string of leading characters to be stripped</td>
</tr> <tr>
<td>const(Char)[] <code>rightChars</code>
</td> <td>string of trailing characters to be stripped</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>slice of <code>str</code> stripped of leading and trailing whitespace or characters as specified in the second argument. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>Generic stripping on ranges: <a href="std_algorithm_mutation.html#strip"><code>std.algorithm.mutation.strip</code></a>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.uni : lineSep, paraSep;
assert(strip("     hello world     ") ==
       "hello world");
assert(strip("\n\t\v\rhello world\n\t\v\r") ==
       "hello world");
assert(strip("hello world") ==
       "hello world");
assert(strip([lineSep] ~ "hello world" ~ [lineSep]) ==
       "hello world");
assert(strip([paraSep] ~ "hello world" ~ [paraSep]) ==
       "hello world");
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(strip("     hello world     ", "x") ==
       "     hello world     ");
assert(strip("     hello world     ", " ") ==
       "hello world");
assert(strip("   xyxyhello worldxyxy     ", "xy ") ==
       "hello world");
writeln(strip("\u2020hello\u2020"w, "\u2020"w)); // "hello"w
writeln(strip("\U00010001hello\U00010001"d, "\U00010001"d)); // "hello"d
writeln(strip(" hello ", "")); // " hello "
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(strip("xxhelloyy", "x", "y")); // "hello"
assert(strip("   xyxyhello worldxyxyzz    ", "xy ", "xyz ") ==
       "hello world");
writeln(strip("\u2020hello\u2028"w, "\u2020"w, "\u2028"w)); // "hello"w
assert(strip("\U00010001hello\U00010002"d, "\U00010001"d, "\U00010002"d) ==
       "hello"d);
writeln(strip(" hello ", "", "")); // " hello "
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="chomp">Range <strong id="chomp">chomp</strong>(Range)(Range str)<br><small>  Constraints: if ((isRandomAccessRange!Range &amp;&amp; isSomeChar!(ElementEncodingType!Range) || isNarrowString!Range) &amp;&amp; !isConvertibleToString!Range); </small><br><br>Range <strong id="chomp">chomp</strong>(Range, C2)(Range str, const(C2)[] delimiter)<br><small>  Constraints: if ((isBidirectionalRange!Range &amp;&amp; isSomeChar!(ElementEncodingType!Range) || isNarrowString!Range) &amp;&amp; !isConvertibleToString!Range &amp;&amp; isSomeChar!C2); </small>
</dt> <dd>
<p>If <code>str</code> ends with <code>delimiter</code>, then <code>str</code> is returned without <code>delimiter</code> on its end. If it <code>str</code> does <i>not</i> end with <code>delimiter</code>, then it is returned unchanged. </p>
<p>If no <code>delimiter</code> is given, then one trailing <code>'\r'</code>, <code>'\n'</code>, <code>"\r\n"</code>, <code>'\f'</code>, <code>'\v'</code>, <a href="std_uni.html#lineSep"><code>std.uni.lineSep</code></a>, <a href="std_uni.html#paraSep"><code>std.uni.paraSep</code></a>, or <a href="std_uni.html#nelSep"><code>std.uni.nelSep</code></a> is removed from the end of <code>str</code>. If <code>str</code> does not end with any of those characters, then it is returned unchanged. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>str</code>
</td> <td>string or indexable range of characters</td>
</tr> <tr>
<td>const(C2)[] <code>delimiter</code>
</td> <td>string of characters to be sliced off end of str[]</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>slice of str</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.uni : lineSep, paraSep, nelSep;
import std.utf : decode;
writeln(chomp(" hello world  \n\r")); // " hello world  \n"
writeln(chomp(" hello world  \r\n")); // " hello world  "
writeln(chomp(" hello world  \f")); // " hello world  "
writeln(chomp(" hello world  \v")); // " hello world  "
writeln(chomp(" hello world  \n\n")); // " hello world  \n"
writeln(chomp(" hello world  \n\n ")); // " hello world  \n\n "
writeln(chomp(" hello world  \n\n" ~ [lineSep])); // " hello world  \n\n"
writeln(chomp(" hello world  \n\n" ~ [paraSep])); // " hello world  \n\n"
writeln(chomp(" hello world  \n\n" ~ [nelSep])); // " hello world  \n\n"
writeln(chomp(" hello world")); // " hello world"
writeln(chomp("")); // ""

writeln(chomp(" hello world", "orld")); // " hello w"
writeln(chomp(" hello world", " he")); // " hello world"
writeln(chomp("", "hello")); // ""

// Don't decode pointlessly
writeln(chomp("hello\xFE", "\r")); // "hello\xFE"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="chompPrefix">Range <strong id="chompPrefix">chompPrefix</strong>(Range, C2)(Range str, const(C2)[] delimiter)<br><small>  Constraints: if ((isForwardRange!Range &amp;&amp; isSomeChar!(ElementEncodingType!Range) || isNarrowString!Range) &amp;&amp; !isConvertibleToString!Range &amp;&amp; isSomeChar!C2); </small>
</dt> <dd>
<p>If <code>str</code> starts with <code>delimiter</code>, then the part of <code>str</code> following <code>delimiter</code> is returned. If <code>str</code> does <i>not</i> start with </p>
<p><code>delimiter</code>, then it is returned unchanged. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>str</code>
</td> <td>string or <a href="std_range_primitives.html#isForwardRange">forward range</a> of characters</td>
</tr> <tr>
<td>const(C2)[] <code>delimiter</code>
</td> <td>string of characters to be sliced off front of str[]</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>slice of str</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(chompPrefix("hello world", "he")); // "llo world"
writeln(chompPrefix("hello world", "hello w")); // "orld"
writeln(chompPrefix("hello world", " world")); // "hello world"
writeln(chompPrefix("", "hello")); // ""
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="chop">Range <strong id="chop">chop</strong>(Range)(Range str)<br><small>  Constraints: if ((isBidirectionalRange!Range &amp;&amp; isSomeChar!(ElementEncodingType!Range) || isNarrowString!Range) &amp;&amp; !isConvertibleToString!Range); </small>
</dt> <dd>
<p>Returns <code>str</code> without its last character, if there is one. If <code>str</code> ends with <code>"\r\n"</code>, then both are removed. If <code>str</code> is empty, then it is returned unchanged. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>str</code>
</td> <td>string (must be valid UTF)</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>slice of str</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(chop("hello world")); // "hello worl"
writeln(chop("hello world\n")); // "hello world"
writeln(chop("hello world\r")); // "hello world"
writeln(chop("hello world\n\r")); // "hello world\n"
writeln(chop("hello world\r\n")); // "hello world"
writeln(chop("Walter Bright")); // "Walter Brigh"
writeln(chop("")); // ""
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="leftJustify">S <strong id="leftJustify">leftJustify</strong>(S)(S s, size_t width, dchar fillChar = ' ')<br><small>  Constraints: if (isSomeString!S); </small>
</dt> <dd>
<p>Left justify <code>s</code> in a field <code>width</code> characters wide. <code>fillChar</code> is the character that will be used to fill up the space in the field that <code>s</code> doesn't fill. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>S <code>s</code>
</td> <td>string</td>
</tr> <tr>
<td>size_t <code>width</code>
</td> <td>minimum field width</td>
</tr> <tr>
<td>dchar <code>fillChar</code>
</td> <td>used to pad end up to <code>width</code> characters</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>GC allocated string </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="#leftJustifier"><code>leftJustifier</code></a>, which does not allocate</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(leftJustify("hello", 7, 'X')); // "helloXX"
writeln(leftJustify("hello", 2, 'X')); // "hello"
writeln(leftJustify("hello", 9, 'X')); // "helloXXXX"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="leftJustifier">auto <strong id="leftJustifier">leftJustifier</strong>(Range)(Range r, size_t width, dchar fillChar = ' ')<br><small>  Constraints: if (isInputRange!Range &amp;&amp; isSomeChar!(ElementEncodingType!Range) &amp;&amp; !isConvertibleToString!Range); </small>
</dt> <dd>
<p>Left justify <code>s</code> in a field <code>width</code> characters wide. <code>fillChar</code> is the character that will be used to fill up the space in the field that <code>s</code> doesn't fill. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>r</code>
</td> <td>string or range of characters</td>
</tr> <tr>
<td>size_t <code>width</code>
</td> <td>minimum field width</td>
</tr> <tr>
<td>dchar <code>fillChar</code>
</td> <td>used to pad end up to <code>width</code> characters</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>a lazy range of the left justified result </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd><a href="#rightJustifier"><code>rightJustifier</code></a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.utf : byChar;
assert(leftJustifier("hello", 2).equal("hello".byChar));
assert(leftJustifier("hello", 7).equal("hello  ".byChar));
assert(leftJustifier("hello", 7, 'x').equal("helloxx".byChar));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="rightJustify">S <strong id="rightJustify">rightJustify</strong>(S)(S s, size_t width, dchar fillChar = ' ')<br><small>  Constraints: if (isSomeString!S); </small>
</dt> <dd>
<p>Right justify <code>s</code> in a field <code>width</code> characters wide. <code>fillChar</code> is the character that will be used to fill up the space in the field that <code>s</code> doesn't fill. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>S <code>s</code>
</td> <td>string</td>
</tr> <tr>
<td>size_t <code>width</code>
</td> <td>minimum field width</td>
</tr> <tr>
<td>dchar <code>fillChar</code>
</td> <td>used to pad end up to <code>width</code> characters</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>GC allocated string </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="#rightJustifier"><code>rightJustifier</code></a>, which does not allocate</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(rightJustify("hello", 7, 'X')); // "XXhello"
writeln(rightJustify("hello", 2, 'X')); // "hello"
writeln(rightJustify("hello", 9, 'X')); // "XXXXhello"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="rightJustifier">auto <strong id="rightJustifier">rightJustifier</strong>(Range)(Range r, size_t width, dchar fillChar = ' ')<br><small>  Constraints: if (isForwardRange!Range &amp;&amp; isSomeChar!(ElementEncodingType!Range) &amp;&amp; !isConvertibleToString!Range); </small>
</dt> <dd>
<p>Right justify <code>s</code> in a field <code>width</code> characters wide. <code>fillChar</code> is the character that will be used to fill up the space in the field that <code>s</code> doesn't fill. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>r</code>
</td> <td>string or <a href="std_range_primitives.html#isForwardRange">forward range</a> of characters</td>
</tr> <tr>
<td>size_t <code>width</code>
</td> <td>minimum field width</td>
</tr> <tr>
<td>dchar <code>fillChar</code>
</td> <td>used to pad end up to <code>width</code> characters</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>a lazy range of the right justified result </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd><a href="#leftJustifier"><code>leftJustifier</code></a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.utf : byChar;
assert(rightJustifier("hello", 2).equal("hello".byChar));
assert(rightJustifier("hello", 7).equal("  hello".byChar));
assert(rightJustifier("hello", 7, 'x').equal("xxhello".byChar));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="center">S <strong id="center">center</strong>(S)(S s, size_t width, dchar fillChar = ' ')<br><small>  Constraints: if (isSomeString!S); </small>
</dt> <dd>
<p>Center <code>s</code> in a field <code>width</code> characters wide. <code>fillChar</code> is the character that will be used to fill up the space in the field that <code>s</code> doesn't fill. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>S <code>s</code>
</td> <td>The string to center</td>
</tr> <tr>
<td>size_t <code>width</code>
</td> <td>Width of the field to center <code>s</code> in</td>
</tr> <tr>
<td>dchar <code>fillChar</code>
</td> <td>The character to use for filling excess space in the field</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The resulting center-justified string. The returned string is GC-allocated. To avoid GC allocation, use <a href="#centerJustifier"><code>centerJustifier</code></a> instead.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(center("hello", 7, 'X')); // "XhelloX"
writeln(center("hello", 2, 'X')); // "hello"
writeln(center("hello", 9, 'X')); // "XXhelloXX"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="centerJustifier">auto <strong id="centerJustifier">centerJustifier</strong>(Range)(Range r, size_t width, dchar fillChar = ' ')<br><small>  Constraints: if (isForwardRange!Range &amp;&amp; isSomeChar!(ElementEncodingType!Range) &amp;&amp; !isConvertibleToString!Range); </small>
</dt> <dd>
<p>Center justify <code>r</code> in a field <code>width</code> characters wide. <code>fillChar</code> is the character that will be used to fill up the space in the field that <code>r</code> doesn't fill. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>r</code>
</td> <td>string or <a href="std_range_primitives.html#isForwardRange">forward range</a> of characters</td>
</tr> <tr>
<td>size_t <code>width</code>
</td> <td>minimum field width</td>
</tr> <tr>
<td>dchar <code>fillChar</code>
</td> <td>used to pad end up to <code>width</code> characters</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>a lazy range of the center justified result </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="#leftJustifier"><code>leftJustifier</code></a> <a href="#rightJustifier"><code>rightJustifier</code></a>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.utf : byChar;
assert(centerJustifier("hello", 2).equal("hello".byChar));
assert(centerJustifier("hello", 8).equal(" hello  ".byChar));
assert(centerJustifier("hello", 7, 'x').equal("xhellox".byChar));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="detab">pure auto <strong id="detab">detab</strong>(Range)(auto ref Range s, size_t tabSize = 8)<br><small>  Constraints: if (isForwardRange!Range &amp;&amp; isSomeChar!(ElementEncodingType!Range) || __traits(compiles, StringTypeOf!Range)); </small>
</dt> <dd>
<p>Replace each tab character in <code>s</code> with the number of spaces necessary to align the following character at the next tab stop. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>s</code>
</td> <td>string</td>
</tr> <tr>
<td>size_t <code>tabSize</code>
</td> <td>distance between tab stops</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>GC allocated string with tabs replaced with spaces</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(detab(" \n\tx", 9)); // " \n         x"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="detabber">auto <strong id="detabber">detabber</strong>(Range)(Range r, size_t tabSize = 8)<br><small>  Constraints: if (isForwardRange!Range &amp;&amp; isSomeChar!(ElementEncodingType!Range) &amp;&amp; !isConvertibleToString!Range); </small>
</dt> <dd>
<p>Replace each tab character in <code>r</code> with the number of spaces necessary to align the following character at the next tab stop. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>r</code>
</td> <td>string or <a href="std_range_primitives.html#isForwardRange">forward range</a>
</td>
</tr> <tr>
<td>size_t <code>tabSize</code>
</td> <td>distance between tab stops</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>lazy forward range with tabs replaced with spaces</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.array : array;

writeln(detabber(" \n\tx", 9).array); // " \n         x"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="entab">auto <strong id="entab">entab</strong>(Range)(Range s, size_t tabSize = 8)<br><small>  Constraints: if (isForwardRange!Range &amp;&amp; isSomeChar!(ElementEncodingType!Range)); </small>
</dt> <dd>
<p>Replaces spaces in <code>s</code> with the optimal number of tabs. All spaces and tabs at the end of a line are removed. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>s</code>
</td> <td>String to convert.</td>
</tr> <tr>
<td>size_t <code>tabSize</code>
</td> <td>Tab columns are <code>tabSize</code> spaces apart.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>GC allocated string with spaces replaced with tabs; use <a href="#entabber"><code>entabber</code></a> to not allocate. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd><a href="#entabber"><code>entabber</code></a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(entab("        x \n")); // "\tx\n"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="entabber">auto <strong id="entabber">entabber</strong>(Range)(Range r, size_t tabSize = 8)<br><small>  Constraints: if (isForwardRange!Range &amp;&amp; !isConvertibleToString!Range); </small>
</dt> <dd>
<p>Replaces spaces in range <code>r</code> with the optimal number of tabs. All spaces and tabs at the end of a line are removed. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>r</code>
</td> <td>string or <a href="std_range_primitives.html#isForwardRange">forward range</a>
</td>
</tr> <tr>
<td>size_t <code>tabSize</code>
</td> <td>distance between tab stops</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>lazy forward range with spaces replaced with tabs </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd><a href="#entab"><code>entab</code></a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.array : array;
writeln(entabber("        x \n").array); // "\tx\n"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="translate">pure @safe C1[] <strong id="translate">translate</strong>(C1, C2 = immutable(char))(C1[] str, in dchar[dchar] transTable, const(C2)[] toRemove = null)<br><small>  Constraints: if (isSomeChar!C1 &amp;&amp; isSomeChar!C2); </small><br><br>pure @safe C1[] <strong id="translate">translate</strong>(C1, S, C2 = immutable(char))(C1[] str, in S[dchar] transTable, const(C2)[] toRemove = null)<br><small>  Constraints: if (isSomeChar!C1 &amp;&amp; isSomeString!S &amp;&amp; isSomeChar!C2); </small>
</dt> <dd>
<p>Replaces the characters in <code>str</code> which are keys in <code>transTable</code> with their corresponding values in <code>transTable</code>. <code>transTable</code> is an AA where its keys are <code>dchar</code> and its values are either <code>dchar</code> or some type of string. Also, if <code>toRemove</code> is given, the characters in it are removed from <code>str</code> prior to translation. <code>str</code> itself is unaltered. A copy with the changes is returned. </p>
<dl>
<dt>See Also:</dt>
<dd>
<a href="#tr"><code>tr</code></a>, <a href="std_array.html#replace"><code>std.array.replace</code></a>, <a href="std_algorithm_iteration.html#substitute"><code>std.algorithm.iteration.substitute</code></a> </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>C1[] <code>str</code>
</td> <td>The original string.</td>
</tr> <tr>
<td>dchar[dchar] <code>transTable</code>
</td> <td>The AA indicating which characters to replace and what to replace them with.</td>
</tr> <tr>
<td>const(C2)[] <code>toRemove</code>
</td> <td>The characters to remove from the string.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">dchar[dchar] transTable1 = ['e' : '5', 'o' : '7', '5': 'q'];
writeln(translate("hello world", transTable1)); // "h5ll7 w7rld"

writeln(translate("hello world", transTable1, "low")); // "h5 rd"

string[dchar] transTable2 = ['e' : "5", 'o' : "orange"];
writeln(translate("hello world", transTable2)); // "h5llorange worangerld"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="translate.2">void <strong id="translate">translate</strong>(C1, C2 = immutable(char), Buffer)(const(C1)[] str, in dchar[dchar] transTable, const(C2)[] toRemove, Buffer buffer)<br><small>  Constraints: if (isSomeChar!C1 &amp;&amp; isSomeChar!C2 &amp;&amp; isOutputRange!(Buffer, C1)); </small><br><br>void <strong id="translate">translate</strong>(C1, S, C2 = immutable(char), Buffer)(C1[] str, in S[dchar] transTable, const(C2)[] toRemove, Buffer buffer)<br><small>  Constraints: if (isSomeChar!C1 &amp;&amp; isSomeString!S &amp;&amp; isSomeChar!C2 &amp;&amp; isOutputRange!(Buffer, S)); </small>
</dt> <dd>
<p>This is an overload of <code>translate</code> which takes an existing buffer to write the contents to. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(C1)[] <code>str</code>
</td> <td>The original string.</td>
</tr> <tr>
<td>dchar[dchar] <code>transTable</code>
</td> <td>The AA indicating which characters to replace and what to replace them with.</td>
</tr> <tr>
<td>const(C2)[] <code>toRemove</code>
</td> <td>The characters to remove from the string.</td>
</tr> <tr>
<td>Buffer <code>buffer</code>
</td> <td>An output range to write the contents to.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.array : appender;
dchar[dchar] transTable1 = ['e' : '5', 'o' : '7', '5': 'q'];
auto buffer = appender!(dchar[])();
translate("hello world", transTable1, null, buffer);
writeln(buffer.data); // "h5ll7 w7rld"

buffer.clear();
translate("hello world", transTable1, "low", buffer);
writeln(buffer.data); // "h5 rd"

buffer.clear();
string[dchar] transTable2 = ['e' : "5", 'o' : "orange"];
translate("hello world", transTable2, null, buffer);
writeln(buffer.data); // "h5llorange worangerld"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="translate.3">pure nothrow @trusted C[] <strong id="translate">translate</strong>(C = immutable(char))(scope const(char)[] str, scope const(char)[] transTable, scope const(char)[] toRemove = null)<br><small>  Constraints: if (is(immutable(C) == immutable(char))); </small>
</dt> <dd>
<p>This is an <i><span class="red">ASCII-only</span></i> overload of <a href="#translate"><code>translate</code></a>. It will <i>not</i> work with Unicode. It exists as an optimization for the cases where Unicode processing is not necessary. </p>
<p>Unlike the other overloads of <a href="#translate"><code>translate</code></a>, this one does not take an AA. Rather, it takes a <code>string</code> generated by <a href="#makeTransTable"><code>makeTransTable</code></a>. <br><br> The array generated by <code>makeTransTable</code> is <code>256</code> elements long such that the index is equal to the ASCII character being replaced and the value is equal to the character that it's being replaced with. Note that translate does not decode any of the characters, so you can actually pass it Extended ASCII characters if you want to (ASCII only actually uses <code>128</code> characters), but be warned that Extended ASCII characters are not valid Unicode and therefore will result in a <code>UTFException</code> being thrown from most other Phobos functions. <br><br> Also, because no decoding occurs, it is possible to use this overload to translate ASCII characters within a proper UTF-8 string without altering the other, non-ASCII characters. It's replacing any code unit greater than <code>127</code> with another code unit or replacing any code unit with another code unit greater than <code>127</code> which will cause UTF validation issues. </p> <dl>
<dt>See Also:</dt>
<dd>
<a href="#tr"><code>tr</code></a>, <a href="std_array.html#replace"><code>std.array.replace</code></a>, <a href="std_algorithm_iteration.html#substitute"><code>std.algorithm.iteration.substitute</code></a> </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(char)[] <code>str</code>
</td> <td>The original string.</td>
</tr> <tr>
<td>const(char)[] <code>transTable</code>
</td> <td>The string indicating which characters to replace and what to replace them with. It is generated by <a href="#makeTransTable"><code>makeTransTable</code></a>.</td>
</tr> <tr>
<td>const(char)[] <code>toRemove</code>
</td> <td>The characters to remove from the string.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto transTable1 = makeTrans("eo5", "57q");
writeln(translate("hello world", transTable1)); // "h5ll7 w7rld"

writeln(translate("hello world", transTable1, "low")); // "h5 rd"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="makeTrans">pure nothrow @trusted string <strong id="makeTrans">makeTrans</strong>(scope const(char)[] from, scope const(char)[] to); </dt> <dd>
<p>Do same thing as <a href="#makeTransTable"><code>makeTransTable</code></a> but allocate the translation table on the GC heap. </p>
<p>Use <a href="#makeTransTable"><code>makeTransTable</code></a> instead.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto transTable1 = makeTrans("eo5", "57q");
writeln(translate("hello world", transTable1)); // "h5ll7 w7rld"

writeln(translate("hello world", transTable1, "low")); // "h5 rd"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="makeTransTable">pure nothrow @nogc @safe char[256] <strong id="makeTransTable">makeTransTable</strong>(scope const(char)[] from, scope const(char)[] to); </dt> <dd>
<p>Construct 256 character translation table, where characters in from[] are replaced by corresponding characters in to[]. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(char)[] <code>from</code>
</td> <td>array of chars, less than or equal to 256 in length</td>
</tr> <tr>
<td>const(char)[] <code>to</code>
</td> <td>corresponding array of chars to translate to</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>translation array</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(translate("hello world", makeTransTable("hl", "q5"))); // "qe55o wor5d"
writeln(translate("hello world", makeTransTable("12345", "67890"))); // "hello world"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="translate.4">pure @trusted void <strong id="translate">translate</strong>(C = immutable(char), Buffer)(scope const(char)[] str, scope const(char)[] transTable, scope const(char)[] toRemove, Buffer buffer)<br><small>  Constraints: if (is(immutable(C) == immutable(char)) &amp;&amp; isOutputRange!(Buffer, char)); </small>
</dt> <dd>
<p>This is an <i><span class="red">ASCII-only</span></i> overload of <code>translate</code> which takes an existing buffer to write the contents to. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(char)[] <code>str</code>
</td> <td>The original string.</td>
</tr> <tr>
<td>const(char)[] <code>transTable</code>
</td> <td>The string indicating which characters to replace and what to replace them with. It is generated by <a href="#makeTransTable"><code>makeTransTable</code></a>.</td>
</tr> <tr>
<td>const(char)[] <code>toRemove</code>
</td> <td>The characters to remove from the string.</td>
</tr> <tr>
<td>Buffer <code>buffer</code>
</td> <td>An output range to write the contents to.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.array : appender;
auto buffer = appender!(char[])();
auto transTable1 = makeTransTable("eo5", "57q");
translate("hello world", transTable1, null, buffer);
writeln(buffer.data); // "h5ll7 w7rld"

buffer.clear();
translate("hello world", transTable1, "low", buffer);
writeln(buffer.data); // "h5 rd"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="succ">pure @safe S <strong id="succ">succ</strong>(S)(S s)<br><small>  Constraints: if (isSomeString!S); </small>
</dt> <dd>
<p>Return string that is the 'successor' to s[]. If the rightmost character is a-zA-Z0-9, it is incremented within its case or digits. If it generates a carry, the process is repeated with the one to its immediate left.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(succ("1")); // "2"
writeln(succ("9")); // "10"
writeln(succ("999")); // "1000"
writeln(succ("zz99")); // "aaa00"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="tr">C1[] <strong id="tr">tr</strong>(C1, C2, C3, C4 = immutable(char))(C1[] str, const(C2)[] from, const(C3)[] to, const(C4)[] modifiers = null); </dt> <dd>
<p>Replaces the characters in <code>str</code> which are in <code>from</code> with the the corresponding characters in <code>to</code> and returns the resulting string. </p>
<p><code>tr</code> is based on <a href="http://pubs.opengroup.org/onlinepubs/9699919799/utilities/tr.html">Posix's tr</a>, though it doesn't do everything that the Posix utility does. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>C1[] <code>str</code>
</td> <td>The original string.</td>
</tr> <tr>
<td>const(C2)[] <code>from</code>
</td> <td>The characters to replace.</td>
</tr> <tr>
<td>const(C3)[] <code>to</code>
</td> <td>The characters to replace with.</td>
</tr> <tr>
<td>const(C4)[] <code>modifiers</code>
</td> <td>String containing modifiers.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Modifiers</dt>

</dl>
<table>
 <tr>
<td>Modifier</td> <td>Description</td>
</tr> <tr>
<td><code>'c'</code></td> <td>Complement the list of characters in <code>from</code>
</td>
</tr> <tr>
<td><code>'d'</code></td> <td>Removes matching characters with no corresponding replacement in <code>to</code>
</td>
</tr> <tr>
<td><code>'s'</code></td> <td>Removes adjacent duplicates in the replaced characters</td>
</tr> </table>  If the modifier <code>'d'</code> is present, then the number of characters in <code>to</code> may be only <code>0</code> or <code>1</code>.  If the modifier <code>'d'</code> is <i>not</i> present, and <code>to</code> is empty, then <code>to</code> is taken to be the same as <code>from</code>.  If the modifier <code>'d'</code> is <i>not</i> present, and <code>to</code> is shorter than <code>from</code>, then <code>to</code> is extended by replicating the last character in <code>to</code>.  Both <code>from</code> and <code>to</code> may contain ranges using the <code>'-'</code> character (e.g. <code>"a-d"</code> is synonymous with <code>"abcd"</code>.) Neither accept a leading <code>'^'</code> as meaning the complement of the string (use the <code>'c'</code> modifier for that).  <dl>
<dt>See Also:</dt>
<dd>
<a href="#translate"><code>translate</code></a>, <a href="std_array.html#replace"><code>std.array.replace</code></a>, <a href="std_algorithm_iteration.html#substitute"><code>std.algorithm.iteration.substitute</code></a>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(tr("abcdef", "cd", "CD")); // "abCDef"
writeln(tr("1st March, 2018", "March", "MAR", "s")); // "1st MAR, 2018"
writeln(tr("abcdef", "ef", "", "d")); // "abcd"
writeln(tr("14-Jul-87", "a-zA-Z", " ", "cs")); // " Jul "
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isNumeric">bool <strong id="isNumeric">isNumeric</strong>(S)(S s, bool bAllowSep = false)<br><small>  Constraints: if (isSomeString!S || isRandomAccessRange!S &amp;&amp; hasSlicing!S &amp;&amp; isSomeChar!(ElementType!S) &amp;&amp; !isInfinite!S); </small>
</dt> <dd>
<p>Takes a string <code>s</code> and determines if it represents a number. This function also takes an optional parameter, <code>bAllowSep</code>, which will accept the separator characters <code>','</code> and <code>'__'</code> within the string. But these characters should be stripped from the string before using any of the conversion functions like <code>to!int()</code>, <code>to!float()</code>, and etc else an error will occur. </p>
<p>Also please note, that no spaces are allowed within the string anywhere whether it's a leading, trailing, or embedded space(s), thus they too must be stripped from the string before using this function, or any of the conversion functions. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>S <code>s</code>
</td> <td>the string or random access range to check</td>
</tr> <tr>
<td>bool <code>bAllowSep</code>
</td> <td>accept separator characters or not</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd><code>bool</code></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Integer Whole Number: (byte, ubyte, short, ushort, int, uint, long, and ulong) ['+'|'-']digit(s)[U|L|UL] <pre data-language="d">assert(isNumeric("123"));
assert(isNumeric("123UL"));
assert(isNumeric("123L"));
assert(isNumeric("+123U"));
assert(isNumeric("-123L"));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Floating-Point Number: (float, double, real, ifloat, idouble, and ireal) ['+'|'-']digit(s)[.][digit(s)][[e-|e+]digit(s)][i|f|L|Li|fi]] or [nan|nani|inf|-inf] <pre data-language="d">assert(isNumeric("+123"));
assert(isNumeric("-123.01"));
assert(isNumeric("123.3e-10f"));
assert(isNumeric("123.3e-10fi"));
assert(isNumeric("123.3e-10L"));

assert(isNumeric("nan"));
assert(isNumeric("nani"));
assert(isNumeric("-inf"));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Floating-Point Number: (cfloat, cdouble, and creal) ['+'|'-']digit(s)[.][digit(s)][[e-|e+]digit(s)][+] [digit(s)[.][digit(s)][[e-|e+]digit(s)][i|f|L|Li|fi]] or [nan|nani|nan+nani|inf|-inf] <pre data-language="d">assert(isNumeric("-123e-1+456.9e-10Li"));
assert(isNumeric("+123e+10+456i"));
assert(isNumeric("123+456"));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>isNumeric works with CTFE <pre data-language="d">enum a = isNumeric("123.00E-5+1234.45E-12Li");
enum b = isNumeric("12345xxxx890");

static assert( a);
static assert(!b);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="soundexer">char[4] <strong id="soundexer">soundexer</strong>(Range)(Range str)<br><small>  Constraints: if (isInputRange!Range &amp;&amp; isSomeChar!(ElementEncodingType!Range) &amp;&amp; !isConvertibleToString!Range); </small><br><br>char[4] <strong id="soundexer">soundexer</strong>(Range)(auto ref Range str)<br><small>  Constraints: if (isConvertibleToString!Range); </small>
</dt> <dd>
<p>Soundex algorithm. </p>
<p>The Soundex algorithm converts a word into 4 characters based on how the word sounds phonetically. The idea is that two spellings that sound alike will have the same Soundex value, which means that Soundex can be used for fuzzy matching of names. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>str</code>
</td> <td>String or InputRange to convert to Soundex representation.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The four character array with the Soundex result in it. The array has zero's in it if there is no Soundex representation for the string. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="http://en.wikipedia.org/wiki/Soundex">Wikipedia</a>, <a href="https://google.com/search?btnI=I%27m+Feeling+Lucky&amp;ie=UTF-8&amp;oe=UTF-8&amp;q=The%20Soundex%20Indexing%20System">The Soundex Indexing System</a> <a href="#soundex"><code>soundex</code></a> </dd>
</dl> <dl>
<dt>Note</dt>
<dd> Only works well with English names.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(soundexer("Gauss")); // "G200"
writeln(soundexer("Ghosh")); // "G200"

writeln(soundexer("Robert")); // "R163"
writeln(soundexer("Rupert")); // "R163"

writeln(soundexer("0123^&amp;^^**&amp;^")); // ['\0', '\0', '\0', '\0']
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="soundex">pure nothrow @safe char[] <strong id="soundex">soundex</strong>(scope const(char)[] str, char[] buffer = null); </dt> <dd>
<p>Like <a href="#soundexer"><code>soundexer</code></a>, but with different parameters and return value. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(char)[] <code>str</code>
</td> <td>String to convert to Soundex representation.</td>
</tr> <tr>
<td>char[] <code>buffer</code>
</td> <td>Optional 4 char array to put the resulting Soundex characters into. If null, the return value buffer will be allocated on the heap.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The four character array with the Soundex result in it. Returns null if there is no Soundex representation for the string. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd><a href="#soundexer"><code>soundexer</code></a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(soundex("Gauss")); // "G200"
writeln(soundex("Ghosh")); // "G200"

writeln(soundex("Robert")); // "R163"
writeln(soundex("Rupert")); // "R163"

writeln(soundex("0123^&amp;^^**&amp;^")); // null
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="abbrev">pure @safe string[string] <strong id="abbrev">abbrev</strong>(string[] values); </dt> <dd>
<p>Construct an associative array consisting of all abbreviations that uniquely map to the strings in values. </p>
<p>This is useful in cases where the user is expected to type in one of a known set of strings, and the program will helpfully auto-complete the string once sufficient characters have been entered that uniquely identify it.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.string;

static string[] list = [ "food", "foxy" ];
auto abbrevs = abbrev(list);
assert(abbrevs == ["fox": "foxy", "food": "food",
                   "foxy": "foxy", "foo": "food"]);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="column">size_t <strong id="column">column</strong>(Range)(Range str, in size_t tabsize = 8)<br><small>  Constraints: if ((isInputRange!Range &amp;&amp; isSomeChar!(Unqual!(ElementEncodingType!Range)) || isNarrowString!Range) &amp;&amp; !isConvertibleToString!Range); </small>
</dt> <dd>
<p>Compute column number at the end of the printed form of the string, assuming the string starts in the leftmost column, which is numbered starting from 0. </p>
<p>Tab characters are expanded into enough spaces to bring the column number to the next multiple of tabsize. If there are multiple lines in the string, the column number of the last line is returned. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>str</code>
</td> <td>string or InputRange to be analyzed</td>
</tr> <tr>
<td>size_t <code>tabsize</code>
</td> <td>number of columns a tab character represents</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>column number</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.utf : byChar, byWchar, byDchar;

writeln(column("1234 ")); // 5
writeln(column("1234 "w)); // 5
writeln(column("1234 "d)); // 5

writeln(column("1234 ".byChar())); // 5
writeln(column("1234 "w.byWchar())); // 5
writeln(column("1234 "d.byDchar())); // 5

// Tab stops are set at 8 spaces by default; tab characters insert enough
// spaces to bring the column position to the next multiple of 8.
writeln(column("\t")); // 8
writeln(column("1\t")); // 8
writeln(column("\t1")); // 9
writeln(column("123\t")); // 8

// Other tab widths are possible by specifying it explicitly:
writeln(column("\t", 4)); // 4
writeln(column("1\t", 4)); // 4
writeln(column("\t1", 4)); // 5
writeln(column("123\t", 4)); // 4

// New lines reset the column number.
writeln(column("abc\n")); // 0
writeln(column("abc\n1")); // 1
writeln(column("abcdefg\r1234")); // 4
writeln(column("abc\u20281")); // 1
writeln(column("abc\u20291")); // 1
writeln(column("abc\u00851")); // 1
writeln(column("abc\u00861")); // 5
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="wrap">S <strong id="wrap">wrap</strong>(S)(S s, in size_t columns = 80, S firstindent = null, S indent = null, in size_t tabsize = 8)<br><small>  Constraints: if (isSomeString!S); </small>
</dt> <dd>
<p>Wrap text into a paragraph. </p>
<p>The input text string s is formed into a paragraph by breaking it up into a sequence of lines, delineated by \n, such that the number of columns is not exceeded on each line. The last line is terminated with a \n. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>S <code>s</code>
</td> <td>text string to be wrapped</td>
</tr> <tr>
<td>size_t <code>columns</code>
</td> <td>maximum number of columns in the paragraph</td>
</tr> <tr>
<td>S <code>firstindent</code>
</td> <td>string used to indent first line of the paragraph</td>
</tr> <tr>
<td>S <code>indent</code>
</td> <td>string to use to indent following lines of the paragraph</td>
</tr> <tr>
<td>size_t <code>tabsize</code>
</td> <td>column spacing of tabs in firstindent[] and indent[]</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>resulting paragraph as an allocated string</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(wrap("a short string", 7)); // "a short\nstring\n"

// wrap will not break inside of a word, but at the next space
writeln(wrap("a short string", 4)); // "a\nshort\nstring\n"

writeln(wrap("a short string", 7, "\t")); // "\ta\nshort\nstring\n"
writeln(wrap("a short string", 7, "\t", "    ")); // "\ta\n    short\n    string\n"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="outdent">pure @safe S <strong id="outdent">outdent</strong>(S)(S str)<br><small>  Constraints: if (isSomeString!S); </small>
</dt> <dd>
<p>Removes one level of indentation from a multi-line string. </p>
<p>This uniformly outdents the text as much as possible. Whitespace-only lines are always converted to blank lines. <br><br> Does not allocate memory if it does not throw. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>S <code>str</code>
</td> <td>multi-line string</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>outdented string </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>StringException if indentation is done with different sequences of whitespace characters.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">enum pretty = q{
   import std.stdio;
   void main() {
       writeln("Hello");
   }
}.outdent();

enum ugly = q{
import std.stdio;
void main() {
writeln("Hello");
}
};

writeln(pretty); // ugly
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="outdent.2">pure @safe S[] <strong id="outdent">outdent</strong>(S)(S[] lines)<br><small>  Constraints: if (isSomeString!S); </small>
</dt> <dd>
<p>Removes one level of indentation from an array of single-line strings. </p>
<p>This uniformly outdents the text as much as possible. Whitespace-only lines are always converted to blank lines. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>S[] <code>lines</code>
</td> <td>array of single-line strings</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>lines[] is rewritten in place with outdented lines </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>StringException if indentation is done with different sequences of whitespace characters.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto str1 = [
    "    void main()\n",
    "    {\n",
    "        test();\n",
    "    }\n"
];
auto str1Expected = [
    "void main()\n",
    "{\n",
    "    test();\n",
    "}\n"
];
writeln(str1.outdent); // str1Expected

auto str2 = [
    "void main()\n",
    "    {\n",
    "            test();\n",
    "    }\n"
];
writeln(str2.outdent); // str2
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="assumeUTF">auto <strong id="assumeUTF">assumeUTF</strong>(T)(T[] arr)<br><small>  Constraints: if (staticIndexOf!(immutable(T), immutable(ubyte), immutable(ushort), immutable(uint)) != -1); </small>
</dt> <dd>
<p>Assume the given array of integers <code>arr</code> is a well-formed UTF string and return it typed as a UTF string. </p>
<p><code>ubyte</code> becomes <code>char</code>, <code>ushort</code> becomes <code>wchar</code> and <code>uint</code> becomes <code>dchar</code>. Type qualifiers are preserved. <br><br> When compiled with debug mode, this function performs an extra check to make sure the return value is a valid Unicode string. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T[] <code>arr</code>
</td> <td>array of bytes, ubytes, shorts, ushorts, ints, or uints</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>arr retyped as an array of chars, wchars, or dchars </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>In debug mode <code>AssertError</code>, when the result is not a well-formed UTF string. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd><a href="#representation"><code>representation</code></a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">string a = "Hölo World";
immutable(ubyte)[] b = a.representation;
string c = b.assumeUTF;

writeln(c); // "Hölo World"
</pre> </dd>
</dl> </dd> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1999&ndash;2021 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/std_string.html" class="_attribution-link">https://dlang.org/phobos/std_string.html</a>
  </p>
</div>
