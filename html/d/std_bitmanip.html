<h1>std.bitmanip</h1>  <p>Bit-level manipulation facilities. </p>
<p> <table>

<tr>
<th scope="col">Category</th> <th scope="col">Functions</th>
</tr> <tr>
<td>Bit constructs</td> <td> <a href="#BitArray"><code>BitArray</code></a> <a href="#bitfields"><code>bitfields</code></a> <a href="#bitsSet"><code>bitsSet</code></a> </td>
</tr> <tr>
<td>Endianness conversion</td> <td> <a href="#bigEndianToNative"><code>bigEndianToNative</code></a> <a href="#littleEndianToNative"><code>littleEndianToNative</code></a> <a href="#nativeToBigEndian"><code>nativeToBigEndian</code></a> <a href="#nativeToLittleEndian"><code>nativeToLittleEndian</code></a> <a href="#swapEndian"><code>swapEndian</code></a> </td>
</tr> <tr>
<td>Integral ranges</td> <td> <a href="#append"><code>append</code></a> <a href="#peek"><code>peek</code></a> <a href="#read"><code>read</code></a> <a href="#write"><code>write</code></a> </td>
</tr> <tr>
<td>Floating-Point manipulation</td> <td> <a href="#DoubleRep"><code>DoubleRep</code></a> <a href="#FloatRep"><code>FloatRep</code></a> </td>
</tr> <tr>
<td>Tagging</td> <td> <a href="#taggedClassRef"><code>taggedClassRef</code></a> <a href="#taggedPointer"><code>taggedPointer</code></a> </td>
</tr> </table> </p> <dl>
<dt>License:</dt>
<dd>
<a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>. </dd>
</dl> <dl>
<dt>Authors:</dt>
<dd>
<a href="http://digitalmars.com">Walter Bright</a>, <a href="http://erdani.org">Andrei Alexandrescu</a>, <a href="http://jmdavisprog.com">Jonathan M Davis</a>, Alex RÃ¸nne Petersen, Damian Ziemba, Amaury SECHET </dd>
</dl> <dl>
<dt>Source</dt>
<dd> <span class="phobos_src"><a class="https" href="https://github.com/dlang/phobos/blob/master/std/bitmanip.d">std/bitmanip.d</a></span>
</dd>
</dl> <dl>
<dt class="d_decl" id="bitfields">template <strong id="bitfields">bitfields</strong>(T...)</dt> <dd>
<p>Allows creating bit fields inside <span class="d_param">struct</span>s and <span class="d_param">class</span>es. </p>
<p>The type of a bit field can be any integral type or enumerated type. The most efficient type to store in bitfields is <span class="d_param">bool</span>, followed by unsigned types, followed by signed types. </p> <dl>
<dt>See Also:</dt>
<dd><a href="std_typecons.html#BitFlags"><code>std.typecons.BitFlags</code></a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Create a bitfield pack of eight bits, which fit in one <span class="d_param">ubyte</span>. The bitfields are allocated starting from the least significant bit, i.e. x occupies the two least significant bits of the bitfields storage. <pre data-language="d">struct A
{
    int a;
    mixin(bitfields!(
        uint, "x",    2,
        int,  "y",    3,
        uint, "z",    2,
        bool, "flag", 1));
}

A obj;
obj.x = 2;
obj.z = obj.x;

writeln(obj.x); // 2
writeln(obj.y); // 0
writeln(obj.z); // 2
writeln(obj.flag); // false
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>The sum of all bit lengths in one <span class="d_param">bitfield</span> instantiation must be exactly 8, 16, 32, or 64. If padding is needed, just allocate one bitfield with an empty name. <pre data-language="d">struct A
{
    mixin(bitfields!(
        bool, "flag1",    1,
        bool, "flag2",    1,
        uint, "",         6));
}

A a;
writeln(a.flag1); // 0
a.flag1 = 1;
writeln(a.flag1); // 1
a.flag1 = 0;
writeln(a.flag1); // 0
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>enums can be used too <pre data-language="d">enum ABC { A, B, C }
struct EnumTest
{
    mixin(bitfields!(
              ABC, "x", 2,
              bool, "y", 1,
              ubyte, "z", 5));
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="taggedPointer">enum auto <strong id="taggedPointer">taggedPointer</strong>(T : T*, string name, Ts...); </dt> <dd>
<p>This string mixin generator allows one to create tagged pointers inside <span class="d_param">struct</span>s and <span class="d_param">class</span>es. </p>
<p>A tagged pointer uses the bits known to be zero in a normal pointer or class reference to store extra information. For example, a pointer to an integer must be 4-byte aligned, so there are 2 bits that are always known to be zero. One can store a 2-bit integer there. <br><br> The example above creates a tagged pointer in the struct A. The pointer is of type <code>uint*</code> as specified by the first argument, and is named x, as specified by the second argument. <br><br> Following arguments works the same way as <code>bitfield</code>'s. The bitfield must fit into the bits known to be zero because of the pointer alignment.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">struct A
{
    int a;
    mixin(taggedPointer!(
        uint*, "x",
        bool, "b1", 1,
        bool, "b2", 1));
}
A obj;
obj.x = new uint;
obj.b1 = true;
obj.b2 = false;
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="taggedClassRef">template <strong id="taggedClassRef">taggedClassRef</strong>(T, string name, Ts...) if (is(T == class))</dt> <dd>
<p>This string mixin generator allows one to create tagged class reference inside <span class="d_param">struct</span>s and <span class="d_param">class</span>es. </p>
<p>A tagged class reference uses the bits known to be zero in a normal class reference to store extra information. For example, a pointer to an integer must be 4-byte aligned, so there are 2 bits that are always known to be zero. One can store a 2-bit integer there. <br><br> The example above creates a tagged reference to an Object in the struct A. This expects the same parameters as <code>taggedPointer</code>, except the first argument which must be a class type instead of a pointer type.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">struct A
{
    int a;
    mixin(taggedClassRef!(
        Object, "o",
        uint, "i", 2));
}
A obj;
obj.o = new Object();
obj.i = 3;
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="FloatRep">struct <strong id="FloatRep">FloatRep</strong>; </dt> <dd>
<p>Allows manipulating the fraction, exponent, and sign parts of a <span class="d_param">float</span> separately. The definition is: </p>
<p><pre data-language="d">struct FloatRep
{
    union
    {
        float value;
        mixin(bitfields!(
                  uint,  "fraction", 23,
                  ubyte, "exponent",  8,
                  bool,  "sign",      1));
    }
    enum uint bias = 127, fractionBits = 23, exponentBits = 8, signBits = 1;
}
</pre> </p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">FloatRep rep = {value: 0};
writeln(rep.fraction); // 0
writeln(rep.exponent); // 0
assert(!rep.sign);

rep.value = 42;
writeln(rep.fraction); // 2621440
writeln(rep.exponent); // 132
assert(!rep.sign);

rep.value = 10;
writeln(rep.fraction); // 2097152
writeln(rep.exponent); // 130
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">FloatRep rep = {value: 1};
writeln(rep.fraction); // 0
writeln(rep.exponent); // 127
assert(!rep.sign);

rep.exponent = 126;
writeln(rep.value); // 0.5

rep.exponent = 130;
writeln(rep.value); // 8
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">FloatRep rep = {value: 1};
rep.value = -0.5;
writeln(rep.fraction); // 0
writeln(rep.exponent); // 126
assert(rep.sign);

rep.value = -1. / 3;
writeln(rep.fraction); // 2796203
writeln(rep.exponent); // 125
assert(rep.sign);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="DoubleRep">struct <strong id="DoubleRep">DoubleRep</strong>; </dt> <dd>
<p>Allows manipulating the fraction, exponent, and sign parts of a <span class="d_param">double</span> separately. The definition is: </p>
<p><pre data-language="d">struct DoubleRep
{
    union
    {
        double value;
        mixin(bitfields!(
                  ulong,   "fraction", 52,
                  ushort,  "exponent", 11,
                  bool,    "sign",      1));
    }
    enum uint bias = 1023, signBits = 1, fractionBits = 52, exponentBits = 11;
}
</pre> </p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">DoubleRep rep = {value: 0};
writeln(rep.fraction); // 0
writeln(rep.exponent); // 0
assert(!rep.sign);

rep.value = 42;
writeln(rep.fraction); // 1407374883553280
writeln(rep.exponent); // 1028
assert(!rep.sign);

rep.value = 10;
writeln(rep.fraction); // 1125899906842624
writeln(rep.exponent); // 1026
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">DoubleRep rep = {value: 1};
writeln(rep.fraction); // 0
writeln(rep.exponent); // 1023
assert(!rep.sign);

rep.exponent = 1022;
writeln(rep.value); // 0.5

rep.exponent = 1026;
writeln(rep.value); // 8
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">DoubleRep rep = {value: 1};
rep.value = -0.5;
writeln(rep.fraction); // 0
writeln(rep.exponent); // 1022
assert(rep.sign);

rep.value = -1. / 3;
writeln(rep.fraction); // 1501199875790165
writeln(rep.exponent); // 1021
assert(rep.sign);
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Reading <pre data-language="d">DoubleRep x;
x.value = 1.0;
assert(x.fraction == 0 &amp;&amp; x.exponent == 1023 &amp;&amp; !x.sign);
x.value = -0.5;
assert(x.fraction == 0 &amp;&amp; x.exponent == 1022 &amp;&amp; x.sign);
x.value = 0.5;
assert(x.fraction == 0 &amp;&amp; x.exponent == 1022 &amp;&amp; !x.sign);
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Writing <pre data-language="d">DoubleRep x;
x.fraction = 1125899906842624;
x.exponent = 1025;
x.sign = true;
writeln(x.value); // -5.0
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="BitArray">struct <strong id="BitArray">BitArray</strong>; </dt> <dd>
<p>A dynamic array of bits. Each bit in a <code>BitArray</code> can be manipulated individually or by the standard bitwise operators <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>~</code>, <code>&gt;&gt;</code>, <code>&lt;&lt;</code> and also by other effective member functions; most of them work relative to the <code>BitArray</code>'s dimension (see <a href="#dim"><code>dim</code></a>), instead of its <a href="#length"><code>length</code></a>.</p>
<dl>
<dt>Examples:</dt>
<dd>Slicing &amp; bitsSet <pre data-language="d">import std.algorithm.comparison : equal;
import std.range : iota;

bool[] buf = new bool[64 * 3];
buf[0 .. 64] = true;
BitArray b = BitArray(buf);
assert(b.bitsSet.equal(iota(0, 64)));
b &lt;&lt;= 64;
assert(b.bitsSet.equal(iota(64, 128)));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Concatenation and appending <pre data-language="d">import std.algorithm.comparison : equal;

auto b = BitArray([1, 0]);
b ~= true;
writeln(b[2]); // 1
b ~= BitArray([0, 1]);
auto c = BitArray([1, 0, 1, 0, 1]);
writeln(b); // c
assert(b.bitsSet.equal([0, 2, 4]));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Bit flipping <pre data-language="d">import std.algorithm.comparison : equal;

auto b = BitArray([1, 1, 0, 1]);
b &amp;= BitArray([0, 1, 1, 0]);
assert(b.bitsSet.equal([1]));
b.flip;
assert(b.bitsSet.equal([0, 2, 3]));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>String format of bitarrays <pre data-language="d">import std.format : format;
auto b = BitArray([1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1]);
writeln(format("%b", b)); // "1_00001111_00001111"
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.format : format;

BitArray b;

b = BitArray([]);
writeln(format("%s", b)); // "[]"
assert(format("%b", b) is null);

b = BitArray([1]);
writeln(format("%s", b)); // "[1]"
writeln(format("%b", b)); // "1"

b = BitArray([0, 0, 0, 0]);
writeln(format("%b", b)); // "0000"

b = BitArray([0, 0, 0, 0, 1, 1, 1, 1]);
writeln(format("%s", b)); // "[0, 0, 0, 0, 1, 1, 1, 1]"
writeln(format("%b", b)); // "00001111"

b = BitArray([0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1]);
writeln(format("%s", b)); // "[0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1]"
writeln(format("%b", b)); // "00001111_00001111"

b = BitArray([1, 0, 0, 0, 0, 1, 1, 1, 1]);
writeln(format("%b", b)); // "1_00001111"

b = BitArray([1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1]);
writeln(format("%b", b)); // "1_00001111_00001111"
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="BitArray.this">pure nothrow this(in bool[] ba); </dt> <dd>
<p>Creates a <code>BitArray</code> from a <code>bool</code> array, such that <code>bool</code> values read from left to right correspond to subsequent bits in the <code>BitArray</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>bool[] <code>ba</code>
</td> <td>Source array of <code>bool</code> values.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;

bool[] input = [true, false, false, true, true];
auto a = BitArray(input);
writeln(a.length); // 5
assert(a.bitsSet.equal([0, 3, 4]));

// This also works because an implicit cast to bool[] occurs for this array.
auto b = BitArray([0, 0, 1]);
writeln(b.length); // 3
assert(b.bitsSet.equal([2]));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.array : array;
import std.range : iota, repeat;

BitArray a = true.repeat(70).array;
writeln(a.length); // 70
assert(a.bitsSet.equal(iota(0, 70)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="BitArray.this.2">pure nothrow @nogc this(void[] v, size_t numbits); </dt> <dd>
<p>Creates a <code>BitArray</code> from the raw contents of the source array. The source array is not copied but simply acts as the underlying array of bits, which stores data as <code>size_t</code> units. </p>
<p> That means a particular care should be taken when passing an array of a type different than <code>size_t</code>, firstly because its length should be a multiple of <code>size_t.sizeof</code>, and secondly because how the bits are mapped: <pre data-language="d">size_t[] source = [1, 2, 3, 3424234, 724398, 230947, 389492];
enum sbits = size_t.sizeof * 8;
auto ba = BitArray(source, source.length * sbits);
foreach (n; 0 .. source.length * sbits)
{
    auto nth_bit = cast(bool) (source[n / sbits] &amp; (1L &lt;&lt; (n % sbits)));
    assert(ba[n] == nth_bit);
}
</pre> The least significant bit in any <code>size_t</code> unit is the starting bit of this unit, and the most significant bit is the last bit of this unit. Therefore, passing e.g. an array of <code>int</code>s may result in a different <code>BitArray</code> depending on the processor's endianness. <br><br> This constructor is the inverse of <a href="#opCast"><code>opCast</code></a>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>void[] <code>v</code>
</td> <td>Source array. <code>v.length</code> must be a multple of <code>size_t.sizeof</code>.</td>
</tr> <tr>
<td>size_t <code>numbits</code>
</td> <td>Number of bits to be mapped from the source array, i.e. length of the created <code>BitArray</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;

auto a = BitArray([1, 0, 0, 1, 1]);

// Inverse of the cast.
auto v = cast(void[]) a;
auto b = BitArray(v, a.length);

writeln(b.length); // 5
assert(b.bitsSet.equal([0, 3, 4]));

// a and b share the underlying data.
a[0] = 0;
writeln(b[0]); // 0
writeln(a); // b
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;

size_t[] source = [0b1100, 0b0011];
enum sbits = size_t.sizeof * 8;
auto ba = BitArray(source, source.length * sbits);
// The least significant bit in each unit is this unit's starting bit.
assert(ba.bitsSet.equal([2, 3, sbits, sbits + 1]));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">// Example from the doc for this constructor.
static immutable size_t[] sourceData = [1, 0b101, 3, 3424234, 724398, 230947, 389492];
size_t[] source = sourceData.dup;
enum sbits = size_t.sizeof * 8;
auto ba = BitArray(source, source.length * sbits);
foreach (n; 0 .. source.length * sbits)
{
    auto nth_bit = cast(bool) (source[n / sbits] &amp; (1L &lt;&lt; (n % sbits)));
    writeln(ba[n]); // nth_bit
}

// Example of mapping only part of the array.
import std.algorithm.comparison : equal;

auto bc = BitArray(source, sbits + 1);
assert(bc.bitsSet.equal([0, sbits]));
// Source array has not been modified.
writeln(source); // sourceData
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="BitArray.dim">const pure nothrow @nogc @property @safe size_t <strong id="dim">dim</strong>(); </dt> <dd>
<dl>
<dt>Returns:</dt>
<dd>Dimension i.e. the number of native words backing this <code>BitArray</code>.  Technically, this is the length of the underlying array storing bits, which is equal to <code>ceil(length / (size_t.sizeof * 8))</code>, as bits are packed into <code>size_t</code> units.</dd>
</dl> </dd> <dt class="d_decl" id="BitArray.length">const pure nothrow @nogc @property @safe size_t <strong id="length">length</strong>(); </dt> <dd>
<dl>
<dt>Returns:</dt>
<dd>Number of bits in the <code>BitArray</code>.</dd>
</dl> </dd> <dt class="d_decl" id="BitArray.length.2">pure nothrow @property @system size_t <strong id="length">length</strong>(size_t newlen); </dt> <dd>
<p>Sets the amount of bits in the <code>BitArray</code>. <span class="red">Warning: increasing length may overwrite bits in the final word of the current underlying data regardless of whether it is shared between BitArray objects. i.e. D dynamic array extension semantics are not followed.</span></p> </dd> <dt class="d_decl" id="BitArray.opIndex">const pure nothrow @nogc bool <strong id="opIndex">opIndex</strong>(size_t i); </dt> <dd>
<p>Gets the <code>i</code>'th bit in the <code>BitArray</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static void fun(const BitArray arr)
{
    auto x = arr[0];
    writeln(x); // 1
}
BitArray a;
a.length = 3;
a[0] = 1;
fun(a);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="BitArray.opIndexAssign">pure nothrow @nogc bool <strong id="opIndexAssign">opIndexAssign</strong>(bool b, size_t i); </dt> <dd>
<p>Sets the <code>i</code>'th bit in the <code>BitArray</code>.</p> </dd> <dt class="d_decl" id="BitArray.opSliceAssign">pure nothrow @nogc void <strong id="opSliceAssign">opSliceAssign</strong>(bool val); </dt> <dd>
<p>Sets all the values in the <code>BitArray</code> to the value specified by <code>val</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;

auto b = BitArray([1, 0, 1, 0, 1, 1]);

b[] = true;
// all bits are set
assert(b.bitsSet.equal([0, 1, 2, 3, 4, 5]));

b[] = false;
// none of the bits are set
assert(b.bitsSet.empty);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="BitArray.opSliceAssign.2">pure nothrow @nogc void <strong id="opSliceAssign">opSliceAssign</strong>(bool val, size_t start, size_t end); </dt> <dd>
<p>Sets the bits of a slice of <code>BitArray</code> starting at index <code>start</code> and ends at index ($D end - 1) with the values specified by <code>val</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.range : iota;
import std.stdio;

auto b = BitArray([1, 0, 0, 0, 1, 1, 0]);
b[1 .. 3] = true;
assert(b.bitsSet.equal([0, 1, 2, 4, 5]));

bool[72] bitArray;
auto b1 = BitArray(bitArray);
b1[63 .. 67] = true;
assert(b1.bitsSet.equal([63, 64, 65, 66]));
b1[63 .. 67] = false;
assert(b1.bitsSet.empty);
b1[0 .. 64] = true;
assert(b1.bitsSet.equal(iota(0, 64)));
b1[0 .. 64] = false;
assert(b1.bitsSet.empty);

bool[256] bitArray2;
auto b2 = BitArray(bitArray2);
b2[3 .. 245] = true;
assert(b2.bitsSet.equal(iota(3, 245)));
b2[3 .. 245] = false;
assert(b2.bitsSet.empty);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="BitArray.flip">pure nothrow @nogc void <strong id="flip">flip</strong>(); </dt> <dd>
<p>Flips all the bits in the <code>BitArray</code></p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.range : iota;

// positions 0, 2, 4 are set
auto b = BitArray([1, 0, 1, 0, 1, 0]);
b.flip();
// after flipping, positions 1, 3, 5 are set
assert(b.bitsSet.equal([1, 3, 5]));

bool[270] bits;
auto b1 = BitArray(bits);
b1.flip();
assert(b1.bitsSet.equal(iota(0, 270)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="BitArray.flip.2">pure nothrow @nogc void <strong id="flip">flip</strong>(size_t i); </dt> <dd>
<p>Flips a single bit, specified by <code>pos</code></p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto ax = BitArray([1, 0, 0, 1]);
ax.flip(0);
writeln(ax[0]); // 0

bool[200] y;
y[90 .. 130] = true;
auto ay = BitArray(y);
ay.flip(100);
writeln(ay[100]); // 0
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="BitArray.count">const pure nothrow @nogc size_t <strong id="count">count</strong>(); </dt> <dd>
<p>Counts all the set bits in the <code>BitArray</code></p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto a = BitArray([0, 1, 1, 0, 0, 1, 1]);
writeln(a.count); // 4

BitArray b;
writeln(b.count); // 0

bool[200] boolArray;
boolArray[45 .. 130] = true;
auto c = BitArray(boolArray);
writeln(c.count); // 85
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="BitArray.dup">const pure nothrow @property BitArray <strong id="dup">dup</strong>(); </dt> <dd>
<p>Duplicates the <code>BitArray</code> and its contents.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">BitArray a;
BitArray b;

a.length = 3;
a[0] = 1; a[1] = 0; a[2] = 1;
b = a.dup;
writeln(b.length); // 3
foreach (i; 0 .. 3)
    writeln(b[i]); // (((i ^ 1) &amp; 1) ? true : false)
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="BitArray.opApply">int <strong id="opApply">opApply</strong>(scope int delegate(ref bool) dg); <br><br>const int <strong id="opApply">opApply</strong>(scope int delegate(bool) dg); <br><br>int <strong id="opApply">opApply</strong>(scope int delegate(size_t, ref bool) dg); <br><br>const int <strong id="opApply">opApply</strong>(scope int delegate(size_t, bool) dg); </dt> <dd>
<p>Support for <code>foreach</code> loops for <code>BitArray</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">bool[] ba = [1,0,1];

auto a = BitArray(ba);

int i;
foreach (b;a)
{
    switch (i)
    {
        case 0: assert(b == true); break;
        case 1: assert(b == false); break;
        case 2: assert(b == true); break;
        default: assert(0);
    }
    i++;
}

foreach (j,b;a)
{
    switch (j)
    {
        case 0: assert(b == true); break;
        case 1: assert(b == false); break;
        case 2: assert(b == true); break;
        default: assert(0);
    }
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="BitArray.reverse">pure nothrow @nogc @property BitArray <strong id="reverse">reverse</strong>(); </dt> <dd>
<p>Reverses the bits of the <code>BitArray</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">BitArray b;
bool[5] data = [1,0,1,1,0];

b = BitArray(data);
b.reverse;
foreach (i; 0 .. data.length)
    writeln(b[i]); // data[4 - i]
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="BitArray.sort">pure nothrow @nogc @property BitArray <strong id="sort">sort</strong>(); </dt> <dd>
<p>Sorts the <code>BitArray</code>'s elements.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">size_t x = 0b1100011000;
auto ba = BitArray(10, &amp;x);
ba.sort;
foreach (i; 0 .. 6)
    writeln(ba[i]); // false
foreach (i; 6 .. 10)
    writeln(ba[i]); // true
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="BitArray.opEquals">const pure nothrow @nogc bool <strong id="opEquals">opEquals</strong>(ref const BitArray a2); </dt> <dd>
<p>Support for operators == and != for <code>BitArray</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">bool[] ba = [1,0,1,0,1];
bool[] bb = [1,0,1];
bool[] bc = [1,0,1,0,1,0,1];
bool[] bd = [1,0,1,1,1];
bool[] be = [1,0,1,0,1];
bool[] bf = [1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
bool[] bg = [1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1];

auto a = BitArray(ba);
auto b = BitArray(bb);
auto c = BitArray(bc);
auto d = BitArray(bd);
auto e = BitArray(be);
auto f = BitArray(bf);
auto g = BitArray(bg);

assert(a != b);
assert(a != c);
assert(a != d);
writeln(a); // e
assert(f != g);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="BitArray.opCmp">const pure nothrow @nogc int <strong id="opCmp">opCmp</strong>(BitArray a2); </dt> <dd>
<p>Supports comparison operators for <code>BitArray</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">bool[] ba = [1,0,1,0,1];
bool[] bb = [1,0,1];
bool[] bc = [1,0,1,0,1,0,1];
bool[] bd = [1,0,1,1,1];
bool[] be = [1,0,1,0,1];
bool[] bf = [1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1];
bool[] bg = [1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0];

auto a = BitArray(ba);
auto b = BitArray(bb);
auto c = BitArray(bc);
auto d = BitArray(bd);
auto e = BitArray(be);
auto f = BitArray(bf);
auto g = BitArray(bg);

assert(a &gt;  b);
assert(a &gt;= b);
assert(a &lt;  c);
assert(a &lt;= c);
assert(a &lt;  d);
assert(a &lt;= d);
writeln(a); // e
assert(a &lt;= e);
assert(a &gt;= e);
assert(f &lt;  g);
assert(g &lt;= g);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="BitArray.toHash">const pure nothrow @nogc size_t <strong id="toHash">toHash</strong>(); </dt> <dd>
<p>Support for hashing for <code>BitArray</code>.</p> </dd> <dt class="d_decl" id="BitArray.opCast">inout pure nothrow @nogc inout(void)[] <strong id="opCast">opCast</strong>(T : const(void[]))(); </dt> <dd>
<p>Convert to <code>void[]</code>.</p> </dd> <dt class="d_decl" id="BitArray.opCast.2">inout pure nothrow @nogc inout(size_t)[] <strong id="opCast">opCast</strong>(T : const(size_t[]))(); </dt> <dd>
<p>Convert to <code>size_t[]</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.array : array;
import std.range : repeat, take;

// bit array with 300 elements
auto a = BitArray(true.repeat.take(300).array);
size_t[] v = cast(size_t[]) a;
const blockSize = size_t.sizeof * 8;
writeln(v.length); // (a.length + blockSize - 1) / blockSize
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="BitArray.opUnary">const pure nothrow BitArray <strong id="opUnary">opUnary</strong>(string op)()<br><small>  Constraints: if (op == "~"); </small>
</dt> <dd>
<p>Support for unary operator ~ for <code>BitArray</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">bool[] ba = [1,0,1,0,1];

auto a = BitArray(ba);
BitArray b = ~a;

writeln(b[0]); // 0
writeln(b[1]); // 1
writeln(b[2]); // 0
writeln(b[3]); // 1
writeln(b[4]); // 0
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="BitArray.opBinary">const pure nothrow BitArray <strong id="opBinary">opBinary</strong>(string op)(const BitArray e2)<br><small>  Constraints: if (op == "-" || op == "&amp;" || op == "|" || op == "^"); </small>
</dt> <dd>
<p>Support for binary bitwise operators for <code>BitArray</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static bool[] ba = [1,0,1,0,1];
static bool[] bb = [1,0,1,1,0];

auto a = BitArray(ba);
auto b = BitArray(bb);

BitArray c = a &amp; b;

writeln(c[0]); // 1
writeln(c[1]); // 0
writeln(c[2]); // 1
writeln(c[3]); // 0
writeln(c[4]); // 0
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">bool[] ba = [1,0,1,0,1];
bool[] bb = [1,0,1,1,0];

auto a = BitArray(ba);
auto b = BitArray(bb);

BitArray c = a | b;

writeln(c[0]); // 1
writeln(c[1]); // 0
writeln(c[2]); // 1
writeln(c[3]); // 1
writeln(c[4]); // 1
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">bool[] ba = [1,0,1,0,1];
bool[] bb = [1,0,1,1,0];

auto a = BitArray(ba);
auto b = BitArray(bb);

BitArray c = a ^ b;

writeln(c[0]); // 0
writeln(c[1]); // 0
writeln(c[2]); // 0
writeln(c[3]); // 1
writeln(c[4]); // 1
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">bool[] ba = [1,0,1,0,1];
bool[] bb = [1,0,1,1,0];

auto a = BitArray(ba);
auto b = BitArray(bb);

BitArray c = a - b;

writeln(c[0]); // 0
writeln(c[1]); // 0
writeln(c[2]); // 0
writeln(c[3]); // 0
writeln(c[4]); // 1
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="BitArray.opOpAssign">pure nothrow @nogc BitArray <strong id="opOpAssign">opOpAssign</strong>(string op)(const BitArray e2)<br><small>  Constraints: if (op == "-" || op == "&amp;" || op == "|" || op == "^"); </small>
</dt> <dd>
<p>Support for operator op= for <code>BitArray</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">bool[] ba = [1,0,1,0,1,1,0,1,0,1];
bool[] bb = [1,0,1,1,0];
auto a = BitArray(ba);
auto b = BitArray(bb);
BitArray c = a;
c.length = 5;
c &amp;= b;
writeln(a[5]); // 1
writeln(a[6]); // 0
writeln(a[7]); // 1
writeln(a[8]); // 0
writeln(a[9]); // 1
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">bool[] ba = [1,0,1,0,1];
bool[] bb = [1,0,1,1,0];

auto a = BitArray(ba);
auto b = BitArray(bb);

a &amp;= b;
writeln(a[0]); // 1
writeln(a[1]); // 0
writeln(a[2]); // 1
writeln(a[3]); // 0
writeln(a[4]); // 0
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">bool[] ba = [1,0,1,0,1];
bool[] bb = [1,0,1,1,0];

auto a = BitArray(ba);
auto b = BitArray(bb);

a |= b;
writeln(a[0]); // 1
writeln(a[1]); // 0
writeln(a[2]); // 1
writeln(a[3]); // 1
writeln(a[4]); // 1
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">bool[] ba = [1,0,1,0,1];
bool[] bb = [1,0,1,1,0];

auto a = BitArray(ba);
auto b = BitArray(bb);

a ^= b;
writeln(a[0]); // 0
writeln(a[1]); // 0
writeln(a[2]); // 0
writeln(a[3]); // 1
writeln(a[4]); // 1
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">bool[] ba = [1,0,1,0,1];
bool[] bb = [1,0,1,1,0];

auto a = BitArray(ba);
auto b = BitArray(bb);

a -= b;
writeln(a[0]); // 0
writeln(a[1]); // 0
writeln(a[2]); // 0
writeln(a[3]); // 0
writeln(a[4]); // 1
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="BitArray.opOpAssign.2">pure nothrow BitArray <strong id="opOpAssign">opOpAssign</strong>(string op)(bool b)<br><small>  Constraints: if (op == "~"); </small><br><br>pure nothrow BitArray <strong id="opOpAssign">opOpAssign</strong>(string op)(BitArray b)<br><small>  Constraints: if (op == "~"); </small>
</dt> <dd>
<p>Support for operator ~= for <code>BitArray</code>. <span class="red">Warning: This will overwrite a bit in the final word of the current underlying data regardless of whether it is shared between BitArray objects. i.e. D dynamic array concatenation semantics are not followed</span></p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">bool[] ba = [1,0,1,0,1];

auto a = BitArray(ba);
BitArray b;

b = (a ~= true);
writeln(a[0]); // 1
writeln(a[1]); // 0
writeln(a[2]); // 1
writeln(a[3]); // 0
writeln(a[4]); // 1
writeln(a[5]); // 1

writeln(b); // a
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">bool[] ba = [1,0];
bool[] bb = [0,1,0];

auto a = BitArray(ba);
auto b = BitArray(bb);
BitArray c;

c = (a ~= b);
writeln(a.length); // 5
writeln(a[0]); // 1
writeln(a[1]); // 0
writeln(a[2]); // 0
writeln(a[3]); // 1
writeln(a[4]); // 0

writeln(c); // a
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="BitArray.opBinary.2">const pure nothrow BitArray <strong id="opBinary">opBinary</strong>(string op)(bool b)<br><small>  Constraints: if (op == "~"); </small><br><br>const pure nothrow BitArray <strong id="opBinaryRight">opBinaryRight</strong>(string op)(bool b)<br><small>  Constraints: if (op == "~"); </small><br><br>const pure nothrow BitArray <strong id="opBinary">opBinary</strong>(string op)(BitArray b)<br><small>  Constraints: if (op == "~"); </small>
</dt> <dd>
<p>Support for binary operator ~ for <code>BitArray</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">bool[] ba = [1,0];
bool[] bb = [0,1,0];

auto a = BitArray(ba);
auto b = BitArray(bb);
BitArray c;

c = (a ~ b);
writeln(c.length); // 5
writeln(c[0]); // 1
writeln(c[1]); // 0
writeln(c[2]); // 0
writeln(c[3]); // 1
writeln(c[4]); // 0

c = (a ~ true);
writeln(c.length); // 3
writeln(c[0]); // 1
writeln(c[1]); // 0
writeln(c[2]); // 1

c = (false ~ a);
writeln(c.length); // 3
writeln(c[0]); // 0
writeln(c[1]); // 1
writeln(c[2]); // 0
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="BitArray.opOpAssign.3">pure nothrow @nogc void <strong id="opOpAssign">opOpAssign</strong>(string op)(size_t nbits)<br><small>  Constraints: if (op == "&lt;&lt;"); </small>
</dt> <dd>
<p>Operator <code>&lt;&lt;=</code> support. </p>
<p>Shifts all the bits in the array to the left by the given number of bits. The leftmost bits are dropped, and 0's are appended to the end to fill up the vacant bits. <br><br> <span class="red">Warning: unused bits in the final word up to the next word boundary may be overwritten by this operation. It does not attempt to preserve bits past the end of the array.</span></p> </dd> <dt class="d_decl" id="BitArray.opOpAssign.4">pure nothrow @nogc void <strong id="opOpAssign">opOpAssign</strong>(string op)(size_t nbits)<br><small>  Constraints: if (op == "&gt;&gt;"); </small>
</dt> <dd>
<p>Operator <code>&gt;&gt;=</code> support. </p>
<p>Shifts all the bits in the array to the right by the given number of bits. The rightmost bits are dropped, and 0's are inserted at the back to fill up the vacant bits. <br><br> <span class="red">Warning: unused bits in the final word up to the next word boundary may be overwritten by this operation. It does not attempt to preserve bits past the end of the array.</span></p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.format : format;

auto b = BitArray([1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1]);

b &lt;&lt;= 1;
writeln(format("%b", b)); // "01100_10101101"

b &gt;&gt;= 1;
writeln(format("%b", b)); // "11001_01011010"

b &lt;&lt;= 4;
writeln(format("%b", b)); // "00001_10010101"

b &gt;&gt;= 5;
writeln(format("%b", b)); // "10010_10100000"

b &lt;&lt;= 13;
writeln(format("%b", b)); // "00000_00000000"

b = BitArray([1, 0, 1, 1, 0, 1, 1, 1]);
b &gt;&gt;= 8;
writeln(format("%b", b)); // "00000000"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="BitArray.toString">const void <strong id="toString">toString</strong>(W)(ref W sink, ref scope const FormatSpec!char fmt)<br><small>  Constraints: if (isOutputRange!(W, char)); </small>
</dt> <dd>
<p>Return a string representation of this BitArray. </p>
<p>Two format specifiers are supported: <li>
<b>%s</b> which prints the bits as an array, and</li> <li>
<b>%b</b> which prints the bits as 8-bit byte packets</li> separated with an underscore. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>W <code>sink</code>
</td> <td>A <code>char</code> accepting <a href="std_range_primitives.html#isOutputRange">output range</a>.</td>
</tr> <tr>
<td>FormatSpec!char <code>fmt</code>
</td> <td>A <a href="std_format.html#FormatSpec"><code>std.format.FormatSpec</code></a> which controls how the data is displayed.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.format : format;

auto b = BitArray([0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1]);

auto s1 = format("%s", b);
writeln(s1); // "[0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1]"

auto s2 = format("%b", b);
writeln(s2); // "00001111_00001111"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="BitArray.bitsSet">const nothrow @property auto <strong id="bitsSet">bitsSet</strong>(); </dt> <dd>
<p>Return a lazy range of the indices of set bits.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;

auto b1 = BitArray([0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1]);
assert(b1.bitsSet.equal([4, 5, 6, 7, 12, 13, 14, 15]));

BitArray b2;
b2.length = 1000;
b2[333] = true;
b2[666] = true;
b2[999] = true;
assert(b2.bitsSet.equal([333, 666, 999]));
</pre> </dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="swapEndian">pure nothrow @nogc @safe T <strong id="swapEndian">swapEndian</strong>(T)(const T val)<br><small>  Constraints: if (isIntegral!T || isSomeChar!T || isBoolean!T); </small>
</dt> <dd>
<p>Swaps the endianness of the given integral value or character.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(42.swapEndian); // 704643072
assert(42.swapEndian.swapEndian == 42); // reflexive
writeln(1.swapEndian); // 16777216

writeln(true.swapEndian); // true
writeln(byte(10).swapEndian); // 10
writeln(char(10).swapEndian); // 10

writeln(ushort(10).swapEndian); // 2560
writeln(long(10).swapEndian); // 720575940379279360
writeln(ulong(10).swapEndian); // 720575940379279360
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="nativeToBigEndian">pure nothrow @nogc @safe auto <strong id="nativeToBigEndian">nativeToBigEndian</strong>(T)(const T val)<br><small>  Constraints: if (canSwapEndianness!T); </small>
</dt> <dd>
<p>Converts the given value from the native endianness to big endian and returns it as a <code>ubyte[n]</code> where <code>n</code> is the size of the given type. </p>
<p>Returning a <code>ubyte[n]</code> helps prevent accidentally using a swapped value as a regular one (and in the case of floating point values, it's necessary, because the FPU will mess up any swapped floating point values. So, you can't actually have swapped floating point values as floating point values). <br><br> <code>real</code> is not supported, because its size is implementation-dependent and therefore could vary from machine to machine (which could make it unusable if you tried to transfer it to another machine).</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int i = 12345;
ubyte[4] swappedI = nativeToBigEndian(i);
writeln(i); // bigEndianToNative!int(swappedI)

float f = 123.45f;
ubyte[4] swappedF = nativeToBigEndian(f);
writeln(f); // bigEndianToNative!float(swappedF)

const float cf = 123.45f;
ubyte[4] swappedCF = nativeToBigEndian(cf);
writeln(cf); // bigEndianToNative!float(swappedCF)

double d = 123.45;
ubyte[8] swappedD = nativeToBigEndian(d);
writeln(d); // bigEndianToNative!double(swappedD)

const double cd = 123.45;
ubyte[8] swappedCD = nativeToBigEndian(cd);
writeln(cd); // bigEndianToNative!double(swappedCD)
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="bigEndianToNative">pure nothrow @nogc @safe T <strong id="bigEndianToNative">bigEndianToNative</strong>(T, size_t n)(ubyte[n] val)<br><small>  Constraints: if (canSwapEndianness!T &amp;&amp; (n == T.sizeof)); </small>
</dt> <dd>
<p>Converts the given value from big endian to the native endianness and returns it. The value is given as a <code>ubyte[n]</code> where <code>n</code> is the size of the target type. You must give the target type as a template argument, because there are multiple types with the same size and so the type of the argument is not enough to determine the return type. </p>
<p>Taking a <code>ubyte[n]</code> helps prevent accidentally using a swapped value as a regular one (and in the case of floating point values, it's necessary, because the FPU will mess up any swapped floating point values. So, you can't actually have swapped floating point values as floating point values).</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">ushort i = 12345;
ubyte[2] swappedI = nativeToBigEndian(i);
writeln(i); // bigEndianToNative!ushort(swappedI)

dchar c = 'D';
ubyte[4] swappedC = nativeToBigEndian(c);
writeln(c); // bigEndianToNative!dchar(swappedC)
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="nativeToLittleEndian">pure nothrow @nogc @safe auto <strong id="nativeToLittleEndian">nativeToLittleEndian</strong>(T)(const T val)<br><small>  Constraints: if (canSwapEndianness!T); </small>
</dt> <dd>
<p>Converts the given value from the native endianness to little endian and returns it as a <code>ubyte[n]</code> where <code>n</code> is the size of the given type. </p>
<p>Returning a <code>ubyte[n]</code> helps prevent accidentally using a swapped value as a regular one (and in the case of floating point values, it's necessary, because the FPU will mess up any swapped floating point values. So, you can't actually have swapped floating point values as floating point values).</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int i = 12345;
ubyte[4] swappedI = nativeToLittleEndian(i);
writeln(i); // littleEndianToNative!int(swappedI)

double d = 123.45;
ubyte[8] swappedD = nativeToLittleEndian(d);
writeln(d); // littleEndianToNative!double(swappedD)
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="littleEndianToNative">pure nothrow @nogc @safe T <strong id="littleEndianToNative">littleEndianToNative</strong>(T, size_t n)(ubyte[n] val)<br><small>  Constraints: if (canSwapEndianness!T &amp;&amp; (n == T.sizeof)); </small>
</dt> <dd>
<p>Converts the given value from little endian to the native endianness and returns it. The value is given as a <code>ubyte[n]</code> where <code>n</code> is the size of the target type. You must give the target type as a template argument, because there are multiple types with the same size and so the type of the argument is not enough to determine the return type. </p>
<p>Taking a <code>ubyte[n]</code> helps prevent accidentally using a swapped value as a regular one (and in the case of floating point values, it's necessary, because the FPU will mess up any swapped floating point values. So, you can't actually have swapped floating point values as floating point values). <br><br> <code>real</code> is not supported, because its size is implementation-dependent and therefore could vary from machine to machine (which could make it unusable if you tried to transfer it to another machine).</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">ushort i = 12345;
ubyte[2] swappedI = nativeToLittleEndian(i);
writeln(i); // littleEndianToNative!ushort(swappedI)

dchar c = 'D';
ubyte[4] swappedC = nativeToLittleEndian(c);
writeln(c); // littleEndianToNative!dchar(swappedC)
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="peek">T <strong id="peek">peek</strong>(T, Endian endianness = Endian.bigEndian, R)(R range)<br><small>  Constraints: if (canSwapEndianness!T &amp;&amp; isForwardRange!R &amp;&amp; is(ElementType!R : const(ubyte))); </small><br><br>T <strong id="peek">peek</strong>(T, Endian endianness = Endian.bigEndian, R)(R range, size_t index)<br><small>  Constraints: if (canSwapEndianness!T &amp;&amp; isForwardRange!R &amp;&amp; hasSlicing!R &amp;&amp; is(ElementType!R : const(ubyte))); </small><br><br>T <strong id="peek">peek</strong>(T, Endian endianness = Endian.bigEndian, R)(R range, size_t* index)<br><small>  Constraints: if (canSwapEndianness!T &amp;&amp; isForwardRange!R &amp;&amp; hasSlicing!R &amp;&amp; is(ElementType!R : const(ubyte))); </small>
</dt> <dd>
<p>Takes a range of <code>ubyte</code>s and converts the first <code>T.sizeof</code> bytes to <code>T</code>. The value returned is converted from the given endianness to the native endianness. The range is not consumed. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T</td> <td>The integral type to convert the first <code>T.sizeof</code> bytes to.</td>
</tr> <tr>
<td>endianness</td> <td>The endianness that the bytes are assumed to be in.</td>
</tr> <tr>
<td>R <code>range</code>
</td> <td>The range to read from.</td>
</tr> <tr>
<td>size_t <code>index</code>
</td> <td>The index to start reading from (instead of starting at the front). If index is a pointer, then it is updated to the index after the bytes read. The overloads with index are only available if <code>hasSlicing!R</code> is <code>true</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">ubyte[] buffer = [1, 5, 22, 9, 44, 255, 8];
writeln(buffer.peek!uint()); // 17110537
writeln(buffer.peek!ushort()); // 261
writeln(buffer.peek!ubyte()); // 1

writeln(buffer.peek!uint(2)); // 369700095
writeln(buffer.peek!ushort(2)); // 5641
writeln(buffer.peek!ubyte(2)); // 22

size_t index = 0;
writeln(buffer.peek!ushort(&amp;index)); // 261
writeln(index); // 2

writeln(buffer.peek!uint(&amp;index)); // 369700095
writeln(index); // 6

writeln(buffer.peek!ubyte(&amp;index)); // 8
writeln(index); // 7
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.iteration : filter;
ubyte[] buffer = [1, 5, 22, 9, 44, 255, 7];
auto range = filter!"true"(buffer);
writeln(range.peek!uint()); // 17110537
writeln(range.peek!ushort()); // 261
writeln(range.peek!ubyte()); // 1
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="read">T <strong id="read">read</strong>(T, Endian endianness = Endian.bigEndian, R)(ref R range)<br><small>  Constraints: if (canSwapEndianness!T &amp;&amp; isInputRange!R &amp;&amp; is(ElementType!R : const(ubyte))); </small>
</dt> <dd>
<p>Takes a range of <code>ubyte</code>s and converts the first <code>T.sizeof</code> bytes to <code>T</code>. The value returned is converted from the given endianness to the native endianness. The <code>T.sizeof</code> bytes which are read are consumed from the range. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T</td> <td>The integral type to convert the first <code>T.sizeof</code> bytes to.</td>
</tr> <tr>
<td>endianness</td> <td>The endianness that the bytes are assumed to be in.</td>
</tr> <tr>
<td>R <code>range</code>
</td> <td>The range to read from.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.range.primitives : empty;
ubyte[] buffer = [1, 5, 22, 9, 44, 255, 8];
writeln(buffer.length); // 7

writeln(buffer.read!ushort()); // 261
writeln(buffer.length); // 5

writeln(buffer.read!uint()); // 369700095
writeln(buffer.length); // 1

writeln(buffer.read!ubyte()); // 8
assert(buffer.empty);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="write">void <strong id="write">write</strong>(T, Endian endianness = Endian.bigEndian, R)(R range, const T value, size_t index)<br><small>  Constraints: if (canSwapEndianness!T &amp;&amp; isForwardRange!R &amp;&amp; hasSlicing!R &amp;&amp; is(ElementType!R : ubyte)); </small><br><br>void <strong id="write">write</strong>(T, Endian endianness = Endian.bigEndian, R)(R range, const T value, size_t* index)<br><small>  Constraints: if (canSwapEndianness!T &amp;&amp; isForwardRange!R &amp;&amp; hasSlicing!R &amp;&amp; is(ElementType!R : ubyte)); </small>
</dt> <dd>
<p>Takes an integral value, converts it to the given endianness, and writes it to the given range of <code>ubyte</code>s as a sequence of <code>T.sizeof</code> <code>ubyte</code>s starting at index. <code>hasSlicing!R</code> must be <code>true</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T</td> <td>The integral type to convert the first <code>T.sizeof</code> bytes to.</td>
</tr> <tr>
<td>endianness</td> <td>The endianness to write the bytes in.</td>
</tr> <tr>
<td>R <code>range</code>
</td> <td>The range to write to.</td>
</tr> <tr>
<td>T <code>value</code>
</td> <td>The value to write.</td>
</tr> <tr>
<td>size_t <code>index</code>
</td> <td>The index to start writing to. If index is a pointer, then it is updated to the index after the bytes read.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">ubyte[] buffer = [0, 0, 0, 0, 0, 0, 0, 0];
buffer.write!uint(29110231u, 0);
writeln(buffer); // [1, 188, 47, 215, 0, 0, 0, 0]

buffer.write!ushort(927, 0);
writeln(buffer); // [3, 159, 47, 215, 0, 0, 0, 0]

buffer.write!ubyte(42, 0);
writeln(buffer); // [42, 159, 47, 215, 0, 0, 0, 0]
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">ubyte[] buffer = [0, 0, 0, 0, 0, 0, 0, 0, 0];
buffer.write!uint(142700095u, 2);
writeln(buffer); // [0, 0, 8, 129, 110, 63, 0, 0, 0]

buffer.write!ushort(19839, 2);
writeln(buffer); // [0, 0, 77, 127, 110, 63, 0, 0, 0]

buffer.write!ubyte(132, 2);
writeln(buffer); // [0, 0, 132, 127, 110, 63, 0, 0, 0]
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">ubyte[] buffer = [0, 0, 0, 0, 0, 0, 0, 0];
size_t index = 0;
buffer.write!ushort(261, &amp;index);
writeln(buffer); // [1, 5, 0, 0, 0, 0, 0, 0]
writeln(index); // 2

buffer.write!uint(369700095u, &amp;index);
writeln(buffer); // [1, 5, 22, 9, 44, 255, 0, 0]
writeln(index); // 6

buffer.write!ubyte(8, &amp;index);
writeln(buffer); // [1, 5, 22, 9, 44, 255, 8, 0]
writeln(index); // 7
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>bool <pre data-language="d">ubyte[] buffer = [0, 0];
buffer.write!bool(false, 0);
writeln(buffer); // [0, 0]

buffer.write!bool(true, 0);
writeln(buffer); // [1, 0]

buffer.write!bool(true, 1);
writeln(buffer); // [1, 1]

buffer.write!bool(false, 1);
writeln(buffer); // [1, 0]

size_t index = 0;
buffer.write!bool(false, &amp;index);
writeln(buffer); // [0, 0]
writeln(index); // 1

buffer.write!bool(true, &amp;index);
writeln(buffer); // [0, 1]
writeln(index); // 2
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>char(8-bit) <pre data-language="d">ubyte[] buffer = [0, 0, 0];

buffer.write!char('a', 0);
writeln(buffer); // [97, 0, 0]

buffer.write!char('b', 1);
writeln(buffer); // [97, 98, 0]

size_t index = 0;
buffer.write!char('a', &amp;index);
writeln(buffer); // [97, 98, 0]
writeln(index); // 1

buffer.write!char('b', &amp;index);
writeln(buffer); // [97, 98, 0]
writeln(index); // 2

buffer.write!char('c', &amp;index);
writeln(buffer); // [97, 98, 99]
writeln(index); // 3
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>wchar (16bit - 2x ubyte) <pre data-language="d">ubyte[] buffer = [0, 0, 0, 0];

buffer.write!wchar('Ä', 0);
writeln(buffer); // [1, 5, 0, 0]

buffer.write!wchar('â', 2);
writeln(buffer); // [1, 5, 32, 29]

size_t index = 0;
buffer.write!wchar('Ä', &amp;index);
writeln(buffer); // [1, 7, 32, 29]
writeln(index); // 2

buffer.write!wchar('Ä', &amp;index);
writeln(buffer); // [1, 7, 1, 5]
writeln(index); // 4
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>dchar (32bit - 4x ubyte) <pre data-language="d">ubyte[] buffer = [0, 0, 0, 0, 0, 0, 0, 0];

buffer.write!dchar('Ä', 0);
writeln(buffer); // [0, 0, 1, 5, 0, 0, 0, 0]

buffer.write!dchar('â', 4);
writeln(buffer); // [0, 0, 1, 5, 0, 0, 32, 29]

size_t index = 0;
buffer.write!dchar('Ä', &amp;index);
writeln(buffer); // [0, 0, 1, 7, 0, 0, 32, 29]
writeln(index); // 4

buffer.write!dchar('Ä', &amp;index);
writeln(buffer); // [0, 0, 1, 7, 0, 0, 1, 5]
writeln(index); // 8
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>float (32bit - 4x ubyte) <pre data-language="d">ubyte[] buffer = [0, 0, 0, 0, 0, 0, 0, 0];

buffer.write!float(32.0f, 0);
writeln(buffer); // [66, 0, 0, 0, 0, 0, 0, 0]

buffer.write!float(25.0f, 4);
writeln(buffer); // [66, 0, 0, 0, 65, 200, 0, 0]

size_t index = 0;
buffer.write!float(25.0f, &amp;index);
writeln(buffer); // [65, 200, 0, 0, 65, 200, 0, 0]
writeln(index); // 4

buffer.write!float(32.0f, &amp;index);
writeln(buffer); // [65, 200, 0, 0, 66, 0, 0, 0]
writeln(index); // 8
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>double (64bit - 8x ubyte) <pre data-language="d">ubyte[] buffer = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];

buffer.write!double(32.0, 0);
writeln(buffer); // [64, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

buffer.write!double(25.0, 8);
writeln(buffer); // [64, 64, 0, 0, 0, 0, 0, 0, 64, 57, 0, 0, 0, 0, 0, 0]

size_t index = 0;
buffer.write!double(25.0, &amp;index);
writeln(buffer); // [64, 57, 0, 0, 0, 0, 0, 0, 64, 57, 0, 0, 0, 0, 0, 0]
writeln(index); // 8

buffer.write!double(32.0, &amp;index);
writeln(buffer); // [64, 57, 0, 0, 0, 0, 0, 0, 64, 64, 0, 0, 0, 0, 0, 0]
writeln(index); // 16
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>enum <pre data-language="d">ubyte[] buffer = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];

enum Foo
{
    one = 10,
    two = 20,
    three = 30
}

buffer.write!Foo(Foo.one, 0);
writeln(buffer); // [0, 0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0]

buffer.write!Foo(Foo.two, 4);
writeln(buffer); // [0, 0, 0, 10, 0, 0, 0, 20, 0, 0, 0, 0]

buffer.write!Foo(Foo.three, 8);
writeln(buffer); // [0, 0, 0, 10, 0, 0, 0, 20, 0, 0, 0, 30]

size_t index = 0;
buffer.write!Foo(Foo.three, &amp;index);
writeln(buffer); // [0, 0, 0, 30, 0, 0, 0, 20, 0, 0, 0, 30]
writeln(index); // 4

buffer.write!Foo(Foo.one, &amp;index);
writeln(buffer); // [0, 0, 0, 30, 0, 0, 0, 10, 0, 0, 0, 30]
writeln(index); // 8

buffer.write!Foo(Foo.two, &amp;index);
writeln(buffer); // [0, 0, 0, 30, 0, 0, 0, 10, 0, 0, 0, 20]
writeln(index); // 12
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>enum - float <pre data-language="d">ubyte[] buffer = [0, 0, 0, 0, 0, 0, 0, 0];

enum Float: float
{
    one = 32.0f,
    two = 25.0f
}

buffer.write!Float(Float.one, 0);
writeln(buffer); // [66, 0, 0, 0, 0, 0, 0, 0]

buffer.write!Float(Float.two, 4);
writeln(buffer); // [66, 0, 0, 0, 65, 200, 0, 0]

size_t index = 0;
buffer.write!Float(Float.two, &amp;index);
writeln(buffer); // [65, 200, 0, 0, 65, 200, 0, 0]
writeln(index); // 4

buffer.write!Float(Float.one, &amp;index);
writeln(buffer); // [65, 200, 0, 0, 66, 0, 0, 0]
writeln(index); // 8
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>enum - double <pre data-language="d">ubyte[] buffer = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];

enum Double: double
{
    one = 32.0,
    two = 25.0
}

buffer.write!Double(Double.one, 0);
writeln(buffer); // [64, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

buffer.write!Double(Double.two, 8);
writeln(buffer); // [64, 64, 0, 0, 0, 0, 0, 0, 64, 57, 0, 0, 0, 0, 0, 0]

size_t index = 0;
buffer.write!Double(Double.two, &amp;index);
writeln(buffer); // [64, 57, 0, 0, 0, 0, 0, 0, 64, 57, 0, 0, 0, 0, 0, 0]
writeln(index); // 8

buffer.write!Double(Double.one, &amp;index);
writeln(buffer); // [64, 57, 0, 0, 0, 0, 0, 0, 64, 64, 0, 0, 0, 0, 0, 0]
writeln(index); // 16
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>enum - real <pre data-language="d">ubyte[] buffer = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];

enum Real: real
{
    one = 32.0,
    two = 25.0
}

static assert(!__traits(compiles, buffer.write!Real(Real.one)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="append">void <strong id="append">append</strong>(T, Endian endianness = Endian.bigEndian, R)(R range, const T value)<br><small>  Constraints: if (canSwapEndianness!T &amp;&amp; isOutputRange!(R, ubyte)); </small>
</dt> <dd>
<p>Takes an integral value, converts it to the given endianness, and appends it to the given range of <code>ubyte</code>s (using <code>put</code>) as a sequence of <code>T.sizeof</code> <code>ubyte</code>s starting at index. <code>hasSlicing!R</code> must be <code>true</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T</td> <td>The integral type to convert the first <code>T.sizeof</code> bytes to.</td>
</tr> <tr>
<td>endianness</td> <td>The endianness to write the bytes in.</td>
</tr> <tr>
<td>R <code>range</code>
</td> <td>The range to append to.</td>
</tr> <tr>
<td>T <code>value</code>
</td> <td>The value to append.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.array;
auto buffer = appender!(const ubyte[])();
buffer.append!ushort(261);
writeln(buffer.data); // [1, 5]

buffer.append!uint(369700095u);
writeln(buffer.data); // [1, 5, 22, 9, 44, 255]

buffer.append!ubyte(8);
writeln(buffer.data); // [1, 5, 22, 9, 44, 255, 8]
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>bool <pre data-language="d">import std.array : appender;
auto buffer = appender!(const ubyte[])();

buffer.append!bool(true);
writeln(buffer.data); // [1]

buffer.append!bool(false);
writeln(buffer.data); // [1, 0]
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>char wchar dchar <pre data-language="d">import std.array : appender;
auto buffer = appender!(const ubyte[])();

buffer.append!char('a');
writeln(buffer.data); // [97]

buffer.append!char('b');
writeln(buffer.data); // [97, 98]

buffer.append!wchar('Ä');
writeln(buffer.data); // [97, 98, 1, 5]

buffer.append!dchar('Ä');
    writeln(buffer.data); // [97, 98, 1, 5, 0, 0, 1, 5]
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>float double <pre data-language="d">import std.array : appender;
auto buffer = appender!(const ubyte[])();

buffer.append!float(32.0f);
writeln(buffer.data); // [66, 0, 0, 0]

buffer.append!double(32.0);
writeln(buffer.data); // [66, 0, 0, 0, 64, 64, 0, 0, 0, 0, 0, 0]
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>enum <pre data-language="d">import std.array : appender;
auto buffer = appender!(const ubyte[])();

enum Foo
{
    one = 10,
    two = 20,
    three = 30
}

buffer.append!Foo(Foo.one);
writeln(buffer.data); // [0, 0, 0, 10]

buffer.append!Foo(Foo.two);
writeln(buffer.data); // [0, 0, 0, 10, 0, 0, 0, 20]

buffer.append!Foo(Foo.three);
writeln(buffer.data); // [0, 0, 0, 10, 0, 0, 0, 20, 0, 0, 0, 30]
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>enum - bool <pre data-language="d">import std.array : appender;
auto buffer = appender!(const ubyte[])();

enum Bool: bool
{
    bfalse = false,
    btrue = true,
}

buffer.append!Bool(Bool.btrue);
writeln(buffer.data); // [1]

buffer.append!Bool(Bool.bfalse);
writeln(buffer.data); // [1, 0]

buffer.append!Bool(Bool.btrue);
writeln(buffer.data); // [1, 0, 1]
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>enum - float <pre data-language="d">import std.array : appender;
auto buffer = appender!(const ubyte[])();

enum Float: float
{
    one = 32.0f,
    two = 25.0f
}

buffer.append!Float(Float.one);
writeln(buffer.data); // [66, 0, 0, 0]

buffer.append!Float(Float.two);
writeln(buffer.data); // [66, 0, 0, 0, 65, 200, 0, 0]
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>enum - double <pre data-language="d">import std.array : appender;
auto buffer = appender!(const ubyte[])();

enum Double: double
{
    one = 32.0,
    two = 25.0
}

buffer.append!Double(Double.one);
writeln(buffer.data); // [64, 64, 0, 0, 0, 0, 0, 0]

buffer.append!Double(Double.two);
writeln(buffer.data); // [64, 64, 0, 0, 0, 0, 0, 0, 64, 57, 0, 0, 0, 0, 0, 0]
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>enum - real <pre data-language="d">import std.array : appender;
auto buffer = appender!(const ubyte[])();

enum Real: real
{
    one = 32.0,
    two = 25.0
}

static assert(!__traits(compiles, buffer.append!Real(Real.one)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="bitsSet">pure nothrow @nogc auto <strong id="bitsSet">bitsSet</strong>(T)(const T value)<br><small>  Constraints: if (isIntegral!T); </small>
</dt> <dd>
<p>Range that iterates the indices of the set bits in <code>value</code>. Index 0 corresponds to the least significant bit. For signed integers, the highest index corresponds to the sign bit.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.range : iota;

assert(bitsSet(1).equal([0]));
assert(bitsSet(5).equal([0, 2]));
assert(bitsSet(-1).equal(iota(32)));
assert(bitsSet(int.min).equal([31]));
</pre> </dd>
</dl> </dd> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1999&ndash;2021 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/std_bitmanip.html" class="_attribution-link">https://dlang.org/phobos/std_bitmanip.html</a>
  </p>
</div>
