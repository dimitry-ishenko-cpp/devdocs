<h1>std.experimental.logger.core</h1>  <dl>
<dt>Source</dt>
<dd> <span class="phobos_src"><a class="https" href="https://github.com/dlang/phobos/blob/master/std/experimental/logger/core.d">std/experimental/logger/core.d</a></span>
</dd>
</dl> <dl>
<dt class="d_decl" id="isLoggingActiveAt">template <strong id="isLoggingActiveAt">isLoggingActiveAt</strong>(LogLevel ll)</dt> <dd>
<p>This template evaluates if the passed <code>LogLevel</code> is active. The previously described version statements are used to decide if the <code>LogLevel</code> is active. The version statements only influence the compile unit they are used with, therefore this function can only disable logging this specific compile unit.</p> </dd> <dt class="d_decl" id="isLoggingActive">enum bool <strong id="isLoggingActive">isLoggingActive</strong>; </dt> <dd>
<p>This compile-time flag is <code>true</code> if logging is not statically disabled.</p> </dd> <dt class="d_decl" id="isLoggingEnabled">@safe bool <strong id="isLoggingEnabled">isLoggingEnabled</strong>()(LogLevel ll, LogLevel loggerLL, LogLevel globalLL, lazy bool condition = true); </dt> <dd>
<p>This functions is used at runtime to determine if a <code>LogLevel</code> is active. The same previously defined version statements are used to disable certain levels. Again the version statements are associated with a compile unit and can therefore not disable logging in other compile units. pure bool isLoggingEnabled()(LogLevel ll) @safe nothrow @nogc</p> </dd> <dt class="d_decl" id="moduleLogLevel">template <strong id="moduleLogLevel">moduleLogLevel</strong>(string moduleName) if (!moduleName.length)<br><br>template <strong id="moduleLogLevel">moduleLogLevel</strong>(string moduleName) if (moduleName.length)</dt> <dd>
<p>This template returns the <code>LogLevel</code> named "logLevel" of type <code>LogLevel</code> defined in a user defined module where the filename has the suffix "loggerconfig.d". This <code>LogLevel</code> sets the minimal <code>LogLevel</code> of the module. </p>
<p>A minimal <code>LogLevel</code> can be defined on a per module basis. In order to define a module <code>LogLevel</code> a file with a modulename "MODULENAME_loggerconfig" must be found. If no such module exists and the module is a nested module, it is checked if there exists a "PARENT_MODULE_loggerconfig" module with such a symbol. If this module exists and it contains a <code>LogLevel</code> called logLevel this <code>LogLevel</code> will be used. This parent lookup is continued until there is no parent module. Then the moduleLogLevel is <code>LogLevel.all</code>.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(moduleLogLevel!"" == LogLevel.all);
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(moduleLogLevel!"not.amodule.path" == LogLevel.all);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="log">void <strong id="log">log</strong>(int line = __LINE__, string file = __FILE__, string funcName = __FUNCTION__, string prettyFuncName = __PRETTY_FUNCTION__, string moduleName = __MODULE__, A...)(const LogLevel ll, lazy bool condition, lazy A args)<br><small>  Constraints: if (args.length != 1); </small><br><br>void <strong id="log">log</strong>(T, string moduleName = __MODULE__)(const LogLevel ll, lazy bool condition, lazy T arg, int line = __LINE__, string file = __FILE__, string funcName = __FUNCTION__, string prettyFuncName = __PRETTY_FUNCTION__); </dt> <dd>
<p>This function logs data. </p>
<p>In order for the data to be processed, the <code>LogLevel</code> of the log call must be greater or equal to the <code>LogLevel</code> of the <code>sharedLog</code> and the <code>defaultLogLevel</code>; additionally the condition passed must be <code>true</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>LogLevel <code>ll</code>
</td> <td>The <code>LogLevel</code> used by this log call.</td>
</tr> <tr>
<td>bool <code>condition</code>
</td> <td>The condition must be <code>true</code> for the data to be logged.</td>
</tr> <tr>
<td>A <code>args</code>
</td> <td>The data that should be logged.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">log(LogLevel.warning, true, "Hello World", 3.1415);
</pre>  </dd> <dt class="d_decl" id="log.2">void <strong id="log">log</strong>(int line = __LINE__, string file = __FILE__, string funcName = __FUNCTION__, string prettyFuncName = __PRETTY_FUNCTION__, string moduleName = __MODULE__, A...)(const LogLevel ll, lazy A args)<br><small>  Constraints: if (args.length &gt; 1 &amp;&amp; !is(Unqual!(A[0]) : bool)); </small><br><br>void <strong id="log">log</strong>(T, string moduleName = __MODULE__)(const LogLevel ll, lazy T arg, int line = __LINE__, string file = __FILE__, string funcName = __FUNCTION__, string prettyFuncName = __PRETTY_FUNCTION__); </dt> <dd>
<p>This function logs data. </p>
<p>In order for the data to be processed the <code>LogLevel</code> of the log call must be greater or equal to the <code>LogLevel</code> of the <code>sharedLog</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>LogLevel <code>ll</code>
</td> <td>The <code>LogLevel</code> used by this log call.</td>
</tr> <tr>
<td>A <code>args</code>
</td> <td>The data that should be logged.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">log(LogLevel.warning, "Hello World", 3.1415);
</pre>  </dd> <dt class="d_decl" id="log.3">void <strong id="log">log</strong>(int line = __LINE__, string file = __FILE__, string funcName = __FUNCTION__, string prettyFuncName = __PRETTY_FUNCTION__, string moduleName = __MODULE__, A...)(lazy bool condition, lazy A args)<br><small>  Constraints: if (args.length != 1); </small><br><br>void <strong id="log">log</strong>(T, string moduleName = __MODULE__)(lazy bool condition, lazy T arg, int line = __LINE__, string file = __FILE__, string funcName = __FUNCTION__, string prettyFuncName = __PRETTY_FUNCTION__); </dt> <dd>
<p>This function logs data. </p>
<p>In order for the data to be processed the <code>LogLevel</code> of the <code>sharedLog</code> must be greater or equal to the <code>defaultLogLevel</code> add the condition passed must be <code>true</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>bool <code>condition</code>
</td> <td>The condition must be <code>true</code> for the data to be logged.</td>
</tr> <tr>
<td>A <code>args</code>
</td> <td>The data that should be logged.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">log(true, "Hello World", 3.1415);
</pre>  </dd> <dt class="d_decl" id="log.4">void <strong id="log">log</strong>(int line = __LINE__, string file = __FILE__, string funcName = __FUNCTION__, string prettyFuncName = __PRETTY_FUNCTION__, string moduleName = __MODULE__, A...)(lazy A args)<br><small>  Constraints: if (args.length &gt; 1 &amp;&amp; !is(Unqual!(A[0]) : bool) &amp;&amp; !is(Unqual!(A[0]) == LogLevel) || args.length == 0); </small>
</dt> <dd>
<p>This function logs data. </p>
<p>In order for the data to be processed the <code>LogLevel</code> of the <code>sharedLog</code> must be greater or equal to the <code>defaultLogLevel</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>A <code>args</code>
</td> <td>The data that should be logged.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">log("Hello World", 3.1415);
</pre>  </dd> <dt class="d_decl" id="logf">void <strong id="logf">logf</strong>(int line = __LINE__, string file = __FILE__, string funcName = __FUNCTION__, string prettyFuncName = __PRETTY_FUNCTION__, string moduleName = __MODULE__, A...)(const LogLevel ll, lazy bool condition, lazy string msg, lazy A args); </dt> <dd>
<p>This function logs data in a <code>printf</code>-style manner. </p>
<p>In order for the data to be processed the <code>LogLevel</code> of the log call must be greater or equal to the <code>LogLevel</code> of the <code>sharedLog</code> and the <code>defaultLogLevel</code> additionally the condition passed must be <code>true</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>LogLevel <code>ll</code>
</td> <td>The <code>LogLevel</code> used by this log call.</td>
</tr> <tr>
<td>bool <code>condition</code>
</td> <td>The condition must be <code>true</code> for the data to be logged.</td>
</tr> <tr>
<td>string <code>msg</code>
</td> <td>The <code>printf</code>-style string.</td>
</tr> <tr>
<td>A <code>args</code>
</td> <td>The data that should be logged.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">logf(LogLevel.warning, true, "Hello World %f", 3.1415);
</pre>  </dd> <dt class="d_decl" id="logf.2">void <strong id="logf">logf</strong>(int line = __LINE__, string file = __FILE__, string funcName = __FUNCTION__, string prettyFuncName = __PRETTY_FUNCTION__, string moduleName = __MODULE__, A...)(const LogLevel ll, lazy string msg, lazy A args); </dt> <dd>
<p>This function logs data in a <code>printf</code>-style manner. </p>
<p>In order for the data to be processed the <code>LogLevel</code> of the log call must be greater or equal to the <code>LogLevel</code> of the <code>sharedLog</code> and the <code>defaultLogLevel</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>LogLevel <code>ll</code>
</td> <td>The <code>LogLevel</code> used by this log call.</td>
</tr> <tr>
<td>string <code>msg</code>
</td> <td>The <code>printf</code>-style string.</td>
</tr> <tr>
<td>A <code>args</code>
</td> <td>The data that should be logged.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">logf(LogLevel.warning, "Hello World %f", 3.1415);
</pre>  </dd> <dt class="d_decl" id="logf.3">void <strong id="logf">logf</strong>(int line = __LINE__, string file = __FILE__, string funcName = __FUNCTION__, string prettyFuncName = __PRETTY_FUNCTION__, string moduleName = __MODULE__, A...)(lazy bool condition, lazy string msg, lazy A args); </dt> <dd>
<p>This function logs data in a <code>printf</code>-style manner. </p>
<p>In order for the data to be processed the <code>LogLevel</code> of the log call must be greater or equal to the <code>defaultLogLevel</code> additionally the condition passed must be <code>true</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>bool <code>condition</code>
</td> <td>The condition must be <code>true</code> for the data to be logged.</td>
</tr> <tr>
<td>string <code>msg</code>
</td> <td>The <code>printf</code>-style string.</td>
</tr> <tr>
<td>A <code>args</code>
</td> <td>The data that should be logged.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">logf(true, "Hello World %f", 3.1415);
</pre>  </dd> <dt class="d_decl" id="logf.4">void <strong id="logf">logf</strong>(int line = __LINE__, string file = __FILE__, string funcName = __FUNCTION__, string prettyFuncName = __PRETTY_FUNCTION__, string moduleName = __MODULE__, A...)(lazy string msg, lazy A args); </dt> <dd>
<p>This function logs data in a <code>printf</code>-style manner. </p>
<p>In order for the data to be processed the <code>LogLevel</code> of the log call must be greater or equal to the <code>defaultLogLevel</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>string <code>msg</code>
</td> <td>The <code>printf</code>-style string.</td>
</tr> <tr>
<td>A <code>args</code>
</td> <td>The data that should be logged.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">logf("Hello World %f", 3.1415);
</pre>  </dd> <dt class="d_decl" id="defaultLogFunction">template <strong id="defaultLogFunction">defaultLogFunction</strong>(LogLevel ll)</dt> <dd>
<p>This template provides the global log functions with the <code>LogLevel</code> is encoded in the function name. </p>
<p>The aliases following this template create the public names of these log functions.</p> </dd> <dt class="d_decl" id="trace">alias <strong id="trace">trace</strong> = defaultLogFunction!LogLevel.<strong id="trace">trace</strong>.defaultLogFunction(int line = __LINE__, string file = __FILE__, string funcName = __FUNCTION__, string prettyFuncName = __PRETTY_FUNCTION__, string moduleName = __MODULE__, A...)(lazy A args) if (args.length &gt; 0 &amp;&amp; !is(Unqual!(A[0]) : bool) || args.length == 0); <br><br>alias <strong id="info">info</strong> = defaultLogFunction!LogLevel.<strong id="info">info</strong>.defaultLogFunction(int line = __LINE__, string file = __FILE__, string funcName = __FUNCTION__, string prettyFuncName = __PRETTY_FUNCTION__, string moduleName = __MODULE__, A...)(lazy A args) if (args.length &gt; 0 &amp;&amp; !is(Unqual!(A[0]) : bool) || args.length == 0); <br><br>alias <strong id="warning">warning</strong> = defaultLogFunction!LogLevel.<strong id="warning">warning</strong>.defaultLogFunction(int line = __LINE__, string file = __FILE__, string funcName = __FUNCTION__, string prettyFuncName = __PRETTY_FUNCTION__, string moduleName = __MODULE__, A...)(lazy A args) if (args.length &gt; 0 &amp;&amp; !is(Unqual!(A[0]) : bool) || args.length == 0); <br><br>alias <strong id="error">error</strong> = defaultLogFunction!LogLevel.<strong id="error">error</strong>.defaultLogFunction(int line = __LINE__, string file = __FILE__, string funcName = __FUNCTION__, string prettyFuncName = __PRETTY_FUNCTION__, string moduleName = __MODULE__, A...)(lazy A args) if (args.length &gt; 0 &amp;&amp; !is(Unqual!(A[0]) : bool) || args.length == 0); <br><br>alias <strong id="critical">critical</strong> = defaultLogFunction!LogLevel.<strong id="critical">critical</strong>.defaultLogFunction(int line = __LINE__, string file = __FILE__, string funcName = __FUNCTION__, string prettyFuncName = __PRETTY_FUNCTION__, string moduleName = __MODULE__, A...)(lazy A args) if (args.length &gt; 0 &amp;&amp; !is(Unqual!(A[0]) : bool) || args.length == 0); <br><br>alias <strong id="fatal">fatal</strong> = defaultLogFunction!LogLevel.<strong id="fatal">fatal</strong>.defaultLogFunction(int line = __LINE__, string file = __FILE__, string funcName = __FUNCTION__, string prettyFuncName = __PRETTY_FUNCTION__, string moduleName = __MODULE__, A...)(lazy A args) if (args.length &gt; 0 &amp;&amp; !is(Unqual!(A[0]) : bool) || args.length == 0); </dt> <dd>
<p>This function logs data to the <code>stdThreadLocalLog</code>, optionally depending on a condition. </p>
<p>In order for the resulting log message to be logged the <code>LogLevel</code> must be greater or equal than the <code>LogLevel</code> of the <code>stdThreadLocalLog</code> and must be greater or equal than the global <code>LogLevel</code>. Additionally the <code>LogLevel</code> must be greater or equal than the <code>LogLevel</code> of the <code>stdSharedLogger</code>. If a condition is given, it must evaluate to <code>true</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>bool condition</td> <td>The condition must be <code>true</code> for the data to be logged.</td>
</tr> <tr>
<td>A args</td> <td>The data that should be logged.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">trace(1337, "is number");
info(1337, "is number");
error(1337, "is number");
critical(1337, "is number");
fatal(1337, "is number");
trace(true, 1337, "is number");
info(false, 1337, "is number");
error(true, 1337, "is number");
critical(false, 1337, "is number");
fatal(true, 1337, "is number");
</pre>  </dd> <dt class="d_decl" id="defaultLogFunctionf">template <strong id="defaultLogFunctionf">defaultLogFunctionf</strong>(LogLevel ll)</dt> <dd>
<p>This template provides the global <code>printf</code>-style log functions with the <code>LogLevel</code> is encoded in the function name. </p>
<p>The aliases following this template create the public names of the log functions.</p> </dd> <dt class="d_decl" id="tracef">alias <strong id="tracef">tracef</strong> = defaultLogFunctionf!LogLevel.trace.defaultLogFunctionf(int line = __LINE__, string file = __FILE__, string funcName = __FUNCTION__, string prettyFuncName = __PRETTY_FUNCTION__, string moduleName = __MODULE__, A...)(lazy string msg, lazy A args); <br><br>alias <strong id="infof">infof</strong> = defaultLogFunctionf!LogLevel.info.defaultLogFunctionf(int line = __LINE__, string file = __FILE__, string funcName = __FUNCTION__, string prettyFuncName = __PRETTY_FUNCTION__, string moduleName = __MODULE__, A...)(lazy string msg, lazy A args); <br><br>alias <strong id="warningf">warningf</strong> = defaultLogFunctionf!LogLevel.warning.defaultLogFunctionf(int line = __LINE__, string file = __FILE__, string funcName = __FUNCTION__, string prettyFuncName = __PRETTY_FUNCTION__, string moduleName = __MODULE__, A...)(lazy string msg, lazy A args); <br><br>alias <strong id="errorf">errorf</strong> = defaultLogFunctionf!LogLevel.error.defaultLogFunctionf(int line = __LINE__, string file = __FILE__, string funcName = __FUNCTION__, string prettyFuncName = __PRETTY_FUNCTION__, string moduleName = __MODULE__, A...)(lazy string msg, lazy A args); <br><br>alias <strong id="criticalf">criticalf</strong> = defaultLogFunctionf!LogLevel.critical.defaultLogFunctionf(int line = __LINE__, string file = __FILE__, string funcName = __FUNCTION__, string prettyFuncName = __PRETTY_FUNCTION__, string moduleName = __MODULE__, A...)(lazy string msg, lazy A args); <br><br>alias <strong id="fatalf">fatalf</strong> = defaultLogFunctionf!LogLevel.fatal.defaultLogFunctionf(int line = __LINE__, string file = __FILE__, string funcName = __FUNCTION__, string prettyFuncName = __PRETTY_FUNCTION__, string moduleName = __MODULE__, A...)(lazy string msg, lazy A args); </dt> <dd>
<p>This function logs data to the <code>sharedLog</code> in a <code>printf</code>-style manner. </p>
<p>In order for the resulting log message to be logged the <code>LogLevel</code> must be greater or equal than the <code>LogLevel</code> of the <code>sharedLog</code> and must be greater or equal than the global <code>LogLevel</code>. Additionally the <code>LogLevel</code> must be greater or equal than the <code>LogLevel</code> of the <code>stdSharedLogger</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>string msg</td> <td>The <code>printf</code>-style string.</td>
</tr> <tr>
<td>A args</td> <td>The data that should be logged.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">tracef("is number %d", 1);
infof("is number %d", 2);
errorf("is number %d", 3);
criticalf("is number %d", 4);
fatalf("is number %d", 5);
</pre>  The second version of the function logs data to the <code>sharedLog</code> in a <code>printf</code>-style manner.  In order for the resulting log message to be logged the <code>LogLevel</code> must be greater or equal than the <code>LogLevel</code> of the <code>sharedLog</code> and must be greater or equal than the global <code>LogLevel</code>. Additionally the <code>LogLevel</code> must be greater or equal than the <code>LogLevel</code> of the <code>stdSharedLogger</code>.  <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>bool condition</td> <td>The condition must be <code>true</code> for the data to be logged.</td>
</tr> <tr>
<td>string msg</td> <td>The <code>printf</code>-style string.</td>
</tr> <tr>
<td>A args</td> <td>The data that should be logged.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">tracef(false, "is number %d", 1);
infof(false, "is number %d", 2);
errorf(true, "is number %d", 3);
criticalf(true, "is number %d", 4);
fatalf(someFunct(), "is number %d", 5);
</pre>  </dd> <dt class="d_decl" id="LogLevel">enum <strong id="LogLevel">LogLevel</strong>: ubyte; </dt> <dd>
<p>There are eight usable logging level. These level are <i>all</i>, <i>trace</i>, <i>info</i>, <i>warning</i>, <i>error</i>, <i>critical</i>, <i>fatal</i>, and <i>off</i>. If a log function with <code>LogLevel.fatal</code> is called the shutdown handler of that logger is called.</p> <dl>
<dt class="d_decl" id="LogLevel.all"><strong id="all">all</strong></dt> <dd>
<p>Lowest possible assignable <code>LogLevel</code>.</p> </dd> <dt class="d_decl" id="LogLevel.trace"><strong id="trace">trace</strong></dt> <dd>
<p><code>LogLevel</code> for tracing the execution of the program.</p> </dd> <dt class="d_decl" id="LogLevel.info"><strong id="info">info</strong></dt> <dd>
<p>This level is used to display information about the program.</p> </dd> <dt class="d_decl" id="LogLevel.warning"><strong id="warning">warning</strong></dt> <dd>
<p>warnings about the program should be displayed with this level.</p> </dd> <dt class="d_decl" id="LogLevel.error"><strong id="error">error</strong></dt> <dd>
<p>Information about errors should be logged with this level.</p> </dd> <dt class="d_decl" id="LogLevel.critical"><strong id="critical">critical</strong></dt> <dd>
<p>Messages that inform about critical errors should be logged with this level.</p> </dd> <dt class="d_decl" id="LogLevel.fatal"><strong id="fatal">fatal</strong></dt> <dd>
<p>Log messages that describe fatal errors should use this level.</p> </dd> <dt class="d_decl" id="LogLevel.off"><strong id="off">off</strong></dt> <dd>
<p>Highest possible <code>LogLevel</code>.</p> </dd> </dl> </dd> <dt class="d_decl" id="Logger">abstract class <strong id="Logger">Logger</strong>; </dt> <dd>
<p>This class is the base of every logger. In order to create a new kind of logger a deriving class needs to implement the <code>writeLogMsg</code> method. By default this is not thread-safe. </p>
<p>It is also possible to <code>override</code> the three methods <code>beginLogMsg</code>, <code>logMsgPart</code> and <code>finishLogMsg</code> together, this option gives more flexibility.</p> <dl>
<dt class="d_decl" id="Logger.LogEntry">struct <strong id="LogEntry">LogEntry</strong>; </dt> <dd>
<p>LogEntry is a aggregation combining all information associated with a log message. This aggregation will be passed to the method writeLogMsg.</p> <dl>
<dt class="d_decl" id="Logger.LogEntry.file">string <strong id="file">file</strong>; </dt> <dd>
<p>the filename the log function was called from</p> </dd> <dt class="d_decl" id="Logger.LogEntry.line">int <strong id="line">line</strong>; </dt> <dd>
<p>the line number the log function was called from</p> </dd> <dt class="d_decl" id="Logger.LogEntry.funcName">string <strong id="funcName">funcName</strong>; </dt> <dd>
<p>the name of the function the log function was called from</p> </dd> <dt class="d_decl" id="Logger.LogEntry.prettyFuncName">string <strong id="prettyFuncName">prettyFuncName</strong>; </dt> <dd>
<p>the pretty formatted name of the function the log function was called from</p> </dd> <dt class="d_decl" id="Logger.LogEntry.moduleName">string <strong id="moduleName">moduleName</strong>; </dt> <dd>
<p>the name of the module the log message is coming from</p> </dd> <dt class="d_decl" id="Logger.LogEntry.logLevel">LogLevel <strong id="logLevel">logLevel</strong>; </dt> <dd>
<p>the <code>LogLevel</code> associated with the log message</p> </dd> <dt class="d_decl" id="Logger.LogEntry.threadId">Tid <strong id="threadId">threadId</strong>; </dt> <dd>
<p>thread id of the log message</p> </dd> <dt class="d_decl" id="Logger.LogEntry.timestamp">SysTime <strong id="timestamp">timestamp</strong>; </dt> <dd>
<p>the time the message was logged</p> </dd> <dt class="d_decl" id="Logger.LogEntry.msg">string <strong id="msg">msg</strong>; </dt> <dd>
<p>the message of the log message</p> </dd> <dt class="d_decl" id="Logger.LogEntry.logger">Logger <strong id="logger">logger</strong>; </dt> <dd>
<p>A refernce to the <code>Logger</code> used to create this <code>LogEntry</code></p> </dd> </dl> </dd> <dt class="d_decl" id="Logger.this">@safe this(LogLevel lv); </dt> <dd>
<p>Every subclass of <code>Logger</code> has to call this constructor from their constructor. It sets the <code>LogLevel</code>, and creates a fatal handler. The fatal handler will throw an <code>Error</code> if a log call is made with level <code>LogLevel.fatal</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>LogLevel <code>lv</code>
</td> <td>
<code>LogLevel</code> to use for this <code>Logger</code> instance.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="Logger.writeLogMsg">protected abstract @safe void <strong id="writeLogMsg">writeLogMsg</strong>(ref LogEntry payload); </dt> <dd>
<p>A custom logger must implement this method in order to work in a <code>MultiLogger</code> and <code>ArrayLogger</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>LogEntry <code>payload</code>
</td> <td>All information associated with call to log function.</td>
</tr> </table></dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>beginLogMsg, logMsgPart, finishLogMsg</dd>
</dl> </dd> <dt class="d_decl" id="Logger.logMsgPart">protected @safe void <strong id="logMsgPart">logMsgPart</strong>(scope const(char)[] msg); </dt> <dd>
<p>Logs a part of the log message.</p> </dd> <dt class="d_decl" id="Logger.finishLogMsg">protected @safe void <strong id="finishLogMsg">finishLogMsg</strong>(); </dt> <dd>
<p>Signals that the message has been written and no more calls to <code>logMsgPart</code> follow.</p> </dd> <dt class="d_decl" id="Logger.logLevel">final const pure @nogc @property @safe LogLevel <strong id="logLevel">logLevel</strong>(); <br><br>final @nogc @property @safe void <strong id="logLevel">logLevel</strong>(const LogLevel lv); </dt> <dd>
<p>The <code>LogLevel</code> determines if the log call are processed or dropped by the <code>Logger</code>. In order for the log call to be processed the <code>LogLevel</code> of the log call must be greater or equal to the <code>LogLevel</code> of the <code>logger</code>. </p>
<p>These two methods set and get the <code>LogLevel</code> of the used <code>Logger</code>. </p> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto f = new FileLogger(stdout);
f.logLevel = LogLevel.info;
assert(f.logLevel == LogLevel.info);
</pre>  </dd> <dt class="d_decl" id="Logger.fatalHandler">final @nogc @property @safe void delegate() <strong id="fatalHandler">fatalHandler</strong>(); <br><br>final @nogc @property @safe void <strong id="fatalHandler">fatalHandler</strong>(void delegate() @safe fh); </dt> <dd>
<p>This <code>delegate</code> is called in case a log message with <code>LogLevel.fatal</code> gets logged. </p>
<p>By default an <code>Error</code> will be thrown.</p> </dd> <dt class="d_decl" id="Logger.forwardMsg">@trusted void <strong id="forwardMsg">forwardMsg</strong>(ref LogEntry payload); </dt> <dd>
<p>This method allows forwarding log entries from one logger to another. </p>
<p><code>forwardMsg</code> will ensure proper synchronization and then call <code>writeLogMsg</code>. This is an API for implementing your own loggers and should not be called by normal user code. A notable difference from other logging functions is that the <code>globalLogLevel</code> wont be evaluated again since it is assumed that the caller already checked that.</p> </dd> <dt class="d_decl" id="Logger.memLogFunctions">template <strong id="memLogFunctions">memLogFunctions</strong>(LogLevel ll)<br><br>alias <strong id="trace">trace</strong> = .Logger.memLogFunctions!LogLevel.<strong id="trace">trace</strong>.logImpl(int line = __LINE__, string file = __FILE__, string funcName = __FUNCTION__, string prettyFuncName = __PRETTY_FUNCTION__, string moduleName = __MODULE__, A...)(lazy A args) if (args.length == 0 || args.length &gt; 0 &amp;&amp; !is(A[0] : bool)); <br><br>alias <strong id="tracef">tracef</strong> = .Logger.memLogFunctions!LogLevel.trace.logImplf(int line = __LINE__, string file = __FILE__, string funcName = __FUNCTION__, string prettyFuncName = __PRETTY_FUNCTION__, string moduleName = __MODULE__, A...)(lazy bool condition, lazy string msg, lazy A args); <br><br>alias <strong id="info">info</strong> = .Logger.memLogFunctions!LogLevel.<strong id="info">info</strong>.logImpl(int line = __LINE__, string file = __FILE__, string funcName = __FUNCTION__, string prettyFuncName = __PRETTY_FUNCTION__, string moduleName = __MODULE__, A...)(lazy A args) if (args.length == 0 || args.length &gt; 0 &amp;&amp; !is(A[0] : bool)); <br><br>alias <strong id="infof">infof</strong> = .Logger.memLogFunctions!LogLevel.info.logImplf(int line = __LINE__, string file = __FILE__, string funcName = __FUNCTION__, string prettyFuncName = __PRETTY_FUNCTION__, string moduleName = __MODULE__, A...)(lazy bool condition, lazy string msg, lazy A args); <br><br>alias <strong id="warning">warning</strong> = .Logger.memLogFunctions!LogLevel.<strong id="warning">warning</strong>.logImpl(int line = __LINE__, string file = __FILE__, string funcName = __FUNCTION__, string prettyFuncName = __PRETTY_FUNCTION__, string moduleName = __MODULE__, A...)(lazy A args) if (args.length == 0 || args.length &gt; 0 &amp;&amp; !is(A[0] : bool)); <br><br>alias <strong id="warningf">warningf</strong> = .Logger.memLogFunctions!LogLevel.warning.logImplf(int line = __LINE__, string file = __FILE__, string funcName = __FUNCTION__, string prettyFuncName = __PRETTY_FUNCTION__, string moduleName = __MODULE__, A...)(lazy bool condition, lazy string msg, lazy A args); <br><br>alias <strong id="error">error</strong> = .Logger.memLogFunctions!LogLevel.<strong id="error">error</strong>.logImpl(int line = __LINE__, string file = __FILE__, string funcName = __FUNCTION__, string prettyFuncName = __PRETTY_FUNCTION__, string moduleName = __MODULE__, A...)(lazy A args) if (args.length == 0 || args.length &gt; 0 &amp;&amp; !is(A[0] : bool)); <br><br>alias <strong id="errorf">errorf</strong> = .Logger.memLogFunctions!LogLevel.error.logImplf(int line = __LINE__, string file = __FILE__, string funcName = __FUNCTION__, string prettyFuncName = __PRETTY_FUNCTION__, string moduleName = __MODULE__, A...)(lazy bool condition, lazy string msg, lazy A args); <br><br>alias <strong id="critical">critical</strong> = .Logger.memLogFunctions!LogLevel.<strong id="critical">critical</strong>.logImpl(int line = __LINE__, string file = __FILE__, string funcName = __FUNCTION__, string prettyFuncName = __PRETTY_FUNCTION__, string moduleName = __MODULE__, A...)(lazy A args) if (args.length == 0 || args.length &gt; 0 &amp;&amp; !is(A[0] : bool)); <br><br>alias <strong id="criticalf">criticalf</strong> = .Logger.memLogFunctions!LogLevel.critical.logImplf(int line = __LINE__, string file = __FILE__, string funcName = __FUNCTION__, string prettyFuncName = __PRETTY_FUNCTION__, string moduleName = __MODULE__, A...)(lazy bool condition, lazy string msg, lazy A args); <br><br>alias <strong id="fatal">fatal</strong> = .Logger.memLogFunctions!LogLevel.<strong id="fatal">fatal</strong>.logImpl(int line = __LINE__, string file = __FILE__, string funcName = __FUNCTION__, string prettyFuncName = __PRETTY_FUNCTION__, string moduleName = __MODULE__, A...)(lazy A args) if (args.length == 0 || args.length &gt; 0 &amp;&amp; !is(A[0] : bool)); <br><br>alias <strong id="fatalf">fatalf</strong> = .Logger.memLogFunctions!LogLevel.fatal.logImplf(int line = __LINE__, string file = __FILE__, string funcName = __FUNCTION__, string prettyFuncName = __PRETTY_FUNCTION__, string moduleName = __MODULE__, A...)(lazy bool condition, lazy string msg, lazy A args); </dt> <dd>
<p>This template provides the log functions for the <code>Logger</code> <code>class</code> with the <code>LogLevel</code> encoded in the function name. </p>
<p>For further information see the the two functions defined inside of this template. <br><br> The aliases following this template create the public names of these log functions.</p> <dl>
<dt class="d_decl" id="Logger.memLogFunctions.logImpl">void <strong id="logImpl">logImpl</strong>(int line = __LINE__, string file = __FILE__, string funcName = __FUNCTION__, string prettyFuncName = __PRETTY_FUNCTION__, string moduleName = __MODULE__, A...)(lazy A args)<br><small>  Constraints: if (args.length == 0 || args.length &gt; 0 &amp;&amp; !is(A[0] : bool)); </small>
</dt> <dd>
<p>This function logs data to the used <code>Logger</code>. </p>
<p>In order for the resulting log message to be logged the <code>LogLevel</code> must be greater or equal than the <code>LogLevel</code> of the used <code>Logger</code> and must be greater or equal than the global <code>LogLevel</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>A <code>args</code>
</td> <td>The data that should be logged.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto s = new FileLogger(stdout);
s.trace(1337, "is number");
s.info(1337, "is number");
s.error(1337, "is number");
s.critical(1337, "is number");
s.fatal(1337, "is number");
</pre>  </dd> <dt class="d_decl" id="Logger.memLogFunctions.logImpl.2">void <strong id="logImpl">logImpl</strong>(int line = __LINE__, string file = __FILE__, string funcName = __FUNCTION__, string prettyFuncName = __PRETTY_FUNCTION__, string moduleName = __MODULE__, A...)(lazy bool condition, lazy A args); </dt> <dd>
<p>This function logs data to the used <code>Logger</code> depending on a condition. </p>
<p>In order for the resulting log message to be logged the <code>LogLevel</code> must be greater or equal than the <code>LogLevel</code> of the used <code>Logger</code> and must be greater or equal than the global <code>LogLevel</code> additionally the condition passed must be <code>true</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>bool <code>condition</code>
</td> <td>The condition must be <code>true</code> for the data to be logged.</td>
</tr> <tr>
<td>A <code>args</code>
</td> <td>The data that should be logged.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto s = new FileLogger(stdout);
s.trace(true, 1337, "is number");
s.info(false, 1337, "is number");
s.error(true, 1337, "is number");
s.critical(false, 1337, "is number");
s.fatal(true, 1337, "is number");
</pre>  </dd> <dt class="d_decl" id="Logger.memLogFunctions.logImplf">void <strong id="logImplf">logImplf</strong>(int line = __LINE__, string file = __FILE__, string funcName = __FUNCTION__, string prettyFuncName = __PRETTY_FUNCTION__, string moduleName = __MODULE__, A...)(lazy bool condition, lazy string msg, lazy A args); </dt> <dd>
<p>This function logs data to the used <code>Logger</code> in a <code>printf</code>-style manner. </p>
<p>In order for the resulting log message to be logged the <code>LogLevel</code> must be greater or equal than the <code>LogLevel</code> of the used <code>Logger</code> and must be greater or equal than the global <code>LogLevel</code> additionally the passed condition must be <code>true</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>bool <code>condition</code>
</td> <td>The condition must be <code>true</code> for the data to be logged.</td>
</tr> <tr>
<td>string <code>msg</code>
</td> <td>The <code>printf</code>-style string.</td>
</tr> <tr>
<td>A <code>args</code>
</td> <td>The data that should be logged.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto s = new FileLogger(stderr);
s.tracef(true, "is number %d", 1);
s.infof(true, "is number %d", 2);
s.errorf(false, "is number %d", 3);
s.criticalf(someFunc(), "is number %d", 4);
s.fatalf(true, "is number %d", 5);
</pre>  </dd> <dt class="d_decl" id="Logger.memLogFunctions.logImplf.2">void <strong id="logImplf">logImplf</strong>(int line = __LINE__, string file = __FILE__, string funcName = __FUNCTION__, string prettyFuncName = __PRETTY_FUNCTION__, string moduleName = __MODULE__, A...)(lazy string msg, lazy A args); </dt> <dd>
<p>This function logs data to the used <code>Logger</code> in a <code>printf</code>-style manner. </p>
<p>In order for the resulting log message to be logged the <code>LogLevel</code> must be greater or equal than the <code>LogLevel</code> of the used <code>Logger</code> and must be greater or equal than the global <code>LogLevel</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>string <code>msg</code>
</td> <td>The <code>printf</code>-style string.</td>
</tr> <tr>
<td>A <code>args</code>
</td> <td>The data that should be logged.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto s = new FileLogger(stderr);
s.tracef("is number %d", 1);
s.infof("is number %d", 2);
s.errorf("is number %d", 3);
s.criticalf("is number %d", 4);
s.fatalf("is number %d", 5);
</pre>  </dd> </dl> </dd> <dt class="d_decl" id="Logger.log">void <strong id="log">log</strong>(int line = __LINE__, string file = __FILE__, string funcName = __FUNCTION__, string prettyFuncName = __PRETTY_FUNCTION__, string moduleName = __MODULE__, A...)(const LogLevel ll, lazy bool condition, lazy A args)<br><small>  Constraints: if (args.length != 1); </small><br><br>void <strong id="log">log</strong>(T, string moduleName = __MODULE__)(const LogLevel ll, lazy bool condition, lazy T args, int line = __LINE__, string file = __FILE__, string funcName = __FUNCTION__, string prettyFuncName = __PRETTY_FUNCTION__); </dt> <dd>
<p>This method logs data with the <code>LogLevel</code> of the used <code>Logger</code>. </p>
<p>This method takes a <code>bool</code> as first argument. In order for the data to be processed the <code>bool</code> must be <code>true</code> and the <code>LogLevel</code> of the Logger must be greater or equal to the global <code>LogLevel</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>A <code>args</code>
</td> <td>The data that should be logged.</td>
</tr> <tr>
<td>bool <code>condition</code>
</td> <td>The condition must be <code>true</code> for the data to be logged.</td>
</tr> <tr>
<td>A <code>args</code>
</td> <td>The data that is to be logged.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The logger used by the logging function as reference. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto l = new StdioLogger();
l.log(1337);
</pre>  </dd> <dt class="d_decl" id="Logger.log.2">void <strong id="log">log</strong>(int line = __LINE__, string file = __FILE__, string funcName = __FUNCTION__, string prettyFuncName = __PRETTY_FUNCTION__, string moduleName = __MODULE__, A...)(const LogLevel ll, lazy A args)<br><small>  Constraints: if (args.length &gt; 1 &amp;&amp; !is(Unqual!(A[0]) : bool) || args.length == 0); </small><br><br>void <strong id="log">log</strong>(T)(const LogLevel ll, lazy T args, int line = __LINE__, string file = __FILE__, string funcName = __FUNCTION__, string prettyFuncName = __PRETTY_FUNCTION__, string moduleName = __MODULE__); </dt> <dd>
<p>This function logs data to the used <code>Logger</code> with a specific <code>LogLevel</code>. </p>
<p>In order for the resulting log message to be logged the <code>LogLevel</code> must be greater or equal than the <code>LogLevel</code> of the used <code>Logger</code> and must be greater or equal than the global <code>LogLevel</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>LogLevel <code>ll</code>
</td> <td>The specific <code>LogLevel</code> used for logging the log message.</td>
</tr> <tr>
<td>A <code>args</code>
</td> <td>The data that should be logged.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto s = new FileLogger(stdout);
s.log(LogLevel.trace, 1337, "is number");
s.log(LogLevel.info, 1337, "is number");
s.log(LogLevel.warning, 1337, "is number");
s.log(LogLevel.error, 1337, "is number");
s.log(LogLevel.fatal, 1337, "is number");
</pre>  </dd> <dt class="d_decl" id="Logger.log.3">void <strong id="log">log</strong>(int line = __LINE__, string file = __FILE__, string funcName = __FUNCTION__, string prettyFuncName = __PRETTY_FUNCTION__, string moduleName = __MODULE__, A...)(lazy bool condition, lazy A args)<br><small>  Constraints: if (args.length != 1); </small><br><br>void <strong id="log">log</strong>(T)(lazy bool condition, lazy T args, int line = __LINE__, string file = __FILE__, string funcName = __FUNCTION__, string prettyFuncName = __PRETTY_FUNCTION__, string moduleName = __MODULE__); </dt> <dd>
<p>This function logs data to the used <code>Logger</code> depending on a explicitly passed condition with the <code>LogLevel</code> of the used <code>Logger</code>. </p>
<p>In order for the resulting log message to be logged the <code>LogLevel</code> of the used <code>Logger</code> must be greater or equal than the global <code>LogLevel</code> and the condition must be <code>true</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>bool <code>condition</code>
</td> <td>The condition must be <code>true</code> for the data to be logged.</td>
</tr> <tr>
<td>A <code>args</code>
</td> <td>The data that should be logged.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto s = new FileLogger(stdout);
s.log(true, 1337, "is number");
s.log(true, 1337, "is number");
s.log(true, 1337, "is number");
s.log(false, 1337, "is number");
s.log(false, 1337, "is number");
</pre>  </dd> <dt class="d_decl" id="Logger.log.4">void <strong id="log">log</strong>(int line = __LINE__, string file = __FILE__, string funcName = __FUNCTION__, string prettyFuncName = __PRETTY_FUNCTION__, string moduleName = __MODULE__, A...)(lazy A args)<br><small>  Constraints: if (args.length &gt; 1 &amp;&amp; !is(Unqual!(A[0]) : bool) &amp;&amp; !is(immutable(A[0]) == immutable(LogLevel)) || args.length == 0); </small><br><br>void <strong id="log">log</strong>(T)(lazy T arg, int line = __LINE__, string file = __FILE__, string funcName = __FUNCTION__, string prettyFuncName = __PRETTY_FUNCTION__, string moduleName = __MODULE__); </dt> <dd>
<p>This function logs data to the used <code>Logger</code> with the <code>LogLevel</code> of the used <code>Logger</code>. </p>
<p>In order for the resulting log message to be logged the <code>LogLevel</code> of the used <code>Logger</code> must be greater or equal than the global <code>LogLevel</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>A <code>args</code>
</td> <td>The data that should be logged.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto s = new FileLogger(stdout);
s.log(1337, "is number");
s.log(info, 1337, "is number");
s.log(1337, "is number");
s.log(1337, "is number");
s.log(1337, "is number");
</pre>  </dd> <dt class="d_decl" id="Logger.logf">void <strong id="logf">logf</strong>(int line = __LINE__, string file = __FILE__, string funcName = __FUNCTION__, string prettyFuncName = __PRETTY_FUNCTION__, string moduleName = __MODULE__, A...)(const LogLevel ll, lazy bool condition, lazy string msg, lazy A args); </dt> <dd>
<p>This function logs data to the used <code>Logger</code> with a specific <code>LogLevel</code> and depending on a condition in a <code>printf</code>-style manner. </p>
<p>In order for the resulting log message to be logged the <code>LogLevel</code> must be greater or equal than the <code>LogLevel</code> of the used <code>Logger</code> and must be greater or equal than the global <code>LogLevel</code> and the condition must be <code>true</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>LogLevel <code>ll</code>
</td> <td>The specific <code>LogLevel</code> used for logging the log message.</td>
</tr> <tr>
<td>bool <code>condition</code>
</td> <td>The condition must be <code>true</code> for the data to be logged.</td>
</tr> <tr>
<td>string <code>msg</code>
</td> <td>The format string used for this log call.</td>
</tr> <tr>
<td>A <code>args</code>
</td> <td>The data that should be logged.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto s = new FileLogger(stdout);
s.logf(LogLevel.trace, true ,"%d %s", 1337, "is number");
s.logf(LogLevel.info, true ,"%d %s", 1337, "is number");
s.logf(LogLevel.warning, true ,"%d %s", 1337, "is number");
s.logf(LogLevel.error, false ,"%d %s", 1337, "is number");
s.logf(LogLevel.fatal, true ,"%d %s", 1337, "is number");
</pre>  </dd> <dt class="d_decl" id="Logger.logf.2">void <strong id="logf">logf</strong>(int line = __LINE__, string file = __FILE__, string funcName = __FUNCTION__, string prettyFuncName = __PRETTY_FUNCTION__, string moduleName = __MODULE__, A...)(const LogLevel ll, lazy string msg, lazy A args); </dt> <dd>
<p>This function logs data to the used <code>Logger</code> with a specific <code>LogLevel</code> in a <code>printf</code>-style manner. </p>
<p>In order for the resulting log message to be logged the <code>LogLevel</code> must be greater or equal than the <code>LogLevel</code> of the used <code>Logger</code> and must be greater or equal than the global <code>LogLevel</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>LogLevel <code>ll</code>
</td> <td>The specific <code>LogLevel</code> used for logging the log message.</td>
</tr> <tr>
<td>string <code>msg</code>
</td> <td>The format string used for this log call.</td>
</tr> <tr>
<td>A <code>args</code>
</td> <td>The data that should be logged.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto s = new FileLogger(stdout);
s.logf(LogLevel.trace, "%d %s", 1337, "is number");
s.logf(LogLevel.info, "%d %s", 1337, "is number");
s.logf(LogLevel.warning, "%d %s", 1337, "is number");
s.logf(LogLevel.error, "%d %s", 1337, "is number");
s.logf(LogLevel.fatal, "%d %s", 1337, "is number");
</pre>  </dd> <dt class="d_decl" id="Logger.logf.3">void <strong id="logf">logf</strong>(int line = __LINE__, string file = __FILE__, string funcName = __FUNCTION__, string prettyFuncName = __PRETTY_FUNCTION__, string moduleName = __MODULE__, A...)(lazy bool condition, lazy string msg, lazy A args); </dt> <dd>
<p>This function logs data to the used <code>Logger</code> depending on a condition with the <code>LogLevel</code> of the used <code>Logger</code> in a <code>printf</code>-style manner. </p>
<p>In order for the resulting log message to be logged the <code>LogLevel</code> of the used <code>Logger</code> must be greater or equal than the global <code>LogLevel</code> and the condition must be <code>true</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>bool <code>condition</code>
</td> <td>The condition must be <code>true</code> for the data to be logged.</td>
</tr> <tr>
<td>string <code>msg</code>
</td> <td>The format string used for this log call.</td>
</tr> <tr>
<td>A <code>args</code>
</td> <td>The data that should be logged.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto s = new FileLogger(stdout);
s.logf(true ,"%d %s", 1337, "is number");
s.logf(true ,"%d %s", 1337, "is number");
s.logf(true ,"%d %s", 1337, "is number");
s.logf(false ,"%d %s", 1337, "is number");
s.logf(true ,"%d %s", 1337, "is number");
</pre>  </dd> <dt class="d_decl" id="Logger.logf.4">void <strong id="logf">logf</strong>(int line = __LINE__, string file = __FILE__, string funcName = __FUNCTION__, string prettyFuncName = __PRETTY_FUNCTION__, string moduleName = __MODULE__, A...)(lazy string msg, lazy A args); </dt> <dd>
<p>This method logs data to the used <code>Logger</code> with the <code>LogLevel</code> of the this <code>Logger</code> in a <code>printf</code>-style manner. </p>
<p>In order for the data to be processed the <code>LogLevel</code> of the <code>Logger</code> must be greater or equal to the global <code>LogLevel</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>string <code>msg</code>
</td> <td>The format string used for this log call.</td>
</tr> <tr>
<td>A <code>args</code>
</td> <td>The data that should be logged.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto s = new FileLogger(stdout);
s.logf("%d %s", 1337, "is number");
s.logf("%d %s", 1337, "is number");
s.logf("%d %s", 1337, "is number");
s.logf("%d %s", 1337, "is number");
s.logf("%d %s", 1337, "is number");
</pre>  </dd> </dl> </dd> <dt class="d_decl" id="sharedLog">@property @safe Logger <strong id="sharedLog">sharedLog</strong>(); <br><br>@property @trusted void <strong id="sharedLog">sharedLog</strong>(Logger logger); </dt> <dd>
<p>This property sets and gets the default <code>Logger</code>. </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">sharedLog = new FileLogger(yourFile);
</pre> The example sets a new <code>FileLogger</code> as new <code>sharedLog</code>.  If at some point you want to use the original default logger again, you can use <code>sharedLog = null;</code>. This will put back the original.  <dl>
<dt>Note</dt>
<dd> While getting and setting <code>sharedLog</code> is thread-safe, it has to be considered that the returned reference is only a current snapshot and in the following code, you must make sure no other thread reassigns to it between reading and writing <code>sharedLog</code>. </dd>
</dl> <code>sharedLog</code> is only thread-safe if the the used <code>Logger</code> is thread-safe. The default <code>Logger</code> is thread-safe. <pre data-language="d">if (sharedLog !is myLogger)
    sharedLog = new myLogger;
</pre>  </dd> <dt class="d_decl" id="globalLogLevel">@nogc @property @safe LogLevel <strong id="globalLogLevel">globalLogLevel</strong>(); <br><br>@property @safe void <strong id="globalLogLevel">globalLogLevel</strong>(LogLevel ll); </dt> <dd>
<p>This methods get and set the global <code>LogLevel</code>. </p>
<p>Every log message with a <code>LogLevel</code> lower as the global <code>LogLevel</code> will be discarded before it reaches <code>writeLogMessage</code> method of any <code>Logger</code>.</p> </dd> <dt class="d_decl" id="StdForwardLogger">class <strong id="StdForwardLogger">StdForwardLogger</strong>: std.experimental.logger.core.Logger; </dt> <dd>
<p>The <code>StdForwardLogger</code> will always forward anything to the sharedLog. </p>
<p>The <code>StdForwardLogger</code> will not throw if data is logged with <code>LogLevel.fatal</code>.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto nl1 = new StdForwardLogger(LogLevel.all);
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="StdForwardLogger.this">@safe this(const LogLevel lv = LogLevel.all); </dt> <dd>
<p>The default constructor for the <code>StdForwardLogger</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>LogLevel <code>lv</code>
</td> <td>The <code>LogLevel</code> for the <code>MultiLogger</code>. By default the <code> LogLevel</code> is <code>all</code>.</td>
</tr> </table></dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="stdThreadLocalLog">@property @safe Logger <strong id="stdThreadLocalLog">stdThreadLocalLog</strong>(); <br><br>@property @safe void <strong id="stdThreadLocalLog">stdThreadLocalLog</strong>(Logger logger); </dt> <dd>
<p>This function returns a thread unique <code>Logger</code>, that by default propergates all data logged to it to the <code>sharedLog</code>. </p>
<p>These properties can be used to set and get this <code>Logger</code>. Every modification to this <code>Logger</code> will only be visible in the thread the modification has been done from. <br><br> This <code>Logger</code> is called by the free standing log functions. This allows to create thread local redirections and still use the free standing log functions.</p> <dl>
<dt>Examples:</dt>
<dd>Ditto <pre data-language="d">import std.experimental.logger.filelogger : FileLogger;
import std.file : deleteme, remove;
Logger l = stdThreadLocalLog;
stdThreadLocalLog = new FileLogger(deleteme ~ "-someFile.log");
scope(exit) remove(deleteme ~ "-someFile.log");

auto tempLog = stdThreadLocalLog;
stdThreadLocalLog = l;
destroy(tempLog);
</pre> </dd>
</dl> </dd> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1999&ndash;2021 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/std_experimental_logger_core.html" class="_attribution-link">https://dlang.org/phobos/std_experimental_logger_core.html</a>
  </p>
</div>
