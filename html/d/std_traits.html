<h1>std.traits</h1>  <p>Templates which extract information about types and symbols at compile time. </p> <table>
 <tr>
<th scope="col">Category</th> <th scope="col">Templates</th>
</tr> <tr>
<td>Symbol Name traits</td> <td> <a href="#fullyQualifiedName"><code>fullyQualifiedName</code></a> <a href="#moduleName"><code>moduleName</code></a> <a href="#packageName"><code>packageName</code></a> </td>
</tr> <tr>
<td>Function traits</td> <td> <a href="#isFunction"><code>isFunction</code></a> <a href="#arity"><code>arity</code></a> <a href="#functionAttributes"><code>functionAttributes</code></a> <a href="#hasFunctionAttributes"><code>hasFunctionAttributes</code></a> <a href="#functionLinkage"><code>functionLinkage</code></a> <a href="#FunctionTypeOf"><code>FunctionTypeOf</code></a> <a href="#isSafe"><code>isSafe</code></a> <a href="#isUnsafe"><code>isUnsafe</code></a> <a href="#isFinal"><code>isFinal</code></a> <a href="#ParameterDefaults"><code>ParameterDefaults</code></a> <a href="#ParameterIdentifierTuple"><code>ParameterIdentifierTuple</code></a> <a href="#ParameterStorageClassTuple"><code>ParameterStorageClassTuple</code></a> <a href="#Parameters"><code>Parameters</code></a> <a href="#ReturnType"><code>ReturnType</code></a> <a href="#SetFunctionAttributes"><code>SetFunctionAttributes</code></a> <a href="#variadicFunctionStyle"><code>variadicFunctionStyle</code></a> </td>
</tr> <tr>
<td>Aggregate Type traits</td> <td> <a href="#BaseClassesTuple"><code>BaseClassesTuple</code></a> <a href="#BaseTypeTuple"><code>BaseTypeTuple</code></a> <a href="#classInstanceAlignment"><code>classInstanceAlignment</code></a> <a href="#EnumMembers"><code>EnumMembers</code></a> <a href="#FieldNameTuple"><code>FieldNameTuple</code></a> <a href="#Fields"><code>Fields</code></a> <a href="#hasAliasing"><code>hasAliasing</code></a> <a href="#hasElaborateAssign"><code>hasElaborateAssign</code></a> <a href="#hasElaborateCopyConstructor"><code>hasElaborateCopyConstructor</code></a> <a href="#hasElaborateDestructor"><code>hasElaborateDestructor</code></a> <a href="#hasElaborateMove"><code>hasElaborateMove</code></a> <a href="#hasIndirections"><code>hasIndirections</code></a> <a href="#hasMember"><code>hasMember</code></a> <a href="#hasStaticMember"><code>hasStaticMember</code></a> <a href="#hasNested"><code>hasNested</code></a> <a href="#hasUnsharedAliasing"><code>hasUnsharedAliasing</code></a> <a href="#InterfacesTuple"><code>InterfacesTuple</code></a> <a href="#isInnerClass"><code>isInnerClass</code></a> <a href="#isNested"><code>isNested</code></a> <a href="#MemberFunctionsTuple"><code>MemberFunctionsTuple</code></a> <a href="#RepresentationTypeTuple"><code>RepresentationTypeTuple</code></a> <a href="#TemplateArgsOf"><code>TemplateArgsOf</code></a> <a href="#TemplateOf"><code>TemplateOf</code></a> <a href="#TransitiveBaseTypeTuple"><code>TransitiveBaseTypeTuple</code></a> </td>
</tr> <tr>
<td>Type Conversion</td> <td> <a href="#CommonType"><code>CommonType</code></a> <a href="#ImplicitConversionTargets"><code>ImplicitConversionTargets</code></a> <a href="#CopyTypeQualifiers"><code>CopyTypeQualifiers</code></a> <a href="#CopyConstness"><code>CopyConstness</code></a> <a href="#isAssignable"><code>isAssignable</code></a> <a href="#isCovariantWith"><code>isCovariantWith</code></a> <a href="#isImplicitlyConvertible"><code>isImplicitlyConvertible</code></a> </td>
</tr> <tr>
<td>SomethingTypeOf</td> <td> <a href="#rvalueOf"><code>rvalueOf</code></a> <a href="#lvalueOf"><code>lvalueOf</code></a> <a href="#InoutOf"><code>InoutOf</code></a> <a href="#ConstOf"><code>ConstOf</code></a> <a href="#SharedOf"><code>SharedOf</code></a> <a href="#SharedInoutOf"><code>SharedInoutOf</code></a> <a href="#SharedConstOf"><code>SharedConstOf</code></a> <a href="#ImmutableOf"><code>ImmutableOf</code></a> <a href="#QualifierOf"><code>QualifierOf</code></a> </td>
</tr> <tr>
<td>Categories of types</td> <td> <a href="#allSameType"><code>allSameType</code></a> <a href="#ifTestable"><code>ifTestable</code></a> <a href="#isType"><code>isType</code></a> <a href="#isAggregateType"><code>isAggregateType</code></a> <a href="#isArray"><code>isArray</code></a> <a href="#isAssociativeArray"><code>isAssociativeArray</code></a> <a href="#isAutodecodableString"><code>isAutodecodableString</code></a> <a href="#isBasicType"><code>isBasicType</code></a> <a href="#isBoolean"><code>isBoolean</code></a> <a href="#isBuiltinType"><code>isBuiltinType</code></a> <a href="#isCopyable"><code>isCopyable</code></a> <a href="#isDynamicArray"><code>isDynamicArray</code></a> <a href="#isEqualityComparable"><code>isEqualityComparable</code></a> <a href="#isFloatingPoint"><code>isFloatingPoint</code></a> <a href="#isIntegral"><code>isIntegral</code></a> <a href="#isNarrowString"><code>isNarrowString</code></a> <a href="#isConvertibleToString"><code>isConvertibleToString</code></a> <a href="#isNumeric"><code>isNumeric</code></a> <a href="#isOrderingComparable"><code>isOrderingComparable</code></a> <a href="#isPointer"><code>isPointer</code></a> <a href="#isScalarType"><code>isScalarType</code></a> <a href="#isSigned"><code>isSigned</code></a> <a href="#isSIMDVector"><code>isSIMDVector</code></a> <a href="#isSomeChar"><code>isSomeChar</code></a> <a href="#isSomeString"><code>isSomeString</code></a> <a href="#isStaticArray"><code>isStaticArray</code></a> <a href="#isUnsigned"><code>isUnsigned</code></a> </td>
</tr> <tr>
<td>Type behaviours</td> <td> <a href="#isAbstractClass"><code>isAbstractClass</code></a> <a href="#isAbstractFunction"><code>isAbstractFunction</code></a> <a href="#isCallable"><code>isCallable</code></a> <a href="#isDelegate"><code>isDelegate</code></a> <a href="#isExpressions"><code>isExpressions</code></a> <a href="#isFinalClass"><code>isFinalClass</code></a> <a href="#isFinalFunction"><code>isFinalFunction</code></a> <a href="#isFunctionPointer"><code>isFunctionPointer</code></a> <a href="#isInstanceOf"><code>isInstanceOf</code></a> <a href="#isIterable"><code>isIterable</code></a> <a href="#isMutable"><code>isMutable</code></a> <a href="#isSomeFunction"><code>isSomeFunction</code></a> <a href="#isTypeTuple"><code>isTypeTuple</code></a> </td>
</tr> <tr>
<td>General Types</td> <td> <a href="#ForeachType"><code>ForeachType</code></a> <a href="#KeyType"><code>KeyType</code></a> <a href="#Largest"><code>Largest</code></a> <a href="#mostNegative"><code>mostNegative</code></a> <a href="#OriginalType"><code>OriginalType</code></a> <a href="#PointerTarget"><code>PointerTarget</code></a> <a href="#Signed"><code>Signed</code></a> <a href="#Unconst"><code>Unconst</code></a> <a href="#Unqual"><code>Unqual</code></a> <a href="#Unsigned"><code>Unsigned</code></a> <a href="#ValueType"><code>ValueType</code></a> <a href="#Promoted"><code>Promoted</code></a> </td>
</tr> <tr>
<td>Misc</td> <td> <a href="#mangledName"><code>mangledName</code></a> <a href="#Select"><code>Select</code></a> <a href="#select"><code>select</code></a> </td>
</tr> <tr>
<td>User-Defined Attributes</td> <td> <a href="#hasUDA"><code>hasUDA</code></a> <a href="#getUDAs"><code>getUDAs</code></a> <a href="#getSymbolsByUDA"><code>getSymbolsByUDA</code></a> </td>
</tr> </table>  <dl>
<dt>License:</dt>
<dd>
<a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>. </dd>
</dl> <dl>
<dt>Authors:</dt>
<dd>
<a href="http://digitalmars.com">Walter Bright</a>, Tomasz Stachowiak (<code>isExpressions</code>), <a href="http://erdani.org">Andrei Alexandrescu</a>, Shin Fujishiro, <a href="http://octarineparrot.com">Robert Clipsham</a>, <a href="http://klickverbot.at">David Nadlinger</a>, Kenji Hara, Shoichi Kato </dd>
</dl> <dl>
<dt>Source</dt>
<dd> <span class="phobos_src"><a class="https" href="https://github.com/dlang/phobos/blob/master/std/traits.d">std/traits.d</a></span>
</dd>
</dl> <dl>
<dt class="d_decl" id="InoutOf">template <strong id="InoutOf">InoutOf</strong>(T)</dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T</td> <td>The type to qualify</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>T</code> with the <code>inout</code> qualifier added.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(is(InoutOf!(int) == inout int));
static assert(is(InoutOf!(inout int) == inout int));
static assert(is(InoutOf!(const int) == inout const int));
static assert(is(InoutOf!(shared int) == inout shared int));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="ConstOf">template <strong id="ConstOf">ConstOf</strong>(T)</dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T</td> <td>The type to qualify</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>T</code> with the <code>const</code> qualifier added.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(is(ConstOf!(int) == const int));
static assert(is(ConstOf!(const int) == const int));
static assert(is(ConstOf!(inout int) == const inout int));
static assert(is(ConstOf!(shared int) == const shared int));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="SharedOf">template <strong id="SharedOf">SharedOf</strong>(T)</dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T</td> <td>The type to qualify</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>T</code> with the <code>shared</code> qualifier added.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(is(SharedOf!(int) == shared int));
static assert(is(SharedOf!(shared int) == shared int));
static assert(is(SharedOf!(inout int) == shared inout int));
static assert(is(SharedOf!(immutable int) == shared immutable int));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="SharedInoutOf">template <strong id="SharedInoutOf">SharedInoutOf</strong>(T)</dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T</td> <td>The type to qualify</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>T</code> with the <code>inout</code> and <code>shared</code> qualifiers added.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(is(SharedInoutOf!(int) == shared inout int));
static assert(is(SharedInoutOf!(int) == inout shared int));

static assert(is(SharedInoutOf!(const int) == shared inout const int));
static assert(is(SharedInoutOf!(immutable int) == shared inout immutable int));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="SharedConstOf">template <strong id="SharedConstOf">SharedConstOf</strong>(T)</dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T</td> <td>The type to qualify</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>T</code> with the <code>const</code> and <code>shared</code> qualifiers added.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(is(SharedConstOf!(int) == shared const int));
static assert(is(SharedConstOf!(int) == const shared int));

static assert(is(SharedConstOf!(inout int) == shared inout const int));
// immutable variables are implicitly shared and const
static assert(is(SharedConstOf!(immutable int) == immutable int));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="ImmutableOf">template <strong id="ImmutableOf">ImmutableOf</strong>(T)</dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T</td> <td>The type to qualify</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>T</code> with the <code>immutable</code> qualifier added.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(is(ImmutableOf!(int) == immutable int));
static assert(is(ImmutableOf!(const int) == immutable int));
static assert(is(ImmutableOf!(inout int) == immutable int));
static assert(is(ImmutableOf!(shared int) == immutable int));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="QualifierOf">template <strong id="QualifierOf">QualifierOf</strong>(T)</dt> <dd>
<p>Gives a template that can be used to apply the same attributes that are on the given type <code>T</code>. E.g. passing <code>inout shared int</code> will return <code>SharedInoutOf</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T</td> <td>the type to check qualifiers from</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The qualifier template from the given type <code>T</code>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(__traits(isSame, QualifierOf!(immutable int), ImmutableOf));
static assert(__traits(isSame, QualifierOf!(shared int), SharedOf));
static assert(__traits(isSame, QualifierOf!(shared inout int), SharedInoutOf));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="packageName">template <strong id="packageName">packageName</strong>(alias T)</dt> <dd>
<p>Get the full package name for the given symbol.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(packageName!packageName == "std");
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(packageName!moduleName == "std");
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="moduleName">template <strong id="moduleName">moduleName</strong>(alias T)</dt> <dd>
<p>Get the module name (including package) for the given symbol.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(moduleName!moduleName == "std.traits");
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="fullyQualifiedName">template <strong id="fullyQualifiedName">fullyQualifiedName</strong>(T...) if (T.length == 1)</dt> <dd>
<p>Get the fully qualified name of a type or a symbol. Can act as an intelligent type/symbol to string converter. </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">module myModule;
struct MyStruct {}
static assert(fullyQualifiedName!(const MyStruct[]) == "const(myModule.MyStruct[])");
</pre>  <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(fullyQualifiedName!fullyQualifiedName == "std.traits.fullyQualifiedName");
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="ReturnType">template <strong id="ReturnType">ReturnType</strong>(func...) if (func.length == 1 &amp;&amp; isCallable!func)</dt> <dd>
<p>Get the type of the return value from a function, a pointer to function, a delegate, a struct with an opCall, a pointer to a struct with an opCall, or a class with an <code>opCall</code>. Please note that <span class="d_keyword">ref</span> is not part of a type, but the attribute of the function (see template <a href="#functionAttributes"><code>functionAttributes</code></a>).</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int foo();
ReturnType!foo x;   // x is declared as int
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Parameters">template <strong id="Parameters">Parameters</strong>(func...) if (func.length == 1 &amp;&amp; isCallable!func)</dt> <dd>
<p>Get, as a tuple, the types of the parameters to a function, a pointer to function, a delegate, a struct with an <code>opCall</code>, a pointer to a struct with an <code>opCall</code>, or a class with an <code>opCall</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int foo(int, long);
void bar(Parameters!foo);      // declares void bar(int, long);
void abc(Parameters!foo[1]);   // declares void abc(long);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="ParameterTypeTuple">alias <strong id="ParameterTypeTuple">ParameterTypeTuple</strong> = Parameters(func...) if (func.length == 1 &amp;&amp; isCallable!func); </dt> <dd>
<p>Alternate name for <a href="#Parameters"><code>Parameters</code></a>, kept for legacy compatibility.</p> </dd> <dt class="d_decl" id="arity">template <strong id="arity">arity</strong>(func...) if (func.length == 1 &amp;&amp; isCallable!func &amp;&amp; (variadicFunctionStyle!func == Variadic.no))</dt> <dd>
<p>Returns the number of arguments of function <code>func</code>. arity is undefined for variadic functions.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">void foo(){}
static assert(arity!foo == 0);
void bar(uint){}
static assert(arity!bar == 1);
void variadicFoo(uint...){}
static assert(!__traits(compiles, arity!variadicFoo));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="ParameterStorageClass">enum <strong id="ParameterStorageClass">ParameterStorageClass</strong>: uint; <br><br>template <strong id="ParameterStorageClassTuple">ParameterStorageClassTuple</strong>(func...) if (func.length == 1 &amp;&amp; isCallable!func)</dt> <dd>
<p>Get tuple, one per function parameter, of the storage classes of the parameters. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>func</td> <td>function symbol or type of function, delegate, or pointer to function</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A tuple of ParameterStorageClass bits</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">alias STC = ParameterStorageClass; // shorten the enum name

void func(ref int ctx, out real result, in real param, void* ptr)
{
}
alias pstc = ParameterStorageClassTuple!func;
static assert(pstc.length == 4); // number of parameters
static assert(pstc[0] == STC.ref_);
static assert(pstc[1] == STC.out_);
version (none)
{
    // TODO: When the DMD PR (dlang/dmd#11474) gets merged,
    // remove the versioning and the second test
    static assert(pstc[2] == STC.in_);
    // This is the current behavior, before `in` is fixed to not be an alias
    static assert(pstc[2] == STC.scope_);
}
static assert(pstc[3] == STC.none);
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="ParameterStorageClass.none">
<strong id="none">none</strong><br><br><strong id="in_">in_</strong><br><br><strong id="ref_">ref_</strong><br><br><strong id="out_">out_</strong><br><br><strong id="lazy_">lazy_</strong><br><br><strong id="scope_">scope_</strong><br><br><strong id="return_">return_</strong>
</dt> <dd>
<p>These flags can be bitwise OR-ed together to represent complex storage class.</p> </dd> </dl> </dd> <dt class="d_decl" id="extractParameterStorageClassFlags">enum ParameterStorageClass <strong id="extractParameterStorageClassFlags">extractParameterStorageClassFlags</strong>(Attribs...); </dt> <dd>
<p>Convert the result of <code>__traits(getParameterStorageClasses)</code> to <a href="#ParameterStorageClass"><code>ParameterStorageClass</code></a> <code>enum</code>s. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Attribs</td> <td>The return value of <code>__traits(getParameterStorageClasses)</code>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The bitwise OR of the equivalent <a href="#ParameterStorageClass"><code>ParameterStorageClass</code></a> <code>enum</code>s.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static void func(ref int ctx, out real result);

enum param1 = extractParameterStorageClassFlags!(
    __traits(getParameterStorageClasses, func, 0)
);
static assert(param1 == ParameterStorageClass.ref_);

enum param2 = extractParameterStorageClassFlags!(
    __traits(getParameterStorageClasses, func, 1)
);
static assert(param2 == ParameterStorageClass.out_);

enum param3 = extractParameterStorageClassFlags!(
    __traits(getParameterStorageClasses, func, 0),
    __traits(getParameterStorageClasses, func, 1)
);
static assert(param3 == (ParameterStorageClass.ref_ | ParameterStorageClass.out_));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="ParameterIdentifierTuple">template <strong id="ParameterIdentifierTuple">ParameterIdentifierTuple</strong>(func...) if (func.length == 1 &amp;&amp; isCallable!func)</dt> <dd>
<p>Get, as a tuple, the identifiers of the parameters to a function symbol.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int foo(int num, string name, int);
static assert([ParameterIdentifierTuple!foo] == ["num", "name", ""]);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="ParameterDefaults">template <strong id="ParameterDefaults">ParameterDefaults</strong>(func...) if (func.length == 1 &amp;&amp; isCallable!func)</dt> <dd>
<p>Get, as a tuple, the default value of the parameters to a function symbol. If a parameter doesn't have the default value, <code>void</code> is returned instead.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int foo(int num, string name = "hello", int[] = [1,2,3], lazy int x = 0);
static assert(is(ParameterDefaults!foo[0] == void));
static assert(   ParameterDefaults!foo[1] == "hello");
static assert(   ParameterDefaults!foo[2] == [1,2,3]);
static assert(   ParameterDefaults!foo[3] == 0);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="ParameterDefaultValueTuple">alias <strong id="ParameterDefaultValueTuple">ParameterDefaultValueTuple</strong> = ParameterDefaults(func...) if (func.length == 1 &amp;&amp; isCallable!func); </dt> <dd>
<p>Alternate name for <a href="#ParameterDefaults"><code>ParameterDefaults</code></a>, kept for legacy compatibility.</p> </dd> <dt class="d_decl" id="FunctionAttribute">enum <strong id="FunctionAttribute">FunctionAttribute</strong>: uint; <br><br>template <strong id="functionAttributes">functionAttributes</strong>(func...) if (func.length == 1 &amp;&amp; isCallable!func)</dt> <dd>
<p>Returns the FunctionAttribute mask for function <code>func</code>. </p>
<dl>
<dt>See Also:</dt>
<dd><a href="#hasFunctionAttributes"><code>hasFunctionAttributes</code></a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">alias FA = FunctionAttribute; // shorten the enum name

real func(real x) pure nothrow @safe
{
    return x;
}
static assert(functionAttributes!func &amp; FA.pure_);
static assert(functionAttributes!func &amp; FA.safe);
static assert(!(functionAttributes!func &amp; FA.trusted)); // not @trusted
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="FunctionAttribute.none">
<strong id="none">none</strong><br><br><strong id="pure_">pure_</strong><br><br><strong id="nothrow_">nothrow_</strong><br><br><strong id="ref_">ref_</strong><br><br><strong id="property">property</strong><br><br><strong id="trusted">trusted</strong><br><br><strong id="safe">safe</strong><br><br><strong id="nogc">nogc</strong><br><br><strong id="system">system</strong><br><br><strong id="const_">const_</strong><br><br><strong id="immutable_">immutable_</strong><br><br><strong id="inout_">inout_</strong><br><br><strong id="shared_">shared_</strong><br><br><strong id="return_">return_</strong><br><br><strong id="scope_">scope_</strong><br><br><strong id="live">live</strong>
</dt> <dd>
<p>These flags can be bitwise OR-ed together to represent a complex attribute.</p> </dd> </dl> </dd> <dt class="d_decl" id="hasFunctionAttributes">template <strong id="hasFunctionAttributes">hasFunctionAttributes</strong>(args...) if (args.length &gt; 0 &amp;&amp; isCallable!(args[0]) &amp;&amp; allSatisfy!(isSomeString, typeof(args[1..$])))</dt> <dd>
<p>Checks whether a function has the given attributes attached. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>args</td> <td>Function to check, followed by a variadic number of function attributes as strings</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>true</code>, if the function has the list of attributes attached and <code>false</code> otherwise. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd><a href="#functionAttributes"><code>functionAttributes</code></a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">real func(real x) pure nothrow @safe;
static assert(hasFunctionAttributes!(func, "@safe", "pure"));
static assert(!hasFunctionAttributes!(func, "@trusted"));

// for templates attributes are automatically inferred
bool myFunc(T)(T b)
{
    return !b;
}
static assert(hasFunctionAttributes!(myFunc!bool, "@safe", "pure", "@nogc", "nothrow"));
static assert(!hasFunctionAttributes!(myFunc!bool, "shared"));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isSafe">template <strong id="isSafe">isSafe</strong>(alias func) if (isCallable!func)</dt> <dd>
<p><code>true</code> if <code>func</code> is <code>@safe</code> or <code>@trusted</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">@safe    int add(int a, int b) {return a+b;}
@trusted int sub(int a, int b) {return a-b;}
@system  int mul(int a, int b) {return a*b;}

static assert( isSafe!add);
static assert( isSafe!sub);
static assert(!isSafe!mul);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isUnsafe">enum auto <strong id="isUnsafe">isUnsafe</strong>(alias func); </dt> <dd>
<p><code>true</code> if <code>func</code> is <code>@system</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">@safe    int add(int a, int b) {return a+b;}
@trusted int sub(int a, int b) {return a-b;}
@system  int mul(int a, int b) {return a*b;}

static assert(!isUnsafe!add);
static assert(!isUnsafe!sub);
static assert( isUnsafe!mul);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="functionLinkage">template <strong id="functionLinkage">functionLinkage</strong>(func...) if (func.length == 1 &amp;&amp; isCallable!func)</dt> <dd>
<p>Determine the linkage attribute of the function. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>func</td> <td>the function symbol, or the type of a function, delegate, or pointer to function</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>one of the strings "D", "C", "C++", "Windows", "Objective-C", or "System".</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">extern(D) void Dfunc() {}
extern(C) void Cfunc() {}
static assert(functionLinkage!Dfunc == "D");
static assert(functionLinkage!Cfunc == "C");

string a = functionLinkage!Dfunc;
writeln(a); // "D"

auto fp = &amp;Cfunc;
string b = functionLinkage!fp;
writeln(b); // "C"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Variadic">enum <strong id="Variadic">Variadic</strong>: int; <br><br>template <strong id="variadicFunctionStyle">variadicFunctionStyle</strong>(func...) if (func.length == 1 &amp;&amp; isCallable!func)</dt> <dd>
<p>Determines what kind of variadic parameters function has. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>func</td> <td>function symbol or type of function, delegate, or pointer to function</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>enum Variadic</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">void func() {}
static assert(variadicFunctionStyle!func == Variadic.no);

extern(C) int printf(in char*, ...);
static assert(variadicFunctionStyle!printf == Variadic.c);
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="Variadic.no"><strong id="no">no</strong></dt> <dd>
<p>Function is not variadic.</p> </dd> <dt class="d_decl" id="Variadic.c"><strong id="c">c</strong></dt> <dd>
<p>Function is a C-style variadic function, which uses <code>core.stdc.stdarg</code></p> </dd> <dt class="d_decl" id="Variadic.d"><strong id="d">d</strong></dt> <dd>
<p>Function is a D-style variadic function, which uses <code>__argptr</code> and <code>__arguments</code>.</p> </dd> <dt class="d_decl" id="Variadic.typesafe"><strong id="typesafe">typesafe</strong></dt> <dd>
<p>Function is a typesafe variadic function.</p> </dd> </dl> </dd> <dt class="d_decl" id="FunctionTypeOf">template <strong id="FunctionTypeOf">FunctionTypeOf</strong>(func...) if (func.length == 1 &amp;&amp; isCallable!func)</dt> <dd>
<p>Get the function type from a callable object <code>func</code>. </p>
<p>Using builtin <code>typeof</code> on a property function yields the types of the property value, not of the property function itself. Still, <code>FunctionTypeOf</code> is able to obtain function types of properties. </p> <dl>
<dt>Note</dt>
<dd> Do not confuse function types with function pointer types; function types are usually used for compile-time reflection purposes.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">class C
{
    int value() @property { return 0; }
}
static assert(is( typeof(C.value) == int ));
static assert(is( FunctionTypeOf!(C.value) == function ));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="SetFunctionAttributes">template <strong id="SetFunctionAttributes">SetFunctionAttributes</strong>(T, string linkage, uint attrs) if (isFunctionPointer!T || isDelegate!T)<br><br>template <strong id="SetFunctionAttributes">SetFunctionAttributes</strong>(T, string linkage, uint attrs) if (is(T == function))</dt> <dd>
<p>Constructs a new function or delegate type with the same basic signature as the given one, but different attributes (including linkage). </p>
<p>This is especially useful for adding/removing attributes to/from types in generic code, where the actual type name cannot be spelt out. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T</td> <td>The base type.</td>
</tr> <tr>
<td>linkage</td> <td>The desired linkage of the result type.</td>
</tr> <tr>
<td>attrs</td> <td>The desired <a href="#FunctionAttribute"><code>FunctionAttribute</code></a>s of the result type.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">alias ExternC(T) = SetFunctionAttributes!(T, "C", functionAttributes!T);

auto assumePure(T)(T t)
if (isFunctionPointer!T || isDelegate!T)
{
    enum attrs = functionAttributes!T | FunctionAttribute.pure_;
    return cast(SetFunctionAttributes!(T, functionLinkage!T, attrs)) t;
}

int f()
{
    import core.thread : getpid;
    return getpid();
}

int g() pure @trusted
{
    auto pureF = assumePure(&amp;f);
    return pureF();
}
assert(g() &gt; 0);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isInnerClass">template <strong id="isInnerClass">isInnerClass</strong>(T) if (is(T == class))</dt> <dd>
<p>Determines whether <code>T</code> is a class nested inside another class and that <code>T.outer</code> is the implicit reference to the outer class (i.e. <code>outer</code> has not been used as a field or method name) </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T</td> <td>type to test</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if <code>T</code> is a class nested inside another, with the conditions described above; <code>false</code> otherwise</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">class C
{
    int outer;
}
static assert(!isInnerClass!C);

class Outer1
{
    class Inner1 { }
    class Inner2
    {
        int outer;
    }
}
static assert(isInnerClass!(Outer1.Inner1));
static assert(!isInnerClass!(Outer1.Inner2));

static class Outer2
{
    static class Inner
    {
        int outer;
    }
}
static assert(!isInnerClass!(Outer2.Inner));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isNested">template <strong id="isNested">isNested</strong>(T) if (is(T == class) || is(T == struct) || is(T == union))</dt> <dd>
<p>Determines whether <code>T</code> has its own context pointer. <code>T</code> must be either <code>class</code>, <code>struct</code>, or <code>union</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static struct S { }
static assert(!isNested!S);

int i;
struct NestedStruct { void f() { ++i; } }
static assert(isNested!NestedStruct);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="hasNested">template <strong id="hasNested">hasNested</strong>(T)</dt> <dd>
<p>Determines whether <code>T</code> or any of its representation types have a context pointer.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static struct S { }

int i;
struct NS { void f() { ++i; } }

static assert(!hasNested!(S[2]));
static assert(hasNested!(NS[2]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Fields">template <strong id="Fields">Fields</strong>(T)</dt> <dd>
<p>Get as a tuple the types of the fields of a struct, class, or union. This consists of the fields that take up memory space, excluding the hidden fields like the virtual function table pointer or a context pointer for nested types. If <code>T</code> isn't a struct, class, or union returns a tuple with one element <code>T</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.meta : AliasSeq;
struct S { int x; float y; }
static assert(is(Fields!S == AliasSeq!(int, float)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="FieldTypeTuple">alias <strong id="FieldTypeTuple">FieldTypeTuple</strong> = Fields(T); </dt> <dd>
<p>Alternate name for <a href="#Fields"><code>Fields</code></a>, kept for legacy compatibility.</p> </dd> <dt class="d_decl" id="FieldNameTuple">template <strong id="FieldNameTuple">FieldNameTuple</strong>(T)</dt> <dd>
<p>Get as an expression tuple the names of the fields of a struct, class, or union. This consists of the fields that take up memory space, excluding the hidden fields like the virtual function table pointer or a context pointer for nested types. Inherited fields (for classes) are not included. If <code>T</code> isn't a struct, class, or union, an expression tuple with an empty string is returned.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.meta : AliasSeq;
struct S { int x; float y; }
static assert(FieldNameTuple!S == AliasSeq!("x", "y"));
static assert(FieldNameTuple!int == AliasSeq!"");
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="RepresentationTypeTuple">template <strong id="RepresentationTypeTuple">RepresentationTypeTuple</strong>(T)</dt> <dd>
<p>Get the primitive types of the fields of a struct or class, in topological order.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">struct S1 { int a; float b; }
struct S2 { char[] a; union { S1 b; S1 * c; } }
alias R = RepresentationTypeTuple!S2;
assert(R.length == 4
    &amp;&amp; is(R[0] == char[]) &amp;&amp; is(R[1] == int)
    &amp;&amp; is(R[2] == float) &amp;&amp; is(R[3] == S1*));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="hasAliasing">enum auto <strong id="hasAliasing">hasAliasing</strong>(T...); </dt> <dd>
<p>Returns <code>true</code> if and only if <code>T</code>'s representation includes at least one of the following: <ol>
<li>a raw pointer <code>U*</code> and <code>U</code> is not immutable;</li> <li>an array <code>U[]</code> and <code>U</code> is not immutable;</li> <li>a reference to a class or interface type <code>C</code> and <code>C</code> is not immutable.</li> <li>an associative array that is not immutable.</li> <li>a delegate.</li>
</ol></p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">struct S1 { int a; Object b; }
struct S2 { string a; }
struct S3 { int a; immutable Object b; }
struct S4 { float[3] vals; }
static assert( hasAliasing!S1);
static assert(!hasAliasing!S2);
static assert(!hasAliasing!S3);
static assert(!hasAliasing!S4);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="hasIndirections">template <strong id="hasIndirections">hasIndirections</strong>(T)</dt> <dd>
<p>Returns <code>true</code> if and only if <code>T</code>'s representation includes at least one of the following: <ol>
<li>a raw pointer <code>U*</code>;</li> <li>an array <code>U[]</code>;</li> <li>a reference to a class type <code>C</code>;</li> <li>an associative array;</li> <li>a delegate;</li> <li>a <a href="#isNested"><code>context pointer</code></a>.</li>
</ol></p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert( hasIndirections!(int[string]));
static assert( hasIndirections!(void delegate()));
static assert( hasIndirections!(void delegate() immutable));
static assert( hasIndirections!(immutable(void delegate())));
static assert( hasIndirections!(immutable(void delegate() immutable)));

static assert(!hasIndirections!(void function()));
static assert( hasIndirections!(void*[1]));
static assert(!hasIndirections!(byte[1]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="hasUnsharedAliasing">enum auto <strong id="hasUnsharedAliasing">hasUnsharedAliasing</strong>(T...); </dt> <dd>
<p>Returns <code>true</code> if and only if <code>T</code>'s representation includes at least one of the following: <ol>
<li>a raw pointer <code>U*</code> and <code>U</code> is not immutable or shared;</li> <li>an array <code>U[]</code> and <code>U</code> is not immutable or shared;</li> <li>a reference to a class type <code>C</code> and <code>C</code> is not immutable or shared.</li> <li>an associative array that is not immutable or shared.</li> <li>a delegate that is not shared.</li>
</ol></p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">struct S1 { int a; Object b; }
struct S2 { string a; }
struct S3 { int a; immutable Object b; }
static assert( hasUnsharedAliasing!S1);
static assert(!hasUnsharedAliasing!S2);
static assert(!hasUnsharedAliasing!S3);

struct S4 { int a; shared Object b; }
struct S5 { char[] a; }
struct S6 { shared char[] b; }
struct S7 { float[3] vals; }
static assert(!hasUnsharedAliasing!S4);
static assert( hasUnsharedAliasing!S5);
static assert(!hasUnsharedAliasing!S6);
static assert(!hasUnsharedAliasing!S7);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="hasElaborateCopyConstructor">template <strong id="hasElaborateCopyConstructor">hasElaborateCopyConstructor</strong>(S)</dt> <dd>
<p>True if <code>S</code> or any type embedded directly in the representation of <code>S</code> defines an elaborate copy constructor. Elaborate copy constructors are introduced by defining <code>this(this)</code> for a <code>struct</code>. </p>
<p>Classes and unions never have elaborate copy constructors.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(!hasElaborateCopyConstructor!int);

static struct S1 { }
static struct S2 { this(this) {} }
static struct S3 { S2 field; }
static struct S4 { S3[1] field; }
static struct S5 { S3[] field; }
static struct S6 { S3[0] field; }
static struct S7 { @disable this(); S3 field; }
static assert(!hasElaborateCopyConstructor!S1);
static assert( hasElaborateCopyConstructor!S2);
static assert( hasElaborateCopyConstructor!(immutable S2));
static assert( hasElaborateCopyConstructor!S3);
static assert( hasElaborateCopyConstructor!(S3[1]));
static assert(!hasElaborateCopyConstructor!(S3[0]));
static assert( hasElaborateCopyConstructor!S4);
static assert(!hasElaborateCopyConstructor!S5);
static assert(!hasElaborateCopyConstructor!S6);
static assert( hasElaborateCopyConstructor!S7);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="hasElaborateAssign">template <strong id="hasElaborateAssign">hasElaborateAssign</strong>(S)</dt> <dd>
<p>True if <code>S</code> or any type directly embedded in the representation of <code>S</code> defines an elaborate assignment. Elaborate assignments are introduced by defining <code>opAssign(typeof(this))</code> or <code>opAssign(ref typeof(this))</code> for a <code>struct</code> or when there is a compiler-generated <code>opAssign</code>. </p>
<p>A type <code>S</code> gets compiler-generated <code>opAssign</code> if it has an elaborate destructor. <br><br> Classes and unions never have elaborate assignments. </p> <dl>
<dt>Note</dt>
<dd> Structs with (possibly nested) postblit operator(s) will have a hidden yet elaborate compiler generated assignment operator (unless explicitly disabled).</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(!hasElaborateAssign!int);

static struct S  { void opAssign(S) {} }
static assert( hasElaborateAssign!S);
static assert(!hasElaborateAssign!(const(S)));

static struct S1 { void opAssign(ref S1) {} }
static struct S2 { void opAssign(int) {} }
static struct S3 { S s; }
static assert( hasElaborateAssign!S1);
static assert(!hasElaborateAssign!S2);
static assert( hasElaborateAssign!S3);
static assert( hasElaborateAssign!(S3[1]));
static assert(!hasElaborateAssign!(S3[0]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="hasElaborateDestructor">template <strong id="hasElaborateDestructor">hasElaborateDestructor</strong>(S)</dt> <dd>
<p>True if <code>S</code> or any type directly embedded in the representation of <code>S</code> defines an elaborate destructor. Elaborate destructors are introduced by defining <code>~this()</code> for a <code> struct</code>. </p>
<p>Classes and unions never have elaborate destructors, even though classes may define <code>~this()</code>.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(!hasElaborateDestructor!int);

static struct S1 { }
static struct S2 { ~this() {} }
static struct S3 { S2 field; }
static struct S4 { S3[1] field; }
static struct S5 { S3[] field; }
static struct S6 { S3[0] field; }
static struct S7 { @disable this(); S3 field; }
static assert(!hasElaborateDestructor!S1);
static assert( hasElaborateDestructor!S2);
static assert( hasElaborateDestructor!(immutable S2));
static assert( hasElaborateDestructor!S3);
static assert( hasElaborateDestructor!(S3[1]));
static assert(!hasElaborateDestructor!(S3[0]));
static assert( hasElaborateDestructor!S4);
static assert(!hasElaborateDestructor!S5);
static assert(!hasElaborateDestructor!S6);
static assert( hasElaborateDestructor!S7);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="hasElaborateMove">template <strong id="hasElaborateMove">hasElaborateMove</strong>(S)</dt> <dd>
<p>True if <code>S</code> or any type embedded directly in the representation of <code>S</code> defines elaborate move semantics. Elaborate move semantics are introduced by defining <code>opPostMove(ref typeof(this))</code> for a <code>struct</code>. </p>
<p>Classes and unions never have elaborate move semantics.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(!hasElaborateMove!int);

static struct S1 { }
static struct S2 { void opPostMove(ref S2) {} }
static struct S3 { void opPostMove(inout ref S3) inout {} }
static struct S4 { void opPostMove(const ref S4) {} }
static struct S5 { void opPostMove(S5) {} }
static struct S6 { void opPostMove(int) {} }
static struct S7 { S3[1] field; }
static struct S8 { S3[] field; }
static struct S9 { S3[0] field; }
static struct S10 { @disable this(); S3 field; }
static assert(!hasElaborateMove!S1);
static assert( hasElaborateMove!S2);
static assert( hasElaborateMove!S3);
static assert( hasElaborateMove!(immutable S3));
static assert( hasElaborateMove!S4);
static assert(!hasElaborateMove!S5);
static assert(!hasElaborateMove!S6);
static assert( hasElaborateMove!S7);
static assert(!hasElaborateMove!S8);
static assert(!hasElaborateMove!S9);
static assert( hasElaborateMove!S10);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="hasMember">enum auto <strong id="hasMember">hasMember</strong>(T, string name); </dt> <dd>
<p>Yields <code>true</code> if and only if <code>T</code> is an aggregate that defines a symbol called <code>name</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(!hasMember!(int, "blah"));
struct S1 { int blah; }
struct S2 { int blah(){ return 0; } }
class C1 { int blah; }
class C2 { int blah(){ return 0; } }
static assert(hasMember!(S1, "blah"));
static assert(hasMember!(S2, "blah"));
static assert(hasMember!(C1, "blah"));
static assert(hasMember!(C2, "blah"));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="hasStaticMember">template <strong id="hasStaticMember">hasStaticMember</strong>(T, string member)</dt> <dd>
<p>Whether the symbol represented by the string, member, exists and is a static member of T. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T</td> <td>Type containing symbol <code>member</code>.</td>
</tr> <tr>
<td>member</td> <td>Name of symbol to test that resides in <code>T</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>true</code> iff <code>member</code> exists and is static.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static struct S
{
    static void sf() {}
    void f() {}

    static int si;
    int i;
}

static assert( hasStaticMember!(S, "sf"));
static assert(!hasStaticMember!(S, "f"));

static assert( hasStaticMember!(S, "si"));
static assert(!hasStaticMember!(S, "i"));

static assert(!hasStaticMember!(S, "hello"));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="EnumMembers">template <strong id="EnumMembers">EnumMembers</strong>(E) if (is(E == enum))</dt> <dd>
<p>Retrieves the members of an enumerated type <code>enum E</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>E</td> <td>An enumerated type. <code>E</code> may have duplicated values.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>Static tuple composed of the members of the enumerated type <code>E</code>. The members are arranged in the same order as declared in <code>E</code>. The name of the enum can be found by querying the compiler for the name of the identifier, i.e. <code>__traits(identifier, EnumMembers!MyEnum[i])</code>. For enumerations with unique values, <a href="std_conv.html#to"><code>std.conv.to</code></a> can also be used. </dd>
</dl> <dl>
<dt>Note</dt>
<dd> An enum can have multiple members which have the same value. If you want to use EnumMembers to e.g. generate switch cases at compile-time, you should use the <a href="std_meta.html#NoDuplicates"><code>std.meta.NoDuplicates</code></a> template to avoid generating duplicate switch cases. </dd>
</dl> <dl>
<dt>Note</dt>
<dd> Returned values are strictly typed with <code>E</code>. Thus, the following code does not work without the explicit cast: </dd>
</dl>
<pre data-language="d">enum E : int { a, b, c }
int[] abc = cast(int[]) [ EnumMembers!E ];
</pre> Cast is not necessary if the type of the variable is inferred. See the example below. <dl>
<dt>Examples:</dt>
<dd>Create an array of enumerated values <pre data-language="d">enum Sqrts : real
{
    one = 1,
    two = 1.41421,
    three = 1.73205
}
auto sqrts = [EnumMembers!Sqrts];
writeln(sqrts); // [Sqrts.one, Sqrts.two, Sqrts.three]
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>A generic function <code>rank(v)</code> in the following example uses this template for finding a member <code>e</code> in an enumerated type <code>E</code>. <pre data-language="d">// Returns i if e is the i-th enumerator of E.
static size_t rank(E)(E e)
if (is(E == enum))
{
    static foreach (i, member; EnumMembers!E)
    {
        if (e == member)
            return i;
    }
    assert(0, "Not an enum member");
}

enum Mode
{
    read = 1,
    write = 2,
    map = 4
}
writeln(rank(Mode.read)); // 0
writeln(rank(Mode.write)); // 1
writeln(rank(Mode.map)); // 2
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Use EnumMembers to generate a switch statement using static foreach. <pre data-language="d">import std.conv : to;
class FooClass
{
    string calledMethod;
    void foo() @safe { calledMethod = "foo"; }
    void bar() @safe { calledMethod = "bar"; }
    void baz() @safe { calledMethod = "baz"; }
}

enum FooEnum { foo, bar, baz }

auto var = FooEnum.bar;
auto fooObj = new FooClass();
s: final switch (var)
{
    static foreach (member; EnumMembers!FooEnum)
    {
        case member: // Generate a case for each enum value.
            // Call fooObj.{name of enum value}().
            __traits(getMember, fooObj, to!string(member))();
            break s;
    }
}
// As we pass in FooEnum.bar, the bar() method gets called.
writeln(fooObj.calledMethod); // "bar"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="BaseTypeTuple">template <strong id="BaseTypeTuple">BaseTypeTuple</strong>(A)</dt> <dd>
<p>Get a <span class="d_param">AliasSeq</span> of the base class and base interfaces of this class or interface. <span class="d_param">BaseTypeTuple!Object</span> returns the empty type tuple.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.meta : AliasSeq;

interface I1 { }
interface I2 { }
interface I12 : I1, I2 { }
static assert(is(BaseTypeTuple!I12 == AliasSeq!(I1, I2)));

interface I3 : I1 { }
interface I123 : I1, I2, I3 { }
static assert(is(BaseTypeTuple!I123 == AliasSeq!(I1, I2, I3)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="BaseClassesTuple">template <strong id="BaseClassesTuple">BaseClassesTuple</strong>(T) if (is(T == class))</dt> <dd>
<p>Get a <span class="d_param">AliasSeq</span> of <i>all</i> base classes of this class, in decreasing order. Interfaces are not included. <span class="d_param"> BaseClassesTuple!Object</span> yields the empty type tuple.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.meta : AliasSeq;

class C1 { }
class C2 : C1 { }
class C3 : C2 { }
static assert(!BaseClassesTuple!Object.length);
static assert(is(BaseClassesTuple!C1 == AliasSeq!(Object)));
static assert(is(BaseClassesTuple!C2 == AliasSeq!(C1, Object)));
static assert(is(BaseClassesTuple!C3 == AliasSeq!(C2, C1, Object)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="InterfacesTuple">template <strong id="InterfacesTuple">InterfacesTuple</strong>(T)</dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T</td> <td>The <code>class</code> or <code>interface</code> to search.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<a href="std_meta.html#AliasSeq"><code>std.meta.AliasSeq</code></a> of all interfaces directly or indirectly inherited by this class or interface. Interfaces do not repeat if multiply implemented.  <code>InterfacesTuple!Object</code> yields an empty <code>AliasSeq</code>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">interface I1 {}
interface I2 {}
class A : I1, I2 {}
class B : A, I1 {}
class C : B {}

alias TL = InterfacesTuple!C;
static assert(is(TL[0] == I1) &amp;&amp; is(TL[1] == I2));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="TransitiveBaseTypeTuple">template <strong id="TransitiveBaseTypeTuple">TransitiveBaseTypeTuple</strong>(T)</dt> <dd>
<p>Get a <span class="d_param">AliasSeq</span> of <i>all</i> base classes of <span class="d_param"> T</span>, in decreasing order, followed by <span class="d_param">T</span>'s interfaces. <span class="d_param">TransitiveBaseTypeTuple!Object</span> yields the empty type tuple.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">interface J1 {}
interface J2 {}
class B1 {}
class B2 : B1, J1, J2 {}
class B3 : B2, J1 {}
alias TL = TransitiveBaseTypeTuple!B3;
writeln(TL.length); // 5
assert(is (TL[0] == B2));
assert(is (TL[1] == B1));
assert(is (TL[2] == Object));
assert(is (TL[3] == J1));
assert(is (TL[4] == J2));

writeln(TransitiveBaseTypeTuple!Object.length); // 0
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="MemberFunctionsTuple">template <strong id="MemberFunctionsTuple">MemberFunctionsTuple</strong>(C, string name) if (is(C == class) || is(C == interface))</dt> <dd>
<p>Returns a tuple of non-static functions with the name <code>name</code> declared in the class or interface <code>C</code>. Covariant duplicates are shrunk into the most derived one.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">interface I { I foo(); }
class B
{
    real foo(real v) { return v; }
}
class C : B, I
{
    override C foo() { return this; } // covariant overriding of I.foo()
}
alias foos = MemberFunctionsTuple!(C, "foo");
static assert(foos.length == 2);
static assert(__traits(isSame, foos[0], C.foo));
static assert(__traits(isSame, foos[1], B.foo));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="TemplateOf">template <strong id="TemplateOf">TemplateOf</strong>(alias T : Base!Args, alias Base, Args...)<br><br>template <strong id="TemplateOf">TemplateOf</strong>(T : Base!Args, alias Base, Args...)<br><br>template <strong id="TemplateOf">TemplateOf</strong>(T)</dt> <dd>
<p>Returns an alias to the template that <code>T</code> is an instance of. It will return <code>void</code> if a symbol without a template is given.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">struct Foo(T, U) {}
static assert(__traits(isSame, TemplateOf!(Foo!(int, real)), Foo));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="TemplateArgsOf">template <strong id="TemplateArgsOf">TemplateArgsOf</strong>(alias T : Base!Args, alias Base, Args...)<br><br>template <strong id="TemplateArgsOf">TemplateArgsOf</strong>(T : Base!Args, alias Base, Args...)</dt> <dd>
<p>Returns a <code>AliasSeq</code> of the template arguments used to instantiate <code>T</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.meta : AliasSeq;

struct Foo(T, U) {}
static assert(is(TemplateArgsOf!(Foo!(int, real)) == AliasSeq!(int, real)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="classInstanceAlignment">template <strong id="classInstanceAlignment">classInstanceAlignment</strong>(T) if (is(T == class))</dt> <dd>
<p>Returns class instance alignment.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">class A { byte b; }
class B { long l; }

// As class instance always has a hidden pointer
static assert(classInstanceAlignment!A == (void*).alignof);
static assert(classInstanceAlignment!B == long.alignof);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="CommonType">template <strong id="CommonType">CommonType</strong>(T...)</dt> <dd>
<p>Get the type that all types can be implicitly converted to. Useful e.g. in figuring out an array type from a bunch of initializing values. Returns <span class="d_param">void</span> if passed an empty list, or if the types have no common type.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">alias X = CommonType!(int, long, short);
assert(is(X == long));
alias Y = CommonType!(int, char[], short);
assert(is(Y == void));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(is(CommonType!(3) == int));
static assert(is(CommonType!(double, 4, float) == double));
static assert(is(CommonType!(string, char[]) == const(char)[]));
static assert(is(CommonType!(3, 3U) == uint));
static assert(is(CommonType!(double, int) == double));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="ImplicitConversionTargets">template <strong id="ImplicitConversionTargets">ImplicitConversionTargets</strong>(T)</dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T</td> <td>The type to check</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>An <a href="std_meta.html#AliasSeq"><code>std.meta.AliasSeq</code></a> with all possible target types of an implicit conversion <code>T</code>.  If <code>T</code> is a class derived from <code>Object</code>, the the result of <a href="#TransitiveBaseTypeTuple"><code>TransitiveBaseTypeTuple</code></a> is returned.  If the type is not a built-in value type or a class derived from <code>Object</code>, the an empty <a href="std_meta.html#AliasSeq"><code>std.meta.AliasSeq</code></a> is returned. </dd>
</dl> <dl>
<dt>Note</dt>
<dd> The possible targets are computed more conservatively than the language allows, eliminating all dangerous conversions. For example, <code>ImplicitConversionTargets!double</code> does not include <code>float</code>. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd><a href="#isImplicitlyConvertible"><code>isImplicitlyConvertible</code></a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.meta : AliasSeq;

static assert(is(ImplicitConversionTargets!(ulong) == AliasSeq!(float, double, real)));
static assert(is(ImplicitConversionTargets!(int) == AliasSeq!(long, ulong, float, double, real)));
static assert(is(ImplicitConversionTargets!(float) == AliasSeq!(double, real)));
static assert(is(ImplicitConversionTargets!(double) == AliasSeq!(real)));

static assert(is(ImplicitConversionTargets!(char) == AliasSeq!(
    wchar, dchar, byte, ubyte, short, ushort, int, uint, long, ulong, float, double, real
)));
static assert(is(ImplicitConversionTargets!(wchar) == AliasSeq!(
    dchar, short, ushort, int, uint, long, ulong, float, double, real
)));
static assert(is(ImplicitConversionTargets!(dchar) == AliasSeq!(
    int, uint, long, ulong, float, double, real
)));

static assert(is(ImplicitConversionTargets!(string) == AliasSeq!(const(char)[])));
static assert(is(ImplicitConversionTargets!(void*) == AliasSeq!(void*)));

interface A {}
interface B {}
class C : A, B {}

static assert(is(ImplicitConversionTargets!(C) == AliasSeq!(Object, A, B)));
static assert(is(ImplicitConversionTargets!(const C) == AliasSeq!(const Object, const A, const B)));
static assert(is(ImplicitConversionTargets!(immutable C) == AliasSeq!(
    immutable Object, immutable A, immutable B
)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isImplicitlyConvertible">enum bool <strong id="isImplicitlyConvertible">isImplicitlyConvertible</strong>(From, To); </dt> <dd>
<p>Is <code>From</code> implicitly convertible to <code>To</code>?</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert( isImplicitlyConvertible!(immutable(char), char));
static assert( isImplicitlyConvertible!(const(char), char));
static assert( isImplicitlyConvertible!(char, wchar));
static assert(!isImplicitlyConvertible!(wchar, char));

static assert(!isImplicitlyConvertible!(const(ushort), ubyte));
static assert(!isImplicitlyConvertible!(const(uint), ubyte));
static assert(!isImplicitlyConvertible!(const(ulong), ubyte));

static assert(!isImplicitlyConvertible!(const(char)[], string));
static assert( isImplicitlyConvertible!(string, const(char)[]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isAssignable">enum auto <strong id="isAssignable">isAssignable</strong>(Lhs, Rhs = Lhs); </dt> <dd>
<p>Returns <code>true</code> iff a value of type <code>Rhs</code> can be assigned to a variable of type <code>Lhs</code>. </p>
<p><code>isAssignable</code> returns whether both an lvalue and rvalue can be assigned. <br><br> If you omit <code>Rhs</code>, <code>isAssignable</code> will check identity assignable of <code>Lhs</code>.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert( isAssignable!(long, int));
static assert(!isAssignable!(int, long));
static assert( isAssignable!(const(char)[], string));
static assert(!isAssignable!(string, char[]));

// int is assignable to int
static assert( isAssignable!int);

// immutable int is not assignable to immutable int
static assert(!isAssignable!(immutable int));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isRvalueAssignable">enum auto <strong id="isRvalueAssignable">isRvalueAssignable</strong>(Lhs, Rhs = Lhs); </dt> <dd>
<p>Returns <code>true</code> iff an rvalue of type <code>Rhs</code> can be assigned to a variable of type <code>Lhs</code></p> </dd> <dt class="d_decl" id="isLvalueAssignable">enum auto <strong id="isLvalueAssignable">isLvalueAssignable</strong>(Lhs, Rhs = Lhs); </dt> <dd>
<p>Returns <code>true</code> iff an lvalue of type <code>Rhs</code> can be assigned to a variable of type <code>Lhs</code></p> </dd> <dt class="d_decl" id="isCovariantWith">template <strong id="isCovariantWith">isCovariantWith</strong>(F, G) if (is(F == function) &amp;&amp; is(G == function) || is(F == delegate) &amp;&amp; is(G == delegate) || isFunctionPointer!F &amp;&amp; isFunctionPointer!G)</dt> <dd>
<p>Determines whether the function type <code>F</code> is covariant with <code>G</code>, i.e., functions of the type <code>F</code> can override ones of the type <code>G</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">interface I { I clone(); }
interface J { J clone(); }
class C : I
{
    override C clone()   // covariant overriding of I.clone()
    {
        return new C;
    }
}

// C.clone() can override I.clone(), indeed.
static assert(isCovariantWith!(typeof(C.clone), typeof(I.clone)));

// C.clone() can't override J.clone(); the return type C is not implicitly
// convertible to J.
static assert(!isCovariantWith!(typeof(C.clone), typeof(J.clone)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="rvalueOf">@property T <strong id="rvalueOf">rvalueOf</strong>(T)(inout __InoutWorkaroundStruct = __InoutWorkaroundStruct.init); <br><br>@property ref T <strong id="lvalueOf">lvalueOf</strong>(T)(inout __InoutWorkaroundStruct = __InoutWorkaroundStruct.init); </dt> <dd>
<p>Creates an lvalue or rvalue of type <code>T</code> for <code>typeof(...)</code> and <code>__traits(compiles, ...)</code> purposes. No actual value is returned. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T</td> <td>The type to transform</td>
</tr> </table></dd>
</dl> <dl>
<dt>Note</dt>
<dd> Trying to use returned value will result in a "Symbol Undefined" error at link time.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static int f(int);
static assert(is(typeof(f(rvalueOf!int)) == int));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static bool f(ref int);
static assert(is(typeof(f(lvalueOf!int)) == bool));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isBoolean">enum bool <strong id="isBoolean">isBoolean</strong>(T); </dt> <dd>
<p>Detect whether <code>T</code> is a built-in boolean type.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert( isBoolean!bool);
enum EB : bool { a = true }
static assert( isBoolean!EB);
static assert(!isBoolean!(SubTypeOf!bool));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isIntegral">enum bool <strong id="isIntegral">isIntegral</strong>(T); </dt> <dd>
<p>Detect whether <code>T</code> is a built-in integral type. Types <code>bool</code>, <code>char</code>, <code>wchar</code>, and <code>dchar</code> are not considered integral.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(
    isIntegral!byte &amp;&amp;
    isIntegral!short &amp;&amp;
    isIntegral!int &amp;&amp;
    isIntegral!long &amp;&amp;
    isIntegral!(const(long)) &amp;&amp;
    isIntegral!(immutable(long))
);

static assert(
    !isIntegral!bool &amp;&amp;
    !isIntegral!char &amp;&amp;
    !isIntegral!double
);

// types which act as integral values do not pass
struct S
{
    int val;
    alias val this;
}

static assert(!isIntegral!S);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isFloatingPoint">enum bool <strong id="isFloatingPoint">isFloatingPoint</strong>(T); </dt> <dd>
<p>Detect whether <code>T</code> is a built-in floating point type.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(
    isFloatingPoint!float &amp;&amp;
    isFloatingPoint!double &amp;&amp;
    isFloatingPoint!real &amp;&amp;
    isFloatingPoint!(const(real)) &amp;&amp;
    isFloatingPoint!(immutable(real))
);

static assert(!isFloatingPoint!int);

// complex and imaginary numbers do not pass
static assert(
    !isFloatingPoint!cfloat &amp;&amp;
    !isFloatingPoint!ifloat
);

// types which act as floating point values do not pass
struct S
{
    float val;
    alias val this;
}

static assert(!isFloatingPoint!S);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isNumeric">enum bool <strong id="isNumeric">isNumeric</strong>(T); </dt> <dd>
<p>Detect whether <code>T</code> is a built-in numeric type (integral or floating point).</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(
    isNumeric!byte &amp;&amp;
    isNumeric!short &amp;&amp;
    isNumeric!int &amp;&amp;
    isNumeric!long &amp;&amp;
    isNumeric!float &amp;&amp;
    isNumeric!double &amp;&amp;
    isNumeric!real &amp;&amp;
    isNumeric!(const(real)) &amp;&amp;
    isNumeric!(immutable(real))
);

static assert(
    !isNumeric!void &amp;&amp;
    !isNumeric!bool &amp;&amp;
    !isNumeric!char &amp;&amp;
    !isNumeric!wchar &amp;&amp;
    !isNumeric!dchar
);

// types which act as numeric values do not pass
struct S
{
    int val;
    alias val this;
}

static assert(!isIntegral!S);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isScalarType">enum bool <strong id="isScalarType">isScalarType</strong>(T); </dt> <dd>
<p>Detect whether <code>T</code> is a scalar type (a built-in numeric, character or boolean type).</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(!isScalarType!void);
static assert( isScalarType!(immutable(byte)));
static assert( isScalarType!(immutable(ushort)));
static assert( isScalarType!(immutable(int)));
static assert( isScalarType!(ulong));
static assert( isScalarType!(shared(float)));
static assert( isScalarType!(shared(const bool)));
static assert( isScalarType!(const(char)));
static assert( isScalarType!(wchar));
static assert( isScalarType!(const(dchar)));
static assert( isScalarType!(const(double)));
static assert( isScalarType!(const(real)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isBasicType">enum bool <strong id="isBasicType">isBasicType</strong>(T); </dt> <dd>
<p>Detect whether <code>T</code> is a basic type (scalar type or void).</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(isBasicType!void);
static assert(isBasicType!(const(void)));
static assert(isBasicType!(shared(void)));
static assert(isBasicType!(immutable(void)));
static assert(isBasicType!(shared const(void)));
static assert(isBasicType!(shared inout(void)));
static assert(isBasicType!(shared inout const(void)));
static assert(isBasicType!(inout(void)));
static assert(isBasicType!(inout const(void)));
static assert(isBasicType!(immutable(int)));
static assert(isBasicType!(shared(float)));
static assert(isBasicType!(shared(const bool)));
static assert(isBasicType!(const(dchar)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isUnsigned">enum bool <strong id="isUnsigned">isUnsigned</strong>(T); </dt> <dd>
<p>Detect whether <code>T</code> is a built-in unsigned numeric type.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(
    isUnsigned!uint &amp;&amp;
    isUnsigned!ulong
);

static assert(
    !isUnsigned!char &amp;&amp;
    !isUnsigned!int &amp;&amp;
    !isUnsigned!long &amp;&amp;
    !isUnsigned!char &amp;&amp;
    !isUnsigned!wchar &amp;&amp;
    !isUnsigned!dchar
);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isSigned">enum bool <strong id="isSigned">isSigned</strong>(T); </dt> <dd>
<p>Detect whether <code>T</code> is a built-in signed numeric type.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(
    isSigned!int &amp;&amp;
    isSigned!long
);

static assert(
    !isSigned!uint &amp;&amp;
    !isSigned!ulong
);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isSomeChar">enum bool <strong id="isSomeChar">isSomeChar</strong>(T); </dt> <dd>
<p>Detect whether <code>T</code> is one of the built-in character types. </p>
<p>The built-in char types are any of <code>char</code>, <code>wchar</code> or <code>dchar</code>, with or without qualifiers.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">//Char types
static assert( isSomeChar!char);
static assert( isSomeChar!wchar);
static assert( isSomeChar!dchar);
static assert( isSomeChar!(typeof('c')));
static assert( isSomeChar!(immutable char));
static assert( isSomeChar!(const dchar));

//Non char types
static assert(!isSomeChar!int);
static assert(!isSomeChar!byte);
static assert(!isSomeChar!string);
static assert(!isSomeChar!wstring);
static assert(!isSomeChar!dstring);
static assert(!isSomeChar!(char[4]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isSomeString">enum bool <strong id="isSomeString">isSomeString</strong>(T); </dt> <dd>
<p>Detect whether <code>T</code> is one of the built-in string types. </p>
<p>The built-in string types are <code>Char[]</code>, where <code>Char</code> is any of <code>char</code>, <code>wchar</code> or <code>dchar</code>, with or without qualifiers. <br><br> Static arrays of characters (like <code>char[80]</code>) are not considered built-in string types.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">//String types
static assert( isSomeString!string);
static assert( isSomeString!(wchar[]));
static assert( isSomeString!(dchar[]));
static assert( isSomeString!(typeof("aaa")));
static assert( isSomeString!(const(char)[]));

//Non string types
static assert(!isSomeString!int);
static assert(!isSomeString!(int[]));
static assert(!isSomeString!(byte[]));
static assert(!isSomeString!(typeof(null)));
static assert(!isSomeString!(char[4]));

enum ES : string { a = "aaa", b = "bbb" }
static assert(!isSomeString!ES);

static struct Stringish
{
    string str;
    alias str this;
}
static assert(!isSomeString!Stringish);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isNarrowString">enum bool <strong id="isNarrowString">isNarrowString</strong>(T); </dt> <dd>
<p>Detect whether type <code>T</code> is a narrow string. </p>
<p>All arrays that use char, wchar, and their qualified versions are narrow strings. (Those include string and wstring).</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(isNarrowString!string);
static assert(isNarrowString!wstring);
static assert(isNarrowString!(char[]));
static assert(isNarrowString!(wchar[]));

static assert(!isNarrowString!dstring);
static assert(!isNarrowString!(dchar[]));

static assert(!isNarrowString!(typeof(null)));
static assert(!isNarrowString!(char[4]));

enum ES : string { a = "aaa", b = "bbb" }
static assert(!isNarrowString!ES);

static struct Stringish
{
    string str;
    alias str this;
}
static assert(!isNarrowString!Stringish);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isOrderingComparable">enum bool <strong id="isOrderingComparable">isOrderingComparable</strong>(T); <br><br>enum bool <strong id="isEqualityComparable">isEqualityComparable</strong>(T); </dt> <dd>
<p>Detects whether <code>T</code> is a comparable type. Basic types and structs and classes that implement opCmp are ordering comparable.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(isOrderingComparable!int);
static assert(isOrderingComparable!string);
static assert(!isOrderingComparable!creal);

static struct Foo {}
static assert(!isOrderingComparable!Foo);

static struct Bar
{
    int a;
    auto opCmp(Bar b1) const { return a - b1.a; }
}

Bar b1 = Bar(5);
Bar b2 = Bar(7);
assert(isOrderingComparable!Bar &amp;&amp; b2 &gt; b1);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isConvertibleToString">enum auto <strong id="isConvertibleToString">isConvertibleToString</strong>(T); </dt> <dd>
<p><span class="red">Warning: This trait will be deprecated as soon as it is no longer used in Phobos. For a function parameter to safely accept a type that implicitly converts to string as a string, the conversion needs to happen at the callsite; otherwise, the conversion is done inside the function, and in many cases, that means that local memory is sliced (e.g. if a static array is passed to the function, then it's copied, and the resulting dynamic array will be a slice of a local variable). So, if the resulting string escapes the function, the string refers to invalid memory, and accessing it would mean accessing invalid memory. As such, the only safe way for a function to accept types that implicitly convert to string is for the implicit conversion to be done at the callsite, and that can only occur if the parameter is explicitly typed as an array, whereas using isConvertibleToString in a template constraint would result in the conversion being done inside the function. As such, isConvertibleToString is inherently unsafe and is going to be deprecated.</span> </p>
<p>Detect whether <code>T</code> is a struct, static array, or enum that is implicitly convertible to a string.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static struct AliasedString
{
    string s;
    alias s this;
}

enum StringEnum { a = "foo" }

assert(!isConvertibleToString!string);
assert(isConvertibleToString!AliasedString);
assert(isConvertibleToString!StringEnum);
assert(isConvertibleToString!(char[25]));
assert(!isConvertibleToString!(char[]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isAutodecodableString">enum auto <strong id="isAutodecodableString">isAutodecodableString</strong>(T); </dt> <dd>
<p>Detect whether type <code>T</code> is a string that will be autodecoded. </p>
<p>Given a type <code>S</code> that is one of: <ol> <li><code>const(char)[]</code></li> <li><code>const(wchar)[]</code></li> </ol> Type <code>T</code> can be one of: <ol> <li><code>S</code></li> <li>implicitly convertible to <code>T</code>
</li> <li>an enum with a base type <code>T</code>
</li> <li>an aggregate with a base type <code>T</code>
</li> </ol> with the proviso that <code>T</code> cannot be a static array. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T</td> <td>type to be tested</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>true if T represents a string that is subject to autodecoding  See Also: <a href="#isNarrowString"><code>isNarrowString</code></a>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static struct Stringish
{
    string s;
    alias s this;
}
static assert(isAutodecodableString!wstring);
static assert(isAutodecodableString!Stringish);
static assert(!isAutodecodableString!dstring);

enum E : const(char)[3] { X = "abc" }
enum F : const(char)[] { X = "abc" }
enum G : F { X = F.init }

static assert(isAutodecodableString!(char[]));
static assert(!isAutodecodableString!(E));
static assert(isAutodecodableString!(F));
static assert(isAutodecodableString!(G));

struct Stringish2
{
    Stringish s;
    alias s this;
}

enum H : Stringish { X = Stringish() }
enum I : Stringish2 { X = Stringish2() }

static assert(isAutodecodableString!(H));
static assert(isAutodecodableString!(I));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isStaticArray">enum bool <strong id="isStaticArray">isStaticArray</strong>(T); </dt> <dd>
<p>Detect whether type <code>T</code> is a static array.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert( isStaticArray!(int[3]));
static assert( isStaticArray!(const(int)[5]));
static assert( isStaticArray!(const(int)[][5]));

static assert(!isStaticArray!(const(int)[]));
static assert(!isStaticArray!(immutable(int)[]));
static assert(!isStaticArray!(const(int)[4][]));
static assert(!isStaticArray!(int[]));
static assert(!isStaticArray!(int[char]));
static assert(!isStaticArray!(int[1][]));
static assert(!isStaticArray!(int[int]));
static assert(!isStaticArray!int);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isDynamicArray">enum bool <strong id="isDynamicArray">isDynamicArray</strong>(T); </dt> <dd>
<p>Detect whether type <code>T</code> is a dynamic array.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert( isDynamicArray!(int[]));
static assert( isDynamicArray!(string));
static assert( isDynamicArray!(long[3][]));

static assert(!isDynamicArray!(int[5]));
static assert(!isDynamicArray!(typeof(null)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isArray">enum bool <strong id="isArray">isArray</strong>(T); </dt> <dd>
<p>Detect whether type <code>T</code> is an array (static or dynamic; for associative arrays see <a href="#isAssociativeArray"><code>isAssociativeArray</code></a>).</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert( isArray!(int[]));
static assert( isArray!(int[5]));
static assert( isArray!(string));

static assert(!isArray!uint);
static assert(!isArray!(uint[uint]));
static assert(!isArray!(typeof(null)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isAssociativeArray">enum bool <strong id="isAssociativeArray">isAssociativeArray</strong>(T); </dt> <dd>
<p>Detect whether <code>T</code> is an associative array type</p> </dd> <dt class="d_decl" id="isBuiltinType">enum bool <strong id="isBuiltinType">isBuiltinType</strong>(T); </dt> <dd>
<p>Detect whether type <code>T</code> is a builtin type.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">class C;
union U;
struct S;
interface I;

static assert( isBuiltinType!void);
static assert( isBuiltinType!string);
static assert( isBuiltinType!(int[]));
static assert( isBuiltinType!(C[string]));
static assert(!isBuiltinType!C);
static assert(!isBuiltinType!U);
static assert(!isBuiltinType!S);
static assert(!isBuiltinType!I);
static assert(!isBuiltinType!(void delegate(int)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isSIMDVector">enum bool <strong id="isSIMDVector">isSIMDVector</strong>(T); </dt> <dd>
<p>Detect whether type <code>T</code> is a SIMD vector type.</p> </dd> <dt class="d_decl" id="isPointer">enum bool <strong id="isPointer">isPointer</strong>(T); </dt> <dd>
<p>Detect whether type <code>T</code> is a pointer.</p> </dd> <dt class="d_decl" id="PointerTarget">template <strong id="PointerTarget">PointerTarget</strong>(T : T*)</dt> <dd>
<p>Returns the target type of a pointer.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(is(PointerTarget!(int*) == int));
static assert(is(PointerTarget!(void*) == void));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isAggregateType">enum bool <strong id="isAggregateType">isAggregateType</strong>(T); </dt> <dd>
<p>Detect whether type <code>T</code> is an aggregate type.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">class C;
union U;
struct S;
interface I;

static assert( isAggregateType!C);
static assert( isAggregateType!U);
static assert( isAggregateType!S);
static assert( isAggregateType!I);
static assert(!isAggregateType!void);
static assert(!isAggregateType!string);
static assert(!isAggregateType!(int[]));
static assert(!isAggregateType!(C[string]));
static assert(!isAggregateType!(void delegate(int)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isIterable">enum bool <strong id="isIterable">isIterable</strong>(T); </dt> <dd>
<p>Returns <code>true</code> if T can be iterated over using a <code>foreach</code> loop with a single loop variable of automatically inferred type, regardless of how the <code>foreach</code> loop is implemented. This includes ranges, structs/classes that define <code>opApply</code> with a single loop variable, and builtin dynamic, static and associative arrays.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">struct OpApply
{
    int opApply(scope int delegate(ref uint) dg) { assert(0); }
}

struct Range
{
    @property uint front() { assert(0); }
    void popFront() { assert(0); }
    enum bool empty = false;
}

static assert( isIterable!(uint[]));
static assert( isIterable!OpApply);
static assert( isIterable!(uint[string]));
static assert( isIterable!Range);

static assert(!isIterable!uint);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isMutable">enum bool <strong id="isMutable">isMutable</strong>(T); </dt> <dd>
<p>Returns true if T is not const or immutable. Note that isMutable is true for string, or immutable(char)[], because the 'head' is mutable.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert( isMutable!int);
static assert( isMutable!string);
static assert( isMutable!(shared int));
static assert( isMutable!(shared const(int)[]));

static assert(!isMutable!(const int));
static assert(!isMutable!(inout int));
static assert(!isMutable!(shared(const int)));
static assert(!isMutable!(shared(inout int)));
static assert(!isMutable!(immutable string));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isInstanceOf">enum bool <strong id="isInstanceOf">isInstanceOf</strong>(alias S, T); <br><br>enum auto <strong id="isInstanceOf">isInstanceOf</strong>(alias S, alias T); </dt> <dd>
<p>Returns true if T is an instance of the template S.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static struct Foo(T...) { }
static struct Bar(T...) { }
static struct Doo(T) { }
static struct ABC(int x) { }
static void fun(T)() { }
template templ(T) { }

static assert(isInstanceOf!(Foo, Foo!int));
static assert(!isInstanceOf!(Foo, Bar!int));
static assert(!isInstanceOf!(Foo, int));
static assert(isInstanceOf!(Doo, Doo!int));
static assert(isInstanceOf!(ABC, ABC!1));
static assert(!isInstanceOf!(Foo, Foo));
static assert(isInstanceOf!(fun, fun!int));
static assert(isInstanceOf!(templ, templ!int));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>To use <code>isInstanceOf</code> to check the identity of a template while inside of said template, use <a href="#TemplateOf"><code>TemplateOf</code></a>. <pre data-language="d">static struct A(T = void)
{
    // doesn't work as expected, only accepts A when T = void
    void func(B)(B b) if (isInstanceOf!(A, B)) {}

    // correct behavior
    void method(B)(B b) if (isInstanceOf!(TemplateOf!(A), B)) {}
}

A!(void) a1;
A!(void) a2;
A!(int) a3;

static assert(!__traits(compiles, a1.func(a3)));
static assert( __traits(compiles, a1.method(a2)));
static assert( __traits(compiles, a1.method(a3)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isExpressions">template <strong id="isExpressions">isExpressions</strong>(T...)</dt> <dd>
<p>Check whether the tuple T is an expression tuple. An expression tuple only contains expressions. </p>
<dl>
<dt>See Also:</dt>
<dd>
<a href="#isTypeTuple"><code>isTypeTuple</code></a>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(isExpressions!(1, 2.0, "a"));
static assert(!isExpressions!(int, double, string));
static assert(!isExpressions!(int, 2.0, "a"));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isExpressionTuple">alias <strong id="isExpressionTuple">isExpressionTuple</strong> = isExpressions(T...); </dt> <dd>
<p>Alternate name for <a href="#isExpressions"><code>isExpressions</code></a>, kept for legacy compatibility.</p> </dd> <dt class="d_decl" id="isTypeTuple">template <strong id="isTypeTuple">isTypeTuple</strong>(T...)</dt> <dd>
<p>Check whether the tuple <code>T</code> is a type tuple. A type tuple only contains types. </p>
<dl>
<dt>See Also:</dt>
<dd>
<a href="#isExpressions"><code>isExpressions</code></a>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(isTypeTuple!(int, float, string));
static assert(!isTypeTuple!(1, 2.0, "a"));
static assert(!isTypeTuple!(1, double, string));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isFunctionPointer">template <strong id="isFunctionPointer">isFunctionPointer</strong>(T...) if (T.length == 1)</dt> <dd>
<p>Detect whether symbol or type <code>T</code> is a function pointer.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static void foo() {}
void bar() {}

auto fpfoo = &amp;foo;
static assert( isFunctionPointer!fpfoo);
static assert( isFunctionPointer!(void function()));

auto dgbar = &amp;bar;
static assert(!isFunctionPointer!dgbar);
static assert(!isFunctionPointer!(void delegate()));
static assert(!isFunctionPointer!foo);
static assert(!isFunctionPointer!bar);

static assert( isFunctionPointer!((int a) {}));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isDelegate">template <strong id="isDelegate">isDelegate</strong>(T...) if (T.length == 1)</dt> <dd>
<p>Detect whether symbol or type <code>T</code> is a delegate.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static void sfunc() { }
int x;
void func() { x++; }

int delegate() dg;
assert(isDelegate!dg);
assert(isDelegate!(int delegate()));
assert(isDelegate!(typeof(&amp;func)));

int function() fp;
assert(!isDelegate!fp);
assert(!isDelegate!(int function()));
assert(!isDelegate!(typeof(&amp;sfunc)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isSomeFunction">template <strong id="isSomeFunction">isSomeFunction</strong>(T...) if (T.length == 1)</dt> <dd>
<p>Detect whether symbol or type <code>T</code> is a function, a function pointer or a delegate. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T</td> <td>The type to check</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A <code>bool</code>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static real func(ref int) { return 0; }
static void prop() @property { }
class C
{
    real method(ref int) { return 0; }
    real prop() @property { return 0; }
}
auto c = new C;
auto fp = &amp;func;
auto dg = &amp;c.method;
real val;

static assert( isSomeFunction!func);
static assert( isSomeFunction!prop);
static assert( isSomeFunction!(C.method));
static assert( isSomeFunction!(C.prop));
static assert( isSomeFunction!(c.prop));
static assert( isSomeFunction!(c.prop));
static assert( isSomeFunction!fp);
static assert( isSomeFunction!dg);

static assert(!isSomeFunction!int);
static assert(!isSomeFunction!val);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isCallable">template <strong id="isCallable">isCallable</strong>(alias callable)</dt> <dd>
<p>Detect whether <code>T</code> is a callable object, which can be called with the function call operator <code>(...)</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>Functions, lambdas, and aggregate types with (static) opCall. <pre data-language="d">void f() { }
int g(int x) { return x; }

static assert( isCallable!f);
static assert( isCallable!g);

class C { int opCall(int) { return 0; } }
auto c = new C;
struct S { static int opCall(int) { return 0; } }
interface I { real value() @property; }

static assert( isCallable!c);
static assert( isCallable!(c.opCall));
static assert( isCallable!S);
static assert( isCallable!(I.value));
static assert( isCallable!((int a) { return a; }));

static assert(!isCallable!I);
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Templates <pre data-language="d">void f()() { }
T g(T = int)(T x) { return x; }

static assert( isCallable!f);
static assert( isCallable!g);
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Overloaded functions and function templates. <pre data-language="d">static struct Wrapper
{
    void f() { }
    int f(int x) { return x; }

    void g()() { }
    T g(T = int)(T x) { return x; }
}

static assert(isCallable!(Wrapper.f));
static assert(isCallable!(Wrapper.g));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isAbstractFunction">template <strong id="isAbstractFunction">isAbstractFunction</strong>(T...) if (T.length == 1)</dt> <dd>
<p>Detect whether <code>T</code> is an abstract function. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T</td> <td>The type to check</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A <code>bool</code>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">struct S { void foo() { } }
class C { void foo() { } }
class AC { abstract void foo(); }
static assert(!isAbstractFunction!(int));
static assert(!isAbstractFunction!(S.foo));
static assert(!isAbstractFunction!(C.foo));
static assert( isAbstractFunction!(AC.foo));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isFinalFunction">template <strong id="isFinalFunction">isFinalFunction</strong>(T...) if (T.length == 1)</dt> <dd>
<p>Detect whether <code>T</code> is a final function.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">struct S { void bar() { } }
final class FC { void foo(); }
class C
{
    void bar() { }
    final void foo();
}
static assert(!isFinalFunction!(int));
static assert(!isFinalFunction!(S.bar));
static assert( isFinalFunction!(FC.foo));
static assert(!isFinalFunction!(C.bar));
static assert( isFinalFunction!(C.foo));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isNestedFunction">enum auto <strong id="isNestedFunction">isNestedFunction</strong>(alias f); </dt> <dd>
<p>Determines if <code>f</code> is a function that requires a context pointer. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>f</td> <td>The type to check Returns A <code>bool</code>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static void f() {}
static void fun()
{
    int i;
    int f() { return i; }

    static assert(isNestedFunction!(f));
}

static assert(!isNestedFunction!f);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isAbstractClass">template <strong id="isAbstractClass">isAbstractClass</strong>(T...) if (T.length == 1)</dt> <dd>
<p>Detect whether <code>T</code> is an abstract class.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">struct S { }
class C { }
abstract class AC { }
static assert(!isAbstractClass!S);
static assert(!isAbstractClass!C);
static assert( isAbstractClass!AC);
C c;
static assert(!isAbstractClass!c);
AC ac;
static assert( isAbstractClass!ac);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isFinalClass">template <strong id="isFinalClass">isFinalClass</strong>(T...) if (T.length == 1)</dt> <dd>
<p>Detect whether <code>T</code> is a final class.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">class C { }
abstract class AC { }
final class FC1 : C { }
final class FC2 { }
static assert(!isFinalClass!C);
static assert(!isFinalClass!AC);
static assert( isFinalClass!FC1);
static assert( isFinalClass!FC2);
C c;
static assert(!isFinalClass!c);
FC1 fc1;
static assert( isFinalClass!fc1);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Unconst">template <strong id="Unconst">Unconst</strong>(T)</dt> <dd>
<p>Removes <code>const</code>, <code>inout</code> and <code>immutable</code> qualifiers, if any, from type <code>T</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(is(Unconst!int == int));
static assert(is(Unconst!(const int) == int));
static assert(is(Unconst!(immutable int) == int));
static assert(is(Unconst!(shared int) == shared int));
static assert(is(Unconst!(shared(const int)) == shared int));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Unqual">template <strong id="Unqual">Unqual</strong>(T)</dt> <dd>
<p>Removes all qualifiers, if any, from type <code>T</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(is(Unqual!int == int));
static assert(is(Unqual!(const int) == int));
static assert(is(Unqual!(immutable int) == int));
static assert(is(Unqual!(shared int) == int));
static assert(is(Unqual!(shared(const int)) == int));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="CopyTypeQualifiers">template <strong id="CopyTypeQualifiers">CopyTypeQualifiers</strong>(FromType, ToType)</dt> <dd>
<p>Copies type qualifiers from <code>FromType</code> to <code>ToType</code>. </p>
<p>Supported type qualifiers: <ul> <li><code>const</code></li> <li><code>inout</code></li> <li><code>immutable</code></li> <li><code>shared</code></li> </ul></p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(is(CopyTypeQualifiers!(inout const real, int) == inout const int));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="CopyConstness">template <strong id="CopyConstness">CopyConstness</strong>(FromType, ToType)</dt> <dd>
<p>Returns the type of <code>ToType</code> with the "constness" of <code>FromType</code>. A type's <b>constness</b> refers to whether it is <code>const</code>, <code>immutable</code>, or <code>inout</code>. If <code>FromType</code> has no constness, the returned type will be the same as <code>ToType</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">const(int) i;
CopyConstness!(typeof(i), float) f;
assert( is(typeof(f) == const float));

CopyConstness!(char, uint) u;
assert( is(typeof(u) == uint));

//The 'shared' qualifier will not be copied
assert(!is(CopyConstness!(shared bool, int) == shared int));

//But the constness will be
assert( is(CopyConstness!(shared const real, double) == const double));

//Careful, const(int)[] is a mutable array of const(int)
alias MutT = CopyConstness!(const(int)[], int);
assert(!is(MutT == const(int)));

//Okay, const(int[]) applies to array and contained ints
alias CstT = CopyConstness!(const(int[]), int);
assert( is(CstT == const(int)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="ForeachType">template <strong id="ForeachType">ForeachType</strong>(T)</dt> <dd>
<p>Returns the inferred type of the loop variable when a variable of type T is iterated over using a <code>foreach</code> loop with a single loop variable and automatically inferred return type. Note that this may not be the same as <code>std.range.ElementType!Range</code> in the case of narrow strings, or if T has both opApply and a range interface.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(is(ForeachType!(uint[]) == uint));
static assert(is(ForeachType!string == immutable(char)));
static assert(is(ForeachType!(string[string]) == string));
static assert(is(ForeachType!(inout(int)[]) == inout(int)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="OriginalType">template <strong id="OriginalType">OriginalType</strong>(T)</dt> <dd>
<p>Strips off all <code>enum</code>s from type <code>T</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">enum E : real { a = 0 } // NOTE: explicit initialization to 0 required during Enum init deprecation cycle
enum F : E    { a = E.a }
alias G = const(F);
static assert(is(OriginalType!E == real));
static assert(is(OriginalType!F == real));
static assert(is(OriginalType!G == const real));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="KeyType">template <strong id="KeyType">KeyType</strong>(V : V[K], K)</dt> <dd>
<p>Get the Key type of an Associative Array.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">alias Hash = int[string];
static assert(is(KeyType!Hash == string));
static assert(is(ValueType!Hash == int));
KeyType!Hash str = "a"; // str is declared as string
ValueType!Hash num = 1; // num is declared as int
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="ValueType">template <strong id="ValueType">ValueType</strong>(V : V[K], K)</dt> <dd>
<p>Get the Value type of an Associative Array.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">alias Hash = int[string];
static assert(is(KeyType!Hash == string));
static assert(is(ValueType!Hash == int));
KeyType!Hash str = "a"; // str is declared as string
ValueType!Hash num = 1; // num is declared as int
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Unsigned">template <strong id="Unsigned">Unsigned</strong>(T)</dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T</td> <td>A built in integral or vector type.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The corresponding unsigned numeric type for <code>T</code> with the same type qualifiers.  If <code>T</code> is not a integral or vector, a compile-time error is given.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(is(Unsigned!(int) == uint));
static assert(is(Unsigned!(long) == ulong));
static assert(is(Unsigned!(const short) == const ushort));
static assert(is(Unsigned!(immutable byte) == immutable ubyte));
static assert(is(Unsigned!(inout int) == inout uint));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Unsigned types are forwarded <pre data-language="d">static assert(is(Unsigned!(uint) == uint));
static assert(is(Unsigned!(const uint) == const uint));

static assert(is(Unsigned!(ubyte) == ubyte));
static assert(is(Unsigned!(immutable uint) == immutable uint));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Largest">template <strong id="Largest">Largest</strong>(T...) if (T.length &gt;= 1)</dt> <dd>
<p>Returns the largest type, i.e. T such that T.sizeof is the largest. If more than one type is of the same size, the leftmost argument of these in will be returned.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(is(Largest!(uint, ubyte, ushort, real) == real));
static assert(is(Largest!(ulong, double) == ulong));
static assert(is(Largest!(double, ulong) == double));
static assert(is(Largest!(uint, byte, double, short) == double));
static if (is(ucent))
    static assert(is(Largest!(uint, ubyte, ucent, ushort) == ucent));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Signed">template <strong id="Signed">Signed</strong>(T)</dt> <dd>
<p>Returns the corresponding signed type for T. T must be a numeric integral type, otherwise a compile-time error occurs.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">alias S1 = Signed!uint;
static assert(is(S1 == int));
alias S2 = Signed!(const(uint));
static assert(is(S2 == const(int)));
alias S3 = Signed!(immutable(uint));
static assert(is(S3 == immutable(int)));
static if (is(ucent))
{
    alias S4 = Signed!ucent;
    static assert(is(S4 == cent));
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="mostNegative">template <strong id="mostNegative">mostNegative</strong>(T) if (isNumeric!T || isSomeChar!T || isBoolean!T)</dt> <dd>
<p>Returns the most negative value of the numeric type T.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(mostNegative!float == -float.max);
static assert(mostNegative!double == -double.max);
static assert(mostNegative!real == -real.max);
static assert(mostNegative!bool == false);
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.meta : AliasSeq;

static foreach (T; AliasSeq!(bool, byte, short, int, long))
    static assert(mostNegative!T == T.min);

static foreach (T; AliasSeq!(ubyte, ushort, uint, ulong, char, wchar, dchar))
    static assert(mostNegative!T == 0);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Promoted">template <strong id="Promoted">Promoted</strong>(T) if (isScalarType!T)</dt> <dd>
<p>Get the type that a scalar type <code>T</code> will <a href="https://dlang.org/spec/type.html#integer-promotions">promote</a> to in multi-term arithmetic expressions.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">ubyte a = 3, b = 5;
static assert(is(typeof(a * b) == Promoted!ubyte));
static assert(is(Promoted!ubyte == int));

static assert(is(Promoted!(shared(bool)) == shared(int)));
static assert(is(Promoted!(const(int)) == const(int)));
static assert(is(Promoted!double == double));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="mangledName">template <strong id="mangledName">mangledName</strong>(sth...) if (sth.length == 1)</dt> <dd>
<p>Returns the mangled name of symbol or type <code>sth</code>. </p>
<p><code>mangledName</code> is the same as builtin <code>.mangleof</code> property, but might be more convenient in generic code, e.g. as a template argument when invoking staticMap.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.meta : AliasSeq;
alias TL = staticMap!(mangledName, int, const int, immutable int);
static assert(TL == AliasSeq!("i", "xi", "yi"));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Select">template <strong id="Select">Select</strong>(bool condition, T...) if (T.length == 2)</dt> <dd>
<p>Aliases itself to <code>T[0]</code> if the boolean <code>condition</code> is <code>true</code> and to <code>T[1]</code> otherwise.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">// can select types
static assert(is(Select!(true, int, long) == int));
static assert(is(Select!(false, int, long) == long));
static struct Foo {}
static assert(is(Select!(false, const(int), const(Foo)) == const(Foo)));

// can select symbols
int a = 1;
int b = 2;
alias selA = Select!(true, a, b);
alias selB = Select!(false, a, b);
writeln(selA); // 1
writeln(selB); // 2

// can select (compile-time) expressions
enum val = Select!(false, -4, 9 - 6);
static assert(val == 3);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="select">A <strong id="select">select</strong>(bool cond : true, A, B)(A a, lazy B b); <br><br>B <strong id="select">select</strong>(bool cond : false, A, B)(lazy A a, B b); </dt> <dd>
<p>Select one of two functions to run via template parameter. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>cond</td> <td>A <code>bool</code> which determines which function is run</td>
</tr> <tr>
<td>A <code>a</code>
</td> <td>The first function</td>
</tr> <tr>
<td>B <code>b</code>
</td> <td>The second function</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>a</code> without evaluating <code>b</code> if <code>cond</code> is <code>true</code>. Otherwise, returns <code>b</code> without evaluating <code>a</code>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">real run() { return 0; }
int fail() { assert(0); }
auto a = select!true(run(), fail());
auto b = select!false(fail(), run());
static assert(is(typeof(a) == real));
static assert(is(typeof(b) == real));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="hasUDA">enum auto <strong id="hasUDA">hasUDA</strong>(alias symbol, alias attribute); </dt> <dd>
<p>Determine if a symbol has a given <a href="https://dlang.org/spec/attribute.html#uda">user-defined attribute</a>. </p>
<dl>
<dt>See Also:</dt>
<dd><a href="#getUDAs"><code>getUDAs</code></a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">enum E;
struct S {}

@("alpha") int a;
static assert(hasUDA!(a, "alpha"));
static assert(!hasUDA!(a, S));
static assert(!hasUDA!(a, E));

@(E) int b;
static assert(!hasUDA!(b, "alpha"));
static assert(!hasUDA!(b, S));
static assert(hasUDA!(b, E));

@E int c;
static assert(!hasUDA!(c, "alpha"));
static assert(!hasUDA!(c, S));
static assert(hasUDA!(c, E));

@(S, E) int d;
static assert(!hasUDA!(d, "alpha"));
static assert(hasUDA!(d, S));
static assert(hasUDA!(d, E));

@S int e;
static assert(!hasUDA!(e, "alpha"));
static assert(hasUDA!(e, S));
static assert(!hasUDA!(e, S()));
static assert(!hasUDA!(e, E));

@S() int f;
static assert(!hasUDA!(f, "alpha"));
static assert(hasUDA!(f, S));
static assert(hasUDA!(f, S()));
static assert(!hasUDA!(f, E));

@(S, E, "alpha") int g;
static assert(hasUDA!(g, "alpha"));
static assert(hasUDA!(g, S));
static assert(hasUDA!(g, E));

@(100) int h;
static assert(hasUDA!(h, 100));

struct Named { string name; }

@Named("abc") int i;
static assert(hasUDA!(i, Named));
static assert(hasUDA!(i, Named("abc")));
static assert(!hasUDA!(i, Named("def")));

struct AttrT(T)
{
    string name;
    T value;
}

@AttrT!int("answer", 42) int j;
static assert(hasUDA!(j, AttrT));
static assert(hasUDA!(j, AttrT!int));
static assert(!hasUDA!(j, AttrT!string));

@AttrT!string("hello", "world") int k;
static assert(hasUDA!(k, AttrT));
static assert(!hasUDA!(k, AttrT!int));
static assert(hasUDA!(k, AttrT!string));

struct FuncAttr(alias f) { alias func = f; }
static int fourtyTwo() { return 42; }
static size_t getLen(string s) { return s.length; }

@FuncAttr!getLen int l;
static assert(hasUDA!(l, FuncAttr));
static assert(!hasUDA!(l, FuncAttr!fourtyTwo));
static assert(hasUDA!(l, FuncAttr!getLen));
static assert(!hasUDA!(l, FuncAttr!fourtyTwo()));
static assert(!hasUDA!(l, FuncAttr!getLen()));

@FuncAttr!getLen() int m;
static assert(hasUDA!(m, FuncAttr));
static assert(!hasUDA!(m, FuncAttr!fourtyTwo));
static assert(hasUDA!(m, FuncAttr!getLen));
static assert(!hasUDA!(m, FuncAttr!fourtyTwo()));
static assert(hasUDA!(m, FuncAttr!getLen()));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="getUDAs">template <strong id="getUDAs">getUDAs</strong>(alias symbol, alias attribute)</dt> <dd>
<p>Gets the matching <a href="https://dlang.org/spec/attribute.html#uda">user-defined attributes</a> from the given symbol. </p>
<p>If the UDA is a type, then any UDAs of the same type on the symbol will match. If the UDA is a template for a type, then any UDA which is an instantiation of that template will match. And if the UDA is a value, then any UDAs on the symbol which are equal to that value will match. </p> <dl>
<dt>See Also:</dt>
<dd><a href="#hasUDA"><code>hasUDA</code></a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">struct Attr
{
    string name;
    int value;
}

@Attr("Answer", 42) int a;
static assert(getUDAs!(a, Attr).length == 1);
static assert(getUDAs!(a, Attr)[0].name == "Answer");
static assert(getUDAs!(a, Attr)[0].value == 42);

@(Attr("Answer", 42), "string", 9999) int b;
static assert(getUDAs!(b, Attr).length == 1);
static assert(getUDAs!(b, Attr)[0].name == "Answer");
static assert(getUDAs!(b, Attr)[0].value == 42);

@Attr("Answer", 42) @Attr("Pi", 3) int c;
static assert(getUDAs!(c, Attr).length == 2);
static assert(getUDAs!(c, Attr)[0].name == "Answer");
static assert(getUDAs!(c, Attr)[0].value == 42);
static assert(getUDAs!(c, Attr)[1].name == "Pi");
static assert(getUDAs!(c, Attr)[1].value == 3);

static assert(getUDAs!(c, Attr("Answer", 42)).length == 1);
static assert(getUDAs!(c, Attr("Answer", 42))[0].name == "Answer");
static assert(getUDAs!(c, Attr("Answer", 42))[0].value == 42);

static assert(getUDAs!(c, Attr("Answer", 99)).length == 0);

struct AttrT(T)
{
    string name;
    T value;
}

@AttrT!uint("Answer", 42) @AttrT!int("Pi", 3) @AttrT int d;
static assert(getUDAs!(d, AttrT).length == 2);
static assert(getUDAs!(d, AttrT)[0].name == "Answer");
static assert(getUDAs!(d, AttrT)[0].value == 42);
static assert(getUDAs!(d, AttrT)[1].name == "Pi");
static assert(getUDAs!(d, AttrT)[1].value == 3);

static assert(getUDAs!(d, AttrT!uint).length == 1);
static assert(getUDAs!(d, AttrT!uint)[0].name == "Answer");
static assert(getUDAs!(d, AttrT!uint)[0].value == 42);

static assert(getUDAs!(d, AttrT!int).length == 1);
static assert(getUDAs!(d, AttrT!int)[0].name == "Pi");
static assert(getUDAs!(d, AttrT!int)[0].value == 3);

struct SimpleAttr {}

@SimpleAttr int e;
static assert(getUDAs!(e, SimpleAttr).length == 1);
static assert(is(getUDAs!(e, SimpleAttr)[0] == SimpleAttr));

@SimpleAttr() int f;
static assert(getUDAs!(f, SimpleAttr).length == 1);
static assert(is(typeof(getUDAs!(f, SimpleAttr)[0]) == SimpleAttr));

struct FuncAttr(alias f) { alias func = f; }
static int add42(int v) { return v + 42; }
static string concat(string l, string r) { return l ~ r; }

@FuncAttr!add42 int g;
static assert(getUDAs!(g, FuncAttr).length == 1);
static assert(getUDAs!(g, FuncAttr)[0].func(5) == 47);

static assert(getUDAs!(g, FuncAttr!add42).length == 1);
static assert(getUDAs!(g, FuncAttr!add42)[0].func(5) == 47);

static assert(getUDAs!(g, FuncAttr!add42()).length == 0);

static assert(getUDAs!(g, FuncAttr!concat).length == 0);
static assert(getUDAs!(g, FuncAttr!concat()).length == 0);

@FuncAttr!add42() int h;
static assert(getUDAs!(h, FuncAttr).length == 1);
static assert(getUDAs!(h, FuncAttr)[0].func(5) == 47);

static assert(getUDAs!(h, FuncAttr!add42).length == 1);
static assert(getUDAs!(h, FuncAttr!add42)[0].func(5) == 47);

static assert(getUDAs!(h, FuncAttr!add42()).length == 1);
static assert(getUDAs!(h, FuncAttr!add42())[0].func(5) == 47);

static assert(getUDAs!(h, FuncAttr!concat).length == 0);
static assert(getUDAs!(h, FuncAttr!concat()).length == 0);

@("alpha") @(42) int i;
static assert(getUDAs!(i, "alpha").length == 1);
static assert(getUDAs!(i, "alpha")[0] == "alpha");

static assert(getUDAs!(i, 42).length == 1);
static assert(getUDAs!(i, 42)[0] == 42);

static assert(getUDAs!(i, 'c').length == 0);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="getSymbolsByUDA">template <strong id="getSymbolsByUDA">getSymbolsByUDA</strong>(alias symbol, alias attribute)</dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>symbol</td> <td>The aggregate type or module to search</td>
</tr> <tr>
<td>attribute</td> <td>The user-defined attribute to search for</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>All symbols within <code>symbol</code> that have the given UDA <code>attribute</code>. </dd>
</dl> <dl>
<dt>Note</dt>
<dd> This is not recursive; it will not search for symbols within symbols such as nested structs or unions.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">enum Attr;
struct A
{
    @Attr int a;
    int b;
}

static assert(getSymbolsByUDA!(A, Attr).length == 1);
static assert(hasUDA!(getSymbolsByUDA!(A, Attr)[0], Attr));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">enum Attr;

static struct A
{
    @Attr int a;
    int b;
    @Attr void doStuff() {}
    void doOtherStuff() {}
    static struct Inner
    {
        // Not found by getSymbolsByUDA
        @Attr int c;
    }
}

// Finds both variables and functions with the attribute, but
// doesn't include the variables and functions without it.
static assert(getSymbolsByUDA!(A, Attr).length == 2);
// Can access attributes on the symbols returned by getSymbolsByUDA.
static assert(hasUDA!(getSymbolsByUDA!(A, Attr)[0], Attr));
static assert(hasUDA!(getSymbolsByUDA!(A, Attr)[1], Attr));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Finds multiple attributes <pre data-language="d">static struct UDA { string name; }

static struct B
{
    @UDA("X")
    int x;
    @UDA("Y")
    int y;
    @(100)
    int z;
}

// Finds both UDA attributes.
static assert(getSymbolsByUDA!(B, UDA).length == 2);
// Finds one `100` attribute.
static assert(getSymbolsByUDA!(B, 100).length == 1);
// Can get the value of the UDA from the return value
static assert(getUDAs!(getSymbolsByUDA!(B, UDA)[0], UDA)[0].name == "X");
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Checks for UDAs on the aggregate symbol itself <pre data-language="d">static struct UDA { string name; }

@UDA("A")
static struct C
{
    @UDA("B")
    int d;
}

static assert(getSymbolsByUDA!(C, UDA).length == 2);
static assert(getSymbolsByUDA!(C, UDA)[0].stringof == "C");
static assert(getSymbolsByUDA!(C, UDA)[1].stringof == "d");
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Finds nothing if there is no member with specific UDA <pre data-language="d">static struct UDA { string name; }

static struct D
{
    int x;
}

static assert(getSymbolsByUDA!(D, UDA).length == 0);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="allSameType">template <strong id="allSameType">allSameType</strong>(T...)</dt> <dd>
<dl>
<dt>Returns:</dt>
<dd>
<code>true</code> iff all types <code>T</code> are the same.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(allSameType!(int, int));
static assert(allSameType!(int, int, int));
static assert(allSameType!(float, float, float));
static assert(!allSameType!(int, double));
static assert(!allSameType!(int, float, double));
static assert(!allSameType!(int, float, double, real));
static assert(!allSameType!(short, int, float, double, real));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="ifTestable">enum auto <strong id="ifTestable">ifTestable</strong>(T, alias pred = (a) =&gt; a); </dt> <dd>
<dl>
<dt>Returns:</dt>
<dd>
<code>true</code> iff the type <code>T</code> can be tested in an <code> if</code>-expression, that is if <code>if (pred(T.init)) {}</code> is compilable.</dd>
</dl> </dd> <dt class="d_decl" id="isType">template <strong id="isType">isType</strong>(X...) if (X.length == 1)</dt> <dd>
<p>Detect whether <code>X</code> is a type. Analogous to <code>is(X)</code>. This is useful when used in conjunction with other templates, e.g. <code>allSatisfy!(isType, X)</code>. </p>
<dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if <code>X</code> is a type, <code>false</code> otherwise</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">struct S {
    template Test() {}
}
class C {}
interface I {}
union U {}
static assert(isType!int);
static assert(isType!string);
static assert(isType!(int[int]));
static assert(isType!S);
static assert(isType!C);
static assert(isType!I);
static assert(isType!U);

int n;
void func(){}
static assert(!isType!n);
static assert(!isType!func);
static assert(!isType!(S.Test));
static assert(!isType!(S.Test!()));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isFunction">template <strong id="isFunction">isFunction</strong>(X...) if (X.length == 1)</dt> <dd>
<p>Detect whether symbol or type <code>X</code> is a function. This is different that finding if a symbol is callable or satisfying <code>is(X == function)</code>, it finds specifically if the symbol represents a normal function declaration, i.e. not a delegate or a function pointer. </p>
<dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if <code>X</code> is a function, <code>false</code> otherwise </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>Use <a href="#isFunctionPointer"><code>isFunctionPointer</code></a> or <a href="#isDelegate"><code>isDelegate</code></a> for detecting those types respectively.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static void func(){}
static assert(isFunction!func);

struct S
{
    void func(){}
}
static assert(isFunction!(S.func));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isFinal">template <strong id="isFinal">isFinal</strong>(X...) if (X.length == 1)</dt> <dd>
<p>Detect whether <code>X</code> is a final method or class. </p>
<dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if <code>X</code> is final, <code>false</code> otherwise</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">class C
{
    void nf() {}
    static void sf() {}
    final void ff() {}
}
final class FC { }

static assert(!isFinal!(C));
static assert( isFinal!(FC));

static assert(!isFinal!(C.nf));
static assert(!isFinal!(C.sf));
static assert( isFinal!(C.ff));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isCopyable">enum auto <strong id="isCopyable">isCopyable</strong>(S); </dt> <dd>
<p>Determines whether the type <code>S</code> can be copied. If a type cannot be copied, then code such as <code>MyStruct x; auto y = x;</code> will fail to compile. Copying for structs can be disabled by using <code>@disable this(this)</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>S</td> <td>The type to check.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if <code>S</code> can be copied. <code>false</code> otherwise.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">struct S1 {}                        // Fine. Can be copied
struct S2 {         this(this) {}}  // Fine. Can be copied
struct S3 {@disable this(this);  }  // Not fine. Copying is disabled.
struct S4 {S3 s;}                   // Not fine. A field has copying disabled.

class C1 {}

static assert( isCopyable!S1);
static assert( isCopyable!S2);
static assert(!isCopyable!S3);
static assert(!isCopyable!S4);

static assert(isCopyable!C1);
static assert(isCopyable!int);
static assert(isCopyable!(int[]));
</pre> </dd>
</dl> </dd> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1999&ndash;2021 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/std_traits.html" class="_attribution-link">https://dlang.org/phobos/std_traits.html</a>
  </p>
</div>
