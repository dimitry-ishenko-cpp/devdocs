<h1>std.container.dlist</h1>  <p>This module implements a generic doubly-linked list container. It can be used as a queue, dequeue or stack. </p>
<p>This module is a submodule of <a href="std_container.html"><code>std.container</code></a>. </p> <dl>
<dt>Source</dt>
<dd> <span class="phobos_src"><a class="https" href="https://github.com/dlang/phobos/blob/master/std/container/dlist.d">std/container/dlist.d</a></span> </dd>
</dl> <dl>
<dt>License:</dt>
<dd>Distributed under the Boost Software License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at <a href="http://boost.org/LICENSE_1_0.txt">boost.org/LICENSE_1_0.txt</a>). </dd>
</dl> <dl>
<dt>Authors:</dt>
<dd>
<a href="http://erdani.com">Andrei Alexandrescu</a>  </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.container : DList;

auto s = DList!int(1, 2, 3);
assert(equal(s[], [1, 2, 3]));

s.removeFront();
assert(equal(s[], [2, 3]));
s.removeBack();
assert(equal(s[], [2]));

s.insertFront([4, 5]);
assert(equal(s[], [4, 5, 2]));
s.insertBack([6, 7]);
assert(equal(s[], [4, 5, 2, 6, 7]));

// If you want to apply range operations, simply slice it.
import std.algorithm.searching : countUntil;
import std.range : popFrontN, popBackN, walkLength;

auto sl = DList!int([1, 2, 3, 4, 5]);
writeln(countUntil(sl[], 2)); // 1

auto r = sl[];
popFrontN(r, 2);
popBackN(r, 2);
assert(r.equal([3]));
writeln(walkLength(r)); // 1

// DList.Range can be used to remove elements from the list it spans
auto nl = DList!int([1, 2, 3, 4, 5]);
for (auto rn = nl[]; !rn.empty;)
    if (rn.front % 2 == 0)
        nl.popFirstOf(rn);
    else
        rn.popFront();
assert(equal(nl[], [1, 3, 5]));
auto rs = nl[];
rs.popFront();
nl.remove(rs);
assert(equal(nl[], [1]));
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="DList">struct <strong id="DList">DList</strong>(T); </dt> <dd>
<p>Implements a doubly-linked list. </p>
<p><code>DList</code> uses reference semantics.</p> <dl>
<dt class="d_decl" id="DList.this">this(U)(U[] values...)<br><small>  Constraints: if (isImplicitlyConvertible!(U, T)); </small>
</dt> <dd>
<p>Constructor taking a number of nodes</p> </dd> <dt class="d_decl" id="DList.this.2">this(Stuff)(Stuff stuff)<br><small>  Constraints: if (isInputRange!Stuff &amp;&amp; isImplicitlyConvertible!(ElementType!Stuff, T)); </small>
</dt> <dd>
<p>Constructor taking an <a href="std_range_primitives.html#isInputRange">input range</a></p> </dd> <dt class="d_decl" id="DList.opEquals">const bool <strong id="opEquals">opEquals</strong>()(ref const DList rhs)<br><small>  Constraints: if (is(typeof(front == front))); </small>
</dt> <dd>
<p>Comparison for equality. </p>
<dl>
<dt>Complexity</dt>
<dd> <span class="bigoh">Ο(<code>min(n, n1)</code>)</span> where <code>n1</code> is the number of elements in <code>rhs</code>.</dd>
</dl> </dd> <dt class="d_decl" id="DList.Range">struct <strong id="Range">Range</strong>; </dt> <dd>
<p>Defines the container's primary range, which embodies a bidirectional range.</p> </dd> <dt class="d_decl" id="DList.empty">const nothrow @property bool <strong id="empty">empty</strong>(); </dt> <dd>
<p>Property returning <code>true</code> if and only if the container has no elements. </p>
<dl>
<dt>Complexity</dt>
<dd> <span class="bigoh">Ο(<code>1</code>)</span>
</dd>
</dl> </dd> <dt class="d_decl" id="DList.clear">void <strong id="clear">clear</strong>(); </dt> <dd>
<p>Removes all contents from the <code>DList</code>. </p>
<dl>
<dt>Postcondition</dt>
<dd> <code>empty</code> </dd>
</dl> <dl>
<dt>Complexity</dt>
<dd> <span class="bigoh">Ο(<code>1</code>)</span>
</dd>
</dl> </dd> <dt class="d_decl" id="DList.dup">@property DList <strong id="dup">dup</strong>(); </dt> <dd>
<p>Duplicates the container. The elements themselves are not transitively duplicated. </p>
<dl>
<dt>Complexity</dt>
<dd> <span class="bigoh">Ο(<code>n</code>)</span>.</dd>
</dl> </dd> <dt class="d_decl" id="DList.opSlice">Range <strong id="opSlice">opSlice</strong>(); </dt> <dd>
<p>Returns a range that iterates over all elements of the container, in forward order. </p>
<dl>
<dt>Complexity</dt>
<dd> <span class="bigoh">Ο(<code>1</code>)</span>
</dd>
</dl> </dd> <dt class="d_decl" id="DList.front">inout @property ref inout(T) <strong id="front">front</strong>(); </dt> <dd>
<p>Forward to <code>opSlice().front</code>. </p>
<dl>
<dt>Complexity</dt>
<dd> <span class="bigoh">Ο(<code>1</code>)</span>
</dd>
</dl> </dd> <dt class="d_decl" id="DList.back">inout @property ref inout(T) <strong id="back">back</strong>(); </dt> <dd>
<p>Forward to <code>opSlice().back</code>. </p>
<dl>
<dt>Complexity</dt>
<dd> <span class="bigoh">Ο(<code>1</code>)</span>
</dd>
</dl> </dd> <dt class="d_decl" id="DList.opBinary">DList <strong id="opBinary">opBinary</strong>(string op, Stuff)(Stuff rhs)<br><small>  Constraints: if (op == "~" &amp;&amp; is(typeof(insertBack(rhs)))); </small>
</dt> <dd>
<p>Returns a new <code>DList</code> that's the concatenation of <code>this</code> and its argument <code>rhs</code>.</p> </dd> <dt class="d_decl" id="DList.opBinaryRight">DList <strong id="opBinaryRight">opBinaryRight</strong>(string op, Stuff)(Stuff lhs)<br><small>  Constraints: if (op == "~" &amp;&amp; is(typeof(insertFront(lhs)))); </small>
</dt> <dd>
<p>Returns a new <code>DList</code> that's the concatenation of the argument <code>lhs</code> and <code>this</code>.</p> </dd> <dt class="d_decl" id="DList.opOpAssign">DList <strong id="opOpAssign">opOpAssign</strong>(string op, Stuff)(Stuff rhs)<br><small>  Constraints: if (op == "~" &amp;&amp; is(typeof(insertBack(rhs)))); </small>
</dt> <dd>
<p>Appends the contents of the argument <code>rhs</code> into <code>this</code>.</p> </dd> <dt class="d_decl" id="DList.insertFront">size_t <strong id="insertFront">insertFront</strong>(Stuff)(Stuff stuff); <br><br>size_t <strong id="insertBack">insertBack</strong>(Stuff)(Stuff stuff); <br><br>alias <strong id="insert">insert</strong> = insertBack; <br><br>alias <strong id="stableInsert">stableInsert</strong> = insert; <br><br>alias <strong id="stableInsertFront">stableInsertFront</strong> = insertFront; <br><br>alias <strong id="stableInsertBack">stableInsertBack</strong> = insertBack; </dt> <dd>
<p>Inserts <code>stuff</code> to the front/back of the container. <code>stuff</code> can be a value convertible to <code>T</code> or a range of objects convertible to <code>T</code>. The stable version behaves the same, but guarantees that ranges iterating over the container are never invalidated. </p>
<dl>
<dt>Returns:</dt>
<dd>The number of elements inserted </dd>
</dl> <dl>
<dt>Complexity</dt>
<dd> <span class="bigoh">Ο(<code>log(n)</code>)</span>
</dd>
</dl> </dd> <dt class="d_decl" id="DList.insertBefore">size_t <strong id="insertBefore">insertBefore</strong>(Stuff)(Range r, Stuff stuff); <br><br>alias <strong id="stableInsertBefore">stableInsertBefore</strong> = insertBefore; <br><br>size_t <strong id="insertAfter">insertAfter</strong>(Stuff)(Range r, Stuff stuff); <br><br>alias <strong id="stableInsertAfter">stableInsertAfter</strong> = insertAfter; </dt> <dd>
<p>Inserts <code>stuff</code> after range <code>r</code>, which must be a non-empty range previously extracted from this container. </p>
<p><code>stuff</code> can be a value convertible to <code>T</code> or a range of objects convertible to <code>T</code>. The stable version behaves the same, but guarantees that ranges iterating over the container are never invalidated. </p> <dl>
<dt>Returns:</dt>
<dd>The number of values inserted. </dd>
</dl> <dl>
<dt>Complexity</dt>
<dd> <span class="bigoh">Ο(<code>k + m</code>)</span>, where <code>k</code> is the number of elements in <code>r</code> and <code>m</code> is the length of <code>stuff</code>.</dd>
</dl> </dd> <dt class="d_decl" id="DList.removeAny">T <strong id="removeAny">removeAny</strong>(); <br><br>alias <strong id="stableRemoveAny">stableRemoveAny</strong> = removeAny; </dt> <dd>
<p>Picks one value in an unspecified position in the container, removes it from the container, and returns it. The stable version behaves the same, but guarantees that ranges iterating over the container are never invalidated. </p>
<dl>
<dt>Precondition</dt>
<dd> <code>!empty</code> </dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The element removed. </dd>
</dl> <dl>
<dt>Complexity</dt>
<dd> <span class="bigoh">Ο(<code>1</code>)</span>.</dd>
</dl> </dd> <dt class="d_decl" id="DList.removeFront">void <strong id="removeFront">removeFront</strong>(); <br><br>alias <strong id="stableRemoveFront">stableRemoveFront</strong> = removeFront; <br><br>void <strong id="removeBack">removeBack</strong>(); <br><br>alias <strong id="stableRemoveBack">stableRemoveBack</strong> = removeBack; </dt> <dd>
<p>Removes the value at the front/back of the container. The stable version behaves the same, but guarantees that ranges iterating over the container are never invalidated. </p>
<dl>
<dt>Precondition</dt>
<dd> <code>!empty</code> </dd>
</dl> <dl>
<dt>Complexity</dt>
<dd> <span class="bigoh">Ο(<code>1</code>)</span>.</dd>
</dl> </dd> <dt class="d_decl" id="DList.removeFront.2">size_t <strong id="removeFront">removeFront</strong>(size_t howMany); <br><br>alias <strong id="stableRemoveFront">stableRemoveFront</strong> = removeFront; <br><br>size_t <strong id="removeBack">removeBack</strong>(size_t howMany); <br><br>alias <strong id="stableRemoveBack">stableRemoveBack</strong> = removeBack; </dt> <dd>
<p>Removes <code>howMany</code> values at the front or back of the container. Unlike the unparameterized versions above, these functions do not throw if they could not remove <code>howMany</code> elements. Instead, if <code>howMany &gt; n</code>, all elements are removed. The returned value is the effective number of elements removed. The stable version behaves the same, but guarantees that ranges iterating over the container are never invalidated. </p>
<dl>
<dt>Returns:</dt>
<dd>The number of elements removed </dd>
</dl> <dl>
<dt>Complexity</dt>
<dd> <span class="bigoh">Ο(<code>howMany</code>)</span>.</dd>
</dl> </dd> <dt class="d_decl" id="DList.remove">Range <strong id="remove">remove</strong>(Range r); <br><br>Range <strong id="linearRemove">linearRemove</strong>(Range r); <br><br>alias <strong id="stableRemove">stableRemove</strong> = remove; </dt> <dd>
<p>Removes all elements belonging to <code>r</code>, which must be a range obtained originally from this container. </p>
<dl>
<dt>Returns:</dt>
<dd>A range spanning the remaining elements in the container that initially were right after <code>r</code>. </dd>
</dl> <dl>
<dt>Complexity</dt>
<dd> <span class="bigoh">Ο(<code>1</code>)</span>
</dd>
</dl> </dd> <dt class="d_decl" id="DList.popFirstOf">void <strong id="popFirstOf">popFirstOf</strong>(ref Range r); </dt> <dd>
<p>Removes first element of <code>r</code>, wich must be a range obtained originally from this container, from both DList instance and range <code>r</code>. </p>
<dl>
<dt>Compexity</dt>
<dd> <span class="bigoh">Ο(<code>1</code>)</span>
</dd>
</dl> </dd> <dt class="d_decl" id="DList.popLastOf">void <strong id="popLastOf">popLastOf</strong>(ref Range r); </dt> <dd>
<p>Removes last element of <code>r</code>, wich must be a range obtained originally from this container, from both DList instance and range <code>r</code>. </p>
<dl>
<dt>Compexity</dt>
<dd> <span class="bigoh">Ο(<code>1</code>)</span>
</dd>
</dl> </dd> <dt class="d_decl" id="DList.linearRemove.2">Range <strong id="linearRemove">linearRemove</strong>(Take!Range r); <br><br>alias <strong id="stableLinearRemove">stableLinearRemove</strong> = linearRemove; </dt> <dd>
<p><code>linearRemove</code> functions as <code>remove</code>, but also accepts ranges that are result the of a <code>take</code> operation. This is a convenient way to remove a fixed amount of elements from the range. </p>
<dl>
<dt>Complexity</dt>
<dd> <span class="bigoh">Ο(<code>r.walkLength</code>)</span>
</dd>
</dl> </dd> <dt class="d_decl" id="DList.linearRemoveElement">bool <strong id="linearRemoveElement">linearRemoveElement</strong>(T value); </dt> <dd>
<p>Removes the first occurence of an element from the list in linear time. </p>
<dl>
<dt>Returns:</dt>
<dd>True if the element existed and was successfully removed, false otherwise. </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T <code>value</code>
</td> <td>value of the node to be removed</td>
</tr> </table></dd>
</dl> <dl>
<dt>Complexity</dt>
<dd> <span class="bigoh">Ο(<code>n</code>)</span>
</dd>
</dl> </dd> </dl> </dd> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1999&ndash;2021 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/std_container_dlist.html" class="_attribution-link">https://dlang.org/phobos/std_container_dlist.html</a>
  </p>
</div>
