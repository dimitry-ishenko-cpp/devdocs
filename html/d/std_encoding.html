<h1>std.encoding</h1>  <p>Classes and functions for handling and transcoding between various encodings. </p>
<p>For cases where the encoding is known at compile-time, functions are provided for arbitrary encoding and decoding of characters, arbitrary transcoding between strings of different type, as well as validation and sanitization. <br><br> Encodings currently supported are UTF-8, UTF-16, UTF-32, ASCII, ISO-8859-1 (also known as LATIN-1), ISO-8859-2 (LATIN-2), WINDOWS-1250, WINDOWS-1251 and WINDOWS-1252. <br><br>  <table>

<tr>
<th scope="col">Category</th> <th scope="col">Functions</th>
</tr> <tr>
<td>Decode</td> <td> <a href="#codePoints"><code>codePoints</code></a> <a href="#decode"><code>decode</code></a> <a href="#decodeReverse"><code>decodeReverse</code></a> <a href="#safeDecode"><code>safeDecode</code></a> </td>
</tr> <tr>
<td>Conversion</td> <td> <a href="#codeUnits"><code>codeUnits</code></a> <a href="#sanitize"><code>sanitize</code></a> <a href="#transcode"><code>transcode</code></a> </td>
</tr> <tr>
<td>Classification</td> <td> <a href="#canEncode"><code>canEncode</code></a> <a href="#isValid"><code>isValid</code></a> <a href="#isValidCodePoint"><code>isValidCodePoint</code></a> <a href="#isValidCodeUnit"><code>isValidCodeUnit</code></a> </td>
</tr> <tr>
<td>BOM</td> <td> <a href="#BOM"><code>BOM</code></a> <a href="#BOMSeq"><code>BOMSeq</code></a> <a href="#getBOM"><code>getBOM</code></a> <a href="#utfBOM"><code>utfBOM</code></a> </td>
</tr> <tr>
<td>Length &amp; Index</td> <td> <a href="#firstSequence"><code>firstSequence</code></a> <a href="#encodedLength"><code>encodedLength</code></a> <a href="#index"><code>index</code></a> <a href="#lastSequence"><code>lastSequence</code></a> <a href="#validLength"><code>validLength</code></a> </td>
</tr> <tr>
<td>Encoding schemes</td> <td> <a href="#encodingName"><code>encodingName</code></a> <a href="#EncodingScheme"><code>EncodingScheme</code></a> <a href="#EncodingSchemeASCII"><code>EncodingSchemeASCII</code></a> <a href="#EncodingSchemeLatin1"><code>EncodingSchemeLatin1</code></a> <a href="#EncodingSchemeLatin2"><code>EncodingSchemeLatin2</code></a> <a href="#EncodingSchemeUtf16Native"><code>EncodingSchemeUtf16Native</code></a> <a href="#EncodingSchemeUtf32Native"><code>EncodingSchemeUtf32Native</code></a> <a href="#EncodingSchemeUtf8"><code>EncodingSchemeUtf8</code></a> <a href="#EncodingSchemeWindows1250"><code>EncodingSchemeWindows1250</code></a> <a href="#EncodingSchemeWindows1251"><code>EncodingSchemeWindows1251</code></a> <a href="#EncodingSchemeWindows1252"><code>EncodingSchemeWindows1252</code></a> </td>
</tr> <tr>
<td>Representation</td> <td> <a href="#AsciiChar"><code>AsciiChar</code></a> <a href="#AsciiString"><code>AsciiString</code></a> <a href="#Latin1Char"><code>Latin1Char</code></a> <a href="#Latin1String"><code>Latin1String</code></a> <a href="#Latin2Char"><code>Latin2Char</code></a> <a href="#Latin2String"><code>Latin2String</code></a> <a href="#Windows1250Char"><code>Windows1250Char</code></a> <a href="#Windows1250String"><code>Windows1250String</code></a> <a href="#Windows1251Char"><code>Windows1251Char</code></a> <a href="#Windows1251String"><code>Windows1251String</code></a> <a href="#Windows1252Char"><code>Windows1252Char</code></a> <a href="#Windows1252String"><code>Windows1252String</code></a> </td>
</tr> <tr>
<td>Exceptions</td> <td> <a href="#INVALID_SEQUENCE"><code>INVALID_SEQUENCE</code></a> <a href="#EncodingException"><code>EncodingException</code></a> </td>
</tr> </table> <br><br> For cases where the encoding is not known at compile-time, but is known at run-time, the abstract class <a href="#EncodingScheme"><code>EncodingScheme</code></a> and its subclasses is provided. To construct a run-time encoder/decoder, one does e.g. <br><br> <pre data-language="d">auto e = EncodingScheme.create("utf-8");
</pre> <br><br> This library supplies <a href="#EncodingScheme"><code>EncodingScheme</code></a> subclasses for ASCII, ISO-8859-1 (also known as LATIN-1), ISO-8859-2 (LATIN-2), WINDOWS-1250, WINDOWS-1251, WINDOWS-1252, UTF-8, and (on little-endian architectures) UTF-16LE and UTF-32LE; or (on big-endian architectures) UTF-16BE and UTF-32BE. <br><br> This library provides a mechanism whereby other modules may add <a href="#EncodingScheme"><code>EncodingScheme</code></a> subclasses for any other encoding. </p> <dl>
<dt>License:</dt>
<dd>
<a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>. </dd>
</dl> <dl>
<dt>Authors:</dt>
<dd>Janice Caron </dd>
</dl> <dl>
<dt>Source</dt>
<dd> <span class="phobos_src"><a class="https" href="https://github.com/dlang/phobos/blob/master/std/encoding.d">std/encoding.d</a></span>
</dd>
</dl> <dl>
<dt class="d_decl" id="INVALID_SEQUENCE">enum dchar <strong id="INVALID_SEQUENCE">INVALID_SEQUENCE</strong>; </dt> <dd>
<p>Special value returned by <code>safeDecode</code></p> </dd> <dt class="d_decl" id="AsciiChar">enum <strong id="AsciiChar">AsciiChar</strong>: ubyte; <br><br>alias <strong id="AsciiString">AsciiString</strong> = immutable(AsciiChar)[]; </dt> <dd>
<p>Defines various character sets.</p> </dd> <dt class="d_decl" id="Latin1Char">enum <strong id="Latin1Char">Latin1Char</strong>: ubyte; </dt> <dd>
<p>Defines an Latin1-encoded character.</p> </dd> <dt class="d_decl" id="Latin1String">alias <strong id="Latin1String">Latin1String</strong> = immutable(Latin1Char)[]; </dt> <dd>
<p>Defines an Latin1-encoded string (as an array of <code>immutable(Latin1Char)</code>).</p> </dd> <dt class="d_decl" id="Latin2Char">enum <strong id="Latin2Char">Latin2Char</strong>: ubyte; </dt> <dd>
<p>Defines a Latin2-encoded character.</p> </dd> <dt class="d_decl" id="Latin2String">alias <strong id="Latin2String">Latin2String</strong> = immutable(Latin2Char)[]; </dt> <dd>
<p>Defines an Latin2-encoded string (as an array of <code> immutable(Latin2Char)</code>).</p> </dd> <dt class="d_decl" id="Windows1250Char">enum <strong id="Windows1250Char">Windows1250Char</strong>: ubyte; </dt> <dd>
<p>Defines a Windows1250-encoded character.</p> </dd> <dt class="d_decl" id="Windows1250String">alias <strong id="Windows1250String">Windows1250String</strong> = immutable(Windows1250Char)[]; </dt> <dd>
<p>Defines an Windows1250-encoded string (as an array of <code> immutable(Windows1250Char)</code>).</p> </dd> <dt class="d_decl" id="Windows1251Char">enum <strong id="Windows1251Char">Windows1251Char</strong>: ubyte; </dt> <dd>
<p>Defines a Windows1251-encoded character.</p> </dd> <dt class="d_decl" id="Windows1251String">alias <strong id="Windows1251String">Windows1251String</strong> = immutable(Windows1251Char)[]; </dt> <dd>
<p>Defines an Windows1251-encoded string (as an array of <code> immutable(Windows1251Char)</code>).</p> </dd> <dt class="d_decl" id="Windows1252Char">enum <strong id="Windows1252Char">Windows1252Char</strong>: ubyte; </dt> <dd>
<p>Defines a Windows1252-encoded character.</p> </dd> <dt class="d_decl" id="Windows1252String">alias <strong id="Windows1252String">Windows1252String</strong> = immutable(Windows1252Char)[]; </dt> <dd>
<p>Defines an Windows1252-encoded string (as an array of <code> immutable(Windows1252Char)</code>).</p> </dd> <dt class="d_decl" id="isValidCodePoint">pure nothrow @nogc @safe bool <strong id="isValidCodePoint">isValidCodePoint</strong>(dchar c); </dt> <dd>
<p>Returns true if c is a valid code point </p>
<p>Note that this includes the non-character code points U+FFFE and U+FFFF, since these are valid code points (even though they are not valid characters). </p> <dl>
<dt>Supersedes</dt>
<dd> This function supersedes <code>std.utf.startsValidDchar()</code>. </dd>
</dl> <dl>
<dt>Standards:</dt>
<dd>Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250, WINDOWS-1251, WINDOWS-1252 </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>dchar <code>c</code>
</td> <td>the code point to be tested</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="encodingName">@property string <strong id="encodingName">encodingName</strong>(T)(); </dt> <dd>
<p>Returns the name of an encoding. </p>
<p>The type of encoding cannot be deduced. Therefore, it is necessary to explicitly specify the encoding type. </p> <dl>
<dt>Standards:</dt>
<dd>Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250, WINDOWS-1251, WINDOWS-1252</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(encodingName!(char)); // "UTF-8"
writeln(encodingName!(wchar)); // "UTF-16"
writeln(encodingName!(dchar)); // "UTF-32"
writeln(encodingName!(AsciiChar)); // "ASCII"
writeln(encodingName!(Latin1Char)); // "ISO-8859-1"
writeln(encodingName!(Latin2Char)); // "ISO-8859-2"
writeln(encodingName!(Windows1250Char)); // "windows-1250"
writeln(encodingName!(Windows1251Char)); // "windows-1251"
writeln(encodingName!(Windows1252Char)); // "windows-1252"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="canEncode">bool <strong id="canEncode">canEncode</strong>(E)(dchar c); </dt> <dd>
<p>Returns true iff it is possible to represent the specified codepoint in the encoding. </p>
<p>The type of encoding cannot be deduced. Therefore, it is necessary to explicitly specify the encoding type. </p> <dl>
<dt>Standards:</dt>
<dd>Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250, WINDOWS-1251, WINDOWS-1252</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert( canEncode!(Latin1Char)('A'));
assert( canEncode!(Latin2Char)('A'));
assert(!canEncode!(AsciiChar)('\u00A0'));
assert( canEncode!(Latin1Char)('\u00A0'));
assert( canEncode!(Latin2Char)('\u00A0'));
assert( canEncode!(Windows1250Char)('\u20AC'));
assert(!canEncode!(Windows1250Char)('\u20AD'));
assert(!canEncode!(Windows1250Char)('\uFFFD'));
assert( canEncode!(Windows1251Char)('\u0402'));
assert(!canEncode!(Windows1251Char)('\u20AD'));
assert(!canEncode!(Windows1251Char)('\uFFFD'));
assert( canEncode!(Windows1252Char)('\u20AC'));
assert(!canEncode!(Windows1252Char)('\u20AD'));
assert(!canEncode!(Windows1252Char)('\uFFFD'));
assert(!canEncode!(char)(cast(dchar) 0x110000));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>How to check an entire string <pre data-language="d">import std.algorithm.searching : find;
import std.utf : byDchar;

assert("The quick brown fox"
    .byDchar
    .find!(x =&gt; !canEncode!AsciiChar(x))
    .empty);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isValidCodeUnit">bool <strong id="isValidCodeUnit">isValidCodeUnit</strong>(E)(E c); </dt> <dd>
<p>Returns true if the code unit is legal. For example, the byte 0x80 would not be legal in ASCII, because ASCII code units must always be in the range 0x00 to 0x7F. </p>
<dl>
<dt>Standards:</dt>
<dd>Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250, WINDOWS-1251, WINDOWS-1252 </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>E <code>c</code>
</td> <td>the code unit to be tested</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(!isValidCodeUnit(cast(char) 0xC0));
assert(!isValidCodeUnit(cast(char) 0xFF));
assert( isValidCodeUnit(cast(wchar) 0xD800));
assert(!isValidCodeUnit(cast(dchar) 0xD800));
assert(!isValidCodeUnit(cast(AsciiChar) 0xA0));
assert( isValidCodeUnit(cast(Windows1250Char) 0x80));
assert(!isValidCodeUnit(cast(Windows1250Char) 0x81));
assert( isValidCodeUnit(cast(Windows1251Char) 0x80));
assert(!isValidCodeUnit(cast(Windows1251Char) 0x98));
assert( isValidCodeUnit(cast(Windows1252Char) 0x80));
assert(!isValidCodeUnit(cast(Windows1252Char) 0x81));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isValid">bool <strong id="isValid">isValid</strong>(E)(const(E)[] s); </dt> <dd>
<p>Returns true if the string is encoded correctly </p>
<dl>
<dt>Supersedes</dt>
<dd> This function supersedes std.utf.validate(), however note that this function returns a bool indicating whether the input was valid or not, whereas the older function would throw an exception. </dd>
</dl> <dl>
<dt>Standards:</dt>
<dd>Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250, WINDOWS-1251, WINDOWS-1252 </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const<span class="template_param_list" title="Template parameter list">(E)</span>[] <code>s</code>
</td> <td>the string to be tested</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert( isValid("\u20AC100"));
assert(!isValid(cast(char[3])[167, 133, 175]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="validLength">size_t <strong id="validLength">validLength</strong>(E)(const(E)[] s); </dt> <dd>
<p>Returns the length of the longest possible substring, starting from the first code unit, which is validly encoded. </p>
<dl>
<dt>Standards:</dt>
<dd>Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250, WINDOWS-1251, WINDOWS-1252 </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const<span class="template_param_list" title="Template parameter list">(E)</span>[] <code>s</code>
</td> <td>the string to be tested</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="sanitize">immutable(E)[] <strong id="sanitize">sanitize</strong>(E)(immutable(E)[] s); </dt> <dd>
<p>Sanitizes a string by replacing malformed code unit sequences with valid code unit sequences. The result is guaranteed to be valid for this encoding. </p>
<p>If the input string is already valid, this function returns the original, otherwise it constructs a new string by replacing all illegal code unit sequences with the encoding's replacement character, Invalid sequences will be replaced with the Unicode replacement character (U+FFFD) if the character repertoire contains it, otherwise invalid sequences will be replaced with '?'. </p> <dl>
<dt>Standards:</dt>
<dd>Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250, WINDOWS-1251, WINDOWS-1252 </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>immutable<span class="template_param_list" title="Template parameter list">(E)</span>[] <code>s</code>
</td> <td>the string to be sanitized</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(sanitize("hello \xF0\x80world")); // "hello \xEF\xBF\xBDworld"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="firstSequence">size_t <strong id="firstSequence">firstSequence</strong>(E)(const(E)[] s); </dt> <dd>
<p>Returns the length of the first encoded sequence. </p>
<p>The input to this function MUST be validly encoded. This is enforced by the function's in-contract. </p> <dl>
<dt>Standards:</dt>
<dd>Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250, WINDOWS-1251, WINDOWS-1252 </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const<span class="template_param_list" title="Template parameter list">(E)</span>[] <code>s</code>
</td> <td>the string to be sliced</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(firstSequence("\u20AC1000")); // "\u20AC".length
writeln(firstSequence("hel")); // "h".length
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="lastSequence">size_t <strong id="lastSequence">lastSequence</strong>(E)(const(E)[] s); </dt> <dd>
<p>Returns the length of the last encoded sequence. </p>
<p>The input to this function MUST be validly encoded. This is enforced by the function's in-contract. </p> <dl>
<dt>Standards:</dt>
<dd>Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250, WINDOWS-1251, WINDOWS-1252 </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const<span class="template_param_list" title="Template parameter list">(E)</span>[] <code>s</code>
</td> <td>the string to be sliced</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(lastSequence("1000\u20AC")); // "\u20AC".length
writeln(lastSequence("hellö")); // "ö".length
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="index">ptrdiff_t <strong id="index">index</strong>(E)(const(E)[] s, int n); </dt> <dd>
<p>Returns the array index at which the (n+1)th code point begins. </p>
<p>The input to this function MUST be validly encoded. This is enforced by the function's in-contract. </p> <dl>
<dt>Supersedes</dt>
<dd> This function supersedes std.utf.toUTFindex(). </dd>
</dl> <dl>
<dt>Standards:</dt>
<dd>Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250, WINDOWS-1251, WINDOWS-1252 </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const<span class="template_param_list" title="Template parameter list">(E)</span>[] <code>s</code>
</td> <td>the string to be counted</td>
</tr> <tr>
<td>int <code>n</code>
</td> <td>the current code point index</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(index("\u20AC100", 1)); // 3
writeln(index("hällo", 2)); // 3
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="decode">dchar <strong id="decode">decode</strong>(S)(ref S s); </dt> <dd>
<p>Decodes a single code point. </p>
<p>This function removes one or more code units from the start of a string, and returns the decoded code point which those code units represent. <br><br> The input to this function MUST be validly encoded. This is enforced by the function's in-contract. </p> <dl>
<dt>Supersedes</dt>
<dd> This function supersedes std.utf.decode(), however, note that the function codePoints() supersedes it more conveniently. </dd>
</dl> <dl>
<dt>Standards:</dt>
<dd>Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250, WINDOWS-1251, WINDOWS-1252 </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>S <code>s</code>
</td> <td>the string whose first code point is to be decoded</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="decodeReverse">dchar <strong id="decodeReverse">decodeReverse</strong>(E)(ref const(E)[] s); </dt> <dd>
<p>Decodes a single code point from the end of a string. </p>
<p>This function removes one or more code units from the end of a string, and returns the decoded code point which those code units represent. <br><br> The input to this function MUST be validly encoded. This is enforced by the function's in-contract. </p> <dl>
<dt>Standards:</dt>
<dd>Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250, WINDOWS-1251, WINDOWS-1252 </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const<span class="template_param_list" title="Template parameter list">(E)</span>[] <code>s</code>
</td> <td>the string whose first code point is to be decoded</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="safeDecode">dchar <strong id="safeDecode">safeDecode</strong>(S)(ref S s); </dt> <dd>
<p>Decodes a single code point. The input does not have to be valid. </p>
<p>This function removes one or more code units from the start of a string, and returns the decoded code point which those code units represent. <br><br> This function will accept an invalidly encoded string as input. If an invalid sequence is found at the start of the string, this function will remove it, and return the value INVALID_SEQUENCE. </p> <dl>
<dt>Standards:</dt>
<dd>Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250, WINDOWS-1251, WINDOWS-1252 </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>S <code>s</code>
</td> <td>the string whose first code point is to be decoded</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="encodedLength">size_t <strong id="encodedLength">encodedLength</strong>(E)(dchar c); </dt> <dd>
<p>Returns the number of code units required to encode a single code point. </p>
<p>The input to this function MUST be a valid code point. This is enforced by the function's in-contract. <br><br> The type of the output cannot be deduced. Therefore, it is necessary to explicitly specify the encoding as a template parameter. </p> <dl>
<dt>Standards:</dt>
<dd>Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250, WINDOWS-1251, WINDOWS-1252 </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>dchar <code>c</code>
</td> <td>the code point to be encoded</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="encode">E[] <strong id="encode">encode</strong>(E)(dchar c); </dt> <dd>
<p>Encodes a single code point. </p>
<p>This function encodes a single code point into one or more code units. It returns a string containing those code units. <br><br> The input to this function MUST be a valid code point. This is enforced by the function's in-contract. <br><br> The type of the output cannot be deduced. Therefore, it is necessary to explicitly specify the encoding as a template parameter. </p> <dl>
<dt>Supersedes</dt>
<dd> This function supersedes std.utf.encode(), however, note that the function codeUnits() supersedes it more conveniently. </dd>
</dl> <dl>
<dt>Standards:</dt>
<dd>Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250, WINDOWS-1251, WINDOWS-1252 </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>dchar <code>c</code>
</td> <td>the code point to be encoded</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="encode.2">size_t <strong id="encode">encode</strong>(E)(dchar c, E[] array); </dt> <dd>
<p>Encodes a single code point into an array. </p>
<p>This function encodes a single code point into one or more code units The code units are stored in a user-supplied fixed-size array, which must be passed by reference. <br><br> The input to this function MUST be a valid code point. This is enforced by the function's in-contract. <br><br> The type of the output cannot be deduced. Therefore, it is necessary to explicitly specify the encoding as a template parameter. </p> <dl>
<dt>Supersedes</dt>
<dd> This function supersedes std.utf.encode(), however, note that the function codeUnits() supersedes it more conveniently. </dd>
</dl> <dl>
<dt>Standards:</dt>
<dd>Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250, WINDOWS-1251, WINDOWS-1252 </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>dchar <code>c</code>
</td> <td>the code point to be encoded</td>
</tr> <tr>
<td>E[] <code>array</code>
</td> <td>the destination array</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>the number of code units written to the array</dd>
</dl> </dd> <dt class="d_decl" id="encode.3">void <strong id="encode">encode</strong>(E)(dchar c, void delegate(E) dg); </dt> <dd>
<p>Encodes a single code point to a delegate. </p>
<p>This function encodes a single code point into one or more code units. The code units are passed one at a time to the supplied delegate. <br><br> The input to this function MUST be a valid code point. This is enforced by the function's in-contract. <br><br> The type of the output cannot be deduced. Therefore, it is necessary to explicitly specify the encoding as a template parameter. </p> <dl>
<dt>Supersedes</dt>
<dd> This function supersedes std.utf.encode(), however, note that the function codeUnits() supersedes it more conveniently. </dd>
</dl> <dl>
<dt>Standards:</dt>
<dd>Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250, WINDOWS-1251, WINDOWS-1252 </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>dchar <code>c</code>
</td> <td>the code point to be encoded</td>
</tr> <tr>
<td>void delegate<span class="template_param_list" title="Template parameter list">(E)</span> <code>dg</code>
</td> <td>the delegate to invoke for each code unit</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="encode.4">size_t <strong id="encode">encode</strong>(Tgt, Src, R)(in Src[] s, R range); </dt> <dd>
<p>Encodes the contents of <code>s</code> in units of type <code>Tgt</code>, writing the result to an output range. </p>
<dl>
<dt>Returns:</dt>
<dd>The number of <code>Tgt</code> elements written. </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Tgt</td> <td>Element type of <code>range</code>.</td>
</tr> <tr>
<td>Src[] <code>s</code>
</td> <td>Input array.</td>
</tr> <tr>
<td>R <code>range</code>
</td> <td>Output range.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="codePoints">CodePoints!E <strong id="codePoints">codePoints</strong>(E)(immutable(E)[] s); </dt> <dd>
<p>Returns a foreachable struct which can bidirectionally iterate over all code points in a string. </p>
<p>The input to this function MUST be validly encoded. This is enforced by the function's in-contract. <br><br> You can foreach either with or without an index. If an index is specified, it will be initialized at each iteration with the offset into the string at which the code point begins. </p> <dl>
<dt>Supersedes</dt>
<dd> This function supersedes std.utf.decode(). </dd>
</dl> <dl>
<dt>Standards:</dt>
<dd>Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250, WINDOWS-1251, WINDOWS-1252 </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>immutable<span class="template_param_list" title="Template parameter list">(E)</span>[] <code>s</code>
</td> <td>the string to be decoded</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">string s = "hello world";
foreach (c;codePoints(s))
{
    // do something with c (which will always be a dchar)
}
</pre>  Note that, currently, foreach (c:codePoints(s)) is superior to foreach (c;s) in that the latter will fall over on encountering U+FFFF. <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">string s = "hello";
string t;
foreach (c;codePoints(s))
{
    t ~= cast(char) c;
}
writeln(s); // t
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="codeUnits">CodeUnits!E <strong id="codeUnits">codeUnits</strong>(E)(dchar c); </dt> <dd>
<p>Returns a foreachable struct which can bidirectionally iterate over all code units in a code point. </p>
<p>The input to this function MUST be a valid code point. This is enforced by the function's in-contract. <br><br> The type of the output cannot be deduced. Therefore, it is necessary to explicitly specify the encoding type in the template parameter. </p> <dl>
<dt>Supersedes</dt>
<dd> This function supersedes std.utf.encode(). </dd>
</dl> <dl>
<dt>Standards:</dt>
<dd>Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250, WINDOWS-1251, WINDOWS-1252 </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>dchar <code>c</code>
</td> <td>the code point to be encoded</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">char[] a;
foreach (c;codeUnits!(char)(cast(dchar)'\u20AC'))
{
    a ~= c;
}
writeln(a.length); // 3
writeln(a[0]); // 0xE2
writeln(a[1]); // 0x82
writeln(a[2]); // 0xAC
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="transcode">void <strong id="transcode">transcode</strong>(Src, Dst)(Src[] s, out Dst[] r); </dt> <dd>
<p>Convert a string from one encoding to another. </p>
<dl>
<dt>Supersedes</dt>
<dd> This function supersedes std.utf.toUTF8(), std.utf.toUTF16() and std.utf.toUTF32() (but note that to!() supersedes it more conveniently). </dd>
</dl> <dl>
<dt>Standards:</dt>
<dd>Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250, WINDOWS-1251, WINDOWS-1252 </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Src[] <code>s</code>
</td> <td>Source string. Must be validly encoded. This is enforced by the function's in-contract.</td>
</tr> <tr>
<td>Dst[] <code>r</code>
</td> <td>Destination string</td>
</tr> </table></dd>
</dl> <dl>
<dt>See Also:</dt>
<dd><a href="std_conv.html#to"><code>std.conv.to</code></a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">wstring ws;
// transcode from UTF-8 to UTF-16
transcode("hello world",ws);
writeln(ws); // "hello world"w

Latin1String ls;
// transcode from UTF-16 to ISO-8859-1
transcode(ws, ls);
writeln(ls); // "hello world"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="EncodingException">class <strong id="EncodingException">EncodingException</strong>: object.Exception; </dt> <dd>
<p>The base class for exceptions thrown by this module</p> </dd> <dt class="d_decl" id="EncodingScheme">abstract class <strong id="EncodingScheme">EncodingScheme</strong>; </dt> <dd>
<p>Abstract base class of all encoding schemes</p> <dl>
<dt class="d_decl" id="EncodingScheme.register">void <strong id="register">register</strong>(Klass : EncodingScheme)(); </dt> <dd>
<p>Registers a subclass of EncodingScheme. </p>
<p>This function allows user-defined subclasses of EncodingScheme to be declared in other modules. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Klass</td> <td>The subclass of EncodingScheme to register.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">class Amiga1251 : EncodingScheme
{
    shared static this()
    {
        EncodingScheme.register!Amiga1251;
    }
}
</pre>  </dd> <dt class="d_decl" id="EncodingScheme.create">static EncodingScheme <strong id="create">create</strong>(string encodingName); </dt> <dd>
<p>Obtains a subclass of EncodingScheme which is capable of encoding and decoding the named encoding scheme. </p>
<p>This function is only aware of EncodingSchemes which have been registered with the register() function. </p> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto scheme = EncodingScheme.create("Amiga-1251");
</pre>  </dd> <dt class="d_decl" id="EncodingScheme.toString">abstract const string <strong id="toString">toString</strong>(); </dt> <dd>
<p>Returns the standard name of the encoding scheme</p> </dd> <dt class="d_decl" id="EncodingScheme.names">abstract const string[] <strong id="names">names</strong>(); </dt> <dd>
<p>Returns an array of all known names for this encoding scheme</p> </dd> <dt class="d_decl" id="EncodingScheme.canEncode">abstract const bool <strong id="canEncode">canEncode</strong>(dchar c); </dt> <dd>
<p>Returns true if the character c can be represented in this encoding scheme.</p> </dd> <dt class="d_decl" id="EncodingScheme.encodedLength">abstract const size_t <strong id="encodedLength">encodedLength</strong>(dchar c); </dt> <dd>
<p>Returns the number of ubytes required to encode this code point. </p>
<p>The input to this function MUST be a valid code point. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>dchar <code>c</code>
</td> <td>the code point to be encoded</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>the number of ubytes required.</dd>
</dl> </dd> <dt class="d_decl" id="EncodingScheme.encode">abstract const size_t <strong id="encode">encode</strong>(dchar c, ubyte[] buffer); </dt> <dd>
<p>Encodes a single code point into a user-supplied, fixed-size buffer. </p>
<p>This function encodes a single code point into one or more ubytes. The supplied buffer must be code unit aligned. (For example, UTF-16LE or UTF-16BE must be wchar-aligned, UTF-32LE or UTF-32BE must be dchar-aligned, etc.) <br><br> The input to this function MUST be a valid code point. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>dchar <code>c</code>
</td> <td>the code point to be encoded</td>
</tr> <tr>
<td>ubyte[] <code>buffer</code>
</td> <td>the destination array</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>the number of ubytes written.</dd>
</dl> </dd> <dt class="d_decl" id="EncodingScheme.decode">abstract const dchar <strong id="decode">decode</strong>(ref const(ubyte)[] s); </dt> <dd>
<p>Decodes a single code point. </p>
<p>This function removes one or more ubytes from the start of an array, and returns the decoded code point which those ubytes represent. <br><br> The input to this function MUST be validly encoded. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(ubyte)[] <code>s</code>
</td> <td>the array whose first code point is to be decoded</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="EncodingScheme.safeDecode">abstract const dchar <strong id="safeDecode">safeDecode</strong>(ref const(ubyte)[] s); </dt> <dd>
<p>Decodes a single code point. The input does not have to be valid. </p>
<p>This function removes one or more ubytes from the start of an array, and returns the decoded code point which those ubytes represent. <br><br> This function will accept an invalidly encoded array as input. If an invalid sequence is found at the start of the string, this function will remove it, and return the value INVALID_SEQUENCE. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(ubyte)[] <code>s</code>
</td> <td>the array whose first code point is to be decoded</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="EncodingScheme.replacementSequence">abstract const @property immutable(ubyte)[] <strong id="replacementSequence">replacementSequence</strong>(); </dt> <dd>
<p>Returns the sequence of ubytes to be used to represent any character which cannot be represented in the encoding scheme. </p>
<p>Normally this will be a representation of some substitution character, such as U+FFFD or '?'.</p> </dd> <dt class="d_decl" id="EncodingScheme.isValid">bool <strong id="isValid">isValid</strong>(const(ubyte)[] s); </dt> <dd>
<p>Returns true if the array is encoded correctly </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(ubyte)[] <code>s</code>
</td> <td>the array to be tested</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="EncodingScheme.validLength">size_t <strong id="validLength">validLength</strong>()(const(ubyte)[] s); </dt> <dd>
<p>Returns the length of the longest possible substring, starting from the first element, which is validly encoded. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(ubyte)[] <code>s</code>
</td> <td>the array to be tested</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="EncodingScheme.sanitize">immutable(ubyte)[] <strong id="sanitize">sanitize</strong>()(immutable(ubyte)[] s); </dt> <dd>
<p>Sanitizes an array by replacing malformed ubyte sequences with valid ubyte sequences. The result is guaranteed to be valid for this encoding scheme. </p>
<p>If the input array is already valid, this function returns the original, otherwise it constructs a new array by replacing all illegal sequences with the encoding scheme's replacement sequence. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>immutable(ubyte)[] <code>s</code>
</td> <td>the string to be sanitized</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="EncodingScheme.firstSequence">size_t <strong id="firstSequence">firstSequence</strong>()(const(ubyte)[] s); </dt> <dd>
<p>Returns the length of the first encoded sequence. </p>
<p>The input to this function MUST be validly encoded. This is enforced by the function's in-contract. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(ubyte)[] <code>s</code>
</td> <td>the array to be sliced</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="EncodingScheme.count">size_t <strong id="count">count</strong>()(const(ubyte)[] s); </dt> <dd>
<p>Returns the total number of code points encoded in a ubyte array. </p>
<p>The input to this function MUST be validly encoded. This is enforced by the function's in-contract. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(ubyte)[] <code>s</code>
</td> <td>the string to be counted</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="EncodingScheme.index">ptrdiff_t <strong id="index">index</strong>()(const(ubyte)[] s, size_t n); </dt> <dd>
<p>Returns the array index at which the (n+1)th code point begins. </p>
<p>The input to this function MUST be validly encoded. This is enforced by the function's in-contract. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(ubyte)[] <code>s</code>
</td> <td>the string to be counted</td>
</tr> <tr>
<td>size_t <code>n</code>
</td> <td>the current code point index</td>
</tr> </table></dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="EncodingSchemeASCII">class <strong id="EncodingSchemeASCII">EncodingSchemeASCII</strong>: std.encoding.EncodingScheme; </dt> <dd>
<p>EncodingScheme to handle ASCII </p>
<p>This scheme recognises the following names: "ANSI_X3.4-1968", "ANSI_X3.4-1986", "ASCII", "IBM367", "ISO646-US", "ISO_646.irv:1991", "US-ASCII", "cp367", "csASCII" "iso-ir-6", "us"</p> </dd> <dt class="d_decl" id="EncodingSchemeLatin1">class <strong id="EncodingSchemeLatin1">EncodingSchemeLatin1</strong>: std.encoding.EncodingScheme; </dt> <dd>
<p>EncodingScheme to handle Latin-1 </p>
<p>This scheme recognises the following names: "CP819", "IBM819", "ISO-8859-1", "ISO_8859-1", "ISO_8859-1:1987", "csISOLatin1", "iso-ir-100", "l1", "latin1"</p> </dd> <dt class="d_decl" id="EncodingSchemeLatin2">class <strong id="EncodingSchemeLatin2">EncodingSchemeLatin2</strong>: std.encoding.EncodingScheme; </dt> <dd>
<p>EncodingScheme to handle Latin-2 </p>
<p>This scheme recognises the following names: "Latin 2", "ISO-8859-2", "ISO_8859-2", "ISO_8859-2:1999", "Windows-28592"</p> </dd> <dt class="d_decl" id="EncodingSchemeWindows1250">class <strong id="EncodingSchemeWindows1250">EncodingSchemeWindows1250</strong>: std.encoding.EncodingScheme; </dt> <dd>
<p>EncodingScheme to handle Windows-1250 </p>
<p>This scheme recognises the following names: "windows-1250"</p> </dd> <dt class="d_decl" id="EncodingSchemeWindows1251">class <strong id="EncodingSchemeWindows1251">EncodingSchemeWindows1251</strong>: std.encoding.EncodingScheme; </dt> <dd>
<p>EncodingScheme to handle Windows-1251 </p>
<p>This scheme recognises the following names: "windows-1251"</p> </dd> <dt class="d_decl" id="EncodingSchemeWindows1252">class <strong id="EncodingSchemeWindows1252">EncodingSchemeWindows1252</strong>: std.encoding.EncodingScheme; </dt> <dd>
<p>EncodingScheme to handle Windows-1252 </p>
<p>This scheme recognises the following names: "windows-1252"</p> </dd> <dt class="d_decl" id="EncodingSchemeUtf8">class <strong id="EncodingSchemeUtf8">EncodingSchemeUtf8</strong>: std.encoding.EncodingScheme; </dt> <dd>
<p>EncodingScheme to handle UTF-8 </p>
<p>This scheme recognises the following names: "UTF-8"</p> </dd> <dt class="d_decl" id="EncodingSchemeUtf16Native">class <strong id="EncodingSchemeUtf16Native">EncodingSchemeUtf16Native</strong>: std.encoding.EncodingScheme; </dt> <dd>
<p>EncodingScheme to handle UTF-16 in native byte order </p>
<p>This scheme recognises the following names: "UTF-16LE" (little-endian architecture only) "UTF-16BE" (big-endian architecture only)</p> </dd> <dt class="d_decl" id="EncodingSchemeUtf32Native">class <strong id="EncodingSchemeUtf32Native">EncodingSchemeUtf32Native</strong>: std.encoding.EncodingScheme; </dt> <dd>
<p>EncodingScheme to handle UTF-32 in native byte order </p>
<p>This scheme recognises the following names: "UTF-32LE" (little-endian architecture only) "UTF-32BE" (big-endian architecture only)</p> </dd> <dt class="d_decl" id="BOM">enum <strong id="BOM">BOM</strong>: int; </dt> <dd>
<p>Definitions of common Byte Order Marks. The elements of the <code>enum</code> can used as indices into <code>bomTable</code> to get matching <code>BOMSeq</code>.</p> <dl>
<dt class="d_decl" id="BOM.none"><strong id="none">none</strong></dt> <dd>
<p>no BOM was found</p> </dd> <dt class="d_decl" id="BOM.utf32be"><strong id="utf32be">utf32be</strong></dt> <dd>
<p>[0x00, 0x00, 0xFE, 0xFF]</p> </dd> <dt class="d_decl" id="BOM.utf32le"><strong id="utf32le">utf32le</strong></dt> <dd>
<p>[0xFF, 0xFE, 0x00, 0x00]</p> </dd> <dt class="d_decl" id="BOM.utf1"><strong id="utf1">utf1</strong></dt> <dd>
<p>[0xF7, 0x64, 0x4C]</p> </dd> <dt class="d_decl" id="BOM.utfebcdic"><strong id="utfebcdic">utfebcdic</strong></dt> <dd>
<p>[0xDD, 0x73, 0x66, 0x73]</p> </dd> <dt class="d_decl" id="BOM.scsu"><strong id="scsu">scsu</strong></dt> <dd>
<p>[0x0E, 0xFE, 0xFF]</p> </dd> <dt class="d_decl" id="BOM.bocu1"><strong id="bocu1">bocu1</strong></dt> <dd>
<p>[0xFB, 0xEE, 0x28]</p> </dd> <dt class="d_decl" id="BOM.gb18030"><strong id="gb18030">gb18030</strong></dt> <dd>
<p>[0x84, 0x31, 0x95, 0x33]</p> </dd> <dt class="d_decl" id="BOM.utf8"><strong id="utf8">utf8</strong></dt> <dd>
<p>[0xEF, 0xBB, 0xBF]</p> </dd> <dt class="d_decl" id="BOM.utf16be"><strong id="utf16be">utf16be</strong></dt> <dd>
<p>[0xFE, 0xFF]</p> </dd> <dt class="d_decl" id="BOM.utf16le"><strong id="utf16le">utf16le</strong></dt> <dd>
<p>[0xFF, 0xFE]</p> </dd> </dl> </dd> <dt class="d_decl" id="BOMSeq">alias <strong id="BOMSeq">BOMSeq</strong> = std.typecons.Tuple!(BOM, "schema", ubyte[], "sequence").Tuple; </dt> <dd>
<p>The type stored inside <code>bomTable</code>.</p> </dd> <dt class="d_decl" id="bomTable">immutable Tuple!(BOM, "schema", ubyte[], "sequence")[] <strong id="bomTable">bomTable</strong>; </dt> <dd>
<p>Mapping of a byte sequence to <b>Byte Order Mark (BOM)</b></p> </dd> <dt class="d_decl" id="getBOM">immutable(BOMSeq) <strong id="getBOM">getBOM</strong>(Range)(Range input)<br><small>  Constraints: if (isForwardRange!Range &amp;&amp; is(immutable(ElementType!Range) == immutable(ubyte))); </small>
</dt> <dd>
<p>Returns a <code>BOMSeq</code> for a given <code>input</code>. If no <code>BOM</code> is present the <code>BOMSeq</code> for <code>BOM.none</code> is returned. The <code>BOM</code> sequence at the beginning of the range will not be comsumed from the passed range. If you pass a reference type range make sure that <code>save</code> creates a deep copy. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>input</code>
</td> <td>The sequence to check for the <code>BOM</code>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>the found <code>BOMSeq</code> corresponding to the passed <code>input</code>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.format : format;

auto ts = dchar(0x0000FEFF) ~ "Hello World"d;

auto entry = getBOM(cast(ubyte[]) ts);
version (BigEndian)
{
    writeln(entry.schema); // BOM.utf32be
}
else
{
    writeln(entry.schema); // BOM.utf32le
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="utfBOM">enum dchar <strong id="utfBOM">utfBOM</strong>; </dt> <dd>
<p>Constant defining a fully decoded BOM</p> </dd> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1999&ndash;2021 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/std_encoding.html" class="_attribution-link">https://dlang.org/phobos/std_encoding.html</a>
  </p>
</div>
