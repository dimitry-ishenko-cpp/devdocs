<h1>std.experimental.allocator.building_blocks.null_allocator</h1>  <dl>
<dt>Source</dt>
<dd> <span class="phobos_src"><a class="https" href="https://github.com/dlang/phobos/blob/master/std/experimental/allocator/building_blocks/null_allocator.d">std/experimental/allocator/building_blocks/null_allocator.d</a></span>
</dd>
</dl> <dl>
<dt class="d_decl" id="NullAllocator">struct <strong id="NullAllocator">NullAllocator</strong>; </dt> <dd>
<p><code>NullAllocator</code> is an emphatically empty implementation of the allocator interface. Although it has no direct use, it is useful as a "terminator" in composite allocators.</p> <dl>
<dt class="d_decl" id="NullAllocator.alignment">enum uint <strong id="alignment">alignment</strong>; </dt> <dd>
<p><code>NullAllocator</code> advertises a relatively large alignment equal to 64 KB. This is because <code>NullAllocator</code> never actually needs to honor this alignment and because composite allocators using <code>NullAllocator</code> shouldn't be unnecessarily constrained.</p> </dd> <dt class="d_decl" id="NullAllocator.allocate">shared pure nothrow @nogc @safe void[] <strong id="allocate">allocate</strong>(size_t); </dt> <dd>
<p>Always returns <code>null</code>.</p> </dd> <dt class="d_decl" id="NullAllocator.alignedAllocate">shared pure nothrow @nogc @safe void[] <strong id="alignedAllocate">alignedAllocate</strong>(size_t, uint); </dt> <dd>
<p>Always returns <code>null</code>.</p> </dd> <dt class="d_decl" id="NullAllocator.allocateAll">shared pure nothrow @nogc @safe void[] <strong id="allocateAll">allocateAll</strong>(); </dt> <dd>
<p>Always returns <code>null</code>.</p> </dd> <dt class="d_decl" id="NullAllocator.expand">shared pure nothrow @nogc @safe bool <strong id="expand">expand</strong>(ref void[] b, size_t s); <br><br>shared pure nothrow @nogc @safe bool <strong id="reallocate">reallocate</strong>(ref void[] b, size_t); <br><br>shared pure nothrow @nogc @safe bool <strong id="alignedReallocate">alignedReallocate</strong>(ref void[] b, size_t, uint); </dt> <dd>
<p>These methods return <code>false</code>. </p>
<dl>
<dt>Precondition</dt>
<dd> <code>b is null</code>. This is because there is no other possible legitimate input.</dd>
</dl> </dd> <dt class="d_decl" id="NullAllocator.owns">shared const pure nothrow @nogc @safe Ternary <strong id="owns">owns</strong>(const void[]); </dt> <dd>
<p>Returns <code>Ternary.no</code>.</p> </dd> <dt class="d_decl" id="NullAllocator.resolveInternalPointer">shared const pure nothrow @nogc @safe Ternary <strong id="resolveInternalPointer">resolveInternalPointer</strong>(const void*, ref void[]); </dt> <dd>
<p>Returns <code>Ternary.no</code>.</p> </dd> <dt class="d_decl" id="NullAllocator.deallocate">shared pure nothrow @nogc @safe bool <strong id="deallocate">deallocate</strong>(void[] b); </dt> <dd>
<p>No-op. </p>
<dl>
<dt>Precondition</dt>
<dd> <code>b is null</code>
</dd>
</dl> </dd> <dt class="d_decl" id="NullAllocator.deallocateAll">shared pure nothrow @nogc @safe bool <strong id="deallocateAll">deallocateAll</strong>(); </dt> <dd>
<p>No-op.</p> </dd> <dt class="d_decl" id="NullAllocator.empty">shared const pure nothrow @nogc @safe Ternary <strong id="empty">empty</strong>(); </dt> <dd>
<p>Returns <code>Ternary.yes</code>.</p> </dd> <dt class="d_decl" id="NullAllocator.instance">static shared NullAllocator <strong id="instance">instance</strong>; </dt> <dd>
<p>Returns the <code>shared</code> global instance of the <code>NullAllocator</code>.</p> </dd> </dl> </dd> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1999&ndash;2021 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/std_experimental_allocator_building_blocks_null_allocator.html" class="_attribution-link">https://dlang.org/phobos/std_experimental_allocator_building_blocks_null_allocator.html</a>
  </p>
</div>
