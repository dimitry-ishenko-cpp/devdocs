<h1>std.algorithm.searching</h1>  <p>This is a submodule of <a href="std_algorithm.html"><code>std.algorithm</code></a>. It contains generic searching algorithms. </p>
<p> <table>
<caption>Cheat Sheet</caption>
<tr>
<th scope="col">Function Name</th> <th scope="col">Description</th>
</tr> <tr>
<td><a href="#all"><code>all</code></a></td> <td> <code>all!"a &gt; 0"([1, 2, 3, 4])</code> returns <code>true</code> because all elements are positive</td>
</tr> <tr>
<td><a href="#any"><code>any</code></a></td> <td> <code>any!"a &gt; 0"([1, 2, -3, -4])</code> returns <code>true</code> because at least one element is positive</td>
</tr> <tr>
<td><a href="#balancedParens"><code>balancedParens</code></a></td> <td> <code>balancedParens("((1 + 1) / 2)")</code> returns <code>true</code> because the string has balanced parentheses.</td>
</tr> <tr>
<td><a href="#boyerMooreFinder"><code>boyerMooreFinder</code></a></td> <td> <code>find("hello world", boyerMooreFinder("or"))</code> returns <code>"orld"</code> using the <a href="https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm"> Boyer-Moore algorithm</a>.</td>
</tr> <tr>
<td><a href="#canFind"><code>canFind</code></a></td> <td> <code>canFind("hello world", "or")</code> returns <code>true</code>.</td>
</tr> <tr>
<td><a href="#count"><code>count</code></a></td> <td> Counts elements that are equal to a specified value or satisfy a predicate. <code>count([1, 2, 1], 1)</code> returns <code>2</code> and <code>count!"a &lt; 0"([1, -3, 0])</code> returns <code>1</code>.</td>
</tr> <tr>
<td><a href="#countUntil"><code>countUntil</code></a></td> <td> <code>countUntil(a, b)</code> returns the number of steps taken in <code>a</code> to reach <code>b</code>; for example, <code>countUntil("hello!", "o")</code> returns <code>4</code>.</td>
</tr> <tr>
<td><a href="#commonPrefix"><code>commonPrefix</code></a></td> <td> <code>commonPrefix("parakeet", "parachute")</code> returns <code>"para"</code>.</td>
</tr> <tr>
<td><a href="#endsWith"><code>endsWith</code></a></td> <td> <code>endsWith("rocks", "ks")</code> returns <code>true</code>.</td>
</tr> <tr>
<td><a href="#find"><code>find</code></a></td> <td> <code>find("hello world", "or")</code> returns <code>"orld"</code> using linear search. (For binary search refer to <a href="std_range.html#SortedRange"><code>std.range.SortedRange</code></a>.)</td>
</tr> <tr>
<td><a href="#findAdjacent"><code>findAdjacent</code></a></td> <td> <code>findAdjacent([1, 2, 3, 3, 4])</code> returns the subrange starting with two equal adjacent elements, i.e. <code>[3, 3, 4]</code>.</td>
</tr> <tr>
<td><a href="#findAmong"><code>findAmong</code></a></td> <td> <code>findAmong("abcd", "qcx")</code> returns <code>"cd"</code> because <code>'c'</code> is among <code>"qcx"</code>.</td>
</tr> <tr>
<td><a href="#findSkip"><code>findSkip</code></a></td> <td> If <code>a = "abcde"</code>, then <code>findSkip(a, "x")</code> returns <code>false</code> and leaves <code>a</code> unchanged, whereas <code>findSkip(a, "c")</code> advances <code>a</code> to <code>"de"</code> and returns <code>true</code>.</td>
</tr> <tr>
<td><a href="#findSplit"><code>findSplit</code></a></td> <td> <code>findSplit("abcdefg", "de")</code> returns the three ranges <code>"abc"</code>, <code>"de"</code>, and <code>"fg"</code>.</td>
</tr> <tr>
<td><a href="#findSplitAfter"><code>findSplitAfter</code></a></td> <td> <code>findSplitAfter("abcdefg", "de")</code> returns the two ranges <code>"abcde"</code> and <code>"fg"</code>.</td>
</tr> <tr>
<td><a href="#findSplitBefore"><code>findSplitBefore</code></a></td> <td> <code>findSplitBefore("abcdefg", "de")</code> returns the two ranges <code>"abc"</code> and <code>"defg"</code>.</td>
</tr> <tr>
<td><a href="#minCount"><code>minCount</code></a></td> <td> <code>minCount([2, 1, 1, 4, 1])</code> returns <code>tuple(1, 3)</code>.</td>
</tr> <tr>
<td><a href="#maxCount"><code>maxCount</code></a></td> <td> <code>maxCount([2, 4, 1, 4, 1])</code> returns <code>tuple(4, 2)</code>.</td>
</tr> <tr>
<td><a href="#minElement"><code>minElement</code></a></td> <td> Selects the minimal element of a range. <code>minElement([3, 4, 1, 2])</code> returns <code>1</code>.</td>
</tr> <tr>
<td><a href="#maxElement"><code>maxElement</code></a></td> <td> Selects the maximal element of a range. <code>maxElement([3, 4, 1, 2])</code> returns <code>4</code>.</td>
</tr> <tr>
<td><a href="#minIndex"><code>minIndex</code></a></td> <td> Index of the minimal element of a range. <code>minElement([3, 4, 1, 2])</code> returns <code>2</code>.</td>
</tr> <tr>
<td><a href="#maxIndex"><code>maxIndex</code></a></td> <td> Index of the maximal element of a range. <code>maxElement([3, 4, 1, 2])</code> returns <code>1</code>.</td>
</tr> <tr>
<td><a href="#minPos"><code>minPos</code></a></td> <td> <code>minPos([2, 3, 1, 3, 4, 1])</code> returns the subrange <code>[1, 3, 4, 1]</code>, i.e., positions the range at the first occurrence of its minimal element.</td>
</tr> <tr>
<td><a href="#maxPos"><code>maxPos</code></a></td> <td> <code>maxPos([2, 3, 1, 3, 4, 1])</code> returns the subrange <code>[4, 1]</code>, i.e., positions the range at the first occurrence of its maximal element.</td>
</tr> <tr>
<td><a href="#skipOver"><code>skipOver</code></a></td> <td> Assume <code>a = "blah"</code>. Then <code>skipOver(a, "bi")</code> leaves <code>a</code> unchanged and returns <code>false</code>, whereas <code>skipOver(a, "bl")</code> advances <code>a</code> to refer to <code>"ah"</code> and returns <code>true</code>.</td>
</tr> <tr>
<td><a href="#startsWith"><code>startsWith</code></a></td> <td> <code>startsWith("hello, world", "hello")</code> returns <code>true</code>.</td>
</tr> <tr>
<td><a href="#until"><code>until</code></a></td> <td> Lazily iterates a range until a specific value is found.</td>
</tr> </table> </p> <dl>
<dt>License:</dt>
<dd>
<a href="http://boost.org/LICENSE_1_0.txt">Boost License 1.0</a>. </dd>
</dl> <dl>
<dt>Authors:</dt>
<dd>
<a href="http://erdani.com">Andrei Alexandrescu</a> </dd>
</dl> <dl>
<dt>Source</dt>
<dd> <span class="phobos_src"><a class="https" href="https://github.com/dlang/phobos/blob/master/std/algorithm/searching.d">std/algorithm/searching.d</a></span> </dd>
</dl> <dl>
<dt class="d_decl" id="all">template <strong id="all">all</strong>(alias pred = "a")</dt> <dd>
<p>Checks if <i>all</i> of the elements verify <code>pred</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert( all!"a &amp; 1"([1, 3, 5, 7, 9]));
assert(!all!"a &amp; 1"([1, 2, 3, 5, 7, 9]));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<code>all</code> can also be used without a predicate, if its items can be evaluated to true or false in a conditional statement. This can be a convenient way to quickly evaluate that <i>all</i> of the elements of a range are true. <pre data-language="d">int[3] vals = [5, 3, 18];
assert( all(vals[]));
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="all.all">bool <strong id="all">all</strong>(Range)(Range range)<br><small>  Constraints: if (isInputRange!Range); </small>
</dt> <dd>
<p>Returns <code>true</code> if and only if <i>all</i> values <code>v</code> found in the input range <code>range</code> satisfy the predicate <code>pred</code>. Performs (at most) <span class="bigoh">Ο(<code>range.length</code>)</span> evaluations of <code>pred</code>.</p> </dd> </dl> </dd> <dt class="d_decl" id="any">template <strong id="any">any</strong>(alias pred = "a")</dt> <dd>
<p>Checks if <i>any</i> of the elements verifies <code>pred</code>. <code>!any</code> can be used to verify that <i>none</i> of the elements verify <code>pred</code>. This is sometimes called <code>exists</code> in other languages.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.ascii : isWhite;
assert( all!(any!isWhite)(["a a", "b b"]));
assert(!any!(all!isWhite)(["a a", "b b"]));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<code>any</code> can also be used without a predicate, if its items can be evaluated to true or false in a conditional statement. <code>!any</code> can be a convenient way to quickly test that <i>none</i> of the elements of a range evaluate to true. <pre data-language="d">int[3] vals1 = [0, 0, 0];
assert(!any(vals1[])); //none of vals1 evaluate to true

int[3] vals2 = [2, 0, 2];
assert( any(vals2[]));
assert(!all(vals2[]));

int[3] vals3 = [3, 3, 3];
assert( any(vals3[]));
assert( all(vals3[]));
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="any.any">bool <strong id="any">any</strong>(Range)(Range range)<br><small>  Constraints: if (isInputRange!Range &amp;&amp; is(typeof(unaryFun!pred(range.front)))); </small>
</dt> <dd>
<p>Returns <code>true</code> if and only if <i>any</i> value <code>v</code> found in the input range <code>range</code> satisfies the predicate <code>pred</code>. Performs (at most) <span class="bigoh">Ο(<code>range.length</code>)</span> evaluations of <code>pred</code>.</p> </dd> </dl> </dd> <dt class="d_decl" id="balancedParens">bool <strong id="balancedParens">balancedParens</strong>(Range, E)(Range r, E lPar, E rPar, size_t maxNestingLevel = size_t.max)<br><small>  Constraints: if (isInputRange!Range &amp;&amp; is(typeof(r.front == lPar))); </small>
</dt> <dd>
<p>Checks whether <code>r</code> has "balanced parentheses", i.e. all instances of <code>lPar</code> are closed by corresponding instances of <code>rPar</code>. The parameter <code>maxNestingLevel</code> controls the nesting level allowed. The most common uses are the default or <code>0</code>. In the latter case, no nesting is allowed. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>r</code>
</td> <td>The range to check.</td>
</tr> <tr>
<td>E <code>lPar</code>
</td> <td>The element corresponding with a left (opening) parenthesis.</td>
</tr> <tr>
<td>E <code>rPar</code>
</td> <td>The element corresponding with a right (closing) parenthesis.</td>
</tr> <tr>
<td>size_t <code>maxNestingLevel</code>
</td> <td>The maximum allowed nesting level.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>true if the given range has balanced parenthesis within the given maximum nesting level; false otherwise.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto s = "1 + (2 * (3 + 1 / 2)";
assert(!balancedParens(s, '(', ')'));
s = "1 + (2 * (3 + 1) / 2)";
assert(balancedParens(s, '(', ')'));
s = "1 + (2 * (3 + 1) / 2)";
assert(!balancedParens(s, '(', ')', 0));
s = "1 + (2 * 3 + 1) / (2 - 5)";
assert(balancedParens(s, '(', ')', 0));
s = "f(x) = ⌈x⌉";
assert(balancedParens(s, '⌈', '⌉'));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="BoyerMooreFinder">struct <strong id="BoyerMooreFinder">BoyerMooreFinder</strong>(alias pred, Range); <br><br>BoyerMooreFinder!(binaryFun!pred, Range) <strong id="boyerMooreFinder">boyerMooreFinder</strong>(alias pred = "a == b", Range)(Range needle)<br><small>  Constraints: if (isRandomAccessRange!Range &amp;&amp; hasSlicing!Range || isSomeString!Range); </small>
</dt> <dd>
<p>Sets up Boyer-Moore matching for use with <code>find</code> below. By default, elements are compared for equality. </p>
<p><code>BoyerMooreFinder</code> allocates GC memory. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>pred</td> <td>Predicate used to compare elements.</td>
</tr> <tr>
<td>Range <code>needle</code>
</td> <td>A random-access range with length and slicing.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>An instance of <code>BoyerMooreFinder</code> that can be used with <code>find()</code> to invoke the Boyer-Moore matching algorithm for finding of <code>needle</code> in a given haystack.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto bmFinder = boyerMooreFinder("TG");

string r = "TAGTGCCTGA";
// search for the first match in the haystack r
r = bmFinder.beFound(r);
writeln(r); // "TGCCTGA"

// continue search in haystack
r = bmFinder.beFound(r[2 .. $]);
writeln(r); // "TGA"
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="BoyerMooreFinder.this">this(Range needle); </dt>  <dt class="d_decl" id="BoyerMooreFinder.beFound">scope Range <strong id="beFound">beFound</strong>(Range haystack); </dt>  <dt class="d_decl" id="BoyerMooreFinder.length">@property size_t <strong id="length">length</strong>(); </dt>  <dt class="d_decl" id="BoyerMooreFinder.opDollar">alias <strong id="opDollar">opDollar</strong> = length; </dt>  </dl> </dd> <dt class="d_decl" id="commonPrefix">auto <strong id="commonPrefix">commonPrefix</strong>(alias pred = "a == b", R1, R2)(R1 r1, R2 r2)<br><small>  Constraints: if (isForwardRange!R1 &amp;&amp; isInputRange!R2 &amp;&amp; !isNarrowString!R1 &amp;&amp; is(typeof(binaryFun!pred(r1.front, r2.front)))); </small><br><br>auto <strong id="commonPrefix">commonPrefix</strong>(alias pred, R1, R2)(R1 r1, R2 r2)<br><small>  Constraints: if (isNarrowString!R1 &amp;&amp; isInputRange!R2 &amp;&amp; is(typeof(binaryFun!pred(r1.front, r2.front)))); </small><br><br>auto <strong id="commonPrefix">commonPrefix</strong>(R1, R2)(R1 r1, R2 r2)<br><small>  Constraints: if (isNarrowString!R1 &amp;&amp; isInputRange!R2 &amp;&amp; !isNarrowString!R2 &amp;&amp; is(typeof(r1.front == r2.front))); </small><br><br>auto <strong id="commonPrefix">commonPrefix</strong>(R1, R2)(R1 r1, R2 r2)<br><small>  Constraints: if (isNarrowString!R1 &amp;&amp; isNarrowString!R2); </small>
</dt> <dd>
<p>Returns the common prefix of two ranges. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>pred</td> <td>The predicate to use in comparing elements for commonality. Defaults to equality <code>"a == b"</code>.</td>
</tr> <tr>
<td>R1 <code>r1</code>
</td> <td>A <a href="std_range_primitives.html#isForwardRange">forward range</a> of elements.</td>
</tr> <tr>
<td>R2 <code>r2</code>
</td> <td>An <a href="std_range_primitives.html#isInputRange">input range</a> of elements.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A slice of <code>r1</code> which contains the characters that both ranges start with, if the first argument is a string; otherwise, the same as the result of <code>takeExactly(r1, n)</code>, where <code>n</code> is the number of elements in the common prefix of both ranges. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd><a href="std_range.html#takeExactly"><code>std.range.takeExactly</code></a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(commonPrefix("hello, world", "hello, there")); // "hello, "
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="count">size_t <strong id="count">count</strong>(alias pred = "a == b", Range, E)(Range haystack, E needle)<br><small>  Constraints: if (isInputRange!Range &amp;&amp; !isInfinite!Range &amp;&amp; is(typeof(binaryFun!pred(haystack.front, needle)) : bool)); </small><br><br>size_t <strong id="count">count</strong>(alias pred = "a == b", R1, R2)(R1 haystack, R2 needle)<br><small>  Constraints: if (isForwardRange!R1 &amp;&amp; !isInfinite!R1 &amp;&amp; isForwardRange!R2 &amp;&amp; is(typeof(binaryFun!pred(haystack.front, needle.front)) : bool)); </small><br><br>size_t <strong id="count">count</strong>(alias pred, R)(R haystack)<br><small>  Constraints: if (isInputRange!R &amp;&amp; !isInfinite!R &amp;&amp; is(typeof(unaryFun!pred(haystack.front)) : bool)); </small><br><br>size_t <strong id="count">count</strong>(R)(R haystack)<br><small>  Constraints: if (isInputRange!R &amp;&amp; !isInfinite!R); </small>
</dt> <dd>
<p>The first version counts the number of elements <code>x</code> in <code>r</code> for which <code>pred(x, value)</code> is <code>true</code>. <code>pred</code> defaults to equality. Performs <span class="bigoh">Ο(<code>haystack.length</code>)</span> evaluations of <code>pred</code>. </p>
<p>The second version returns the number of times <code>needle</code> occurs in <code>haystack</code>. Throws an exception if <code>needle.empty</code>, as the count of the empty range in any range would be infinite. Overlapped counts are not considered, for example <code>count("aaa", "aa")</code> is <code>1</code>, not <code>2</code>. <br><br> The third version counts the elements for which <code>pred(x)</code> is <code>true</code>. Performs <span class="bigoh">Ο(<code>haystack.length</code>)</span> evaluations of <code>pred</code>. <br><br> The fourth version counts the number of elements in a range. It is an optimization for the third version: if the given range has the <code>length</code> property the count is returned right away, otherwise performs <span class="bigoh">Ο(<code>haystack.length</code>)</span> to walk the range. </p> <dl>
<dt>Note</dt>
<dd> Regardless of the overload, <code>count</code> will not accept infinite ranges for <code>haystack</code>. </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>pred</td> <td>The predicate to evaluate.</td>
</tr> <tr>
<td>Range <code>haystack</code>
</td> <td>The range to count.</td>
</tr> <tr>
<td>E <code>needle</code>
</td> <td>The element or sub-range to count in the <code>haystack</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The number of positions in the <code>haystack</code> for which <code>pred</code> returned true.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.uni : toLower;

// count elements in range
int[] a = [ 1, 2, 4, 3, 2, 5, 3, 2, 4 ];
writeln(count(a)); // 9
writeln(count(a, 2)); // 3
writeln(count!("a &gt; b")(a, 2)); // 5
// count range in range
writeln(count("abcadfabf", "ab")); // 2
writeln(count("ababab", "abab")); // 1
writeln(count("ababab", "abx")); // 0
// fuzzy count range in range
writeln(count!((a, b) =&gt; toLower(a) == toLower(b))("AbcAdFaBf", "ab")); // 2
// count predicate in range
writeln(count!("a &gt; 1")(a)); // 8
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="countUntil">ptrdiff_t <strong id="countUntil">countUntil</strong>(alias pred = "a == b", R, Rs...)(R haystack, Rs needles)<br><small>  Constraints: if (isForwardRange!R &amp;&amp; (Rs.length &gt; 0) &amp;&amp; (isForwardRange!(Rs[0]) == isInputRange!(Rs[0])) &amp;&amp; is(typeof(startsWith!pred(haystack, needles[0]))) &amp;&amp; (Rs.length == 1 || is(typeof(countUntil!pred(haystack, needles[1..$]))))); </small><br><br>ptrdiff_t <strong id="countUntil">countUntil</strong>(alias pred = "a == b", R, N)(R haystack, N needle)<br><small>  Constraints: if (isInputRange!R &amp;&amp; is(typeof(binaryFun!pred(haystack.front, needle)) : bool)); </small><br><br>ptrdiff_t <strong id="countUntil">countUntil</strong>(alias pred, R)(R haystack)<br><small>  Constraints: if (isInputRange!R &amp;&amp; is(typeof(unaryFun!pred(haystack.front)) : bool)); </small>
</dt> <dd>
<p>Counts elements in the given <a href="std_range_primitives.html#isForwardRange">forward range</a> until the given predicate is true for one of the given <code>needles</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>pred</td> <td>The predicate for determining when to stop counting.</td>
</tr> <tr>
<td>R <code>haystack</code>
</td> <td>The <a href="std_range_primitives.html#isInputRange">input range</a> to be counted.</td>
</tr> <tr>
<td>Rs <code>needles</code>
</td> <td>Either a single element, or a <a href="std_range_primitives.html#isForwardRange">forward range</a> of elements, to be evaluated in turn against each element in <code>haystack</code> under the given predicate.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The number of elements which must be popped from the front of <code>haystack</code> before reaching an element for which <code>startsWith!pred(haystack, needles)</code> is <code>true</code>. If <code>startsWith!pred(haystack, needles)</code> is not <code>true</code> for any element in <code>haystack</code>, then <code>-1</code> is returned. If only <code>pred</code> is provided, <code>pred(haystack)</code> is tested for each element. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd><a href="std_string.html#indexOf"><code>std.string.indexOf</code></a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(countUntil("hello world", "world")); // 6
writeln(countUntil("hello world", 'r')); // 8
writeln(countUntil("hello world", "programming")); // -1
writeln(countUntil("日本語", "本語")); // 1
writeln(countUntil("日本語", '語')); // 2
writeln(countUntil("日本語", "五")); // -1
writeln(countUntil("日本語", '五')); // -1
writeln(countUntil([0, 7, 12, 22, 9], [12, 22])); // 2
writeln(countUntil([0, 7, 12, 22, 9], 9)); // 4
writeln(countUntil!"a &gt; b"([0, 7, 12, 22, 9], 20)); // 3
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.ascii : isDigit;
import std.uni : isWhite;

writeln(countUntil!(std.uni.isWhite)("hello world")); // 5
writeln(countUntil!(std.ascii.isDigit)("hello world")); // -1
writeln(countUntil!"a &gt; 20"([0, 7, 12, 22, 9])); // 3
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="endsWith">uint <strong id="endsWith">endsWith</strong>(alias pred = "a == b", Range, Needles...)(Range doesThisEnd, Needles withOneOfThese)<br><small>  Constraints: if (isBidirectionalRange!Range &amp;&amp; (Needles.length &gt; 1) &amp;&amp; is(typeof(.endsWith!pred(doesThisEnd, withOneOfThese[0])) : bool) &amp;&amp; is(typeof(.endsWith!pred(doesThisEnd, withOneOfThese[1..$])) : uint)); </small><br><br>bool <strong id="endsWith">endsWith</strong>(alias pred = "a == b", R1, R2)(R1 doesThisEnd, R2 withThis)<br><small>  Constraints: if (isBidirectionalRange!R1 &amp;&amp; isBidirectionalRange!R2 &amp;&amp; is(typeof(binaryFun!pred(doesThisEnd.back, withThis.back)) : bool)); </small><br><br>bool <strong id="endsWith">endsWith</strong>(alias pred = "a == b", R, E)(R doesThisEnd, E withThis)<br><small>  Constraints: if (isBidirectionalRange!R &amp;&amp; is(typeof(binaryFun!pred(doesThisEnd.back, withThis)) : bool)); </small><br><br>bool <strong id="endsWith">endsWith</strong>(alias pred, R)(R doesThisEnd)<br><small>  Constraints: if (isInputRange!R &amp;&amp; ifTestable!(typeof(doesThisEnd.front), unaryFun!pred)); </small>
</dt> <dd>
<p>Checks if the given range ends with (one of) the given needle(s). The reciprocal of <code>startsWith</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>pred</td> <td>The predicate to use for comparing elements between the range and the needle(s).</td>
</tr> <tr>
<td>Range <code>doesThisEnd</code>
</td> <td>The <a href="std_range_primitives.html#isBidirectionalRange">bidirectional range</a> to check.</td>
</tr> <tr>
<td>Needles <code>withOneOfThese</code>
</td> <td>The needles to check against, which may be single elements, or bidirectional ranges of elements.</td>
</tr> <tr>
<td>R2 <code>withThis</code>
</td> <td>The single element to check.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>0 if the needle(s) do not occur at the end of the given range; otherwise the position of the matching needle, that is, 1 if the range ends with <code>withOneOfThese[0]</code>, 2 if it ends with <code>withOneOfThese[1]</code>, and so on.  In the case when no needle parameters are given, return <code>true</code> iff back of <code>doesThisStart</code> fulfils predicate <code>pred</code>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.ascii : isAlpha;
assert("abc".endsWith!(a =&gt; a.isAlpha));
assert("abc".endsWith!isAlpha);

assert(!"ab1".endsWith!(a =&gt; a.isAlpha));

assert(!"ab1".endsWith!isAlpha);
assert(!"".endsWith!(a =&gt; a.isAlpha));

import std.algorithm.comparison : among;
assert("abc".endsWith!(a =&gt; a.among('c', 'd') != 0));
assert(!"abc".endsWith!(a =&gt; a.among('a', 'b') != 0));

assert(endsWith("abc", ""));
assert(!endsWith("abc", "b"));
writeln(endsWith("abc", "a", 'c')); // 2
writeln(endsWith("abc", "c", "a")); // 1
writeln(endsWith("abc", "c", "c")); // 1
writeln(endsWith("abc", "bc", "c")); // 2
writeln(endsWith("abc", "x", "c", "b")); // 2
writeln(endsWith("abc", "x", "aa", "bc")); // 3
writeln(endsWith("abc", "x", "aaa", "sab")); // 0
writeln(endsWith("abc", "x", "aaa", 'c', "sab")); // 3
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="find">InputRange <strong id="find">find</strong>(alias pred = "a == b", InputRange, Element)(InputRange haystack, scope Element needle)<br><small>  Constraints: if (isInputRange!InputRange &amp;&amp; is(typeof(binaryFun!pred(haystack.front, needle)) : bool) &amp;&amp; !is(typeof(binaryFun!pred(haystack.front, needle.front)) : bool)); </small><br><br>InputRange <strong id="find">find</strong>(alias pred, InputRange)(InputRange haystack)<br><small>  Constraints: if (isInputRange!InputRange); </small><br><br>R1 <strong id="find">find</strong>(alias pred = "a == b", R1, R2)(R1 haystack, scope R2 needle)<br><small>  Constraints: if (isForwardRange!R1 &amp;&amp; isForwardRange!R2 &amp;&amp; is(typeof(binaryFun!pred(haystack.front, needle.front)) : bool)); </small>
</dt> <dd>
<p>Finds an individual element in an <a href="std_range_primitives.html#isInputRange">input range</a>. Elements of <code>haystack</code> are compared with <code>needle</code> by using predicate <code>pred</code> with <code>pred(haystack.front, needle)</code>. <code>find</code> performs <span class="bigoh">Ο(<code>walkLength(haystack)</code>)</span> evaluations of <code>pred</code>. </p>
<p>The predicate is passed to <a href="std_functional.html#binaryFun"><code>std.functional.binaryFun</code></a>, and can either accept a string, or any callable that can be executed via <code>pred(element, element)</code>. <br><br> To find the last occurrence of <code>needle</code> in a <a href="std_range_primitives.html#isBidirectionalRange">bidirectional</a> <code>haystack</code>, call <code>find(retro(haystack), needle)</code>. See <a href="std_range.html#retro"><code>std.range.retro</code></a>. <br><br> If no <code>needle</code> is provided, <code>pred(haystack.front)</code> will be evaluated on each element of the input range. <br><br> If <code>input</code> is a <a href="std_range_primitives.html#isForwardRange">forward range</a>, <code>needle</code> can be a <a href="std_range_primitives.html#isForwardRange">forward range</a> too. In this case <code>startsWith!pred(haystack, needle)</code> is evaluated on each evaluation. </p> <dl>
<dt>Note</dt>
<dd> <code>find</code> behaves similar to <code>dropWhile</code> in other languages. </dd>
</dl> <dl>
<dt>Complexity</dt>
<dd> <code>find</code> performs <span class="bigoh">Ο(<code>walkLength(haystack)</code>)</span> evaluations of <code>pred</code>. There are specializations that improve performance by taking advantage of <a href="std_range_primitives.html#isBidirectionalRange">bidirectional</a> or <a href="std_range_primitives.html#isRandomAccess">random access</a> ranges (where possible). </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>pred</td> <td>The predicate for comparing each element with the needle, defaulting to equality <code>"a == b"</code>. The negated predicate <code>"a != b"</code> can be used to search instead for the first element <i>not</i> matching the needle.</td>
</tr> <tr>
<td>InputRange <code>haystack</code>
</td> <td>The <a href="std_range_primitives.html#isInputRange">input range</a> searched in.</td>
</tr> <tr>
<td>Element <code>needle</code>
</td> <td>The element searched for.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>haystack</code> advanced such that the front element is the one searched for; that is, until <code>binaryFun!pred(haystack.front, needle)</code> is <code>true</code>. If no such position exists, returns an empty <code>haystack</code>. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="#findAdjacent"><code>findAdjacent</code></a>, <a href="#findAmong"><code>findAmong</code></a>, <a href="#findSkip"><code>findSkip</code></a>, <a href="#findSplit"><code>findSplit</code></a>, <a href="#startsWith"><code>startsWith</code></a>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.range.primitives;

auto arr = [1, 2, 4, 4, 4, 4, 5, 6, 9];
writeln(arr.find(4)); // [4, 4, 4, 4, 5, 6, 9]
writeln(arr.find(1)); // arr
writeln(arr.find(9)); // [9]
writeln(arr.find!((a, b) =&gt; a &gt; b)(4)); // [5, 6, 9]
writeln(arr.find!((a, b) =&gt; a &lt; b)(4)); // arr
assert(arr.find(0).empty);
assert(arr.find(10).empty);
assert(arr.find(8).empty);

writeln(find("hello, world", ',')); // ", world"
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Case-insensitive find of a string <pre data-language="d">import std.range.primitives;
import std.uni : toLower;

string[] s = ["Hello", "world", "!"];
writeln(s.find!((a, b) =&gt; toLower(a) == b)("hello")); // s
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto arr = [ 1, 2, 3, 4, 1 ];
writeln(find!("a &gt; 2")(arr)); // [3, 4, 1]

// with predicate alias
bool pred(int x) { return x + 1 &gt; 1.5; }
writeln(find!(pred)(arr)); // arr
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.container : SList;
import std.range.primitives : empty;
import std.typecons : Tuple;

assert(find("hello, world", "World").empty);
writeln(find("hello, world", "wo")); // "world"
writeln([1, 2, 3, 4].find(SList!int(2, 3)[])); // [2, 3, 4]
alias C = Tuple!(int, "x", int, "y");
auto a = [C(1,0), C(2,0), C(3,1), C(4,0)];
writeln(a.find!"a.x == b"([2, 3])); // [C(2, 0), C(3, 1), C(4, 0)]
writeln(a[1 .. $].find!"a.x == b"([2, 3])); // [C(2, 0), C(3, 1), C(4, 0)]
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="find.2">Tuple!(Range, size_t) <strong id="find">find</strong>(alias pred = "a == b", Range, Ranges...)(Range haystack, Ranges needles)<br><small>  Constraints: if (Ranges.length &gt; 1 &amp;&amp; is(typeof(startsWith!pred(haystack, needles)))); </small>
</dt> <dd>
<p>Finds two or more <code>needles</code> into a <code>haystack</code>. The predicate <code>pred</code> is used throughout to compare elements. By default, elements are compared for equality. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>pred</td> <td>The predicate to use for comparing elements.</td>
</tr> <tr>
<td>Range <code>haystack</code>
</td> <td>The target of the search. Must be an input range. If any of <code>needles</code> is a range with elements comparable to elements in <code>haystack</code>, then <code>haystack</code> must be a <a href="std_range_primitives.html#isForwardRange">forward range</a> such that the search can backtrack.</td>
</tr> <tr>
<td>Ranges <code>needles</code>
</td> <td>One or more items to search for. Each of <code>needles</code> must be either comparable to one element in <code>haystack</code>, or be itself a forward range with elements comparable with elements in <code>haystack</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A tuple containing <code>haystack</code> positioned to match one of the needles and also the 1-based index of the matching element in <code>needles</code> (0 if none of <code>needles</code> matched, 1 if <code>needles[0]</code> matched, 2 if <code>needles[1]</code> matched...). The first needle to be found will be the one that matches. If multiple needles are found at the same spot in the range, then the shortest one is the one which matches (if multiple needles of the same length are found at the same spot (e.g <code>"a"</code> and <code>'a'</code>), then the left-most of them in the argument list matches).  The relationship between <code>haystack</code> and <code>needles</code> simply means that one can e.g. search for individual <code>int</code>s or arrays of <code>int</code>s in an array of <code>int</code>s. In addition, if elements are individually comparable, searches of heterogeneous types are allowed as well: a <code>double[]</code> can be searched for an <code>int</code> or a <code>short[]</code>, and conversely a <code>long</code> can be searched for a <code>float</code> or a <code>double[]</code>. This makes for efficient searches without the need to coerce one side of the comparison into the other's side type.  The complexity of the search is <span class="bigoh">Ο(<code>haystack.length * max(needles.length)</code>)</span>. (For needles that are individual items, length is considered to be 1.) The strategy used in searching several subranges at once maximizes cache usage by moving in <code>haystack</code> as few times as possible.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.typecons : tuple;
int[] a = [ 1, 4, 2, 3 ];
writeln(find(a, 4)); // [4, 2, 3]
writeln(find(a, [1, 4])); // [1, 4, 2, 3]
writeln(find(a, [1, 3], 4)); // tuple([4, 2, 3], 2)
// Mixed types allowed if comparable
writeln(find(a, 5, [1.2, 3.5], 2.0)); // tuple([2, 3], 3)
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="find.3">RandomAccessRange <strong id="find">find</strong>(RandomAccessRange, alias pred, InputRange)(RandomAccessRange haystack, scope BoyerMooreFinder!(pred, InputRange) needle); </dt> <dd>
<p>Finds <code>needle</code> in <code>haystack</code> efficiently using the <a href="https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm"> Boyer-Moore</a> method. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>RandomAccessRange <code>haystack</code>
</td> <td>A random-access range with length and slicing.</td>
</tr> <tr>
<td>BoyerMooreFinder!(pred, InputRange) <code>needle</code>
</td> <td>A <a href="#BoyerMooreFinder"><code>BoyerMooreFinder</code></a>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>haystack</code> advanced such that <code>needle</code> is a prefix of it (if no such position exists, returns <code>haystack</code> advanced to termination).</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.range.primitives : empty;
int[] a = [ -1, 0, 1, 2, 3, 4, 5 ];
int[] b = [ 1, 2, 3 ];

writeln(find(a, boyerMooreFinder(b))); // [1, 2, 3, 4, 5]
assert(find(b, boyerMooreFinder(a)).empty);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="canFind">template <strong id="canFind">canFind</strong>(alias pred = "a == b")</dt> <dd>
<p>Convenience function. Like find, but only returns whether or not the search was successful. </p>
<dl>
<dt>See Also:</dt>
<dd>
<a href="std_algorithm_comparison.html#among"><code>std.algorithm.comparison.among</code></a> for checking a value against multiple possibilities.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(canFind([0, 1, 2, 3], 2)); // true
assert(canFind([0, 1, 2, 3], [1, 2], [2, 3]));
writeln(canFind([0, 1, 2, 3], [1, 2], [2, 3])); // 1
assert(canFind([0, 1, 2, 3], [1, 7], [2, 3]));
writeln(canFind([0, 1, 2, 3], [1, 7], [2, 3])); // 2

writeln(canFind([0, 1, 2, 3], 4)); // false
assert(!canFind([0, 1, 2, 3], [1, 3], [2, 4]));
writeln(canFind([0, 1, 2, 3], [1, 3], [2, 4])); // 0
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Example using a custom predicate. Note that the needle appears as the second argument of the predicate. <pre data-language="d">auto words = [
    "apple",
    "beeswax",
    "cardboard"
];
assert(!canFind(words, "bees"));
assert( canFind!((string a, string b) =&gt; a.startsWith(b))(words, "bees"));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Search for mutliple items in an array of items (search for needles in an array of hay stacks) <pre data-language="d">string s1 = "aaa111aaa";
string s2 = "aaa222aaa";
string s3 = "aaa333aaa";
string s4 = "aaa444aaa";
const hay = [s1, s2, s3, s4];
assert(hay.canFind!(e =&gt; (e.canFind("111", "222"))));
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="canFind.canFind">bool <strong id="canFind">canFind</strong>(Range)(Range haystack)<br><small>  Constraints: if (is(typeof(find!pred(haystack)))); </small>
</dt> <dd>
<p>Returns <code>true</code> if and only if any value <code>v</code> found in the input range <code>range</code> satisfies the predicate <code>pred</code>. Performs (at most) <span class="bigoh">Ο(<code>haystack.length</code>)</span> evaluations of <code>pred</code>.</p> </dd> <dt class="d_decl" id="canFind.canFind.2">bool <strong id="canFind">canFind</strong>(Range, Element)(Range haystack, scope Element needle)<br><small>  Constraints: if (is(typeof(find!pred(haystack, needle)))); </small>
</dt> <dd>
<p>Returns <code>true</code> if and only if <code>needle</code> can be found in <code> range</code>. Performs <span class="bigoh">Ο(<code>haystack.length</code>)</span> evaluations of <code>pred</code>.</p> </dd> <dt class="d_decl" id="canFind.canFind.3">size_t <strong id="canFind">canFind</strong>(Range, Ranges...)(Range haystack, scope Ranges needles)<br><small>  Constraints: if (Ranges.length &gt; 1 &amp;&amp; allSatisfy!(isForwardRange, Ranges) &amp;&amp; is(typeof(find!pred(haystack, needles)))); </small>
</dt> <dd>
<p>Returns the 1-based index of the first needle found in <code>haystack</code>. If no needle is found, then <code>0</code> is returned. </p>
<p>So, if used directly in the condition of an if statement or loop, the result will be <code>true</code> if one of the needles is found and <code>false</code> if none are found, whereas if the result is used elsewhere, it can either be cast to <code>bool</code> for the same effect or used to get which needle was found first without having to deal with the tuple that <code>LREF find</code> returns for the same operation.</p> </dd> </dl> </dd> <dt class="d_decl" id="findAdjacent">Range <strong id="findAdjacent">findAdjacent</strong>(alias pred = "a == b", Range)(Range r)<br><small>  Constraints: if (isForwardRange!Range); </small>
</dt> <dd>
<p>Advances <code>r</code> until it finds the first two adjacent elements <code>a</code>, <code>b</code> that satisfy <code>pred(a, b)</code>. Performs <span class="bigoh">Ο(<code>r.length</code>)</span> evaluations of <code>pred</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>pred</td> <td>The predicate to satisfy.</td>
</tr> <tr>
<td>Range <code>r</code>
</td> <td>A <a href="std_range_primitives.html#isForwardRange">forward range</a> to search in.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>r</code> advanced to the first occurrence of two adjacent elements that satisfy the given predicate. If there are no such two elements, returns <code>r</code> advanced until empty. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd><a href="http://en.cppreference.com/w/cpp/algorithm/adjacent_find">STL's <code>adjacent_find</code></a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int[] a = [ 11, 10, 10, 9, 8, 8, 7, 8, 9 ];
auto r = findAdjacent(a);
writeln(r); // [10, 10, 9, 8, 8, 7, 8, 9]
auto p = findAdjacent!("a &lt; b")(a);
writeln(p); // [7, 8, 9]
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="findAmong">InputRange <strong id="findAmong">findAmong</strong>(alias pred = "a == b", InputRange, ForwardRange)(InputRange seq, ForwardRange choices)<br><small>  Constraints: if (isInputRange!InputRange &amp;&amp; isForwardRange!ForwardRange); </small>
</dt> <dd>
<p>Searches the given range for an element that matches one of the given choices. </p>
<p>Advances <code>seq</code> by calling <code>seq.popFront</code> until either <code>find!(pred)(choices, seq.front)</code> is <code>true</code>, or <code>seq</code> becomes empty. Performs <span class="bigoh">Ο(<code>seq.length * choices.length</code>)</span> evaluations of <code>pred</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>pred</td> <td>The predicate to use for determining a match.</td>
</tr> <tr>
<td>InputRange <code>seq</code>
</td> <td>The <a href="std_range_primitives.html#isInputRange">input range</a> to search.</td>
</tr> <tr>
<td>ForwardRange <code>choices</code>
</td> <td>A <a href="std_range_primitives.html#isForwardRange">forward range</a> of possible choices.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>seq</code> advanced to the first matching element, or until empty if there are no matching elements. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="#find"><code>find</code></a>, <a href="algorithm_comparison_among.html#std"><code>algorithm.comparison.among.std</code></a>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int[] a = [ -1, 0, 1, 2, 3, 4, 5 ];
int[] b = [ 3, 1, 2 ];
writeln(findAmong(a, b)); // a[2 .. &amp;dollar;]
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="findSkip">bool <strong id="findSkip">findSkip</strong>(alias pred = "a == b", R1, R2)(ref R1 haystack, R2 needle)<br><small>  Constraints: if (isForwardRange!R1 &amp;&amp; isForwardRange!R2 &amp;&amp; is(typeof(binaryFun!pred(haystack.front, needle.front)))); </small><br><br>size_t <strong id="findSkip">findSkip</strong>(alias pred, R1)(ref R1 haystack)<br><small>  Constraints: if (isForwardRange!R1 &amp;&amp; ifTestable!(typeof(haystack.front), unaryFun!pred)); </small>
</dt> <dd>
<p>Finds <code>needle</code> in <code>haystack</code> and positions <code>haystack</code> right after the first occurrence of <code>needle</code>. </p>
<p>If no needle is provided, the <code>haystack</code> is advanced as long as <code>pred</code> evaluates to <code>true</code>. Similarly, the haystack is positioned so as <code>pred</code> evaluates to <code>false</code> for <code>haystack.front</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R1 <code>haystack</code>
</td> <td>The <a href="std_range_primitives.html#isForwardRange">forward range</a> to search in.</td>
</tr> <tr>
<td>R2 <code>needle</code>
</td> <td>The <a href="std_range_primitives.html#isForwardRange">forward range</a> to search for.</td>
</tr> <tr>
<td>pred</td> <td>Custom predicate for comparison of haystack and needle</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if the needle was found, in which case <code>haystack</code> is positioned after the end of the first occurrence of <code>needle</code>; otherwise <code>false</code>, leaving <code>haystack</code> untouched. If no needle is provided, it returns the number of times <code>pred(haystack.front)</code> returned true. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd><a href="#find"><code>find</code></a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.range.primitives : empty;
// Needle is found; s is replaced by the substring following the first
// occurrence of the needle.
string s = "abcdef";
assert(findSkip(s, "cd") &amp;&amp; s == "ef");

// Needle is not found; s is left untouched.
s = "abcdef";
assert(!findSkip(s, "cxd") &amp;&amp; s == "abcdef");

// If the needle occurs at the end of the range, the range is left empty.
s = "abcdef";
assert(findSkip(s, "def") &amp;&amp; s.empty);
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.ascii : isWhite;
string s = "    abc";
assert(findSkip!isWhite(s) &amp;&amp; s == "abc");
assert(!findSkip!isWhite(s) &amp;&amp; s == "abc");

s = "  ";
writeln(findSkip!isWhite(s)); // 2
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="findSplit">auto <strong id="findSplit">findSplit</strong>(alias pred = "a == b", R1, R2)(R1 haystack, R2 needle)<br><small>  Constraints: if (isForwardRange!R1 &amp;&amp; isForwardRange!R2); </small><br><br>auto <strong id="findSplitBefore">findSplitBefore</strong>(alias pred = "a == b", R1, R2)(R1 haystack, R2 needle)<br><small>  Constraints: if (isForwardRange!R1 &amp;&amp; isForwardRange!R2); </small><br><br>auto <strong id="findSplitAfter">findSplitAfter</strong>(alias pred = "a == b", R1, R2)(R1 haystack, R2 needle)<br><small>  Constraints: if (isForwardRange!R1 &amp;&amp; isForwardRange!R2); </small>
</dt> <dd>
<p>These functions find the first occurrence of <code>needle</code> in <code>haystack</code> and then split <code>haystack</code> as follows. </p>
<p><code>findSplit</code> returns a tuple <code>result</code> containing <i>three</i> ranges. <code>result[0]</code> is the portion of <code>haystack</code> before <code>needle</code>, <code>result[1]</code> is the portion of <code>haystack</code> that matches <code>needle</code>, and <code>result[2]</code> is the portion of <code>haystack</code> after the match. If <code>needle</code> was not found, <code>result[0]</code> comprehends <code>haystack</code> entirely and <code>result[1]</code> and <code>result[2]</code> are empty. <br><br> <code>findSplitBefore</code> returns a tuple <code>result</code> containing two ranges. <code>result[0]</code> is the portion of <code>haystack</code> before <code>needle</code>, and <code>result[1]</code> is the balance of <code>haystack</code> starting with the match. If <code>needle</code> was not found, <code>result[0]</code> comprehends <code>haystack</code> entirely and <code>result[1]</code> is empty. <br><br> <code>findSplitAfter</code> returns a tuple <code>result</code> containing two ranges. <code>result[0]</code> is the portion of <code>haystack</code> up to and including the match, and <code>result[1]</code> is the balance of <code>haystack</code> starting after the match. If <code>needle</code> was not found, <code>result[0]</code> is empty and <code>result[1]</code> is <code>haystack</code>. <br><br> In all cases, the concatenation of the returned ranges spans the entire <code>haystack</code>. <br><br> If <code>haystack</code> is a random-access range, all three components of the tuple have the same type as <code>haystack</code>. Otherwise, <code>haystack</code> must be a <a href="std_range_primitives.html#isForwardRange">forward range</a> and the type of <code>result[0]</code> and <code>result[1]</code> is the same as <a href="std_range.html#takeExactly"><code>std.range.takeExactly</code></a>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>pred</td> <td>Predicate to use for comparing needle against haystack.</td>
</tr> <tr>
<td>R1 <code>haystack</code>
</td> <td>The range to search.</td>
</tr> <tr>
<td>R2 <code>needle</code>
</td> <td>What to look for.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A sub-type of <code>Tuple!()</code> of the split portions of <code>haystack</code> (see above for details). This sub-type of <code>Tuple!()</code> has <code>opCast</code> defined for <code>bool</code>. This <code>opCast</code> returns <code>true</code> when the separating <code>needle</code> was found and <code>false</code> otherwise. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd><a href="#find"><code>find</code></a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Returning a subtype of <a href="std_typecons.html#Tuple"><code>std.typecons.Tuple</code></a> enables the following convenient idiom: <pre data-language="d">// findSplit returns a triplet
if (auto split = "dlang-rocks".findSplit("-"))
{
    writeln(split[0]); // "dlang"
    writeln(split[1]); // "-"
    writeln(split[2]); // "rocks"
}
else assert(0);

// works with const aswell
if (const split = "dlang-rocks".findSplit("-"))
{
    writeln(split[0]); // "dlang"
    writeln(split[1]); // "-"
    writeln(split[2]); // "rocks"
}
else assert(0);
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.range.primitives : empty;

auto a = "Carl Sagan Memorial Station";
auto r = findSplit(a, "Velikovsky");
import std.typecons : isTuple;
static assert(isTuple!(typeof(r.asTuple)));
static assert(isTuple!(typeof(r)));
assert(!r);
writeln(r[0]); // a
assert(r[1].empty);
assert(r[2].empty);
r = findSplit(a, " ");
writeln(r[0]); // "Carl"
writeln(r[1]); // " "
writeln(r[2]); // "Sagan Memorial Station"
if (const r1 = findSplitBefore(a, "Sagan"))
{
    assert(r1);
    writeln(r1[0]); // "Carl "
    writeln(r1[1]); // "Sagan Memorial Station"
}
if (const r2 = findSplitAfter(a, "Sagan"))
{
    assert(r2);
    writeln(r2[0]); // "Carl Sagan"
    writeln(r2[1]); // " Memorial Station"
}
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Use <a href="std_range.html#only"><code>std.range.only</code></a> to find single elements: <pre data-language="d">import std.range : only;
writeln([1, 2, 3, 4].findSplitBefore(only(3))[0]); // [1, 2]
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="minCount">Tuple!(ElementType!Range, size_t) <strong id="minCount">minCount</strong>(alias pred = "a &lt; b", Range)(Range range)<br><small>  Constraints: if (isInputRange!Range &amp;&amp; !isInfinite!Range &amp;&amp; is(typeof(binaryFun!pred(range.front, range.front)))); </small><br><br>Tuple!(ElementType!Range, size_t) <strong id="maxCount">maxCount</strong>(alias pred = "a &lt; b", Range)(Range range)<br><small>  Constraints: if (isInputRange!Range &amp;&amp; !isInfinite!Range &amp;&amp; is(typeof(binaryFun!pred(range.front, range.front)))); </small>
</dt> <dd>
<p>Computes the minimum (respectively maximum) of <code>range</code> along with its number of occurrences. Formally, the minimum is a value <code>x</code> in <code>range</code> such that <code>pred(a, x)</code> is <code>false</code> for all values <code>a</code> in <code>range</code>. Conversely, the maximum is a value <code>x</code> in <code>range</code> such that <code>pred(x, a)</code> is <code>false</code> for all values <code>a</code> in <code>range</code> (note the swapped arguments to <code>pred</code>). </p>
<p>These functions may be used for computing arbitrary extrema by choosing <code>pred</code> appropriately. For corrrect functioning, <code>pred</code> must be a strict partial order, i.e. transitive (if <code>pred(a, b) &amp;&amp; pred(b, c)</code> then <code>pred(a, c)</code>) and irreflexive (<code>pred(a, a)</code> is <code>false</code>). The <a href="#">trichotomy property of inequality</a> is not required: these algorithms consider elements <code>a</code> and <code>b</code> equal (for the purpose of counting) if <code>pred</code> puts them in the same equivalence class, i.e. <code>!pred(a, b) &amp;&amp; !pred(b, a)</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>pred</td> <td>The ordering predicate to use to determine the extremum (minimum or maximum).</td>
</tr> <tr>
<td>Range <code>range</code>
</td> <td>The <a href="std_range_primitives.html#isInputRange">input range</a> to count.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The minimum, respectively maximum element of a range together with the number it occurs in the range. </dd>
</dl> <dl>
<dt>Limitations</dt>
<dd> If at least one of the arguments is NaN, the result is an unspecified value. See <a href="std_algorithm_searching.html#maxElement"><code>std.algorithm.searching.maxElement</code></a> for examples on how to cope with NaNs. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<code>Exception</code> if <code>range.empty</code>. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="std_algorithm_comparison.html#min"><code>std.algorithm.comparison.min</code></a>, <a href="#minIndex"><code>minIndex</code></a>, <a href="#minElement"><code>minElement</code></a>, <a href="#minPos"><code>minPos</code></a>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.conv : text;
import std.typecons : tuple;

int[] a = [ 2, 3, 4, 1, 2, 4, 1, 1, 2 ];
// Minimum is 1 and occurs 3 times
writeln(a.minCount); // tuple(1, 3)
// Maximum is 4 and occurs 2 times
writeln(a.maxCount); // tuple(4, 2)
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="minElement">auto <strong id="minElement">minElement</strong>(alias map = (a) =&gt; a, Range)(Range r)<br><small>  Constraints: if (isInputRange!Range &amp;&amp; !isInfinite!Range); </small><br><br>auto <strong id="minElement">minElement</strong>(alias map = (a) =&gt; a, Range, RangeElementType = ElementType!Range)(Range r, RangeElementType seed)<br><small>  Constraints: if (isInputRange!Range &amp;&amp; !isInfinite!Range &amp;&amp; !is(CommonType!(ElementType!Range, RangeElementType) == void)); </small>
</dt> <dd>
<p>Iterates the passed range and returns the minimal element. A custom mapping function can be passed to <code>map</code>. In other languages this is sometimes called <code>argmin</code>. </p>
<dl>
<dt>Complexity</dt>
<dd> O(n) Exactly <code>n - 1</code> comparisons are needed. </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>map</td> <td>custom accessor for the comparison key</td>
</tr> <tr>
<td>Range <code>r</code>
</td> <td>range from which the minimal element will be selected</td>
</tr> <tr>
<td>RangeElementType <code>seed</code>
</td> <td>custom seed to use as initial element</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The minimal element of the passed-in range. </dd>
</dl> <dl>
<dt>Note</dt>
<dd> If at least one of the arguments is NaN, the result is an unspecified value. </dd>
</dl> If you want to ignore NaNs, you can use <a href="std_algorithm_iteration.html#filter"><code>std.algorithm.iteration.filter</code></a> and <a href="std_math.html#isNaN"><code>std.math.isNaN</code></a> to remove them, before applying minElement. Add a suitable seed, to avoid error messages if all elements are NaNs:  <pre data-language="d">&lt;range&gt;.filter!(a=&gt;!a.isNaN).minElement(&lt;seed&gt;);
</pre>  If you want to get NaN as a result if a NaN is present in the range, you can use <a href="std_algorithm_iteration.html#fold"><code>std.algorithm.iteration.fold</code></a> and <a href="std_math.html#isNaN"><code>std.math.isNaN</code></a>:  <pre data-language="d">&lt;range&gt;.fold!((a,b)=&gt;a.isNaN || b.isNaN ? real.nan : a &lt; b ? a : b);
</pre>  <dl>
<dt>See Also:</dt>
<dd>
<a href="#maxElement"><code>maxElement</code></a>, <a href="std_algorithm_comparison.html#min"><code>std.algorithm.comparison.min</code></a>, <a href="#minCount"><code>minCount</code></a>, <a href="#minIndex"><code>minIndex</code></a>, <a href="#minPos"><code>minPos</code></a>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.range : enumerate;
import std.typecons : tuple;

writeln([2, 7, 1, 3].minElement); // 1

// allows to get the index of an element too
writeln([5, 3, 7, 9].enumerate.minElement!"a.value"); // tuple(1, 3)

// any custom accessor can be passed
writeln([[0, 4], [1, 2]].minElement!"a[1]"); // [1, 2]

// can be seeded
int[] arr;
writeln(arr.minElement(1)); // 1
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="maxElement">auto <strong id="maxElement">maxElement</strong>(alias map = (a) =&gt; a, Range)(Range r)<br><small>  Constraints: if (isInputRange!Range &amp;&amp; !isInfinite!Range); </small><br><br>auto <strong id="maxElement">maxElement</strong>(alias map = (a) =&gt; a, Range, RangeElementType = ElementType!Range)(Range r, RangeElementType seed)<br><small>  Constraints: if (isInputRange!Range &amp;&amp; !isInfinite!Range &amp;&amp; !is(CommonType!(ElementType!Range, RangeElementType) == void)); </small>
</dt> <dd>
<p>Iterates the passed range and returns the maximal element. A custom mapping function can be passed to <code>map</code>. In other languages this is sometimes called <code>argmax</code>. </p>
<dl>
<dt>Complexity</dt>
<dd> O(n) Exactly <code>n - 1</code> comparisons are needed. </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>map</td> <td>custom accessor for the comparison key</td>
</tr> <tr>
<td>Range <code>r</code>
</td> <td>range from which the maximum element will be selected</td>
</tr> <tr>
<td>RangeElementType <code>seed</code>
</td> <td>custom seed to use as initial element</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The maximal element of the passed-in range. </dd>
</dl> <dl>
<dt>Note</dt>
<dd> If at least one of the arguments is NaN, the result is an unspecified value. See <a href="std_algorithm_searching.html#minElement"><code>std.algorithm.searching.minElement</code></a> for examples on how to cope with NaNs. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="#minElement"><code>minElement</code></a>, <a href="std_algorithm_comparison.html#max"><code>std.algorithm.comparison.max</code></a>, <a href="#maxCount"><code>maxCount</code></a>, <a href="#maxIndex"><code>maxIndex</code></a>, <a href="#maxPos"><code>maxPos</code></a>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.range : enumerate;
import std.typecons : tuple;
writeln([2, 1, 4, 3].maxElement); // 4

// allows to get the index of an element too
writeln([2, 1, 4, 3].enumerate.maxElement!"a.value"); // tuple(2, 4)

// any custom accessor can be passed
writeln([[0, 4], [1, 2]].maxElement!"a[1]"); // [0, 4]

// can be seeded
int[] arr;
writeln(arr.minElement(1)); // 1
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="minPos">Range <strong id="minPos">minPos</strong>(alias pred = "a &lt; b", Range)(Range range)<br><small>  Constraints: if (isForwardRange!Range &amp;&amp; !isInfinite!Range &amp;&amp; is(typeof(binaryFun!pred(range.front, range.front)))); </small><br><br>Range <strong id="maxPos">maxPos</strong>(alias pred = "a &lt; b", Range)(Range range)<br><small>  Constraints: if (isForwardRange!Range &amp;&amp; !isInfinite!Range &amp;&amp; is(typeof(binaryFun!pred(range.front, range.front)))); </small>
</dt> <dd>
<p>Computes a subrange of <code>range</code> starting at the first occurrence of <code>range</code>'s minimum (respectively maximum) and with the same ending as <code>range</code>, or the empty range if <code>range</code> itself is empty. </p>
<p>Formally, the minimum is a value <code>x</code> in <code>range</code> such that <code>pred(a, x)</code> is <code>false</code> for all values <code>a</code> in <code>range</code>. Conversely, the maximum is a value <code>x</code> in <code>range</code> such that <code>pred(x, a)</code> is <code>false</code> for all values <code>a</code> in <code>range</code> (note the swapped arguments to <code>pred</code>). <br><br> These functions may be used for computing arbitrary extrema by choosing <code>pred</code> appropriately. For corrrect functioning, <code>pred</code> must be a strict partial order, i.e. transitive (if <code>pred(a, b) &amp;&amp; pred(b, c)</code> then <code>pred(a, c)</code>) and irreflexive (<code>pred(a, a)</code> is <code>false</code>). </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>pred</td> <td>The ordering predicate to use to determine the extremum (minimum or maximum) element.</td>
</tr> <tr>
<td>Range <code>range</code>
</td> <td>The <a href="std_range_primitives.html#isForwardRange">forward range</a> to search.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The position of the minimum (respectively maximum) element of forward range <code>range</code>, i.e. a subrange of <code>range</code> starting at the position of its smallest (respectively largest) element and with the same ending as <code>range</code>. </dd>
</dl> <dl>
<dt>Limitations</dt>
<dd> If at least one of the arguments is NaN, the result is an unspecified value. See <a href="std_algorithm_searching.html#maxElement"><code>std.algorithm.searching.maxElement</code></a> for examples on how to cope with NaNs. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="std_algorithm_comparison.html#max"><code>std.algorithm.comparison.max</code></a>, <a href="#minCount"><code>minCount</code></a>, <a href="#minIndex"><code>minIndex</code></a>, <a href="#minElement"><code>minElement</code></a>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int[] a = [ 2, 3, 4, 1, 2, 4, 1, 1, 2 ];
// Minimum is 1 and first occurs in position 3
writeln(a.minPos); // [1, 2, 4, 1, 1, 2]
// Maximum is 4 and first occurs in position 2
writeln(a.maxPos); // [4, 1, 2, 4, 1, 1, 2]
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="minIndex">ptrdiff_t <strong id="minIndex">minIndex</strong>(alias pred = "a &lt; b", Range)(Range range)<br><small>  Constraints: if (isInputRange!Range &amp;&amp; !isInfinite!Range &amp;&amp; is(typeof(binaryFun!pred(range.front, range.front)))); </small>
</dt> <dd>
<p>Computes the index of the first occurrence of <code>range</code>'s minimum element. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>pred</td> <td>The ordering predicate to use to determine the minimum element.</td>
</tr> <tr>
<td>Range <code>range</code>
</td> <td>The <a href="std_range_primitives.html#isInputRange">input range</a> to search.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Complexity</dt>
<dd> <span class="bigoh">Ο(<code>range.length</code>)</span> Exactly <code>range.length - 1</code> comparisons are needed. </dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The index of the first encounter of the minimum element in <code>range</code>. If the <code>range</code> is empty, -1 is returned. </dd>
</dl> <dl>
<dt>Limitations</dt>
<dd> If at least one of the arguments is NaN, the result is an unspecified value. See <a href="std_algorithm_searching.html#maxElement"><code>std.algorithm.searching.maxElement</code></a> for examples on how to cope with NaNs. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="#maxIndex"><code>maxIndex</code></a>, <a href="std_algorithm_comparison.html#min"><code>std.algorithm.comparison.min</code></a>, <a href="#minCount"><code>minCount</code></a>, <a href="#minElement"><code>minElement</code></a>, <a href="#minPos"><code>minPos</code></a>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int[] a = [2, 3, 4, 1, 2, 4, 1, 1, 2];

// Minimum is 1 and first occurs in position 3
writeln(a.minIndex); // 3
// Get maximum index with minIndex
writeln(a.minIndex!"a &gt; b"); // 2

// Range is empty, so return value is -1
int[] b;
writeln(b.minIndex); // -1

// Works with more custom types
struct Dog { int age; }
Dog[] dogs = [Dog(10), Dog(5), Dog(15)];
writeln(dogs.minIndex!"a.age &lt; b.age"); // 1
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="maxIndex">ptrdiff_t <strong id="maxIndex">maxIndex</strong>(alias pred = "a &lt; b", Range)(Range range)<br><small>  Constraints: if (isInputRange!Range &amp;&amp; !isInfinite!Range &amp;&amp; is(typeof(binaryFun!pred(range.front, range.front)))); </small>
</dt> <dd>
<p>Computes the index of the first occurrence of <code>range</code>'s maximum element. </p>
<dl>
<dt>Complexity</dt>
<dd> <span class="bigoh">Ο(<code>range</code>)</span> Exactly <code>range.length - 1</code> comparisons are needed. </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>pred</td> <td>The ordering predicate to use to determine the maximum element.</td>
</tr> <tr>
<td>Range <code>range</code>
</td> <td>The <a href="std_range_primitives.html#isInputRange">input range</a> to search.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The index of the first encounter of the maximum in <code>range</code>. If the <code>range</code> is empty, -1 is returned. </dd>
</dl> <dl>
<dt>Limitations</dt>
<dd> If at least one of the arguments is NaN, the result is an unspecified value. See <a href="std_algorithm_searching.html#maxElement"><code>std.algorithm.searching.maxElement</code></a> for examples on how to cope with NaNs. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="#minIndex"><code>minIndex</code></a>, <a href="std_algorithm_comparison.html#max"><code>std.algorithm.comparison.max</code></a>, <a href="#maxCount"><code>maxCount</code></a>, <a href="#maxElement"><code>maxElement</code></a>, <a href="#maxPos"><code>maxPos</code></a>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">// Maximum is 4 and first occurs in position 2
int[] a = [2, 3, 4, 1, 2, 4, 1, 1, 2];
writeln(a.maxIndex); // 2

// Empty range
int[] b;
writeln(b.maxIndex); // -1

// Works with more custom types
struct Dog { int age; }
Dog[] dogs = [Dog(10), Dog(15), Dog(5)];
writeln(dogs.maxIndex!"a.age &lt; b.age"); // 1
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="skipOver">template <strong id="skipOver">skipOver</strong>(alias pred = (a, b) =&gt; a == b)</dt> <dd>
<p>Skip over the initial portion of the first given range (<code>haystack</code>) that matches any of the additionally given ranges (<code>needles</code>) fully, or if no second range is given skip over the elements that fulfill pred. Do nothing if there is no match. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>pred</td> <td>The predicate that determines whether elements from each respective range match. Defaults to equality <code>"a == b"</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;

auto s1 = "Hello world";
assert(!skipOver(s1, "Ha"));
writeln(s1); // "Hello world"
assert(skipOver(s1, "Hell") &amp;&amp; s1 == "o world", s1);

string[]  r1 = ["abc", "def", "hij"];
dstring[] r2 = ["abc"d];
assert(!skipOver!((a, b) =&gt; a.equal(b))(r1, ["def"d]), r1[0]);
writeln(r1); // ["abc", "def", "hij"]
assert(skipOver!((a, b) =&gt; a.equal(b))(r1, r2));
writeln(r1); // ["def", "hij"]
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.ascii : isWhite;
import std.range.primitives : empty;

auto s2 = "\t\tvalue";
auto s3 = "";
auto s4 = "\t\t\t";
assert(s2.skipOver!isWhite &amp;&amp; s2 == "value");
assert(!s3.skipOver!isWhite);
assert(s4.skipOver!isWhite &amp;&amp; s3.empty);
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Variadic skipOver <pre data-language="d">auto s = "Hello world";
assert(!skipOver(s, "hello", "HellO"));
writeln(s); // "Hello world"

// the range is skipped over the longest matching needle is skipped
assert(skipOver(s, "foo", "hell", "Hello "));
writeln(s); // "world"
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;

auto s1 = "Hello world";
assert(!skipOver(s1, 'a'));
writeln(s1); // "Hello world"
assert(skipOver(s1, 'H') &amp;&amp; s1 == "ello world");

string[] r = ["abc", "def", "hij"];
dstring e = "abc"d;
assert(!skipOver!((a, b) =&gt; a.equal(b))(r, "def"d));
writeln(r); // ["abc", "def", "hij"]
assert(skipOver!((a, b) =&gt; a.equal(b))(r, e));
writeln(r); // ["def", "hij"]

auto s2 = "";
assert(!s2.skipOver('a'));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Partial instantiation <pre data-language="d">import std.ascii : isWhite;
import std.range.primitives : empty;

alias whitespaceSkiper = skipOver!isWhite;

auto s2 = "\t\tvalue";
auto s3 = "";
auto s4 = "\t\t\t";
assert(whitespaceSkiper(s2) &amp;&amp; s2 == "value");
assert(!whitespaceSkiper(s2));
assert(whitespaceSkiper(s4) &amp;&amp; s3.empty);
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="skipOver.skipOver">bool <strong id="skipOver">skipOver</strong>(Haystack, Needles...)(ref Haystack haystack, Needles needles)<br><small>  Constraints: if (is(typeof(binaryFun!pred(haystack.front, needles[0].front))) &amp;&amp; isForwardRange!Haystack &amp;&amp; allSatisfy!(isInputRange, Needles) &amp;&amp; !is(CommonType!(staticMap!(ElementType, staticMap!(Unqual, Needles))) == void)); </small><br><br>bool <strong id="skipOver">skipOver</strong>(R)(ref R r1)<br><small>  Constraints: if (isForwardRange!R &amp;&amp; ifTestable!(typeof(r1.front), unaryFun!pred)); </small><br><br>bool <strong id="skipOver">skipOver</strong>(R, Es...)(ref R r, Es es)<br><small>  Constraints: if (isInputRange!R &amp;&amp; is(typeof(binaryFun!pred(r.front, es[0])))); </small>
</dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Haystack <code>haystack</code>
</td> <td>The <a href="std_range_primitives.html#isForwardRange">forward range</a> to move forward.</td>
</tr> <tr>
<td>Needles <code>needles</code>
</td> <td>The <a href="std_range_primitives.html#isInputRange">input ranges</a> representing the prefix of <code>r1</code> to skip over.</td>
</tr> <tr>
<td>Es <code>es</code>
</td> <td>The element to match.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if the prefix of <code>haystack</code> matches any range of <code>needles</code> fully or <code>pred</code> evaluates to true, and <code>haystack</code> has been advanced to the point past this segment; otherwise false, and <code>haystack</code> is left in its original position. </dd>
</dl> <dl>
<dt>Note</dt>
<dd> By definition, empty ranges are matched fully and if <code>needles</code> contains an empty range, <code>skipOver</code> will return <code>true</code>.</dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="startsWith">uint <strong id="startsWith">startsWith</strong>(alias pred = (a, b) =&gt; a == b, Range, Needles...)(Range doesThisStart, Needles withOneOfThese)<br><small>  Constraints: if (isInputRange!Range &amp;&amp; (Needles.length &gt; 1) &amp;&amp; is(typeof(.startsWith!pred(doesThisStart, withOneOfThese[0])) : bool) &amp;&amp; is(typeof(.startsWith!pred(doesThisStart, withOneOfThese[1..$])) : uint)); </small><br><br>bool <strong id="startsWith">startsWith</strong>(alias pred = "a == b", R1, R2)(R1 doesThisStart, R2 withThis)<br><small>  Constraints: if (isInputRange!R1 &amp;&amp; isInputRange!R2 &amp;&amp; is(typeof(binaryFun!pred(doesThisStart.front, withThis.front)) : bool)); </small><br><br>bool <strong id="startsWith">startsWith</strong>(alias pred = "a == b", R, E)(R doesThisStart, E withThis)<br><small>  Constraints: if (isInputRange!R &amp;&amp; is(typeof(binaryFun!pred(doesThisStart.front, withThis)) : bool)); </small><br><br>bool <strong id="startsWith">startsWith</strong>(alias pred, R)(R doesThisStart)<br><small>  Constraints: if (isInputRange!R &amp;&amp; ifTestable!(typeof(doesThisStart.front), unaryFun!pred)); </small>
</dt> <dd>
<p>Checks whether the given <a href="std_range_primitives.html#isInputRange">input range</a> starts with (one of) the given needle(s) or, if no needles are given, if its front element fulfils predicate <code>pred</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>pred</td> <td>Predicate to use in comparing the elements of the haystack and the needle(s). Mandatory if no needles are given.</td>
</tr> <tr>
<td>Range <code>doesThisStart</code>
</td> <td>The input range to check.</td>
</tr> <tr>
<td>Needles <code>withOneOfThese</code>
</td> <td>The needles against which the range is to be checked, which may be individual elements or input ranges of elements.</td>
</tr> <tr>
<td>R2 <code>withThis</code>
</td> <td>The single needle to check, which may be either a single element or an input range of elements.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>0 if the needle(s) do not occur at the beginning of the given range; otherwise the position of the matching needle, that is, 1 if the range starts with <code>withOneOfThese[0]</code>, 2 if it starts with <code>withOneOfThese[1]</code>, and so on.  In the case where <code>doesThisStart</code> starts with multiple of the ranges or elements in <code>withOneOfThese</code>, then the shortest one matches (if there are two which match which are of the same length (e.g. <code>"a"</code> and <code>'a'</code>), then the left-most of them in the argument list matches).  In the case when no needle parameters are given, return <code>true</code> iff front of <code>doesThisStart</code> fulfils predicate <code>pred</code>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.ascii : isAlpha;

assert("abc".startsWith!(a =&gt; a.isAlpha));
assert("abc".startsWith!isAlpha);
assert(!"1ab".startsWith!(a =&gt; a.isAlpha));
assert(!"".startsWith!(a =&gt; a.isAlpha));

import std.algorithm.comparison : among;
assert("abc".startsWith!(a =&gt; a.among('a', 'b') != 0));
assert(!"abc".startsWith!(a =&gt; a.among('b', 'c') != 0));

assert(startsWith("abc", ""));
assert(startsWith("abc", "a"));
assert(!startsWith("abc", "b"));
writeln(startsWith("abc", 'a', "b")); // 1
writeln(startsWith("abc", "b", "a")); // 2
writeln(startsWith("abc", "a", "a")); // 1
writeln(startsWith("abc", "ab", "a")); // 2
writeln(startsWith("abc", "x", "a", "b")); // 2
writeln(startsWith("abc", "x", "aa", "ab")); // 3
writeln(startsWith("abc", "x", "aaa", "sab")); // 0
writeln(startsWith("abc", "x", "aaa", "a", "sab")); // 3

import std.typecons : Tuple;
alias C = Tuple!(int, "x", int, "y");
assert(startsWith!"a.x == b"([ C(1,1), C(1,2), C(2,2) ], [1, 1]));
writeln(startsWith!"a.x == b"([C(1, 1), C(2, 1), C(2, 2)], [1, 1], [1, 2], [1, 3])); // 2
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="OpenRight">alias <strong id="OpenRight">OpenRight</strong> = std.typecons.Flag!"openRight".Flag; </dt> <dd>
<p>Interval option specifier for <code>until</code> (below) and others. </p>
<p>If set to <code>OpenRight.yes</code>, then the interval is open to the right (last element is not included). <br><br> Otherwise if set to <code>OpenRight.no</code>, then the interval is closed to the right (last element included).</p> </dd> <dt class="d_decl" id="until">Until!(pred, Range, Sentinel) <strong id="until">until</strong>(alias pred = "a == b", Range, Sentinel)(Range range, Sentinel sentinel, OpenRight openRight = Yes.openRight)<br><small>  Constraints: if (!is(Sentinel == OpenRight)); </small><br><br>Until!(pred, Range, void) <strong id="until">until</strong>(alias pred, Range)(Range range, OpenRight openRight = Yes.openRight); <br><br>struct <strong id="Until">Until</strong>(alias pred, Range, Sentinel) if (isInputRange!Range); </dt> <dd>
<p>Lazily iterates <code>range</code> until the element <code>e</code> for which <code>pred(e, sentinel)</code> is true. </p>
<p>This is similar to <code>takeWhile</code> in other languages. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>pred</td> <td>Predicate to determine when to stop.</td>
</tr> <tr>
<td>Range <code>range</code>
</td> <td>The <a href="std_range_primitives.html#isInputRange">input range</a> to iterate over.</td>
</tr> <tr>
<td>Sentinel <code>sentinel</code>
</td> <td>The element to stop at.</td>
</tr> <tr>
<td>OpenRight <code>openRight</code>
</td> <td>Determines whether the element for which the given predicate is true should be included in the resulting range (<code>No.openRight</code>), or not (<code>Yes.openRight</code>).</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>An <a href="std_range_primitives.html#isInputRange">input range</a> that iterates over the original range's elements, but ends when the specified predicate becomes true. If the original range is a <a href="std_range_primitives.html#isForwardRange">forward range</a> or higher, this range will be a forward range.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.typecons : No;
int[] a = [ 1, 2, 4, 7, 7, 2, 4, 7, 3, 5];
assert(equal(a.until(7), [1, 2, 4]));
assert(equal(a.until(7, No.openRight), [1, 2, 4, 7]));
</pre> </dd>
</dl> </dd> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1999&ndash;2021 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/std_algorithm_searching.html" class="_attribution-link">https://dlang.org/phobos/std_algorithm_searching.html</a>
  </p>
</div>
