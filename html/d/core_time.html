<h1>core.time</h1>  <p>Module containing core time functionality, such as <a href="#Duration"><code>Duration</code></a> (which represents a duration of time) or <a href="#MonoTime"><code>MonoTime</code></a> (which represents a timestamp of the system's monotonic clock). </p>
<p>Various functions take a string (or strings) to represent a unit of time (e.g. <code>convert!("days", "hours")(numDays)</code>). The valid strings to use with such functions are "years", "months", "weeks", "days", "hours", "minutes", "seconds", "msecs" (milliseconds), "usecs" (microseconds), "hnsecs" (hecto-nanoseconds - i.e. 100 ns) or some subset thereof. There are a few functions that also allow "nsecs", but very little actually has precision greater than hnsecs. <br><br> <table>
<caption>Cheat Sheet</caption> <tr>
<th scope="col">Symbol</th> <th scope="col">Description</th>
</tr> <tr><td colspan="2"><em> Types</em></td></tr> <tr>
<td><a href="#Duration"><code>Duration</code></a></td> <td>Represents a duration of time of weeks or less (kept internally as hnsecs). (e.g. 22 days or 700 seconds).</td>
</tr> <tr>
<td><a href="#TickDuration"><code>TickDuration</code></a></td> <td>Represents a duration of time in system clock ticks, using the highest precision that the system provides.</td>
</tr> <tr>
<td><a href="#MonoTime"><code>MonoTime</code></a></td> <td>Represents a monotonic timestamp in system clock ticks, using the highest precision that the system provides.</td>
</tr> <tr><td colspan="2"><em> Functions</em></td></tr> <tr>
<td><a href="#convert"><code>convert</code></a></td> <td>Generic way of converting between two time units.</td>
</tr> <tr>
<td><a href="#dur"><code>dur</code></a></td> <td>Allows constructing a <a href="#Duration"><code>Duration</code></a> from the given time units with the given length.</td>
</tr> <tr>
<td>
<a href="#weeks"><code>weeks</code></a> <a href="#days"><code>days</code></a> <a href="#hours"><code>hours</code></a><br> <a href="#minutes"><code>minutes</code></a> <a href="#seconds"><code>seconds</code></a> <a href="#msecs"><code>msecs</code></a><br> <a href="#usecs"><code>usecs</code></a> <a href="#hnsecs"><code>hnsecs</code></a> <a href="#nsecs"><code>nsecs</code></a>
</td> <td>Convenience aliases for <a href="#dur"><code>dur</code></a>.</td>
</tr> <tr>
<td><a href="#abs"><code>abs</code></a></td> <td>Returns the absolute value of a duration.</td>
</tr> </table> <br><br> <table>
<caption>Conversions</caption> <tr>
<th scope="col"></th> <th scope="col">From <a href="#Duration"><code>Duration</code></a>
</th> <th scope="col">From <a href="#TickDuration"><code>TickDuration</code></a>
</th> <th scope="col">From units</th> </tr> <tr>
<td>To <a href="#Duration"><code>Duration</code></a>
</td> <td>-</td> <td>
<code>tickDuration.</code><a href="std_conv.html#to"><code>to</code></a><code>!Duration()</code>
</td> <td>
<code>dur!"msecs"(5)</code> or <code>5.msecs()</code>
</td> </tr> <tr>
<td>To <a href="#TickDuration"><code>TickDuration</code></a>
</td> <td>
<code>duration.</code><a href="std_conv.html#to"><code>to</code></a><code>!TickDuration()</code>
</td> <td>-</td> <td><code>TickDuration.from!"msecs"(msecs)</code></td> </tr> <tr>
<td>To units</td> <td><code>duration.total!"days"</code></td> <td><code>tickDuration.msecs</code></td> <td><code>convert!("days", "msecs")(msecs)</code></td> </tr>
</table> </p> <dl>
<dt>License:</dt>
<dd>
<a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>. </dd>
</dl> <dl>
<dt>Authors:</dt>
<dd>
<a href="http://jmdavisprog.com">Jonathan M Davis</a> and Kato Shoichi </dd>
</dl> <dl>
<dt>Source</dt>
<dd> <a href="https://github.com/dlang/druntime/blob/master/src/core/time.d">core/time.d</a> </dd>
</dl> <dl>
<dt class="d_decl" id="ClockType">enum <strong id="ClockType">ClockType</strong>: int; </dt> <dd>
<p>What type of clock to use with <a href="#MonoTime"><code>MonoTime</code></a> / <a href="#MonoTimeImpl"><code>MonoTimeImpl</code></a> or <code>std.datetime.Clock.currTime</code>. They default to <code>ClockType.normal</code>, and most programs do not need to ever deal with the others. </p>
<p>The other <code>ClockType</code>s are provided so that other clocks provided by the underlying C, system calls can be used with <a href="#MonoTimeImpl"><code>MonoTimeImpl</code></a> or <code>std.datetime.Clock.currTime</code> without having to use the C API directly. <br><br> In the case of the monotonic time, <a href="#MonoTimeImpl"><code>MonoTimeImpl</code></a> is templatized on <code>ClockType</code>, whereas with <code>std.datetime.Clock.currTime</code>, its a runtime argument, since in the case of the monotonic time, the type of the clock affects the resolution of a <a href="#MonoTimeImpl"><code>MonoTimeImpl</code></a> object, whereas with <a href="std_datetime.html#SysTime"><code>std.datetime.SysTime</code></a>, its resolution is always hecto-nanoseconds regardless of the source of the time. <br><br> <code>ClockType.normal</code>, <code>ClockType.coarse</code>, and <code>ClockType.precise</code> work with both <code>Clock.currTime</code> and <a href="#MonoTimeImpl"><code>MonoTimeImpl</code></a>. <code>ClockType.second</code> only works with <code>Clock.currTime</code>. The others only work with <a href="#MonoTimeImpl"><code>MonoTimeImpl</code></a>.</p> <dl>
<dt class="d_decl" id="ClockType.normal"><strong id="normal">normal</strong></dt> <dd>
<p>Use the normal clock.</p> </dd> <dt class="d_decl" id="ClockType.bootTime"><strong id="bootTime">bootTime</strong></dt> <dd>
<p><span class="blue">Linux,OpenBSD-Only</span> </p>
<p>Uses <code>CLOCK_BOOTTIME</code>.</p> </dd> <dt class="d_decl" id="ClockType.coarse"><strong id="coarse">coarse</strong></dt> <dd>
<p>Use the coarse clock, not the normal one (e.g. on Linux, that would be <code>CLOCK_REALTIME_COARSE</code> instead of <code>CLOCK_REALTIME</code> for <code>clock_gettime</code> if a function is using the realtime clock). It's generally faster to get the time with the coarse clock than the normal clock, but it's less precise (e.g. 1 msec instead of 1 usec or 1 nsec). Howeover, it <i>is</i> guaranteed to still have sub-second precision (just not as high as with <code>ClockType.normal</code>). </p>
<p>On systems which do not support a coarser clock, <code>MonoTimeImpl!(ClockType.coarse)</code> will internally use the same clock as <code>Monotime</code> does, and <code>Clock.currTime!(ClockType.coarse)</code> will use the same clock as <code>Clock.currTime</code>. This is because the coarse clock is doing the same thing as the normal clock (just at lower precision), whereas some of the other clock types (e.g. <code>ClockType.processCPUTime</code>) mean something fundamentally different. So, treating those as <code>ClockType.normal</code> on systems where they weren't natively supported would give misleading results. <br><br> Most programs should not use the coarse clock, exactly because it's less precise, and most programs don't need to get the time often enough to care, but for those rare programs that need to get the time extremely frequently (e.g. hundreds of thousands of times a second) but don't care about high precision, the coarse clock might be appropriate. <br><br> Currently, only Linux and FreeBSD/DragonFlyBSD support a coarser clock, and on other platforms, it's treated as <code>ClockType.normal</code>.</p> </dd> <dt class="d_decl" id="ClockType.precise"><strong id="precise">precise</strong></dt> <dd>
<p>Uses a more precise clock than the normal one (which is already very precise), but it takes longer to get the time. Similarly to <code>ClockType.coarse</code>, if it's used on a system that does not support a more precise clock than the normal one, it's treated as equivalent to <code>ClockType.normal</code>. </p>
<p>Currently, only FreeBSD/DragonFlyBSD supports a more precise clock, where it uses <code>CLOCK_MONOTONIC_PRECISE</code> for the monotonic time and <code>CLOCK_REALTIME_PRECISE</code> for the wall clock time.</p> </dd> <dt class="d_decl" id="ClockType.processCPUTime"><strong id="processCPUTime">processCPUTime</strong></dt> <dd>
<p><span class="blue">Linux,OpenBSD,Solaris-Only</span> </p>
<p>Uses <code>CLOCK_PROCESS_CPUTIME_ID</code>.</p> </dd> <dt class="d_decl" id="ClockType.raw"><strong id="raw">raw</strong></dt> <dd>
<p><span class="blue">Linux-Only</span> </p>
<p>Uses <code>CLOCK_MONOTONIC_RAW</code>.</p> </dd> <dt class="d_decl" id="ClockType.second"><strong id="second">second</strong></dt> <dd>
<p>Uses a clock that has a precision of one second (contrast to the coarse clock, which has sub-second precision like the normal clock does). </p>
<p>FreeBSD/DragonFlyBSD are the only systems which specifically have a clock set up for this (it has <code>CLOCK_SECOND</code> to use with <code>clock_gettime</code> which takes advantage of an in-kernel cached value), but on other systems, the fastest function available will be used, and the resulting <code>SysTime</code> will be rounded down to the second if the clock that was used gave the time at a more precise resolution. So, it's guaranteed that the time will be given at a precision of one second and it's likely the case that will be faster than <code>ClockType.normal</code>, since there tend to be several options on a system to get the time at low resolutions, and they tend to be faster than getting the time at high resolutions. <br><br> So, the primary difference between <code>ClockType.coarse</code> and <code>ClockType.second</code> is that <code>ClockType.coarse</code> sacrifices some precision in order to get speed but is still fairly precise, whereas <code>ClockType.second</code> tries to be as fast as possible at the expense of all sub-second precision.</p> </dd> <dt class="d_decl" id="ClockType.threadCPUTime"><strong id="threadCPUTime">threadCPUTime</strong></dt> <dd>
<p><span class="blue">Linux,OpenBSD,Solaris-Only</span> </p>
<p>Uses <code>CLOCK_THREAD_CPUTIME_ID</code>.</p> </dd> <dt class="d_decl" id="ClockType.uptime"><strong id="uptime">uptime</strong></dt> <dd>
<p><span class="blue">DragonFlyBSD,FreeBSD,OpenBSD-Only</span> </p>
<p>Uses <code>CLOCK_UPTIME</code>.</p> </dd> <dt class="d_decl" id="ClockType.uptimeCoarse"><strong id="uptimeCoarse">uptimeCoarse</strong></dt> <dd>
<p><span class="blue">FreeBSD-Only</span> </p>
<p>Uses <code>CLOCK_UPTIME_FAST</code>.</p> </dd> <dt class="d_decl" id="ClockType.uptimePrecise"><strong id="uptimePrecise">uptimePrecise</strong></dt> <dd>
<p><span class="blue">FreeBSD-Only</span> </p>
<p>Uses <code>CLOCK_UPTIME_PRECISE</code>.</p> </dd> </dl> </dd> <dt class="d_decl" id="Duration">struct <strong id="Duration">Duration</strong>; </dt> <dd>
<p>Represents a duration of time of weeks or less (kept internally as hnsecs). (e.g. 22 days or 700 seconds). </p>
<p>It is used when representing a duration of time - such as how long to sleep with <a href="core_thread.html#Thread.sleep"><code>core.thread.Thread.sleep</code></a>. <br><br> In std.datetime, it is also used as the result of various arithmetic operations on time points. <br><br> Use the <a href="#dur"><code>dur</code></a> function or one of its non-generic aliases to create <code>Duration</code>s. <br><br> It's not possible to create a Duration of months or years, because the variable number of days in a month or year makes it impossible to convert between months or years and smaller units without a specific date. So, nothing uses <code>Duration</code>s when dealing with months or years. Rather, functions specific to months and years are defined. For instance, <a href="std_datetime.html#Date"><code>std.datetime.Date</code></a> has <code>add!"years"</code> and <code>add!"months"</code> for adding years and months rather than creating a Duration of years or months and adding that to a <a href="std_datetime.html#Date"><code>std.datetime.Date</code></a>. But Duration is used when dealing with weeks or smaller. </p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.datetime;

assert(dur!"days"(12) == dur!"hnsecs"(10_368_000_000_000L));
assert(dur!"hnsecs"(27) == dur!"hnsecs"(27));
assert(std.datetime.Date(2010, 9, 7) + dur!"days"(5) ==
       std.datetime.Date(2010, 9, 12));

assert(days(-12) == dur!"hnsecs"(-10_368_000_000_000L));
assert(hnsecs(-27) == dur!"hnsecs"(-27));
assert(std.datetime.Date(2010, 9, 7) - std.datetime.Date(2010, 10, 3) ==
       days(-26));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import core.time;

// using the dur template
auto numDays = dur!"days"(12);

// using the days function
numDays = days(12);

// alternatively using UFCS syntax
numDays = 12.days;

auto myTime = 100.msecs + 20_000.usecs + 30_000.hnsecs;
assert(myTime == 123.msecs);
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="Duration.zero">static pure nothrow @nogc @property @safe Duration <strong id="zero">zero</strong>(); </dt> <dd>
<p>A <code>Duration</code> of <code>0</code>. It's shorter than doing something like <code>dur!"seconds"(0)</code> and more explicit than <code>Duration.init</code>.</p> </dd> <dt class="d_decl" id="Duration.max">static pure nothrow @nogc @property @safe Duration <strong id="max">max</strong>(); </dt> <dd>
<p>Largest <code>Duration</code> possible.</p> </dd> <dt class="d_decl" id="Duration.min">static pure nothrow @nogc @property @safe Duration <strong id="min">min</strong>(); </dt> <dd>
<p>Most negative <code>Duration</code> possible.</p> </dd> <dt class="d_decl" id="Duration.opCmp">const pure nothrow @nogc @safe int <strong id="opCmp">opCmp</strong>(Duration rhs); </dt> <dd>
<p>Compares this <code>Duration</code> with the given <code>Duration</code>. </p>
<dl>
<dt>Returns:</dt>
<dd><table>

<tr>
<td>this &lt; rhs</td> <td>&lt; 0</td>
</tr> <tr>
<td>this == rhs</td> <td>0</td>
</tr> <tr>
<td>this &gt; rhs</td> <td>&gt; 0</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="Duration.opBinary">const nothrow @nogc Duration <strong id="opBinary">opBinary</strong>(string op, D)(D rhs)<br><small>  Constraints: if ((op == "+" || op == "-" || op == "%") &amp;&amp; is(immutable(D) == immutable(Duration)) || (op == "+" || op == "-") &amp;&amp; is(immutable(D) == immutable(TickDuration))); </small>
</dt> <dd>
<p>Adds, subtracts or calculates the modulo of two durations. </p>
<p>The legal types of arithmetic for <code>Duration</code> using this operator are <br><br> <table>

<tr>
<td>Duration</td> <td>+</td> <td>Duration</td> <td>--&gt;</td> <td>Duration</td>
</tr> <tr>
<td>Duration</td> <td>-</td> <td>Duration</td> <td>--&gt;</td> <td>Duration</td>
</tr> <tr>
<td>Duration</td> <td>%</td> <td>Duration</td> <td>--&gt;</td> <td>Duration</td>
</tr> <tr>
<td>Duration</td> <td>+</td> <td>TickDuration</td> <td>--&gt;</td> <td>Duration</td>
</tr> <tr>
<td>Duration</td> <td>-</td> <td>TickDuration</td> <td>--&gt;</td> <td>Duration</td>
</tr> </table> </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>D <code>rhs</code>
</td> <td>The duration to add to or subtract from this <code>Duration</code>.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="Duration.opBinaryRight">const nothrow @nogc Duration <strong id="opBinaryRight">opBinaryRight</strong>(string op, D)(D lhs)<br><small>  Constraints: if ((op == "+" || op == "-") &amp;&amp; is(immutable(D) == immutable(TickDuration))); </small>
</dt> <dd>
<p>Adds or subtracts two durations. </p>
<p>The legal types of arithmetic for <code>Duration</code> using this operator are <br><br> <table>

<tr>
<td>TickDuration</td> <td>+</td> <td>Duration</td> <td>--&gt;</td> <td>Duration</td>
</tr> <tr>
<td>TickDuration</td> <td>-</td> <td>Duration</td> <td>--&gt;</td> <td>Duration</td>
</tr> </table> </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>D <code>lhs</code>
</td> <td>The <code>TickDuration</code> to add to this <code>Duration</code> or to subtract this <code>Duration</code> from.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="Duration.opOpAssign">nothrow @nogc ref Duration <strong id="opOpAssign">opOpAssign</strong>(string op, D)(scope const D rhs)<br><small>  Constraints: if ((op == "+" || op == "-" || op == "%") &amp;&amp; is(immutable(D) == immutable(Duration)) || (op == "+" || op == "-") &amp;&amp; is(immutable(D) == immutable(TickDuration))); </small>
</dt> <dd>
<p>Adds, subtracts or calculates the modulo of two durations as well as assigning the result to this <code>Duration</code>. </p>
<p>The legal types of arithmetic for <code>Duration</code> using this operator are <br><br> <table>

<tr>
<td>Duration</td> <td>+</td> <td>Duration</td> <td>--&gt;</td> <td>Duration</td>
</tr> <tr>
<td>Duration</td> <td>-</td> <td>Duration</td> <td>--&gt;</td> <td>Duration</td>
</tr> <tr>
<td>Duration</td> <td>%</td> <td>Duration</td> <td>--&gt;</td> <td>Duration</td>
</tr> <tr>
<td>Duration</td> <td>+</td> <td>TickDuration</td> <td>--&gt;</td> <td>Duration</td>
</tr> <tr>
<td>Duration</td> <td>-</td> <td>TickDuration</td> <td>--&gt;</td> <td>Duration</td>
</tr> </table> </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>D <code>rhs</code>
</td> <td>The duration to add to or subtract from this <code>Duration</code>.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="Duration.opBinary.2">const nothrow @nogc Duration <strong id="opBinary">opBinary</strong>(string op)(long value)<br><small>  Constraints: if (op == "*" || op == "/"); </small>
</dt> <dd>
<p>Multiplies or divides the duration by an integer value. </p>
<p>The legal types of arithmetic for <code>Duration</code> using this operator overload are <br><br> <table>

<tr>
<td>Duration</td> <td>*</td> <td>long</td> <td>--&gt;</td> <td>Duration</td>
</tr> <tr>
<td>Duration</td> <td>/</td> <td>long</td> <td>--&gt;</td> <td>Duration</td>
</tr> </table> </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>long <code>value</code>
</td> <td>The value to multiply this <code>Duration</code> by.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="Duration.opOpAssign.2">nothrow @nogc ref Duration <strong id="opOpAssign">opOpAssign</strong>(string op)(long value)<br><small>  Constraints: if (op == "*" || op == "/"); </small>
</dt> <dd>
<p>Multiplies/Divides the duration by an integer value as well as assigning the result to this <code>Duration</code>. </p>
<p>The legal types of arithmetic for <code>Duration</code> using this operator overload are <br><br> <table>

<tr>
<td>Duration</td> <td>*</td> <td>long</td> <td>--&gt;</td> <td>Duration</td>
</tr> <tr>
<td>Duration</td> <td>/</td> <td>long</td> <td>--&gt;</td> <td>Duration</td>
</tr> </table> </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>long <code>value</code>
</td> <td>The value to multiply/divide this <code>Duration</code> by.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="Duration.opBinary.3">const nothrow @nogc long <strong id="opBinary">opBinary</strong>(string op)(Duration rhs)<br><small>  Constraints: if (op == "/"); </small>
</dt> <dd>
<p>Divides two durations. </p>
<p>The legal types of arithmetic for <code>Duration</code> using this operator are <br><br> <table>

<tr>
<td>Duration</td> <td>/</td> <td>Duration</td> <td>--&gt;</td> <td>long</td>
</tr> </table> </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Duration <code>rhs</code>
</td> <td>The duration to divide this <code>Duration</code> by.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="Duration.opBinaryRight.2">const nothrow @nogc Duration <strong id="opBinaryRight">opBinaryRight</strong>(string op)(long value)<br><small>  Constraints: if (op == "*"); </small>
</dt> <dd>
<p>Multiplies an integral value and a <code>Duration</code>. </p>
<p>The legal types of arithmetic for <code>Duration</code> using this operator overload are <br><br> <table>

<tr>
<td>long</td> <td>*</td> <td>Duration</td> <td>--&gt;</td> <td>Duration</td>
</tr> </table> </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>long <code>value</code>
</td> <td>The number of units to multiply this <code>Duration</code> by.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="Duration.opUnary">const nothrow @nogc Duration <strong id="opUnary">opUnary</strong>(string op)()<br><small>  Constraints: if (op == "-"); </small>
</dt> <dd>
<p>Returns the negation of this <code>Duration</code>.</p> </dd> <dt class="d_decl" id="Duration.opCast">const nothrow @nogc TickDuration <strong id="opCast">opCast</strong>(T)()<br><small>  Constraints: if (is(immutable(T) == immutable(TickDuration))); </small>
</dt> <dd>
<p>Returns a <a href="#TickDuration"><code>TickDuration</code></a> with the same number of hnsecs as this <code>Duration</code>. Note that the conventional way to convert between <code>Duration</code> and <code>TickDuration</code> is using <a href="std_conv.html#to"><code>std.conv.to</code></a>, e.g.: <code>duration.to!TickDuration()</code></p> </dd> <dt class="d_decl" id="Duration.opCast.2">const nothrow @nogc bool <strong id="opCast">opCast</strong>(T : bool)(); </dt> <dd>
<p>Allow Duration to be used as a boolean. </p>
<dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if this duration is non-zero.</dd>
</dl> </dd> <dt class="d_decl" id="Duration.split">template <strong id="split">split</strong>(units...) if (allAreAcceptedUnits!("weeks", "days", "hours", "minutes", "seconds", "msecs", "usecs", "hnsecs", "nsecs")(units) &amp;&amp; unitsAreInDescendingOrder(units))</dt> <dd>
<p>Splits out the Duration into the given units. </p>
<p>split takes the list of time units to split out as template arguments. The time unit strings must be given in decreasing order. How it returns the values for those units depends on the overload used. <br><br> The overload which accepts function arguments takes integral types in the order that the time unit strings were given, and those integers are passed by <code>ref</code>. split assigns the values for the units to each corresponding integer. Any integral type may be used, but no attempt is made to prevent integer overflow, so don't use small integral types in circumstances where the values for those units aren't likely to fit in an integral type that small. <br><br> The overload with no arguments returns the values for the units in a struct with members whose names are the same as the given time unit strings. The members are all <code>long</code>s. This overload will also work with no time strings being given, in which case <i>all</i> of the time units from weeks through hnsecs will be provided (but no nsecs, since it would always be <code>0</code>). <br><br> For both overloads, the entire value of the Duration is split among the units (rather than splitting the Duration across all units and then only providing the values for the requested units), so if only one unit is given, the result is equivalent to <a href="#total"><code>total</code></a>. <br><br> <code>"nsecs"</code> is accepted by split, but <code>"years"</code> and <code>"months"</code> are not. <br><br> For negative durations, all of the split values will be negative.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">{
    auto d = dur!"days"(12) + dur!"minutes"(7) + dur!"usecs"(501223);
    long days;
    int seconds;
    short msecs;
    d.split!("days", "seconds", "msecs")(days, seconds, msecs);
    assert(days == 12);
    assert(seconds == 7 * 60);
    assert(msecs == 501);

    auto splitStruct = d.split!("days", "seconds", "msecs")();
    assert(splitStruct.days == 12);
    assert(splitStruct.seconds == 7 * 60);
    assert(splitStruct.msecs == 501);

    auto fullSplitStruct = d.split();
    assert(fullSplitStruct.weeks == 1);
    assert(fullSplitStruct.days == 5);
    assert(fullSplitStruct.hours == 0);
    assert(fullSplitStruct.minutes == 7);
    assert(fullSplitStruct.seconds == 0);
    assert(fullSplitStruct.msecs == 501);
    assert(fullSplitStruct.usecs == 223);
    assert(fullSplitStruct.hnsecs == 0);

    assert(d.split!"minutes"().minutes == d.total!"minutes");
}

{
    auto d = dur!"days"(12);
    assert(d.split!"weeks"().weeks == 1);
    assert(d.split!"days"().days == 12);

    assert(d.split().weeks == 1);
    assert(d.split().days == 5);
}

{
    auto d = dur!"days"(7) + dur!"hnsecs"(42);
    assert(d.split!("seconds", "nsecs")().nsecs == 4200);
}

{
    auto d = dur!"days"(-7) + dur!"hours"(-9);
    auto result = d.split!("days", "hours")();
    assert(result.days == -7);
    assert(result.hours == -9);
}
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="Duration.split.split">const nothrow @nogc void <strong id="split">split</strong>(Args...)(out Args args)<br><small>  Constraints: if (units.length != 0 &amp;&amp; (args.length == units.length) &amp;&amp; allAreMutableIntegralTypes!Args); </small><br><br>const nothrow @nogc auto <strong id="split">split</strong>(); </dt> <dd>
<p>Ditto</p> </dd> </dl> </dd> <dt class="d_decl" id="Duration.total">const nothrow @nogc @property long <strong id="total">total</strong>(string units)()<br><small>  Constraints: if (units == "weeks" || units == "days" || units == "hours" || units == "minutes" || units == "seconds" || units == "msecs" || units == "usecs" || units == "hnsecs" || units == "nsecs"); </small>
</dt> <dd>
<p>Returns the total number of the given units in this <code>Duration</code>. So, unlike <code>split</code>, it does not strip out the larger units.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(dur!"weeks"(12).total!"weeks" == 12);
assert(dur!"weeks"(12).total!"days" == 84);

assert(dur!"days"(13).total!"weeks" == 1);
assert(dur!"days"(13).total!"days" == 13);

assert(dur!"hours"(49).total!"days" == 2);
assert(dur!"hours"(49).total!"hours" == 49);

assert(dur!"nsecs"(2007).total!"hnsecs" == 20);
assert(dur!"nsecs"(2007).total!"nsecs" == 2000);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Duration.toString">const pure nothrow @safe string <strong id="toString">toString</strong>(); </dt> <dd>
<p>Converts this <code>Duration</code> to a <code>string</code>. </p>
<p>The string is meant to be human readable, not machine parseable (e.g. whether there is an <code>'s'</code> on the end of the unit name usually depends on whether it's plural or not, and empty units are not included unless the Duration is <code>zero</code>). Any code needing a specific string format should use <code>total</code> or <code>split</code> to get the units needed to create the desired string format and create the string itself. <br><br> The format returned by toString may or may not change in the future.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(Duration.zero.toString() == "0 hnsecs");
assert(weeks(5).toString() == "5 weeks");
assert(days(2).toString() == "2 days");
assert(hours(1).toString() == "1 hour");
assert(minutes(19).toString() == "19 minutes");
assert(seconds(42).toString() == "42 secs");
assert(msecs(42).toString() == "42 ms");
assert(usecs(27).toString() == "27 μs");
assert(hnsecs(5).toString() == "5 hnsecs");

assert(seconds(121).toString() == "2 minutes and 1 sec");
assert((minutes(5) + seconds(3) + usecs(4)).toString() ==
       "5 minutes, 3 secs, and 4 μs");

assert(seconds(-42).toString() == "-42 secs");
assert(usecs(-5239492).toString() == "-5 secs, -239 ms, and -492 μs");
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Duration.isNegative">const pure nothrow @nogc @property @safe bool <strong id="isNegative">isNegative</strong>(); </dt> <dd>
<p>Returns whether this <code>Duration</code> is negative.</p> </dd> </dl> </dd> <dt class="d_decl" id="to">pure nothrow @nogc @safe T <strong id="to">to</strong>(string units, T, D)(D td)<br><small>  Constraints: if (is(immutable(D) == immutable(TickDuration)) &amp;&amp; (units == "seconds" || units == "msecs" || units == "usecs" || units == "hnsecs" || units == "nsecs")); </small>
</dt> <dd>
<p>Converts a <code>TickDuration</code> to the given units as either an integral value or a floating point value. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>units</td> <td>The units to convert to. Accepts <code>"seconds"</code> and smaller only.</td>
</tr> <tr>
<td>T</td> <td>The type to convert to (either an integral type or a floating point type).</td>
</tr> <tr>
<td>D <code>td</code>
</td> <td>The TickDuration to convert</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto t = TickDuration.from!"seconds"(1000);

long tl = to!("seconds",long)(t);
assert(tl == 1000);

import core.stdc.math : fabs;
double td = to!("seconds",double)(t);
assert(fabs(td - 1000) &lt; 0.001);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="dur">pure nothrow @nogc @safe Duration <strong id="dur">dur</strong>(string units)(long length)<br><small>  Constraints: if (units == "weeks" || units == "days" || units == "hours" || units == "minutes" || units == "seconds" || units == "msecs" || units == "usecs" || units == "hnsecs" || units == "nsecs"); </small><br><br>alias <strong id="weeks">weeks</strong> = dur!"<strong id="weeks">weeks</strong>".dur; <br><br>alias <strong id="days">days</strong> = dur!"<strong id="days">days</strong>".dur; <br><br>alias <strong id="hours">hours</strong> = dur!"<strong id="hours">hours</strong>".dur; <br><br>alias <strong id="minutes">minutes</strong> = dur!"<strong id="minutes">minutes</strong>".dur; <br><br>alias <strong id="seconds">seconds</strong> = dur!"<strong id="seconds">seconds</strong>".dur; <br><br>alias <strong id="msecs">msecs</strong> = dur!"<strong id="msecs">msecs</strong>".dur; <br><br>alias <strong id="usecs">usecs</strong> = dur!"<strong id="usecs">usecs</strong>".dur; <br><br>alias <strong id="hnsecs">hnsecs</strong> = dur!"<strong id="hnsecs">hnsecs</strong>".dur; <br><br>alias <strong id="nsecs">nsecs</strong> = dur!"<strong id="nsecs">nsecs</strong>".dur; </dt> <dd>
<p>These allow you to construct a <code>Duration</code> from the given time units with the given length. </p>
<p>You can either use the generic function <code>dur</code> and give it the units as a <code>string</code> or use the named aliases. <br><br> The possible values for units are <code>"weeks"</code>, <code>"days"</code>, <code>"hours"</code>, <code>"minutes"</code>, <code>"seconds"</code>, <code>"msecs"</code> (milliseconds), <code>"usecs"</code>, (microseconds), <code>"hnsecs"</code> (hecto-nanoseconds, i.e. 100 ns), and <code>"nsecs"</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>units</td> <td>The time units of the <code>Duration</code> (e.g. <code>"days"</code>).</td>
</tr> <tr>
<td>long <code>length</code>
</td> <td>The number of units in the <code>Duration</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">// Generic
assert(dur!"weeks"(142).total!"weeks" == 142);
assert(dur!"days"(142).total!"days" == 142);
assert(dur!"hours"(142).total!"hours" == 142);
assert(dur!"minutes"(142).total!"minutes" == 142);
assert(dur!"seconds"(142).total!"seconds" == 142);
assert(dur!"msecs"(142).total!"msecs" == 142);
assert(dur!"usecs"(142).total!"usecs" == 142);
assert(dur!"hnsecs"(142).total!"hnsecs" == 142);
assert(dur!"nsecs"(142).total!"nsecs" == 100);

// Non-generic
assert(weeks(142).total!"weeks" == 142);
assert(days(142).total!"days" == 142);
assert(hours(142).total!"hours" == 142);
assert(minutes(142).total!"minutes" == 142);
assert(seconds(142).total!"seconds" == 142);
assert(msecs(142).total!"msecs" == 142);
assert(usecs(142).total!"usecs" == 142);
assert(hnsecs(142).total!"hnsecs" == 142);
assert(nsecs(142).total!"nsecs" == 100);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="MonoTime">alias <strong id="MonoTime">MonoTime</strong> = MonoTimeImpl!ClockType.normal.MonoTimeImpl; </dt> <dd>
<p>alias for <code>MonoTimeImpl</code> instantiated with <code>ClockType.normal</code>. This is what most programs should use. It's also what much of <code>MonoTimeImpl</code> uses in its documentation (particularly in the examples), because that's what's going to be used in most code.</p> </dd> <dt class="d_decl" id="MonoTimeImpl">struct <strong id="MonoTimeImpl">MonoTimeImpl</strong>(ClockType clockType); </dt> <dd>
<p>Represents a timestamp of the system's monotonic clock. </p>
<p> A monotonic clock is one which always goes forward and never moves backwards, unlike the system's wall clock time (as represented by <a href="std_datetime.html#SysTime"><code>std.datetime.SysTime</code></a>). The system's wall clock time can be adjusted by the user or by the system itself via services such as NTP, so it is unreliable to use the wall clock time for timing. Timers which use the wall clock time could easily end up never going off due to changes made to the wall clock time or otherwise waiting for a different period of time than that specified by the programmer. However, because the monotonic clock always increases at a fixed rate and is not affected by adjustments to the wall clock time, it is ideal for use with timers or anything which requires high precision timing. <br><br> So, MonoTime should be used for anything involving timers and timing, whereas <a href="std_datetime.html#SysTime"><code>std.datetime.SysTime</code></a> should be used when the wall clock time is required. <br><br> The monotonic clock has no relation to wall clock time. Rather, it holds its time as the number of ticks of the clock which have occurred since the clock started (typically when the system booted up). So, to determine how much time has passed between two points in time, one monotonic time is subtracted from the other to determine the number of ticks which occurred between the two points of time, and those ticks are divided by the number of ticks that occur every second (as represented by MonoTime.ticksPerSecond) to get a meaningful duration of time. Normally, MonoTime does these calculations for the programmer, but the <code>ticks</code> and <code>ticksPerSecond</code> properties are provided for those who require direct access to the system ticks. The normal way that MonoTime would be used is <br><br> <pre data-language="d">    MonoTime before = MonoTime.currTime;
    // do stuff...
    MonoTime after = MonoTime.currTime;
    Duration timeElapsed = after - before;
</pre> <br><br> <a href="#MonoTime"><code>MonoTime</code></a> is an alias to <code>MonoTimeImpl!(ClockType.normal)</code> and is what most programs should use for the monotonic clock, so that's what is used in most of <code>MonoTimeImpl</code>'s documentation. But <code>MonoTimeImpl</code> can be instantiated with other clock types for those rare programs that need it. </p> <dl>
<dt>See Also:</dt>
<dd><a href="#ClockType"><code>ClockType</code></a></dd>
</dl> <dl>
<dt class="d_decl" id="MonoTimeImpl.currTime">static nothrow @nogc @property @trusted MonoTimeImpl <strong id="currTime">currTime</strong>(); </dt> <dd>
<p>The current time of the system's monotonic clock. This has no relation to the wall clock time, as the wall clock time can be adjusted (e.g. by NTP), whereas the monotonic clock always moves forward. The source of the monotonic time is system-specific. </p>
<p>On Windows, <code>QueryPerformanceCounter</code> is used. On Mac OS X, <code>mach_absolute_time</code> is used, while on other POSIX systems, <code>clock_gettime</code> is used. <br><br> <span class="red">Warning</span>: On some systems, the monotonic clock may stop counting when the computer goes to sleep or hibernates. So, the monotonic clock may indicate less time than has actually passed if that occurs. This is known to happen on Mac OS X. It has not been tested whether it occurs on either Windows or Linux.</p> </dd> <dt class="d_decl" id="MonoTimeImpl.zero">MonoTimeImpl <strong id="zero">zero</strong>(); </dt> <dd>
<p>A <code>MonoTime</code> of <code>0</code> ticks. It's provided to be consistent with <code>Duration.zero</code>, and it's more explicit than <code>MonoTime.init</code>.</p> </dd> <dt class="d_decl" id="MonoTimeImpl.max">MonoTimeImpl <strong id="max">max</strong>(); </dt> <dd>
<p>Largest <code>MonoTime</code> possible.</p> </dd> <dt class="d_decl" id="MonoTimeImpl.min">MonoTimeImpl <strong id="min">min</strong>(); </dt> <dd>
<p>Most negative <code>MonoTime</code> possible.</p> </dd> <dt class="d_decl" id="MonoTimeImpl.opCmp">const pure nothrow @nogc int <strong id="opCmp">opCmp</strong>(MonoTimeImpl rhs); </dt> <dd>
<p>Compares this MonoTime with the given MonoTime. </p>
<dl>
<dt>Returns:</dt>
<dd><table>
 <tr>
<td>this &lt; rhs</td> <td>&lt; 0</td>
</tr> <tr>
<td>this == rhs</td> <td>0</td>
</tr> <tr>
<td>this &gt; rhs</td> <td>&gt; 0</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="MonoTimeImpl.opBinary">const pure nothrow @nogc Duration <strong id="opBinary">opBinary</strong>(string op)(MonoTimeImpl rhs)<br><small>  Constraints: if (op == "-"); </small>
</dt> <dd>
<p>Subtracting two MonoTimes results in a <a href="#Duration"><code>Duration</code></a> representing the amount of time which elapsed between them. </p>
<p> The primary way that programs should time how long something takes is to do <pre data-language="d">MonoTime before = MonoTime.currTime;
// do stuff
MonoTime after = MonoTime.currTime;

// How long it took.
Duration timeElapsed = after - before;
</pre> or to use a wrapper (such as a stop watch type) which does that. <br><br> <span class="red">Warning</span>: Because <a href="#Duration"><code>Duration</code></a> is in hnsecs, whereas MonoTime is in system ticks, it's usually the case that this assertion will fail <pre data-language="d">auto before = MonoTime.currTime;
// do stuff
auto after = MonoTime.currTime;
auto timeElapsed = after - before;
assert(before + timeElapsed == after);
</pre> <br><br> This is generally fine, and by its very nature, converting from system ticks to any type of seconds (hnsecs, nsecs, etc.) will introduce rounding errors, but if code needs to avoid any of the small rounding errors introduced by conversion, then it needs to use MonoTime's <code>ticks</code> property and keep all calculations in ticks rather than using <a href="#Duration"><code>Duration</code></a>.</p> </dd> <dt class="d_decl" id="MonoTimeImpl.opBinary.2">const pure nothrow @nogc MonoTimeImpl <strong id="opBinary">opBinary</strong>(string op)(Duration rhs)<br><small>  Constraints: if (op == "+" || op == "-"); </small><br><br>pure nothrow @nogc ref MonoTimeImpl <strong id="opOpAssign">opOpAssign</strong>(string op)(Duration rhs)<br><small>  Constraints: if (op == "+" || op == "-"); </small>
</dt> <dd>
<p>Adding or subtracting a <a href="#Duration"><code>Duration</code></a> to/from a MonoTime results in a MonoTime which is adjusted by that amount.</p> </dd> <dt class="d_decl" id="MonoTimeImpl.ticks">const pure nothrow @nogc @property long <strong id="ticks">ticks</strong>(); </dt> <dd>
<p>The number of ticks in the monotonic time. </p>
<p>Most programs should not use this directly, but it's exposed for those few programs that need it. <br><br> The main reasons that a program might need to use ticks directly is if the system clock has higher precision than hnsecs, and the program needs that higher precision, or if the program needs to avoid the rounding errors caused by converting to hnsecs.</p> </dd> <dt class="d_decl" id="MonoTimeImpl.ticksPerSecond">static pure nothrow @nogc @property long <strong id="ticksPerSecond">ticksPerSecond</strong>(); </dt> <dd>
<p>The number of ticks that MonoTime has per second - i.e. the resolution or frequency of the system's monotonic clock. </p>
<p>e.g. if the system clock had a resolution of microseconds, then ticksPerSecond would be <code>1_000_000</code>.</p> </dd> <dt class="d_decl" id="MonoTimeImpl.toString">const pure nothrow string <strong id="toString">toString</strong>(); </dt>  </dl> </dd> <dt class="d_decl" id="convClockFreq">pure nothrow @nogc @safe long <strong id="convClockFreq">convClockFreq</strong>(long ticks, long srcTicksPerSecond, long dstTicksPerSecond); </dt> <dd>
<p>Converts the given time from one clock frequency/resolution to another. </p>
<dl>
<dt>See Also:</dt>
<dd><a href="#ticksToNSecs"><code>ticksToNSecs</code></a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">// one tick is one second -&gt; one tick is a hecto-nanosecond
assert(convClockFreq(45, 1, 10_000_000) == 450_000_000);

// one tick is one microsecond -&gt; one tick is a millisecond
assert(convClockFreq(9029, 1_000_000, 1_000) == 9);

// one tick is 1/3_515_654 of a second -&gt; 1/1_001_010 of a second
assert(convClockFreq(912_319, 3_515_654, 1_001_010) == 259_764);

// one tick is 1/MonoTime.ticksPerSecond -&gt; one tick is a nanosecond
// Equivalent to ticksToNSecs
auto nsecs = convClockFreq(1982, MonoTime.ticksPerSecond, 1_000_000_000);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="ticksToNSecs">pure nothrow @nogc @safe long <strong id="ticksToNSecs">ticksToNSecs</strong>(long ticks); </dt> <dd>
<p>Convenience wrapper around <a href="#convClockFreq"><code>convClockFreq</code></a> which converts ticks at a clock frequency of <code>MonoTime.ticksPerSecond</code> to nanoseconds. </p>
<p>It's primarily of use when <code>MonoTime.ticksPerSecond</code> is greater than hecto-nanosecond resolution, and an application needs a higher precision than hecto-nanoceconds. </p> <dl>
<dt>See Also:</dt>
<dd><a href="#convClockFreq"><code>convClockFreq</code></a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto before = MonoTime.currTime;
// do stuff
auto after = MonoTime.currTime;
auto diffInTicks = after.ticks - before.ticks;
auto diffInNSecs = ticksToNSecs(diffInTicks);
assert(diffInNSecs == convClockFreq(diffInTicks, MonoTime.ticksPerSecond, 1_000_000_000));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="nsecsToTicks">pure nothrow @nogc @safe long <strong id="nsecsToTicks">nsecsToTicks</strong>(long ticks); </dt> <dd>
<p>The reverse of <a href="#ticksToNSecs"><code>ticksToNSecs</code></a>.</p> </dd> <dt class="d_decl" id="TickDuration">struct <strong id="TickDuration">TickDuration</strong>; </dt> <dd>
<p><span class="red">Warning: TickDuration will be deprecated in the near future (once all uses of it in Phobos have been deprecated). Please use <a href="#MonoTime"><code>MonoTime</code></a> for the cases where a monotonic timestamp is needed and <a href="#Duration"><code>Duration</code></a> when a duration is needed, rather than using TickDuration. It has been decided that TickDuration is too confusing (e.g. it conflates a monotonic timestamp and a duration in monotonic clock ticks) and that having multiple duration types is too awkward and confusing.</span> </p>
<p>Represents a duration of time in system clock ticks. <br><br> The system clock ticks are the ticks of the system clock at the highest precision that the system provides.</p> <dl>
<dt class="d_decl" id="TickDuration.ticksPerSec">static immutable long <strong id="ticksPerSec">ticksPerSec</strong>; </dt> <dd>
<p>The number of ticks that the system clock has in one second. </p>
<p>If <code>ticksPerSec</code> is <code>0</code>, then then <code>TickDuration</code> failed to get the value of <code>ticksPerSec</code> on the current system, and <code>TickDuration</code> is not going to work. That would be highly abnormal though.</p> </dd> <dt class="d_decl" id="TickDuration.appOrigin">static immutable TickDuration <strong id="appOrigin">appOrigin</strong>; </dt> <dd>
<p>The tick of the system clock (as a <code>TickDuration</code>) when the application started.</p> </dd> <dt class="d_decl" id="TickDuration.zero">static pure nothrow @nogc @property @safe TickDuration <strong id="zero">zero</strong>(); </dt> <dd>
<p>It's the same as <code>TickDuration(0)</code>, but it's provided to be consistent with <code>Duration</code>, which provides a <code>zero</code> property.</p> </dd> <dt class="d_decl" id="TickDuration.max">static pure nothrow @nogc @property @safe TickDuration <strong id="max">max</strong>(); </dt> <dd>
<p>Largest <code>TickDuration</code> possible.</p> </dd> <dt class="d_decl" id="TickDuration.min">static pure nothrow @nogc @property @safe TickDuration <strong id="min">min</strong>(); </dt> <dd>
<p>Most negative <code>TickDuration</code> possible.</p> </dd> <dt class="d_decl" id="TickDuration.length">long <strong id="length">length</strong>; </dt> <dd>
<p>The number of system ticks in this <code>TickDuration</code>. </p>
<p>You can convert this <code>length</code> into the number of seconds by dividing it by <code>ticksPerSec</code> (or using one the appropriate property function to do it).</p> </dd> <dt class="d_decl" id="TickDuration.seconds">const pure nothrow @nogc @property @safe long <strong id="seconds">seconds</strong>(); </dt> <dd>
<p>Returns the total number of seconds in this <code>TickDuration</code>.</p> </dd> <dt class="d_decl" id="TickDuration.msecs">const pure nothrow @nogc @property @safe long <strong id="msecs">msecs</strong>(); </dt> <dd>
<p>Returns the total number of milliseconds in this <code>TickDuration</code>.</p> </dd> <dt class="d_decl" id="TickDuration.usecs">const pure nothrow @nogc @property @safe long <strong id="usecs">usecs</strong>(); </dt> <dd>
<p>Returns the total number of microseconds in this <code>TickDuration</code>.</p> </dd> <dt class="d_decl" id="TickDuration.hnsecs">const pure nothrow @nogc @property @safe long <strong id="hnsecs">hnsecs</strong>(); </dt> <dd>
<p>Returns the total number of hecto-nanoseconds in this <code>TickDuration</code>.</p> </dd> <dt class="d_decl" id="TickDuration.nsecs">const pure nothrow @nogc @property @safe long <strong id="nsecs">nsecs</strong>(); </dt> <dd>
<p>Returns the total number of nanoseconds in this <code>TickDuration</code>.</p> </dd> <dt class="d_decl" id="TickDuration.from">pure nothrow @nogc @safe TickDuration <strong id="from">from</strong>(string units)(long length)<br><small>  Constraints: if (units == "seconds" || units == "msecs" || units == "usecs" || units == "hnsecs" || units == "nsecs"); </small>
</dt> <dd>
<p>This allows you to construct a <code>TickDuration</code> from the given time units with the given length. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>units</td> <td>The time units of the <code>TickDuration</code> (e.g. <code>"msecs"</code>).</td>
</tr> <tr>
<td>long <code>length</code>
</td> <td>The number of units in the <code>TickDuration</code>.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="TickDuration.opCast">const pure nothrow @nogc @safe Duration <strong id="opCast">opCast</strong>(T)()<br><small>  Constraints: if (is(immutable(T) == immutable(Duration))); </small>
</dt> <dd>
<p>Returns a <a href="#Duration"><code>Duration</code></a> with the same number of hnsecs as this <code>TickDuration</code>. Note that the conventional way to convert between <code>TickDuration</code> and <code>Duration</code> is using <a href="std_conv.html#to"><code>std.conv.to</code></a>, e.g.: <code>tickDuration.to!Duration()</code></p> </dd> <dt class="d_decl" id="TickDuration.opOpAssign">pure nothrow @nogc ref @safe TickDuration <strong id="opOpAssign">opOpAssign</strong>(string op)(TickDuration rhs)<br><small>  Constraints: if (op == "+" || op == "-"); </small>
</dt> <dd>
<p>Adds or subtracts two <code>TickDuration</code>s as well as assigning the result to this <code>TickDuration</code>. </p>
<p>The legal types of arithmetic for <code>TickDuration</code> using this operator are <br><br> <table>

<tr>
<td>TickDuration</td> <td>+=</td> <td>TickDuration</td> <td>--&gt;</td> <td>TickDuration</td>
</tr> <tr>
<td>TickDuration</td> <td>-=</td> <td>TickDuration</td> <td>--&gt;</td> <td>TickDuration</td>
</tr> </table> </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>TickDuration <code>rhs</code>
</td> <td>The <code>TickDuration</code> to add to or subtract from this <code>TickDuration</code>.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="TickDuration.opBinary">const pure nothrow @nogc @safe TickDuration <strong id="opBinary">opBinary</strong>(string op)(TickDuration rhs)<br><small>  Constraints: if (op == "+" || op == "-"); </small>
</dt> <dd>
<p>Adds or subtracts two <code>TickDuration</code>s. </p>
<p>The legal types of arithmetic for <code>TickDuration</code> using this operator are <br><br> <table>

<tr>
<td>TickDuration</td> <td>+</td> <td>TickDuration</td> <td>--&gt;</td> <td>TickDuration</td>
</tr> <tr>
<td>TickDuration</td> <td>-</td> <td>TickDuration</td> <td>--&gt;</td> <td>TickDuration</td>
</tr> </table> </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>TickDuration <code>rhs</code>
</td> <td>The <code>TickDuration</code> to add to or subtract from this <code>TickDuration</code>.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="TickDuration.opUnary">const pure nothrow @nogc @safe TickDuration <strong id="opUnary">opUnary</strong>(string op)()<br><small>  Constraints: if (op == "-"); </small>
</dt> <dd>
<p>Returns the negation of this <code>TickDuration</code>.</p> </dd> <dt class="d_decl" id="TickDuration.opCmp">const pure nothrow @nogc @safe int <strong id="opCmp">opCmp</strong>(TickDuration rhs); </dt> <dd>
<p>operator overloading "&lt;, &gt;, &lt;=, &gt;="</p> </dd> <dt class="d_decl" id="TickDuration.opOpAssign.2">pure nothrow @nogc @safe void <strong id="opOpAssign">opOpAssign</strong>(string op, T)(T value)<br><small>  Constraints: if (op == "*" &amp;&amp; (__traits(isIntegral, T) || __traits(isFloating, T))); </small>
</dt> <dd>
<p>The legal types of arithmetic for <code>TickDuration</code> using this operator overload are </p>
<p><table>

<tr>
<td>TickDuration</td> <td>*</td> <td>long</td> <td>--&gt;</td> <td>TickDuration</td>
</tr> <tr>
<td>TickDuration</td> <td>*</td> <td>floating point</td> <td>--&gt;</td> <td>TickDuration</td>
</tr> </table> </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T <code>value</code>
</td> <td>The value to divide from this duration.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="TickDuration.opOpAssign.3">pure @safe void <strong id="opOpAssign">opOpAssign</strong>(string op, T)(T value)<br><small>  Constraints: if (op == "/" &amp;&amp; (__traits(isIntegral, T) || __traits(isFloating, T))); </small>
</dt> <dd>
<p>The legal types of arithmetic for <code>TickDuration</code> using this operator overload are </p>
<p><table>

<tr>
<td>TickDuration</td> <td>/</td> <td>long</td> <td>--&gt;</td> <td>TickDuration</td>
</tr> <tr>
<td>TickDuration</td> <td>/</td> <td>floating point</td> <td>--&gt;</td> <td>TickDuration</td>
</tr> </table> </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T <code>value</code>
</td> <td>The value to divide from this <code>TickDuration</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<code>TimeException</code> if an attempt to divide by <code>0</code> is made.</dd>
</dl> </dd> <dt class="d_decl" id="TickDuration.opBinary.2">const pure nothrow @nogc @safe TickDuration <strong id="opBinary">opBinary</strong>(string op, T)(T value)<br><small>  Constraints: if (op == "*" &amp;&amp; (__traits(isIntegral, T) || __traits(isFloating, T))); </small>
</dt> <dd>
<p>The legal types of arithmetic for <code>TickDuration</code> using this operator overload are </p>
<p><table>

<tr>
<td>TickDuration</td> <td>*</td> <td>long</td> <td>--&gt;</td> <td>TickDuration</td>
</tr> <tr>
<td>TickDuration</td> <td>*</td> <td>floating point</td> <td>--&gt;</td> <td>TickDuration</td>
</tr> </table> </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T <code>value</code>
</td> <td>The value to divide from this <code>TickDuration</code>.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="TickDuration.opBinary.3">const pure @safe TickDuration <strong id="opBinary">opBinary</strong>(string op, T)(T value)<br><small>  Constraints: if (op == "/" &amp;&amp; (__traits(isIntegral, T) || __traits(isFloating, T))); </small>
</dt> <dd>
<p>The legal types of arithmetic for <code>TickDuration</code> using this operator overload are </p>
<p><table>

<tr>
<td>TickDuration</td> <td>/</td> <td>long</td> <td>--&gt;</td> <td>TickDuration</td>
</tr> <tr>
<td>TickDuration</td> <td>/</td> <td>floating point</td> <td>--&gt;</td> <td>TickDuration</td>
</tr> </table> </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T <code>value</code>
</td> <td>The value to divide from this <code>TickDuration</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<code>TimeException</code> if an attempt to divide by <code>0</code> is made.</dd>
</dl> </dd> <dt class="d_decl" id="TickDuration.this">pure nothrow @nogc @safe this(long ticks); </dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>long <code>ticks</code>
</td> <td>The number of ticks in the TickDuration.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="TickDuration.currSystemTick">static nothrow @nogc @property @trusted TickDuration <strong id="currSystemTick">currSystemTick</strong>(); </dt> <dd>
<p>The current system tick. The number of ticks per second varies from system to system. <code>currSystemTick</code> uses a monotonic clock, so it's intended for precision timing by comparing relative time values, not for getting the current system time. </p>
<p>On Windows, <code>QueryPerformanceCounter</code> is used. On Mac OS X, <code>mach_absolute_time</code> is used, while on other Posix systems, <code>clock_gettime</code> is used. If <code>mach_absolute_time</code> or <code>clock_gettime</code> is unavailable, then Posix systems use <code>gettimeofday</code> (the decision is made when <code>TickDuration</code> is compiled), which unfortunately, is not monotonic, but if <code>mach_absolute_time</code> and <code>clock_gettime</code> aren't available, then <code>gettimeofday</code> is the the best that there is. <br><br> <span class="red">Warning</span>: On some systems, the monotonic clock may stop counting when the computer goes to sleep or hibernates. So, the monotonic clock could be off if that occurs. This is known to happen on Mac OS X. It has not been tested whether it occurs on either Windows or on Linux. </p> <dl>
<dt>Throws:</dt>
<dd>
<code>TimeException</code> if it fails to get the time.</dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="convert">pure nothrow @nogc @safe long <strong id="convert">convert</strong>(string from, string to)(long value)<br><small>  Constraints: if ((from == "weeks" || from == "days" || from == "hours" || from == "minutes" || from == "seconds" || from == "msecs" || from == "usecs" || from == "hnsecs" || from == "nsecs") &amp;&amp; (to == "weeks" || to == "days" || to == "hours" || to == "minutes" || to == "seconds" || to == "msecs" || to == "usecs" || to == "hnsecs" || to == "nsecs") || (from == "years" || from == "months") &amp;&amp; (to == "years" || to == "months")); </small>
</dt> <dd>
<p>Generic way of converting between two time units. Conversions to smaller units use truncating division. Years and months can be converted to each other, small units can be converted to each other, but years and months cannot be converted to or from smaller units (due to the varying number of days in a month or year). </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>from</td> <td>The units of time to convert from.</td>
</tr> <tr>
<td>to</td> <td>The units of time to convert to.</td>
</tr> <tr>
<td>long <code>value</code>
</td> <td>The value to convert.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(convert!("years", "months")(1) == 12);
assert(convert!("months", "years")(12) == 1);

assert(convert!("weeks", "days")(1) == 7);
assert(convert!("hours", "seconds")(1) == 3600);
assert(convert!("seconds", "days")(1) == 0);
assert(convert!("seconds", "days")(86_400) == 1);

assert(convert!("nsecs", "nsecs")(1) == 1);
assert(convert!("nsecs", "hnsecs")(1) == 0);
assert(convert!("hnsecs", "nsecs")(1) == 100);
assert(convert!("nsecs", "seconds")(1) == 0);
assert(convert!("seconds", "nsecs")(1) == 1_000_000_000);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="TimeException">class <strong id="TimeException">TimeException</strong>: object.Exception; </dt> <dd>
<p>Exception type used by core.time.</p> <dl>
<dt class="d_decl" id="TimeException.this">pure nothrow @safe this(string msg, string file = __FILE__, size_t line = __LINE__, Throwable next = null); </dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>string <code>msg</code>
</td> <td>The message for the exception.</td>
</tr> <tr>
<td>string <code>file</code>
</td> <td>The file where the exception occurred.</td>
</tr> <tr>
<td>size_t <code>line</code>
</td> <td>The line number where the exception occurred.</td>
</tr> <tr>
<td>Throwable <code>next</code>
</td> <td>The previous exception in the chain of exceptions, if any.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="TimeException.this.2">pure nothrow @safe this(string msg, Throwable next, string file = __FILE__, size_t line = __LINE__); </dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>string <code>msg</code>
</td> <td>The message for the exception.</td>
</tr> <tr>
<td>Throwable <code>next</code>
</td> <td>The previous exception in the chain of exceptions.</td>
</tr> <tr>
<td>string <code>file</code>
</td> <td>The file where the exception occurred.</td>
</tr> <tr>
<td>size_t <code>line</code>
</td> <td>The line number where the exception occurred.</td>
</tr> </table></dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="abs">pure nothrow @nogc @safe Duration <strong id="abs">abs</strong>(Duration duration); <br><br>pure nothrow @nogc @safe TickDuration <strong id="abs">abs</strong>(TickDuration duration); </dt> <dd>
<p>Returns the absolute value of a duration.</p> </dd> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1999&ndash;2021 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/core_time.html" class="_attribution-link">https://dlang.org/phobos/core_time.html</a>
  </p>
</div>
