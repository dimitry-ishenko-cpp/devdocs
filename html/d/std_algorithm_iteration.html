<h1>std.algorithm.iteration</h1>  <p>This is a submodule of <a href="std_algorithm.html"><code>std.algorithm</code></a>. It contains generic iteration algorithms. </p>
<p> <table>
<caption>Cheat Sheet</caption>
<tr>
<th scope="col">Function Name</th> <th scope="col">Description</th>
</tr> <tr>
<td><a href="#cache"><code>cache</code></a></td> <td> Eagerly evaluates and caches another range's <code>front</code>.</td>
</tr> <tr>
<td><a href="#cacheBidirectional"><code>cacheBidirectional</code></a></td> <td> As above, but also provides <code>back</code> and <code>popBack</code>.</td>
</tr> <tr>
<td><a href="#chunkBy"><code>chunkBy</code></a></td> <td> <code>chunkBy!((a,b) =&gt; a[1] == b[1])([[1, 1], [1, 2], [2, 2], [2, 1]])</code> returns a range containing 3 subranges: the first with just <code>[1, 1]</code>; the second with the elements <code>[1, 2]</code> and <code>[2, 2]</code>; and the third with just <code>[2, 1]</code>.</td>
</tr> <tr>
<td><a href="#cumulativeFold"><code>cumulativeFold</code></a></td> <td> <code>cumulativeFold!((a, b) =&gt; a + b)([1, 2, 3, 4])</code> returns a lazily-evaluated range containing the successive reduced values <code>1</code>, <code>3</code>, <code>6</code>, <code>10</code>.</td>
</tr> <tr>
<td><a href="#each"><code>each</code></a></td> <td> <code>each!writeln([1, 2, 3])</code> eagerly prints the numbers <code>1</code>, <code>2</code> and <code>3</code> on their own lines.</td>
</tr> <tr>
<td><a href="#filter"><code>filter</code></a></td> <td> <code>filter!(a =&gt; a &gt; 0)([1, -1, 2, 0, -3])</code> iterates over elements <code>1</code> and <code>2</code>.</td>
</tr> <tr>
<td><a href="#filterBidirectional"><code>filterBidirectional</code></a></td> <td> Similar to <code>filter</code>, but also provides <code>back</code> and <code>popBack</code> at a small increase in cost.</td>
</tr> <tr>
<td><a href="#fold"><code>fold</code></a></td> <td> <code>fold!((a, b) =&gt; a + b)([1, 2, 3, 4])</code> returns <code>10</code>.</td>
</tr> <tr>
<td><a href="#group"><code>group</code></a></td> <td> <code>group([5, 2, 2, 3, 3])</code> returns a range containing the tuples <code>tuple(5, 1)</code>, <code>tuple(2, 2)</code>, and <code>tuple(3, 2)</code>.</td>
</tr> <tr>
<td><a href="#joiner"><code>joiner</code></a></td> <td> <code>joiner(["hello", "world!"], "; ")</code> returns a range that iterates over the characters <code>"hello; world!"</code>. No new string is created - the existing inputs are iterated.</td>
</tr> <tr>
<td><a href="#map"><code>map</code></a></td> <td> <code>map!(a =&gt; a * 2)([1, 2, 3])</code> lazily returns a range with the numbers <code>2</code>, <code>4</code>, <code>6</code>.</td>
</tr> <tr>
<td><a href="#mean"><code>mean</code></a></td> <td> Colloquially known as the average, <code>mean([1, 2, 3])</code> returns <code>2</code>.</td>
</tr> <tr>
<td><a href="#permutations"><code>permutations</code></a></td> <td> Lazily computes all permutations using Heap's algorithm.</td>
</tr> <tr>
<td><a href="#reduce"><code>reduce</code></a></td> <td> <code>reduce!((a, b) =&gt; a + b)([1, 2, 3, 4])</code> returns <code>10</code>. This is the old implementation of <code>fold</code>.</td>
</tr> <tr>
<td><a href="#splitter"><code>splitter</code></a></td> <td> Lazily splits a range by a separator.</td>
</tr> <tr>
<td><a href="#substitute"><code>substitute</code></a></td> <td> <code>[1, 2].substitute(1, 0.1)</code> returns <code>[0.1, 2]</code>.</td>
</tr> <tr>
<td><a href="#sum"><code>sum</code></a></td> <td> Same as <code>fold</code>, but specialized for accurate summation.</td>
</tr> <tr>
<td><a href="#uniq"><code>uniq</code></a></td> <td> Iterates over the unique elements in a range, which is assumed sorted.</td>
</tr> </table> </p> <dl>
<dt>License:</dt>
<dd>
<a href="http://boost.org/LICENSE_1_0.txt">Boost License 1.0</a>. </dd>
</dl> <dl>
<dt>Authors:</dt>
<dd>
<a href="http://erdani.com">Andrei Alexandrescu</a> </dd>
</dl> <dl>
<dt>Source</dt>
<dd> <span class="phobos_src"><a class="https" href="https://github.com/dlang/phobos/blob/master/std/algorithm/iteration.d">std/algorithm/iteration.d</a></span> </dd>
</dl> <dl>
<dt class="d_decl" id="cache">auto <strong id="cache">cache</strong>(Range)(Range range)<br><small>  Constraints: if (isInputRange!Range); </small><br><br>auto <strong id="cacheBidirectional">cacheBidirectional</strong>(Range)(Range range)<br><small>  Constraints: if (isBidirectionalRange!Range); </small>
</dt> <dd>
<p><code>cache</code> eagerly evaluates <a href="std_range_primitives.html#front">front</a> of <code>range</code> on each construction or call to <a href="std_range_primitives.html#popFront">popFront</a>, to store the result in a cache. The result is then directly returned when <a href="std_range_primitives.html#front">front</a> is called, rather than re-evaluated. </p>
<p>This can be a useful function to place in a chain, after functions that have expensive evaluation, as a lazy alternative to <a href="std_array.html#array"><code>std.array.array</code></a>. In particular, it can be placed after a call to <a href="#map"><code>map</code></a>, or before a call <a href="std_range.html#filter"><code>std.range.filter</code></a> or <a href="std_range.html#tee"><code>std.range.tee</code></a> <br><br> <code>cache</code> may provide <a href="std_range_primitives.html#isBidirectionalRange">bidirectional range</a> iteration if needed, but since this comes at an increased cost, it must be explicitly requested via the call to <code>cacheBidirectional</code>. Furthermore, a bidirectional cache will evaluate the "center" element twice, when there is only one element left in the range. <br><br> <code>cache</code> does not provide random access primitives, as <code>cache</code> would be unable to cache the random accesses. If <code>Range</code> provides slicing primitives, then <code>cache</code> will provide the same slicing primitives, but <code>hasSlicing!Cache</code> will not yield true (as the <a href="std_range_primitives.html#hasSlicing"><code>std.range.primitives.hasSlicing</code></a> trait also checks for random access). </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>range</code>
</td> <td>an <a href="std_range_primitives.html#isInputRange">input range</a>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>An <a href="std_range_primitives.html#isInputRange">input range</a> with the cached values of range</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.range, std.stdio;
import std.typecons : tuple;

ulong counter = 0;
double fun(int x)
{
    ++counter;
    // http://en.wikipedia.org/wiki/Quartic_function
    return ( (x + 4.0) * (x + 1.0) * (x - 1.0) * (x - 3.0) ) / 14.0 + 0.5;
}
// Without cache, with array (greedy)
auto result1 = iota(-4, 5).map!(a =&gt;tuple(a, fun(a)))()
                         .filter!(a =&gt; a[1] &lt; 0)()
                         .map!(a =&gt; a[0])()
                         .array();

// the values of x that have a negative y are:
assert(equal(result1, [-3, -2, 2]));

// Check how many times fun was evaluated.
// As many times as the number of items in both source and result.
writeln(counter); // iota(-4, 5).length + result1.length

counter = 0;
// Without array, with cache (lazy)
auto result2 = iota(-4, 5).map!(a =&gt;tuple(a, fun(a)))()
                         .cache()
                         .filter!(a =&gt; a[1] &lt; 0)()
                         .map!(a =&gt; a[0])();

// the values of x that have a negative y are:
assert(equal(result2, [-3, -2, 2]));

// Check how many times fun was evaluated.
// Only as many times as the number of items in source.
writeln(counter); // iota(-4, 5).length
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Tip: <code>cache</code> is eager when evaluating elements. If calling front on the underlying range has a side effect, it will be observable before calling front on the actual cached range.  Furthermore, care should be taken composing <code>cache</code> with <a href="std_range.html#take"><code>std.range.take</code></a>. By placing <code>take</code> before <code>cache</code>, then <code>cache</code> will be "aware" of when the range ends, and correctly stop caching elements when needed. If calling front has no side effect though, placing <code>take</code> after <code>cache</code> may yield a faster range.  Either way, the resulting ranges will be equivalent, but maybe not at the same cost or side effects. <pre data-language="d">import std.algorithm.comparison : equal;
import std.range;
int i = 0;

auto r = iota(0, 4).tee!((a){i = a;}, No.pipeOnPop);
auto r1 = r.take(3).cache();
auto r2 = r.cache().take(3);

assert(equal(r1, [0, 1, 2]));
assert(i == 2); //The last "seen" element was 2. The data in cache has been cleared.

assert(equal(r2, [0, 1, 2]));
assert(i == 3); //cache has accessed 3. It is still stored internally by cache.
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="map">template <strong id="map">map</strong>(fun...) if (fun.length &gt;= 1)</dt> <dd>
<p>Implements the homonym function (also known as <code>transform</code>) present in many languages of functional flavor. The call <code>map!(fun)(range)</code> returns a range of which elements are obtained by applying <code>fun(a)</code> left to right for all elements <code>a</code> in <code>range</code>. The original ranges are not changed. Evaluation is done lazily. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>fun</td> <td>one or more transformation functions</td>
</tr> </table></dd>
</dl> <dl>
<dt>See Also:</dt>
<dd><a href="http://en.wikipedia.org/wiki/Map_(higher-order_function)">Map (higher-order function)</a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.range : chain, only;
auto squares =
    chain(only(1, 2, 3, 4), only(5, 6)).map!(a =&gt; a * a);
assert(equal(squares, only(1, 4, 9, 16, 25, 36)));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Multiple functions can be passed to <code>map</code>. In that case, the element type of <code>map</code> is a tuple containing one element for each function. <pre data-language="d">auto sums = [2, 4, 6, 8];
auto products = [1, 4, 9, 16];

size_t i = 0;
foreach (result; [ 1, 2, 3, 4 ].map!("a + a", "a * a"))
{
    writeln(result[0]); // sums[i]
    writeln(result[1]); // products[i]
    ++i;
}
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>You may alias <code>map</code> with some function(s) to a symbol and use it separately: <pre data-language="d">import std.algorithm.comparison : equal;
import std.conv : to;

alias stringize = map!(to!string);
assert(equal(stringize([ 1, 2, 3, 4 ]), [ "1", "2", "3", "4" ]));
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="map.map">auto <strong id="map">map</strong>(Range)(Range r)<br><small>  Constraints: if (isInputRange!(Unqual!Range)); </small>
</dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>r</code>
</td> <td>an <a href="std_range_primitives.html#isInputRange">input range</a>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A range with each fun applied to all the elements. If there is more than one fun, the element type will be <code>Tuple</code> containing one element for each fun.</dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="each">template <strong id="each">each</strong>(alias fun = "a")</dt> <dd>
<p>Eagerly iterates over <code>r</code> and calls <code>fun</code> over each element. </p>
<p>If no function to call is specified, <code>each</code> defaults to doing nothing but consuming the entire range. <code>r.front</code> will be evaluated, but that can be avoided by specifying a lambda with a <code>lazy</code> parameter. <br><br> <code>each</code> also supports <code>opApply</code>-based types, so it works with e.g. <a href="std_parallelism.html#parallel"><code>std.parallelism.parallel</code></a>. <br><br> Normally the entire range is iterated. If partial iteration (early stopping) is desired, <code>fun</code> needs to return a value of type <a href="std_typecons.html#Flag"><code>std.typecons.Flag</code></a><code>!"each"</code> (<code>Yes.each</code> to continue iteration, or <code>No.each</code> to stop iteration). </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>fun</td> <td>function to apply to each element of the range</td>
</tr> <tr>
<td>Range r</td> <td>range or iterable over which <code>each</code> iterates</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>Yes.each</code> if the entire range was iterated, <code>No.each</code> in case of early stopping. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd><a href="std_range.html#tee"><code>std.range.tee</code></a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.range : iota;
import std.typecons : Flag, Yes, No;

long[] arr;
iota(5).each!(n =&gt; arr ~= n);
writeln(arr); // [0, 1, 2, 3, 4]
iota(5).each!((n) { arr ~= n; return No.each; });
writeln(arr); // [0, 1, 2, 3, 4, 0]

// If the range supports it, the value can be mutated in place
arr.each!((ref n) =&gt; n++);
writeln(arr); // [1, 2, 3, 4, 5, 1]

arr.each!"a++";
writeln(arr); // [2, 3, 4, 5, 6, 2]

// by-ref lambdas are not allowed for non-ref ranges
static assert(!is(typeof(arr.map!(n =&gt; n).each!((ref n) =&gt; n++))));

// The default predicate consumes the range
auto m = arr.map!(n =&gt; n);
(&amp;m).each();
assert(m.empty);

// Indexes are also available for in-place mutations
arr[] = 0;
arr.each!"a=i"();
writeln(arr); // [0, 1, 2, 3, 4, 5]

// opApply iterators work as well
static class S
{
    int x;
    int opApply(scope int delegate(ref int _x) dg) { return dg(x); }
}

auto s = new S;
s.each!"a++";
writeln(s.x); // 1
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<code>each</code> works with iterable objects which provide an index variable, along with each element <pre data-language="d">import std.range : iota, lockstep;

auto arr = [1, 2, 3, 4];

// 1 ref parameter
arr.each!((ref e) =&gt; e = 0);
writeln(arr.sum); // 0

// 1 ref parameter and index
arr.each!((i, ref e) =&gt; e = cast(int) i);
writeln(arr.sum); // 4.iota.sum
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="each.each">Flag!"<strong id="each">each</strong>" <strong id="each">each</strong>(Range)(Range r)<br><small>  Constraints: if (!isForeachIterable!Range &amp;&amp; (isRangeIterable!Range || __traits(compiles, typeof(r.front).length))); </small><br><br>Flag!"<strong id="each">each</strong>" <strong id="each">each</strong>(Iterable)(auto ref Iterable r)<br><small>  Constraints: if (isForeachIterable!Iterable || __traits(compiles, Parameters!(Parameters!(r.opApply)))); </small>
</dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>r</code>
</td> <td>range or iterable over which each iterates</td>
</tr> </table></dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="filter">template <strong id="filter">filter</strong>(alias predicate) if (is(typeof(unaryFun!predicate)))</dt> <dd>
<p>Implements the higher order filter function. The predicate is passed to <a href="std_functional.html#unaryFun"><code>std.functional.unaryFun</code></a>, and can either accept a string, or any callable that can be executed via <code>pred(element)</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>predicate</td> <td>Function to apply to each element of range</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>filter!(predicate)(range)</code> returns a new range containing only elements <code>x</code> in <code>range</code> for which <code>predicate(x)</code> returns <code>true</code>. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd><a href="http://en.wikipedia.org/wiki/Filter_(higher-order_function)">Filter (higher-order function)</a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.math : approxEqual;
import std.range;

int[] arr = [ 1, 2, 3, 4, 5 ];

// Filter below 3
auto small = filter!(a =&gt; a &lt; 3)(arr);
assert(equal(small, [ 1, 2 ]));

// Filter again, but with Uniform Function Call Syntax (UFCS)
auto sum = arr.filter!(a =&gt; a &lt; 3);
assert(equal(sum, [ 1, 2 ]));

// In combination with chain() to span multiple ranges
int[] a = [ 3, -2, 400 ];
int[] b = [ 100, -101, 102 ];
auto r = chain(a, b).filter!(a =&gt; a &gt; 0);
assert(equal(r, [ 3, 400, 100, 102 ]));

// Mixing convertible types is fair game, too
double[] c = [ 2.5, 3.0 ];
auto r1 = chain(c, a, b).filter!(a =&gt; cast(int) a != a);
assert(approxEqual(r1, [ 2.5 ]));
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="filter.filter">auto <strong id="filter">filter</strong>(Range)(Range range)<br><small>  Constraints: if (isInputRange!(Unqual!Range)); </small>
</dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>range</code>
</td> <td>An <a href="std_range_primitives.html#isInputRange">input range</a> of elements</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A range containing only elements <code>x</code> in <code>range</code> for which <code>predicate(x)</code> returns <code>true</code>.</dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="filterBidirectional">template <strong id="filterBidirectional">filterBidirectional</strong>(alias pred)</dt> <dd>
<p>Similar to <code>filter</code>, except it defines a <a href="std_range_primitives.html#isBidirectionalRange">bidirectional range</a>. There is a speed disadvantage - the constructor spends time finding the last element in the range that satisfies the filtering condition (in addition to finding the first one). The advantage is that the filtered range can be spanned from both directions. Also, <a href="std_range.html#retro"><code>std.range.retro</code></a> can be applied against the filtered range. </p>
<p>The predicate is passed to <a href="std_functional.html#unaryFun"><code>std.functional.unaryFun</code></a>, and can either accept a string, or any callable that can be executed via <code>pred(element)</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>pred</td> <td>Function to apply to each element of range</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.range;

int[] arr = [ 1, 2, 3, 4, 5 ];
auto small = filterBidirectional!("a &lt; 3")(arr);
static assert(isBidirectionalRange!(typeof(small)));
writeln(small.back); // 2
assert(equal(small, [ 1, 2 ]));
assert(equal(retro(small), [ 2, 1 ]));
// In combination with chain() to span multiple ranges
int[] a = [ 3, -2, 400 ];
int[] b = [ 100, -101, 102 ];
auto r = filterBidirectional!("a &gt; 0")(chain(a, b));
writeln(r.back); // 102
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="filterBidirectional.filterBidirectional">auto <strong id="filterBidirectional">filterBidirectional</strong>(Range)(Range r)<br><small>  Constraints: if (isBidirectionalRange!(Unqual!Range)); </small>
</dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>r</code>
</td> <td>Bidirectional range of elements</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A range containing only the elements in <code>r</code> for which <code>pred</code> returns <code>true</code>.</dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="group">Group!(pred, Range) <strong id="group">group</strong>(alias pred = "a == b", Range)(Range r); <br><br>struct <strong id="Group">Group</strong>(alias pred, R) if (isInputRange!R); </dt> <dd>
<p>Groups consecutively equivalent elements into a single tuple of the element and the number of its repetitions. </p>
<p>Similarly to <code>uniq</code>, <code>group</code> produces a range that iterates over unique consecutive elements of the given range. Each element of this range is a tuple of the element and the number of times it is repeated in the original range. Equivalence of elements is assessed by using the predicate <code>pred</code>, which defaults to <code>"a == b"</code>. The predicate is passed to <a href="std_functional.html#binaryFun"><code>std.functional.binaryFun</code></a>, and can either accept a string, or any callable that can be executed via <code>pred(element, element)</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>pred</td> <td>Binary predicate for determining equivalence of two elements.</td>
</tr> <tr>
<td>R</td> <td>The range type</td>
</tr> <tr>
<td>Range <code>r</code>
</td> <td>The <a href="std_range_primitives.html#isInputRange">input range</a> to iterate over.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A range of elements of type <code>Tuple!(ElementType!R, uint)</code>, representing each consecutively unique element and its respective number of occurrences in that run. This will be an input range if <code>R</code> is an input range, and a forward range in all other cases. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="#chunkBy"><code>chunkBy</code></a>, which chunks an input range into subranges of equivalent adjacent elements.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.typecons : tuple, Tuple;

int[] arr = [ 1, 2, 2, 2, 2, 3, 4, 4, 4, 5 ];
assert(equal(group(arr), [ tuple(1, 1u), tuple(2, 4u), tuple(3, 1u),
    tuple(4, 3u), tuple(5, 1u) ][]));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Using group, an associative array can be easily generated with the count of each unique element in the range. <pre data-language="d">import std.algorithm.sorting : sort;
import std.array : assocArray;

uint[string] result;
auto range = ["a", "b", "a", "c", "b", "c", "c", "d", "e"];
result = range.sort!((a, b) =&gt; a &lt; b)
    .group
    .assocArray;

writeln(result); // ["a":2U, "b":2U, "c":3U, "d":1U, "e":1U]
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="chunkBy">auto <strong id="chunkBy">chunkBy</strong>(alias pred, Range)(Range r)<br><small>  Constraints: if (isInputRange!Range); </small>
</dt> <dd>
<p>Chunks an input range into subranges of equivalent adjacent elements. In other languages this is often called <code>partitionBy</code>, <code>groupBy</code> or <code>sliceWhen</code>. </p>
<p>Equivalence is defined by the predicate <code>pred</code>, which can be either binary, which is passed to <a href="std_functional.html#binaryFun"><code>std.functional.binaryFun</code></a>, or unary, which is passed to <a href="std_functional.html#unaryFun"><code>std.functional.unaryFun</code></a>. In the binary form, two range elements <code>a</code> and <code>b</code> are considered equivalent if <code>pred(a,b)</code> is true. In unary form, two elements are considered equivalent if <code>pred(a) == pred(b)</code> is true. <br><br> This predicate must be an equivalence relation, that is, it must be reflexive (<code>pred(x,x)</code> is always true), symmetric (<code>pred(x,y) == pred(y,x)</code>), and transitive (<code>pred(x,y) &amp;&amp; pred(y,z)</code> implies <code>pred(x,z)</code>). If this is not the case, the range returned by chunkBy may assert at runtime or behave erratically. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>pred</td> <td>Predicate for determining equivalence.</td>
</tr> <tr>
<td>Range <code>r</code>
</td> <td>An <a href="std_range_primitives.html#isInputRange">input range</a> to be chunked.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>With a binary predicate, a range of ranges is returned in which all elements in a given subrange are equivalent under the given predicate. With a unary predicate, a range of tuples is returned, with the tuple consisting of the result of the unary predicate for each subrange, and the subrange itself. </dd>
</dl> <dl>
<dt>Notes</dt>
<dd> Equivalent elements separated by an intervening non-equivalent element will appear in separate subranges; this function only considers adjacent equivalence. Elements in the subranges will always appear in the same order they appear in the original range. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="#group"><code>group</code></a>, which collapses adjacent equivalent elements into a single element.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Showing usage with binary predicate: <pre data-language="d">import std.algorithm.comparison : equal;

// Grouping by particular attribute of each element:
auto data = [
    [1, 1],
    [1, 2],
    [2, 2],
    [2, 3]
];

auto r1 = data.chunkBy!((a,b) =&gt; a[0] == b[0]);
assert(r1.equal!equal([
    [[1, 1], [1, 2]],
    [[2, 2], [2, 3]]
]));

auto r2 = data.chunkBy!((a,b) =&gt; a[1] == b[1]);
assert(r2.equal!equal([
    [[1, 1]],
    [[1, 2], [2, 2]],
    [[2, 3]]
]));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Showing usage with unary predicate: <pre data-language="d">import std.algorithm.comparison : equal;
import std.range.primitives;
import std.typecons : tuple;

// Grouping by particular attribute of each element:
auto range =
[
    [1, 1],
    [1, 1],
    [1, 2],
    [2, 2],
    [2, 3],
    [2, 3],
    [3, 3]
];

auto byX = chunkBy!(a =&gt; a[0])(range);
auto expected1 =
[
    tuple(1, [[1, 1], [1, 1], [1, 2]]),
    tuple(2, [[2, 2], [2, 3], [2, 3]]),
    tuple(3, [[3, 3]])
];
foreach (e; byX)
{
    assert(!expected1.empty);
    writeln(e[0]); // expected1.front[0]
    assert(e[1].equal(expected1.front[1]));
    expected1.popFront();
}

auto byY = chunkBy!(a =&gt; a[1])(range);
auto expected2 =
[
    tuple(1, [[1, 1], [1, 1]]),
    tuple(2, [[1, 2], [2, 2]]),
    tuple(3, [[2, 3], [2, 3], [3, 3]])
];
foreach (e; byY)
{
    assert(!expected2.empty);
    writeln(e[0]); // expected2.front[0]
    assert(e[1].equal(expected2.front[1]));
    expected2.popFront();
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="joiner">auto <strong id="joiner">joiner</strong>(RoR, Separator)(RoR r, Separator sep)<br><small>  Constraints: if (isInputRange!RoR &amp;&amp; isInputRange!(ElementType!RoR) &amp;&amp; isForwardRange!Separator &amp;&amp; is(ElementType!Separator : ElementType!(ElementType!RoR))); </small><br><br>auto <strong id="joiner">joiner</strong>(RoR)(RoR r)<br><small>  Constraints: if (isInputRange!RoR &amp;&amp; isInputRange!(ElementType!RoR)); </small>
</dt> <dd>
<p>Lazily joins a range of ranges with a separator. The separator itself is a range. If a separator is not provided, then the ranges are joined directly without anything in between them (often called <code>flatten</code> in other languages). </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>RoR <code>r</code>
</td> <td>An <a href="std_range_primitives.html#isInputRange">input range</a> of input ranges to be joined.</td>
</tr> <tr>
<td>Separator <code>sep</code>
</td> <td>A <a href="std_range_primitives.html#isForwardRange">forward range</a> of element(s) to serve as separators in the joined range.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A range of elements in the joined range. This will be a forward range if both outer and inner ranges of <code>RoR</code> are forward ranges; otherwise it will be only an input range. The <a href="std_range_primitives.html#isBidirectionalRange">range bidirectionality</a> is propagated if no separator is specified. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="std_range.html#chain"><code>std.range.chain</code></a>, which chains a sequence of ranges with compatible elements into a single range.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.conv : text;

assert(["abc", "def"].joiner.equal("abcdef"));
assert(["Mary", "has", "a", "little", "lamb"]
    .joiner("...")
    .equal("Mary...has...a...little...lamb"));
assert(["", "abc"].joiner("xyz").equal("xyzabc"));
assert([""].joiner("xyz").equal(""));
assert(["", ""].joiner("xyz").equal("xyz"));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.range : repeat;

assert([""].joiner.equal(""));
assert(["", ""].joiner.equal(""));
assert(["", "abc"].joiner.equal("abc"));
assert(["abc", ""].joiner.equal("abc"));
assert(["abc", "def"].joiner.equal("abcdef"));
assert(["Mary", "has", "a", "little", "lamb"].joiner.equal("Maryhasalittlelamb"));
assert("abc".repeat(3).joiner.equal("abcabcabc"));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>joiner allows in-place mutation! <pre data-language="d">import std.algorithm.comparison : equal;
auto a = [ [1, 2, 3], [42, 43] ];
auto j = joiner(a);
j.front = 44;
writeln(a); // [[44, 2, 3], [42, 43]]
assert(equal(j, [44, 2, 3, 42, 43]));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>insert characters fully lazily into a string <pre data-language="d">import std.algorithm.comparison : equal;
import std.range : chain, cycle, iota, only, retro, take, zip;
import std.format : format;

static immutable number = "12345678";
static immutable delimiter = ",";
auto formatted = number.retro
    .zip(3.iota.cycle.take(number.length))
    .map!(z =&gt; chain(z[0].only, z[1] == 2 ? delimiter : null))
    .joiner
    .retro;
static immutable expected = "12,345,678";
assert(formatted.equal(expected));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>joiner can be bidirectional <pre data-language="d">import std.algorithm.comparison : equal;
import std.range : retro;

auto a = [[1, 2, 3], [4, 5]];
auto j = a.joiner;
j.back = 44;
writeln(a); // [[1, 2, 3], [4, 44]]
assert(equal(j.retro, [44, 4, 3, 2, 1]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="reduce">template <strong id="reduce">reduce</strong>(fun...) if (fun.length &gt;= 1)</dt> <dd>
<p>Implements the homonym function (also known as <code>accumulate</code>, <code>compress</code>, <code>inject</code>, or <code>foldl</code>) present in various programming languages of functional flavor. There is also <a href="#fold"><code>fold</code></a> which does the same thing but with the opposite parameter order. The call <code>reduce!(fun)(seed, range)</code> first assigns <code>seed</code> to an internal variable <code>result</code>, also called the accumulator. Then, for each element <code>x</code> in <code>range</code>, <code>result = fun(result, x)</code> gets evaluated. Finally, <code>result</code> is returned. The one-argument version <code>reduce!(fun)(range)</code> works similarly, but it uses the first element of the range as the seed (the range must be non-empty). </p>
<dl>
<dt>Returns:</dt>
<dd>the accumulated <code>result</code> </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>fun</td> <td>one or more functions</td>
</tr> </table></dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="http://en.wikipedia.org/wiki/Fold_(higher-order_function)">Fold (higher-order function)</a>  <a href="#fold"><code>fold</code></a> is functionally equivalent to <a href="#reduce"><code>reduce</code></a> with the argument order reversed, and without the need to use <a href="std_typecons.html#tuple"><code>tuple</code></a> for multiple seeds. This makes it easier to use in UFCS chains.  <a href="#sum"><code>sum</code></a> is similar to <code>reduce!((a, b) =&gt; a + b)</code> that offers pairwise summing of floating point numbers.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Many aggregate range operations turn out to be solved with <code>reduce</code> quickly and easily. The example below illustrates <code>reduce</code>'s remarkable power and flexibility. <pre data-language="d">import std.algorithm.comparison : max, min;
import std.math : approxEqual;
import std.range;

int[] arr = [ 1, 2, 3, 4, 5 ];
// Sum all elements
auto sum = reduce!((a,b) =&gt; a + b)(0, arr);
writeln(sum); // 15

// Sum again, using a string predicate with "a" and "b"
sum = reduce!"a + b"(0, arr);
writeln(sum); // 15

// Compute the maximum of all elements
auto largest = reduce!(max)(arr);
writeln(largest); // 5

// Max again, but with Uniform Function Call Syntax (UFCS)
largest = arr.reduce!(max);
writeln(largest); // 5

// Compute the number of odd elements
auto odds = reduce!((a,b) =&gt; a + (b &amp; 1))(0, arr);
writeln(odds); // 3

// Compute the sum of squares
auto ssquares = reduce!((a,b) =&gt; a + b * b)(0, arr);
writeln(ssquares); // 55

// Chain multiple ranges into seed
int[] a = [ 3, 4 ];
int[] b = [ 100 ];
auto r = reduce!("a + b")(chain(a, b));
writeln(r); // 107

// Mixing convertible types is fair game, too
double[] c = [ 2.5, 3.0 ];
auto r1 = reduce!("a + b")(chain(a, b, c));
assert(approxEqual(r1, 112.5));

// To minimize nesting of parentheses, Uniform Function Call Syntax can be used
auto r2 = chain(a, b, c).reduce!("a + b");
assert(approxEqual(r2, 112.5));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Sometimes it is very useful to compute multiple aggregates in one pass. One advantage is that the computation is faster because the looping overhead is shared. That's why <code>reduce</code> accepts multiple functions. If two or more functions are passed, <code>reduce</code> returns a <a href="std_typecons.html#Tuple"><code>std.typecons.Tuple</code></a> object with one member per passed-in function. The number of seeds must be correspondingly increased. <pre data-language="d">import std.algorithm.comparison : max, min;
import std.math : approxEqual, sqrt;
import std.typecons : tuple, Tuple;

double[] a = [ 3.0, 4, 7, 11, 3, 2, 5 ];
// Compute minimum and maximum in one pass
auto r = reduce!(min, max)(a);
// The type of r is Tuple!(int, int)
assert(approxEqual(r[0], 2));  // minimum
assert(approxEqual(r[1], 11)); // maximum

// Compute sum and sum of squares in one pass
r = reduce!("a + b", "a + b * b")(tuple(0.0, 0.0), a);
assert(approxEqual(r[0], 35));  // sum
assert(approxEqual(r[1], 233)); // sum of squares
// Compute average and standard deviation from the above
auto avg = r[0] / a.length;
writeln(avg); // 5
auto stdev = sqrt(r[1] / a.length - avg * avg);
writeln(cast(int)stdev); // 2
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="reduce.reduce">auto <strong id="reduce">reduce</strong>(R)(R r)<br><small>  Constraints: if (isIterable!R); </small>
</dt> <dd>
<p>No-seed version. The first element of <code>r</code> is used as the seed's value. </p>
<p>For each function <code>f</code> in <code>fun</code>, the corresponding seed type <code>S</code> is <code>Unqual!(typeof(f(e, e)))</code>, where <code>e</code> is an element of <code>r</code>: <code>ElementType!R</code> for ranges, and <code>ForeachType!R</code> otherwise. <br><br> Once S has been determined, then <code>S s = e;</code> and <code>s = f(s, e);</code> must both be legal. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>r</code>
</td> <td>an iterable value as defined by <code>isIterable</code>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>the final result of the accumulator applied to the iterable </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<code>Exception</code> if <code>r</code> is empty</dd>
</dl> </dd> <dt class="d_decl" id="reduce.reduce.2">auto <strong id="reduce">reduce</strong>(S, R)(S seed, R r)<br><small>  Constraints: if (isIterable!R); </small>
</dt> <dd>
<p>Seed version. The seed should be a single value if <code>fun</code> is a single function. If <code>fun</code> is multiple functions, then <code>seed</code> should be a <a href="std_typecons.html#Tuple"><code>std.typecons.Tuple</code></a>, with one field per function in <code>f</code>. </p>
<p>For convenience, if the seed is const, or has qualified fields, then <code>reduce</code> will operate on an unqualified copy. If this happens then the returned type will not perfectly match <code>S</code>. <br><br> Use <code>fold</code> instead of <code>reduce</code> to use the seed version in a UFCS chain. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>S <code>seed</code>
</td> <td>the initial value of the accumulator</td>
</tr> <tr>
<td>R <code>r</code>
</td> <td>an iterable value as defined by <code>isIterable</code>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>the final result of the accumulator applied to the iterable</dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="fold">template <strong id="fold">fold</strong>(fun...) if (fun.length &gt;= 1)</dt> <dd>
<p>Implements the homonym function (also known as <code>accumulate</code>, <code>compress</code>, <code>inject</code>, or <code>foldl</code>) present in various programming languages of functional flavor. The call <code>fold!(fun)(range, seed)</code> first assigns <code>seed</code> to an internal variable <code>result</code>, also called the accumulator. Then, for each element <code>x</code> in <code>range</code>, <code>result = fun(result, x)</code> gets evaluated. Finally, <code>result</code> is returned. The one-argument version <code>fold!(fun)(range)</code> works similarly, but it uses the first element of the range as the seed (the range must be non-empty). </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>fun</td> <td>the predicate function(s) to apply to the elements</td>
</tr> </table></dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="http://en.wikipedia.org/wiki/Fold_(higher-order_function)">Fold (higher-order function)</a>  <a href="#sum"><code>sum</code></a> is similar to <code>fold!((a, b) =&gt; a + b)</code> that offers precise summing of floating point numbers.  This is functionally equivalent to <a href="#reduce"><code>reduce</code></a> with the argument order reversed, and without the need to use <a href="std_typecons.html#tuple"><code>tuple</code></a> for multiple seeds.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">immutable arr = [1, 2, 3, 4, 5];

// Sum all elements
writeln(arr.fold!((a, b) =&gt; a + b)); // 15

// Sum all elements with explicit seed
writeln(arr.fold!((a, b) =&gt; a + b)(6)); // 21

import std.algorithm.comparison : min, max;
import std.typecons : tuple;

// Compute minimum and maximum at the same time
writeln(arr.fold!(min, max)); // tuple(1, 5)

// Compute minimum and maximum at the same time with seeds
writeln(arr.fold!(min, max)(0, 7)); // tuple(0, 7)

// Can be used in a UFCS chain
writeln(arr.map!(a =&gt; a + 1).fold!((a, b) =&gt; a + b)); // 20

// Return the last element of any range
writeln(arr.fold!((a, b) =&gt; b)); // 5
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="fold.fold">auto <strong id="fold">fold</strong>(R, S...)(R r, S seed); </dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>r</code>
</td> <td>the <a href="std_range_primitives.html#isInputRange">input range</a> to fold</td>
</tr> <tr>
<td>S <code>seed</code>
</td> <td>the initial value of the accumulator</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>the accumulated <code>result</code>
</dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="cumulativeFold">template <strong id="cumulativeFold">cumulativeFold</strong>(fun...) if (fun.length &gt;= 1)</dt> <dd>
<p>Similar to <code>fold</code>, but returns a range containing the successive reduced values. The call <code>cumulativeFold!(fun)(range, seed)</code> first assigns <code>seed</code> to an internal variable <code>result</code>, also called the accumulator. The returned range contains the values <code>result = fun(result, x)</code> lazily evaluated for each element <code>x</code> in <code>range</code>. Finally, the last element has the same value as <code>fold!(fun)(seed, range)</code>. The one-argument version <code>cumulativeFold!(fun)(range)</code> works similarly, but it returns the first element unchanged and uses it as seed for the next elements. This function is also known as <a href="http://en.cppreference.com/w/cpp/algorithm/partial_sum">partial_sum</a>, <a href="http://docs.python.org/3/library/itertools.html#itertools.accumulate">accumulate</a>, <a href="http://hackage.haskell.org/package/base-4.8.2.0/docs/Prelude.html#v:scanl">scan</a>, <a href="http://mathworld.wolfram.com/CumulativeSum.html">Cumulative Sum</a>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>fun</td> <td>one or more functions to use as fold operation</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The function returns a range containing the consecutive reduced values. If there is more than one <code>fun</code>, the element type will be <a href="std_typecons.html#Tuple"><code> std.typecons.Tuple</code></a> containing one element for each <code>fun</code>. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="http://en.wikipedia.org/wiki/Prefix_sum">Prefix Sum</a> </dd>
</dl> <dl>
<dt>Note</dt>
<dd> In functional programming languages this is typically called <code>scan</code>, <code>scanl</code>, <code>scanLeft</code> or <code>reductions</code>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : max, min;
import std.array : array;
import std.math : approxEqual;
import std.range : chain;

int[] arr = [1, 2, 3, 4, 5];
// Partial sum of all elements
auto sum = cumulativeFold!((a, b) =&gt; a + b)(arr, 0);
writeln(sum.array); // [1, 3, 6, 10, 15]

// Partial sum again, using a string predicate with "a" and "b"
auto sum2 = cumulativeFold!"a + b"(arr, 0);
writeln(sum2.array); // [1, 3, 6, 10, 15]

// Compute the partial maximum of all elements
auto largest = cumulativeFold!max(arr);
writeln(largest.array); // [1, 2, 3, 4, 5]

// Partial max again, but with Uniform Function Call Syntax (UFCS)
largest = arr.cumulativeFold!max;
writeln(largest.array); // [1, 2, 3, 4, 5]

// Partial count of odd elements
auto odds = arr.cumulativeFold!((a, b) =&gt; a + (b &amp; 1))(0);
writeln(odds.array); // [1, 1, 2, 2, 3]

// Compute the partial sum of squares
auto ssquares = arr.cumulativeFold!((a, b) =&gt; a + b * b)(0);
writeln(ssquares.array); // [1, 5, 14, 30, 55]

// Chain multiple ranges into seed
int[] a = [3, 4];
int[] b = [100];
auto r = cumulativeFold!"a + b"(chain(a, b));
writeln(r.array); // [3, 7, 107]

// Mixing convertible types is fair game, too
double[] c = [2.5, 3.0];
auto r1 = cumulativeFold!"a + b"(chain(a, b, c));
assert(approxEqual(r1, [3, 7, 107, 109.5, 112.5]));

// To minimize nesting of parentheses, Uniform Function Call Syntax can be used
auto r2 = chain(a, b, c).cumulativeFold!"a + b";
assert(approxEqual(r2, [3, 7, 107, 109.5, 112.5]));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Sometimes it is very useful to compute multiple aggregates in one pass. One advantage is that the computation is faster because the looping overhead is shared. That's why <code>cumulativeFold</code> accepts multiple functions. If two or more functions are passed, <code>cumulativeFold</code> returns a <a href="std_typecons.html#Tuple"><code>std.typecons.Tuple</code></a> object with one member per passed-in function. The number of seeds must be correspondingly increased. <pre data-language="d">import std.algorithm.comparison : max, min;
import std.algorithm.iteration : map;
import std.math : approxEqual;
import std.typecons : tuple;

double[] a = [3.0, 4, 7, 11, 3, 2, 5];
// Compute minimum and maximum in one pass
auto r = a.cumulativeFold!(min, max);
// The type of r is Tuple!(int, int)
assert(approxEqual(r.map!"a[0]", [3, 3, 3, 3, 3, 2, 2]));     // minimum
assert(approxEqual(r.map!"a[1]", [3, 4, 7, 11, 11, 11, 11])); // maximum

// Compute sum and sum of squares in one pass
auto r2 = a.cumulativeFold!("a + b", "a + b * b")(tuple(0.0, 0.0));
assert(approxEqual(r2.map!"a[0]", [3, 7, 14, 25, 28, 30, 35]));      // sum
assert(approxEqual(r2.map!"a[1]", [9, 25, 74, 195, 204, 208, 233])); // sum of squares
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="cumulativeFold.cumulativeFold">auto <strong id="cumulativeFold">cumulativeFold</strong>(R)(R range)<br><small>  Constraints: if (isInputRange!(Unqual!R)); </small>
</dt> <dd>
<p>No-seed version. The first element of <code>r</code> is used as the seed's value. For each function <code>f</code> in <code>fun</code>, the corresponding seed type <code>S</code> is <code>Unqual!(typeof(f(e, e)))</code>, where <code>e</code> is an element of <code>r</code>: <code>ElementType!R</code>. Once <code>S</code> has been determined, then <code>S s = e;</code> and <code>s = f(s, e);</code> must both be legal. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>range</code>
</td> <td>An <a href="std_range_primitives.html#isInputRange">input range</a>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>a range containing the consecutive reduced values.</dd>
</dl> </dd> <dt class="d_decl" id="cumulativeFold.cumulativeFold.2">auto <strong id="cumulativeFold">cumulativeFold</strong>(R, S)(R range, S seed)<br><small>  Constraints: if (isInputRange!(Unqual!R)); </small>
</dt> <dd>
<p>Seed version. The seed should be a single value if <code>fun</code> is a single function. If <code>fun</code> is multiple functions, then <code>seed</code> should be a <a href="std_typecons.html#Tuple"><code>std.typecons.Tuple</code></a>, with one field per function in <code>f</code>. For convenience, if the seed is <code>const</code>, or has qualified fields, then <code>cumulativeFold</code> will operate on an unqualified copy. If this happens then the returned type will not perfectly match <code>S</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>range</code>
</td> <td>An <a href="std_range_primitives.html#isInputRange">input range</a>
</td>
</tr> <tr>
<td>S <code>seed</code>
</td> <td>the initial value of the accumulator</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>a range containing the consecutive reduced values.</dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="splitter">auto <strong id="splitter">splitter</strong>(alias pred = "a == b", Range, Separator)(Range r, Separator s)<br><small>  Constraints: if (is(typeof(binaryFun!pred(r.front, s)) : bool) &amp;&amp; (hasSlicing!Range &amp;&amp; hasLength!Range || isNarrowString!Range)); </small><br><br>auto <strong id="splitter">splitter</strong>(alias pred = "a == b", Range, Separator)(Range r, Separator s)<br><small>  Constraints: if (is(typeof(binaryFun!pred(r.front, s.front)) : bool) &amp;&amp; (hasSlicing!Range || isNarrowString!Range) &amp;&amp; isForwardRange!Separator &amp;&amp; (hasLength!Separator || isNarrowString!Separator)); </small><br><br>auto <strong id="splitter">splitter</strong>(alias isTerminator, Range)(Range r)<br><small>  Constraints: if (isForwardRange!Range &amp;&amp; is(typeof(unaryFun!isTerminator(r.front)))); </small>
</dt> <dd>
<p>Lazily splits a range using an element or range as a separator. Separator ranges can be any narrow string type or sliceable range type. </p>
<p>Two adjacent separators are considered to surround an empty element in the split range. Use <code>filter!(a =&gt; !a.empty)</code> on the result to compress empty elements. <br><br> The predicate is passed to <a href="std_functional.html#binaryFun"><code>std.functional.binaryFun</code></a> and accepts any callable function that can be executed via <code>pred(element, s)</code>. </p> <dl>
<dt>Notes</dt>
<dd> If splitting a string on whitespace and token compression is desired, consider using <code>splitter</code> without specifying a separator. </dd>
</dl> If no separator is passed, the  predicate <code>isTerminator</code> decides whether to accept an element of <code>r</code>.  <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>pred</td> <td>The predicate for comparing each element with the separator, defaulting to <code>"a == b"</code>.</td>
</tr> <tr>
<td>Range <code>r</code>
</td> <td>The <a href="std_range_primitives.html#isInputRange">input range</a> to be split. Must support slicing and <code>.length</code> or be a narrow string type.</td>
</tr> <tr>
<td>Separator <code>s</code>
</td> <td>The element (or range) to be treated as the separator between range segments to be split.</td>
</tr> <tr>
<td>isTerminator</td> <td>The predicate for deciding where to split the range when no separator is passed</td>
</tr> </table></dd>
</dl> <dl>
<dt>Constraints</dt>
<dd> The predicate <code>pred</code> needs to accept an element of <code>r</code> and the separator <code>s</code>. </dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>An input range of the subranges of elements between separators. If <code>r</code> is a <a href="std_range_primitives.html#isForwardRange">forward range</a> or <a href="std_range_primitives.html#isBidirectionalRange">bidirectional range</a>, the returned range will be likewise. When a range is used a separator, bidirectionality isn't possible.  If an empty range is given, the result is an empty range. If a range with one separator is given, the result is a range with two empty elements. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="std_regex.html#splitter"><code>std.regex.splitter</code></a> for a version that splits using a regular expression defined separator and <a href="std_array.html#split"><code>std.array.split</code></a> for a version that splits eagerly.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Basic splitting with characters and numbers. <pre data-language="d">import std.algorithm.comparison : equal;

assert("a|bc|def".splitter('|').equal([ "a", "bc", "def" ]));

int[] a = [1, 0, 2, 3, 0, 4, 5, 6];
int[][] w = [ [1], [2, 3], [4, 5, 6] ];
assert(a.splitter(0).equal(w));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Adjacent separators. <pre data-language="d">import std.algorithm.comparison : equal;

assert("|ab|".splitter('|').equal([ "", "ab", "" ]));
assert("ab".splitter('|').equal([ "ab" ]));

assert("a|b||c".splitter('|').equal([ "a", "b", "", "c" ]));
assert("hello  world".splitter(' ').equal([ "hello", "", "world" ]));

auto a = [ 1, 2, 0, 0, 3, 0, 4, 5, 0 ];
auto w = [ [1, 2], [], [3], [4, 5], [] ];
assert(a.splitter(0).equal(w));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Empty and separator-only ranges. <pre data-language="d">import std.algorithm.comparison : equal;
import std.range : empty;

assert("".splitter('|').empty);
assert("|".splitter('|').equal([ "", "" ]));
assert("||".splitter('|').equal([ "", "", "" ]));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Use a range for splitting <pre data-language="d">import std.algorithm.comparison : equal;

assert("a=&gt;bc=&gt;def".splitter("=&gt;").equal([ "a", "bc", "def" ]));
assert("a|b||c".splitter("||").equal([ "a|b", "c" ]));
assert("hello  world".splitter("  ").equal([ "hello", "world" ]));

int[] a = [ 1, 2, 0, 0, 3, 0, 4, 5, 0 ];
int[][] w = [ [1, 2], [3, 0, 4, 5, 0] ];
assert(a.splitter([0, 0]).equal(w));

a = [ 0, 0 ];
assert(a.splitter([0, 0]).equal([ (int[]).init, (int[]).init ]));

a = [ 0, 0, 1 ];
assert(a.splitter([0, 0]).equal([ [], [1] ]));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Custom predicate functions. <pre data-language="d">import std.algorithm.comparison : equal;
import std.ascii : toLower;

assert("abXcdxef".splitter!"a.toLower == b"('x').equal(
             [ "ab", "cd", "ef" ]));

auto w = [ [0], [1], [2] ];
assert(w.splitter!"a.front == b"(1).equal([ [[0]], [[2]] ]));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Use splitter without a separator <pre data-language="d">import std.algorithm.comparison : equal;
import std.range.primitives : front;

assert(equal(splitter!(a =&gt; a == '|')("a|bc|def"), [ "a", "bc", "def" ]));
assert(equal(splitter!(a =&gt; a == ' ')("hello  world"), [ "hello", "", "world" ]));

int[] a = [ 1, 2, 0, 0, 3, 0, 4, 5, 0 ];
int[][] w = [ [1, 2], [], [3], [4, 5], [] ];
assert(equal(splitter!(a =&gt; a == 0)(a), w));

a = [ 0 ];
assert(equal(splitter!(a =&gt; a == 0)(a), [ (int[]).init, (int[]).init ]));

a = [ 0, 1 ];
assert(equal(splitter!(a =&gt; a == 0)(a), [ [], [1] ]));

w = [ [0], [1], [2] ];
assert(equal(splitter!(a =&gt; a.front == 1)(w), [ [[0]], [[2]] ]));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Leading separators, trailing separators, or no separators. <pre data-language="d">import std.algorithm.comparison : equal;

assert("|ab|".splitter('|').equal([ "", "ab", "" ]));
assert("ab".splitter('|').equal([ "ab" ]));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Splitter returns bidirectional ranges if the delimiter is a single element <pre data-language="d">import std.algorithm.comparison : equal;
import std.range : retro;
assert("a|bc|def".splitter('|').retro.equal([ "def", "bc", "a" ]));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Splitting by word lazily <pre data-language="d">import std.ascii : isWhite;
import std.algorithm.comparison : equal;
import std.algorithm.iteration : splitter;

string str = "Hello World!";
assert(str.splitter!(isWhite).equal(["Hello", "World!"]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="splitter.2">auto <strong id="splitter">splitter</strong>(Range)(Range s)<br><small>  Constraints: if (isSomeString!Range || isRandomAccessRange!Range &amp;&amp; hasLength!Range &amp;&amp; hasSlicing!Range &amp;&amp; !isConvertibleToString!Range &amp;&amp; isSomeChar!(ElementEncodingType!Range)); </small>
</dt> <dd>
<p>Lazily splits the character-based range <code>s</code> into words, using whitespace as the delimiter. </p>
<p>This function is character-range specific and, contrary to <code>splitter!(std.uni.isWhite)</code>, runs of whitespace will be merged together (no empty tokens will be produced). </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>s</code>
</td> <td>The character-based range to be split. Must be a string, or a random-access range of character types.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>An <a href="std_range_primitives.html#isInputRange">input range</a> of slices of the original range split by whitespace.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
auto a = " a     bcd   ef gh ";
assert(equal(splitter(a), ["a", "bcd", "ef", "gh"][]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="substitute">template <strong id="substitute">substitute</strong>(substs...) if (substs.length &gt;= 2 &amp;&amp; isExpressions!substs)<br><br>auto <strong id="substitute">substitute</strong>(alias pred = (a, b) =&gt; a == b, R, Substs...)(R r, Substs substs)<br><small>  Constraints: if (isInputRange!R &amp;&amp; (Substs.length &gt;= 2) &amp;&amp; !is(CommonType!Substs == void)); </small>
</dt> <dd>
<p>Returns a range with all occurrences of <code>substs</code> in <code>r</code>. replaced with their substitution. </p>
<p>Single value replacements (<code>'ö'.substitute!('ä', 'a', 'ö', 'o', 'ü', 'u)</code>) are supported as well and in <span class="bigoh">Ο(<code>1</code>)</span>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>r</code>
</td> <td>an <a href="std_range_primitives.html#isInputRange">input range</a>
</td>
</tr> <tr>
<td>Value value</td> <td>a single value which can be substituted in <span class="bigoh">Ο(<code>1</code>)</span>
</td>
</tr> <tr>
<td>Substs <code>substs</code>
</td> <td>a set of replacements/substitutions</td>
</tr> <tr>
<td>pred</td> <td>the equality function to test if element(s) are equal to a substitution</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>a range with the substitutions replaced. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="std_array.html#replace"><code>std.array.replace</code></a> for an eager replace algorithm or <a href="std_string.html#translate"><code>std.string.translate</code></a>, and <a href="std_string.html#tr"><code>std.string.tr</code></a> for string algorithms with translation tables.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;

// substitute single elements
assert("do_it".substitute('_', ' ').equal("do it"));

// substitute multiple, single elements
assert("do_it".substitute('_', ' ',
                           'd', 'g',
                           'i', 't',
                           't', 'o')
              .equal("go to"));

// substitute subranges
assert("do_it".substitute("_", " ",
                          "do", "done")
              .equal("done it"));

// substitution works for any ElementType
int[] x = [1, 2, 3];
auto y = x.substitute(1, 0.1);
assert(y.equal([0.1, 2, 3]));
static assert(is(typeof(y.front) == double));

import std.range : retro;
assert([1, 2, 3].substitute(1, 0.1).retro.equal([3, 2, 0.1]));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Use the faster compile-time overload <pre data-language="d">import std.algorithm.comparison : equal;

// substitute subranges of a range
assert("apple_tree".substitute!("apple", "banana",
                                "tree", "shrub").equal("banana_shrub"));

// substitute subranges of a range
assert("apple_tree".substitute!('a', 'b',
                                't', 'f').equal("bpple_free"));

// substitute values
writeln('a'.substitute!('a', 'b', 't', 'f')); // 'b'
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Multiple substitutes <pre data-language="d">import std.algorithm.comparison : equal;
import std.range.primitives : ElementType;

int[3] x = [1, 2, 3];
auto y = x[].substitute(1, 0.1)
            .substitute(0.1, 0.2);
static assert(is(typeof(y.front) == double));
assert(y.equal([0.2, 2, 3]));

auto z = "42".substitute('2', '3')
             .substitute('3', '1');
static assert(is(ElementType!(typeof(z)) == dchar));
assert(equal(z, "41"));
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="substitute.substitute">auto <strong id="substitute">substitute</strong>(Value)(Value value)<br><small>  Constraints: if (isInputRange!Value || !is(CommonType!(Value, typeof(substs[0])) == void)); </small>
</dt> <dd>
<p>Substitute single values with compile-time substitution mappings. </p>
<dl>
<dt>Complexity</dt>
<dd> <span class="bigoh">Ο(<code>1</code>)</span> due to D's <code>switch</code> guaranteeing <span class="bigoh">Ο(<code>1</code>)</span>;</dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="sum">auto <strong id="sum">sum</strong>(R)(R r)<br><small>  Constraints: if (isInputRange!R &amp;&amp; !isInfinite!R &amp;&amp; is(typeof(r.front + r.front))); </small><br><br>auto <strong id="sum">sum</strong>(R, E)(R r, E seed)<br><small>  Constraints: if (isInputRange!R &amp;&amp; !isInfinite!R &amp;&amp; is(typeof(seed = seed + r.front))); </small>
</dt> <dd>
<p>Sums elements of <code>r</code>, which must be a finite <a href="std_range_primitives.html#isInputRange">input range</a>. Although conceptually <code>sum(r)</code> is equivalent to <a href="#fold"><code>fold</code></a>!((a, b) =&gt; a + b)(r, 0), <code>sum</code> uses specialized algorithms to maximize accuracy, as follows. </p>
<p><ul>
<li>If <a href="std_range_primitives.html#ElementType"><code>std.range.primitives.ElementType</code></a>!R is a floating-point type and <code>R</code> is a <a href="std_range_primitives.html#isRandomAccessRange">random-access range</a> with length and slicing, then <code>sum</code> uses the <a href="http://en.wikipedia.org/wiki/Pairwise_summation">pairwise summation</a> algorithm.</li> <li>If <code>ElementType!R</code> is a floating-point type and <code>R</code> is a finite input range (but not a random-access range with slicing), then <code>sum</code> uses the <a href="http://en.wikipedia.org/wiki/Kahan_summation">Kahan summation</a> algorithm.</li> <li>In all other cases, a simple element by element addition is done.</li> </ul> <br><br> For floating point inputs, calculations are made in <a href="https://dlang.org/spec/type.html"><code>real</code></a> precision for <code>real</code> inputs and in <code>double</code> precision otherwise (Note this is a special case that deviates from <code>fold</code>'s behavior, which would have kept <code>float</code> precision for a <code>float</code> range). For all other types, the calculations are done in the same type obtained from from adding two elements of the range, which may be a different type from the elements themselves (for example, in case of <a href="https://dlang.org/spec/type.html#integer-promotions">integral promotion</a>). <br><br> A seed may be passed to <code>sum</code>. Not only will this seed be used as an initial value, but its type will override all the above, and determine the algorithm and precision used for summation. If a seed is not passed, one is created with the value of <code>typeof(r.front + r.front)(0)</code>, or <code>typeof(r.front + r.front).zero</code> if no constructor exists that takes an int. <br><br> Note that these specialized summing algorithms execute more primitive operations than vanilla summation. Therefore, if in certain cases maximum speed is required at expense of precision, one can use <code>fold!((a, b) =&gt; a + b)(r, 0)</code>, which is not specialized for summation. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>E <code>seed</code>
</td> <td>the initial value of the summation</td>
</tr> <tr>
<td>R <code>r</code>
</td> <td>a finite input range</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The sum of all the elements in the range r.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Ditto <pre data-language="d">import std.range;

//simple integral sumation
writeln(sum([1, 2, 3, 4])); // 10

//with integral promotion
writeln(sum([false, true, true, false, true])); // 3
writeln(sum(ubyte.max.repeat(100))); // 25500

//The result may overflow
writeln(uint.max.repeat(3).sum()); // 4294967293U
//But a seed can be used to change the sumation primitive
writeln(uint.max.repeat(3).sum(ulong.init)); // 12884901885UL

//Floating point sumation
writeln(sum([1.0, 2.0, 3.0, 4.0])); // 10

//Floating point operations have double precision minimum
static assert(is(typeof(sum([1F, 2F, 3F, 4F])) == double));
writeln(sum([1F, 2, 3, 4])); // 10

//Force pair-wise floating point sumation on large integers
import std.math : approxEqual;
assert(iota(ulong.max / 2, ulong.max / 2 + 4096).sum(0.0)
           .approxEqual((ulong.max / 2) * 4096.0 + 4096^^2 / 2));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="mean">T <strong id="mean">mean</strong>(T = double, R)(R r)<br><small>  Constraints: if (isInputRange!R &amp;&amp; isNumeric!(ElementType!R) &amp;&amp; !isInfinite!R); </small><br><br>auto <strong id="mean">mean</strong>(R, T)(R r, T seed)<br><small>  Constraints: if (isInputRange!R &amp;&amp; !isNumeric!(ElementType!R) &amp;&amp; is(typeof(r.front + seed)) &amp;&amp; is(typeof(r.front / size_t(1))) &amp;&amp; !isInfinite!R); </small>
</dt> <dd>
<p>Finds the mean (colloquially known as the average) of a range. </p>
<p>For built-in numerical types, accurate Knuth &amp; Welford mean calculation is used. For user-defined types, element by element summation is used. Additionally an extra parameter <code>seed</code> is needed in order to correctly seed the summation with the equivalent to <code>0</code>. <br><br> The first overload of this function will return <code>T.init</code> if the range is empty. However, the second overload will return <code>seed</code> on empty ranges. <br><br> This function is <span class="bigoh">Ο(<code>r.length</code>)</span>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T</td> <td>The type of the return value.</td>
</tr> <tr>
<td>R <code>r</code>
</td> <td>An <a href="std_range_primitives.html#isInputRange">input range</a>
</td>
</tr> <tr>
<td>T <code>seed</code>
</td> <td>For user defined types. Should be equivalent to <code>0</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The mean of <code>r</code> when <code>r</code> is non-empty.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.math : approxEqual, isNaN;

static immutable arr1 = [1, 2, 3];
static immutable arr2 = [1.5, 2.5, 12.5];

assert(arr1.mean.approxEqual(2));
assert(arr2.mean.approxEqual(5.5));

assert(arr1[0 .. 0].mean.isNaN);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="uniq">auto <strong id="uniq">uniq</strong>(alias pred = "a == b", Range)(Range r)<br><small>  Constraints: if (isInputRange!Range &amp;&amp; is(typeof(binaryFun!pred(r.front, r.front)) == bool)); </small>
</dt> <dd>
<p>Lazily iterates unique consecutive elements of the given range (functionality akin to the <a href="http://wikipedia.org/wiki/Uniq">uniq</a> system utility). Equivalence of elements is assessed by using the predicate <code>pred</code>, by default <code>"a == b"</code>. The predicate is passed to <a href="std_functional.html#binaryFun"><code>std.functional.binaryFun</code></a>, and can either accept a string, or any callable that can be executed via <code>pred(element, element)</code>. If the given range is bidirectional, <code>uniq</code> also yields a <a href="std_range_primitives.html#isBidirectionalRange">bidirectional range</a>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>pred</td> <td>Predicate for determining equivalence between range elements.</td>
</tr> <tr>
<td>Range <code>r</code>
</td> <td>An <a href="std_range_primitives.html#isInputRange">input range</a> of elements to filter.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>An <a href="std_range_primitives.html#isInputRange">input range</a> of consecutively unique elements in the original range. If <code>r</code> is also a forward range or bidirectional range, the returned range will be likewise.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.algorithm.mutation : copy;

int[] arr = [ 1, 2, 2, 2, 2, 3, 4, 4, 4, 5 ];
assert(equal(uniq(arr), [ 1, 2, 3, 4, 5 ][]));

// Filter duplicates in-place using copy
arr.length -= arr.uniq().copy(arr).length;
writeln(arr); // [1, 2, 3, 4, 5]

// Note that uniqueness is only determined consecutively; duplicated
// elements separated by an intervening different element will not be
// eliminated:
assert(equal(uniq([ 1, 1, 2, 1, 1, 3, 1]), [1, 2, 1, 3, 1]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="permutations">Permutations!Range <strong id="permutations">permutations</strong>(Range)(Range r)<br><small>  Constraints: if (isRandomAccessRange!Range &amp;&amp; hasLength!Range); </small><br><br>struct <strong id="Permutations">Permutations</strong>(Range) if (isRandomAccessRange!Range &amp;&amp; hasLength!Range); </dt> <dd>
<p>Lazily computes all permutations of <code>r</code> using <a href="http://en.wikipedia.org/wiki/Heap%27s_algorithm">Heap's algorithm</a>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range</td> <td>the range type</td>
</tr> <tr>
<td>Range <code>r</code>
</td> <td>the <a href="std_range_primitives.html#isRandomAccessRange">random access range</a> to find the permutations for.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A <a href="std_range_primitives.html#isForwardRange">forward range</a> of elements of which are an <a href="std_range.html#indexed"><code>std.range.indexed</code></a> view into <code>r</code>. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="std_algorithm_sorting.html#nextPermutation"><code>std.algorithm.sorting.nextPermutation</code></a>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.range : iota;
assert(equal!equal(iota(3).permutations,
    [[0, 1, 2],
     [1, 0, 2],
     [2, 0, 1],
     [0, 2, 1],
     [1, 2, 0],
     [2, 1, 0]]));
</pre> </dd>
</dl> </dd> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1999&ndash;2021 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/std_algorithm_iteration.html" class="_attribution-link">https://dlang.org/phobos/std_algorithm_iteration.html</a>
  </p>
</div>
