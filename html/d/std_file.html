<h1>std.file</h1>  <p>Utilities for manipulating files and scanning directories. Functions in this module handle files as a unit, e.g., read or write one file at a time. For opening files and manipulating them via handles refer to module <a href="std_stdio.html"><code>std.stdio</code></a>. </p>
<p> <table>

<tr>
<th scope="col">Category</th> <th scope="col">Functions</th>
</tr> <tr>
<td>General</td> <td> <a href="#exists"><code>exists</code></a> <a href="#isDir"><code>isDir</code></a> <a href="#isFile"><code>isFile</code></a> <a href="#isSymlink"><code>isSymlink</code></a> <a href="#rename"><code>rename</code></a> <a href="#thisExePath"><code>thisExePath</code></a> </td>
</tr> <tr>
<td>Directories</td> <td> <a href="#chdir"><code>chdir</code></a> <a href="#dirEntries"><code>dirEntries</code></a> <a href="#getcwd"><code>getcwd</code></a> <a href="#mkdir"><code>mkdir</code></a> <a href="#mkdirRecurse"><code>mkdirRecurse</code></a> <a href="#rmdir"><code>rmdir</code></a> <a href="#rmdirRecurse"><code>rmdirRecurse</code></a> <a href="#tempDir"><code>tempDir</code></a> </td>
</tr> <tr>
<td>Files</td> <td> <a href="#append"><code>append</code></a> <a href="#copy"><code>copy</code></a> <a href="#read"><code>read</code></a> <a href="#readText"><code>readText</code></a> <a href="#remove"><code>remove</code></a> <a href="#slurp"><code>slurp</code></a> <a href="#write"><code>write</code></a> </td>
</tr> <tr>
<td>Symlinks</td> <td> <a href="#symlink"><code>symlink</code></a> <a href="#readLink"><code>readLink</code></a> </td>
</tr> <tr>
<td>Attributes</td> <td> <a href="#attrIsDir"><code>attrIsDir</code></a> <a href="#attrIsFile"><code>attrIsFile</code></a> <a href="#attrIsSymlink"><code>attrIsSymlink</code></a> <a href="#getAttributes"><code>getAttributes</code></a> <a href="#getLinkAttributes"><code>getLinkAttributes</code></a> <a href="#getSize"><code>getSize</code></a> <a href="#setAttributes"><code>setAttributes</code></a> </td>
</tr> <tr>
<td>Timestamp</td> <td> <a href="#getTimes"><code>getTimes</code></a> <a href="#getTimesWin"><code>getTimesWin</code></a> <a href="#setTimes"><code>setTimes</code></a> <a href="#timeLastModified"><code>timeLastModified</code></a> <a href="#timeLastAccessed"><code>timeLastAccessed</code></a> <a href="#timeStatusChanged"><code>timeStatusChanged</code></a> </td>
</tr> <tr>
<td>Other</td> <td> <a href="#DirEntry"><code>DirEntry</code></a> <a href="#FileException"><code>FileException</code></a> <a href="#PreserveAttributes"><code>PreserveAttributes</code></a> <a href="#SpanMode"><code>SpanMode</code></a> <a href="#getAvailableDiskSpace"><code>getAvailableDiskSpace</code></a> </td>
</tr> </table> <br><br> </p> <dl>
<dt>See Also:</dt>
<dd>The <a href="http://ddili.org/ders/d.en/files.html">official tutorial</a> for an introduction to working with files in D, module <a href="std_stdio.html"><code>std.stdio</code></a> for opening files and manipulating them via handles, and module <a href="std_path.html"><code>std.path</code></a> for manipulating path strings. </dd>
</dl> <dl>
<dt>License:</dt>
<dd>
<a href="http://boost.org/LICENSE_1_0.txt">Boost License 1.0</a>. </dd>
</dl> <dl>
<dt>Authors:</dt>
<dd>
<a href="http://digitalmars.com">Walter Bright</a>, <a href="http://erdani.org">Andrei Alexandrescu</a>, <a href="http://jmdavisprog.com">Jonathan M Davis</a> </dd>
</dl> <dl>
<dt>Source</dt>
<dd> <span class="phobos_src"><a class="https" href="https://github.com/dlang/phobos/blob/master/std/file.d">std/file.d</a></span>
</dd>
</dl> <dl>
<dt class="d_decl" id="FileException">class <strong id="FileException">FileException</strong>: object.Exception; </dt> <dd>
<p>Exception thrown for file I/O errors.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.exception : assertThrown;

assertThrown!FileException("non.existing.file.".readText);
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="FileException.errno">immutable uint <strong id="errno">errno</strong>; </dt> <dd>
<p>OS error code.</p> </dd> <dt class="d_decl" id="FileException.this">pure @safe this(scope const(char)[] name, scope const(char)[] msg, string file = __FILE__, size_t line = __LINE__); </dt> <dd>
<p>Constructor which takes an error message. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(char)[] <code>name</code>
</td> <td>Name of file for which the error occurred.</td>
</tr> <tr>
<td>const(char)[] <code>msg</code>
</td> <td>Message describing the error.</td>
</tr> <tr>
<td>string <code>file</code>
</td> <td>The file where the error occurred.</td>
</tr> <tr>
<td>size_t <code>line</code>
</td> <td>The line where the error occurred.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="FileException.this.2">@trusted this(scope const(char)[] name, uint errno = .errno, string file = __FILE__, size_t line = __LINE__); </dt> <dd>
<p>Constructor which takes the error number (<a href="https://google.com/search?btnI=I%27m+Feeling+Lucky&amp;ie=UTF-8&amp;oe=UTF-8&amp;q=GetLastError">GetLastError</a> in Windows, <span class="d_param">errno</span> in POSIX). </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(char)[] <code>name</code>
</td> <td>Name of file for which the error occurred.</td>
</tr> <tr>
<td>uint <code>errno</code>
</td> <td>The error number.</td>
</tr> <tr>
<td>string <code>file</code>
</td> <td>The file where the error occurred. Defaults to <code>__FILE__</code>.</td>
</tr> <tr>
<td>size_t <code>line</code>
</td> <td>The line where the error occurred. Defaults to <code>__LINE__</code>.</td>
</tr> </table></dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="read">void[] <strong id="read">read</strong>(R)(R name, size_t upTo = size_t.max)<br><small>  Constraints: if (isInputRange!R &amp;&amp; isSomeChar!(ElementEncodingType!R) &amp;&amp; !isInfinite!R &amp;&amp; !isConvertibleToString!R); </small><br><br>void[] <strong id="read">read</strong>(R)(auto ref R name, size_t upTo = size_t.max)<br><small>  Constraints: if (isConvertibleToString!R); </small>
</dt> <dd>
<p>Read entire contents of file <code>name</code> and returns it as an untyped array. If the file size is larger than <code>upTo</code>, only <code>upTo</code> bytes are read. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>name</code>
</td> <td>string or range of characters representing the file name</td>
</tr> <tr>
<td>size_t <code>upTo</code>
</td> <td>if present, the maximum number of bytes to read</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>Untyped array of bytes read. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="#FileException"><code>FileException</code></a> on error.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.utf : byChar;
scope(exit)
{
    assert(exists(deleteme));
    remove(deleteme);
}

std.file.write(deleteme, "1234"); // deleteme is the name of a temporary file
writeln(read(deleteme, 2)); // "12"
writeln(read(deleteme.byChar)); // "1234"
writeln((cast(const(ubyte)[])read(deleteme)).length); // 4
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="readText">S <strong id="readText">readText</strong>(S = string, R)(auto ref R name)<br><small>  Constraints: if (isSomeString!S &amp;&amp; (isInputRange!R &amp;&amp; !isInfinite!R &amp;&amp; isSomeChar!(ElementType!R) || is(StringTypeOf!R))); </small>
</dt> <dd>
<p>Reads and validates (using <a href="std_utf.html#validate"><code>std.utf.validate</code></a>) a text file. S can be an array of any character type. However, no width or endian conversions are performed. So, if the width or endianness of the characters in the given file differ from the width or endianness of the element type of S, then validation will fail. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>S</td> <td>the string type of the file</td>
</tr> <tr>
<td>R <code>name</code>
</td> <td>string or range of characters representing the file name</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>Array of characters read. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="#FileException"><code>FileException</code></a> if there is an error reading the file, <a href="std_utf.html#UTFException"><code>std.utf.UTFException</code></a> on UTF decoding error.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Read file with UTF-8 text. <pre data-language="d">write(deleteme, "abc"); // deleteme is the name of a temporary file
scope(exit) remove(deleteme);
string content = readText(deleteme);
writeln(content); // "abc"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="write">void <strong id="write">write</strong>(R)(R name, const void[] buffer)<br><small>  Constraints: if ((isInputRange!R &amp;&amp; !isInfinite!R &amp;&amp; isSomeChar!(ElementEncodingType!R) || isSomeString!R) &amp;&amp; !isConvertibleToString!R); </small><br><br>void <strong id="write">write</strong>(R)(auto ref R name, const void[] buffer)<br><small>  Constraints: if (isConvertibleToString!R); </small>
</dt> <dd>
<p>Write <code>buffer</code> to file <code>name</code>. </p>
<p>Creates the file if it does not already exist. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>name</code>
</td> <td>string or range of characters representing the file name</td>
</tr> <tr>
<td>void[] <code>buffer</code>
</td> <td>data to be written to file</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="#FileException"><code>FileException</code></a> on error. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd><a href="std_stdio.html#toFile"><code>std.stdio.toFile</code></a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">scope(exit)
{
    assert(exists(deleteme));
    remove(deleteme);
}

int[] a = [ 0, 1, 1, 2, 3, 5, 8 ];
write(deleteme, a); // deleteme is the name of a temporary file
writeln(cast(int[])read(deleteme)); // a
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="append">void <strong id="append">append</strong>(R)(R name, const void[] buffer)<br><small>  Constraints: if ((isInputRange!R &amp;&amp; !isInfinite!R &amp;&amp; isSomeChar!(ElementEncodingType!R) || isSomeString!R) &amp;&amp; !isConvertibleToString!R); </small><br><br>void <strong id="append">append</strong>(R)(auto ref R name, const void[] buffer)<br><small>  Constraints: if (isConvertibleToString!R); </small>
</dt> <dd>
<p>Appends <code>buffer</code> to file <code>name</code>. </p>
<p>Creates the file if it does not already exist. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>name</code>
</td> <td>string or range of characters representing the file name</td>
</tr> <tr>
<td>void[] <code>buffer</code>
</td> <td>data to be appended to file</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="#FileException"><code>FileException</code></a> on error.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">scope(exit)
{
    assert(exists(deleteme));
    remove(deleteme);
}

int[] a = [ 0, 1, 1, 2, 3, 5, 8 ];
write(deleteme, a); // deleteme is the name of a temporary file
int[] b = [ 13, 21 ];
append(deleteme, b);
writeln(cast(int[])read(deleteme)); // a ~ b
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="rename">void <strong id="rename">rename</strong>(RF, RT)(RF from, RT to)<br><small>  Constraints: if ((isInputRange!RF &amp;&amp; !isInfinite!RF &amp;&amp; isSomeChar!(ElementEncodingType!RF) || isSomeString!RF) &amp;&amp; !isConvertibleToString!RF &amp;&amp; (isInputRange!RT &amp;&amp; !isInfinite!RT &amp;&amp; isSomeChar!(ElementEncodingType!RT) || isSomeString!RT) &amp;&amp; !isConvertibleToString!RT); </small><br><br>void <strong id="rename">rename</strong>(RF, RT)(auto ref RF from, auto ref RT to)<br><small>  Constraints: if (isConvertibleToString!RF || isConvertibleToString!RT); </small>
</dt> <dd>
<p>Rename file <code>from</code> to <code>to</code>, moving it between directories if required. If the target file exists, it is overwritten. </p>
<p>It is not possible to rename a file across different mount points or drives. On POSIX, the operation is atomic. That means, if <code>to</code> already exists there will be no time period during the operation where <code>to</code> is missing. See <a href="http://man7.org/linux/man-pages/man2/rename.2.html">manpage for rename</a> for more details. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>RF <code>from</code>
</td> <td>string or range of characters representing the existing file name</td>
</tr> <tr>
<td>RT <code>to</code>
</td> <td>string or range of characters representing the target file name</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="#FileException"><code>FileException</code></a> on error.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto t1 = deleteme, t2 = deleteme~"2";
scope(exit) foreach (t; [t1, t2]) if (t.exists) t.remove();

t1.write("1");
t1.rename(t2);
writeln(t2.readText); // "1"

t1.write("2");
t1.rename(t2);
writeln(t2.readText); // "2"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="remove">void <strong id="remove">remove</strong>(R)(R name)<br><small>  Constraints: if (isInputRange!R &amp;&amp; !isInfinite!R &amp;&amp; isSomeChar!(ElementEncodingType!R) &amp;&amp; !isConvertibleToString!R); </small><br><br>void <strong id="remove">remove</strong>(R)(auto ref R name)<br><small>  Constraints: if (isConvertibleToString!R); </small>
</dt> <dd>
<p>Delete file <code>name</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>name</code>
</td> <td>string or range of characters representing the file name</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="#FileException"><code>FileException</code></a> on error.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.exception : assertThrown;

deleteme.write("Hello");
writeln(deleteme.readText); // "Hello"

deleteme.remove;
assertThrown!FileException(deleteme.readText);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="getSize">ulong <strong id="getSize">getSize</strong>(R)(R name)<br><small>  Constraints: if (isInputRange!R &amp;&amp; !isInfinite!R &amp;&amp; isSomeChar!(ElementEncodingType!R) &amp;&amp; !isConvertibleToString!R); </small><br><br>ulong <strong id="getSize">getSize</strong>(R)(auto ref R name)<br><small>  Constraints: if (isConvertibleToString!R); </small>
</dt> <dd>
<p>Get size of file <code>name</code> in bytes. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>name</code>
</td> <td>string or range of characters representing the file name</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The size of file in bytes. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="#FileException"><code>FileException</code></a> on error (e.g., file not found).</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">scope(exit) deleteme.remove;

// create a file of size 1
write(deleteme, "a");
writeln(getSize(deleteme)); // 1

// create a file of size 3
write(deleteme, "abc");
writeln(getSize(deleteme)); // 3
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="getTimes">void <strong id="getTimes">getTimes</strong>(R)(R name, out SysTime accessTime, out SysTime modificationTime)<br><small>  Constraints: if (isInputRange!R &amp;&amp; !isInfinite!R &amp;&amp; isSomeChar!(ElementEncodingType!R) &amp;&amp; !isConvertibleToString!R); </small><br><br>void <strong id="getTimes">getTimes</strong>(R)(auto ref R name, out SysTime accessTime, out SysTime modificationTime)<br><small>  Constraints: if (isConvertibleToString!R); </small>
</dt> <dd>
<p>Get the access and modified times of file or folder <code>name</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>name</code>
</td> <td>File/Folder name to get times for.</td>
</tr> <tr>
<td>SysTime <code>accessTime</code>
</td> <td>Time the file/folder was last accessed.</td>
</tr> <tr>
<td>SysTime <code>modificationTime</code>
</td> <td>Time the file/folder was last modified.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="#FileException"><code>FileException</code></a> on error.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.datetime : abs, SysTime;

scope(exit) deleteme.remove;
write(deleteme, "a");

SysTime accessTime, modificationTime;

getTimes(deleteme, accessTime, modificationTime);

import std.datetime : Clock, seconds;
auto currTime = Clock.currTime();
enum leeway = 5.seconds;

auto diffAccess = accessTime - currTime;
auto diffModification = modificationTime - currTime;
assert(abs(diffAccess) &lt;= leeway);
assert(abs(diffModification) &lt;= leeway);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="getTimesWin">void <strong id="getTimesWin">getTimesWin</strong>(R)(R name, out SysTime fileCreationTime, out SysTime fileAccessTime, out SysTime fileModificationTime)<br><small>  Constraints: if (isInputRange!R &amp;&amp; !isInfinite!R &amp;&amp; isSomeChar!(ElementEncodingType!R) &amp;&amp; !isConvertibleToString!R); </small>
</dt> <dd>
<p><span class="blue">This function is Windows-Only.</span> </p>
<p>Get creation/access/modified times of file <code>name</code>. <br><br> This is the same as <code>getTimes</code> except that it also gives you the file creation time - which isn't possible on POSIX systems. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>name</code>
</td> <td>File name to get times for.</td>
</tr> <tr>
<td>SysTime <code>fileCreationTime</code>
</td> <td>Time the file was created.</td>
</tr> <tr>
<td>SysTime <code>fileAccessTime</code>
</td> <td>Time the file was last accessed.</td>
</tr> <tr>
<td>SysTime <code>fileModificationTime</code>
</td> <td>Time the file was last modified.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="#FileException"><code>FileException</code></a> on error.</dd>
</dl> </dd> <dt class="d_decl" id="setTimes">void <strong id="setTimes">setTimes</strong>(R)(R name, SysTime accessTime, SysTime modificationTime)<br><small>  Constraints: if (isInputRange!R &amp;&amp; !isInfinite!R &amp;&amp; isSomeChar!(ElementEncodingType!R) &amp;&amp; !isConvertibleToString!R); </small><br><br>void <strong id="setTimes">setTimes</strong>(R)(auto ref R name, SysTime accessTime, SysTime modificationTime)<br><small>  Constraints: if (isConvertibleToString!R); </small>
</dt> <dd>
<p>Set access/modified times of file or folder <code>name</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>name</code>
</td> <td>File/Folder name to get times for.</td>
</tr> <tr>
<td>SysTime <code>accessTime</code>
</td> <td>Time the file/folder was last accessed.</td>
</tr> <tr>
<td>SysTime <code>modificationTime</code>
</td> <td>Time the file/folder was last modified.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="#FileException"><code>FileException</code></a> on error.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.datetime : DateTime, hnsecs, SysTime;

scope(exit) deleteme.remove;
write(deleteme, "a");

SysTime accessTime = SysTime(DateTime(2010, 10, 4, 0, 0, 30));
SysTime modificationTime = SysTime(DateTime(2018, 10, 4, 0, 0, 30));
setTimes(deleteme, accessTime, modificationTime);

SysTime accessTimeResolved, modificationTimeResolved;
getTimes(deleteme, accessTimeResolved, modificationTimeResolved);

writeln(accessTime); // accessTimeResolved
writeln(modificationTime); // modificationTimeResolved
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="timeLastModified">SysTime <strong id="timeLastModified">timeLastModified</strong>(R)(R name)<br><small>  Constraints: if (isInputRange!R &amp;&amp; !isInfinite!R &amp;&amp; isSomeChar!(ElementEncodingType!R) &amp;&amp; !isConvertibleToString!R); </small><br><br>SysTime <strong id="timeLastModified">timeLastModified</strong>(R)(auto ref R name)<br><small>  Constraints: if (isConvertibleToString!R); </small>
</dt> <dd>
<p>Returns the time that the given file was last modified. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>name</code>
</td> <td>the name of the file to check</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A <a href="std_datetime_systime.html#SysTime"><code>std.datetime.systime.SysTime</code></a>. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="#FileException"><code>FileException</code></a> if the given file does not exist.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.datetime : abs, DateTime, hnsecs, SysTime;
scope(exit) deleteme.remove;

import std.datetime : Clock, seconds;
auto currTime = Clock.currTime();
enum leeway = 5.seconds;
deleteme.write("bb");
assert(abs(deleteme.timeLastModified - currTime) &lt;= leeway);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="timeLastModified.2">SysTime <strong id="timeLastModified">timeLastModified</strong>(R)(R name, SysTime returnIfMissing)<br><small>  Constraints: if (isInputRange!R &amp;&amp; !isInfinite!R &amp;&amp; isSomeChar!(ElementEncodingType!R)); </small>
</dt> <dd>
<p>Returns the time that the given file was last modified. If the file does not exist, returns <code>returnIfMissing</code>. </p>
<p>A frequent usage pattern occurs in build automation tools such as <a href="http://gnu.org/software/make">make</a> or <a href="http://%20%20%20%20en.wikipedia.org/wiki/Apache_Ant">ant</a>. To check whether file <code> target</code> must be rebuilt from file <code>source</code> (i.e., <code>target</code> is older than <code>source</code> or does not exist), use the comparison below. The code throws a <a href="#FileException"><code>FileException</code></a> if <code>source</code> does not exist (as it should). On the other hand, the <code>SysTime.min</code> default makes a non-existing <code>target</code> seem infinitely old so the test correctly prompts building it. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>name</code>
</td> <td>The name of the file to get the modification time for.</td>
</tr> <tr>
<td>SysTime <code>returnIfMissing</code>
</td> <td>The time to return if the given file does not exist.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A <a href="std_datetime_systime.html#SysTime"><code>std.datetime.systime.SysTime</code></a>. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">if (source.timeLastModified &gt;= target.timeLastModified(SysTime.min))
{
    // must (re)build
}
else
{
    // target is up-to-date
}
</pre>  <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.datetime : SysTime;

writeln("file.does.not.exist".timeLastModified(SysTime.min)); // SysTime.min

auto source = deleteme ~ "source";
auto target = deleteme ~ "target";
scope(exit) source.remove, target.remove;

source.write(".");
assert(target.timeLastModified(SysTime.min) &lt; source.timeLastModified);
target.write(".");
assert(target.timeLastModified(SysTime.min) &gt;= source.timeLastModified);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="timeLastModified.3">pure nothrow SysTime <strong id="timeLastModified">timeLastModified</strong>()(auto ref stat_t statbuf); </dt> <dd>
<p><span class="blue">This function is POSIX-Only.</span> </p>
<p>Returns the time that the given file was last modified. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>stat_t <code>statbuf</code>
</td> <td>stat_t retrieved from file.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="timeLastAccessed">pure nothrow SysTime <strong id="timeLastAccessed">timeLastAccessed</strong>()(auto ref stat_t statbuf); </dt> <dd>
<p><span class="blue">This function is POSIX-Only.</span> </p>
<p>Returns the time that the given file was last accessed. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>stat_t <code>statbuf</code>
</td> <td>stat_t retrieved from file.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="timeStatusChanged">pure nothrow SysTime <strong id="timeStatusChanged">timeStatusChanged</strong>()(auto ref stat_t statbuf); </dt> <dd>
<p><span class="blue">This function is POSIX-Only.</span> </p>
<p>Returns the time that the given file was last changed. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>stat_t <code>statbuf</code>
</td> <td>stat_t retrieved from file.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="exists">bool <strong id="exists">exists</strong>(R)(R name)<br><small>  Constraints: if (isInputRange!R &amp;&amp; !isInfinite!R &amp;&amp; isSomeChar!(ElementEncodingType!R) &amp;&amp; !isConvertibleToString!R); </small><br><br>bool <strong id="exists">exists</strong>(R)(auto ref R name)<br><small>  Constraints: if (isConvertibleToString!R); </small>
</dt> <dd>
<p>Determine whether the given file (or directory) exists. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>name</code>
</td> <td>string or range of characters representing the file name</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>true if the file name specified as input exists</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto f = deleteme ~ "does.not.exist";
assert(!f.exists);

f.write("hello");
assert(f.exists);

f.remove;
assert(!f.exists);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="getAttributes">uint <strong id="getAttributes">getAttributes</strong>(R)(R name)<br><small>  Constraints: if (isInputRange!R &amp;&amp; !isInfinite!R &amp;&amp; isSomeChar!(ElementEncodingType!R) &amp;&amp; !isConvertibleToString!R); </small><br><br>uint <strong id="getAttributes">getAttributes</strong>(R)(auto ref R name)<br><small>  Constraints: if (isConvertibleToString!R); </small>
</dt> <dd>
<p>Returns the attributes of the given file. </p>
<p>Note that the file attributes on Windows and POSIX systems are completely different. On Windows, they're what is returned by <a href="http://msdn.microsoft.com/en-us/library/aa364944(v=vs.85).aspx"> GetFileAttributes</a>, whereas on POSIX systems, they're the <code>st_mode</code> value which is part of the <code>stat struct</code> gotten by calling the <a href="http://en.wikipedia.org/wiki/Stat_%28Unix%29"><code>stat</code></a> function. <br><br> On POSIX systems, if the given file is a symbolic link, then attributes are the attributes of the file pointed to by the symbolic link. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>name</code>
</td> <td>The file to get the attributes of.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The attributes of the file as a <code>uint</code>. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="#FileException"><code>FileException</code></a> on error.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>getAttributes with a file <pre data-language="d">import std.exception : assertThrown;

auto f = deleteme ~ "file";
scope(exit) f.remove;

assert(!f.exists);
assertThrown!FileException(f.getAttributes);

f.write(".");
auto attributes = f.getAttributes;
assert(!attributes.attrIsDir);
assert(attributes.attrIsFile);
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>getAttributes with a directory <pre data-language="d">import std.exception : assertThrown;

auto dir = deleteme ~ "dir";
scope(exit) dir.rmdir;

assert(!dir.exists);
assertThrown!FileException(dir.getAttributes);

dir.mkdir;
auto attributes = dir.getAttributes;
assert(attributes.attrIsDir);
assert(!attributes.attrIsFile);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="getLinkAttributes">uint <strong id="getLinkAttributes">getLinkAttributes</strong>(R)(R name)<br><small>  Constraints: if (isInputRange!R &amp;&amp; !isInfinite!R &amp;&amp; isSomeChar!(ElementEncodingType!R) &amp;&amp; !isConvertibleToString!R); </small><br><br>uint <strong id="getLinkAttributes">getLinkAttributes</strong>(R)(auto ref R name)<br><small>  Constraints: if (isConvertibleToString!R); </small>
</dt> <dd>
<p>If the given file is a symbolic link, then this returns the attributes of the symbolic link itself rather than file that it points to. If the given file is <i>not</i> a symbolic link, then this function returns the same result as getAttributes. </p>
<p>On Windows, getLinkAttributes is identical to getAttributes. It exists on Windows so that you don't have to special-case code for Windows when dealing with symbolic links. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>name</code>
</td> <td>The file to get the symbolic link attributes of.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>the attributes </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="#FileException"><code>FileException</code></a> on error.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.exception : assertThrown;

auto source = deleteme ~ "source";
auto target = deleteme ~ "target";

assert(!source.exists);
assertThrown!FileException(source.getLinkAttributes);

// symlinking isn't available on Windows
version (Posix)
{
    scope(exit) source.remove, target.remove;

    target.write("target");
    target.symlink(source);
    writeln(source.readText); // "target"
    assert(source.isSymlink);
    assert(source.getLinkAttributes.attrIsSymlink);
}
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>if the file is no symlink, getLinkAttributes behaves like getAttributes <pre data-language="d">import std.exception : assertThrown;

auto f = deleteme ~ "file";
scope(exit) f.remove;

assert(!f.exists);
assertThrown!FileException(f.getLinkAttributes);

f.write(".");
auto attributes = f.getLinkAttributes;
assert(!attributes.attrIsDir);
assert(attributes.attrIsFile);
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>if the file is no symlink, getLinkAttributes behaves like getAttributes <pre data-language="d">import std.exception : assertThrown;

auto dir = deleteme ~ "dir";
scope(exit) dir.rmdir;

assert(!dir.exists);
assertThrown!FileException(dir.getLinkAttributes);

dir.mkdir;
auto attributes = dir.getLinkAttributes;
assert(attributes.attrIsDir);
assert(!attributes.attrIsFile);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="setAttributes">void <strong id="setAttributes">setAttributes</strong>(R)(R name, uint attributes)<br><small>  Constraints: if (isInputRange!R &amp;&amp; !isInfinite!R &amp;&amp; isSomeChar!(ElementEncodingType!R) &amp;&amp; !isConvertibleToString!R); </small><br><br>void <strong id="setAttributes">setAttributes</strong>(R)(auto ref R name, uint attributes)<br><small>  Constraints: if (isConvertibleToString!R); </small>
</dt> <dd>
<p>Set the attributes of the given file. </p>
<p>For example, a programmatic equivalent of Unix's <code>chmod +x name</code> to make a file executable is <code>name.setAttributes(name.getAttributes | octal!700)</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>name</code>
</td> <td>the file name</td>
</tr> <tr>
<td>uint <code>attributes</code>
</td> <td>the attributes to set the file to</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="#FileException"><code>FileException</code></a> if the given file does not exist.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>setAttributes with a file <pre data-language="d">import std.exception : assertThrown;
import std.conv : octal;

auto f = deleteme ~ "file";
version (Posix)
{
    scope(exit) f.remove;

    assert(!f.exists);
    assertThrown!FileException(f.setAttributes(octal!777));

    f.write(".");
    auto attributes = f.getAttributes;
    assert(!attributes.attrIsDir);
    assert(attributes.attrIsFile);

    f.setAttributes(octal!777);
    attributes = f.getAttributes;

    writeln((attributes &amp; 1023)); // octal!777
}
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>setAttributes with a directory <pre data-language="d">import std.exception : assertThrown;
import std.conv : octal;

auto dir = deleteme ~ "dir";
version (Posix)
{
    scope(exit) dir.rmdir;

    assert(!dir.exists);
    assertThrown!FileException(dir.setAttributes(octal!777));

    dir.mkdir;
    auto attributes = dir.getAttributes;
    assert(attributes.attrIsDir);
    assert(!attributes.attrIsFile);

    dir.setAttributes(octal!777);
    attributes = dir.getAttributes;

    writeln((attributes &amp; 1023)); // octal!777
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isDir">@property bool <strong id="isDir">isDir</strong>(R)(R name)<br><small>  Constraints: if (isInputRange!R &amp;&amp; !isInfinite!R &amp;&amp; isSomeChar!(ElementEncodingType!R) &amp;&amp; !isConvertibleToString!R); </small><br><br>@property bool <strong id="isDir">isDir</strong>(R)(auto ref R name)<br><small>  Constraints: if (isConvertibleToString!R); </small>
</dt> <dd>
<p>Returns whether the given file is a directory. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>name</code>
</td> <td>The path to the file.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>true if name specifies a directory </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="#FileException"><code>FileException</code></a> if the given file does not exist.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.exception : assertThrown;

auto dir = deleteme ~ "dir";
auto f = deleteme ~ "f";
scope(exit) dir.rmdir, f.remove;

assert(!dir.exists);
assertThrown!FileException(dir.isDir);

dir.mkdir;
assert(dir.isDir);

f.write(".");
assert(!f.isDir);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="attrIsDir">pure nothrow @nogc @safe bool <strong id="attrIsDir">attrIsDir</strong>(uint attributes); </dt> <dd>
<p>Returns whether the given file attributes are for a directory. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>uint <code>attributes</code>
</td> <td>The file attributes.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>true if attributes specifies a directory</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.exception : assertThrown;

auto dir = deleteme ~ "dir";
auto f = deleteme ~ "f";
scope(exit) dir.rmdir, f.remove;

assert(!dir.exists);
assertThrown!FileException(dir.getAttributes.attrIsDir);

dir.mkdir;
assert(dir.isDir);
assert(dir.getAttributes.attrIsDir);

f.write(".");
assert(!f.isDir);
assert(!f.getAttributes.attrIsDir);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isFile">@property bool <strong id="isFile">isFile</strong>(R)(R name)<br><small>  Constraints: if (isInputRange!R &amp;&amp; !isInfinite!R &amp;&amp; isSomeChar!(ElementEncodingType!R) &amp;&amp; !isConvertibleToString!R); </small><br><br>@property bool <strong id="isFile">isFile</strong>(R)(auto ref R name)<br><small>  Constraints: if (isConvertibleToString!R); </small>
</dt> <dd>
<p>Returns whether the given file (or directory) is a file. </p>
<p>On Windows, if a file is not a directory, then it's a file. So, either <code>isFile</code> or <code>isDir</code> will return true for any given file. <br><br> On POSIX systems, if <code>isFile</code> is <code>true</code>, that indicates that the file is a regular file (e.g. not a block not device). So, on POSIX systems, it's possible for both <code>isFile</code> and <code>isDir</code> to be <code>false</code> for a particular file (in which case, it's a special file). You can use <code>getAttributes</code> to get the attributes to figure out what type of special it is, or you can use <code>DirEntry</code> to get at its <code>statBuf</code>, which is the result from <code>stat</code>. In either case, see the man page for <code>stat</code> for more information. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>name</code>
</td> <td>The path to the file.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>true if name specifies a file </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="#FileException"><code>FileException</code></a> if the given file does not exist.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.exception : assertThrown;

auto dir = deleteme ~ "dir";
auto f = deleteme ~ "f";
scope(exit) dir.rmdir, f.remove;

dir.mkdir;
assert(!dir.isFile);

assert(!f.exists);
assertThrown!FileException(f.isFile);

f.write(".");
assert(f.isFile);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="attrIsFile">pure nothrow @nogc @safe bool <strong id="attrIsFile">attrIsFile</strong>(uint attributes); </dt> <dd>
<p>Returns whether the given file attributes are for a file. </p>
<p>On Windows, if a file is not a directory, it's a file. So, either <code>attrIsFile</code> or <code>attrIsDir</code> will return <code>true</code> for the attributes of any given file. <br><br> On POSIX systems, if <code>attrIsFile</code> is <code>true</code>, that indicates that the file is a regular file (e.g. not a block not device). So, on POSIX systems, it's possible for both <code>attrIsFile</code> and <code>attrIsDir</code> to be <code>false</code> for a particular file (in which case, it's a special file). If a file is a special file, you can use the attributes to check what type of special file it is (see the man page for <code>stat</code> for more information). </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>uint <code>attributes</code>
</td> <td>The file attributes.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>true if the given file attributes are for a file </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(attrIsFile(getAttributes("/etc/fonts/fonts.conf")));
assert(attrIsFile(getLinkAttributes("/etc/fonts/fonts.conf")));
</pre>  <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.exception : assertThrown;

auto dir = deleteme ~ "dir";
auto f = deleteme ~ "f";
scope(exit) dir.rmdir, f.remove;

dir.mkdir;
assert(!dir.isFile);
assert(!dir.getAttributes.attrIsFile);

assert(!f.exists);
assertThrown!FileException(f.getAttributes.attrIsFile);

f.write(".");
assert(f.isFile);
assert(f.getAttributes.attrIsFile);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isSymlink">@property bool <strong id="isSymlink">isSymlink</strong>(R)(R name)<br><small>  Constraints: if (isInputRange!R &amp;&amp; !isInfinite!R &amp;&amp; isSomeChar!(ElementEncodingType!R) &amp;&amp; !isConvertibleToString!R); </small><br><br>@property bool <strong id="isSymlink">isSymlink</strong>(R)(auto ref R name)<br><small>  Constraints: if (isConvertibleToString!R); </small>
</dt> <dd>
<p>Returns whether the given file is a symbolic link. </p>
<p>On Windows, returns <code>true</code> when the file is either a symbolic link or a junction point. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>name</code>
</td> <td>The path to the file.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>true if name is a symbolic link </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="#FileException"><code>FileException</code></a> if the given file does not exist.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.exception : assertThrown;

auto source = deleteme ~ "source";
auto target = deleteme ~ "target";

assert(!source.exists);
assertThrown!FileException(source.isSymlink);

// symlinking isn't available on Windows
version (Posix)
{
    scope(exit) source.remove, target.remove;

    target.write("target");
    target.symlink(source);
    writeln(source.readText); // "target"
    assert(source.isSymlink);
    assert(source.getLinkAttributes.attrIsSymlink);
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="attrIsSymlink">pure nothrow @nogc @safe bool <strong id="attrIsSymlink">attrIsSymlink</strong>(uint attributes); </dt> <dd>
<p>Returns whether the given file attributes are for a symbolic link. </p>
<p>On Windows, return <code>true</code> when the file is either a symbolic link or a junction point. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>uint <code>attributes</code>
</td> <td>The file attributes.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>true if attributes are for a symbolic link </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">core.sys.posix.unistd.symlink("/etc/fonts/fonts.conf", "/tmp/alink");

assert(!getAttributes("/tmp/alink").isSymlink);
assert(getLinkAttributes("/tmp/alink").isSymlink);
</pre>  <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.exception : assertThrown;

auto source = deleteme ~ "source";
auto target = deleteme ~ "target";

assert(!source.exists);
assertThrown!FileException(source.getLinkAttributes.attrIsSymlink);

// symlinking isn't available on Windows
version (Posix)
{
    scope(exit) source.remove, target.remove;

    target.write("target");
    target.symlink(source);
    writeln(source.readText); // "target"
    assert(source.isSymlink);
    assert(source.getLinkAttributes.attrIsSymlink);
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="chdir">void <strong id="chdir">chdir</strong>(R)(R pathname)<br><small>  Constraints: if (isInputRange!R &amp;&amp; !isInfinite!R &amp;&amp; isSomeChar!(ElementEncodingType!R) &amp;&amp; !isConvertibleToString!R); </small><br><br>void <strong id="chdir">chdir</strong>(R)(auto ref R pathname)<br><small>  Constraints: if (isConvertibleToString!R); </small>
</dt> <dd>
<p>Change directory to <code>pathname</code>. Equivalent to <code>cd</code> on Windows and POSIX. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>pathname</code>
</td> <td>the directory to step into</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="#FileException"><code>FileException</code></a> on error.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.path : buildPath;

auto cwd = getcwd;
auto dir = deleteme ~ "dir";
dir.mkdir;
scope(exit) cwd.chdir, dir.rmdirRecurse;

dir.buildPath("a").write(".");
dir.chdir; // step into dir
"b".write(".");
dirEntries(".", SpanMode.shallow).equal(
    [".".buildPath("b"), ".".buildPath("a")]
);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="mkdir">void <strong id="mkdir">mkdir</strong>(R)(R pathname)<br><small>  Constraints: if (isInputRange!R &amp;&amp; !isInfinite!R &amp;&amp; isSomeChar!(ElementEncodingType!R) &amp;&amp; !isConvertibleToString!R); </small><br><br>void <strong id="mkdir">mkdir</strong>(R)(auto ref R pathname)<br><small>  Constraints: if (isConvertibleToString!R); </small>
</dt> <dd>
<p>Make a new directory <code>pathname</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>pathname</code>
</td> <td>the path of the directory to make</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="#FileException"><code>FileException</code></a> on POSIX or <a href="#WindowsException"><code>WindowsException</code></a> on Windows if an error occured.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.file : mkdir;

auto dir = deleteme ~ "dir";
scope(exit) dir.rmdir;

dir.mkdir;
assert(dir.exists);
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.exception : assertThrown;
assertThrown("a/b/c/d/e".mkdir);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="mkdirRecurse">@safe void <strong id="mkdirRecurse">mkdirRecurse</strong>(scope const(char)[] pathname); </dt> <dd>
<p>Make directory and all parent directories as needed. </p>
<p>Does nothing if the directory specified by <code>pathname</code> already exists. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(char)[] <code>pathname</code>
</td> <td>the full path of the directory to create</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="#FileException"><code>FileException</code></a> on error.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.path : buildPath;

auto dir = deleteme ~ "dir";
scope(exit) dir.rmdirRecurse;

dir.mkdir;
assert(dir.exists);
dir.mkdirRecurse; // does nothing

// creates all parent directories as needed
auto nested = dir.buildPath("a", "b", "c");
nested.mkdirRecurse;
assert(nested.exists);
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.exception : assertThrown;

scope(exit) deleteme.remove;
deleteme.write("a");

// cannot make directory as it's already a file
assertThrown!FileException(deleteme.mkdirRecurse);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="rmdir">void <strong id="rmdir">rmdir</strong>(R)(R pathname)<br><small>  Constraints: if (isInputRange!R &amp;&amp; !isInfinite!R &amp;&amp; isSomeChar!(ElementEncodingType!R) &amp;&amp; !isConvertibleToString!R); </small><br><br>void <strong id="rmdir">rmdir</strong>(R)(auto ref R pathname)<br><small>  Constraints: if (isConvertibleToString!R); </small>
</dt> <dd>
<p>Remove directory <code>pathname</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>pathname</code>
</td> <td>Range or string specifying the directory name</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="#FileException"><code>FileException</code></a> on error.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto dir = deleteme ~ "dir";

dir.mkdir;
assert(dir.exists);
dir.rmdir;
assert(!dir.exists);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="symlink">void <strong id="symlink">symlink</strong>(RO, RL)(RO original, RL link)<br><small>  Constraints: if ((isInputRange!RO &amp;&amp; !isInfinite!RO &amp;&amp; isSomeChar!(ElementEncodingType!RO) || isConvertibleToString!RO) &amp;&amp; (isInputRange!RL &amp;&amp; !isInfinite!RL &amp;&amp; isSomeChar!(ElementEncodingType!RL) || isConvertibleToString!RL)); </small>
</dt> <dd>
<p><span class="blue">This function is POSIX-Only.</span> </p>
<p>Creates a symbolic link (symlink). </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>RO <code>original</code>
</td> <td>The file that is being linked. This is the target path that's stored in the symlink. A relative path is relative to the created symlink.</td>
</tr> <tr>
<td>RL <code>link</code>
</td> <td>The symlink to create. A relative path is relative to the current working directory.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="#FileException"><code>FileException</code></a> on error (which includes if the symlink already exists).</dd>
</dl> </dd> <dt class="d_decl" id="readLink">string <strong id="readLink">readLink</strong>(R)(R link)<br><small>  Constraints: if (isInputRange!R &amp;&amp; !isInfinite!R &amp;&amp; isSomeChar!(ElementEncodingType!R) || isConvertibleToString!R); </small>
</dt> <dd>
<p><span class="blue">This function is POSIX-Only.</span> </p>
<p>Returns the path to the file pointed to by a symlink. Note that the path could be either relative or absolute depending on the symlink. If the path is relative, it's relative to the symlink, not the current working directory. </p> <dl>
<dt>Throws:</dt>
<dd>
<a href="#FileException"><code>FileException</code></a> on error.</dd>
</dl> </dd> <dt class="d_decl" id="getcwd">@trusted string <strong id="getcwd">getcwd</strong>(); </dt> <dd>
<p>Get the current working directory. </p>
<dl>
<dt>Throws:</dt>
<dd>
<a href="#FileException"><code>FileException</code></a> on error.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto s = getcwd();
assert(s.length);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="thisExePath">@trusted string <strong id="thisExePath">thisExePath</strong>(); </dt> <dd>
<p>Returns the full path of the current executable. </p>
<dl>
<dt>Returns:</dt>
<dd>The path of the executable as a <code>string</code>. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd><a href="object.html#Exception"><code>Exception</code></a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.path : isAbsolute;
auto path = thisExePath();

assert(path.exists);
assert(path.isAbsolute);
assert(path.isFile);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="DirEntry">struct <strong id="DirEntry">DirEntry</strong>; </dt> <dd>
<p>Info on a file, similar to what you'd get from stat on a POSIX system.</p> <dl>
<dt class="d_decl" id="DirEntry.this">@safe this(string path); </dt> <dd>
<p>Constructs a <code>DirEntry</code> for the given file (or directory). </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>string <code>path</code>
</td> <td>The file (or directory) to get a DirEntry for.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="#FileException"><code>FileException</code></a> if the file does not exist.</dd>
</dl> </dd> <dt class="d_decl" id="DirEntry.name">const @property @safe string <strong id="name">name</strong>(); </dt> <dd>
<p>Returns the path to the file represented by this <code>DirEntry</code>. </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto de1 = DirEntry("/etc/fonts/fonts.conf");
assert(de1.name == "/etc/fonts/fonts.conf");

auto de2 = DirEntry("/usr/share/include");
assert(de2.name == "/usr/share/include");
</pre>  </dd> <dt class="d_decl" id="DirEntry.isDir">@property @safe bool <strong id="isDir">isDir</strong>(); </dt> <dd>
<p>Returns whether the file represented by this <code>DirEntry</code> is a directory. </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto de1 = DirEntry("/etc/fonts/fonts.conf");
assert(!de1.isDir);

auto de2 = DirEntry("/usr/share/include");
assert(de2.isDir);
</pre>  </dd> <dt class="d_decl" id="DirEntry.isFile">@property @safe bool <strong id="isFile">isFile</strong>(); </dt> <dd>
<p>Returns whether the file represented by this <code>DirEntry</code> is a file. </p>
<p>On Windows, if a file is not a directory, then it's a file. So, either <code>isFile</code> or <code>isDir</code> will return <code>true</code>. <br><br> On POSIX systems, if <code>isFile</code> is <code>true</code>, that indicates that the file is a regular file (e.g. not a block not device). So, on POSIX systems, it's possible for both <code>isFile</code> and <code>isDir</code> to be <code>false</code> for a particular file (in which case, it's a special file). You can use <code>attributes</code> or <code>statBuf</code> to get more information about a special file (see the stat man page for more details). </p> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto de1 = DirEntry("/etc/fonts/fonts.conf");
assert(de1.isFile);

auto de2 = DirEntry("/usr/share/include");
assert(!de2.isFile);
</pre>  </dd> <dt class="d_decl" id="DirEntry.isSymlink">@property @safe bool <strong id="isSymlink">isSymlink</strong>(); </dt> <dd>
<p>Returns whether the file represented by this <code>DirEntry</code> is a symbolic link. </p>
<p>On Windows, return <code>true</code> when the file is either a symbolic link or a junction point.</p> </dd> <dt class="d_decl" id="DirEntry.size">@property @safe ulong <strong id="size">size</strong>(); </dt> <dd>
<p>Returns the size of the the file represented by this <code>DirEntry</code> in bytes.</p> </dd> <dt class="d_decl" id="DirEntry.timeCreated">const @property @safe SysTime <strong id="timeCreated">timeCreated</strong>(); </dt> <dd>
<p><span class="blue">This function is Windows-Only.</span> </p>
<p>Returns the creation time of the file represented by this <code>DirEntry</code>.</p> </dd> <dt class="d_decl" id="DirEntry.timeLastAccessed">@property @safe SysTime <strong id="timeLastAccessed">timeLastAccessed</strong>(); </dt> <dd>
<p>Returns the time that the file represented by this <code>DirEntry</code> was last accessed. </p>
<p>Note that many file systems do not update the access time for files (generally for performance reasons), so there's a good chance that <code>timeLastAccessed</code> will return the same value as <code>timeLastModified</code>.</p> </dd> <dt class="d_decl" id="DirEntry.timeLastModified">@property @safe SysTime <strong id="timeLastModified">timeLastModified</strong>(); </dt> <dd>
<p>Returns the time that the file represented by this <code>DirEntry</code> was last modified.</p> </dd> <dt class="d_decl" id="DirEntry.timeStatusChanged">const @property @safe SysTime <strong id="timeStatusChanged">timeStatusChanged</strong>(); </dt> <dd>
<p><span class="blue">This function is POSIX-Only.</span> </p>
<p>Returns the time that the file represented by this <code>DirEntry</code> was last changed (not only in contents, but also in permissions or ownership).</p> </dd> <dt class="d_decl" id="DirEntry.attributes">@property @safe uint <strong id="attributes">attributes</strong>(); </dt> <dd>
<p>Returns the attributes of the file represented by this <code>DirEntry</code>. </p>
<p>Note that the file attributes on Windows and POSIX systems are completely different. On, Windows, they're what is returned by <code>GetFileAttributes</code> <a href="http://msdn.microsoft.com/en-us/library/aa364944(v=vs.85).aspx">GetFileAttributes</a> Whereas, an POSIX systems, they're the <code>st_mode</code> value which is part of the <code>stat</code> struct gotten by calling <code>stat</code>. <br><br> On POSIX systems, if the file represented by this <code>DirEntry</code> is a symbolic link, then attributes are the attributes of the file pointed to by the symbolic link.</p> </dd> <dt class="d_decl" id="DirEntry.linkAttributes">@property @safe uint <strong id="linkAttributes">linkAttributes</strong>(); </dt> <dd>
<p>On POSIX systems, if the file represented by this <code>DirEntry</code> is a symbolic link, then <code>linkAttributes</code> are the attributes of the symbolic link itself. Otherwise, <code>linkAttributes</code> is identical to <code>attributes</code>. </p>
<p>On Windows, <code>linkAttributes</code> is identical to <code>attributes</code>. It exists on Windows so that you don't have to special-case code for Windows when dealing with symbolic links.</p> </dd> <dt class="d_decl" id="DirEntry.statBuf">@property @safe stat_t <strong id="statBuf">statBuf</strong>(); </dt> <dd>
<p><span class="blue">This function is POSIX-Only.</span> </p>
<p>The <code>stat</code> struct gotten from calling <code>stat</code>.</p> </dd> </dl> </dd> <dt class="d_decl" id="preserveAttributesDefault">PreserveAttributes <strong id="preserveAttributesDefault">preserveAttributesDefault</strong>; </dt> <dd>
<p>Defaults to <code>Yes.preserveAttributes</code> on Windows, and the opposite on all other platforms.</p> </dd> <dt class="d_decl" id="copy">void <strong id="copy">copy</strong>(RF, RT)(RF from, RT to, PreserveAttributes preserve = preserveAttributesDefault)<br><small>  Constraints: if (isInputRange!RF &amp;&amp; !isInfinite!RF &amp;&amp; isSomeChar!(ElementEncodingType!RF) &amp;&amp; !isConvertibleToString!RF &amp;&amp; isInputRange!RT &amp;&amp; !isInfinite!RT &amp;&amp; isSomeChar!(ElementEncodingType!RT) &amp;&amp; !isConvertibleToString!RT); </small><br><br>void <strong id="copy">copy</strong>(RF, RT)(auto ref RF from, auto ref RT to, PreserveAttributes preserve = preserveAttributesDefault)<br><small>  Constraints: if (isConvertibleToString!RF || isConvertibleToString!RT); </small>
</dt> <dd>
<p>Copy file <code>from</code> to file <code>to</code>. File timestamps are preserved. File attributes are preserved, if <code>preserve</code> equals <code>Yes.preserveAttributes</code>. On Windows only <code>Yes.preserveAttributes</code> (the default on Windows) is supported. If the target file exists, it is overwritten. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>RF <code>from</code>
</td> <td>string or range of characters representing the existing file name</td>
</tr> <tr>
<td>RT <code>to</code>
</td> <td>string or range of characters representing the target file name</td>
</tr> <tr>
<td>PreserveAttributes <code>preserve</code>
</td> <td>whether to preserve the file attributes</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="#FileException"><code>FileException</code></a> on error.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto source = deleteme ~ "source";
auto target = deleteme ~ "target";
auto targetNonExistent = deleteme ~ "target2";

scope(exit) source.remove, target.remove, targetNonExistent.remove;

source.write("source");
target.write("target");

writeln(target.readText); // "target"

source.copy(target);
writeln(target.readText); // "source"

source.copy(targetNonExistent);
writeln(targetNonExistent.readText); // "source"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="rmdirRecurse">@safe void <strong id="rmdirRecurse">rmdirRecurse</strong>(scope const(char)[] pathname); <br><br>@safe void <strong id="rmdirRecurse">rmdirRecurse</strong>(ref DirEntry de); <br><br>@safe void <strong id="rmdirRecurse">rmdirRecurse</strong>(DirEntry de); </dt> <dd>
<p>Remove directory and all of its content and subdirectories, recursively. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(char)[] <code>pathname</code>
</td> <td>the path of the directory to completely remove</td>
</tr> <tr>
<td>DirEntry <code>de</code>
</td> <td>The <a href="#DirEntry"><code>DirEntry</code></a> to remove</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="#FileException"><code>FileException</code></a> if there is an error (including if the given file is not a directory).</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.path : buildPath;

auto dir = deleteme.buildPath("a", "b", "c");

dir.mkdirRecurse;
assert(dir.exists);

deleteme.rmdirRecurse;
assert(!dir.exists);
assert(!deleteme.exists);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="SpanMode">enum <strong id="SpanMode">SpanMode</strong>: int; </dt> <dd>
<p>Dictates directory spanning policy for <span class="d_param">dirEntries</span> (see below).</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.algorithm.iteration : map;
import std.path : buildPath, relativePath;

auto root = deleteme ~ "root";
scope(exit) root.rmdirRecurse;
root.mkdir;

root.buildPath("animals").mkdir;
root.buildPath("animals", "cat").mkdir;
root.buildPath("animals", "dog").mkdir;
root.buildPath("plants").mkdir;

alias removeRoot = (e) =&gt; e.relativePath(root);

root.dirEntries(SpanMode.shallow).map!removeRoot.equal(
    ["plants", "animals"]);

root.dirEntries(SpanMode.depth).map!removeRoot.equal(
    ["plants", "animals/dog", "animals/cat", "animals"]);

root.dirEntries(SpanMode.breadth).map!removeRoot.equal(
    ["plants", "animals", "animals/dog", "animals/cat"]);
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="SpanMode.shallow"><strong id="shallow">shallow</strong></dt> <dd>
<p>Only spans one directory.</p> </dd> <dt class="d_decl" id="SpanMode.depth"><strong id="depth">depth</strong></dt> <dd>
<p>Spans the directory in <a href="https://en.wikipedia.org/wiki/Tree_traversal#Post-order"> depth-first <b>post</b>-order</a>, i.e. the content of any subdirectory is spanned before that subdirectory itself. Useful e.g. when recursively deleting files.</p> </dd> <dt class="d_decl" id="SpanMode.breadth"><strong id="breadth">breadth</strong></dt> <dd>
<p>Spans the directory in <a href="https://en.wikipedia.org/wiki/Tree_traversal#Pre-order">depth-first <b>pre</b>-order</a>, i.e. the content of any subdirectory is spanned right after that subdirectory itself. </p>
<p>Note that <code>SpanMode.breadth</code> will not result in all directory members occurring before any subdirectory members, i.e. it is not true <a href="https://en.wikipedia.org/wiki/Tree_traversal#Breadth-first_search"> breadth-first traversal</a>.</p> </dd> </dl> </dd> <dt class="d_decl" id="dirEntries">auto <strong id="dirEntries">dirEntries</strong>(string path, SpanMode mode, bool followSymlink = true); <br><br>auto <strong id="dirEntries">dirEntries</strong>(string path, string pattern, SpanMode mode, bool followSymlink = true); </dt> <dd>
<p>Returns an <a href="std_range_primitives.html#isInputRange">input range</a> of <code>DirEntry</code> that lazily iterates a given directory, also provides two ways of foreach iteration. The iteration variable can be of type <code>string</code> if only the name is needed, or <code>DirEntry</code> if additional details are needed. The span mode dictates how the directory is traversed. The name of each iterated directory entry contains the absolute or relative path (depending on pathname). </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>string <code>path</code>
</td> <td>The directory to iterate over. If empty, the current directory will be iterated.</td>
</tr> <tr>
<td>string <code>pattern</code>
</td> <td>Optional string with wildcards, such as <span class="red"> "*.d"</span>. When present, it is used to filter the results by their file name. The supported wildcard strings are described under <a href="std_path.html#globMatch"><code> std.path.globMatch</code></a>.</td>
</tr> <tr>
<td>SpanMode <code>mode</code>
</td> <td>Whether the directory's sub-directories should be iterated in depth-first post-order (<a href="#depth"><code>depth</code></a>), depth-first pre-order (<a href="#breadth"><code>breadth</code></a>), or not at all (<a href="#shallow"><code>shallow</code></a>).</td>
</tr> <tr>
<td>bool <code>followSymlink</code>
</td> <td>Whether symbolic links which point to directories should be treated as directories and their contents iterated over.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>An <a href="std_range_primitives.html#isInputRange">input range</a> of <a href="#DirEntry"><code>DirEntry</code></a>. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="#FileException"><code>FileException</code></a> if the directory does not exist. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">// Iterate a directory in depth
foreach (string name; dirEntries("destroy/me", SpanMode.depth))
{
    remove(name);
}

// Iterate the current directory in breadth
foreach (string name; dirEntries("", SpanMode.breadth))
{
    writeln(name);
}

// Iterate a directory and get detailed info about it
foreach (DirEntry e; dirEntries("dmd-testing", SpanMode.breadth))
{
    writeln(e.name, "\t", e.size);
}

// Iterate over all *.d files in current directory and all its subdirectories
auto dFiles = dirEntries("", SpanMode.depth).filter!(f =&gt; f.name.endsWith(".d"));
foreach (d; dFiles)
    writeln(d.name);

// Hook it up with std.parallelism to compile them all in parallel:
foreach (d; parallel(dFiles, 1)) //passes by 1 file to each thread
{
    string cmd = "dmd -c "  ~ d.name;
    writeln(cmd);
    std.process.executeShell(cmd);
}

// Iterate over all D source files in current directory and all its
// subdirectories
auto dFiles = dirEntries("","*.{d,di}",SpanMode.depth);
foreach (d; dFiles)
    writeln(d.name);
</pre>  <dl>
<dt>Examples:</dt>
<dd>Duplicate functionality of D1's <code>std.file.listdir()</code>: <pre data-language="d">string[] listdir(string pathname)
{
    import std.algorithm;
    import std.array;
    import std.file;
    import std.path;

    return std.file.dirEntries(pathname, SpanMode.shallow)
        .filter!(a =&gt; a.isFile)
        .map!(a =&gt; std.path.baseName(a.name))
        .array;
}

void main(string[] args)
{
    import std.stdio;

    string[] files = listdir(args[1]);
    writefln("%s", files);
 }
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="slurp">Select!(Types.length == 1, Types[0][], Tuple!Types[]) <strong id="slurp">slurp</strong>(Types...)(string filename, scope const(char)[] format); </dt> <dd>
<p>Reads a file line by line and parses the line into a single value or a <a href="std_typecons.html#Tuple"><code>std.typecons.Tuple</code></a> of values depending on the length of <code>Types</code>. The lines are parsed using the specified format string. The format string is passed to <a href="std_format.html#formattedRead"><code>std.format.formattedRead</code></a>, and therefore must conform to the format string specification outlined in <a href="std_format.html"><code>std.format</code></a>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Types</td> <td>the types that each of the elements in the line should be returned as</td>
</tr> <tr>
<td>string <code>filename</code>
</td> <td>the name of the file to read</td>
</tr> <tr>
<td>const(char)[] <code>format</code>
</td> <td>the format string to use when reading</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>If only one type is passed, then an array of that type. Otherwise, an array of <a href="std_typecons.html#Tuple"><code>std.typecons.Tuple</code></a>s. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<code>Exception</code> if the format string is malformed. Also, throws <code>Exception</code> if any of the lines in the file are not fully consumed by the call to <a href="std_format.html#formattedRead"><code>std.format.formattedRead</code></a>. Meaning that no empty lines or lines with extra characters are allowed.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.typecons : tuple;

scope(exit)
{
    assert(exists(deleteme));
    remove(deleteme);
}

write(deleteme, "12 12.25\n345 1.125"); // deleteme is the name of a temporary file

// Load file; each line is an int followed by comma, whitespace and a
// double.
auto a = slurp!(int, double)(deleteme, "%s %s");
writeln(a.length); // 2
writeln(a[0]); // tuple(12, 12.25)
writeln(a[1]); // tuple(345, 1.125)
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="tempDir">@trusted string <strong id="tempDir">tempDir</strong>(); </dt> <dd>
<p>Returns the path to a directory for temporary files. </p>
<p>The return value of the function is cached, so the procedures described below will only be performed the first time the function is called. All subsequent runs will return the same string, regardless of whether environment variables and directory structures have changed in the meantime. <br><br> The POSIX <code>tempDir</code> algorithm is inspired by Python's <a href="http://docs.python.org/library/tempfile.html#tempfile.tempdir"><code>tempfile.tempdir</code></a>. </p> <dl>
<dt>Returns:</dt>
<dd>On Windows, this function returns the result of calling the Windows API function <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa364992.aspx"><code>GetTempPath</code></a>.  On POSIX platforms, it searches through the following list of directories and returns the first one which is found to exist: <ol> <li>The directory given by the <code>TMPDIR</code> environment variable.</li> <li>The directory given by the <code>TEMP</code> environment variable.</li> <li>The directory given by the <code>TMP</code> environment variable.</li> <li><code>/tmp</code></li> <li><code>/var/tmp</code></li> <li><code>/usr/tmp</code></li> </ol>  On all platforms, <code>tempDir</code> returns <code>"."</code> on failure, representing the current working directory.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.ascii : letters;
import std.conv : to;
import std.path : buildPath;
import std.random : randomSample;
import std.utf : byCodeUnit;

// random id with 20 letters
auto id = letters.byCodeUnit.randomSample(20).to!string;
auto myFile = tempDir.buildPath(id ~ "my_tmp_file");
scope(exit) myFile.remove;

myFile.write("hello");
writeln(myFile.readText); // "hello"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="getAvailableDiskSpace">@safe ulong <strong id="getAvailableDiskSpace">getAvailableDiskSpace</strong>(scope const(char)[] path); </dt> <dd>
<p>Returns the available disk space based on a given path. On Windows, <code>path</code> must be a directory; on POSIX systems, it can be a file or directory. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(char)[] <code>path</code>
</td> <td>on Windows, it must be a directory; on POSIX it can be a file or directory</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>Available space in bytes </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="#FileException"><code>FileException</code></a> in case of failure</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.exception : assertThrown;

auto space = getAvailableDiskSpace(".");
assert(space &gt; 0);

assertThrown!FileException(getAvailableDiskSpace("ThisFileDoesNotExist123123"));
</pre> </dd>
</dl> </dd> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1999&ndash;2021 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/std_file.html" class="_attribution-link">https://dlang.org/phobos/std_file.html</a>
  </p>
</div>
