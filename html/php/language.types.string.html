  <div id="layout"> <div id="layout-content"><div id="language.types.string" class="sect1"> <h2 class="title">Strings</h2> <p class="para"> A <span class="type">string</span> is a series of characters, where a character is the same as a byte. This means that PHP only supports a 256-character set, and hence does not offer native Unicode support. See <a href="language.types.string.html#language.types.string.details" class="link">details of the string type</a>. </p> <blockquote class="note"><p><strong class="note">Note</strong>: <span class="simpara"> On 32-bit builds, a <span class="type">string</span> can be as large as up to 2GB (2147483647 bytes maximum) </span> </p></blockquote> <div class="sect2" id="language.types.string.syntax"> <h3 class="title">Syntax</h3> <p class="para"> A <span class="type">string</span> literal can be specified in four different ways: </p> <ul class="itemizedlist"> <li class="listitem"> <span class="simpara"> <a href="language.types.string.html#language.types.string.syntax.single" class="link">single quoted</a> </span> </li> <li class="listitem"> <span class="simpara"> <a href="language.types.string.html#language.types.string.syntax.double" class="link">double quoted</a> </span> </li> <li class="listitem"> <span class="simpara"> <a href="language.types.string.html#language.types.string.syntax.heredoc" class="link">heredoc syntax</a> </span> </li> <li class="listitem"> <span class="simpara"> <a href="language.types.string.html#language.types.string.syntax.nowdoc" class="link">nowdoc syntax</a> </span> </li> </ul> <div class="sect3" id="language.types.string.syntax.single"> <h4 class="title">Single quoted</h4> <p class="para"> The simplest way to specify a <span class="type">string</span> is to enclose it in single quotes (the character <code class="literal">'</code>). </p> <p class="para"> To specify a literal single quote, escape it with a backslash (<code class="literal">\</code>). To specify a literal backslash, double it (<code class="literal">\\</code>). All other instances of backslash will be treated as a literal backslash: this means that the other escape sequences you might be used to, such as <code class="literal">\r</code> or <code class="literal">\n</code>, will be output literally as specified rather than having any special meaning. </p> <blockquote class="note"><p><strong class="note">Note</strong>: <span class="simpara"> Unlike the <a href="language.types.string.html#language.types.string.syntax.double" class="link">double-quoted</a> and <a href="language.types.string.html#language.types.string.syntax.heredoc" class="link">heredoc</a> syntaxes, <a href="https://www.php.net/manual/en/language.variables.php" class="link">variables</a> and escape sequences for special characters will <em>not</em> be expanded when they occur in single quoted <span class="type">string</span>s. </span> </p></blockquote> <div class="informalexample"> <div class="example-contents"> <pre class="phpcode" data-language="php">&lt;?php
echo 'this is a simple string';

echo 'You can also have embedded newlines in
strings this way as it is
okay to do';

// Outputs: Arnold once said: "I'll be back"
echo 'Arnold once said: "I\'ll be back"';

// Outputs: You deleted C:\*.*?
echo 'You deleted C:\\*.*?';

// Outputs: You deleted C:\*.*?
echo 'You deleted C:\*.*?';

// Outputs: This will not expand: \n a newline
echo 'This will not expand: \n a newline';

// Outputs: Variables do not $expand $either
echo 'Variables do not $expand $either';
?&gt;</pre> </div> </div> </div> <div class="sect3" id="language.types.string.syntax.double"> <h4 class="title">Double quoted</h4> <p class="para"> If the <span class="type">string</span> is enclosed in double-quotes ("), PHP will interpret the following escape sequences for special characters: </p> <table class="doctable table"> <caption><strong>Escaped characters</strong></caption> <thead> <tr> <th>Sequence</th> <th>Meaning</th> </tr> </thead> <tbody class="tbody"> <tr> <td><code class="literal">\n</code></td> <td>linefeed (LF or 0x0A (10) in ASCII)</td> </tr> <tr> <td><code class="literal">\r</code></td> <td>carriage return (CR or 0x0D (13) in ASCII)</td> </tr> <tr> <td><code class="literal">\t</code></td> <td>horizontal tab (HT or 0x09 (9) in ASCII)</td> </tr> <tr> <td><code class="literal">\v</code></td> <td>vertical tab (VT or 0x0B (11) in ASCII)</td> </tr> <tr> <td><code class="literal">\e</code></td> <td>escape (ESC or 0x1B (27) in ASCII)</td> </tr> <tr> <td><code class="literal">\f</code></td> <td>form feed (FF or 0x0C (12) in ASCII)</td> </tr> <tr> <td><code class="literal">\\</code></td> <td>backslash</td> </tr> <tr> <td><code class="literal">\$</code></td> <td>dollar sign</td> </tr> <tr> <td><code class="literal">\"</code></td> <td>double-quote</td> </tr> <tr> <td><code class="literal">\[0-7]{1,3}</code></td> <td> Octal: the sequence of characters matching the regular expression <code class="literal">[0-7]{1,3}</code> is a character in octal notation (e.g. <code class="literal">"\101" === "A"</code>), which silently overflows to fit in a byte (e.g. <code class="literal">"\400" === "\000"</code>) </td> </tr> <tr> <td><code class="literal">\x[0-9A-Fa-f]{1,2}</code></td> <td> Hexadecimal: the sequence of characters matching the regular expression <code class="literal">[0-9A-Fa-f]{1,2}</code> is a character in hexadecimal notation (e.g. <code class="literal">"\x41" === "A"</code>) </td> </tr> <tr> <td><code class="literal">\u{[0-9A-Fa-f]+}</code></td> <td> Unicode: the sequence of characters matching the regular expression <code class="literal">[0-9A-Fa-f]+</code> is a Unicode codepoint, which will be output to the string as that codepoint's UTF-8 representation. The braces are required in the sequence. E.g. <code class="literal">"\u{41}" === "A"</code> </td> </tr> </tbody> </table> <p class="para"> As in single quoted <span class="type">string</span>s, escaping any other character will result in the backslash being printed too. </p> <p class="para"> The most important feature of double-quoted <span class="type">string</span>s is the fact that variable names will be expanded. See <a href="language.types.string.html#language.types.string.parsing" class="link">string parsing</a> for details. </p> </div> <div class="sect3" id="language.types.string.syntax.heredoc"> <h4 class="title">Heredoc</h4> <p class="simpara"> A third way to delimit <span class="type">string</span>s is the heredoc syntax: <code class="literal">&lt;&lt;&lt;</code>. After this operator, an identifier is provided, then a newline. The <span class="type">string</span> itself follows, and then the same identifier again to close the quotation. </p> <p class="simpara"> The closing identifier may be indented by space or tab, in which case the indentation will be stripped from all lines in the doc string. Prior to PHP 7.3.0, the closing identifier <em>must</em> begin in the first column of the line. </p> <p class="simpara"> Also, the closing identifier must follow the same naming rules as any other label in PHP: it must contain only alphanumeric characters and underscores, and must start with a non-digit character or underscore. </p> <div class="example" id="example-107"> <p><strong>Example #1 Basic Heredoc example as of PHP 7.3.0</strong></p> <div class="example-contents"> <pre class="phpcode" data-language="php">&lt;?php
// no indentation
echo &lt;&lt;&lt;END
      a
     b
    c
\n
END;

// 4 spaces of indentation
echo &lt;&lt;&lt;END
      a
     b
    c
    END;</pre> </div> <div class="example-contents"><p>Output of the above example in PHP 7.3:</p></div> <div class="example-contents screen"> <div class="cdata"><pre>
      a
     b
    c

  a
 b
c
</pre></div> </div> </div> <p class="simpara"> If the closing identifier is indented further than any lines of the body, then a <span class="classname"><a href="class.parseerror.html" class="classname">ParseError</a></span> will be thrown: </p> <div class="example" id="example-110"> <p><strong>Example #2 Closing identifier must not be indented further than any lines of the body</strong></p> <div class="example-contents"> <pre class="phpcode" data-language="php">&lt;?php
echo &lt;&lt;&lt;END
  a
 b
c
   END;</pre> </div> <div class="example-contents"><p>Output of the above example in PHP 7.3:</p></div> <div class="example-contents screen"> <div class="cdata"><pre>
PHP Parse error:  Invalid body indentation level (expecting an indentation level of at least 3) in example.php on line 4
</pre></div> </div> </div> <p class="simpara"> If the closing identifier is indented, tabs can be used as well, however, tabs and spaces <em>must not</em> be intermixed regarding the indentation of the closing identifier and the indentation of the body (up to the closing identifier). In any of these cases, a <span class="classname"><a href="class.parseerror.html" class="classname">ParseError</a></span> will be thrown. These whitespace constraints have been included because mixing tabs and spaces for indentation is harmful to legibility. </p> <div class="example" id="example-113"> <p><strong>Example #3 Different indentation for body (spaces) closing identifier</strong></p> <div class="example-contents"> <pre class="phpcode" data-language="php">&lt;?php
// All the following code do not work.

// different indentation for body (spaces) ending marker (tabs)
{
    echo &lt;&lt;&lt;END
     a
        END;
}

// mixing spaces and tabs in body
{
    echo &lt;&lt;&lt;END
        a
     END;
}

// mixing spaces and tabs in ending marker
{
    echo &lt;&lt;&lt;END
          a
         END;
}</pre> </div> <div class="example-contents"><p>Output of the above example in PHP 7.3:</p></div> <div class="example-contents screen"> <div class="cdata"><pre>
PHP Parse error:  Invalid indentation - tabs and spaces cannot be mixed in example.php line 8
</pre></div> </div> </div> <p class="simpara"> The closing identifier for the body string is not required to be followed by a semicolon or newline. For example, the following code is allowed as of PHP 7.3.0: </p> <div class="example" id="example-116"> <p><strong>Example #4 Continuing an expression after a closing identifier</strong></p> <div class="example-contents"> <pre class="phpcode" data-language="php">&lt;?php
$values = [&lt;&lt;&lt;END
a
  b
    c
END, 'd e f'];
var_dump($values);</pre> </div> <div class="example-contents"><p>Output of the above example in PHP 7.3:</p></div> <div class="example-contents screen"> <div class="cdata"><pre>
array(2) {
  [0] =&gt;
  string(11) "a
  b
    c"
  [1] =&gt;
  string(5) "d e f"
}
</pre></div> </div> </div> <div class="warning">
<strong class="warning">Warning</strong> <p class="simpara"> If the closing identifier was found at the start of a line, then regardless of whether it was a part of another word, it may be considered as the closing identifier and causes a <span class="classname"><a href="class.parseerror.html" class="classname">ParseError</a></span>. </p> <div class="example" id="example-119"> <p><strong>Example #5 Closing identifier in body of the string tends to cause ParseError</strong></p> <div class="example-contents"> <pre class="phpcode" data-language="php">&lt;?php
$values = [&lt;&lt;&lt;END
a
b
END ING
END, 'd e f'];</pre> </div> <div class="example-contents"><p>Output of the above example in PHP 7.3:</p></div> <div class="example-contents screen"> <div class="cdata"><pre>
PHP Parse error:  syntax error, unexpected identifier "ING", expecting "]" in example.php on line 6
</pre></div> </div> </div> <p class="simpara"> To avoid this problem, it is safe to follow the simple rule: <em>do not choose as a closing identifier if it appears in the body of the text</em>. </p> </div> <div class="warning">
<strong class="warning">Warning</strong> <p class="simpara"> Prior to PHP 7.3.0, it is very important to note that the line with the closing identifier must contain no other characters, except a semicolon (<code class="literal">;</code>). That means especially that the identifier <em>may not be indented</em>, and there may not be any spaces or tabs before or after the semicolon. It's also important to realize that the first character before the closing identifier must be a newline as defined by the local operating system. This is <code class="literal">\n</code> on UNIX systems, including macOS. The closing delimiter must also be followed by a newline. </p> <p class="simpara"> If this rule is broken and the closing identifier is not "clean", it will not be considered a closing identifier, and PHP will continue looking for one. If a proper closing identifier is not found before the end of the current file, a parse error will result at the last line. </p> <div class="example" id="example-122"> <p><strong>Example #6 Invalid example, prior to PHP 7.3.0</strong></p> <div class="example-contents"> <pre class="phpcode" data-language="php">&lt;?php
class foo {
    public $bar = &lt;&lt;&lt;EOT
bar
    EOT;
}
// Identifier must not be indented
?&gt;</pre> </div> </div> <div class="example" id="example-125"> <p><strong>Example #7 Valid example, even prior to PHP 7.3.0</strong></p> <div class="example-contents"> <pre class="phpcode" data-language="php">&lt;?php
class foo {
    public $bar = &lt;&lt;&lt;EOT
bar
EOT;
}
?&gt;</pre> </div> </div> <p class="para"> Heredocs containing variables can not be used for initializing class properties. </p> </div> <p class="para"> Heredoc text behaves just like a double-quoted <span class="type">string</span>, without the double quotes. This means that quotes in a heredoc do not need to be escaped, but the escape codes listed above can still be used. Variables are expanded, but the same care must be taken when expressing complex variables inside a heredoc as with <span class="type">string</span>s. </p> <div class="example" id="example-128"> <p><strong>Example #8 Heredoc string quoting example</strong></p> <div class="example-contents"> <pre class="phpcode" data-language="php">&lt;?php
$str = &lt;&lt;&lt;EOD
Example of string
spanning multiple lines
using heredoc syntax.
EOD;

/* More complex example, with variables. */
class foo
{
    var $foo;
    var $bar;

    function __construct()
    {
        $this-&gt;foo = 'Foo';
        $this-&gt;bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$name = 'MyName';

echo &lt;&lt;&lt;EOT
My name is "$name". I am printing some $foo-&gt;foo.
Now, I am printing some {$foo-&gt;bar[1]}.
This should print a capital 'A': \x41
EOT;
?&gt;</pre> </div> <div class="example-contents"><p>The above example will output:</p></div> <div class="example-contents screen"> <div class="cdata"><pre>
My name is "MyName". I am printing some Foo.
Now, I am printing some Bar2.
This should print a capital 'A': A</pre></div> </div> </div> <p class="para"> It is also possible to use the Heredoc syntax to pass data to function arguments: </p> <div class="example" id="example-131"> <p><strong>Example #9 Heredoc in arguments example</strong></p> <div class="example-contents"> <pre class="phpcode" data-language="php">&lt;?php
var_dump(array(&lt;&lt;&lt;EOD
foobar!
EOD
));
?&gt;</pre> </div> </div> <p class="para"> It's possible to initialize static variables and class properties/constants using the Heredoc syntax: </p> <div class="example" id="example-134"> <p><strong>Example #10 Using Heredoc to initialize static values</strong></p> <div class="example-contents"> <pre class="phpcode" data-language="php">&lt;?php
// Static variables
function foo()
{
    static $bar = &lt;&lt;&lt;LABEL
Nothing in here...
LABEL;
}

// Class properties/constants
class foo
{
    const BAR = &lt;&lt;&lt;FOOBAR
Constant example
FOOBAR;

    public $baz = &lt;&lt;&lt;FOOBAR
Property example
FOOBAR;
}
?&gt;</pre> </div> </div> <p class="para"> The opening Heredoc identifier may optionally be enclosed in double quotes: </p> <div class="example" id="example-137"> <p><strong>Example #11 Using double quotes in Heredoc</strong></p> <div class="example-contents"> <pre class="phpcode" data-language="php">&lt;?php
echo &lt;&lt;&lt;"FOOBAR"
Hello World!
FOOBAR;
?&gt;</pre> </div> </div> </div> <div class="sect3" id="language.types.string.syntax.nowdoc"> <h4 class="title">Nowdoc</h4> <p class="para"> Nowdocs are to single-quoted strings what heredocs are to double-quoted strings. A nowdoc is specified similarly to a heredoc, but <em>no parsing is done</em> inside a nowdoc. The construct is ideal for embedding PHP code or other large blocks of text without the need for escaping. It shares some features in common with the SGML <code class="literal">&lt;![CDATA[ ]]&gt;</code> construct, in that it declares a block of text which is not for parsing. </p> <p class="para"> A nowdoc is identified with the same <code class="literal">&lt;&lt;&lt;</code> sequence used for heredocs, but the identifier which follows is enclosed in single quotes, e.g. <code class="literal">&lt;&lt;&lt;'EOT'</code>. All the rules for heredoc identifiers also apply to nowdoc identifiers, especially those regarding the appearance of the closing identifier. </p> <div class="example" id="example-140"> <p><strong>Example #12 Nowdoc string quoting example</strong></p> <div class="example-contents"> <pre class="phpcode" data-language="php">&lt;?php
echo &lt;&lt;&lt;'EOD'
Example of string spanning multiple lines
using nowdoc syntax. Backslashes are always treated literally,
e.g. \\ and \'.
EOD;</pre> </div> <div class="example-contents"><p>The above example will output:</p></div> <div class="example-contents screen"> <div class="cdata"><pre>
Example of string spanning multiple lines
using nowdoc syntax. Backslashes are always treated literally,
e.g. \\ and \'.
</pre></div> </div> </div> <div class="example" id="example-143"> <p><strong>Example #13 Nowdoc string quoting example with variables</strong></p> <div class="example-contents"> <pre class="phpcode" data-language="php">&lt;?php
class foo
{
    public $foo;
    public $bar;

    function __construct()
    {
        $this-&gt;foo = 'Foo';
        $this-&gt;bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$name = 'MyName';

echo &lt;&lt;&lt;'EOT'
My name is "$name". I am printing some $foo-&gt;foo.
Now, I am printing some {$foo-&gt;bar[1]}.
This should not print a capital 'A': \x41
EOT;
?&gt;</pre> </div> <div class="example-contents"><p>The above example will output:</p></div> <div class="example-contents screen"> <div class="cdata"><pre>
My name is "$name". I am printing some $foo-&gt;foo.
Now, I am printing some {$foo-&gt;bar[1]}.
This should not print a capital 'A': \x41</pre></div> </div> </div> <div class="example" id="example-146"> <p><strong>Example #14 Static data example</strong></p> <div class="example-contents"> <pre class="phpcode" data-language="php">&lt;?php
class foo {
    public $bar = &lt;&lt;&lt;'EOT'
bar
EOT;
}
?&gt;</pre> </div> </div> </div> <div class="sect3" id="language.types.string.parsing"> <h4 class="title">Variable parsing</h4> <p class="simpara"> When a <span class="type">string</span> is specified in double quotes or with heredoc, <a href="https://www.php.net/manual/en/language.variables.php" class="link">variables</a> are parsed within it. </p> <p class="simpara"> There are two types of syntax: a <a href="language.types.string.html#language.types.string.parsing.simple" class="link">simple</a> one and a <a href="language.types.string.html#language.types.string.parsing.complex" class="link">complex</a> one. The simple syntax is the most common and convenient. It provides a way to embed a variable, an <span class="type">array</span> value, or an <span class="type">object</span> property in a <span class="type">string</span> with a minimum of effort. </p> <p class="simpara"> The complex syntax can be recognised by the curly braces surrounding the expression. </p> <div class="sect4" id="language.types.string.parsing.simple"> <h5 class="title">Simple syntax</h5> <p class="simpara"> If a dollar sign (<code class="literal">$</code>) is encountered, the parser will greedily take as many tokens as possible to form a valid variable name. Enclose the variable name in curly braces to explicitly specify the end of the name. </p> <div class="informalexample"> <div class="example-contents"> <pre class="phpcode" data-language="php">&lt;?php
$juice = "apple";

echo "He drank some $juice juice.".PHP_EOL;
// Unintended. "s" is a valid character for a variable name, so this refers to $juices, not $juice.
echo "He drank some juice made of $juices.";
// Explicitly specify the end of the variable name by enclosing the reference in braces.
echo "He drank some juice made of {$juice}s.";
?&gt;</pre> </div> <p class="para">The above example will output:</p> <div class="example-contents screen"> <div class="cdata"><pre>
He drank some apple juice.
He drank some juice made of .
He drank some juice made of apples.
</pre></div> </div> </div> <p class="simpara"> Similarly, an <span class="type">array</span> index or an <span class="type">object</span> property can be parsed. With array indices, the closing square bracket (<code class="literal">]</code>) marks the end of the index. The same rules apply to object properties as to simple variables. </p> <div class="example" id="example-149">
<p><strong>Example #15 Simple syntax example</strong></p> <div class="example-contents"> <pre class="phpcode" data-language="php">&lt;?php
$juices = array("apple", "orange", "koolaid1" =&gt; "purple");

echo "He drank some $juices[0] juice.".PHP_EOL;
echo "He drank some $juices[1] juice.".PHP_EOL;
echo "He drank some $juices[koolaid1] juice.".PHP_EOL;

class people {
    public $john = "John Smith";
    public $jane = "Jane Smith";
    public $robert = "Robert Paulsen";

    public $smith = "Smith";
}

$people = new people();

echo "$people-&gt;john drank some $juices[0] juice.".PHP_EOL;
echo "$people-&gt;john then said hello to $people-&gt;jane.".PHP_EOL;
echo "$people-&gt;john's wife greeted $people-&gt;robert.".PHP_EOL;
echo "$people-&gt;robert greeted the two $people-&gt;smiths."; // Won't work
?&gt;</pre> </div> <div class="example-contents"><p>The above example will output:</p></div> <div class="example-contents screen"> <div class="cdata"><pre>
He drank some apple juice.
He drank some orange juice.
He drank some purple juice.
John Smith drank some apple juice.
John Smith then said hello to Jane Smith.
John Smith's wife greeted Robert Paulsen.
Robert Paulsen greeted the two .
</pre></div> </div> </div> <p class="simpara"> As of PHP 7.1.0 also <em>negative</em> numeric indices are supported. </p> <div class="example" id="example-152">
<p><strong>Example #16 Negative numeric indices</strong></p> <div class="example-contents"> <pre class="phpcode" data-language="php">&lt;?php
$string = 'string';
echo "The character at index -2 is $string[-2].", PHP_EOL;
$string[-3] = 'o';
echo "Changing the character at index -3 to o gives $string.", PHP_EOL;
?&gt;</pre> </div> <div class="example-contents"><p>The above example will output:</p></div> <div class="example-contents screen"> <div class="cdata"><pre>
The character at index -2 is n.
Changing the character at index -3 to o gives strong.
</pre></div> </div> </div> <p class="simpara"> For anything more complex, you should use the complex syntax. </p> </div> <div class="sect4" id="language.types.string.parsing.complex"> <h5 class="title">Complex (curly) syntax</h5> <p class="simpara"> This isn't called complex because the syntax is complex, but because it allows for the use of complex expressions. </p> <p class="simpara"> Any scalar variable, array element or object property with a <span class="type">string</span> representation can be included via this syntax. The expression is written the same way as it would appear outside the <span class="type">string</span>, and then wrapped in <code class="literal">{</code> and <code class="literal">}</code>. Since <code class="literal">{</code> can not be escaped, this syntax will only be recognised when the <code class="literal">$</code> immediately follows the <code class="literal">{</code>. Use <code class="literal">{\$</code> to get a literal <code class="literal">{$</code>. Some examples to make it clear: </p> <div class="informalexample"> <div class="example-contents"> <pre class="phpcode" data-language="php">&lt;?php
// Show all errors
error_reporting(E_ALL);

$great = 'fantastic';

// Won't work, outputs: This is { fantastic}
echo "This is { $great}";

// Works, outputs: This is fantastic
echo "This is {$great}";

// Works
echo "This square is {$square-&gt;width}00 centimeters broad.";


// Works, quoted keys only work using the curly brace syntax
echo "This works: {$arr['key']}";


// Works
echo "This works: {$arr[4][3]}";

// This is wrong for the same reason as $foo[bar] is wrong  outside a string.
// In other words, it will still work, but only because PHP first looks for a
// constant named foo; an error of level E_NOTICE (undefined constant) will be
// thrown.
echo "This is wrong: {$arr[foo][3]}";

// Works. When using multi-dimensional arrays, always use braces around arrays
// when inside of strings
echo "This works: {$arr['foo'][3]}";

// Works.
echo "This works: " . $arr['foo'][3];

echo "This works too: {$obj-&gt;values[3]-&gt;name}";

echo "This is the value of the var named $name: {${$name}}";

echo "This is the value of the var named by the return value of getName(): {${getName()}}";

echo "This is the value of the var named by the return value of \$object-&gt;getName(): {${$object-&gt;getName()}}";

// Won't work, outputs: This is the return value of getName(): {getName()}
echo "This is the return value of getName(): {getName()}";

// Won't work, outputs: C:\folder\{fantastic}.txt
echo "C:\folder\{$great}.txt"
// Works, outputs: C:\folder\fantastic.txt
echo "C:\\folder\\{$great}.txt"
?&gt;</pre> </div> </div> <p class="para"> It is also possible to access class properties using variables within strings using this syntax. </p> <div class="informalexample"> <div class="example-contents"> <pre class="phpcode" data-language="php">&lt;?php
class foo {
    var $bar = 'I am bar.';
}

$foo = new foo();
$bar = 'bar';
$baz = array('foo', 'bar', 'baz', 'quux');
echo "{$foo-&gt;$bar}\n";
echo "{$foo-&gt;{$baz[1]}}\n";
?&gt;</pre> </div> <p class="para">The above example will output:</p> <div class="example-contents screen"> <div class="cdata"><pre>
I am bar.
I am bar.
</pre></div> </div> </div> <blockquote class="note">
<p><strong class="note">Note</strong>: </p>
<p class="para"> The value accessed from functions, method calls, static class variables, and class constants inside <code class="literal">{$}</code> will be interpreted as the name of a variable in the scope in which the string is defined. Using single curly braces (<code class="literal">{}</code>) will not work for accessing the return values of functions or methods or the values of class constants or static class variables. </p> </blockquote> <div class="informalexample"> <div class="example-contents"> <pre class="phpcode" data-language="php">&lt;?php
// Show all errors.
error_reporting(E_ALL);

class beers {
    const softdrink = 'rootbeer';
    public static $ale = 'ipa';
}

$rootbeer = 'A &amp; W';
$ipa = 'Alexander Keith\'s';

// This works; outputs: I'd like an A &amp; W
echo "I'd like an {${beers::softdrink}}\n";

// This works too; outputs: I'd like an Alexander Keith's
echo "I'd like an {${beers::$ale}}\n";
?&gt;</pre> </div> </div> </div> </div> <div class="sect3" id="language.types.string.substr"> <h4 class="title">String access and modification by character</h4> <p class="para"> Characters within <span class="type">string</span>s may be accessed and modified by specifying the zero-based offset of the desired character after the <span class="type">string</span> using square <span class="type">array</span> brackets, as in <var class="varname">$str[42]</var>. Think of a <span class="type">string</span> as an <span class="type">array</span> of characters for this purpose. The functions <span class="function"><a href="function.substr.html" class="function">substr()</a></span> and <span class="function"><a href="function.substr-replace.html" class="function">substr_replace()</a></span> can be used when you want to extract or replace more than 1 character. </p> <blockquote class="note"><p><strong class="note">Note</strong>: <span class="simpara"> As of PHP 7.1.0, negative string offsets are also supported. These specify the offset from the end of the string. Formerly, negative offsets emitted <strong><code>E_NOTICE</code></strong> for reading (yielding an empty string) and <strong><code>E_WARNING</code></strong> for writing (leaving the string untouched). </span> </p></blockquote> <blockquote class="note"><p><strong class="note">Note</strong>: <span class="simpara"> Prior to PHP 8.0.0, <span class="type">string</span>s could also be accessed using braces, as in <var class="varname">$str{42}</var>, for the same purpose. This curly brace syntax was deprecated as of PHP 7.4.0 and no longer supported as of PHP 8.0.0. </span> </p></blockquote> <div class="warning">
<strong class="warning">Warning</strong> <p class="simpara"> Writing to an out of range offset pads the string with spaces. Non-integer types are converted to integer. Illegal offset type emits <strong><code>E_WARNING</code></strong>. Only the first character of an assigned string is used. As of PHP 7.1.0, assigning an empty string throws a fatal error. Formerly, it assigned a NULL byte. </p> </div> <div class="warning">
<strong class="warning">Warning</strong> <p class="simpara"> Internally, PHP strings are byte arrays. As a result, accessing or modifying a string using array brackets is not multi-byte safe, and should only be done with strings that are in a single-byte encoding such as ISO-8859-1. </p> </div> <blockquote class="note"><p><strong class="note">Note</strong>: <span class="simpara"> As of PHP 7.1.0, applying the empty index operator on an empty string throws a fatal error. Formerly, the empty string was silently converted to an array. </span> </p></blockquote> <div class="example" id="example-155"> <p><strong>Example #17 Some string examples</strong></p> <div class="example-contents"> <pre class="phpcode" data-language="php">&lt;?php
// Get the first character of a string
$str = 'This is a test.';
$first = $str[0];

// Get the third character of a string
$third = $str[2];

// Get the last character of a string.
$str = 'This is still a test.';
$last = $str[strlen($str)-1];

// Modify the last character of a string
$str = 'Look at the sea';
$str[strlen($str)-1] = 'e';

?&gt;</pre> </div> </div> <p class="para"> String offsets have to either be integers or integer-like strings, otherwise a warning will be thrown. </p> <div class="example" id="example-158"> <p><strong>Example #18 Example of Illegal String Offsets</strong></p> <div class="example-contents"> <pre class="phpcode" data-language="php">&lt;?php
$str = 'abc';

var_dump($str['1']);
var_dump(isset($str['1']));

var_dump($str['1.0']);
var_dump(isset($str['1.0']));

var_dump($str['x']);
var_dump(isset($str['x']));

var_dump($str['1x']);
var_dump(isset($str['1x']));
?&gt;</pre> </div> <div class="example-contents"><p>The above example will output:</p></div> <div class="example-contents screen"> <div class="cdata"><pre>
string(1) "b"
bool(true)

Warning: Illegal string offset '1.0' in /tmp/t.php on line 7
string(1) "b"
bool(false)

Warning: Illegal string offset 'x' in /tmp/t.php on line 9
string(1) "a"
bool(false)
string(1) "b"
bool(false)
</pre></div> </div> </div> <blockquote class="note">
<p><strong class="note">Note</strong>: </p>
<p class="para"> Accessing variables of other types (not including arrays or objects implementing the appropriate interfaces) using <code class="literal">[]</code> or <code class="literal">{}</code> silently returns <strong><code>null</code></strong>. </p> </blockquote> <blockquote class="note">
<p><strong class="note">Note</strong>: </p>
<p class="para"> Characters within string literals can be accessed using <code class="literal">[]</code> or <code class="literal">{}</code>. </p> </blockquote> <blockquote class="note">
<p><strong class="note">Note</strong>: </p>
<p class="para"> Accessing characters within string literals using the <code class="literal">{}</code> syntax has been deprecated in PHP 7.4. This has been removed in PHP 8.0. </p> </blockquote> </div> </div> <div class="sect2" id="language.types.string.useful-funcs"> <h3 class="title">Useful functions and operators</h3> <p class="para"> <span class="type">String</span>s may be concatenated using the '.' (dot) operator. Note that the '+' (addition) operator will <em>not</em> work for this. See <a href="language.operators.string.html" class="link">String operators</a> for more information. </p> <p class="para"> There are a number of useful functions for <span class="type">string</span> manipulation. </p> <p class="simpara"> See the <a href="https://www.php.net/manual/en/ref.strings.php" class="link">string functions section</a> for general functions, and the <a href="https://www.php.net/manual/en/ref.pcre.php" class="link">Perl-compatible regular expression functions</a> for advanced find &amp; replace functionality. </p> <p class="simpara"> There are also <a href="https://www.php.net/manual/en/ref.url.php" class="link">functions for URL strings</a>, and functions to encrypt/decrypt strings (<a href="https://www.php.net/manual/en/ref.sodium.php" class="link">Sodium</a> and <a href="https://www.php.net/manual/en/ref.hash.php" class="link">Hash</a>). </p> <p class="simpara"> Finally, see also the <a href="https://www.php.net/manual/en/ref.ctype.php" class="link">character type functions</a>. </p> </div> <div class="sect2" id="language.types.string.casting"> <h3 class="title">Converting to string</h3> <p class="para"> A value can be converted to a <span class="type">string</span> using the <code class="literal">(string)</code> cast or the <span class="function"><a href="function.strval.html" class="function">strval()</a></span> function. <span class="type">String</span> conversion is automatically done in the scope of an expression where a <span class="type">string</span> is needed. This happens when using the <span class="function"><a href="function.echo.html" class="function">echo</a></span> or <span class="function"><a href="function.print.html" class="function">print</a></span> functions, or when a variable is compared to a <span class="type">string</span>. The sections on <a href="https://www.php.net/manual/en/language.types.php" class="link">Types</a> and <a href="language.types.type-juggling.html" class="link">Type Juggling</a> will make the following clearer. See also the <span class="function"><a href="function.settype.html" class="function">settype()</a></span> function. </p> <p class="para"> A <span class="type">bool</span> <strong><code>true</code></strong> value is converted to the <span class="type">string</span> <code class="literal">"1"</code>. <span class="type">bool</span> <strong><code>false</code></strong> is converted to <code class="literal">""</code> (the empty string). This allows conversion back and forth between <span class="type">bool</span> and <span class="type">string</span> values. </p> <p class="para"> An <span class="type">int</span> or <span class="type">float</span> is converted to a <span class="type">string</span> representing the number textually (including the exponent part for <span class="type">float</span>s). Floating point numbers can be converted using exponential notation (<code class="literal">4.1E+6</code>). </p> <blockquote class="note">
<p><strong class="note">Note</strong>: </p>
<p class="para"> As of PHP 8.0.0, the decimal point character is always a period ("<code class="literal">.</code>"). Prior to PHP 8.0.0, the decimal point character is defined in the script's locale (category LC_NUMERIC). See the <span class="function"><a href="function.setlocale.html" class="function">setlocale()</a></span> function. </p> </blockquote> <p class="para"> <span class="type">Array</span>s are always converted to the <span class="type">string</span> <code class="literal">"Array"</code>; because of this, <span class="function"><a href="function.echo.html" class="function">echo</a></span> and <span class="function"><a href="function.print.html" class="function">print</a></span> can not by themselves show the contents of an <span class="type">array</span>. To view a single element, use a construction such as <code class="literal">echo $arr['foo']</code>. See below for tips on viewing the entire contents. </p> <p class="para"> In order to convert <span class="type">object</span>s to <span class="type">string</span>, the magic method <a href="language.oop5.magic.html" class="link">__toString</a> must be used. </p> <p class="para"> <span class="type">Resource</span>s are always converted to <span class="type">string</span>s with the structure <code class="literal">"Resource id #1"</code>, where <code class="literal">1</code> is the resource number assigned to the <span class="type">resource</span> by PHP at runtime. While the exact structure of this string should not be relied on and is subject to change, it will always be unique for a given resource within the lifetime of a script being executed (ie a Web request or CLI process) and won't be reused. To get a <span class="type">resource</span>'s type, use the <span class="function"><a href="function.get-resource-type.html" class="function">get_resource_type()</a></span> function. </p> <p class="para"> <strong><code>null</code></strong> is always converted to an empty string. </p> <p class="para"> As stated above, directly converting an <span class="type">array</span>, <span class="type">object</span>, or <span class="type">resource</span> to a <span class="type">string</span> does not provide any useful information about the value beyond its type. See the functions <span class="function"><a href="function.print-r.html" class="function">print_r()</a></span> and <span class="function"><a href="function.var-dump.html" class="function">var_dump()</a></span> for more effective means of inspecting the contents of these types. </p> <p class="para"> Most PHP values can also be converted to <span class="type">string</span>s for permanent storage. This method is called serialization, and is performed by the <span class="function"><a href="function.serialize.html" class="function">serialize()</a></span> function. </p> </div> <div class="sect2" id="language.types.string.details"> <h3 class="title">Details of the String Type</h3> <p class="para"> The <span class="type">string</span> in PHP is implemented as an array of bytes and an integer indicating the length of the buffer. It has no information about how those bytes translate to characters, leaving that task to the programmer. There are no limitations on the values the string can be composed of; in particular, bytes with value <code class="literal">0</code> (“NUL bytes”) are allowed anywhere in the string (however, a few functions, said in this manual not to be “binary safe”, may hand off the strings to libraries that ignore data after a NUL byte.) </p> <p class="para"> This nature of the string type explains why there is no separate “byte” type in PHP – strings take this role. Functions that return no textual data – for instance, arbitrary data read from a network socket – will still return strings. </p> <p class="para"> Given that PHP does not dictate a specific encoding for strings, one might wonder how string literals are encoded. For instance, is the string <code class="literal">"á"</code> equivalent to <code class="literal">"\xE1"</code> (ISO-8859-1), <code class="literal">"\xC3\xA1"</code> (UTF-8, C form), <code class="literal">"\x61\xCC\x81"</code> (UTF-8, D form) or any other possible representation? The answer is that string will be encoded in whatever fashion it is encoded in the script file. Thus, if the script is written in ISO-8859-1, the string will be encoded in ISO-8859-1 and so on. However, this does not apply if Zend Multibyte is enabled; in that case, the script may be written in an arbitrary encoding (which is explicitly declared or is detected) and then converted to a certain internal encoding, which is then the encoding that will be used for the string literals. Note that there are some constraints on the encoding of the script (or on the internal encoding, should Zend Multibyte be enabled) – this almost always means that this encoding should be a compatible superset of ASCII, such as UTF-8 or ISO-8859-1. Note, however, that state-dependent encodings where the same byte values can be used in initial and non-initial shift states may be problematic. </p> <p class="para"> Of course, in order to be useful, functions that operate on text may have to make some assumptions about how the string is encoded. Unfortunately, there is much variation on this matter throughout PHP’s functions: </p> <ul class="itemizedlist"> <li class="listitem"> <span class="simpara"> Some functions assume that the string is encoded in some (any) single-byte encoding, but they do not need to interpret those bytes as specific characters. This is case of, for instance, <span class="function"><a href="function.substr.html" class="function">substr()</a></span>, <span class="function"><a href="function.strpos.html" class="function">strpos()</a></span>, <span class="function"><a href="function.strlen.html" class="function">strlen()</a></span> or <span class="function"><a href="function.strcmp.html" class="function">strcmp()</a></span>. Another way to think of these functions is that operate on memory buffers, i.e., they work with bytes and byte offsets. </span> </li> <li class="listitem"> <span class="simpara"> Other functions are passed the encoding of the string, possibly they also assume a default if no such information is given. This is the case of <span class="function"><a href="function.htmlentities.html" class="function">htmlentities()</a></span> and the majority of the functions in the <a href="https://www.php.net/manual/en/book.mbstring.php" class="link">mbstring</a> extension. </span> </li> <li class="listitem"> <span class="simpara"> Others use the current locale (see <span class="function"><a href="function.setlocale.html" class="function">setlocale()</a></span>), but operate byte-by-byte. </span> </li> <li class="listitem"> <span class="simpara"> Finally, they may just assume the string is using a specific encoding, usually UTF-8. This is the case of most functions in the <a href="https://www.php.net/manual/en/book.intl.php" class="link">intl</a> extension and in the <a href="https://www.php.net/manual/en/book.pcre.php" class="link">PCRE</a> extension (in the last case, only when the <code class="literal">u</code> modifier is used). </span> </li> </ul> <p class="para"> Ultimately, this means writing correct programs using Unicode depends on carefully avoiding functions that will not work and that most likely will corrupt the data and using instead the functions that do behave correctly, generally from the <a href="https://www.php.net/manual/en/book.intl.php" class="link">intl</a> and <a href="https://www.php.net/manual/en/book.mbstring.php" class="link">mbstring</a> extensions. However, using functions that can handle Unicode encodings is just the beginning. No matter the functions the language provides, it is essential to know the Unicode specification. For instance, a program that assumes there is only uppercase and lowercase is making a wrong assumption. </p> </div> </div></div>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1997&ndash;2023 The PHP Documentation Group<br>Licensed under the Creative Commons Attribution License v3.0 or later.<br>
    <a href="https://www.php.net/manual/en/language.types.string.php" class="_attribution-link">https://www.php.net/manual/en/language.types.string.php</a>
  </p>
</div>
