  <div id="layout"> <div id="layout-content"> <h2 class="title">Assertions</h2> <p class="para"> An assertion is a test on the characters following or preceding the current matching point that does not actually consume any characters. The simple assertions coded as \b, \B, \A, \Z, \z, ^ and $ are described in <a href="regexp.reference.escape.html" class="link">escape sequences</a>. More complicated assertions are coded as subpatterns. There are two kinds: those that <em>look ahead</em> of the current position in the subject string, and those that <em>look behind</em> it. </p> <p class="para"> An assertion subpattern is matched in the normal way, except that it does not cause the current matching position to be changed. <em>Lookahead</em> assertions start with (?= for positive assertions and (?! for negative assertions. For example, <code class="literal">\w+(?=;)</code> matches a word followed by a semicolon, but does not include the semicolon in the match, and <code class="literal">foo(?!bar)</code> matches any occurrence of "foo" that is not followed by "bar". Note that the apparently similar pattern <code class="literal">(?!foo)bar</code> does not find an occurrence of "bar" that is preceded by something other than "foo"; it finds any occurrence of "bar" whatsoever, because the assertion (?!foo) is always <strong><code>true</code></strong> when the next three characters are "bar". A lookbehind assertion is needed to achieve this effect. </p> <p class="para"> <em>Lookbehind</em> assertions start with (?&lt;= for positive assertions and (?&lt;! for negative assertions. For example, <code class="literal">(?&lt;!foo)bar</code> does find an occurrence of "bar" that is not preceded by "foo". The contents of a lookbehind assertion are restricted such that all the strings it matches must have a fixed length. However, if there are several alternatives, they do not all have to have the same fixed length. Thus <code class="literal">(?&lt;=bullock|donkey)</code> is permitted, but <code class="literal">(?&lt;!dogs?|cats?)</code> causes an error at compile time. Branches that match different length strings are permitted only at the top level of a lookbehind assertion. This is an extension compared with Perl 5.005, which requires all branches to match the same length of string. An assertion such as <code class="literal">(?&lt;=ab(c|de))</code> is not permitted, because its single top-level branch can match two different lengths, but it is acceptable if rewritten to use two top-level branches: <code class="literal">(?&lt;=abc|abde)</code> The implementation of lookbehind assertions is, for each alternative, to temporarily move the current position back by the fixed width and then try to match. If there are insufficient characters before the current position, the match is deemed to fail. Lookbehinds in conjunction with once-only subpatterns can be particularly useful for matching at the ends of strings; an example is given at the end of the section on once-only subpatterns. </p> <p class="para"> Several assertions (of any sort) may occur in succession. For example, <code class="literal">(?&lt;=\d{3})(?&lt;!999)foo</code> matches "foo" preceded by three digits that are not "999". Notice that each of the assertions is applied independently at the same point in the subject string. First there is a check that the previous three characters are all digits, then there is a check that the same three characters are not "999". This pattern does not match "foo" preceded by six characters, the first of which are digits and the last three of which are not "999". For example, it doesn't match "123abcfoo". A pattern to do that is <code class="literal">(?&lt;=\d{3}...)(?&lt;!999)foo</code> </p> <p class="para"> This time the first assertion looks at the preceding six characters, checking that the first three are digits, and then the second assertion checks that the preceding three characters are not "999". </p> <p class="para"> Assertions can be nested in any combination. For example, <code class="literal">(?&lt;=(?&lt;!foo)bar)baz</code> matches an occurrence of "baz" that is preceded by "bar" which in turn is not preceded by "foo", while <code class="literal">(?&lt;=\d{3}...(?&lt;!999))foo</code> is another pattern which matches "foo" preceded by three digits and any three characters that are not "999". </p> <p class="para"> Assertion subpatterns are not capturing subpatterns, and may not be repeated, because it makes no sense to assert the same thing several times. If any kind of assertion contains capturing subpatterns within it, these are counted for the purposes of numbering the capturing subpatterns in the whole pattern. However, substring capturing is carried out only for positive assertions, because it does not make sense for negative assertions. </p> <p class="para"> Assertions count towards the maximum of 200 parenthesized subpatterns. </p> </div>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1997&ndash;2023 The PHP Documentation Group<br>Licensed under the Creative Commons Attribution License v3.0 or later.<br>
    <a href="https://www.php.net/manual/en/regexp.reference.assertions.php" class="_attribution-link">https://www.php.net/manual/en/regexp.reference.assertions.php</a>
  </p>
</div>
