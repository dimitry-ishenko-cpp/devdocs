  <div id="layout"> <div id="layout-content"><div id="language.attributes.classes" class="sect1"> <h2 class="title">Declaring Attribute Classes</h2> <p class="para"> While not strictly required it is recommended to create an actual class for every attribute. In the most simple case only an empty class is needed with the <code class="literal">#[Attribute]</code> attribute declared that can be imported from the global namespace with a use statement. </p> <div class="example" id="example-374"> <p><strong>Example #1 Simple Attribute Class</strong></p> <div class="example-contents"> <pre class="phpcode" data-language="php">&lt;?php

namespace Example;

use Attribute;

#[Attribute]
class MyAttribute
{
}</pre> </div> </div> <p class="para"> To restrict the type of declaration an attribute can be assigned to, a bitmask can be passed as the first argument to the <code class="literal">#[Attribute]</code> declaration. </p> <div class="example" id="example-375"> <p><strong>Example #2 Using target specification to restrict where attributes can be used</strong></p> <div class="example-contents"> <pre class="phpcode" data-language="php">&lt;?php

namespace Example;

use Attribute;

#[Attribute(Attribute::TARGET_METHOD | Attribute::TARGET_FUNCTION)]
class MyAttribute
{
}</pre> </div> <div class="example-contents"><p> Declaring <span class="classname"><strong class="classname">MyAttribute</strong></span> on another type will now throw an exception during the call to <span class="function"><a href="reflectionattribute.newinstance.html" class="function">ReflectionAttribute::newInstance()</a></span> </p></div> </div> <p class="para">The following targets can be specified:</p> <ul class="simplelist"> <li><strong><code><a href="class.attribute.html#attribute.constants.target-class">Attribute::TARGET_CLASS</a></code></strong></li> <li><strong><code><a href="class.attribute.html#attribute.constants.target-function">Attribute::TARGET_FUNCTION</a></code></strong></li> <li><strong><code><a href="class.attribute.html#attribute.constants.target-method">Attribute::TARGET_METHOD</a></code></strong></li> <li><strong><code><a href="class.attribute.html#attribute.constants.target-property">Attribute::TARGET_PROPERTY</a></code></strong></li> <li><strong><code><a href="class.attribute.html#attribute.constants.target-class-constant">Attribute::TARGET_CLASS_CONSTANT</a></code></strong></li> <li><strong><code><a href="class.attribute.html#attribute.constants.target-parameter">Attribute::TARGET_PARAMETER</a></code></strong></li> <li><strong><code><a href="class.attribute.html#attribute.constants.target-all">Attribute::TARGET_ALL</a></code></strong></li> </ul> <p class="para"> By default an attribute can only be used once per declaration. If the attribute should be repeatable on declarations it must be specified as part of the bitmask to the <code class="literal">#[Attribute]</code> declaration. </p> <div class="example" id="example-376"> <p><strong>Example #3 Using IS_REPEATABLE to allow attribute on a declaration multiple times</strong></p> <div class="example-contents"> <pre class="phpcode" data-language="php">&lt;?php

namespace Example;

use Attribute;

#[Attribute(Attribute::TARGET_METHOD | Attribute::TARGET_FUNCTION | Attribute::IS_REPEATABLE)]
class MyAttribute
{
}</pre> </div> </div> </div></div>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1997&ndash;2024 The PHP Documentation Group<br>Licensed under the Creative Commons Attribution License v3.0 or later.<br>
    <a href="https://www.php.net/manual/en/language.attributes.classes.php" class="_attribution-link">https://www.php.net/manual/en/language.attributes.classes.php</a>
  </p>
</div>
