  <div id="layout"> <div id="layout-content"><div id="language.types.type-juggling" class="sect1"> <h2 class="title">Type Juggling</h2> <p class="simpara"> PHP does not require explicit type definition in variable declaration. In this case, the type of a variable is determined by the value it stores. That is to say, if a <span class="type">string</span> is assigned to variable <var class="varname">$var</var>, then <var class="varname">$var</var> is of type <span class="type">string</span>. If afterwards an <span class="type">int</span> value is assigned to <var class="varname">$var</var>, it will be of type <span class="type">int</span>. </p> <p class="para"> PHP may attempt to convert the type of a value to another automatically in certain contexts. The different contexts which exist are: </p>
<ul class="itemizedlist"> <li class="listitem"> <span class="simpara">Numeric</span> </li> <li class="listitem"> <span class="simpara">String</span> </li> <li class="listitem"> <span class="simpara">Logical</span> </li> <li class="listitem"> <span class="simpara">Integral and string</span> </li> <li class="listitem"> <span class="simpara">Comparative</span> </li> <li class="listitem"> <span class="simpara">Function</span> </li> </ul> <blockquote class="note"><p><strong class="note">Note</strong>: <span class="simpara"> When a value needs to be interpreted as a different type, the value itself does <em>not</em> change types. </span> </p></blockquote> <p class="simpara"> To force a variable to be evaluated as a certain type, see the section on <a href="language.types.type-juggling.html#language.types.typecasting" class="link">Type casting</a>. To change the type of a variable, see the <span class="function"><a href="function.settype.html" class="function">settype()</a></span> function. </p> <div class="sect2"> <h3 class="title">Numeric contexts</h3> <p class="simpara"> This is the context when using an <a href="language.operators.arithmetic.html" class="link">arithmetical operator</a>. </p> <p class="simpara"> In this context if either operand is a <span class="type">float</span> (or not interpretable as an <span class="type">int</span>), both operands are interpreted as <span class="type">float</span>s, and the result will be a <span class="type">float</span>. Otherwise, the operands will be interpreted as <span class="type">int</span>s, and the result will also be an <span class="type">int</span>. As of PHP 8.0.0, if one of the operands cannot be interpreted a <span class="classname"><a href="class.typeerror.html" class="classname">TypeError</a></span> is thrown. </p> </div> <div class="sect2"> <h3 class="title">String contexts</h3> <p class="simpara"> This is the context when using <span class="function"><a href="function.echo.html" class="function">echo</a></span>, <span class="function"><a href="function.print.html" class="function">print</a></span>, <a href="language.types.string.html#language.types.string.parsing" class="link">string interpolation</a>, or the string <a href="language.operators.string.html" class="link">concatenation operator</a>. </p> <p class="simpara"> In this context the value will be interpreted as <span class="type">string</span>. If the value cannot be interpreted a <span class="classname"><a href="class.typeerror.html" class="classname">TypeError</a></span> is thrown. Prior to PHP 7.4.0, an <strong><code>E_RECOVERABLE_ERROR</code></strong> was raised. </p> </div> <div class="sect2"> <h3 class="title">Logical contexts</h3> <p class="simpara"> This is the context when using conditional statements, the <a href="language.operators.comparison.html#language.operators.comparison.ternary" class="link">ternary operator</a>, or a <a href="language.operators.logical.html" class="link">logical operator</a>. </p> <p class="simpara"> In this context the value will be interpreted as <span class="type">bool</span>. </p> </div> <div class="sect2"> <h3 class="title">Integral and string contexts</h3> <p class="simpara"> This is the context when using <a href="language.operators.bitwise.html" class="link">bitwise operators</a>. </p> <p class="simpara"> In this context if all operands are of type <span class="type">string</span> the result will also be a <span class="type">string</span>. Otherwise, the operands will be interpreted as <span class="type">int</span>s, and the result will also be an <span class="type">int</span>. As of PHP 8.0.0, if one of the operands cannot be interpreted a <span class="classname"><a href="class.typeerror.html" class="classname">TypeError</a></span> is thrown. </p> </div> <div class="sect2"> <h3 class="title">Comparative contexts</h3> <p class="simpara"> This is the context when using a <a href="language.operators.comparison.html" class="link">comparison operator</a>. </p> <p class="simpara"> The type conversions which occur in this context are explained in the Comparison with Various Types <a href="language.operators.comparison.html#language.operators.comparison.types" class="link">table</a>. </p> </div> <div class="sect2" id="language.types.type-juggling.function"> <h3 class="title">Function contexts</h3> <p class="simpara"> This is the context when a value is passed to a typed parameter, property, or returned from a function which declares a return type. </p> <p class="para"> In this context the value must be a value of the type. Two exceptions exist, the first one is: if the value is of type <span class="type">int</span> and the declared type is <span class="type">float</span>, then the integer is converted to a floating point number. The second one is: if the declared type is a <em>scalar</em> type, the value is convertable to a scalar type, and the coercive typing mode is active (the default), the value may be converted to an accepted scalar value. See below for a description of this behaviour. </p> <div class="warning">
<strong class="warning">Warning</strong> <p class="simpara"> <a href="functions.internal.html" class="link">Internal functions</a> automatically coerce <strong><code>null</code></strong> to scalar types, this behaviour is <em>DEPRECATED</em> as of PHP 8.1.0. </p> </div> <div class="sect3" id="language.types.type-juggling.function.simple"> <h4 class="title">Coercive typing with simple type declarations</h4> <ul class="itemizedlist"> <li class="listitem"> <span class="simpara"> <span class="type">bool</span> type declaration: value is interpreted as <span class="type">bool</span>. </span> </li> <li class="listitem"> <span class="simpara"> <span class="type">int</span> type declaration: value is interpreted as <span class="type">int</span> if the conversion is well-defined. For example the string is <a href="language.types.numeric-strings.html" class="link">numeric</a>. </span> </li> <li class="listitem"> <span class="simpara"> <span class="type">float</span> type declaration: value is interpreted as <span class="type">float</span> if the conversion is well-defined. For example the string is <a href="language.types.numeric-strings.html" class="link">numeric</a>. </span> </li> <li class="listitem"> <span class="simpara"> <span class="type">string</span> type declaration: value is interpreted as <span class="type">string</span>. </span> </li> </ul> </div> <div class="sect3" id="language.types.type-juggling.function.union"> <h4 class="title">Coercive typing with union types</h4> <p class="para"> When <code class="literal">strict_types</code> is not enabled, scalar type declarations are subject to limited implicit type coercions. If the exact type of the value is not part of the union, then the target type is chosen in the following order of preference: </p>
<ol type="1"> <li class="listitem"> <span class="simpara"> <span class="type">int</span> </span> </li> <li class="listitem"> <span class="simpara"> <span class="type">float</span> </span> </li> <li class="listitem"> <span class="simpara"> <span class="type">string</span> </span> </li> <li class="listitem"> <span class="simpara"> <span class="type">bool</span> </span> </li> </ol> If the type exists in the union and the value can be coerced to the type under PHP's existing type-checking semantics, then the type is chosen. Otherwise, the next type is tried. <div class="caution">
<strong class="caution">Caution</strong> <p class="para"> As an exception, if the value is a string and both int and float are part of the union, the preferred type is determined by the existing <a href="language.types.numeric-strings.html" class="link">numeric string</a> semantics. For example, for <code class="literal">"42"</code> <span class="type">int</span> is chosen, while for <code class="literal">"42.0"</code> <span class="type">float</span> is chosen. </p> </div> <blockquote class="note">
<p><strong class="note">Note</strong>: </p>
<p class="para"> Types that are not part of the above preference list are not eligible targets for implicit coercion. In particular no implicit coercions to the <span class="type">null</span>, <span class="type"><span class="type false">false</span></span>, and <span class="type"><span class="type true">true</span></span> types occur. </p> </blockquote> <div class="example" id="language.oop5.traits.conflict.ex1"> <p><strong>Example #1 Example of types being coerced into a type part of the union</strong></p> <div class="example-contents"> <pre class="phpcode" data-language="php">&lt;?php
// int|string
42    --&gt; 42          // exact type
"42"  --&gt; "42"        // exact type
new ObjectWithToString --&gt; "Result of __toString()"
                      // object never compatible with int, fall back to string
42.0  --&gt; 42          // float compatible with int
42.1  --&gt; 42          // float compatible with int
1e100 --&gt; "1.0E+100"  // float too large for int type, fall back to string
INF   --&gt; "INF"       // float too large for int type, fall back to string
true  --&gt; 1           // bool compatible with int
[]    --&gt; TypeError   // array not compatible with int or string

// int|float|bool
"45"    --&gt; 45        // int numeric string
"45.0"  --&gt; 45.0      // float numeric string

"45X"   --&gt; true      // not numeric string, fall back to bool
""      --&gt; false     // not numeric string, fall back to bool
"X"     --&gt; true      // not numeric string, fall back to bool
[]      --&gt; TypeError // array not compatible with int, float or bool
?&gt;</pre> </div> </div> </div> </div> <div class="sect2" id="language.types.typecasting"> <h3 class="title">Type Casting</h3> <p class="simpara"> Type casting converts the value to a chosen type by writing the type within parentheses before the value to convert. </p> <div class="informalexample"> <div class="example-contents"> <pre class="phpcode" data-language="php">&lt;?php
$foo = 10;   // $foo is an integer
$bar = (bool) $foo;   // $bar is a boolean
?&gt;</pre> </div> </div> <p class="simpara"> The casts allowed are: </p> <ul class="simplelist"> <li class="member">
<code class="literal">(int)</code> - cast to <span class="type">int</span>
</li> <li class="member">
<code class="literal">(bool)</code> - cast to <span class="type">bool</span>
</li> <li class="member">
<code class="literal">(float)</code> - cast to <span class="type">float</span>
</li> <li class="member">
<code class="literal">(string)</code> - cast to <span class="type">string</span>
</li> <li class="member">
<code class="literal">(array)</code> - cast to <span class="type">array</span>
</li> <li class="member">
<code class="literal">(object)</code> - cast to <span class="type">object</span>
</li> <li class="member">
<code class="literal">(unset)</code> - cast to <span class="type">NULL</span>
</li> </ul> <blockquote class="note">
<p><strong class="note">Note</strong>: </p>
<p class="para"> <code class="literal">(integer)</code> is an alias of the <code class="literal">(int)</code> cast. <code class="literal">(boolean)</code> is an alias of the <code class="literal">(bool)</code> cast. <code class="literal">(binary)</code> is an alias of the <code class="literal">(string)</code> cast. <code class="literal">(double)</code> and <code class="literal">(real)</code> are aliases of the <code class="literal">(float)</code> cast. These casts do not use the canonical type name and are not recommended. </p> </blockquote> <div class="warning">
<strong class="warning">Warning</strong> <p class="simpara"> The <code class="literal">(real)</code> cast alias has been deprecated as of PHP 8.0.0. </p> </div> <div class="warning">
<strong class="warning">Warning</strong> <p class="simpara"> The <code class="literal">(unset)</code> cast has been deprecated as of PHP 7.2.0. Note that the <code class="literal">(unset)</code> cast is the same as assigning the value <span class="type">NULL</span> to the variable or call. The <code class="literal">(unset)</code> cast is removed as of PHP 8.0.0. </p> </div> <div class="caution">
<strong class="caution">Caution</strong> <p class="simpara"> The <code class="literal">(binary)</code> cast and <code class="literal">b</code> prefix exists for forward support. Currently <code class="literal">(binary)</code> and <code class="literal">(string)</code> are identical, however this may change and should not be relied upon. </p> </div> <blockquote class="note">
<p><strong class="note">Note</strong>: </p>
<p class="para"> Whitespaces are ignored within the parentheses of a cast. Therefore, the following two casts are equivalent: </p>
<div class="informalexample"> <div class="example-contents"> <pre class="phpcode" data-language="php">&lt;?php
$foo = (int) $bar;
$foo = ( int ) $bar;
?&gt;</pre> </div> </div> </blockquote> <div class="informalexample"> <p class="simpara"> Casting literal <span class="type">string</span>s and variables to binary <span class="type">string</span>s: </p> <div class="example-contents"> <pre class="phpcode" data-language="php">&lt;?php
$binary = (binary) $string;
$binary = b"binary string";
?&gt;</pre> </div> </div> <blockquote class="note">
<p><strong class="note">Note</strong>: <span class="simpara"> Instead of casting a variable to a <span class="type">string</span>, it is also possible to enclose the variable in double quotes. </span> </p>
<div class="informalexample"> <div class="example-contents"> <pre class="phpcode" data-language="php">&lt;?php
$foo = 10;            // $foo is an integer
$str = "$foo";        // $str is a string
$fst = (string) $foo; // $fst is also a string

// This prints out that "they are the same"
if ($fst === $str) {
    echo "they are the same";
}
?&gt;</pre> </div> </div> </blockquote> <p class="para"> It may not be obvious exactly what will happen when casting between certain types. For more information, see these sections: </p>
<ul class="simplelist"> <li class="member"><a href="language.types.boolean.html#language.types.boolean.casting" class="link">Converting to boolean</a></li> <li class="member"><a href="language.types.integer.html#language.types.integer.casting" class="link">Converting to integer</a></li> <li class="member"><a href="language.types.float.html#language.types.float.casting" class="link">Converting to float</a></li> <li class="member"><a href="language.types.string.html#language.types.string.casting" class="link">Converting to string</a></li> <li class="member"><a href="language.types.array.html#language.types.array.casting" class="link">Converting to array</a></li> <li class="member"><a href="language.types.object.html#language.types.object.casting" class="link">Converting to object</a></li> <li class="member"><a href="language.types.resource.html#language.types.resource.casting" class="link">Converting to resource</a></li> <li class="member"><a href="language.types.null.html#language.types.null.casting" class="link">Converting to NULL</a></li> <li class="member"><a href="https://www.php.net/manual/en/types.comparisons.php" class="link">The type comparison tables</a></li> </ul> </div> <div class="simplesect"> <blockquote class="note">
<p><strong class="note">Note</strong>: <span class="simpara"> Because PHP supports indexing into <span class="type">string</span>s via offsets using the same syntax as <span class="type">array</span> indexing, the following example holds true for all PHP versions: </span> </p>
<div class="informalexample"> <div class="example-contents"> <pre class="phpcode" data-language="php">&lt;?php
$a    = 'car'; // $a is a string
$a[0] = 'b';   // $a is still a string
echo $a;       // bar
?&gt;</pre> </div> </div> <span class="simpara"> See the section titled <a href="language.types.string.html#language.types.string.substr" class="link">String access by character</a> for more information. </span> </blockquote> </div> </div></div>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1997&ndash;2023 The PHP Documentation Group<br>Licensed under the Creative Commons Attribution License v3.0 or later.<br>
    <a href="https://www.php.net/manual/en/language.types.type-juggling.php" class="_attribution-link">https://www.php.net/manual/en/language.types.type-juggling.php</a>
  </p>
</div>
