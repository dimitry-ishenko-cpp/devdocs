  <div id="layout"> <div id="layout-content"><div id="language.oop5.paamayim-nekudotayim" class="sect1"> <h2 class="title">Scope Resolution Operator (::)</h2> <p class="para"> The Scope Resolution Operator (also called Paamayim Nekudotayim) or in simpler terms, the double colon, is a token that allows access to a <a href="language.oop5.constants.html" class="link">constant</a>, <a href="language.oop5.static.html" class="link">static</a> property, or <a href="language.oop5.static.html" class="link">static</a> method of a class or one of its parents. Moreover, static properties or methods can be overriden via <a href="language.oop5.late-static-bindings.html" class="link">late static binding</a>. </p> <p class="para"> When referencing these items from outside the class definition, use the name of the class. </p> <p class="para"> It's possible to reference the class using a variable. The variable's value can not be a keyword (e.g. <code class="literal">self</code>, <code class="literal">parent</code> and <code class="literal">static</code>). </p> <p class="para"> Paamayim Nekudotayim would, at first, seem like a strange choice for naming a double-colon. However, while writing the Zend Engine 0.5 (which powers PHP 3), that's what the Zend team decided to call it. It actually does mean double-colon - in Hebrew! </p> <div class="example" id="example-255"> <p><strong>Example #1 :: from outside the class definition</strong></p> <div class="example-contents"> <pre class="phpcode" data-language="php">&lt;?php
class MyClass {
    const CONST_VALUE = 'A constant value';
}

$classname = 'MyClass';
echo $classname::CONST_VALUE;

echo MyClass::CONST_VALUE;
?&gt;</pre> </div> </div> <p class="para"> Three special keywords <var class="varname">self</var>, <var class="varname">parent</var> and <var class="varname">static</var> are used to access properties or methods from inside the class definition. </p> <div class="example" id="example-256"> <p><strong>Example #2 :: from inside the class definition</strong></p> <div class="example-contents"> <pre class="phpcode" data-language="php">&lt;?php
class OtherClass extends MyClass
{
    public static $my_static = 'static var';

    public static function doubleColon() {
        echo parent::CONST_VALUE . "\n";
        echo self::$my_static . "\n";
    }
}

$classname = 'OtherClass';
$classname::doubleColon();

OtherClass::doubleColon();
?&gt;</pre> </div> </div> <p class="para"> When an extending class overrides the parent's definition of a method, PHP will not call the parent's method. It's up to the extended class on whether or not the parent's method is called. This also applies to <a href="language.oop5.decon.html" class="link">Constructors and Destructors</a>, <a href="language.oop5.overloading.html" class="link">Overloading</a>, and <a href="language.oop5.magic.html" class="link">Magic</a> method definitions. </p> <div class="example" id="example-257"> <p><strong>Example #3 Calling a parent's method</strong></p> <div class="example-contents"> <pre class="phpcode" data-language="php">&lt;?php
class MyClass
{
    protected function myFunc() {
        echo "MyClass::myFunc()\n";
    }
}

class OtherClass extends MyClass
{
    // Override parent's definition
    public function myFunc()
    {
        // But still call the parent function
        parent::myFunc();
        echo "OtherClass::myFunc()\n";
    }
}

$class = new OtherClass();
$class-&gt;myFunc();
?&gt;</pre> </div> </div> <p class="para"> See also <a href="language.oop5.basic.html#language.oop5.basic.class.this" class="link">some examples of static call trickery</a>. </p> </div></div>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1997&ndash;2024 The PHP Documentation Group<br>Licensed under the Creative Commons Attribution License v3.0 or later.<br>
    <a href="https://www.php.net/manual/en/language.oop5.paamayim-nekudotayim.php" class="_attribution-link">https://www.php.net/manual/en/language.oop5.paamayim-nekudotayim.php</a>
  </p>
</div>
