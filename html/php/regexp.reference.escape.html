  <div id="layout"> <div id="layout-content"> <h2 class="title">Escape sequences</h2> <p class="para"> The backslash character has several uses. Firstly, if it is followed by a non-alphanumeric character, it takes away any special meaning that character may have. This use of backslash as an escape character applies both inside and outside character classes. </p> <p class="para"> For example, if you want to match a "*" character, you write "\*" in the pattern. This applies whether or not the following character would otherwise be interpreted as a meta-character, so it is always safe to precede a non-alphanumeric with "\" to specify that it stands for itself. In particular, if you want to match a backslash, you write "\\". </p> <blockquote class="note">
<p><strong class="note">Note</strong>: </p>
<p class="para"> Single and double quoted PHP <a href="language.types.string.html#language.types.string.syntax" class="link">strings</a> have special meaning of backslash. Thus if \ has to be matched with a regular expression \\, then "\\\\" or '\\\\' must be used in PHP code. </p> </blockquote> <p class="para"> If a pattern is compiled with the <a href="reference.pcre.pattern.modifiers.html" class="link">PCRE_EXTENDED</a> option, whitespace in the pattern (other than in a character class) and characters between a "#" outside a character class and the next newline character are ignored. An escaping backslash can be used to include a whitespace or "#" character as part of the pattern. </p> <p class="para"> A second use of backslash provides a way of encoding non-printing characters in patterns in a visible manner. There is no restriction on the appearance of non-printing characters, apart from the binary zero that terminates a pattern, but when a pattern is being prepared by text editing, it is usually easier to use one of the following escape sequences than the binary character it represents: </p> 
<dl> <dt><em>\a</em></dt> <dd> <span class="simpara">alarm, that is, the BEL character (hex 07)</span> </dd> <dt><em>\cx</em></dt> <dd> <span class="simpara">"control-x", where x is any character</span> </dd> <dt><em>\e</em></dt> <dd> <span class="simpara">escape (hex 1B)</span> </dd> <dt><em>\f</em></dt> <dd> <span class="simpara">formfeed (hex 0C)</span> </dd> <dt><em>\n</em></dt> <dd> <span class="simpara">newline (hex 0A)</span> </dd> <dt><em>\p{xx}</em></dt> <dd> <span class="simpara"> a character with the xx property, see <a href="regexp.reference.unicode.html" class="link">unicode properties</a> for more info </span> </dd> <dt><em>\P{xx}</em></dt> <dd> <span class="simpara"> a character without the xx property, see <a href="regexp.reference.unicode.html" class="link">unicode properties</a> for more info </span> </dd> <dt><em>\r</em></dt> <dd> <span class="simpara">carriage return (hex 0D)</span> </dd> <dt><em>\R</em></dt> <dd> <span class="simpara">line break: matches \n, \r and \r\n</span> </dd> <dt><em>\t</em></dt> <dd> <span class="simpara">tab (hex 09)</span> </dd> <dt><em>\xhh</em></dt> <dd> <span class="simpara"> character with hex code hh </span> </dd> <dt><em>\ddd</em></dt> <dd> <span class="simpara">character with octal code ddd, or backreference</span> </dd> </dl> <p class="para"> The precise effect of "<code class="literal">\cx</code>" is as follows: if "<code class="literal">x</code>" is a lower case letter, it is converted to upper case. Then bit 6 of the character (hex 40) is inverted. Thus "<code class="literal">\cz</code>" becomes hex 1A, but "<code class="literal">\c{</code>" becomes hex 3B, while "<code class="literal">\c;</code>" becomes hex 7B. </p> <p class="para"> After "<code class="literal">\x</code>", up to two hexadecimal digits are read (letters can be in upper or lower case). In <em>UTF-8 mode</em>, "<code class="literal">\x{...}</code>" is allowed, where the contents of the braces is a string of hexadecimal digits. It is interpreted as a UTF-8 character whose code number is the given hexadecimal number. The original hexadecimal escape sequence, <code class="literal">\xhh</code>, matches a two-byte UTF-8 character if the value is greater than 127. </p> <p class="para"> After "<code class="literal">\0</code>" up to two further octal digits are read. In both cases, if there are fewer than two digits, just those that are present are used. Thus the sequence "<code class="literal">\0\x\07</code>" specifies two binary zeros followed by a BEL character. Make sure you supply two digits after the initial zero if the character that follows is itself an octal digit. </p> <p class="para"> The handling of a backslash followed by a digit other than 0 is complicated. Outside a character class, PCRE reads it and any following digits as a decimal number. If the number is less than 10, or if there have been at least that many previous capturing left parentheses in the expression, the entire sequence is taken as a <em>back reference</em>. A description of how this works is given later, following the discussion of parenthesized subpatterns. </p> <p class="para"> Inside a character class, or if the decimal number is greater than 9 and there have not been that many capturing subpatterns, PCRE re-reads up to three octal digits following the backslash, and generates a single byte from the least significant 8 bits of the value. Any subsequent digits stand for themselves. For example: </p> 
<dl> <dt><em>\040</em></dt> <dd><span class="simpara">is another way of writing a space</span></dd> <dt><em>\40</em></dt> <dd> <span class="simpara"> is the same, provided there are fewer than 40 previous capturing subpatterns </span> </dd> <dt><em>\7</em></dt> <dd><span class="simpara">is always a back reference</span></dd> <dt><em>\11</em></dt> <dd> <span class="simpara"> might be a back reference, or another way of writing a tab </span> </dd> <dt><em>\011</em></dt> <dd><span class="simpara">is always a tab</span></dd> <dt><em>\0113</em></dt> <dd><span class="simpara">is a tab followed by the character "3"</span></dd> <dt><em>\113</em></dt> <dd> <span class="simpara"> is the character with octal code 113 (since there can be no more than 99 back references) </span> </dd> <dt><em>\377</em></dt> <dd><span class="simpara">is a byte consisting entirely of 1 bits</span></dd> <dt><em>\81</em></dt> <dd> <span class="simpara"> is either a back reference, or a binary zero followed by the two characters "8" and "1" </span> </dd> </dl> <p class="para"> Note that octal values of 100 or greater must not be introduced by a leading zero, because no more than three octal digits are ever read. </p> <p class="para"> All the sequences that define a single byte value can be used both inside and outside character classes. In addition, inside a character class, the sequence "<code class="literal">\b</code>" is interpreted as the backspace character (hex 08). Outside a character class it has a different meaning (see below). </p> <p class="para"> The third use of backslash is for specifying generic character types: </p> 
<dl> <dt><em>\d</em></dt> <dd><span class="simpara">any decimal digit</span></dd> <dt><em>\D</em></dt> <dd><span class="simpara">any character that is not a decimal digit</span></dd> <dt><em>\h</em></dt> <dd><span class="simpara">any horizontal whitespace character</span></dd> <dt><em>\H</em></dt> <dd><span class="simpara">any character that is not a horizontal whitespace character</span></dd> <dt><em>\s</em></dt> <dd><span class="simpara">any whitespace character</span></dd> <dt><em>\S</em></dt> <dd><span class="simpara">any character that is not a whitespace character</span></dd> <dt><em>\v</em></dt> <dd><span class="simpara">any vertical whitespace character</span></dd> <dt><em>\V</em></dt> <dd><span class="simpara">any character that is not a vertical whitespace character</span></dd> <dt><em>\w</em></dt> <dd><span class="simpara">any "word" character</span></dd> <dt><em>\W</em></dt> <dd><span class="simpara">any "non-word" character</span></dd> </dl> <p class="para"> Each pair of escape sequences partitions the complete set of characters into two disjoint sets. Any given character matches one, and only one, of each pair. </p> <p class="para"> The "whitespace" characters are HT (9), LF (10), FF (12), CR (13), and space (32). However, if locale-specific matching is happening, characters with code points in the range 128-255 may also be considered as whitespace characters, for instance, NBSP (A0). </p> <p class="para"> A "word" character is any letter or digit or the underscore character, that is, any character which can be part of a Perl "<em>word</em>". The definition of letters and digits is controlled by PCRE's character tables, and may vary if locale-specific matching is taking place. For example, in the "fr" (French) locale, some character codes greater than 128 are used for accented letters, and these are matched by <code class="literal">\w</code>. </p> <p class="para"> These character type sequences can appear both inside and outside character classes. They each match one character of the appropriate type. If the current matching point is at the end of the subject string, all of them fail, since there is no character to match. </p> <p class="para"> The fourth use of backslash is for certain simple assertions. An assertion specifies a condition that has to be met at a particular point in a match, without consuming any characters from the subject string. The use of subpatterns for more complicated assertions is described below. The backslashed assertions are </p> 
<dl> <dt><em>\b</em></dt> <dd><span class="simpara">word boundary</span></dd> <dt><em>\B</em></dt> <dd><span class="simpara">not a word boundary</span></dd> <dt><em>\A</em></dt> <dd><span class="simpara">start of subject (independent of multiline mode)</span></dd> <dt><em>\Z</em></dt> <dd> <span class="simpara"> end of subject or newline at end (independent of multiline mode) </span> </dd> <dt><em>\z</em></dt> <dd><span class="simpara">end of subject (independent of multiline mode)</span></dd> <dt><em>\G</em></dt> <dd><span class="simpara">first matching position in subject</span></dd> </dl> <p class="para"> These assertions may not appear in character classes (but note that "<code class="literal">\b</code>" has a different meaning, namely the backspace character, inside a character class). </p> <p class="para"> A word boundary is a position in the subject string where the current character and the previous character do not both match <code class="literal">\w</code> or <code class="literal">\W</code> (i.e. one matches <code class="literal">\w</code> and the other matches <code class="literal">\W</code>), or the start or end of the string if the first or last character matches <code class="literal">\w</code>, respectively. </p> <p class="para"> The <code class="literal">\A</code>, <code class="literal">\Z</code>, and <code class="literal">\z</code> assertions differ from the traditional circumflex and dollar (described in <a href="regexp.reference.anchors.html" class="link">anchors</a> ) in that they only ever match at the very start and end of the subject string, whatever options are set. They are not affected by the <a href="reference.pcre.pattern.modifiers.html" class="link">PCRE_MULTILINE</a> or <a href="reference.pcre.pattern.modifiers.html" class="link">PCRE_DOLLAR_ENDONLY</a> options. The difference between <code class="literal">\Z</code> and <code class="literal">\z</code> is that <code class="literal">\Z</code> matches before a newline that is the last character of the string as well as at the end of the string, whereas <code class="literal">\z</code> matches only at the end. </p> <p class="para"> The <code class="literal">\G</code> assertion is true only when the current matching position is at the start point of the match, as specified by the <code class="parameter">offset</code> argument of <span class="function"><a href="function.preg-match.html" class="function">preg_match()</a></span>. It differs from <code class="literal">\A</code> when the value of <code class="parameter">offset</code> is non-zero. </p> <p class="para"> <code class="literal">\Q</code> and <code class="literal">\E</code> can be used to ignore regexp metacharacters in the pattern. For example: <code class="literal">\w+\Q.$.\E$</code> will match one or more word characters, followed by literals <code class="literal">.$.</code> and anchored at the end of the string. Note that this does not change the behavior of delimiters; for instance the pattern <code class="literal">#\Q#\E#$</code> is not valid, because the second <code class="literal">#</code> marks the end of the pattern, and the <code class="literal">\E#</code> is interpreted as invalid modifiers. </p> <p class="para"> <code class="literal">\K</code> can be used to reset the match start. For example, the pattern <code class="literal">foo\Kbar</code> matches "foobar", but reports that it has matched "bar". The use of <code class="literal">\K</code> does not interfere with the setting of captured substrings. For example, when the pattern <code class="literal">(foo)\Kbar</code> matches "foobar", the first substring is still set to "foo". </p> </div>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1997&ndash;2024 The PHP Documentation Group<br>Licensed under the Creative Commons Attribution License v3.0 or later.<br>
    <a href="https://www.php.net/manual/en/regexp.reference.escape.php" class="_attribution-link">https://www.php.net/manual/en/regexp.reference.escape.php</a>
  </p>
</div>
