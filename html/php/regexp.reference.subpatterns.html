  <div id="layout"> <div id="layout-content"> <h2 class="title">Subpatterns</h2> <p class="para"> Subpatterns are delimited by parentheses (round brackets), which can be nested. Marking part of a pattern as a subpattern does two things: </p> <ol type="1"> <li class="listitem"> <p class="para"> It localizes a set of alternatives. For example, the pattern <code class="literal">cat(aract|erpillar|)</code> matches one of the words "cat", "cataract", or "caterpillar". Without the parentheses, it would match "cataract", "erpillar" or the empty string. </p> </li> <li class="listitem"> <p class="para"> It sets up the subpattern as a capturing subpattern (as defined above). When the whole pattern matches, that portion of the subject string that matched the subpattern is passed back to the caller via the <em>ovector</em> argument of <span class="function"><strong>pcre_exec()</strong></span>. Opening parentheses are counted from left to right (starting from 1) to obtain the numbers of the capturing subpatterns. </p> </li> </ol> <p class="para"> For example, if the string "the red king" is matched against the pattern <code class="literal">the ((red|white) (king|queen))</code> the captured substrings are "red king", "red", and "king", and are numbered 1, 2, and 3. </p> <p class="para"> The fact that plain parentheses fulfill two functions is not always helpful. There are often times when a grouping subpattern is required without a capturing requirement. If an opening parenthesis is followed by "?:", the subpattern does not do any capturing, and is not counted when computing the number of any subsequent capturing subpatterns. For example, if the string "the white queen" is matched against the pattern <code class="literal">the ((?:red|white) (king|queen))</code> the captured substrings are "white queen" and "queen", and are numbered 1 and 2. The maximum number of captured substrings is 65535. It may not be possible to compile such large patterns, however, depending on the configuration options of libpcre. </p> <p class="para"> As a convenient shorthand, if any option settings are required at the start of a non-capturing subpattern, the option letters may appear between the "?" and the ":". Thus the two patterns </p> <div class="informalexample"> <div class="example-contents"> <div class="cdata"><pre>
(?i:saturday|sunday)
(?:(?i)saturday|sunday)
</pre></div> </div> </div> <p class="para"> match exactly the same set of strings. Because alternative branches are tried from left to right, and options are not reset until the end of the subpattern is reached, an option setting in one branch does affect subsequent branches, so the above patterns match "SUNDAY" as well as "Saturday". </p> <p class="para"> It is possible to name a subpattern using the syntax <code class="literal">(?P&lt;name&gt;pattern)</code>. This subpattern will then be indexed in the matches array by its normal numeric position and also by name. There are two alternative syntaxes <code class="literal">(?&lt;name&gt;pattern)</code> and <code class="literal">(?'name'pattern)</code>. </p> <p class="para"> Sometimes it is necessary to have multiple matching, but alternating subgroups in a regular expression. Normally, each of these would be given their own backreference number even though only one of them would ever possibly match. To overcome this, the <code class="literal">(?|</code> syntax allows having duplicate numbers. Consider the following regex matched against the string <code class="literal">Sunday</code>: </p> <div class="informalexample"> <div class="example-contents"> <div class="cdata"><pre>(?:(Sat)ur|(Sun))day</pre></div> </div> </div> <p class="para"> Here <code class="literal">Sun</code> is stored in backreference 2, while backreference 1 is empty. Matching <code class="literal">Saturday</code> yields <code class="literal">Sat</code> in backreference 1 while backreference 2 does not exist. Changing the pattern to use the <code class="literal">(?|</code> fixes this problem: </p> <div class="informalexample"> <div class="example-contents"> <div class="cdata"><pre>(?|(Sat)ur|(Sun))day</pre></div> </div> </div> <p class="para"> Using this pattern, both <code class="literal">Sun</code> and <code class="literal">Sat</code> would be stored in backreference 1. </p> </div>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1997&ndash;2024 The PHP Documentation Group<br>Licensed under the Creative Commons Attribution License v3.0 or later.<br>
    <a href="https://www.php.net/manual/en/regexp.reference.subpatterns.php" class="_attribution-link">https://www.php.net/manual/en/regexp.reference.subpatterns.php</a>
  </p>
</div>
