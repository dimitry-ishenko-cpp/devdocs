<h1 id="serving-wsgi-applications">Serving WSGI Applications</h1> <p>There are many ways to serve a WSGI application. While you’re developing it, you usually don’t want to have a full-blown webserver like Apache up and running, but instead a simple standalone one. Because of that Werkzeug comes with a builtin development server.</p> <p>The easiest way is creating a small <code>start-myproject.py</code> file that runs the application using the builtin server:</p> <pre data-language="python">from werkzeug.serving import run_simple
from myproject import make_app

app = make_app(...)
run_simple('localhost', 8080, app, use_reloader=True)
</pre> <p>You can also pass it the <code>extra_files</code> keyword argument with a list of additional files (like configuration files) you want to observe.</p> <dl class="py function"> <dt class="sig sig-object py" id="werkzeug.serving.run_simple">
<code>werkzeug.serving.run_simple(hostname, port, application, use_reloader=False, use_debugger=False, use_evalex=True, extra_files=None, exclude_patterns=None, reloader_interval=1, reloader_type='auto', threaded=False, processes=1, request_handler=None, static_files=None, passthrough_errors=False, ssl_context=None)</code> </dt> <dd>
<p>Start a development server for a WSGI application. Various optional features can be enabled.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>Do not use the development server when deploying to production. It is intended for use only during local development. It is not designed to be particularly efficient, stable, or secure.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>hostname</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)">str</a>) – The host to bind to, for example <code>'localhost'</code>. Can be a domain, IPv4 or IPv6 address, or file path starting with <code>unix://</code> for a Unix socket.</li> <li>
<strong>port</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)">int</a>) – The port to bind to, for example <code>8080</code>. Using <code>0</code> tells the OS to pick a random free port.</li> <li>
<strong>application</strong> (<em>WSGIApplication</em>) – The WSGI application to run.</li> <li>
<strong>use_reloader</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)">bool</a>) – Use a reloader process to restart the server process when files are changed.</li> <li>
<strong>use_debugger</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)">bool</a>) – Use Werkzeug’s debugger, which will show formatted tracebacks on unhandled exceptions.</li> <li>
<strong>use_evalex</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)">bool</a>) – Make the debugger interactive. A Python terminal can be opened for any frame in the traceback. Some protection is provided by requiring a PIN, but this should never be enabled on a publicly visible server.</li> <li>
<strong>extra_files</strong> (<em>t.Iterable</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)">str</a><em>] </em><em>| </em><em>None</em>) – The reloader will watch these files for changes in addition to Python modules. For example, watch a configuration file.</li> <li>
<strong>exclude_patterns</strong> (<em>t.Iterable</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)">str</a><em>] </em><em>| </em><em>None</em>) – The reloader will ignore changes to any files matching these <a class="reference external" href="https://docs.python.org/3/library/fnmatch.html#module-fnmatch" title="(in Python v3.11)"><code>fnmatch</code></a> patterns. For example, ignore cache files.</li> <li>
<strong>reloader_interval</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)">int</a>) – How often the reloader tries to check for changes.</li> <li>
<strong>reloader_type</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)">str</a>) – The reloader to use. The <code>'stat'</code> reloader is built in, but may require significant CPU to watch files. The <code>'watchdog'</code> reloader is much more efficient but requires installing the <code>watchdog</code> package first.</li> <li>
<strong>threaded</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)">bool</a>) – Handle concurrent requests using threads. Cannot be used with <code>processes</code>.</li> <li>
<strong>processes</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)">int</a>) – Handle concurrent requests using up to this number of processes. Cannot be used with <code>threaded</code>.</li> <li>
<strong>request_handler</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#type" title="(in Python v3.11)">type</a><em>[</em><em>WSGIRequestHandler</em><em>] </em><em>| </em><em>None</em>) – Use a different <code>BaseHTTPRequestHandler</code> subclass to handle requests.</li> <li>
<strong>static_files</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.11)">dict</a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)">str</a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)">str</a><em> | </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)">tuple</a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)">str</a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)">str</a><em>]</em><em>] </em><em>| </em><em>None</em>) – A dict mapping URL prefixes to directories to serve static files from using <code>SharedDataMiddleware</code>.</li> <li>
<strong>passthrough_errors</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)">bool</a>) – Don’t catch unhandled exceptions at the server level, let the server crash instead. If <code>use_debugger</code> is enabled, the debugger will still catch such errors.</li> <li>
<strong>ssl_context</strong> (<em>_TSSLContextArg</em><em> | </em><em>None</em>) – Configure TLS to serve over HTTPS. Can be an <a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLContext" title="(in Python v3.11)"><code>ssl.SSLContext</code></a> object, a <code>(cert_file, key_file)</code> tuple to create a typical context, or the string <code>'adhoc'</code> to generate a temporary self-signed certificate.</li> </ul> </dd> <dt class="field-even">Return type<span class="colon">:</span>
</dt> <dd class="field-even">
<p>None</p> </dd> </dl> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.1: </span>Instructions are shown for dealing with an “address already in use” error.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.1: </span>Running on <code>0.0.0.0</code> or <code>::</code> shows the loopback IP in addition to a real IP.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.1: </span>The command-line interface was removed.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.0: </span>Running on <code>0.0.0.0</code> or <code>::</code> shows a real IP address that was bound as well as a warning not to run the development server in production.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.0: </span>The <code>exclude_patterns</code> parameter was added.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.15: </span>Bind to a Unix socket by passing a <code>hostname</code> that starts with <code>unix://</code>.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.10: </span>Improved the reloader and added support for changing the backend through the <code>reloader_type</code> parameter.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.9: </span>A command-line interface was added.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.8: </span><code>ssl_context</code> can be a tuple of paths to the certificate and private key files.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.6: </span>The <code>ssl_context</code> parameter was added.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.5: </span>The <code>static_files</code> and <code>passthrough_errors</code> parameters were added.</p> </div> </details>
</dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="werkzeug.serving.is_running_from_reloader">
<code>werkzeug.serving.is_running_from_reloader()</code> </dt> <dd>
<p>Check if the server is running as a subprocess within the Werkzeug reloader.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.10.</span></p> </div> </details><dl class="field-list simple"> <dt class="field-odd">Return type<span class="colon">:</span>
</dt> <dd class="field-odd">
<p><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)">bool</a></p> </dd> </dl> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="werkzeug.serving.make_ssl_devcert">
<code>werkzeug.serving.make_ssl_devcert(base_path, host=None, cn=None)</code> </dt> <dd>
<p>Creates an SSL key for development. This should be used instead of the <code>'adhoc'</code> key which generates a new cert on each server start. It accepts a path for where it should store the key and cert and either a host or CN. If a host is given it will use the CN <code>*.host/CN=host</code>.</p> <p>For more information see <a class="reference internal" href="#werkzeug.serving.run_simple" title="werkzeug.serving.run_simple"><code>run_simple()</code></a>.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.9.</span></p> </div> </details><dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>base_path</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)">str</a>) – the path to the certificate and key. The extension <code>.crt</code> is added for the certificate, <code>.key</code> is added for the key.</li> <li>
<strong>host</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)">str</a><em> | </em><em>None</em>) – the name of the host. This can be used as an alternative for the <code>cn</code>.</li> <li>
<strong>cn</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)">str</a><em> | </em><em>None</em>) – the <code>CN</code> to use.</li> </ul> </dd> <dt class="field-even">Return type<span class="colon">:</span>
</dt> <dd class="field-even">
<p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)">tuple</a>[<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)">str</a>, <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)">str</a>]</p> </dd> </dl> </dd>
</dl> <div class="admonition-information admonition"> <p class="admonition-title">Information</p> <p>The development server is not intended to be used on production systems. It was designed especially for development purposes and performs poorly under high load. For deployment setups have a look at the <a class="reference internal" href="../deployment/index.html"><span class="doc">Deploying to Production</span></a> pages.</p> </div> <section id="reloader"> <h2 id="id1">Reloader</h2> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.10.</span></p> </div> </details><p>The Werkzeug reloader constantly monitors modules and paths of your web application, and restarts the server if any of the observed files change.</p> <p>Since version 0.10, there are two backends the reloader supports: <code>stat</code> and <code>watchdog</code>.</p> <ul class="simple"> <li>The default <code>stat</code> backend simply checks the <code>mtime</code> of all files in a regular interval. This is sufficient for most cases, however, it is known to drain a laptop’s battery.</li> <li>The <code>watchdog</code> backend uses filesystem events, and is much faster than <code>stat</code>. It requires the <a class="reference external" href="https://pypi.org/project/watchdog/">watchdog</a> module to be installed. The recommended way to achieve this is to add <code>Werkzeug[watchdog]</code> to your requirements file.</li> </ul> <p>If <code>watchdog</code> is installed and available it will automatically be used instead of the builtin <code>stat</code> reloader.</p> <p>To switch between the backends you can use the <code>reloader_type</code> parameter of the <a class="reference internal" href="#werkzeug.serving.run_simple" title="werkzeug.serving.run_simple"><code>run_simple()</code></a> function. <code>'stat'</code> sets it to the default stat based polling and <code>'watchdog'</code> forces it to the watchdog backend.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Some edge cases, like modules that failed to import correctly, are not handled by the stat reloader for performance reasons. The watchdog reloader monitors such files too.</p> </div> </section> <section id="colored-logging"> <h2>Colored Logging</h2> <p>The development server highlights the request logs in different colors based on the status code. On Windows, <a class="reference external" href="https://pypi.org/project/colorama/">Colorama</a> must be installed as well to enable this.</p> </section> <section id="virtual-hosts"> <h2>Virtual Hosts</h2> <p>Many web applications utilize multiple subdomains. This can be a bit tricky to simulate locally. Fortunately there is the <a class="reference external" href="https://en.wikipedia.org/wiki/Hosts_file">hosts file</a> that can be used to assign the local computer multiple names.</p> <p>This allows you to call your local computer <code>yourapplication.local</code> and <code>api.yourapplication.local</code> (or anything else) in addition to <code>localhost</code>.</p> <p>You can find the hosts file on the following location:</p>  <table class="docutils align-default">  <tr>
<td><p>Windows</p></td> <td><p><code>%SystemRoot%\system32\drivers\etc\hosts</code></p></td> </tr> <tr>
<td><p>Linux / OS X</p></td> <td><p><code>/etc/hosts</code></p></td> </tr>  </table>  <p>You can open the file with your favorite text editor and add a new name after <code>localhost</code>:</p> <pre data-language="python">127.0.0.1       localhost yourapplication.local api.yourapplication.local
</pre> <p>Save the changes and after a while you should be able to access the development server on these host names as well. You can use the <a class="reference internal" href="../routing/index.html"><span class="doc">URL Routing</span></a> system to dispatch between different hosts or parse <code>request.host</code> yourself.</p> </section> <section id="shutting-down-the-server"> <h2>Shutting Down The Server</h2> <p>In some cases it can be useful to shut down a server after handling a request. For example, a local command line tool that needs OAuth authentication could temporarily start a server to listen for a response, record the user’s token, then stop the server.</p> <p>One method to do this could be to start a server in a <a class="reference external" href="https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing" title="(in Python v3.11)"><code>multiprocessing</code></a> process, then terminate the process after a value is passed back to the parent.</p> <pre data-language="python">import multiprocessing
from werkzeug import Request, Response, run_simple

def get_token(q: multiprocessing.Queue) -&gt; None:
    @Request.application
    def app(request: Request) -&gt; Response:
        q.put(request.args["token"])
        return Response("", 204)

    run_simple("localhost", 5000, app)

if __name__ == "__main__":
    q = multiprocessing.Queue()
    p = multiprocessing.Process(target=get_token, args=(q,))
    p.start()
    print("waiting")
    token = q.get(block=True)
    p.terminate()
    print(token)
</pre> <p>That example uses Werkzeug’s development server, but any production server that can be started as a Python process could use the same technique and should be preferred for security. Another method could be to start a <a class="reference external" href="https://docs.python.org/3/library/subprocess.html#module-subprocess" title="(in Python v3.11)"><code>subprocess</code></a> process and send the value back over <code>stdout</code>.</p> </section> <section id="troubleshooting"> <h2>Troubleshooting</h2> <p>On operating systems that support ipv6 and have it configured such as modern Linux systems, OS X 10.4 or higher as well as Windows Vista some browsers can be painfully slow if accessing your local server. The reason for this is that sometimes “localhost” is configured to be available on both ipv4 and ipv6 sockets and some browsers will try to access ipv6 first and then ipv4.</p> <p>At the current time the integrated webserver does not support ipv6 and ipv4 at the same time and for better portability ipv4 is the default.</p> <p>If you notice that the web browser takes ages to load the page there are two ways around this issue. If you don’t need ipv6 support you can disable the ipv6 entry in the <a class="reference external" href="https://en.wikipedia.org/wiki/Hosts_file">hosts file</a> by removing this line:</p> <pre data-language="python">::1             localhost
</pre> <p>Alternatively you can also disable ipv6 support in your browser. For example if Firefox shows this behavior you can disable it by going to <code>about:config</code> and disabling the <code>network.dns.disableIPv6</code> key. This however is not recommended as of Werkzeug 0.6.1!</p> <p>Starting with Werkzeug 0.6.1, the server will now switch between ipv4 and ipv6 based on your operating system’s configuration. This means if that you disabled ipv6 support in your browser but your operating system is preferring ipv6, you will be unable to connect to your server. In that situation, you can either remove the localhost entry for <code>::1</code> or explicitly bind the hostname to an ipv4 address (<code>127.0.0.1</code>)</p> </section> <section id="ssl"> <h2>SSL</h2> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.6.</span></p> </div> </details><p>The builtin server supports SSL for testing purposes. If an SSL context is provided it will be used. That means a server can either run in HTTP or HTTPS mode, but not both.</p> <section id="quickstart"> <h3>Quickstart</h3> <p>The easiest way to do SSL based development with Werkzeug is by using it to generate an SSL certificate and private key and storing that somewhere and to then put it there. For the certificate you need to provide the name of your server on generation or a <code>CN</code>.</p> <ol class="arabic"> <li>
<p>Generate an SSL key and store it somewhere:</p> <pre data-language="python">&gt;&gt;&gt; from werkzeug.serving import make_ssl_devcert
&gt;&gt;&gt; make_ssl_devcert('/path/to/the/key', host='localhost')
('/path/to/the/key.crt', '/path/to/the/key.key')
</pre> </li> <li>
<p>Now this tuple can be passed as <code>ssl_context</code> to the <a class="reference internal" href="#werkzeug.serving.run_simple" title="werkzeug.serving.run_simple"><code>run_simple()</code></a> method:</p> <pre data-language="python">run_simple('localhost', 4000, application,
           ssl_context=('/path/to/the/key.crt',
                        '/path/to/the/key.key'))
</pre> </li> </ol> <p>You will have to acknowledge the certificate in your browser once then.</p> </section> <section id="loading-contexts-by-hand"> <h3>Loading Contexts by Hand</h3> <p>You can use a <code>ssl.SSLContext</code> object instead of a tuple for full control over the TLS configuration.</p> <pre data-language="python">import ssl
ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
ctx.load_cert_chain('ssl.cert', 'ssl.key')
run_simple('localhost', 4000, application, ssl_context=ctx)
</pre> </section> <section id="generating-certificates"> <h3>Generating Certificates</h3> <p>A key and certificate can be created in advance using the openssl tool instead of the <a class="reference internal" href="#werkzeug.serving.make_ssl_devcert" title="werkzeug.serving.make_ssl_devcert"><code>make_ssl_devcert()</code></a>. This requires that you have the <code>openssl</code> command installed on your system:</p> <pre data-language="python">$ openssl genrsa 1024 &gt; ssl.key
$ openssl req -new -x509 -nodes -sha1 -days 365 -key ssl.key &gt; ssl.cert
</pre> </section> <section id="adhoc-certificates"> <h3>Adhoc Certificates</h3> <p>The easiest way to enable SSL is to start the server in adhoc-mode. In that case Werkzeug will generate an SSL certificate for you:</p> <pre data-language="python">run_simple('localhost', 4000, application,
           ssl_context='adhoc')
</pre> <p>The downside of this of course is that you will have to acknowledge the certificate each time the server is reloaded. Adhoc certificates are discouraged because modern browsers do a bad job at supporting them for security reasons.</p> <p>This feature requires the cryptography library to be installed.</p> </section> </section> <section id="unix-sockets"> <h2>Unix Sockets</h2> <p>The dev server can bind to a Unix socket instead of a TCP socket. <a class="reference internal" href="#werkzeug.serving.run_simple" title="werkzeug.serving.run_simple"><code>run_simple()</code></a> will bind to a Unix socket if the <code>hostname</code> parameter starts with <code>'unix://'</code>.</p> <pre data-language="python">from werkzeug.serving import run_simple
run_simple('unix://example.sock', 0, app)
</pre> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2007 Pallets<br>Licensed under the BSD 3-clause License.<br>
    <a href="https://werkzeug.palletsprojects.com/en/3.0.x/serving/" class="_attribution-link">https://werkzeug.palletsprojects.com/en/3.0.x/serving/</a>
  </p>
</div>
