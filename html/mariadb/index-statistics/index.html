<h1>Index Statistics</h1> <div> <div class="node creole"> <div class="answer formatted">  <h2 class="anchored_heading" id="how-index-statistics-help-the-query-optimizer">How Index Statistics Help the Query Optimizer</h2> <p>The MariaDB query optimizer decides how best to execute each query based largely on the details of the indexes involved.</p> <p>The index statistics help inform these decisions. Imagine yourself choosing whether to look up a number in a phone book, or in your personal address book. You'd choose the personal phone book if at all possible, as it would (usually!) contain far fewer records and be quicker to search.</p> <p>Now imagine getting to your personal address book and finding it has twice the number of entries as the phone book. Your search would be slower. The same process applies to the query optimizer, so having access to up-to-date and accurate statistics is critical.</p> <h2 class="anchored_heading" id="value-groups">Value Groups</h2> <p>The statistics are mainly based on groups of index elements of the same value. In a primary key, every index is unique, so every group size is one. In a non-unique index, you may have multiple keys with the same value. A worst-case example would be having large groups with the same value, for example an index on a boolean field.</p> <p>MariaDB makes heavy use of the average group size statistic. For example, if there are 100 rows, and twenty groups with the same index values, the average group size would be five.</p> <p>However, averages can be skewed by extremes, and the usual culprit is NULL values. The row of 100 may have 19 groups with an average size of 1, while the other 81 values are all NULL. MariaDB may think five is a good average size and choose to use that index, and then end up having to read through 81 rows with identical keys, taking longer than an alternative.</p> <h2 class="anchored_heading" id="dealing-with-nulls">Dealing with NULLs</h2> <p>There are three main approaches to the problem of NULLs. NULL index values can be treated as a single group (nulls_equal). This is usually fine, but if you have large numbers of NULLs the average group size is slanted higher, and the optimizer may miss using the index for ref accesses when it would be useful. This is the default used by XtraDB/InnoDB and MyISAM. Nulls_unequal is the opposite approach, with each NULL forming its own group of one. Conversely, the average group size is slanted lower, and the optimizer may use the index for ref accesses when not suitable. This is the default used by the Aria storage engine. A third options sees NULL's ignored altogether from index group calculations.</p> <p>The default approaches can be changed by setting the <a href="../aria-server-system-variables/index.html#aria_stats_method">aria_stats_method</a>, <a href="../myisam-server-system-variables/index.html#myisam_stats_method">myisam_stats_method</a> and <a href="../xtradbinnodb-server-system-variables/index.html#innodb_stats_method">innodb_stats_method</a> server variables.</p> <h2 class="anchored_heading" id="null-safe-and-regular-comparisons">Null-Safe and Regular Comparisons</h2> <p>The comparison operator used plays an important role. If two values are compared with &lt;=&gt; (see the <a href="../null-safe-equal/index.html">null-safe-equal</a> comparison operator), and both are null, 1 is returned. If the same values are compared with = (see the <a href="../equal/index.html">equal</a> comparison operator) null is returned. For example: </p> <pre class="fixed" data-language="sql">SELECT 1 &lt;=&gt; 1, NULL &lt;=&gt; NULL, 1 &lt;=&gt; NULL;
+---------+---------------+------------+
| 1 &lt;=&gt; 1 | NULL &lt;=&gt; NULL | 1 &lt;=&gt; NULL |
+---------+---------------+------------+
|       1 |             1 |          0 |
+---------+---------------+------------+

SELECT 1 = 1, NULL = NULL, 1 = NULL;
+-------+-------------+----------+
| 1 = 1 | NULL = NULL | 1 = NULL |
+-------+-------------+----------+
|     1 |        NULL |     NULL |
+-------+-------------+----------+
</pre>
<p><br></p> <h2 class="anchored_heading" id="engine-independent-statistics">Engine-Independent Statistics</h2> <p><a href="https://mariadb.com/kb/en/mariadb-1001-release-notes/">MariaDB 10.0.1</a> introduced a way to gather statistics independently of the storage engine. See <a href="../engine-independent-table-statistics/index.html">Engine-independent table statistics</a>.</p> <p><br></p> <h2 class="anchored_heading" id="histogram-based-statistics">Histogram-Based Statistics</h2> <p><a href="../histogram-based-statistics/index.html">Histogram-Based Statistics</a> were introduced in <a href="https://mariadb.com/kb/en/mariadb-1002-release-notes/">MariaDB 10.0.2</a>, and are collected by default from <a href="https://mariadb.com/kb/en/mariadb-1043-release-notes/">MariaDB 10.4.3</a>.</p> <h2 class="anchored_heading" id="see-also">See Also</h2> <ul start="1">
<li>
<a href="../user-statistics/index.html">User Statistics</a>. This plugin provides user, client, table and index usage statistics. </li>
<li>
<a href="../innodb-persistent-statistics/index.html">InnoDB Persistent Statistics</a> </li>
<li>
<a href="../engine-independent-table-statistics/index.html">Engine-independent Statistics</a> </li>
<li>
<a href="../histogram-based-statistics/index.html">Histogram-based Statistics</a> </li>
<li><a href="../ignored-indexes/index.html">Ignored Indexes</a></li>
</ul> </div>     </div> <div id="content_disclaimer" class="graybox"> Content reproduced on this site is the property of its respective owners, and this content is not reviewed in advance by MariaDB. The views, information and opinions expressed by this content do not necessarily represent those of MariaDB or any other party. </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2023 MariaDB<br>Licensed under the Creative Commons Attribution 3.0 Unported License and the GNU Free Documentation License.<br>
    <a href="https://mariadb.com/kb/en/index-statistics/" class="_attribution-link">https://mariadb.com/kb/en/index-statistics/</a>
  </p>
</div>
