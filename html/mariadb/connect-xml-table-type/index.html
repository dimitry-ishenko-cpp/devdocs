<h1>CONNECT XML Table Type</h1> <div> <div class="node creole"> <div class="answer formatted">  <h2 class="anchored_heading" id="overview">Overview</h2> <p>CONNECT supports tables represented by XML files. For these tables, the standard input/output functions of the operating system are not used but the parsing and processing of the file is delegated to a specialized library. Currently two such systems are supported: libxml2, a part of the GNOME framework, but which does not require GNOME and, on Windows, MS-DOM (DOMDOC), the Microsoft standard support of XML documents.</p> <p>DOMDOC is the default for the Windows version of CONNECT and libxml2 is always used on other systems. On Windows the choice can be specified using the XMLSUP <a href="../create-table/index.html">CREATE TABLE</a> list option, for instance specifying <code>option_list='xmlsup=libxml2'</code>.</p> <h2 class="anchored_heading" id="creating-xml-tables">Creating XML tables</h2> <p>First of all, it must be understood that XML is a very general language used to encode data having any structure. In particular, the tag hierarchy in an XML file describes a tree structure of the data. For instance, consider the file:</p> <pre class="fixed" data-language="sql">&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;
&lt;BIBLIO SUBJECT="XML"&gt;
   &lt;BOOK ISBN="9782212090819" LANG="fr" SUBJECT="applications"&gt;
      &lt;AUTHOR&gt;
         &lt;FIRSTNAME&gt;Jean-Christophe&lt;/FIRSTNAME&gt;
         &lt;LASTNAME&gt;Bernadac&lt;/LASTNAME&gt;
      &lt;/AUTHOR&gt;
      &lt;AUTHOR&gt;
         &lt;FIRSTNAME&gt;François&lt;/FIRSTNAME&gt;
         &lt;LASTNAME&gt;Knab&lt;/LASTNAME&gt;
      &lt;/AUTHOR&gt;
      &lt;TITLE&gt;Construire une application XML&lt;/TITLE&gt;
      &lt;PUBLISHER&gt;
         &lt;NAME&gt;Eyrolles&lt;/NAME&gt;
         &lt;PLACE&gt;Paris&lt;/PLACE&gt;
      &lt;/PUBLISHER&gt;
      &lt;DATEPUB&gt;1999&lt;/DATEPUB&gt;
   &lt;/BOOK&gt;
   &lt;BOOK ISBN="9782840825685" LANG="fr" SUBJECT="applications"&gt;
      &lt;AUTHOR&gt;
         &lt;FIRSTNAME&gt;William J.&lt;/FIRSTNAME&gt;
         &lt;LASTNAME&gt;Pardi&lt;/LASTNAME&gt;
      &lt;/AUTHOR&gt;
      &lt;TRANSLATOR PREFIX="adapté de l'anglais par"&gt;
         &lt;FIRSTNAME&gt;James&lt;/FIRSTNAME&gt;
         &lt;LASTNAME&gt;Guerin&lt;/LASTNAME&gt;
      &lt;/TRANSLATOR&gt;
      &lt;TITLE&gt;XML en Action&lt;/TITLE&gt;
      &lt;PUBLISHER&gt;
         &lt;NAME&gt;Microsoft Press&lt;/NAME&gt;
         &lt;PLACE&gt;Paris&lt;/PLACE&gt;
      &lt;/PUBLISHER&gt;
      &lt;DATEPUB&gt;1999&lt;/DATEPUB&gt;
   &lt;/BOOK&gt;
&lt;/BIBLIO&gt;
</pre>
<p>It represents data having the structure:</p> <pre class="fixed" data-language="sql">                               &lt;BIBLIO&gt;
                        __________|_________
                       |                    |
            &lt;BOOK:ISBN,LANG,SUBJECT&gt;        |
         ______________|_______________     |
        |        |         |           |    |
     &lt;AUTHOR&gt; &lt;TITLE&gt; &lt;PUBLISHER&gt; &lt;DATEPUB&gt; |
    ____|____            ___|____           |
   |    |    |          |        |          |
&lt;FIRST&gt; | &lt;LAST&gt;     &lt;NAME&gt;   &lt;PLACE&gt;       |
        |                                   |
     &lt;AUTHOR&gt;                   &lt;BOOK:ISBN,LANG,SUBJECT&gt;
    ____|____         ______________________|__________________
   |         |       |            |         |        |         |
&lt;FIRST&gt;   &lt;LAST&gt;  &lt;AUTHOR&gt; &lt;TRANSLATOR&gt; &lt;TITLE&gt; &lt;PUBLISHER&gt; &lt;DATEPUB&gt;
                _____|_        ___|___            ___|____
               |       |      |       |          |        |
            &lt;FIRST&gt; &lt;LAST&gt; &lt;FIRST&gt; &lt;LAST&gt;     &lt;NAME&gt;   &lt;PLACE&gt;
</pre>
<p>This structure seems at first view far from being tabular. However, modern database management systems, including MariaDB, implement something close to the relational model and work on tables that are structurally not hierarchical but tabular with rows and columns.</p> <p>Nevertheless, CONNECT can do it. Of course, it cannot guess what you want to extract from the XML structure, but gives you the possibility to specify it when you create the table<sup class="reference" id="_ref-0">[<a href="#_note-0">1</a>]</sup>.</p> <p>Let us take a first example. Suppose you want to make a table from the above document, displaying the node contents.</p> <p>For this, you can define a table <em>xsamptag</em> as:</p> <pre class="fixed" data-language="sql">create table xsamptag (
  AUTHOR char(50),
  TITLE char(32),
  TRANSLATOR char(40),
  PUBLISHER char(40),
  DATEPUB int(4))
engine=CONNECT table_type=XML file_name='Xsample.xml';
</pre>
<p>It will be displayed as:</p> <div class="cstm-style darkheader-nospace-borders">
<table>
<tr>
<th>AUTHOR</th>
<th>TITLE</th>
<th>TRANSLATOR</th>
<th>PUBLISHER</th>
<th>DATEPUB</th>
</tr> <tr>
<td>Jean-Christophe Bernadac</td>
<td>Construire une application XML</td>
<td>&lt;null&gt;</td>
<td>Eyrolles Paris</td>
<td>1999</td>
</tr> <tr>
<td>William J. Pardi</td>
<td>XML en Action</td>
<td>James Guerin</td>
<td>Microsoft Press Paris</td>
<td>1999</td>
</tr> </table> </div>
<p>Let us try to understand what happened. By default the column names correspond to tag names. Because this file is rather simple, CONNECT was able to default the top tag of the table as the root node <code>&lt;BIBLIO&gt;</code> of the file, and the row tags as the <code>&lt;BOOK&gt;</code> children of the table tag. In a more complex file, this should have been specified, as we will see later. Note that we didn't have to worry about the sub-tags such as <code>&lt;FIRSTNAME&gt;</code> or <code>&lt;LASTNAME&gt;</code> because CONNECT automatically retrieves the entire text contained in a tag and its sub-tags<sup class="reference" id="_ref-1">[<a href="#_note-1">2</a>]</sup>.</p> <div class="cstm-style bluebox">
<p>Only the first author of the first book appears. This is because only the first occurrence of a column tag has been retrieved so the result has a proper tabular structure. We will see later what we can do about that.</p> </div>
<p>How can we retrieve the values specified by attributes? By using a <em>Coltype</em> table option to specify the default column type. The value ‘@’ means that column names match attribute names. Therefore, we can retrieve them by creating a table such as:</p> <pre class="fixed" data-language="sql">create table xsampattr (
  ISBN char(15),
  LANG char(2),
  SUBJECT char(32))
engine=CONNECT table_type=XML file_name='Xsample.xml'
option_list='Coltype=@';
</pre>
<p>This table returns the following:</p> <div class="cstm-style darkheader-nospace-borders">
<table>
<tr>
<th>ISBN</th>
<th>LANG</th>
<th>SUBJECT</th>
</tr> <tr>
<td>9782212090819</td>
<td>fr</td>
<td>applications</td>
</tr> <tr>
<td>9782840825685</td>
<td>fr</td>
<td>applications</td>
</tr> </table> </div>
<p>Now to define a table that will give us all the previous information, we must specify the column type for each column. Because in the next statement the column type defaults to Node, the <em>field_format</em> column parameter was used to indicate which columns are attributes:</p> <p>From Connect 1.7.0002</p> <pre class="fixed" data-language="sql">create table xsamp (
ISBN char(15) xpath='@',
LANG char(2) xpath='@',
SUBJECT char(32) xpath='@',
AUTHOR char(50),
TITLE char(32),
TRANSLATOR char(40),
PUBLISHER char(40),
DATEPUB int(4))
engine=CONNECT table_type=XML file_name='Xsample.xml'
tabname='BIBLIO' option_list='rownode=BOOK';
</pre>
<p>Before Connect 1.7.0002</p> <pre class="fixed" data-language="sql">create table xsamp (
  ISBN char(15) field_format='@',
  LANG char(2) field_format='@',
  SUBJECT char(32) field_format='@',
  AUTHOR char(50),
  TITLE char(32),
  TRANSLATOR char(40),
  PUBLISHER char(40),
  DATEPUB int(4))
engine=CONNECT table_type=XML file_name='Xsample.xml'
tabname='BIBLIO' option_list='rownode=BOOK';
</pre>
<p>Once done, we can enter the query:</p> <pre class="fixed" data-language="sql">select subject, lang, title, author from xsamp;
</pre>
<p>This will return the following result:</p> <div class="cstm-style darkheader-nospace-borders">
<table>
<tr>
<th>SUBJECT</th>
<th>LANG</th>
<th>TITLE</th>
<th>AUTHOR</th>
</tr> <tr>
<td>applications</td>
<td>fr</td>
<td>Construire une application XML</td>
<td>Jean-Christophe Bernadac</td>
</tr> <tr>
<td>applications</td>
<td>fr</td>
<td>XML en Action</td>
<td>William J. Pardi</td>
</tr> </table> </div>
<p>Note that we have been lucky. Because unlike SQL, XML is case sensitive and the column names have matched the node names only because the column names were given in upper case. Note also that the order of the columns in the table could have been different from the order in which the nodes appear in the XML file.</p> <h2 class="anchored_heading" id="using-xpaths-with-xml-tables">Using Xpaths with XML tables</h2> <p>Xpath is used by XML to locate and retrieve nodes. The table's main node Xpath is specified by the <code>tabname</code> option. If just the node name is given, CONNECT constructs an Xpath such as <code>‘<em>BIBLIO’</em></code> in the example above that should retrieve the <code>BIBLIO</code> node wherever it is within the XML file. </p> <p>The row nodes are by default the children of the table node. However, for instance to eliminate some children nodes that are not real row nodes, the row node name can be specified using the <code>rownode</code> sub-option of the <code>option_list</code> option.</p> <p>The field_format options we used above can be specified to locate more precisely where and what information to retrieve using an Xpath-like syntax. For instance:</p> <p>From Connect 1.7.0002</p> <pre class="fixed" data-language="sql">create table xsampall (
isbn char(15) xpath='@ISBN',
language char(2) xpath='@LANG',
subject char(32) xpath='@SUBJECT',
authorfn char(20) xpath='AUTHOR/FIRSTNAME',
authorln char(20) xpath='AUTHOR/LASTNAME',
title char(32) xpath='TITLE',
translated char(32) xpath='TRANSLATOR/@PREFIX',
tranfn char(20) xpath='TRANSLATOR/FIRSTNAME',
tranln char(20) xpath='TRANSLATOR/LASTNAME',
publisher char(20) xpath='PUBLISHER/NAME',
location char(20) xpath='PUBLISHER/PLACE',
year int(4) xpath='DATEPUB')
engine=CONNECT table_type=XML file_name='Xsample.xml'
tabname='BIBLIO' option_list='rownode=BOOK';
</pre>
<p>Before Connect 1.7.0002</p> <pre class="fixed" data-language="sql">create table xsampall (
  isbn char(15) field_format='@ISBN',
  language char(2) field_format='@LANG',
  subject char(32) field_format='@SUBJECT',
  authorfn char(20) field_format='AUTHOR/FIRSTNAME',
  authorln char(20) field_format='AUTHOR/LASTNAME',
  title char(32) field_format='TITLE',
  translated char(32) field_format='TRANSLATOR/@PREFIX',
  tranfn char(20) field_format='TRANSLATOR/FIRSTNAME',
  tranln char(20) field_format='TRANSLATOR/LASTNAME',
  publisher char(20) field_format='PUBLISHER/NAME',
  location char(20) field_format='PUBLISHER/PLACE',
  year int(4) field_format='DATEPUB')
engine=CONNECT table_type=XML file_name='Xsample.xml'
tabname='BIBLIO' option_list='rownode=BOOK';
</pre>
<p>This very flexible column parameter serves several purposes:</p> <ul start="1">
<li>To specify the tag name, or the attribute name if different from the column name. </li>
<li>To specify the type (tag or attribute) by a prefix of '@' for attributes. </li>
<li>To specify the path for sub-tags using the '/' character. </li>
</ul> <p>This path is always relative to the current context (the column top node) and cannot be specified as an absolute path from the document root, therefore a leading '/' cannot be used. The path cannot be variable in node names or depth, therefore using '<code>//</code>' is not allowed.</p> <p>The query:</p> <pre class="fixed" data-language="sql">select isbn, title, translated, tranfn, tranln, location from
    xsampall where translated is not null;
</pre>
<p>replies:</p> <div class="cstm-style darkheader-nospace-borders">
<table>
<tr>
<th>ISBN</th>
<th>TITLE</th>
<th>TRANSLATED</th>
<th>TRANFN</th>
<th>TRANLN</th>
<th>LOCATION</th>
</tr> <tr>
<td>9782840825685</td>
<td>XML en Action</td>
<td>adapté de l'anglais par</td>
<td>James</td>
<td>Guerin</td>
<td>Paris</td>
</tr> </table> </div>
<h3 class="anchored_heading" id="libxml2-default-name-space-issue">Libxml2 default name space issue</h3> <p>An issue with libxml2 is that some files can declare a default name space in their root node. Because Xpath only searches in that name space, the nodes will not be found if they are not prefixed. If this happens, specify the tabname option as an Xpath ignoring the current name space:</p> <pre class="fixed" data-language="sql">TABNAME="//*[local-name()='BIBLIO']"
</pre>
<p>This must also be done for the default of specified Xpath of the not attribute columns. For instance:</p> <pre class="fixed" data-language="sql">title char(32) field_format="*[local-name()='TITLE']",
</pre>
<p>Note: This raises an error (and is useless anyway) with DOMDOC.</p> <h3 class="anchored_heading" id="direct-access-on-xml-tables">Direct access on XML tables</h3> <p>Direct access is available on XML tables. This means that XML tables can be sorted and used in joins, even in the one-side of the join.</p> <p>However, building a permanent index is not yet implemented. It is unclear whether this can be useful. Indeed, the DOM implementation that is used to access these tables firstly parses the whole file and constructs a node tree in memory. This may often be the longest part of the process, so the use of an index would not be of great value. Note also that this limits the XML files to a reasonable size. Anyway, when speed is important, this table type is not the best to use. Therefore, in these cases, it is probably better to convert the file to another type by inserting the XML table into another table of a more appropriate type for performance.</p> <h3 class="anchored_heading" id="accessing-tags-with-namespaces">Accessing tags with namespaces</h3> <p>With the Windows DOMDOC support, this can be done using the prefix in the tabname column option and/or xpath column option. For instance, given the file gns.xml:</p> <pre class="fixed" data-language="sql">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;gpx xmlns:gns="http:dummy"&gt;
&lt;gns:trkseg&gt;
&lt;trkpt lon="-121.9822235107421875" lat="37.3884925842285156"&gt;
&lt;gns:ele&gt;6.610851287841797&lt;/gns:ele&gt;
&lt;time&gt;2014-04-01T14:54:05.000Z&lt;/time&gt;
&lt;/trkpt&gt;
&lt;trkpt lon="-121.9821929931640625" lat="37.3885803222656250"&gt;
&lt;ele&gt;6.787827968597412&lt;/ele&gt;
&lt;time&gt;2014-04-01T14:54:08.000Z&lt;/time&gt;
&lt;/trkpt&gt;
&lt;trkpt lon="-121.9821624755859375" lat="37.3886299133300781"&gt;
&lt;ele&gt;6.771987438201904&lt;/ele&gt;
&lt;time&gt;2014-04-01T14:54:10.000Z&lt;/time&gt;
&lt;/trkpt&gt;
&lt;/gns:trkseg&gt;
&lt;/gpx&gt;
</pre>
<p>and the defined CONNECT table:</p> <pre class="fixed" data-language="sql">CREATE TABLE xgns (
`lon` double(21,16) NOT NULL `xpath`='@',
`lat` double(20,16) NOT NULL `xpath`='@',
`ele` double(21,16) NOT NULL `xpath`='gns:ele',
`time` datetime date_format="YYYY-MM-DD 'T' hh:mm:ss '.000Z'"
) 
  ENGINE=CONNECT DEFAULT CHARSET=latin1 `table_type`=XML 
  `file_name`='gns.xml' tabname='gns:trkseg' option_list='xmlsup=domdoc';
</pre>
<pre class="fixed" data-language="sql">select * from xgns;
</pre>
<p>Displays:</p> <div class="cstm-style darkheader-nospace-borders">
<table>
<tr>
<th>lon</th>
<th>lat</th>
<th>ele</th>
<th>time</th>
</tr> <tr>
<td>-121,982223510742</td>
<td>37,3884925842285</td>
<td>6,6108512878418</td>
<td>01/04/2014 14:54:05</td>
</tr> <tr>
<td>-121,982192993164</td>
<td>37,3885803222656</td>
<td>0</td>
<td>01/04/2014 14:54:08</td>
</tr> <tr>
<td>-121,982162475586</td>
<td>37,3886299133301</td>
<td>0</td>
<td>01/04/2014 14:54:10</td>
</tr> </table> </div>
<p>Only the prefixed ‘ele’ tag is recognized.</p> <p>However, this does not work with the libxml2 support. The solution is then to use a function ignoring the name space:</p> <pre class="fixed" data-language="sql">CREATE TABLE xgns2 (
`lon` double(21,16) NOT NULL `xpath`='@',
`lat` double(20,16) NOT NULL `xpath`='@',
`ele` double(21,16) NOT NULL `xpath`="*[local-name()='ele']",
`time` datetime date_format="YYYY-MM-DD 'T' hh:mm:ss '.000Z'"
) 
  ENGINE=CONNECT DEFAULT CHARSET=latin1 `table_type`=XML 
  `file_name`='gns.xml' tabname="*[local-name()='trkseg']" option_list='xmlsup=libxml2';
</pre>
<p>Then :</p> <pre class="fixed" data-language="sql">select * from xgns2;
</pre>
<p>Displays:</p> <div class="cstm-style darkheader-nospace-borders">
<table>
<tr>
<th>lon</th>
<th>lat</th>
<th>ele</th>
<th>time</th>
</tr> <tr>
<td>-121,982223510742</td>
<td>37,3884925842285</td>
<td>6,6108512878418</td>
<td>01/04/2014 14:54:05</td>
</tr> <tr>
<td>-121,982192993164</td>
<td>37,3885803222656</td>
<td>6.7878279685974</td>
<td>01/04/2014 14:54:08</td>
</tr> <tr>
<td>-121,982162475586</td>
<td>37,3886299133301</td>
<td>6.7719874382019</td>
<td>01/04/2014 14:54:10</td>
</tr> </table> </div>
<p>This time, all ‘ele` tags are recognized. This solution does not work with DOMDOC.</p> <h2 class="anchored_heading" id="having-columns-defined-by-discovery">Having Columns defined by Discovery</h2> <p>It is possible to let the MariaDB discovery process do the job of column specification. When columns are not defined in the <a href="../create-table/index.html">CREATE TABLE</a> statement, CONNECT endeavours to analyze the XML file and to provide the column specifications. This is possible only for true XML tables, but not for HTML tables.</p> <p>For instance, the <em>xsamp</em> table could have been created specifying:</p> <pre class="fixed" data-language="sql">create table xsamp
engine=CONNECT table_type=XML file_name='Xsample.xml'
tabname='BIBLIO' option_list='rownode=BOOK';
</pre>
<p>Let’s check how it was actually specified using the SHOW CREATE TABLE statement:</p> <pre class="fixed" data-language="sql">CREATE TABLE `xsamp` (
  `ISBN` char(13) NOT NULL `FIELD_FORMAT`='@',
  `LANG` char(2) NOT NULL `FIELD_FORMAT`='@',
  `SUBJECT` char(12) NOT NULL `FIELD_FORMAT`='@',
  `AUTHOR` char(24) NOT NULL,
  `TRANSLATOR` char(12) DEFAULT NULL,
  `TITLE` char(30) NOT NULL,
  `PUBLISHER` char(21) NOT NULL,
  `DATEPUB` char(4) NOT NULL
) ENGINE=CONNECT DEFAULT CHARSET=latin1 `TABLE_TYPE`='XML' 
  `FILE_NAME`='E:/Data/Xml/Xsample.xml' `TABNAME`='BIBLIO' `OPTION_LIST`='rownode=BOOK';
</pre>
<p>It is equivalent except for the column sizes that have been calculated from the file as the maximum length of the corresponding column when it was a normal value. Also, all columns are specified as type <a href="../char/index.html">CHAR</a> because XML does not provide information about the node content data type. Nullable is set to true if the column is missing in some rows.</p> <p>If a more complex definition is desired, you can ask CONNECT to analyse the XPATH up to a given level using the level option in the option list. The level value is the number of nodes that are taken in the XPATH. For instance:</p> <pre class="fixed" data-language="sql">create table xsampall
engine=CONNECT table_type=XML file_name='Xsample.xml'
tabname='BIBLIO' option_list='rownode=BOOK,Level=1';
</pre>
<p>This will define the table as:</p> <p>From Connect 1.7.0002</p> <pre class="fixed wrap" data-language="sql">CREATE TABLE `xsampall` (
  `ISBN` char(13) NOT NULL `XPATH`='@',
  `LANG` char(2) NOT NULL `XPATH`='@',
  `SUBJECT` char(12) NOT NULL `XPATH`='@',
  `AUTHOR_FIRSTNAME` char(15) NOT NULL `XPATH`='AUTHOR/FIRSTNAME',
  `AUTHOR_LASTNAME` char(8) NOT NULL `XPATH`='AUTHOR/LASTNAME',
  `TRANSLATOR_PREFIX` char(24) DEFAULT NULL `XPATH`='TRANSLATOR/@PREFIX',
  `TRANSLATOR_FIRSTNAME` char(7) DEFAULT NULL `XPATH`='TRANSLATOR/FIRSTNAME',
  `TRANSLATOR_LASTNAME` char(6) DEFAULT NULL `XPATH`='TRANSLATOR/LASTNAME',
  `TITLE` char(30) NOT NULL,
  `PUBLISHER_NAME` char(15) NOT NULL `XPATH`='PUBLISHER/NAME',
  `PUBLISHER_PLACE` char(5) NOT NULL `XPATH`='PUBLISHER/PLACE',
  `DATEPUB` char(4) NOT NULL
) ENGINE=CONNECT DEFAULT CHARSET=latin1 `TABLE_TYPE`='XML' `FILE_NAME`='Xsample.xml' `TABNAME`='BIBLIO' `OPTION_LIST`='rownode=BOOK,Depth=1';
&lt;&lt;/sql&gt;&gt;


Before Connect 1.7.0002
&lt;&lt;sql&gt;&gt;
CREATE TABLE `xsampall` (
  `ISBN` char(13) NOT NULL `FIELD_FORMAT`='@',
  `LANG` char(2) NOT NULL `FIELD_FORMAT`='@',
  `SUBJECT` char(12) NOT NULL `FIELD_FORMAT`='@',
  `AUTHOR_FIRSTNAME` char(15) NOT NULL `FIELD_FORMAT`='AUTHOR/FIRSTNAME',
  `AUTHOR_LASTNAME` char(8) NOT NULL `FIELD_FORMAT`='AUTHOR/LASTNAME',
  `TRANSLATOR_PREFIX` char(24) DEFAULT NULL `FIELD_FORMAT`='TRANSLATOR/@PREFIX',
  `TRANSLATOR_FIRSTNAME` char(7) DEFAULT NULL `FIELD_FORMAT`='TRANSLATOR/FIRSTNAME',
  `TRANSLATOR_LASTNAME` char(6) DEFAULT NULL `FIELD_FORMAT`='TRANSLATOR/LASTNAME',
  `TITLE` char(30) NOT NULL,
  `PUBLISHER_NAME` char(15) NOT NULL `FIELD_FORMAT`='PUBLISHER/NAME',
  `PUBLISHER_PLACE` char(5) NOT NULL `FIELD_FORMAT`='PUBLISHER/PLACE',
  `DATEPUB` char(4) NOT NULL
) ENGINE=CONNECT DEFAULT CHARSET=latin1 `TABLE_TYPE`='XML' `FILE_NAME`='Xsample.xml' 
  `TABNAME`='BIBLIO' `OPTION_LIST`='rownode=BOOK,Level=1';
&lt;&lt;/sql&gt;&gt;

This method can be used as a quick way to make a “template” table definition that can later be edited to make the desired definition. In particular, column names are constructed from all the nodes of their path in order to have distinct column names. This can be manually edited to have the desired names, provided their XPATH is not modified.

To have a preview of how columns will be defined, you can use a catalog table like this:

&lt;&lt;sql&gt;&gt;
create table xsacol
engine=CONNECT table_type=XML file_name='Xsample.xml'
tabname='BIBLIO' option_list='rownode=BOOK,Level=1' catfunc=col;
&lt;&lt;/sql&gt;&gt;

And when asking:

&lt;&lt;sql&gt;&gt;
select column_name Name, type_name Type, column_size Size, nullable, xpath from xsacol;
&lt;&lt;/sql&gt;&gt;

You get the description of what the table columns will be:

&lt;&lt;style class="darkheader-nospace-borders"&gt;&gt;
|= Name |= Type |= Size |= nullable |= xpath |
| ISBN | CHAR | 13 | 0 | @ | 
| LANG | CHAR | 2 | 0 | @ |
| SUBJECT | CHAR | 12 | 0 | @ |
| AUTHOR_FIRSTNAME | CHAR | 15 | 0 | AUTHOR/FIRSTNAME | 
| AUTHOR_LASTNAME | CHAR | 8 | 0 | AUTHOR/LASTNAME | 
| TRANSLATOR_PREFIX | CHAR | 24 | 1 | TRANSLATOR/@PREFIX | 
| TRANSLATOR_FIRSTNAME | CHAR | 7 | 1 | TRANSLATOR/FIRSTNAME |
| TRANSLATOR_LASTNAME | CHAR | 6 | 1 | TRANSLATOR/LASTNAME | 
| TITLE | CHAR | 30 | 0 |  | 
| PUBLISHER_NAME | CHAR | 15 | 0 | PUBLISHER/NAME |
| PUBLISHER_PLACE | CHAR | 5 | 0 | PUBLISHER/PLACE |
| DATEPUB | CHAR | 4 | 0 | |
&lt;&lt;/style&gt;&gt;

== Write operations on XML tables
You can freely use the Update, Delete and Insert commands with XML tables.
However, you must understand that the format of the updated or inserted data
follows the specifications of the table you created, not the ones of the
original source file. For instance, let us suppose we insert a new book using
the //xsamp// table (not the //xsampall// table) with the command:

&lt;&lt;code lang=mysql inline=false&gt;&gt;
insert into xsamp
  (isbn, lang, subject, author, title, publisher,datepub)
  values ('9782212090529','fr','général','Alain Michard',
         'XML, Langage et Applications','Eyrolles Paris',1998);
</pre>
<p>Then if we ask:</p> <pre class="fixed" data-language="sql">select subject, author, title, translator, publisher from xsamp;
</pre>
<p>Everything seems correct when we get the result:</p> <div class="cstm-style darkheader-nospace-borders">
<table>
<tr>
<th>SUBJECT</th>
<th>AUTHOR</th>
<th>TITLE</th>
<th>TRANSLATOR</th>
<th>PUBLISHER</th>
</tr> <tr>
<td>applications</td>
<td>Jean-Christophe Bernadac</td>
<td>Construire une application XML</td>
<td></td>
<td>Eyrolles Paris</td>
</tr> <tr>
<td>applications</td>
<td>William J. Pardi</td>
<td>XML en Action</td>
<td>James Guerin</td>
<td>Microsoft Press Paris</td>
</tr> <tr>
<td>général</td>
<td>Alain Michard</td>
<td>XML, Langage et Applications</td>
<td></td>
<td>Eyrolles Paris</td>
</tr> </table> </div>
<p>However if we enter the apparently equivalent query on the <em>xsampall</em> table, based on the same file:</p> <pre class="fixed" data-language="sql">select subject,
concat(authorfn, ' ', authorln) author , title,
concat(tranfn, ' ', tranln) translator,
concat(publisher, ' ', location) publisher from xsampall;
</pre>
<p>this returns an apparently wrong answer:</p> <div class="cstm-style darkheader-nospace-borders">
<table>
<tr>
<th>SUBJECT</th>
<th>AUTHOR</th>
<th>TITLE</th>
<th>TRANSLATOR</th>
<th>PUBLISHER</th>
</tr> <tr>
<td>applications</td>
<td>Jean-Christophe Bernadac</td>
<td>Construire une application XML</td>
<td></td>
<td>Eyrolles Paris</td>
</tr> <tr>
<td>applications</td>
<td>William J. Pardi</td>
<td>XML en Action</td>
<td>James Guerin</td>
<td>Microsoft Press Paris</td>
</tr> <tr>
<td>général</td>
<td></td>
<td>XML, Langage et Applications</td>
<td></td>
<td></td>
</tr> </table> </div>
<p>What happened here? Simply, because we used the <em>xsamp</em> table to do the Insert, what has been inserted within the XML file had the structure described for <em>xsamp</em>:</p> <pre class="fixed" data-language="sql">   &lt;BOOK ISBN="9782212090529" LANG="fr" SUBJECT="général"&gt;
      &lt;AUTHOR&gt;Alain Michard&lt;/AUTHOR&gt;
      &lt;TITLE&gt;XML, Langage et Applications&lt;/TITLE&gt;
      &lt;TRANSLATOR&gt;&lt;/TRANSLATOR&gt;
      &lt;PUBLISHER&gt;Eyrolles Paris&lt;/PUBLISHER&gt;
      &lt;DATEPUB&gt;1998&lt;/DATEPUB&gt;
   &lt;/BOOK&gt;
</pre>
<p>CONNECT cannot "invent" sub-tags that are not part of the <em>xsamp</em> table. Because these sub-tags do not exist, the <em>xsampall</em> table cannot retrieve the information that should be attached to them. If we want to be able to query the XML file by all the defined tables, the correct way to insert a new book to the file is to use the <em>xsampall</em> table, the only one that addresses all the components of the original document:</p> <pre class="fixed" data-language="sql">delete from xsamp where isbn = '9782212090529';

insert into xsampall (isbn, language, subject, authorfn, authorln,
      title, publisher, location, year)
   values('9782212090529','fr','général','Alain','Michard',
      'XML, Langage et Applications','Eyrolles','Paris',1998);
</pre>
<p>Now the added book, in the XML file, will have the required structure:</p> <pre class="fixed" data-language="sql">   &lt;BOOK ISBN="9782212090529" LANG="fr" SUBJECT="général"&gt;
      &lt;AUTHOR&gt;
         &lt;FIRSTNAME&gt;Alain&lt;/FIRSTNAME&gt;
         &lt;LASTNAME&gt;Michard&lt;/LASTNAME&gt;
      &lt;/AUTHOR&gt;
      &lt;TITLE&gt;XML, Langage et Applications&lt;/TITLE&gt;
      &lt;PUBLISHER&gt;
         &lt;NAME&gt;Eyrolles&lt;/NAME&gt;
         &lt;PLACE&gt;Paris&lt;/PLACE&gt;
      &lt;/PUBLISHER&gt;
      &lt;DATEPUB&gt;1998&lt;/DATEPUB&gt;
   &lt;/BOOK&gt;
</pre>
<p><strong>Note:</strong> We used a column list in the Insert statements when creating the table to avoid generating a <code>&lt;TRANSLATOR&gt;</code> node with sub-nodes, all containing null values (this works on Windows only).</p> <h2 class="anchored_heading" id="multiple-nodes-in-the-xml-document">Multiple nodes in the XML document</h2> <p>Let us come back to the above example XML file. We have seen that the author node can be "multiple" meaning that there can be more than one author of a book. What can we do to get the complete information fitting the relational model? CONNECT provides you with two possibilities, but is restricted to only one such multiple node per table.</p> <p>The first and most challenging one is to return as many rows than there are authors, the other columns being repeated as if we had make a join between the author column and the rest of the table. To achieve this, simply specify the “multiple” node name and the “expand” option when creating the table. For instance, we can create the <em>xsamp2</em> table like this:</p> <pre class="fixed" data-language="sql">create table xsamp2 (
  ISBN char(15) field_format='@',
  LANG char(2) field_format='@',
  SUBJECT char(32) field_format='@',
  AUTHOR char(40),
  TITLE char(32),
  TRANSLATOR char(32),
  PUBLISHER char(32),
  DATEPUB int(4))
engine=CONNECT table_type=XML file_name='Xsample.xml'
tabname='BIBLIO'
option_list='rownode=BOOK,Expand=1,Mulnode=AUTHOR,Limit=2';
</pre>
<p>In this statement, the Limit option specifies the maximum number of values that will be expanded. If not specified, it defaults to <code>10</code>. Any values above the limit will be ignored and a warning message issued<sup class="reference" id="_ref-2">[<a href="#_note-2">3</a>]</sup>. Now you can enter a query such as:</p> <pre class="fixed" data-language="sql">select isbn, subject, author, title from xsamp2;
</pre>
<p>This will retrieve and display the following result:</p> <div class="cstm-style darkheader-nospace-borders">
<table>
<tr>
<th>ISBN</th>
<th>SUBJECT</th>
<th>AUTHOR</th>
<th>TITLE</th>
</tr> <tr>
<td>9782212090819</td>
<td>applications</td>
<td>Jean-Christophe Bernadac</td>
<td>Construire une application XML</td>
</tr> <tr>
<td>9782212090819</td>
<td>applications</td>
<td>François Knab</td>
<td>Construire une application XML</td>
</tr> <tr>
<td>9782840825685</td>
<td>applications</td>
<td>William J. Pardi</td>
<td>XML en Action</td>
</tr> <tr>
<td>9782212090529</td>
<td>général</td>
<td>Alain Michard</td>
<td>XML, Langage et Applications</td>
</tr> </table> </div>
<p>In this case, this is as if the table had four rows. However if we enter the query:</p> <pre class="fixed" data-language="sql">select isbn, subject, title, publisher from xsamp2;
</pre>
<p>this time the result will be:</p> <div class="cstm-style darkheader-nospace-borders">
<table>
<tr>
<th>ISBN</th>
<th>SUBJECT</th>
<th>TITLE</th>
<th>PUBLISHER</th>
</tr> <tr>
<td>9782212090819</td>
<td>applications</td>
<td>Construire une application XML</td>
<td>Eyrolles Paris</td>
</tr> <tr>
<td>9782840825685</td>
<td>applications</td>
<td>XML en Action</td>
<td>Microsoft Press Paris</td>
</tr> <tr>
<td>9782212090529</td>
<td>général</td>
<td>XML, Langage et Applications</td>
<td>Eyrolles Paris</td>
</tr> </table> </div>
<p>Because the author column does not appear in the query, the corresponding row was not expanded. This is somewhat strange because this would have been different if we had been working on a table of a different type. However, it is closer to the relational model for which there should not be two identical rows (tuples) in a table. Nevertheless, you should be aware of this somewhat erratic behavior. For instance:</p> <pre class="fixed" data-language="sql">select count(*) from xsamp2;                /* Replies 3 */
select count(author) from xsamp2;           /* Replies 4 */
select count(isbn) from xsamp2;             /* Replies 3 */
select isbn, subject, title, publisher from xsamp2 where author &lt;&gt; '';
</pre>
<p>This last query replies:</p> <div class="cstm-style darkheader-nospace-borders">
<table>
<tr>
<th>ISBN</th>
<th>SUBJECT</th>
<th>TITLE</th>
<th>PUBLISHER</th>
</tr> <tr>
<td>9782212090819</td>
<td>applications</td>
<td>Construire une application XML</td>
<td>Eyrolles Paris</td>
</tr> <tr>
<td>9782212090819</td>
<td>applications</td>
<td>Construire une application XML</td>
<td>Eyrolles Paris</td>
</tr> <tr>
<td>9782840825685</td>
<td>applications</td>
<td>XML en Action</td>
<td>Microsoft Press Paris</td>
</tr> <tr>
<td>9782212090529</td>
<td>général</td>
<td>XML, Langage et Applications</td>
<td>Eyrolles Paris</td>
</tr> </table> </div>
<p>Even though the author column does not appear in the result, the corresponding row was expanded because the multiple column was used in the where clause.</p> <h2 class="anchored_heading" id="intermediate-multiple-node">Intermediate multiple node</h2> <p>The "multiple" node can be an intermediate node. If we want to do the same expanding with the <em>xsampall</em> table, there will be nothing more to do. The <em>xsampall2</em> table can be created with:</p> <p>From Connect 1.7.0002</p> <pre class="fixed" data-language="sql">create table xsampall2 (
isbn char(15) xpath='@ISBN',
language char(2) xpath='@LANG',
subject char(32) xpath='@SUBJECT',
authorfn char(20) xpath='AUTHOR/FIRSTNAME',
authorln char(20) xpath='AUTHOR/LASTNAME',
title char(32) xpath='TITLE',
translated char(32) xpath='TRANSLATOR/@PREFIX',
tranfn char(20) xpath='TRANSLATOR/FIRSTNAME',
tranln char(20) xpath='TRANSLATOR/LASTNAME',
publisher char(20) xpath='PUBLISHER/NAME',
location char(20) xpath='PUBLISHER/PLACE',
year int(4) xpath='DATEPUB')
engine=CONNECT table_type=XML file_name='Xsample.xml'
tabname='BIBLIO' option_list='rownode=BOOK,Expand=1,Mulnode=AUTHOR,Limit=2';
</pre>
<p>Before Connect 1.7.0002</p> <pre class="fixed" data-language="sql">create table xsampall2 (
  isbn char(15) field_format='@ISBN',
  language char(2) field_format='@LANG',
  subject char(32) field_format='@SUBJECT',
  authorfn char(20) field_format='AUTHOR/FIRSTNAME',
  authorln char(20) field_format='AUTHOR/LASTNAME',
  title char(32) field_format='TITLE',
  translated char(32) field_format='TRANSLATOR/@PREFIX',
  tranfn char(20) field_format='TRANSLATOR/FIRSTNAME',
  tranln char(20) field_format='TRANSLATOR/LASTNAME',
  publisher char(20) field_format='PUBLISHER/NAME',
  location char(20) field_format='PUBLISHER/PLACE',
  year int(4) field_format='DATEPUB')
engine=CONNECT table_type=XML file_name='Xsample.xml'
tabname='BIBLIO'
option_list='rownode=BOOK,Expand=1,Mulnode=AUTHOR,Limit=2';
</pre>
<p>The only difference is that the "multiple" node is an intermediate node in the path. The resulting table can be seen with a query such as:</p> <pre class="fixed" data-language="sql">select subject, language lang, title, authorfn first, authorln
    last, year from xsampall2;
</pre>
<p>This query displays:</p> <div class="cstm-style darkheader-nospace-borders">
<table>
<tr>
<th>SUBJECT</th>
<th>LANG</th>
<th>TITLE</th>
<th>FIRST</th>
<th>LAST</th>
<th>YEAR</th>
</tr> <tr>
<td>applications</td>
<td>fr</td>
<td>Construire une application XML</td>
<td>Jean-Christophe</td>
<td>Bernadac</td>
<td>1999</td>
</tr> <tr>
<td>applications</td>
<td>fr</td>
<td>Construire une application XML</td>
<td>François</td>
<td>Knab</td>
<td>1999</td>
</tr> <tr>
<td>applications</td>
<td>fr</td>
<td>XML en Action</td>
<td>William J.</td>
<td>Pardi</td>
<td>1999</td>
</tr> <tr>
<td>général</td>
<td>fr</td>
<td>XML, Langage et Applications</td>
<td>Alain</td>
<td>Michard</td>
<td>1998</td>
</tr> </table> </div>
<p>These composite tables, half array half tree, reserve some surprises for us when updating, deleting from or inserting into them. Insert just cannot generate this structure; if two rows are inserted with just a different author, two book nodes will be generated in the XML file. Delete always deletes one book node and all its children nodes even if specified against only one author. Update is more complicated:</p> <pre class="fixed" data-language="sql">update xsampall2 set authorfn = 'Simon' where authorln = 'Knab';
update xsampall2 set year = 2002 where authorln = 'Bernadac';
update xsampall2 set authorln = 'Mercier' where year = 2002;
</pre>
<p>After these three updates, the first two responding "Affected rows: 1" and the last one responding "Affected rows: 2", the last query answers:</p> <div class="cstm-style darkheader-nospace-borders">
<table>
<tr>
<th>subject</th>
<th>lang</th>
<th>title</th>
<th>first</th>
<th>last</th>
<th>year</th>
</tr> <tr>
<td>applications</td>
<td>fr</td>
<td>Construire une application XML</td>
<td>Jean-Christophe</td>
<td>Mercier</td>
<td>2002</td>
</tr> <tr>
<td>applications</td>
<td>fr</td>
<td>Construire une application XML</td>
<td>François</td>
<td>Knab</td>
<td>2002</td>
</tr> <tr>
<td>applications</td>
<td>fr</td>
<td>XML en Action</td>
<td>William J.</td>
<td>Pardi</td>
<td>1999</td>
</tr> <tr>
<td>général</td>
<td>fr</td>
<td>XML, Langage et Applications</td>
<td>Alain</td>
<td>Michard</td>
<td>1998</td>
</tr> </table> </div>
<p>What must be understood here is that the Update modifies node values in the XML file, not cell values in the relational table. The first update worked normally. The second update changed the year value of the book and this shows for the two expanded rows because there is only one DATEPUB node for that book. Because the third update applies to a row having a certain date value, both author names were updated.</p> <h2 class="anchored_heading" id="making-a-list-of-multiple-values">Making a List of Multiple Values</h2> <p>Another way to see multiple values is to ask CONNECT to make a comma separated list of the multiple node values. This time, it can only be done if the "multiple" node is not intermediate. For example, we can modify the <em>xsamp2</em> table definition by:</p> <pre class="fixed" data-language="sql">alter table xsamp2 option_list='rownode=BOOK,Mulnode=AUTHOR,Limit=3';
</pre>
<p>This time 'Expand' is not specified, and Limit gives the maximum number of items in the list. Now if we enter the query:</p> <pre class="fixed" data-language="sql">select isbn, subject, author "AUTHOR(S)", title from xsamp2;
</pre>
<p>We will get the following result:</p> <div class="cstm-style darkheader-nospace-borders">
<table>
<tr>
<th>ISBN</th>
<th>SUBJECT</th>
<th>AUTHOR(S)</th>
<th>TITLE</th>
</tr> <tr>
<td>9782212090819</td>
<td>applications</td>
<td>Jean-Christophe Bernadac, François Knab</td>
<td>Construire une application XML</td>
</tr> <tr>
<td>9782840825685</td>
<td>applications</td>
<td>William J. Pardi</td>
<td>XML en Action</td>
</tr> <tr>
<td>9782212090529</td>
<td>général</td>
<td>Alain Michard</td>
<td>XML, Langage et Applications</td>
</tr> </table> </div>
<p>Note that updating the "multiple" column is not possible because CONNECT does not know which of the nodes to update.</p> <p>This could not have been done with the <em>xsampall2</em> table because the author node is intermediate in the path, and making two lists, one of first names and another one of last names would not make sense anyway.</p> <h3 class="anchored_heading" id="what-if-a-table-contains-several-multiple-nodes">What if a table contains several multiple nodes</h3> <p>This can be handled by creating several tables on the same file, each containing only one multiple node and constructing the desired result using joins.</p> <h2 class="anchored_heading" id="support-of-html-tables">Support of HTML Tables</h2> <p>Most tables included in HTML documents cannot be processed by CONNECT because the HTML language is often not compatible with the syntax of XML. In particular, XML requires all open tags to be matched by a closing tag while it is sometimes optional in HTML. This is often the case concerning column tags.</p> <p>However, you can meet tables that respect the XML syntax but have some of the features of HTML tables. For instance:</p> <pre class="fixed" data-language="sql">&lt;?xml version="1.0"?&gt;
&lt;Beers&gt;
  &lt;table&gt;
    &lt;th&gt;&lt;td&gt;Name&lt;/td&gt;&lt;td&gt;Origin&lt;/td&gt;&lt;td&gt;Description&lt;/td&gt;&lt;/th&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;brandName&gt;Huntsman&lt;/brandName&gt;&lt;/td&gt;
      &lt;td&gt;&lt;origin&gt;Bath, UK&lt;/origin&gt;&lt;/td&gt;
      &lt;td&gt;&lt;details&gt;Wonderful hop, light alcohol&lt;/details&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;brandName&gt;Tuborg&lt;/brandName&gt;&lt;/td&gt;
      &lt;td&gt;&lt;origin&gt;Danmark&lt;/origin&gt;&lt;/td&gt;
      &lt;td&gt;&lt;details&gt;In small bottles&lt;/details&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
&lt;/Beers&gt;
</pre>
<p>Here the different column tags are included in <code>&lt;td&gt;&lt;/td&gt;</code> tags as for HTML tables. You cannot just add this tag in the Xpath of the columns, because the search is done on the first occurrence of each tag, and this would cause this search to fail for all columns except the first one. This case is handled by specifying the <em>Colnode</em> table option that gives the name of these column tags, for example:</p> <p>From Connect 1.7.0002</p> <pre class="fixed" data-language="sql">create table beers (
`Name` char(16) xpath='brandName',
`Origin` char(16) xpath='origin',
`Description` char(32) xpath='details')
engine=CONNECT table_type=XML file_name='beers.xml'
tabname='table' option_list='rownode=tr,colnode=td';
</pre>
<p>Before Connect 1.7.0002</p> <pre class="fixed" data-language="sql">create table beers (
  `Name` char(16) field_format='brandName',
  `Origin` char(16) field_format='origin',
  `Description` char(32) field_format='details')
engine=CONNECT table_type=XML file_name='beers.xml'
tabname='table' option_list='rownode=tr,colnode=td';
</pre>
<p>The table will be displayed as:</p> <div class="cstm-style darkheader-nospace-borders">
<table>
<tr>
<th>Name</th>
<th>Origin</th>
<th>Description</th>
</tr> <tr>
<td>Huntsman</td>
<td>Bath, UK</td>
<td>Wonderful hop, light alcohol</td>
</tr> <tr>
<td>Tuborg</td>
<td>Danmark</td>
<td>In small bottles</td>
</tr> </table> </div>
<p>However, you can deal with tables even closer to the HTML model. For example the <em>coffee.htm</em> file:</p> <pre class="fixed" data-language="sql">&lt;TABLE summary="This table charts the number of cups of coffe
                consumed by each senator, the type of coffee (decaf
                or regular), and whether taken with sugar."&gt;
  &lt;CAPTION&gt;Cups of coffee consumed by each senator&lt;/CAPTION&gt;
  &lt;TR&gt;
    &lt;TH&gt;Name&lt;/TH&gt;
    &lt;TH&gt;Cups&lt;/TH&gt;
    &lt;TH&gt;Type of Coffee&lt;/TH&gt;
    &lt;TH&gt;Sugar?&lt;/TH&gt;
  &lt;/TR&gt;
  &lt;TR&gt;
    &lt;TD&gt;T. Sexton&lt;/TD&gt;
    &lt;TD&gt;10&lt;/TD&gt;
    &lt;TD&gt;Espresso&lt;/TD&gt;
    &lt;TD&gt;No&lt;/TD&gt;
  &lt;/TR&gt;
  &lt;TR&gt;
    &lt;TD&gt;J. Dinnen&lt;/TD&gt;
    &lt;TD&gt;5&lt;/TD&gt;
    &lt;TD&gt;Decaf&lt;/TD&gt;
    &lt;TD&gt;Yes&lt;/TD&gt;
  &lt;/TR&gt;
&lt;/TABLE&gt;
</pre>
<p>Here column values are directly represented by the TD tag text. You cannot declare them as tags nor as attributes. In addition, they are not located using their name but by their position within the row. Here is how to declare such a table to CONNECT:</p> <pre class="fixed" data-language="sql">create table coffee (
  `Name` char(16),
  `Cups` int(8),
  `Type` char(16),
  `Sugar` char(4))
engine=connect table_type=XML file_name='coffee.htm'
tabname='TABLE' header=1 option_list='Coltype=HTML';
</pre>
<p>You specify the fact that columns are located by position by setting the <em>Coltype</em> option to 'HTML'. Each column position (0 based) will be the value of the <em>flag</em> column parameter that is set by default in sequence. Now we are able to display the table:</p> <div class="cstm-style darkheader-nospace-borders">
<table>
<tr>
<th>Name</th>
<th>Cups</th>
<th>Type</th>
<th>Sugar</th>
</tr> <tr>
<td>T. Sexton</td>
<td>10</td>
<td>Espresso</td>
<td>No</td>
</tr> <tr>
<td>J. Dinnen</td>
<td>5</td>
<td>Decaf</td>
<td>Yes</td>
</tr> </table> </div>
<p><strong>Note 1:</strong> We specified '<code>header=n</code>' in the create statement to indicate that the first n rows of the table are not data rows and should be skipped.</p> <p><strong>Note 2:</strong> In this last example, we did not specify the node names using the Rownode and Colnode options because when <em>Coltype</em> is set to 'HTML' they default to '<code>Rownode=TR</code>' and '<code>Colnode=TD</code>'.</p> <p><strong>Note 3:</strong> The <em>Coltype</em> option is a word only the first character of which is significant. Recognized values are:</p> <table>
<tr>
<td>T(ag) or N(ode)</td>
<td>Column names match a tag name (the default).</td>
</tr> <tr>
<td>A(ttribute) or @</td>
<td>Column names match an attribute name.</td>
</tr> <tr>
<td>H(tml) or C(ol) or P(os)</td>
<td>Column are retrieved by their position.</td>
</tr> </table> <h3 class="anchored_heading" id="new-file-setting">New file setting</h3> <p>Some create options are used only when creating a table on a new file, i. e. when inserting into a file that does not exist yet. When specified, the 'Header' option will create a header row with the name of the table columns. This is chiefly useful for HTML tables to be displayed on a web browser.</p> <p>Some new list-options are used in this context:</p> <table>
<tr>
<td><strong>Encoding</strong></td>
<td>The encoding of the new document, defaulting to UTF-8.</td>
</tr> <tr>
<td><strong>Attribute</strong></td>
<td>A list of 'attname=attvalue' separated by ';' to add to the table node.</td>
</tr> <tr>
<td><strong>HeadAttr</strong></td>
<td>An attribute list to be added to the header row node.</td>
</tr> </table> <p>Let us see for instance, the following create statement:</p> <pre class="fixed" data-language="sql">create table handlers (
  handler char(64),
  version char(20),
  author char(64),
  description char(255),
  maturity char(12))
engine=CONNECT table_type=XML file_name='handlers.htm'
tabname='TABLE' header=yes
option_list='coltype=HTML,encoding=ISO-8859-1,
attribute=border=1;cellpadding=5,headattr=bgcolor=yellow';
</pre>
<p>Supposing the table file does not exist yet, the first insert into that table, for instance by the following statement:</p> <pre class="fixed" data-language="sql">insert into handlers select plugin_name, plugin_version,
  plugin_author, plugin_description, plugin_maturity from
  information_schema.plugins where plugin_type = 'DAEMON';
</pre>
<p>will generate the following file:</p> <pre class="fixed" data-language="sql">&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;
&lt;!-- Created by CONNECT Version 3.05.0005 August 17, 2012 --&gt;
&lt;TABLE border="1" cellpadding="5"&gt;
  &lt;TR bgcolor="yellow"&gt;
    &lt;TH&gt;handler&lt;/TH&gt;
    &lt;TH&gt;version&lt;/TH&gt;
    &lt;TH&gt;author&lt;/TH&gt;
    &lt;TH&gt;description&lt;/TH&gt;
    &lt;TH&gt;maturity&lt;/TH&gt;
  &lt;/TR&gt;
  &lt;TR&gt;
    &lt;TD&gt;Maria&lt;/TD&gt;
    &lt;TD&gt;1.5&lt;/TD&gt;
    &lt;TD&gt;Monty Program Ab&lt;/TD&gt;
    &lt;TD&gt;Compatibility aliases for the Aria engine&lt;/TD&gt;
    &lt;TD&gt;Gamma&lt;/TD&gt;
  &lt;/TR&gt;
&lt;/TABLE&gt;
</pre>
<p>This file can be used to display the table on a web browser (encoding should be <code>ISO-8859-x</code>)</p> <div class="cstm-style darkheader-nospace-borders">
<table>
<tr>
<th>handler</th>
<th>version</th>
<th>author</th>
<th>description</th>
<th>maturity</th>
</tr> <tr>
<td>Maria</td>
<td>1.5</td>
<td>Monty Program Ab</td>
<td>Compatibility aliases for the Aria engine</td>
<td>Gamma</td>
</tr> </table> </div>
<p><strong>Note:</strong> The XML document encoding is generally specified in the XML header node and can be different from the DATA_CHARSET, which is always UTF-8 for XML tables. Therefore the table DATA_CHARSET character set should be unspecified, or specified as UTF8. The Encoding specification is useful only for new XML files and ignored for existing files having their encoding already specified in the header node.</p> <h2 class="anchored_heading" id="notes">Notes</h2> <ol>
<li id="_note-0"> <a href="#_ref-0">↑</a> CONNECT does not claim to be able to deal with any XML document. Besides, those that can usefully be processed for data analysis are likely to have a structure that can easily be transformed into a table.</li> <li id="_note-1"> <a href="#_ref-1">↑</a> With libxml2, sub tags text can be separated by 0 or several blanks depending on the structure and indentation of the data file.</li> <li id="_note-2"> <a href="#_ref-2">↑</a> This may cause some rows to be lost because an eventual where clause on the “multiple” column is applied only on the limited number of retrieved rows.</li> </ol> </div>     </div> <div id="content_disclaimer" class="graybox"> Content reproduced on this site is the property of its respective owners, and this content is not reviewed in advance by MariaDB. The views, information and opinions expressed by this content do not necessarily represent those of MariaDB or any other party. </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2023 MariaDB<br>Licensed under the Creative Commons Attribution 3.0 Unported License and the GNU Free Documentation License.<br>
    <a href="https://mariadb.com/kb/en/connect-xml-table-type/" class="_attribution-link">https://mariadb.com/kb/en/connect-xml-table-type/</a>
  </p>
</div>
