<h1>RANGE Partitioning Type</h1> <div> <div class="node creole"> <div class="answer formatted"> <p> The RANGE partitioning type is used to assign each partition a range of values generated by the partitioning expression. Ranges must be ordered, contiguous and non-overlapping. The minimum value is always included in the first range. The highest value may or may not be included in the last range.</p> <p>A variant of this partitioning method, <a href="../range-columns-and-list-columns-partitioning-types/index.html">RANGE COLUMNS</a>, allows us to use multiple columns and more datatypes.</p> <h2 class="anchored_heading" id="syntax">Syntax</h2> <p>The last part of a <a href="../create-table/index.html">CREATE TABLE</a> statement can be definition of the new table's partitions. In the case of RANGE partitioning, the syntax is the following:</p> <pre class="fixed" data-language="sql">PARTITION BY RANGE (partitioning_expression)
(
	PARTITION partition_name VALUES LESS THAN (value),
	[ PARTITION partition_name VALUES LESS THAN (value), ... ]
)
</pre>
<p>PARTITION BY RANGE indicates that the partitioning type is RANGE.</p> <p>The <code>partitioning_expression</code> is an SQL expression that returns a value from each row. In the simplest cases, it is a column name. This value is used to determine which partition should contain a row.</p> <p><code>partition_name</code> is the name of a partition.</p> <p><code>value</code> indicates the upper bound for that partition. The values must be ascending. For the first partition, the lower limit is NULL. When trying to insert a row, if its value is higher than the upper limit of the last partition, the row will be rejected (with an error, if the <a href="../ignore/index.html">IGNORE</a> keyword is not used).</p> <p>If this is a problem, MAXVALUE can be specified as a value for the last partition. Note however that it is not possible to split partitions of an existing RANGE partitioned table. New partitions can be appended, but this will not be possible if the last partition's higher bound is MAXVALUE.</p> <h2 class="anchored_heading" id="use-cases">Use Cases</h2> <p>A typical use case is when we want to partition a table whose rows refer to a moment or period in time; for example commercial transactions, blog posts, or events of some kind. We can partition the table by year, to keep all recent data in one partition and distribute historical data in big partitions that are stored on slower disks. Or, if our queries always read rows which refer to the same month or week, we can partition the table by month or year week (in this case, historical data and recent data will be stored together).</p> <p><a href="../auto_increment/index.html">AUTO_INCREMENT</a> values also represent a chronological order. So, these values can be used to store old data in separate partitions. However, partitioning by id is not the best choice if we usually query a table by date.</p> <h2 class="anchored_heading" id="examples">Examples</h2> <p>In the following example, we will partition a log table by year.</p> <pre class="fixed" data-language="sql">CREATE TABLE log
(
	id INT UNSIGNED NOT NULL AUTO_INCREMENT,
	timestamp DATETIME NOT NULL,
	user INT UNSIGNED,
	ip BINARY(16) NOT NULL,
	action VARCHAR(20) NOT NULL,
	PRIMARY KEY (id, timestamp)
)
	ENGINE = InnoDB
PARTITION BY RANGE (YEAR(timestamp))
(
	PARTITION p0 VALUES LESS THAN (2013),
	PARTITION p1 VALUES LESS THAN (2014),
	PARTITION p2 VALUES LESS THAN (2015),
	PARTITION p3 VALUES LESS THAN (2016)
);
</pre>
<p>As an alternative, we can partition the table by both year and month:</p> <pre class="fixed" data-language="sql">CREATE TABLE log
(
	id INT UNSIGNED NOT NULL AUTO_INCREMENT,
	timestamp TIMESTAMP NOT NULL,
	user INT UNSIGNED,
	ip BINARY(16) NOT NULL,
	action VARCHAR(20) NOT NULL,
	PRIMARY KEY (id, timestamp)
)
	ENGINE = InnoDB
PARTITION BY RANGE (UNIX_TIMESTAMP(timestamp))
(
	PARTITION p0 VALUES LESS THAN (UNIX_TIMESTAMP('2014-08-01 00:00:00')),
	PARTITION p1 VALUES LESS THAN (UNIX_TIMESTAMP('2014-11-01 00:00:00')),
	PARTITION p2 VALUES LESS THAN (UNIX_TIMESTAMP('2015-01-01 00:00:00')),
	PARTITION p3 VALUES LESS THAN (UNIX_TIMESTAMP('2015-02-01 00:00:00'))
);
</pre>
<p>As you can see, we used the <a href="../unix_timestamp/index.html">UNIX_TIMESTAMP</a> function to accomplish the purpose. Also, the first two partitions cover longer periods of time (probably because the logged activities were less intensive).</p> <p>In both cases, when our tables become huge and we don't need to store all historical data any more, we can drop the oldest partitions in this way:</p> <pre class="fixed" data-language="sql"> ALTER TABLE log DROP PARTITION p0;
</pre>
<div class="cstm-style redbox">
<p>We will still be able to drop a partition that does not contain the oldest data, but all rows stored in it will disappear.</p> </div>
<p>Example of an error when inserting outside a defined partition range:</p> <pre class="fixed" data-language="sql">INSERT INTO log(id,timestamp) VALUES 
  (1, '2016-01-01 01:01:01'), 
  (2, '2015-01-01 01:01:01');
ERROR 1526 (HY000): Table has no partition for value 2016
</pre>
<p>Unless the IGNORE keyword is used:</p> <pre class="fixed" data-language="sql">INSERT IGNORE INTO log(id,timestamp) VALUES 
  (1, '2016-01-01 01:01:01'), 
  (2, '2015-01-01 01:01:01');

SELECT * FROM log;
+----+---------------------+------+------------------+--------+
| id | timestamp           | user | ip               | action |
+----+---------------------+------+------------------+--------+
|  2 | 2015-01-01 01:01:01 | NULL |                  |        |
+----+---------------------+------+------------------+--------+
</pre>
<p>An alternative definition with MAXVALUE as a catchall:</p> <pre class="fixed" data-language="sql">CREATE TABLE log
(
	id INT UNSIGNED NOT NULL AUTO_INCREMENT,
	timestamp DATETIME NOT NULL,
	user INT UNSIGNED,
	ip BINARY(16) NOT NULL,
	action VARCHAR(20) NOT NULL,
	PRIMARY KEY (id, timestamp)
)
	ENGINE = InnoDB
PARTITION BY RANGE (YEAR(timestamp))
(
	PARTITION p0 VALUES LESS THAN (2013),
	PARTITION p1 VALUES LESS THAN (2014),
	PARTITION p2 VALUES LESS THAN (2015),
	PARTITION p3 VALUES LESS THAN (2016),
	PARTITION p4 VALUES LESS THAN MAXVALUE
);
</pre> </div>     </div> <div id="content_disclaimer" class="graybox"> Content reproduced on this site is the property of its respective owners, and this content is not reviewed in advance by MariaDB. The views, information and opinions expressed by this content do not necessarily represent those of MariaDB or any other party. </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2023 MariaDB<br>Licensed under the Creative Commons Attribution 3.0 Unported License and the GNU Free Documentation License.<br>
    <a href="https://mariadb.com/kb/en/range-partitioning-type/" class="_attribution-link">https://mariadb.com/kb/en/range-partitioning-type/</a>
  </p>
</div>
