<h1>SET TRANSACTION</h1> <div> <div class="node creole"> <div class="answer formatted"> <h2 class="anchored_heading" id="syntax">Syntax</h2> <pre class="fixed" data-language="sql">SET [GLOBAL | SESSION] TRANSACTION
    transaction_property [, transaction_property] ...

transaction_property:
    ISOLATION LEVEL level
  | READ WRITE
  | READ ONLY

level:
     REPEATABLE READ
   | READ COMMITTED
   | READ UNCOMMITTED
   | SERIALIZABLE
</pre> <h2 class="anchored_heading" id="description">Description</h2> <p>This statement sets the transaction isolation level or the transaction access mode globally, for the current session, or for the next transaction:</p> <ul start="1">
<li>With the <code class="highlight fixed" style="white-space:pre-wrap">GLOBAL</code> keyword, the statement sets the default transaction level globally for all subsequent sessions. Existing sessions are unaffected. </li>
<li>With the <code class="highlight fixed" style="white-space:pre-wrap">SESSION</code> keyword, the statement sets the default transaction level for all subsequent transactions performed within the current session. </li>
<li>Without any <code class="highlight fixed" style="white-space:pre-wrap">SESSION</code> or <code class="highlight fixed" style="white-space:pre-wrap">GLOBAL</code> keyword, the statement sets the isolation level for only the next (not started) transaction performed within the current session. After that it reverts to using the session value. </li>
</ul> <p>A change to the global default isolation level requires the <code class="highlight fixed" style="white-space:pre-wrap"><a href="../grant/index.html">SUPER</a></code> privilege. Any session is free to change its session isolation level (even in the middle of a transaction), or the isolation level for its next transaction.</p> <h3 class="anchored_heading" id="isolation-level">Isolation Level</h3> <p>To set the global default isolation level at server startup, use the <a href="../server-system-variables/index.html#tx_isolation">--transaction-isolation=level</a> option on the command line or in an option file. Values of level for this option use dashes rather than spaces, so the allowable values are <a href="#read-uncommitted">READ_UNCOMMITTED</a>, <a href="#read-committed">READ-COMMITTED</a>, <a href="#repeatable-read">REPEATABLE-READ</a>, or <a href="#serializable">SERIALIZABLE</a>. For example, to set the default isolation level to <code class="highlight fixed" style="white-space:pre-wrap">REPEATABLE READ</code>, use these lines in the [mariadb] section of an option file:</p> <pre class="highlight fixed" data-language="sql">[mariadb]
transaction-isolation = REPEATABLE-READ</pre>
<p>To determine the global and session transaction isolation levels at runtime, check the value of the <a href="../server-system-variables/index.html#tx_isolation">tx_isolation</a> system variable (note that the variable has been renamed <a href="../server-system-variables/index.html#transaction_isolation">transaction_isolation</a> from <a href="https://mariadb.com/kb/en/mariadb-11-1-1-release-notes/">MariaDB 11.1.1</a>, to match the option, and the old name deprecated).</p> <pre class="fixed" data-language="sql">SELECT @@GLOBAL.tx_isolation, @@tx_isolation;
</pre>
<p>From <a href="https://mariadb.com/kb/en/mariadb-11-1-1-release-notes/">MariaDB 11.1.1</a>:</p> <pre class="fixed" data-language="sql">SELECT @@GLOBAL.transaction_isolation, @@transaction_isolation;
</pre>
<p>InnoDB supports each of the translation isolation levels described here using different locking strategies. The default level is <code class="highlight fixed" style="white-space:pre-wrap">REPEATABLE READ</code>. For additional information about InnoDB record-level locks and how it uses them to execute various types of statements, see <a href="../innodb-lock-modes/index.html">InnoDB Lock Modes</a>, and <a href="http://dev.mysql.com/doc/refman/en/innodb-locks-set.html">http://dev.mysql.com/doc/refman/en/innodb-locks-set.html</a>.</p> <h3 class="anchored_heading" id="isolation-levels">Isolation Levels</h3> <p>The following sections describe how MariaDB supports the different transaction levels.</p> <h4 class="anchored_heading" id="read-uncommitted">READ UNCOMMITTED</h4> <p><code class="highlight fixed" style="white-space:pre-wrap">SELECT</code> statements are performed in a non-locking fashion, but a possible earlier version of a row might be used. Thus, using this isolation level, such reads are not consistent. This is also called a "dirty read." Otherwise, this isolation level works like <code class="highlight fixed" style="white-space:pre-wrap">READ COMMITTED</code>.</p> <h4 class="anchored_heading" id="read-committed">READ COMMITTED</h4> <p>A somewhat Oracle-like isolation level with respect to consistent (non-locking) reads: Each consistent read, even within the same transaction, sets and reads its own fresh snapshot. See <a href="http://dev.mysql.com/doc/refman/en/innodb-consistent-read.html">http://dev.mysql.com/doc/refman/en/innodb-consistent-read.html</a>.</p> <p>For locking reads (<code class="highlight fixed" style="white-space:pre-wrap">SELECT</code> with <code class="highlight fixed" style="white-space:pre-wrap">FOR UPDATE</code> or <code class="highlight fixed" style="white-space:pre-wrap">LOCK IN SHARE MODE</code>), InnoDB locks only index records, not the gaps before them, and thus allows the free insertion of new records next to locked records. For <code class="highlight fixed" style="white-space:pre-wrap">UPDATE</code> and <code class="highlight fixed" style="white-space:pre-wrap">DELETE</code> statements, locking depends on whether the statement uses a unique index with a unique search condition (such as <code class="highlight fixed" style="white-space:pre-wrap">WHERE id = 100</code>), or a range-type search condition (such as <code class="highlight fixed" style="white-space:pre-wrap">WHERE id &gt; 100</code>). For a unique index with a unique search condition, InnoDB locks only the index record found, not the gap before it. For range-type searches, InnoDB locks the index range scanned, using gap locks or next-key (gap plus index-record) locks to block insertions by other sessions into the gaps covered by the range. This is necessary because "phantom rows" must be blocked for MariaDB replication and recovery to work.</p> <p><strong>Note:</strong> If the <code class="highlight fixed" style="white-space:pre-wrap">READ COMMITTED</code> isolation level is used or the <a href="../innodb-system-variables/index.html#innodb_locks_unsafe_for_binlog">innodb_locks_unsafe_for_binlog</a> system variable is enabled, there is no InnoDB gap locking except for <a href="../foreign-keys/index.html">foreign-key</a> constraint checking and duplicate-key checking. Also, record locks for non-matching rows are released after MariaDB has evaluated the <code class="highlight fixed" style="white-space:pre-wrap">WHERE</code> condition.If you use <code class="highlight fixed" style="white-space:pre-wrap">READ COMMITTED</code> or enable innodb_locks_unsafe_for_binlog, you must use row-based binary logging.</p> <h4 class="anchored_heading" id="repeatable-read">REPEATABLE READ</h4> <p>This is the default isolation level for InnoDB. For consistent reads, there is an important difference from the <code class="highlight fixed" style="white-space:pre-wrap">READ COMMITTED</code> isolation level: All consistent reads within the same transaction read the snapshot established by the first read. This convention means that if you issue several plain (non-locking) <code class="highlight fixed" style="white-space:pre-wrap">SELECT</code> statements within the same transaction, these <code class="highlight fixed" style="white-space:pre-wrap">SELECT</code> statements are consistent also with respect to each other. See <a href="http://dev.mysql.com/doc/refman/en/innodb-consistent-read.html">http://dev.mysql.com/doc/refman/en/innodb-consistent-read.html</a>.</p> <p>For locking reads (SELECT with FOR UPDATE or LOCK IN SHARE MODE), UPDATE, and DELETE statements, locking depends on whether the statement uses a unique index with a unique search condition, or a range-type search condition. For a unique index with a unique search condition, InnoDB locks only the index record found, not the gap before it. For other search conditions, InnoDB locks the index range scanned, using gap locks or next-key (gap plus index-record) locks to block insertions by other sessions into the gaps covered by the range.</p> <p>This is the minimum isolation level for non-distributed <a href="../xa-transactions/index.html">XA transactions</a>.</p> <h4 class="anchored_heading" id="serializable">SERIALIZABLE</h4> <p>This level is like REPEATABLE READ, but InnoDB implicitly converts all plain SELECT statements to <a href="../select/index.html#lock-in-share-mode-and-for-update-clauses">SELECT ... LOCK IN SHARE MODE</a> if <a href="../server-system-variables/index.html#autocommit">autocommit</a> is disabled. If autocommit is enabled, the SELECT is its own transaction. It therefore is known to be read only and can be serialized if performed as a consistent (non-locking) read and need not block for other transactions. (This means that to force a plain SELECT to block if other transactions have modified the selected rows, you should disable autocommit.)</p> <p>Distributed <a href="../xa-transactions/index.html">XA transactions</a> should always use this isolation level.</p> <h3 class="anchored_heading" id="access-mode">Access Mode</h3> <p>The access mode specifies whether the transaction is allowed to write data or not. By default, transactions are in <code>READ WRITE</code> mode (see the <a href="../server-system-variables/index.html#tx_read_only">tx_read_only</a> system variable). <code>READ ONLY</code> mode allows the storage engine to apply optimizations that cannot be used for transactions which write data. Note that unlike the global <a href="../server-system-variables/index.html#read_only">read_only</a> mode, <a href="../grant/index.html#read_only-admin">READ_ONLY ADMIN</a> (and <a href="../grant/index.html#super">SUPER</a> before <a href="https://mariadb.com/kb/en/mariadb-10-11-0-release-notes/">MariaDB 10.11.0</a>) privilege doesn't allow writes and DDL statements on temporary tables are not allowed either.</p> <p>It is not permitted to specify both <code>READ WRITE</code> and <code>READ ONLY</code> in the same statement.</p> <p><code>READ WRITE</code> and <code>READ ONLY</code> can also be specified in the <a href="../start-transaction/index.html">START TRANSACTION</a> statement, in which case the specified mode is only valid for one transaction.</p> <h2 class="anchored_heading" id="examples">Examples</h2> <pre class="fixed" data-language="sql">SET GLOBAL TRANSACTION ISOLATION LEVEL SERIALIZABLE;
</pre>
<p>Attempting to set the isolation level within an existing transaction without specifying <code>GLOBAL</code> or <code>SESSION</code>.</p> <pre class="fixed" data-language="sql">START TRANSACTION;

SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
ERROR 1568 (25001): Transaction characteristics can't be changed while a transaction is in progress
</pre> </div>     </div> <div id="content_disclaimer" class="graybox"> Content reproduced on this site is the property of its respective owners, and this content is not reviewed in advance by MariaDB. The views, information and opinions expressed by this content do not necessarily represent those of MariaDB or any other party. </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2023 MariaDB<br>Licensed under the Creative Commons Attribution 3.0 Unported License and the GNU Free Documentation License.<br>
    <a href="https://mariadb.com/kb/en/set-transaction/" class="_attribution-link">https://mariadb.com/kb/en/set-transaction/</a>
  </p>
</div>
