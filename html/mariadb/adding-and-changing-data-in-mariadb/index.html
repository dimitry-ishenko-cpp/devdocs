<h1>Adding and Changing Data in MariaDB</h1> <div> <div class="node creole"> <div class="answer formatted"> <p> There are several ways to add and to change data in MariaDB. There are a few SQL statements that you can use, each with a few options. Additionally, there are twists that you can do by mixing SQL statements together with various clauses. In this article, we will explore the ways in which data can be added and changed in MariaDB.</p> <h4 class="anchored_heading" id="adding-data">Adding Data</h4> <p>To add data to a table in MariaDB, you will need to use the <a href="../insert/index.html">INSERT</a> statement. Its basic, minimal syntax is the command <a href="../insert/index.html">INSERT</a> followed by the table name and then the keyword VALUES with a comma separated list of values contained in parentheses:</p> <pre class="fixed" data-language="sql">INSERT table1
VALUES('text1','text2','text3');
</pre>
<p>In this example, text is added to a table called table1, which contains only three columns<span>—</span>the same number of values that we're inserting. The number of columns must match. If you don't want to insert data into all of the columns of a table, though, you could name the columns desired:</p> <pre class="fixed" data-language="sql">INSERT INTO table1
(col3, col1)
VALUES('text3','text1');
</pre>
<p>Notice that the keyword <code>INTO</code> was added here. This is optional and has no effect on MariaDB. It's only a matter of grammatical preference. In this example we not only name the columns, but we list them in a different order. This is acceptable to MariaDB. Just be sure to list the values in the same order. If you're going to insert data into a table and want to specify all of the values except one (say the key column since it's an auto-incremented one), then you could just give a value of DEFAULT to keep from having to list the columns. Incidentally, you can give the column names even if you're naming all of them. It's just unnecessary unless you're going to reorder them as we did in this last example.</p> <p>When you have many rows of data to insert into the same table, it can be more efficient to insert all of the rows in one SQL statement. Multiple row insertions can be done like so:</p> <pre class="fixed" data-language="sql">INSERT IGNORE
INTO table2
VALUES('id1','text','text'),
('id2','text','text'),
('id2','text','text');
</pre>
<p>Notice that the keyword VALUES is used only once and each row is contained in its own set of parentheses and each set is separated by commas. We've added an intentional mistake to this example: We are attempting to insert three rows of data into table2 for which the first column happens to be a <code>UNIQUE</code> key field. The third row entered here has the same identification number for the key column as the second row. This would normally result in an error and none of the three rows would be inserted. However, since the statement has an <code>IGNORE</code> flag, duplicates will be ignored and not inserted, but the other rows will still be inserted. So, the first and second rows above will be inserted and the third one won't.</p> <h4 class="anchored_heading" id="priority">Priority</h4> <p>An <a href="../insert/index.html">INSERT</a> statement takes priority over read statements (i.e., SELECT statements). An <a href="../insert/index.html">INSERT</a> will lock the table and force other clients to wait until it's finished. On a busy MariaDB server that has many simultaneous requests for data, this could cause users to experience delays when you run a script that performs a series of <a href="../insert/index.html">INSERT</a> statements. If you don't want user requests to be put on hold and you can wait to insert the data, you could use the <code>LOW_PRIORITY</code> flag:</p> <pre class="fixed" data-language="sql">INSERT LOW_PRIORITY
INTO table1
VALUES('text1','text2','text3');
</pre>
<p>The <code>LOW_PRIORITY</code> flag will put the <a href="../insert/index.html">INSERT</a> statement in queue, waiting for all current and pending requests to be completed before it's performed. If new requests are made while a low priority statement is waiting, then they are put ahead of it in the queue. MariaDB does not begin to execute a low priority statement until there are no other requests waiting. Once the transaction begins, though, the table is locked and any other requests for data from the table that come in after it starts must wait until it's completed. Because it locks the table, low priority statements will prevent simultaneous insertions from other clients even if you're dealing with a MyISAM table. Incidentally, notice that the <code>LOW_PRIORITY</code> flag comes before the <code>INTO</code>.</p> <p>One potential inconvenience with an <code>INSERT LOW_PRIORITY</code> statement is that the client will be tied up waiting for the statement to be completed successfully. So if you're inserting data into a busy server with a low priority setting using the mariadb client, your client could be locked up for minutes, maybe hours depending on how busy your server is at the time. As an alternative either to making other clients with read requests wait or to having your client wait, you can use the DELAYED flag instead of the <code>LOW_PRIORITY</code> flag:</p> <pre class="fixed" data-language="sql">INSERT DELAYED
INTO table1
VALUES('text1','text2','text3');
</pre>
<p>MariaDB will take the request as a low priority one and put it on its list of tasks to perform when it has a break. However, it will immediately release the client so that the client can go on to enter other SQL statements or even exit. Another advantage of this method is that multiple <code>INSERT DELAYED</code> requests are batched together for block insertion when there is a gap, making the process potentially faster than <code>INSERT LOW_PRIORITY</code>. The flaw in this choice, however, is that the client is never told if a delayed insertion is successfully made or not. The client is informed of error messages when the statement is entered<span>—</span>the statement has to be valid before it will be queued<span>—</span>but it's not told of problems that occur after it's accepted. This brings up another flaw: delayed insertions are stored in the server's memory. So if the MariaDB daemon (mariadbd) dies or is manually killed, then the transactions are lost and the client is not notified of the failure. So DELAYED is not always a good alternative.</p> <h4 class="anchored_heading" id="contingent-additions">Contingent Additions</h4> <p>As an added twist to <a href="../insert/index.html">INSERT</a>, you can combine it with a SELECT statement. Suppose that you have a table called employees which contains employee information for your company. Suppose further that you have a column to indicate whether an employee is on the company's softball team. However, you one day decide to create a separate database and table for the softball team's data that someone else will administer. To get the database ready for the new administrator, you have to copy some data for team members to the new table. Here's one way you can accomplish this task:</p> <pre class="fixed" data-language="sql">INSERT INTO softball_team 
(last, first, telephone) 
SELECT name_last, name_first, tel_home
FROM company.employees 
WHERE softball='Y';
</pre>
<p>In this SQL statement the columns in which data is to be inserted into are listed, then the complete SELECT statement follows with the appropriate WHERE clause to determine if an employee is on the softball team. Since we're executing this statement from the new database and since the table employees is in a separate database called company, we have to specify it as you see here. By the way, <a href="../insert-select/index.html">INSERT...SELECT</a> statements cannot be performed on the same table.</p> <h4 class="anchored_heading" id="replacement-data">Replacement Data</h4> <p>When you're adding massive amounts of data to a table that has a key field, as mentioned earlier, you can use the <code>IGNORE</code> flag to prevent duplicates from being inserted, but still allow unique rows to be entered. However, there may be times when you actually want to replace the rows with the same key fields with the new ones. In such a situation, instead of using <a href="../insert/index.html">INSERT</a> you can use a <a href="../replace/index.html">REPLACE</a> statement:</p> <pre class="fixed" data-language="sql">REPLACE LOW_PRIORITY
INTO table2 (id, col1, col2)
VALUES('id1','text','text'),
('id2','text','text'),
('id3','text','text');
</pre>
<p>Notice that the syntax is the same as an <a href="../insert/index.html">INSERT</a> statement. The flags all have the same effect, as well. Also, multiple rows may be inserted, but there's no need for the <code>IGNORE</code> flag since duplicates won't happen<span>—</span>the originals are just overwritten. Actually, when a row is replaced, it's first deleted completely and the new row is then inserted. Any columns without values in the new row will be given the default values for the columns. None of the values of the old row are kept. Incidentally, <a href="../replace/index.html">REPLACE</a> will also allow you to combine it with a SELECT statement as we saw with the <a href="../insert/index.html">INSERT</a> statement earlier.</p> <h4 class="anchored_heading" id="updating-data">Updating Data</h4> <p>If you want to change the data contained in existing records, but only for certain columns, then you would need to use an <a href="../update/index.html">UPDATE</a> statement. The syntax for <a href="../update/index.html">UPDATE</a> is a little bit different from the syntax shown before for <a href="../insert/index.html">INSERT</a> and <a href="../replace/index.html">REPLACE</a> statements:</p> <pre class="fixed" data-language="sql">UPDATE LOW_PRIORITY table3
SET col1 = 'text-a', col2='text-b'
WHERE id &lt; 100;
</pre>
<p>In the SQL statement here, we are changing the value of the two columns named individually using the <code>SET</code> clause. Incidentally, the <code>SET</code> clause optionally can be used in <a href="../insert/index.html">INSERT</a> and <a href="../replace/index.html">REPLACE</a> statements, but it eliminates the multiple row option. In the statement above, we're also using a <code>WHERE</code> clause to determine which records are changed: only rows with an id that has a value less than 100 are updated. Notice that the <code>LOW_PRIORITY</code> flag can be used with this statement, too. The <code>IGNORE</code> flag can be used, as well.</p> <p>A useful feature of the <a href="../update/index.html">UPDATE</a> statement is that it allows the use of the current value of a column to update the same column. For instance, suppose you want to add one day to the value of a date column where the date is a Sunday. You could do the following:</p> <pre class="fixed" data-language="sql">UPDATE table5
SET col_date = DATE_ADD(col_date, INTERVAL 1 DAY)
WHERE DAYOFWEEK(col_date) = 1;
</pre>
<p>For rows where the day of the week is Sunday, the DATE_ADD() function will take the value of col_date before it's updated and add one day to it. MariaDB will then take this sum and set col_date to it.</p> <p>There are a couple more twists that you can now do with the <a href="../update/index.html">UPDATE</a> statement: if you want to update the rows in a specific order, you can add an <a href="../select/index.html#order-by">ORDER BY</a> clause. You can also limit the number of rows that are updated with a <a href="../select/index.html#limit">LIMIT</a> clause. Below is an example of both of these clauses:</p> <pre class="fixed" data-language="sql">UPDATE LOW_PRIORITY table3
SET col1='text-a', col2='text-b'
WHERE id &lt; 100
ORDER BY col3 DESC
LIMIT 10;
</pre>
<p>The ordering can be descending as indicated here by the <code>DESC</code> flag, or ascending with either the ASC flag or by just leaving it out, as ascending is the default. The <a href="../select/index.html#limit">LIMIT</a> clause, of course, limits the number of rows affected to ten here.</p> <p>If you want to refer to multiple tables in one <a href="../update/index.html">UPDATE</a> statement, you can do so like this:</p> <pre class="fixed" data-language="sql">UPDATE table3, table4
SET table3.col1 = table4.col1
WHERE table3.id = table4.id;
</pre>
<p>Here we see a join between the two tables named. In table3, the value of col1 is set to the value of the same column in table4 where the values of id from each match. We're not updating both tables here; we're just accessing both. We must specify the table name for each column to prevent an ambiguity error. Incidentally, <a href="../select/index.html#order-by">ORDER BY</a> and <a href="../select/index.html#limit">LIMIT</a> clauses aren't allowed with multiple table updates.</p> <p>There's another combination that you can do with the <a href="../insert/index.html">INSERT</a> statement that we didn't mention earlier. It involves the <a href="../update/index.html">UPDATE</a> statement. When inserting multiple rows of data, if you want to note which rows had potentially duplicate entries and which ones are new, you could add a column called status and change it's value accordingly with a statement like this one:</p> <pre class="fixed" data-language="sql">INSERT IGNORE INTO table1 
(id, col1, col2, status) 
VALUES('1012','text','text','new'),
('1025,'text','text','new'),
('1030,'text','text','new')
ON DUPLICATE KEY 
UPDATE status = 'old';
</pre>
<p>Because of the <code>IGNORE</code> flag, errors will not be generated, duplicates won't be inserted or replaced, but the rest will be added. Because of the <a href="../insert-on-duplicate-key-update/index.html">ON DUPLICATE KEY</a>, the column status of the original row will be set to old when there are duplicate entry attempts. The rest will be inserted and their status set to new.</p> <h4 class="anchored_heading" id="conclusion">Conclusion</h4> <p>As you can see from some of these SQL statements, MariaDB offers you quite a few ways to add and to change data. In addition to these methods, there are also some bulk methods of adding and changing data in a table. You could use the <a href="../load-data-infile/index.html">LOAD DATA INFILE</a> statement and the <a href="../mariadb-dump/index.html">mariadb-dump</a> command-line utility. These methods are covered in another article on <a href="../importing-data-into-mariadb/index.html">Importing Data into MariaDB</a>.</p> </div>     </div> <div id="content_disclaimer" class="graybox"> Content reproduced on this site is the property of its respective owners, and this content is not reviewed in advance by MariaDB. The views, information and opinions expressed by this content do not necessarily represent those of MariaDB or any other party. </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2023 MariaDB<br>Licensed under the Creative Commons Attribution 3.0 Unported License and the GNU Free Documentation License.<br>
    <a href="https://mariadb.com/kb/en/adding-and-changing-data-in-mariadb/" class="_attribution-link">https://mariadb.com/kb/en/adding-and-changing-data-in-mariadb/</a>
  </p>
</div>
