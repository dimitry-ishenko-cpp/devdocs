<h1>OPTIMIZE TABLE</h1> <div> <div class="node creole"> <div class="answer formatted"> <h2 class="anchored_heading" id="syntax">Syntax</h2> <pre class="fixed" data-language="sql">OPTIMIZE [NO_WRITE_TO_BINLOG | LOCAL] TABLE
    tbl_name [, tbl_name] ...
    [WAIT n | NOWAIT]
</pre> <h2 class="anchored_heading" id="description">Description</h2> <p><code class="fixed" style="white-space:pre-wrap">OPTIMIZE TABLE</code> has two main functions. It can either be used to defragment tables, or to update the InnoDB fulltext index.</p> <h4 class="anchored_heading" id="waitnowait">WAIT/NOWAIT</h4> <p>Set the lock wait timeout. See <a href="../wait-and-nowait/index.html">WAIT and NOWAIT</a>.</p> <h3 class="anchored_heading" id="defragmenting">Defragmenting</h3> <p><code>OPTIMIZE TABLE</code> works for <a href="../innodb/index.html">InnoDB</a> (before <a href="https://mariadb.com/kb/en/mariadb-1011-release-notes/">MariaDB 10.1.1</a>, only if the <a href="../innodb-system-variables/index.html#innodb_file_per_table">innodb_file_per_table</a> server system variable is set), <a href="../aria/index.html">Aria</a>, <a href="../myisam/index.html">MyISAM</a> and <a href="../archive/index.html">ARCHIVE</a> tables, and should be used if you have deleted a large part of a table or if you have made many changes to a table with variable-length rows (tables that have <a href="../varchar/index.html">VARCHAR</a>, <a href="../varbinary/index.html">VARBINARY</a>, <a href="../blob/index.html">BLOB</a>, or <a href="../text/index.html">TEXT</a> columns). Deleted rows are maintained in a linked list and subsequent <code class="fixed" style="white-space:pre-wrap">INSERT</code> operations reuse old row positions.</p> <p>This statement requires <a href="../grant/index.html">SELECT and INSERT privileges</a> for the table.</p> <p>By default, <code>OPTIMIZE TABLE</code> statements are written to the <a href="../binary-log/index.html">binary log</a> and will be <a href="../replication/index.html">replicated</a>. The <code>NO_WRITE_TO_BINLOG</code> keyword (<code>LOCAL</code> is an alias) will ensure the statement is not written to the binary log.</p> <p><code>OPTIMIZE TABLE</code> statements are not logged to the binary log if <a href="../server-system-variables/index.html#read_only">read_only</a> is set. See also <a href="../read-only-replicas/index.html">Read-Only Replicas</a>.</p> <p><code class="fixed" style="white-space:pre-wrap">OPTIMIZE TABLE</code> is also supported for partitioned tables. You can use <code class="highlight fixed" style="white-space:pre-wrap"><a href="../alter-table/index.html">ALTER TABLE</a> ... OPTIMIZE PARTITION</code> to optimize one or more partitions.</p> <p>You can use <code class="fixed" style="white-space:pre-wrap">OPTIMIZE TABLE</code> to reclaim the unused space and to defragment the data file. With other storage engines, <code>OPTIMIZE TABLE</code> does nothing by default, and returns this message: " The storage engine for the table doesn't support optimize". However, if the server has been started with the <code>--skip-new</code> option, <code>OPTIMIZE TABLE</code> is linked to <a href="../alter-table/index.html">ALTER TABLE</a>, and recreates the table. This operation frees the unused space and updates index statistics.</p> <p>The <a href="../aria/index.html">Aria</a> storage engine supports <a href="../progress-reporting/index.html">progress reporting</a> for this statement.</p> <p>If a <a href="../myisam/index.html">MyISAM</a> table is fragmented, <a href="../concurrent-inserts/index.html">concurrent inserts</a> will not be performed until an <code>OPTIMIZE TABLE</code> statement is executed on that table, unless the <a href="../server-system-variables/index.html#concurrent_insert">concurrent_insert</a> server system variable is set to <code>ALWAYS</code>.</p> <h3 class="anchored_heading" id="updating-an-innodb-fulltext-index">Updating an InnoDB fulltext index</h3> <p>When rows are added or deleted to an InnoDB <a href="../full-text-indexes/index.html">fulltext index</a>, the index is not immediately re-organized, as this can be an expensive operation. Change statistics are stored in a separate location . The fulltext index is only fully re-organized when an <code>OPTIMIZE TABLE</code> statement is run.</p> <p>By default, an OPTIMIZE TABLE will defragment a table. In order to use it to update fulltext index statistics, the <a href="../innodb-system-variables/index.html#innodb_optimize_fulltext_only">innodb_optimize_fulltext_only</a> system variable must be set to <code>1</code>. This is intended to be a temporary setting, and should be reset to <code>0</code> once the fulltext index has been re-organized.</p> <p>Since fulltext re-organization can take a long time, the <a href="../innodb-system-variables/index.html#innodb_ft_num_word_optimize">innodb_ft_num_word_optimize</a> variable limits the re-organization to a number of words (2000 by default). You can run multiple OPTIMIZE statements to fully re-organize the index.</p> <h3 class="anchored_heading" id="defragmenting-innodb-tablespaces">Defragmenting InnoDB tablespaces</h3> <p><a href="https://mariadb.com/kb/en/mariadb-1011-release-notes/">MariaDB 10.1.1</a> merged the Facebook/Kakao defragmentation patch, allowing one to use <code>OPTIMIZE TABLE</code> to defragment InnoDB tablespaces. For this functionality to be enabled, the <a href="../innodb-system-variables/index.html#innodb_defragment">innodb_defragment</a> system variable must be enabled. No new tables are created and there is no need to copy data from old tables to new tables. Instead, this feature loads <code>n</code> pages (determined by <a href="../innodb-system-variables/index.html#innodb_defragment_n_pages">innodb-defragment-n-pages</a>) and tries to move records so that pages would be full of records and then frees pages that are fully empty after the operation. Note that tablespace files (including ibdata1) will not shrink as the result of defragmentation, but one will get better memory utilization in the InnoDB buffer pool as there are fewer data pages in use.</p> <p>See <a href="../defragmenting-innodb-tablespaces/index.html">Defragmenting InnoDB Tablespaces</a> for more details.</p> <h2 class="anchored_heading" id="see-also">See Also</h2> <ul start="1">
<li>
<a href="../innodb-online-ddl-operations-with-the-inplace-alter-algorithm/index.html#optimize-table">Optimize Table in InnoDB with ALGORITHM set to INPLACE</a> </li>
<li>
<a href="../innodb-online-ddl-operations-with-the-nocopy-alter-algorithm/index.html#optimize-table">Optimize Table in InnoDB with ALGORITHM set to NOCOPY</a> </li>
<li><a href="../innodb-online-ddl-operations-with-the-instant-alter-algorithm/index.html#optimize-table">Optimize Table in InnoDB with ALGORITHM set to INSTANT</a></li>
</ul> </div>     </div> <div id="content_disclaimer" class="graybox"> Content reproduced on this site is the property of its respective owners, and this content is not reviewed in advance by MariaDB. The views, information and opinions expressed by this content do not necessarily represent those of MariaDB or any other party. </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2023 MariaDB<br>Licensed under the Creative Commons Attribution 3.0 Unported License and the GNU Free Documentation License.<br>
    <a href="https://mariadb.com/kb/en/optimize-table/" class="_attribution-link">https://mariadb.com/kb/en/optimize-table/</a>
  </p>
</div>
