<h1>Database Design Phase 2: Logical and Physical Design</h1> <div> <div class="node creole"> <div class="answer formatted"> <div class="cstm-style bluebox">
<p>This article follows on from <a href="../database-design-phase-2-conceptual-design/index.html">Database Design Phase 2: Conceptual Design</a>.</p> </div> <h2 class="anchored_heading" id="overview">Overview</h2> <p>Once the conceptual design is finalized, it's time to convert this to the logical and physical design. Usually, the DBMS is chosen at this stage, depending on the requirements and complexity of the data structures. Strictly speaking, the logical design and the physical design are two separate stages, but are often merged into one. They overlap because most current DBMSs (including MariaDB) match logical records to physical records on disk on a 1:1 basis.</p> <p>Each entity will become a database table, and each attribute will become a field of this table. Foreign keys can be created if the DBMS supports them and the designer decides to implement them. If the relationship is mandatory, the foreign key must be defined as <em>NOT NULL</em>, and if it's optional, the foreign key can allow nulls. For example, because of the invoice line-to-product relationship in the previous example, the product code field is a foreign key in the invoice to line table. Because the invoice line must contain a product, the field must be defined as <em>NOT NULL</em>. The default MariaDB storage engine, <a href="../innodb/index.html">XtraDB</a>, does support foreign key constraints, but some storage engines, such as <a href="../myisam/index.html">MyISAM</a> do not. The <em>ON DELETE CASCADE</em> and <em>ON DELETE RESTRICT</em> clauses are used to support foreign keys. <em>ON DELETE RESTRICT</em> means that records cannot be deleted unless all records associated with the foreign key are also deleted. In the invoice line-to-product case, <em>ON DELETE RESTRICT</em> in the invoice line table means that if a product is deleted, the deletion will not take place unless all associated invoice lines with that product are deleted as well. This avoids the possibility of an invoice line existing that points to a non-existent product. <em>ON DELETE CASCADE</em> achieves a similar effect, but more automatically (and more dangerously!). If the foreign key was declared with <em>ON CASCADE DELETE</em>, associated invoice lines would automatically be deleted if a product was deleted. <em>ON UPDATE CASCADE</em> is similar to <em>ON DELETE CASCADE</em> in that all foreign key references to a primary key are updated when the primary key is updated.</p> <p><a href="../database-normalization/index.html">Normalizing</a> your tables is an important step when designing the database. This process helps avoid data redundancy and improves your data integrity.</p> <p>Novice database designers usually make a number of common errors. If you've carefully identified entities and attributes and you've normalized your data, you'll probably avoid these errors.</p> <h2 class="anchored_heading" id="common-errors">Common errors</h2> <ul start="1">
<li>Keep unrelated data in different tables. People who are used to using spreadsheets often make this mistake because they are used to seeing all their data in one two-dimensional table. A relational database is much more powerful; don't 'hamstring' it in this way. </li>
<li>Don't store values you can calculate. Let's say you're interested three numbers: /A, B and the product of A and B (A*B). Don't store the product. It wastes space and can easily be calculated if you need it. And it makes your database more difficult to maintain: If you change A, you also have to change all of the products as well. Why waste your database's efforts on something you can calculate when you need it? </li>
<li>Does your design cater to all the conditions you've analyzed? In the heady rush of creating an entity-relationship diagram, you can easily overlook a condition. Entity-relationship diagrams are usually better at getting stakeholders to spot an incorrect rule than spot a missing one. The business logic is as important as the database logic and is more likely to be overlooked. For example, it's easy to spot that you cannot have a sale without an associated customer, but have you built in that the customer cannot be approved for a sale of less than $500 if another approved customer has not recommended them? </li>
<li>Are your attributes, which are about to become field names, well chosen? Fields should be clearly named. For example, if you use <em>f1</em> and <em>f2</em> instead of <em>surname</em> and <em>first_name</em>, the time saved in less typing will be lost in looking up the correct spelling of the field, or in mistakes where a developer thought <em>f1</em> was the first name, and <em>f2</em> the surname. Similarly, try to avoid the same names for different fields. If six tables have a primary key of <em>code</em>, you're making life unnecessarily difficult. Rather, use more descriptive terms, such as <em>sales_code</em> or <em>customer_code</em>. </li>
<li>Don't create too many relationships. Almost every table in a system can be related by some stretch of the imagination, but there's no need to do this. For example, a tennis player belongs to a sports club. A sports club belongs to a region. The tennis players then also belong to a region, but this relationship can be derived through the sports club, so there's no need to add another foreign key (except to achieve performance benefits for certain kinds of queries). Normalizing can help you avoid this sort of problem (and even when you're trying to optimize for speed, it's usually better to normalize and then consciously denormalize rather than not normalize at all). </li>
<li>Conversely, have you catered to all relations? Do all relations from your entity-relationship diagram appear as common fields in your table structures? Have you covered all relations? Are all many-to-many relationships broken up into two one-to-many relationships, with an intersection entity? </li>
<li>Have you listed all constraints? Constraints include a gender that can only be <em>m</em> or <em>f</em>, ages of schoolchildren that cannot exceed twenty, or email addresses that need to have an <em>@</em> sign and at least one period (<em>.</em>; don't take these limits for granted. At some stage the system you will need to implement them, and you're either going to forget to do so, or have to go back and gather more data if you don't list these up front. </li>
<li>Are you planning to store too much data? Should a customer be asked to supply their eye color, favorite kind of fish, and names of their grandparents if they are simply trying to register for an online newsletter? Sometimes stakeholders want too much information from their customers. If the user is outside the organization, they may not have a voice in the design process, but they should always be thought of foremost. Consider also the difficulty and time taken to capture all the data. If a telephone operator needs to take all this information down before making a sale, imagine how much slower they will be. Also consider the impact data has on database speed. Larger tables are generally slower to access, and unnecessary <a href="../blob/index.html">BLOB</a>, <a href="../text/index.html">TEXT</a> and <a href="../varchar/index.html">VARCHAR</a> fields lead to record and table fragmentation. </li>
<li>Have you combined fields that should be separate? Combining first name and surname into one field is a common beginner mistake. Later you'll realise that sorting names alphabetically is tricky if you've stored them as <em>John Ellis</em> and <em>Alfred Ntombela</em>. Keep distinct data discrete. </li>
<li>Has every table got a primary key? There had better be a good reason for leaving out a primary key. How else are you going to identify a unique record quickly? Consider that an index speeds up access time tremendously, and when kept small it adds very little overhead. Also, it's usually better to create a new field for the primary key rather than take existing fields. First name and surname may be unique in your current database, but they may not always be. Creating a system-defined primary key ensures it will always be unique. </li>
<li>Give some thought to your other indexes. What fields are likely to be used in this condition to access the table? You can always create more fields later when you test the system, but add any you think you need at this stage. </li>
<li>Are your foreign keys correctly placed? In a one-to-many relationship, the foreign key appears in the <em>many</em> table, and the associated primary key in the <em>one</em> table. Mixing these up can cause errors. </li>
<li>Do you ensure referential integrity? Foreign keys should not relate to a primary key in another table that no longer exists. </li>
<li>Have you covered all character sets you may need? German letters, for example, have an expanded character set, and if the database is to cater for German users it will have to take this into account. Similarly, dates and currency formats should be carefully considered if the system is to be international </li>
<li>Is your security sufficient? Remember to assign the minimum permissions you can. Do not allow anyone to view a table if they do not need to do so. Allowing malicious users view data, even if they cannot change it, is often the first step in for an attacker.</li>
</ul> </div>     </div> <div id="content_disclaimer" class="graybox"> Content reproduced on this site is the property of its respective owners, and this content is not reviewed in advance by MariaDB. The views, information and opinions expressed by this content do not necessarily represent those of MariaDB or any other party. </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2023 MariaDB<br>Licensed under the Creative Commons Attribution 3.0 Unported License and the GNU Free Documentation License.<br>
    <a href="https://mariadb.com/kb/en/database-design-phase-2-logical-and-physical-design/" class="_attribution-link">https://mariadb.com/kb/en/database-design-phase-2-logical-and-physical-design/</a>
  </p>
</div>
