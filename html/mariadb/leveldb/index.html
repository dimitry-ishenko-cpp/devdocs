<h1>LevelDB Storage Engine</h1> <div> <div class="node creole"> <div class="answer formatted"> <h2 class="anchored_heading" id="basic-feature-list">Basic feature list</h2> <ul start="1">
<li>single-statement transactions </li>
<li>secondary indexes </li>
<li>HANDLER implementation with extensions to support atomic multi-put (kind of like multi-statement transactions) </li>
<li>binlog XA on the master to be crash safe </li>
<li>crash-proof slave replication state </li>
<li>(almost) non blocking schema change </li>
<li>full test coverage via mysql-test-run </li>
<li>hot backup </li>
<li>possible options are to have LevelDB instance per mysqld, per schema or per table </li>
</ul>  <h2 class="anchored_heading" id="implementation-overview">Implementation overview</h2> <h3 class="anchored_heading" id="one-leveldb-instance">One leveldb instance</h3> <p>We consider using one LevelDB instance for mysqld process. LevelDB keys will be prefixed with 'dbname.table_name', 'dbname.table_name.index_name' (or their shorter equivalents). This will allow to store arbitrary number of tables/indexes in one LevelDB instance.</p> <h3 class="anchored_heading" id="transaction-support">Transaction support</h3> <p>LevelDB supports</p> <ul start="1">
<li>read snapshots </li>
<li>batch updates </li>
</ul> <p>when you have just those, there is no easy way to support full transactional semantics in the way it is required from MySQL table engine.</p> <p>If we limit ourselves to single-statement transactions which touch limited numbers of rows, they could be implemented as follows:</p> <ul start="1">
<li>updates done by the statement are accumulated in a batch </li>
<li>if the statement is committed, the batch is applied. LevelDB guarantees this will be an atomic operation </li>
<li>if the statement is rolled back, the batch is simply discarded. </li>
</ul> <p>(Note: the "Test implementation" uses exactly this approach. It presents itself to MySQL as a non-transactional engine which is able to roll back a statement)</p> <p>(Note: According to Serg: Storage Engine API does not specify whether the changes made to table data should be immediately visible, or remain invisible until the end of the statement. Both kinds of behavior are allowed).</p> <p><em>TODO: what if two transactions attempt to make conflicting changes? Will one of them get a conflict? A: NO, because LevelDB's operations cannot get in conflict. Delete() means "delete if exists" and Put() means "write, or overwrite". Therefore, no conflicts possible. TODO: is this ok? (more on this below)</em></p> <h3 class="anchored_heading" id="data-formats">Data formats</h3> <p>LevelDB compresses data with something called SnappyCompressor. </p> <p>We will rely on it to make the storage compact. Data that goes into LevelDB's key will be stored in KeyTupleFormat (which allows mysql's lookup/index ordering functions to work). Data that goes into LevelDB's value will be stored in table-&gt;record[0] format, except blobs. (Blobs will require special storage convention because they store a char* pointer in table-&gt;record[0]). </p> <p>(TODO: is it okay not to support blobs in the first milestone?)</p> <p>(note: datatypes in the provided benchmark are: composite primary/secondary keys, INTs and VARCHARs (are they latin1 or utf-8?)).</p> <h3 class="anchored_heading" id="secondary-indexes">Secondary Indexes</h3> <h4 class="anchored_heading" id="unique-secondary-indexes">Unique secondary indexes</h4> <p>Unique secondary index is stored in a {KEY-&gt;VALUE} mapping in LevelDB, where index columns are used as KEY, and Primary Key columns are used as VALUE. This way,</p> <ul start="1">
<li>"index-only" scans are possible </li>
<li>non-"index-only" scan is a two step process (access the index, access the primary index). </li>
</ul> <p>We need to support unique indexes, but not in the first milestone. </p> <p>Note: unique indexes may prevent read-before-write optimization. There is a @@unique_checks variable (used at least by InnoDB) which can be used to offer no-guarantees fast execution.</p> <h4 class="anchored_heading" id="non-unique-secondary-indexes">Non-unique secondary indexes</h4> <p>LevelDB stores {KEY-&gt;VALUE} mappings. Non-unique index will need to have some unique values for KEY. This is possible if we do </p> <pre class="fixed" data-language="sql">KEY = {index_columns, primary_key_columns}.   
VALUE = {nothing}
</pre>
<p>(todo: check if leveldb allows zero-sized values).</p> <p>Using primary key as suffix will make DB::Get() useless. Instead, we will have to do lookups with:</p> <pre class="fixed" data-language="sql">get(secondary_index_key_val)
{
  open cursor for (secondary_index_key_val)
  read the first record
  if (record &gt; secondary_index_key_val)
    return NOT_FOUND;
  else
    return FOUND;
}
</pre>
<h3 class="anchored_heading" id="non-blocking-schema-changes">Non-blocking schema changes</h3> <ul start="1"><li>There is a requirement that doing schema changes does not block other queries from running. </li></ul> <ul start="1"><li>Reclaiming space immediately after some parts of data were dropped is not important. </li></ul> <p>Possible approaches we could use:</p> <ul start="1"><li>Record format that support multiple versions. That way, adding/modifying/ dropping a non-indexed column may be instant. Note that this is applicable for records, not keys. </li></ul> <ul start="1"><li>Background creation/dropping of indexes. </li></ul> <h3 class="anchored_heading" id="hot-backup">Hot backup</h3> <p>Hot backup will be made outside of this project. The idea is to hard-link the files so that they can't be deleted by compaction process, and then copy them over.</p> <h2 class="anchored_heading" id="sql-command-mapping-for-leveldb">SQL Command mapping for LevelDB</h2> <h3 class="anchored_heading" id="insert">INSERT</h3> <p>There will be two kinds of INSERTs</p> <ol start="1">
<li>No-reads INSERT-or-UPDATE, with semantics like in LevelDB's DB::Put() operation. </li>
<li>a "real" INSERT with SQL semantics </li>
</ol> <h4 class="anchored_heading" id="insert-or-update-low-priority">INSERT-or-UPDATE (low priority)</h4> <p>SergeiG has pointed out that SQL layer already has support for write-optimized INSERTs (it was implemented for NDB Cluster). </p> <p>When the table has no triggers, REPLACE command will call handler-&gt;extra(HA_EXTRA_WRITE_CAN_REPLACE), after which handler-&gt;write_row() calls are allowed to silently overwrite rows. </p> <p>The number of affected rows returned by the statement is actually upper bound.</p> <p>(note: TokuDB documentation mentions they have something similar with INSERTs. They allow no-reads REPLACE and INSERT IGNORE, when the table has no triggers, there is no RBR binary logging, etc - the same conditions as we will have)</p> <h5 class="anchored_heading" id="batching">Batching</h5> <p>It is possible to batch multi-line REPLACE commands. (TODO: Can no-read REPLACEs fail at all? If not, we can limit batch size and use multiple batches if necessary. If yes, we'll have to document that big REPLACEs may fail in the middle of a statement/ Q: is this OK?)</p> <h4 class="anchored_heading" id="regular-insert">Regular INSERT</h4> <p>Regular INSERT will do a read before write and will use "gap locking" to make sure its DB::Put() call doesn't overwrite somebody's data.</p> <h3 class="anchored_heading" id="update">UPDATE</h3> <p>UPDATE will do a read before write and will use record locking to make sure it's not overwriting somebody else's changes (or not updating a row that has just been deleted).</p> <p><em>Note: mysql-5.6 has <a href="http://askmonty.org/worklog/?tid=5906">WL#5906</a> (see link at the bottom)read before write removal (RBWR). It is not exactly what we need, but is similar (and ugly)</em></p> <h3 class="anchored_heading" id="delete">DELETE</h3> <p>Currently, a DELETE statement has to do a read. Records are deleted through handler-&gt;delete_row() call of the Storage Engine API, which has the meaning "delete the row that was just read". </p> <p>There will be two kinds of DELETE statement:</p> <ul start="1">
<li>Write-optimized DELETE IF_EXISTS </li>
<li>Regular DELETE </li>
</ul> <h4 class="anchored_heading" id="delete-if_exists-low-priority">DELETE IF_EXISTS (low priority)</h4> <p>This is a write-optimized version. It will have semantics close to LevelDB's DB::Delete() call. We will have to modify the SQL layer to support it.</p> <p>The syntax will be</p> <p>&lt;&lt;code lang='sql'&gt; DELETE NO_READ FROM tbl WHERE ... &lt;&lt;/code&gt;&gt;</p> <p>the option NO_READ will be supported only for single-table DELETEs, and will require that - the WHERE clause refers to primary key columns only - the WHERE clause allows to construct a list of primary keys to be deleted. - there ORDER BY clause</p> <p>if the above conditions are not met, the statement will fail with an error. if they are met, the statement translate into handler-&gt;delete_row() calls, without any read calls.</p> <p>mysql_affected_rows() will return an upper bound of how many rows could be deleted.</p> <h4 class="anchored_heading" id="regular-delete">Regular DELETE</h4> <p>Regular DELETE will have to use locking.</p> <h3 class="anchored_heading" id="select">SELECT</h3> <h4 class="anchored_heading" id="will-use-snapshot">Will use snapshot</h4> <p>SELECTs will allocate/use a snapshot for reading data. This way, sql layer will not get non-repeatable reads within a statement.</p> <p>Q: is this needed? Using snapshots has some cost?</p> <h4 class="anchored_heading" id="range-scans">Range scans</h4> <ul start="1">
<li>LevelDB cursors can be used for range scans. </li>
<li>DB::GetApproximateSizes() can be used to implement handler::records_in_range() </li>
<li>There is nothing for rec_per_key (index statistics) </li>
</ul> <h3 class="anchored_heading" id="alter-table">ALTER TABLE</h3> <p>MySQL 5.6 should support online ALTER TABLE operations (as InnoDB now supports them).</p> <p>TODO: what does the storage engine needs to do to inform the SQL layer that it is running a long DDL change which does not prevent other selects/updates from running?</p> <h2 class="anchored_heading" id="binlog-xa-on-master">Binlog XA on Master</h2> <p>This is about keeping binlog and LevelDB in sync on the master. MySQL does it as follows: </p> <ul start="1">
<li>prepare transaction in the storage engine </li>
<li>write it into the binlog </li>
<li>commit it in the engine </li>
</ul> <p>If transactions are grouped, they are committed in the same order as they were written into the binary log.</p> <p>Recovery proceeds as follows:</p> <ul start="1">
<li>Read the last binlog file and note XIDs of transactions that are there. </li>
<li>for each storage engine, <ul start="1">
<li>scan the committed transactions and compare their XIDs to those we've found in the binlog. </li>
<li>If transaction is the binlog - commit, otherwise - roll it back) </li>
</ul> </li>
</ul> <p>(note that the order the transactions are applied in is determined from the engine, not from the binlog)</p> <p>TODO: suggestions about how PREPARE/COMMIT/recovery should work for LevelDB. (got some ideas after discussion with Kristian, need to write them down)</p> <h2 class="anchored_heading" id="crash-proof-slave">Crash-proof slave</h2> <p>MySQL 5.6 stores information that used to be in relay_log.info in InnoDB. That way, InnoDB and relay_log.info (aka binlog position) are always in sync.</p> <p>It seems, switching to storing relay_log.info in a LevelDB table is sufficient for crash-proof slave. (note: this implies that semantics of operations over LevelDB table is sufficiently close to that of a regular MySQL storage engine, like innodb).</p> <h2 class="anchored_heading" id="other-details">Other details</h2> <ul start="1">
<li>The target version is MySQL 5.6 (good, because LevelDB API uses STL and 5.6-based versions support compiling with STL). </li>
<li>It is ok to make changes to LevelDB itself </li>
</ul> <ul start="1"><li>There is a "Test implementation" at <a href="https://github.com/tbdingqi/tbleveldb">https://github.com/tbdingqi/tbleveldb</a>. </li></ul> <ul start="1"><li>Task tracking for this is done here: <a href="https://jira.mariadb.org/browse/MDEV-3841">MDEV-3841</a> </li></ul> <ul start="1"><li>We may want to check out this: <a href="http://dev.mysql.com/worklog/task/?id=5906">http://dev.mysql.com/worklog/task/?id=5906</a>. It is pushed into 5.6 </li></ul> <h2 class="anchored_heading" id="milestones">Milestones</h2> <ul start="1">
<li>Milestone #1 is described at <a href="../leveldb-storage-engine-ms1/index.html">leveldb-storage-engine-ms1</a> </li>
<li>Subsequent development is described at <a href="../leveldb-storage-engine-development/index.html">leveldb-storage-engine-development</a> </li>
</ul> <ul start="1"><li>Milestone #2 is described at <a href="../leveldb-storage-engine-ms2/index.html">leveldb-storage-engine-ms2</a> </li></ul> </div>     </div> <div id="content_disclaimer" class="graybox"> Content reproduced on this site is the property of its respective owners, and this content is not reviewed in advance by MariaDB. The views, information and opinions expressed by this content do not necessarily represent those of MariaDB or any other party. </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2023 MariaDB<br>Licensed under the Creative Commons Attribution 3.0 Unported License and the GNU Free Documentation License.<br>
    <a href="https://mariadb.com/kb/en/leveldb/" class="_attribution-link">https://mariadb.com/kb/en/leveldb/</a>
  </p>
</div>
