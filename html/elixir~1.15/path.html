<h1>   <span translate="no">Path</span>  </h1> <section id="moduledoc"> <p>This module provides conveniences for manipulating or retrieving file system paths.</p>
<p>The functions in this module may receive chardata as arguments and will always return a string encoded in UTF-8. Chardata is a string or a list of characters and strings, see <a href="io.html#t:chardata/0"><code class="inline">IO.chardata/0</code></a>. If a binary is given, in whatever encoding, its encoding will be kept.</p>
<p>The majority of the functions in this module do not interact with the file system, except for a few functions that require it (like <a href="#wildcard/2"><code class="inline">wildcard/2</code></a> and <a href="#expand/1"><code class="inline">expand/1</code></a>).</p> </section> <section id="summary" class="details-list">  <h2> Types </h2>
<dl class="summary-types summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#t:t/0" translate="no">t()</a> </dt> <dd class="summary-synopsis"><p>A path.</p></dd> </div> </dl> <h2> Functions </h2>
<dl class="summary-functions summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#absname/1" translate="no">absname(path)</a> </dt> <dd class="summary-synopsis"><p>Converts the given path to an absolute one.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#absname/2" translate="no">absname(path, relative_to)</a> </dt> <dd class="summary-synopsis"><p>Builds a path from <code class="inline">relative_to</code> to <code class="inline">path</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#basename/1" translate="no">basename(path)</a> </dt> <dd class="summary-synopsis"><p>Returns the last component of the path or the path itself if it does not contain any directory separators.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#basename/2" translate="no">basename(path, extension)</a> </dt> <dd class="summary-synopsis"><p>Returns the last component of <code class="inline">path</code> with the <code class="inline">extension</code> stripped.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#dirname/1" translate="no">dirname(path)</a> </dt> <dd class="summary-synopsis"><p>Returns the directory component of <code class="inline">path</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#expand/1" translate="no">expand(path)</a> </dt> <dd class="summary-synopsis"><p>Converts the path to an absolute one, expanding any <code class="inline">.</code> and <code class="inline">..</code> components and a leading <code class="inline">~</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#expand/2" translate="no">expand(path, relative_to)</a> </dt> <dd class="summary-synopsis"><p>Expands the path relative to the path given as the second argument expanding any <code class="inline">.</code> and <code class="inline">..</code> characters.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#extname/1" translate="no">extname(path)</a> </dt> <dd class="summary-synopsis"><p>Returns the extension of the last component of <code class="inline">path</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#join/1" translate="no">join(list)</a> </dt> <dd class="summary-synopsis"><p>Joins a list of paths.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#join/2" translate="no">join(left, right)</a> </dt> <dd class="summary-synopsis"><p>Joins two paths.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#relative/1" translate="no">relative(name)</a> </dt> <dd class="summary-synopsis"><p>Forces the path to be a relative path.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#relative_to/2" translate="no">relative_to(path, from)</a> </dt> <dd class="summary-synopsis"><p>Returns the direct relative path from <code class="inline">path</code> in relation to <code class="inline">from</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#relative_to_cwd/1" translate="no">relative_to_cwd(path)</a> </dt> <dd class="summary-synopsis"><p>Convenience to get the path relative to the current working directory.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#rootname/1" translate="no">rootname(path)</a> </dt> <dd class="summary-synopsis"><p>Returns the <code class="inline">path</code> with the <code class="inline">extension</code> stripped.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#rootname/2" translate="no">rootname(path, extension)</a> </dt> <dd class="summary-synopsis"><p>Returns the <code class="inline">path</code> with the <code class="inline">extension</code> stripped.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#safe_relative/1" translate="no">safe_relative(path)</a> </dt> <dd class="summary-synopsis"><p>Returns a path relative to the current working directory that is protected from directory-traversal attacks.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#safe_relative_to/2" translate="no">safe_relative_to(path, relative_to)</a> </dt> <dd class="summary-synopsis"><p>Returns a relative path that is protected from directory-traversal attacks.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#split/1" translate="no">split(path)</a> </dt> <dd class="summary-synopsis"><p>Splits the path into a list at the path separator.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#type/1" translate="no">type(name)</a> </dt> <dd class="summary-synopsis"><p>Returns the path type.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#wildcard/2" translate="no">wildcard(glob, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Traverses paths according to the given <code class="inline">glob</code> expression and returns a list of matches.</p></dd> </div> </dl> </section> <section id="types" class="details-list">  <div class="types-list"> <section class="detail"> <h3 class="detail-header" id="t:t/0">t()<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/path.ex#L19" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type t() :: IO.chardata()</pre> </div> <p>A path.</p> </section> </section> </div> </section> <section id="functions" class="details-list">  <div class="functions-list"> <section class="detail"> <h3 class="detail-header" id="absname/1">absname(path)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/path.ex#L46" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec absname(t()) :: binary()</pre> </div> <p>Converts the given path to an absolute one.</p>
<p>Unlike <a href="#expand/1"><code class="inline">expand/1</code></a>, no attempt is made to resolve <code class="inline">..</code>, <code class="inline">.</code>, or <code class="inline">~</code>.</p>
<h4 id="absname/1-examples" class="section-heading"> <a href="#absname/1-examples">  Examples </a> </h4> <h3 id="absname/1-unix-like-operating-systems" class="section-heading"> <a href="#absname/1-unix-like-operating-systems">  Unix-like operating systems </a> </h3> <pre data-language="elixir">Path.absname("foo")
#=&gt; "/usr/local/foo"

Path.absname("../x")
#=&gt; "/usr/local/../x"</pre>
<h3 id="absname/1-windows" class="section-heading"> <a href="#absname/1-windows">  Windows </a> </h3> <pre data-language="elixir">Path.absname("foo")
#=&gt; "D:/usr/local/foo"

Path.absname("../x")
#=&gt; "D:/usr/local/../x"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="absname/2">absname(path, relative_to)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/path.ex#L69" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec absname(t(), t()) :: binary()</pre> </div> <p>Builds a path from <code class="inline">relative_to</code> to <code class="inline">path</code>.</p>
<p>If <code class="inline">path</code> is already an absolute path, <code class="inline">relative_to</code> is ignored. See also <a href="#relative_to/2"><code class="inline">relative_to/2</code></a>.</p>
<p>Unlike <a href="#expand/2"><code class="inline">expand/2</code></a>, no attempt is made to resolve <code class="inline">..</code>, <code class="inline">.</code> or <code class="inline">~</code>.</p>
<h4 id="absname/2-examples" class="section-heading"> <a href="#absname/2-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Path.absname("foo", "bar")
"bar/foo"

iex&gt; Path.absname("../x", "bar")
"bar/../x"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="basename/1">basename(path)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/path.ex#L382" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec basename(t()) :: binary()</pre> </div> <p>Returns the last component of the path or the path itself if it does not contain any directory separators.</p>
<h4 id="basename/1-examples" class="section-heading"> <a href="#basename/1-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Path.basename("foo")
"foo"

iex&gt; Path.basename("foo/bar")
"bar"

iex&gt; Path.basename("lib/module/submodule.ex")
"submodule.ex"

iex&gt; Path.basename("/")
""</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="basename/2">basename(path, extension)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/path.ex#L406" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec basename(t(), t()) :: binary()</pre> </div> <p>Returns the last component of <code class="inline">path</code> with the <code class="inline">extension</code> stripped.</p>
<p>This function should be used to remove a specific extension which may or may not be there.</p>
<h4 id="basename/2-examples" class="section-heading"> <a href="#basename/2-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Path.basename("~/foo/bar.ex", ".ex")
"bar"

iex&gt; Path.basename("~/foo/bar.exs", ".ex")
"bar.exs"

iex&gt; Path.basename("~/foo/bar.old.ex", ".ex")
"bar.old"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="dirname/1">dirname(path)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/path.ex#L429" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec dirname(t()) :: binary()</pre> </div> <p>Returns the directory component of <code class="inline">path</code>.</p>
<h4 id="dirname/1-examples" class="section-heading"> <a href="#dirname/1-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Path.dirname("/foo/bar.ex")
"/foo"

iex&gt; Path.dirname("/foo/bar/baz.ex")
"/foo/bar"

iex&gt; Path.dirname("/foo/bar/")
"/foo/bar"

iex&gt; Path.dirname("bar.ex")
"."</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="expand/1">expand(path)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/path.ex#L165" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec expand(t()) :: binary()</pre> </div> <p>Converts the path to an absolute one, expanding any <code class="inline">.</code> and <code class="inline">..</code> components and a leading <code class="inline">~</code>.</p>
<h4 id="expand/1-examples" class="section-heading"> <a href="#expand/1-examples">  Examples </a> </h4> <pre data-language="elixir">Path.expand("/foo/bar/../baz")
#=&gt; "/foo/baz"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="expand/2">expand(path, relative_to)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/path.ex#L194" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec expand(t(), t()) :: binary()</pre> </div> <p>Expands the path relative to the path given as the second argument expanding any <code class="inline">.</code> and <code class="inline">..</code> characters.</p>
<p>If the path is already an absolute path, <code class="inline">relative_to</code> is ignored.</p>
<p>Note that this function treats a <code class="inline">path</code> with a leading <code class="inline">~</code> as an absolute one.</p>
<p>The second argument is first expanded to an absolute path.</p>
<h4 id="expand/2-examples" class="section-heading"> <a href="#expand/2-examples">  Examples </a> </h4> <pre data-language="elixir"># Assuming that the absolute path to baz is /quux/baz
Path.expand("foo/bar/../bar", "baz")
#=&gt; "/quux/baz/foo/bar"

Path.expand("foo/bar/../bar", "/baz")
#=&gt; "/baz/foo/bar"

Path.expand("/foo/bar/../bar", "/baz")
#=&gt; "/foo/bar"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="extname/1">extname(path)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/path.ex#L455" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec extname(t()) :: binary()</pre> </div> <p>Returns the extension of the last component of <code class="inline">path</code>.</p>
<p>For filenames starting with a dot and without an extension, it returns an empty string.</p>
<p>See <a href="#basename/1"><code class="inline">basename/1</code></a> and <a href="#rootname/1"><code class="inline">rootname/1</code></a> for related functions to extract information from paths.</p>
<h4 id="extname/1-examples" class="section-heading"> <a href="#extname/1-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Path.extname("foo.erl")
".erl"

iex&gt; Path.extname("~/foo/bar")
""

iex&gt; Path.extname(".gitignore")
""</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="join/1">join(list)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/path.ex#L517" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec join([t(), ...]) :: binary()</pre> </div> <p>Joins a list of paths.</p>
<p>This function should be used to convert a list of paths to a path. Note that any trailing slash is removed when joining.</p>
<p>Raises an error if the given list of paths is empty.</p>
<h4 id="join/1-examples" class="section-heading"> <a href="#join/1-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Path.join(["~", "foo"])
"~/foo"

iex&gt; Path.join(["foo"])
"foo"

iex&gt; Path.join(["/", "foo", "bar/"])
"/foo/bar"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="join/2">join(left, right)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/path.ex#L546" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec join(t(), t()) :: binary()</pre> </div> <p>Joins two paths.</p>
<p>The right path will always be expanded to its relative format and any trailing slash will be removed when joining.</p>
<h4 id="join/2-examples" class="section-heading"> <a href="#join/2-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Path.join("foo", "bar")
"foo/bar"

iex&gt; Path.join("/foo", "/bar/")
"/foo/bar"</pre>
<p>The functions in this module support chardata, so giving a list will treat it as a single entity:</p>
<pre data-language="elixir">iex&gt; Path.join("foo", ["bar", "fiz"])
"foo/barfiz"

iex&gt; Path.join(["foo", "bar"], "fiz")
"foobar/fiz"</pre>
<p>Use <a href="#join/1"><code class="inline">join/1</code></a> if you need to join a list of paths instead.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="relative/1">relative(name)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/path.ex#L246" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec relative(t()) :: binary()</pre> </div> <p>Forces the path to be a relative path.</p>
<h4 id="relative/1-examples" class="section-heading"> <a href="#relative/1-examples">  Examples </a> </h4> <h3 id="relative/1-unix-like-operating-systems" class="section-heading"> <a href="#relative/1-unix-like-operating-systems">  Unix-like operating systems </a> </h3> <pre data-language="elixir">Path.relative("/usr/local/bin")   #=&gt; "usr/local/bin"
Path.relative("usr/local/bin")    #=&gt; "usr/local/bin"
Path.relative("../usr/local/bin") #=&gt; "../usr/local/bin"</pre>
<h3 id="relative/1-windows" class="section-heading"> <a href="#relative/1-windows">  Windows </a> </h3> <pre data-language="elixir">Path.relative("D:/usr/local/bin") #=&gt; "usr/local/bin"
Path.relative("usr/local/bin")    #=&gt; "usr/local/bin"
Path.relative("D:bar.ex")         #=&gt; "bar.ex"
Path.relative("/bar/foo.ex")      #=&gt; "bar/foo.ex"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="relative_to/2">relative_to(path, from)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/path.ex#L326" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec relative_to(t(), t()) :: binary()</pre> </div> <p>Returns the direct relative path from <code class="inline">path</code> in relation to <code class="inline">from</code>.</p>
<p>In other words, this function tries to strip the <code class="inline">from</code> prefix from <code class="inline">path</code>.</p>
<p>This function does not query the file system, so it assumes no symlinks between the paths.</p>
<p>In case a direct relative path cannot be found, it returns the original path.</p>
<h4 id="relative_to/2-examples" class="section-heading"> <a href="#relative_to/2-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Path.relative_to("/usr/local/foo", "/usr/local")
"foo"

iex&gt; Path.relative_to("/usr/local/foo", "/")
"usr/local/foo"

iex&gt; Path.relative_to("/usr/local/foo", "/etc")
"/usr/local/foo"

iex&gt; Path.relative_to("/usr/local/foo", "/usr/local/foo")
"."</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="relative_to_cwd/1">relative_to_cwd(path)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/path.ex#L355" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec relative_to_cwd(t()) :: binary()</pre> </div> <p>Convenience to get the path relative to the current working directory.</p>
<p>If, for some reason, the current working directory cannot be retrieved, this function returns the given <code class="inline">path</code>.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="rootname/1">rootname(path)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/path.ex#L472" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec rootname(t()) :: binary()</pre> </div> <p>Returns the <code class="inline">path</code> with the <code class="inline">extension</code> stripped.</p>
<h4 id="rootname/1-examples" class="section-heading"> <a href="#rootname/1-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Path.rootname("/foo/bar")
"/foo/bar"

iex&gt; Path.rootname("/foo/bar.ex")
"/foo/bar"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="rootname/2">rootname(path, extension)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/path.ex#L492" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec rootname(t(), t()) :: binary()</pre> </div> <p>Returns the <code class="inline">path</code> with the <code class="inline">extension</code> stripped.</p>
<p>This function should be used to remove a specific extension which may or may not be there.</p>
<h4 id="rootname/2-examples" class="section-heading"> <a href="#rootname/2-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Path.rootname("/foo/bar.erl", ".erl")
"/foo/bar"

iex&gt; Path.rootname("/foo/bar.erl", ".ex")
"/foo/bar.erl"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="safe_relative/1">safe_relative(path)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/path.ex#L807" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec safe_relative(t()) :: {:ok, binary()} | :error</pre> </div> <p>Returns a path relative to the current working directory that is protected from directory-traversal attacks.</p>
<p>Same as <a href="#safe_relative_to/2"><code class="inline">safe_relative_to/2</code></a> with the current working directory as the second argument. If there is an issue retrieving the current working directory, this function raises an error.</p>
<h4 id="safe_relative/1-examples" class="section-heading"> <a href="#safe_relative/1-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Path.safe_relative("foo")
{:ok, "foo"}

iex&gt; Path.safe_relative("foo/../bar")
{:ok, "bar"}

iex&gt; Path.safe_relative("foo/../..")
:error

iex&gt; Path.safe_relative("/usr/local")
:error</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="safe_relative_to/2">safe_relative_to(path, relative_to)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/path.ex#L773" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec safe_relative_to(t(), t()) :: {:ok, binary()} | :error</pre> </div> <p>Returns a relative path that is protected from directory-traversal attacks.</p>
<p>The given relative path is sanitized by eliminating <code class="inline">..</code> and <code class="inline">.</code> components.</p>
<p>This function checks that, after expanding those components, the path is still "safe". Paths are considered unsafe if either of these is true:</p>
<ul>
<li><p>The path is not relative, such as <code class="inline">"/foo/bar"</code>.</p></li>
<li><p>A <code class="inline">..</code> component would make it so that the path would travers up above the root of <code class="inline">relative_to</code>.</p></li>
<li><p>A symbolic link in the path points to something above the root of <code class="inline">relative_to</code>.</p></li>
</ul>
<h4 id="safe_relative_to/2-examples" class="section-heading"> <a href="#safe_relative_to/2-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Path.safe_relative_to("deps/my_dep/app.beam", "deps")
{:ok, "deps/my_dep/app.beam"}

iex&gt; Path.safe_relative_to("deps/my_dep/./build/../app.beam", "deps")
{:ok, "deps/my_dep/app.beam"}

iex&gt; Path.safe_relative_to("my_dep/../..", "deps")
:error

iex&gt; Path.safe_relative_to("/usr/local", ".")
:error</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="split/1">split(path)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/path.ex#L594" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec split(t()) :: [binary()]</pre> </div> <p>Splits the path into a list at the path separator.</p>
<p>If an empty string is given, returns an empty list.</p>
<p>On Windows, path is split on both <code class="inline">"\"</code> and <code class="inline">"/"</code> separators and the driver letter, if there is one, is always returned in lowercase.</p>
<h4 id="split/1-examples" class="section-heading"> <a href="#split/1-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Path.split("")
[]

iex&gt; Path.split("foo")
["foo"]

iex&gt; Path.split("/foo/bar")
["/", "foo", "bar"]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="type/1">type(name)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/path.ex#L220" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec type(t()) :: :absolute | :relative | :volumerelative</pre> </div> <p>Returns the path type.</p>
<h4 id="type/1-examples" class="section-heading"> <a href="#type/1-examples">  Examples </a> </h4> <h3 id="type/1-unix-like-operating-systems" class="section-heading"> <a href="#type/1-unix-like-operating-systems">  Unix-like operating systems </a> </h3> <pre data-language="elixir">Path.type("/")                #=&gt; :absolute
Path.type("/usr/local/bin")   #=&gt; :absolute
Path.type("usr/local/bin")    #=&gt; :relative
Path.type("../usr/local/bin") #=&gt; :relative
Path.type("~/file")           #=&gt; :relative</pre>
<h3 id="type/1-windows" class="section-heading"> <a href="#type/1-windows">  Windows </a> </h3> <pre data-language="elixir">Path.type("D:/usr/local/bin") #=&gt; :absolute
Path.type("usr/local/bin")    #=&gt; :relative
Path.type("D:bar.ex")         #=&gt; :volumerelative
Path.type("/bar/foo.ex")      #=&gt; :volumerelative</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="wildcard/2">wildcard(glob, opts \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/path.ex#L677" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec wildcard(
  t(),
  keyword()
) :: [binary()]</pre> </div> <p>Traverses paths according to the given <code class="inline">glob</code> expression and returns a list of matches.</p>
<p>The wildcard looks like an ordinary path, except that the following "wildcard characters" are interpreted in a special way:</p>
<ul>
<li><p><code class="inline">?</code> - matches one character.</p></li>
<li><p><code class="inline">*</code> - matches any number of characters up to the end of the filename, the next dot, or the next slash.</p></li>
<li><p><code class="inline">**</code> - two adjacent <code class="inline">*</code>'s used as a single pattern will match all files and zero or more directories and subdirectories.</p></li>
<li><p><code class="inline">[char1,char2,...]</code> - matches any of the characters listed; two characters separated by a hyphen will match a range of characters. Do not add spaces before and after the comma as it would then match paths containing the space character itself.</p></li>
<li><p><code class="inline">{item1,item2,...}</code> - matches one of the alternatives. Do not add spaces before and after the comma as it would then match paths containing the space character itself.</p></li>
</ul>
<p>Other characters represent themselves. Only paths that have exactly the same character in the same position will match. Note that matching is case-sensitive: <code class="inline">"a"</code> will not match <code class="inline">"A"</code>.</p>
<p>Directory separators must always be written as <code class="inline">/</code>, even on Windows. You may call <a href="#expand/1"><code class="inline">Path.expand/1</code></a> to normalize the path before invoking this function.</p>
<p>A character preceded by loses its special meaning. Note that must be written as \ in a string literal. For example, "\?*" will match any filename starting with ?.</p>
<p>By default, the patterns <code class="inline">*</code> and <code class="inline">?</code> do not match files starting with a dot <code class="inline">.</code>. See the <code class="inline">:match_dot</code> option in the "Options" section below.</p>
<h4 id="wildcard/2-options" class="section-heading"> <a href="#wildcard/2-options">  Options </a> </h4> <ul><li>
<code class="inline">:match_dot</code> - (boolean) if <code class="inline">false</code>, the special wildcard characters <code class="inline">*</code> and <code class="inline">?</code> will not match files starting with a dot (<code class="inline">.</code>). If <code class="inline">true</code>, files starting with a <code class="inline">.</code> will not be treated specially. Defaults to <code class="inline">false</code>.</li></ul>
<h4 id="wildcard/2-examples" class="section-heading"> <a href="#wildcard/2-examples">  Examples </a> </h4> <p>Imagine you have a directory called <code class="inline">projects</code> with three Elixir projects inside of it: <code class="inline">elixir</code>, <code class="inline">ex_doc</code>, and <code class="inline">plug</code>. You can find all <code class="inline">.beam</code> files inside the <code class="inline">ebin</code> directory of each project as follows:</p>
<pre data-language="elixir">Path.wildcard("projects/*/ebin/**/*.beam")</pre>
<p>If you want to search for both <code class="inline">.beam</code> and <code class="inline">.app</code> files, you could do:</p>
<pre data-language="elixir">Path.wildcard("projects/*/ebin/**/*.{beam,app}")</pre> </section> </section> </div> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/elixir/1.15.4/Path.html" class="_attribution-link">https://hexdocs.pm/elixir/1.15.4/Path.html</a>
  </p>
</div>
