<h1>   <span translate="no">IEx</span>  </h1> <section id="moduledoc"> <p>Elixir's interactive shell.</p>
<p>Some of the functionalities described here will not be available depending on your terminal. In particular, if you get a message saying that the smart terminal could not be run, some of the features described here won't work.</p>
<h2 id="module-helpers" class="section-heading"> <a href="#module-helpers">  Helpers </a> </h2> <p>IEx provides a bunch of helpers. They can be accessed by typing <code class="inline">h()</code> into the shell or as a documentation for the <a href="iex.helpers.html"><code class="inline">IEx.Helpers</code></a> module.</p>
<h2 id="module-autocomplete" class="section-heading"> <a href="#module-autocomplete">  Autocomplete </a> </h2> <p>To discover a module's public functions or other modules, type the module name followed by a dot, then press tab to trigger autocomplete. For example:</p>
<pre data-language="elixir">Enum.</pre>
<p>A module may export functions that are not meant to be used directly: these functions won't be autocompleted by IEx. IEx will not autocomplete functions annotated with <code class="inline">@doc false</code>, <code class="inline">@impl true</code>, or functions that aren't explicitly documented and where the function name is in the form of <code class="inline">__foo__</code>.</p>
<p>Autocomplete is available by default on Windows shells from Erlang/OTP 26. In earlier versions, you may need to pass the <code class="inline">--werl</code> option when starting IEx, such as <code class="inline">iex --werl</code> (or <code class="inline">iex.bat --werl</code> if using PowerShell). <code class="inline">--werl</code> may be permanently enabled by setting the <code class="inline">IEX_WITH_WERL</code> environment variable to <code class="inline">1</code>.</p>
<h2 id="module-encoding-and-coloring" class="section-heading"> <a href="#module-encoding-and-coloring">  Encoding and coloring </a> </h2> <p>IEx expects inputs and outputs to be in UTF-8 encoding. This is the default for most Unix terminals but it may not be the case on Windows. If you are running on Windows and you see incorrect values printed, you may need change the encoding of your current session by running <code class="inline">chcp 65001</code> before calling <code class="inline">iex</code> (or before calling <code class="inline">iex.bat</code> if using PowerShell).</p>
<p>Similarly, ANSI coloring is enabled by default on most Unix terminals. They are also available on Windows consoles from Windows 10 and on Erlang/OTP 26 or later. For earlier Erlang/OTP versions, you can explicitly enable it for the current user in the registry by running the following command:</p>
<pre data-language="elixir">$ reg add HKCU\Console /v VirtualTerminalLevel /t REG_DWORD /d 1
</pre>
<p>After running the command above, you must restart your current console.</p>
<h2 id="module-shell-history" class="section-heading"> <a href="#module-shell-history">  Shell history </a> </h2> <p>It is possible to get shell history by passing some options that enable it in the VM. This can be done on a per-need basis when starting IEx:</p>
<pre data-language="elixir">$ iex --erl "-kernel shell_history enabled"
</pre>
<p>If you would rather enable it on your system as a whole, you can use the <code class="inline">ERL_AFLAGS</code> environment variable and make sure that it is set accordingly on your terminal/shell configuration.</p>
<p>On Unix-like / Bash:</p>
<pre data-language="elixir">$ export ERL_AFLAGS="-kernel shell_history enabled"
</pre>
<p>On Windows:</p>
<pre data-language="elixir">$ set ERL_AFLAGS "-kernel shell_history enabled"
</pre>
<p>On Windows 10 / PowerShell:</p>
<pre data-language="elixir">$ $env:ERL_AFLAGS = "-kernel shell_history enabled"
</pre>
<h2 id="module-expressions-in-iex" class="section-heading"> <a href="#module-expressions-in-iex">  Expressions in IEx </a> </h2> <p>As an interactive shell, IEx evaluates expressions. This has some interesting consequences that are worth discussing.</p>
<p>The first one is that the code is truly evaluated and not compiled. This means that any benchmarking done in the shell is going to have skewed results. So never run any profiling nor benchmarks in the shell.</p>
<p>Second, IEx allows you to break an expression into many lines, since this is common in Elixir. For example:</p>
<pre data-language="elixir">iex(1)&gt; "ab
...(1)&gt; c"
"ab\nc"</pre>
<p>In the example above, the shell will be expecting more input until it finds the closing quote. Sometimes it is not obvious which character the shell is expecting, and the user may find themselves trapped in the state of incomplete expression with no ability to terminate it other than by exiting the shell.</p>
<p>For such cases, there is a special break-trigger (<code class="inline">#iex:break</code>) that when encountered on a line by itself will force the shell to break out of any pending expression and return to its normal state:</p>
<pre data-language="elixir">iex(1)&gt; ["ab
...(1)&gt; c"
...(1)&gt; "
...(1)&gt; ]
...(1)&gt; #iex:break
** (TokenMissingError) iex:1: incomplete expression</pre>
<h2 id="module-pasting-multiline-expressions-into-iex" class="section-heading"> <a href="#module-pasting-multiline-expressions-into-iex">  Pasting multiline expressions into IEx </a> </h2> <p>IEx evaluates its input line by line in an eager fashion. If at the end of a line the code seen so far is a complete expression, IEx will evaluate it at that point.</p>
<pre data-language="elixir">iex(1)&gt; [1, [2], 3]
[1, [2], 3]</pre>
<p>To prevent this behaviour breaking valid code where the subsequent line begins with a binary operator, such as <a href="https://hexdocs.pm/elixir/1.15/Kernel.html#%7C%3E/2"><code class="inline">|&gt;/2</code></a> or <a href="https://hexdocs.pm/elixir/1.15/Kernel.html#++/2"><code class="inline">++/2</code></a> , IEx automatically treats such lines as if they were prepended with <a href="iex.helpers.html#v/0"><code class="inline">IEx.Helpers.v/0</code></a>, which returns the value of the previous expression, if available.</p>
<pre data-language="elixir">iex(1)&gt; [1, [2], 3]
[1, [2], 3]
iex(2)&gt; |&gt; List.flatten()
[1, 2, 3]</pre>
<p>The above is equivalent to:</p>
<pre data-language="elixir">iex(1)&gt; [1, [2], 3]
[1, [2], 3]
iex(2)&gt; v() |&gt; List.flatten()
[1, 2, 3]</pre>
<p>If there are no previous expressions in the history, the pipe operator will fail:</p>
<pre data-language="elixir">iex(1)&gt; |&gt; List.flatten()
** (RuntimeError) v(-1) is out of bounds</pre>
<p>If the previous expression was a match operation, the pipe operator will also fail, to prevent an unsolicited break of the match:</p>
<pre data-language="elixir">iex(1)&gt; x = 42
iex(2)&gt; |&gt; IO.puts()
** (SyntaxError) iex:2:1: pipe shorthand is not allowed immediately after a match expression in IEx. To make it work, surround the whole pipeline with parentheses ('|&gt;')
    |
  2 | |&gt; IO.puts()
    | ^</pre>
<p>Note, however, the above does not work for <a href="https://hexdocs.pm/elixir/1.15/Kernel.html#+/2"><code class="inline">+/2</code></a> and <a href="https://hexdocs.pm/elixir/1.15/Kernel.html#-/2"><code class="inline">-/2</code></a>, as they are ambiguous with the unary <a href="https://hexdocs.pm/elixir/1.15/Kernel.html#+/1"><code class="inline">+/1</code></a> and <a href="https://hexdocs.pm/elixir/1.15/Kernel.html#-/1"><code class="inline">-/1</code></a>:</p>
<pre data-language="elixir">iex(1)&gt; 1
1
iex(2)&gt; + 2
2</pre>
<h2 id="module-the-break-menu" class="section-heading"> <a href="#module-the-break-menu">  The BREAK menu </a> </h2> <p>Inside IEx, hitting <code class="inline">Ctrl+C</code> will open up the <code class="inline">BREAK</code> menu. In this menu you can quit the shell, see process and ETS tables information and much more.</p>
<h2 id="module-exiting-the-shell" class="section-heading"> <a href="#module-exiting-the-shell">  Exiting the shell </a> </h2> <p>There are a few ways to quit the IEx shell:</p>
<ul>
<li>via the <code class="inline">BREAK</code> menu (available via <code class="inline">Ctrl+C</code>) by typing <code class="inline">q</code>, pressing enter</li>
<li>by hitting <code class="inline">Ctrl+C</code>, <code class="inline">Ctrl+C</code>
</li>
<li>by hitting <code class="inline">Ctrl+\</code>
</li>
</ul>
<p>If you are connected to remote shell, it remains alive after disconnection.</p>
<h2 id="module-dbg-and-breakpoints" class="section-heading"> <a href="#module-dbg-and-breakpoints">  <code class="inline">dbg</code> and breakpoints </a> </h2> <p>IEx integrates with <a href="https://hexdocs.pm/elixir/1.15/Kernel.html#dbg/2"><code class="inline">Kernel.dbg/2</code></a> and introduces a backend that can pause code execution. To enable it, you must pass <code class="inline">--dbg pry</code>:</p>
<pre data-language="elixir">$ iex --dbg pry
</pre>
<p>For example, take the following function:</p>
<pre data-language="elixir">def my_fun(arg1, arg2) do
  dbg(arg1 + arg2)
  ... implementation ...
end</pre>
<p>When the code is executed with <code class="inline">iex</code> (most often by calling <code class="inline">iex --dbg pry -S mix</code>), it will ask you permission to use "pry". If you agree, it will start an IEx shell in the context of the function above, with access to its variables, imports, and aliases. However, you can only access existing values, it is not possible to access private functions nor change the execution itself (hence the name "pry").</p>
<p>When using <code class="inline">|&gt; dbg()</code> at the end of a pipeline, you can pry each step of the pipeline. You can type <code class="inline">n</code> whenever you want to jump into the next pipe. Type <code class="inline">continue</code> when you want to execute all of the steps but stay within the pried process. Type <code class="inline">respawn</code> when you want to leave the pried process and start a new shell.</p>
<p>Alternatively, you can start a pry session directly, without <a href="https://hexdocs.pm/elixir/1.15/Kernel.html#dbg/2"><code class="inline">dbg/2</code></a> by calling <a href="#pry/0"><code class="inline">IEx.pry/0</code></a>.</p>
<p>IEx also allows you to set breakpoints to start pry sessions on a given module, function, and arity you have no control of via <a href="#break!/4"><code class="inline">IEx.break!/4</code></a>. Similar to pipelines in <code class="inline">dbg()</code>, <a href="#break!/4"><code class="inline">IEx.break!/4</code></a> allows you to debug a function line by line and access its variables. However, breakpoints do not contain information about imports and aliases from the source code.</p>
<p>When using <code class="inline">dbg</code> or breakpoints with tests, remember to pass the <code class="inline">--trace</code> to <a href="https://hexdocs.pm/mix/1.15/Mix.Tasks.Test.html"><code class="inline">mix test</code></a> to avoid running into timeouts:</p>
<pre data-language="elixir">$ iex -S mix test --trace
$ iex -S mix test path/to/file:line --trace
</pre>
<h2 id="module-the-user-switch-command" class="section-heading"> <a href="#module-the-user-switch-command">  The User switch command </a> </h2> <p>Besides the <code class="inline">BREAK</code> menu, one can type <code class="inline">Ctrl+G</code> to get to the <code class="inline">User switch command</code> menu. When reached, you can type <code class="inline">h</code> to get more information.</p>
<p>In this menu, developers are able to start new shells and alternate between them. Let's give it a try:</p>
<pre data-language="elixir">User switch command
 --&gt; s 'Elixir.IEx'
 --&gt; c</pre>
<p>The command above will start a new shell and connect to it. Create a new variable called <code class="inline">hello</code> and assign some value to it:</p>
<pre data-language="elixir">hello = :world</pre>
<p>Now, let's roll back to the first shell:</p>
<pre data-language="elixir">User switch command
 --&gt; c 1</pre>
<p>Now, try to access the <code class="inline">hello</code> variable again:</p>
<pre data-language="elixir">hello
** (UndefinedFunctionError) undefined function hello/0</pre>
<p>The command above fails because we have switched shells. Since shells are isolated from each other, you can't access the variables defined in one shell from the other one.</p>
<p>The <code class="inline">User switch command</code> can also be used to terminate an existing session, for example when the evaluator gets stuck in an infinite loop or when you are stuck typing an expression:</p>
<pre data-language="elixir">User switch command
 --&gt; i
 --&gt; c</pre>
<p>The <code class="inline">User switch command</code> menu also allows developers to connect to remote shells using the <code class="inline">r</code> command. A topic which we will discuss next.</p>
<h2 id="module-remote-shells" class="section-heading"> <a href="#module-remote-shells">  Remote shells </a> </h2> <p>IEx allows you to connect to another node in two fashions. First of all, we can only connect to a shell if we give names both to the current shell and the shell we want to connect to.</p>
<p>Let's give it a try. First, start a new shell:</p>
<pre data-language="elixir">$ iex --sname foo
iex(foo@HOST)1&gt;
</pre>
<p>The string between the parentheses in the prompt is the name of your node. We can retrieve it by calling the <a href="https://hexdocs.pm/elixir/1.15/Kernel.html#node/0"><code class="inline">node/0</code></a> function:</p>
<pre data-language="elixir">iex(foo@HOST)1&gt; node()
:"foo@HOST"
iex(foo@HOST)2&gt; Node.alive?()
true</pre>
<p>For fun, let's define a simple module in this shell too:</p>
<pre data-language="elixir">iex(foo@HOST)3&gt; defmodule Hello do
...(foo@HOST)3&gt;   def world, do: "it works!"
...(foo@HOST)3&gt; end</pre>
<p>Now, let's start another shell, giving it a name as well:</p>
<pre data-language="elixir">$ iex --sname bar
iex(bar@HOST)1&gt;
</pre>
<p>If we try to dispatch to <code class="inline">Hello.world/0</code>, it won't be available as it was defined only in the other shell:</p>
<pre data-language="elixir">iex(bar@HOST)1&gt; Hello.world()
** (UndefinedFunctionError) undefined function Hello.world/0</pre>
<p>However, we can connect to the other shell remotely. Open up the <code class="inline">User switch command</code> prompt (Ctrl+G) and type:</p>
<pre data-language="elixir">User switch command
 --&gt; r 'foo@HOST' 'Elixir.IEx'
 --&gt; c</pre>
<p>Now we are connected into the remote node, as the prompt shows us, and we can access the information and modules defined over there:</p>
<pre data-language="elixir">iex(foo@HOST)1&gt; Hello.world()
"it works!"</pre>
<p>In fact, connecting to remote shells is so common that we provide a shortcut via the command line as well:</p>
<pre data-language="elixir">$ iex --sname baz --remsh foo@HOST
</pre>
<p>Where "remsh" means "remote shell". In general, Elixir supports:</p>
<ul>
<li>remsh from an Elixir node to an Elixir node</li>
<li>remsh from a plain Erlang node to an Elixir node (through the ^G menu)</li>
<li>remsh from an Elixir node to a plain Erlang node (and get an <code class="inline">erl</code> shell there)</li>
</ul>
<p>Connecting an Elixir shell to a remote node without Elixir is <strong>not</strong> supported.</p>
<h2 id="module-the-iex-exs-file" class="section-heading"> <a href="#module-the-iex-exs-file">  The .iex.exs file </a> </h2> <p>When starting, IEx looks for a local <code class="inline">.iex.exs</code> file (located in the current working directory), then for a global <code class="inline">.iex.exs</code> file located inside the directory pointed by the <code class="inline">IEX_HOME</code> environment variable (which defaults to <code class="inline">~</code>) and loads the first one it finds (if any).</p>
<p>The code in the chosen <code class="inline">.iex.exs</code> file is evaluated line by line in the shell's context, as if each line were being typed in the shell. For instance, any modules that are loaded or variables that are bound in the <code class="inline">.iex.exs</code> file will be available in the shell after it has booted.</p>
<p>Take the following <code class="inline">.iex.exs</code> file:</p>
<pre data-language="elixir"># Load another ".iex.exs" file
import_file("~/.iex.exs")

# Import some module from lib that may not yet have been defined
import_if_available(MyApp.Mod)

# Print something before the shell starts
IO.puts("hello world")

# Bind a variable that'll be accessible in the shell
value = 13</pre>
<p>Running IEx in the directory where the above <code class="inline">.iex.exs</code> file is located results in:</p>
<pre data-language="elixir">$ iex
Erlang/OTP 24 [...]

hello world
Interactive Elixir - press Ctrl+C to exit (type h() ENTER for help)
iex(1)&gt; value
13
</pre>
<p>It is possible to load another file by supplying the <code class="inline">--dot-iex</code> option to IEx. See <code class="inline">iex --help</code>.</p>
<p>In case of remote nodes, the location of the <code class="inline">.iex.exs</code> files are taken relative to the user that started the application, not to the user that is connecting to the node in case of remote IEx connections.</p>
<h2 id="module-configuring-the-shell" class="section-heading"> <a href="#module-configuring-the-shell">  Configuring the shell </a> </h2> <p>There are a number of customization options provided by IEx. Take a look at the docs for the <a href="#configure/1"><code class="inline">IEx.configure/1</code></a> function by typing <code class="inline">h IEx.configure/1</code>.</p>
<p>Those options can be configured in your project configuration file or globally by calling <a href="#configure/1"><code class="inline">IEx.configure/1</code></a> from your <code class="inline">~/.iex.exs</code> file. For example:</p>
<pre data-language="elixir"># .iex.exs
IEx.configure(inspect: [limit: 3])</pre>
<p>Now run the shell:</p>
<pre data-language="elixir">$ iex
Erlang/OTP 24 [...]

Interactive Elixir - press Ctrl+C to exit (type h() ENTER for help)
iex(1)&gt; [1, 2, 3, 4, 5]
[1, 2, 3, ...]
</pre> </section> <section id="summary" class="details-list">  <h2> Functions </h2>
<dl class="summary-functions summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#break!/2" translate="no">break!(ast, stops \\ 1)</a> </dt> <dd class="summary-synopsis"><p>Macro-based shortcut for <a href="#break!/4"><code class="inline">IEx.break!/4</code></a>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#break!/4" translate="no">break!(module, function, arity, stops \\ 1)</a> </dt> <dd class="summary-synopsis"><p>Sets up a breakpoint in <code class="inline">module</code>, <code class="inline">function</code> and <code class="inline">arity</code> with the given number of <code class="inline">stops</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#color/2" translate="no">color(color, string)</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">string</code> escaped using the specified <code class="inline">color</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#configuration/0" translate="no">configuration()</a> </dt> <dd class="summary-synopsis"><p>Returns IEx configuration.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#configure/1" translate="no">configure(options)</a> </dt> <dd class="summary-synopsis"><p>Configures IEx.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#inspect_opts/0" translate="no">inspect_opts()</a> </dt> <dd class="summary-synopsis"><p>Returns the options used for inspecting.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#pry/0" translate="no">pry()</a> </dt> <dd class="summary-synopsis"><p>Pries into the process environment.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#started?/0" translate="no">started?()</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if IEx was started, <code class="inline">false</code> otherwise.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#width/0" translate="no">width()</a> </dt> <dd class="summary-synopsis"><p>Returns the IEx width for printing.</p></dd> </div> </dl> </section> <section id="functions" class="details-list">  <div class="functions-list"> <section class="detail">  <h3 class="detail-header" id="break!/2">break!(ast, stops \\ 1)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/iex/lib/iex.ex#L685" class="source">Source</a>
</h3> <section class="docstring"> <p>Macro-based shortcut for <a href="#break!/4"><code class="inline">IEx.break!/4</code></a>.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="break!/4">break!(module, function, arity, stops \\ 1)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/iex/lib/iex.ex#L854" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec break!(module(), atom(), arity(), non_neg_integer()) :: IEx.Pry.id()</pre> </div> <p>Sets up a breakpoint in <code class="inline">module</code>, <code class="inline">function</code> and <code class="inline">arity</code> with the given number of <code class="inline">stops</code>.</p>
<p>This function will instrument the given module and load a new version in memory with line by line breakpoints at the given function and arity. If the module is recompiled, all breakpoints are lost.</p>
<p>When a breakpoint is reached, IEx will ask if you want to <code class="inline">pry</code> the given function and arity. In other words, this works similar to <a href="#pry/0"><code class="inline">IEx.pry/0</code></a> as the running process becomes the evaluator of IEx commands and is temporarily changed to have a custom group leader. However, differently from <a href="#pry/0"><code class="inline">IEx.pry/0</code></a>, aliases and imports from the source code won't be available in the shell.</p>
<p>IEx helpers includes many conveniences related to breakpoints. Below they are listed with the full module, such as <a href="iex.helpers.html#breaks/0"><code class="inline">IEx.Helpers.breaks/0</code></a>, but remember it can be called directly as <code class="inline">breaks()</code> inside IEx. They are:</p>
<ul>
<li>
<a href="iex.helpers.html#break!/2"><code class="inline">IEx.Helpers.break!/2</code></a> - sets up a breakpoint for a given <code class="inline">Mod.fun/arity</code>
</li>
<li>
<a href="iex.helpers.html#break!/4"><code class="inline">IEx.Helpers.break!/4</code></a> - sets up a breakpoint for the given module, function, arity</li>
<li>
<a href="iex.helpers.html#breaks/0"><code class="inline">IEx.Helpers.breaks/0</code></a> - prints all breakpoints and their IDs</li>
<li>
<a href="iex.helpers.html#continue/0"><code class="inline">IEx.Helpers.continue/0</code></a> - continues until the next breakpoint in the same shell</li>
<li>
<a href="iex.helpers.html#n/0"><code class="inline">IEx.Helpers.n/0</code></a> - goes to the next line of the current breakpoint</li>
<li>
<a href="iex.helpers.html#next/0"><code class="inline">IEx.Helpers.next/0</code></a> - same as above</li>
<li>
<a href="iex.helpers.html#open/0"><code class="inline">IEx.Helpers.open/0</code></a> - opens editor on the current breakpoint</li>
<li>
<a href="iex.helpers.html#remove_breaks/0"><code class="inline">IEx.Helpers.remove_breaks/0</code></a> - removes all breakpoints in all modules</li>
<li>
<a href="iex.helpers.html#remove_breaks/1"><code class="inline">IEx.Helpers.remove_breaks/1</code></a> - removes all breakpoints in a given module</li>
<li>
<a href="iex.helpers.html#reset_break/1"><code class="inline">IEx.Helpers.reset_break/1</code></a> - sets the number of stops on the given ID to zero</li>
<li>
<a href="iex.helpers.html#reset_break/3"><code class="inline">IEx.Helpers.reset_break/3</code></a> - sets the number of stops on the given module, function, arity to zero</li>
<li>
<a href="iex.helpers.html#respawn/0"><code class="inline">IEx.Helpers.respawn/0</code></a> - starts a new shell (breakpoints will ask for permission once more)</li>
<li>
<a href="iex.helpers.html#whereami/1"><code class="inline">IEx.Helpers.whereami/1</code></a> - shows the current location</li>
</ul>
<p>By default, the number of stops in a breakpoint is 1. Any follow-up call won't stop the code execution unless another breakpoint is set.</p>
<p>Alternatively, the number of stops can be increased by passing the <code class="inline">stops</code> argument. <a href="iex.helpers.html#reset_break/1"><code class="inline">IEx.Helpers.reset_break/1</code></a> and <a href="iex.helpers.html#reset_break/3"><code class="inline">IEx.Helpers.reset_break/3</code></a> can be used to reset the number back to zero. Note the module remains "instrumented" even after all stops on all breakpoints are consumed. You can remove the instrumentation in a given module by calling <a href="iex.helpers.html#remove_breaks/1"><code class="inline">IEx.Helpers.remove_breaks/1</code></a> and on all modules by calling <a href="iex.helpers.html#remove_breaks/0"><code class="inline">IEx.Helpers.remove_breaks/0</code></a>.</p>
<p>Within a breakpoint, you can call <code class="inline">n</code> to jump to the next line. To exit a breakpoint, you can either invoke <code class="inline">continue</code>, which will block the shell until the next breakpoint is found or the process terminates, or invoke <code class="inline">respawn</code>, which starts a new IEx shell, freeing up the pried one.</p>
<h4 id="break!/4-examples" class="section-heading"> <a href="#break!/4-examples">  Examples </a> </h4> <p>The examples below will use <code class="inline">break!</code>, assuming that you are setting a breakpoint directly from your IEx shell. But you can set up a break from anywhere by using the fully qualified name <code class="inline">IEx.break!</code>.</p>
<p>The following sets up a breakpoint on <a href="https://hexdocs.pm/elixir/1.15/URI.html#parse/1"><code class="inline">URI.parse/1</code></a>:</p>
<pre data-language="elixir">break! URI, :parse, 1</pre>
<p>This call will setup a breakpoint that stops once. To set a breakpoint that will stop 10 times:</p>
<pre data-language="elixir">break! URI, :parse, 1, 10</pre>
<p><a href="#break!/2"><code class="inline">IEx.break!/2</code></a> is a convenience macro that allows breakpoints to be given in the <code class="inline">Mod.fun/arity</code> format:</p>
<pre data-language="elixir">break! URI.parse/1</pre>
<p>Or to set a breakpoint that will stop 10 times:</p>
<pre data-language="elixir">break! URI.parse/1, 10</pre>
<p>This function returns the breakpoint ID and will raise if there is an error setting up the breakpoint.</p>
<h4 id="break!/4-patterns-and-guards" class="section-heading"> <a href="#break!/4-patterns-and-guards">  Patterns and guards </a> </h4> <p><a href="#break!/2"><code class="inline">IEx.break!/2</code></a> allows patterns to be given, triggering the breakpoint only in some occasions. For example, to trigger the breakpoint only when the first argument starts with the "https" string:</p>
<pre data-language="elixir">break! URI.parse("https" &lt;&gt; _, _)</pre>
<p>Only a single break point can be set per function. So if you call <code class="inline">IEx.break!</code> multiple times with different patterns, only the last pattern is kept.</p>
<h4 id="break!/4-macros" class="section-heading"> <a href="#break!/4-macros">  Macros </a> </h4> <p>While it is possible to set breakpoint in macros, remember that macros are generally expanded at compilation time, and therefore they may never be invoked during runtime. Similarly, while patterns may be given to macros, macros receive ASTs as arguments, and not values. For example, if you try to break on a macro with the following pattern:</p>
<pre data-language="elixir">break! MyModule.some_macro(pid) when pid == self()</pre>
<p>This breakpoint will never be reached, because a macro never receives a PID. Even if you call the macro as <code class="inline">MyModule.some_macro(self())</code>, the macro will receive the AST representing the <code class="inline">self()</code> call, and not the PID itself.</p>
<h4 id="break!/4-breaks-and-mix-test" class="section-heading"> <a href="#break!/4-breaks-and-mix-test">  Breaks and </a><a href="https://hexdocs.pm/mix/1.15/Mix.Tasks.Test.html"><code class="inline">mix test</code></a> </h4> <p>To use <a href="#break!/4"><code class="inline">IEx.break!/4</code></a> during tests, you need to run <code class="inline">mix</code> inside the <code class="inline">iex</code> command and pass the <code class="inline">--trace</code> to <a href="https://hexdocs.pm/mix/1.15/Mix.Tasks.Test.html"><code class="inline">mix test</code></a> to avoid running into timeouts:</p>
<pre data-language="elixir">$ iex -S mix test --trace
$ iex -S mix test path/to/file:line --trace
</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="color/2">color(color, string)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/iex/lib/iex.ex#L554" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec color(atom(), iodata()) :: iodata()</pre> </div> <p>Returns <code class="inline">string</code> escaped using the specified <code class="inline">color</code>.</p>
<p>ANSI escapes in <code class="inline">string</code> are not processed in any way.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="configuration/0">configuration()<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/iex/lib/iex.ex#L521" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec configuration() :: keyword()</pre> </div> <p>Returns IEx configuration.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="configure/1">configure(options)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/iex/lib/iex.ex#L513" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec configure(keyword()) :: :ok</pre> </div> <p>Configures IEx.</p>
<p>The supported options are:</p>
<ul>
<li><code class="inline">:colors</code></li>
<li><code class="inline">:inspect</code></li>
<li><code class="inline">:width</code></li>
<li><code class="inline">:history_size</code></li>
<li><code class="inline">:default_prompt</code></li>
<li><code class="inline">:continuation_prompt</code></li>
<li><code class="inline">:alive_prompt</code></li>
<li><code class="inline">:alive_continuation_prompt</code></li>
<li><code class="inline">:parser</code></li>
</ul>
<p>They are discussed individually in the sections below.</p>
<h4 id="configure/1-colors" class="section-heading"> <a href="#configure/1-colors">  Colors </a> </h4> <p>A keyword list that encapsulates all color settings used by the shell. See documentation for the <a href="https://hexdocs.pm/elixir/1.15/IO.ANSI.html"><code class="inline">IO.ANSI</code></a> module for the list of supported colors and attributes.</p>
<p>List of supported keys in the keyword list:</p>
<ul>
<li>
<code class="inline">:enabled</code> - boolean value that allows for switching the coloring on and off</li>
<li>
<code class="inline">:eval_result</code> - color for an expression's resulting value</li>
<li>
<code class="inline">:eval_info</code> - ... various informational messages</li>
<li>
<code class="inline">:eval_error</code> - ... error messages</li>
<li>
<code class="inline">:eval_interrupt</code> - ... interrupt messages</li>
<li>
<code class="inline">:stack_info</code> - ... the stacktrace color</li>
<li>
<code class="inline">:blame_diff</code> - ... when blaming source with no match</li>
<li>
<code class="inline">:ls_directory</code> - ... for directory entries (ls helper)</li>
<li>
<code class="inline">:ls_device</code> - ... device entries (ls helper)</li>
</ul>
<p>When printing documentation, IEx will convert the Markdown documentation to ANSI as well. Colors for this can be configured via:</p>
<ul>
<li>
<code class="inline">:doc_code</code> - the attributes for code blocks (cyan, bright)</li>
<li>
<code class="inline">:doc_inline_code</code> - inline code (cyan)</li>
<li>
<code class="inline">:doc_headings</code> - h1 and h2 (yellow, bright)</li>
<li>
<code class="inline">:doc_title</code> - the overall heading for the output (reverse, yellow, bright)</li>
<li>
<code class="inline">:doc_bold</code> - (bright)</li>
<li>
<code class="inline">:doc_underline</code> - (underline)</li>
</ul>
<p>IEx will also color inspected expressions using the <code class="inline">:syntax_colors</code> option. Such can be disabled with:</p>
<pre data-language="elixir">IEx.configure(colors: [syntax_colors: false])</pre>
<p>You can also configure the syntax colors, however, as desired. The below will format atoms in red and remove the coloring for all other data types:</p>
<pre data-language="elixir">IEx.configure(colors: [syntax_colors: [atom: :red]])</pre>
<p>The default values can be found in <a href="https://hexdocs.pm/elixir/1.15/IO.ANSI.html#syntax_colors/0"><code class="inline">IO.ANSI.syntax_colors/0</code></a>.</p>
<h4 id="configure/1-inspect" class="section-heading"> <a href="#configure/1-inspect">  Inspect </a> </h4> <p>A keyword list containing inspect options used by the shell when printing results of expression evaluation. Defaults to pretty formatting with a limit of 50 entries.</p>
<p>To show all entries, configure the limit to <code class="inline">:infinity</code>:</p>
<pre data-language="elixir">IEx.configure(inspect: [limit: :infinity])</pre>
<p>See <a href="https://hexdocs.pm/elixir/1.15/Inspect.Opts.html"><code class="inline">Inspect.Opts</code></a> for the full list of options.</p>
<h4 id="configure/1-width" class="section-heading"> <a href="#configure/1-width">  Width </a> </h4> <p>An integer indicating the maximum number of columns to use in output. The default value is 80 columns. The actual output width is the minimum of this number and result of <code class="inline">:io.columns</code>. This way you can configure IEx to be your largest screen size and it should always take up the full width of your current terminal screen.</p>
<h4 id="configure/1-history-size" class="section-heading"> <a href="#configure/1-history-size">  History size </a> </h4> <p>Number of expressions and their results to keep in the history. The value is an integer. When it is negative, the history is unlimited.</p>
<h4 id="configure/1-prompt" class="section-heading"> <a href="#configure/1-prompt">  Prompt </a> </h4> <p>This is an option determining the prompt displayed to the user when awaiting input.</p>
<p>The value is a keyword list with two possible keys representing prompt types:</p>
<ul>
<li><p><code class="inline">:default_prompt</code> - used when <a href="https://hexdocs.pm/elixir/1.15/Node.html#alive?/0"><code class="inline">Node.alive?/0</code></a> returns <code class="inline">false</code></p></li>
<li><p><code class="inline">:continuation_prompt</code> - used when <a href="https://hexdocs.pm/elixir/1.15/Node.html#alive?/0"><code class="inline">Node.alive?/0</code></a> returns <code class="inline">false</code> and more input is expected</p></li>
<li><p><code class="inline">:alive_prompt</code> - used when <a href="https://hexdocs.pm/elixir/1.15/Node.html#alive?/0"><code class="inline">Node.alive?/0</code></a> returns <code class="inline">true</code></p></li>
<li><p><code class="inline">:alive_continuation_prompt</code> - used when <a href="https://hexdocs.pm/elixir/1.15/Node.html#alive?/0"><code class="inline">Node.alive?/0</code></a> returns <code class="inline">true</code> and more input is expected</p></li>
</ul>
<p>The following values in the prompt string will be replaced appropriately:</p>
<ul>
<li>
<code class="inline">%counter</code> - the index of the history</li>
<li>
<code class="inline">%prefix</code> - a prefix given by <a href="iex.server.html"><code class="inline">IEx.Server</code></a>
</li>
<li>
<code class="inline">%node</code> - the name of the local node</li>
</ul>
<h4 id="configure/1-parser" class="section-heading"> <a href="#configure/1-parser">  Parser </a> </h4> <p>This is an option determining the parser to use for IEx.</p>
<p>The parser is a "mfargs", which is a tuple with three elements: the module name, the function name, and extra arguments to be appended. The parser receives at least three arguments, the current input as a string, the parsing options as a keyword list, and the buffer as a string. It must return <code class="inline">{:ok, expr, buffer}</code> or <code class="inline">{:incomplete, buffer}</code>.</p>
<p>If the parser raises, the buffer is reset to an empty string.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="inspect_opts/0">inspect_opts()<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/iex/lib/iex.ex#L578" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec inspect_opts() :: keyword()</pre> </div> <p>Returns the options used for inspecting.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="pry/0">pry()<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/iex/lib/iex.ex#L675" class="source">Source</a>
</h3> <section class="docstring"> <p>Pries into the process environment.</p>
<p>This function is useful for debugging a particular chunk of code when executed by a particular process. The process becomes the evaluator of IEx commands and is temporarily changed to have a custom group leader. Those values are reverted by calling <a href="iex.helpers.html#respawn/0"><code class="inline">IEx.Helpers.respawn/0</code></a>, which starts a new IEx shell, freeing up the pried one.</p>
<p>When a process is pried, all code runs inside IEx and has access to all imports and aliases from the original code. However, you cannot change the execution of the code nor access private functions of the module being pried. Module functions still need to be accessed via <code class="inline">Mod.fun(args)</code>.</p>
<p>See also <a href="#break!/4"><code class="inline">break!/4</code></a> for others ways to pry.</p>
<blockquote>
<h4>
<a href="https://hexdocs.pm/elixir/1.15/Kernel.html#dbg/0"><code class="inline">dbg/0</code></a> integration</h4>
<p>By calling <code class="inline">iex --dbg pry</code>, <code class="inline">iex</code> will set this function as the default backend for <a href="https://hexdocs.pm/elixir/1.15/Kernel.html#dbg/0"><code class="inline">dbg/0</code></a> calls.</p>
</blockquote>
<h4 id="pry/0-examples" class="section-heading"> <a href="#pry/0-examples">  Examples </a> </h4> <p>Let's suppose you want to investigate what is happening with some particular function. By invoking <a href="#pry/0"><code class="inline">IEx.pry/0</code></a> from the function, IEx will allow you to access its binding (variables), verify its lexical information and access the process information. Let's see an example:</p>
<pre data-language="elixir">import Enum, only: [map: 2]

defmodule Adder do
  def add(a, b) do
    c = a + b
    require IEx; IEx.pry()
  end
end</pre>
<p>When invoking <code class="inline">Adder.add(1, 2)</code>, you will receive a message in your shell to pry the given environment. By allowing it, the shell will be reset and you gain access to all variables and the lexical scope from above:</p>
<pre data-language="elixir">iex(1)&gt; map([a, b, c], &amp;IO.inspect(&amp;1))
1
2
3</pre>
<p>Keep in mind that <a href="#pry/0"><code class="inline">IEx.pry/0</code></a> runs in the caller process, blocking the caller during the evaluation cycle. The caller process can be freed by calling <a href="iex.helpers.html#respawn/0"><code class="inline">respawn/0</code></a>, which starts a new IEx evaluation cycle, letting this one go:</p>
<pre data-language="elixir">iex(2)&gt; respawn()
true

Interactive Elixir - press Ctrl+C to exit (type h() ENTER for help)</pre>
<p>Setting variables or importing modules in IEx does not affect the caller's environment. However, sending and receiving messages will change the process state.</p>
<h4 id="pry/0-pry-and-macros" class="section-heading"> <a href="#pry/0-pry-and-macros">  Pry and macros </a> </h4> <p>When setting up Pry inside a code defined by macros, such as:</p>
<pre data-language="elixir">defmacro __using__(_) do
  quote do
    def add(a, b) do
      c = a + b
      require IEx; IEx.pry()
    end
  end
end</pre>
<p>The variables defined inside <code class="inline">quote</code> won't be available during prying due to the hygiene mechanism in quoted expressions. The hygiene mechanism changes the variable names in quoted expressions so they don't collide with variables defined by the users of the macros. Therefore the original names are not available.</p>
<h4 id="pry/0-pry-and-mix-test" class="section-heading"> <a href="#pry/0-pry-and-mix-test">  Pry and </a><a href="https://hexdocs.pm/mix/1.15/Mix.Tasks.Test.html"><code class="inline">mix test</code></a> </h4> <p>To use <a href="#pry/0"><code class="inline">IEx.pry/0</code></a> during tests, you need to run <code class="inline">mix</code> inside the <code class="inline">iex</code> command and pass the <code class="inline">--trace</code> to <a href="https://hexdocs.pm/mix/1.15/Mix.Tasks.Test.html"><code class="inline">mix test</code></a> to avoid running into timeouts:</p>
<pre data-language="elixir">$ iex -S mix test --trace
$ iex -S mix test path/to/file:line --trace
</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="started?/0">started?()<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/iex/lib/iex.ex#L544" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec started?() :: boolean()</pre> </div> <p>Returns <code class="inline">true</code> if IEx was started, <code class="inline">false</code> otherwise.</p>
<p>This means the IEx application was started, but not that its CLI interface is running.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="width/0">width()<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/iex/lib/iex.ex#L570" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec width() :: pos_integer()</pre> </div> <p>Returns the IEx width for printing.</p>
<p>Used by helpers and it has a default maximum cap of 80 chars.</p> </section> </section> </div> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/iex/1.15.4/IEx.html" class="_attribution-link">https://hexdocs.pm/iex/1.15.4/IEx.html</a>
  </p>
</div>
