<h1>   <span translate="no">Macro</span>  </h1> <section id="moduledoc"> <p>Functions for manipulating AST and implementing macros.</p>
<p>Macros are compile-time constructs that receive Elixir's AST as input and return Elixir's AST as output.</p>
<p>Many of the functions in this module exist precisely to work with Elixir AST, to traverse, query, and transform it.</p>
<p>Let's see a simple example that shows the difference between functions and macros:</p>
<pre data-language="elixir">defmodule Example do
  defmacro macro_inspect(value) do
    IO.inspect(value)
    value
  end

  def fun_inspect(value) do
    IO.inspect(value)
    value
  end
end</pre>
<p>Now let's give it a try:</p>
<pre data-language="elixir">import Example

macro_inspect(1)
#=&gt; 1
#=&gt; 1

fun_inspect(1)
#=&gt; 1
#=&gt; 1</pre>
<p>So far they behave the same, as we are passing an integer as argument. But let's see what happens when we pass an expression:</p>
<pre data-language="elixir">macro_inspect(1 + 2)
#=&gt; {:+, [line: 3], [1, 2]}
#=&gt; 3

fun_inspect(1 + 2)
#=&gt; 3
#=&gt; 3</pre>
<p>The macro receives the representation of the code given as argument, while a function receives the result of the code given as argument. A macro must return a superset of the code representation. See <a href="#t:input/0"><code class="inline">input/0</code></a> and <a href="#t:output/0"><code class="inline">output/0</code></a> for more information.</p>
<p>To learn more about Elixir's AST and how to build them programmatically, see <a href="kernel.specialforms.html#quote/2"><code class="inline">quote/2</code></a>.</p>
<blockquote>
<h4 class="tip">Evaluating code</h4>
<p>The functions in this module do not evaluate code. In fact, evaluating code from macros is often an anti-pattern. For code evaluation, see the <a href="code.html"><code class="inline">Code</code></a> module.</p>
</blockquote>
<h2 id="module-custom-sigils" class="section-heading"> <a href="#module-custom-sigils">  Custom Sigils </a> </h2> <p>Macros are also commonly used to implement custom sigils.</p>
<p>Sigils start with <code class="inline">~</code> and are followed by one lowercase letter or by one or more uppercase letters, and then a separator (see the <a href="syntax-reference.html">Syntax Reference</a>). One example is <code class="inline">~D[2020-10-13]</code> to define a date.</p>
<p>To create a custom sigil, define a macro with the name <code class="inline">sigil_{identifier}</code> that takes two arguments. The first argument will be the string, the second will be a charlist containing any modifiers. If the sigil is lower case (such as <code class="inline">sigil_x</code>) then the string argument will allow interpolation. If the sigil is one or more upper case letters (such as <code class="inline">sigil_X</code> and <code class="inline">sigil_EXAMPLE</code>) then the string will not be interpolated.</p>
<p>Valid modifiers are ASCII letters and digits. Any other character will cause a syntax error.</p>
<p>Single-letter sigils are typically reserved to the language. Multi-letter sigils are uppercased and extensively used by the community to embed alternative markups and data-types within Elixir source code.</p>
<p>The module containing the custom sigil must be imported before the sigil syntax can be used.</p>
<h3 id="module-examples" class="section-heading"> <a href="#module-examples">  Examples </a> </h3> <p>As an example, let's define a sigil <code class="inline">~x</code> and sigil <code class="inline">~X</code> which return its contents as a string. However, if the <code class="inline">r</code> modifier is given, it reverses the string instead:</p>
<pre data-language="elixir">defmodule MySigils do
  defmacro sigil_x(term, [?r]) do
    quote do
      unquote(term) |&gt; String.reverse()
    end
  end

  defmacro sigil_x(term, _modifiers) do
    term
  end

  defmacro sigil_X(term, [?r]) do
    quote do
      unquote(term) |&gt; String.reverse()
    end
  end

  defmacro sigil_X(term, _modifiers) do
    term
  end
end

import MySigils

~x(with #{"inter" &lt;&gt; "polation"})
#=&gt; "with interpolation"

~x(with #{"inter" &lt;&gt; "polation"})r
#=&gt; "noitalopretni htiw"

~X(without #{"interpolation"})
#=&gt; "without \#{"interpolation"}"

~X(without #{"interpolation"})r
#=&gt; "}\"noitalopretni\"{# tuohtiw"</pre> </section> <section id="summary" class="details-list">  <h2> Types </h2>
<dl class="summary-types summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#t:captured_remote_function/0" translate="no">captured_remote_function()</a> </dt> <dd class="summary-synopsis"><p>A captured remote function in the format of &amp;Mod.fun/arity</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:input/0" translate="no">input()</a> </dt> <dd class="summary-synopsis"><p>The inputs of a macro</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:metadata/0" translate="no">metadata()</a> </dt> <dd class="summary-synopsis"><p>A keyword list of AST metadata.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:output/0" translate="no">output()</a> </dt> <dd class="summary-synopsis"><p>The output of a macro</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:t/0" translate="no">t()</a> </dt> <dd class="summary-synopsis"><p>Abstract Syntax Tree (AST)</p></dd> </div> </dl> <h2> Functions </h2>
<dl class="summary-functions summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#camelize/1" translate="no">camelize(string)</a> </dt> <dd class="summary-synopsis"><p>Converts the given string to CamelCase format.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#classify_atom/1" translate="no">classify_atom(atom)</a> </dt> <dd class="summary-synopsis"><p>Classifies a runtime <code class="inline">atom</code> based on its possible AST placement.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#dbg/3" translate="no">dbg(code, options, env)</a> </dt> <dd class="summary-synopsis"><p>Default backend for <a href="kernel.html#dbg/2"><code class="inline">Kernel.dbg/2</code></a>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#decompose_call/1" translate="no">decompose_call(ast)</a> </dt> <dd class="summary-synopsis"><p>Decomposes a local or remote call into its remote part (when provided), function name and argument list.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#escape/2" translate="no">escape(expr, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Recursively escapes a value so it can be inserted into a syntax tree.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#expand/2" translate="no">expand(ast, env)</a> </dt> <dd class="summary-synopsis"><p>Receives an AST node and expands it until it can no longer be expanded.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#expand_literals/2" translate="no">expand_literals(ast, env)</a> </dt> <dd class="summary-synopsis"><p>Expands all literals in <code class="inline">ast</code> with the given <code class="inline">env</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#expand_literals/3" translate="no">expand_literals(ast, acc, fun)</a> </dt> <dd class="summary-synopsis"><p>Expands all literals in <code class="inline">ast</code> with the given <code class="inline">acc</code> and <code class="inline">fun</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#expand_once/2" translate="no">expand_once(ast, env)</a> </dt> <dd class="summary-synopsis"><p>Receives an AST node and expands it once.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#generate_arguments/2" translate="no">generate_arguments(amount, context)</a> </dt> <dd class="summary-synopsis"><p>Generates AST nodes for a given number of required argument variables using <a href="#var/2"><code class="inline">Macro.var/2</code></a>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#generate_unique_arguments/2" translate="no">generate_unique_arguments(amount, context)</a> </dt> <dd class="summary-synopsis"><p>Generates AST nodes for a given number of required argument variables using <a href="#unique_var/2"><code class="inline">Macro.unique_var/2</code></a>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#inspect_atom/2" translate="no">inspect_atom(source_format, atom)</a> </dt> <dd class="summary-synopsis"><p>Inspects <code class="inline">atom</code> according to different source formats.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#operator?/2" translate="no">operator?(name, arity)</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if the given name and arity is an operator.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#path/2" translate="no">path(ast, fun)</a> </dt> <dd class="summary-synopsis"><p>Returns the path to the node in <code class="inline">ast</code> which <code class="inline">fun</code> returns true.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#pipe/3" translate="no">pipe(expr, call_args, position)</a> </dt> <dd class="summary-synopsis"><p>Pipes <code class="inline">expr</code> into the <code class="inline">call_args</code> at the given <code class="inline">position</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#postwalk/2" translate="no">postwalk(ast, fun)</a> </dt> <dd class="summary-synopsis"><p>This function behaves like <a href="#prewalk/2"><code class="inline">prewalk/2</code></a>, but performs a depth-first, post-order traversal of quoted expressions.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#postwalk/3" translate="no">postwalk(ast, acc, fun)</a> </dt> <dd class="summary-synopsis"><p>This functions behaves like <a href="#prewalk/3"><code class="inline">prewalk/3</code></a>, but performs a depth-first, post-order traversal of quoted expressions using an accumulator.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#postwalker/1" translate="no">postwalker(ast)</a> </dt> <dd class="summary-synopsis"><p>Returns an enumerable that traverses the <code class="inline">ast</code> in depth-first, post-order traversal.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#prewalk/2" translate="no">prewalk(ast, fun)</a> </dt> <dd class="summary-synopsis"><p>Performs a depth-first, pre-order traversal of quoted expressions.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#prewalk/3" translate="no">prewalk(ast, acc, fun)</a> </dt> <dd class="summary-synopsis"><p>Performs a depth-first, pre-order traversal of quoted expressions using an accumulator.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#prewalker/1" translate="no">prewalker(ast)</a> </dt> <dd class="summary-synopsis"><p>Returns an enumerable that traverses the <code class="inline">ast</code> in depth-first, pre-order traversal.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#quoted_literal?/1" translate="no">quoted_literal?(term)</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if the given quoted expression represents a quoted literal.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#special_form?/2" translate="no">special_form?(name, arity)</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if the given name and arity is a special form.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#struct!/2" translate="no">struct!(module, env)</a> </dt> <dd class="summary-synopsis"><p>Expands the struct given by <code class="inline">module</code> in the given <code class="inline">env</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#to_string/1" translate="no">to_string(tree)</a> </dt> <dd class="summary-synopsis"><p>Converts the given expression AST to a string.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#to_string/2" translate="no">to_string(tree, fun)</a> <span class="deprecated" title="Use Macro.to_string/1 instead">deprecated</span> </dt> <dd class="summary-synopsis"><p>Converts the given expression AST to a string.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#traverse/4" translate="no">traverse(ast, acc, pre, post)</a> </dt> <dd class="summary-synopsis"><p>Performs a depth-first traversal of quoted expressions using an accumulator.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#underscore/1" translate="no">underscore(atom_or_string)</a> </dt> <dd class="summary-synopsis"><p>Converts the given argument to a string with the underscore-slash format.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#unescape_string/1" translate="no">unescape_string(string)</a> </dt> <dd class="summary-synopsis"><p>Unescapes characters in a string.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#unescape_string/2" translate="no">unescape_string(string, map)</a> </dt> <dd class="summary-synopsis"><p>Unescapes characters in a string according to the given mapping.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#unique_var/2" translate="no">unique_var(var, context)</a> </dt> <dd class="summary-synopsis"><p>Generates an AST node representing a unique variable given by the atoms <code class="inline">var</code> and <code class="inline">context</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#unpipe/1" translate="no">unpipe(expr)</a> </dt> <dd class="summary-synopsis"><p>Breaks a pipeline expression into a list.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#update_meta/2" translate="no">update_meta(quoted, fun)</a> </dt> <dd class="summary-synopsis"><p>Applies the given function to the node metadata if it contains one.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#validate/1" translate="no">validate(expr)</a> </dt> <dd class="summary-synopsis"><p>Validates the given expressions are valid quoted expressions.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#var/2" translate="no">var(var, context)</a> </dt> <dd class="summary-synopsis"><p>Generates an AST node representing the variable given by the atoms <code class="inline">var</code> and <code class="inline">context</code>.</p></dd> </div> </dl> </section> <section id="types" class="details-list">  <div class="types-list"> <section class="detail"> <h3 class="detail-header" id="t:captured_remote_function/0">captured_remote_function()<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/macro.ex#L237" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type captured_remote_function() :: (... -&gt; any())</pre> </div> <p>A captured remote function in the format of &amp;Mod.fun/arity</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:input/0">input()<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/macro.ex#L141" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type input() ::
  input_expr() | {input(), input()} | [input()] | atom() | number() | binary()</pre> </div> <p>The inputs of a macro</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:metadata/0">metadata()<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/macro.ex#L234" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type metadata() :: keyword()</pre> </div> <p>A keyword list of AST metadata.</p>
<p>The metadata in Elixir AST is a keyword list of values. Any key can be used and different parts of the compiler may use different keys. For example, the AST received by a macro will always include the <code class="inline">:line</code> annotation, while the AST emitted by <a href="kernel.specialforms.html#quote/2"><code class="inline">quote/2</code></a> will only have the <code class="inline">:line</code> annotation if the <code class="inline">:line</code> option is provided.</p>
<p>The following metadata keys are public:</p>
<ul>
<li><p><code class="inline">:context</code> - Defines the context in which the AST was generated. For example, <a href="kernel.specialforms.html#quote/2"><code class="inline">quote/2</code></a> will include the module calling <a href="kernel.specialforms.html#quote/2"><code class="inline">quote/2</code></a> as the context. This is often used to distinguish regular code from code generated by a macro or by <a href="kernel.specialforms.html#quote/2"><code class="inline">quote/2</code></a>.</p></li>
<li><p><code class="inline">:counter</code> - The variable counter used for variable hygiene. In terms of the compiler, each variable is identified by the combination of either <code class="inline">name</code> and <code class="inline">metadata[:counter]</code>, or <code class="inline">name</code> and <code class="inline">context</code>.</p></li>
<li><p><code class="inline">:generated</code> - Whether the code should be considered as generated by the compiler or not. This means the compiler and tools like Dialyzer may not emit certain warnings.</p></li>
<li><p><code class="inline">:if_undefined</code> - How to expand a variable that is undefined. Set it to <code class="inline">:apply</code> if you want a variable to become a nullary call without warning or <code class="inline">:raise</code></p></li>
<li><p><code class="inline">:keep</code> - Used by <a href="kernel.specialforms.html#quote/2"><code class="inline">quote/2</code></a> with the option <code class="inline">location: :keep</code> to annotate the file and the line number of the quoted source.</p></li>
<li><p><code class="inline">:line</code> - The line number of the AST node.</p></li>
<li><p><code class="inline">:from_brackets</code> - Used to determine whether a call to <a href="access.html#get/3"><code class="inline">Access.get/3</code></a> is from bracket syntax or a function call.</p></li>
</ul>
<p>The following metadata keys are enabled by <a href="code.html#string_to_quoted/2"><code class="inline">Code.string_to_quoted/2</code></a>:</p>
<ul>
<li>
<code class="inline">:closing</code> - contains metadata about the closing pair, such as a <code class="inline">}</code> in a tuple or in a map, or such as the closing <code class="inline">)</code> in a function call with parens. The <code class="inline">:closing</code> does not delimit the end of expression if there are <code class="inline">:do</code> and <code class="inline">:end</code> metadata (when <code class="inline">:token_metadata</code> is true)</li>
<li>
<code class="inline">:column</code> - the column number of the AST node (when <code class="inline">:columns</code> is true)</li>
<li>
<code class="inline">:delimiter</code> - contains the opening delimiter for sigils, strings, and charlists as a string (such as <code class="inline">"{"</code>, <code class="inline">"/"</code>, <code class="inline">"'"</code>, and the like)</li>
<li>
<code class="inline">:format</code> - set to <code class="inline">:keyword</code> when an atom is defined as a keyword</li>
<li>
<code class="inline">:do</code> - contains metadata about the <code class="inline">do</code> location in a function call with <code class="inline">do</code>-<code class="inline">end</code> blocks (when <code class="inline">:token_metadata</code> is true)</li>
<li>
<code class="inline">:end</code> - contains metadata about the <code class="inline">end</code> location in a function call with <code class="inline">do</code>-<code class="inline">end</code> blocks (when <code class="inline">:token_metadata</code> is true)</li>
<li>
<code class="inline">:end_of_expression</code> - denotes when the end of expression effectively happens. Available for all expressions except the last one inside a <code class="inline">__block__</code> (when <code class="inline">:token_metadata</code> is true)</li>
<li>
<code class="inline">:indentation</code> - indentation of a sigil heredoc</li>
</ul>
<p>The following metadata keys are private:</p>
<ul>
<li>
<code class="inline">:alias</code> - Used for alias hygiene.</li>
<li>
<code class="inline">:ambiguous_op</code> - Used for improved error messages in the compiler.</li>
<li>
<code class="inline">:imports</code> - Used for import hygiene.</li>
<li>
<code class="inline">:var</code> - Used for improved error messages on undefined variables.</li>
</ul>
<p>Do not rely on them as they may change or be fully removed in future versions of the language. They are often used by <a href="kernel.specialforms.html#quote/2"><code class="inline">quote/2</code></a> and the compiler to provide features like hygiene, better error messages, and so forth.</p>
<p>If you introduce custom keys into the AST metadata, please make sure to prefix them with the name of your library or application, so that they will not conflict with keys that could potentially be introduced by the compiler in the future.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:output/0">output()<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/macro.ex#L152" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type output() ::
  output_expr()
  | {output(), output()}
  | [output()]
  | atom()
  | number()
  | binary()
  | captured_remote_function()
  | pid()</pre> </div> <p>The output of a macro</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:t/0">t()<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/macro.ex#L138" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type t() :: input()</pre> </div> <p>Abstract Syntax Tree (AST)</p> </section> </section> </div> </section> <section id="functions" class="details-list">  <div class="functions-list"> <section class="detail"> <h3 class="detail-header" id="camelize/1">camelize(string)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/macro.ex#L2299" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec camelize(String.t()) :: String.t()</pre> </div> <p>Converts the given string to CamelCase format.</p>
<p>This function was designed to camelize language identifiers/tokens, that's why it belongs to the <a href="macro.html#content"><code class="inline">Macro</code></a> module. Do not use it as a general mechanism for camelizing strings as it does not support Unicode or characters that are not valid in Elixir identifiers.</p>
<h4 id="camelize/1-examples" class="section-heading"> <a href="#camelize/1-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Macro.camelize("foo_bar")
"FooBar"

iex&gt; Macro.camelize("foo/bar")
"Foo.Bar"</pre>
<p>If uppercase characters are present, they are not modified in any way as a mechanism to preserve acronyms:</p>
<pre data-language="elixir">iex&gt; Macro.camelize("API.V1")
"API.V1"
iex&gt; Macro.camelize("API_SPEC")
"API_SPEC"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="classify_atom/1">classify_atom(atom)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/macro.ex#L2361" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec classify_atom(atom()) :: :alias | :identifier | :quoted | :unquoted</pre> </div> <p>Classifies a runtime <code class="inline">atom</code> based on its possible AST placement.</p>
<p>It returns one of the following atoms:</p>
<ul>
<li><p><code class="inline">:alias</code> - the atom represents an alias</p></li>
<li><p><code class="inline">:identifier</code> - the atom can be used as a variable or local function call (as well as be an unquoted atom)</p></li>
<li><p><code class="inline">:unquoted</code> - the atom can be used in its unquoted form, includes operators and atoms with <code class="inline">@</code> in them</p></li>
<li><p><code class="inline">:quoted</code> - all other atoms which can only be used in their quoted form</p></li>
</ul>
<p>Most operators are going to be <code class="inline">:unquoted</code>, such as <code class="inline">:+</code>, with some exceptions returning <code class="inline">:quoted</code> due to ambiguity, such as <code class="inline">:"::"</code>. Use <a href="#operator?/2"><code class="inline">operator?/2</code></a> to check if a given atom is an operator.</p>
<h4 id="classify_atom/1-examples" class="section-heading"> <a href="#classify_atom/1-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Macro.classify_atom(:foo)
:identifier
iex&gt; Macro.classify_atom(Foo)
:alias
iex&gt; Macro.classify_atom(:foo@bar)
:unquoted
iex&gt; Macro.classify_atom(:+)
:unquoted
iex&gt; Macro.classify_atom(:Foo)
:unquoted
iex&gt; Macro.classify_atom(:"with spaces")
:quoted</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="dbg/3">dbg(code, options, env)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/macro.ex#L2593" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec dbg(t(), t(), Macro.Env.t()) :: t()</pre> </div> <p>Default backend for <a href="kernel.html#dbg/2"><code class="inline">Kernel.dbg/2</code></a>.</p>
<p>This function provides a default backend for <a href="kernel.html#dbg/2"><code class="inline">Kernel.dbg/2</code></a>. See the <a href="kernel.html#dbg/2"><code class="inline">Kernel.dbg/2</code></a> documentation for more information.</p>
<p>This function:</p>
<ul>
<li>prints information about the given <code class="inline">env</code>
</li>
<li>prints information about <code class="inline">code</code> and its returned value (using <code class="inline">opts</code> to inspect terms)</li>
<li>returns the value returned by evaluating <code class="inline">code</code>
</li>
</ul>
<p>You can call this function directly to build <a href="kernel.html#dbg/2"><code class="inline">Kernel.dbg/2</code></a> backends that fall back to this function.</p>
<p>This function raises if the context of the given <code class="inline">env</code> is <code class="inline">:match</code> or <code class="inline">:guard</code>.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="decompose_call/1">decompose_call(ast)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/macro.ex#L798" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec decompose_call(t()) :: {atom(), [t()]} | {t(), atom(), [t()]} | :error</pre> </div> <p>Decomposes a local or remote call into its remote part (when provided), function name and argument list.</p>
<p>Returns <code class="inline">:error</code> when an invalid call syntax is provided.</p>
<h4 id="decompose_call/1-examples" class="section-heading"> <a href="#decompose_call/1-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Macro.decompose_call(quote(do: foo))
{:foo, []}

iex&gt; Macro.decompose_call(quote(do: foo()))
{:foo, []}

iex&gt; Macro.decompose_call(quote(do: foo(1, 2, 3)))
{:foo, [1, 2, 3]}

iex&gt; Macro.decompose_call(quote(do: Elixir.M.foo(1, 2, 3)))
{{:__aliases__, [], [:Elixir, :M]}, :foo, [1, 2, 3]}

iex&gt; Macro.decompose_call(quote(do: 42))
:error

iex&gt; Macro.decompose_call(quote(do: {:foo, [], []}))
:error</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="escape/2">escape(expr, opts \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/macro.ex#L873" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec escape(
  term(),
  keyword()
) :: t()</pre> </div> <p>Recursively escapes a value so it can be inserted into a syntax tree.</p>
<h4 id="escape/2-examples" class="section-heading"> <a href="#escape/2-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Macro.escape(:foo)
:foo

iex&gt; Macro.escape({:a, :b, :c})
{:{}, [], [:a, :b, :c]}

iex&gt; Macro.escape({:unquote, [], [1]}, unquote: true)
1</pre>
<h4 id="escape/2-options" class="section-heading"> <a href="#escape/2-options">  Options </a> </h4> <ul>
<li><p><code class="inline">:unquote</code> - when true, this function leaves <a href="kernel.specialforms.html#unquote/1"><code class="inline">unquote/1</code></a> and <a href="kernel.specialforms.html#unquote_splicing/1"><code class="inline">unquote_splicing/1</code></a> statements unescaped, effectively unquoting the contents on escape. This option is useful only when escaping ASTs which may have quoted fragments in them. Defaults to false.</p></li>
<li>
<p><code class="inline">:prune_metadata</code> - when true, removes metadata from escaped AST nodes. Note this option changes the semantics of escaped code and it should only be used when escaping ASTs. Defaults to false.</p>
<p>As an example, <a href="https://hexdocs.pm/ex_unit/1.15/ExUnit.html"><code class="inline">ExUnit</code></a> stores the AST of every assertion, so when an assertion fails we can show code snippets to users. Without this option, each time the test module is compiled, we get a different MD5 of the module bytecode, because the AST contains metadata, such as counters, specific to the compilation environment. By pruning the metadata, we ensure that the module is deterministic and reduce the amount of data <a href="https://hexdocs.pm/ex_unit/1.15/ExUnit.html"><code class="inline">ExUnit</code></a> needs to keep around. Only the minimal amount of metadata is kept, such as <code class="inline">:line</code> and <code class="inline">:no_parens</code>.</p>
</li>
</ul>
<h4 id="escape/2-comparison-to-quote-2" class="section-heading"> <a href="#escape/2-comparison-to-quote-2">  Comparison to </a><a href="kernel.specialforms.html#quote/2"><code class="inline">quote/2</code></a> </h4> <p>The <a href="#escape/2"><code class="inline">escape/2</code></a> function is sometimes confused with <a href="kernel.specialforms.html#quote/2"><code class="inline">quote/2</code></a>, because the above examples behave the same with both. The key difference is best illustrated when the value to escape is stored in a variable.</p>
<pre data-language="elixir">iex&gt; Macro.escape({:a, :b, :c})
{:{}, [], [:a, :b, :c]}
iex&gt; quote do: {:a, :b, :c}
{:{}, [], [:a, :b, :c]}

iex&gt; value = {:a, :b, :c}
iex&gt; Macro.escape(value)
{:{}, [], [:a, :b, :c]}

iex&gt; quote do: value
{:value, [], __MODULE__}

iex&gt; value = {:a, :b, :c}
iex&gt; quote do: unquote(value)
{:a, :b, :c}</pre>
<p><a href="#escape/2"><code class="inline">escape/2</code></a> is used to escape <em>values</em> (either directly passed or variable bound), while <a href="kernel.specialforms.html#quote/2"><code class="inline">quote/2</code></a> produces syntax trees for expressions.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="expand/2">expand(ast, env)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/macro.ex#L2183" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec expand(input(), Macro.Env.t()) :: output()</pre> </div> <p>Receives an AST node and expands it until it can no longer be expanded.</p>
<p>Note this function does not traverse the AST, only the root node is expanded.</p>
<p>This function uses <a href="#expand_once/2"><code class="inline">expand_once/2</code></a> under the hood. Check it out for more information and examples.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="expand_literals/2">expand_literals(ast, env)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/macro.ex#L2103" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec expand_literals(input(), Macro.Env.t()) :: output()</pre> </div> <p>Expands all literals in <code class="inline">ast</code> with the given <code class="inline">env</code>.</p>
<p>This function is mostly used to remove compile-time dependencies from AST nodes. In such cases, the given environment is usually manipulated to represent a function:</p>
<pre data-language="elixir">Macro.expand_literals(ast, %{env | function: {:my_code, 1}})</pre>
<p>At the moment, the only expandable literal nodes in an AST are aliases, so this function only expands aliases (and it does so anywhere in a literal).</p>
<p>However, be careful when removing compile-time dependencies between modules. If you remove them but you still invoke the module at compile-time, Elixir will be unable to properly recompile modules when they change.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="expand_literals/3">expand_literals(ast, acc, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/macro.ex#L2118" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec expand_literals(t(), acc, (t(), acc -&gt; {t(), acc})) :: t() when acc: term()</pre> </div> <p>Expands all literals in <code class="inline">ast</code> with the given <code class="inline">acc</code> and <code class="inline">fun</code>.</p>
<p><code class="inline">fun</code> will be invoked with an expandable AST node and <code class="inline">acc</code> and must return a new node with <code class="inline">acc</code>. This is a general version of <a href="#expand_literals/2"><code class="inline">expand_literals/2</code></a> which supports a custom expansion function. Please check <a href="#expand_literals/2"><code class="inline">expand_literals/2</code></a> for use cases and pitfalls.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="expand_once/2">expand_once(ast, env)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/macro.ex#L1840" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec expand_once(input(), Macro.Env.t()) :: output()</pre> </div> <p>Receives an AST node and expands it once.</p>
<p>The following contents are expanded:</p>
<ul>
<li>Macros (local or remote)</li>
<li>Aliases are expanded (if possible) and return atoms</li>
<li>Compilation environment macros (<a href="kernel.specialforms.html#__CALLER__/0"><code class="inline">__CALLER__/0</code></a>, <a href="kernel.specialforms.html#__DIR__/0"><code class="inline">__DIR__/0</code></a>, <a href="kernel.specialforms.html#__ENV__/0"><code class="inline">__ENV__/0</code></a> and <a href="kernel.specialforms.html#__MODULE__/0"><code class="inline">__MODULE__/0</code></a>)</li>
<li>Module attributes reader (<code class="inline">@foo</code>)</li>
</ul>
<p>If the expression cannot be expanded, it returns the expression itself. This function does not traverse the AST, only the root node is expanded.</p>
<p><a href="#expand_once/2"><code class="inline">expand_once/2</code></a> performs the expansion just once. Check <a href="#expand/2"><code class="inline">expand/2</code></a> to perform expansion until the node can no longer be expanded.</p>
<h4 id="expand_once/2-examples" class="section-heading"> <a href="#expand_once/2-examples">  Examples </a> </h4> <p>In the example below, we have a macro that generates a module with a function named <code class="inline">name_length</code> that returns the length of the module name. The value of this function will be calculated at compilation time and not at runtime.</p>
<p>Consider the implementation below:</p>
<pre data-language="elixir">defmacro defmodule_with_length(name, do: block) do
  length = length(Atom.to_charlist(name))

  quote do
    defmodule unquote(name) do
      def name_length, do: unquote(length)
      unquote(block)
    end
  end
end</pre>
<p>When invoked like this:</p>
<pre data-language="elixir">defmodule_with_length My.Module do
  def other_function, do: ...
end</pre>
<p>The compilation will fail because <code class="inline">My.Module</code> when quoted is not an atom, but a syntax tree as follows:</p>
<pre data-language="elixir">{:__aliases__, [], [:My, :Module]}</pre>
<p>That said, we need to expand the aliases node above to an atom, so we can retrieve its length. Expanding the node is not straightforward because we also need to expand the caller aliases. For example:</p>
<pre data-language="elixir">alias MyHelpers, as: My

defmodule_with_length My.Module do
  def other_function, do: ...
end</pre>
<p>The final module name will be <code class="inline">MyHelpers.Module</code> and not <code class="inline">My.Module</code>. With <a href="#expand/2"><code class="inline">Macro.expand/2</code></a>, such aliases are taken into consideration. Local and remote macros are also expanded. We could rewrite our macro above to use this function as:</p>
<pre data-language="elixir">defmacro defmodule_with_length(name, do: block) do
  expanded = Macro.expand(name, __CALLER__)
  length = length(Atom.to_charlist(expanded))

  quote do
    defmodule unquote(name) do
      def name_length, do: unquote(length)
      unquote(block)
    end
  end
end</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="generate_arguments/2">generate_arguments(amount, context)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/macro.ex#L438" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec generate_arguments(0, context :: atom()) :: []</pre> <pre translate="no" data-language="elixir">@spec generate_arguments(pos_integer(), context) :: [{atom(), [], context}, ...]
when context: atom()</pre> </div> <p>Generates AST nodes for a given number of required argument variables using <a href="#var/2"><code class="inline">Macro.var/2</code></a>.</p>
<p>Note the arguments are not unique. If you later on want to access the same variables, you can invoke this function with the same inputs. Use <a href="#generate_unique_arguments/2"><code class="inline">generate_unique_arguments/2</code></a> to generate a unique arguments that can't be overridden.</p>
<h4 id="generate_arguments/2-examples" class="section-heading"> <a href="#generate_arguments/2-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Macro.generate_arguments(2, __MODULE__)
[{:arg1, [], __MODULE__}, {:arg2, [], __MODULE__}]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="generate_unique_arguments/2">generate_unique_arguments(amount, context)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/macro.ex#L550" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec generate_unique_arguments(0, context :: atom()) :: []</pre> <pre translate="no" data-language="elixir">@spec generate_unique_arguments(pos_integer(), context) :: [
  {atom(), [{:counter, integer()}], context},
  ...
]
when context: atom()</pre> </div> <p>Generates AST nodes for a given number of required argument variables using <a href="#unique_var/2"><code class="inline">Macro.unique_var/2</code></a>.</p>
<h4 id="generate_unique_arguments/2-examples" class="section-heading"> <a href="#generate_unique_arguments/2-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; [var1, var2] = Macro.generate_unique_arguments(2, __MODULE__)
iex&gt; {:arg1, [counter: c1], __MODULE__} = var1
iex&gt; {:arg2, [counter: c2], __MODULE__} = var2
iex&gt; is_integer(c1) and is_integer(c2)
true</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="inspect_atom/2">inspect_atom(source_format, atom)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/macro.ex#L2427" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec inspect_atom(:literal | :key | :remote_call, atom()) :: binary()</pre> </div> <p>Inspects <code class="inline">atom</code> according to different source formats.</p>
<p>The atom can be inspected according to the three different formats it appears in the AST: as a literal (<code class="inline">:literal</code>), as a key (<code class="inline">:key</code>), or as the function name of a remote call (<code class="inline">:remote_call</code>).</p>
<h4 id="inspect_atom/2-examples" class="section-heading"> <a href="#inspect_atom/2-examples">  Examples </a> </h4> <h3 id="inspect_atom/2-as-a-literal" class="section-heading"> <a href="#inspect_atom/2-as-a-literal">  As a literal </a> </h3> <p>Literals include regular atoms, quoted atoms, operators, aliases, and the special <code class="inline">nil</code>, <code class="inline">true</code>, and <code class="inline">false</code> atoms.</p>
<pre data-language="elixir">iex&gt; Macro.inspect_atom(:literal, nil)
"nil"
iex&gt; Macro.inspect_atom(:literal, :foo)
":foo"
iex&gt; Macro.inspect_atom(:literal, :&lt;&gt;)
":&lt;&gt;"
iex&gt; Macro.inspect_atom(:literal, :Foo)
":Foo"
iex&gt; Macro.inspect_atom(:literal, Foo.Bar)
"Foo.Bar"
iex&gt; Macro.inspect_atom(:literal, :"with spaces")
":\"with spaces\""</pre>
<h3 id="inspect_atom/2-as-a-key" class="section-heading"> <a href="#inspect_atom/2-as-a-key">  As a key </a> </h3> <p>Inspect an atom as a key of a keyword list or a map.</p>
<pre data-language="elixir">iex&gt; Macro.inspect_atom(:key, :foo)
"foo:"
iex&gt; Macro.inspect_atom(:key, :&lt;&gt;)
"&lt;&gt;:"
iex&gt; Macro.inspect_atom(:key, :Foo)
"Foo:"
iex&gt; Macro.inspect_atom(:key, :"with spaces")
"\"with spaces\":"</pre>
<h3 id="inspect_atom/2-as-a-remote-call" class="section-heading"> <a href="#inspect_atom/2-as-a-remote-call">  As a remote call </a> </h3> <p>Inspect an atom the function name of a remote call.</p>
<pre data-language="elixir">iex&gt; Macro.inspect_atom(:remote_call, :foo)
"foo"
iex&gt; Macro.inspect_atom(:remote_call, :&lt;&gt;)
"&lt;&gt;"
iex&gt; Macro.inspect_atom(:remote_call, :Foo)
"\"Foo\""
iex&gt; Macro.inspect_atom(:remote_call, :"with spaces")
"\"with spaces\""</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="operator?/2">operator?(name, arity)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/macro.ex#L1993" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec operator?(name :: atom(), arity()) :: boolean()</pre> </div> <p>Returns <code class="inline">true</code> if the given name and arity is an operator.</p>
<h4 id="operator?/2-examples" class="section-heading"> <a href="#operator?/2-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Macro.operator?(:not_an_operator, 3)
false
iex&gt; Macro.operator?(:.., 0)
true
iex&gt; Macro.operator?(:+, 1)
true
iex&gt; Macro.operator?(:++, 2)
true
iex&gt; Macro.operator?(:..//, 3)
true</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="path/2">path(ast, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/macro.ex#L469" class="source">Source</a>
</h3> <section class="docstring"> <p>Returns the path to the node in <code class="inline">ast</code> which <code class="inline">fun</code> returns true.</p>
<p>The path is a list, starting with the node in which <code class="inline">fun</code> returns true, followed by all of its parents.</p>
<p>Computing the path can be an efficient operation when you want to find a particular node in the AST within its context and then assert something about it.</p>
<h4 id="path/2-examples" class="section-heading"> <a href="#path/2-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Macro.path(quote(do: [1, 2, 3]), &amp; &amp;1 == 3)
[3, [1, 2, 3]]

iex&gt; Macro.path(quote(do: Foo.bar(3)), &amp; &amp;1 == 3)
[3, quote(do: Foo.bar(3))]

iex&gt; Macro.path(quote(do: %{foo: [bar: :baz]}), &amp; &amp;1 == :baz)
[
  :baz,
  {:bar, :baz},
  [bar: :baz],
  {:foo, [bar: :baz]},
  {:%{}, [], [foo: [bar: :baz]]}
]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="pipe/3">pipe(expr, call_args, position)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/macro.ex#L300" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec pipe(t(), t(), integer()) :: t()</pre> </div> <p>Pipes <code class="inline">expr</code> into the <code class="inline">call_args</code> at the given <code class="inline">position</code>.</p>
<p>This function can be used to implement <code class="inline">|&gt;</code> like functionality. For example, <code class="inline">|&gt;</code> itself is implemented as:</p>
<pre data-language="elixir">defmacro left |&gt; right do
  Macro.pipe(left, right, 0)
end</pre>
<p><code class="inline">expr</code> is the AST of an expression. <code class="inline">call_args</code> must be the AST <em>of a call</em>, otherwise this function will raise an error. As an example, consider the pipe operator <a href="kernel.html#%7C%3E/2"><code class="inline">|&gt;/2</code></a>, which uses this function to build pipelines.</p>
<p>Even if the expression is piped into the AST, it doesn't necessarily mean that the AST is valid. For example, you could pipe an argument to <a href="kernel.html#div/2"><code class="inline">div/2</code></a>, effectively turning it into a call to <code class="inline">div/3</code>, which is a function that doesn't exist by default. The code will raise unless a <code class="inline">div/3</code> function is locally defined.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="postwalk/2">postwalk(ast, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/macro.ex#L757" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec postwalk(t(), (t() -&gt; t())) :: t()</pre> </div> <p>This function behaves like <a href="#prewalk/2"><code class="inline">prewalk/2</code></a>, but performs a depth-first, post-order traversal of quoted expressions.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="postwalk/3">postwalk(ast, acc, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/macro.ex#L766" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec postwalk(t(), any(), (t(), any() -&gt; {t(), any()})) :: {t(), any()}</pre> </div> <p>This functions behaves like <a href="#prewalk/3"><code class="inline">prewalk/3</code></a>, but performs a depth-first, post-order traversal of quoted expressions using an accumulator.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="postwalker/1">postwalker(ast)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/macro.ex#L1026" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec postwalker(t()) :: Enumerable.t()</pre> </div> <p>Returns an enumerable that traverses the <code class="inline">ast</code> in depth-first, post-order traversal.</p>
<h4 id="postwalker/1-examples" class="section-heading"> <a href="#postwalker/1-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; ast = quote do: foo(1, "abc")
iex&gt; Enum.map(Macro.postwalker(ast), &amp; &amp;1)
[1, "abc", {:foo, [], [1, "abc"]}]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="prewalk/2">prewalk(ast, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/macro.ex#L719" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec prewalk(t(), (t() -&gt; t())) :: t()</pre> </div> <p>Performs a depth-first, pre-order traversal of quoted expressions.</p>
<p>Returns a new AST where each node is the result of invoking <code class="inline">fun</code> on each corresponding node of <code class="inline">ast</code>.</p>
<h4 id="prewalk/2-examples" class="section-heading"> <a href="#prewalk/2-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; ast = quote do: 5 + 3 * 7
iex&gt; {:+, _, [5, {:*, _, [3, 7]}]} = ast
iex&gt; new_ast = Macro.prewalk(ast, fn
...&gt;   {:+, meta, children} -&gt; {:*, meta, children}
...&gt;   {:*, meta, children} -&gt; {:+, meta, children}
...&gt;   other -&gt; other
...&gt; end)
iex&gt; {:*, _, [5, {:+, _, [3, 7]}]} = new_ast
iex&gt; Code.eval_quoted(ast)
{26, []}
iex&gt; Code.eval_quoted(new_ast)
{50, []}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="prewalk/3">prewalk(ast, acc, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/macro.ex#L748" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec prewalk(t(), any(), (t(), any() -&gt; {t(), any()})) :: {t(), any()}</pre> </div> <p>Performs a depth-first, pre-order traversal of quoted expressions using an accumulator.</p>
<p>Returns a tuple where the first element is a new AST where each node is the result of invoking <code class="inline">fun</code> on each corresponding node and the second one is the final accumulator.</p>
<h4 id="prewalk/3-examples" class="section-heading"> <a href="#prewalk/3-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; ast = quote do: 5 + 3 * 7
iex&gt; {:+, _, [5, {:*, _, [3, 7]}]} = ast
iex&gt; {new_ast, acc} = Macro.prewalk(ast, [], fn
...&gt;   {:+, meta, children}, acc -&gt; {{:*, meta, children}, [:+ | acc]}
...&gt;   {:*, meta, children}, acc -&gt; {{:+, meta, children}, [:* | acc]}
...&gt;   other, acc -&gt; {other, acc}
...&gt; end)
iex&gt; {{:*, _, [5, {:+, _, [3, 7]}]}, [:*, :+]} = {new_ast, acc}
iex&gt; Code.eval_quoted(ast)
{26, []}
iex&gt; Code.eval_quoted(new_ast)
{50, []}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="prewalker/1">prewalker(ast)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/macro.ex#L968" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec prewalker(t()) :: Enumerable.t()</pre> </div> <p>Returns an enumerable that traverses the <code class="inline">ast</code> in depth-first, pre-order traversal.</p>
<h4 id="prewalker/1-examples" class="section-heading"> <a href="#prewalker/1-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; ast = quote do: foo(1, "abc")
iex&gt; Enum.map(Macro.prewalker(ast), &amp; &amp;1)
[{:foo, [], [1, "abc"]}, 1, "abc"]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="quoted_literal?/1">quoted_literal?(term)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/macro.ex#L2037" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec quoted_literal?(t()) :: boolean()</pre> </div> <p>Returns <code class="inline">true</code> if the given quoted expression represents a quoted literal.</p>
<p>Atoms and numbers are always literals. Binaries, lists, tuples, maps, and structs are only literals if all of their terms are also literals.</p>
<h4 id="quoted_literal?/1-examples" class="section-heading"> <a href="#quoted_literal?/1-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Macro.quoted_literal?(quote(do: "foo"))
true
iex&gt; Macro.quoted_literal?(quote(do: {"foo", 1}))
true
iex&gt; Macro.quoted_literal?(quote(do: {"foo", 1, :baz}))
true
iex&gt; Macro.quoted_literal?(quote(do: %{foo: "bar"}))
true
iex&gt; Macro.quoted_literal?(quote(do: %URI{path: "/"}))
true
iex&gt; Macro.quoted_literal?(quote(do: URI.parse("/")))
false
iex&gt; Macro.quoted_literal?(quote(do: {foo, var}))
false</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="special_form?/2">special_form?(name, arity)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/macro.ex#L1970" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec special_form?(name :: atom(), arity()) :: boolean()</pre> </div> <p>Returns <code class="inline">true</code> if the given name and arity is a special form.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="struct!/2">struct!(module, env)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/macro.ex#L895" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec struct!(module, Macro.Env.t()) :: %{
  :__struct__ =&gt; module,
  optional(atom()) =&gt; any()
}
when module: module()</pre> </div> <p>Expands the struct given by <code class="inline">module</code> in the given <code class="inline">env</code>.</p>
<p>This is useful when a struct needs to be expanded at compilation time and the struct being expanded may or may not have been compiled. This function is also capable of expanding structs defined under the module being compiled.</p>
<p>It will raise <a href="compileerror.html"><code class="inline">CompileError</code></a> if the struct is not available. From Elixir v1.12, calling this function also adds an export dependency on the given struct.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="to_string/1">to_string(tree)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/macro.ex#L1185" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec to_string(t()) :: String.t()</pre> </div> <p>Converts the given expression AST to a string.</p>
<p>This is a convenience function for converting AST into a string, which discards all formatting of the original code and wraps newlines around 98 characters. See <a href="code.html#quoted_to_algebra/2"><code class="inline">Code.quoted_to_algebra/2</code></a> as a lower level function with more control around formatting.</p>
<h4 id="to_string/1-examples" class="section-heading"> <a href="#to_string/1-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Macro.to_string(quote(do: foo.bar(1, 2, 3)))
"foo.bar(1, 2, 3)"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="to_string/2">to_string(tree, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/macro.ex#L1212" class="source">Source</a>
</h3> <div class="deprecated"> This function is deprecated. Use Macro.to_string/1 instead. </div> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec to_string(t(), (t(), String.t() -&gt; String.t())) :: String.t()</pre> </div> <p>Converts the given expression AST to a string.</p>
<p>The given <code class="inline">fun</code> is called for every node in the AST with two arguments: the AST of the node being printed and the string representation of that same node. The return value of this function is used as the final string representation for that AST node.</p>
<p>This function discards all formatting of the original code.</p>
<h4 id="to_string/2-examples" class="section-heading"> <a href="#to_string/2-examples">  Examples </a> </h4> <pre data-language="elixir">Macro.to_string(quote(do: 1 + 2), fn
  1, _string -&gt; "one"
  2, _string -&gt; "two"
  _ast, string -&gt; string
end)
#=&gt; "one + two"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="traverse/4">traverse(ast, acc, pre, post)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/macro.ex#L647" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec traverse(t(), any(), (t(), any() -&gt; {t(), any()}), (t(), any() -&gt; {t(), any()})) ::
  {t(), any()}</pre> </div> <p>Performs a depth-first traversal of quoted expressions using an accumulator.</p>
<p>Returns a tuple where the first element is a new AST and the second one is the final accumulator. The new AST is the result of invoking <code class="inline">pre</code> on each node of <code class="inline">ast</code> during the pre-order phase and <code class="inline">post</code> during the post-order phase.</p>
<h4 id="traverse/4-examples" class="section-heading"> <a href="#traverse/4-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; ast = quote do: 5 + 3 * 7
iex&gt; {:+, _, [5, {:*, _, [3, 7]}]} = ast
iex&gt; {new_ast, acc} =
...&gt;  Macro.traverse(
...&gt;    ast,
...&gt;    [],
...&gt;    fn
...&gt;      {:+, meta, children}, acc -&gt; {{:-, meta, children}, [:- | acc]}
...&gt;      {:*, meta, children}, acc -&gt; {{:/, meta, children}, [:/ | acc]}
...&gt;      other, acc -&gt; {other, acc}
...&gt;    end,
...&gt;    fn
...&gt;      {:-, meta, children}, acc -&gt; {{:min, meta, children}, [:min | acc]}
...&gt;      {:/, meta, children}, acc -&gt; {{:max, meta, children}, [:max | acc]}
...&gt;      other, acc -&gt; {other, acc}
...&gt;    end
...&gt;  )
iex&gt; {:min, _, [5, {:max, _, [3, 7]}]} = new_ast
iex&gt; [:min, :max, :/, :-] = acc
iex&gt; Code.eval_quoted(new_ast)
{5, []}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="underscore/1">underscore(atom_or_string)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/macro.ex#L2235" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec underscore(module() | atom() | String.t()) :: String.t()</pre> </div> <p>Converts the given argument to a string with the underscore-slash format.</p>
<p>The argument must either be an atom or a string. If an atom is given, it is assumed to be an Elixir module, so it is converted to a string and then processed.</p>
<p>This function was designed to format language identifiers/tokens with the underscore-slash format, that's why it belongs to the <a href="macro.html#content"><code class="inline">Macro</code></a> module. Do not use it as a general mechanism for underscoring strings as it does not support Unicode or characters that are not valid in Elixir identifiers.</p>
<h4 id="underscore/1-examples" class="section-heading"> <a href="#underscore/1-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Macro.underscore("FooBar")
"foo_bar"

iex&gt; Macro.underscore("Foo.Bar")
"foo/bar"

iex&gt; Macro.underscore(Foo.Bar)
"foo/bar"</pre>
<p>In general, <code class="inline">underscore</code> can be thought of as the reverse of <code class="inline">camelize</code>, however, in some cases formatting may be lost:</p>
<pre data-language="elixir">iex&gt; Macro.underscore("SAPExample")
"sap_example"

iex&gt; Macro.camelize("sap_example")
"SapExample"

iex&gt; Macro.camelize("hello_10")
"Hello10"

iex&gt; Macro.camelize("foo/bar")
"Foo.Bar"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="unescape_string/1">unescape_string(string)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/macro.ex#L1102" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec unescape_string(String.t()) :: String.t()</pre> </div> <p>Unescapes characters in a string.</p>
<p>This is the unescaping behaviour used by default in Elixir single- and double-quoted strings. Check <a href="#unescape_string/2"><code class="inline">unescape_string/2</code></a> for information on how to customize the escaping map.</p>
<p>In this setup, Elixir will escape the following: <code class="inline">\0</code>, <code class="inline">\a</code>, <code class="inline">\b</code>, <code class="inline">\d</code>, <code class="inline">\e</code>, <code class="inline">\f</code>, <code class="inline">\n</code>, <code class="inline">\r</code>, <code class="inline">\s</code>, <code class="inline">\t</code> and <code class="inline">\v</code>. Bytes can be given as hexadecimals via <code class="inline">\xNN</code> and Unicode code points as <code class="inline">\uNNNN</code> escapes.</p>
<p>This function is commonly used on sigil implementations (like <code class="inline">~r</code>, <code class="inline">~s</code> and others), which receive a raw, unescaped string, and it can be used anywhere that needs to mimic how Elixir parses strings.</p>
<h4 id="unescape_string/1-examples" class="section-heading"> <a href="#unescape_string/1-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Macro.unescape_string("example\\n")
"example\n"</pre>
<p>In the example above, we pass a string with <code class="inline">\n</code> escaped and return a version with it unescaped.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="unescape_string/2">unescape_string(string, map)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/macro.ex#L1148" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec unescape_string(String.t(), (non_neg_integer() -&gt; non_neg_integer() | false)) ::
  String.t()</pre> </div> <p>Unescapes characters in a string according to the given mapping.</p>
<p>Check <a href="#unescape_string/1"><code class="inline">unescape_string/1</code></a> if you want to use the same mapping as Elixir single- and double-quoted strings.</p>
<h4 id="unescape_string/2-mapping-function" class="section-heading"> <a href="#unescape_string/2-mapping-function">  Mapping function </a> </h4> <p>The mapping function receives an integer representing the code point of the character it wants to unescape. There are also the special atoms <code class="inline">:newline</code>, <code class="inline">:unicode</code>, and <code class="inline">:hex</code>, which control newline, unicode, and escaping respectively.</p>
<p>Here is the default mapping function implemented by Elixir:</p>
<pre data-language="elixir">def unescape_map(:newline), do: true
def unescape_map(:unicode), do: true
def unescape_map(:hex), do: true
def unescape_map(?0), do: ?0
def unescape_map(?a), do: ?\a
def unescape_map(?b), do: ?\b
def unescape_map(?d), do: ?\d
def unescape_map(?e), do: ?\e
def unescape_map(?f), do: ?\f
def unescape_map(?n), do: ?\n
def unescape_map(?r), do: ?\r
def unescape_map(?s), do: ?\s
def unescape_map(?t), do: ?\t
def unescape_map(?v), do: ?\v
def unescape_map(e), do: e</pre>
<p>If the <code class="inline">unescape_map/1</code> function returns <code class="inline">false</code>, the char is not escaped and the backslash is kept in the string.</p>
<h4 id="unescape_string/2-examples" class="section-heading"> <a href="#unescape_string/2-examples">  Examples </a> </h4> <p>Using the <code class="inline">unescape_map/1</code> function defined above is easy:</p>
<pre data-language="elixir">Macro.unescape_string("example\\n", &amp;unescape_map(&amp;1))</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="unique_var/2">unique_var(var, context)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/macro.ex#L608" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec unique_var(var, context) :: {var, [{:counter, integer()}], context}
when var: atom(), context: atom()</pre> </div> <p>Generates an AST node representing a unique variable given by the atoms <code class="inline">var</code> and <code class="inline">context</code>.</p>
<p>Calling this function with the same arguments will generate another variable, with its own unique counter. See <a href="#var/2"><code class="inline">var/2</code></a> for an alternative.</p>
<h4 id="unique_var/2-examples" class="section-heading"> <a href="#unique_var/2-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; {:foo, [counter: c], __MODULE__} = Macro.unique_var(:foo, __MODULE__)
iex&gt; is_integer(c)
true</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="unpipe/1">unpipe(expr)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/macro.ex#L268" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec unpipe(t()) :: [t()]</pre> </div> <p>Breaks a pipeline expression into a list.</p>
<p>The AST for a pipeline (a sequence of applications of <a href="kernel.html#%7C%3E/2"><code class="inline">|&gt;/2</code></a>) is similar to the AST of a sequence of binary operators or function applications: the top-level expression is the right-most <code class="inline">:|&gt;</code> (which is the last one to be executed), and its left-hand and right-hand sides are its arguments:</p>
<pre data-language="elixir">quote do: 100 |&gt; div(5) |&gt; div(2)
#=&gt; {:|&gt;, _, [arg1, arg2]}</pre>
<p>In the example above, the <a href="kernel.html#%7C%3E/2"><code class="inline">|&gt;/2</code></a> pipe is the right-most pipe; <code class="inline">arg1</code> is the AST for <code class="inline">100 |&gt; div(5)</code>, and <code class="inline">arg2</code> is the AST for <code class="inline">div(2)</code>.</p>
<p>It's often useful to have the AST for such a pipeline as a list of function applications. This function does exactly that:</p>
<pre data-language="elixir">Macro.unpipe(quote do: 100 |&gt; div(5) |&gt; div(2))
#=&gt; [{100, 0}, {{:div, [], [5]}, 0}, {{:div, [], [2]}, 0}]</pre>
<p>We get a list that follows the pipeline directly: first the <code class="inline">100</code>, then the <code class="inline">div(5)</code> (more precisely, its AST), then <code class="inline">div(2)</code>. The <code class="inline">0</code> as the second element of the tuples is the position of the previous element in the pipeline inside the current function application: <code class="inline">{{:div, [], [5]}, 0}</code> means that the previous element (<code class="inline">100</code>) will be inserted as the 0th (first) argument to the <a href="kernel.html#div/2"><code class="inline">div/2</code></a> function, so that the AST for that function will become <code class="inline">{:div, [], [100, 5]}</code> (<code class="inline">div(100, 5)</code>).</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="update_meta/2">update_meta(quoted, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/macro.ex#L410" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec update_meta(t(), (keyword() -&gt; keyword())) :: t()</pre> </div> <p>Applies the given function to the node metadata if it contains one.</p>
<p>This is often useful when used with <a href="#prewalk/2"><code class="inline">Macro.prewalk/2</code></a> to remove information like lines and hygienic counters from the expression for either storage or comparison.</p>
<h4 id="update_meta/2-examples" class="section-heading"> <a href="#update_meta/2-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; quoted = quote line: 10, do: sample()
{:sample, [line: 10], []}
iex&gt; Macro.update_meta(quoted, &amp;Keyword.delete(&amp;1, :line))
{:sample, [], []}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="validate/1">validate(expr)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/macro.ex#L929" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec validate(term()) :: :ok | {:error, term()}</pre> </div> <p>Validates the given expressions are valid quoted expressions.</p>
<p>Check the type <a href="#t:t/0"><code class="inline">Macro.t/0</code></a> for a complete specification of a valid quoted expression.</p>
<p>It returns <code class="inline">:ok</code> if the expression is valid. Otherwise it returns a tuple in the form of <code class="inline">{:error, remainder}</code> where <code class="inline">remainder</code> is the invalid part of the quoted expression.</p>
<h4 id="validate/1-examples" class="section-heading"> <a href="#validate/1-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Macro.validate({:two_element, :tuple})
:ok
iex&gt; Macro.validate({:three, :element, :tuple})
{:error, {:three, :element, :tuple}}

iex&gt; Macro.validate([1, 2, 3])
:ok
iex&gt; Macro.validate([1, 2, 3, {4}])
{:error, {4}}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="var/2">var(var, context)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/macro.ex#L586" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec var(var, context) :: {var, [], context} when var: atom(), context: atom()</pre> </div> <p>Generates an AST node representing the variable given by the atoms <code class="inline">var</code> and <code class="inline">context</code>.</p>
<p>Note this variable is not unique. If you later on want to access this same variable, you can invoke <a href="#var/2"><code class="inline">var/2</code></a> again with the same arguments. Use <a href="#unique_var/2"><code class="inline">unique_var/2</code></a> to generate a unique variable that can't be overridden.</p>
<h4 id="var/2-examples" class="section-heading"> <a href="#var/2-examples">  Examples </a> </h4> <p>In order to build a variable, a context is expected. Most of the times, in order to preserve hygiene, the context must be <a href="kernel.specialforms.html#__MODULE__/0"><code class="inline">__MODULE__/0</code></a>:</p>
<pre data-language="elixir">iex&gt; Macro.var(:foo, __MODULE__)
{:foo, [], __MODULE__}</pre>
<p>However, if there is a need to access the user variable, nil can be given:</p>
<pre data-language="elixir">iex&gt; Macro.var(:foo, nil)
{:foo, [], nil}</pre> </section> </section> </div> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/elixir/1.15.4/Macro.html" class="_attribution-link">https://hexdocs.pm/elixir/1.15.4/Macro.html</a>
  </p>
</div>
