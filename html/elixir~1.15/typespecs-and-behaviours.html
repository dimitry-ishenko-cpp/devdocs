<div class="getting-started-title"> <small>Getting Started</small> <h1>Typespecs and behaviours</h1> </div>  <h2 id="types-and-specs">Types and specs</h2> <p>Elixir is a dynamically typed language, so all types in Elixir are checked at runtime. Nonetheless, Elixir comes with <strong>typespecs</strong>, which are a notation used for:</p> <ol> <li>declaring typed function signatures (also called specifications);</li> <li>declaring custom types.</li> </ol> <p>Typespecs are useful for code clarity and static code analysis (for example, Erlang’s <a href="http://www.erlang.org/doc/man/dialyzer.html">Dialyzer</a> tool).</p> <h3 id="function-specifications">Function specifications</h3> <p>Elixir provides many <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">built-in types</a>, such as <code class="language-plaintext highlighter-rouge">integer</code> or <code class="language-plaintext highlighter-rouge">pid</code>, that can be used to document function signatures. For example, the <code class="language-plaintext highlighter-rouge">round/1</code> function, which rounds a number to its nearest integer. As you can see <a href="https://hexdocs.pm/elixir/Kernel.html#round/1">in its documentation</a>, <code class="language-plaintext highlighter-rouge">round/1</code>’s typed signature is written as:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">round(number()) :: integer()
</pre></div> <p>The syntax is to put the function and its input on the left side of the <code class="language-plaintext highlighter-rouge">::</code> and the return value’s type on the right side. Be aware that types <em>may</em> omit parentheses.</p> <p>In code, function specs are written with the <code class="language-plaintext highlighter-rouge">@spec</code> attribute, typically placed immediately before the function definition. Specs can describe both public and private functions. The function name and the number of arguments used in the <code class="language-plaintext highlighter-rouge">@spec</code> attribute must match the function it describes.</p> <p>Elixir supports compound types as well. For example, a list of integers has type <code class="language-plaintext highlighter-rouge">[integer]</code>, or maps that define keys and types (see the example below).</p> <p>You can see all the built-in types provided by Elixir <a href="https://hexdocs.pm/elixir/typespecs.html">in the typespecs docs</a>.</p> <h3 id="defining-custom-types">Defining custom types</h3> <p>Defining custom types can help communicate the intention of your code and increase its readability. Custom types can be defined within modules via the <code class="language-plaintext highlighter-rouge">@type</code> attribute.</p> <p>A simple example of a custom type implementation is to provide a more descriptive alias of an existing type. For example, defining <code class="language-plaintext highlighter-rouge">year</code> as a type makes your function specs more descriptive than if they had simply used <code class="language-plaintext highlighter-rouge">integer</code>:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">defmodule Person do
   @typedoc """
   A 4 digit year, e.g. 1984
   """
   @type year :: integer

   @spec current_age(year) :: integer
   def current_age(year_of_birth), do: # implementation
end
</pre></div> <p>The <code class="language-plaintext highlighter-rouge">@typedoc</code> attribute, similar to the <code class="language-plaintext highlighter-rouge">@doc</code> and <code class="language-plaintext highlighter-rouge">@moduledoc</code> attributes, is used to document custom types.</p> <p>You may define compound custom types, e.g. maps:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">@type error_map :: %{
   message: String.t,
   line_number: integer
}
</pre></div> <p><a href="structs.html">Structs</a> offer similar functionality.</p> <p>Let’s look at another example to understand how to define more complex types. Say we have a <code class="language-plaintext highlighter-rouge">LousyCalculator</code> module, which performs the usual arithmetic operations (sum, product, and so on) but, instead of returning numbers, it returns tuples with the result of an operation as the first element and a random remark as the second element.</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">defmodule LousyCalculator do
  @spec add(number, number) :: {number, String.t}
  def add(x, y), do: {x + y, "You need a calculator to do that?!"}

  @spec multiply(number, number) :: {number, String.t}
  def multiply(x, y), do: {x * y, "Jeez, come on!"}
end
</pre></div> <p>Tuples are a compound type and each tuple is identified by the types inside it (in this case, a number and a string). To understand why <code class="language-plaintext highlighter-rouge">String.t</code> is not written as <code class="language-plaintext highlighter-rouge">string</code>, have another look at the <a href="https://hexdocs.pm/elixir/typespecs.html#the-string-type">typespecs docs</a>.</p> <p>Defining function specs this way works, but we end up repeating the type <code class="language-plaintext highlighter-rouge">{number, String.t}</code> over and over. We can use the <code class="language-plaintext highlighter-rouge">@type</code> attribute to declare our own custom type and cut down on the repetition.</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">defmodule LousyCalculator do
  @typedoc """
  Just a number followed by a string.
  """
  @type number_with_remark :: {number, String.t}

  @spec add(number, number) :: number_with_remark
  def add(x, y), do: {x + y, "You need a calculator to do that?"}

  @spec multiply(number, number) :: number_with_remark
  def multiply(x, y), do: {x * y, "It is like addition on steroids."}
end
</pre></div> <p>Custom types defined through <code class="language-plaintext highlighter-rouge">@type</code> are exported and are available outside the module they’re defined in:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">defmodule QuietCalculator do
  @spec add(number, number) :: number
  def add(x, y), do: make_quiet(LousyCalculator.add(x, y))

  @spec make_quiet(LousyCalculator.number_with_remark) :: number
  defp make_quiet({num, _remark}), do: num
end
</pre></div> <p>If you want to keep a custom type private, you can use the <code class="language-plaintext highlighter-rouge">@typep</code> attribute instead of <code class="language-plaintext highlighter-rouge">@type</code>. The visibility also affects whether or not documentation will be generated by tools like <a href="https://hexdocs.pm/ex_doc/readme.html">ExDoc</a>, Elixir’s documentation generator.</p> <h3 id="static-code-analysis">Static code analysis</h3> <p>Typespecs are not only useful to developers as additional documentation. The Erlang tool <a href="http://www.erlang.org/doc/man/dialyzer.html">Dialyzer</a>, for example, uses typespecs in order to perform static analysis of code. That’s why, in the <code class="language-plaintext highlighter-rouge">QuietCalculator</code> example, we wrote a spec for the <code class="language-plaintext highlighter-rouge">make_quiet/1</code> function even though it was defined as a private function.</p> <h2 id="behaviours">Behaviours</h2> <p>Many modules share the same public API. Take a look at <a href="https://github.com/elixir-lang/plug">Plug</a>, which, as its description states, is a <strong>specification</strong> for composable modules in web applications. Each <em>plug</em> is a module which <strong>has to</strong> implement at least two public functions: <code class="language-plaintext highlighter-rouge">init/1</code> and <code class="language-plaintext highlighter-rouge">call/2</code>.</p> <p>Behaviours provide a way to:</p> <ul> <li>define a set of functions that have to be implemented by a module;</li> <li>ensure that a module implements all the functions in that set.</li> </ul> <p>If you have to, you can think of behaviours like interfaces in object oriented languages like Java: a set of function signatures that a module has to implement. Unlike Protocols, behaviours are independent of the type/data.</p> <h3 id="defining-behaviours">Defining behaviours</h3> <p>Say we want to implement a bunch of parsers, each parsing structured data: for example, a JSON parser and a MessagePack parser. Each of these two parsers will <em>behave</em> the same way: both will provide a <code class="language-plaintext highlighter-rouge">parse/1</code> function and an <code class="language-plaintext highlighter-rouge">extensions/0</code> function. The <code class="language-plaintext highlighter-rouge">parse/1</code> function will return an Elixir representation of the structured data, while the <code class="language-plaintext highlighter-rouge">extensions/0</code> function will return a list of file extensions that can be used for each type of data (e.g., <code class="language-plaintext highlighter-rouge">.json</code> for JSON files).</p> <p>We can create a <code class="language-plaintext highlighter-rouge">Parser</code> behaviour:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">defmodule Parser do
  @doc """
  Parses a string.
  """
  @callback parse(String.t) :: {:ok, term} | {:error, atom}

  @doc """
  Lists all supported file extensions.
  """
  @callback extensions() :: [String.t]
end
</pre></div> <p>Modules adopting the <code class="language-plaintext highlighter-rouge">Parser</code> behaviour will have to implement all the functions defined with the <code class="language-plaintext highlighter-rouge">@callback</code> attribute. As you can see, <code class="language-plaintext highlighter-rouge">@callback</code> expects a function name but also a function specification like the ones used with the <code class="language-plaintext highlighter-rouge">@spec</code> attribute we saw above. Also note that the <code class="language-plaintext highlighter-rouge">term</code> type is used to represent the parsed value. In Elixir, the <code class="language-plaintext highlighter-rouge">term</code> type is a shortcut to represent any type.</p> <h3 id="implementing-behaviours">Implementing behaviours</h3> <p>Implementing a behaviour is straightforward:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">defmodule JSONParser do
  @behaviour Parser

  @impl Parser
  def parse(str), do: {:ok, "some json " &lt;&gt; str} # ... parse JSON

  @impl Parser
  def extensions, do: [".json"]
end
</pre></div> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">defmodule CSVParser do
  @behaviour Parser

  @impl Parser
  def parse(str), do: {:ok, "some csv " &lt;&gt; str} # ... parse CSV

  @impl Parser
  def extensions, do: [".csv"]
end
</pre></div> <p>If a module adopting a given behaviour doesn’t implement one of the callbacks required by that behaviour, a compile-time warning will be generated.</p> <p>Furthermore, with <code class="language-plaintext highlighter-rouge">@impl</code> you can also make sure that you are implementing the <strong>correct</strong> callbacks from the given behaviour in an explicit manner. For example, the following parser implements both <code class="language-plaintext highlighter-rouge">parse</code> and <code class="language-plaintext highlighter-rouge">extensions</code>. However, thanks to a typo, <code class="language-plaintext highlighter-rouge">BADParser</code> is implementing <code class="language-plaintext highlighter-rouge">parse/0</code> instead of <code class="language-plaintext highlighter-rouge">parse/1</code>.</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">defmodule BADParser do
  @behaviour Parser

  @impl Parser
  def parse, do: {:ok, "something bad"}

  @impl Parser
  def extensions, do: ["bad"]
end
</pre></div> <p>This code generates a warning letting you know that you are mistakenly implementing <code class="language-plaintext highlighter-rouge">parse/0</code> instead of <code class="language-plaintext highlighter-rouge">parse/1</code>. You can read more about <code class="language-plaintext highlighter-rouge">@impl</code> in the <a href="https://hexdocs.pm/elixir/main/Module.html#module-impl">module documentation</a>.</p> <h3 id="using-behaviours">Using behaviours</h3> <p>Behaviours are useful because you can pass modules around as arguments and you can then <em>call back</em> to any of the functions specified in the behaviour. For example, we can have a function that receives a filename, several parsers, and parses the file based on its extension:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">@spec parse_path(Path.t(), [module()]) :: {:ok, term} | {:error, atom}
def parse_path(filename, parsers) do
  with {:ok, ext} &lt;- parse_extension(filename),
       {:ok, parser} &lt;- find_parser(ext, parsers),
       {:ok, contents} &lt;- File.read(filename) do
    parser.parse(contents)
  end
end

defp parse_extension(filename) do
  if ext = Path.extname(filename) do
    {:ok, ext}
  else
    {:error, :no_extension}
  end
end

defp find_parser(ext, parsers) do
  if parser = Enum.find(parsers, fn parser -&gt; ext in parser.extensions() end) do
    {:ok, parser}
  else
    {:error, :no_matching_parser}
  end
end
</pre></div> <p>Of course, you could also invoke any parser directly: <code class="language-plaintext highlighter-rouge">CSVParser.parse(...)</code>.</p> <p>Note you don’t need to define a behaviour in order to dynamically dispatch on a module, but those features often go hand in hand.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://elixir-lang.org/getting-started/typespecs-and-behaviours.html" class="_attribution-link">https://elixir-lang.org/getting-started/typespecs-and-behaviours.html</a>
  </p>
</div>
