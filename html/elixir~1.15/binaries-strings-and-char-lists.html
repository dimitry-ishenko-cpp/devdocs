<div class="getting-started-title"> <small>Getting Started</small> <h1>Binaries, strings, and charlists</h1> </div>  <p>In â€œBasic typesâ€, we learned a little bit about strings and we used the <code class="language-plaintext highlighter-rouge">is_binary/1</code> function for checks:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; string = "hello"
"hello"
iex&gt; is_binary(string)
true
</pre></div> <p>In this chapter, we will gain clarity on what exactly binaries are, how they relate to strings, and what single-quoted values, <code class="language-plaintext highlighter-rouge">'like this'</code>, mean in Elixir. Although strings are one of the most common data types in computer languages, they are subtly complex and are often misunderstood. To understand strings in Elixir, we have to educate ourselves about <a href="https://en.wikipedia.org/wiki/Unicode">Unicode</a> and character encodings, specifically the <a href="https://en.wikipedia.org/wiki/UTF-8">UTF-8</a> encoding.</p> <h2 id="unicode-and-code-points">Unicode and Code Points</h2> <p>In order to facilitate meaningful communication between computers across multiple languages, a standard is required so that the ones and zeros on one machine mean the same thing when they are transmitted to another. The <a href="https://unicode.org/standard/standard.html">Unicode Standard</a> acts as an official registry of virtually all the characters we know: this includes characters from classical and historical texts, emoji, and formatting and control characters as well.</p> <p>Unicode organizes all of the characters in its repertoire into code charts, and each character is given a unique numerical index. This numerical index is known as a <a href="https://en.wikipedia.org/wiki/Code_point">Code Point</a>.</p> <p>In Elixir you can use a <code class="language-plaintext highlighter-rouge">?</code> in front of a character literal to reveal its code point:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; ?a
97
iex&gt; ?Å‚
322
</pre></div> <p>Note that most Unicode code charts will refer to a code point by its hexadecimal (hex) representation, e.g. <code class="language-plaintext highlighter-rouge">97</code> translates to <code class="language-plaintext highlighter-rouge">0061</code> in hex, and we can represent any Unicode character in an Elixir string by using the <code class="language-plaintext highlighter-rouge">\uXXXX</code> notation and the hex representation of its code point number:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; "\u0061" == "a"
true
iex&gt; 0x0061 = 97 = ?a
97
</pre></div> <p>The hex representation will also help you look up information about a code point, e.g. <a href="https://codepoints.net/U+0061">https://codepoints.net/U+0061</a> has a data sheet all about the lower case <code class="language-plaintext highlighter-rouge">a</code>, a.k.a. code point 97.</p> <h2 id="utf-8-and-encodings">UTF-8 and Encodings</h2> <p>Now that we understand what the Unicode standard is and what code points are, we can finally talk about encodings. Whereas the code point is <strong>what</strong> we store, an encoding deals with <strong>how</strong> we store it: encoding is an implementation. In other words, we need a mechanism to convert the code point numbers into bytes so they can be stored in memory, written to disk, etc.</p> <p>Elixir uses UTF-8 to encode its strings, which means that code points are encoded as a series of 8-bit bytes. UTF-8 is a <strong>variable width</strong> character encoding that uses one to four bytes to store each code point. It is capable of encoding all valid Unicode code points. Letâ€™s see an example:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; string = "heÌllo"
"heÌllo"
iex&gt; String.length(string)
5
iex&gt; byte_size(string)
6
</pre></div> <p>Although the string above has 5 characters, it uses 6 bytes, as two bytes are used to represent the character <code class="language-plaintext highlighter-rouge">Ã©</code>.</p> <blockquote> <p>Note: if you are running on Windows, there is a chance your terminal does not use UTF-8 by default. You can change the encoding of your current session by running <code class="language-plaintext highlighter-rouge">chcp 65001</code> before entering <code class="language-plaintext highlighter-rouge">iex</code> (<code class="language-plaintext highlighter-rouge">iex.bat</code>).</p> </blockquote> <p>Besides defining characters, UTF-8 also provides a notion of graphemes. Graphemes may consist of multiple characters that are often perceived as one. For example, the <a href="https://emojipedia.org/woman-firefighter/">woman firefighter emoji</a> is represented as the combination of three characters: the woman emoji (ğŸ‘©), a hidden zero-width joiner, and the fire engine emoji (ğŸš’):</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; String.codepoints("ğŸ‘©â€ğŸš’")
["ğŸ‘©", "â€", "ğŸš’"]
iex&gt; String.graphemes("ğŸ‘©â€ğŸš’")
["ğŸ‘©â€ğŸš’"]
</pre></div> <p>However, Elixir is smart enough to know they are seen as a single character, and therefore the length is still one:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; String.length("ğŸ‘©â€ğŸš’")
1
</pre></div> <blockquote> <p>Note: if you canâ€™t see the emoji above in your terminal, you need to make sure your terminal supports emoji and that you are using a font that can render them.</p> </blockquote> <p>Although these rules may sound complicated, UTF-8 encoded documents are everywhere. This page itself is encoded in UTF-8. The encoding information is given to your browser which then knows how to render all of the bytes, characters, and graphemes accordingly.</p> <p>If you want to see the exact bytes that a string would be stored in a file, a common trick is to concatenate the null byte <code class="language-plaintext highlighter-rouge">&lt;&lt;0&gt;&gt;</code> to it:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; "heÅ‚Å‚o" &lt;&gt; &lt;&lt;0&gt;&gt;
&lt;&lt;104, 101, 197, 130, 197, 130, 111, 0&gt;&gt;
</pre></div> <p>Alternatively, you can view a stringâ€™s binary representation by using <a href="https://hexdocs.pm/elixir/IO.html#inspect/2">IO.inspect/2</a>:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; IO.inspect("heÅ‚Å‚o", binaries: :as_binaries)
&lt;&lt;104, 101, 197, 130, 197, 130, 111&gt;&gt;
</pre></div> <p>We are getting a little bit ahead of ourselves. Letâ€™s talk about bitstrings to learn about what exactly the <code class="language-plaintext highlighter-rouge">&lt;&lt;&gt;&gt;</code> constructor means.</p> <h2 id="bitstrings">Bitstrings</h2> <p>Although we have covered code points and UTF-8 encoding, we still need to go a bit deeper into how exactly we store the encoded bytes, and this is where we introduce the <strong>bitstring</strong>. A bitstring is a fundamental data type in Elixir, denoted with the <code class="language-plaintext highlighter-rouge">&lt;&lt;&gt;&gt;</code> syntax. <strong>A bitstring is a contiguous sequence of bits in memory.</strong></p> <p>A complete reference about the binary / bitstring constructor <code class="language-plaintext highlighter-rouge">&lt;&lt;&gt;&gt;</code> can be found <a href="https://hexdocs.pm/elixir/Kernel.SpecialForms.html#%3C%3C%3E%3E/1">in the Elixir documentation</a>.</p> <p>By default, 8 bits (i.e. 1 byte) is used to store each number in a bitstring, but you can manually specify the number of bits via a <code class="language-plaintext highlighter-rouge">::n</code> modifier to denote the size in <code class="language-plaintext highlighter-rouge">n</code> bits, or you can use the more verbose declaration <code class="language-plaintext highlighter-rouge">::size(n)</code>:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; &lt;&lt;42&gt;&gt; == &lt;&lt;42::8&gt;&gt;
true
iex&gt; &lt;&lt;3::4&gt;&gt;
&lt;&lt;3::size(4)&gt;&gt;
</pre></div> <p>For example, the decimal number <code class="language-plaintext highlighter-rouge">3</code> when represented with 4 bits in base 2 would be <code class="language-plaintext highlighter-rouge">0011</code>, which is equivalent to the values <code class="language-plaintext highlighter-rouge">0</code>, <code class="language-plaintext highlighter-rouge">0</code>, <code class="language-plaintext highlighter-rouge">1</code>, <code class="language-plaintext highlighter-rouge">1</code>, each stored using 1 bit:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; &lt;&lt;0::1, 0::1, 1::1, 1::1&gt;&gt; == &lt;&lt;3::4&gt;&gt;
true
</pre></div> <p>Any value that exceeds what can be stored by the number of bits provisioned is truncated:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; &lt;&lt;1&gt;&gt; == &lt;&lt;257&gt;&gt;
true
</pre></div> <p>Here, 257 in base 2 would be represented as <code class="language-plaintext highlighter-rouge">100000001</code>, but since we have reserved only 8 bits for its representation (by default), the left-most bit is ignored and the value becomes truncated to <code class="language-plaintext highlighter-rouge">00000001</code>, or simply <code class="language-plaintext highlighter-rouge">1</code> in decimal.</p> <h2 id="binaries">Binaries</h2> <p><strong>A binary is a bitstring where the number of bits is divisible by 8.</strong> That means that every binary is a bitstring, but not every bitstring is a binary. We can use the <code class="language-plaintext highlighter-rouge">is_bitstring/1</code> and <code class="language-plaintext highlighter-rouge">is_binary/1</code> functions to demonstrate this.</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; is_bitstring(&lt;&lt;3::4&gt;&gt;)
true
iex&gt; is_binary(&lt;&lt;3::4&gt;&gt;)
false
iex&gt; is_bitstring(&lt;&lt;0, 255, 42&gt;&gt;)
true
iex&gt; is_binary(&lt;&lt;0, 255, 42&gt;&gt;)
true
iex&gt; is_binary(&lt;&lt;42::16&gt;&gt;)
true
</pre></div> <p>We can pattern match on binaries / bitstrings:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; &lt;&lt;0, 1, x&gt;&gt; = &lt;&lt;0, 1, 2&gt;&gt;
&lt;&lt;0, 1, 2&gt;&gt;
iex&gt; x
2
iex&gt; &lt;&lt;0, 1, x&gt;&gt; = &lt;&lt;0, 1, 2, 3&gt;&gt;
** (MatchError) no match of right hand side value: &lt;&lt;0, 1, 2, 3&gt;&gt;
</pre></div> <p>Note that unless you explicitly use <code class="language-plaintext highlighter-rouge">::</code> modifiers, each entry in the binary pattern is expected to match a single byte (exactly 8 bits). If we want to match on a binary of unknown size, we can use the <code class="language-plaintext highlighter-rouge">binary</code> modifier at the end of the pattern:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; &lt;&lt;0, 1, x::binary&gt;&gt; = &lt;&lt;0, 1, 2, 3&gt;&gt;
&lt;&lt;0, 1, 2, 3&gt;&gt;
iex&gt; x
&lt;&lt;2, 3&gt;&gt;
</pre></div> <p>There are a couple other modifiers that can be useful when doing pattern matches on binaries. The <code class="language-plaintext highlighter-rouge">binary-size(n)</code> modifier will match <code class="language-plaintext highlighter-rouge">n</code> bytes in a binary:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; &lt;&lt;head::binary-size(2), rest::binary&gt;&gt; = &lt;&lt;0, 1, 2, 3&gt;&gt;
&lt;&lt;0, 1, 2, 3&gt;&gt;
iex&gt; head
&lt;&lt;0, 1&gt;&gt;
iex&gt; rest
&lt;&lt;2, 3&gt;&gt;
</pre></div> <p><strong>A string is a UTF-8 encoded binary</strong>, where the code point for each character is encoded using 1 to 4 bytes. Thus every string is a binary, but due to the UTF-8 standard encoding rules, not every binary is a valid string.</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; is_binary("hello")
true
iex&gt; is_binary(&lt;&lt;239, 191, 19&gt;&gt;)
true
iex&gt; String.valid?(&lt;&lt;239, 191, 19&gt;&gt;)
false
</pre></div> <p>The string concatenation operator <code class="language-plaintext highlighter-rouge">&lt;&gt;</code> is actually a binary concatenation operator:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; "a" &lt;&gt; "ha"
"aha"
iex&gt; &lt;&lt;0, 1&gt;&gt; &lt;&gt; &lt;&lt;2, 3&gt;&gt;
&lt;&lt;0, 1, 2, 3&gt;&gt;
</pre></div> <p>Given that strings are binaries, we can also pattern match on strings:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; &lt;&lt;head, rest::binary&gt;&gt; = "banana"
"banana"
iex&gt; head == ?b
true
iex&gt; rest
"anana"
</pre></div> <p>However, remember that binary pattern matching works on <em>bytes</em>, so matching on the string like â€œÃ¼berâ€ with multibyte characters wonâ€™t match on the <em>character</em>, it will match on the <em>first byte of that character</em>:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; "Ã¼" &lt;&gt; &lt;&lt;0&gt;&gt;
&lt;&lt;195, 188, 0&gt;&gt;
iex&gt; &lt;&lt;x, rest::binary&gt;&gt; = "Ã¼ber"
"Ã¼ber"
iex&gt; x == ?Ã¼
false
iex&gt; rest
&lt;&lt;188, 98, 101, 114&gt;&gt;
</pre></div> <p>Above, <code class="language-plaintext highlighter-rouge">x</code> matched on only the first byte of the multibyte <code class="language-plaintext highlighter-rouge">Ã¼</code> character.</p> <p>Therefore, when pattern matching on strings, it is important to use the <code class="language-plaintext highlighter-rouge">utf8</code> modifier:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; &lt;&lt;x::utf8, rest::binary&gt;&gt; = "Ã¼ber"
"Ã¼ber"
iex&gt; x == ?Ã¼
true
iex&gt; rest
"ber"
</pre></div> <h2 id="charlists">Charlists</h2> <p>Our tour of our bitstrings, binaries, and strings is nearly complete, but we have one more data type to explain: the charlist.</p> <p><strong>A charlist is a list of integers where all the integers are valid code points.</strong> In practice, you will not come across them often, only in specific scenarios such as interfacing with older Erlang libraries that do not accept binaries as arguments.</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; ~c"hello"
~c"hello"
iex&gt; [?h, ?e, ?l, ?l, ?o]
~c"hello"
</pre></div> <p>The <code class="language-plaintext highlighter-rouge">~c</code> sigil (weâ€™ll cover sigils later in the <a href="sigils.html">â€œSigilsâ€</a> section) indicates the fact that we are dealing with a charlist and not a regular string.</p> <p>Whereas double-quotes creates strings, single-quotes create charlist literals. Charlists used to be represented with single quotes in Elixir &lt;1.15:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; 'hello'
~c"hello"
</pre></div> <p>The key takeaway is that <code class="language-plaintext highlighter-rouge">"hello"</code> is not the same as <code class="language-plaintext highlighter-rouge">'hello'</code>. Generally speaking, <strong>double-quotes must always be used to represent strings in Elixir</strong>. In any case, letâ€™s learn how charlists work.</p> <p>Instead of containing bytes, a charlist contains integer code points. However, the list is only printed in single-quotes if all code points are within the ASCII range:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; ~c"heÅ‚Å‚o"
[104, 101, 322, 322, 111]
iex&gt; is_list(~c"heÅ‚Å‚o")
true
</pre></div> <p>Interpreting integers as code points may lead to some surprising behavior. For example, if you are storing a list of integers that happen to range between 0 and 127, by default IEx will interpret this as a charlist and it will display the corresponding ASCII characters.</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; heartbeats_per_minute = [99, 97, 116]
~c"cat"
</pre></div> <p>You can convert a charlist to a string and back by using the <code class="language-plaintext highlighter-rouge">to_string/1</code> and <code class="language-plaintext highlighter-rouge">to_charlist/1</code> functions:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; to_charlist("heÅ‚Å‚o")
[104, 101, 322, 322, 111]
iex&gt; to_string(~c"heÅ‚Å‚o")
"heÅ‚Å‚o"
iex&gt; to_string(:hello)
"hello"
iex&gt; to_string(1)
"1"
</pre></div> <p>Note that those functions are polymorphic - not only do they convert charlists to strings, they also operate on integers, atoms, and so on.</p> <p>String (binary) concatenation uses the <code class="language-plaintext highlighter-rouge">&lt;&gt;</code> operator but charlists, being lists, use the list concatenation operator <code class="language-plaintext highlighter-rouge">++</code>:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; ~c"this " &lt;&gt; ~c"fails"
** (ArgumentError) expected binary argument in &lt;&gt; operator but got: ~c"this "
    (elixir) lib/kernel.ex:1821: Kernel.wrap_concatenation/3
    (elixir) lib/kernel.ex:1808: Kernel.extract_concatenations/2
    (elixir) expanding macro: Kernel.&lt;&gt;/2
    iex:1: (file)
iex&gt; ~c"this " ++ ~c"works"
~c"this works"
iex&gt; "he" ++ "llo"
** (ArgumentError) argument error
    :erlang.++("he", "llo")
iex&gt; "he" &lt;&gt; "llo"
"hello"
</pre></div> <p>With binaries, strings, and charlists out of the way, it is time to talk about key-value data structures.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://elixir-lang.org/getting-started/binaries-strings-and-char-lists.html" class="_attribution-link">https://elixir-lang.org/getting-started/binaries-strings-and-char-lists.html</a>
  </p>
</div>
