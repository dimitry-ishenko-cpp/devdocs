<div class="getting-started-title"> <small>Getting Started</small> <h1>Erlang libraries</h1> </div>  <p>Elixir provides excellent interoperability with Erlang libraries. In fact, Elixir discourages simply wrapping Erlang libraries in favor of directly interfacing with Erlang code. In this section, we will present some of the most common and useful Erlang functionality that is not found in Elixir.</p> <p>As you grow more proficient in Elixir, you may want to explore the Erlang <a href="http://www.erlang.org/doc/apps/stdlib/index.html">STDLIB Reference Manual</a> in more detail.</p> <h2 id="the-binary-module">The binary module</h2> <p>The built-in Elixir String module handles binaries that are UTF-8 encoded. <a href="http://www.erlang.org/doc/man/binary.html">The binary module</a> is useful when you are dealing with binary data that is not necessarily UTF-8 encoded.</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; String.to_charlist "Ø"
[216]
iex&gt; :binary.bin_to_list "Ø"
[195, 152]
</pre></div> <p>The above example shows the difference; the <code class="language-plaintext highlighter-rouge">String</code> module returns Unicode codepoints, while <code class="language-plaintext highlighter-rouge">:binary</code> deals with raw data bytes.</p> <h2 id="formatted-text-output">Formatted text output</h2> <p>Elixir does not contain a function similar to <code class="language-plaintext highlighter-rouge">printf</code> found in C and other languages. Luckily, the Erlang standard library functions <code class="language-plaintext highlighter-rouge">:io.format/2</code> and <code class="language-plaintext highlighter-rouge">:io_lib.format/2</code> may be used. The first formats to terminal output, while the second formats to an iolist. The format specifiers differ from <code class="language-plaintext highlighter-rouge">printf</code>, <a href="http://www.erlang.org/doc/man/io.html#format-1">refer to the Erlang documentation for details</a>.</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; :io.format("Pi is approximately given by:~10.3f~n", [:math.pi])
Pi is approximately given by:     3.142
:ok
iex&gt; to_string :io_lib.format("Pi is approximately given by:~10.3f~n", [:math.pi])
"Pi is approximately given by:     3.142\n"
</pre></div> <p>Also note that Erlang’s formatting functions require special attention to Unicode handling.</p> <h2 id="the-crypto-module">The crypto module</h2> <p><a href="http://www.erlang.org/doc/man/crypto.html">The crypto module</a> contains hashing functions, digital signatures, encryption and more:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; Base.encode16(:crypto.hash(:sha256, "Elixir"))
"3315715A7A3AD57428298676C5AE465DADA38D951BDFAC9348A8A31E9C7401CB"
</pre></div> <p>The <code class="language-plaintext highlighter-rouge">:crypto</code> module is part of the <code class="language-plaintext highlighter-rouge">:crypto</code> application that ships with Erlang. This means you must list the <code class="language-plaintext highlighter-rouge">:crypto</code> application as an additional application in your project configuration. To do this, edit your <code class="language-plaintext highlighter-rouge">mix.exs</code> file to include:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">def application do
  [extra_applications: [:crypto]]
end
</pre></div> <p>Any module that is not part of the <code class="language-plaintext highlighter-rouge">:kernel</code> or <code class="language-plaintext highlighter-rouge">:stdlib</code> Erlang applications must have their application explicitly listed in your <code class="language-plaintext highlighter-rouge">mix.exs</code>. You can find the application name of any Erlang module in the Erlang documentation, immediately below the Erlang logo in the sidebar.</p> <h2 id="the-digraph-module">The digraph module</h2> <p><a href="http://www.erlang.org/doc/man/digraph.html">The digraph module</a> (as well as <a href="http://www.erlang.org/doc/man/digraph_utils.html">digraph_utils</a>) contains functions for dealing with directed graphs built of vertices and edges. After constructing the graph, the algorithms in there will help find, for instance, the shortest path between two vertices, or loops in the graph.</p> <p>Given three vertices, find the shortest path from the first to the last.</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; digraph = :digraph.new()
iex&gt; coords = [{0.0, 0.0}, {1.0, 0.0}, {1.0, 1.0}]
iex&gt; [v0, v1, v2] = (for c &lt;- coords, do: :digraph.add_vertex(digraph, c))
iex&gt; :digraph.add_edge(digraph, v0, v1)
iex&gt; :digraph.add_edge(digraph, v1, v2)
iex&gt; :digraph.get_short_path(digraph, v0, v2)
[{0.0, 0.0}, {1.0, 0.0}, {1.0, 1.0}]
</pre></div> <p>Note that the functions in <code class="language-plaintext highlighter-rouge">:digraph</code> alter the graph structure in-place, this is possible because they are implemented as ETS tables, explained next.</p> <h2 id="erlang-term-storage">Erlang Term Storage</h2> <p>The modules <a href="http://www.erlang.org/doc/man/ets.html"><code class="language-plaintext highlighter-rouge">ets</code></a> and <a href="http://www.erlang.org/doc/man/dets.html"><code class="language-plaintext highlighter-rouge">dets</code></a> handle storage of large data structures in memory or on disk respectively.</p> <p>ETS lets you create a table containing tuples. By default, ETS tables are protected, which means only the owner process may write to the table but any other process can read. ETS has some functionality to allow a table to be used as a simple database, a key-value store or as a cache mechanism.</p> <p>The functions in the <code class="language-plaintext highlighter-rouge">ets</code> module will modify the state of the table as a side-effect.</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; table = :ets.new(:ets_test, [])
# Store as tuples with {name, population}
iex&gt; :ets.insert(table, {"China", 1_374_000_000})
iex&gt; :ets.insert(table, {"India", 1_284_000_000})
iex&gt; :ets.insert(table, {"USA", 322_000_000})
iex&gt; :ets.i(table)
&lt;1   &gt; {&lt;&lt;"India"&gt;&gt;,1284000000}
&lt;2   &gt; {&lt;&lt;"USA"&gt;&gt;,322000000}
&lt;3   &gt; {&lt;&lt;"China"&gt;&gt;,1374000000}
</pre></div> <h2 id="the-math-module">The math module</h2> <p><a href="http://www.erlang.org/doc/man/math.html">The <code class="language-plaintext highlighter-rouge">math</code> module</a> contains common mathematical operations covering trigonometry, exponential, and logarithmic functions.</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; angle_45_deg = :math.pi() * 45.0 / 180.0
iex&gt; :math.sin(angle_45_deg)
0.7071067811865475
iex&gt; :math.exp(55.0)
7.694785265142018e23
iex&gt; :math.log(7.694785265142018e23)
55.0
</pre></div> <h2 id="the-queue-module">The queue module</h2> <p>The <a href="http://www.erlang.org/doc/man/queue.html"><code class="language-plaintext highlighter-rouge">queue</code> is a data structure</a> that implements (double-ended) FIFO (first-in first-out) queues efficiently:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; q = :queue.new
iex&gt; q = :queue.in("A", q)
iex&gt; q = :queue.in("B", q)
iex&gt; {value, q} = :queue.out(q)
iex&gt; value
{:value, "A"}
iex&gt; {value, q} = :queue.out(q)
iex&gt; value
{:value, "B"}
iex&gt; {value, q} = :queue.out(q)
iex&gt; value
:empty
</pre></div> <h2 id="the-rand-module">The rand module</h2> <p><a href="http://www.erlang.org/doc/man/rand.html"><code class="language-plaintext highlighter-rouge">rand</code> has functions</a> for returning random values and setting the random seed.</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; :rand.uniform()
0.8175669086010815
iex&gt; _ = :rand.seed(:exs1024, {123, 123534, 345345})
iex&gt; :rand.uniform()
0.5820506340260994
iex&gt; :rand.uniform(6)
6
</pre></div> <h2 id="the-zip-and-zlib-modules">The zip and zlib modules</h2> <p><a href="http://www.erlang.org/doc/man/zip.html">The <code class="language-plaintext highlighter-rouge">zip</code> module</a> lets you read and write ZIP files to and from disk or memory, as well as extracting file information.</p> <p>This code counts the number of files in a ZIP file:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; :zip.foldl(fn _, _, _, acc -&gt; acc + 1 end, 0, :binary.bin_to_list("file.zip"))
{:ok, 633}
</pre></div> <p><a href="http://www.erlang.org/doc/man/zlib.html">The <code class="language-plaintext highlighter-rouge">zlib</code> module</a> deals with data compression in zlib format, as found in the <code class="language-plaintext highlighter-rouge">gzip</code> command.</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; song = "
...&gt; Mary had a little lamb,
...&gt; His fleece was white as snow,
...&gt; And everywhere that Mary went,
...&gt; The lamb was sure to go."
iex&gt; compressed = :zlib.compress(song)
iex&gt; byte_size song
110
iex&gt; byte_size compressed
99
iex&gt; :zlib.uncompress(compressed)
"\nMary had a little lamb,\nHis fleece was white as snow,\nAnd everywhere that Mary went,\nThe lamb was sure to go."
</pre></div> <p>Now let’s take a look at existing Elixir (and Erlang) libraries you might use while debugging.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://elixir-lang.org/getting-started/erlang-libraries.html" class="_attribution-link">https://elixir-lang.org/getting-started/erlang-libraries.html</a>
  </p>
</div>
