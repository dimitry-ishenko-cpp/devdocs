<div class="getting-started-title"> <small>Getting Started</small> <h1>Keyword lists and maps</h1> </div>  <p>Now let’s talk about associative data structures. Associative data structures are able to associate a key to a certain value. Different languages call these different names like dictionaries, hashes, associative arrays, etc.</p> <p>In Elixir, we have two main associative data structures: keyword lists and maps. It’s time to learn more about them!</p> <h2 id="keyword-lists">Keyword lists</h2> <p>Keyword lists are a data-structure used to pass options to functions. Imagine you want to split a string of numbers. We can use <code class="language-plaintext highlighter-rouge">String.split/2</code>:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; String.split("1 2 3", " ")
["1", "2", "3"]
</pre></div> <p>However, what happens if there is an additional space between the numbers:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; String.split("1  2  3", " ")
["1", "", "2", "", "3"]
</pre></div> <p>As you can see, there are now empty strings in our results. Luckily, the <code class="language-plaintext highlighter-rouge">String.split/3</code> function allows the <code class="language-plaintext highlighter-rouge">trim</code> option to be set to true:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; String.split("1  2  3", " ", [trim: true])
["1", "2", "3"]
</pre></div> <p><code class="language-plaintext highlighter-rouge">[trim: true]</code> is a keyword list. Furthermore, when a keyword list is the last argument of a function, we can skip the brackets and write:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; String.split("1  2  3", " ", trim: true)
["1", "2", "3"]
</pre></div> <p>As the name implies, keyword lists are simply lists. In particular, they are lists consisting of 2-item tuples where the first element (the key) is an atom and the second element can be any value. Both representations are the same:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; [{:trim, true}] == [trim: true]
true
</pre></div> <p>Since keyword lists are lists, we can use all operations available to lists. For example, we can use <code class="language-plaintext highlighter-rouge">++</code> to add new values to a keyword list:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; list = [a: 1, b: 2]
[a: 1, b: 2]
iex&gt; list ++ [c: 3]
[a: 1, b: 2, c: 3]
iex&gt; [a: 0] ++ list
[a: 0, a: 1, b: 2]
</pre></div> <p>You can read the value of a keyword list using the brackets syntax:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; list[:a]
1
iex&gt; list[:b]
2
</pre></div> <p>In case of duplicate keys, values added to the front are the ones fetched:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; new_list = [a: 0] ++ list
[a: 0, a: 1, b: 2]
iex&gt; new_list[:a]
0
</pre></div> <p>Keyword lists are important because they have three special characteristics:</p> <ul> <li>Keys must be atoms.</li> <li>Keys are ordered, as specified by the developer.</li> <li>Keys can be given more than once.</li> </ul> <p>For example, <a href="https://github.com/elixir-lang/ecto">the Ecto library</a> makes use of these features to provide an elegant DSL for writing database queries:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">query =
  from w in Weather,
    where: w.prcp &gt; 0,
    where: w.temp &lt; 20,
    select: w
</pre></div> <p>Although we can pattern match on keyword lists, it is rarely done in practice since pattern matching on lists requires the number of items and their order to match:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; [a: a] = [a: 1]
[a: 1]
iex&gt; a
1
iex&gt; [a: a] = [a: 1, b: 2]
** (MatchError) no match of right hand side value: [a: 1, b: 2]
iex&gt; [b: b, a: a] = [a: 1, b: 2]
** (MatchError) no match of right hand side value: [a: 1, b: 2]
</pre></div> <p>In order to manipulate keyword lists, Elixir provides <a href="https://hexdocs.pm/elixir/Keyword.html">the <code class="language-plaintext highlighter-rouge">Keyword</code> module</a>. Remember, though, keyword lists are simply lists, and as such they provide the same linear performance characteristics as them: the longer the list, the longer it will take to find a key, to count the number of items, and so on. For this reason, keyword lists are used in Elixir mainly for passing optional values. If you need to store many items or guarantee one-key associates with at maximum one-value, you should use maps instead.</p> <h3 id="do-blocks-and-keywords">
<code class="language-plaintext highlighter-rouge">do</code>-blocks and keywords</h3> <p>As we have seen, keywords are mostly used in the language to pass optional values. In fact, we have used keywords before in this guide. For example, we have seen:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; if true do
...&gt;   "This will be seen"
...&gt; else
...&gt;   "This won't"
...&gt; end
"This will be seen"
</pre></div> <p>It happens that <code class="language-plaintext highlighter-rouge">do</code> blocks are nothing more than a syntax convenience on top of keywords. We can rewrite the above to:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; if true, do: "This will be seen", else: "This won't"
"This will be seen"
</pre></div> <p>Pay close attention to both syntaxes. In the keyword list format, we separate each key-value pair with commas, and each key is followed by <code class="language-plaintext highlighter-rouge">:</code>. In the <code class="language-plaintext highlighter-rouge">do</code>-blocks, we get rid of the colons, the commas, and separate each keyword by a newline. They are useful exactly because they remove the verbosity when writing blocks of code. Most of the time, you will use the block syntax, but it is good to know they are equivalent.</p> <p>Note that only a handful of keyword lists can be converted to blocks: <code class="language-plaintext highlighter-rouge">do</code>, <code class="language-plaintext highlighter-rouge">else</code>, <code class="language-plaintext highlighter-rouge">catch</code>, <code class="language-plaintext highlighter-rouge">rescue</code>, and <code class="language-plaintext highlighter-rouge">after</code>. Those are all the keywords used by Elixir control-flow constructs. We have already learned some of them and we will learn others in the future.</p> <p>With this out of the way, let’s see how we can work with nested data structures.</p> <h2 id="maps-as-key-value-pairs">Maps as key-value pairs</h2> <p>Whenever you need to store key-value pairs, maps are the “go to” data structure in Elixir. A map is created using the <code class="language-plaintext highlighter-rouge">%{}</code> syntax:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; map = %{:a =&gt; 1, 2 =&gt; :b}
%{2 =&gt; :b, :a =&gt; 1}
iex&gt; map[:a]
1
iex&gt; map[2]
:b
iex&gt; map[:c]
nil
</pre></div> <p>Compared to keyword lists, we can already see two differences:</p> <ul> <li>Maps allow any value as a key.</li> <li>Maps’ keys do not follow any ordering.</li> </ul> <p>In contrast to keyword lists, maps are very useful with pattern matching. When a map is used in a pattern, it will always match on a subset of the given value:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; %{} = %{:a =&gt; 1, 2 =&gt; :b}
%{2 =&gt; :b, :a =&gt; 1}
iex&gt; %{:a =&gt; a} = %{:a =&gt; 1, 2 =&gt; :b}
%{2 =&gt; :b, :a =&gt; 1}
iex&gt; a
1
iex&gt; %{:c =&gt; c} = %{:a =&gt; 1, 2 =&gt; :b}
** (MatchError) no match of right hand side value: %{2 =&gt; :b, :a =&gt; 1}
</pre></div> <p>As shown above, a map matches as long as the keys in the pattern exist in the given map. Therefore, an empty map matches all maps.</p> <p><a href="https://hexdocs.pm/elixir/Map.html">The <code class="language-plaintext highlighter-rouge">Map</code> module</a> provides a very similar API to the <code class="language-plaintext highlighter-rouge">Keyword</code> module with convenience functions to add, remove, and update maps keys:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; Map.get(%{:a =&gt; 1, 2 =&gt; :b}, :a)
1
iex&gt; Map.put(%{:a =&gt; 1, 2 =&gt; :b}, :c, 3)
%{2 =&gt; :b, :a =&gt; 1, :c =&gt; 3}
iex&gt; Map.to_list(%{:a =&gt; 1, 2 =&gt; :b})
[{2, :b}, {:a, 1}]
</pre></div> <h2 id="maps-of-fixed-keys">Maps of fixed keys</h2> <p>In the previous section, we have used maps as a key-value data structure where keys can be added or removed at any time. However, it is also common to create maps with a pre-defined set of keys. Their values may be updated, but new keys are never added nor removed. This is useful when we know the shape of the data we are working with and, if we get a different key, it likely means a mistake was done elsewhere.</p> <p>We define such maps using the same syntax as in the previous section, except that all keys must be atoms:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; map = %{:name =&gt; "John", :age =&gt; 23}
%{name: "John", age: 23}
</pre></div> <p>As you can see from the printed result above, Elixir also allows you to write maps of atom keys using the same <code class="language-plaintext highlighter-rouge">key: value</code> syntax as keyword lists.</p> <p>When the keys are atoms, we can also also access them using the <code class="language-plaintext highlighter-rouge">map.key</code> syntax:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; map = %{name: "John", age: 23}
%{name: "John", age: 23}

iex&gt; map.name
"John"
iex&gt; map.agee
** (KeyError) key :agee not found in: %{name: "John", age: 23}
</pre></div> <p>This syntax has one large benefit in that it raises if the key does not exist in the map. Sometimes the Elixir compiler may even warn too. This makes it useful to get quick feedback and spot bugs and typos early on. This is also the syntax used to power another Elixir feature called “Structs”.</p> <p>Elixir developers typically prefer to use the <code class="language-plaintext highlighter-rouge">map.key</code> syntax and pattern matching instead of the functions in the <code class="language-plaintext highlighter-rouge">Map</code> module when working with maps because they lead to an assertive style of programming. <a href="https://dashbit.co/blog/writing-assertive-code-with-elixir">This blog post by José Valim</a> provides insight and examples on how you get more concise and faster software by writing assertive code in Elixir.</p> <h2 id="nested-data-structures">Nested data structures</h2> <p>Often we will have maps inside maps, or even keywords lists inside maps, and so forth. Elixir provides conveniences for manipulating nested data structures via the <code class="language-plaintext highlighter-rouge">put_in/2</code>, <code class="language-plaintext highlighter-rouge">update_in/2</code> and other macros giving the same conveniences you would find in imperative languages while keeping the immutable properties of the language.</p> <p>Imagine you have the following structure:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; users = [
  john: %{name: "John", age: 27, languages: ["Erlang", "Ruby", "Elixir"]},
  mary: %{name: "Mary", age: 29, languages: ["Elixir", "F#", "Clojure"]}
]
[
  john: %{age: 27, languages: ["Erlang", "Ruby", "Elixir"], name: "John"},
  mary: %{age: 29, languages: ["Elixir", "F#", "Clojure"], name: "Mary"}
]
</pre></div> <p>We have a keyword list of users where each value is a map containing the name, age and a list of programming languages each user likes. If we wanted to access the age for john, we could write:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; users[:john].age
27
</pre></div> <p>It happens we can also use this same syntax for updating the value:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; users = put_in users[:john].age, 31
[
  john: %{age: 31, languages: ["Erlang", "Ruby", "Elixir"], name: "John"},
  mary: %{age: 29, languages: ["Elixir", "F#", "Clojure"], name: "Mary"}
]
</pre></div> <p>The <code class="language-plaintext highlighter-rouge">update_in/2</code> macro is similar but allows us to pass a function that controls how the value changes. For example, let’s remove “Clojure” from Mary’s list of languages:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; users = update_in users[:mary].languages, fn languages -&gt; List.delete(languages, "Clojure") end
[
  john: %{age: 31, languages: ["Erlang", "Ruby", "Elixir"], name: "John"},
  mary: %{age: 29, languages: ["Elixir", "F#"], name: "Mary"}
]
</pre></div> <p>There is more to learn about <code class="language-plaintext highlighter-rouge">put_in/2</code> and <code class="language-plaintext highlighter-rouge">update_in/2</code>, including the <code class="language-plaintext highlighter-rouge">get_and_update_in/2</code> that allows us to extract a value and update the data structure at once. There are also <code class="language-plaintext highlighter-rouge">put_in/3</code>, <code class="language-plaintext highlighter-rouge">update_in/3</code> and <code class="language-plaintext highlighter-rouge">get_and_update_in/3</code> which allow dynamic access into the data structure. <a href="https://hexdocs.pm/elixir/Kernel.html">Check their respective documentation in the <code class="language-plaintext highlighter-rouge">Kernel</code> module for more information</a>. Between the Access module and pattern matching, Elixir developers have a rich set of tools for manipulating nested and complex data structures.</p> <h2 id="summary">Summary</h2> <p>This concludes our introduction to associative data structures in Elixir. As a summary, you should:</p> <ul> <li> <p>Use keyword lists for passing optional values to functions</p> </li> <li> <p>Use maps for general key-value data structures and when working with known data (with fixed keys)</p> </li> </ul> <p>Now we can move on to talk about modules and functions.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://elixir-lang.org/getting-started/keywords-and-maps.html" class="_attribution-link">https://elixir-lang.org/getting-started/keywords-and-maps.html</a>
  </p>
</div>
