<div class="getting-started-title"> <small>Getting Started</small> <h1>Sigils</h1> </div>  <p>We have already learned that Elixir provides double-quoted strings and single-quoted char lists. However, this only covers the surface of structures that have textual representation in the language. Atoms, for example, are mostly created via the <code class="language-plaintext highlighter-rouge">:atom</code> representation.</p> <p>One of Elixir’s goals is extensibility: developers should be able to extend the language to fit any particular domain. Computer science has become such a wide field that it is impossible for a language to tackle all aspects of it as part of its core. Instead, Elixir aims to make itself extensible so developers, companies, and communities can extend the language to their relevant domains.</p> <p>In this chapter, we are going to explore sigils, which are one of the mechanisms provided by the language for working with textual representations. Sigils start with the tilde (<code class="language-plaintext highlighter-rouge">~</code>) character which is followed by a letter (which identifies the sigil) and then a delimiter; optionally, modifiers can be added after the final delimiter.</p> <h2 id="regular-expressions">Regular expressions</h2> <p>The most common sigil in Elixir is <code class="language-plaintext highlighter-rouge">~r</code>, which is used to create <a href="https://en.wikipedia.org/wiki/Regular_Expressions">regular expressions</a>:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language=""># A regular expression that matches strings which contain "foo" or "bar":
iex&gt; regex = ~r/foo|bar/
~r/foo|bar/
iex&gt; "foo" =~ regex
true
iex&gt; "bat" =~ regex
false
</pre></div> <p>Elixir provides Perl-compatible regular expressions (regexes), as implemented by the <a href="http://www.pcre.org/">PCRE</a> library. Regexes also support modifiers. For example, the <code class="language-plaintext highlighter-rouge">i</code> modifier makes a regular expression case insensitive:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; "HELLO" =~ ~r/hello/
false
iex&gt; "HELLO" =~ ~r/hello/i
true
</pre></div> <p>Check out the <a href="https://hexdocs.pm/elixir/Regex.html"><code class="language-plaintext highlighter-rouge">Regex</code> module</a> for more information on other modifiers and the supported operations with regular expressions.</p> <p>So far, all examples have used <code class="language-plaintext highlighter-rouge">/</code> to delimit a regular expression. However, sigils support 8 different delimiters:</p> <div class="language-plaintext highlighter-rouge"><pre class="highlight" data-language="">~r/hello/
~r|hello|
~r"hello"
~r'hello'
~r(hello)
~r[hello]
~r{hello}
~r&lt;hello&gt;
</pre></div> <p>The reason behind supporting different delimiters is to provide a way to write literals without escaped delimiters. For example, a regular expression with forward slashes like <code class="language-plaintext highlighter-rouge">~r(^https?://)</code> reads arguably better than <code class="language-plaintext highlighter-rouge">~r/^https?:\/\//</code>. Similarly, if the regular expression has forward slashes and capturing groups (that use <code class="language-plaintext highlighter-rouge">()</code>), you may then choose double quotes instead of parentheses.</p> <h2 id="strings-char-lists-and-word-lists-sigils">Strings, char lists, and word lists sigils</h2> <p>Besides regular expressions, Elixir ships with three other sigils.</p> <h3 id="strings">Strings</h3> <p>The <code class="language-plaintext highlighter-rouge">~s</code> sigil is used to generate strings, like double quotes are. The <code class="language-plaintext highlighter-rouge">~s</code> sigil is useful when a string contains double quotes:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; ~s(this is a string with "double" quotes, not 'single' ones)
"this is a string with \"double\" quotes, not 'single' ones"
</pre></div> <h3 id="char-lists">Char lists</h3> <p>The <code class="language-plaintext highlighter-rouge">~c</code> sigil is the regular way to represent charlists.</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; [?c, ?a, ?t]
~c"cat"
iex&gt; ~c(this is a char list containing "double quotes")
~c"this is a char list containing \"double quotes\""
</pre></div> <h3 id="word-lists">Word lists</h3> <p>The <code class="language-plaintext highlighter-rouge">~w</code> sigil is used to generate lists of words (<em>words</em> are just regular strings). Inside the <code class="language-plaintext highlighter-rouge">~w</code> sigil, words are separated by whitespace.</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; ~w(foo bar bat)
["foo", "bar", "bat"]
</pre></div> <p>The <code class="language-plaintext highlighter-rouge">~w</code> sigil also accepts the <code class="language-plaintext highlighter-rouge">c</code>, <code class="language-plaintext highlighter-rouge">s</code> and <code class="language-plaintext highlighter-rouge">a</code> modifiers (for char lists, strings, and atoms, respectively), which specify the data type of the elements of the resulting list:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; ~w(foo bar bat)a
[:foo, :bar, :bat]
</pre></div> <h2 id="interpolation-and-escaping-in-string-sigils">Interpolation and escaping in string sigils</h2> <p>Elixir supports some sigil variants to deal with escaping characters and interpolation. In particular, uppercase letters sigils do not perform interpolation nor escaping. For example, although both <code class="language-plaintext highlighter-rouge">~s</code> and <code class="language-plaintext highlighter-rouge">~S</code> will return strings, the former allows escape codes and interpolation while the latter does not:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; ~s(String with escape codes \x26 #{"inter" &lt;&gt; "polation"})
"String with escape codes &amp; interpolation"
iex&gt; ~S(String without escape codes \x26 without #{interpolation})
"String without escape codes \\x26 without \#{interpolation}"
</pre></div> <p>The following escape codes can be used in strings and char lists:</p> <ul> <li>
<code class="language-plaintext highlighter-rouge">\\</code> – single backslash</li> <li>
<code class="language-plaintext highlighter-rouge">\a</code> – bell/alert</li> <li>
<code class="language-plaintext highlighter-rouge">\b</code> – backspace</li> <li>
<code class="language-plaintext highlighter-rouge">\d</code> - delete</li> <li>
<code class="language-plaintext highlighter-rouge">\e</code> - escape</li> <li>
<code class="language-plaintext highlighter-rouge">\f</code> - form feed</li> <li>
<code class="language-plaintext highlighter-rouge">\n</code> – newline</li> <li>
<code class="language-plaintext highlighter-rouge">\r</code> – carriage return</li> <li>
<code class="language-plaintext highlighter-rouge">\s</code> – space</li> <li>
<code class="language-plaintext highlighter-rouge">\t</code> – tab</li> <li>
<code class="language-plaintext highlighter-rouge">\v</code> – vertical tab</li> <li>
<code class="language-plaintext highlighter-rouge">\0</code> - null byte</li> <li>
<code class="language-plaintext highlighter-rouge">\xDD</code> - represents a single byte in hexadecimal (such as <code class="language-plaintext highlighter-rouge">\x13</code>)</li> <li>
<code class="language-plaintext highlighter-rouge">\uDDDD</code> and <code class="language-plaintext highlighter-rouge">\u{D...}</code> - represents a Unicode codepoint in hexadecimal (such as <code class="language-plaintext highlighter-rouge">\u{1F600}</code>)</li> </ul> <p>In addition to those, a double quote inside a double-quoted string needs to be escaped as <code class="language-plaintext highlighter-rouge">\"</code>, and, analogously, a single quote inside a single-quoted char list needs to be escaped as <code class="language-plaintext highlighter-rouge">\'</code>. Nevertheless, it is better style to change delimiters as seen above than to escape them.</p> <p>Sigils also support heredocs, that is, three double-quotes or single-quotes as separators:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; ~s"""
...&gt; this is
...&gt; a heredoc string
...&gt; """
</pre></div> <p>The most common use case for heredoc sigils is when writing documentation. For example, writing escape characters in the documentation would soon become error prone because of the need to double-escape some characters:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">@doc """
Converts double-quotes to single-quotes.

## Examples

    iex&gt; convert("\\\"foo\\\"")
    "'foo'"

"""
def convert(...)
</pre></div> <p>By using <code class="language-plaintext highlighter-rouge">~S</code>, this problem can be avoided altogether:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">@doc ~S"""
Converts double-quotes to single-quotes.

## Examples

    iex&gt; convert("\"foo\"")
    "'foo'"

"""
def convert(...)
</pre></div> <h2 id="calendar-sigils">Calendar sigils</h2> <p>Elixir offers several sigils to deal with various flavors of times and dates.</p> <h3 id="date">Date</h3> <p>A <a href="https://hexdocs.pm/elixir/Date.html">%Date{}</a> struct contains the fields <code class="language-plaintext highlighter-rouge">year</code>, <code class="language-plaintext highlighter-rouge">month</code>, <code class="language-plaintext highlighter-rouge">day</code>, and <code class="language-plaintext highlighter-rouge">calendar</code>. You can create one using the <code class="language-plaintext highlighter-rouge">~D</code> sigil:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; d = ~D[2019-10-31]
~D[2019-10-31]
iex&gt; d.day
31
</pre></div> <h3 id="time">Time</h3> <p>The <a href="https://hexdocs.pm/elixir/Time.html">%Time{}</a> struct contains the fields <code class="language-plaintext highlighter-rouge">hour</code>, <code class="language-plaintext highlighter-rouge">minute</code>, <code class="language-plaintext highlighter-rouge">second</code>, <code class="language-plaintext highlighter-rouge">microsecond</code>, and <code class="language-plaintext highlighter-rouge">calendar</code>. You can create one using the <code class="language-plaintext highlighter-rouge">~T</code> sigil:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; t = ~T[23:00:07.0]
~T[23:00:07.0]
iex&gt; t.second
7
</pre></div> <h3 id="naivedatetime">NaiveDateTime</h3> <p>The <a href="https://hexdocs.pm/elixir/NaiveDateTime.html">%NaiveDateTime{}</a> struct contains fields from both <code class="language-plaintext highlighter-rouge">Date</code> and <code class="language-plaintext highlighter-rouge">Time</code>. You can create one using the <code class="language-plaintext highlighter-rouge">~N</code> sigil:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; ndt = ~N[2019-10-31 23:00:07]
~N[2019-10-31 23:00:07]
</pre></div> <p>Why is it called naive? Because it does not contain timezone information. Therefore, the given datetime may not exist at all or it may exist twice in certain timezones - for example, when we move the clock back and forward for daylight saving time.</p> <h3 id="utc-datetime">UTC DateTime</h3> <p>A <a href="https://hexdocs.pm/elixir/DateTime.html">%DateTime{}</a> struct contains the same fields as a <code class="language-plaintext highlighter-rouge">NaiveDateTime</code> with the addition of fields to track timezones. The <code class="language-plaintext highlighter-rouge">~U</code> sigil allows developers to create a DateTime in the UTC timezone:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; dt = ~U[2019-10-31 19:59:03Z]
~U[2019-10-31 19:59:03Z]
iex&gt; %DateTime{minute: minute, time_zone: time_zone} = dt
~U[2019-10-31 19:59:03Z]
iex&gt; minute
59
iex&gt; time_zone
"Etc/UTC"
</pre></div> <h2 id="custom-sigils">Custom sigils</h2> <p>As hinted at the beginning of this chapter, sigils in Elixir are extensible. In fact, using the sigil <code class="language-plaintext highlighter-rouge">~r/foo/i</code> is equivalent to calling <code class="language-plaintext highlighter-rouge">sigil_r</code> with a binary and a char list as the argument:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; sigil_r(&lt;&lt;"foo"&gt;&gt;, ~c"i")
~r"foo"i
</pre></div> <p>We can access the documentation for the <code class="language-plaintext highlighter-rouge">~r</code> sigil via <code class="language-plaintext highlighter-rouge">sigil_r</code>:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; h sigil_r
...
</pre></div> <p>We can also provide our own sigils by implementing functions that follow the <code class="language-plaintext highlighter-rouge">sigil_{character}</code> pattern. For example, let’s implement the <code class="language-plaintext highlighter-rouge">~i</code> sigil that returns an integer (with the optional <code class="language-plaintext highlighter-rouge">n</code> modifier to make it negative):</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; defmodule MySigils do
...&gt;   def sigil_i(string, []), do: String.to_integer(string)
...&gt;   def sigil_i(string, [?n]), do: -String.to_integer(string)
...&gt; end
iex&gt; import MySigils
iex&gt; ~i(13)
13
iex&gt; ~i(42)n
-42
</pre></div> <p>Sigils can also be used to do compile-time work with the help of macros. For example, regular expressions in Elixir are compiled into an efficient representation during compilation of the source code, therefore skipping this step at runtime. If you’re interested in the subject, we recommend you learn more about macros and check out how sigils are implemented in the <code class="language-plaintext highlighter-rouge">Kernel</code> module (where the <code class="language-plaintext highlighter-rouge">sigil_*</code> functions are defined).</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://elixir-lang.org/getting-started/sigils.html" class="_attribution-link">https://elixir-lang.org/getting-started/sigils.html</a>
  </p>
</div>
