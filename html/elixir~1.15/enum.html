<h1>   <span translate="no">Enum</span>  </h1> <section id="moduledoc"> <p>Functions for working with collections (known as enumerables).</p>
<p>In Elixir, an enumerable is any data type that implements the <a href="enumerable.html"><code class="inline">Enumerable</code></a> protocol. <a href="list.html"><code class="inline">List</code></a>s (<code class="inline">[1, 2, 3]</code>), <a href="map.html"><code class="inline">Map</code></a>s (<code class="inline">%{foo: 1, bar: 2}</code>) and <a href="range.html"><code class="inline">Range</code></a>s (<code class="inline">1..3</code>) are common data types used as enumerables:</p>
<pre data-language="elixir">iex&gt; Enum.map([1, 2, 3], fn x -&gt; x * 2 end)
[2, 4, 6]

iex&gt; Enum.sum([1, 2, 3])
6

iex&gt; Enum.map(1..3, fn x -&gt; x * 2 end)
[2, 4, 6]

iex&gt; Enum.sum(1..3)
6

iex&gt; map = %{"a" =&gt; 1, "b" =&gt; 2}
iex&gt; Enum.map(map, fn {k, v} -&gt; {k, v * 2} end)
[{"a", 2}, {"b", 4}]</pre>
<p>However, many other enumerables exist in the language, such as <a href="mapset.html"><code class="inline">MapSet</code></a>s and the data type returned by <a href="file.html#stream!/3"><code class="inline">File.stream!/3</code></a> which allows a file to be traversed as if it was an enumerable.</p>
<p>The functions in this module work in linear time. This means that, the time it takes to perform an operation grows at the same rate as the length of the enumerable. This is expected on operations such as <a href="#map/2"><code class="inline">Enum.map/2</code></a>. After all, if we want to traverse every element on a list, the longer the list, the more elements we need to traverse, and the longer it will take.</p>
<p>This linear behaviour should also be expected on operations like <a href="#count/1"><code class="inline">count/1</code></a>, <a href="#member?/2"><code class="inline">member?/2</code></a>, <a href="#at/2"><code class="inline">at/2</code></a> and similar. While Elixir does allow data types to provide performant variants for such operations, you should not expect it to always be available, since the <a href="enum.html#content"><code class="inline">Enum</code></a> module is meant to work with a large variety of data types and not all data types can provide optimized behaviour.</p>
<p>Finally, note the functions in the <a href="enum.html#content"><code class="inline">Enum</code></a> module are eager: they will traverse the enumerable as soon as they are invoked. This is particularly dangerous when working with infinite enumerables. In such cases, you should use the <a href="stream.html"><code class="inline">Stream</code></a> module, which allows you to lazily express computations, without traversing collections, and work with possibly infinite collections. See the <a href="stream.html"><code class="inline">Stream</code></a> module for examples and documentation.</p> </section> <section id="summary" class="details-list">  <h2> Types </h2>
<dl class="summary-types summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#t:acc/0" translate="no">acc()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:default/0" translate="no">default()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:element/0" translate="no">element()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:index/0" translate="no">index()</a> </dt> <dd class="summary-synopsis"><p>Zero-based index. It can also be a negative integer.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:t/0" translate="no">t()</a> </dt> </div> </dl> <h2> Functions </h2>
<dl class="summary-functions summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#all?/1" translate="no">all?(enumerable)</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if all elements in <code class="inline">enumerable</code> are truthy.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#all?/2" translate="no">all?(enumerable, fun)</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if <code class="inline">fun.(element)</code> is truthy for all elements in <code class="inline">enumerable</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#any?/1" translate="no">any?(enumerable)</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if at least one element in <code class="inline">enumerable</code> is truthy.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#any?/2" translate="no">any?(enumerable, fun)</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if <code class="inline">fun.(element)</code> is truthy for at least one element in <code class="inline">enumerable</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#at/3" translate="no">at(enumerable, index, default \\ nil)</a> </dt> <dd class="summary-synopsis"><p>Finds the element at the given <code class="inline">index</code> (zero-based).</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#chunk_by/2" translate="no">chunk_by(enumerable, fun)</a> </dt> <dd class="summary-synopsis"><p>Splits enumerable on every element for which <code class="inline">fun</code> returns a new value.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#chunk_every/2" translate="no">chunk_every(enumerable, count)</a> </dt> <dd class="summary-synopsis"><p>Shortcut to <code class="inline">chunk_every(enumerable, count, count)</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#chunk_every/4" translate="no">chunk_every(enumerable, count, step, leftover \\ [])</a> </dt> <dd class="summary-synopsis"><p>Returns list of lists containing <code class="inline">count</code> elements each, where each new chunk starts <code class="inline">step</code> elements into the <code class="inline">enumerable</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#chunk_while/4" translate="no">chunk_while(enumerable, acc, chunk_fun, after_fun)</a> </dt> <dd class="summary-synopsis"><p>Chunks the <code class="inline">enumerable</code> with fine grained control when every chunk is emitted.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#concat/1" translate="no">concat(enumerables)</a> </dt> <dd class="summary-synopsis"><p>Given an enumerable of enumerables, concatenates the <code class="inline">enumerables</code> into a single list.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#concat/2" translate="no">concat(left, right)</a> </dt> <dd class="summary-synopsis"><p>Concatenates the enumerable on the <code class="inline">right</code> with the enumerable on the <code class="inline">left</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#count/1" translate="no">count(enumerable)</a> </dt> <dd class="summary-synopsis"><p>Returns the size of the <code class="inline">enumerable</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#count/2" translate="no">count(enumerable, fun)</a> </dt> <dd class="summary-synopsis"><p>Returns the count of elements in the <code class="inline">enumerable</code> for which <code class="inline">fun</code> returns a truthy value.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#count_until/2" translate="no">count_until(enumerable, limit)</a> </dt> <dd class="summary-synopsis"><p>Counts the enumerable stopping at <code class="inline">limit</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#count_until/3" translate="no">count_until(enumerable, fun, limit)</a> </dt> <dd class="summary-synopsis"><p>Counts the elements in the enumerable for which <code class="inline">fun</code> returns a truthy value, stopping at <code class="inline">limit</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#dedup/1" translate="no">dedup(enumerable)</a> </dt> <dd class="summary-synopsis"><p>Enumerates the <code class="inline">enumerable</code>, returning a list where all consecutive duplicated elements are collapsed to a single element.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#dedup_by/2" translate="no">dedup_by(enumerable, fun)</a> </dt> <dd class="summary-synopsis"><p>Enumerates the <code class="inline">enumerable</code>, returning a list where all consecutive duplicated elements are collapsed to a single element.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#drop/2" translate="no">drop(enumerable, amount)</a> </dt> <dd class="summary-synopsis"><p>Drops the <code class="inline">amount</code> of elements from the <code class="inline">enumerable</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#drop_every/2" translate="no">drop_every(enumerable, nth)</a> </dt> <dd class="summary-synopsis"><p>Returns a list of every <code class="inline">nth</code> element in the <code class="inline">enumerable</code> dropped, starting with the first element.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#drop_while/2" translate="no">drop_while(enumerable, fun)</a> </dt> <dd class="summary-synopsis"><p>Drops elements at the beginning of the <code class="inline">enumerable</code> while <code class="inline">fun</code> returns a truthy value.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#each/2" translate="no">each(enumerable, fun)</a> </dt> <dd class="summary-synopsis"><p>Invokes the given <code class="inline">fun</code> for each element in the <code class="inline">enumerable</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#empty?/1" translate="no">empty?(enumerable)</a> </dt> <dd class="summary-synopsis"><p>Determines if the <code class="inline">enumerable</code> is empty.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#fetch/2" translate="no">fetch(enumerable, index)</a> </dt> <dd class="summary-synopsis"><p>Finds the element at the given <code class="inline">index</code> (zero-based).</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#fetch!/2" translate="no">fetch!(enumerable, index)</a> </dt> <dd class="summary-synopsis"><p>Finds the element at the given <code class="inline">index</code> (zero-based).</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#filter/2" translate="no">filter(enumerable, fun)</a> </dt> <dd class="summary-synopsis"><p>Filters the <code class="inline">enumerable</code>, i.e. returns only those elements for which <code class="inline">fun</code> returns a truthy value.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#find/3" translate="no">find(enumerable, default \\ nil, fun)</a> </dt> <dd class="summary-synopsis"><p>Returns the first element for which <code class="inline">fun</code> returns a truthy value. If no such element is found, returns <code class="inline">default</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#find_index/2" translate="no">find_index(enumerable, fun)</a> </dt> <dd class="summary-synopsis"><p>Similar to <a href="#find/3"><code class="inline">find/3</code></a>, but returns the index (zero-based) of the element instead of the element itself.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#find_value/3" translate="no">find_value(enumerable, default \\ nil, fun)</a> </dt> <dd class="summary-synopsis"><p>Similar to <a href="#find/3"><code class="inline">find/3</code></a>, but returns the value of the function invocation instead of the element itself.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#flat_map/2" translate="no">flat_map(enumerable, fun)</a> </dt> <dd class="summary-synopsis"><p>Maps the given <code class="inline">fun</code> over <code class="inline">enumerable</code> and flattens the result.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#flat_map_reduce/3" translate="no">flat_map_reduce(enumerable, acc, fun)</a> </dt> <dd class="summary-synopsis"><p>Maps and reduces an <code class="inline">enumerable</code>, flattening the given results (only one level deep).</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#frequencies/1" translate="no">frequencies(enumerable)</a> </dt> <dd class="summary-synopsis"><p>Returns a map with keys as unique elements of <code class="inline">enumerable</code> and values as the count of every element.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#frequencies_by/2" translate="no">frequencies_by(enumerable, key_fun)</a> </dt> <dd class="summary-synopsis"><p>Returns a map with keys as unique elements given by <code class="inline">key_fun</code> and values as the count of every element.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#group_by/3" translate="no">group_by(enumerable, key_fun, value_fun \\ fn x -&gt; x end)</a> </dt> <dd class="summary-synopsis"><p>Splits the <code class="inline">enumerable</code> into groups based on <code class="inline">key_fun</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#intersperse/2" translate="no">intersperse(enumerable, separator)</a> </dt> <dd class="summary-synopsis"><p>Intersperses <code class="inline">separator</code> between each element of the enumeration.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#into/2" translate="no">into(enumerable, collectable)</a> </dt> <dd class="summary-synopsis"><p>Inserts the given <code class="inline">enumerable</code> into a <code class="inline">collectable</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#into/3" translate="no">into(enumerable, collectable, transform)</a> </dt> <dd class="summary-synopsis"><p>Inserts the given <code class="inline">enumerable</code> into a <code class="inline">collectable</code> according to the transformation function.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#join/2" translate="no">join(enumerable, joiner \\ "")</a> </dt> <dd class="summary-synopsis"><p>Joins the given <code class="inline">enumerable</code> into a string using <code class="inline">joiner</code> as a separator.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#map/2" translate="no">map(enumerable, fun)</a> </dt> <dd class="summary-synopsis"><p>Returns a list where each element is the result of invoking <code class="inline">fun</code> on each corresponding element of <code class="inline">enumerable</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#map_every/3" translate="no">map_every(enumerable, nth, fun)</a> </dt> <dd class="summary-synopsis"><p>Returns a list of results of invoking <code class="inline">fun</code> on every <code class="inline">nth</code> element of <code class="inline">enumerable</code>, starting with the first element.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#map_intersperse/3" translate="no">map_intersperse(enumerable, separator, mapper)</a> </dt> <dd class="summary-synopsis"><p>Maps and intersperses the given enumerable in one pass.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#map_join/3" translate="no">map_join(enumerable, joiner \\ "", mapper)</a> </dt> <dd class="summary-synopsis"><p>Maps and joins the given <code class="inline">enumerable</code> in one pass.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#map_reduce/3" translate="no">map_reduce(enumerable, acc, fun)</a> </dt> <dd class="summary-synopsis"><p>Invokes the given function to each element in the <code class="inline">enumerable</code> to reduce it to a single element, while keeping an accumulator.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#max/3" translate="no">max(enumerable, sorter \\ &amp;&gt;=/2, empty_fallback \\ fn -&gt; raise Enum.EmptyError end)</a> </dt> <dd class="summary-synopsis"><p>Returns the maximal element in the <code class="inline">enumerable</code> according to Erlang's term ordering.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#max_by/4" translate="no">max_by(enumerable, fun, sorter \\ &amp;&gt;=/2, empty_fallback \\ fn -&gt; raise Enum.EmptyError end)</a> </dt> <dd class="summary-synopsis"><p>Returns the maximal element in the <code class="inline">enumerable</code> as calculated by the given <code class="inline">fun</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#member?/2" translate="no">member?(enumerable, element)</a> </dt> <dd class="summary-synopsis"><p>Checks if <code class="inline">element</code> exists within the <code class="inline">enumerable</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#min/3" translate="no">min(enumerable, sorter \\ &amp;&lt;=/2, empty_fallback \\ fn -&gt; raise Enum.EmptyError end)</a> </dt> <dd class="summary-synopsis"><p>Returns the minimal element in the <code class="inline">enumerable</code> according to Erlang's term ordering.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#min_by/4" translate="no">min_by(enumerable, fun, sorter \\ &amp;&lt;=/2, empty_fallback \\ fn -&gt; raise Enum.EmptyError end)</a> </dt> <dd class="summary-synopsis"><p>Returns the minimal element in the <code class="inline">enumerable</code> as calculated by the given <code class="inline">fun</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#min_max/2" translate="no">min_max(enumerable, empty_fallback \\ fn -&gt; raise Enum.EmptyError end)</a> </dt> <dd class="summary-synopsis"><p>Returns a tuple with the minimal and the maximal elements in the enumerable according to Erlang's term ordering.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#min_max_by/4" translate="no">min_max_by(enumerable, fun, sorter_or_empty_fallback \\ &amp;&lt;/2, empty_fallback \\ fn -&gt; raise Enum.EmptyError end)</a> </dt> <dd class="summary-synopsis"><p>Returns a tuple with the minimal and the maximal elements in the enumerable as calculated by the given function.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#product/1" translate="no">product(enumerable)</a> </dt> <dd class="summary-synopsis"><p>Returns the product of all elements.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#random/1" translate="no">random(enumerable)</a> </dt> <dd class="summary-synopsis"><p>Returns a random element of an <code class="inline">enumerable</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#reduce/2" translate="no">reduce(enumerable, fun)</a> </dt> <dd class="summary-synopsis"><p>Invokes <code class="inline">fun</code> for each element in the <code class="inline">enumerable</code> with the accumulator.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#reduce/3" translate="no">reduce(enumerable, acc, fun)</a> </dt> <dd class="summary-synopsis"><p>Invokes <code class="inline">fun</code> for each element in the <code class="inline">enumerable</code> with the accumulator.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#reduce_while/3" translate="no">reduce_while(enumerable, acc, fun)</a> </dt> <dd class="summary-synopsis"><p>Reduces <code class="inline">enumerable</code> until <code class="inline">fun</code> returns <code class="inline">{:halt, term}</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#reject/2" translate="no">reject(enumerable, fun)</a> </dt> <dd class="summary-synopsis"><p>Returns a list of elements in <code class="inline">enumerable</code> excluding those for which the function <code class="inline">fun</code> returns a truthy value.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#reverse/1" translate="no">reverse(enumerable)</a> </dt> <dd class="summary-synopsis"><p>Returns a list of elements in <code class="inline">enumerable</code> in reverse order.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#reverse/2" translate="no">reverse(enumerable, tail)</a> </dt> <dd class="summary-synopsis"><p>Reverses the elements in <code class="inline">enumerable</code>, appends the <code class="inline">tail</code>, and returns it as a list.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#reverse_slice/3" translate="no">reverse_slice(enumerable, start_index, count)</a> </dt> <dd class="summary-synopsis"><p>Reverses the <code class="inline">enumerable</code> in the range from initial <code class="inline">start_index</code> through <code class="inline">count</code> elements.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#scan/2" translate="no">scan(enumerable, fun)</a> </dt> <dd class="summary-synopsis"><p>Applies the given function to each element in the <code class="inline">enumerable</code>, storing the result in a list and passing it as the accumulator for the next computation. Uses the first element in the <code class="inline">enumerable</code> as the starting value.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#scan/3" translate="no">scan(enumerable, acc, fun)</a> </dt> <dd class="summary-synopsis"><p>Applies the given function to each element in the <code class="inline">enumerable</code>, storing the result in a list and passing it as the accumulator for the next computation. Uses the given <code class="inline">acc</code> as the starting value.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#shuffle/1" translate="no">shuffle(enumerable)</a> </dt> <dd class="summary-synopsis"><p>Returns a list with the elements of <code class="inline">enumerable</code> shuffled.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#slice/2" translate="no">slice(enumerable, index_range)</a> </dt> <dd class="summary-synopsis"><p>Returns a subset list of the given <code class="inline">enumerable</code> by <code class="inline">index_range</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#slice/3" translate="no">slice(enumerable, start_index, amount)</a> </dt> <dd class="summary-synopsis"><p>Returns a subset list of the given <code class="inline">enumerable</code>, from <code class="inline">start_index</code> (zero-based) with <code class="inline">amount</code> number of elements if available.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#slide/3" translate="no">slide(enumerable, range_or_single_index, insertion_index)</a> </dt> <dd class="summary-synopsis"><p>Slides a single or multiple elements given by <code class="inline">range_or_single_index</code> from <code class="inline">enumerable</code> to <code class="inline">insertion_index</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#sort/1" translate="no">sort(enumerable)</a> </dt> <dd class="summary-synopsis"><p>Sorts the <code class="inline">enumerable</code> according to Erlang's term ordering.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#sort/2" translate="no">sort(enumerable, sorter)</a> </dt> <dd class="summary-synopsis"><p>Sorts the <code class="inline">enumerable</code> by the given function.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#sort_by/3" translate="no">sort_by(enumerable, mapper, sorter \\ :asc)</a> </dt> <dd class="summary-synopsis"><p>Sorts the mapped results of the <code class="inline">enumerable</code> according to the provided <code class="inline">sorter</code> function.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#split/2" translate="no">split(enumerable, count)</a> </dt> <dd class="summary-synopsis"><p>Splits the <code class="inline">enumerable</code> into two enumerables, leaving <code class="inline">count</code> elements in the first one.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#split_while/2" translate="no">split_while(enumerable, fun)</a> </dt> <dd class="summary-synopsis"><p>Splits enumerable in two at the position of the element for which <code class="inline">fun</code> returns a falsy value (<code class="inline">false</code> or <code class="inline">nil</code>) for the first time.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#split_with/2" translate="no">split_with(enumerable, fun)</a> </dt> <dd class="summary-synopsis"><p>Splits the <code class="inline">enumerable</code> in two lists according to the given function <code class="inline">fun</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#sum/1" translate="no">sum(enumerable)</a> </dt> <dd class="summary-synopsis"><p>Returns the sum of all elements.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#take/2" translate="no">take(enumerable, amount)</a> </dt> <dd class="summary-synopsis"><p>Takes an <code class="inline">amount</code> of elements from the beginning or the end of the <code class="inline">enumerable</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#take_every/2" translate="no">take_every(enumerable, nth)</a> </dt> <dd class="summary-synopsis"><p>Returns a list of every <code class="inline">nth</code> element in the <code class="inline">enumerable</code>, starting with the first element.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#take_random/2" translate="no">take_random(enumerable, count)</a> </dt> <dd class="summary-synopsis"><p>Takes <code class="inline">count</code> random elements from <code class="inline">enumerable</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#take_while/2" translate="no">take_while(enumerable, fun)</a> </dt> <dd class="summary-synopsis"><p>Takes the elements from the beginning of the <code class="inline">enumerable</code> while <code class="inline">fun</code> returns a truthy value.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#to_list/1" translate="no">to_list(enumerable)</a> </dt> <dd class="summary-synopsis"><p>Converts <code class="inline">enumerable</code> to a list.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#uniq/1" translate="no">uniq(enumerable)</a> </dt> <dd class="summary-synopsis"><p>Enumerates the <code class="inline">enumerable</code>, removing all duplicated elements.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#uniq_by/2" translate="no">uniq_by(enumerable, fun)</a> </dt> <dd class="summary-synopsis"><p>Enumerates the <code class="inline">enumerable</code>, by removing the elements for which function <code class="inline">fun</code> returned duplicate elements.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#unzip/1" translate="no">unzip(list)</a> </dt> <dd class="summary-synopsis"><p>Opposite of <a href="#zip/2"><code class="inline">zip/2</code></a>. Extracts two-element tuples from the given <code class="inline">enumerable</code> and groups them together.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#with_index/2" translate="no">with_index(enumerable, fun_or_offset \\ 0)</a> </dt> <dd class="summary-synopsis"><p>Returns the <code class="inline">enumerable</code> with each element wrapped in a tuple alongside its index.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#zip/1" translate="no">zip(enumerables)</a> </dt> <dd class="summary-synopsis"><p>Zips corresponding elements from a finite collection of enumerables into a list of tuples.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#zip/2" translate="no">zip(enumerable1, enumerable2)</a> </dt> <dd class="summary-synopsis"><p>Zips corresponding elements from two enumerables into a list of tuples.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#zip_reduce/3" translate="no">zip_reduce(enums, acc, reducer)</a> </dt> <dd class="summary-synopsis"><p>Reduces over all of the given enumerables, halting as soon as any enumerable is empty.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#zip_reduce/4" translate="no">zip_reduce(left, right, acc, reducer)</a> </dt> <dd class="summary-synopsis"><p>Reduces over two enumerables halting as soon as either enumerable is empty.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#zip_with/2" translate="no">zip_with(enumerables, zip_fun)</a> </dt> <dd class="summary-synopsis"><p>Zips corresponding elements from a finite collection of enumerables into list, transforming them with the <code class="inline">zip_fun</code> function as it goes.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#zip_with/3" translate="no">zip_with(enumerable1, enumerable2, zip_fun)</a> </dt> <dd class="summary-synopsis"><p>Zips corresponding elements from two enumerables into a list, transforming them with the <code class="inline">zip_fun</code> function as it goes.</p></dd> </div> </dl> </section> <section id="types" class="details-list">  <div class="types-list"> <section class="detail"> <h3 class="detail-header" id="t:acc/0">acc()<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L287" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type acc() :: any()</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:default/0">default()<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L293" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type default() :: any()</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:element/0">element()<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L288" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type element() :: any()</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:index/0">index()<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L291" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type index() :: integer()</pre> </div> <p>Zero-based index. It can also be a negative integer.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:t/0">t()<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L286" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type t() :: Enumerable.t()</pre> </div> </section> </section> </div> </section> <section id="functions" class="details-list">  <div class="functions-list"> <section class="detail"> <h3 class="detail-header" id="all?/1">all?(enumerable)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L334" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec all?(t()) :: boolean()</pre> </div> <p>Returns <code class="inline">true</code> if all elements in <code class="inline">enumerable</code> are truthy.</p>
<p>When an element has a falsy value (<code class="inline">false</code> or <code class="inline">nil</code>) iteration stops immediately and <code class="inline">false</code> is returned. In all other cases <code class="inline">true</code> is returned.</p>
<h4 id="all?/1-examples" class="section-heading"> <a href="#all?/1-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.all?([1, 2, 3])
true

iex&gt; Enum.all?([1, nil, 3])
false

iex&gt; Enum.all?([])
true</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="all?/2">all?(enumerable, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L370" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec all?(t(), (element() -&gt; as_boolean(term()))) :: boolean()</pre> </div> <p>Returns <code class="inline">true</code> if <code class="inline">fun.(element)</code> is truthy for all elements in <code class="inline">enumerable</code>.</p>
<p>Iterates over <code class="inline">enumerable</code> and invokes <code class="inline">fun</code> on each element. If <code class="inline">fun</code> ever returns a falsy value (<code class="inline">false</code> or <code class="inline">nil</code>), iteration stops immediately and <code class="inline">false</code> is returned. Otherwise, <code class="inline">true</code> is returned.</p>
<h4 id="all?/2-examples" class="section-heading"> <a href="#all?/2-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.all?([2, 4, 6], fn x -&gt; rem(x, 2) == 0 end)
true

iex&gt; Enum.all?([2, 3, 4], fn x -&gt; rem(x, 2) == 0 end)
false

iex&gt; Enum.all?([], fn _ -&gt; nil end)
true</pre>
<p>As the last example shows, <a href="#all?/2"><code class="inline">Enum.all?/2</code></a> returns <code class="inline">true</code> if <code class="inline">enumerable</code> is empty, regardless of <code class="inline">fun</code>. In an empty enumerable there is no element for which <code class="inline">fun</code> returns a falsy value, so the result must be <code class="inline">true</code>. This is a well-defined logical argument for empty collections.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="any?/1">any?(enumerable)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L404" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec any?(t()) :: boolean()</pre> </div> <p>Returns <code class="inline">true</code> if at least one element in <code class="inline">enumerable</code> is truthy.</p>
<p>When an element has a truthy value (neither <code class="inline">false</code> nor <code class="inline">nil</code>) iteration stops immediately and <code class="inline">true</code> is returned. In all other cases <code class="inline">false</code> is returned.</p>
<h4 id="any?/1-examples" class="section-heading"> <a href="#any?/1-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.any?([false, false, false])
false

iex&gt; Enum.any?([false, true, false])
true

iex&gt; Enum.any?([])
false</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="any?/2">any?(enumerable, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L435" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec any?(t(), (element() -&gt; as_boolean(term()))) :: boolean()</pre> </div> <p>Returns <code class="inline">true</code> if <code class="inline">fun.(element)</code> is truthy for at least one element in <code class="inline">enumerable</code>.</p>
<p>Iterates over the <code class="inline">enumerable</code> and invokes <code class="inline">fun</code> on each element. When an invocation of <code class="inline">fun</code> returns a truthy value (neither <code class="inline">false</code> nor <code class="inline">nil</code>) iteration stops immediately and <code class="inline">true</code> is returned. In all other cases <code class="inline">false</code> is returned.</p>
<h4 id="any?/2-examples" class="section-heading"> <a href="#any?/2-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.any?([2, 4, 6], fn x -&gt; rem(x, 2) == 1 end)
false

iex&gt; Enum.any?([2, 3, 4], fn x -&gt; rem(x, 2) == 1 end)
true

iex&gt; Enum.any?([], fn x -&gt; x &gt; 0 end)
false</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="at/3">at(enumerable, index, default \\ nil)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L475" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec at(t(), index(), default()) :: element() | default()</pre> </div> <p>Finds the element at the given <code class="inline">index</code> (zero-based).</p>
<p>Returns <code class="inline">default</code> if <code class="inline">index</code> is out of bounds.</p>
<p>A negative <code class="inline">index</code> can be passed, which means the <code class="inline">enumerable</code> is enumerated once and the <code class="inline">index</code> is counted from the end (for example, <code class="inline">-1</code> finds the last element).</p>
<h4 id="at/3-examples" class="section-heading"> <a href="#at/3-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.at([2, 4, 6], 0)
2

iex&gt; Enum.at([2, 4, 6], 2)
6

iex&gt; Enum.at([2, 4, 6], 4)
nil

iex&gt; Enum.at([2, 4, 6], 4, :none)
:none</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="chunk_by/2">chunk_by(enumerable, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L631" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec chunk_by(t(), (element() -&gt; any())) :: [list()]</pre> </div> <p>Splits enumerable on every element for which <code class="inline">fun</code> returns a new value.</p>
<p>Returns a list of lists.</p>
<h4 id="chunk_by/2-examples" class="section-heading"> <a href="#chunk_by/2-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.chunk_by([1, 2, 2, 3, 4, 4, 6, 7, 7], &amp;(rem(&amp;1, 2) == 1))
[[1], [2, 2], [3], [4, 4, 6], [7, 7]]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="chunk_every/2">chunk_every(enumerable, count)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L503" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec chunk_every(t(), pos_integer()) :: [list()]</pre> </div> <p>Shortcut to <code class="inline">chunk_every(enumerable, count, count)</code>.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="chunk_every/4">chunk_every(enumerable, count, step, leftover \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L547" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec chunk_every(t(), pos_integer(), pos_integer(), t() | :discard) :: [list()]</pre> </div> <p>Returns list of lists containing <code class="inline">count</code> elements each, where each new chunk starts <code class="inline">step</code> elements into the <code class="inline">enumerable</code>.</p>
<p><code class="inline">step</code> is optional and, if not passed, defaults to <code class="inline">count</code>, i.e. chunks do not overlap. Chunking will stop as soon as the collection ends or when we emit an incomplete chunk.</p>
<p>If the last chunk does not have <code class="inline">count</code> elements to fill the chunk, elements are taken from <code class="inline">leftover</code> to fill in the chunk. If <code class="inline">leftover</code> does not have enough elements to fill the chunk, then a partial chunk is returned with less than <code class="inline">count</code> elements.</p>
<p>If <code class="inline">:discard</code> is given in <code class="inline">leftover</code>, the last chunk is discarded unless it has exactly <code class="inline">count</code> elements.</p>
<h4 id="chunk_every/4-examples" class="section-heading"> <a href="#chunk_every/4-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.chunk_every([1, 2, 3, 4, 5, 6], 2)
[[1, 2], [3, 4], [5, 6]]

iex&gt; Enum.chunk_every([1, 2, 3, 4, 5, 6], 3, 2, :discard)
[[1, 2, 3], [3, 4, 5]]

iex&gt; Enum.chunk_every([1, 2, 3, 4, 5, 6], 3, 2, [7])
[[1, 2, 3], [3, 4, 5], [5, 6, 7]]

iex&gt; Enum.chunk_every([1, 2, 3, 4], 3, 3, [])
[[1, 2, 3], [4]]

iex&gt; Enum.chunk_every([1, 2, 3, 4], 10)
[[1, 2, 3, 4]]

iex&gt; Enum.chunk_every([1, 2, 3, 4, 5], 2, 3, [])
[[1, 2], [4, 5]]

iex&gt; Enum.chunk_every([1, 2, 3, 4], 3, 3, Stream.cycle([0]))
[[1, 2, 3], [4, 0, 0]]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="chunk_while/4">chunk_while(enumerable, acc, chunk_fun, after_fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L602" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec chunk_while(
  t(),
  acc(),
  (element(), acc() -&gt; {:cont, chunk, acc()} | {:cont, acc()} | {:halt, acc()}),
  (acc() -&gt; {:cont, chunk, acc()} | {:cont, acc()})
) :: Enumerable.t()
when chunk: any()</pre> </div> <p>Chunks the <code class="inline">enumerable</code> with fine grained control when every chunk is emitted.</p>
<p><code class="inline">chunk_fun</code> receives the current element and the accumulator and must return:</p>
<ul>
<li>
<code class="inline">{:cont, chunk, acc}</code> to emit a chunk and continue with the accumulator</li>
<li>
<code class="inline">{:cont, acc}</code> to not emit any chunk and continue with the accumulator</li>
<li>
<code class="inline">{:halt, acc}</code> to halt chunking over the <code class="inline">enumerable</code>.</li>
</ul>
<p><code class="inline">after_fun</code> is invoked with the final accumulator when iteration is finished (or <code class="inline">halt</code>ed) to handle any trailing elements that were returned as part of an accumulator, but were not emitted as a chunk by <code class="inline">chunk_fun</code>. It must return:</p>
<ul>
<li>
<code class="inline">{:cont, chunk, acc}</code> to emit a chunk. The chunk will be appended to the list of already emitted chunks.</li>
<li>
<code class="inline">{:cont, acc}</code> to not emit a chunk</li>
</ul>
<p>The <code class="inline">acc</code> in <code class="inline">after_fun</code> is required in order to mirror the tuple format from <code class="inline">chunk_fun</code> but it will be discarded since the traversal is complete.</p>
<p>Returns a list of emitted chunks.</p>
<h4 id="chunk_while/4-examples" class="section-heading"> <a href="#chunk_while/4-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; chunk_fun = fn element, acc -&gt;
...&gt;   if rem(element, 2) == 0 do
...&gt;     {:cont, Enum.reverse([element | acc]), []}
...&gt;   else
...&gt;     {:cont, [element | acc]}
...&gt;   end
...&gt; end
iex&gt; after_fun = fn
...&gt;   [] -&gt; {:cont, []}
...&gt;   acc -&gt; {:cont, Enum.reverse(acc), []}
...&gt; end
iex&gt; Enum.chunk_while(1..10, [], chunk_fun, after_fun)
[[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]
iex&gt; Enum.chunk_while([1, 2, 3, 5, 7], [], chunk_fun, after_fun)
[[1, 2], [3, 5, 7]]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="concat/1">concat(enumerables)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L649" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec concat(t()) :: t()</pre> </div> <p>Given an enumerable of enumerables, concatenates the <code class="inline">enumerables</code> into a single list.</p>
<h4 id="concat/1-examples" class="section-heading"> <a href="#concat/1-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.concat([1..3, 4..6, 7..9])
[1, 2, 3, 4, 5, 6, 7, 8, 9]

iex&gt; Enum.concat([[1, [2], 3], [4], [5, 6]])
[1, [2], 3, 4, 5, 6]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="concat/2">concat(left, right)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L676" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec concat(t(), t()) :: t()</pre> </div> <p>Concatenates the enumerable on the <code class="inline">right</code> with the enumerable on the <code class="inline">left</code>.</p>
<p>This function produces the same result as the <a href="kernel.html#++/2"><code class="inline">++/2</code></a> operator for lists.</p>
<h4 id="concat/2-examples" class="section-heading"> <a href="#concat/2-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.concat(1..3, 4..6)
[1, 2, 3, 4, 5, 6]

iex&gt; Enum.concat([1, 2, 3], [4, 5, 6])
[1, 2, 3, 4, 5, 6]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="count/1">count(enumerable)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L694" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec count(t()) :: non_neg_integer()</pre> </div> <p>Returns the size of the <code class="inline">enumerable</code>.</p>
<h4 id="count/1-examples" class="section-heading"> <a href="#count/1-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.count([1, 2, 3])
3</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="count/2">count(enumerable, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L719" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec count(t(), (element() -&gt; as_boolean(term()))) :: non_neg_integer()</pre> </div> <p>Returns the count of elements in the <code class="inline">enumerable</code> for which <code class="inline">fun</code> returns a truthy value.</p>
<h4 id="count/2-examples" class="section-heading"> <a href="#count/2-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.count([1, 2, 3, 4, 5], fn x -&gt; rem(x, 2) == 0 end)
2</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="count_until/2">count_until(enumerable, limit)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L755" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec count_until(t(), pos_integer()) :: non_neg_integer()</pre> </div> <p>Counts the enumerable stopping at <code class="inline">limit</code>.</p>
<p>This is useful for checking certain properties of the count of an enumerable without having to actually count the entire enumerable. For example, if you wanted to check that the count was exactly, at least, or more than a value.</p>
<p>If the enumerable implements <a href="enumerable.html#c:count/1"><code class="inline">Enumerable.count/1</code></a>, the enumerable is not traversed and we return the lower of the two numbers. To force enumeration, use <a href="#count_until/3"><code class="inline">count_until/3</code></a> with <code class="inline">fn _ -&gt; true end</code> as the second argument.</p>
<h4 id="count_until/2-examples" class="section-heading"> <a href="#count_until/2-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.count_until(1..20, 5)
5
iex&gt; Enum.count_until(1..20, 50)
20
iex&gt; Enum.count_until(1..10, 10) == 10 # At least 10
true
iex&gt; Enum.count_until(1..11, 10 + 1) &gt; 10 # More than 10
true
iex&gt; Enum.count_until(1..5, 10) &lt; 10 # Less than 10
true
iex&gt; Enum.count_until(1..10, 10 + 1) == 10 # Exactly ten
true</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="count_until/3">count_until(enumerable, fun, limit)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L792" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec count_until(t(), (element() -&gt; as_boolean(term())), pos_integer()) ::
  non_neg_integer()</pre> </div> <p>Counts the elements in the enumerable for which <code class="inline">fun</code> returns a truthy value, stopping at <code class="inline">limit</code>.</p>
<p>See <a href="#count/2"><code class="inline">count/2</code></a> and <a href="#count_until/2"><code class="inline">count_until/2</code></a> for more information.</p>
<h4 id="count_until/3-examples" class="section-heading"> <a href="#count_until/3-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.count_until(1..20, fn x -&gt; rem(x, 2) == 0 end, 7)
7
iex&gt; Enum.count_until(1..20, fn x -&gt; rem(x, 2) == 0 end, 11)
10</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="dedup/1">dedup(enumerable)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L832" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec dedup(t()) :: list()</pre> </div> <p>Enumerates the <code class="inline">enumerable</code>, returning a list where all consecutive duplicated elements are collapsed to a single element.</p>
<p>Elements are compared using <a href="kernel.html#===/2"><code class="inline">===/2</code></a>.</p>
<p>If you want to remove all duplicated elements, regardless of order, see <a href="#uniq/1"><code class="inline">uniq/1</code></a>.</p>
<h4 id="dedup/1-examples" class="section-heading"> <a href="#dedup/1-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.dedup([1, 2, 3, 3, 2, 1])
[1, 2, 3, 2, 1]

iex&gt; Enum.dedup([1, 1, 2, 2.0, :three, :three])
[1, 2, 2.0, :three]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="dedup_by/2">dedup_by(enumerable, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L863" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec dedup_by(t(), (element() -&gt; term())) :: list()</pre> </div> <p>Enumerates the <code class="inline">enumerable</code>, returning a list where all consecutive duplicated elements are collapsed to a single element.</p>
<p>The function <code class="inline">fun</code> maps every element to a term which is used to determine if two elements are duplicates.</p>
<h4 id="dedup_by/2-examples" class="section-heading"> <a href="#dedup_by/2-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.dedup_by([{1, :a}, {2, :b}, {2, :c}, {1, :a}], fn {x, _} -&gt; x end)
[{1, :a}, {2, :b}, {1, :a}]

iex&gt; Enum.dedup_by([5, 1, 2, 3, 2, 1], fn x -&gt; x &gt; 2 end)
[5, 1, 3, 2]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="drop/2">drop(enumerable, amount)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L891" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec drop(t(), integer()) :: list()</pre> </div> <p>Drops the <code class="inline">amount</code> of elements from the <code class="inline">enumerable</code>.</p>
<p>If a negative <code class="inline">amount</code> is given, the <code class="inline">amount</code> of last values will be dropped. The <code class="inline">enumerable</code> will be enumerated once to retrieve the proper index and the remaining calculation is performed from the end.</p>
<h4 id="drop/2-examples" class="section-heading"> <a href="#drop/2-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.drop([1, 2, 3], 2)
[3]

iex&gt; Enum.drop([1, 2, 3], 10)
[]

iex&gt; Enum.drop([1, 2, 3], 0)
[1, 2, 3]

iex&gt; Enum.drop([1, 2, 3], -1)
[1, 2]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="drop_every/2">drop_every(enumerable, nth)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L938" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec drop_every(t(), non_neg_integer()) :: list()</pre> </div> <p>Returns a list of every <code class="inline">nth</code> element in the <code class="inline">enumerable</code> dropped, starting with the first element.</p>
<p>The first element is always dropped, unless <code class="inline">nth</code> is 0.</p>
<p>The second argument specifying every <code class="inline">nth</code> element must be a non-negative integer.</p>
<h4 id="drop_every/2-examples" class="section-heading"> <a href="#drop_every/2-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.drop_every(1..10, 2)
[2, 4, 6, 8, 10]

iex&gt; Enum.drop_every(1..10, 0)
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

iex&gt; Enum.drop_every([1, 2, 3], 1)
[]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="drop_while/2">drop_while(enumerable, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L960" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec drop_while(t(), (element() -&gt; as_boolean(term()))) :: list()</pre> </div> <p>Drops elements at the beginning of the <code class="inline">enumerable</code> while <code class="inline">fun</code> returns a truthy value.</p>
<h4 id="drop_while/2-examples" class="section-heading"> <a href="#drop_while/2-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.drop_while([1, 2, 3, 2, 1], fn x -&gt; x &lt; 3 end)
[3, 2, 1]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="each/2">each(enumerable, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L983" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec each(t(), (element() -&gt; any())) :: :ok</pre> </div> <p>Invokes the given <code class="inline">fun</code> for each element in the <code class="inline">enumerable</code>.</p>
<p>Returns <code class="inline">:ok</code>.</p>
<h4 id="each/2-examples" class="section-heading"> <a href="#each/2-examples">  Examples </a> </h4> <pre data-language="elixir">Enum.each(["some", "example"], fn x -&gt; IO.puts(x) end)
"some"
"example"
#=&gt; :ok</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="empty?/1">empty?(enumerable)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L1011" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec empty?(t()) :: boolean()</pre> </div> <p>Determines if the <code class="inline">enumerable</code> is empty.</p>
<p>Returns <code class="inline">true</code> if <code class="inline">enumerable</code> is empty, otherwise <code class="inline">false</code>.</p>
<h4 id="empty?/1-examples" class="section-heading"> <a href="#empty?/1-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.empty?([])
true

iex&gt; Enum.empty?([1, 2, 3])
false</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="fetch/2">fetch(enumerable, index)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L1052" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec fetch(t(), index()) :: {:ok, element()} | :error</pre> </div> <p>Finds the element at the given <code class="inline">index</code> (zero-based).</p>
<p>Returns <code class="inline">{:ok, element}</code> if found, otherwise <code class="inline">:error</code>.</p>
<p>A negative <code class="inline">index</code> can be passed, which means the <code class="inline">enumerable</code> is enumerated once and the <code class="inline">index</code> is counted from the end (for example, <code class="inline">-1</code> fetches the last element).</p>
<h4 id="fetch/2-examples" class="section-heading"> <a href="#fetch/2-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.fetch([2, 4, 6], 0)
{:ok, 2}

iex&gt; Enum.fetch([2, 4, 6], -3)
{:ok, 2}

iex&gt; Enum.fetch([2, 4, 6], 2)
{:ok, 6}

iex&gt; Enum.fetch([2, 4, 6], 4)
:error</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="fetch!/2">fetch!(enumerable, index)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L1078" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec fetch!(t(), index()) :: element()</pre> </div> <p>Finds the element at the given <code class="inline">index</code> (zero-based).</p>
<p>Raises <code class="inline">OutOfBoundsError</code> if the given <code class="inline">index</code> is outside the range of the <code class="inline">enumerable</code>.</p>
<h4 id="fetch!/2-examples" class="section-heading"> <a href="#fetch!/2-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.fetch!([2, 4, 6], 0)
2

iex&gt; Enum.fetch!([2, 4, 6], 2)
6

iex&gt; Enum.fetch!([2, 4, 6], 4)
** (Enum.OutOfBoundsError) out of bounds error</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="filter/2">filter(enumerable, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L1116" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec filter(t(), (element() -&gt; as_boolean(term()))) :: list()</pre> </div> <p>Filters the <code class="inline">enumerable</code>, i.e. returns only those elements for which <code class="inline">fun</code> returns a truthy value.</p>
<p>See also <a href="#reject/2"><code class="inline">reject/2</code></a> which discards all elements where the function returns a truthy value.</p>
<h4 id="filter/2-examples" class="section-heading"> <a href="#filter/2-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.filter([1, 2, 3], fn x -&gt; rem(x, 2) == 0 end)
[2]</pre>
<p>Keep in mind that <code class="inline">filter</code> is not capable of filtering and transforming an element at the same time. If you would like to do so, consider using <a href="#flat_map/2"><code class="inline">flat_map/2</code></a>. For example, if you want to convert all strings that represent an integer and discard the invalid one in one pass:</p>
<pre data-language="elixir">strings = ["1234", "abc", "12ab"]

Enum.flat_map(strings, fn string -&gt;
  case Integer.parse(string) do
    # transform to integer
    {int, _rest} -&gt; [int]
    # skip the value
    :error -&gt; []
  end
end)</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="find/3">find(enumerable, default \\ nil, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L1152" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec find(t(), default(), (element() -&gt; any())) :: element() | default()</pre> </div> <p>Returns the first element for which <code class="inline">fun</code> returns a truthy value. If no such element is found, returns <code class="inline">default</code>.</p>
<h4 id="find/3-examples" class="section-heading"> <a href="#find/3-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.find([2, 3, 4], fn x -&gt; rem(x, 2) == 1 end)
3

iex&gt; Enum.find([2, 4, 6], fn x -&gt; rem(x, 2) == 1 end)
nil
iex&gt; Enum.find([2, 4, 6], 0, fn x -&gt; rem(x, 2) == 1 end)
0</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="find_index/2">find_index(enumerable, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L1179" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec find_index(t(), (element() -&gt; any())) :: non_neg_integer() | nil</pre> </div> <p>Similar to <a href="#find/3"><code class="inline">find/3</code></a>, but returns the index (zero-based) of the element instead of the element itself.</p>
<h4 id="find_index/2-examples" class="section-heading"> <a href="#find_index/2-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.find_index([2, 4, 6], fn x -&gt; rem(x, 2) == 1 end)
nil

iex&gt; Enum.find_index([2, 3, 4], fn x -&gt; rem(x, 2) == 1 end)
1</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="find_value/3">find_value(enumerable, default \\ nil, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L1220" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec find_value(t(), any(), (element() -&gt; any())) :: any() | nil</pre> </div> <p>Similar to <a href="#find/3"><code class="inline">find/3</code></a>, but returns the value of the function invocation instead of the element itself.</p>
<p>The return value is considered to be found when the result is truthy (neither <code class="inline">nil</code> nor <code class="inline">false</code>).</p>
<h4 id="find_value/3-examples" class="section-heading"> <a href="#find_value/3-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.find_value([2, 3, 4], fn x -&gt;
...&gt;   if x &gt; 2, do: x * x
...&gt; end)
9

iex&gt; Enum.find_value([2, 4, 6], fn x -&gt; rem(x, 2) == 1 end)
nil

iex&gt; Enum.find_value([2, 3, 4], fn x -&gt; rem(x, 2) == 1 end)
true

iex&gt; Enum.find_value([1, 2, 3], "no bools!", &amp;is_boolean/1)
"no bools!"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="flat_map/2">flat_map(enumerable, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L1254" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec flat_map(t(), (element() -&gt; t())) :: list()</pre> </div> <p>Maps the given <code class="inline">fun</code> over <code class="inline">enumerable</code> and flattens the result.</p>
<p>This function returns a new enumerable built by appending the result of invoking <code class="inline">fun</code> on each element of <code class="inline">enumerable</code> together; conceptually, this is similar to a combination of <a href="#map/2"><code class="inline">map/2</code></a> and <a href="#concat/1"><code class="inline">concat/1</code></a>.</p>
<h4 id="flat_map/2-examples" class="section-heading"> <a href="#flat_map/2-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.flat_map([:a, :b, :c], fn x -&gt; [x, x] end)
[:a, :a, :b, :b, :c, :c]

iex&gt; Enum.flat_map([{1, 3}, {4, 6}], fn {x, y} -&gt; x..y end)
[1, 2, 3, 4, 5, 6]

iex&gt; Enum.flat_map([:a, :b, :c], fn x -&gt; [[x]] end)
[[:a], [:b], [:c]]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="flat_map_reduce/3">flat_map_reduce(enumerable, acc, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L1294" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec flat_map_reduce(t(), acc(), fun) :: {[any()], acc()}
when fun: (element(), acc() -&gt; {t(), acc()} | {:halt, acc()})</pre> </div> <p>Maps and reduces an <code class="inline">enumerable</code>, flattening the given results (only one level deep).</p>
<p>It expects an accumulator and a function that receives each enumerable element, and must return a tuple containing a new enumerable (often a list) with the new accumulator or a tuple with <code class="inline">:halt</code> as first element and the accumulator as second.</p>
<h4 id="flat_map_reduce/3-examples" class="section-heading"> <a href="#flat_map_reduce/3-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; enumerable = 1..100
iex&gt; n = 3
iex&gt; Enum.flat_map_reduce(enumerable, 0, fn x, acc -&gt;
...&gt;   if acc &lt; n, do: {[x], acc + 1}, else: {:halt, acc}
...&gt; end)
{[1, 2, 3], 3}

iex&gt; Enum.flat_map_reduce(1..5, 0, fn x, acc -&gt; {[[x]], acc + x} end)
{[[1], [2], [3], [4], [5]], 15}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="frequencies/1">frequencies(enumerable)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L1327" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec frequencies(t()) :: map()</pre> </div> <p>Returns a map with keys as unique elements of <code class="inline">enumerable</code> and values as the count of every element.</p>
<h4 id="frequencies/1-examples" class="section-heading"> <a href="#frequencies/1-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.frequencies(~w{ant buffalo ant ant buffalo dingo})
%{"ant" =&gt; 3, "buffalo" =&gt; 2, "dingo" =&gt; 1}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="frequencies_by/2">frequencies_by(enumerable, key_fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L1351" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec frequencies_by(t(), (element() -&gt; any())) :: map()</pre> </div> <p>Returns a map with keys as unique elements given by <code class="inline">key_fun</code> and values as the count of every element.</p>
<h4 id="frequencies_by/2-examples" class="section-heading"> <a href="#frequencies_by/2-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.frequencies_by(~w{aa aA bb cc}, &amp;String.downcase/1)
%{"aa" =&gt; 2, "bb" =&gt; 1, "cc" =&gt; 1}

iex&gt; Enum.frequencies_by(~w{aaa aA bbb cc c}, &amp;String.length/1)
%{3 =&gt; 2, 2 =&gt; 2, 1 =&gt; 1}</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="group_by/3">group_by(enumerable, key_fun, value_fun \\ fn x -&gt; x end)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L1406" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec group_by(t(), (element() -&gt; any()), (element() -&gt; any())) :: map()</pre> </div> <p>Splits the <code class="inline">enumerable</code> into groups based on <code class="inline">key_fun</code>.</p>
<p>The result is a map where each key is given by <code class="inline">key_fun</code> and each value is a list of elements given by <code class="inline">value_fun</code>. The order of elements within each list is preserved from the <code class="inline">enumerable</code>. However, like all maps, the resulting map is unordered.</p>
<h4 id="group_by/3-examples" class="section-heading"> <a href="#group_by/3-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.group_by(~w{ant buffalo cat dingo}, &amp;String.length/1)
%{3 =&gt; ["ant", "cat"], 5 =&gt; ["dingo"], 7 =&gt; ["buffalo"]}

iex&gt; Enum.group_by(~w{ant buffalo cat dingo}, &amp;String.length/1, &amp;String.first/1)
%{3 =&gt; ["a", "c"], 5 =&gt; ["d"], 7 =&gt; ["b"]}</pre>
<p>The key can be any Elixir value. For example, you may use a tuple to group by multiple keys:</p>
<pre data-language="elixir">iex&gt; collection = [
...&gt;   %{id: 1, lang: "Elixir", seq: 1},
...&gt;   %{id: 1, lang: "Java", seq: 1},
...&gt;   %{id: 1, lang: "Ruby", seq: 2},
...&gt;   %{id: 2, lang: "Python", seq: 1},
...&gt;   %{id: 2, lang: "C#", seq: 2},
...&gt;   %{id: 2, lang: "Haskell", seq: 2},
...&gt; ]
iex&gt; Enum.group_by(collection, &amp;{&amp;1.id, &amp;1.seq})
%{
  {1, 1} =&gt; [%{id: 1, lang: "Elixir", seq: 1}, %{id: 1, lang: "Java", seq: 1}],
  {1, 2} =&gt; [%{id: 1, lang: "Ruby", seq: 2}],
  {2, 1} =&gt; [%{id: 2, lang: "Python", seq: 1}],
  {2, 2} =&gt; [%{id: 2, lang: "C#", seq: 2}, %{id: 2, lang: "Haskell", seq: 2}]
}
iex&gt; Enum.group_by(collection, &amp;{&amp;1.id, &amp;1.seq}, &amp;{&amp;1.id, &amp;1.lang})
%{
  {1, 1} =&gt; [{1, "Elixir"}, {1, "Java"}],
  {1, 2} =&gt; [{1, "Ruby"}],
  {2, 1} =&gt; [{2, "Python"}],
  {2, 2} =&gt; [{2, "C#"}, {2, "Haskell"}]
}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="intersperse/2">intersperse(enumerable, separator)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L1450" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec intersperse(t(), element()) :: list()</pre> </div> <p>Intersperses <code class="inline">separator</code> between each element of the enumeration.</p>
<h4 id="intersperse/2-examples" class="section-heading"> <a href="#intersperse/2-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.intersperse([1, 2, 3], 0)
[1, 0, 2, 0, 3]

iex&gt; Enum.intersperse([1], 0)
[1]

iex&gt; Enum.intersperse([], 0)
[]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="into/2">into(enumerable, collectable)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L1494" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec into(Enumerable.t(), Collectable.t()) :: Collectable.t()</pre> </div> <p>Inserts the given <code class="inline">enumerable</code> into a <code class="inline">collectable</code>.</p>
<p>Note that passing a non-empty list as the <code class="inline">collectable</code> is deprecated. If you're collecting into a non-empty keyword list, consider using <code class="inline">Keyword.merge(collectable, Enum.to_list(enumerable))</code>. If you're collecting into a non-empty list, consider something like <code class="inline">Enum.to_list(enumerable) ++ collectable</code>.</p>
<h4 id="into/2-examples" class="section-heading"> <a href="#into/2-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.into([1, 2], [])
[1, 2]

iex&gt; Enum.into([a: 1, b: 2], %{})
%{a: 1, b: 2}

iex&gt; Enum.into(%{a: 1}, %{b: 2})
%{a: 1, b: 2}

iex&gt; Enum.into([a: 1, a: 2], %{})
%{a: 2}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="into/3">into(enumerable, collectable, transform)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L1573" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec into(Enumerable.t(), Collectable.t(), (term() -&gt; term())) :: Collectable.t()</pre> </div> <p>Inserts the given <code class="inline">enumerable</code> into a <code class="inline">collectable</code> according to the transformation function.</p>
<h4 id="into/3-examples" class="section-heading"> <a href="#into/3-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.into([1, 2, 3], [], fn x -&gt; x * 3 end)
[3, 6, 9]

iex&gt; Enum.into(%{a: 1, b: 2}, %{c: 3}, fn {k, v} -&gt; {k, v * 2} end)
%{a: 2, b: 4, c: 3}</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="join/2">join(enumerable, joiner \\ "")<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L1648" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec join(t(), String.t()) :: String.t()</pre> </div> <p>Joins the given <code class="inline">enumerable</code> into a string using <code class="inline">joiner</code> as a separator.</p>
<p>If <code class="inline">joiner</code> is not passed at all, it defaults to an empty string.</p>
<p>All elements in the <code class="inline">enumerable</code> must be convertible to a string, otherwise an error is raised.</p>
<h4 id="join/2-examples" class="section-heading"> <a href="#join/2-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.join([1, 2, 3])
"123"

iex&gt; Enum.join([1, 2, 3], " = ")
"1 = 2 = 3"

iex&gt; Enum.join([["a", "b"], ["c", "d", "e", ["f", "g"]], "h", "i"], " ")
"ab cdefg h i"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="map/2">map(enumerable, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L1690" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec map(t(), (element() -&gt; any())) :: list()</pre> </div> <p>Returns a list where each element is the result of invoking <code class="inline">fun</code> on each corresponding element of <code class="inline">enumerable</code>.</p>
<p>For maps, the function expects a key-value tuple.</p>
<h4 id="map/2-examples" class="section-heading"> <a href="#map/2-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.map([1, 2, 3], fn x -&gt; x * 2 end)
[2, 4, 6]

iex&gt; Enum.map([a: 1, b: 2], fn {k, v} -&gt; {k, -v} end)
[a: -1, b: -2]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="map_every/3">map_every(enumerable, nth, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L1733" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec map_every(t(), non_neg_integer(), (element() -&gt; any())) :: list()</pre> </div> <p>Returns a list of results of invoking <code class="inline">fun</code> on every <code class="inline">nth</code> element of <code class="inline">enumerable</code>, starting with the first element.</p>
<p>The first element is always passed to the given function, unless <code class="inline">nth</code> is <code class="inline">0</code>.</p>
<p>The second argument specifying every <code class="inline">nth</code> element must be a non-negative integer.</p>
<p>If <code class="inline">nth</code> is <code class="inline">0</code>, then <code class="inline">enumerable</code> is directly converted to a list, without <code class="inline">fun</code> being ever applied.</p>
<h4 id="map_every/3-examples" class="section-heading"> <a href="#map_every/3-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.map_every(1..10, 2, fn x -&gt; x + 1000 end)
[1001, 2, 1003, 4, 1005, 6, 1007, 8, 1009, 10]

iex&gt; Enum.map_every(1..10, 3, fn x -&gt; x + 1000 end)
[1001, 2, 3, 1004, 5, 6, 1007, 8, 9, 1010]

iex&gt; Enum.map_every(1..5, 0, fn x -&gt; x + 1000 end)
[1, 2, 3, 4, 5]

iex&gt; Enum.map_every([1, 2, 3], 1, fn x -&gt; x + 1000 end)
[1001, 1002, 1003]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="map_intersperse/3">map_intersperse(enumerable, separator, mapper)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L1754" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec map_intersperse(t(), element(), (element() -&gt; any())) :: list()</pre> </div> <p>Maps and intersperses the given enumerable in one pass.</p>
<h4 id="map_intersperse/3-examples" class="section-heading"> <a href="#map_intersperse/3-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.map_intersperse([1, 2, 3], :a, &amp;(&amp;1 * 2))
[2, :a, 4, :a, 6]</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="map_join/3">map_join(enumerable, joiner \\ "", mapper)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L1792" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec map_join(t(), String.t(), (element() -&gt; String.Chars.t())) :: String.t()</pre> </div> <p>Maps and joins the given <code class="inline">enumerable</code> in one pass.</p>
<p>If <code class="inline">joiner</code> is not passed at all, it defaults to an empty string.</p>
<p>All elements returned from invoking the <code class="inline">mapper</code> must be convertible to a string, otherwise an error is raised.</p>
<h4 id="map_join/3-examples" class="section-heading"> <a href="#map_join/3-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.map_join([1, 2, 3], &amp;(&amp;1 * 2))
"246"

iex&gt; Enum.map_join([1, 2, 3], " = ", &amp;(&amp;1 * 2))
"2 = 4 = 6"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="map_reduce/3">map_reduce(enumerable, acc, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L1818" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec map_reduce(t(), acc(), (element(), acc() -&gt; {element(), acc()})) ::
  {list(), acc()}</pre> </div> <p>Invokes the given function to each element in the <code class="inline">enumerable</code> to reduce it to a single element, while keeping an accumulator.</p>
<p>Returns a tuple where the first element is the mapped enumerable and the second one is the final accumulator.</p>
<p>The function, <code class="inline">fun</code>, receives two arguments: the first one is the element, and the second one is the accumulator. <code class="inline">fun</code> must return a tuple with two elements in the form of <code class="inline">{result, accumulator}</code>.</p>
<p>For maps, the first tuple element must be a <code class="inline">{key, value}</code> tuple.</p>
<h4 id="map_reduce/3-examples" class="section-heading"> <a href="#map_reduce/3-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.map_reduce([1, 2, 3], 0, fn x, acc -&gt; {x * 2, x + acc} end)
{[2, 4, 6], 6}</pre> </section> </section> <section class="detail">   <h3 class="detail-header" id="max/3">max(enumerable, sorter \\ &amp;&gt;=/2, empty_fallback \\ fn -&gt; raise Enum.EmptyError end)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L1894" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec max(t(), (element(), element() -&gt; boolean()) | module(), (-&gt; empty_result)) ::
  element() | empty_result
when empty_result: any()</pre> </div> <p>Returns the maximal element in the <code class="inline">enumerable</code> according to Erlang's term ordering.</p>
<p>By default, the comparison is done with the <code class="inline">&gt;=</code> sorter function. If multiple elements are considered maximal, the first one that was found is returned. If you want the last element considered maximal to be returned, the sorter function should not return true for equal elements.</p>
<p>If the enumerable is empty, the provided <code class="inline">empty_fallback</code> is called. The default <code class="inline">empty_fallback</code> raises <a href="enum.emptyerror.html"><code class="inline">Enum.EmptyError</code></a>.</p>
<h4 id="max/3-examples" class="section-heading"> <a href="#max/3-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.max([1, 2, 3])
3</pre>
<p>The fact this function uses Erlang's term ordering means that the comparison is structural and not semantic. For example:</p>
<pre data-language="elixir">iex&gt; Enum.max([~D[2017-03-31], ~D[2017-04-01]])
~D[2017-03-31]</pre>
<p>In the example above, <a href="#max/2"><code class="inline">max/2</code></a> returned March 31st instead of April 1st because the structural comparison compares the day before the year. For this reason, most structs provide a "compare" function, such as <a href="date.html#compare/2"><code class="inline">Date.compare/2</code></a>, which receives two structs and returns <code class="inline">:lt</code> (less-than), <code class="inline">:eq</code> (equal to), and <code class="inline">:gt</code> (greater-than). If you pass a module as the sorting function, Elixir will automatically use the <code class="inline">compare/2</code> function of said module:</p>
<pre data-language="elixir">iex&gt; Enum.max([~D[2017-03-31], ~D[2017-04-01]], Date)
~D[2017-04-01]</pre>
<p>Finally, if you don't want to raise on empty enumerables, you can pass the empty fallback:</p>
<pre data-language="elixir">iex&gt; Enum.max([], &amp;&gt;=/2, fn -&gt; 0 end)
0</pre> </section> </section> <section class="detail">   <h3 class="detail-header" id="max_by/4">max_by(enumerable, fun, sorter \\ &amp;&gt;=/2, empty_fallback \\ fn -&gt; raise Enum.EmptyError end)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L1964" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec max_by(
  t(),
  (element() -&gt; any()),
  (element(), element() -&gt; boolean()) | module(),
  (-&gt; empty_result)
) :: element() | empty_result
when empty_result: any()</pre> </div> <p>Returns the maximal element in the <code class="inline">enumerable</code> as calculated by the given <code class="inline">fun</code>.</p>
<p>By default, the comparison is done with the <code class="inline">&gt;=</code> sorter function. If multiple elements are considered maximal, the first one that was found is returned. If you want the last element considered maximal to be returned, the sorter function should not return true for equal elements.</p>
<p>Calls the provided <code class="inline">empty_fallback</code> function and returns its value if <code class="inline">enumerable</code> is empty. The default <code class="inline">empty_fallback</code> raises <a href="enum.emptyerror.html"><code class="inline">Enum.EmptyError</code></a>.</p>
<h4 id="max_by/4-examples" class="section-heading"> <a href="#max_by/4-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.max_by(["a", "aa", "aaa"], fn x -&gt; String.length(x) end)
"aaa"

iex&gt; Enum.max_by(["a", "aa", "aaa", "b", "bbb"], &amp;String.length/1)
"aaa"</pre>
<p>The fact this function uses Erlang's term ordering means that the comparison is structural and not semantic. Therefore, if you want to compare structs, most structs provide a "compare" function, such as <a href="date.html#compare/2"><code class="inline">Date.compare/2</code></a>, which receives two structs and returns <code class="inline">:lt</code> (less-than), <code class="inline">:eq</code> (equal to), and <code class="inline">:gt</code> (greater-than). If you pass a module as the sorting function, Elixir will automatically use the <code class="inline">compare/2</code> function of said module:</p>
<pre data-language="elixir">iex&gt; users = [
...&gt;   %{name: "Ellis", birthday: ~D[1943-05-11]},
...&gt;   %{name: "Lovelace", birthday: ~D[1815-12-10]},
...&gt;   %{name: "Turing", birthday: ~D[1912-06-23]}
...&gt; ]
iex&gt; Enum.max_by(users, &amp;(&amp;1.birthday), Date)
%{name: "Ellis", birthday: ~D[1943-05-11]}</pre>
<p>Finally, if you don't want to raise on empty enumerables, you can pass the empty fallback:</p>
<pre data-language="elixir">iex&gt; Enum.max_by([], &amp;String.length/1, fn -&gt; nil end)
nil</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="member?/2">member?(enumerable, element)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L1994" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec member?(t(), element()) :: boolean()</pre> </div> <p>Checks if <code class="inline">element</code> exists within the <code class="inline">enumerable</code>.</p>
<p>Membership is tested with the match (<a href="kernel.html#===/2"><code class="inline">===/2</code></a>) operator.</p>
<h4 id="member?/2-examples" class="section-heading"> <a href="#member?/2-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.member?(1..10, 5)
true
iex&gt; Enum.member?(1..10, 5.0)
false

iex&gt; Enum.member?([1.0, 2.0, 3.0], 2)
false
iex&gt; Enum.member?([1.0, 2.0, 3.0], 2.000)
true

iex&gt; Enum.member?([:a, :b, :c], :d)
false</pre>
<p>When called outside guards, the <a href="kernel.html#in/2"><code class="inline">in</code></a> and <a href="kernel.html#in/2"><code class="inline">not in</code></a> operators work by using this function.</p> </section> </section> <section class="detail">   <h3 class="detail-header" id="min/3">min(enumerable, sorter \\ &amp;&lt;=/2, empty_fallback \\ fn -&gt; raise Enum.EmptyError end)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L2074" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec min(t(), (element(), element() -&gt; boolean()) | module(), (-&gt; empty_result)) ::
  element() | empty_result
when empty_result: any()</pre> </div> <p>Returns the minimal element in the <code class="inline">enumerable</code> according to Erlang's term ordering.</p>
<p>By default, the comparison is done with the <code class="inline">&lt;=</code> sorter function. If multiple elements are considered minimal, the first one that was found is returned. If you want the last element considered minimal to be returned, the sorter function should not return true for equal elements.</p>
<p>If the enumerable is empty, the provided <code class="inline">empty_fallback</code> is called. The default <code class="inline">empty_fallback</code> raises <a href="enum.emptyerror.html"><code class="inline">Enum.EmptyError</code></a>.</p>
<h4 id="min/3-examples" class="section-heading"> <a href="#min/3-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.min([1, 2, 3])
1</pre>
<p>The fact this function uses Erlang's term ordering means that the comparison is structural and not semantic. For example:</p>
<pre data-language="elixir">iex&gt; Enum.min([~D[2017-03-31], ~D[2017-04-01]])
~D[2017-04-01]</pre>
<p>In the example above, <a href="#min/2"><code class="inline">min/2</code></a> returned April 1st instead of March 31st because the structural comparison compares the day before the year. For this reason, most structs provide a "compare" function, such as <a href="date.html#compare/2"><code class="inline">Date.compare/2</code></a>, which receives two structs and returns <code class="inline">:lt</code> (less-than), <code class="inline">:eq</code> (equal to), and <code class="inline">:gt</code> (greater-than). If you pass a module as the sorting function, Elixir will automatically use the <code class="inline">compare/2</code> function of said module:</p>
<pre data-language="elixir">iex&gt; Enum.min([~D[2017-03-31], ~D[2017-04-01]], Date)
~D[2017-03-31]</pre>
<p>Finally, if you don't want to raise on empty enumerables, you can pass the empty fallback:</p>
<pre data-language="elixir">iex&gt; Enum.min([], fn -&gt; 0 end)
0</pre> </section> </section> <section class="detail">   <h3 class="detail-header" id="min_by/4">min_by(enumerable, fun, sorter \\ &amp;&lt;=/2, empty_fallback \\ fn -&gt; raise Enum.EmptyError end)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L2144" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec min_by(
  t(),
  (element() -&gt; any()),
  (element(), element() -&gt; boolean()) | module(),
  (-&gt; empty_result)
) :: element() | empty_result
when empty_result: any()</pre> </div> <p>Returns the minimal element in the <code class="inline">enumerable</code> as calculated by the given <code class="inline">fun</code>.</p>
<p>By default, the comparison is done with the <code class="inline">&lt;=</code> sorter function. If multiple elements are considered minimal, the first one that was found is returned. If you want the last element considered minimal to be returned, the sorter function should not return true for equal elements.</p>
<p>Calls the provided <code class="inline">empty_fallback</code> function and returns its value if <code class="inline">enumerable</code> is empty. The default <code class="inline">empty_fallback</code> raises <a href="enum.emptyerror.html"><code class="inline">Enum.EmptyError</code></a>.</p>
<h4 id="min_by/4-examples" class="section-heading"> <a href="#min_by/4-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.min_by(["a", "aa", "aaa"], fn x -&gt; String.length(x) end)
"a"

iex&gt; Enum.min_by(["a", "aa", "aaa", "b", "bbb"], &amp;String.length/1)
"a"</pre>
<p>The fact this function uses Erlang's term ordering means that the comparison is structural and not semantic. Therefore, if you want to compare structs, most structs provide a "compare" function, such as <a href="date.html#compare/2"><code class="inline">Date.compare/2</code></a>, which receives two structs and returns <code class="inline">:lt</code> (less-than), <code class="inline">:eq</code> (equal to), and <code class="inline">:gt</code> (greater-than). If you pass a module as the sorting function, Elixir will automatically use the <code class="inline">compare/2</code> function of said module:</p>
<pre data-language="elixir">iex&gt; users = [
...&gt;   %{name: "Ellis", birthday: ~D[1943-05-11]},
...&gt;   %{name: "Lovelace", birthday: ~D[1815-12-10]},
...&gt;   %{name: "Turing", birthday: ~D[1912-06-23]}
...&gt; ]
iex&gt; Enum.min_by(users, &amp;(&amp;1.birthday), Date)
%{name: "Lovelace", birthday: ~D[1815-12-10]}</pre>
<p>Finally, if you don't want to raise on empty enumerables, you can pass the empty fallback:</p>
<pre data-language="elixir">iex&gt; Enum.min_by([], &amp;String.length/1, fn -&gt; nil end)
nil</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="min_max/2">min_max(enumerable, empty_fallback \\ fn -&gt; raise Enum.EmptyError end)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L2170" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec min_max(t(), (-&gt; empty_result)) :: {element(), element()} | empty_result
when empty_result: any()</pre> </div> <p>Returns a tuple with the minimal and the maximal elements in the enumerable according to Erlang's term ordering.</p>
<p>If multiple elements are considered maximal or minimal, the first one that was found is returned.</p>
<p>Calls the provided <code class="inline">empty_fallback</code> function and returns its value if <code class="inline">enumerable</code> is empty. The default <code class="inline">empty_fallback</code> raises <a href="enum.emptyerror.html"><code class="inline">Enum.EmptyError</code></a>.</p>
<h4 id="min_max/2-examples" class="section-heading"> <a href="#min_max/2-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.min_max([2, 3, 1])
{1, 3}

iex&gt; Enum.min_max([], fn -&gt; {nil, nil} end)
{nil, nil}</pre> </section> </section> <section class="detail">   <h3 class="detail-header" id="min_max_by/4">min_max_by(enumerable, fun, sorter_or_empty_fallback \\ &amp;&lt;/2, empty_fallback \\ fn -&gt; raise Enum.EmptyError end)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L2258" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec min_max_by(
  t(),
  (element() -&gt; any()),
  (element(), element() -&gt; boolean()) | module(),
  (-&gt; empty_result)
) :: {element(), element()} | empty_result
when empty_result: any()</pre> </div> <p>Returns a tuple with the minimal and the maximal elements in the enumerable as calculated by the given function.</p>
<p>If multiple elements are considered maximal or minimal, the first one that was found is returned.</p>
<h4 id="min_max_by/4-examples" class="section-heading"> <a href="#min_max_by/4-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.min_max_by(["aaa", "bb", "c"], fn x -&gt; String.length(x) end)
{"c", "aaa"}

iex&gt; Enum.min_max_by(["aaa", "a", "bb", "c", "ccc"], &amp;String.length/1)
{"a", "aaa"}

iex&gt; Enum.min_max_by([], &amp;String.length/1, fn -&gt; {nil, nil} end)
{nil, nil}</pre>
<p>The fact this function uses Erlang's term ordering means that the comparison is structural and not semantic. Therefore, if you want to compare structs, most structs provide a "compare" function, such as <a href="date.html#compare/2"><code class="inline">Date.compare/2</code></a>, which receives two structs and returns <code class="inline">:lt</code> (less-than), <code class="inline">:eq</code> (equal to), and <code class="inline">:gt</code> (greater-than). If you pass a module as the sorting function, Elixir will automatically use the <code class="inline">compare/2</code> function of said module:</p>
<pre data-language="elixir">iex&gt; users = [
...&gt;   %{name: "Ellis", birthday: ~D[1943-05-11]},
...&gt;   %{name: "Lovelace", birthday: ~D[1815-12-10]},
...&gt;   %{name: "Turing", birthday: ~D[1912-06-23]}
...&gt; ]
iex&gt; Enum.min_max_by(users, &amp;(&amp;1.birthday), Date)
{
  %{name: "Lovelace", birthday: ~D[1815-12-10]},
  %{name: "Ellis", birthday: ~D[1943-05-11]}
}</pre>
<p>Finally, if you don't want to raise on empty enumerables, you can pass the empty fallback:</p>
<pre data-language="elixir">iex&gt; Enum.min_max_by([], &amp;String.length/1, fn -&gt; nil end)
nil</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="product/1">product(enumerable)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L3462" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec product(t()) :: number()</pre> </div> <p>Returns the product of all elements.</p>
<p>Raises <a href="arithmeticerror.html"><code class="inline">ArithmeticError</code></a> if <code class="inline">enumerable</code> contains a non-numeric value.</p>
<h4 id="product/1-examples" class="section-heading"> <a href="#product/1-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.product([])
1
iex&gt; Enum.product([2, 3, 4])
24
iex&gt; Enum.product([2.0, 3.0, 4.0])
24.0</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="random/1">random(enumerable)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L2384" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec random(t()) :: element()</pre> </div> <p>Returns a random element of an <code class="inline">enumerable</code>.</p>
<p>Raises <a href="enum.emptyerror.html"><code class="inline">Enum.EmptyError</code></a> if <code class="inline">enumerable</code> is empty.</p>
<p>This function uses Erlang's <a href="https://www.erlang.org/doc/man/rand.html"><code class="inline">:rand</code> module</a> to calculate the random value. Check its documentation for setting a different random algorithm or a different seed.</p>
<p>The implementation is based on the <a href="https://en.wikipedia.org/wiki/Reservoir_sampling#Relation_to_Fisher-Yates_shuffle">reservoir sampling</a> algorithm. It assumes that the sample being returned can fit into memory; the input <code class="inline">enumerable</code> doesn't have to, as it is traversed just once.</p>
<p>If a range is passed into the function, this function will pick a random value between the range limits, without traversing the whole range (thus executing in constant time and constant memory).</p>
<h4 id="random/1-examples" class="section-heading"> <a href="#random/1-examples">  Examples </a> </h4> <p>The examples below use the <code class="inline">:exsss</code> pseudorandom algorithm since it's the default from Erlang/OTP 22:</p>
<pre data-language="elixir"># Although not necessary, let's seed the random algorithm
iex&gt; :rand.seed(:exsss, {100, 101, 102})
iex&gt; Enum.random([1, 2, 3])
2
iex&gt; Enum.random([1, 2, 3])
1
iex&gt; Enum.random(1..1_000)
309</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="reduce/2">reduce(enumerable, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L2446" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec reduce(t(), (element(), acc() -&gt; acc())) :: acc()</pre> </div> <p>Invokes <code class="inline">fun</code> for each element in the <code class="inline">enumerable</code> with the accumulator.</p>
<p>Raises <a href="enum.emptyerror.html"><code class="inline">Enum.EmptyError</code></a> if <code class="inline">enumerable</code> is empty.</p>
<p>The first element of the <code class="inline">enumerable</code> is used as the initial value of the accumulator. Then, the function is invoked with the next element and the accumulator. The result returned by the function is used as the accumulator for the next iteration, recursively. When the <code class="inline">enumerable</code> is done, the last accumulator is returned.</p>
<p>Since the first element of the enumerable is used as the initial value of the accumulator, <code class="inline">fun</code> will only be executed <code class="inline">n - 1</code> times where <code class="inline">n</code> is the length of the enumerable. This function won't call the specified function for enumerables that are one-element long.</p>
<p>If you wish to use another value for the accumulator, use <a href="#reduce/3"><code class="inline">Enum.reduce/3</code></a>.</p>
<h4 id="reduce/2-examples" class="section-heading"> <a href="#reduce/2-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.reduce([1, 2, 3, 4], fn x, acc -&gt; x * acc end)
24</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="reduce/3">reduce(enumerable, acc, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L2509" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec reduce(t(), acc(), (element(), acc() -&gt; acc())) :: acc()</pre> </div> <p>Invokes <code class="inline">fun</code> for each element in the <code class="inline">enumerable</code> with the accumulator.</p>
<p>The initial value of the accumulator is <code class="inline">acc</code>. The function is invoked for each element in the enumerable with the accumulator. The result returned by the function is used as the accumulator for the next iteration. The function returns the last accumulator.</p>
<h4 id="reduce/3-examples" class="section-heading"> <a href="#reduce/3-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.reduce([1, 2, 3], 0, fn x, acc -&gt; x + acc end)
6

iex&gt; Enum.reduce(%{a: 2, b: 3, c: 4}, 0, fn {_key, val}, acc -&gt; acc + val end)
9</pre>
<h4 id="reduce/3-reduce-as-a-building-block" class="section-heading"> <a href="#reduce/3-reduce-as-a-building-block">  Reduce as a building block </a> </h4> <p>Reduce (sometimes called <code class="inline">fold</code>) is a basic building block in functional programming. Almost all of the functions in the <a href="enum.html#content"><code class="inline">Enum</code></a> module can be implemented on top of reduce. Those functions often rely on other operations, such as <a href="#reverse/1"><code class="inline">Enum.reverse/1</code></a>, which are optimized by the runtime.</p>
<p>For example, we could implement <a href="#map/2"><code class="inline">map/2</code></a> in terms of <a href="#reduce/3"><code class="inline">reduce/3</code></a> as follows:</p>
<pre data-language="elixir">def my_map(enumerable, fun) do
  enumerable
  |&gt; Enum.reduce([], fn x, acc -&gt; [fun.(x) | acc] end)
  |&gt; Enum.reverse()
end</pre>
<p>In the example above, <a href="#reduce/3"><code class="inline">Enum.reduce/3</code></a> accumulates the result of each call to <code class="inline">fun</code> into a list in reverse order, which is correctly ordered at the end by calling <a href="#reverse/1"><code class="inline">Enum.reverse/1</code></a>.</p>
<p>Implementing functions like <a href="#map/2"><code class="inline">map/2</code></a>, <a href="#filter/2"><code class="inline">filter/2</code></a> and others are a good exercise for understanding the power behind <a href="#reduce/3"><code class="inline">Enum.reduce/3</code></a>. When an operation cannot be expressed by any of the functions in the <a href="enum.html#content"><code class="inline">Enum</code></a> module, developers will most likely resort to <a href="#reduce/3"><code class="inline">reduce/3</code></a>.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="reduce_while/3">reduce_while(enumerable, acc, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L2563" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec reduce_while(t(), any(), (element(), any() -&gt; {:cont, any()} | {:halt, any()})) ::
  any()</pre> </div> <p>Reduces <code class="inline">enumerable</code> until <code class="inline">fun</code> returns <code class="inline">{:halt, term}</code>.</p>
<p>The return value for <code class="inline">fun</code> is expected to be</p>
<ul>
<li>
<code class="inline">{:cont, acc}</code> to continue the reduction with <code class="inline">acc</code> as the new accumulator or</li>
<li>
<code class="inline">{:halt, acc}</code> to halt the reduction</li>
</ul>
<p>If <code class="inline">fun</code> returns <code class="inline">{:halt, acc}</code> the reduction is halted and the function returns <code class="inline">acc</code>. Otherwise, if the enumerable is exhausted, the function returns the accumulator of the last <code class="inline">{:cont, acc}</code>.</p>
<h4 id="reduce_while/3-examples" class="section-heading"> <a href="#reduce_while/3-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.reduce_while(1..100, 0, fn x, acc -&gt;
...&gt;   if x &lt; 5 do
...&gt;     {:cont, acc + x}
...&gt;   else
...&gt;     {:halt, acc}
...&gt;   end
...&gt; end)
10
iex&gt; Enum.reduce_while(1..100, 0, fn x, acc -&gt;
...&gt;   if x &gt; 0 do
...&gt;     {:cont, acc + x}
...&gt;   else
...&gt;     {:halt, acc}
...&gt;   end
...&gt; end)
5050</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="reject/2">reject(enumerable, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L2580" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec reject(t(), (element() -&gt; as_boolean(term()))) :: list()</pre> </div> <p>Returns a list of elements in <code class="inline">enumerable</code> excluding those for which the function <code class="inline">fun</code> returns a truthy value.</p>
<p>See also <a href="#filter/2"><code class="inline">filter/2</code></a>.</p>
<h4 id="reject/2-examples" class="section-heading"> <a href="#reject/2-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.reject([1, 2, 3], fn x -&gt; rem(x, 2) == 0 end)
[1, 3]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="reverse/1">reverse(enumerable)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L2598" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec reverse(t()) :: list()</pre> </div> <p>Returns a list of elements in <code class="inline">enumerable</code> in reverse order.</p>
<h4 id="reverse/1-examples" class="section-heading"> <a href="#reverse/1-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.reverse([1, 2, 3])
[3, 2, 1]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="reverse/2">reverse(enumerable, tail)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L2620" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec reverse(t(), t()) :: list()</pre> </div> <p>Reverses the elements in <code class="inline">enumerable</code>, appends the <code class="inline">tail</code>, and returns it as a list.</p>
<p>This is an optimization for <code class="inline">enumerable |&gt; Enum.reverse() |&gt; Enum.concat(tail)</code>.</p>
<h4 id="reverse/2-examples" class="section-heading"> <a href="#reverse/2-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.reverse([1, 2, 3], [4, 5, 6])
[3, 2, 1, 4, 5, 6]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="reverse_slice/3">reverse_slice(enumerable, start_index, count)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L2644" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec reverse_slice(t(), non_neg_integer(), non_neg_integer()) :: list()</pre> </div> <p>Reverses the <code class="inline">enumerable</code> in the range from initial <code class="inline">start_index</code> through <code class="inline">count</code> elements.</p>
<p>If <code class="inline">count</code> is greater than the size of the rest of the <code class="inline">enumerable</code>, then this function will reverse the rest of the enumerable.</p>
<h4 id="reverse_slice/3-examples" class="section-heading"> <a href="#reverse_slice/3-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.reverse_slice([1, 2, 3, 4, 5, 6], 2, 4)
[1, 2, 6, 5, 4, 3]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="scan/2">scan(enumerable, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L2839" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec scan(t(), (element(), any() -&gt; any())) :: list()</pre> </div> <p>Applies the given function to each element in the <code class="inline">enumerable</code>, storing the result in a list and passing it as the accumulator for the next computation. Uses the first element in the <code class="inline">enumerable</code> as the starting value.</p>
<h4 id="scan/2-examples" class="section-heading"> <a href="#scan/2-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.scan(1..5, &amp;(&amp;1 + &amp;2))
[1, 3, 6, 10, 15]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="scan/3">scan(enumerable, acc, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L2865" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec scan(t(), any(), (element(), any() -&gt; any())) :: list()</pre> </div> <p>Applies the given function to each element in the <code class="inline">enumerable</code>, storing the result in a list and passing it as the accumulator for the next computation. Uses the given <code class="inline">acc</code> as the starting value.</p>
<h4 id="scan/3-examples" class="section-heading"> <a href="#scan/3-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.scan(1..5, 0, &amp;(&amp;1 + &amp;2))
[1, 3, 6, 10, 15]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="shuffle/1">shuffle(enumerable)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L2895" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec shuffle(t()) :: list()</pre> </div> <p>Returns a list with the elements of <code class="inline">enumerable</code> shuffled.</p>
<p>This function uses Erlang's <a href="https://www.erlang.org/doc/man/rand.html"><code class="inline">:rand</code> module</a> to calculate the random value. Check its documentation for setting a different random algorithm or a different seed.</p>
<h4 id="shuffle/1-examples" class="section-heading"> <a href="#shuffle/1-examples">  Examples </a> </h4> <p>The examples below use the <code class="inline">:exsss</code> pseudorandom algorithm since it's the default from Erlang/OTP 22:</p>
<pre data-language="elixir"># Although not necessary, let's seed the random algorithm
iex&gt; :rand.seed(:exsss, {1, 2, 3})
iex&gt; Enum.shuffle([1, 2, 3])
[3, 2, 1]
iex&gt; Enum.shuffle([1, 2, 3])
[2, 1, 3]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="slice/2">slice(enumerable, index_range)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L2969" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec slice(t(), Range.t()) :: list()</pre> </div> <p>Returns a subset list of the given <code class="inline">enumerable</code> by <code class="inline">index_range</code>.</p>
<p><code class="inline">index_range</code> must be a <a href="range.html"><code class="inline">Range</code></a>. Given an <code class="inline">enumerable</code>, it drops elements before <code class="inline">index_range.first</code> (zero-base), then it takes elements until element <code class="inline">index_range.last</code> (inclusively).</p>
<p>Indexes are normalized, meaning that negative indexes will be counted from the end (for example, <code class="inline">-1</code> means the last element of the <code class="inline">enumerable</code>).</p>
<p>If <code class="inline">index_range.last</code> is out of bounds, then it is assigned as the index of the last element.</p>
<p>If the normalized <code class="inline">index_range.first</code> is out of bounds of the given <code class="inline">enumerable</code>, or this one is greater than the normalized <code class="inline">index_range.last</code>, then <code class="inline">[]</code> is returned.</p>
<p>If a step <code class="inline">n</code> (other than <code class="inline">1</code>) is used in <code class="inline">index_range</code>, then it takes every <code class="inline">n</code>th element from <code class="inline">index_range.first</code> to <code class="inline">index_range.last</code> (according to the same rules described above).</p>
<h4 id="slice/2-examples" class="section-heading"> <a href="#slice/2-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.slice([1, 2, 3, 4, 5], 1..3)
[2, 3, 4]

iex&gt; Enum.slice([1, 2, 3, 4, 5], 3..10)
[4, 5]

# Last three elements (negative indexes)
iex&gt; Enum.slice([1, 2, 3, 4, 5], -3..-1)
[3, 4, 5]</pre>
<p>For ranges where <code class="inline">start &gt; stop</code>, you need to explicit mark them as increasing:</p>
<pre data-language="elixir">iex&gt; Enum.slice([1, 2, 3, 4, 5], 1..-2//1)
[2, 3, 4]</pre>
<p>The step can be any positive number. For example, to get every 2 elements of the collection:</p>
<pre data-language="elixir">iex&gt; Enum.slice([1, 2, 3, 4, 5], 0..-1//2)
[1, 3, 5]</pre>
<p>To get every third element of the first ten elements:</p>
<pre data-language="elixir">iex&gt; integers = Enum.to_list(1..20)
iex&gt; Enum.slice(integers, 0..9//3)
[1, 4, 7, 10]</pre>
<p>If the first position is after the end of the enumerable or after the last position of the range, it returns an empty list:</p>
<pre data-language="elixir">iex&gt; Enum.slice([1, 2, 3, 4, 5], 6..10)
[]

# first is greater than last
iex&gt; Enum.slice([1, 2, 3, 4, 5], 6..5)
[]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="slice/3">slice(enumerable, start_index, amount)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L3060" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec slice(t(), index(), non_neg_integer()) :: list()</pre> </div> <p>Returns a subset list of the given <code class="inline">enumerable</code>, from <code class="inline">start_index</code> (zero-based) with <code class="inline">amount</code> number of elements if available.</p>
<p>Given an <code class="inline">enumerable</code>, it drops elements right before element <code class="inline">start_index</code>; then, it takes <code class="inline">amount</code> of elements, returning as many elements as possible if there are not enough elements.</p>
<p>A negative <code class="inline">start_index</code> can be passed, which means the <code class="inline">enumerable</code> is enumerated once and the index is counted from the end (for example, <code class="inline">-1</code> starts slicing from the last element).</p>
<p>It returns <code class="inline">[]</code> if <code class="inline">amount</code> is <code class="inline">0</code> or if <code class="inline">start_index</code> is out of bounds.</p>
<h4 id="slice/3-examples" class="section-heading"> <a href="#slice/3-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.slice(1..100, 5, 10)
[6, 7, 8, 9, 10, 11, 12, 13, 14, 15]

# amount to take is greater than the number of elements
iex&gt; Enum.slice(1..10, 5, 100)
[6, 7, 8, 9, 10]

iex&gt; Enum.slice(1..10, 5, 0)
[]

# using a negative start index
iex&gt; Enum.slice(1..10, -6, 3)
[5, 6, 7]
iex&gt; Enum.slice(1..10, -11, 5)
[1, 2, 3, 4, 5]

# out of bound start index
iex&gt; Enum.slice(1..10, 10, 5)
[]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="slide/3">slide(enumerable, range_or_single_index, insertion_index)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L2705" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec slide(t(), Range.t() | index(), index()) :: list()</pre> </div> <p>Slides a single or multiple elements given by <code class="inline">range_or_single_index</code> from <code class="inline">enumerable</code> to <code class="inline">insertion_index</code>.</p>
<p>The semantics of the range to be moved match the semantics of <a href="#slice/2"><code class="inline">Enum.slice/2</code></a>. Specifically, that means:</p>
<ul>
<li><p>Indices are normalized, meaning that negative indexes will be counted from the end (for example, -1 means the last element of the enumerable). This will result in <em>two</em> traversals of your enumerable on types like lists that don't provide a constant-time count.</p></li>
<li><p>If the normalized index range's <code class="inline">last</code> is out of bounds, the range is truncated to the last element.</p></li>
<li><p>If the normalized index range's <code class="inline">first</code> is out of bounds, the selected range for sliding will be empty, so you'll get back your input list.</p></li>
<li><p>Decreasing ranges (such as <code class="inline">5..0//1</code>) also select an empty range to be moved, so you'll get back your input list.</p></li>
<li><p>Ranges with any step but 1 will raise an error.</p></li>
</ul>
<h4 id="slide/3-examples" class="section-heading"> <a href="#slide/3-examples">  Examples </a> </h4> <pre data-language="elixir"># Slide a single element
iex&gt; Enum.slide([:a, :b, :c, :d, :e, :f, :g], 5, 1)
[:a, :f, :b, :c, :d, :e, :g]

# Slide a range of elements backward
iex&gt; Enum.slide([:a, :b, :c, :d, :e, :f, :g], 3..5, 1)
[:a, :d, :e, :f, :b, :c, :g]

# Slide a range of elements forward
iex&gt; Enum.slide([:a, :b, :c, :d, :e, :f, :g], 1..3, 5)
[:a, :e, :f, :b, :c, :d, :g]

# Slide with negative indices (counting from the end)
iex&gt; Enum.slide([:a, :b, :c, :d, :e, :f, :g], 3..-1//1, 2)
[:a, :b, :d, :e, :f, :g, :c]
iex&gt; Enum.slide([:a, :b, :c, :d, :e, :f, :g], -4..-2, 1)
[:a, :d, :e, :f, :b, :c, :g]

# Insert at negative indices (counting from the end)
iex&gt; Enum.slide([:a, :b, :c, :d, :e, :f, :g], 3, -1)
[:a, :b, :c, :e, :f, :g, :d]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="sort/1">sort(enumerable)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L3093" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec sort(t()) :: list()</pre> </div> <p>Sorts the <code class="inline">enumerable</code> according to Erlang's term ordering.</p>
<p>This function uses the merge sort algorithm. Do not use this function to sort structs, see <a href="#sort/2"><code class="inline">sort/2</code></a> for more information.</p>
<h4 id="sort/1-examples" class="section-heading"> <a href="#sort/1-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.sort([3, 2, 1])
[1, 2, 3]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="sort/2">sort(enumerable, sorter)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L3177" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec sort(
  t(),
  (element(), element() -&gt; boolean())
  | :asc
  | :desc
  | module()
  | {:asc | :desc, module()}
) :: list()</pre> </div> <p>Sorts the <code class="inline">enumerable</code> by the given function.</p>
<p>This function uses the merge sort algorithm. The given function should compare two arguments, and return <code class="inline">true</code> if the first argument precedes or is in the same place as the second one.</p>
<h4 id="sort/2-examples" class="section-heading"> <a href="#sort/2-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.sort([1, 2, 3], &amp;(&amp;1 &gt;= &amp;2))
[3, 2, 1]</pre>
<p>The sorting algorithm will be stable as long as the given function returns <code class="inline">true</code> for values considered equal:</p>
<pre data-language="elixir">iex&gt; Enum.sort(["some", "kind", "of", "monster"], &amp;(byte_size(&amp;1) &lt;= byte_size(&amp;2)))
["of", "some", "kind", "monster"]</pre>
<p>If the function does not return <code class="inline">true</code> for equal values, the sorting is not stable and the order of equal terms may be shuffled. For example:</p>
<pre data-language="elixir">iex&gt; Enum.sort(["some", "kind", "of", "monster"], &amp;(byte_size(&amp;1) &lt; byte_size(&amp;2)))
["of", "kind", "some", "monster"]</pre>
<h4 id="sort/2-ascending-and-descending-since-v1-10-0" class="section-heading"> <a href="#sort/2-ascending-and-descending-since-v1-10-0">  Ascending and descending (since v1.10.0) </a> </h4> <p><a href="#sort/2"><code class="inline">sort/2</code></a> allows a developer to pass <code class="inline">:asc</code> or <code class="inline">:desc</code> as the sorter, which is a convenience for <a href="kernel.html#%3C=/2"><code class="inline">&amp;&lt;=/2</code></a> and <a href="kernel.html#%3E=/2"><code class="inline">&amp;&gt;=/2</code></a> respectively.</p>
<pre data-language="elixir">iex&gt; Enum.sort([2, 3, 1], :asc)
[1, 2, 3]
iex&gt; Enum.sort([2, 3, 1], :desc)
[3, 2, 1]</pre>
<h4 id="sort/2-sorting-structs" class="section-heading"> <a href="#sort/2-sorting-structs">  Sorting structs </a> </h4> <p>Do not use <a href="kernel.html#%3C/2"><code class="inline">&lt;/2</code></a>, <a href="kernel.html#%3C=/2"><code class="inline">&lt;=/2</code></a>, <a href="kernel.html#%3E/2"><code class="inline">&gt;/2</code></a>, <a href="kernel.html#%3E=/2"><code class="inline">&gt;=/2</code></a> and friends when sorting structs. That's because the built-in operators above perform structural comparison and not a semantic one. Imagine we sort the following list of dates:</p>
<pre data-language="elixir">iex&gt; dates = [~D[2019-01-01], ~D[2020-03-02], ~D[2019-06-06]]
iex&gt; Enum.sort(dates)
[~D[2019-01-01], ~D[2020-03-02], ~D[2019-06-06]]</pre>
<p>Note that the returned result is incorrect, because <a href="#sort/1"><code class="inline">sort/1</code></a> by default uses <a href="kernel.html#%3C=/2"><code class="inline">&lt;=/2</code></a>, which will compare their structure. When comparing structures, the fields are compared in alphabetical order, which means the dates above will be compared by <code class="inline">day</code>, <code class="inline">month</code> and then <code class="inline">year</code>, which is the opposite of what we want.</p>
<p>For this reason, most structs provide a "compare" function, such as <a href="date.html#compare/2"><code class="inline">Date.compare/2</code></a>, which receives two structs and returns <code class="inline">:lt</code> (less-than), <code class="inline">:eq</code> (equal to), and <code class="inline">:gt</code> (greater-than). If you pass a module as the sorting function, Elixir will automatically use the <code class="inline">compare/2</code> function of said module:</p>
<pre data-language="elixir">iex&gt; dates = [~D[2019-01-01], ~D[2020-03-02], ~D[2019-06-06]]
iex&gt; Enum.sort(dates, Date)
[~D[2019-01-01], ~D[2019-06-06], ~D[2020-03-02]]</pre>
<p>To retrieve all dates in descending order, you can wrap the module in a tuple with <code class="inline">:asc</code> or <code class="inline">:desc</code> as first element:</p>
<pre data-language="elixir">iex&gt; dates = [~D[2019-01-01], ~D[2020-03-02], ~D[2019-06-06]]
iex&gt; Enum.sort(dates, {:asc, Date})
[~D[2019-01-01], ~D[2019-06-06], ~D[2020-03-02]]
iex&gt; dates = [~D[2019-01-01], ~D[2020-03-02], ~D[2019-06-06]]
iex&gt; Enum.sort(dates, {:desc, Date})
[~D[2020-03-02], ~D[2019-06-06], ~D[2019-01-01]]</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="sort_by/3">sort_by(enumerable, mapper, sorter \\ :asc)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L3310" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec sort_by(
  t(),
  (element() -&gt; mapped_element),
  (element(), element() -&gt; boolean())
  | :asc
  | :desc
  | module()
  | {:asc | :desc, module()}
) :: list()
when mapped_element: element()</pre> </div> <p>Sorts the mapped results of the <code class="inline">enumerable</code> according to the provided <code class="inline">sorter</code> function.</p>
<p>This function maps each element of the <code class="inline">enumerable</code> using the provided <code class="inline">mapper</code> function. The enumerable is then sorted by the mapped elements using the <code class="inline">sorter</code>, which defaults to <code class="inline">:asc</code> and sorts the elements ascendingly.</p>
<p><a href="#sort_by/3"><code class="inline">sort_by/3</code></a> differs from <a href="#sort/2"><code class="inline">sort/2</code></a> in that it only calculates the comparison value for each element in the enumerable once instead of once for each element in each comparison. If the same function is being called on both elements, it's more efficient to use <a href="#sort_by/3"><code class="inline">sort_by/3</code></a>.</p>
<h4 id="sort_by/3-ascending-and-descending-since-v1-10-0" class="section-heading"> <a href="#sort_by/3-ascending-and-descending-since-v1-10-0">  Ascending and descending (since v1.10.0) </a> </h4> <p><a href="#sort_by/3"><code class="inline">sort_by/3</code></a> allows a developer to pass <code class="inline">:asc</code> or <code class="inline">:desc</code> as the sorter, which is a convenience for <a href="kernel.html#%3C=/2"><code class="inline">&amp;&lt;=/2</code></a> and <a href="kernel.html#%3E=/2"><code class="inline">&amp;&gt;=/2</code></a> respectively:</p>
<pre data-language="elixir">iex&gt; Enum.sort_by([2, 3, 1], &amp;(&amp;1), :asc)
[1, 2, 3]

iex&gt; Enum.sort_by([2, 3, 1], &amp;(&amp;1), :desc)
[3, 2, 1]</pre>
<h4 id="sort_by/3-examples" class="section-heading"> <a href="#sort_by/3-examples">  Examples </a> </h4> <p>Using the default <code class="inline">sorter</code> of <code class="inline">:asc</code> :</p>
<pre data-language="elixir">iex&gt; Enum.sort_by(["some", "kind", "of", "monster"], &amp;byte_size/1)
["of", "some", "kind", "monster"]</pre>
<p>Sorting by multiple properties - first by size, then by first letter (this takes advantage of the fact that tuples are compared element-by-element):</p>
<pre data-language="elixir">iex&gt; Enum.sort_by(["some", "kind", "of", "monster"], &amp;{byte_size(&amp;1), String.first(&amp;1)})
["of", "kind", "some", "monster"]</pre>
<p>Similar to <a href="#sort/2"><code class="inline">sort/2</code></a>, you can pass a custom sorter:</p>
<pre data-language="elixir">iex&gt; Enum.sort_by(["some", "kind", "of", "monster"], &amp;byte_size/1, :desc)
["monster", "some", "kind", "of"]</pre>
<p>As in <a href="#sort/2"><code class="inline">sort/2</code></a>, avoid using the default sorting function to sort structs, as by default it performs structural comparison instead of a semantic one. In such cases, you shall pass a sorting function as third element or any module that implements a <code class="inline">compare/2</code> function. For example, to sort users by their birthday in both ascending and descending order respectively:</p>
<pre data-language="elixir">iex&gt; users = [
...&gt;   %{name: "Ellis", birthday: ~D[1943-05-11]},
...&gt;   %{name: "Lovelace", birthday: ~D[1815-12-10]},
...&gt;   %{name: "Turing", birthday: ~D[1912-06-23]}
...&gt; ]
iex&gt; Enum.sort_by(users, &amp;(&amp;1.birthday), Date)
[
  %{name: "Lovelace", birthday: ~D[1815-12-10]},
  %{name: "Turing", birthday: ~D[1912-06-23]},
  %{name: "Ellis", birthday: ~D[1943-05-11]}
]
iex&gt; Enum.sort_by(users, &amp;(&amp;1.birthday), {:desc, Date})
[
  %{name: "Ellis", birthday: ~D[1943-05-11]},
  %{name: "Turing", birthday: ~D[1912-06-23]},
  %{name: "Lovelace", birthday: ~D[1815-12-10]}
]</pre>
<h4 id="sort_by/3-performance-characteristics" class="section-heading"> <a href="#sort_by/3-performance-characteristics">  Performance characteristics </a> </h4> <p>As detailed in the initial section, <a href="#sort_by/3"><code class="inline">sort_by/3</code></a> calculates the comparison value for each element in the enumerable once instead of once for each element in each comparison. This implies <a href="#sort_by/3"><code class="inline">sort_by/3</code></a> must do an initial pass on the data to compute those values.</p>
<p>However, if those values are cheap to compute, for example, you have already extracted the field you want to sort by into a tuple, then those extra passes become overhead. In such cases, consider using <a href="list.html#keysort/3"><code class="inline">List.keysort/3</code></a> instead.</p>
<p>Let's see an example. Imagine you have a list of products and you have a list of IDs. You want to keep all products that are in the given IDs and return their names sorted by their price. You could write it like this:</p>
<pre data-language="elixir">for(
  product &lt;- products,
  product.id in ids,
  do: product
)
|&gt; Enum.sort_by(&amp; &amp;1.price)
|&gt; Enum.map(&amp; &amp;1.name)</pre>
<p>However, you could also write it like this:</p>
<pre data-language="elixir">for(
  product &lt;- products,
  product.id in ids,
  do: {product.name, product.price}
)
|&gt; List.keysort(1)
|&gt; Enum.map(&amp;elem(&amp;1, 0))</pre>
<p>Using <a href="list.html#keysort/3"><code class="inline">List.keysort/3</code></a> will be a better choice for performance sensitive code as it avoids additional traversals.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="split/2">split(enumerable, count)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L3356" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec split(t(), integer()) :: {list(), list()}</pre> </div> <p>Splits the <code class="inline">enumerable</code> into two enumerables, leaving <code class="inline">count</code> elements in the first one.</p>
<p>If <code class="inline">count</code> is a negative number, it starts counting from the back to the beginning of the <code class="inline">enumerable</code>.</p>
<p>Be aware that a negative <code class="inline">count</code> implies the <code class="inline">enumerable</code> will be enumerated twice: once to calculate the position, and a second time to do the actual splitting.</p>
<h4 id="split/2-examples" class="section-heading"> <a href="#split/2-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.split([1, 2, 3], 2)
{[1, 2], [3]}

iex&gt; Enum.split([1, 2, 3], 10)
{[1, 2, 3], []}

iex&gt; Enum.split([1, 2, 3], 0)
{[], [1, 2, 3]}

iex&gt; Enum.split([1, 2, 3], -1)
{[1, 2], [3]}

iex&gt; Enum.split([1, 2, 3], -5)
{[], [1, 2, 3]}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="split_while/2">split_while(enumerable, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L3397" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec split_while(t(), (element() -&gt; as_boolean(term()))) :: {list(), list()}</pre> </div> <p>Splits enumerable in two at the position of the element for which <code class="inline">fun</code> returns a falsy value (<code class="inline">false</code> or <code class="inline">nil</code>) for the first time.</p>
<p>It returns a two-element tuple with two lists of elements. The element that triggered the split is part of the second list.</p>
<h4 id="split_while/2-examples" class="section-heading"> <a href="#split_while/2-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.split_while([1, 2, 3, 4], fn x -&gt; x &lt; 3 end)
{[1, 2], [3, 4]}

iex&gt; Enum.split_while([1, 2, 3, 4], fn x -&gt; x &lt; 0 end)
{[], [1, 2, 3, 4]}

iex&gt; Enum.split_while([1, 2, 3, 4], fn x -&gt; x &gt; 0 end)
{[1, 2, 3, 4], []}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="split_with/2">split_with(enumerable, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L2330" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec split_with(t(), (element() -&gt; as_boolean(term()))) :: {list(), list()}</pre> </div> <p>Splits the <code class="inline">enumerable</code> in two lists according to the given function <code class="inline">fun</code>.</p>
<p>Splits the given <code class="inline">enumerable</code> in two lists by calling <code class="inline">fun</code> with each element in the <code class="inline">enumerable</code> as its only argument. Returns a tuple with the first list containing all the elements in <code class="inline">enumerable</code> for which applying <code class="inline">fun</code> returned a truthy value, and a second list with all the elements for which applying <code class="inline">fun</code> returned a falsy value (<code class="inline">false</code> or <code class="inline">nil</code>).</p>
<p>The elements in both the returned lists are in the same relative order as they were in the original enumerable (if such enumerable was ordered, like a list). See the examples below.</p>
<h4 id="split_with/2-examples" class="section-heading"> <a href="#split_with/2-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.split_with([5, 4, 3, 2, 1, 0], fn x -&gt; rem(x, 2) == 0 end)
{[4, 2, 0], [5, 3, 1]}

iex&gt; Enum.split_with([a: 1, b: -2, c: 1, d: -3], fn {_k, v} -&gt; v &lt; 0 end)
{[b: -2, d: -3], [a: 1, c: 1]}

iex&gt; Enum.split_with([a: 1, b: -2, c: 1, d: -3], fn {_k, v} -&gt; v &gt; 50 end)
{[], [a: 1, b: -2, c: 1, d: -3]}

iex&gt; Enum.split_with([], fn {_k, v} -&gt; v &gt; 50 end)
{[], []}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="sum/1">sum(enumerable)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L3432" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec sum(t()) :: number()</pre> </div> <p>Returns the sum of all elements.</p>
<p>Raises <a href="arithmeticerror.html"><code class="inline">ArithmeticError</code></a> if <code class="inline">enumerable</code> contains a non-numeric value.</p>
<h4 id="sum/1-examples" class="section-heading"> <a href="#sum/1-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.sum([1, 2, 3])
6

iex&gt; Enum.sum(1..10)
55

iex&gt; Enum.sum(1..10//2)
25</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="take/2">take(enumerable, amount)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L3494" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec take(t(), integer()) :: list()</pre> </div> <p>Takes an <code class="inline">amount</code> of elements from the beginning or the end of the <code class="inline">enumerable</code>.</p>
<p>If a positive <code class="inline">amount</code> is given, it takes the <code class="inline">amount</code> elements from the beginning of the <code class="inline">enumerable</code>.</p>
<p>If a negative <code class="inline">amount</code> is given, the <code class="inline">amount</code> of elements will be taken from the end. The <code class="inline">enumerable</code> will be enumerated once to retrieve the proper index and the remaining calculation is performed from the end.</p>
<p>If amount is <code class="inline">0</code>, it returns <code class="inline">[]</code>.</p>
<h4 id="take/2-examples" class="section-heading"> <a href="#take/2-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.take([1, 2, 3], 2)
[1, 2]

iex&gt; Enum.take([1, 2, 3], 10)
[1, 2, 3]

iex&gt; Enum.take([1, 2, 3], 0)
[]

iex&gt; Enum.take([1, 2, 3], -1)
[3]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="take_every/2">take_every(enumerable, nth)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L3543" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec take_every(t(), non_neg_integer()) :: list()</pre> </div> <p>Returns a list of every <code class="inline">nth</code> element in the <code class="inline">enumerable</code>, starting with the first element.</p>
<p>The first element is always included, unless <code class="inline">nth</code> is 0.</p>
<p>The second argument specifying every <code class="inline">nth</code> element must be a non-negative integer.</p>
<h4 id="take_every/2-examples" class="section-heading"> <a href="#take_every/2-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.take_every(1..10, 2)
[1, 3, 5, 7, 9]

iex&gt; Enum.take_every(1..10, 0)
[]

iex&gt; Enum.take_every([1, 2, 3], 1)
[1, 2, 3]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="take_random/2">take_random(enumerable, count)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L3576" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec take_random(t(), non_neg_integer()) :: list()</pre> </div> <p>Takes <code class="inline">count</code> random elements from <code class="inline">enumerable</code>.</p>
<p>Note that this function will traverse the whole <code class="inline">enumerable</code> to get the random sublist.</p>
<p>See <a href="#random/1"><code class="inline">random/1</code></a> for notes on implementation and random seed.</p>
<h4 id="take_random/2-examples" class="section-heading"> <a href="#take_random/2-examples">  Examples </a> </h4> <pre data-language="elixir"># Although not necessary, let's seed the random algorithm
iex&gt; :rand.seed(:exsss, {1, 2, 3})
iex&gt; Enum.take_random(1..10, 2)
[3, 1]
iex&gt; Enum.take_random(?a..?z, 5)
'mikel'</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="take_while/2">take_while(enumerable, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L3673" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec take_while(t(), (element() -&gt; as_boolean(term()))) :: list()</pre> </div> <p>Takes the elements from the beginning of the <code class="inline">enumerable</code> while <code class="inline">fun</code> returns a truthy value.</p>
<h4 id="take_while/2-examples" class="section-heading"> <a href="#take_while/2-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.take_while([1, 2, 3], fn x -&gt; x &lt; 3 end)
[1, 2]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="to_list/1">to_list(enumerable)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L3700" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec to_list(t()) :: [element()]</pre> </div> <p>Converts <code class="inline">enumerable</code> to a list.</p>
<h4 id="to_list/1-examples" class="section-heading"> <a href="#to_list/1-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.to_list(1..3)
[1, 2, 3]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="uniq/1">uniq(enumerable)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L3716" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec uniq(t()) :: list()</pre> </div> <p>Enumerates the <code class="inline">enumerable</code>, removing all duplicated elements.</p>
<h4 id="uniq/1-examples" class="section-heading"> <a href="#uniq/1-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.uniq([1, 2, 3, 3, 2, 1])
[1, 2, 3]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="uniq_by/2">uniq_by(enumerable, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L3747" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec uniq_by(t(), (element() -&gt; term())) :: list()</pre> </div> <p>Enumerates the <code class="inline">enumerable</code>, by removing the elements for which function <code class="inline">fun</code> returned duplicate elements.</p>
<p>The function <code class="inline">fun</code> maps every element to a term. Two elements are considered duplicates if the return value of <code class="inline">fun</code> is equal for both of them.</p>
<p>The first occurrence of each element is kept.</p>
<h4 id="uniq_by/2-example" class="section-heading"> <a href="#uniq_by/2-example">  Example </a> </h4> <pre data-language="elixir">iex&gt; Enum.uniq_by([{1, :x}, {2, :y}, {1, :z}], fn {x, _} -&gt; x end)
[{1, :x}, {2, :y}]

iex&gt; Enum.uniq_by([a: {:tea, 2}, b: {:tea, 2}, c: {:coffee, 1}], fn {_, y} -&gt; y end)
[a: {:tea, 2}, c: {:coffee, 1}]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="unzip/1">unzip(list)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L3778" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec unzip(t()) :: {[element()], [element()]}</pre> </div> <p>Opposite of <a href="#zip/2"><code class="inline">zip/2</code></a>. Extracts two-element tuples from the given <code class="inline">enumerable</code> and groups them together.</p>
<p>It takes an <code class="inline">enumerable</code> with elements being two-element tuples and returns a tuple with two lists, each of which is formed by the first and second element of each tuple, respectively.</p>
<p>This function fails unless <code class="inline">enumerable</code> is or can be converted into a list of tuples with <em>exactly</em> two elements in each tuple.</p>
<h4 id="unzip/1-examples" class="section-heading"> <a href="#unzip/1-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.unzip([{:a, 1}, {:b, 2}, {:c, 3}])
{[:a, :b, :c], [1, 2, 3]}

iex&gt; Enum.unzip(%{a: 1, b: 2})
{[:a, :b], [1, 2]}</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="with_index/2">with_index(enumerable, fun_or_offset \\ 0)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L3829" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec with_index(t(), integer()) :: [{term(), integer()}]</pre> <pre translate="no" data-language="elixir">@spec with_index(t(), (element(), index() -&gt; value)) :: [value] when value: any()</pre> </div> <p>Returns the <code class="inline">enumerable</code> with each element wrapped in a tuple alongside its index.</p>
<p>May receive a function or an integer offset.</p>
<p>If an <code class="inline">offset</code> is given, it will index from the given offset instead of from zero.</p>
<p>If a <code class="inline">function</code> is given, it will index by invoking the function for each element and index (zero-based) of the enumerable.</p>
<h4 id="with_index/2-examples" class="section-heading"> <a href="#with_index/2-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.with_index([:a, :b, :c])
[a: 0, b: 1, c: 2]

iex&gt; Enum.with_index([:a, :b, :c], 3)
[a: 3, b: 4, c: 5]

iex&gt; Enum.with_index([:a, :b, :c], fn element, index -&gt; {index, element} end)
[{0, :a}, {1, :b}, {2, :c}]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="zip/1">zip(enumerables)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L3892" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec zip(enumerables) :: [tuple()] when enumerables: [t()] | t()</pre> </div> <p>Zips corresponding elements from a finite collection of enumerables into a list of tuples.</p>
<p>The zipping finishes as soon as any enumerable in the given collection completes.</p>
<h4 id="zip/1-examples" class="section-heading"> <a href="#zip/1-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.zip([[1, 2, 3], [:a, :b, :c], ["foo", "bar", "baz"]])
[{1, :a, "foo"}, {2, :b, "bar"}, {3, :c, "baz"}]

iex&gt; Enum.zip([[1, 2, 3, 4, 5], [:a, :b, :c]])
[{1, :a}, {2, :b}, {3, :c}]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="zip/2">zip(enumerable1, enumerable2)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L3867" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec zip(t(), t()) :: [{any(), any()}]</pre> </div> <p>Zips corresponding elements from two enumerables into a list of tuples.</p>
<p>The zipping finishes as soon as either enumerable completes.</p>
<h4 id="zip/2-examples" class="section-heading"> <a href="#zip/2-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.zip([1, 2, 3], [:a, :b, :c])
[{1, :a}, {2, :b}, {3, :c}]

iex&gt; Enum.zip([1, 2, 3, 4, 5], [:a, :b, :c])
[{1, :a}, {2, :b}, {3, :c}]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="zip_reduce/3">zip_reduce(enums, acc, reducer)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L4038" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec zip_reduce(t(), acc, ([term()], acc -&gt; acc)) :: acc when acc: term()</pre> </div> <p>Reduces over all of the given enumerables, halting as soon as any enumerable is empty.</p>
<p>The reducer will receive 2 args: a list of elements (one from each enum) and the accumulator.</p>
<p>In practice, the behaviour provided by this function can be achieved with:</p>
<pre data-language="elixir">Enum.reduce(Stream.zip(enums), acc, reducer)</pre>
<p>But <a href="#zip_reduce/3"><code class="inline">zip_reduce/3</code></a> exists for convenience purposes.</p>
<h4 id="zip_reduce/3-examples" class="section-heading"> <a href="#zip_reduce/3-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; enums = [[1, 1], [2, 2], [3, 3]]
...&gt;  Enum.zip_reduce(enums, [], fn elements, acc -&gt;
...&gt;    [List.to_tuple(elements) | acc]
...&gt; end)
[{1, 2, 3}, {1, 2, 3}]

iex&gt; enums = [[1, 2], %{a: 3, b: 4}, [5, 6]]
...&gt; Enum.zip_reduce(enums, [], fn elements, acc -&gt;
...&gt;   [List.to_tuple(elements) | acc]
...&gt; end)
[{2, {:b, 4}, 6}, {1, {:a, 3}, 5}]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="zip_reduce/4">zip_reduce(left, right, acc, reducer)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L3999" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec zip_reduce(
  t(),
  t(),
  acc,
  (enum1_elem :: term(), enum2_elem :: term(), acc -&gt; acc)
) :: acc
when acc: term()</pre> </div> <p>Reduces over two enumerables halting as soon as either enumerable is empty.</p>
<p>In practice, the behaviour provided by this function can be achieved with:</p>
<pre data-language="elixir">Enum.reduce(Stream.zip(left, right), acc, reducer)</pre>
<p>But <a href="#zip_reduce/4"><code class="inline">zip_reduce/4</code></a> exists for convenience purposes.</p>
<h4 id="zip_reduce/4-examples" class="section-heading"> <a href="#zip_reduce/4-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.zip_reduce([1, 2], [3, 4], 0, fn x, y, acc -&gt; x + y + acc end)
10

iex&gt; Enum.zip_reduce([1, 2], [3, 4], [], fn x, y, acc -&gt; [x + y | acc] end)
[6, 4]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="zip_with/2">zip_with(enumerables, zip_fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L3972" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec zip_with(t(), ([term()] -&gt; term())) :: [term()]</pre> </div> <p>Zips corresponding elements from a finite collection of enumerables into list, transforming them with the <code class="inline">zip_fun</code> function as it goes.</p>
<p>The first element from each of the enums in <code class="inline">enumerables</code> will be put into a list which is then passed to the one-arity <code class="inline">zip_fun</code> function. Then, the second elements from each of the enums are put into a list and passed to <code class="inline">zip_fun</code>, and so on until any one of the enums in <code class="inline">enumerables</code> runs out of elements.</p>
<p>Returns a list with all the results of calling <code class="inline">zip_fun</code>.</p>
<h4 id="zip_with/2-examples" class="section-heading"> <a href="#zip_with/2-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.zip_with([[1, 2], [3, 4], [5, 6]], fn [x, y, z] -&gt; x + y + z end)
[9, 12]

iex&gt; Enum.zip_with([[1, 2], [3, 4]], fn [x, y] -&gt; x + y end)
[4, 6]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="zip_with/3">zip_with(enumerable1, enumerable2, zip_fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L3939" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec zip_with(t(), t(), (enum1_elem :: term(), enum2_elem :: term() -&gt; term())) :: [
  term()
]</pre> </div> <p>Zips corresponding elements from two enumerables into a list, transforming them with the <code class="inline">zip_fun</code> function as it goes.</p>
<p>The corresponding elements from each collection are passed to the provided two-arity <code class="inline">zip_fun</code> function in turn. Returns a list that contains the result of calling <code class="inline">zip_fun</code> for each pair of elements.</p>
<p>The zipping finishes as soon as either enumerable runs out of elements.</p>
<h4 id="zip_with/3-zipping-maps" class="section-heading"> <a href="#zip_with/3-zipping-maps">  Zipping Maps </a> </h4> <p>It's important to remember that zipping inherently relies on order. If you zip two lists you get the element at the index from each list in turn. If we zip two maps together it's tempting to think that you will get the given key in the left map and the matching key in the right map, but there is no such guarantee because map keys are not ordered! Consider the following:</p>
<pre data-language="elixir">left =  %{:a =&gt; 1, 1 =&gt; 3}
right = %{:a =&gt; 1, :b =&gt; :c}
Enum.zip(left, right)
# [{{1, 3}, {:a, 1}}, {{:a, 1}, {:b, :c}}]</pre>
<p>As you can see <code class="inline">:a</code> does not get paired with <code class="inline">:a</code>. If this is what you want, you should use <a href="map.html#merge/3"><code class="inline">Map.merge/3</code></a>.</p>
<h4 id="zip_with/3-examples" class="section-heading"> <a href="#zip_with/3-examples">  Examples </a> </h4> <pre data-language="elixir">iex&gt; Enum.zip_with([1, 2], [3, 4], fn x, y -&gt; x + y end)
[4, 6]

iex&gt; Enum.zip_with([1, 2], [3, 4, 5, 6], fn x, y -&gt; x + y end)
[4, 6]

iex&gt; Enum.zip_with([1, 2, 5, 6], [3, 4], fn x, y -&gt; x + y end)
[4, 6]</pre> </section> </section> </div> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/elixir/1.15.4/Enum.html" class="_attribution-link">https://hexdocs.pm/elixir/1.15.4/Enum.html</a>
  </p>
</div>
