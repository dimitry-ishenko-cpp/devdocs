<p class="_links"><a href="../../dart-async/dart-async-library.html" class="_links-link">dart:async</a></p> <h1>then&lt;<wbr>R&gt;</wbr> method  </h1> <section class="multi-line-signature"> <a href="../future-class.html">Future</a>&lt;<wbr>R&gt;</wbr> then&lt;<wbr>R&gt;(<wbr><ol class="parameter-list">
<li>
<a href="../futureor-class.html">FutureOr</a>&lt;<wbr>R&gt;</wbr> onValue(<ol class="parameter-list">
<li>T value</li> </ol> ), </li> <li>{<a href="../../dart-core/function-class.html">Function</a>? onError}</li> </ol>) </wbr></wbr></section>  <p>Register callbacks to be called when this future completes.</p> <p>When this future completes with a value, the <code>onValue</code> callback will be called with that value. If this future is already completed, the callback will not be called immediately, but will be scheduled in a later microtask.</p> <p>If <code>onError</code> is provided, and this future completes with an error, the <code>onError</code> callback is called with that error and its stack trace. The <code>onError</code> callback must accept either one argument or two arguments where the latter is a <a href="../../dart-core/stacktrace-class.html">StackTrace</a>. If <code>onError</code> accepts two arguments, it is called with both the error and the stack trace, otherwise it is called with just the error object. The <code>onError</code> callback must return a value or future that can be used to complete the returned future, so it must be something assignable to <code>FutureOr&lt;R&gt;</code>.</p> <p>Returns a new <a href="../future-class.html">Future</a> which is completed with the result of the call to <code>onValue</code> (if this future completes with a value) or to <code>onError</code> (if this future completes with an error).</p> <p>If the invoked callback throws, the returned future is completed with the thrown error and a stack trace for the error. In the case of <code>onError</code>, if the exception thrown is <code>identical</code> to the error argument to <code>onError</code>, the throw is considered a rethrow, and the original stack trace is used instead.</p> <p>If the callback returns a <a href="../future-class.html">Future</a>, the future returned by <code>then</code> will be completed with the same result as the future returned by the callback.</p> <p>If <code>onError</code> is not given, and this future completes with an error, the error is forwarded directly to the returned future.</p> <p>In most cases, it is more readable to use <a href="catcherror.html">catchError</a> separately, possibly with a <code>test</code> parameter, instead of handling both value and error in a single <a href="then.html">then</a> call.</p> <p>Note that futures don't delay reporting of errors until listeners are added. If the first <code>then</code> or <code>catchError</code> call happens after this future has completed with an error, then the error is reported as unhandled error. See the description on <a href="../future-class.html">Future</a>.</p>   <h2 id="source">Implementation</h2> <pre class="language-dart" data-language="dart">Future&lt;R&gt; then&lt;R&gt;(FutureOr&lt;R&gt; onValue(T value), {Function? onError});</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012 the Dart project authors<br>Licensed under the BSD 3-Clause "New" or "Revised" License.<br>
    <a href="https://api.dart.dev/stable/2.18.5/dart-async/Future/then.html" class="_attribution-link">https://api.dart.dev/stable/2.18.5/dart-async/Future/then.html</a>
  </p>
</div>
