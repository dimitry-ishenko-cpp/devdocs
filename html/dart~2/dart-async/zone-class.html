<p class="_links"><a href="../dart-async/dart-async-library.html" class="_links-link">dart:async</a></p> <h1>Zone class  </h1>  <p>A zone represents an environment that remains stable across asynchronous calls.</p> <p>Code is always executed in the context of a zone, available as <a href="zone/current.html">Zone.current</a>. The initial <code>main</code> function runs in the context of the default zone (<a href="zone/root-constant.html">Zone.root</a>). Code can be run in a different zone using either <a href="runzoned.html">runZoned</a>, to create a new zone, or <a href="zone/run.html">Zone.run</a> to run code in the context of an existing zone which was created earlier using <a href="zone/fork.html">Zone.fork</a>.</p> <p>Developers can create a new zone that overrides some of the functionality of an existing zone. For example, custom zones can replace or modify the behavior of <code>print</code>, timers, microtasks or how uncaught errors are handled.</p> <p>The <a href="zone-class.html">Zone</a> class is not subclassable, but users can provide custom zones by forking an existing zone (usually <a href="zone/current.html">Zone.current</a>) with a <a href="zonespecification-class.html">ZoneSpecification</a>. This is similar to creating a new class that extends the base <code>Zone</code> class and that overrides some methods, except without actually creating a new class. Instead the overriding methods are provided as functions that explicitly take the equivalent of their own class, the "super" class and the <code>this</code> object as parameters.</p> <p>Asynchronous callbacks always run in the context of the zone where they were scheduled. This is implemented using two steps:</p> <ol> <li>the callback is first registered using one of <a href="zone/registercallback.html">registerCallback</a>, <a href="zone/registerunarycallback.html">registerUnaryCallback</a>, or <a href="zone/registerbinarycallback.html">registerBinaryCallback</a>. This allows the zone to record that a callback exists and potentially modify it (by returning a different callback). The code doing the registration (e.g., <code>Future.then</code>) also remembers the current zone so that it can later run the callback in that zone.</li> <li>At a later point the registered callback is run in the remembered zone, using one of <a href="zone/run.html">run</a>, <a href="zone/rununary.html">runUnary</a> or <a href="zone/runbinary.html">runBinary</a>.</li> </ol> <p>This is all handled internally by the platform code and most users don't need to worry about it. However, developers of new asynchronous operations, provided by the underlying system, must follow the protocol to be zone compatible.</p> <p>For convenience, zones provide <a href="zone/bindcallback.html">bindCallback</a> (and the corresponding <a href="zone/bindunarycallback.html">bindUnaryCallback</a> and <a href="zone/bindbinarycallback.html">bindBinaryCallback</a>) to make it easier to respect the zone contract: these functions first invoke the corresponding <code>register</code> functions and then wrap the returned function so that it runs in the current zone when it is later asynchronously invoked.</p> <p>Similarly, zones provide <a href="zone/bindcallbackguarded.html">bindCallbackGuarded</a> (and the corresponding <a href="zone/bindunarycallbackguarded.html">bindUnaryCallbackGuarded</a> and <a href="zone/bindbinarycallbackguarded.html">bindBinaryCallbackGuarded</a>), when the callback should be invoked through <a href="zone/runguarded.html">Zone.runGuarded</a>.</p>   <h2 id="instance-properties">Properties</h2> <dl> <dt id="errorZone"> <a href="zone/errorzone.html">errorZone</a> → <a href="zone-class.html">Zone</a> <div class="features">read-only</div>
</dt> <dd> The error zone is responsible for dealing with uncaught errors.  </dd> <dt id="hashCode"> <a href="../dart-core/object/hashcode.html">hashCode</a> → <a href="../dart-core/int-class.html">int</a> <div class="features">read-only, inherited</div>
</dt> <dd class="inherited"> The hash code for this object.  </dd> <dt id="parent"> <a href="zone/parent.html">parent</a> → <a href="zone-class.html">Zone</a>? <div class="features">read-only</div>
</dt> <dd> The parent zone of the this zone.  </dd> <dt id="runtimeType"> <a href="../dart-core/object/runtimetype.html">runtimeType</a> → <a href="../dart-core/type-class.html">Type</a> <div class="features">read-only, inherited</div>
</dt> <dd class="inherited"> A representation of the runtime type of the object.  </dd> </dl>   <h2 id="instance-methods">Methods</h2> <dl> <dt id="bindBinaryCallback"> <a href="zone/bindbinarycallback.html">bindBinaryCallback</a>&lt;<wbr>R, T1, T2&gt;</wbr>(<wbr>R callback(T1 argument1, T2 argument2)) → <a href="zonebinarycallback.html">ZoneBinaryCallback</a>&lt;<wbr>R, T1, T2&gt;</wbr> </wbr> </dt> <dd> Registers the provided <code>callback</code> and returns a function that will execute in this zone. </dd> <dt id="bindBinaryCallbackGuarded"> <a href="zone/bindbinarycallbackguarded.html">bindBinaryCallbackGuarded</a>&lt;<wbr>T1, T2&gt;</wbr>(<wbr>void callback(T1 argument1, T2 argument2)) → void Function(T1, T2) </wbr> </dt> <dd> Registers the provided <code>callback</code> and returns a function that will execute in this zone. </dd> <dt id="bindCallback"> <a href="zone/bindcallback.html">bindCallback</a>&lt;<wbr>R&gt;</wbr>(<wbr>R callback()) → <a href="zonecallback.html">ZoneCallback</a>&lt;<wbr>R&gt;</wbr> </wbr> </dt> <dd> Registers the provided <code>callback</code> and returns a function that will execute in this zone. </dd> <dt id="bindCallbackGuarded"> <a href="zone/bindcallbackguarded.html">bindCallbackGuarded</a>(<wbr>void callback()) → void Function() </wbr> </dt> <dd> Registers the provided <code>callback</code> and returns a function that will execute in this zone. </dd> <dt id="bindUnaryCallback"> <a href="zone/bindunarycallback.html">bindUnaryCallback</a>&lt;<wbr>R, T&gt;</wbr>(<wbr>R callback(T argument)) → <a href="zoneunarycallback.html">ZoneUnaryCallback</a>&lt;<wbr>R, T&gt;</wbr> </wbr> </dt> <dd> Registers the provided <code>callback</code> and returns a function that will execute in this zone. </dd> <dt id="bindUnaryCallbackGuarded"> <a href="zone/bindunarycallbackguarded.html">bindUnaryCallbackGuarded</a>&lt;<wbr>T&gt;</wbr>(<wbr>void callback(T argument)) → void Function(T) </wbr> </dt> <dd> Registers the provided <code>callback</code> and returns a function that will execute in this zone. </dd> <dt id="createPeriodicTimer"> <a href="zone/createperiodictimer.html">createPeriodicTimer</a>(<wbr><a href="../dart-core/duration-class.html">Duration</a> period, void callback(<a href="timer-class.html">Timer</a> timer)) → <a href="timer-class.html">Timer</a> </wbr> </dt> <dd> Creates a periodic <a href="timer-class.html">Timer</a> where the callback is executed in this zone. </dd> <dt id="createTimer"> <a href="zone/createtimer.html">createTimer</a>(<wbr><a href="../dart-core/duration-class.html">Duration</a> duration, void callback()) → <a href="timer-class.html">Timer</a> </wbr> </dt> <dd> Creates a <a href="timer-class.html">Timer</a> where the callback is executed in this zone. </dd> <dt id="errorCallback"> <a href="zone/errorcallback.html">errorCallback</a>(<wbr><a href="../dart-core/object-class.html">Object</a> error, <a href="../dart-core/stacktrace-class.html">StackTrace</a>? stackTrace) → <a href="asyncerror-class.html">AsyncError</a>? </wbr> </dt> <dd> Intercepts errors when added programmatically to a <a href="future-class.html">Future</a> or <a href="stream-class.html">Stream</a>. </dd> <dt id="fork"> <a href="zone/fork.html">fork</a>(<wbr>{<a href="zonespecification-class.html">ZoneSpecification</a>? specification, <a href="../dart-core/map-class.html">Map</a>&lt;<wbr><a href="../dart-core/object-class.html">Object</a>?, <a href="../dart-core/object-class.html">Object</a>?&gt;</wbr>? zoneValues}) → <a href="zone-class.html">Zone</a> </wbr> </dt> <dd> Creates a new zone as a child zone of this zone. </dd> <dt id="handleUncaughtError"> <a href="zone/handleuncaughterror.html">handleUncaughtError</a>(<wbr><a href="../dart-core/object-class.html">Object</a> error, <a href="../dart-core/stacktrace-class.html">StackTrace</a> stackTrace) → void </wbr> </dt> <dd> Handles uncaught asynchronous errors. </dd> <dt id="inSameErrorZone"> <a href="zone/insameerrorzone.html">inSameErrorZone</a>(<wbr><a href="zone-class.html">Zone</a> otherZone) → <a href="../dart-core/bool-class.html">bool</a> </wbr> </dt> <dd> Whether this zone and <code>otherZone</code> are in the same error zone. </dd> <dt id="noSuchMethod"> <a href="../dart-core/object/nosuchmethod.html">noSuchMethod</a>(<wbr><a href="../dart-core/invocation-class.html">Invocation</a> invocation) → dynamic </wbr> <div class="features">inherited</div>
</dt> <dd class="inherited"> Invoked when a non-existent method or property is accessed.  </dd> <dt id="print"> <a href="zone/print.html">print</a>(<wbr><a href="../dart-core/string-class.html">String</a> line) → void </wbr> </dt> <dd> Prints the given <code>line</code>. </dd> <dt id="registerBinaryCallback"> <a href="zone/registerbinarycallback.html">registerBinaryCallback</a>&lt;<wbr>R, T1, T2&gt;</wbr>(<wbr>R callback(T1 arg1, T2 arg2)) → <a href="zonebinarycallback.html">ZoneBinaryCallback</a>&lt;<wbr>R, T1, T2&gt;</wbr> </wbr> </dt> <dd> Registers the given callback in this zone. </dd> <dt id="registerCallback"> <a href="zone/registercallback.html">registerCallback</a>&lt;<wbr>R&gt;</wbr>(<wbr>R callback()) → <a href="zonecallback.html">ZoneCallback</a>&lt;<wbr>R&gt;</wbr> </wbr> </dt> <dd> Registers the given callback in this zone. </dd> <dt id="registerUnaryCallback"> <a href="zone/registerunarycallback.html">registerUnaryCallback</a>&lt;<wbr>R, T&gt;</wbr>(<wbr>R callback(T arg)) → <a href="zoneunarycallback.html">ZoneUnaryCallback</a>&lt;<wbr>R, T&gt;</wbr> </wbr> </dt> <dd> Registers the given callback in this zone. </dd> <dt id="run"> <a href="zone/run.html">run</a>&lt;<wbr>R&gt;</wbr>(<wbr>R action()) → R </wbr> </dt> <dd> Executes <code>action</code> in this zone. </dd> <dt id="runBinary"> <a href="zone/runbinary.html">runBinary</a>&lt;<wbr>R, T1, T2&gt;</wbr>(<wbr>R action(T1 argument1, T2 argument2), T1 argument1, T2 argument2) → R </wbr> </dt> <dd> Executes the given <code>action</code> with <code>argument1</code> and <code>argument2</code> in this zone. </dd> <dt id="runBinaryGuarded"> <a href="zone/runbinaryguarded.html">runBinaryGuarded</a>&lt;<wbr>T1, T2&gt;</wbr>(<wbr>void action(T1 argument1, T2 argument2), T1 argument1, T2 argument2) → void </wbr> </dt> <dd> Executes the given <code>action</code> with <code>argument1</code> and <code>argument2</code> in this zone and catches synchronous errors. </dd> <dt id="runGuarded"> <a href="zone/runguarded.html">runGuarded</a>(<wbr>void action()) → void </wbr> </dt> <dd> Executes the given <code>action</code> in this zone and catches synchronous errors. </dd> <dt id="runUnary"> <a href="zone/rununary.html">runUnary</a>&lt;<wbr>R, T&gt;</wbr>(<wbr>R action(T argument), T argument) → R </wbr> </dt> <dd> Executes the given <code>action</code> with <code>argument</code> in this zone. </dd> <dt id="runUnaryGuarded"> <a href="zone/rununaryguarded.html">runUnaryGuarded</a>&lt;<wbr>T&gt;</wbr>(<wbr>void action(T argument), T argument) → void </wbr> </dt> <dd> Executes the given <code>action</code> with <code>argument</code> in this zone and catches synchronous errors. </dd> <dt id="scheduleMicrotask"> <a href="zone/schedulemicrotask.html">scheduleMicrotask</a>(<wbr>void callback()) → void </wbr> </dt> <dd> Runs <code>callback</code> asynchronously in this zone. </dd> <dt id="toString"> <a href="../dart-core/object/tostring.html">toString</a>(<wbr>) → <a href="../dart-core/string-class.html">String</a> </wbr> <div class="features">inherited</div>
</dt> <dd class="inherited"> A string representation of this object.  </dd> </dl>   <h2 id="operators">Operators</h2> <dl> <dt id="operator =="> <a href="../dart-core/object/operator_equals.html">operator ==</a>(<wbr><a href="../dart-core/object-class.html">Object</a> other) → <a href="../dart-core/bool-class.html">bool</a> </wbr> <div class="features">inherited</div>
</dt> <dd class="inherited"> The equality operator.  </dd> <dt id="operator []"> <a href="zone/operator_get.html">operator []</a>(<wbr><a href="../dart-core/object-class.html">Object</a>? key) → dynamic </wbr> </dt> <dd> Retrieves the zone-value associated with <code>key</code>. </dd> </dl>   <h2 id="static-properties">Static Properties</h2> <dl> <dt id="current"> <a href="zone/current.html">current</a> → <a href="zone-class.html">Zone</a> <div class="features">read-only</div>
</dt> <dd> The zone that is currently active.  </dd> </dl>   <h2 id="constants">Constants</h2> <dl> <dt id="root" class="constant"> <a href="zone/root-constant.html">root</a> → const <a href="zone-class.html">Zone</a> </dt> <dd> The root zone. <div> <code>_rootZone</code> </div> </dd> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012 the Dart project authors<br>Licensed under the BSD 3-Clause "New" or "Revised" License.<br>
    <a href="https://api.dart.dev/stable/2.18.5/dart-async/Zone-class.html" class="_attribution-link">https://api.dart.dev/stable/2.18.5/dart-async/Zone-class.html</a>
  </p>
</div>
