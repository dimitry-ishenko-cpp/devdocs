<p class="_links"><a href="../../dart-core/dart-core-library.html" class="_links-link">dart:core</a></p> <h1>toSigned method  </h1> <section class="multi-line-signature"> <a href="../int-class.html">int</a> toSigned(<wbr><ol class="parameter-list">
<li>
<a href="../int-class.html">int</a> width</li> </ol>) </wbr></section>  <p>Returns the least significant <code>width</code> bits of this integer, extending the highest retained bit to the sign. This is the same as truncating the value to fit in <code>width</code> bits using an signed 2-s complement representation. The returned value has the same bit value in all positions higher than <code>width</code>.</p> <pre class="language-dart" data-language="dart">//     V--sign bit-V
16.toSigned(5) == -16;   //  00010000 -&gt; 11110000
239.toSigned(5) == 15;   //  11101111 -&gt; 00001111
                         //     ^           ^</pre> <p>This operation can be used to simulate arithmetic from low level languages. For example, to increment an 8 bit signed quantity:</p> <pre class="language-dart" data-language="dart">q = (q + 1).toSigned(8);</pre> <p><code>q</code> will count from <code>0</code> up to <code>127</code>, wrap to <code>-128</code> and count back up to <code>127</code>.</p> <p>If the input value fits in <code>width</code> bits without truncation, the result is the same as the input. The minimum width needed to avoid truncation of <code>x</code> is <code>x.bitLength + 1</code>, i.e.</p> <pre class="language-dart" data-language="dart">x == x.toSigned(x.bitLength + 1);</pre>   <h2 id="source">Implementation</h2> <pre class="language-dart" data-language="dart">int toSigned(int width);</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012 the Dart project authors<br>Licensed under the BSD 3-Clause "New" or "Revised" License.<br>
    <a href="https://api.dart.dev/stable/2.18.5/dart-core/int/toSigned.html" class="_attribution-link">https://api.dart.dev/stable/2.18.5/dart-core/int/toSigned.html</a>
  </p>
</div>
