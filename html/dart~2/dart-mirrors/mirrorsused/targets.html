<p class="_links"><a href="../../dart-mirrors/dart-mirrors-library.html" class="_links-link">dart:mirrors</a></p> <h1>targets property  </h1> <section class="multi-line-signature"> dynamic targets <div class="features">final</div> </section>  <p>A list of reflective targets.</p> <p>Combined with <a href="metatargets.html">metaTargets</a>, this provides the complete list of reflective targets used by the library to which this metadata applies.</p> <p>The following text is non-normative:</p> <p>For now, there is no formal description of what a reflective target is. Informally, a target is a library, a class, a method or a field.</p> <p>Dart2js currently supports the following formats to specify targets:</p> <ul> <li>A constant <a href="../../dart-core/list-class.html">List</a> containing <a href="../../dart-core/string-class.html">String</a> constants representing (qualified) names of targets and Dart types.</li> <li>A single <a href="../../dart-core/string-class.html">String</a> constant whose value is a comma-separated list of (qualified) names.</li> <li>A single Dart type.</li> </ul> <p>A (qualified) name is resolved to a target as follows:</p> <ol> <li>If the qualified name matches a library name, the matching library is the target.</li> <li>Else, find the longest prefix of the name such that the prefix ends just before a <code>.</code> and is a library name.</li> <li>Use that library as current scope. If no matching prefix was found, use the current library, i.e., the library where the <a class="deprecated" href="../mirrorsused-class.html">MirrorsUsed</a> annotation was placed.</li> <li>Split the remaining suffix (the entire name if no library name was found in step 3) into a list of <a href="../../dart-core/string-class.html">String</a> using <code>.</code> as a separator.</li> <li>Select all targets in the current scope whose name matches a <a href="../../dart-core/string-class.html">String</a> from the list.</li> </ol> <p>For example:</p> <pre class="language-dart" data-language="dart">library my.library.one;

class A {
  var aField;
}

library main;

@MirrorsUsed(targets: "my.library.one.A.aField")
import "dart:mirrors";</pre> <p>The <a class="deprecated" href="../mirrorsused-class.html">MirrorsUsed</a> annotation specifies <code>A</code> and <code>aField</code> from library <code>my.library.one</code> as targets. This will mark the class <code>A</code> as a reflective target. The target specification for <code>aField</code> has no effect, as there is no target in <code>my.library.one</code> with that name.</p> <p>Note that everything within a target also is available for reflection. So, if a library is specified as target, all classes in that library become targets for reflection. Likewise, if a class is a target, all its methods and fields become targets for reflection. As a consequence, <code>aField</code> in the above example is also a reflective target.</p>   <h2 id="source">Implementation</h2> <pre class="language-dart" data-language="dart">final targets;</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012 the Dart project authors<br>Licensed under the BSD 3-Clause "New" or "Revised" License.<br>
    <a href="https://api.dart.dev/stable/2.18.5/dart-mirrors/MirrorsUsed/targets.html" class="_attribution-link">https://api.dart.dev/stable/2.18.5/dart-mirrors/MirrorsUsed/targets.html</a>
  </p>
</div>
