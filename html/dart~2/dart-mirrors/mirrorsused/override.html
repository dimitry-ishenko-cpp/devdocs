<p class="_links"><a href="../../dart-mirrors/dart-mirrors-library.html" class="_links-link">dart:mirrors</a></p> <h1>override property  </h1> <section class="multi-line-signature"> dynamic override <div class="features">final</div> </section>  <p>A list of library names or "*".</p> <p>When used as metadata on an import of "dart:mirrors", this metadata does not apply to the library in which the annotation is used, but instead applies to the other libraries (all libraries if "*" is used).</p> <p>The following text is non-normative:</p> <p>Dart2js currently supports the following formats to specify libraries:</p> <ul> <li>A constant <a href="../../dart-core/list-class.html">List</a> containing <a href="../../dart-core/string-class.html">String</a> constants representing names of libraries.</li> <li>A single <a href="../../dart-core/string-class.html">String</a> constant whose value is a comma-separated list of library names.</li> </ul> <p>Conceptually, a <a class="deprecated" href="../mirrorsused-class.html">MirrorsUsed</a> annotation with <a href="override.html">override</a> has the same effect as placing the annotation directly on the import of <code>dart:mirrors</code> in each of the referenced libraries. Thus, if the library had no <a class="deprecated" href="../mirrorsused-class.html">MirrorsUsed</a> annotation before, its unconditional import of <code>dart:mirrors</code> is overridden by an annotated import.</p> <p>Note that, like multiple explicit <a class="deprecated" href="../mirrorsused-class.html">MirrorsUsed</a> annotations, using override on a library with an existing <a class="deprecated" href="../mirrorsused-class.html">MirrorsUsed</a> annotation is additive. That is, the overall set of reflective targets is the union of the reflective targets that arise from the original and the overriding <a class="deprecated" href="../mirrorsused-class.html">MirrorsUsed</a> annotations.</p> <p>The use of <a href="override.html">override</a> is only meaningful for libraries that have an import of <code>dart:mirrors</code> without annotation because otherwise it would work exactly the same way without the <a href="override.html">override</a> parameter.</p> <p>While the annotation will apply to the given target libraries, the <a href="symbols.html">symbols</a>, <a href="targets.html">targets</a> and <a href="metatargets.html">metaTargets</a> are still evaluated in the scope of the annotation. Thus, to select a target from library <code>foo</code>, a qualified name has to be used or, if the target is visible in the current scope, its type may be referenced.</p> <p>For example, the following code marks all targets in the library <code>foo</code> as reflectable that have a metadata annotation using the <code>Reflectable</code> class from the same library.</p> <pre class="language-dart" data-language="dart">@MirrorsUsed(metaTargets: "foo.Reflectable", override: "foo")</pre> <p>However, the following code would require the use of the <code>Reflectable</code> class from the current library, instead.</p> <pre class="language-dart" data-language="dart">@MirrorsUsed(metaTargets: "Reflectable", override: "foo")</pre>   <h2 id="source">Implementation</h2> <pre class="language-dart" data-language="dart">final override;</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012 the Dart project authors<br>Licensed under the BSD 3-Clause "New" or "Revised" License.<br>
    <a href="https://api.dart.dev/stable/2.18.5/dart-mirrors/MirrorsUsed/override.html" class="_attribution-link">https://api.dart.dev/stable/2.18.5/dart-mirrors/MirrorsUsed/override.html</a>
  </p>
</div>
