<h1>IO</h1> <div id="preamble"> <div class="sectionbody"> <div class="paragraph"> <p>Most applications will need to deal with input and output concerns at some point. Spring Boot provides utilities and integrations with a range of technologies to help when you need IO capabilities. This section covers standard IO features such as caching and validation as well as more advanced topics such as scheduling and distributed transactions. We will also cover calling remote REST or SOAP services and sending email.</p> </div> </div> </div> <div class="sect1"> <h2 id="io.caching">
1. Caching</h2> <div class="sectionbody"> <div class="paragraph"> <p>The Spring Framework provides support for transparently adding caching to an application. At its core, the abstraction applies caching to methods, thus reducing the number of executions based on the information available in the cache. The caching logic is applied transparently, without any interference to the invoker. Spring Boot auto-configures the cache infrastructure as long as caching support is enabled by using the <code>@EnableCaching</code> annotation.</p> </div> <div class="admonitionblock note"> <table> <tr> <td class="icon">  </td> <td class="content"> Check the <a href="https://docs.spring.io/spring-framework/docs/6.0.11/reference/html/integration.html#cache">relevant section</a> of the Spring Framework reference for more details. </td> </tr> </table> </div> <div class="paragraph"> <p>In a nutshell, to add caching to an operation of your service add the relevant annotation to its method, as shown in the following example:</p> </div> <div class="listingblock primary"> <div class="title">Java</div> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Component;

</span><span class="fold-block">@Component
public class MyMathService {

    @Cacheable("piDecimals")
    public int computePiDecimal(int precision) {
        ...
    }

}
</span></code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Kotlin</div> <div class="content"> <pre class="highlight" data-language="kotlin"><code class="language-kotlin" data-lang="kotlin"><span class="fold-block hide-when-folded">import org.springframework.cache.annotation.Cacheable
import org.springframework.stereotype.Component

</span><span class="fold-block">@Component
class MyMathService {

    @Cacheable("piDecimals")
    fun computePiDecimal(precision: Int): Int {
        ...
    }

}
</span></code></pre> </div> </div> <div class="paragraph"> <p>This example demonstrates the use of caching on a potentially costly operation. Before invoking <code>computePiDecimal</code>, the abstraction looks for an entry in the <code>piDecimals</code> cache that matches the <code>i</code> argument. If an entry is found, the content in the cache is immediately returned to the caller, and the method is not invoked. Otherwise, the method is invoked, and the cache is updated before returning the value.</p> </div> <div class="admonitionblock caution"> <table> <tr> <td class="icon">  </td> <td class="content"> You can also use the standard JSR-107 (JCache) annotations (such as <code>@CacheResult</code>) transparently. However, we strongly advise you to not mix and match the Spring Cache and JCache annotations. </td> </tr> </table> </div> <div class="paragraph"> <p>If you do not add any specific cache library, Spring Boot auto-configures a <a href="#io.caching.provider.simple">simple provider</a> that uses concurrent maps in memory. When a cache is required (such as <code>piDecimals</code> in the preceding example), this provider creates it for you. The simple provider is not really recommended for production usage, but it is great for getting started and making sure that you understand the features. When you have made up your mind about the cache provider to use, please make sure to read its documentation to figure out how to configure the caches that your application uses. Nearly all providers require you to explicitly configure every cache that you use in the application. Some offer a way to customize the default caches defined by the <code>spring.cache.cache-names</code> property.</p> </div> <div class="admonitionblock tip"> <table> <tr> <td class="icon">  </td> <td class="content"> It is also possible to transparently <a href="https://docs.spring.io/spring-framework/docs/6.0.11/reference/html/integration.html#cache-annotations-put">update</a> or <a href="https://docs.spring.io/spring-framework/docs/6.0.11/reference/html/integration.html#cache-annotations-evict">evict</a> data from the cache. </td> </tr> </table> </div> <div class="sect2"> <h3 id="io.caching.provider">
1.1. Supported Cache Providers</h3> <div class="paragraph"> <p>The cache abstraction does not provide an actual store and relies on abstraction materialized by the <code>org.springframework.cache.Cache</code> and <code>org.springframework.cache.CacheManager</code> interfaces.</p> </div> <div class="paragraph"> <p>If you have not defined a bean of type <code>CacheManager</code> or a <code>CacheResolver</code> named <code>cacheResolver</code> (see <a href="https://docs.spring.io/spring-framework/docs/6.0.11/javadoc-api/org/springframework/cache/annotation/CachingConfigurer.html"><code>CachingConfigurer</code></a>), Spring Boot tries to detect the following providers (in the indicated order):</p> </div> <div class="olist arabic"> <ol class="arabic"> <li> <p><a href="#io.caching.provider.generic">Generic</a></p> </li> <li> <p><a href="#io.caching.provider.jcache">JCache (JSR-107)</a> (EhCache 3, Hazelcast, Infinispan, and others)</p> </li> <li> <p><a href="#io.caching.provider.hazelcast">Hazelcast</a></p> </li> <li> <p><a href="#io.caching.provider.infinispan">Infinispan</a></p> </li> <li> <p><a href="#io.caching.provider.couchbase">Couchbase</a></p> </li> <li> <p><a href="#io.caching.provider.redis">Redis</a></p> </li> <li> <p><a href="#io.caching.provider.caffeine">Caffeine</a></p> </li> <li> <p><a href="#io.caching.provider.cache2k">Cache2k</a></p> </li> <li> <p><a href="#io.caching.provider.simple">Simple</a></p> </li> </ol> </div> <div class="paragraph"> <p>Additionally, <a href="https://github.com/spring-projects/spring-boot-data-geode">Spring Boot for Apache Geode</a> provides <a href="https://docs.spring.io/spring-boot-data-geode-build/2.0.x/reference/html5/#geode-caching-provider">auto-configuration for using Apache Geode as a cache provider</a>.</p> </div> <div class="admonitionblock tip"> <table> <tr> <td class="icon">  </td> <td class="content"> If the <code>CacheManager</code> is auto-configured by Spring Boot, it is possible to <em>force</em> a particular cache provider by setting the <code>spring.cache.type</code> property. Use this property if you need to <a href="#io.caching.provider.none">use no-op caches</a> in certain environments (such as tests). </td> </tr> </table> </div> <div class="admonitionblock tip"> <table> <tr> <td class="icon">  </td> <td class="content"> Use the <code>spring-boot-starter-cache</code> “Starter” to quickly add basic caching dependencies. The starter brings in <code>spring-context-support</code>. If you add dependencies manually, you must include <code>spring-context-support</code> in order to use the JCache or Caffeine support. </td> </tr> </table> </div> <div class="paragraph"> <p>If the <code>CacheManager</code> is auto-configured by Spring Boot, you can further tune its configuration before it is fully initialized by exposing a bean that implements the <code>CacheManagerCustomizer</code> interface. The following example sets a flag to say that <code>null</code> values should not be passed down to the underlying map:</p> </div> <div class="listingblock primary"> <div class="title">Java</div> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import org.springframework.boot.autoconfigure.cache.CacheManagerCustomizer;
import org.springframework.cache.concurrent.ConcurrentMapCacheManager;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

</span><span class="fold-block">@Configuration(proxyBeanMethods = false)
public class MyCacheManagerConfiguration {

    @Bean
    public CacheManagerCustomizer&lt;ConcurrentMapCacheManager&gt; cacheManagerCustomizer() {
        return (cacheManager) -&gt; cacheManager.setAllowNullValues(false);
    }

}
</span></code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Kotlin</div> <div class="content"> <pre class="highlight" data-language="kotlin"><code class="language-kotlin" data-lang="kotlin"><span class="fold-block hide-when-folded">import org.springframework.boot.autoconfigure.cache.CacheManagerCustomizer
import org.springframework.cache.concurrent.ConcurrentMapCacheManager
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration

</span><span class="fold-block">@Configuration(proxyBeanMethods = false)
class MyCacheManagerConfiguration {

    @Bean
    fun cacheManagerCustomizer(): CacheManagerCustomizer&lt;ConcurrentMapCacheManager&gt; {
        return CacheManagerCustomizer { cacheManager -&gt;
            cacheManager.isAllowNullValues = false
        }
    }

}
</span></code></pre> </div> </div> <div class="admonitionblock note"> <table> <tr> <td class="icon">  </td> <td class="content"> In the preceding example, an auto-configured <code>ConcurrentMapCacheManager</code> is expected. If that is not the case (either you provided your own config or a different cache provider was auto-configured), the customizer is not invoked at all. You can have as many customizers as you want, and you can also order them by using <code>@Order</code> or <code>Ordered</code>. </td> </tr> </table> </div> <div class="sect3"> <h4 id="io.caching.provider.generic">
1.1.1. Generic</h4> <div class="paragraph"> <p>Generic caching is used if the context defines <em>at least</em> one <code>org.springframework.cache.Cache</code> bean. A <code>CacheManager</code> wrapping all beans of that type is created.</p> </div> </div> <div class="sect3"> <h4 id="io.caching.provider.jcache">
1.1.2. JCache (JSR-107)</h4> <div class="paragraph"> <p><a href="https://jcp.org/en/jsr/detail?id=107">JCache</a> is bootstrapped through the presence of a <code>javax.cache.spi.CachingProvider</code> on the classpath (that is, a JSR-107 compliant caching library exists on the classpath), and the <code>JCacheCacheManager</code> is provided by the <code>spring-boot-starter-cache</code> “Starter”. Various compliant libraries are available, and Spring Boot provides dependency management for Ehcache 3, Hazelcast, and Infinispan. Any other compliant library can be added as well.</p> </div> <div class="paragraph"> <p>It might happen that more than one provider is present, in which case the provider must be explicitly specified. Even if the JSR-107 standard does not enforce a standardized way to define the location of the configuration file, Spring Boot does its best to accommodate setting a cache with implementation details, as shown in the following example:</p> </div> <div class="listingblock primary"> <div class="title">Properties</div> <div class="content"> <pre class="highlight" data-language="properties"><code class="language-properties" data-lang="properties"># Only necessary if more than one provider is present
spring.cache.jcache.provider=com.example.MyCachingProvider
spring.cache.jcache.config=classpath:example.xml</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Yaml</div> <div class="content"> <pre class="highlight" data-language="yaml"><code class="language-yaml" data-lang="yaml"># Only necessary if more than one provider is present
spring:
  cache:
    jcache:
      provider: "com.example.MyCachingProvider"
      config: "classpath:example.xml"</code></pre> </div> </div> <div class="admonitionblock note"> <table> <tr> <td class="icon">  </td> <td class="content"> When a cache library offers both a native implementation and JSR-107 support, Spring Boot prefers the JSR-107 support, so that the same features are available if you switch to a different JSR-107 implementation. </td> </tr> </table> </div> <div class="admonitionblock tip"> <table> <tr> <td class="icon">  </td> <td class="content"> Spring Boot has <a href="#io.hazelcast">general support for Hazelcast</a>. If a single <code>HazelcastInstance</code> is available, it is automatically reused for the <code>CacheManager</code> as well, unless the <code>spring.cache.jcache.config</code> property is specified. </td> </tr> </table> </div> <div class="paragraph"> <p>There are two ways to customize the underlying <code>javax.cache.cacheManager</code>:</p> </div> <div class="ulist"> <ul> <li> <p>Caches can be created on startup by setting the <code>spring.cache.cache-names</code> property. If a custom <code>javax.cache.configuration.Configuration</code> bean is defined, it is used to customize them.</p> </li> <li> <p><code>org.springframework.boot.autoconfigure.cache.JCacheManagerCustomizer</code> beans are invoked with the reference of the <code>CacheManager</code> for full customization.</p> </li> </ul> </div> <div class="admonitionblock tip"> <table> <tr> <td class="icon">  </td> <td class="content"> If a standard <code>javax.cache.CacheManager</code> bean is defined, it is wrapped automatically in an <code>org.springframework.cache.CacheManager</code> implementation that the abstraction expects. No further customization is applied to it. </td> </tr> </table> </div> </div> <div class="sect3"> <h4 id="io.caching.provider.hazelcast">
1.1.3. Hazelcast</h4> <div class="paragraph"> <p>Spring Boot has <a href="#io.hazelcast">general support for Hazelcast</a>. If a <code>HazelcastInstance</code> has been auto-configured and <code>com.hazelcast:hazelcast-spring</code> is on the classpath, it is automatically wrapped in a <code>CacheManager</code>.</p> </div> <div class="admonitionblock note"> <table> <tr> <td class="icon">  </td> <td class="content"> Hazelcast can be used as a JCache compliant cache or as a Spring <code>CacheManager</code> compliant cache. When setting <code>spring.cache.type</code> to <code>hazelcast</code>, Spring Boot will use the <code>CacheManager</code> based implementation. If you want to use Hazelcast as a JCache compliant cache, set <code>spring.cache.type</code> to <code>jcache</code>. If you have multiple JCache compliant cache providers and want to force the use of Hazelcast, you have to <a href="#io.caching.provider.jcache">explicitly set the JCache provider</a>. </td> </tr> </table> </div> </div> <div class="sect3"> <h4 id="io.caching.provider.infinispan">
1.1.4. Infinispan</h4> <div class="paragraph"> <p><a href="https://infinispan.org/">Infinispan</a> has no default configuration file location, so it must be specified explicitly. Otherwise, the default bootstrap is used.</p> </div> <div class="listingblock primary"> <div class="title">Properties</div> <div class="content"> <pre class="highlight" data-language="properties"><code class="language-properties" data-lang="properties">spring.cache.infinispan.config=infinispan.xml</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Yaml</div> <div class="content"> <pre class="highlight" data-language="yaml"><code class="language-yaml" data-lang="yaml">spring:
  cache:
    infinispan:
      config: "infinispan.xml"</code></pre> </div> </div> <div class="paragraph"> <p>Caches can be created on startup by setting the <code>spring.cache.cache-names</code> property. If a custom <code>ConfigurationBuilder</code> bean is defined, it is used to customize the caches.</p> </div> <div class="paragraph"> <p>To be compatible with Spring Boot’s Jakarta EE 9 baseline, Infinispan’s <code>-jakarta</code> modules must be used. For every module with a <code>-jakarta</code> variant, the variant must be used in place of the standard module. For example, <code>infinispan-core-jakarta</code> and <code>infinispan-commons-jakarta</code> must be used in place of <code>infinispan-core</code> and <code>infinispan-commons</code> respectively.</p> </div> </div> <div class="sect3"> <h4 id="io.caching.provider.couchbase">
1.1.5. Couchbase</h4> <div class="paragraph"> <p>If Spring Data Couchbase is available and Couchbase is <a href="data.html#data.nosql.couchbase">configured</a>, a <code>CouchbaseCacheManager</code> is auto-configured. It is possible to create additional caches on startup by setting the <code>spring.cache.cache-names</code> property and cache defaults can be configured by using <code>spring.cache.couchbase.*</code> properties. For instance, the following configuration creates <code>cache1</code> and <code>cache2</code> caches with an entry <em>expiration</em> of 10 minutes:</p> </div> <div class="listingblock primary"> <div class="title">Properties</div> <div class="content"> <pre class="highlight" data-language="properties"><code class="language-properties" data-lang="properties">spring.cache.cache-names=cache1,cache2
spring.cache.couchbase.expiration=10m</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Yaml</div> <div class="content"> <pre class="highlight" data-language="yaml"><code class="language-yaml" data-lang="yaml">spring:
  cache:
    cache-names: "cache1,cache2"
    couchbase:
      expiration: "10m"</code></pre> </div> </div> <div class="paragraph"> <p>If you need more control over the configuration, consider registering a <code>CouchbaseCacheManagerBuilderCustomizer</code> bean. The following example shows a customizer that configures a specific entry expiration for <code>cache1</code> and <code>cache2</code>:</p> </div> <div class="listingblock primary"> <div class="title">Java</div> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import java.time.Duration;

import org.springframework.boot.autoconfigure.cache.CouchbaseCacheManagerBuilderCustomizer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.couchbase.cache.CouchbaseCacheConfiguration;

</span><span class="fold-block">@Configuration(proxyBeanMethods = false)
public class MyCouchbaseCacheManagerConfiguration {

    @Bean
    public CouchbaseCacheManagerBuilderCustomizer myCouchbaseCacheManagerBuilderCustomizer() {
        return (builder) -&gt; builder
                .withCacheConfiguration("cache1", CouchbaseCacheConfiguration
                        .defaultCacheConfig().entryExpiry(Duration.ofSeconds(10)))
                .withCacheConfiguration("cache2", CouchbaseCacheConfiguration
                        .defaultCacheConfig().entryExpiry(Duration.ofMinutes(1)));

    }

}
</span></code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Kotlin</div> <div class="content"> <pre class="highlight" data-language="kotlin"><code class="language-kotlin" data-lang="kotlin"><span class="fold-block hide-when-folded">import org.springframework.boot.autoconfigure.cache.CouchbaseCacheManagerBuilderCustomizer
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.data.couchbase.cache.CouchbaseCacheConfiguration
import java.time.Duration

</span><span class="fold-block">@Configuration(proxyBeanMethods = false)
class MyCouchbaseCacheManagerConfiguration {

    @Bean
    fun myCouchbaseCacheManagerBuilderCustomizer(): CouchbaseCacheManagerBuilderCustomizer {
        return CouchbaseCacheManagerBuilderCustomizer { builder -&gt;
            builder
                .withCacheConfiguration(
                    "cache1", CouchbaseCacheConfiguration
                        .defaultCacheConfig().entryExpiry(Duration.ofSeconds(10))
                )
                .withCacheConfiguration(
                    "cache2", CouchbaseCacheConfiguration
                        .defaultCacheConfig().entryExpiry(Duration.ofMinutes(1))
                )
        }
    }

}
</span></code></pre> </div> </div> </div> <div class="sect3"> <h4 id="io.caching.provider.redis">
1.1.6. Redis</h4> <div class="paragraph"> <p>If <a href="https://redis.io/">Redis</a> is available and configured, a <code>RedisCacheManager</code> is auto-configured. It is possible to create additional caches on startup by setting the <code>spring.cache.cache-names</code> property and cache defaults can be configured by using <code>spring.cache.redis.*</code> properties. For instance, the following configuration creates <code>cache1</code> and <code>cache2</code> caches with a <em>time to live</em> of 10 minutes:</p> </div> <div class="listingblock primary"> <div class="title">Properties</div> <div class="content"> <pre class="highlight" data-language="properties"><code class="language-properties" data-lang="properties">spring.cache.cache-names=cache1,cache2
spring.cache.redis.time-to-live=10m</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Yaml</div> <div class="content"> <pre class="highlight" data-language="yaml"><code class="language-yaml" data-lang="yaml">spring:
  cache:
    cache-names: "cache1,cache2"
    redis:
      time-to-live: "10m"</code></pre> </div> </div> <div class="admonitionblock note"> <table> <tr> <td class="icon">  </td> <td class="content"> By default, a key prefix is added so that, if two separate caches use the same key, Redis does not have overlapping keys and cannot return invalid values. We strongly recommend keeping this setting enabled if you create your own <code>RedisCacheManager</code>. </td> </tr> </table> </div> <div class="admonitionblock tip"> <table> <tr> <td class="icon">  </td> <td class="content"> You can take full control of the default configuration by adding a <code>RedisCacheConfiguration</code> <code>@Bean</code> of your own. This can be useful if you need to customize the default serialization strategy. </td> </tr> </table> </div> <div class="paragraph"> <p>If you need more control over the configuration, consider registering a <code>RedisCacheManagerBuilderCustomizer</code> bean. The following example shows a customizer that configures a specific time to live for <code>cache1</code> and <code>cache2</code>:</p> </div> <div class="listingblock primary"> <div class="title">Java</div> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import java.time.Duration;

import org.springframework.boot.autoconfigure.cache.RedisCacheManagerBuilderCustomizer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.cache.RedisCacheConfiguration;

</span><span class="fold-block">@Configuration(proxyBeanMethods = false)
public class MyRedisCacheManagerConfiguration {

    @Bean
    public RedisCacheManagerBuilderCustomizer myRedisCacheManagerBuilderCustomizer() {
        return (builder) -&gt; builder
                .withCacheConfiguration("cache1", RedisCacheConfiguration
                        .defaultCacheConfig().entryTtl(Duration.ofSeconds(10)))
                .withCacheConfiguration("cache2", RedisCacheConfiguration
                        .defaultCacheConfig().entryTtl(Duration.ofMinutes(1)));

    }

}
</span></code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Kotlin</div> <div class="content"> <pre class="highlight" data-language="kotlin"><code class="language-kotlin" data-lang="kotlin"><span class="fold-block hide-when-folded">import org.springframework.boot.autoconfigure.cache.RedisCacheManagerBuilderCustomizer
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.data.redis.cache.RedisCacheConfiguration
import java.time.Duration

</span><span class="fold-block">@Configuration(proxyBeanMethods = false)
class MyRedisCacheManagerConfiguration {

    @Bean
    fun myRedisCacheManagerBuilderCustomizer(): RedisCacheManagerBuilderCustomizer {
        return RedisCacheManagerBuilderCustomizer { builder -&gt;
            builder
                .withCacheConfiguration(
                    "cache1", RedisCacheConfiguration
                        .defaultCacheConfig().entryTtl(Duration.ofSeconds(10))
                )
                .withCacheConfiguration(
                    "cache2", RedisCacheConfiguration
                        .defaultCacheConfig().entryTtl(Duration.ofMinutes(1))
                )
        }
    }

}
</span></code></pre> </div> </div> </div> <div class="sect3"> <h4 id="io.caching.provider.caffeine">
1.1.7. Caffeine</h4> <div class="paragraph"> <p><a href="https://github.com/ben-manes/caffeine">Caffeine</a> is a Java 8 rewrite of Guava’s cache that supersedes support for Guava. If Caffeine is present, a <code>CaffeineCacheManager</code> (provided by the <code>spring-boot-starter-cache</code> “Starter”) is auto-configured. Caches can be created on startup by setting the <code>spring.cache.cache-names</code> property and can be customized by one of the following (in the indicated order):</p> </div> <div class="olist arabic"> <ol class="arabic"> <li> <p>A cache spec defined by <code>spring.cache.caffeine.spec</code></p> </li> <li> <p>A <code>com.github.benmanes.caffeine.cache.CaffeineSpec</code> bean is defined</p> </li> <li> <p>A <code>com.github.benmanes.caffeine.cache.Caffeine</code> bean is defined</p> </li> </ol> </div> <div class="paragraph"> <p>For instance, the following configuration creates <code>cache1</code> and <code>cache2</code> caches with a maximum size of 500 and a <em>time to live</em> of 10 minutes</p> </div> <div class="listingblock primary"> <div class="title">Properties</div> <div class="content"> <pre class="highlight" data-language="properties"><code class="language-properties" data-lang="properties">spring.cache.cache-names=cache1,cache2
spring.cache.caffeine.spec=maximumSize=500,expireAfterAccess=600s</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Yaml</div> <div class="content"> <pre class="highlight" data-language="yaml"><code class="language-yaml" data-lang="yaml">spring:
  cache:
    cache-names: "cache1,cache2"
    caffeine:
      spec: "maximumSize=500,expireAfterAccess=600s"</code></pre> </div> </div> <div class="paragraph"> <p>If a <code>com.github.benmanes.caffeine.cache.CacheLoader</code> bean is defined, it is automatically associated to the <code>CaffeineCacheManager</code>. Since the <code>CacheLoader</code> is going to be associated with <em>all</em> caches managed by the cache manager, it must be defined as <code>CacheLoader&lt;Object, Object&gt;</code>. The auto-configuration ignores any other generic type.</p> </div> </div> <div class="sect3"> <h4 id="io.caching.provider.cache2k">
1.1.8. Cache2k</h4> <div class="paragraph"> <p><a href="https://cache2k.org/">Cache2k</a> is an in-memory cache. If the Cache2k spring integration is present, a <code>SpringCache2kCacheManager</code> is auto-configured.</p> </div> <div class="paragraph"> <p>Caches can be created on startup by setting the <code>spring.cache.cache-names</code> property. Cache defaults can be customized using a <code>Cache2kBuilderCustomizer</code> bean. The following example shows a customizer that configures the capacity of the cache to 200 entries, with an expiration of 5 minutes:</p> </div> <div class="listingblock primary"> <div class="title">Java</div> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import java.util.concurrent.TimeUnit;

import org.springframework.boot.autoconfigure.cache.Cache2kBuilderCustomizer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

</span><span class="fold-block">@Configuration(proxyBeanMethods = false)
public class MyCache2kDefaultsConfiguration {

    @Bean
    public Cache2kBuilderCustomizer myCache2kDefaultsCustomizer() {
        return (builder) -&gt; builder.entryCapacity(200)
                .expireAfterWrite(5, TimeUnit.MINUTES);
    }

}
</span></code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Kotlin</div> <div class="content"> <pre class="highlight" data-language="kotlin"><code class="language-kotlin" data-lang="kotlin"><span class="fold-block hide-when-folded">import org.springframework.boot.autoconfigure.cache.Cache2kBuilderCustomizer
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import java.util.concurrent.TimeUnit

</span><span class="fold-block">@Configuration(proxyBeanMethods = false)
class MyCache2kDefaultsConfiguration {

    @Bean
    fun myCache2kDefaultsCustomizer(): Cache2kBuilderCustomizer {
        return Cache2kBuilderCustomizer { builder -&gt;
            builder.entryCapacity(200)
                .expireAfterWrite(5, TimeUnit.MINUTES)
        }
    }
}
</span></code></pre> </div> </div> </div> <div class="sect3"> <h4 id="io.caching.provider.simple">
1.1.9. Simple</h4> <div class="paragraph"> <p>If none of the other providers can be found, a simple implementation using a <code>ConcurrentHashMap</code> as the cache store is configured. This is the default if no caching library is present in your application. By default, caches are created as needed, but you can restrict the list of available caches by setting the <code>cache-names</code> property. For instance, if you want only <code>cache1</code> and <code>cache2</code> caches, set the <code>cache-names</code> property as follows:</p> </div> <div class="listingblock primary"> <div class="title">Properties</div> <div class="content"> <pre class="highlight" data-language="properties"><code class="language-properties" data-lang="properties">spring.cache.cache-names=cache1,cache2</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Yaml</div> <div class="content"> <pre class="highlight" data-language="yaml"><code class="language-yaml" data-lang="yaml">spring:
  cache:
    cache-names: "cache1,cache2"</code></pre> </div> </div> <div class="paragraph"> <p>If you do so and your application uses a cache not listed, then it fails at runtime when the cache is needed, but not on startup. This is similar to the way the "real" cache providers behave if you use an undeclared cache.</p> </div> </div> <div class="sect3"> <h4 id="io.caching.provider.none">
1.1.10. None</h4> <div class="paragraph"> <p>When <code>@EnableCaching</code> is present in your configuration, a suitable cache configuration is expected as well. If you have a custom <code>CacheManager</code>, consider defining it in a separate <code>@Configuration</code> class so that you can override it if necessary. None uses a no-op implementation that is useful in tests, and slice tests use that by default via <code>@AutoConfigureCache</code>.</p> </div> <div class="paragraph"> <p>If you need to use a no-op cache rather than the auto-configured cache manager in a certain environment, set the cache type to <code>none</code>, as shown in the following example:</p> </div> <div class="listingblock primary"> <div class="title">Properties</div> <div class="content"> <pre class="highlight" data-language="properties"><code class="language-properties" data-lang="properties">spring.cache.type=none</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Yaml</div> <div class="content"> <pre class="highlight" data-language="yaml"><code class="language-yaml" data-lang="yaml">spring:
  cache:
    type: "none"</code></pre> </div> </div> </div> </div> </div> </div> <div class="sect1"> <h2 id="io.hazelcast">
2. Hazelcast</h2> <div class="sectionbody"> <div class="paragraph"> <p>If <a href="https://hazelcast.com/">Hazelcast</a> is on the classpath and a suitable configuration is found, Spring Boot auto-configures a <code>HazelcastInstance</code> that you can inject in your application.</p> </div> <div class="paragraph"> <p>Spring Boot first attempts to create a client by checking the following configuration options:</p> </div> <div class="ulist"> <ul> <li> <p>The presence of a <code>com.hazelcast.client.config.ClientConfig</code> bean.</p> </li> <li> <p>A configuration file defined by the <code>spring.hazelcast.config</code> property.</p> </li> <li> <p>The presence of the <code>hazelcast.client.config</code> system property.</p> </li> <li> <p>A <code>hazelcast-client.xml</code> in the working directory or at the root of the classpath.</p> </li> <li> <p>A <code>hazelcast-client.yaml</code> (or <code>hazelcast-client.yml</code>) in the working directory or at the root of the classpath.</p> </li> </ul> </div> <div class="paragraph"> <p>If a client can not be created, Spring Boot attempts to configure an embedded server. If you define a <code>com.hazelcast.config.Config</code> bean, Spring Boot uses that. If your configuration defines an instance name, Spring Boot tries to locate an existing instance rather than creating a new one.</p> </div> <div class="paragraph"> <p>You could also specify the Hazelcast configuration file to use through configuration, as shown in the following example:</p> </div> <div class="listingblock primary"> <div class="title">Properties</div> <div class="content"> <pre class="highlight" data-language="properties"><code class="language-properties" data-lang="properties">spring.hazelcast.config=classpath:config/my-hazelcast.xml</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Yaml</div> <div class="content"> <pre class="highlight" data-language="yaml"><code class="language-yaml" data-lang="yaml">spring:
  hazelcast:
    config: "classpath:config/my-hazelcast.xml"</code></pre> </div> </div> <div class="paragraph"> <p>Otherwise, Spring Boot tries to find the Hazelcast configuration from the default locations: <code>hazelcast.xml</code> in the working directory or at the root of the classpath, or a YAML counterpart in the same locations. We also check if the <code>hazelcast.config</code> system property is set. See the <a href="https://docs.hazelcast.org/docs/latest/manual/html-single/">Hazelcast documentation</a> for more details.</p> </div> <div class="admonitionblock tip"> <table> <tr> <td class="icon">  </td> <td class="content"> By default, <code>@SpringAware</code> on Hazelcast components is supported. The <code>ManagementContext</code> can be overridden by declaring a <code>HazelcastConfigCustomizer</code> bean with an <code>@Order</code> higher than zero. </td> </tr> </table> </div> <div class="admonitionblock note"> <table> <tr> <td class="icon">  </td> <td class="content"> Spring Boot also has <a href="#io.caching.provider.hazelcast">explicit caching support for Hazelcast</a>. If caching is enabled, the <code>HazelcastInstance</code> is automatically wrapped in a <code>CacheManager</code> implementation. </td> </tr> </table> </div> </div> </div> <div class="sect1"> <h2 id="io.quartz">
3. Quartz Scheduler</h2> <div class="sectionbody"> <div class="paragraph"> <p>Spring Boot offers several conveniences for working with the <a href="https://www.quartz-scheduler.org/">Quartz scheduler</a>, including the <code>spring-boot-starter-quartz</code> “Starter”. If Quartz is available, a <code>Scheduler</code> is auto-configured (through the <code>SchedulerFactoryBean</code> abstraction).</p> </div> <div class="paragraph"> <p>Beans of the following types are automatically picked up and associated with the <code>Scheduler</code>:</p> </div> <div class="ulist"> <ul> <li> <p><code>JobDetail</code>: defines a particular Job. <code>JobDetail</code> instances can be built with the <code>JobBuilder</code> API.</p> </li> <li> <p><code>Calendar</code>.</p> </li> <li> <p><code>Trigger</code>: defines when a particular job is triggered.</p> </li> </ul> </div> <div class="paragraph"> <p>By default, an in-memory <code>JobStore</code> is used. However, it is possible to configure a JDBC-based store if a <code>DataSource</code> bean is available in your application and if the <code>spring.quartz.job-store-type</code> property is configured accordingly, as shown in the following example:</p> </div> <div class="listingblock primary"> <div class="title">Properties</div> <div class="content"> <pre class="highlight" data-language="properties"><code class="language-properties" data-lang="properties">spring.quartz.job-store-type=jdbc</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Yaml</div> <div class="content"> <pre class="highlight" data-language="yaml"><code class="language-yaml" data-lang="yaml">spring:
  quartz:
    job-store-type: "jdbc"</code></pre> </div> </div> <div class="paragraph"> <p>When the JDBC store is used, the schema can be initialized on startup, as shown in the following example:</p> </div> <div class="listingblock primary"> <div class="title">Properties</div> <div class="content"> <pre class="highlight" data-language="properties"><code class="language-properties" data-lang="properties">spring.quartz.jdbc.initialize-schema=always</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Yaml</div> <div class="content"> <pre class="highlight" data-language="yaml"><code class="language-yaml" data-lang="yaml">spring:
  quartz:
    jdbc:
      initialize-schema: "always"</code></pre> </div> </div> <div class="admonitionblock warning"> <table> <tr> <td class="icon">  </td> <td class="content"> By default, the database is detected and initialized by using the standard scripts provided with the Quartz library. These scripts drop existing tables, deleting all triggers on every restart. It is also possible to provide a custom script by setting the <code>spring.quartz.jdbc.schema</code> property. </td> </tr> </table> </div> <div class="paragraph"> <p>To have Quartz use a <code>DataSource</code> other than the application’s main <code>DataSource</code>, declare a <code>DataSource</code> bean, annotating its <code>@Bean</code> method with <code>@QuartzDataSource</code>. Doing so ensures that the Quartz-specific <code>DataSource</code> is used by both the <code>SchedulerFactoryBean</code> and for schema initialization. Similarly, to have Quartz use a <code>TransactionManager</code> other than the application’s main <code>TransactionManager</code> declare a <code>TransactionManager</code> bean, annotating its <code>@Bean</code> method with <code>@QuartzTransactionManager</code>.</p> </div> <div class="paragraph"> <p>By default, jobs created by configuration will not overwrite already registered jobs that have been read from a persistent job store. To enable overwriting existing job definitions set the <code>spring.quartz.overwrite-existing-jobs</code> property.</p> </div> <div class="paragraph"> <p>Quartz Scheduler configuration can be customized using <code>spring.quartz</code> properties and <code>SchedulerFactoryBeanCustomizer</code> beans, which allow programmatic <code>SchedulerFactoryBean</code> customization. Advanced Quartz configuration properties can be customized using <code>spring.quartz.properties.*</code>.</p> </div> <div class="admonitionblock note"> <table> <tr> <td class="icon">  </td> <td class="content"> In particular, an <code>Executor</code> bean is not associated with the scheduler as Quartz offers a way to configure the scheduler through <code>spring.quartz.properties</code>. If you need to customize the task executor, consider implementing <code>SchedulerFactoryBeanCustomizer</code>. </td> </tr> </table> </div> <div class="paragraph"> <p>Jobs can define setters to inject data map properties. Regular beans can also be injected in a similar manner, as shown in the following example:</p> </div> <div class="listingblock primary"> <div class="title">Java</div> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import org.quartz.JobExecutionContext;
import org.quartz.JobExecutionException;

import org.springframework.scheduling.quartz.QuartzJobBean;

</span><span class="fold-block">public class MySampleJob extends QuartzJobBean {

</span><span class="fold-block hide-when-unfolded">    // fields ...

</span><span class="fold-block hide-when-folded">    private MyService myService;

    private String name;

</span><span class="fold-block">    // Inject "MyService" bean
    public void setMyService(MyService myService) {
        this.myService = myService;
    }

    // Inject the "name" job data property
    public void setName(String name) {
        this.name = name;
    }

    @Override
    protected void executeInternal(JobExecutionContext context) throws JobExecutionException {
        this.myService.someMethod(context.getFireTime(), this.name);
    }

}
</span></code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Kotlin</div> <div class="content"> <pre class="highlight" data-language="kotlin"><code class="language-kotlin" data-lang="kotlin"><span class="fold-block hide-when-folded">import org.quartz.JobExecutionContext
import org.springframework.scheduling.quartz.QuartzJobBean

</span><span class="fold-block">class MySampleJob : QuartzJobBean() {

</span><span class="fold-block hide-when-unfolded">    // fields ...

</span><span class="fold-block hide-when-folded">    private var myService: MyService? = null

    private var name: String? = null

</span><span class="fold-block">    // Inject "MyService" bean
    fun setMyService(myService: MyService?) {
        this.myService = myService
    }

    // Inject the "name" job data property
    fun setName(name: String?) {
        this.name = name
    }

    override fun executeInternal(context: JobExecutionContext) {
        myService!!.someMethod(context.fireTime, name)
    }

}
</span></code></pre> </div> </div> </div> </div> <div class="sect1"> <h2 id="io.email">
4. Sending Email</h2> <div class="sectionbody"> <div class="paragraph"> <p>The Spring Framework provides an abstraction for sending email by using the <code>JavaMailSender</code> interface, and Spring Boot provides auto-configuration for it as well as a starter module.</p> </div> <div class="admonitionblock tip"> <table> <tr> <td class="icon">  </td> <td class="content"> See the <a href="https://docs.spring.io/spring-framework/docs/6.0.11/reference/html/integration.html#mail">reference documentation</a> for a detailed explanation of how you can use <code>JavaMailSender</code>. </td> </tr> </table> </div> <div class="paragraph"> <p>If <code>spring.mail.host</code> and the relevant libraries (as defined by <code>spring-boot-starter-mail</code>) are available, a default <code>JavaMailSender</code> is created if none exists. The sender can be further customized by configuration items from the <code>spring.mail</code> namespace. See <a href="https://github.com/spring-projects/spring-boot/tree/v3.1.3/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/mail/MailProperties.java"><code>MailProperties</code></a> for more details.</p> </div> <div class="paragraph"> <p>In particular, certain default timeout values are infinite, and you may want to change that to avoid having a thread blocked by an unresponsive mail server, as shown in the following example:</p> </div> <div class="listingblock primary"> <div class="title">Properties</div> <div class="content"> <pre class="highlight" data-language="properties"><code class="language-properties" data-lang="properties">spring.mail.properties[mail.smtp.connectiontimeout]=5000
spring.mail.properties[mail.smtp.timeout]=3000
spring.mail.properties[mail.smtp.writetimeout]=5000</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Yaml</div> <div class="content"> <pre class="highlight" data-language="yaml"><code class="language-yaml" data-lang="yaml">spring:
  mail:
    properties:
      "[mail.smtp.connectiontimeout]": 5000
      "[mail.smtp.timeout]": 3000
      "[mail.smtp.writetimeout]": 5000</code></pre> </div> </div> <div class="paragraph"> <p>It is also possible to configure a <code>JavaMailSender</code> with an existing <code>Session</code> from JNDI:</p> </div> <div class="listingblock primary"> <div class="title">Properties</div> <div class="content"> <pre class="highlight" data-language="properties"><code class="language-properties" data-lang="properties">spring.mail.jndi-name=mail/Session</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Yaml</div> <div class="content"> <pre class="highlight" data-language="yaml"><code class="language-yaml" data-lang="yaml">spring:
  mail:
    jndi-name: "mail/Session"</code></pre> </div> </div> <div class="paragraph"> <p>When a <code>jndi-name</code> is set, it takes precedence over all other Session-related settings.</p> </div> </div> </div> <div class="sect1"> <h2 id="io.validation">
5. Validation</h2> <div class="sectionbody"> <div class="paragraph"> <p>The method validation feature supported by Bean Validation 1.1 is automatically enabled as long as a JSR-303 implementation (such as Hibernate validator) is on the classpath. This lets bean methods be annotated with <code>jakarta.validation</code> constraints on their parameters and/or on their return value. Target classes with such annotated methods need to be annotated with the <code>@Validated</code> annotation at the type level for their methods to be searched for inline constraint annotations.</p> </div> <div class="paragraph"> <p>For instance, the following service triggers the validation of the first argument, making sure its size is between 8 and 10:</p> </div> <div class="listingblock primary"> <div class="title">Java</div> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import jakarta.validation.constraints.Size;

import org.springframework.stereotype.Service;
import org.springframework.validation.annotation.Validated;

</span><span class="fold-block">@Service
@Validated
public class MyBean {

    public Archive findByCodeAndAuthor(@Size(min = 8, max = 10) String code, Author author) {
        return ...
    }

}
</span></code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Kotlin</div> <div class="content"> <pre class="highlight" data-language="kotlin"><code class="language-kotlin" data-lang="kotlin"><span class="fold-block hide-when-folded">import jakarta.validation.constraints.Size
import org.springframework.stereotype.Service
import org.springframework.validation.annotation.Validated

</span><span class="fold-block">@Service
@Validated
class MyBean {

    fun findByCodeAndAuthor(code: @Size(min = 8, max = 10) String?, author: Author?): Archive? {
        return null
    }

}
</span></code></pre> </div> </div> <div class="paragraph"> <p>The application’s <code>MessageSource</code> is used when resolving <code>{parameters}</code> in constraint messages. This allows you to use <a href="features.html#features.internationalization">your application’s <code>messages.properties</code> files</a> for Bean Validation messages. Once the parameters have been resolved, message interpolation is completed using Bean Validation’s default interpolator.</p> </div> <div class="paragraph"> <p>To customize the <code>Configuration</code> used to build the <code>ValidatorFactory</code>, define a <code>ValidationConfigurationCustomizer</code> bean. When multiple customizer beans are defined, they are called in order based on their <code>@Order</code> annotation or <code>Ordered</code> implementation.</p> </div> </div> </div> <div class="sect1"> <h2 id="io.rest-client">
6. Calling REST Services</h2> <div class="sectionbody"> <div class="paragraph"> <p>If your application calls remote REST services, Spring Boot makes that very convenient using a <code>RestTemplate</code> or a <code>WebClient</code>.</p> </div> <div class="sect2"> <h3 id="io.rest-client.resttemplate">
6.1. RestTemplate</h3> <div class="paragraph"> <p>If you need to call remote REST services from your application, you can use the Spring Framework’s <a href="https://docs.spring.io/spring-framework/docs/6.0.11/javadoc-api/org/springframework/web/client/RestTemplate.html"><code>RestTemplate</code></a> class. Since <code>RestTemplate</code> instances often need to be customized before being used, Spring Boot does not provide any single auto-configured <code>RestTemplate</code> bean. It does, however, auto-configure a <code>RestTemplateBuilder</code>, which can be used to create <code>RestTemplate</code> instances when needed. The auto-configured <code>RestTemplateBuilder</code> ensures that sensible <code>HttpMessageConverters</code> are applied to <code>RestTemplate</code> instances.</p> </div> <div class="paragraph"> <p>The following code shows a typical example:</p> </div> <div class="listingblock primary"> <div class="title">Java</div> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import org.springframework.boot.web.client.RestTemplateBuilder;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

</span><span class="fold-block">@Service
public class MyService {

    private final RestTemplate restTemplate;

    public MyService(RestTemplateBuilder restTemplateBuilder) {
        this.restTemplate = restTemplateBuilder.build();
    }

    public Details someRestCall(String name) {
        return this.restTemplate.getForObject("/{name}/details", Details.class, name);
    }

}
</span></code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Kotlin</div> <div class="content"> <pre class="highlight" data-language="kotlin"><code class="language-kotlin" data-lang="kotlin"><span class="fold-block hide-when-folded">import org.springframework.boot.web.client.RestTemplateBuilder
import org.springframework.stereotype.Service
import org.springframework.web.client.RestTemplate

</span><span class="fold-block">@Service
class MyService(restTemplateBuilder: RestTemplateBuilder) {

    private val restTemplate: RestTemplate

    init {
        restTemplate = restTemplateBuilder.build()
    }

    fun someRestCall(name: String): Details {
        return restTemplate.getForObject("/{name}/details", Details::class.java, name)!!
    }

}
</span></code></pre> </div> </div> <div class="paragraph"> <p><code>RestTemplateBuilder</code> includes a number of useful methods that can be used to quickly configure a <code>RestTemplate</code>. For example, to add BASIC authentication support, you can use <code>builder.basicAuthentication("user", "password").build()</code>.</p> </div> <div class="sect3"> <h4 id="io.rest-client.resttemplate.http-client">
6.1.1. RestTemplate HTTP Client</h4> <div class="paragraph"> <p>Spring Boot will auto-detect which HTTP client to use with <code>RestTemplate</code> depending on the libraries available on the application classpath. In order of preference, the following clients are supported:</p> </div> <div class="olist arabic"> <ol class="arabic"> <li> <p>Apache HttpClient</p> </li> <li> <p>OkHttp</p> </li> <li> <p>Simple JDK client (<code>HttpURLConnection</code>)</p> </li> </ol> </div> <div class="paragraph"> <p>If multiple clients are available on the classpath, the most preferred client will be used.</p> </div> </div> <div class="sect3"> <h4 id="io.rest-client.resttemplate.customization">
6.1.2. RestTemplate Customization</h4> <div class="paragraph"> <p>There are three main approaches to <code>RestTemplate</code> customization, depending on how broadly you want the customizations to apply.</p> </div> <div class="paragraph"> <p>To make the scope of any customizations as narrow as possible, inject the auto-configured <code>RestTemplateBuilder</code> and then call its methods as required. Each method call returns a new <code>RestTemplateBuilder</code> instance, so the customizations only affect this use of the builder.</p> </div> <div class="paragraph"> <p>To make an application-wide, additive customization, use a <code>RestTemplateCustomizer</code> bean. All such beans are automatically registered with the auto-configured <code>RestTemplateBuilder</code> and are applied to any templates that are built with it.</p> </div> <div class="paragraph"> <p>The following example shows a customizer that configures the use of a proxy for all hosts except <code>192.168.0.5</code>:</p> </div> <div class="listingblock primary"> <div class="title">Java</div> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import org.apache.hc.client5.http.classic.HttpClient;
import org.apache.hc.client5.http.impl.classic.HttpClientBuilder;
import org.apache.hc.client5.http.impl.routing.DefaultProxyRoutePlanner;
import org.apache.hc.client5.http.routing.HttpRoutePlanner;
import org.apache.hc.core5.http.HttpException;
import org.apache.hc.core5.http.HttpHost;
import org.apache.hc.core5.http.protocol.HttpContext;

import org.springframework.boot.web.client.RestTemplateCustomizer;
import org.springframework.http.client.HttpComponentsClientHttpRequestFactory;
import org.springframework.web.client.RestTemplate;

</span><span class="fold-block">public class MyRestTemplateCustomizer implements RestTemplateCustomizer {

    @Override
    public void customize(RestTemplate restTemplate) {
        HttpRoutePlanner routePlanner = new CustomRoutePlanner(new HttpHost("proxy.example.com"));
        HttpClient httpClient = HttpClientBuilder.create().setRoutePlanner(routePlanner).build();
        restTemplate.setRequestFactory(new HttpComponentsClientHttpRequestFactory(httpClient));
    }

    static class CustomRoutePlanner extends DefaultProxyRoutePlanner {

        CustomRoutePlanner(HttpHost proxy) {
            super(proxy);
        }

        @Override
        protected HttpHost determineProxy(HttpHost target, HttpContext context) throws HttpException {
            if (target.getHostName().equals("192.168.0.5")) {
                return null;
            }
            return super.determineProxy(target, context);
        }

    }

}
</span></code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Kotlin</div> <div class="content"> <pre class="highlight" data-language="kotlin"><code class="language-kotlin" data-lang="kotlin"><span class="fold-block hide-when-folded">import org.apache.hc.client5.http.classic.HttpClient
import org.apache.hc.client5.http.impl.classic.HttpClientBuilder
import org.apache.hc.client5.http.impl.routing.DefaultProxyRoutePlanner
import org.apache.hc.client5.http.routing.HttpRoutePlanner
import org.apache.hc.core5.http.HttpException
import org.apache.hc.core5.http.HttpHost
import org.apache.hc.core5.http.protocol.HttpContext
import org.springframework.boot.web.client.RestTemplateCustomizer
import org.springframework.http.client.HttpComponentsClientHttpRequestFactory
import org.springframework.web.client.RestTemplate

</span><span class="fold-block">class MyRestTemplateCustomizer : RestTemplateCustomizer {

    override fun customize(restTemplate: RestTemplate) {
        val routePlanner: HttpRoutePlanner = CustomRoutePlanner(HttpHost("proxy.example.com"))
        val httpClient: HttpClient = HttpClientBuilder.create().setRoutePlanner(routePlanner).build()
        restTemplate.requestFactory = HttpComponentsClientHttpRequestFactory(httpClient)
    }

    internal class CustomRoutePlanner(proxy: HttpHost?) : DefaultProxyRoutePlanner(proxy) {

        @Throws(HttpException::class)
        public override fun determineProxy(target: HttpHost, context: HttpContext): HttpHost? {
            if (target.hostName == "192.168.0.5") {
                return null
            }
            return  super.determineProxy(target, context)
        }

    }

}
</span></code></pre> </div> </div> <div class="paragraph"> <p>Finally, you can define your own <code>RestTemplateBuilder</code> bean. Doing so will replace the auto-configured builder. If you want any <code>RestTemplateCustomizer</code> beans to be applied to your custom builder, as the auto-configuration would have done, configure it using a <code>RestTemplateBuilderConfigurer</code>. The following example exposes a <code>RestTemplateBuilder</code> that matches what Spring Boot’s auto-configuration would have done, except that custom connect and read timeouts are also specified:</p> </div> <div class="listingblock primary"> <div class="title">Java</div> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import java.time.Duration;

import org.springframework.boot.autoconfigure.web.client.RestTemplateBuilderConfigurer;
import org.springframework.boot.web.client.RestTemplateBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

</span><span class="fold-block">@Configuration(proxyBeanMethods = false)
public class MyRestTemplateBuilderConfiguration {

    @Bean
    public RestTemplateBuilder restTemplateBuilder(RestTemplateBuilderConfigurer configurer) {
        return configurer.configure(new RestTemplateBuilder())
            .setConnectTimeout(Duration.ofSeconds(5))
            .setReadTimeout(Duration.ofSeconds(2));
    }

}
</span></code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Kotlin</div> <div class="content"> <pre class="highlight" data-language="kotlin"><code class="language-kotlin" data-lang="kotlin"><span class="fold-block hide-when-folded">import org.springframework.boot.autoconfigure.web.client.RestTemplateBuilderConfigurer
import org.springframework.boot.web.client.RestTemplateBuilder
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import java.time.Duration

</span><span class="fold-block">@Configuration(proxyBeanMethods = false)
class MyRestTemplateBuilderConfiguration {

    @Bean
    fun restTemplateBuilder(configurer: RestTemplateBuilderConfigurer): RestTemplateBuilder {
        return configurer.configure(RestTemplateBuilder()).setConnectTimeout(Duration.ofSeconds(5))
            .setReadTimeout(Duration.ofSeconds(2))
    }

}
</span></code></pre> </div> </div> <div class="paragraph"> <p>The most extreme (and rarely used) option is to create your own <code>RestTemplateBuilder</code> bean without using a configurer. In addition to replacing the auto-configured builder, this also prevents any <code>RestTemplateCustomizer</code> beans from being used.</p> </div> </div> <div class="sect3"> <h4 id="io.rest-client.resttemplate.ssl">
6.1.3. RestTemplate SSL Support</h4> <div class="paragraph"> <p>If you need custom SSL configuration on the <code>RestTemplate</code>, you can apply an <a href="features.html#features.ssl.bundles">SSL bundle</a> to the <code>RestTemplateBuilder</code> as shown in this example:</p> </div> <div class="listingblock primary"> <div class="title">Java</div> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import org.springframework.boot.docs.io.restclient.resttemplate.Details;
import org.springframework.boot.ssl.SslBundles;
import org.springframework.boot.web.client.RestTemplateBuilder;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

</span><span class="fold-block">@Service
public class MyService {

    private final RestTemplate restTemplate;

    public MyService(RestTemplateBuilder restTemplateBuilder, SslBundles sslBundles) {
        this.restTemplate = restTemplateBuilder.setSslBundle(sslBundles.getBundle("mybundle")).build();
    }

    public Details someRestCall(String name) {
        return this.restTemplate.getForObject("/{name}/details", Details.class, name);
    }

}
</span></code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Kotlin</div> <div class="content"> <pre class="highlight" data-language="kotlin"><code class="language-kotlin" data-lang="kotlin"><span class="fold-block hide-when-folded">import org.springframework.boot.docs.io.restclient.resttemplate.Details
import org.springframework.boot.ssl.SslBundles
import org.springframework.boot.web.client.RestTemplateBuilder
import org.springframework.stereotype.Service
import org.springframework.web.client.RestTemplate

</span><span class="fold-block">@Service
class MyService(restTemplateBuilder: RestTemplateBuilder, sslBundles: SslBundles) {

    private val restTemplate: RestTemplate

    init {
        restTemplate = restTemplateBuilder.setSslBundle(sslBundles.getBundle("mybundle")).build()
    }

    fun someRestCall(name: String): Details {
        return restTemplate.getForObject("/{name}/details", Details::class.java, name)!!
    }

}
</span></code></pre> </div> </div> </div> </div> <div class="sect2"> <h3 id="io.rest-client.webclient">
6.2. WebClient</h3> <div class="paragraph"> <p>If you have Spring WebFlux on your classpath, you can also choose to use <code>WebClient</code> to call remote REST services. Compared to <code>RestTemplate</code>, this client has a more functional feel and is fully reactive. You can learn more about the <code>WebClient</code> in the dedicated <a href="https://docs.spring.io/spring-framework/docs/6.0.11/reference/html/web-reactive.html#webflux-client">section in the Spring Framework docs</a>.</p> </div> <div class="paragraph"> <p>Spring Boot creates and pre-configures a <code>WebClient.Builder</code> for you. It is strongly advised to inject it in your components and use it to create <code>WebClient</code> instances. Spring Boot is configuring that builder to share HTTP resources, reflect codecs setup in the same fashion as the server ones (see <a href="web.html#web.reactive.webflux.httpcodecs">WebFlux HTTP codecs auto-configuration</a>), and more.</p> </div> <div class="paragraph"> <p>The following code shows a typical example:</p> </div> <div class="listingblock primary"> <div class="title">Java</div> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import reactor.core.publisher.Mono;

import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;

</span><span class="fold-block">@Service
public class MyService {

    private final WebClient webClient;

    public MyService(WebClient.Builder webClientBuilder) {
        this.webClient = webClientBuilder.baseUrl("https://example.org").build();
    }

    public Mono&lt;Details&gt; someRestCall(String name) {
        return this.webClient.get().uri("/{name}/details", name).retrieve().bodyToMono(Details.class);
    }

}
</span></code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Kotlin</div> <div class="content"> <pre class="highlight" data-language="kotlin"><code class="language-kotlin" data-lang="kotlin"><span class="fold-block hide-when-folded">import org.springframework.stereotype.Service
import org.springframework.web.reactive.function.client.WebClient
import reactor.core.publisher.Mono

</span><span class="fold-block">@Service
class MyService(webClientBuilder: WebClient.Builder) {

    private val webClient: WebClient

    init {
        webClient = webClientBuilder.baseUrl("https://example.org").build()
    }

    fun someRestCall(name: String?): Mono&lt;Details&gt; {
        return webClient.get().uri("/{name}/details", name)
                .retrieve().bodyToMono(Details::class.java)
    }

}
</span></code></pre> </div> </div> <div class="sect3"> <h4 id="io.rest-client.webclient.runtime">
6.2.1. WebClient Runtime</h4> <div class="paragraph"> <p>Spring Boot will auto-detect which <code>ClientHttpConnector</code> to use to drive <code>WebClient</code> depending on the libraries available on the application classpath. In order of preference, the following clients are supported:</p> </div> <div class="olist arabic"> <ol class="arabic"> <li> <p>Reactor Netty</p> </li> <li> <p>Jetty RS client</p> </li> <li> <p>Apache HttpClient</p> </li> <li> <p>JDK HttpClient</p> </li> </ol> </div> <div class="paragraph"> <p>If multiple clients are available on the classpath, the most preferred client will be used.</p> </div> <div class="paragraph"> <p>The <code>spring-boot-starter-webflux</code> starter depends on <code>io.projectreactor.netty:reactor-netty</code> by default, which brings both server and client implementations. If you choose to use Jetty as a reactive server instead, you should add a dependency on the Jetty Reactive HTTP client library, <code>org.eclipse.jetty:jetty-reactive-httpclient</code>. Using the same technology for server and client has its advantages, as it will automatically share HTTP resources between client and server.</p> </div> <div class="paragraph"> <p>Developers can override the resource configuration for Jetty and Reactor Netty by providing a custom <code>ReactorResourceFactory</code> or <code>JettyResourceFactory</code> bean - this will be applied to both clients and servers.</p> </div> <div class="paragraph"> <p>If you wish to override that choice for the client, you can define your own <code>ClientHttpConnector</code> bean and have full control over the client configuration.</p> </div> <div class="paragraph"> <p>You can learn more about the <a href="https://docs.spring.io/spring-framework/docs/6.0.11/reference/html/web-reactive.html#webflux-client-builder"><code>WebClient</code> configuration options in the Spring Framework reference documentation</a>.</p> </div> </div> <div class="sect3"> <h4 id="io.rest-client.webclient.customization">
6.2.2. WebClient Customization</h4> <div class="paragraph"> <p>There are three main approaches to <code>WebClient</code> customization, depending on how broadly you want the customizations to apply.</p> </div> <div class="paragraph"> <p>To make the scope of any customizations as narrow as possible, inject the auto-configured <code>WebClient.Builder</code> and then call its methods as required. <code>WebClient.Builder</code> instances are stateful: Any change on the builder is reflected in all clients subsequently created with it. If you want to create several clients with the same builder, you can also consider cloning the builder with <code>WebClient.Builder other = builder.clone();</code>.</p> </div> <div class="paragraph"> <p>To make an application-wide, additive customization to all <code>WebClient.Builder</code> instances, you can declare <code>WebClientCustomizer</code> beans and change the <code>WebClient.Builder</code> locally at the point of injection.</p> </div> <div class="paragraph"> <p>Finally, you can fall back to the original API and use <code>WebClient.create()</code>. In that case, no auto-configuration or <code>WebClientCustomizer</code> is applied.</p> </div> </div> <div class="sect3"> <h4 id="io.rest-client.webclient.ssl">
6.2.3. WebClient SSL Support</h4> <div class="paragraph"> <p>If you need custom SSL configuration on the <code>ClientHttpConnector</code> used by the <code>WebClient</code>, you can inject a <code>WebClientSsl</code> instance that can be used with the builder’s <code>apply</code> method.</p> </div> <div class="paragraph"> <p>The <code>WebClientSsl</code> interface provides access to any <a href="features.html#features.ssl.bundles">SSL bundles</a> that you have defined in your <code>application.properties</code> or <code>application.yaml</code> file.</p> </div> <div class="paragraph"> <p>The following code shows a typical example:</p> </div> <div class="listingblock primary"> <div class="title">Java</div> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import reactor.core.publisher.Mono;

import org.springframework.boot.autoconfigure.web.reactive.function.client.WebClientSsl;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;

</span><span class="fold-block">@Service
public class MyService {

    private final WebClient webClient;

    public MyService(WebClient.Builder webClientBuilder, WebClientSsl ssl) {
        this.webClient = webClientBuilder.baseUrl("https://example.org").apply(ssl.fromBundle("mybundle")).build();
    }

    public Mono&lt;Details&gt; someRestCall(String name) {
        return this.webClient.get().uri("/{name}/details", name).retrieve().bodyToMono(Details.class);
    }

}
</span></code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Kotlin</div> <div class="content"> <pre class="highlight" data-language="kotlin"><code class="language-kotlin" data-lang="kotlin"><span class="fold-block hide-when-folded">import org.springframework.boot.autoconfigure.web.reactive.function.client.WebClientSsl
import org.springframework.stereotype.Service
import org.springframework.web.reactive.function.client.WebClient
import reactor.core.publisher.Mono

</span><span class="fold-block">@Service
class MyService(webClientBuilder: WebClient.Builder, ssl: WebClientSsl) {

    private val webClient: WebClient

    init {
        webClient = webClientBuilder.baseUrl("https://example.org")
                .apply(ssl.fromBundle("mybundle")).build()
    }

    fun someRestCall(name: String?): Mono&lt;Details&gt; {
        return webClient.get().uri("/{name}/details", name)
                .retrieve().bodyToMono(Details::class.java)
    }

}
</span></code></pre> </div> </div> </div> </div> </div> </div> <div class="sect1"> <h2 id="io.webservices">
7. Web Services</h2> <div class="sectionbody"> <div class="paragraph"> <p>Spring Boot provides Web Services auto-configuration so that all you must do is define your <code>Endpoints</code>.</p> </div> <div class="paragraph"> <p>The <a href="https://docs.spring.io/spring-ws/docs/4.0.5/reference/html/">Spring Web Services features</a> can be easily accessed with the <code>spring-boot-starter-webservices</code> module.</p> </div> <div class="paragraph"> <p><code>SimpleWsdl11Definition</code> and <code>SimpleXsdSchema</code> beans can be automatically created for your WSDLs and XSDs respectively. To do so, configure their location, as shown in the following example:</p> </div> <div class="listingblock primary"> <div class="title">Properties</div> <div class="content"> <pre class="highlight" data-language="properties"><code class="language-properties" data-lang="properties">spring.webservices.wsdl-locations=classpath:/wsdl</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Yaml</div> <div class="content"> <pre class="highlight" data-language="yaml"><code class="language-yaml" data-lang="yaml">spring:
  webservices:
    wsdl-locations: "classpath:/wsdl"</code></pre> </div> </div> <div class="sect2"> <h3 id="io.webservices.template">
7.1. Calling Web Services with WebServiceTemplate</h3> <div class="paragraph"> <p>If you need to call remote Web services from your application, you can use the <a href="https://docs.spring.io/spring-ws/docs/4.0.5/reference/html/#client-web-service-template"><code>WebServiceTemplate</code></a> class. Since <code>WebServiceTemplate</code> instances often need to be customized before being used, Spring Boot does not provide any single auto-configured <code>WebServiceTemplate</code> bean. It does, however, auto-configure a <code>WebServiceTemplateBuilder</code>, which can be used to create <code>WebServiceTemplate</code> instances when needed.</p> </div> <div class="paragraph"> <p>The following code shows a typical example:</p> </div> <div class="listingblock primary"> <div class="title">Java</div> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import org.springframework.boot.webservices.client.WebServiceTemplateBuilder;
import org.springframework.stereotype.Service;
import org.springframework.ws.client.core.WebServiceTemplate;
import org.springframework.ws.soap.client.core.SoapActionCallback;

</span><span class="fold-block">@Service
public class MyService {

    private final WebServiceTemplate webServiceTemplate;

    public MyService(WebServiceTemplateBuilder webServiceTemplateBuilder) {
        this.webServiceTemplate = webServiceTemplateBuilder.build();
    }

    public SomeResponse someWsCall(SomeRequest detailsReq) {
        return (SomeResponse) this.webServiceTemplate.marshalSendAndReceive(detailsReq,
                new SoapActionCallback("https://ws.example.com/action"));
    }

}
</span></code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Kotlin</div> <div class="content"> <pre class="highlight" data-language="kotlin"><code class="language-kotlin" data-lang="kotlin"><span class="fold-block hide-when-folded">import org.springframework.boot.webservices.client.WebServiceTemplateBuilder
import org.springframework.stereotype.Service
import org.springframework.ws.client.core.WebServiceTemplate
import org.springframework.ws.soap.client.core.SoapActionCallback

</span><span class="fold-block">@Service
class MyService(webServiceTemplateBuilder: WebServiceTemplateBuilder) {

    private val webServiceTemplate: WebServiceTemplate

    init {
        webServiceTemplate = webServiceTemplateBuilder.build()
    }

    fun someWsCall(detailsReq: SomeRequest?): SomeResponse {
        return webServiceTemplate.marshalSendAndReceive(
            detailsReq,
            SoapActionCallback("https://ws.example.com/action")
        ) as SomeResponse
    }

}
</span></code></pre> </div> </div> <div class="paragraph"> <p>By default, <code>WebServiceTemplateBuilder</code> detects a suitable HTTP-based <code>WebServiceMessageSender</code> using the available HTTP client libraries on the classpath. You can also customize read and connection timeouts as follows:</p> </div> <div class="listingblock primary"> <div class="title">Java</div> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import java.time.Duration;

import org.springframework.boot.webservices.client.HttpWebServiceMessageSenderBuilder;
import org.springframework.boot.webservices.client.WebServiceTemplateBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.ws.client.core.WebServiceTemplate;
import org.springframework.ws.transport.WebServiceMessageSender;

</span><span class="fold-block">@Configuration(proxyBeanMethods = false)
public class MyWebServiceTemplateConfiguration {

    @Bean
    public WebServiceTemplate webServiceTemplate(WebServiceTemplateBuilder builder) {
        WebServiceMessageSender sender = new HttpWebServiceMessageSenderBuilder()
                .setConnectTimeout(Duration.ofSeconds(5))
                .setReadTimeout(Duration.ofSeconds(2))
                .build();
        return builder.messageSenders(sender).build();
    }

}
</span></code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Kotlin</div> <div class="content"> <pre class="highlight" data-language="kotlin"><code class="language-kotlin" data-lang="kotlin"><span class="fold-block hide-when-folded">import org.springframework.boot.webservices.client.HttpWebServiceMessageSenderBuilder
import org.springframework.boot.webservices.client.WebServiceTemplateBuilder
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.ws.client.core.WebServiceTemplate
import java.time.Duration

</span><span class="fold-block">@Configuration(proxyBeanMethods = false)
class MyWebServiceTemplateConfiguration {

    @Bean
    fun webServiceTemplate(builder: WebServiceTemplateBuilder): WebServiceTemplate {
        val sender = HttpWebServiceMessageSenderBuilder()
            .setConnectTimeout(Duration.ofSeconds(5))
            .setReadTimeout(Duration.ofSeconds(2))
            .build()
        return builder.messageSenders(sender).build()
    }

}
</span></code></pre> </div> </div> </div> </div> </div> <div class="sect1"> <h2 id="io.jta">
8. Distributed Transactions With JTA</h2> <div class="sectionbody"> <div class="paragraph"> <p>Spring Boot supports distributed JTA transactions across multiple XA resources by using a transaction manager retrieved from JNDI.</p> </div> <div class="paragraph"> <p>When a JTA environment is detected, Spring’s <code>JtaTransactionManager</code> is used to manage transactions. Auto-configured JMS, DataSource, and JPA beans are upgraded to support XA transactions. You can use standard Spring idioms, such as <code>@Transactional</code>, to participate in a distributed transaction. If you are within a JTA environment and still want to use local transactions, you can set the <code>spring.jta.enabled</code> property to <code>false</code> to disable the JTA auto-configuration.</p> </div> <div class="sect2"> <h3 id="io.jta.jakartaee">
8.1. Using a Jakarta EE Managed Transaction Manager</h3> <div class="paragraph"> <p>If you package your Spring Boot application as a <code>war</code> or <code>ear</code> file and deploy it to a Jakarta EE application server, you can use your application server’s built-in transaction manager. Spring Boot tries to auto-configure a transaction manager by looking at common JNDI locations (<code>java:comp/UserTransaction</code>, <code>java:comp/TransactionManager</code>, and so on). When using a transaction service provided by your application server, you generally also want to ensure that all resources are managed by the server and exposed over JNDI. Spring Boot tries to auto-configure JMS by looking for a <code>ConnectionFactory</code> at the JNDI path (<code>java:/JmsXA</code> or <code>java:/XAConnectionFactory</code>), and you can use the <a href="data.html#data.sql.datasource.jndi"><code>spring.datasource.jndi-name</code> property</a> to configure your <code>DataSource</code>.</p> </div> </div> <div class="sect2"> <h3 id="io.jta.mixing-xa-and-non-xa-connections">
8.2. Mixing XA and Non-XA JMS Connections</h3> <div class="paragraph"> <p>When using JTA, the primary JMS <code>ConnectionFactory</code> bean is XA-aware and participates in distributed transactions. You can inject into your bean without needing to use any <code>@Qualifier</code>:</p> </div> <div class="listingblock primary"> <div class="title">Java</div> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java">public MyBean(ConnectionFactory connectionFactory) {
    // ...
}
</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Kotlin</div>  </div> <div class="paragraph"> <p>In some situations, you might want to process certain JMS messages by using a non-XA <code>ConnectionFactory</code>. For example, your JMS processing logic might take longer than the XA timeout.</p> </div> <div class="paragraph"> <p>If you want to use a non-XA <code>ConnectionFactory</code>, you can the <code>nonXaJmsConnectionFactory</code> bean:</p> </div> <div class="listingblock primary"> <div class="title">Java</div> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java">public MyBean(@Qualifier("nonXaJmsConnectionFactory") ConnectionFactory connectionFactory) {
    // ...
}
</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Kotlin</div>  </div> <div class="paragraph"> <p>For consistency, the <code>jmsConnectionFactory</code> bean is also provided by using the bean alias <code>xaJmsConnectionFactory</code>:</p> </div> <div class="listingblock primary"> <div class="title">Java</div> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java">public MyBean(@Qualifier("xaJmsConnectionFactory") ConnectionFactory connectionFactory) {
    // ...
}
</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Kotlin</div>  </div> </div> <div class="sect2"> <h3 id="io.jta.supporting-embedded-transaction-manager">
8.3. Supporting an Embedded Transaction Manager</h3> <div class="paragraph"> <p>The <a href="https://github.com/spring-projects/spring-boot/tree/v3.1.3/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jms/XAConnectionFactoryWrapper.java"><code>XAConnectionFactoryWrapper</code></a> and <a href="https://github.com/spring-projects/spring-boot/tree/v3.1.3/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jdbc/XADataSourceWrapper.java"><code>XADataSourceWrapper</code></a> interfaces can be used to support embedded transaction managers. The interfaces are responsible for wrapping <code>XAConnectionFactory</code> and <code>XADataSource</code> beans and exposing them as regular <code>ConnectionFactory</code> and <code>DataSource</code> beans, which transparently enroll in the distributed transaction. DataSource and JMS auto-configuration use JTA variants, provided you have a <code>JtaTransactionManager</code> bean and appropriate XA wrapper beans registered within your <code>ApplicationContext</code>.</p> </div> </div> </div> </div> <div class="sect1"> <h2 id="io.whats-next">
9. What to Read Next</h2> <div class="sectionbody"> <div class="paragraph"> <p>You should now have a good understanding of Spring Boot’s <a href="features.html#features">core features</a> and the various technologies that Spring Boot provides support for through auto-configuration.</p> </div> <div class="paragraph"> <p>The next few sections go into detail about deploying applications to cloud platforms. You can read about <a href="container-images.html#container-images">building container images</a> in the next section or skip to the <a href="actuator.html#actuator">production-ready features</a> section.</p> </div> </div> </div><div class="_attribution">
  <p class="_attribution-p">
    Copyright &copy; 2012-2023 VMware, Inc.<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://docs.spring.io/spring-boot/docs/3.1.3/reference/html/io.html" class="_attribution-link">https://docs.spring.io/spring-boot/docs/3.1.3/reference/html/io.html</a>
  </p>
</div>
