<h1>GraalVM Native Image Support</h1> <div id="preamble"> <div class="sectionbody"> <div class="paragraph"> <p><a href="https://www.graalvm.org/native-image/">GraalVM Native Images</a> are standalone executables that can be generated by processing compiled Java applications ahead-of-time. Native Images generally have a smaller memory footprint and start faster than their JVM counterparts.</p> </div> </div> </div> <div class="sect1"> <h2 id="native-image.introducing-graalvm-native-images">
1. Introducing GraalVM Native Images</h2> <div class="sectionbody"> <div class="paragraph"> <p>GraalVM Native Images provide a new way to deploy and run Java applications. Compared to the Java Virtual Machine, native images can run with a smaller memory footprint and with much faster startup times.</p> </div> <div class="paragraph"> <p>They are well suited to applications that are deployed using container images and are especially interesting when combined with "Function as a service" (FaaS) platforms.</p> </div> <div class="paragraph"> <p>Unlike traditional applications written for the JVM, GraalVM Native Image applications require ahead-of-time processing in order to create an executable. This ahead-of-time processing involves statically analyzing your application code from its main entry point.</p> </div> <div class="paragraph"> <p>A GraalVM Native Image is a complete, platform-specific executable. You do not need to ship a Java Virtual Machine in order to run a native image.</p> </div> <div class="admonitionblock tip"> <table> <tr> <td class="icon">  </td> <td class="content"> If you just want to get started and experiment with GraalVM you can skip ahead to the “<a href="#native-image.developing-your-first-application">Developing Your First GraalVM Native Application</a>” section and return to this section later. </td> </tr> </table> </div> <div class="sect2"> <h3 id="native-image.introducing-graalvm-native-images.key-differences-with-jvm-deployments">
1.1. Key Differences with JVM Deployments</h3> <div class="paragraph"> <p>The fact that GraalVM Native Images are produced ahead-of-time means that there are some key differences between native and JVM based applications. The main differences are:</p> </div> <div class="ulist"> <ul> <li> <p>Static analysis of your application is performed at build-time from the <code>main</code> entry point.</p> </li> <li> <p>Code that cannot be reached when the native image is created will be removed and won’t be part of the executable.</p> </li> <li> <p>GraalVM is not directly aware of dynamic elements of your code and must be told about reflection, resources, serialization, and dynamic proxies.</p> </li> <li> <p>The application classpath is fixed at build time and cannot change.</p> </li> <li> <p>There is no lazy class loading, everything shipped in the executables will be loaded in memory on startup.</p> </li> <li> <p>There are some limitations around some aspects of Java applications that are not fully supported.</p> </li> </ul> </div> <div class="admonitionblock tip"> <table> <tr> <td class="icon">  </td> <td class="content"> The <a href="https://www.graalvm.org/22.3/reference-manual/native-image/metadata/Compatibility/">Native Image Compatibility Guide</a> section of the GraalVM reference documentation provides more details about GraalVM limitations. </td> </tr> </table> </div> </div> <div class="sect2"> <h3 id="native-image.introducing-graalvm-native-images.understanding-aot-processing">
1.2. Understanding Spring Ahead-of-Time Processing</h3> <div class="paragraph"> <p>Typical Spring Boot applications are quite dynamic and configuration is performed at runtime. In fact, the concept of Spring Boot auto-configuration depends heavily on reacting to the state of the runtime in order to configure things correctly.</p> </div> <div class="paragraph"> <p>Although it would be possible to tell GraalVM about these dynamic aspects of the application, doing so would undo most of the benefit of static analysis. So instead, when using Spring Boot to create native images, a closed-world is assumed and the dynamic aspects of the application are restricted.</p> </div> <div class="paragraph"> <p>A closed-world assumption implies the following restrictions:</p> </div> <div class="ulist"> <ul> <li> <p>The classpath is fixed and fully defined at build time</p> </li> <li> <p>The beans defined in your application cannot change at runtime, meaning:</p> <div class="ulist"> <ul> <li> <p>The Spring <code>@Profile</code> annotation and profile-specific configuration <a href="howto.html#howto.aot.conditions">have limitations</a>.</p> </li> <li> <p>Properties that change if a bean is created are not supported (for example, <code>@ConditionalOnProperty</code> and <code>.enable</code> properties).</p> </li> </ul> </div> </li> </ul> </div> <div class="paragraph"> <p>When these restrictions are in place, it becomes possible for Spring to perform ahead-of-time processing during build-time and generate additional assets that GraalVM can use. A Spring AOT processed application will typically generate:</p> </div> <div class="ulist"> <ul> <li> <p>Java source code</p> </li> <li> <p>Bytecode (for dynamic proxies etc)</p> </li> <li> <p>GraalVM JSON hint files:</p> <div class="ulist"> <ul> <li> <p>Resource hints (<code>resource-config.json</code>)</p> </li> <li> <p>Reflection hints (<code>reflect-config.json</code>)</p> </li> <li> <p>Serialization hints (<code>serialization-config.json</code>)</p> </li> <li> <p>Java Proxy Hints (<code>proxy-config.json</code>)</p> </li> <li> <p>JNI Hints (<code>jni-config.json</code>)</p> </li> </ul> </div> </li> </ul> </div> <div class="sect3"> <h4 id="native-image.introducing-graalvm-native-images.understanding-aot-processing.source-code-generation">
1.2.1. Source Code Generation</h4> <div class="paragraph"> <p>Spring applications are composed of Spring Beans. Internally, Spring Framework uses two distinct concepts to manage beans. There are bean instances, which are the actual instances that have been created and can be injected into other beans. There are also bean definitions which are used to define attributes of a bean and how its instance should be created.</p> </div> <div class="paragraph"> <p>If we take a typical <code>@Configuration</code> class:</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

</span><span class="fold-block">@Configuration(proxyBeanMethods = false)
public class MyConfiguration {

    @Bean
    public MyBean myBean() {
        return new MyBean();
    }

}
</span></code></pre> </div> </div> <div class="paragraph"> <p>The bean definition is created by parsing the <code>@Configuration</code> class and finding the <code>@Bean</code> methods. In the above example, we’re defining a <code>BeanDefinition</code> for a singleton bean named <code>myBean</code>. We’re also creating a <code>BeanDefinition</code> for the <code>MyConfiguration</code> class itself.</p> </div> <div class="paragraph"> <p>When the <code>myBean</code> instance is required, Spring knows that it must invoke the <code>myBean()</code> method and use the result. When running on the JVM, <code>@Configuration</code> class parsing happens when your application starts and <code>@Bean</code> methods are invoked using reflection.</p> </div> <div class="paragraph"> <p>When creating a native image, Spring operates in a different way. Rather than parsing <code>@Configuration</code> classes and generating bean definitions at runtime, it does it at build-time. Once the bean definitions have been discovered, they are processed and converted into source code that can be analyzed by the GraalVM compiler.</p> </div> <div class="paragraph"> <p>The Spring AOT process would convert the configuration class above to code like this:</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import org.springframework.beans.factory.aot.BeanInstanceSupplier;
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.beans.factory.support.RootBeanDefinition;

</span><span class="fold-block">/**
 * Bean definitions for {@link MyConfiguration}.
 */
public class MyConfiguration__BeanDefinitions {

    /**
     * Get the bean definition for 'myConfiguration'.
     */
    public static BeanDefinition getMyConfigurationBeanDefinition() {
        Class&lt;?&gt; beanType = MyConfiguration.class;
        RootBeanDefinition beanDefinition = new RootBeanDefinition(beanType);
        beanDefinition.setInstanceSupplier(MyConfiguration::new);
        return beanDefinition;
    }

    /**
     * Get the bean instance supplier for 'myBean'.
     */
    private static BeanInstanceSupplier&lt;MyBean&gt; getMyBeanInstanceSupplier() {
        return BeanInstanceSupplier.&lt;MyBean&gt;forFactoryMethod(MyConfiguration.class, "myBean")
            .withGenerator((registeredBean) -&gt; registeredBean.getBeanFactory().getBean(MyConfiguration.class).myBean());
    }

    /**
     * Get the bean definition for 'myBean'.
     */
    public static BeanDefinition getMyBeanBeanDefinition() {
        Class&lt;?&gt; beanType = MyBean.class;
        RootBeanDefinition beanDefinition = new RootBeanDefinition(beanType);
        beanDefinition.setInstanceSupplier(getMyBeanInstanceSupplier());
        return beanDefinition;
    }

}
</span></code></pre> </div> </div> <div class="admonitionblock note"> <table> <tr> <td class="icon">  </td> <td class="content"> The exact code generated may differ depending on the nature of your bean definitions. </td> </tr> </table> </div> <div class="paragraph"> <p>You can see above that the generated code creates equivalent bean definitions to the <code>@Configuration</code> class, but in a direct way that can be understood by GraalVM.</p> </div> <div class="paragraph"> <p>There is a bean definition for the <code>myConfiguration</code> bean, and one for <code>myBean</code>. When a <code>myBean</code> instance is required, a <code>BeanInstanceSupplier</code> is called. This supplier will invoke the <code>myBean()</code> method on the <code>myConfiguration</code> bean.</p> </div> <div class="admonitionblock note"> <table> <tr> <td class="icon">  </td> <td class="content"> During Spring AOT processing your application is started up to the point that bean definitions are available. Bean instances are not created during the AOT processing phase. </td> </tr> </table> </div> <div class="paragraph"> <p>Spring AOT will generate code like this for all your bean definitions. It will also generate code when bean post-processing is required (for example, to call <code>@Autowired</code> methods). An <code>ApplicationContextInitializer</code> will also be generated which will be used by Spring Boot to initialize the <code>ApplicationContext</code> when an AOT processed application is actually run.</p> </div> <div class="admonitionblock tip"> <table> <tr> <td class="icon">  </td> <td class="content"> Although AOT generated source code can be verbose, it is quite readable and can be helpful when debugging an application. Generated source files can be found in <code>target/spring-aot/main/sources</code> when using Maven and <code>build/generated/aotSources</code> with Gradle. </td> </tr> </table> </div> </div> <div class="sect3"> <h4 id="native-image.introducing-graalvm-native-images.understanding-aot-processing.hint-file-generation">
1.2.2. Hint File Generation</h4> <div class="paragraph"> <p>In addition to generating source files, the Spring AOT engine will also generate hint files that are used by GraalVM. Hint files contain JSON data that describes how GraalVM should deal with things that it can’t understand by directly inspecting the code.</p> </div> <div class="paragraph"> <p>For example, you might be using a Spring annotation on a private method. Spring will need to use reflection in order to invoke private methods, even on GraalVM. When such situations arise, Spring can write a reflection hint so that GraalVM knows that even though the private method isn’t called directly, it still needs to be available in the native image.</p> </div> <div class="paragraph"> <p>Hint files are generated under <code>META-INF/native-image</code> where they are automatically picked up by GraalVM.</p> </div> <div class="admonitionblock tip"> <table> <tr> <td class="icon">  </td> <td class="content"> Generated hint files can be found in <code>target/spring-aot/main/resources</code> when using Maven and <code>build/generated/aotResources</code> with Gradle. </td> </tr> </table> </div> </div> <div class="sect3"> <h4 id="native-image.introducing-graalvm-native-images.understanding-aot-processing.proxy-class-generation">
1.2.3. Proxy Class Generation</h4> <div class="paragraph"> <p>Spring sometimes needs to generate proxy classes to enhance the code you’ve written with additional features. To do this, it uses the cglib library which directly generates bytecode.</p> </div> <div class="paragraph"> <p>When an application is running on the JVM, proxy classes are generated dynamically as the application runs. When creating a native image, these proxies need to be created at build-time so that they can be included by GraalVM.</p> </div> <div class="admonitionblock note"> <table> <tr> <td class="icon">  </td> <td class="content"> Unlike source code generation, generated bytecode isn’t particularly helpful when debugging an application. However, if you need to inspect the contents of the <code>.class</code> files using a tool such as <code>javap</code> you can find them in <code>target/spring-aot/main/classes</code> for Maven and <code>build/generated/aotClasses</code> for Gradle. </td> </tr> </table> </div> </div> </div> </div> </div> <div class="sect1"> <h2 id="native-image.developing-your-first-application">
2. Developing Your First GraalVM Native Application</h2> <div class="sectionbody"> <div class="paragraph"> <p>Now that we have a good overview of GraalVM Native Images and how the Spring ahead-of-time engine works, we can look at how to create an application.</p> </div> <div class="paragraph"> <p>There are two main ways to build a Spring Boot native image application:</p> </div> <div class="ulist"> <ul> <li> <p>Using Spring Boot support for Cloud Native Buildpacks to generate a lightweight container containing a native executable.</p> </li> <li> <p>Using GraalVM Native Build Tools to generate a native executable.</p> </li> </ul> </div> <div class="admonitionblock tip"> <table> <tr> <td class="icon">  </td> <td class="content"> The easiest way to start a new native Spring Boot project is to go to <a href="https://start.spring.io">start.spring.io</a>, add the “GraalVM Native Support” dependency and generate the project. The included <code>HELP.md</code> file will provide getting started hints. </td> </tr> </table> </div> <div class="sect2"> <h3 id="native-image.developing-your-first-application.sample-application">
2.1. Sample Application</h3> <div class="paragraph"> <p>We need an example application that we can use to create our native image. For our purposes, the simple “Hello World!” web application that’s covered in the “<a href="getting-started.html#getting-started.first-application">getting-started.html</a>” section will suffice.</p> </div> <div class="paragraph"> <p>To recap, our main application code looks like this:</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

</span><span class="fold-block">@RestController
@SpringBootApplication
public class MyApplication {

    @RequestMapping("/")
    String home() {
        return "Hello World!";
    }

    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }

}
</span></code></pre> </div> </div> <div class="paragraph"> <p>This application uses Spring MVC and embedded Tomcat, both of which have been tested and verified to work with GraalVM native images.</p> </div> </div> <div class="sect2"> <h3 id="native-image.developing-your-first-application.buildpacks">
2.2. Building a Native Image Using Buildpacks</h3> <div class="paragraph"> <p>Spring Boot includes buildpack support for native images directly for both Maven and Gradle. This means you can just type a single command and quickly get a sensible image into your locally running Docker daemon. The resulting image doesn’t contain a JVM, instead the native image is compiled statically. This leads to smaller images.</p> </div> <div class="admonitionblock note"> <table> <tr> <td class="icon">  </td> <td class="content"> The builder used for the images is <code>paketobuildpacks/builder:tiny</code>. It has small footprint and reduced attack surface, but you can also use <code>paketobuildpacks/builder-jammy-base</code> or <code>paketobuildpacks/builder-jammy-full</code> to have more tools available in the image if required. </td> </tr> </table> </div> <div class="sect3"> <h4 id="native-image.developing-your-first-application.buildpacks.system-requirements">
2.2.1. System Requirements</h4> <div class="paragraph"> <p>Docker should be installed. See <a href="https://docs.docker.com/installation/#installation">Get Docker</a> for more details. <a href="https://docs.docker.com/engine/install/linux-postinstall/#manage-docker-as-a-non-root-user">Configure it to allow non-root user</a> if you are on Linux.</p> </div> <div class="admonitionblock note"> <table> <tr> <td class="icon">  </td> <td class="content"> You can run <code>docker run hello-world</code> (without <code>sudo</code>) to check the Docker daemon is reachable as expected. Check the <a href="https://docs.spring.io/spring-boot/docs/3.1.3/maven-plugin/reference/htmlsingle//#build-image-docker-daemon">Maven</a> or <a href="https://docs.spring.io/spring-boot/docs/3.1.3/gradle-plugin/reference/htmlsingle//#build-image-docker-daemon">Gradle</a> Spring Boot plugin documentation for more details. </td> </tr> </table> </div> <div class="admonitionblock tip"> <table> <tr> <td class="icon">  </td> <td class="content"> On macOS, it is recommended to increase the memory allocated to Docker to at least <code>8GB</code>, and potentially add more CPUs as well. See this <a href="https://stackoverflow.com/questions/44533319/how-to-assign-more-memory-to-docker-container/44533437#44533437">Stack Overflow answer</a> for more details. On Microsoft Windows, make sure to enable the <a href="https://docs.docker.com/docker-for-windows/wsl/">Docker WSL 2 backend</a> for better performance. </td> </tr> </table> </div> </div> <div class="sect3"> <h4 id="native-image.developing-your-first-application.buildpacks.maven">
2.2.2. Using Maven</h4> <div class="paragraph"> <p>To build a native image container using Maven you should ensure that your <code>pom.xml</code> file uses the <code>spring-boot-starter-parent</code> and the <code>org.graalvm.buildtools:native-maven-plugin</code>. You should have a <code>&lt;parent&gt;</code> section that looks like this:</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlight" data-language="xml"><code class="language-xml" data-lang="xml">&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;3.1.3&lt;/version&gt;
&lt;/parent&gt;</code></pre> </div> </div> <div class="paragraph"> <p>You additionally should have this in the <code>&lt;build&gt; &lt;plugins&gt;</code> section:</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlight" data-language="xml"><code class="language-xml" data-lang="xml">&lt;plugin&gt;
    &lt;groupId&gt;org.graalvm.buildtools&lt;/groupId&gt;
    &lt;artifactId&gt;native-maven-plugin&lt;/artifactId&gt;
&lt;/plugin&gt;</code></pre> </div> </div> <div class="paragraph"> <p>The <code>spring-boot-starter-parent</code> declares a <code>native</code> profile that configures the executions that need to run in order to create a native image. You can activate profiles using the <code>-P</code> flag on the command line.</p> </div> <div class="admonitionblock tip"> <table> <tr> <td class="icon">  </td> <td class="content"> If you don’t want to use <code>spring-boot-starter-parent</code> you’ll need to configure executions for the <code>process-aot</code> goal from Spring Boot’s plugin and the <code>add-reachability-metadata</code> goal from the Native Build Tools plugin. </td> </tr> </table> </div> <div class="paragraph"> <p>To build the image, you can run the <code>spring-boot:build-image</code> goal with the <code>native</code> profile active:</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlight" data-language="shell"><code class="language-shell" data-lang="shell">$ mvn -Pnative spring-boot:build-image</code></pre> </div> </div> </div> <div class="sect3"> <h4 id="native-image.developing-your-first-application.buildpacks.gradle">
2.2.3. Using Gradle</h4> <div class="paragraph"> <p>The Spring Boot Gradle plugin automatically configures AOT tasks when the GraalVM Native Image plugin is applied. You should check that your Gradle build contains a <code>plugins</code> block that includes <code>org.graalvm.buildtools.native</code>.</p> </div> <div class="paragraph"> <p>As long as the <code>org.graalvm.buildtools.native</code> plugin is applied, the <code>bootBuildImage</code> task will generate a native image rather than a JVM one. You can run the task using:</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlight" data-language="shell"><code class="language-shell" data-lang="shell">$ gradle bootBuildImage</code></pre> </div> </div> </div> <div class="sect3"> <h4 id="native-image.developing-your-first-application.buildpacks.running">
2.2.4. Running the example</h4> <div class="paragraph"> <p>Once you have run the appropriate build command, a Docker image should be available. You can start your application using <code>docker run</code>:</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlight" data-language="shell"><code class="language-shell" data-lang="shell">$ docker run --rm -p 8080:8080 docker.io/library/myproject:0.0.1-SNAPSHOT</code></pre> </div> </div> <div class="paragraph"> <p>You should see output similar to the following:</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlight" data-language="shell"><code class="language-shell" data-lang="shell">  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::  (v3.1.3)
....... . . .
....... . . . (log output here)
....... . . .
........ Started MyApplication in 0.08 seconds (process running for 0.095)</code></pre> </div> </div> <div class="admonitionblock note"> <table> <tr> <td class="icon">  </td> <td class="content"> The startup time differs from machine to machine, but it should be much faster than a Spring Boot application running on a JVM. </td> </tr> </table> </div> <div class="paragraph"> <p>If you open a web browser to <code><a href="http://localhost:8080" class="bare">localhost:8080</a></code>, you should see the following output:</p> </div> <div class="listingblock"> <div class="content"> <pre data-language="">Hello World!</pre> </div> </div> <div class="paragraph"> <p>To gracefully exit the application, press <code>ctrl-c</code>.</p> </div> </div> </div> <div class="sect2"> <h3 id="native-image.developing-your-first-application.native-build-tools">
2.3. Building a Native Image using Native Build Tools</h3> <div class="paragraph"> <p>If you want to generate a native executable directly without using Docker, you can use GraalVM Native Build Tools. Native Build Tools are plugins shipped by GraalVM for both Maven and Gradle. You can use them to perform a variety of GraalVM tasks, including generating a native image.</p> </div> <div class="sect3"> <h4 id="native-image.developing-your-first-application.native-build-tools.prerequisites">
2.3.1. Prerequisites</h4> <div class="paragraph"> <p>To build a native image using the Native Build Tools, you’ll need a GraalVM distribution on your machine. You can either download it manually on the <a href="https://bell-sw.com/pages/downloads/native-image-kit/#/nik-22-17">Liberica Native Image Kit page</a>, or you can use a download manager like SDKMAN!.</p> </div> <div class="sect4"> <h5 id="native-image.developing-your-first-application.native-build-tools.prerequisites.linux-macos">
Linux and macOS</h5> <div class="paragraph"> <p>To install the native image compiler on macOS or Linux, we recommend using SDKMAN!. Get SDKMAN! from <a href="https://sdkman.io" class="bare">sdkman.io</a> and install the Liberica GraalVM distribution by using the following commands:</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlight" data-language="shell"><code class="language-shell" data-lang="shell">$ sdk install java 22.3.r17-nik
$ sdk use java 22.3.r17-nik</code></pre> </div> </div> <div class="paragraph"> <p>Verify that the correct version has been configured by checking the output of <code>java -version</code>:</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlight" data-language="shell"><code class="language-shell" data-lang="shell">$ java -version
openjdk version "17.0.5" 2022-10-18 LTS
OpenJDK Runtime Environment GraalVM 22.3.0 (build 17.0.5+8-LTS)
OpenJDK 64-Bit Server VM GraalVM 22.3.0 (build 17.0.5+8-LTS, mixed mode)</code></pre> </div> </div> </div> <div class="sect4"> <h5 id="native-image.developing-your-first-application.native-build-tools.prerequisites.windows">
Windows</h5> <div class="paragraph"> <p>On Windows, follow <a href="https://medium.com/graalvm/using-graalvm-and-native-image-on-windows-10-9954dc071311">these instructions</a> to install either <a href="https://www.graalvm.org/downloads/">GraalVM</a> or <a href="https://bell-sw.com/pages/downloads/native-image-kit/#/nik-22-17">Liberica Native Image Kit</a> in version 22.3, the Visual Studio Build Tools and the Windows SDK. Due to the <a href="https://docs.microsoft.com/en-US/troubleshoot/windows-client/shell-experience/command-line-string-limitation">Windows related command-line maximum length</a>, make sure to use x64 Native Tools Command Prompt instead of the regular Windows command line to run Maven or Gradle plugins.</p> </div> </div> </div> <div class="sect3"> <h4 id="native-image.developing-your-first-application.native-build-tools.maven">
2.3.2. Using Maven</h4> <div class="paragraph"> <p>As with the <a href="#native-image.developing-your-first-application.buildpacks.maven">buildpack support</a>, you need to make sure that you’re using <code>spring-boot-starter-parent</code> in order to inherit the <code>native</code> profile and that the <code>org.graalvm.buildtools:native-maven-plugin</code> plugin is used.</p> </div> <div class="paragraph"> <p>With the <code>native</code> profile active, you can invoke the <code>native:compile</code> goal to trigger <code>native-image</code> compilation:</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlight" data-language="shell"><code class="language-shell" data-lang="shell">$ mvn -Pnative native:compile</code></pre> </div> </div> <div class="paragraph"> <p>The native image executable can be found in the <code>target</code> directory.</p> </div> </div> <div class="sect3"> <h4 id="native-image.developing-your-first-application.native-build-tools.gradle">
2.3.3. Using Gradle</h4> <div class="paragraph"> <p>When the Native Build Tools Gradle plugin is applied to your project, the Spring Boot Gradle plugin will automatically trigger the Spring AOT engine. Task dependencies are automatically configured, so you can just run the standard <code>nativeCompile</code> task to generate a native image:</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlight" data-language="shell"><code class="language-shell" data-lang="shell">$ gradle nativeCompile</code></pre> </div> </div> <div class="paragraph"> <p>The native image executable can be found in the <code>build/native/nativeCompile</code> directory.</p> </div> </div> <div class="sect3"> <h4 id="native-image.developing-your-first-application.native-build-tools.running">
2.3.4. Running the Example</h4> <div class="paragraph"> <p>At this point, your application should work. You can now start the application by running it directly:</p> </div> <div class="listingblock primary"> <div class="title">Maven</div> <div class="content"> <pre class="highlight" data-language="shell"><code class="language-shell" data-lang="shell">$ target/myproject</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Gradle</div> <div class="content"> <pre class="highlight" data-language="shell"><code class="language-shell" data-lang="shell">$ build/native/nativeCompile/myproject</code></pre> </div> </div> <div class="paragraph"> <p>You should see output similar to the following:</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlight" data-language="shell"><code class="language-shell" data-lang="shell">  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::  (v3.1.3)
....... . . .
....... . . . (log output here)
....... . . .
........ Started MyApplication in 0.08 seconds (process running for 0.095)</code></pre> </div> </div> <div class="admonitionblock note"> <table> <tr> <td class="icon">  </td> <td class="content"> The startup time differs from machine to machine, but it should be much faster than a Spring Boot application running on a JVM. </td> </tr> </table> </div> <div class="paragraph"> <p>If you open a web browser to <code><a href="http://localhost:8080" class="bare">localhost:8080</a></code>, you should see the following output:</p> </div> <div class="listingblock"> <div class="content"> <pre data-language="">Hello World!</pre> </div> </div> <div class="paragraph"> <p>To gracefully exit the application, press <code>ctrl-c</code>.</p> </div> </div> </div> </div> </div> <div class="sect1"> <h2 id="native-image.testing">
3. Testing GraalVM Native Images</h2> <div class="sectionbody"> <div class="paragraph"> <p>When writing native image applications, we recommend that you continue to use the JVM whenever possible to develop the majority of your unit and integration tests. This will help keep developer build times down and allow you to use existing IDE integrations. With broad test coverage on the JVM, you can then focus native image testing on the areas that are likely to be different.</p> </div> <div class="paragraph"> <p>For native image testing, you’re generally looking to ensure that the following aspects work:</p> </div> <div class="ulist"> <ul> <li> <p>The Spring AOT engine is able to process your application, and it will run in an AOT-processed mode.</p> </li> <li> <p>GraalVM has enough hints to ensure that a valid native image can be produced.</p> </li> </ul> </div> <div class="sect2"> <h3 id="native-image.testing.with-the-jvm">
3.1. Testing Ahead-of-time Processing With the JVM</h3> <div class="paragraph"> <p>When a Spring Boot application runs, it attempts to detect if it is running as a native image. If it is running as a native image, it will initialize the application using the code that was generated during at build-time by the Spring AOT engine.</p> </div> <div class="paragraph"> <p>If the application is running on a regular JVM, then any AOT generated code is ignored.</p> </div> <div class="paragraph"> <p>Since the <code>native-image</code> compilation phase can take a while to complete, it’s sometimes useful to run your application on the JVM but have it use the AOT generated initialization code. Doing so helps you to quickly validate that there are no errors in the AOT generated code and nothing is missing when your application is eventually converted to a native image.</p> </div> <div class="paragraph"> <p>To run a Spring Boot application on the JVM and have it use AOT generated code you can set the <code>spring.aot.enabled</code> system property to <code>true</code>.</p> </div> <div class="paragraph"> <p>For example:</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlight" data-language="shell"><code class="language-shell" data-lang="shell">$ java -Dspring.aot.enabled=true -jar myapplication.jar</code></pre> </div> </div> <div class="admonitionblock note"> <table> <tr> <td class="icon">  </td> <td class="content"> You need to ensure that the jar you are testing includes AOT generated code. For Maven, this means that you should build with <code>-Pnative</code> to activate the <code>native</code> profile. For Gradle, you need to ensure that your build includes the <code>org.graalvm.buildtools.native</code> plugin. </td> </tr> </table> </div> <div class="paragraph"> <p>If your application starts with the <code>spring.aot.enabled</code> property set to <code>true</code>, then you have higher confidence that it will work when converted to a native image.</p> </div> <div class="paragraph"> <p>You can also consider running integration tests against the running application. For example, you could use the Spring <code>WebClient</code> to call your application REST endpoints. Or you might consider using a project like Selenium to check your application’s HTML responses.</p> </div> </div> <div class="sect2"> <h3 id="native-image.testing.with-native-build-tools">
3.2. Testing With Native Build Tools</h3> <div class="paragraph"> <p>GraalVM Native Build Tools includes the ability to run tests inside a native image. This can be helpful when you want to deeply test that the internals of your application work in a GraalVM native image.</p> </div> <div class="paragraph"> <p>Generating the native image that contains the tests to run can be a time-consuming operation, so most developers will probably prefer to use the JVM locally. They can, however, be very useful as part of a CI pipeline. For example, you might choose to run native tests once a day.</p> </div> <div class="paragraph"> <p>Spring Framework includes ahead-of-time support for running tests. All the usual Spring testing features work with native image tests. For example, you can continue to use the <code>@SpringBootTest</code> annotation. You can also use Spring Boot <a href="features.html#features.testing.spring-boot-applications.autoconfigured-tests">test slices</a> to test only specific parts of your application.</p> </div> <div class="paragraph"> <p>Spring Framework’s native testing support works in the following way:</p> </div> <div class="ulist"> <ul> <li> <p>Tests are analyzed in order to discover any <code>ApplicationContext</code> instances that will be required.</p> </li> <li> <p>Ahead-of-time processing is applied to each of these application contexts and assets are generated.</p> </li> <li> <p>A native image is created, with the generated assets being processed by GraalVM.</p> </li> <li> <p>The native image also includes the JUnit <code>TestEngine</code> configured with a list of the discovered tests.</p> </li> <li> <p>The native image is started, triggering the engine which will run each test and report results.</p> </li> </ul> </div> <div class="sect3"> <h4 id="native-image.testing.with-native-build-tools.maven">
3.2.1. Using Maven</h4> <div class="paragraph"> <p>To run native tests using Maven, ensure that your <code>pom.xml</code> file uses the <code>spring-boot-starter-parent</code>. You should have a <code>&lt;parent&gt;</code> section that looks like this:</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlight" data-language="xml"><code class="language-xml" data-lang="xml">&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;3.1.3&lt;/version&gt;
&lt;/parent&gt;</code></pre> </div> </div> <div class="paragraph"> <p>The <code>spring-boot-starter-parent</code> declares a <code>nativeTest</code> profile that configures the executions that are needed to run the native tests. You can activate profiles using the <code>-P</code> flag on the command line.</p> </div> <div class="admonitionblock tip"> <table> <tr> <td class="icon">  </td> <td class="content"> If you don’t want to use <code>spring-boot-starter-parent</code> you’ll need to configure executions for the <code>process-test-aot</code> goal from the Spring Boot plugin and the <code>test</code> goal from the Native Build Tools plugin. </td> </tr> </table> </div> <div class="paragraph"> <p>To build the image and run the tests, use the <code>test</code> goal with the <code>nativeTest</code> profile active:</p> </div> <div class="listingblock"> <div class="content"> <pre data-language="">$ mvn -PnativeTest test</pre> </div> </div> </div> <div class="sect3"> <h4 id="native-image.testing.with-native-build-tools.gradle">
3.2.2. Using Gradle</h4> <div class="paragraph"> <p>The Spring Boot Gradle plugin automatically configures AOT test tasks when the GraalVM Native Image plugin is applied. You should check that your Gradle build contains a <code>plugins</code> block that includes <code>org.graalvm.buildtools.native</code>.</p> </div> <div class="paragraph"> <p>To run native tests using Gradle you can use the <code>nativeTest</code> task:</p> </div> <div class="listingblock"> <div class="content"> <pre data-language="">$ gradle nativeTest</pre> </div> </div> </div> </div> </div> </div> <div class="sect1"> <h2 id="native-image.advanced">
4. Advanced Native Images Topics</h2> <div class="sectionbody"> <div class="sect2"> <h3 id="native-image.advanced.nested-configuration-properties">
4.1. Nested Configuration Properties</h3> <div class="paragraph"> <p>Reflection hints are automatically created for configuration properties by the Spring ahead-of-time engine. Nested configuration properties which are not inner classes, however, <strong>must</strong> be annotated with <code>@NestedConfigurationProperty</code>, otherwise they won’t be detected and will not be bindable.</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.context.properties.NestedConfigurationProperty;

</span><span class="fold-block">@ConfigurationProperties(prefix = "my.properties")
public class MyProperties {

    private String name;

    @NestedConfigurationProperty
    private final Nested nested = new Nested();

</span><span class="fold-block hide-when-unfolded">    // getters / setters...

</span><span class="fold-block hide-when-folded">    public String getName() {
        return this.name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Nested getNested() {
        return this.nested;
    }

</span><span class="fold-block">}
</span></code></pre> </div> </div> <div class="paragraph"> <p>where <code>Nested</code> is:</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block">public class Nested {

    private int number;

</span><span class="fold-block hide-when-unfolded">    // getters / setters...

</span><span class="fold-block hide-when-folded">    public int getNumber() {
        return this.number;
    }

    public void setNumber(int number) {
        this.number = number;
    }

</span><span class="fold-block">}
</span></code></pre> </div> </div> <div class="paragraph"> <p>The example above produces configuration properties for <code>my.properties.name</code> and <code>my.properties.nested.number</code>. Without the <code>@NestedConfigurationProperty</code> annotation on the <code>nested</code> field, the <code>my.properties.nested.number</code> property would not be bindable in a native image.</p> </div> <div class="paragraph"> <p>When using constructor binding, you have to annotate the field with <code>@NestedConfigurationProperty</code>:</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.context.properties.NestedConfigurationProperty;

</span><span class="fold-block">@ConfigurationProperties(prefix = "my.properties")
public class MyPropertiesCtor {

    private final String name;

    @NestedConfigurationProperty
    private final Nested nested;

    public MyPropertiesCtor(String name, Nested nested) {
        this.name = name;
        this.nested = nested;
    }

</span><span class="fold-block hide-when-unfolded">    // getters / setters...

</span><span class="fold-block hide-when-folded">    public String getName() {
        return this.name;
    }

    public Nested getNested() {
        return this.nested;
    }

</span><span class="fold-block">}
</span></code></pre> </div> </div> <div class="paragraph"> <p>When using records, you have to annotate the parameter with <code>@NestedConfigurationProperty</code>:</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.context.properties.NestedConfigurationProperty;

</span><span class="fold-block">@ConfigurationProperties(prefix = "my.properties")
public record MyPropertiesRecord(String name, @NestedConfigurationProperty Nested nested) {

}
</span></code></pre> </div> </div> <div class="paragraph"> <p>When using Kotlin, you need to annotate the parameter of a data class with <code>@NestedConfigurationProperty</code>:</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlight" data-language="kotlin"><code class="language-kotlin" data-lang="kotlin"><span class="fold-block hide-when-folded">import org.springframework.boot.context.properties.ConfigurationProperties
import org.springframework.boot.context.properties.NestedConfigurationProperty

</span><span class="fold-block">@ConfigurationProperties(prefix = "my.properties")
data class MyPropertiesKotlin(
    val name: String,
    @NestedConfigurationProperty val nested: Nested
)
</span></code></pre> </div> </div> <div class="admonitionblock note"> <table> <tr> <td class="icon">  </td> <td class="content"> Please use public getters and setters in all cases, otherwise the properties will not be bindable. </td> </tr> </table> </div> </div> <div class="sect2"> <h3 id="native-image.advanced.converting-executable-jars">
4.2. Converting a Spring Boot Executable Jar</h3> <div class="paragraph"> <p>It is possible to convert a Spring Boot <a href="executable-jar.html#appendix.executable-jar">executable jar</a> into a native image as long as the jar contains the AOT generated assets. This can be useful for a number of reasons, including:</p> </div> <div class="ulist"> <ul> <li> <p>You can keep your regular JVM pipeline and turn the JVM application into a native image on your CI/CD platform.</p> </li> <li> <p>As <code>native-image</code> <a href="https://github.com/oracle/graal/issues/407">does not support cross-compilation</a>, you can keep an OS neutral deployment artifact which you convert later to different OS architectures.</p> </li> </ul> </div> <div class="paragraph"> <p>You can convert a Spring Boot executable jar into a native image using Cloud Native Buildpacks, or using the <code>native-image</code> tool that is shipped with GraalVM.</p> </div> <div class="admonitionblock note"> <table> <tr> <td class="icon">  </td> <td class="content"> Your executable jar must include AOT generated assets such as generated classes and JSON hint files. </td> </tr> </table> </div> <div class="sect3"> <h4 id="native-image.advanced.converting-executable-jars.buildpacks">
4.2.1. Using Buildpacks</h4> <div class="paragraph"> <p>Spring Boot applications usually use Cloud Native Buildpacks through the Maven (<code>mvn spring-boot:build-image</code>) or Gradle (<code>gradle bootBuildImage</code>) integrations. You can, however, also use <a href="https://buildpacks.io//docs/tools/pack/"><code>pack</code></a> to turn an AOT processed Spring Boot executable jar into a native container image.</p> </div> <div class="paragraph"> <p>First, make sure that a Docker daemon is available (see <a href="https://docs.docker.com/installation/#installation">Get Docker</a> for more details). <a href="https://docs.docker.com/engine/install/linux-postinstall/#manage-docker-as-a-non-root-user">Configure it to allow non-root user</a> if you are on Linux.</p> </div> <div class="paragraph"> <p>You also need to install <code>pack</code> by following <a href="https://buildpacks.io//docs/tools/pack/#install">the installation guide on buildpacks.io</a>.</p> </div> <div class="paragraph"> <p>Assuming an AOT processed Spring Boot executable jar built as <code>myproject-0.0.1-SNAPSHOT.jar</code> is in the <code>target</code> directory, run:</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlight" data-language="shell"><code class="language-shell" data-lang="shell">$ pack build --builder paketobuildpacks/builder-jammy-tiny \
    --path target/myproject-0.0.1-SNAPSHOT.jar \
    --env 'BP_NATIVE_IMAGE=true' \
    my-application:0.0.1-SNAPSHOT</code></pre> </div> </div> <div class="admonitionblock note"> <table> <tr> <td class="icon">  </td> <td class="content"> You do not need to have a local GraalVM installation to generate an image in this way. </td> </tr> </table> </div> <div class="paragraph"> <p>Once <code>pack</code> has finished, you can launch the application using <code>docker run</code>:</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlight" data-language="shell"><code class="language-shell" data-lang="shell">$ docker run --rm -p 8080:8080 docker.io/library/myproject:0.0.1-SNAPSHOT</code></pre> </div> </div> </div> <div class="sect3"> <h4 id="native-image.advanced.converting-executable-jars.native-image">
4.2.2. Using GraalVM native-image</h4> <div class="paragraph"> <p>Another option to turn an AOT processed Spring Boot executable jar into a native executable is to use the GraalVM <code>native-image</code> tool. For this to work, you’ll need a GraalVM distribution on your machine. You can either download it manually on the <a href="https://bell-sw.com/pages/downloads/native-image-kit/#/nik-22-17">Liberica Native Image Kit page</a> or you can use a download manager like SDKMAN!.</p> </div> <div class="paragraph"> <p>Assuming an AOT processed Spring Boot executable jar built as <code>myproject-0.0.1-SNAPSHOT.jar</code> is in the <code>target</code> directory, run:</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlight" data-language="shell"><code class="language-shell" data-lang="shell">$ rm -rf target/native
$ mkdir -p target/native
$ cd target/native
$ jar -xvf ../myproject-0.0.1-SNAPSHOT.jar
$ native-image -H:Name=myproject @META-INF/native-image/argfile -cp .:BOOT-INF/classes:`find BOOT-INF/lib | tr '\n' ':'`
$ mv myproject ../</code></pre> </div> </div> <div class="admonitionblock note"> <table> <tr> <td class="icon">  </td> <td class="content"> These commands work on Linux or macOS machines, but you will need to adapt them for Windows. </td> </tr> </table> </div> <div class="admonitionblock tip"> <table> <tr> <td class="icon">  </td> <td class="content"> The <code>@META-INF/native-image/argfile</code> might not be packaged in your jar. It is only included when reachability metadata overrides are needed. </td> </tr> </table> </div> <div class="admonitionblock warning"> <table> <tr> <td class="icon">  </td> <td class="content"> The <code>native-image</code> <code>-cp</code> flag does not accept wildcards. You need to ensure that all jars are listed (the command above uses <code>find</code> and <code>tr</code> to do this). </td> </tr> </table> </div> </div> </div> <div class="sect2"> <h3 id="native-image.advanced.using-the-tracing-agent">
4.3. Using the Tracing Agent</h3> <div class="paragraph"> <p>The GraalVM native image <a href="https://www.graalvm.org/22.3/reference-manual/native-image/metadata/AutomaticMetadataCollection">tracing agent</a> allows you to intercept reflection, resources or proxy usage on the JVM in order to generate the related hints. Spring should generate most of these hints automatically, but the tracing agent can be used to quickly identify the missing entries.</p> </div> <div class="paragraph"> <p>When using the agent to generate hints for a native image, there are a couple of approaches:</p> </div> <div class="ulist"> <ul> <li> <p>Launch the application directly and exercise it.</p> </li> <li> <p>Run application tests to exercise the application.</p> </li> </ul> </div> <div class="paragraph"> <p>The first option is interesting for identifying the missing hints when a library or a pattern is not recognized by Spring.</p> </div> <div class="paragraph"> <p>The second option sounds more appealing for a repeatable setup, but by default the generated hints will include anything required by the test infrastructure. Some of these will be unnecessary when the application runs for real. To address this problem the agent supports an access-filter file that will cause certain data to be excluded from the generated output.</p> </div> <div class="sect3"> <h4 id="native-image.advanced.using-the-tracing-agent.launch">
4.3.1. Launch the Application Directly</h4> <div class="paragraph"> <p>Use the following command to launch the application with the native image tracing agent attached:</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlight" data-language="shell"><code class="language-shell" data-lang="shell">$ java -Dspring.aot.enabled=true \
    -agentlib:native-image-agent=config-output-dir=/path/to/config-dir/ \
    -jar target/myproject-0.0.1-SNAPSHOT.jar</code></pre> </div> </div> <div class="paragraph"> <p>Now you can exercise the code paths you want to have hints for and then stop the application with <code>ctrl-c</code>.</p> </div> <div class="paragraph"> <p>On application shutdown the native image tracing agent will write the hint files to the given config output directory. You can either manually inspect these files, or use them as input to the native image build process. To use them as input, copy them into the <code>src/main/resources/META-INF/native-image/</code> directory. The next time you build the native image, GraalVM will take these files into consideration.</p> </div> <div class="paragraph"> <p>There are more advanced options which can be set on the native image tracing agent, for example filtering the recorded hints by caller classes, etc. For further reading, please see <a href="https://www.graalvm.org/22.3/reference-manual/native-image/metadata/AutomaticMetadataCollection">the official documentation</a>.</p> </div> </div> </div> <div class="sect2"> <h3 id="native-image.advanced.custom-hints">
4.4. Custom Hints</h3> <div class="paragraph"> <p>If you need to provide your own hints for reflection, resources, serialization, proxy usage etc. you can use the <code>RuntimeHintsRegistrar</code> API. Create a class that implements the <code>RuntimeHintsRegistrar</code> interface, and then make appropriate calls to the provided <code>RuntimeHints</code> instance:</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import java.lang.reflect.Method;

import org.springframework.aot.hint.ExecutableMode;
import org.springframework.aot.hint.RuntimeHints;
import org.springframework.aot.hint.RuntimeHintsRegistrar;
import org.springframework.util.ReflectionUtils;

</span><span class="fold-block">public class MyRuntimeHints implements RuntimeHintsRegistrar {

    @Override
    public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
        // Register method for reflection
        Method method = ReflectionUtils.findMethod(MyClass.class, "sayHello", String.class);
        hints.reflection().registerMethod(method, ExecutableMode.INVOKE);

        // Register resources
        hints.resources().registerPattern("my-resource.txt");

        // Register serialization
        hints.serialization().registerType(MySerializableClass.class);

        // Register proxy
        hints.proxies().registerJdkProxy(MyInterface.class);
    }

}
</span></code></pre> </div> </div> <div class="paragraph"> <p>You can then use <code>@ImportRuntimeHints</code> on any <code>@Configuration</code> class (for example your <code>@SpringBootApplication</code> annotated application class) to activate those hints.</p> </div> <div class="paragraph"> <p>If you have classes which need binding (mostly needed when serializing or deserializing JSON), you can use <a href="https://docs.spring.io/spring-framework/docs/6.0.11/reference/html/core.html#aot-hints-register-reflection-for-binding"><code>@RegisterReflectionForBinding</code></a> on any bean. Most of the hints are automatically inferred, for example when accepting or returning data from a <code>@RestController</code> method. But when you work with <code>WebClient</code> or <code>RestTemplate</code> directly, you might need to use <code>@RegisterReflectionForBinding</code>.</p> </div> <div class="sect3"> <h4 id="native-image.advanced.custom-hints.testing">
4.4.1. Testing custom hints</h4> <div class="paragraph"> <p>The <code>RuntimeHintsPredicates</code> API can be used to test your hints. The API provides methods that build a <code>Predicate</code> that can be used to test a <code>RuntimeHints</code> instance.</p> </div> <div class="paragraph"> <p>If you’re using AssertJ, your test would look like this:</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import org.junit.jupiter.api.Test;

import org.springframework.aot.hint.RuntimeHints;
import org.springframework.aot.hint.predicate.RuntimeHintsPredicates;
import org.springframework.boot.docs.nativeimage.advanced.customhints.MyRuntimeHints;

import static org.assertj.core.api.Assertions.assertThat;

</span><span class="fold-block">class MyRuntimeHintsTests {

    @Test
    void shouldRegisterHints() {
        RuntimeHints hints = new RuntimeHints();
        new MyRuntimeHints().registerHints(hints, getClass().getClassLoader());
        assertThat(RuntimeHintsPredicates.resource().forResource("my-resource.txt")).accepts(hints);
    }

}
</span></code></pre> </div> </div> </div> </div> <div class="sect2"> <h3 id="native-image.advanced.known-limitations">
4.5. Known Limitations</h3> <div class="paragraph"> <p>GraalVM native images are an evolving technology and not all libraries provide support. The GraalVM community is helping by providing <a href="https://github.com/oracle/graalvm-reachability-metadata">reachability metadata</a> for projects that don’t yet ship their own. Spring itself doesn’t contain hints for 3rd party libraries and instead relies on the reachability metadata project.</p> </div> <div class="paragraph"> <p>If you encounter problems when generating native images for Spring Boot applications, please check the <a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-with-GraalVM">Spring Boot with GraalVM</a> page of the Spring Boot wiki. You can also contribute issues to the <a href="https://github.com/spring-projects/spring-aot-smoke-tests">spring-aot-smoke-tests</a> project on GitHub which is used to confirm that common application types are working as expected.</p> </div> <div class="paragraph"> <p>If you find a library which doesn’t work with GraalVM, please raise an issue on the <a href="https://github.com/oracle/graalvm-reachability-metadata">reachability metadata project</a>.</p> </div> </div> </div> </div> <div class="sect1"> <h2 id="native-image.whats-next">
5. What to Read Next</h2> <div class="sectionbody"> <div class="paragraph"> <p>If you want to learn more about the ahead-of-time processing provided by our build plugins, see the <a href="https://docs.spring.io/spring-boot/docs/3.1.3/maven-plugin/reference/htmlsingle/">Maven</a> and <a href="https://docs.spring.io/spring-boot/docs/3.1.3/gradle-plugin/reference/htmlsingle/">Gradle</a> plugin documentation. To learn more about the APIs used to perform the processing, browse the <code>org.springframework.aot.generate</code> and <code>org.springframework.beans.factory.aot</code> packages of the Spring Framework sources.</p> </div> <div class="paragraph"> <p>For known limitations with Spring and GraalVM, please see the <a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-with-GraalVM">Spring Boot wiki</a>.</p> </div> <div class="paragraph"> <p>The next section goes on to cover the <em><a href="cli.html#cli">Spring Boot CLI</a></em>.</p> </div> </div> </div><div class="_attribution">
  <p class="_attribution-p">
    Copyright &copy; 2012-2023 VMware, Inc.<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://docs.spring.io/spring-boot/docs/3.1.3/reference/html/native-image.html" class="_attribution-link">https://docs.spring.io/spring-boot/docs/3.1.3/reference/html/native-image.html</a>
  </p>
</div>
