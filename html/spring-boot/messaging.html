<h1>Messaging</h1> <div id="preamble"> <div class="sectionbody"> <div class="paragraph"> <p>The Spring Framework provides extensive support for integrating with messaging systems, from simplified use of the JMS API using <code>JmsTemplate</code> to a complete infrastructure to receive messages asynchronously. Spring AMQP provides a similar feature set for the Advanced Message Queuing Protocol. Spring Boot also provides auto-configuration options for <code>RabbitTemplate</code> and RabbitMQ. Spring WebSocket natively includes support for STOMP messaging, and Spring Boot has support for that through starters and a small amount of auto-configuration. Spring Boot also has support for Apache Kafka.</p> </div> </div> </div> <div class="sect1"> <h2 id="messaging.jms">
1. JMS</h2> <div class="sectionbody"> <div class="paragraph"> <p>The <code>jakarta.jms.ConnectionFactory</code> interface provides a standard method of creating a <code>jakarta.jms.Connection</code> for interacting with a JMS broker. Although Spring needs a <code>ConnectionFactory</code> to work with JMS, you generally need not use it directly yourself and can instead rely on higher level messaging abstractions. (See the <a href="https://docs.spring.io/spring-framework/docs/6.0.11/reference/html/integration.html#jms">relevant section</a> of the Spring Framework reference documentation for details.) Spring Boot also auto-configures the necessary infrastructure to send and receive messages.</p> </div> <div class="sect2"> <h3 id="messaging.jms.activemq">
1.1. ActiveMQ Support</h3> <div class="paragraph"> <p>When <a href="https://activemq.apache.org/">ActiveMQ</a> is available on the classpath, Spring Boot can configure a <code>ConnectionFactory</code>.</p> </div> <div class="admonitionblock note"> <table> <tr> <td class="icon">  </td> <td class="content"> If you use <code>spring-boot-starter-activemq</code>, the necessary dependencies to connect to an ActiveMQ instance are provided, as is the Spring infrastructure to integrate with JMS. </td> </tr> </table> </div> <div class="paragraph"> <p>ActiveMQ configuration is controlled by external configuration properties in <code>spring.activemq.*</code>. By default, ActiveMQ is auto-configured to use the <a href="https://activemq.apache.org/tcp-transport-reference">TCP transport</a>, connecting by default to <code>tcp://localhost:61616</code>. The following example shows how to change the default broker URL:</p> </div> <div class="listingblock primary"> <div class="title">Properties</div> <div class="content"> <pre class="highlight" data-language="properties"><code class="language-properties" data-lang="properties">spring.activemq.broker-url=tcp://192.168.1.210:9876
spring.activemq.user=admin
spring.activemq.password=secret</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Yaml</div> <div class="content"> <pre class="highlight" data-language="yaml"><code class="language-yaml" data-lang="yaml">spring:
  activemq:
    broker-url: "tcp://192.168.1.210:9876"
    user: "admin"
    password: "secret"</code></pre> </div> </div> <div class="paragraph"> <p>By default, a <code>CachingConnectionFactory</code> wraps the native <code>ConnectionFactory</code> with sensible settings that you can control by external configuration properties in <code>spring.jms.*</code>:</p> </div> <div class="listingblock primary"> <div class="title">Properties</div> <div class="content"> <pre class="highlight" data-language="properties"><code class="language-properties" data-lang="properties">spring.jms.cache.session-cache-size=5</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Yaml</div> <div class="content"> <pre class="highlight" data-language="yaml"><code class="language-yaml" data-lang="yaml">spring:
  jms:
    cache:
      session-cache-size: 5</code></pre> </div> </div> <div class="paragraph"> <p>If you’d rather use native pooling, you can do so by adding a dependency to <code>org.messaginghub:pooled-jms</code> and configuring the <code>JmsPoolConnectionFactory</code> accordingly, as shown in the following example:</p> </div> <div class="listingblock primary"> <div class="title">Properties</div> <div class="content"> <pre class="highlight" data-language="properties"><code class="language-properties" data-lang="properties">spring.activemq.pool.enabled=true
spring.activemq.pool.max-connections=50</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Yaml</div> <div class="content"> <pre class="highlight" data-language="yaml"><code class="language-yaml" data-lang="yaml">spring:
  activemq:
    pool:
      enabled: true
      max-connections: 50</code></pre> </div> </div> <div class="admonitionblock tip"> <table> <tr> <td class="icon">  </td> <td class="content"> See <a href="https://github.com/spring-projects/spring-boot/tree/v3.1.3/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jms/activemq/ActiveMQProperties.java"><code>ActiveMQProperties</code></a> for more of the supported options. You can also register an arbitrary number of beans that implement <code>ActiveMQConnectionFactoryCustomizer</code> for more advanced customizations. </td> </tr> </table> </div> <div class="paragraph"> <p>By default, ActiveMQ creates a destination if it does not yet exist so that destinations are resolved against their provided names.</p> </div> </div> <div class="sect2"> <h3 id="messaging.jms.artemis">
1.2. ActiveMQ Artemis Support</h3> <div class="paragraph"> <p>Spring Boot can auto-configure a <code>ConnectionFactory</code> when it detects that <a href="https://activemq.apache.org/components/artemis/">ActiveMQ Artemis</a> is available on the classpath. If the broker is present, an embedded broker is automatically started and configured (unless the mode property has been explicitly set). The supported modes are <code>embedded</code> (to make explicit that an embedded broker is required and that an error should occur if the broker is not available on the classpath) and <code>native</code> (to connect to a broker using the <code>netty</code> transport protocol). When the latter is configured, Spring Boot configures a <code>ConnectionFactory</code> that connects to a broker running on the local machine with the default settings.</p> </div> <div class="admonitionblock note"> <table> <tr> <td class="icon">  </td> <td class="content"> If you use <code>spring-boot-starter-artemis</code>, the necessary dependencies to connect to an existing ActiveMQ Artemis instance are provided, as well as the Spring infrastructure to integrate with JMS. Adding <code>org.apache.activemq:artemis-jakarta-server</code> to your application lets you use embedded mode. </td> </tr> </table> </div> <div class="paragraph"> <p>ActiveMQ Artemis configuration is controlled by external configuration properties in <code>spring.artemis.*</code>. For example, you might declare the following section in <code>application.properties</code>:</p> </div> <div class="listingblock primary"> <div class="title">Properties</div> <div class="content"> <pre class="highlight" data-language="properties"><code class="language-properties" data-lang="properties">spring.artemis.mode=native
spring.artemis.broker-url=tcp://192.168.1.210:9876
spring.artemis.user=admin
spring.artemis.password=secret</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Yaml</div> <div class="content"> <pre class="highlight" data-language="yaml"><code class="language-yaml" data-lang="yaml">spring:
  artemis:
    mode: native
    broker-url: "tcp://192.168.1.210:9876"
    user: "admin"
    password: "secret"</code></pre> </div> </div> <div class="paragraph"> <p>When embedding the broker, you can choose if you want to enable persistence and list the destinations that should be made available. These can be specified as a comma-separated list to create them with the default options, or you can define bean(s) of type <code>org.apache.activemq.artemis.jms.server.config.JMSQueueConfiguration</code> or <code>org.apache.activemq.artemis.jms.server.config.TopicConfiguration</code>, for advanced queue and topic configurations, respectively.</p> </div> <div class="paragraph"> <p>By default, a <code>CachingConnectionFactory</code> wraps the native <code>ConnectionFactory</code> with sensible settings that you can control by external configuration properties in <code>spring.jms.*</code>:</p> </div> <div class="listingblock primary"> <div class="title">Properties</div> <div class="content"> <pre class="highlight" data-language="properties"><code class="language-properties" data-lang="properties">spring.jms.cache.session-cache-size=5</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Yaml</div> <div class="content"> <pre class="highlight" data-language="yaml"><code class="language-yaml" data-lang="yaml">spring:
  jms:
    cache:
      session-cache-size: 5</code></pre> </div> </div> <div class="paragraph"> <p>If you’d rather use native pooling, you can do so by adding a dependency on <code>org.messaginghub:pooled-jms</code> and configuring the <code>JmsPoolConnectionFactory</code> accordingly, as shown in the following example:</p> </div> <div class="listingblock primary"> <div class="title">Properties</div> <div class="content"> <pre class="highlight" data-language="properties"><code class="language-properties" data-lang="properties">spring.artemis.pool.enabled=true
spring.artemis.pool.max-connections=50</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Yaml</div> <div class="content"> <pre class="highlight" data-language="yaml"><code class="language-yaml" data-lang="yaml">spring:
  artemis:
    pool:
      enabled: true
      max-connections: 50</code></pre> </div> </div> <div class="paragraph"> <p>See <a href="https://github.com/spring-projects/spring-boot/tree/v3.1.3/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jms/artemis/ArtemisProperties.java"><code>ArtemisProperties</code></a> for more supported options.</p> </div> <div class="paragraph"> <p>No JNDI lookup is involved, and destinations are resolved against their names, using either the <code>name</code> attribute in the Artemis configuration or the names provided through configuration.</p> </div> </div> <div class="sect2"> <h3 id="messaging.jms.jndi">
1.3. Using a JNDI ConnectionFactory</h3> <div class="paragraph"> <p>If you are running your application in an application server, Spring Boot tries to locate a JMS <code>ConnectionFactory</code> by using JNDI. By default, the <code>java:/JmsXA</code> and <code>java:/XAConnectionFactory</code> location are checked. You can use the <code>spring.jms.jndi-name</code> property if you need to specify an alternative location, as shown in the following example:</p> </div> <div class="listingblock primary"> <div class="title">Properties</div> <div class="content"> <pre class="highlight" data-language="properties"><code class="language-properties" data-lang="properties">spring.jms.jndi-name=java:/MyConnectionFactory</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Yaml</div> <div class="content"> <pre class="highlight" data-language="yaml"><code class="language-yaml" data-lang="yaml">spring:
  jms:
    jndi-name: "java:/MyConnectionFactory"</code></pre> </div> </div> </div> <div class="sect2"> <h3 id="messaging.jms.sending">
1.4. Sending a Message</h3> <div class="paragraph"> <p>Spring’s <code>JmsTemplate</code> is auto-configured, and you can autowire it directly into your own beans, as shown in the following example:</p> </div> <div class="listingblock primary"> <div class="title">Java</div> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import org.springframework.jms.core.JmsTemplate;
import org.springframework.stereotype.Component;

</span><span class="fold-block">@Component
public class MyBean {

    private final JmsTemplate jmsTemplate;

    public MyBean(JmsTemplate jmsTemplate) {
        this.jmsTemplate = jmsTemplate;
    }

</span><span class="fold-block hide-when-unfolded">    // ...

</span><span class="fold-block hide-when-folded">    public void someMethod() {
        this.jmsTemplate.convertAndSend("hello");
    }

</span><span class="fold-block">}
</span></code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Kotlin</div> <div class="content"> <pre class="highlight" data-language="kotlin"><code class="language-kotlin" data-lang="kotlin"><span class="fold-block hide-when-folded">import org.springframework.jms.core.JmsTemplate
import org.springframework.stereotype.Component

</span><span class="fold-block">@Component
class MyBean(private val jmsTemplate: JmsTemplate) {

</span><span class="fold-block hide-when-unfolded">    // ...

</span><span class="fold-block hide-when-folded">    fun someMethod() {
        jmsTemplate.convertAndSend("hello")
    }

</span><span class="fold-block">}
</span></code></pre> </div> </div> <div class="admonitionblock note"> <table> <tr> <td class="icon">  </td> <td class="content"> <a href="https://docs.spring.io/spring-framework/docs/6.0.11/javadoc-api/org/springframework/jms/core/JmsMessagingTemplate.html"><code>JmsMessagingTemplate</code></a> can be injected in a similar manner. If a <code>DestinationResolver</code> or a <code>MessageConverter</code> bean is defined, it is associated automatically to the auto-configured <code>JmsTemplate</code>. </td> </tr> </table> </div> </div> <div class="sect2"> <h3 id="messaging.jms.receiving">
1.5. Receiving a Message</h3> <div class="paragraph"> <p>When the JMS infrastructure is present, any bean can be annotated with <code>@JmsListener</code> to create a listener endpoint. If no <code>JmsListenerContainerFactory</code> has been defined, a default one is configured automatically. If a <code>DestinationResolver</code>, a <code>MessageConverter</code>, or a <code>jakarta.jms.ExceptionListener</code> beans are defined, they are associated automatically with the default factory.</p> </div> <div class="paragraph"> <p>By default, the default factory is transactional. If you run in an infrastructure where a <code>JtaTransactionManager</code> is present, it is associated to the listener container by default. If not, the <code>sessionTransacted</code> flag is enabled. In that latter scenario, you can associate your local data store transaction to the processing of an incoming message by adding <code>@Transactional</code> on your listener method (or a delegate thereof). This ensures that the incoming message is acknowledged, once the local transaction has completed. This also includes sending response messages that have been performed on the same JMS session.</p> </div> <div class="paragraph"> <p>The following component creates a listener endpoint on the <code>someQueue</code> destination:</p> </div> <div class="listingblock primary"> <div class="title">Java</div> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import org.springframework.jms.annotation.JmsListener;
import org.springframework.stereotype.Component;

</span><span class="fold-block">@Component
public class MyBean {

    @JmsListener(destination = "someQueue")
    public void processMessage(String content) {
        // ...
    }

}
</span></code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Kotlin</div> <div class="content"> <pre class="highlight" data-language="kotlin"><code class="language-kotlin" data-lang="kotlin"><span class="fold-block hide-when-folded">import org.springframework.jms.annotation.JmsListener
import org.springframework.stereotype.Component

</span><span class="fold-block">@Component
class MyBean {

    @JmsListener(destination = "someQueue")
    fun processMessage(content: String?) {
        // ...
    }

}
</span></code></pre> </div> </div> <div class="admonitionblock tip"> <table> <tr> <td class="icon">  </td> <td class="content"> See <a href="https://docs.spring.io/spring-framework/docs/6.0.11/javadoc-api/org/springframework/jms/annotation/EnableJms.html">the Javadoc of <code>@EnableJms</code></a> for more details. </td> </tr> </table> </div> <div class="paragraph"> <p>If you need to create more <code>JmsListenerContainerFactory</code> instances or if you want to override the default, Spring Boot provides a <code>DefaultJmsListenerContainerFactoryConfigurer</code> that you can use to initialize a <code>DefaultJmsListenerContainerFactory</code> with the same settings as the one that is auto-configured.</p> </div> <div class="paragraph"> <p>For instance, the following example exposes another factory that uses a specific <code>MessageConverter</code>:</p> </div> <div class="listingblock primary"> <div class="title">Java</div> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import jakarta.jms.ConnectionFactory;

import org.springframework.boot.autoconfigure.jms.DefaultJmsListenerContainerFactoryConfigurer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jms.config.DefaultJmsListenerContainerFactory;

</span><span class="fold-block">@Configuration(proxyBeanMethods = false)
public class MyJmsConfiguration {

    @Bean
    public DefaultJmsListenerContainerFactory myFactory(DefaultJmsListenerContainerFactoryConfigurer configurer) {
        DefaultJmsListenerContainerFactory factory = new DefaultJmsListenerContainerFactory();
        ConnectionFactory connectionFactory = getCustomConnectionFactory();
        configurer.configure(factory, connectionFactory);
        factory.setMessageConverter(new MyMessageConverter());
        return factory;
    }

    private ConnectionFactory getCustomConnectionFactory() {
        return ...
    }

}
</span></code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Kotlin</div> <div class="content"> <pre class="highlight" data-language="kotlin"><code class="language-kotlin" data-lang="kotlin"><span class="fold-block hide-when-folded">import jakarta.jms.ConnectionFactory
import org.springframework.boot.autoconfigure.jms.DefaultJmsListenerContainerFactoryConfigurer
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.jms.config.DefaultJmsListenerContainerFactory

</span><span class="fold-block">@Configuration(proxyBeanMethods = false)
class MyJmsConfiguration {

    @Bean
    fun myFactory(configurer: DefaultJmsListenerContainerFactoryConfigurer): DefaultJmsListenerContainerFactory {
        val factory = DefaultJmsListenerContainerFactory()
        val connectionFactory = getCustomConnectionFactory()
        configurer.configure(factory, connectionFactory)
        factory.setMessageConverter(MyMessageConverter())
        return factory
    }

    fun getCustomConnectionFactory() : ConnectionFactory? {
        return ...
    }

}
</span></code></pre> </div> </div> <div class="paragraph"> <p>Then you can use the factory in any <code>@JmsListener</code>-annotated method as follows:</p> </div> <div class="listingblock primary"> <div class="title">Java</div> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import org.springframework.jms.annotation.JmsListener;
import org.springframework.stereotype.Component;

</span><span class="fold-block">@Component
public class MyBean {

    @JmsListener(destination = "someQueue", containerFactory = "myFactory")
    public void processMessage(String content) {
        // ...
    }

}
</span></code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Kotlin</div> <div class="content"> <pre class="highlight" data-language="kotlin"><code class="language-kotlin" data-lang="kotlin"><span class="fold-block hide-when-folded">import org.springframework.jms.annotation.JmsListener
import org.springframework.stereotype.Component

</span><span class="fold-block">@Component
class MyBean {

    @JmsListener(destination = "someQueue", containerFactory = "myFactory")
    fun processMessage(content: String?) {
        // ...
    }

}
</span></code></pre> </div> </div> </div> </div> </div> <div class="sect1"> <h2 id="messaging.amqp">
2. AMQP</h2> <div class="sectionbody"> <div class="paragraph"> <p>The Advanced Message Queuing Protocol (AMQP) is a platform-neutral, wire-level protocol for message-oriented middleware. The Spring AMQP project applies core Spring concepts to the development of AMQP-based messaging solutions. Spring Boot offers several conveniences for working with AMQP through RabbitMQ, including the <code>spring-boot-starter-amqp</code> “Starter”.</p> </div> <div class="sect2"> <h3 id="messaging.amqp.rabbitmq">
2.1. RabbitMQ Support</h3> <div class="paragraph"> <p><a href="https://www.rabbitmq.com/">RabbitMQ</a> is a lightweight, reliable, scalable, and portable message broker based on the AMQP protocol. Spring uses RabbitMQ to communicate through the AMQP protocol.</p> </div> <div class="paragraph"> <p>RabbitMQ configuration is controlled by external configuration properties in <code>spring.rabbitmq.*</code>. For example, you might declare the following section in <code>application.properties</code>:</p> </div> <div class="listingblock primary"> <div class="title">Properties</div> <div class="content"> <pre class="highlight" data-language="properties"><code class="language-properties" data-lang="properties">spring.rabbitmq.host=localhost
spring.rabbitmq.port=5672
spring.rabbitmq.username=admin
spring.rabbitmq.password=secret</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Yaml</div> <div class="content"> <pre class="highlight" data-language="yaml"><code class="language-yaml" data-lang="yaml">spring:
  rabbitmq:
    host: "localhost"
    port: 5672
    username: "admin"
    password: "secret"</code></pre> </div> </div> <div class="paragraph"> <p>Alternatively, you could configure the same connection using the <code>addresses</code> attribute:</p> </div> <div class="listingblock primary"> <div class="title">Properties</div> <div class="content"> <pre class="highlight" data-language="properties"><code class="language-properties" data-lang="properties">spring.rabbitmq.addresses=amqp://admin:secret@localhost</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Yaml</div> <div class="content"> <pre class="highlight" data-language="yaml"><code class="language-yaml" data-lang="yaml">spring:
  rabbitmq:
    addresses: "amqp://admin:secret@localhost"</code></pre> </div> </div> <div class="admonitionblock note"> <table> <tr> <td class="icon">  </td> <td class="content"> When specifying addresses that way, the <code>host</code> and <code>port</code> properties are ignored. If the address uses the <code>amqps</code> protocol, SSL support is enabled automatically. </td> </tr> </table> </div> <div class="paragraph"> <p>See <a href="https://github.com/spring-projects/spring-boot/tree/v3.1.3/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/amqp/RabbitProperties.java"><code>RabbitProperties</code></a> for more of the supported property-based configuration options. To configure lower-level details of the RabbitMQ <code>ConnectionFactory</code> that is used by Spring AMQP, define a <code>ConnectionFactoryCustomizer</code> bean.</p> </div> <div class="paragraph"> <p>If a <code>ConnectionNameStrategy</code> bean exists in the context, it will be automatically used to name connections created by the auto-configured <code>CachingConnectionFactory</code>.</p> </div> <div class="paragraph"> <p>To make an application-wide, additive customization to the <code>RabbitTemplate</code>, use a <code>RabbitTemplateCustomizer</code> bean.</p> </div> <div class="admonitionblock tip"> <table> <tr> <td class="icon">  </td> <td class="content"> See <a href="https://spring.io/blog/2010/06/14/understanding-amqp-the-protocol-used-by-rabbitmq/">Understanding AMQP, the protocol used by RabbitMQ</a> for more details. </td> </tr> </table> </div> </div> <div class="sect2"> <h3 id="messaging.amqp.sending">
2.2. Sending a Message</h3> <div class="paragraph"> <p>Spring’s <code>AmqpTemplate</code> and <code>AmqpAdmin</code> are auto-configured, and you can autowire them directly into your own beans, as shown in the following example:</p> </div> <div class="listingblock primary"> <div class="title">Java</div> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import org.springframework.amqp.core.AmqpAdmin;
import org.springframework.amqp.core.AmqpTemplate;
import org.springframework.stereotype.Component;

</span><span class="fold-block">@Component
public class MyBean {

    private final AmqpAdmin amqpAdmin;

    private final AmqpTemplate amqpTemplate;

    public MyBean(AmqpAdmin amqpAdmin, AmqpTemplate amqpTemplate) {
        this.amqpAdmin = amqpAdmin;
        this.amqpTemplate = amqpTemplate;
    }

</span><span class="fold-block hide-when-unfolded">    // ...

</span><span class="fold-block hide-when-folded">    public void someMethod() {
        this.amqpAdmin.getQueueInfo("someQueue");
    }

    public void someOtherMethod() {
        this.amqpTemplate.convertAndSend("hello");
    }

</span><span class="fold-block">}
</span></code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Kotlin</div> <div class="content"> <pre class="highlight" data-language="kotlin"><code class="language-kotlin" data-lang="kotlin"><span class="fold-block hide-when-folded">import org.springframework.amqp.core.AmqpAdmin
import org.springframework.amqp.core.AmqpTemplate
import org.springframework.stereotype.Component

</span><span class="fold-block">@Component
class MyBean(private val amqpAdmin: AmqpAdmin, private val amqpTemplate: AmqpTemplate) {

</span><span class="fold-block hide-when-unfolded">    // ...

</span><span class="fold-block hide-when-folded">    fun someMethod() {
        amqpAdmin.getQueueInfo("someQueue")
    }

    fun someOtherMethod() {
        amqpTemplate.convertAndSend("hello")
    }

</span><span class="fold-block">}
</span></code></pre> </div> </div> <div class="admonitionblock note"> <table> <tr> <td class="icon">  </td> <td class="content"> <a href="https://docs.spring.io/spring-amqp/docs/3.0.8/api/org/springframework/amqp/rabbit/core/RabbitMessagingTemplate.html"><code>RabbitMessagingTemplate</code></a> can be injected in a similar manner. If a <code>MessageConverter</code> bean is defined, it is associated automatically to the auto-configured <code>AmqpTemplate</code>. </td> </tr> </table> </div> <div class="paragraph"> <p>If necessary, any <code>org.springframework.amqp.core.Queue</code> that is defined as a bean is automatically used to declare a corresponding queue on the RabbitMQ instance.</p> </div> <div class="paragraph"> <p>To retry operations, you can enable retries on the <code>AmqpTemplate</code> (for example, in the event that the broker connection is lost):</p> </div> <div class="listingblock primary"> <div class="title">Properties</div> <div class="content"> <pre class="highlight" data-language="properties"><code class="language-properties" data-lang="properties">spring.rabbitmq.template.retry.enabled=true
spring.rabbitmq.template.retry.initial-interval=2s</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Yaml</div> <div class="content"> <pre class="highlight" data-language="yaml"><code class="language-yaml" data-lang="yaml">spring:
  rabbitmq:
    template:
      retry:
        enabled: true
        initial-interval: "2s"</code></pre> </div> </div> <div class="paragraph"> <p>Retries are disabled by default. You can also customize the <code>RetryTemplate</code> programmatically by declaring a <code>RabbitRetryTemplateCustomizer</code> bean.</p> </div> <div class="paragraph"> <p>If you need to create more <code>RabbitTemplate</code> instances or if you want to override the default, Spring Boot provides a <code>RabbitTemplateConfigurer</code> bean that you can use to initialize a <code>RabbitTemplate</code> with the same settings as the factories used by the auto-configuration.</p> </div> </div> <div class="sect2"> <h3 id="messaging.amqp.sending-stream">
2.3. Sending a Message To A Stream</h3> <div class="paragraph"> <p>To send a message to a particular stream, specify the name of the stream, as shown in the following example:</p> </div> <div class="listingblock primary"> <div class="title">Properties</div> <div class="content"> <pre class="highlight" data-language="properties"><code class="language-properties" data-lang="properties">spring.rabbitmq.stream.name=my-stream</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Yaml</div> <div class="content"> <pre class="highlight" data-language="yaml"><code class="language-yaml" data-lang="yaml">spring:
  rabbitmq:
    stream:
      name: "my-stream"</code></pre> </div> </div> <div class="paragraph"> <p>If a <code>MessageConverter</code>, <code>StreamMessageConverter</code>, or <code>ProducerCustomizer</code> bean is defined, it is associated automatically to the auto-configured <code>RabbitStreamTemplate</code>.</p> </div> <div class="paragraph"> <p>If you need to create more <code>RabbitStreamTemplate</code> instances or if you want to override the default, Spring Boot provides a <code>RabbitStreamTemplateConfigurer</code> bean that you can use to initialize a <code>RabbitStreamTemplate</code> with the same settings as the factories used by the auto-configuration.</p> </div> </div> <div class="sect2"> <h3 id="messaging.amqp.receiving">
2.4. Receiving a Message</h3> <div class="paragraph"> <p>When the Rabbit infrastructure is present, any bean can be annotated with <code>@RabbitListener</code> to create a listener endpoint. If no <code>RabbitListenerContainerFactory</code> has been defined, a default <code>SimpleRabbitListenerContainerFactory</code> is automatically configured and you can switch to a direct container using the <code>spring.rabbitmq.listener.type</code> property. If a <code>MessageConverter</code> or a <code>MessageRecoverer</code> bean is defined, it is automatically associated with the default factory.</p> </div> <div class="paragraph"> <p>The following sample component creates a listener endpoint on the <code>someQueue</code> queue:</p> </div> <div class="listingblock primary"> <div class="title">Java</div> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Component;

</span><span class="fold-block">@Component
public class MyBean {

    @RabbitListener(queues = "someQueue")
    public void processMessage(String content) {
        // ...
    }

}
</span></code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Kotlin</div> <div class="content"> <pre class="highlight" data-language="kotlin"><code class="language-kotlin" data-lang="kotlin"><span class="fold-block hide-when-folded">import org.springframework.amqp.rabbit.annotation.RabbitListener
import org.springframework.stereotype.Component

</span><span class="fold-block">@Component
class MyBean {

    @RabbitListener(queues = ["someQueue"])
    fun processMessage(content: String?) {
        // ...
    }

}
</span></code></pre> </div> </div> <div class="admonitionblock tip"> <table> <tr> <td class="icon">  </td> <td class="content"> See <a href="https://docs.spring.io/spring-amqp/docs/3.0.8/api/org/springframework/amqp/rabbit/annotation/EnableRabbit.html">the Javadoc of <code>@EnableRabbit</code></a> for more details. </td> </tr> </table> </div> <div class="paragraph"> <p>If you need to create more <code>RabbitListenerContainerFactory</code> instances or if you want to override the default, Spring Boot provides a <code>SimpleRabbitListenerContainerFactoryConfigurer</code> and a <code>DirectRabbitListenerContainerFactoryConfigurer</code> that you can use to initialize a <code>SimpleRabbitListenerContainerFactory</code> and a <code>DirectRabbitListenerContainerFactory</code> with the same settings as the factories used by the auto-configuration.</p> </div> <div class="admonitionblock tip"> <table> <tr> <td class="icon">  </td> <td class="content"> It does not matter which container type you chose. Those two beans are exposed by the auto-configuration. </td> </tr> </table> </div> <div class="paragraph"> <p>For instance, the following configuration class exposes another factory that uses a specific <code>MessageConverter</code>:</p> </div> <div class="listingblock primary"> <div class="title">Java</div> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import org.springframework.amqp.rabbit.config.SimpleRabbitListenerContainerFactory;
import org.springframework.amqp.rabbit.connection.ConnectionFactory;
import org.springframework.boot.autoconfigure.amqp.SimpleRabbitListenerContainerFactoryConfigurer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

</span><span class="fold-block">@Configuration(proxyBeanMethods = false)
public class MyRabbitConfiguration {

    @Bean
    public SimpleRabbitListenerContainerFactory myFactory(SimpleRabbitListenerContainerFactoryConfigurer configurer) {
        SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();
        ConnectionFactory connectionFactory = getCustomConnectionFactory();
        configurer.configure(factory, connectionFactory);
        factory.setMessageConverter(new MyMessageConverter());
        return factory;
    }

    private ConnectionFactory getCustomConnectionFactory() {
        return ...
    }

}
</span></code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Kotlin</div> <div class="content"> <pre class="highlight" data-language="kotlin"><code class="language-kotlin" data-lang="kotlin"><span class="fold-block hide-when-folded">import org.springframework.amqp.rabbit.config.SimpleRabbitListenerContainerFactory
import org.springframework.amqp.rabbit.connection.ConnectionFactory
import org.springframework.boot.autoconfigure.amqp.SimpleRabbitListenerContainerFactoryConfigurer
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration

</span><span class="fold-block">@Configuration(proxyBeanMethods = false)
class MyRabbitConfiguration {

    @Bean
    fun myFactory(configurer: SimpleRabbitListenerContainerFactoryConfigurer): SimpleRabbitListenerContainerFactory {
        val factory = SimpleRabbitListenerContainerFactory()
        val connectionFactory = getCustomConnectionFactory()
        configurer.configure(factory, connectionFactory)
        factory.setMessageConverter(MyMessageConverter())
        return factory
    }

    fun getCustomConnectionFactory() : ConnectionFactory? {
        return ...
    }

}
</span></code></pre> </div> </div> <div class="paragraph"> <p>Then you can use the factory in any <code>@RabbitListener</code>-annotated method, as follows:</p> </div> <div class="listingblock primary"> <div class="title">Java</div> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Component;

</span><span class="fold-block">@Component
public class MyBean {

    @RabbitListener(queues = "someQueue", containerFactory = "myFactory")
    public void processMessage(String content) {
        // ...
    }

}
</span></code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Kotlin</div> <div class="content"> <pre class="highlight" data-language="kotlin"><code class="language-kotlin" data-lang="kotlin"><span class="fold-block hide-when-folded">import org.springframework.amqp.rabbit.annotation.RabbitListener
import org.springframework.stereotype.Component

</span><span class="fold-block">@Component
class MyBean {

    @RabbitListener(queues = ["someQueue"], containerFactory = "myFactory")
    fun processMessage(content: String?) {
        // ...
    }

}
</span></code></pre> </div> </div> <div class="paragraph"> <p>You can enable retries to handle situations where your listener throws an exception. By default, <code>RejectAndDontRequeueRecoverer</code> is used, but you can define a <code>MessageRecoverer</code> of your own. When retries are exhausted, the message is rejected and either dropped or routed to a dead-letter exchange if the broker is configured to do so. By default, retries are disabled. You can also customize the <code>RetryTemplate</code> programmatically by declaring a <code>RabbitRetryTemplateCustomizer</code> bean.</p> </div> <div class="admonitionblock important"> <table> <tr> <td class="icon">  </td> <td class="content"> By default, if retries are disabled and the listener throws an exception, the delivery is retried indefinitely. You can modify this behavior in two ways: Set the <code>defaultRequeueRejected</code> property to <code>false</code> so that zero re-deliveries are attempted or throw an <code>AmqpRejectAndDontRequeueException</code> to signal the message should be rejected. The latter is the mechanism used when retries are enabled and the maximum number of delivery attempts is reached. </td> </tr> </table> </div> </div> </div> </div> <div class="sect1"> <h2 id="messaging.kafka">
3. Apache Kafka Support</h2> <div class="sectionbody"> <div class="paragraph"> <p><a href="https://kafka.apache.org/">Apache Kafka</a> is supported by providing auto-configuration of the <code>spring-kafka</code> project.</p> </div> <div class="paragraph"> <p>Kafka configuration is controlled by external configuration properties in <code>spring.kafka.*</code>. For example, you might declare the following section in <code>application.properties</code>:</p> </div> <div class="listingblock primary"> <div class="title">Properties</div> <div class="content"> <pre class="highlight" data-language="properties"><code class="language-properties" data-lang="properties">spring.kafka.bootstrap-servers=localhost:9092
spring.kafka.consumer.group-id=myGroup</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Yaml</div> <div class="content"> <pre class="highlight" data-language="yaml"><code class="language-yaml" data-lang="yaml">spring:
  kafka:
    bootstrap-servers: "localhost:9092"
    consumer:
      group-id: "myGroup"</code></pre> </div> </div> <div class="admonitionblock tip"> <table> <tr> <td class="icon">  </td> <td class="content"> To create a topic on startup, add a bean of type <code>NewTopic</code>. If the topic already exists, the bean is ignored. </td> </tr> </table> </div> <div class="paragraph"> <p>See <a href="https://github.com/spring-projects/spring-boot/tree/v3.1.3/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/kafka/KafkaProperties.java"><code>KafkaProperties</code></a> for more supported options.</p> </div> <div class="sect2"> <h3 id="messaging.kafka.sending">
3.1. Sending a Message</h3> <div class="paragraph"> <p>Spring’s <code>KafkaTemplate</code> is auto-configured, and you can autowire it directly in your own beans, as shown in the following example:</p> </div> <div class="listingblock primary"> <div class="title">Java</div> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Component;

</span><span class="fold-block">@Component
public class MyBean {

    private final KafkaTemplate&lt;String, String&gt; kafkaTemplate;

    public MyBean(KafkaTemplate&lt;String, String&gt; kafkaTemplate) {
        this.kafkaTemplate = kafkaTemplate;
    }

</span><span class="fold-block hide-when-unfolded">    // ...

</span><span class="fold-block hide-when-folded">    public void someMethod() {
        this.kafkaTemplate.send("someTopic", "Hello");
    }

</span><span class="fold-block">}
</span></code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Kotlin</div> <div class="content"> <pre class="highlight" data-language="kotlin"><code class="language-kotlin" data-lang="kotlin"><span class="fold-block hide-when-folded">import org.springframework.kafka.core.KafkaTemplate
import org.springframework.stereotype.Component

</span><span class="fold-block">@Component
class MyBean(private val kafkaTemplate: KafkaTemplate&lt;String, String&gt;) {

</span><span class="fold-block hide-when-unfolded">    // ...

</span><span class="fold-block hide-when-folded">    fun someMethod() {
        kafkaTemplate.send("someTopic", "Hello")
    }

</span><span class="fold-block">}
</span></code></pre> </div> </div> <div class="admonitionblock note"> <table> <tr> <td class="icon">  </td> <td class="content"> If the property <code>spring.kafka.producer.transaction-id-prefix</code> is defined, a <code>KafkaTransactionManager</code> is automatically configured. Also, if a <code>RecordMessageConverter</code> bean is defined, it is automatically associated to the auto-configured <code>KafkaTemplate</code>. </td> </tr> </table> </div> </div> <div class="sect2"> <h3 id="messaging.kafka.receiving">
3.2. Receiving a Message</h3> <div class="paragraph"> <p>When the Apache Kafka infrastructure is present, any bean can be annotated with <code>@KafkaListener</code> to create a listener endpoint. If no <code>KafkaListenerContainerFactory</code> has been defined, a default one is automatically configured with keys defined in <code>spring.kafka.listener.*</code>.</p> </div> <div class="paragraph"> <p>The following component creates a listener endpoint on the <code>someTopic</code> topic:</p> </div> <div class="listingblock primary"> <div class="title">Java</div> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.stereotype.Component;

</span><span class="fold-block">@Component
public class MyBean {

    @KafkaListener(topics = "someTopic")
    public void processMessage(String content) {
        // ...
    }

}
</span></code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Kotlin</div> <div class="content"> <pre class="highlight" data-language="kotlin"><code class="language-kotlin" data-lang="kotlin"><span class="fold-block hide-when-folded">import org.springframework.kafka.annotation.KafkaListener
import org.springframework.stereotype.Component

</span><span class="fold-block">@Component
class MyBean {

    @KafkaListener(topics = ["someTopic"])
    fun processMessage(content: String?) {
        // ...
    }

}
</span></code></pre> </div> </div> <div class="paragraph"> <p>If a <code>KafkaTransactionManager</code> bean is defined, it is automatically associated to the container factory. Similarly, if a <code>RecordFilterStrategy</code>, <code>CommonErrorHandler</code>, <code>AfterRollbackProcessor</code> or <code>ConsumerAwareRebalanceListener</code> bean is defined, it is automatically associated to the default factory.</p> </div> <div class="paragraph"> <p>Depending on the listener type, a <code>RecordMessageConverter</code> or <code>BatchMessageConverter</code> bean is associated to the default factory. If only a <code>RecordMessageConverter</code> bean is present for a batch listener, it is wrapped in a <code>BatchMessageConverter</code>.</p> </div> <div class="admonitionblock tip"> <table> <tr> <td class="icon">  </td> <td class="content"> A custom <code>ChainedKafkaTransactionManager</code> must be marked <code>@Primary</code> as it usually references the auto-configured <code>KafkaTransactionManager</code> bean. </td> </tr> </table> </div> </div> <div class="sect2"> <h3 id="messaging.kafka.streams">
3.3. Kafka Streams</h3> <div class="paragraph"> <p>Spring for Apache Kafka provides a factory bean to create a <code>StreamsBuilder</code> object and manage the lifecycle of its streams. Spring Boot auto-configures the required <code>KafkaStreamsConfiguration</code> bean as long as <code>kafka-streams</code> is on the classpath and Kafka Streams is enabled by the <code>@EnableKafkaStreams</code> annotation.</p> </div> <div class="paragraph"> <p>Enabling Kafka Streams means that the application id and bootstrap servers must be set. The former can be configured using <code>spring.kafka.streams.application-id</code>, defaulting to <code>spring.application.name</code> if not set. The latter can be set globally or specifically overridden only for streams.</p> </div> <div class="paragraph"> <p>Several additional properties are available using dedicated properties; other arbitrary Kafka properties can be set using the <code>spring.kafka.streams.properties</code> namespace. See also <a href="#messaging.kafka.additional-properties">Additional Kafka Properties</a> for more information.</p> </div> <div class="paragraph"> <p>To use the factory bean, wire <code>StreamsBuilder</code> into your <code>@Bean</code> as shown in the following example:</p> </div> <div class="listingblock primary"> <div class="title">Java</div> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import org.apache.kafka.common.serialization.Serdes;
import org.apache.kafka.streams.KeyValue;
import org.apache.kafka.streams.StreamsBuilder;
import org.apache.kafka.streams.kstream.KStream;
import org.apache.kafka.streams.kstream.Produced;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.kafka.annotation.EnableKafkaStreams;
import org.springframework.kafka.support.serializer.JsonSerde;

</span><span class="fold-block">@Configuration(proxyBeanMethods = false)
@EnableKafkaStreams
public class MyKafkaStreamsConfiguration {

    @Bean
    public KStream&lt;Integer, String&gt; kStream(StreamsBuilder streamsBuilder) {
        KStream&lt;Integer, String&gt; stream = streamsBuilder.stream("ks1In");
        stream.map(this::uppercaseValue).to("ks1Out", Produced.with(Serdes.Integer(), new JsonSerde&lt;&gt;()));
        return stream;
    }

    private KeyValue&lt;Integer, String&gt; uppercaseValue(Integer key, String value) {
        return new KeyValue&lt;&gt;(key, value.toUpperCase());
    }

}
</span></code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Kotlin</div> <div class="content"> <pre class="highlight" data-language="kotlin"><code class="language-kotlin" data-lang="kotlin"><span class="fold-block hide-when-folded">import org.apache.kafka.common.serialization.Serdes
import org.apache.kafka.streams.KeyValue
import org.apache.kafka.streams.StreamsBuilder
import org.apache.kafka.streams.kstream.KStream
import org.apache.kafka.streams.kstream.Produced
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.kafka.annotation.EnableKafkaStreams
import org.springframework.kafka.support.serializer.JsonSerde

</span><span class="fold-block">@Configuration(proxyBeanMethods = false)
@EnableKafkaStreams
class MyKafkaStreamsConfiguration {

    @Bean
    fun kStream(streamsBuilder: StreamsBuilder): KStream&lt;Int, String&gt; {
        val stream = streamsBuilder.stream&lt;Int, String&gt;("ks1In")
        stream.map(this::uppercaseValue).to("ks1Out", Produced.with(Serdes.Integer(), JsonSerde()))
        return stream
    }

    private fun uppercaseValue(key: Int, value: String): KeyValue&lt;Int?, String?&gt; {
        return KeyValue(key, value.uppercase())
    }

}
</span></code></pre> </div> </div> <div class="paragraph"> <p>By default, the streams managed by the <code>StreamBuilder</code> object are started automatically. You can customize this behavior using the <code>spring.kafka.streams.auto-startup</code> property.</p> </div> </div> <div class="sect2"> <h3 id="messaging.kafka.additional-properties">
3.4. Additional Kafka Properties</h3> <div class="paragraph"> <p>The properties supported by auto configuration are shown in the <a href="application-properties.html#appendix.application-properties.integration">“Integration Properties”</a> section of the Appendix. Note that, for the most part, these properties (hyphenated or camelCase) map directly to the Apache Kafka dotted properties. See the Apache Kafka documentation for details.</p> </div> <div class="paragraph"> <p>Properties that don’t include a client type (<code>producer</code>, <code>consumer</code>, <code>admin</code>, or <code>streams</code>) in their name are considered to be common and apply to all clients. Most of these common properties can be overridden for one or more of the client types, if needed.</p> </div> <div class="paragraph"> <p>Apache Kafka designates properties with an importance of HIGH, MEDIUM, or LOW. Spring Boot auto-configuration supports all HIGH importance properties, some selected MEDIUM and LOW properties, and any properties that do not have a default value.</p> </div> <div class="paragraph"> <p>Only a subset of the properties supported by Kafka are available directly through the <code>KafkaProperties</code> class. If you wish to configure the individual client types with additional properties that are not directly supported, use the following properties:</p> </div> <div class="listingblock primary"> <div class="title">Properties</div> <div class="content"> <pre class="highlight" data-language="properties"><code class="language-properties" data-lang="properties">spring.kafka.properties[prop.one]=first
spring.kafka.admin.properties[prop.two]=second
spring.kafka.consumer.properties[prop.three]=third
spring.kafka.producer.properties[prop.four]=fourth
spring.kafka.streams.properties[prop.five]=fifth</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Yaml</div> <div class="content"> <pre class="highlight" data-language="yaml"><code class="language-yaml" data-lang="yaml">spring:
  kafka:
    properties:
      "[prop.one]": "first"
    admin:
      properties:
        "[prop.two]": "second"
    consumer:
      properties:
        "[prop.three]": "third"
    producer:
      properties:
        "[prop.four]": "fourth"
    streams:
      properties:
        "[prop.five]": "fifth"</code></pre> </div> </div> <div class="paragraph"> <p>This sets the common <code>prop.one</code> Kafka property to <code>first</code> (applies to producers, consumers, admins, and streams), the <code>prop.two</code> admin property to <code>second</code>, the <code>prop.three</code> consumer property to <code>third</code>, the <code>prop.four</code> producer property to <code>fourth</code> and the <code>prop.five</code> streams property to <code>fifth</code>.</p> </div> <div class="paragraph"> <p>You can also configure the Spring Kafka <code>JsonDeserializer</code> as follows:</p> </div> <div class="listingblock primary"> <div class="title">Properties</div> <div class="content"> <pre class="highlight" data-language="properties"><code class="language-properties" data-lang="properties">spring.kafka.consumer.value-deserializer=org.springframework.kafka.support.serializer.JsonDeserializer
spring.kafka.consumer.properties[spring.json.value.default.type]=com.example.Invoice
spring.kafka.consumer.properties[spring.json.trusted.packages]=com.example.main,com.example.another</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Yaml</div> <div class="content"> <pre class="highlight" data-language="yaml"><code class="language-yaml" data-lang="yaml">spring:
  kafka:
    consumer:
      value-deserializer: "org.springframework.kafka.support.serializer.JsonDeserializer"
      properties:
        "[spring.json.value.default.type]": "com.example.Invoice"
        "[spring.json.trusted.packages]": "com.example.main,com.example.another"</code></pre> </div> </div> <div class="paragraph"> <p>Similarly, you can disable the <code>JsonSerializer</code> default behavior of sending type information in headers:</p> </div> <div class="listingblock primary"> <div class="title">Properties</div> <div class="content"> <pre class="highlight" data-language="properties"><code class="language-properties" data-lang="properties">spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer
spring.kafka.producer.properties[spring.json.add.type.headers]=false</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Yaml</div> <div class="content"> <pre class="highlight" data-language="yaml"><code class="language-yaml" data-lang="yaml">spring:
  kafka:
    producer:
      value-serializer: "org.springframework.kafka.support.serializer.JsonSerializer"
      properties:
        "[spring.json.add.type.headers]": false</code></pre> </div> </div> <div class="admonitionblock important"> <table> <tr> <td class="icon">  </td> <td class="content"> Properties set in this way override any configuration item that Spring Boot explicitly supports. </td> </tr> </table> </div> </div> <div class="sect2"> <h3 id="messaging.kafka.embedded">
3.5. Testing with Embedded Kafka</h3> <div class="paragraph"> <p>Spring for Apache Kafka provides a convenient way to test projects with an embedded Apache Kafka broker. To use this feature, annotate a test class with <code>@EmbeddedKafka</code> from the <code>spring-kafka-test</code> module. For more information, please see the Spring for Apache Kafka <a href="https://docs.spring.io/spring-kafka/docs/3.0.10/reference/html/#embedded-kafka-annotation">reference manual</a>.</p> </div> <div class="paragraph"> <p>To make Spring Boot auto-configuration work with the aforementioned embedded Apache Kafka broker, you need to remap a system property for embedded broker addresses (populated by the <code>EmbeddedKafkaBroker</code>) into the Spring Boot configuration property for Apache Kafka. There are several ways to do that:</p> </div> <div class="ulist"> <ul> <li> <p>Provide a system property to map embedded broker addresses into <code>spring.kafka.bootstrap-servers</code> in the test class:</p> </li> </ul> </div> <div class="listingblock primary"> <div class="title">Java</div> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java">static {
    System.setProperty(EmbeddedKafkaBroker.BROKER_LIST_PROPERTY, "spring.kafka.bootstrap-servers");
}
</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Kotlin</div> <div class="content"> <pre class="highlight" data-language="kotlin"><code class="language-kotlin" data-lang="kotlin">init {
    System.setProperty(EmbeddedKafkaBroker.BROKER_LIST_PROPERTY, "spring.kafka.bootstrap-servers")
}
</code></pre> </div> </div> <div class="ulist"> <ul> <li> <p>Configure a property name on the <code>@EmbeddedKafka</code> annotation:</p> </li> </ul> </div> <div class="listingblock primary"> <div class="title">Java</div> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.kafka.test.context.EmbeddedKafka;

</span><span class="fold-block">@SpringBootTest
@EmbeddedKafka(topics = "someTopic", bootstrapServersProperty = "spring.kafka.bootstrap-servers")
class MyTest {

    // ...

}
</span></code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Kotlin</div> <div class="content"> <pre class="highlight" data-language="kotlin"><code class="language-kotlin" data-lang="kotlin"><span class="fold-block hide-when-folded">import org.springframework.boot.test.context.SpringBootTest
import org.springframework.kafka.test.context.EmbeddedKafka

</span><span class="fold-block">@SpringBootTest
@EmbeddedKafka(topics = ["someTopic"], bootstrapServersProperty = "spring.kafka.bootstrap-servers")
class MyTest {

    // ...

}
</span></code></pre> </div> </div> <div class="ulist"> <ul> <li> <p>Use a placeholder in configuration properties:</p> </li> </ul> </div> <div class="listingblock primary"> <div class="title">Properties</div> <div class="content"> <pre class="highlight" data-language="properties"><code class="language-properties" data-lang="properties">spring.kafka.bootstrap-servers=${spring.embedded.kafka.brokers}</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Yaml</div> <div class="content"> <pre class="highlight" data-language="yaml"><code class="language-yaml" data-lang="yaml">spring:
  kafka:
    bootstrap-servers: "${spring.embedded.kafka.brokers}"</code></pre> </div> </div> </div> </div> </div> <div class="sect1"> <h2 id="messaging.rsocket">
4. RSocket</h2> <div class="sectionbody"> <div class="paragraph"> <p><a href="https://rsocket.io">RSocket</a> is a binary protocol for use on byte stream transports. It enables symmetric interaction models through async message passing over a single connection.</p> </div> <div class="paragraph"> <p>The <code>spring-messaging</code> module of the Spring Framework provides support for RSocket requesters and responders, both on the client and on the server side. See the <a href="https://docs.spring.io/spring-framework/docs/6.0.11/reference/html/web-reactive.html#rsocket-spring">RSocket section</a> of the Spring Framework reference for more details, including an overview of the RSocket protocol.</p> </div> <div class="sect2"> <h3 id="messaging.rsocket.strategies-auto-configuration">
4.1. RSocket Strategies Auto-configuration</h3> <div class="paragraph"> <p>Spring Boot auto-configures an <code>RSocketStrategies</code> bean that provides all the required infrastructure for encoding and decoding RSocket payloads. By default, the auto-configuration will try to configure the following (in order):</p> </div> <div class="olist arabic"> <ol class="arabic"> <li> <p><a href="https://cbor.io/">CBOR</a> codecs with Jackson</p> </li> <li> <p>JSON codecs with Jackson</p> </li> </ol> </div> <div class="paragraph"> <p>The <code>spring-boot-starter-rsocket</code> starter provides both dependencies. See the <a href="features.html#features.json.jackson">Jackson support section</a> to know more about customization possibilities.</p> </div> <div class="paragraph"> <p>Developers can customize the <code>RSocketStrategies</code> component by creating beans that implement the <code>RSocketStrategiesCustomizer</code> interface. Note that their <code>@Order</code> is important, as it determines the order of codecs.</p> </div> </div> <div class="sect2"> <h3 id="messaging.rsocket.server-auto-configuration">
4.2. RSocket server Auto-configuration</h3> <div class="paragraph"> <p>Spring Boot provides RSocket server auto-configuration. The required dependencies are provided by the <code>spring-boot-starter-rsocket</code>.</p> </div> <div class="paragraph"> <p>Spring Boot allows exposing RSocket over WebSocket from a WebFlux server, or standing up an independent RSocket server. This depends on the type of application and its configuration.</p> </div> <div class="paragraph"> <p>For WebFlux application (that is of type <code>WebApplicationType.REACTIVE</code>), the RSocket server will be plugged into the Web Server only if the following properties match:</p> </div> <div class="listingblock primary"> <div class="title">Properties</div> <div class="content"> <pre class="highlight" data-language="properties"><code class="language-properties" data-lang="properties">spring.rsocket.server.mapping-path=/rsocket
spring.rsocket.server.transport=websocket</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Yaml</div> <div class="content"> <pre class="highlight" data-language="yaml"><code class="language-yaml" data-lang="yaml">spring:
  rsocket:
    server:
      mapping-path: "/rsocket"
      transport: "websocket"</code></pre> </div> </div> <div class="admonitionblock warning"> <table> <tr> <td class="icon">  </td> <td class="content"> Plugging RSocket into a web server is only supported with Reactor Netty, as RSocket itself is built with that library. </td> </tr> </table> </div> <div class="paragraph"> <p>Alternatively, an RSocket TCP or websocket server is started as an independent, embedded server. Besides the dependency requirements, the only required configuration is to define a port for that server:</p> </div> <div class="listingblock primary"> <div class="title">Properties</div> <div class="content"> <pre class="highlight" data-language="properties"><code class="language-properties" data-lang="properties">spring.rsocket.server.port=9898</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Yaml</div> <div class="content"> <pre class="highlight" data-language="yaml"><code class="language-yaml" data-lang="yaml">spring:
  rsocket:
    server:
      port: 9898</code></pre> </div> </div> </div> <div class="sect2"> <h3 id="messaging.rsocket.messaging">
4.3. Spring Messaging RSocket support</h3> <div class="paragraph"> <p>Spring Boot will auto-configure the Spring Messaging infrastructure for RSocket.</p> </div> <div class="paragraph"> <p>This means that Spring Boot will create a <code>RSocketMessageHandler</code> bean that will handle RSocket requests to your application.</p> </div> </div> <div class="sect2"> <h3 id="messaging.rsocket.requester">
4.4. Calling RSocket Services with RSocketRequester</h3> <div class="paragraph"> <p>Once the <code>RSocket</code> channel is established between server and client, any party can send or receive requests to the other.</p> </div> <div class="paragraph"> <p>As a server, you can get injected with an <code>RSocketRequester</code> instance on any handler method of an RSocket <code>@Controller</code>. As a client, you need to configure and establish an RSocket connection first. Spring Boot auto-configures an <code>RSocketRequester.Builder</code> for such cases with the expected codecs and applies any <code>RSocketConnectorConfigurer</code> bean.</p> </div> <div class="paragraph"> <p>The <code>RSocketRequester.Builder</code> instance is a prototype bean, meaning each injection point will provide you with a new instance . This is done on purpose since this builder is stateful and you should not create requesters with different setups using the same instance.</p> </div> <div class="paragraph"> <p>The following code shows a typical example:</p> </div> <div class="listingblock primary"> <div class="title">Java</div> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import reactor.core.publisher.Mono;

import org.springframework.messaging.rsocket.RSocketRequester;
import org.springframework.stereotype.Service;

</span><span class="fold-block">@Service
public class MyService {

    private final RSocketRequester rsocketRequester;

    public MyService(RSocketRequester.Builder rsocketRequesterBuilder) {
        this.rsocketRequester = rsocketRequesterBuilder.tcp("example.org", 9898);
    }

    public Mono&lt;User&gt; someRSocketCall(String name) {
        return this.rsocketRequester.route("user").data(name).retrieveMono(User.class);
    }

}
</span></code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Kotlin</div> <div class="content"> <pre class="highlight" data-language="kotlin"><code class="language-kotlin" data-lang="kotlin"><span class="fold-block hide-when-folded">import org.springframework.messaging.rsocket.RSocketRequester
import org.springframework.stereotype.Service
import reactor.core.publisher.Mono

</span><span class="fold-block">@Service
class MyService(rsocketRequesterBuilder: RSocketRequester.Builder) {

    private val rsocketRequester: RSocketRequester

    init {
        rsocketRequester = rsocketRequesterBuilder.tcp("example.org", 9898)
    }

    fun someRSocketCall(name: String): Mono&lt;User&gt; {
        return rsocketRequester.route("user").data(name).retrieveMono(
            User::class.java
        )
    }

}
</span></code></pre> </div> </div> </div> </div> </div> <div class="sect1"> <h2 id="messaging.spring-integration">
5. Spring Integration</h2> <div class="sectionbody"> <div class="paragraph"> <p>Spring Boot offers several conveniences for working with <a href="https://spring.io/projects/spring-integration">Spring Integration</a>, including the <code>spring-boot-starter-integration</code> “Starter”. Spring Integration provides abstractions over messaging and also other transports such as HTTP, TCP, and others. If Spring Integration is available on your classpath, it is initialized through the <code>@EnableIntegration</code> annotation.</p> </div> <div class="paragraph"> <p>Spring Integration polling logic relies <a href="features.html#features.task-execution-and-scheduling">on the auto-configured <code>TaskScheduler</code></a>. The default <code>PollerMetadata</code> (poll unbounded number of messages every second) can be customized with <code>spring.integration.poller.*</code> configuration properties.</p> </div> <div class="paragraph"> <p>Spring Boot also configures some features that are triggered by the presence of additional Spring Integration modules. If <code>spring-integration-jmx</code> is also on the classpath, message processing statistics are published over JMX. If <code>spring-integration-jdbc</code> is available, the default database schema can be created on startup, as shown in the following line:</p> </div> <div class="listingblock primary"> <div class="title">Properties</div> <div class="content"> <pre class="highlight" data-language="properties"><code class="language-properties" data-lang="properties">spring.integration.jdbc.initialize-schema=always</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Yaml</div> <div class="content"> <pre class="highlight" data-language="yaml"><code class="language-yaml" data-lang="yaml">spring:
  integration:
    jdbc:
      initialize-schema: "always"</code></pre> </div> </div> <div class="paragraph"> <p>If <code>spring-integration-rsocket</code> is available, developers can configure an RSocket server using <code>"spring.rsocket.server.*"</code> properties and let it use <code>IntegrationRSocketEndpoint</code> or <code>RSocketOutboundGateway</code> components to handle incoming RSocket messages. This infrastructure can handle Spring Integration RSocket channel adapters and <code>@MessageMapping</code> handlers (given <code>"spring.integration.rsocket.server.message-mapping-enabled"</code> is configured).</p> </div> <div class="paragraph"> <p>Spring Boot can also auto-configure an <code>ClientRSocketConnector</code> using configuration properties:</p> </div> <div class="listingblock primary"> <div class="title">Properties</div> <div class="content"> <pre class="highlight" data-language="properties"><code class="language-properties" data-lang="properties"># Connecting to a RSocket server over TCP
spring.integration.rsocket.client.host=example.org
spring.integration.rsocket.client.port=9898</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Yaml</div> <div class="content"> <pre class="highlight" data-language="yaml"><code class="language-yaml" data-lang="yaml"># Connecting to a RSocket server over TCP
spring:
  integration:
    rsocket:
      client:
        host: "example.org"
        port: 9898</code></pre> </div> </div> <div class="listingblock primary"> <div class="title">Properties</div> <div class="content"> <pre class="highlight" data-language="properties"><code class="language-properties" data-lang="properties"># Connecting to a RSocket Server over WebSocket
spring.integration.rsocket.client.uri=ws://example.org</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Yaml</div> <div class="content"> <pre class="highlight" data-language="yaml"><code class="language-yaml" data-lang="yaml"># Connecting to a RSocket Server over WebSocket
spring:
  integration:
    rsocket:
      client:
        uri: "ws://example.org"</code></pre> </div> </div> <div class="paragraph"> <p>See the <a href="https://github.com/spring-projects/spring-boot/tree/v3.1.3/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/integration/IntegrationAutoConfiguration.java"><code>IntegrationAutoConfiguration</code></a> and <a href="https://github.com/spring-projects/spring-boot/tree/v3.1.3/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/integration/IntegrationProperties.java"><code>IntegrationProperties</code></a> classes for more details.</p> </div> </div> </div> <div class="sect1"> <h2 id="messaging.websockets">
6. WebSockets</h2> <div class="sectionbody"> <div class="paragraph"> <p>Spring Boot provides WebSockets auto-configuration for embedded Tomcat, Jetty, and Undertow. If you deploy a war file to a standalone container, Spring Boot assumes that the container is responsible for the configuration of its WebSocket support.</p> </div> <div class="paragraph"> <p>Spring Framework provides <a href="https://docs.spring.io/spring-framework/docs/6.0.11/reference/html/web.html#websocket">rich WebSocket support</a> for MVC web applications that can be easily accessed through the <code>spring-boot-starter-websocket</code> module.</p> </div> <div class="paragraph"> <p>WebSocket support is also available for <a href="https://docs.spring.io/spring-framework/docs/6.0.11/reference/html/web-reactive.html#webflux-websocket">reactive web applications</a> and requires to include the WebSocket API alongside <code>spring-boot-starter-webflux</code>:</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlight" data-language="xml"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;jakarta.websocket&lt;/groupId&gt;
    &lt;artifactId&gt;jakarta.websocket-api&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre> </div> </div> </div> </div> <div class="sect1"> <h2 id="messaging.whats-next">
7. What to Read Next</h2> <div class="sectionbody"> <div class="paragraph"> <p>The next section describes how to enable <a href="io.html#io">IO capabilities</a> in your application. You can read about <a href="io.html#io.caching">caching</a>, <a href="io.html#io.email">mail</a>, <a href="io.html#io.validation">validation</a>, <a href="io.html#io.rest-client">rest clients</a> and more in this section.</p> </div> </div> </div><div class="_attribution">
  <p class="_attribution-p">
    Copyright &copy; 2012-2023 VMware, Inc.<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://docs.spring.io/spring-boot/docs/3.1.3/reference/html/messaging.html" class="_attribution-link">https://docs.spring.io/spring-boot/docs/3.1.3/reference/html/messaging.html</a>
  </p>
</div>
