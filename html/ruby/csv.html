<h1 id="class-CSV" class="class"> class CSV </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent"><a href="object.html">Object</a></dd>
<dt>Included modules:</dt>
<dd class="meta-includes"><a class="include" href="enumerable.html">Enumerable</a></dd>
</dl> <section class="description"> <h2 id="class-CSV-label-CSV">CSV</h2> <h3 id="class-CSV-label-CSV+Data">CSV </h3> <p>CSV (comma-separated values) data is a text representation of a table:</p> <ul>
<li> <p>A <em>row</em> <em>separator</em> delimits table rows. A common row separator is the newline character <code>"\n"</code>.</p> </li>
<li> <p>A <em>column</em> <em>separator</em> delimits fields in a row. A common column separator is the comma character <code>","</code>.</p> </li>
</ul> <p>This CSV String, with row separator <code>"\n"</code> and column separator <code>","</code>, has three rows and two columns:</p> <pre class="ruby" data-language="ruby">"foo,0\nbar,1\nbaz,2\n"
</pre> <p>Despite the name CSV, a CSV representation can use different separators.</p> <p>For more about tables, see the Wikipedia article “<a href="https://en.wikipedia.org/wiki/Table_(information)">Table (information)</a>”, especially its section “<a href="https://en.wikipedia.org/wiki/Table_(information)#Simple_table">Simple table</a>”</p> <h2 id="class-CSV-label-Class+CSV">Class CSV</h2> <p><a href="class.html"><code>Class</code></a> CSV provides methods for:</p> <ul>
<li> <p>Parsing CSV data from a String object, a File (via its file path), or an IO object.</p> </li>
<li> <p>Generating CSV data to a String object.</p> </li>
</ul> <p>To make CSV available:</p> <pre class="ruby" data-language="ruby">require 'csv'
</pre> <p>All examples here assume that this has been done.</p> <h2 id="class-CSV-label-Keeping+It+Simple">Keeping It Simple</h2> <p>A CSV object has dozens of instance methods that offer fine-grained control of parsing and generating CSV data. For many needs, though, simpler approaches will do.</p> <p>This section summarizes the singleton methods in CSV that allow you to parse and generate without explicitly creating CSV objects. For details, follow the links.</p> <h3 id="class-CSV-label-Simple+Parsing">Simple Parsing</h3> <p>Parsing methods commonly return either of:</p> <ul>
<li> <p>An Array of Arrays of Strings:</p> <ul>
<li> <p>The outer Array is the entire “table”.</p> </li>
<li> <p>Each inner Array is a row.</p> </li>
<li> <p>Each String is a field.</p> </li>
</ul> </li>
<li> <p>A <a href="csv/table.html"><code>CSV::Table</code></a> object. For details, see <a href="#class-CSV-label-CSV+with+Headers">CSV with Headers</a>.</p> </li>
</ul> <h4 id="class-CSV-label-Parsing+a+String">Parsing a String</h4> <p>The input to be parsed can be a string:</p> <pre class="ruby" data-language="ruby">string = "foo,0\nbar,1\nbaz,2\n"
</pre> <p>Method <a href="csv.html#method-c-parse"><code>CSV.parse</code></a> returns the entire CSV data:</p> <pre class="ruby" data-language="ruby">CSV.parse(string) # =&gt; [["foo", "0"], ["bar", "1"], ["baz", "2"]]
</pre> <p>Method <a href="csv.html#method-c-parse_line"><code>CSV.parse_line</code></a> returns only the first row:</p> <pre class="ruby" data-language="ruby">CSV.parse_line(string) # =&gt; ["foo", "0"]
</pre> <p>CSV extends class String with instance method String#parse_csv, which also returns only the first row:</p> <pre class="ruby" data-language="ruby">string.parse_csv # =&gt; ["foo", "0"]
</pre> <h4 id="class-CSV-label-Parsing+Via+a+File+Path">Parsing Via a File Path</h4> <p>The input to be parsed can be in a file:</p> <pre class="ruby" data-language="ruby">string = "foo,0\nbar,1\nbaz,2\n"
path = 't.csv'
File.write(path, string)
</pre> <p>Method <a href="csv.html#method-c-read"><code>CSV.read</code></a> returns the entire CSV data:</p> <pre class="ruby" data-language="ruby">CSV.read(path) # =&gt; [["foo", "0"], ["bar", "1"], ["baz", "2"]]
</pre> <p>Method <a href="csv.html#method-c-foreach"><code>CSV.foreach</code></a> iterates, passing each row to the given block:</p> <pre class="ruby" data-language="ruby">CSV.foreach(path) do |row|
  p row
end
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">["foo", "0"]
["bar", "1"]
["baz", "2"]
</pre> <p>Method <a href="csv.html#method-c-table"><code>CSV.table</code></a> returns the entire CSV data as a <a href="csv/table.html"><code>CSV::Table</code></a> object:</p> <pre class="ruby" data-language="ruby">CSV.table(path) # =&gt; #&lt;CSV::Table mode:col_or_row row_count:3&gt;
</pre> <h4 id="class-CSV-label-Parsing+from+an+Open+IO+Stream">Parsing from an Open IO Stream</h4> <p>The input to be parsed can be in an open IO stream:</p> <p>Method <a href="csv.html#method-c-read"><code>CSV.read</code></a> returns the entire CSV data:</p> <pre class="ruby" data-language="ruby">File.open(path) do |file|
  CSV.read(file)
end # =&gt; [["foo", "0"], ["bar", "1"], ["baz", "2"]]
</pre> <p>As does method <a href="csv.html#method-c-parse"><code>CSV.parse</code></a>:</p> <pre class="ruby" data-language="ruby">File.open(path) do |file|
  CSV.parse(file)
end # =&gt; [["foo", "0"], ["bar", "1"], ["baz", "2"]]
</pre> <p>Method <a href="csv.html#method-c-parse_line"><code>CSV.parse_line</code></a> returns only the first row:</p> <pre class="ruby" data-language="ruby">File.open(path) do |file|
 CSV.parse_line(file)
end # =&gt; ["foo", "0"]
</pre> <p>Method <a href="csv.html#method-c-foreach"><code>CSV.foreach</code></a> iterates, passing each row to the given block:</p> <pre class="ruby" data-language="ruby">File.open(path) do |file|
  CSV.foreach(file) do |row|
    p row
  end
end
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">["foo", "0"]
["bar", "1"]
["baz", "2"]
</pre> <p>Method <a href="csv.html#method-c-table"><code>CSV.table</code></a> returns the entire CSV data as a <a href="csv/table.html"><code>CSV::Table</code></a> object:</p> <pre class="ruby" data-language="ruby">File.open(path) do |file|
  CSV.table(file)
end # =&gt; #&lt;CSV::Table mode:col_or_row row_count:3&gt;
</pre> <h3 id="class-CSV-label-Simple+Generating">Simple Generating</h3> <p>Method <a href="csv.html#method-c-generate"><code>CSV.generate</code></a> returns a String; this example uses method <a href="csv.html#method-i-3C-3C"><code>CSV#&lt;&lt;</code></a> to append the rows that are to be generated:</p> <pre class="ruby" data-language="ruby">output_string = CSV.generate do |csv|
  csv &lt;&lt; ['foo', 0]
  csv &lt;&lt; ['bar', 1]
  csv &lt;&lt; ['baz', 2]
end
output_string # =&gt; "foo,0\nbar,1\nbaz,2\n"
</pre> <p>Method <a href="csv.html#method-c-generate_line"><code>CSV.generate_line</code></a> returns a String containing the single row constructed from an Array:</p> <pre class="ruby" data-language="ruby">CSV.generate_line(['foo', '0']) # =&gt; "foo,0\n"
</pre> <p>CSV extends class Array with instance method <code>Array#to_csv</code>, which forms an Array into a String:</p> <pre class="ruby" data-language="ruby">['foo', '0'].to_csv # =&gt; "foo,0\n"
</pre> <h3 id="class-CSV-label-22Filtering-22+CSV">“Filtering” CSV</h3> <p>Method <a href="csv.html#method-c-filter"><code>CSV.filter</code></a> provides a Unix-style filter for CSV data. The input data is processed to form the output data:</p> <pre class="ruby" data-language="ruby">in_string = "foo,0\nbar,1\nbaz,2\n"
out_string = ''
CSV.filter(in_string, out_string) do |row|
  row[0] = row[0].upcase
  row[1] *= 4
end
out_string # =&gt; "FOO,0000\nBAR,1111\nBAZ,2222\n"
</pre> <h2 id="class-CSV-label-CSV+Objects">CSV Objects</h2> <p>There are three ways to create a CSV object:</p> <ul>
<li> <p>Method <a href="csv.html#method-c-new"><code>CSV.new</code></a> returns a new CSV object.</p> </li>
<li> <p>Method <a href="csv.html#method-c-instance"><code>CSV.instance</code></a> returns a new or cached CSV object.</p> </li>
<li> <p>Method CSV() also returns a new or cached CSV object.</p> </li>
</ul> <h3 id="class-CSV-label-Instance+Methods">Instance Methods</h3> <p>CSV has three groups of instance methods:</p> <ul>
<li> <p>Its own internally defined instance methods.</p> </li>
<li> <p>Methods included by module <a href="enumerable.html"><code>Enumerable</code></a>.</p> </li>
<li> <p>Methods delegated to class <a href="io.html"><code>IO</code></a>. See below.</p> </li>
</ul> <h4 id="class-CSV-label-Delegated+Methods">Delegated Methods</h4> <p>For convenience, a <a href="csv.html"><code>CSV</code></a> object will delegate to many methods in class <a href="io.html"><code>IO</code></a>. (A few have wrapper “guard code” in CSV.) You may call:</p> <ul>
<li> <p><a href="io.html#method-i-binmode"><code>IO#binmode</code></a></p> </li>
<li> <p><a href="csv.html#method-i-binmode-3F"><code>binmode?</code></a></p> </li>
<li> <p><a href="io.html#method-i-close"><code>IO#close</code></a></p> </li>
<li> <p><a href="io.html#method-i-close_read"><code>IO#close_read</code></a></p> </li>
<li> <p><a href="io.html#method-i-close_write"><code>IO#close_write</code></a></p> </li>
<li> <p><a href="io.html#method-i-closed-3F"><code>IO#closed?</code></a></p> </li>
<li> <p><a href="csv.html#method-i-eof"><code>eof</code></a></p> </li>
<li> <p><a href="csv.html#method-i-eof-3F"><code>eof?</code></a></p> </li>
<li> <p><a href="io.html#method-i-external_encoding"><code>IO#external_encoding</code></a></p> </li>
<li> <p><a href="io.html#method-i-fcntl"><code>IO#fcntl</code></a></p> </li>
<li> <p><a href="io.html#method-i-fileno"><code>IO#fileno</code></a></p> </li>
<li> <p><a href="csv.html#method-i-flock"><code>flock</code></a></p> </li>
<li> <p><a href="io.html#method-i-flush"><code>IO#flush</code></a></p> </li>
<li> <p><a href="io.html#method-i-fsync"><code>IO#fsync</code></a></p> </li>
<li> <p><a href="io.html#method-i-internal_encoding"><code>IO#internal_encoding</code></a></p> </li>
<li> <p><a href="csv.html#method-i-ioctl"><code>ioctl</code></a></p> </li>
<li> <p><a href="io.html#method-i-isatty"><code>IO#isatty</code></a></p> </li>
<li> <p><a href="csv.html#method-i-path"><code>path</code></a></p> </li>
<li> <p><a href="io.html#method-i-pid"><code>IO#pid</code></a></p> </li>
<li> <p><a href="io.html#method-i-pos"><code>IO#pos</code></a></p> </li>
<li> <p><a href="io.html#method-i-pos-3D"><code>IO#pos=</code></a></p> </li>
<li> <p><a href="io.html#method-i-reopen"><code>IO#reopen</code></a></p> </li>
<li> <p><a href="csv.html#method-i-rewind"><code>rewind</code></a></p> </li>
<li> <p><a href="io.html#method-i-seek"><code>IO#seek</code></a></p> </li>
<li> <p><a href="csv.html#method-i-stat"><code>stat</code></a></p> </li>
<li> <p>IO#string</p> </li>
<li> <p><a href="io.html#method-i-sync"><code>IO#sync</code></a></p> </li>
<li> <p><a href="io.html#method-i-sync-3D"><code>IO#sync=</code></a></p> </li>
<li> <p><a href="io.html#method-i-tell"><code>IO#tell</code></a></p> </li>
<li> <p><a href="csv.html#method-i-to_i"><code>to_i</code></a></p> </li>
<li> <p><a href="csv.html#method-i-to_io"><code>to_io</code></a></p> </li>
<li> <p>IO#truncate</p> </li>
<li> <p><a href="io.html#method-i-tty-3F"><code>IO#tty?</code></a></p> </li>
</ul> <h3 id="class-CSV-label-Options">Options</h3> <p>The default values for options are:</p> <pre class="ruby" data-language="ruby">DEFAULT_OPTIONS = {
  # For both parsing and generating.
  col_sep:            ",",
  row_sep:            :auto,
  quote_char:         '"',
  # For parsing.
  field_size_limit:   nil,
  converters:         nil,
  unconverted_fields: nil,
  headers:            false,
  return_headers:     false,
  header_converters:  nil,
  skip_blanks:        false,
  skip_lines:         nil,
  liberal_parsing:    false,
  nil_value:          nil,
  empty_value:        "",
  strip:              false,
  # For generating.
  write_headers:      nil,
  quote_empty:        true,
  force_quotes:       false,
  write_converters:   nil,
  write_nil_value:    nil,
  write_empty_value:  "",
}
</pre> <h4 id="class-CSV-label-Options+for+Parsing">Options for Parsing</h4> <p>Options for parsing, described in detail below, include:</p> <ul>
<li> <p><code>row_sep</code>: Specifies the row separator; used to delimit rows.</p> </li>
<li> <p><code>col_sep</code>: Specifies the column separator; used to delimit fields.</p> </li>
<li> <p><code>quote_char</code>: Specifies the quote character; used to quote fields.</p> </li>
<li> <p><code>field_size_limit</code>: Specifies the maximum field size + 1 allowed. Deprecated since 3.2.3. Use <code>max_field_size</code> instead.</p> </li>
<li> <p><code>max_field_size</code>: Specifies the maximum field size allowed.</p> </li>
<li> <p><code>converters</code>: Specifies the field converters to be used.</p> </li>
<li> <p><code>unconverted_fields</code>: Specifies whether unconverted fields are to be available.</p> </li>
<li> <p><code>headers</code>: Specifies whether data contains headers, or specifies the headers themselves.</p> </li>
<li> <p><code>return_headers</code>: Specifies whether headers are to be returned.</p> </li>
<li> <p><code>header_converters</code>: Specifies the header converters to be used.</p> </li>
<li> <p><code>skip_blanks</code>: Specifies whether blanks lines are to be ignored.</p> </li>
<li> <p><code>skip_lines</code>: Specifies how comments lines are to be recognized.</p> </li>
<li> <p><code>strip</code>: Specifies whether leading and trailing whitespace are to be stripped from fields. This must be compatible with <code>col_sep</code>; if it is not, then an <code>ArgumentError</code> exception will be raised.</p> </li>
<li> <p><code>liberal_parsing</code>: Specifies whether CSV should attempt to parse non-compliant data.</p> </li>
<li> <p><code>nil_value</code>: Specifies the object that is to be substituted for each null (no-text) field.</p> </li>
<li> <p><code>empty_value</code>: Specifies the object that is to be substituted for each empty field.</p> </li>
</ul> <h6 id="class-CSV-label-Option+row_sep">Option <code>row_sep</code>
</h6> <p>Specifies the row separator, a String or the Symbol <code>:auto</code> (see below), to be used for both parsing and generating.</p> <p>Default value:</p> <pre class="ruby" data-language="ruby">CSV::DEFAULT_OPTIONS.fetch(:row_sep) # =&gt; :auto
</pre>  <p>When <code>row_sep</code> is a String, that String becomes the row separator. The <a href="string.html"><code>String</code></a> will be transcoded into the data’s <a href="encoding.html"><code>Encoding</code></a> before use.</p> <p>Using <code>"\n"</code>:</p> <pre class="ruby" data-language="ruby">row_sep = "\n"
str = CSV.generate(row_sep: row_sep) do |csv|
  csv &lt;&lt; [:foo, 0]
  csv &lt;&lt; [:bar, 1]
  csv &lt;&lt; [:baz, 2]
end
str # =&gt; "foo,0\nbar,1\nbaz,2\n"
ary = CSV.parse(str)
ary # =&gt; [["foo", "0"], ["bar", "1"], ["baz", "2"]]
</pre> <p>Using <code>|</code> (pipe):</p> <pre class="ruby" data-language="ruby">row_sep = '|'
str = CSV.generate(row_sep: row_sep) do |csv|
  csv &lt;&lt; [:foo, 0]
  csv &lt;&lt; [:bar, 1]
  csv &lt;&lt; [:baz, 2]
end
str # =&gt; "foo,0|bar,1|baz,2|"
ary = CSV.parse(str, row_sep: row_sep)
ary # =&gt; [["foo", "0"], ["bar", "1"], ["baz", "2"]]
</pre> <p>Using <code>--</code> (two hyphens):</p> <pre class="ruby" data-language="ruby">row_sep = '--'
str = CSV.generate(row_sep: row_sep) do |csv|
  csv &lt;&lt; [:foo, 0]
  csv &lt;&lt; [:bar, 1]
  csv &lt;&lt; [:baz, 2]
end
str # =&gt; "foo,0--bar,1--baz,2--"
ary = CSV.parse(str, row_sep: row_sep)
ary # =&gt; [["foo", "0"], ["bar", "1"], ["baz", "2"]]
</pre> <p>Using <code>''</code> (empty string):</p> <pre class="ruby" data-language="ruby">row_sep = ''
str = CSV.generate(row_sep: row_sep) do |csv|
  csv &lt;&lt; [:foo, 0]
  csv &lt;&lt; [:bar, 1]
  csv &lt;&lt; [:baz, 2]
end
str # =&gt; "foo,0bar,1baz,2"
ary = CSV.parse(str, row_sep: row_sep)
ary # =&gt; [["foo", "0bar", "1baz", "2"]]
</pre>  <p>When <code>row_sep</code> is the Symbol <code>:auto</code> (the default), generating uses <code>"\n"</code> as the row separator:</p> <pre class="ruby" data-language="ruby">str = CSV.generate do |csv|
  csv &lt;&lt; [:foo, 0]
  csv &lt;&lt; [:bar, 1]
  csv &lt;&lt; [:baz, 2]
end
str # =&gt; "foo,0\nbar,1\nbaz,2\n"
</pre> <p>Parsing, on the other hand, invokes auto-discovery of the row separator.</p> <p>Auto-discovery reads ahead in the data looking for the next <code>\r\n</code>, <code>\n</code>, or <code>\r</code> sequence. The sequence will be selected even if it occurs in a quoted field, assuming that you would have the same line endings there.</p> <p>Example:</p> <pre class="ruby" data-language="ruby">str = CSV.generate do |csv|
  csv &lt;&lt; [:foo, 0]
  csv &lt;&lt; [:bar, 1]
  csv &lt;&lt; [:baz, 2]
end
str # =&gt; "foo,0\nbar,1\nbaz,2\n"
ary = CSV.parse(str)
ary # =&gt; [["foo", "0"], ["bar", "1"], ["baz", "2"]]
</pre> <p>The default <code>$INPUT_RECORD_SEPARATOR</code> (<code>$/</code>) is used if any of the following is true:</p> <ul>
<li> <p>None of those sequences is found.</p> </li>
<li> <p><span><code>Data</code></span> is <code>ARGF</code>, <code>STDIN</code>, <code>STDOUT</code>, or <code>STDERR</code>.</p> </li>
<li> <p>The stream is only available for output.</p> </li>
</ul> <p>Obviously, discovery takes a little time. <a href="set.html"><code>Set</code></a> manually if speed is important. Also note that <a href="io.html"><code>IO</code></a> objects should be opened in binary mode on Windows if this feature will be used as the line-ending translation can cause problems with resetting the document position to where it was before the read ahead.</p> <h6 id="class-CSV-label-Option+col_sep">Option <code>col_sep</code>
</h6> <p>Specifies the String field separator to be used for both parsing and generating. The String will be transcoded into the data’s Encoding before use.</p> <p>Default value:</p> <pre class="ruby" data-language="ruby">CSV::DEFAULT_OPTIONS.fetch(:col_sep) # =&gt; "," (comma)
</pre> <p>Using the default (comma):</p> <pre class="ruby" data-language="ruby">str = CSV.generate do |csv|
  csv &lt;&lt; [:foo, 0]
  csv &lt;&lt; [:bar, 1]
  csv &lt;&lt; [:baz, 2]
end
str # =&gt; "foo,0\nbar,1\nbaz,2\n"
ary = CSV.parse(str)
ary # =&gt; [["foo", "0"], ["bar", "1"], ["baz", "2"]]
</pre> <p>Using <code>:</code> (colon):</p> <pre class="ruby" data-language="ruby">col_sep = ':'
str = CSV.generate(col_sep: col_sep) do |csv|
  csv &lt;&lt; [:foo, 0]
  csv &lt;&lt; [:bar, 1]
  csv &lt;&lt; [:baz, 2]
end
str # =&gt; "foo:0\nbar:1\nbaz:2\n"
ary = CSV.parse(str, col_sep: col_sep)
ary # =&gt; [["foo", "0"], ["bar", "1"], ["baz", "2"]]
</pre> <p>Using <code>::</code> (two colons):</p> <pre class="ruby" data-language="ruby">col_sep = '::'
str = CSV.generate(col_sep: col_sep) do |csv|
  csv &lt;&lt; [:foo, 0]
  csv &lt;&lt; [:bar, 1]
  csv &lt;&lt; [:baz, 2]
end
str # =&gt; "foo::0\nbar::1\nbaz::2\n"
ary = CSV.parse(str, col_sep: col_sep)
ary # =&gt; [["foo", "0"], ["bar", "1"], ["baz", "2"]]
</pre> <p>Using <code>''</code> (empty string):</p> <pre class="ruby" data-language="ruby">col_sep = ''
str = CSV.generate(col_sep: col_sep) do |csv|
  csv &lt;&lt; [:foo, 0]
  csv &lt;&lt; [:bar, 1]
  csv &lt;&lt; [:baz, 2]
end
str # =&gt; "foo0\nbar1\nbaz2\n"
</pre>  <p>Raises an exception if parsing with the empty String:</p> <pre class="ruby" data-language="ruby">col_sep = ''
# Raises ArgumentError (:col_sep must be 1 or more characters: "")
CSV.parse("foo0\nbar1\nbaz2\n", col_sep: col_sep)
</pre> <h6 id="class-CSV-label-Option+quote_char">Option <code>quote_char</code>
</h6> <p>Specifies the character (String of length 1) used used to quote fields in both parsing and generating. This <a href="string.html"><code>String</code></a> will be transcoded into the data’s Encoding before use.</p> <p>Default value:</p> <pre class="ruby" data-language="ruby">CSV::DEFAULT_OPTIONS.fetch(:quote_char) # =&gt; "\"" (double quote)
</pre> <p>This is useful for an application that incorrectly uses <code>'</code> (single-quote) to quote fields, instead of the correct <code>"</code> (double-quote).</p> <p>Using the default (double quote):</p> <pre class="ruby" data-language="ruby">str = CSV.generate do |csv|
  csv &lt;&lt; ['foo', 0]
  csv &lt;&lt; ["'bar'", 1]
  csv &lt;&lt; ['"baz"', 2]
end
str # =&gt; "foo,0\n'bar',1\n\"\"\"baz\"\"\",2\n"
ary = CSV.parse(str)
ary # =&gt; [["foo", "0"], ["'bar'", "1"], ["\"baz\"", "2"]]
</pre> <p>Using <code>'</code> (single-quote):</p> <pre class="ruby" data-language="ruby">quote_char = "'"
str = CSV.generate(quote_char: quote_char) do |csv|
  csv &lt;&lt; ['foo', 0]
  csv &lt;&lt; ["'bar'", 1]
  csv &lt;&lt; ['"baz"', 2]
end
str # =&gt; "foo,0\n'''bar''',1\n\"baz\",2\n"
ary = CSV.parse(str, quote_char: quote_char)
ary # =&gt; [["foo", "0"], ["'bar'", "1"], ["\"baz\"", "2"]]
</pre>  <p>Raises an exception if the String length is greater than 1:</p> <pre class="ruby" data-language="ruby"># Raises ArgumentError (:quote_char has to be nil or a single character String)
CSV.new('', quote_char: 'xx')
</pre> <p>Raises an exception if the value is not a String:</p> <pre class="ruby" data-language="ruby"># Raises ArgumentError (:quote_char has to be nil or a single character String)
CSV.new('', quote_char: :foo)
</pre> <h6 id="class-CSV-label-Option+field_size_limit">Option <code>field_size_limit</code>
</h6> <p>Specifies the Integer field size limit.</p> <p>Default value:</p> <pre class="ruby" data-language="ruby">CSV::DEFAULT_OPTIONS.fetch(:field_size_limit) # =&gt; nil
</pre> <p>This is a maximum size <a href="csv.html"><code>CSV</code></a> will read ahead looking for the closing quote for a field. (In truth, it reads to the first line ending beyond this size.) If a quote cannot be found within the limit <a href="csv.html"><code>CSV</code></a> will raise a <a href="csv/malformedcsverror.html"><code>MalformedCSVError</code></a>, assuming the data is faulty. You can use this limit to prevent what are effectively DoS attacks on the parser. However, this limit can cause a legitimate parse to fail; therefore the default value is <code>nil</code> (no limit).</p> <p>For the examples in this section:</p> <pre class="ruby" data-language="ruby">str = &lt;&lt;~EOT
  "a","b"
  "
  2345
  ",""
EOT
str # =&gt; "\"a\",\"b\"\n\"\n2345\n\",\"\"\n"
</pre> <p>Using the default <code>nil</code>:</p> <pre class="ruby" data-language="ruby">ary = CSV.parse(str)
ary # =&gt; [["a", "b"], ["\n2345\n", ""]]
</pre> <p>Using <code>50</code>:</p> <pre class="ruby" data-language="ruby">field_size_limit = 50
ary = CSV.parse(str, field_size_limit: field_size_limit)
ary # =&gt; [["a", "b"], ["\n2345\n", ""]]
</pre>  <p>Raises an exception if a field is too long:</p> <pre class="ruby" data-language="ruby">big_str = "123456789\n" * 1024
# Raises CSV::MalformedCSVError (Field size exceeded in line 1.)
CSV.parse('valid,fields,"' + big_str + '"', field_size_limit: 2048)
</pre> <h6 id="class-CSV-label-Option+converters">Option <code>converters</code>
</h6> <p>Specifies converters to be used in parsing fields. See <a href="#class-CSV-label-Field+Converters">Field Converters</a></p> <p>Default value:</p> <pre class="ruby" data-language="ruby">CSV::DEFAULT_OPTIONS.fetch(:converters) # =&gt; nil
</pre> <p>The value may be a field converter name (see <a href="#class-CSV-label-Stored+Converters">Stored Converters</a>):</p> <pre class="ruby" data-language="ruby">str = '1,2,3'
# Without a converter
array = CSV.parse_line(str)
array # =&gt; ["1", "2", "3"]
# With built-in converter :integer
array = CSV.parse_line(str, converters: :integer)
array # =&gt; [1, 2, 3]
</pre> <p>The value may be a converter list (see <a href="#class-CSV-label-Converter+Lists">Converter Lists</a>):</p> <pre class="ruby" data-language="ruby">str = '1,3.14159'
# Without converters
array = CSV.parse_line(str)
array # =&gt; ["1", "3.14159"]
# With built-in converters
array = CSV.parse_line(str, converters: [:integer, :float])
array # =&gt; [1, 3.14159]
</pre> <p>The value may be a Proc custom converter: (see <a href="#class-CSV-label-Custom+Field+Converters">Custom Field Converters</a>):</p> <pre class="ruby" data-language="ruby">str = ' foo  ,  bar  ,  baz  '
# Without a converter
array = CSV.parse_line(str)
array # =&gt; [" foo  ", "  bar  ", "  baz  "]
# With a custom converter
array = CSV.parse_line(str, converters: proc {|field| field.strip })
array # =&gt; ["foo", "bar", "baz"]
</pre> <p>See also <a href="#class-CSV-label-Custom+Field+Converters">Custom Field Converters</a></p>  <p>Raises an exception if the converter is not a converter name or a Proc:</p> <pre class="ruby" data-language="ruby">str = 'foo,0'
# Raises NoMethodError (undefined method `arity' for nil:NilClass)
CSV.parse(str, converters: :foo)
</pre> <h6 id="class-CSV-label-Option+unconverted_fields">Option <code>unconverted_fields</code>
</h6> <p>Specifies the boolean that determines whether unconverted field values are to be available.</p> <p>Default value:</p> <pre class="ruby" data-language="ruby">CSV::DEFAULT_OPTIONS.fetch(:unconverted_fields) # =&gt; nil
</pre> <p>The unconverted field values are those found in the source data, prior to any conversions performed via option <code>converters</code>.</p> <p>When option <code>unconverted_fields</code> is <code>true</code>, each returned row (Array or CSV::Row) has an added method, <code>unconverted_fields</code>, that returns the unconverted field values:</p> <pre class="ruby" data-language="ruby">str = &lt;&lt;-EOT
foo,0
bar,1
baz,2
EOT
# Without unconverted_fields
csv = CSV.parse(str, converters: :integer)
csv # =&gt; [["foo", 0], ["bar", 1], ["baz", 2]]
csv.first.respond_to?(:unconverted_fields) # =&gt; false
# With unconverted_fields
csv = CSV.parse(str, converters: :integer, unconverted_fields: true)
csv # =&gt; [["foo", 0], ["bar", 1], ["baz", 2]]
csv.first.respond_to?(:unconverted_fields) # =&gt; true
csv.first.unconverted_fields # =&gt; ["foo", "0"]
</pre> <h6 id="class-CSV-label-Option+headers">Option <code>headers</code>
</h6> <p>Specifies a boolean, Symbol, Array, or String to be used to define column headers.</p> <p>Default value:</p> <pre class="ruby" data-language="ruby">CSV::DEFAULT_OPTIONS.fetch(:headers) # =&gt; false
</pre>  <p>Without <code>headers</code>:</p> <pre class="ruby" data-language="ruby">str = &lt;&lt;-EOT
Name,Count
foo,0
bar,1
bax,2
EOT
csv = CSV.new(str)
csv # =&gt; #&lt;CSV io_type:StringIO encoding:UTF-8 lineno:0 col_sep:"," row_sep:"\n" quote_char:"\""&gt;
csv.headers # =&gt; nil
csv.shift # =&gt; ["Name", "Count"]
</pre>  <p>If set to <code>true</code> or the Symbol <code>:first_row</code>, the first row of the data is treated as a row of headers:</p> <pre class="ruby" data-language="ruby">str = &lt;&lt;-EOT
Name,Count
foo,0
bar,1
bax,2
EOT
csv = CSV.new(str, headers: true)
csv # =&gt; #&lt;CSV io_type:StringIO encoding:UTF-8 lineno:2 col_sep:"," row_sep:"\n" quote_char:"\"" headers:["Name", "Count"]&gt;
csv.headers # =&gt; ["Name", "Count"]
csv.shift # =&gt; #&lt;CSV::Row "Name":"bar" "Count":"1"&gt;
</pre>  <p>If set to an Array, the Array elements are treated as headers:</p> <pre class="ruby" data-language="ruby">str = &lt;&lt;-EOT
foo,0
bar,1
bax,2
EOT
csv = CSV.new(str, headers: ['Name', 'Count'])
csv
csv.headers # =&gt; ["Name", "Count"]
csv.shift # =&gt; #&lt;CSV::Row "Name":"bar" "Count":"1"&gt;
</pre>  <p>If set to a String <code>str</code>, method <code>CSV::parse_line(str, options)</code> is called with the current <code>options</code>, and the returned Array is treated as headers:</p> <pre class="ruby" data-language="ruby">str = &lt;&lt;-EOT
foo,0
bar,1
bax,2
EOT
csv = CSV.new(str, headers: 'Name,Count')
csv
csv.headers # =&gt; ["Name", "Count"]
csv.shift # =&gt; #&lt;CSV::Row "Name":"bar" "Count":"1"&gt;
</pre> <h6 id="class-CSV-label-Option+return_headers">Option <code>return_headers</code>
</h6> <p>Specifies the boolean that determines whether method <a href="csv.html#method-i-shift"><code>shift</code></a> returns or ignores the header row.</p> <p>Default value:</p> <pre class="ruby" data-language="ruby">CSV::DEFAULT_OPTIONS.fetch(:return_headers) # =&gt; false
</pre> <p>Examples:</p> <pre class="ruby" data-language="ruby">str = &lt;&lt;-EOT
Name,Count
foo,0
bar,1
bax,2
EOT
# Without return_headers first row is str.
csv = CSV.new(str, headers: true)
csv.shift # =&gt; #&lt;CSV::Row "Name":"foo" "Count":"0"&gt;
# With return_headers first row is headers.
csv = CSV.new(str, headers: true, return_headers: true)
csv.shift # =&gt; #&lt;CSV::Row "Name":"Name" "Count":"Count"&gt;
</pre> <h6 id="class-CSV-label-Option+header_converters">Option <code>header_converters</code>
</h6> <p>Specifies converters to be used in parsing headers. See <a href="#class-CSV-label-Header+Converters">Header Converters</a></p> <p>Default value:</p> <pre class="ruby" data-language="ruby">CSV::DEFAULT_OPTIONS.fetch(:header_converters) # =&gt; nil
</pre> <p>Identical in functionality to option <a href="#class-CSV-label-Option+converters">converters</a> except that:</p> <ul>
<li> <p>The converters apply only to the header row.</p> </li>
<li> <p>The built-in header converters are <code>:downcase</code> and <code>:symbol</code>.</p> </li>
</ul> <p>This section assumes prior execution of:</p> <pre class="ruby" data-language="ruby">str = &lt;&lt;-EOT
Name,Value
foo,0
bar,1
baz,2
EOT
# With no header converter
table = CSV.parse(str, headers: true)
table.headers # =&gt; ["Name", "Value"]
</pre> <p>The value may be a header converter name (see <a href="#class-CSV-label-Stored+Converters">Stored Converters</a>):</p> <pre class="ruby" data-language="ruby">table = CSV.parse(str, headers: true, header_converters: :downcase)
table.headers # =&gt; ["name", "value"]
</pre> <p>The value may be a converter list (see <a href="#class-CSV-label-Converter+Lists">Converter Lists</a>):</p> <pre class="ruby" data-language="ruby">header_converters = [:downcase, :symbol]
table = CSV.parse(str, headers: true, header_converters: header_converters)
table.headers # =&gt; [:name, :value]
</pre> <p>The value may be a Proc custom converter (see <a href="#class-CSV-label-Custom+Header+Converters">Custom Header Converters</a>):</p> <pre class="ruby" data-language="ruby">upcase_converter = proc {|field| field.upcase }
table = CSV.parse(str, headers: true, header_converters: upcase_converter)
table.headers # =&gt; ["NAME", "VALUE"]
</pre> <p>See also <a href="#class-CSV-label-Custom+Header+Converters">Custom Header Converters</a></p> <h6 id="class-CSV-label-Option+skip_blanks">Option <code>skip_blanks</code>
</h6> <p>Specifies a boolean that determines whether blank lines in the input will be ignored; a line that contains a column separator is not considered to be blank.</p> <p>Default value:</p> <pre class="ruby" data-language="ruby">CSV::DEFAULT_OPTIONS.fetch(:skip_blanks) # =&gt; false
</pre> <p>See also option <a href="#class-CSV-label-Option+skip_lines">skiplines</a>.</p> <p>For examples in this section:</p> <pre class="ruby" data-language="ruby">str = &lt;&lt;-EOT
foo,0

bar,1
baz,2

,
EOT
</pre> <p>Using the default, <code>false</code>:</p> <pre class="ruby" data-language="ruby">ary = CSV.parse(str)
ary # =&gt; [["foo", "0"], [], ["bar", "1"], ["baz", "2"], [], [nil, nil]]
</pre> <p>Using <code>true</code>:</p> <pre class="ruby" data-language="ruby">ary = CSV.parse(str, skip_blanks: true)
ary # =&gt; [["foo", "0"], ["bar", "1"], ["baz", "2"], [nil, nil]]
</pre> <p>Using a truthy value:</p> <pre class="ruby" data-language="ruby">ary = CSV.parse(str, skip_blanks: :foo)
ary # =&gt; [["foo", "0"], ["bar", "1"], ["baz", "2"], [nil, nil]]
</pre> <h6 id="class-CSV-label-Option+skip_lines">Option <code>skip_lines</code>
</h6> <p>Specifies an object to use in identifying comment lines in the input that are to be ignored:</p> <ul>
<li> <p>If a Regexp, ignores lines that match it.</p> </li>
<li> <p>If a String, converts it to a Regexp, ignores lines that match it.</p> </li>
<li> <p>If <code>nil</code>, no lines are considered to be comments.</p> </li>
</ul> <p>Default value:</p> <pre class="ruby" data-language="ruby">CSV::DEFAULT_OPTIONS.fetch(:skip_lines) # =&gt; nil
</pre> <p>For examples in this section:</p> <pre class="ruby" data-language="ruby">str = &lt;&lt;-EOT
# Comment
foo,0
bar,1
baz,2
# Another comment
EOT
str # =&gt; "# Comment\nfoo,0\nbar,1\nbaz,2\n# Another comment\n"
</pre> <p>Using the default, <code>nil</code>:</p> <pre class="ruby" data-language="ruby">ary = CSV.parse(str)
ary # =&gt; [["# Comment"], ["foo", "0"], ["bar", "1"], ["baz", "2"], ["# Another comment"]]
</pre> <p>Using a Regexp:</p> <pre class="ruby" data-language="ruby">ary = CSV.parse(str, skip_lines: /^#/)
ary # =&gt; [["foo", "0"], ["bar", "1"], ["baz", "2"]]
</pre> <p>Using a String:</p> <pre class="ruby" data-language="ruby">ary = CSV.parse(str, skip_lines: '#')
ary # =&gt; [["foo", "0"], ["bar", "1"], ["baz", "2"]]
</pre>  <p>Raises an exception if given an object that is not a Regexp, a String, or <code>nil</code>:</p> <pre class="ruby" data-language="ruby"># Raises ArgumentError (:skip_lines has to respond to #match: 0)
CSV.parse(str, skip_lines: 0)
</pre> <h6 id="class-CSV-label-Option+strip">Option <code>strip</code>
</h6> <p>Specifies the boolean value that determines whether whitespace is stripped from each input field.</p> <p>Default value:</p> <pre class="ruby" data-language="ruby">CSV::DEFAULT_OPTIONS.fetch(:strip) # =&gt; false
</pre> <p>With default value <code>false</code>:</p> <pre class="ruby" data-language="ruby">ary = CSV.parse_line(' a , b ')
ary # =&gt; [" a ", " b "]
</pre> <p>With value <code>true</code>:</p> <pre class="ruby" data-language="ruby">ary = CSV.parse_line(' a , b ', strip: true)
ary # =&gt; ["a", "b"]
</pre> <h6 id="class-CSV-label-Option+liberal_parsing">Option <code>liberal_parsing</code>
</h6> <p>Specifies the boolean or hash value that determines whether <a href="csv.html"><code>CSV</code></a> will attempt to parse input not conformant with RFC 4180, such as double quotes in unquoted fields.</p> <p>Default value:</p> <pre class="ruby" data-language="ruby">CSV::DEFAULT_OPTIONS.fetch(:liberal_parsing) # =&gt; false
</pre> <p>For the next two examples:</p> <pre class="ruby" data-language="ruby">str = 'is,this "three, or four",fields'
</pre> <p>Without <code>liberal_parsing</code>:</p> <pre class="ruby" data-language="ruby"># Raises CSV::MalformedCSVError (Illegal quoting in str 1.)
CSV.parse_line(str)
</pre> <p>With <code>liberal_parsing</code>:</p> <pre class="ruby" data-language="ruby">ary = CSV.parse_line(str, liberal_parsing: true)
ary # =&gt; ["is", "this \"three", " or four\"", "fields"]
</pre> <p>Use the <code>backslash_quote</code> sub-option to parse values that use a backslash to escape a double-quote character. This causes the parser to treat <code>\"</code> as if it were <code>""</code>.</p> <p>For the next two examples:</p> <pre class="ruby" data-language="ruby">str = 'Show,"Harry \"Handcuff\" Houdini, the one and only","Tampa Theater"'
</pre> <p>With <code>liberal_parsing</code>, but without the <code>backslash_quote</code> sub-option:</p> <pre class="ruby" data-language="ruby"># Incorrect interpretation of backslash; incorrectly interprets the quoted comma as a field separator.
ary = CSV.parse_line(str, liberal_parsing: true)
ary # =&gt; ["Show", "\"Harry \\\"Handcuff\\\" Houdini", " the one and only\"", "Tampa Theater"]
puts ary[1] # =&gt; "Harry \"Handcuff\" Houdini
</pre> <p>With <code>liberal_parsing</code> and its <code>backslash_quote</code> sub-option:</p> <pre class="ruby" data-language="ruby">ary = CSV.parse_line(str, liberal_parsing: { backslash_quote: true })
ary # =&gt; ["Show", "Harry \"Handcuff\" Houdini, the one and only", "Tampa Theater"]
puts ary[1] # =&gt; Harry "Handcuff" Houdini, the one and only
</pre> <h6 id="class-CSV-label-Option+nil_value">Option <code>nil_value</code>
</h6> <p>Specifies the object that is to be substituted for each null (no-text) field.</p> <p>Default value:</p> <pre class="ruby" data-language="ruby">CSV::DEFAULT_OPTIONS.fetch(:nil_value) # =&gt; nil
</pre> <p>With the default, <code>nil</code>:</p> <pre class="ruby" data-language="ruby">CSV.parse_line('a,,b,,c') # =&gt; ["a", nil, "b", nil, "c"]
</pre> <p>With a different object:</p> <pre class="ruby" data-language="ruby">CSV.parse_line('a,,b,,c', nil_value: 0) # =&gt; ["a", 0, "b", 0, "c"]
</pre> <h6 id="class-CSV-label-Option+empty_value">Option <code>empty_value</code>
</h6> <p>Specifies the object that is to be substituted for each field that has an empty String.</p> <p>Default value:</p> <pre class="ruby" data-language="ruby">CSV::DEFAULT_OPTIONS.fetch(:empty_value) # =&gt; "" (empty string)
</pre> <p>With the default, <code>""</code>:</p> <pre class="ruby" data-language="ruby">CSV.parse_line('a,"",b,"",c') # =&gt; ["a", "", "b", "", "c"]
</pre> <p>With a different object:</p> <pre class="ruby" data-language="ruby">CSV.parse_line('a,"",b,"",c', empty_value: 'x') # =&gt; ["a", "x", "b", "x", "c"]
</pre> <h4 id="class-CSV-label-Options+for+Generating">Options for Generating</h4> <p>Options for generating, described in detail below, include:</p> <ul>
<li> <p><code>row_sep</code>: Specifies the row separator; used to delimit rows.</p> </li>
<li> <p><code>col_sep</code>: Specifies the column separator; used to delimit fields.</p> </li>
<li> <p><code>quote_char</code>: Specifies the quote character; used to quote fields.</p> </li>
<li> <p><code>write_headers</code>: Specifies whether headers are to be written.</p> </li>
<li> <p><code>force_quotes</code>: Specifies whether each output field is to be quoted.</p> </li>
<li> <p><code>quote_empty</code>: Specifies whether each empty output field is to be quoted.</p> </li>
<li> <p><code>write_converters</code>: Specifies the field converters to be used in writing.</p> </li>
<li> <p><code>write_nil_value</code>: Specifies the object that is to be substituted for each <code>nil</code>-valued field.</p> </li>
<li> <p><code>write_empty_value</code>: Specifies the object that is to be substituted for each empty field.</p> </li>
</ul> <h6 id="class-CSV-label-Option+row_sep">Option <code>row_sep</code>
</h6> <p>Specifies the row separator, a String or the Symbol <code>:auto</code> (see below), to be used for both parsing and generating.</p> <p>Default value:</p> <pre class="ruby" data-language="ruby">CSV::DEFAULT_OPTIONS.fetch(:row_sep) # =&gt; :auto
</pre>  <p>When <code>row_sep</code> is a String, that String becomes the row separator. The <a href="string.html"><code>String</code></a> will be transcoded into the data’s <a href="encoding.html"><code>Encoding</code></a> before use.</p> <p>Using <code>"\n"</code>:</p> <pre class="ruby" data-language="ruby">row_sep = "\n"
str = CSV.generate(row_sep: row_sep) do |csv|
  csv &lt;&lt; [:foo, 0]
  csv &lt;&lt; [:bar, 1]
  csv &lt;&lt; [:baz, 2]
end
str # =&gt; "foo,0\nbar,1\nbaz,2\n"
ary = CSV.parse(str)
ary # =&gt; [["foo", "0"], ["bar", "1"], ["baz", "2"]]
</pre> <p>Using <code>|</code> (pipe):</p> <pre class="ruby" data-language="ruby">row_sep = '|'
str = CSV.generate(row_sep: row_sep) do |csv|
  csv &lt;&lt; [:foo, 0]
  csv &lt;&lt; [:bar, 1]
  csv &lt;&lt; [:baz, 2]
end
str # =&gt; "foo,0|bar,1|baz,2|"
ary = CSV.parse(str, row_sep: row_sep)
ary # =&gt; [["foo", "0"], ["bar", "1"], ["baz", "2"]]
</pre> <p>Using <code>--</code> (two hyphens):</p> <pre class="ruby" data-language="ruby">row_sep = '--'
str = CSV.generate(row_sep: row_sep) do |csv|
  csv &lt;&lt; [:foo, 0]
  csv &lt;&lt; [:bar, 1]
  csv &lt;&lt; [:baz, 2]
end
str # =&gt; "foo,0--bar,1--baz,2--"
ary = CSV.parse(str, row_sep: row_sep)
ary # =&gt; [["foo", "0"], ["bar", "1"], ["baz", "2"]]
</pre> <p>Using <code>''</code> (empty string):</p> <pre class="ruby" data-language="ruby">row_sep = ''
str = CSV.generate(row_sep: row_sep) do |csv|
  csv &lt;&lt; [:foo, 0]
  csv &lt;&lt; [:bar, 1]
  csv &lt;&lt; [:baz, 2]
end
str # =&gt; "foo,0bar,1baz,2"
ary = CSV.parse(str, row_sep: row_sep)
ary # =&gt; [["foo", "0bar", "1baz", "2"]]
</pre>  <p>When <code>row_sep</code> is the Symbol <code>:auto</code> (the default), generating uses <code>"\n"</code> as the row separator:</p> <pre class="ruby" data-language="ruby">str = CSV.generate do |csv|
  csv &lt;&lt; [:foo, 0]
  csv &lt;&lt; [:bar, 1]
  csv &lt;&lt; [:baz, 2]
end
str # =&gt; "foo,0\nbar,1\nbaz,2\n"
</pre> <p>Parsing, on the other hand, invokes auto-discovery of the row separator.</p> <p>Auto-discovery reads ahead in the data looking for the next <code>\r\n</code>, <code>\n</code>, or <code>\r</code> sequence. The sequence will be selected even if it occurs in a quoted field, assuming that you would have the same line endings there.</p> <p>Example:</p> <pre class="ruby" data-language="ruby">str = CSV.generate do |csv|
  csv &lt;&lt; [:foo, 0]
  csv &lt;&lt; [:bar, 1]
  csv &lt;&lt; [:baz, 2]
end
str # =&gt; "foo,0\nbar,1\nbaz,2\n"
ary = CSV.parse(str)
ary # =&gt; [["foo", "0"], ["bar", "1"], ["baz", "2"]]
</pre> <p>The default <code>$INPUT_RECORD_SEPARATOR</code> (<code>$/</code>) is used if any of the following is true:</p> <ul>
<li> <p>None of those sequences is found.</p> </li>
<li> <p><span><code>Data</code></span> is <code>ARGF</code>, <code>STDIN</code>, <code>STDOUT</code>, or <code>STDERR</code>.</p> </li>
<li> <p>The stream is only available for output.</p> </li>
</ul> <p>Obviously, discovery takes a little time. <a href="set.html"><code>Set</code></a> manually if speed is important. Also note that <a href="io.html"><code>IO</code></a> objects should be opened in binary mode on Windows if this feature will be used as the line-ending translation can cause problems with resetting the document position to where it was before the read ahead.</p> <h6 id="class-CSV-label-Option+col_sep">Option <code>col_sep</code>
</h6> <p>Specifies the String field separator to be used for both parsing and generating. The String will be transcoded into the data’s Encoding before use.</p> <p>Default value:</p> <pre class="ruby" data-language="ruby">CSV::DEFAULT_OPTIONS.fetch(:col_sep) # =&gt; "," (comma)
</pre> <p>Using the default (comma):</p> <pre class="ruby" data-language="ruby">str = CSV.generate do |csv|
  csv &lt;&lt; [:foo, 0]
  csv &lt;&lt; [:bar, 1]
  csv &lt;&lt; [:baz, 2]
end
str # =&gt; "foo,0\nbar,1\nbaz,2\n"
ary = CSV.parse(str)
ary # =&gt; [["foo", "0"], ["bar", "1"], ["baz", "2"]]
</pre> <p>Using <code>:</code> (colon):</p> <pre class="ruby" data-language="ruby">col_sep = ':'
str = CSV.generate(col_sep: col_sep) do |csv|
  csv &lt;&lt; [:foo, 0]
  csv &lt;&lt; [:bar, 1]
  csv &lt;&lt; [:baz, 2]
end
str # =&gt; "foo:0\nbar:1\nbaz:2\n"
ary = CSV.parse(str, col_sep: col_sep)
ary # =&gt; [["foo", "0"], ["bar", "1"], ["baz", "2"]]
</pre> <p>Using <code>::</code> (two colons):</p> <pre class="ruby" data-language="ruby">col_sep = '::'
str = CSV.generate(col_sep: col_sep) do |csv|
  csv &lt;&lt; [:foo, 0]
  csv &lt;&lt; [:bar, 1]
  csv &lt;&lt; [:baz, 2]
end
str # =&gt; "foo::0\nbar::1\nbaz::2\n"
ary = CSV.parse(str, col_sep: col_sep)
ary # =&gt; [["foo", "0"], ["bar", "1"], ["baz", "2"]]
</pre> <p>Using <code>''</code> (empty string):</p> <pre class="ruby" data-language="ruby">col_sep = ''
str = CSV.generate(col_sep: col_sep) do |csv|
  csv &lt;&lt; [:foo, 0]
  csv &lt;&lt; [:bar, 1]
  csv &lt;&lt; [:baz, 2]
end
str # =&gt; "foo0\nbar1\nbaz2\n"
</pre>  <p>Raises an exception if parsing with the empty String:</p> <pre class="ruby" data-language="ruby">col_sep = ''
# Raises ArgumentError (:col_sep must be 1 or more characters: "")
CSV.parse("foo0\nbar1\nbaz2\n", col_sep: col_sep)
</pre> <h6 id="class-CSV-label-Option+quote_char">Option <code>quote_char</code>
</h6> <p>Specifies the character (String of length 1) used used to quote fields in both parsing and generating. This <a href="string.html"><code>String</code></a> will be transcoded into the data’s Encoding before use.</p> <p>Default value:</p> <pre class="ruby" data-language="ruby">CSV::DEFAULT_OPTIONS.fetch(:quote_char) # =&gt; "\"" (double quote)
</pre> <p>This is useful for an application that incorrectly uses <code>'</code> (single-quote) to quote fields, instead of the correct <code>"</code> (double-quote).</p> <p>Using the default (double quote):</p> <pre class="ruby" data-language="ruby">str = CSV.generate do |csv|
  csv &lt;&lt; ['foo', 0]
  csv &lt;&lt; ["'bar'", 1]
  csv &lt;&lt; ['"baz"', 2]
end
str # =&gt; "foo,0\n'bar',1\n\"\"\"baz\"\"\",2\n"
ary = CSV.parse(str)
ary # =&gt; [["foo", "0"], ["'bar'", "1"], ["\"baz\"", "2"]]
</pre> <p>Using <code>'</code> (single-quote):</p> <pre class="ruby" data-language="ruby">quote_char = "'"
str = CSV.generate(quote_char: quote_char) do |csv|
  csv &lt;&lt; ['foo', 0]
  csv &lt;&lt; ["'bar'", 1]
  csv &lt;&lt; ['"baz"', 2]
end
str # =&gt; "foo,0\n'''bar''',1\n\"baz\",2\n"
ary = CSV.parse(str, quote_char: quote_char)
ary # =&gt; [["foo", "0"], ["'bar'", "1"], ["\"baz\"", "2"]]
</pre>  <p>Raises an exception if the String length is greater than 1:</p> <pre class="ruby" data-language="ruby"># Raises ArgumentError (:quote_char has to be nil or a single character String)
CSV.new('', quote_char: 'xx')
</pre> <p>Raises an exception if the value is not a String:</p> <pre class="ruby" data-language="ruby"># Raises ArgumentError (:quote_char has to be nil or a single character String)
CSV.new('', quote_char: :foo)
</pre> <h6 id="class-CSV-label-Option+write_headers">Option <code>write_headers</code>
</h6> <p>Specifies the boolean that determines whether a header row is included in the output; ignored if there are no headers.</p> <p>Default value:</p> <pre class="ruby" data-language="ruby">CSV::DEFAULT_OPTIONS.fetch(:write_headers) # =&gt; nil
</pre> <p>Without <code>write_headers</code>:</p> <pre class="ruby" data-language="ruby">file_path = 't.csv'
CSV.open(file_path,'w',
    :headers =&gt; ['Name','Value']
  ) do |csv|
    csv &lt;&lt; ['foo', '0']
end
CSV.open(file_path) do |csv|
  csv.shift
end # =&gt; ["foo", "0"]
</pre> <p>With <code>write_headers</code>“:</p> <pre class="ruby" data-language="ruby">CSV.open(file_path,'w',
    :write_headers =&gt; true,
    :headers =&gt; ['Name','Value']
  ) do |csv|
    csv &lt;&lt; ['foo', '0']
end
CSV.open(file_path) do |csv|
  csv.shift
end # =&gt; ["Name", "Value"]
</pre> <h6 id="class-CSV-label-Option+force_quotes">Option <code>force_quotes</code>
</h6> <p>Specifies the boolean that determines whether each output field is to be double-quoted.</p> <p>Default value:</p> <pre class="ruby" data-language="ruby">CSV::DEFAULT_OPTIONS.fetch(:force_quotes) # =&gt; false
</pre> <p>For examples in this section:</p> <pre class="ruby" data-language="ruby">ary = ['foo', 0, nil]
</pre> <p>Using the default, <code>false</code>:</p> <pre class="ruby" data-language="ruby">str = CSV.generate_line(ary)
str # =&gt; "foo,0,\n"
</pre> <p>Using <code>true</code>:</p> <pre class="ruby" data-language="ruby">str = CSV.generate_line(ary, force_quotes: true)
str # =&gt; "\"foo\",\"0\",\"\"\n"
</pre> <h6 id="class-CSV-label-Option+quote_empty">Option <code>quote_empty</code>
</h6> <p>Specifies the boolean that determines whether an empty value is to be double-quoted.</p> <p>Default value:</p> <pre class="ruby" data-language="ruby">CSV::DEFAULT_OPTIONS.fetch(:quote_empty) # =&gt; true
</pre> <p>With the default <code>true</code>:</p> <pre class="ruby" data-language="ruby">CSV.generate_line(['"', ""]) # =&gt; "\"\"\"\",\"\"\n"
</pre> <p>With <code>false</code>:</p> <pre class="ruby" data-language="ruby">CSV.generate_line(['"', ""], quote_empty: false) # =&gt; "\"\"\"\",\n"
</pre> <h6 id="class-CSV-label-Option+write_converters">Option <code>write_converters</code>
</h6> <p>Specifies converters to be used in generating fields. See <a href="#class-CSV-label-Write+Converters">Write Converters</a></p> <p>Default value:</p> <pre class="ruby" data-language="ruby">CSV::DEFAULT_OPTIONS.fetch(:write_converters) # =&gt; nil
</pre> <p>With no write converter:</p> <pre class="ruby" data-language="ruby">str = CSV.generate_line(["\na\n", "\tb\t", " c "])
str # =&gt; "\"\na\n\",\tb\t, c \n"
</pre> <p>With a write converter:</p> <pre class="ruby" data-language="ruby">strip_converter = proc {|field| field.strip }
str = CSV.generate_line(["\na\n", "\tb\t", " c "], write_converters: strip_converter)
str # =&gt; "a,b,c\n"
</pre> <p>With two write converters (called in order):</p> <pre class="ruby" data-language="ruby">upcase_converter = proc {|field| field.upcase }
downcase_converter = proc {|field| field.downcase }
write_converters = [upcase_converter, downcase_converter]
str = CSV.generate_line(['a', 'b', 'c'], write_converters: write_converters)
str # =&gt; "a,b,c\n"
</pre> <p>See also <a href="#class-CSV-label-Write+Converters">Write Converters</a></p> <h6 id="class-CSV-label-Option+write_nil_value">Option <code>write_nil_value</code>
</h6> <p>Specifies the object that is to be substituted for each <code>nil</code>-valued field.</p> <p>Default value:</p> <pre class="ruby" data-language="ruby">CSV::DEFAULT_OPTIONS.fetch(:write_nil_value) # =&gt; nil
</pre> <p>Without the option:</p> <pre class="ruby" data-language="ruby">str = CSV.generate_line(['a', nil, 'c', nil])
str # =&gt; "a,,c,\n"
</pre> <p>With the option:</p> <pre class="ruby" data-language="ruby">str = CSV.generate_line(['a', nil, 'c', nil], write_nil_value: "x")
str # =&gt; "a,x,c,x\n"
</pre> <h6 id="class-CSV-label-Option+write_empty_value">Option <code>write_empty_value</code>
</h6> <p>Specifies the object that is to be substituted for each field that has an empty String.</p> <p>Default value:</p> <pre class="ruby" data-language="ruby">CSV::DEFAULT_OPTIONS.fetch(:write_empty_value) # =&gt; ""
</pre> <p>Without the option:</p> <pre class="ruby" data-language="ruby">str = CSV.generate_line(['a', '', 'c', ''])
str # =&gt; "a,\"\",c,\"\"\n"
</pre> <p>With the option:</p> <pre class="ruby" data-language="ruby">str = CSV.generate_line(['a', '', 'c', ''], write_empty_value: "x")
str # =&gt; "a,x,c,x\n"
</pre> <h3 id="class-CSV-label-CSV+with+Headers">CSV with Headers</h3> <p><a href="csv.html"><code>CSV</code></a> allows to specify column names of <a href="csv.html"><code>CSV</code></a> file, whether they are in data, or provided separately. If headers are specified, reading methods return an instance of <a href="csv/table.html"><code>CSV::Table</code></a>, consisting of <a href="csv/row.html"><code>CSV::Row</code></a>.</p> <pre class="ruby" data-language="ruby"># Headers are part of data
data = CSV.parse(&lt;&lt;~ROWS, headers: true)
  Name,Department,Salary
  Bob,Engineering,1000
  Jane,Sales,2000
  John,Management,5000
ROWS

data.class      #=&gt; CSV::Table
data.first      #=&gt; #&lt;CSV::Row "Name":"Bob" "Department":"Engineering" "Salary":"1000"&gt;
data.first.to_h #=&gt; {"Name"=&gt;"Bob", "Department"=&gt;"Engineering", "Salary"=&gt;"1000"}

# Headers provided by developer
data = CSV.parse('Bob,Engineering,1000', headers: %i[name department salary])
data.first      #=&gt; #&lt;CSV::Row name:"Bob" department:"Engineering" salary:"1000"&gt;
</pre> <h3 id="class-CSV-label-Converters">Converters</h3> <p>By default, each value (field or header) parsed by CSV is formed into a String. You can use a <em>field</em> <em>converter</em> or <em>header</em> <em>converter</em> to intercept and modify the parsed values:</p> <ul>
<li> <p>See <a href="#class-CSV-label-Field+Converters">Field Converters</a>.</p> </li>
<li> <p>See <a href="#class-CSV-label-Header+Converters">Header Converters</a>.</p> </li>
</ul> <p>Also by default, each value to be written during generation is written ‘as-is’. You can use a <em>write</em> <em>converter</em> to modify values before writing.</p> <ul><li> <p>See <a href="#class-CSV-label-Write+Converters">Write Converters</a>.</p> </li></ul> <h4 id="class-CSV-label-Specifying+Converters">Specifying Converters</h4> <p>You can specify converters for parsing or generating in the <code>options</code> argument to various CSV methods:</p> <ul>
<li> <p>Option <code>converters</code> for converting parsed field values.</p> </li>
<li> <p>Option <code>header_converters</code> for converting parsed header values.</p> </li>
<li> <p>Option <code>write_converters</code> for converting values to be written (generated).</p> </li>
</ul> <p>There are three forms for specifying converters:</p> <ul>
<li> <p>A converter proc: executable code to be used for conversion.</p> </li>
<li> <p>A converter name: the name of a stored converter.</p> </li>
<li> <p>A converter list: an array of converter procs, converter names, and converter lists.</p> </li>
</ul> <h5 id="class-CSV-label-Converter+Procs">Converter Procs</h5> <p>This converter proc, <code>strip_converter</code>, accepts a value <code>field</code> and returns <code>field.strip</code>:</p> <pre class="ruby" data-language="ruby">strip_converter = proc {|field| field.strip }
</pre> <p>In this call to <code>CSV.parse</code>, the keyword argument <code>converters: string_converter</code> specifies that:</p> <ul>
<li> <p>Proc <code>string_converter</code> is to be called for each parsed field.</p> </li>
<li> <p>The converter’s return value is to replace the <code>field</code> value.</p> </li>
</ul> <p>Example:</p> <pre class="ruby" data-language="ruby">string = " foo , 0 \n bar , 1 \n baz , 2 \n"
array = CSV.parse(string, converters: strip_converter)
array # =&gt; [["foo", "0"], ["bar", "1"], ["baz", "2"]]
</pre> <p>A converter proc can receive a second argument, <code>field_info</code>, that contains details about the field. This modified <code>strip_converter</code> displays its arguments:</p> <pre class="ruby" data-language="ruby">strip_converter = proc do |field, field_info|
  p [field, field_info]
  field.strip
end
string = " foo , 0 \n bar , 1 \n baz , 2 \n"
array = CSV.parse(string, converters: strip_converter)
array # =&gt; [["foo", "0"], ["bar", "1"], ["baz", "2"]]
</pre> <p>Output:</p> <pre>[" foo ", #&lt;struct CSV::FieldInfo index=0, line=1, header=nil&gt;]
[" 0 ", #&lt;struct CSV::FieldInfo index=1, line=1, header=nil&gt;]
[" bar ", #&lt;struct CSV::FieldInfo index=0, line=2, header=nil&gt;]
[" 1 ", #&lt;struct CSV::FieldInfo index=1, line=2, header=nil&gt;]
[" baz ", #&lt;struct CSV::FieldInfo index=0, line=3, header=nil&gt;]
[" 2 ", #&lt;struct CSV::FieldInfo index=1, line=3, header=nil&gt;]</pre> <p>Each <a href="csv.html#FieldInfo"><code>CSV::FieldInfo</code></a> object shows:</p> <ul>
<li> <p>The 0-based field index.</p> </li>
<li> <p>The 1-based line index.</p> </li>
<li> <p>The field header, if any.</p> </li>
</ul> <h5 id="class-CSV-label-Stored+Converters">Stored Converters</h5> <p>A converter may be given a name and stored in a structure where the parsing methods can find it by name.</p> <p>The storage structure for field converters is the Hash <a href="csv.html#Converters"><code>CSV::Converters</code></a>. It has several built-in converter procs:</p> <ul>
<li> <p><code>:integer</code>: converts each String-embedded integer into a true Integer.</p> </li>
<li> <p><code>:float</code>: converts each String-embedded float into a true Float.</p> </li>
<li> <p><code>:date</code>: converts each String-embedded date into a true Date.</p> </li>
<li> <p><code>:date_time</code>: converts each String-embedded date-time into a true DateTime</p> </li>
</ul> <p>. This example creates a converter proc, then stores it:</p> <pre class="ruby" data-language="ruby">strip_converter = proc {|field| field.strip }
CSV::Converters[:strip] = strip_converter
</pre> <p>Then the parsing method call can refer to the converter by its name, <code>:strip</code>:</p> <pre class="ruby" data-language="ruby">string = " foo , 0 \n bar , 1 \n baz , 2 \n"
array = CSV.parse(string, converters: :strip)
array # =&gt; [["foo", "0"], ["bar", "1"], ["baz", "2"]]
</pre> <p>The storage structure for header converters is the Hash <a href="csv.html#HeaderConverters"><code>CSV::HeaderConverters</code></a>, which works in the same way. It also has built-in converter procs:</p> <ul>
<li> <p><code>:downcase</code>: Downcases each header.</p> </li>
<li> <p><code>:symbol</code>: Converts each header to a Symbol.</p> </li>
</ul> <p>There is no such storage structure for write headers.</p> <p>In order for the parsing methods to access stored converters in non-main-Ractors, the storage structure must be made shareable first. Therefore, <code>Ractor.make_shareable(CSV::Converters)</code> and <code>Ractor.make_shareable(CSV::HeaderConverters)</code> must be called before the creation of Ractors that use the converters stored in these structures. (Since making the storage structures shareable involves freezing them, any custom converters that are to be used must be added first.)</p> <h5 id="class-CSV-label-Converter+Lists">Converter Lists</h5> <p>A <em>converter</em> <em>list</em> is an Array that may include any assortment of:</p> <ul>
<li> <p>Converter procs.</p> </li>
<li> <p>Names of stored converters.</p> </li>
<li> <p>Nested converter lists.</p> </li>
</ul> <p>Examples:</p> <pre class="ruby" data-language="ruby">numeric_converters = [:integer, :float]
date_converters = [:date, :date_time]
[numeric_converters, strip_converter]
[strip_converter, date_converters, :float]
</pre> <p>Like a converter proc, a converter list may be named and stored in either CSV::Converters or <a href="csv.html#HeaderConverters"><code>CSV::HeaderConverters</code></a>:</p> <pre class="ruby" data-language="ruby">CSV::Converters[:custom] = [strip_converter, date_converters, :float]
CSV::HeaderConverters[:custom] = [:downcase, :symbol]
</pre> <p>There are two built-in converter lists:</p> <pre class="ruby" data-language="ruby">CSV::Converters[:numeric] # =&gt; [:integer, :float]
CSV::Converters[:all] # =&gt; [:date_time, :numeric]
</pre> <h4 id="class-CSV-label-Field+Converters">Field Converters</h4> <p>With no conversion, all parsed fields in all rows become Strings:</p> <pre class="ruby" data-language="ruby">string = "foo,0\nbar,1\nbaz,2\n"
ary = CSV.parse(string)
ary # =&gt; # =&gt; [["foo", "0"], ["bar", "1"], ["baz", "2"]]
</pre> <p>When you specify a field converter, each parsed field is passed to the converter; its return value becomes the stored value for the field. A converter might, for example, convert an integer embedded in a String into a true Integer. (In fact, that’s what built-in field converter <code>:integer</code> does.)</p> <p>There are three ways to use field converters.</p> <ul>
<li> <p>Using option <a href="#class-CSV-label-Option+converters">converters</a> with a parsing method:</p> <pre class="ruby" data-language="ruby">ary = CSV.parse(string, converters: :integer)
ary # =&gt; [0, 1, 2] # =&gt; [["foo", 0], ["bar", 1], ["baz", 2]]
</pre> </li>
<li> <p>Using option <a href="#class-CSV-label-Option+converters">converters</a> with a new CSV instance:</p> <pre class="ruby" data-language="ruby">csv = CSV.new(string, converters: :integer)
# Field converters in effect:
csv.converters # =&gt; [:integer]
csv.read # =&gt; [["foo", 0], ["bar", 1], ["baz", 2]]
</pre> </li>
<li> <p>Using method <a href="csv.html#method-i-convert"><code>convert</code></a> to add a field converter to a CSV instance:</p> <pre class="ruby" data-language="ruby">csv = CSV.new(string)
# Add a converter.
csv.convert(:integer)
csv.converters # =&gt; [:integer]
csv.read # =&gt; [["foo", 0], ["bar", 1], ["baz", 2]]
</pre> </li>
</ul> <p>Installing a field converter does not affect already-read rows:</p> <pre class="ruby" data-language="ruby">csv = CSV.new(string)
csv.shift # =&gt; ["foo", "0"]
# Add a converter.
csv.convert(:integer)
csv.converters # =&gt; [:integer]
csv.read # =&gt; [["bar", 1], ["baz", 2]]
</pre> <p>There are additional built-in converters, and custom converters are also supported.</p> <h5 id="class-CSV-label-Built-In+Field+Converters">Built-In Field Converters</h5> <p>The built-in field converters are in Hash <a href="csv.html#Converters"><code>CSV::Converters</code></a>:</p> <ul>
<li> <p>Each key is a field converter name.</p> </li>
<li> <p>Each value is one of:</p> <ul>
<li> <p>A Proc field converter.</p> </li>
<li> <p>An Array of field converter names.</p> </li>
</ul> </li>
</ul> <p>Display:</p> <pre class="ruby" data-language="ruby">CSV::Converters.each_pair do |name, value|
  if value.kind_of?(Proc)
    p [name, value.class]
  else
    p [name, value]
  end
end
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">[:integer, Proc]
[:float, Proc]
[:numeric, [:integer, :float]]
[:date, Proc]
[:date_time, Proc]
[:all, [:date_time, :numeric]]
</pre> <p>Each of these converters transcodes values to UTF-8 before attempting conversion. If a value cannot be transcoded to UTF-8 the conversion will fail and the value will remain unconverted.</p> <p>Converter <code>:integer</code> converts each field that Integer() accepts:</p> <pre class="ruby" data-language="ruby">data = '0,1,2,x'
# Without the converter
csv = CSV.parse_line(data)
csv # =&gt; ["0", "1", "2", "x"]
# With the converter
csv = CSV.parse_line(data, converters: :integer)
csv # =&gt; [0, 1, 2, "x"]
</pre> <p>Converter <code>:float</code> converts each field that Float() accepts:</p> <pre class="ruby" data-language="ruby">data = '1.0,3.14159,x'
# Without the converter
csv = CSV.parse_line(data)
csv # =&gt; ["1.0", "3.14159", "x"]
# With the converter
csv = CSV.parse_line(data, converters: :float)
csv # =&gt; [1.0, 3.14159, "x"]
</pre> <p>Converter <code>:numeric</code> converts with both <code>:integer</code> and <code>:float</code>..</p> <p>Converter <code>:date</code> converts each field that <a href="date.html#method-c-parse"><code>Date::parse</code></a> accepts:</p> <pre class="ruby" data-language="ruby">data = '2001-02-03,x'
# Without the converter
csv = CSV.parse_line(data)
csv # =&gt; ["2001-02-03", "x"]
# With the converter
csv = CSV.parse_line(data, converters: :date)
csv # =&gt; [#&lt;Date: 2001-02-03 ((2451944j,0s,0n),+0s,2299161j)&gt;, "x"]
</pre> <p>Converter <code>:date_time</code> converts each field that <a href="datetime.html#method-c-parse"><code>DateTime::parse</code></a> accepts:</p> <pre class="ruby" data-language="ruby">data = '2020-05-07T14:59:00-05:00,x'
# Without the converter
csv = CSV.parse_line(data)
csv # =&gt; ["2020-05-07T14:59:00-05:00", "x"]
# With the converter
csv = CSV.parse_line(data, converters: :date_time)
csv # =&gt; [#&lt;DateTime: 2020-05-07T14:59:00-05:00 ((2458977j,71940s,0n),-18000s,2299161j)&gt;, "x"]
</pre> <p>Converter <code>:numeric</code> converts with both <code>:date_time</code> and <code>:numeric</code>..</p> <p>As seen above, method <a href="csv.html#method-i-convert"><code>convert</code></a> adds converters to a CSV instance, and method <a href="csv.html#method-i-converters"><code>converters</code></a> returns an Array of the converters in effect:</p> <pre class="ruby" data-language="ruby">csv = CSV.new('0,1,2')
csv.converters # =&gt; []
csv.convert(:integer)
csv.converters # =&gt; [:integer]
csv.convert(:date)
csv.converters # =&gt; [:integer, :date]
</pre> <h5 id="class-CSV-label-Custom+Field+Converters">Custom Field Converters</h5> <p>You can define a custom field converter:</p> <pre class="ruby" data-language="ruby">strip_converter = proc {|field| field.strip }
string = " foo , 0 \n bar , 1 \n baz , 2 \n"
array = CSV.parse(string, converters: strip_converter)
array # =&gt; [["foo", "0"], ["bar", "1"], ["baz", "2"]]
</pre> <p>You can register the converter in Converters Hash, which allows you to refer to it by name:</p> <pre class="ruby" data-language="ruby">CSV::Converters[:strip] = strip_converter
string = " foo , 0 \n bar , 1 \n baz , 2 \n"
array = CSV.parse(string, converters: :strip)
array # =&gt; [["foo", "0"], ["bar", "1"], ["baz", "2"]]
</pre> <h4 id="class-CSV-label-Header+Converters">Header Converters</h4> <p>Header converters operate only on headers (and not on other rows).</p> <p>There are three ways to use header converters; these examples use built-in header converter <code>:downcase</code>, which downcases each parsed header.</p> <ul>
<li> <p>Option <code>header_converters</code> with a singleton parsing method:</p> <pre class="ruby" data-language="ruby">string = "Name,Count\nFoo,0\n,Bar,1\nBaz,2"
tbl = CSV.parse(string, headers: true, header_converters: :downcase)
tbl.class # =&gt; CSV::Table
tbl.headers # =&gt; ["name", "count"]
</pre> </li>
<li> <p>Option <code>header_converters</code> with a new CSV instance:</p> <pre class="ruby" data-language="ruby">csv = CSV.new(string, header_converters: :downcase)
# Header converters in effect:
csv.header_converters # =&gt; [:downcase]
tbl = CSV.parse(string, headers: true)
tbl.headers # =&gt; ["Name", "Count"]
</pre> </li>
<li> <p><a href="method.html"><code>Method</code></a> <a href="csv.html#method-i-header_convert"><code>header_convert</code></a> adds a header converter to a CSV instance:</p> <pre class="ruby" data-language="ruby">csv = CSV.new(string)
# Add a header converter.
csv.header_convert(:downcase)
csv.header_converters # =&gt; [:downcase]
tbl = CSV.parse(string, headers: true)
tbl.headers # =&gt; ["Name", "Count"]
</pre> </li>
</ul> <h5 id="class-CSV-label-Built-In+Header+Converters">Built-In Header Converters</h5> <p>The built-in header converters are in Hash <a href="csv.html#HeaderConverters"><code>CSV::HeaderConverters</code></a>. The keys there are the names of the converters:</p> <pre class="ruby" data-language="ruby">CSV::HeaderConverters.keys # =&gt; [:downcase, :symbol]
</pre> <p>Converter <code>:downcase</code> converts each header by downcasing it:</p> <pre class="ruby" data-language="ruby">string = "Name,Count\nFoo,0\n,Bar,1\nBaz,2"
tbl = CSV.parse(string, headers: true, header_converters: :downcase)
tbl.class # =&gt; CSV::Table
tbl.headers # =&gt; ["name", "count"]
</pre> <p>Converter <code>:symbol</code> converts each header by making it into a Symbol:</p> <pre class="ruby" data-language="ruby">string = "Name,Count\nFoo,0\n,Bar,1\nBaz,2"
tbl = CSV.parse(string, headers: true, header_converters: :symbol)
tbl.headers # =&gt; [:name, :count]
</pre> <p>Details:</p> <ul>
<li> <p>Strips leading and trailing whitespace.</p> </li>
<li> <p>Downcases the header.</p> </li>
<li> <p>Replaces embedded spaces with underscores.</p> </li>
<li> <p>Removes non-word characters.</p> </li>
<li> <p>Makes the string into a Symbol.</p> </li>
</ul> <h5 id="class-CSV-label-Custom+Header+Converters">Custom Header Converters</h5> <p>You can define a custom header converter:</p> <pre class="ruby" data-language="ruby">upcase_converter = proc {|header| header.upcase }
string = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
table = CSV.parse(string, headers: true, header_converters: upcase_converter)
table # =&gt; #&lt;CSV::Table mode:col_or_row row_count:4&gt;
table.headers # =&gt; ["NAME", "VALUE"]
</pre> <p>You can register the converter in HeaderConverters Hash, which allows you to refer to it by name:</p> <pre class="ruby" data-language="ruby">CSV::HeaderConverters[:upcase] = upcase_converter
table = CSV.parse(string, headers: true, header_converters: :upcase)
table # =&gt; #&lt;CSV::Table mode:col_or_row row_count:4&gt;
table.headers # =&gt; ["NAME", "VALUE"]
</pre> <h5 id="class-CSV-label-Write+Converters">Write Converters</h5> <p>When you specify a write converter for generating CSV, each field to be written is passed to the converter; its return value becomes the new value for the field. A converter might, for example, strip whitespace from a field.</p> <p>Using no write converter (all fields unmodified):</p> <pre class="ruby" data-language="ruby">output_string = CSV.generate do |csv|
  csv &lt;&lt; [' foo ', 0]
  csv &lt;&lt; [' bar ', 1]
  csv &lt;&lt; [' baz ', 2]
end
output_string # =&gt; " foo ,0\n bar ,1\n baz ,2\n"
</pre> <p>Using option <code>write_converters</code> with two custom write converters:</p> <pre class="ruby" data-language="ruby">strip_converter = proc {|field| field.respond_to?(:strip) ? field.strip : field }
upcase_converter = proc {|field| field.respond_to?(:upcase) ? field.upcase : field }
write_converters = [strip_converter, upcase_converter]
output_string = CSV.generate(write_converters: write_converters) do |csv|
  csv &lt;&lt; [' foo ', 0]
  csv &lt;&lt; [' bar ', 1]
  csv &lt;&lt; [' baz ', 2]
end
output_string # =&gt; "FOO,0\nBAR,1\nBAZ,2\n"
</pre> <h3 id="class-CSV-label-Character+Encodings+-28M17n+or+Multilingualization-29">Character Encodings (M17n or Multilingualization)</h3> <p>This new <a href="csv.html"><code>CSV</code></a> parser is m17n savvy. The parser works in the <a href="encoding.html"><code>Encoding</code></a> of the <a href="io.html"><code>IO</code></a> or <a href="string.html"><code>String</code></a> object being read from or written to. Your data is never transcoded (unless you ask Ruby to transcode it for you) and will literally be parsed in the <a href="encoding.html"><code>Encoding</code></a> it is in. Thus <a href="csv.html"><code>CSV</code></a> will return Arrays or Rows of Strings in the <a href="encoding.html"><code>Encoding</code></a> of your data. This is accomplished by transcoding the parser itself into your <a href="encoding.html"><code>Encoding</code></a>.</p> <p>Some transcoding must take place, of course, to accomplish this multiencoding support. For example, <code>:col_sep</code>, <code>:row_sep</code>, and <code>:quote_char</code> must be transcoded to match your data. Hopefully this makes the entire process feel transparent, since CSV’s defaults should just magically work for your data. However, you can set these values manually in the target <a href="encoding.html"><code>Encoding</code></a> to avoid the translation.</p> <p>It’s also important to note that while all of CSV’s core parser is now <a href="encoding.html"><code>Encoding</code></a> agnostic, some features are not. For example, the built-in converters will try to transcode data to UTF-8 before making conversions. Again, you can provide custom converters that are aware of your Encodings to avoid this translation. It’s just too hard for me to support native conversions in all of Ruby’s Encodings.</p> <p>Anyway, the practical side of this is simple: make sure <a href="io.html"><code>IO</code></a> and <a href="string.html"><code>String</code></a> objects passed into <a href="csv.html"><code>CSV</code></a> have the proper <a href="encoding.html"><code>Encoding</code></a> set and everything should just work. <a href="csv.html"><code>CSV</code></a> methods that allow you to open <a href="io.html"><code>IO</code></a> objects (<a href="csv.html#method-c-foreach"><code>CSV::foreach()</code></a>, <a href="csv.html#method-c-open"><code>CSV::open()</code></a>, <a href="csv.html#method-c-read"><code>CSV::read()</code></a>, and <a href="csv.html#method-c-readlines"><code>CSV::readlines()</code></a>) do allow you to specify the <a href="encoding.html"><code>Encoding</code></a>.</p> <p>One minor exception comes when generating <a href="csv.html"><code>CSV</code></a> into a <a href="string.html"><code>String</code></a> with an <a href="encoding.html"><code>Encoding</code></a> that is not ASCII compatible. There’s no existing data for <a href="csv.html"><code>CSV</code></a> to use to prepare itself and thus you will probably need to manually specify the desired <a href="encoding.html"><code>Encoding</code></a> for most of those cases. It will try to guess using the fields in a row of output though, when using <a href="csv.html#method-c-generate_line"><code>CSV::generate_line()</code></a> or Array#to_csv().</p> <p>I try to point out any other <a href="encoding.html"><code>Encoding</code></a> issues in the documentation of methods as they come up.</p> <p>This has been tested to the best of my ability with all non-“dummy” Encodings Ruby ships with. However, it is brave new code and may have some bugs. Please feel free to <a href="mailto:james@grayproductions.net.html">report</a> any issues you find with it.</p> </section> <section id="5Buntitled-5D" class="documentation-section"> <section class="constants-list"> <header> <h3>Constants</h3> </header> <dl> <dt id="ConverterEncoding">ConverterEncoding </dt>
<dd>
<p>The encoding used by all converters.</p> </dd>
<dt id="Converters">Converters </dt>
<dd>
<p>A Hash containing the names and Procs for the built-in field converters. See <a href="#class-CSV-label-Built-In+Field+Converters">Built-In Field Converters</a>.</p> <p>This Hash is intentionally left unfrozen, and may be extended with custom field converters. See <a href="#class-CSV-label-Custom+Field+Converters">Custom Field Converters</a>.</p> </dd>
<dt id="DEFAULT_OPTIONS">DEFAULT_OPTIONS </dt>
<dd>
<p>Default values for method options.</p> </dd>
<dt id="DateMatcher">DateMatcher </dt>
<dd>
<p>A <a href="regexp.html"><code>Regexp</code></a> used to find and convert some common <a href="date.html"><code>Date</code></a> formats.</p> </dd>
<dt id="DateTimeMatcher">DateTimeMatcher </dt>
<dd>
<p>A <a href="regexp.html"><code>Regexp</code></a> used to find and convert some common <a href="datetime.html"><code>DateTime</code></a> formats.</p> </dd>
<dt id="FieldInfo">FieldInfo </dt>
<dd>
<p>A <a href="csv.html#FieldInfo"><code>FieldInfo</code></a> <a href="struct.html"><code>Struct</code></a> contains details about a field’s position in the data source it was read from. <a href="csv.html"><code>CSV</code></a> will pass this <a href="struct.html"><code>Struct</code></a> to some blocks that make decisions based on field structure. See <a href="csv.html#method-i-convert_fields"><code>CSV.convert_fields()</code></a> for an example.</p> <dl class="rdoc-list note-list">
<dt>
<strong><code>index</code></strong> </dt>
<dd> <p>The zero-based index of the field in its row.</p> </dd>
<dt>
<strong><code>line</code></strong> </dt>
<dd> <p>The line of the data source this row is from.</p> </dd>
<dt>
<strong><code>header</code></strong> </dt>
<dd> <p>The header for the column, when available.</p> </dd>
<dt>
<strong><code>quoted?</code></strong> </dt>
<dd> <p>True or false, whether the original value is quoted or not.</p> </dd>
</dl> </dd>
<dt id="HeaderConverters">HeaderConverters </dt>
<dd>
<p>A Hash containing the names and Procs for the built-in header converters. See <a href="#class-CSV-label-Built-In+Header+Converters">Built-In Header Converters</a>.</p> <p>This Hash is intentionally left unfrozen, and may be extended with custom field converters. See <a href="#class-CSV-label-Custom+Header+Converters">Custom Header Converters</a>.</p> </dd>
<dt id="VERSION">VERSION </dt>
<dd>
<p>The version of the installed library.</p> </dd>
</dl> </section> <section class="attribute-method-details"> <header> <h3>Attributes</h3> </header> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-encoding"> <span class="method-name">encoding</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>:call-seq:</p> <pre>csv.encoding -&gt; encoding</pre> <p>Returns the encoding used for parsing and generating; see <a href="#class-CSV-label-Character+Encodings+-28M17n+or+Multilingualization-29">Character Encodings (M17n or Multilingualization)</a>:</p> <pre class="ruby" data-language="ruby">CSV.new('').encoding # =&gt; #&lt;Encoding:UTF-8&gt;
</pre> </div> </div> </section> <section id="public-class-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-filter"> <span class="method-callseq"> filter(in_string_or_io, **options) {|row| ... } → array_of_arrays or csv_table </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> filter(in_string_or_io, out_string_or_io, **options) {|row| ... } → array_of_arrays or csv_table </span> </div> <div class="method-heading"> <span class="method-callseq"> filter(**options) {|row| ... } → array_of_arrays or csv_table </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="filter-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 1202
def filter(input=nil, output=nil, **options)
  # parse options for input, output, or both
  in_options, out_options = Hash.new, {row_sep: InputRecordSeparator.value}
  options.each do |key, value|
    case key
    when /\Ain(?:put)?_(.+)\Z/
      in_options[$1.to_sym] = value
    when /\Aout(?:put)?_(.+)\Z/
      out_options[$1.to_sym] = value
    else
      in_options[key]  = value
      out_options[key] = value
    end
  end

  # build input and output wrappers
  input  = new(input  || ARGF, **in_options)
  output = new(output || $stdout, **out_options)

  # process headers
  need_manual_header_output =
    (in_options[:headers] and
     out_options[:headers] == true and
     out_options[:write_headers])
  if need_manual_header_output
    first_row = input.shift
    if first_row
      if first_row.is_a?(Row)
        headers = first_row.headers
        yield headers
        output &lt;&lt; headers
      end
      yield first_row
      output &lt;&lt; first_row
    end
  end

  # read, yield, write
  input.each do |row|
    yield row
    output &lt;&lt; row
  end
end</pre> </div> <ul>
<li> <p>Parses CSV from a source (String, IO stream, or <a href="argf.html"><code>ARGF</code></a>).</p> </li>
<li> <p>Calls the given block with each parsed row:</p> <ul>
<li> <p>Without headers, each row is an Array.</p> </li>
<li> <p>With headers, each row is a <a href="csv/row.html"><code>CSV::Row</code></a>.</p> </li>
</ul> </li>
<li> <p>Generates CSV to an output (String, IO stream, or STDOUT).</p> </li>
<li> <p>Returns the parsed source:</p> <ul>
<li> <p>Without headers, an Array of Arrays.</p> </li>
<li> <p>With headers, a <a href="csv/table.html"><code>CSV::Table</code></a>.</p> </li>
</ul> </li>
</ul> <p>When <code>in_string_or_io</code> is given, but not <code>out_string_or_io</code>, parses from the given <code>in_string_or_io</code> and generates to STDOUT.</p> <p>String input without headers:</p> <pre class="ruby" data-language="ruby">in_string = "foo,0\nbar,1\nbaz,2"
CSV.filter(in_string) do |row|
  row[0].upcase!
  row[1] = - row[1].to_i
end # =&gt; [["FOO", 0], ["BAR", -1], ["BAZ", -2]]
</pre> <p>Output (to STDOUT):</p> <pre>FOO,0
BAR,-1
BAZ,-2</pre> <p>String input with headers:</p> <pre class="ruby" data-language="ruby">in_string = "Name,Value\nfoo,0\nbar,1\nbaz,2"
CSV.filter(in_string, headers: true) do |row|
  row[0].upcase!
  row[1] = - row[1].to_i
end # =&gt; #&lt;CSV::Table mode:col_or_row row_count:4&gt;
</pre> <p>Output (to STDOUT):</p> <pre>Name,Value
FOO,0
BAR,-1
BAZ,-2</pre> <p>IO stream input without headers:</p> <pre class="ruby" data-language="ruby">File.write('t.csv', "foo,0\nbar,1\nbaz,2")
File.open('t.csv') do |in_io|
  CSV.filter(in_io) do |row|
    row[0].upcase!
    row[1] = - row[1].to_i
  end
end # =&gt; [["FOO", 0], ["BAR", -1], ["BAZ", -2]]
</pre> <p>Output (to STDOUT):</p> <pre>FOO,0
BAR,-1
BAZ,-2</pre> <p>IO stream input with headers:</p> <pre class="ruby" data-language="ruby">File.write('t.csv', "Name,Value\nfoo,0\nbar,1\nbaz,2")
File.open('t.csv') do |in_io|
  CSV.filter(in_io, headers: true) do |row|
    row[0].upcase!
    row[1] = - row[1].to_i
  end
end # =&gt; #&lt;CSV::Table mode:col_or_row row_count:4&gt;
</pre> <p>Output (to STDOUT):</p> <pre>Name,Value
FOO,0
BAR,-1
BAZ,-2</pre> <p>When both <code>in_string_or_io</code> and <code>out_string_or_io</code> are given, parses from <code>in_string_or_io</code> and generates to <code>out_string_or_io</code>.</p> <p>String output without headers:</p> <pre class="ruby" data-language="ruby">in_string = "foo,0\nbar,1\nbaz,2"
out_string = ''
CSV.filter(in_string, out_string) do |row|
  row[0].upcase!
  row[1] = - row[1].to_i
end # =&gt; [["FOO", 0], ["BAR", -1], ["BAZ", -2]]
out_string # =&gt; "FOO,0\nBAR,-1\nBAZ,-2\n"
</pre> <p>String output with headers:</p> <pre class="ruby" data-language="ruby">in_string = "Name,Value\nfoo,0\nbar,1\nbaz,2"
out_string = ''
CSV.filter(in_string, out_string, headers: true) do |row|
  row[0].upcase!
  row[1] = - row[1].to_i
end # =&gt; #&lt;CSV::Table mode:col_or_row row_count:4&gt;
out_string # =&gt; "Name,Value\nFOO,0\nBAR,-1\nBAZ,-2\n"
</pre> <p>IO stream output without headers:</p> <pre class="ruby" data-language="ruby">in_string = "foo,0\nbar,1\nbaz,2"
File.open('t.csv', 'w') do |out_io|
  CSV.filter(in_string, out_io) do |row|
    row[0].upcase!
    row[1] = - row[1].to_i
  end
end # =&gt; [["FOO", 0], ["BAR", -1], ["BAZ", -2]]
File.read('t.csv') # =&gt; "FOO,0\nBAR,-1\nBAZ,-2\n"
</pre> <p>IO stream output with headers:</p> <pre class="ruby" data-language="ruby">in_string = "Name,Value\nfoo,0\nbar,1\nbaz,2"
File.open('t.csv', 'w') do |out_io|
  CSV.filter(in_string, out_io, headers: true) do |row|
    row[0].upcase!
    row[1] = - row[1].to_i
  end
end # =&gt; #&lt;CSV::Table mode:col_or_row row_count:4&gt;
File.read('t.csv') # =&gt; "Name,Value\nFOO,0\nBAR,-1\nBAZ,-2\n"
</pre> <p>When neither <code>in_string_or_io</code> nor <code>out_string_or_io</code> given, parses from <a href="argf.html"><code>ARGF</code></a> and generates to STDOUT.</p> <p>Without headers:</p> <pre class="ruby" data-language="ruby"># Put Ruby code into a file.
ruby = &lt;&lt;-EOT
  require 'csv'
  CSV.filter do |row|
    row[0].upcase!
    row[1] = - row[1].to_i
  end
EOT
File.write('t.rb', ruby)
# Put some CSV into a file.
File.write('t.csv', "foo,0\nbar,1\nbaz,2")
# Run the Ruby code with CSV filename as argument.
system(Gem.ruby, "t.rb", "t.csv")
</pre> <p>Output (to STDOUT):</p> <pre>FOO,0
BAR,-1
BAZ,-2</pre> <p>With headers:</p> <pre class="ruby" data-language="ruby"># Put Ruby code into a file.
ruby = &lt;&lt;-EOT
  require 'csv'
  CSV.filter(headers: true) do |row|
    row[0].upcase!
    row[1] = - row[1].to_i
  end
EOT
File.write('t.rb', ruby)
# Put some CSV into a file.
File.write('t.csv', "Name,Value\nfoo,0\nbar,1\nbaz,2")
# Run the Ruby code with CSV filename as argument.
system(Gem.ruby, "t.rb", "t.csv")
</pre> <p>Output (to STDOUT):</p> <pre>Name,Value
FOO,0
BAR,-1
BAZ,-2</pre> <p>Arguments:</p> <ul>
<li> <p>Argument <code>in_string_or_io</code> must be a String or an IO stream.</p> </li>
<li> <p>Argument <code>out_string_or_io</code> must be a String or an IO stream.</p> </li>
<li> <p>Arguments <code>**options</code> must be keyword options. See <a href="#class-CSV-label-Options+for+Parsing">Options for Parsing</a>.</p> </li>
</ul>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-foreach"> <span class="method-callseq"> foreach(path_or_io, mode='r', **options) {|row| ... ) </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> foreach(path_or_io, mode='r', **options) → new_enumerator </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="foreach-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 1332
def foreach(path, mode="r", **options, &amp;block)
  return to_enum(__method__, path, mode, **options) unless block_given?
  open(path, mode, **options) do |csv|
    csv.each(&amp;block)
  end
end</pre> </div> <p>Calls the block with each row read from source <code>path_or_io</code>.</p> <p>Path input without headers:</p> <pre class="ruby" data-language="ruby">string = "foo,0\nbar,1\nbaz,2\n"
in_path = 't.csv'
File.write(in_path, string)
CSV.foreach(in_path) {|row| p row }
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">["foo", "0"]
["bar", "1"]
["baz", "2"]
</pre> <p>Path input with headers:</p> <pre class="ruby" data-language="ruby">string = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
in_path = 't.csv'
File.write(in_path, string)
CSV.foreach(in_path, headers: true) {|row| p row }
</pre> <p>Output:</p> <pre>&lt;CSV::Row "Name":"foo" "Value":"0"&gt;
&lt;CSV::Row "Name":"bar" "Value":"1"&gt;
&lt;CSV::Row "Name":"baz" "Value":"2"&gt;</pre> <p>IO stream input without headers:</p> <pre class="ruby" data-language="ruby">string = "foo,0\nbar,1\nbaz,2\n"
path = 't.csv'
File.write(path, string)
File.open('t.csv') do |in_io|
  CSV.foreach(in_io) {|row| p row }
end
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">["foo", "0"]
["bar", "1"]
["baz", "2"]
</pre> <p>IO stream input with headers:</p> <pre class="ruby" data-language="ruby">string = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
path = 't.csv'
File.write(path, string)
File.open('t.csv') do |in_io|
  CSV.foreach(in_io, headers: true) {|row| p row }
end
</pre> <p>Output:</p> <pre>&lt;CSV::Row "Name":"foo" "Value":"0"&gt;
&lt;CSV::Row "Name":"bar" "Value":"1"&gt;
&lt;CSV::Row "Name":"baz" "Value":"2"&gt;</pre> <p>With no block given, returns an Enumerator:</p> <pre class="ruby" data-language="ruby">string = "foo,0\nbar,1\nbaz,2\n"
path = 't.csv'
File.write(path, string)
CSV.foreach(path) # =&gt; #&lt;Enumerator: CSV:foreach("t.csv", "r")&gt;
</pre> <p>Arguments:</p> <ul>
<li> <p>Argument <code>path_or_io</code> must be a file path or an IO stream.</p> </li>
<li> <p>Argument <code>mode</code>, if given, must be a File mode. See <a href="file.html#class-File-label-Access+Modes">Access Modes</a>.</p> </li>
<li> <p>Arguments <code>**options</code> must be keyword options. See <a href="#class-CSV-label-Options+for+Parsing">Options for Parsing</a>.</p> </li>
<li> <p>This method optionally accepts an additional <code>:encoding</code> option that you can use to specify the <a href="encoding.html"><code>Encoding</code></a> of the data read from <code>path</code> or <code>io</code>. You must provide this unless your data is in the encoding given by <code>Encoding::default_external</code>. Parsing will use this to determine how to parse the data. You may provide a second <a href="encoding.html"><code>Encoding</code></a> to have the data transcoded as it is read. For example,</p> <pre>encoding: 'UTF-32BE:UTF-8'</pre> <p>would read <code>UTF-32BE</code> data from the file but transcode it to <code>UTF-8</code> before parsing.</p> </li>
</ul>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-generate"> <span class="method-callseq"> generate(csv_string, **options) {|csv| ... } </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> generate(**options) {|csv| ... } </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="generate-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 1398
def generate(str=nil, **options)
  encoding = options[:encoding]
  # add a default empty String, if none was given
  if str
    str = StringIO.new(str)
    str.seek(0, IO::SEEK_END)
    str.set_encoding(encoding) if encoding
  else
    str = +""
    str.force_encoding(encoding) if encoding
  end
  csv = new(str, **options) # wrap
  yield csv         # yield for appending
  csv.string        # return final String
end</pre> </div> <ul>
<li> <p>Argument <code>csv_string</code>, if given, must be a String object; defaults to a new empty String.</p> </li>
<li> <p>Arguments <code>options</code>, if given, should be generating options. See <a href="#class-CSV-label-Options+for+Generating">Options for Generating</a>.</p> </li>
</ul>  <p>Creates a new CSV object via <code>CSV.new(csv_string, **options)</code>; calls the block with the CSV object, which the block may modify; returns the String generated from the CSV object.</p> <p>Note that a passed String <strong>is</strong> modified by this method. Pass <code>csv_string</code>.dup if the String must be preserved.</p> <p>This method has one additional option: <code>:encoding</code>, which sets the base <a href="encoding.html"><code>Encoding</code></a> for the output if no no <code>str</code> is specified. <a href="csv.html"><code>CSV</code></a> needs this hint if you plan to output non-ASCII compatible data.</p>  <p>Add lines:</p> <pre class="ruby" data-language="ruby">input_string = "foo,0\nbar,1\nbaz,2\n"
output_string = CSV.generate(input_string) do |csv|
  csv &lt;&lt; ['bat', 3]
  csv &lt;&lt; ['bam', 4]
end
output_string # =&gt; "foo,0\nbar,1\nbaz,2\nbat,3\nbam,4\n"
input_string # =&gt; "foo,0\nbar,1\nbaz,2\nbat,3\nbam,4\n"
output_string.equal?(input_string) # =&gt; true # Same string, modified
</pre> <p>Add lines into new string, preserving old string:</p> <pre class="ruby" data-language="ruby">input_string = "foo,0\nbar,1\nbaz,2\n"
output_string = CSV.generate(input_string.dup) do |csv|
  csv &lt;&lt; ['bat', 3]
  csv &lt;&lt; ['bam', 4]
end
output_string # =&gt; "foo,0\nbar,1\nbaz,2\nbat,3\nbam,4\n"
input_string # =&gt; "foo,0\nbar,1\nbaz,2\n"
output_string.equal?(input_string) # =&gt; false # Different strings
</pre> <p>Create lines from nothing:</p> <pre class="ruby" data-language="ruby">output_string = CSV.generate do |csv|
  csv &lt;&lt; ['foo', 0]
  csv &lt;&lt; ['bar', 1]
  csv &lt;&lt; ['baz', 2]
end
output_string # =&gt; "foo,0\nbar,1\nbaz,2\n"
</pre>  <p>Raises an exception if <code>csv_string</code> is not a String object:</p> <pre class="ruby" data-language="ruby"># Raises TypeError (no implicit conversion of Integer into String)
CSV.generate(0)
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-generate_line"> <span class="method-callseq"> generate_line(ary) </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> generate_line(ary, **options) </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="generate_line-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 1446
def generate_line(row, **options)
  options = {row_sep: InputRecordSeparator.value}.merge(options)
  str = +""
  if options[:encoding]
    str.force_encoding(options[:encoding])
  else
    fallback_encoding = nil
    output_encoding = nil
    row.each do |field|
      next unless field.is_a?(String)
      fallback_encoding ||= field.encoding
      next if field.ascii_only?
      output_encoding = field.encoding
      break
    end
    output_encoding ||= fallback_encoding
    if output_encoding
      str.force_encoding(output_encoding)
    end
  end
  (new(str, **options) &lt;&lt; row).string
end</pre> </div> <p>Returns the String created by generating CSV from <code>ary</code> using the specified <code>options</code>.</p> <p>Argument <code>ary</code> must be an Array.</p> <p>Special options:</p> <ul>
<li> <p>Option <code>:row_sep</code> defaults to <code>"\n"&gt; on Ruby 3.0 or later and &lt;tt&gt;$INPUT_RECORD_SEPARATOR</code> (<code>$/</code>) otherwise.:</p> <pre class="ruby" data-language="ruby">$INPUT_RECORD_SEPARATOR # =&gt; "\n"
</pre> </li>
<li> <p>This method accepts an additional option, <code>:encoding</code>, which sets the base <a href="encoding.html"><code>Encoding</code></a> for the output. This method will try to guess your <a href="encoding.html"><code>Encoding</code></a> from the first non-<code>nil</code> field in <code>row</code>, if possible, but you may need to use this parameter as a backup plan.</p> </li>
</ul> <p>For other <code>options</code>, see <a href="#class-CSV-label-Options+for+Generating">Options for Generating</a>.</p>  <p>Returns the String generated from an Array:</p> <pre class="ruby" data-language="ruby">CSV.generate_line(['foo', '0']) # =&gt; "foo,0\n"
</pre>  <p>Raises an exception if <code>ary</code> is not an Array:</p> <pre class="ruby" data-language="ruby"># Raises NoMethodError (undefined method `find' for :foo:Symbol)
CSV.generate_line(:foo)
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-generate_lines"> <span class="method-callseq"> generate_lines(rows) </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> generate_lines(rows, **options) </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="generate_lines-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 1501
def generate_lines(rows, **options)
  self.generate(**options) do |csv|
    rows.each do |row|
      csv &lt;&lt; row
    end
  end
end</pre> </div> <p>Returns the String created by generating CSV from using the specified <code>options</code>.</p> <p>Argument <code>rows</code> must be an Array of row. <a href="csv/row.html"><code>Row</code></a> is Array of String or CSV::Row.</p> <p>Special options:</p> <ul>
<li> <p>Option <code>:row_sep</code> defaults to <code>"\n"</code> on Ruby 3.0 or later and <code>$INPUT_RECORD_SEPARATOR</code> (<code>$/</code>) otherwise.:</p> <pre class="ruby" data-language="ruby">$INPUT_RECORD_SEPARATOR # =&gt; "\n"
</pre> </li>
<li> <p>This method accepts an additional option, <code>:encoding</code>, which sets the base <a href="encoding.html"><code>Encoding</code></a> for the output. This method will try to guess your <a href="encoding.html"><code>Encoding</code></a> from the first non-<code>nil</code> field in <code>row</code>, if possible, but you may need to use this parameter as a backup plan.</p> </li>
</ul> <p>For other <code>options</code>, see <a href="#class-CSV-label-Options+for+Generating">Options for Generating</a>.</p>  <p>Returns the String generated from an</p> <pre class="ruby" data-language="ruby">CSV.generate_lines([['foo', '0'], ['bar', '1'], ['baz', '2']]) # =&gt; "foo,0\nbar,1\nbaz,2\n"
</pre>  <p>Raises an exception</p> <pre class="ruby" data-language="ruby"># Raises NoMethodError (undefined method `each' for :foo:Symbol)
CSV.generate_lines(:foo)
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-instance"> <span class="method-callseq"> instance(string, **options) </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> instance(io = $stdout, **options) </span> </div> <div class="method-heading"> <span class="method-callseq"> instance(string, **options) {|csv| ... } </span> </div> <div class="method-heading"> <span class="method-callseq"> instance(io = $stdout, **options) {|csv| ... } </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="instance-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 1006
def instance(data = $stdout, **options)
  # create a _signature_ for this method call, data object and options
  sig = [data.object_id] +
        options.values_at(*DEFAULT_OPTIONS.keys)

  # fetch or create the instance for this signature
  @@instances ||= Hash.new
  instance = (@@instances[sig] ||= new(data, **options))

  if block_given?
    yield instance  # run block, if given, returning result
  else
    instance        # or return the instance
  end
end</pre> </div> <p>Creates or retrieves cached CSV objects. For arguments and options, see <a href="csv.html#method-c-new"><code>CSV.new</code></a>.</p> <p>This API is not Ractor-safe.</p>  <p>With no block given, returns a CSV object.</p> <p>The first call to <code>instance</code> creates and caches a CSV object:</p> <pre class="ruby" data-language="ruby">s0 = 's0'
csv0 = CSV.instance(s0)
csv0.class # =&gt; CSV
</pre> <p>Subsequent calls to <code>instance</code> with that <em>same</em> <code>string</code> or <code>io</code> retrieve that same cached object:</p> <pre class="ruby" data-language="ruby">csv1 = CSV.instance(s0)
csv1.class # =&gt; CSV
csv1.equal?(csv0) # =&gt; true # Same CSV object
</pre> <p>A subsequent call to <code>instance</code> with a <em>different</em> <code>string</code> or <code>io</code> creates and caches a <em>different</em> CSV object.</p> <pre class="ruby" data-language="ruby">s1 = 's1'
csv2 = CSV.instance(s1)
csv2.equal?(csv0) # =&gt; false # Different CSV object
</pre> <p>All the cached objects remains available:</p> <pre class="ruby" data-language="ruby">csv3 = CSV.instance(s0)
csv3.equal?(csv0) # true # Same CSV object
csv4 = CSV.instance(s1)
csv4.equal?(csv2) # true # Same CSV object
</pre>  <p>When a block is given, calls the block with the created or retrieved CSV object; returns the block’s return value:</p> <pre class="ruby" data-language="ruby">CSV.instance(s0) {|csv| :foo } # =&gt; :foo
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-new"> <span class="method-callseq"> new(string) </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> new(io) </span> </div> <div class="method-heading"> <span class="method-callseq"> new(string, **options) </span> </div> <div class="method-heading"> <span class="method-callseq"> new(io, **options) </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="new-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 1905
def initialize(data,
               col_sep: ",",
               row_sep: :auto,
               quote_char: '"',
               field_size_limit: nil,
               max_field_size: nil,
               converters: nil,
               unconverted_fields: nil,
               headers: false,
               return_headers: false,
               write_headers: nil,
               header_converters: nil,
               skip_blanks: false,
               force_quotes: false,
               skip_lines: nil,
               liberal_parsing: false,
               internal_encoding: nil,
               external_encoding: nil,
               encoding: nil,
               nil_value: nil,
               empty_value: "",
               strip: false,
               quote_empty: true,
               write_converters: nil,
               write_nil_value: nil,
               write_empty_value: "")
  raise ArgumentError.new("Cannot parse nil as CSV") if data.nil?

  if data.is_a?(String)
    if encoding
      if encoding.is_a?(String)
        data_external_encoding, data_internal_encoding = encoding.split(":", 2)
        if data_internal_encoding
          data = data.encode(data_internal_encoding, data_external_encoding)
        else
          data = data.dup.force_encoding(data_external_encoding)
        end
      else
        data = data.dup.force_encoding(encoding)
      end
    end
    @io = StringIO.new(data)
  else
    @io = data
  end
  @encoding = determine_encoding(encoding, internal_encoding)

  @base_fields_converter_options = {
    nil_value: nil_value,
    empty_value: empty_value,
  }
  @write_fields_converter_options = {
    nil_value: write_nil_value,
    empty_value: write_empty_value,
  }
  @initial_converters = converters
  @initial_header_converters = header_converters
  @initial_write_converters = write_converters

  if max_field_size.nil? and field_size_limit
    max_field_size = field_size_limit - 1
  end
  @parser_options = {
    column_separator: col_sep,
    row_separator: row_sep,
    quote_character: quote_char,
    max_field_size: max_field_size,
    unconverted_fields: unconverted_fields,
    headers: headers,
    return_headers: return_headers,
    skip_blanks: skip_blanks,
    skip_lines: skip_lines,
    liberal_parsing: liberal_parsing,
    encoding: @encoding,
    nil_value: nil_value,
    empty_value: empty_value,
    strip: strip,
  }
  @parser = nil
  @parser_enumerator = nil
  @eof_error = nil

  @writer_options = {
    encoding: @encoding,
    force_encoding: (not encoding.nil?),
    force_quotes: force_quotes,
    headers: headers,
    write_headers: write_headers,
    column_separator: col_sep,
    row_separator: row_sep,
    quote_character: quote_char,
    quote_empty: quote_empty,
  }

  @writer = nil
  writer if @writer_options[:write_headers]
end</pre> </div> <p>Returns the new CSV object created using <code>string</code> or <code>io</code> and the specified <code>options</code>.</p> <ul>
<li> <p>Argument <code>string</code> should be a String object; it will be put into a new <a href="stringio.html"><code>StringIO</code></a> object positioned at the beginning.</p> </li>
<li> <p>Argument <code>io</code> should be an <a href="io.html"><code>IO</code></a> object that is:</p> <ul>
<li> <p>Open for reading; on return, the <a href="io.html"><code>IO</code></a> object will be closed.</p> </li>
<li> <p>Positioned at the beginning. To position at the end, for appending, use method <a href="csv.html#method-c-generate"><code>CSV.generate</code></a>. For any other positioning, pass a preset StringIO object instead.</p> </li>
</ul> </li>
<li> <p>Argument <code>options</code>: See:</p> <ul>
<li> <p><a href="#class-CSV-label-Options+for+Parsing">Options for Parsing</a></p> </li>
<li> <p><a href="#class-CSV-label-Options+for+Generating">Options for Generating</a></p> </li>
</ul> <p>For performance reasons, the options cannot be overridden in a CSV object, so those specified here will endure.</p> </li>
</ul> <p>In addition to the CSV instance methods, several IO methods are delegated. See <a href="#class-CSV-label-Delegated+Methods">Delegated Methods</a>.</p>  <p>Create a CSV object from a String object:</p> <pre class="ruby" data-language="ruby">csv = CSV.new('foo,0')
csv # =&gt; #&lt;CSV io_type:StringIO encoding:UTF-8 lineno:0 col_sep:"," row_sep:"\n" quote_char:"\""&gt;
</pre> <p>Create a CSV object from a File object:</p> <pre class="ruby" data-language="ruby">File.write('t.csv', 'foo,0')
csv = CSV.new(File.open('t.csv'))
csv # =&gt; #&lt;CSV io_type:File io_path:"t.csv" encoding:UTF-8 lineno:0 col_sep:"," row_sep:"\n" quote_char:"\""&gt;
</pre>  <p>Raises an exception if the argument is <code>nil</code>:</p> <pre class="ruby" data-language="ruby"># Raises ArgumentError (Cannot parse nil as CSV):
CSV.new(nil)
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-open"> <span class="method-callseq"> open(file_path, mode = "rb", **options ) → new_csv </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> open(io, mode = "rb", **options ) → new_csv </span> </div> <div class="method-heading"> <span class="method-callseq"> open(file_path, mode = "rb", **options ) { |csv| ... } → object </span> </div> <div class="method-heading"> <span class="method-callseq"> open(io, mode = "rb", **options ) { |csv| ... } → object </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="open-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 1581
def open(filename, mode="r", **options)
  # wrap a File opened with the remaining +args+ with no newline
  # decorator
  file_opts = options.dup
  unless file_opts.key?(:newline)
    file_opts[:universal_newline] ||= false
  end
  options.delete(:invalid)
  options.delete(:undef)
  options.delete(:replace)
  options.delete_if {|k, _| /newline\z/.match?(k)}

  begin
    f = File.open(filename, mode, **file_opts)
  rescue ArgumentError =&gt; e
    raise unless /needs binmode/.match?(e.message) and mode == "r"
    mode = "rb"
    file_opts = {encoding: Encoding.default_external}.merge(file_opts)
    retry
  end
  begin
    csv = new(f, **options)
  rescue Exception
    f.close
    raise
  end

  # handle blocks like Ruby's open(), not like the CSV library
  if block_given?
    begin
      yield csv
    ensure
      csv.close
    end
  else
    csv
  end
end</pre> </div> <p>possible options elements:</p> <pre>keyword form:
  :invalid =&gt; nil      # raise error on invalid byte sequence (default)
  :invalid =&gt; :replace # replace invalid byte sequence
  :undef =&gt; :replace   # replace undefined conversion
  :replace =&gt; string   # replacement string ("?" or "\uFFFD" if not specified)</pre> <ul>
<li> <p>Argument <code>path</code>, if given, must be the path to a file.</p> </li>
<li> <p>Argument <code>io</code> should be an <a href="io.html"><code>IO</code></a> object that is:</p> <ul>
<li> <p>Open for reading; on return, the <a href="io.html"><code>IO</code></a> object will be closed.</p> </li>
<li> <p>Positioned at the beginning. To position at the end, for appending, use method <a href="csv.html#method-c-generate"><code>CSV.generate</code></a>. For any other positioning, pass a preset StringIO object instead.</p> </li>
</ul> </li>
<li> <p>Argument <code>mode</code>, if given, must be a File mode. See <a href="file.html#class-File-label-Access+Modes">Access Modes</a>.</p> </li>
<li> <p>Arguments <code>**options</code> must be keyword options. See <a href="#class-CSV-label-Options+for+Generating">Options for Generating</a>.</p> </li>
<li> <p>This method optionally accepts an additional <code>:encoding</code> option that you can use to specify the <a href="encoding.html"><code>Encoding</code></a> of the data read from <code>path</code> or <code>io</code>. You must provide this unless your data is in the encoding given by <code>Encoding::default_external</code>. Parsing will use this to determine how to parse the data. You may provide a second <a href="encoding.html"><code>Encoding</code></a> to have the data transcoded as it is read. For example,</p> <pre>encoding: 'UTF-32BE:UTF-8'</pre> <p>would read <code>UTF-32BE</code> data from the file but transcode it to <code>UTF-8</code> before parsing.</p> </li>
</ul>  <p>These examples assume prior execution of:</p> <pre class="ruby" data-language="ruby">string = "foo,0\nbar,1\nbaz,2\n"
path = 't.csv'
File.write(path, string)
</pre>  <p>With no block given, returns a new CSV object.</p> <p>Create a CSV object using a file path:</p> <pre class="ruby" data-language="ruby">csv = CSV.open(path)
csv # =&gt; #&lt;CSV io_type:File io_path:"t.csv" encoding:UTF-8 lineno:0 col_sep:"," row_sep:"\n" quote_char:"\""&gt;
</pre> <p>Create a CSV object using an open File:</p> <pre class="ruby" data-language="ruby">csv = CSV.open(File.open(path))
csv # =&gt; #&lt;CSV io_type:File io_path:"t.csv" encoding:UTF-8 lineno:0 col_sep:"," row_sep:"\n" quote_char:"\""&gt;
</pre>  <p>With a block given, calls the block with the created CSV object; returns the block’s return value:</p> <p>Using a file path:</p> <pre class="ruby" data-language="ruby">csv = CSV.open(path) {|csv| p csv}
csv # =&gt; #&lt;CSV io_type:File io_path:"t.csv" encoding:UTF-8 lineno:0 col_sep:"," row_sep:"\n" quote_char:"\""&gt;
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">#&lt;CSV io_type:File io_path:"t.csv" encoding:UTF-8 lineno:0 col_sep:"," row_sep:"\n" quote_char:"\""&gt;
</pre> <p>Using an open File:</p> <pre class="ruby" data-language="ruby">csv = CSV.open(File.open(path)) {|csv| p csv}
csv # =&gt; #&lt;CSV io_type:File io_path:"t.csv" encoding:UTF-8 lineno:0 col_sep:"," row_sep:"\n" quote_char:"\""&gt;
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">#&lt;CSV io_type:File io_path:"t.csv" encoding:UTF-8 lineno:0 col_sep:"," row_sep:"\n" quote_char:"\""&gt;
</pre>  <p>Raises an exception if the argument is not a String object or IO object:</p> <pre class="ruby" data-language="ruby"># Raises TypeError (no implicit conversion of Symbol into String)
CSV.open(:foo)
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-parse"> <span class="method-callseq"> parse(string) → array_of_arrays </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> parse(io) → array_of_arrays </span> </div> <div class="method-heading"> <span class="method-callseq"> parse(string, headers: ..., **options) → csv_table </span> </div> <div class="method-heading"> <span class="method-callseq"> parse(io, headers: ..., **options) → csv_table </span> </div> <div class="method-heading"> <span class="method-callseq"> parse(string, **options) {|row| ... } </span> </div> <div class="method-heading"> <span class="method-callseq"> parse(io, **options) {|row| ... } </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="parse-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 1732
def parse(str, **options, &amp;block)
  csv = new(str, **options)

  return csv.each(&amp;block) if block_given?

  # slurp contents, if no block is given
  begin
    csv.read
  ensure
    csv.close
  end
end</pre> </div> <p>Parses <code>string</code> or <code>io</code> using the specified <code>options</code>.</p> <ul>
<li> <p>Argument <code>string</code> should be a String object; it will be put into a new <a href="stringio.html"><code>StringIO</code></a> object positioned at the beginning.</p> </li>
<li> <p>Argument <code>io</code> should be an <a href="io.html"><code>IO</code></a> object that is:</p> <ul>
<li> <p>Open for reading; on return, the <a href="io.html"><code>IO</code></a> object will be closed.</p> </li>
<li> <p>Positioned at the beginning. To position at the end, for appending, use method <a href="csv.html#method-c-generate"><code>CSV.generate</code></a>. For any other positioning, pass a preset StringIO object instead.</p> </li>
</ul> </li>
<li> <p>Argument <code>options</code>: see <a href="#class-CSV-label-Options+for+Parsing">Options for Parsing</a></p> </li>
</ul> <h6 id="method-c-parse-label-Without+Option+headers">Without Option <code>headers</code>
</h6> <p>Without {option <code>headers</code><a href="#class-CSV-label-Option+headers">}</a> case.</p> <p>These examples assume prior execution of:</p> <pre class="ruby" data-language="ruby">string = "foo,0\nbar,1\nbaz,2\n"
path = 't.csv'
File.write(path, string)
</pre>  <p>With no block given, returns an Array of Arrays formed from the source.</p> <p>Parse a String:</p> <pre class="ruby" data-language="ruby">a_of_a = CSV.parse(string)
a_of_a # =&gt; [["foo", "0"], ["bar", "1"], ["baz", "2"]]
</pre> <p>Parse an open File:</p> <pre class="ruby" data-language="ruby">a_of_a = File.open(path) do |file|
  CSV.parse(file)
end
a_of_a # =&gt; [["foo", "0"], ["bar", "1"], ["baz", "2"]]
</pre>  <p>With a block given, calls the block with each parsed row:</p> <p>Parse a String:</p> <pre class="ruby" data-language="ruby">CSV.parse(string) {|row| p row }
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">["foo", "0"]
["bar", "1"]
["baz", "2"]
</pre> <p>Parse an open File:</p> <pre class="ruby" data-language="ruby">File.open(path) do |file|
  CSV.parse(file) {|row| p row }
end
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">["foo", "0"]
["bar", "1"]
["baz", "2"]
</pre> <h6 id="method-c-parse-label-With+Option+headers">With Option <code>headers</code>
</h6> <p>With {option <code>headers</code><a href="#class-CSV-label-Option+headers">}</a> case.</p> <p>These examples assume prior execution of:</p> <pre class="ruby" data-language="ruby">string = "Name,Count\nfoo,0\nbar,1\nbaz,2\n"
path = 't.csv'
File.write(path, string)
</pre>  <p>With no block given, returns a <a href="csv/table.html"><code>CSV::Table</code></a> object formed from the source.</p> <p>Parse a String:</p> <pre class="ruby" data-language="ruby">csv_table = CSV.parse(string, headers: ['Name', 'Count'])
csv_table # =&gt; #&lt;CSV::Table mode:col_or_row row_count:5&gt;
</pre> <p>Parse an open File:</p> <pre class="ruby" data-language="ruby">csv_table = File.open(path) do |file|
  CSV.parse(file, headers: ['Name', 'Count'])
end
csv_table # =&gt; #&lt;CSV::Table mode:col_or_row row_count:4&gt;
</pre>  <p>With a block given, calls the block with each parsed row, which has been formed into a <a href="csv/row.html"><code>CSV::Row</code></a> object:</p> <p>Parse a String:</p> <pre class="ruby" data-language="ruby">CSV.parse(string, headers: ['Name', 'Count']) {|row| p row }
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby"># &lt;CSV::Row "Name":"foo" "Count":"0"&gt;
# &lt;CSV::Row "Name":"bar" "Count":"1"&gt;
# &lt;CSV::Row "Name":"baz" "Count":"2"&gt;
</pre> <p>Parse an open File:</p> <pre class="ruby" data-language="ruby">File.open(path) do |file|
  CSV.parse(file, headers: ['Name', 'Count']) {|row| p row }
end
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby"># &lt;CSV::Row "Name":"foo" "Count":"0"&gt;
# &lt;CSV::Row "Name":"bar" "Count":"1"&gt;
# &lt;CSV::Row "Name":"baz" "Count":"2"&gt;
</pre>  <p>Raises an exception if the argument is not a String object or IO object:</p> <pre class="ruby" data-language="ruby"># Raises NoMethodError (undefined method `close' for :foo:Symbol)
CSV.parse(:foo)
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-parse_line"> <span class="method-callseq"> parse_line(string) → new_array or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> parse_line(io) → new_array or nil </span> </div> <div class="method-heading"> <span class="method-callseq"> parse_line(string, **options) → new_array or nil </span> </div> <div class="method-heading"> <span class="method-callseq"> parse_line(io, **options) → new_array or nil </span> </div> <div class="method-heading"> <span class="method-callseq"> parse_line(string, headers: true, **options) → csv_row or nil </span> </div> <div class="method-heading"> <span class="method-callseq"> parse_line(io, headers: true, **options) → csv_row or nil </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="parse_line-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 1805
def parse_line(line, **options)
  new(line, **options).each.first
end</pre> </div> <p>Returns the data created by parsing the first line of <code>string</code> or <code>io</code> using the specified <code>options</code>.</p> <ul>
<li> <p>Argument <code>string</code> should be a String object; it will be put into a new <a href="stringio.html"><code>StringIO</code></a> object positioned at the beginning.</p> </li>
<li> <p>Argument <code>io</code> should be an <a href="io.html"><code>IO</code></a> object that is:</p> <ul>
<li> <p>Open for reading; on return, the <a href="io.html"><code>IO</code></a> object will be closed.</p> </li>
<li> <p>Positioned at the beginning. To position at the end, for appending, use method <a href="csv.html#method-c-generate"><code>CSV.generate</code></a>. For any other positioning, pass a preset StringIO object instead.</p> </li>
</ul> </li>
<li> <p>Argument <code>options</code>: see <a href="#class-CSV-label-Options+for+Parsing">Options for Parsing</a></p> </li>
</ul> <h6 id="method-c-parse_line-label-Without+Option+headers">Without Option <code>headers</code>
</h6> <p>Without option <code>headers</code>, returns the first row as a new Array.</p> <p>These examples assume prior execution of:</p> <pre class="ruby" data-language="ruby">string = "foo,0\nbar,1\nbaz,2\n"
path = 't.csv'
File.write(path, string)
</pre> <p>Parse the first line from a String object:</p> <pre class="ruby" data-language="ruby">CSV.parse_line(string) # =&gt; ["foo", "0"]
</pre> <p>Parse the first line from a <a href="file.html"><code>File</code></a> object:</p> <pre class="ruby" data-language="ruby">File.open(path) do |file|
  CSV.parse_line(file) # =&gt; ["foo", "0"]
end # =&gt; ["foo", "0"]
</pre> <p>Returns <code>nil</code> if the argument is an empty String:</p> <pre class="ruby" data-language="ruby">CSV.parse_line('') # =&gt; nil
</pre> <h6 id="method-c-parse_line-label-With+Option+headers">With Option <code>headers</code>
</h6> <p>With {option <code>headers</code><a href="#class-CSV-label-Option+headers">}</a>, returns the first row as a <a href="csv/row.html"><code>CSV::Row</code></a> object.</p> <p>These examples assume prior execution of:</p> <pre class="ruby" data-language="ruby">string = "Name,Count\nfoo,0\nbar,1\nbaz,2\n"
path = 't.csv'
File.write(path, string)
</pre> <p>Parse the first line from a String object:</p> <pre class="ruby" data-language="ruby">CSV.parse_line(string, headers: true) # =&gt; #&lt;CSV::Row "Name":"foo" "Count":"0"&gt;
</pre> <p>Parse the first line from a <a href="file.html"><code>File</code></a> object:</p> <pre class="ruby" data-language="ruby">File.open(path) do |file|
  CSV.parse_line(file, headers: true)
end # =&gt; #&lt;CSV::Row "Name":"foo" "Count":"0"&gt;
</pre>  <p>Raises an exception if the argument is <code>nil</code>:</p> <pre class="ruby" data-language="ruby"># Raises ArgumentError (Cannot parse nil as CSV):
CSV.parse_line(nil)
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-read"> <span class="method-callseq"> read(source, **options) → array_of_arrays </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> read(source, headers: true, **options) → csv_table </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="read-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 1829
def read(path, **options)
  open(path, **options) { |csv| csv.read }
end</pre> </div> <p>Opens the given <code>source</code> with the given <code>options</code> (see <a href="csv.html#method-c-open"><code>CSV.open</code></a>), reads the source (see <a href="csv.html#method-i-read"><code>CSV#read</code></a>), and returns the result, which will be either an Array of Arrays or a <a href="csv/table.html"><code>CSV::Table</code></a>.</p> <p>Without headers:</p> <pre class="ruby" data-language="ruby">string = "foo,0\nbar,1\nbaz,2\n"
path = 't.csv'
File.write(path, string)
CSV.read(path) # =&gt; [["foo", "0"], ["bar", "1"], ["baz", "2"]]
</pre> <p>With headers:</p> <pre class="ruby" data-language="ruby">string = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
path = 't.csv'
File.write(path, string)
CSV.read(path, headers: true) # =&gt; #&lt;CSV::Table mode:col_or_row row_count:4&gt;
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-readlines"> <span class="method-callseq"> readlines(source, **options) </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="readlines-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 1837
def readlines(path, **options)
  read(path, **options)
end</pre> </div> <p>Alias for <a href="csv.html#method-c-read"><code>CSV.read</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-table"> <span class="method-callseq"> table(source, **options) </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="table-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 1856
def table(path, **options)
  default_options = {
    headers:           true,
    converters:        :numeric,
    header_converters: :symbol,
  }
  options = default_options.merge(options)
  read(path, **options)
end</pre> </div> <p>Calls <a href="csv.html#method-c-read"><code>CSV.read</code></a> with <code>source</code>, <code>options</code>, and certain default options:</p> <ul>
<li> <p><code>headers</code>: <code>true</code></p> </li>
<li> <p><code>converters</code>: <code>:numeric</code></p> </li>
<li> <p><code>header_converters</code>: <code>:symbol</code></p> </li>
</ul> <p>Returns a <a href="csv/table.html"><code>CSV::Table</code></a> object.</p> <p>Example:</p> <pre class="ruby" data-language="ruby">string = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
path = 't.csv'
File.write(path, string)
CSV.table(path) # =&gt; #&lt;CSV::Table mode:col_or_row row_count:4&gt;
</pre>  </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-3C-3C"> <span class="method-callseq"> csv &lt;&lt; row → self </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="3C-3C-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2372
def &lt;&lt;(row)
  writer &lt;&lt; row
  self
end</pre> </div> <p>Appends a row to <code>self</code>.</p> <ul>
<li> <p>Argument <code>row</code> must be an Array object or a <a href="csv/row.html"><code>CSV::Row</code></a> object.</p> </li>
<li> <p>The output stream must be open for writing.</p> </li>
</ul>  <p>Append Arrays:</p> <pre class="ruby" data-language="ruby">CSV.generate do |csv|
  csv &lt;&lt; ['foo', 0]
  csv &lt;&lt; ['bar', 1]
  csv &lt;&lt; ['baz', 2]
end # =&gt; "foo,0\nbar,1\nbaz,2\n"
</pre> <p>Append CSV::Rows:</p> <pre class="ruby" data-language="ruby">headers = []
CSV.generate do |csv|
  csv &lt;&lt; CSV::Row.new(headers, ['foo', 0])
  csv &lt;&lt; CSV::Row.new(headers, ['bar', 1])
  csv &lt;&lt; CSV::Row.new(headers, ['baz', 2])
end # =&gt; "foo,0\nbar,1\nbaz,2\n"
</pre> <p>Headers in <a href="csv/row.html"><code>CSV::Row</code></a> objects are not appended:</p> <pre class="ruby" data-language="ruby">headers = ['Name', 'Count']
CSV.generate do |csv|
  csv &lt;&lt; CSV::Row.new(headers, ['foo', 0])
  csv &lt;&lt; CSV::Row.new(headers, ['bar', 1])
  csv &lt;&lt; CSV::Row.new(headers, ['baz', 2])
end # =&gt; "foo,0\nbar,1\nbaz,2\n"
</pre>  <p>Raises an exception if <code>row</code> is not an Array or CSV::Row:</p> <pre class="ruby" data-language="ruby">CSV.generate do |csv|
  # Raises NoMethodError (undefined method `collect' for :foo:Symbol)
  csv &lt;&lt; :foo
end
</pre> <p>Raises an exception if the output stream is not opened for writing:</p> <pre class="ruby" data-language="ruby">path = 't.csv'
File.write(path, '')
File.open(path) do |file|
  CSV.open(file) do |csv|
    # Raises IOError (not opened for writing)
    csv &lt;&lt; ['foo', 0]
  end
end
</pre>  </div> <div class="aliases"> Also aliased as: <a href="csv.html#method-i-add_row">add_row</a>, <a href="csv.html#method-i-puts">puts</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-add_row"> <span class="method-name">add_row</span> </div> </div> <div class="aliases"> Alias for: <a href="csv.html#method-i-3C-3C">&lt;&lt;</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-binmode-3F"> <span class="method-name">binmode?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="binmode-3F-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2261
def binmode?
  if @io.respond_to?(:binmode?)
    @io.binmode?
  else
    false
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-col_sep"> <span class="method-callseq"> col_sep → string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="col_sep-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2009
def col_sep
  parser.column_separator
end</pre> </div> <p>Returns the encoded column separator; used for parsing and writing; see {Option <code>col_sep</code><a href="#class-CSV-label-Option+col_sep">}</a>:</p> <pre class="ruby" data-language="ruby">CSV.new('').col_sep # =&gt; ","
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-convert"> <span class="method-callseq"> convert(converter_name) → array_of_procs </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> convert {|field, field_info| ... } → array_of_procs </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="convert-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2443
def convert(name = nil, &amp;converter)
  parser_fields_converter.add_converter(name, &amp;converter)
end</pre> </div> <ul>
<li> <p>With no block, installs a field converter (a Proc).</p> </li>
<li> <p>With a block, defines and installs a custom field converter.</p> </li>
<li> <p>Returns the Array of installed field converters.</p> </li>
<li> <p>Argument <code>converter_name</code>, if given, should be the name of an existing field converter.</p> </li>
</ul> <p>See <a href="#class-CSV-label-Field+Converters">Field Converters</a>.</p>  <p>With no block, installs a field converter:</p> <pre class="ruby" data-language="ruby">csv = CSV.new('')
csv.convert(:integer)
csv.convert(:float)
csv.convert(:date)
csv.converters # =&gt; [:integer, :float, :date]
</pre>  <p>The block, if given, is called for each field:</p> <ul>
<li> <p>Argument <code>field</code> is the field value.</p> </li>
<li> <p>Argument <code>field_info</code> is a <a href="csv.html#FieldInfo"><code>CSV::FieldInfo</code></a> object containing details about the field.</p> </li>
</ul> <p>The examples here assume the prior execution of:</p> <pre class="ruby" data-language="ruby">string = "foo,0\nbar,1\nbaz,2\n"
path = 't.csv'
File.write(path, string)
</pre> <p>Example giving a block:</p> <pre class="ruby" data-language="ruby">csv = CSV.open(path)
csv.convert {|field, field_info| p [field, field_info]; field.upcase }
csv.read # =&gt; [["FOO", "0"], ["BAR", "1"], ["BAZ", "2"]]
</pre> <p>Output:</p> <pre>["foo", #&lt;struct CSV::FieldInfo index=0, line=1, header=nil&gt;]
["0", #&lt;struct CSV::FieldInfo index=1, line=1, header=nil&gt;]
["bar", #&lt;struct CSV::FieldInfo index=0, line=2, header=nil&gt;]
["1", #&lt;struct CSV::FieldInfo index=1, line=2, header=nil&gt;]
["baz", #&lt;struct CSV::FieldInfo index=0, line=3, header=nil&gt;]
["2", #&lt;struct CSV::FieldInfo index=1, line=3, header=nil&gt;]</pre> <p>The block need not return a String object:</p> <pre class="ruby" data-language="ruby">csv = CSV.open(path)
csv.convert {|field, field_info| field.to_sym }
csv.read # =&gt; [[:foo, :"0"], [:bar, :"1"], [:baz, :"2"]]
</pre> <p>If <code>converter_name</code> is given, the block is not called:</p> <pre class="ruby" data-language="ruby">csv = CSV.open(path)
csv.convert(:integer) {|field, field_info| fail 'Cannot happen' }
csv.read # =&gt; [["foo", 0], ["bar", 1], ["baz", 2]]
</pre>  <p>Raises a parse-time exception if <code>converter_name</code> is not the name of a built-in field converter:</p> <pre class="ruby" data-language="ruby">csv = CSV.open(path)
csv.convert(:nosuch) =&gt; [nil]
# Raises NoMethodError (undefined method `arity' for nil:NilClass)
csv.read
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-converters"> <span class="method-callseq"> converters → array </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="converters-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2082
def converters
  parser_fields_converter.map do |converter|
    name = Converters.rassoc(converter)
    name ? name.first : converter
  end
end</pre> </div> <p>Returns an Array containing field converters; see <a href="#class-CSV-label-Field+Converters">Field Converters</a>:</p> <pre class="ruby" data-language="ruby">csv = CSV.new('')
csv.converters # =&gt; []
csv.convert(:integer)
csv.converters # =&gt; [:integer]
csv.convert(proc {|x| x.to_s })
csv.converters
</pre> <p>Notes that you need to call +Ractor.make_shareable(<a href="csv.html#Converters"><code>CSV::Converters</code></a>)+ on the main <a href="ractor.html"><code>Ractor</code></a> to use this method.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-each"> <span class="method-callseq"> each → enumerator </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> each {|row| ...} </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="each-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2554
def each(&amp;block)
  return to_enum(__method__) unless block_given?
  begin
    while true
      yield(parser_enumerator.next)
    end
  rescue StopIteration
  end
end</pre> </div> <p>Calls the block with each successive row. The data source must be opened for reading.</p> <p>Without headers:</p> <pre class="ruby" data-language="ruby">string = "foo,0\nbar,1\nbaz,2\n"
csv = CSV.new(string)
csv.each do |row|
  p row
end
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">["foo", "0"]
["bar", "1"]
["baz", "2"]
</pre> <p>With headers:</p> <pre class="ruby" data-language="ruby">string = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
csv = CSV.new(string, headers: true)
csv.each do |row|
  p row
end
</pre> <p>Output:</p> <pre>&lt;CSV::Row "Name":"foo" "Value":"0"&gt;
&lt;CSV::Row "Name":"bar" "Value":"1"&gt;
&lt;CSV::Row "Name":"baz" "Value":"2"&gt;</pre>  <p>Raises an exception if the source is not opened for reading:</p> <pre class="ruby" data-language="ruby">string = "foo,0\nbar,1\nbaz,2\n"
csv = CSV.new(string)
csv.close
# Raises IOError (not opened for reading)
csv.each do |row|
  p row
end
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-eof"> <span class="method-name">eof</span><span class="method-args">()</span> </div> </div>  <div class="aliases"> Alias for: <a href="csv.html#method-i-eof-3F">eof?</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-eof-3F"> <span class="method-name">eof?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="eof-3F-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2297
def eof?
  return false if @eof_error
  begin
    parser_enumerator.peek
    false
  rescue MalformedCSVError =&gt; error
    @eof_error = error
    false
  rescue StopIteration
    true
  end
end</pre> </div>  </div> <div class="aliases"> Also aliased as: <a href="csv.html#method-i-eof">eof</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-field_size_limit"> <span class="method-callseq"> field_size_limit → integer or nil </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="field_size_limit-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2041
def field_size_limit
  parser.field_size_limit
end</pre> </div> <p>Returns the limit for field size; used for parsing; see {Option <code>field_size_limit</code><a href="#class-CSV-label-Option+field_size_limit">}</a>:</p> <pre class="ruby" data-language="ruby">CSV.new('').field_size_limit # =&gt; nil
</pre> <p>Deprecated since 3.2.3. Use <code>max_field_size</code> instead.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-flock"> <span class="method-name">flock</span><span class="method-args">(*args)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="flock-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2269
def flock(*args)
  raise NotImplementedError unless @io.respond_to?(:flock)
  @io.flock(*args)
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-force_quotes-3F"> <span class="method-callseq"> force_quotes? → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="force_quotes-3F-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2172
def force_quotes?
  @writer_options[:force_quotes]
end</pre> </div> <p>Returns the value that determines whether all output fields are to be quoted; used for generating; see {Option <code>force_quotes</code><a href="#class-CSV-label-Option+force_quotes">}</a>:</p> <pre class="ruby" data-language="ruby">CSV.new('').force_quotes? # =&gt; false
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-gets"> <span class="method-name">gets</span> </div> </div> <div class="aliases"> Alias for: <a href="csv.html#method-i-shift">shift</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-header_convert"> <span class="method-name">header_convert</span><span class="method-args">(name = nil, &amp;converter)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="header_convert-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2509
def header_convert(name = nil, &amp;converter)
  header_fields_converter.add_converter(name, &amp;converter)
end</pre> </div> <p>The block need not return a String object:</p> <pre class="ruby" data-language="ruby">csv = CSV.open(path, headers: true)
csv.header_convert {|header, field_info| header.to_sym }
table = csv.read
table.headers # =&gt; [:Name, :Value]
</pre> <p>If <code>converter_name</code> is given, the block is not called:</p> <pre class="ruby" data-language="ruby">csv = CSV.open(path, headers: true)
csv.header_convert(:downcase) {|header, field_info| fail 'Cannot happen' }
table = csv.read
table.headers # =&gt; ["name", "value"]
</pre>  <p>Raises a parse-time exception if <code>converter_name</code> is not the name of a built-in field converter:</p> <pre class="ruby" data-language="ruby">csv = CSV.open(path, headers: true)
csv.header_convert(:nosuch)
# Raises NoMethodError (undefined method `arity' for nil:NilClass)
csv.read
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-header_converters"> <span class="method-callseq"> header_converters → array </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="header_converters-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2148
def header_converters
  header_fields_converter.map do |converter|
    name = HeaderConverters.rassoc(converter)
    name ? name.first : converter
  end
end</pre> </div> <p>Returns an Array containing header converters; used for parsing; see <a href="#class-CSV-label-Header+Converters">Header Converters</a>:</p> <pre class="ruby" data-language="ruby">CSV.new('').header_converters # =&gt; []
</pre> <p>Notes that you need to call +Ractor.make_shareable(<a href="csv.html#HeaderConverters"><code>CSV::HeaderConverters</code></a>)+ on the main <a href="ractor.html"><code>Ractor</code></a> to use this method.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-header_row-3F"> <span class="method-callseq"> header_row? → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="header_row-3F-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2631
def header_row?
  parser.header_row?
end</pre> </div> <p>Returns <code>true</code> if the next row to be read is a header row; <code>false</code> otherwise.</p> <p>Without headers:</p> <pre class="ruby" data-language="ruby">string = "foo,0\nbar,1\nbaz,2\n"
csv = CSV.new(string)
csv.header_row? # =&gt; false
</pre> <p>With headers:</p> <pre class="ruby" data-language="ruby">string = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
csv = CSV.new(string, headers: true)
csv.header_row? # =&gt; true
csv.shift # =&gt; #&lt;CSV::Row "Name":"foo" "Value":"0"&gt;
csv.header_row? # =&gt; false
</pre>  <p>Raises an exception if the source is not opened for reading:</p> <pre class="ruby" data-language="ruby">string = "foo,0\nbar,1\nbaz,2\n"
csv = CSV.new(string)
csv.close
# Raises IOError (not opened for reading)
csv.header_row?
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-headers"> <span class="method-callseq"> headers → object </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="headers-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2106
def headers
  if @writer
    @writer.headers
  else
    parsed_headers = parser.headers
    return parsed_headers if parsed_headers
    raw_headers = @parser_options[:headers]
    raw_headers = nil if raw_headers == false
    raw_headers
  end
end</pre> </div> <p>Returns the value that determines whether headers are used; used for parsing; see {Option <code>headers</code><a href="#class-CSV-label-Option+headers">}</a>:</p> <pre class="ruby" data-language="ruby">CSV.new('').headers # =&gt; nil
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-inspect"> <span class="method-callseq"> inspect → string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="inspect-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2690
def inspect
  str = ["#&lt;", self.class.to_s, " io_type:"]
  # show type of wrapped IO
  if    @io == $stdout then str &lt;&lt; "$stdout"
  elsif @io == $stdin  then str &lt;&lt; "$stdin"
  elsif @io == $stderr then str &lt;&lt; "$stderr"
  else                      str &lt;&lt; @io.class.to_s
  end
  # show IO.path(), if available
  if @io.respond_to?(:path) and (p = @io.path)
    str &lt;&lt; " io_path:" &lt;&lt; p.inspect
  end
  # show encoding
  str &lt;&lt; " encoding:" &lt;&lt; @encoding.name
  # show other attributes
  ["lineno", "col_sep", "row_sep", "quote_char"].each do |attr_name|
    if a = __send__(attr_name)
      str &lt;&lt; " " &lt;&lt; attr_name &lt;&lt; ":" &lt;&lt; a.inspect
    end
  end
  ["skip_blanks", "liberal_parsing"].each do |attr_name|
    if a = __send__("#{attr_name}?")
      str &lt;&lt; " " &lt;&lt; attr_name &lt;&lt; ":" &lt;&lt; a.inspect
    end
  end
  _headers = headers
  str &lt;&lt; " headers:" &lt;&lt; _headers.inspect if _headers
  str &lt;&lt; "&gt;"
  begin
    str.join('')
  rescue  # any encoding error
    str.map do |s|
      e = Encoding::Converter.asciicompat_encoding(s.encoding)
      e ? s.encode(e) : s.force_encoding("ASCII-8BIT")
    end.join('')
  end
end</pre> </div> <p>Returns a String showing certain properties of <code>self</code>:</p> <pre class="ruby" data-language="ruby">string = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
csv = CSV.new(string, headers: true)
s = csv.inspect
s # =&gt; "#&lt;CSV io_type:StringIO encoding:UTF-8 lineno:0 col_sep:\",\" row_sep:\"\\n\" quote_char:\"\\\"\" headers:true&gt;"
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-ioctl"> <span class="method-name">ioctl</span><span class="method-args">(*args)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="ioctl-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2274
def ioctl(*args)
  raise NotImplementedError unless @io.respond_to?(:ioctl)
  @io.ioctl(*args)
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-liberal_parsing-3F"> <span class="method-callseq"> liberal_parsing? → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="liberal_parsing-3F-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2182
def liberal_parsing?
  parser.liberal_parsing?
end</pre> </div> <p>Returns the value that determines whether illegal input is to be handled; used for parsing; see {Option <code>liberal_parsing</code><a href="#class-CSV-label-Option+liberal_parsing">}</a>:</p> <pre class="ruby" data-language="ruby">CSV.new('').liberal_parsing? # =&gt; false
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-line"> <span class="method-callseq"> line → array </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="line-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2247
def line
  parser.line
end</pre> </div> <p>Returns the line most recently read:</p> <pre class="ruby" data-language="ruby">string = "foo,0\nbar,1\nbaz,2\n"
path = 't.csv'
File.write(path, string)
CSV.open(path) do |csv|
  csv.each do |row|
    p [csv.lineno, csv.line]
  end
end
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">[1, "foo,0\n"]
[2, "bar,1\n"]
[3, "baz,2\n"]
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-lineno"> <span class="method-callseq"> line_no → integer </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="lineno-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2223
def lineno
  if @writer
    @writer.lineno
  else
    parser.lineno
  end
end</pre> </div> <p>Returns the count of the rows parsed or generated.</p> <p>Parsing:</p> <pre class="ruby" data-language="ruby">string = "foo,0\nbar,1\nbaz,2\n"
path = 't.csv'
File.write(path, string)
CSV.open(path) do |csv|
  csv.each do |row|
    p [csv.lineno, row]
  end
end
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">[1, ["foo", "0"]]
[2, ["bar", "1"]]
[3, ["baz", "2"]]
</pre> <p>Generating:</p> <pre class="ruby" data-language="ruby">CSV.generate do |csv|
  p csv.lineno; csv &lt;&lt; ['foo', 0]
  p csv.lineno; csv &lt;&lt; ['bar', 1]
  p csv.lineno; csv &lt;&lt; ['baz', 2]
end
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">0
1
2
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-max_field_size"> <span class="method-callseq"> max_field_size → integer or nil </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="max_field_size-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2053
def max_field_size
  parser.max_field_size
end</pre> </div> <p>Returns the limit for field size; used for parsing; see {Option <code>max_field_size</code><a href="#class-CSV-label-Option+max_field_size">}</a>:</p> <pre class="ruby" data-language="ruby">CSV.new('').max_field_size # =&gt; nil
</pre> <p>Since 3.2.3.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-path"> <span class="method-name">path</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="path-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2279
def path
  @io.path if @io.respond_to?(:path)
end</pre> </div>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-puts"> <span class="method-name">puts</span> </div> </div> <div class="aliases"> Alias for: <a href="csv.html#method-i-3C-3C">&lt;&lt;</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-quote_char"> <span class="method-callseq"> quote_char → character </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="quote_char-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2029
def quote_char
  parser.quote_character
end</pre> </div> <p>Returns the encoded quote character; used for parsing and writing; see {Option <code>quote_char</code><a href="#class-CSV-label-Option+quote_char">}</a>:</p> <pre class="ruby" data-language="ruby">CSV.new('').quote_char # =&gt; "\""
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-read"> <span class="method-callseq"> read → array or csv_table </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="read-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2595
def read
  rows = to_a
  if parser.use_headers?
    Table.new(rows, headers: parser.headers)
  else
    rows
  end
end</pre> </div> <p>Forms the remaining rows from <code>self</code> into:</p> <ul>
<li> <p>A <a href="csv/table.html"><code>CSV::Table</code></a> object, if headers are in use.</p> </li>
<li> <p>An Array of Arrays, otherwise.</p> </li>
</ul> <p>The data source must be opened for reading.</p> <p>Without headers:</p> <pre class="ruby" data-language="ruby">string = "foo,0\nbar,1\nbaz,2\n"
path = 't.csv'
File.write(path, string)
csv = CSV.open(path)
csv.read # =&gt; [["foo", "0"], ["bar", "1"], ["baz", "2"]]
</pre> <p>With headers:</p> <pre class="ruby" data-language="ruby">string = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
path = 't.csv'
File.write(path, string)
csv = CSV.open(path, headers: true)
csv.read # =&gt; #&lt;CSV::Table mode:col_or_row row_count:4&gt;
</pre>  <p>Raises an exception if the source is not opened for reading:</p> <pre class="ruby" data-language="ruby">string = "foo,0\nbar,1\nbaz,2\n"
csv = CSV.new(string)
csv.close
# Raises IOError (not opened for reading)
csv.read
</pre>  </div> <div class="aliases"> Also aliased as: <a href="csv.html#method-i-readlines">readlines</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-readline"> <span class="method-name">readline</span> </div> </div> <div class="aliases"> Alias for: <a href="csv.html#method-i-shift">shift</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-readlines"> <span class="method-name">readlines</span> </div> </div> <div class="aliases"> Alias for: <a href="csv.html#method-i-read">read</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-return_headers-3F"> <span class="method-callseq"> return_headers? → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="return_headers-3F-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2124
def return_headers?
  parser.return_headers?
end</pre> </div> <p>Returns the value that determines whether headers are to be returned; used for parsing; see {Option <code>return_headers</code><a href="#class-CSV-label-Option+return_headers">}</a>:</p> <pre class="ruby" data-language="ruby">CSV.new('').return_headers? # =&gt; false
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-rewind"> <span class="method-name">rewind</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="rewind-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2312
def rewind
  @parser = nil
  @parser_enumerator = nil
  @eof_error = nil
  @writer.rewind if @writer
  @io.rewind
end</pre> </div> <p>Rewinds the underlying <a href="io.html"><code>IO</code></a> object and resets CSV’s lineno() counter.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-row_sep"> <span class="method-callseq"> row_sep → string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="row_sep-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2019
def row_sep
  parser.row_separator
end</pre> </div> <p>Returns the encoded row separator; used for parsing and writing; see {Option <code>row_sep</code><a href="#class-CSV-label-Option+row_sep">}</a>:</p> <pre class="ruby" data-language="ruby">CSV.new('').row_sep # =&gt; "\n"
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-shift"> <span class="method-callseq"> shift → array, csv_row, or nil </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="shift-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2668
def shift
  if @eof_error
    eof_error, @eof_error = @eof_error, nil
    raise eof_error
  end
  begin
    parser_enumerator.next
  rescue StopIteration
    nil
  end
end</pre> </div> <p>Returns the next row of data as:</p> <ul>
<li> <p>An Array if no headers are used.</p> </li>
<li> <p>A <a href="csv/row.html"><code>CSV::Row</code></a> object if headers are used.</p> </li>
</ul> <p>The data source must be opened for reading.</p> <p>Without headers:</p> <pre class="ruby" data-language="ruby">string = "foo,0\nbar,1\nbaz,2\n"
csv = CSV.new(string)
csv.shift # =&gt; ["foo", "0"]
csv.shift # =&gt; ["bar", "1"]
csv.shift # =&gt; ["baz", "2"]
csv.shift # =&gt; nil
</pre> <p>With headers:</p> <pre class="ruby" data-language="ruby">string = "Name,Value\nfoo,0\nbar,1\nbaz,2\n"
csv = CSV.new(string, headers: true)
csv.shift # =&gt; #&lt;CSV::Row "Name":"foo" "Value":"0"&gt;
csv.shift # =&gt; #&lt;CSV::Row "Name":"bar" "Value":"1"&gt;
csv.shift # =&gt; #&lt;CSV::Row "Name":"baz" "Value":"2"&gt;
csv.shift # =&gt; nil
</pre>  <p>Raises an exception if the source is not opened for reading:</p> <pre class="ruby" data-language="ruby">string = "foo,0\nbar,1\nbaz,2\n"
csv = CSV.new(string)
csv.close
# Raises IOError (not opened for reading)
csv.shift
</pre>  </div> <div class="aliases"> Also aliased as: <a href="csv.html#method-i-gets">gets</a>, <a href="csv.html#method-i-readline">readline</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-skip_blanks-3F"> <span class="method-callseq"> skip_blanks? → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="skip_blanks-3F-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2161
def skip_blanks?
  parser.skip_blanks?
end</pre> </div> <p>Returns the value that determines whether blank lines are to be ignored; used for parsing; see {Option <code>skip_blanks</code><a href="#class-CSV-label-Option+skip_blanks">}</a>:</p> <pre class="ruby" data-language="ruby">CSV.new('').skip_blanks? # =&gt; false
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-skip_lines"> <span class="method-callseq"> skip_lines → regexp or nil </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="skip_lines-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2063
def skip_lines
  parser.skip_lines
end</pre> </div> <p>Returns the Regexp used to identify comment lines; used for parsing; see {Option <code>skip_lines</code><a href="#class-CSV-label-Option+skip_lines">}</a>:</p> <pre class="ruby" data-language="ruby">CSV.new('').skip_lines # =&gt; nil
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-stat"> <span class="method-name">stat</span><span class="method-args">(*args)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="stat-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2283
def stat(*args)
  raise NotImplementedError unless @io.respond_to?(:stat)
  @io.stat(*args)
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-to_i"> <span class="method-name">to_i</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="to_i-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2288
def to_i
  raise NotImplementedError unless @io.respond_to?(:to_i)
  @io.to_i
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-to_io"> <span class="method-name">to_io</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="to_io-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2293
def to_io
  @io.respond_to?(:to_io) ? @io.to_io : @io
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-unconverted_fields-3F"> <span class="method-callseq"> unconverted_fields? → object </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="unconverted_fields-3F-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2096
def unconverted_fields?
  parser.unconverted_fields?
end</pre> </div> <p>Returns the value that determines whether unconverted fields are to be available; used for parsing; see {Option <code>unconverted_fields</code><a href="#class-CSV-label-Option+unconverted_fields">}</a>:</p> <pre class="ruby" data-language="ruby">CSV.new('').unconverted_fields? # =&gt; nil
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-write_headers-3F"> <span class="method-callseq"> write_headers? → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="write_headers-3F-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2134
def write_headers?
  @writer_options[:write_headers]
end</pre> </div> <p>Returns the value that determines whether headers are to be written; used for generating; see {Option <code>write_headers</code><a href="#class-CSV-label-Option+write_headers">}</a>:</p> <pre class="ruby" data-language="ruby">CSV.new('').write_headers? # =&gt; nil
</pre>  </div> </div> </section> <section id="private-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Private Instance Methods</h3> </header> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-build_fields_converter"> <span class="method-name">build_fields_converter</span><span class="method-args">(initial_converters, options)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="build_fields_converter-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2822
def build_fields_converter(initial_converters, options)
  fields_converter = FieldsConverter.new(options)
  normalize_converters(initial_converters).each do |name, converter|
    fields_converter.add_converter(name, &amp;converter)
  end
  fields_converter
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-build_header_fields_converter"> <span class="method-name">build_header_fields_converter</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="build_header_fields_converter-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2804
def build_header_fields_converter
  specific_options = {
    builtin_converters_name: :HeaderConverters,
    accept_nil: true,
  }
  options = @base_fields_converter_options.merge(specific_options)
  build_fields_converter(@initial_header_converters, options)
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-build_parser_fields_converter"> <span class="method-name">build_parser_fields_converter</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="build_parser_fields_converter-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2792
def build_parser_fields_converter
  specific_options = {
    builtin_converters_name: :Converters,
  }
  options = @base_fields_converter_options.merge(specific_options)
  build_fields_converter(@initial_converters, options)
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-build_writer_fields_converter"> <span class="method-name">build_writer_fields_converter</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="build_writer_fields_converter-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2817
def build_writer_fields_converter
  build_fields_converter(@initial_write_converters,
                         @write_fields_converter_options)
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-convert_fields"> <span class="method-name">convert_fields</span><span class="method-args">(fields, headers = false)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="convert_fields-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2767
def convert_fields(fields, headers = false)
  if headers
    header_fields_converter.convert(fields, nil, 0)
  else
    parser_fields_converter.convert(fields, @headers, lineno)
  end
end</pre> </div> <p>Processes <code>fields</code> with <code>@converters</code>, or <code>@header_converters</code> if <code>headers</code> is passed as <code>true</code>, returning the converted field set. Any converter that changes the field into something other than a <a href="string.html"><code>String</code></a> halts the pipeline of conversion for that field. This is primarily an efficiency shortcut.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-determine_encoding"> <span class="method-name">determine_encoding</span><span class="method-args">(encoding, internal_encoding)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="determine_encoding-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2730
def determine_encoding(encoding, internal_encoding)
  # honor the IO encoding if we can, otherwise default to ASCII-8BIT
  io_encoding = raw_encoding
  return io_encoding if io_encoding

  return Encoding.find(internal_encoding) if internal_encoding

  if encoding
    encoding, = encoding.split(":", 2) if encoding.is_a?(String)
    return Encoding.find(encoding)
  end

  Encoding.default_internal || Encoding.default_external
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-header_fields_converter"> <span class="method-name">header_fields_converter</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="header_fields_converter-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2800
def header_fields_converter
  @header_fields_converter ||= build_header_fields_converter
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-normalize_converters"> <span class="method-name">normalize_converters</span><span class="method-args">(converters)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="normalize_converters-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2745
def normalize_converters(converters)
  converters ||= []
  unless converters.is_a?(Array)
    converters = [converters]
  end
  converters.collect do |converter|
    case converter
    when Proc # custom code block
      [nil, converter]
    else # by name
      [converter, nil]
    end
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-parser"> <span class="method-name">parser</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="parser-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2830
def parser
  @parser ||= Parser.new(@io, parser_options)
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-parser_enumerator"> <span class="method-name">parser_enumerator</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="parser_enumerator-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2839
def parser_enumerator
  @parser_enumerator ||= parser.parse
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-parser_fields_converter"> <span class="method-name">parser_fields_converter</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="parser_fields_converter-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2788
def parser_fields_converter
  @parser_fields_converter ||= build_parser_fields_converter
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-parser_options"> <span class="method-name">parser_options</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="parser_options-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2834
def parser_options
  @parser_options.merge(header_fields_converter: header_fields_converter,
                        fields_converter: parser_fields_converter)
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-raw_encoding"> <span class="method-name">raw_encoding</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="raw_encoding-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2778
def raw_encoding
  if @io.respond_to? :internal_encoding
    @io.internal_encoding || @io.external_encoding
  elsif @io.respond_to? :encoding
    @io.encoding
  else
    nil
  end
end</pre> </div> <p>Returns the encoding of the internal <a href="io.html"><code>IO</code></a> object.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-writer"> <span class="method-name">writer</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="writer-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2843
def writer
  @writer ||= Writer.new(@io, writer_options)
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-writer_fields_converter"> <span class="method-name">writer_fields_converter</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="writer_fields_converter-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2813
def writer_fields_converter
  @writer_fields_converter ||= build_writer_fields_converter
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-writer_options"> <span class="method-name">writer_options</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="writer_options-source"> <pre class="ruby" data-language="ruby"># File lib/csv.rb, line 2847
def writer_options
  @writer_options.merge(header_fields_converter: header_fields_converter,
                        fields_converter: writer_fields_converter)
end</pre> </div>  </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core &copy; 1993&ndash;2022 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library &copy; contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>
