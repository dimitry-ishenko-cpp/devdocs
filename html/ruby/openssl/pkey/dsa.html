<h1 id="class-OpenSSL::PKey::DSA" class="class"> class OpenSSL::PKey::DSA </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent"><a href="pkey.html">OpenSSL::PKey::PKey</a></dd>
<dt>Included modules:</dt>
<dd class="meta-includes"><a class="include" href="../marshal.html">OpenSSL::Marshal</a></dd>
</dl> <section class="description"> <p><a href="dsa.html"><code>DSA</code></a>, the Digital Signature Algorithm, is specified in NIST’s FIPS 186-3. It is an asymmetric public key algorithm that may be used similar to e.g. <a href="rsa.html"><code>RSA</code></a>.</p> </section> <section id="5Buntitled-5D" class="documentation-section"> <section id="public-class-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-generate"> <span class="method-callseq"> generate(size) → dsa </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="generate-source"> <pre class="ruby" data-language="ruby"># File ext/openssl/lib/openssl/pkey.rb, line 169
def generate(size, &amp;blk)
  # FIPS 186-4 specifies four (L,N) pairs: (1024,160), (2048,224),
  # (2048,256), and (3072,256).
  #
  # q size is derived here with compatibility with
  # DSA_generator_parameters_ex() which previous versions of ruby/openssl
  # used to call.
  qsize = size &gt;= 2048 ? 256 : 160
  dsaparams = OpenSSL::PKey.generate_parameters("DSA", {
    "dsa_paramgen_bits" =&gt; size,
    "dsa_paramgen_q_bits" =&gt; qsize,
  }, &amp;blk)
  OpenSSL::PKey.generate_key(dsaparams)
end</pre> </div> <p>Creates a new <a href="dsa.html"><code>DSA</code></a> instance by generating a private/public key pair from scratch.</p> <p>See also <a href="../pkey.html#method-c-generate_parameters"><code>OpenSSL::PKey.generate_parameters</code></a> and <a href="../pkey.html#method-c-generate_key"><code>OpenSSL::PKey.generate_key</code></a>.</p> <dl class="rdoc-list note-list">
<dt>
<code>size</code> </dt>
<dd> <p>The desired key size in bits.</p> </dd>
</dl>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-new"> <span class="method-callseq"> new → dsa </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> new(string [, pass]) → dsa </span> </div> <div class="method-heading"> <span class="method-callseq"> new(size) → dsa </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="new-source"> <pre class="c" data-language="c">static VALUE
ossl_dsa_initialize(int argc, VALUE *argv, VALUE self)
{
    EVP_PKEY *pkey;
    DSA *dsa;
    BIO *in = NULL;
    VALUE arg, pass;
    int type;

    TypedData_Get_Struct(self, EVP_PKEY, &amp;ossl_evp_pkey_type, pkey);
    if (pkey)
        rb_raise(rb_eTypeError, "pkey already initialized");

    /* The DSA.new(size, generator) form is handled by lib/openssl/pkey.rb */
    rb_scan_args(argc, argv, "02", &amp;arg, &amp;pass);
    if (argc == 0) {
        dsa = DSA_new();
        if (!dsa)
            ossl_raise(eDSAError, "DSA_new");
        goto legacy;
    }

    pass = ossl_pem_passwd_value(pass);
    arg = ossl_to_der_if_possible(arg);
    in = ossl_obj2bio(&amp;arg);

    /* DER-encoded DSAPublicKey format isn't supported by the generic routine */
    dsa = (DSA *)PEM_ASN1_read_bio((d2i_of_void *)d2i_DSAPublicKey,
                                   PEM_STRING_DSA_PUBLIC,
                                   in, NULL, NULL, NULL);
    if (dsa)
        goto legacy;
    OSSL_BIO_reset(in);

    pkey = ossl_pkey_read_generic(in, pass);
    BIO_free(in);
    if (!pkey)
        ossl_raise(eDSAError, "Neither PUB key nor PRIV key");

    type = EVP_PKEY_base_id(pkey);
    if (type != EVP_PKEY_DSA) {
        EVP_PKEY_free(pkey);
        rb_raise(eDSAError, "incorrect pkey type: %s", OBJ_nid2sn(type));
    }
    RTYPEDDATA_DATA(self) = pkey;
    return self;

  legacy:
    BIO_free(in);
    pkey = EVP_PKEY_new();
    if (!pkey || EVP_PKEY_assign_DSA(pkey, dsa) != 1) {
        EVP_PKEY_free(pkey);
        DSA_free(dsa);
        ossl_raise(eDSAError, "EVP_PKEY_assign_DSA");
    }
    RTYPEDDATA_DATA(self) = pkey;
    return self;
}</pre> </div> <p>Creates a new <a href="dsa.html"><code>DSA</code></a> instance by reading an existing key from <em>string</em>.</p> <p>If called without arguments, creates a new instance with no key components set. They can be set individually by <a href="dsa.html#method-i-set_pqg"><code>set_pqg</code></a> and <a href="dsa.html#method-i-set_key"><code>set_key</code></a>.</p> <p>If called with a <a href="../../string.html"><code>String</code></a>, tries to parse as DER or PEM encoding of a DSA key. See also <a href="../pkey.html#method-c-read"><code>OpenSSL::PKey.read</code></a> which can parse keys of any kinds.</p> <p>If called with a number, generates random parameters and a key pair. This form works as an alias of <a href="dsa.html#method-c-generate"><code>DSA.generate</code></a>.</p> <dl class="rdoc-list note-list">
<dt>
<code>string</code> </dt>
<dd> <p>A <a href="../../string.html"><code>String</code></a> that contains a DER or PEM encoded key.</p> </dd>
<dt>
<code>pass</code> </dt>
<dd> <p>A <a href="../../string.html"><code>String</code></a> that contains an optional password.</p> </dd>
<dt>
<code>size</code> </dt>
<dd> <p>See <a href="dsa.html#method-c-generate"><code>DSA.generate</code></a>.</p> </dd>
</dl> <p>Examples:</p> <pre class="ruby" data-language="ruby">p OpenSSL::PKey::DSA.new(1024)
#=&gt; #&lt;OpenSSL::PKey::DSA:0x000055a8d6025bf0 oid=DSA&gt;

p OpenSSL::PKey::DSA.new(File.read('dsa.pem'))
#=&gt; #&lt;OpenSSL::PKey::DSA:0x000055555d6b8110 oid=DSA&gt;

p OpenSSL::PKey::DSA.new(File.read('dsa.pem'), 'mypassword')
#=&gt; #&lt;OpenSSL::PKey::DSA:0x0000556f973c40b8 oid=DSA&gt;
</pre>  </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-export"> <span class="method-callseq"> export([cipher, password]) → aString </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="export-source"> <pre class="c" data-language="c">static VALUE
ossl_dsa_export(int argc, VALUE *argv, VALUE self)
{
    OSSL_3_const DSA *dsa;

    GetDSA(self, dsa);
    if (DSA_HAS_PRIVATE(dsa))
        return ossl_pkey_export_traditional(argc, argv, self, 0);
    else
        return ossl_pkey_export_spki(self, 0);
}</pre> </div> <p>Serializes a private or public key to a PEM-encoding.</p> <dl class="rdoc-list label-list">
<dt>When the key contains public components only </dt>
<dd> <p>Serializes it into an X.509 SubjectPublicKeyInfo. The parameters <em>cipher</em> and <em>password</em> are ignored.</p> <p>A PEM-encoded key will look like:</p> <pre>-----BEGIN PUBLIC KEY-----
[...]
-----END PUBLIC KEY-----</pre> <p>Consider using <a href="pkey.html#method-i-public_to_pem"><code>public_to_pem</code></a> instead. This serializes the key into an X.509 SubjectPublicKeyInfo regardless of whether it is a public key or a private key.</p> </dd>
<dt>When the key contains private components, and no parameters are given </dt>
<dd> <p>Serializes it into a traditional OpenSSL DSAPrivateKey.</p> <p>A PEM-encoded key will look like:</p> <pre>-----BEGIN DSA PRIVATE KEY-----
[...]
-----END DSA PRIVATE KEY-----</pre> </dd>
<dt>When the key contains private components, and <em>cipher</em> and <em>password</em> are given </dt>
<dd> <p>Serializes it into a traditional OpenSSL DSAPrivateKey and encrypts it in OpenSSL’s traditional PEM encryption format. <em>cipher</em> must be a cipher name understood by <a href="../cipher.html#method-c-new"><code>OpenSSL::Cipher.new</code></a> or an instance of <a href="../cipher.html"><code>OpenSSL::Cipher</code></a>.</p> <p>An encrypted PEM-encoded key will look like:</p> <pre>-----BEGIN DSA PRIVATE KEY-----
Proc-Type: 4,ENCRYPTED
DEK-Info: AES-128-CBC,733F5302505B34701FC41F5C0746E4C0

[...]
-----END DSA PRIVATE KEY-----</pre> <p>Note that this format uses MD5 to derive the encryption key, and hence will not be available on FIPS-compliant systems.</p> </dd>
</dl> <p><strong>This method is kept for compatibility.</strong> This should only be used when the traditional, non-standard OpenSSL format is required.</p> <p>Consider using <a href="pkey.html#method-i-public_to_pem"><code>public_to_pem</code></a> (X.509 SubjectPublicKeyInfo) or <a href="pkey.html#method-i-private_to_pem"><code>private_to_pem</code></a> (PKCS #8 PrivateKeyInfo or EncryptedPrivateKeyInfo) instead.</p>  </div> <div class="aliases"> Also aliased as: <a href="dsa.html#method-i-to_pem">to_pem</a>, <a href="dsa.html#method-i-to_s">to_s</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-initialize_copy"> <span class="method-name">initialize_copy</span><span class="method-args">(p1)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="initialize_copy-source"> <pre class="c" data-language="c">HAVE_EVP_PKEY_DUP
static VALUE
ossl_dsa_initialize_copy(VALUE self, VALUE other)
{
    EVP_PKEY *pkey;
    DSA *dsa, *dsa_new;

    TypedData_Get_Struct(self, EVP_PKEY, &amp;ossl_evp_pkey_type, pkey);
    if (pkey)
        rb_raise(rb_eTypeError, "pkey already initialized");
    GetDSA(other, dsa);

    dsa_new = (DSA *)ASN1_dup((i2d_of_void *)i2d_DSAPrivateKey,
                              (d2i_of_void *)d2i_DSAPrivateKey,
                              (char *)dsa);
    if (!dsa_new)
        ossl_raise(eDSAError, "ASN1_dup");

    pkey = EVP_PKEY_new();
    if (!pkey || EVP_PKEY_assign_DSA(pkey, dsa_new) != 1) {
        EVP_PKEY_free(pkey);
        DSA_free(dsa_new);
        ossl_raise(eDSAError, "EVP_PKEY_assign_DSA");
    }
    RTYPEDDATA_DATA(self) = pkey;

    return self;
}</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-params"> <span class="method-callseq"> params → hash </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="params-source"> <pre class="c" data-language="c">static VALUE
ossl_dsa_get_params(VALUE self)
{
    OSSL_3_const DSA *dsa;
    VALUE hash;
    const BIGNUM *p, *q, *g, *pub_key, *priv_key;

    GetDSA(self, dsa);
    DSA_get0_pqg(dsa, &amp;p, &amp;q, &amp;g);
    DSA_get0_key(dsa, &amp;pub_key, &amp;priv_key);

    hash = rb_hash_new();
    rb_hash_aset(hash, rb_str_new2("p"), ossl_bn_new(p));
    rb_hash_aset(hash, rb_str_new2("q"), ossl_bn_new(q));
    rb_hash_aset(hash, rb_str_new2("g"), ossl_bn_new(g));
    rb_hash_aset(hash, rb_str_new2("pub_key"), ossl_bn_new(pub_key));
    rb_hash_aset(hash, rb_str_new2("priv_key"), ossl_bn_new(priv_key));

    return hash;
}</pre> </div> <p>Stores all parameters of key to the hash INSECURE: PRIVATE INFORMATIONS CAN LEAK OUT!!! Don’t use :-)) (I’s up to you)</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-private-3F"> <span class="method-callseq"> private? → true | false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="private-3F-source"> <pre class="c" data-language="c">static VALUE
ossl_dsa_is_private(VALUE self)
{
    OSSL_3_const DSA *dsa;

    GetDSA(self, dsa);

    return DSA_PRIVATE(self, dsa) ? Qtrue : Qfalse;
}</pre> </div> <p>Indicates whether this <a href="dsa.html"><code>DSA</code></a> instance has a private key associated with it or not. The private key may be retrieved with DSA#private_key.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-public-3F"> <span class="method-callseq"> public? → true | false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="public-3F-source"> <pre class="c" data-language="c">static VALUE
ossl_dsa_is_public(VALUE self)
{
    const DSA *dsa;
    const BIGNUM *bn;

    GetDSA(self, dsa);
    DSA_get0_key(dsa, &amp;bn, NULL);

    return bn ? Qtrue : Qfalse;
}</pre> </div> <p>Indicates whether this <a href="dsa.html"><code>DSA</code></a> instance has a public key associated with it or not. The public key may be retrieved with <a href="dsa.html#method-i-public_key"><code>DSA#public_key</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-public_key"> <span class="method-callseq"> public_key → dsanew </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="public_key-source"> <pre class="ruby" data-language="ruby"># File ext/openssl/lib/openssl/pkey.rb, line 153
def public_key
  OpenSSL::PKey.read(public_to_der)
end</pre> </div> <p>Returns a new <a href="dsa.html"><code>DSA</code></a> instance that carries just the DSA parameters and the public key.</p> <p>This method is provided for backwards compatibility. In most cases, there is no need to call this method.</p> <p>For the purpose of serializing the public key, to PEM or DER encoding of X.509 SubjectPublicKeyInfo format, check <a href="pkey.html#method-i-public_to_pem"><code>PKey#public_to_pem</code></a> and <a href="pkey.html#method-i-public_to_der"><code>PKey#public_to_der</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-set_key"> <span class="method-callseq"> set_key(pub_key, priv_key) → self </span> </div> </div> <div class="method-description"> <p>Sets <em>pub_key</em> and <em>priv_key</em> for the <a href="dsa.html"><code>DSA</code></a> instance. <em>priv_key</em> may be <code>nil</code>.</p> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-set_pqg"> <span class="method-callseq"> set_pqg(p, q, g) → self </span> </div> </div> <div class="method-description"> <p>Sets <em>p</em>, <em>q</em>, <em>g</em> to the <a href="dsa.html"><code>DSA</code></a> instance.</p> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-syssign"> <span class="method-callseq"> syssign(string) → string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="syssign-source"> <pre class="ruby" data-language="ruby"># File ext/openssl/lib/openssl/pkey.rb, line 220
def syssign(string)
  q or raise OpenSSL::PKey::DSAError, "incomplete DSA"
  private? or raise OpenSSL::PKey::DSAError, "Private DSA key needed!"
  begin
    sign_raw(nil, string)
  rescue OpenSSL::PKey::PKeyError
    raise OpenSSL::PKey::DSAError, $!.message
  end
end</pre> </div> <p>Computes and returns the DSA signature of <code>string</code>, where <code>string</code> is expected to be an already-computed message digest of the original input data. The signature is issued using the private key of this <a href="dsa.html"><code>DSA</code></a> instance.</p> <p><strong>Deprecated in version 3.0</strong>. Consider using <a href="pkey.html#method-i-sign_raw"><code>PKey::PKey#sign_raw</code></a> and <a href="pkey.html#method-i-verify_raw"><code>PKey::PKey#verify_raw</code></a> instead.</p> <dl class="rdoc-list note-list">
<dt>
<code>string</code> </dt>
<dd> <p>A message digest of the original input data to be signed.</p> </dd>
</dl> <p>Example:</p> <pre class="ruby" data-language="ruby">dsa = OpenSSL::PKey::DSA.new(2048)
doc = "Sign me"
digest = OpenSSL::Digest.digest('SHA1', doc)

# With legacy #syssign and #sysverify:
sig = dsa.syssign(digest)
p dsa.sysverify(digest, sig) #=&gt; true

# With #sign_raw and #verify_raw:
sig = dsa.sign_raw(nil, digest)
p dsa.verify_raw(nil, sig, digest) #=&gt; true
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-sysverify"> <span class="method-callseq"> sysverify(digest, sig) → true | false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="sysverify-source"> <pre class="ruby" data-language="ruby"># File ext/openssl/lib/openssl/pkey.rb, line 243
def sysverify(digest, sig)
  verify_raw(nil, sig, digest)
rescue OpenSSL::PKey::PKeyError
  raise OpenSSL::PKey::DSAError, $!.message
end</pre> </div> <p>Verifies whether the signature is valid given the message digest input. It does so by validating <code>sig</code> using the public key of this <a href="dsa.html"><code>DSA</code></a> instance.</p> <p><strong>Deprecated in version 3.0</strong>. Consider using <a href="pkey.html#method-i-sign_raw"><code>PKey::PKey#sign_raw</code></a> and <a href="pkey.html#method-i-verify_raw"><code>PKey::PKey#verify_raw</code></a> instead.</p> <dl class="rdoc-list note-list">
<dt>
<code>digest</code> </dt>
<dd> <p>A message digest of the original input data to be signed.</p> </dd>
<dt>
<code>sig</code> </dt>
<dd> <p>A DSA signature value.</p> </dd>
</dl>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-to_der"> <span class="method-callseq"> to_der → aString </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="to_der-source"> <pre class="c" data-language="c">static VALUE
ossl_dsa_to_der(VALUE self)
{
    OSSL_3_const DSA *dsa;

    GetDSA(self, dsa);
    if (DSA_HAS_PRIVATE(dsa))
        return ossl_pkey_export_traditional(0, NULL, self, 1);
    else
        return ossl_pkey_export_spki(self, 1);
}</pre> </div> <p>Serializes a private or public key to a DER-encoding.</p> <p>See <a href="dsa.html#method-i-to_pem"><code>to_pem</code></a> for details.</p> <p><strong>This method is kept for compatibility.</strong> This should only be used when the traditional, non-standard OpenSSL format is required.</p> <p>Consider using <a href="pkey.html#method-i-public_to_der"><code>public_to_der</code></a> or <a href="pkey.html#method-i-private_to_der"><code>private_to_der</code></a> instead.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-to_pem"> <span class="method-callseq"> to_pem([cipher, password]) → aString </span> </div> </div> <div class="method-description"> <p>Serializes a private or public key to a PEM-encoding.</p> <dl class="rdoc-list label-list">
<dt>When the key contains public components only </dt>
<dd> <p>Serializes it into an X.509 SubjectPublicKeyInfo. The parameters <em>cipher</em> and <em>password</em> are ignored.</p> <p>A PEM-encoded key will look like:</p> <pre>-----BEGIN PUBLIC KEY-----
[...]
-----END PUBLIC KEY-----</pre> <p>Consider using <a href="pkey.html#method-i-public_to_pem"><code>public_to_pem</code></a> instead. This serializes the key into an X.509 SubjectPublicKeyInfo regardless of whether it is a public key or a private key.</p> </dd>
<dt>When the key contains private components, and no parameters are given </dt>
<dd> <p>Serializes it into a traditional OpenSSL DSAPrivateKey.</p> <p>A PEM-encoded key will look like:</p> <pre>-----BEGIN DSA PRIVATE KEY-----
[...]
-----END DSA PRIVATE KEY-----</pre> </dd>
<dt>When the key contains private components, and <em>cipher</em> and <em>password</em> are given </dt>
<dd> <p>Serializes it into a traditional OpenSSL DSAPrivateKey and encrypts it in OpenSSL’s traditional PEM encryption format. <em>cipher</em> must be a cipher name understood by <a href="../cipher.html#method-c-new"><code>OpenSSL::Cipher.new</code></a> or an instance of <a href="../cipher.html"><code>OpenSSL::Cipher</code></a>.</p> <p>An encrypted PEM-encoded key will look like:</p> <pre>-----BEGIN DSA PRIVATE KEY-----
Proc-Type: 4,ENCRYPTED
DEK-Info: AES-128-CBC,733F5302505B34701FC41F5C0746E4C0

[...]
-----END DSA PRIVATE KEY-----</pre> <p>Note that this format uses MD5 to derive the encryption key, and hence will not be available on FIPS-compliant systems.</p> </dd>
</dl> <p><strong>This method is kept for compatibility.</strong> This should only be used when the traditional, non-standard OpenSSL format is required.</p> <p>Consider using <a href="pkey.html#method-i-public_to_pem"><code>public_to_pem</code></a> (X.509 SubjectPublicKeyInfo) or <a href="pkey.html#method-i-private_to_pem"><code>private_to_pem</code></a> (PKCS #8 PrivateKeyInfo or EncryptedPrivateKeyInfo) instead.</p> </div> <div class="aliases"> Alias for: <a href="dsa.html#method-i-export">export</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-to_s"> <span class="method-callseq"> to_s([cipher, password]) → aString </span> </div> </div> <div class="method-description"> <p>Serializes a private or public key to a PEM-encoding.</p> <dl class="rdoc-list label-list">
<dt>When the key contains public components only </dt>
<dd> <p>Serializes it into an X.509 SubjectPublicKeyInfo. The parameters <em>cipher</em> and <em>password</em> are ignored.</p> <p>A PEM-encoded key will look like:</p> <pre>-----BEGIN PUBLIC KEY-----
[...]
-----END PUBLIC KEY-----</pre> <p>Consider using <a href="pkey.html#method-i-public_to_pem"><code>public_to_pem</code></a> instead. This serializes the key into an X.509 SubjectPublicKeyInfo regardless of whether it is a public key or a private key.</p> </dd>
<dt>When the key contains private components, and no parameters are given </dt>
<dd> <p>Serializes it into a traditional OpenSSL DSAPrivateKey.</p> <p>A PEM-encoded key will look like:</p> <pre>-----BEGIN DSA PRIVATE KEY-----
[...]
-----END DSA PRIVATE KEY-----</pre> </dd>
<dt>When the key contains private components, and <em>cipher</em> and <em>password</em> are given </dt>
<dd> <p>Serializes it into a traditional OpenSSL DSAPrivateKey and encrypts it in OpenSSL’s traditional PEM encryption format. <em>cipher</em> must be a cipher name understood by <a href="../cipher.html#method-c-new"><code>OpenSSL::Cipher.new</code></a> or an instance of <a href="../cipher.html"><code>OpenSSL::Cipher</code></a>.</p> <p>An encrypted PEM-encoded key will look like:</p> <pre>-----BEGIN DSA PRIVATE KEY-----
Proc-Type: 4,ENCRYPTED
DEK-Info: AES-128-CBC,733F5302505B34701FC41F5C0746E4C0

[...]
-----END DSA PRIVATE KEY-----</pre> <p>Note that this format uses MD5 to derive the encryption key, and hence will not be available on FIPS-compliant systems.</p> </dd>
</dl> <p><strong>This method is kept for compatibility.</strong> This should only be used when the traditional, non-standard OpenSSL format is required.</p> <p>Consider using <a href="pkey.html#method-i-public_to_pem"><code>public_to_pem</code></a> (X.509 SubjectPublicKeyInfo) or <a href="pkey.html#method-i-private_to_pem"><code>private_to_pem</code></a> (PKCS #8 PrivateKeyInfo or EncryptedPrivateKeyInfo) instead.</p> </div> <div class="aliases"> Alias for: <a href="dsa.html#method-i-export">export</a> </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core &copy; 1993&ndash;2022 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library &copy; contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>
