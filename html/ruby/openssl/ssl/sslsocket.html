<h1 id="class-OpenSSL::SSL::SSLSocket" class="anchor-link class"> class OpenSSL::SSL::SSLSocket </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent"><a href="../../object.html">Object</a></dd>
<dt>Included modules:</dt>
<dd class="meta-includes">
<a class="include" href="../buffering.html">OpenSSL::Buffering</a>, <a class="include" href="socketforwarder.html">OpenSSL::SSL::SocketForwarder</a>
</dd>
</dl>  <section id="5Buntitled-5D" class="documentation-section anchor-link"> <section class="attribute-method-details"> <header> <h3>Attributes</h3> </header> <div class="method-detail anchor-link"> <div class="method-heading attribute-method-heading" id="attribute-i-context"> <a href="#attribute-i-context" title="Link to this attribute"> <span class="method-name">context</span> <span class="attribute-access-type">[R]</span> </a> </div> <div class="method-description"> <p>The <a href="sslcontext.html"><code>SSLContext</code></a> object used in this connection.</p> </div> </div> <div class="method-detail anchor-link"> <div class="method-heading attribute-method-heading" id="attribute-i-hostname"> <a href="#attribute-i-hostname" title="Link to this attribute"> <span class="method-name">hostname</span> <span class="attribute-access-type">[R]</span> </a> </div>  </div> <div class="method-detail anchor-link"> <div class="method-heading attribute-method-heading" id="attribute-i-io"> <a href="#attribute-i-io" title="Link to this attribute"> <span class="method-name">io</span> <span class="attribute-access-type">[R]</span> </a> </div> <div class="method-description"> <p>The underlying <a href="../../io.html"><code>IO</code></a> object.</p> </div> </div> <div class="method-detail anchor-link"> <div class="method-heading attribute-method-heading" id="attribute-i-sync_close"> <a href="#attribute-i-sync_close" title="Link to this attribute"> <span class="method-name">sync_close</span> <span class="attribute-access-type">[RW]</span> </a> </div> <div class="method-description"> <p>Whether to close the underlying socket as well, when the SSL/TLS connection is shut down. This defaults to <code>false</code>.</p> </div> </div> <div class="method-detail anchor-link"> <div class="method-heading attribute-method-heading" id="attribute-i-to_io"> <a href="#attribute-i-to_io" title="Link to this attribute"> <span class="method-name">to_io</span> <span class="attribute-access-type">[R]</span> </a> </div> <div class="method-description"> <p>The underlying <a href="../../io.html"><code>IO</code></a> object.</p> </div> </div> </section> <section id="public-class-5Buntitled-5D-method-details" class="method-section anchor-link"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-new"> <a href="#method-c-new" title="Link to this method"> <span class="method-callseq"> new(io) → aSSLSocket </span> </a> </div> <div class="method-heading"> <a href="#method-c-new" title="Link to this method"> <span class="method-callseq"> new(io, ctx) → aSSLSocket </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="new-source"> <pre class="c" data-language="c">static VALUE
ossl_ssl_initialize(int argc, VALUE *argv, VALUE self)
{
    VALUE io, v_ctx;
    SSL *ssl;
    SSL_CTX *ctx;

    TypedData_Get_Struct(self, SSL, &amp;ossl_ssl_type, ssl);
    if (ssl)
        ossl_raise(eSSLError, "SSL already initialized");

    if (rb_scan_args(argc, argv, "11", &amp;io, &amp;v_ctx) == 1)
        v_ctx = rb_funcall(cSSLContext, rb_intern("new"), 0);

    GetSSLCTX(v_ctx, ctx);
    rb_ivar_set(self, id_i_context, v_ctx);
    ossl_sslctx_setup(v_ctx);

    if (rb_respond_to(io, rb_intern("nonblock=")))
        rb_funcall(io, rb_intern("nonblock="), 1, Qtrue);
    Check_Type(io, T_FILE);
    rb_ivar_set(self, id_i_io, io);

    ssl = SSL_new(ctx);
    if (!ssl)
        ossl_raise(eSSLError, NULL);
    RTYPEDDATA_DATA(self) = ssl;

    SSL_set_ex_data(ssl, ossl_ssl_ex_ptr_idx, (void *)self);
    SSL_set_info_callback(ssl, ssl_info_cb);

    rb_call_super(0, NULL);

    return self;
}</pre> </div>  <p>Creates a new <a href="../ssl.html"><code>SSL</code></a> socket from <em>io</em> which must be a real <a href="../../io.html"><code>IO</code></a> object (not an IO-like object that responds to read/write).</p> <p>If <em>ctx</em> is provided the <a href="../ssl.html"><code>SSL</code></a> Sockets initial params will be taken from the context.</p> <p>The <a href="../buffering.html"><code>OpenSSL::Buffering</code></a> module provides additional <a href="../../io.html"><code>IO</code></a> methods.</p> <p>This method will freeze the <a href="sslcontext.html"><code>SSLContext</code></a> if one is provided; however, session management is still allowed in the frozen <a href="sslcontext.html"><code>SSLContext</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-open"> <a href="#method-c-open" title="Link to this method"> <span class="method-callseq"> open(remote_host, remote_port, local_host=nil, local_port=nil, context: nil) </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="open-source"> <pre class="ruby" data-language="ruby"># File ext/openssl/lib/openssl/ssl.rb, line 533
def open(remote_host, remote_port, local_host=nil, local_port=nil, context: nil)
  sock = ::TCPSocket.open(remote_host, remote_port, local_host, local_port)
  if context.nil?
    return OpenSSL::SSL::SSLSocket.new(sock)
  else
    return OpenSSL::SSL::SSLSocket.new(sock, context)
  end
end</pre> </div>  <p>Creates a new instance of <a href="sslsocket.html"><code>SSLSocket</code></a>. <em>remote</em>host_ and <em>remote</em>port_ are used to open <a href="../../tcpsocket.html"><code>TCPSocket</code></a>. If <em>local</em>host_ and <em>local</em>port_ are specified, then those parameters are used on the local end to establish the connection. If <em>context</em> is provided, the <a href="../ssl.html"><code>SSL</code></a> Sockets initial params will be taken from the context.</p> <h3 id="method-c-open-label-Examples">Examples</h3> <pre class="ruby" data-language="ruby">sock = OpenSSL::SSL::SSLSocket.open('localhost', 443)
sock.connect # Initiates a connection to localhost:443
</pre> <p>with SSLContext:</p> <pre class="ruby" data-language="ruby">ctx = OpenSSL::SSL::SSLContext.new
sock = OpenSSL::SSL::SSLSocket.open('localhost', 443, context: ctx)
sock.connect # Initiates a connection to localhost:443 with SSLContext
</pre> </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section anchor-link"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-accept"> <a href="#method-i-accept" title="Link to this method"> <span class="method-callseq"> accept → self </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="accept-source"> <pre class="c" data-language="c">static VALUE
ossl_ssl_accept(VALUE self)
{
    ossl_ssl_setup(self);

    return ossl_start_ssl(self, SSL_accept, "SSL_accept", Qfalse);
}</pre> </div>  <p>Waits for a SSL/TLS client to initiate a handshake.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-accept_nonblock"> <a href="#method-i-accept_nonblock" title="Link to this method"> <span class="method-callseq"> accept_nonblock([options]) → self </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="accept_nonblock-source"> <pre class="c" data-language="c">static VALUE
ossl_ssl_accept_nonblock(int argc, VALUE *argv, VALUE self)
{
    VALUE opts;

    rb_scan_args(argc, argv, "0:", &amp;opts);
    ossl_ssl_setup(self);

    return ossl_start_ssl(self, SSL_accept, "SSL_accept", opts);
}</pre> </div>  <p>Initiates the SSL/TLS handshake as a server in non-blocking manner.</p> <pre class="ruby" data-language="ruby"># emulates blocking accept
begin
  ssl.accept_nonblock
rescue IO::WaitReadable
  IO.select([s2])
  retry
rescue IO::WaitWritable
  IO.select(nil, [s2])
  retry
end
</pre> <p>By specifying a keyword argument <em>exception</em> to <code>false</code>, you can indicate that <a href="sslsocket.html#method-i-accept_nonblock"><code>accept_nonblock</code></a> should not raise an <a href="../../io/waitreadable.html"><code>IO::WaitReadable</code></a> or <a href="../../io/waitwritable.html"><code>IO::WaitWritable</code></a> exception, but return the symbol <code>:wait_readable</code> or <code>:wait_writable</code> instead.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-alpn_protocol"> <a href="#method-i-alpn_protocol" title="Link to this method"> <span class="method-callseq"> alpn_protocol → String | nil </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="alpn_protocol-source"> <pre class="c" data-language="c">static VALUE
ossl_ssl_alpn_protocol(VALUE self)
{
    SSL *ssl;
    const unsigned char *out;
    unsigned int outlen;

    GetSSL(self, ssl);

    SSL_get0_alpn_selected(ssl, &amp;out, &amp;outlen);
    if (!outlen)
        return Qnil;
    else
        return rb_str_new((const char *) out, outlen);
}</pre> </div>  <p>Returns the ALPN protocol string that was finally selected by the server during the handshake.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-cert"> <a href="#method-i-cert" title="Link to this method"> <span class="method-callseq"> cert → cert or nil </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="cert-source"> <pre class="c" data-language="c">static VALUE
ossl_ssl_get_cert(VALUE self)
{
    SSL *ssl;
    X509 *cert = NULL;

    GetSSL(self, ssl);

    /*
     * Is this OpenSSL bug? Should add a ref?
     * TODO: Ask for.
     */
    cert = SSL_get_certificate(ssl); /* NO DUPs =&gt; DON'T FREE. */

    if (!cert) {
        return Qnil;
    }
    return ossl_x509_new(cert);
}</pre> </div>  <p>The <span><code>X509</code></span> certificate for this socket endpoint.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-cipher"> <a href="#method-i-cipher" title="Link to this method"> <span class="method-callseq"> cipher → nil or [name, version, bits, alg_bits] </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="cipher-source"> <pre class="c" data-language="c">static VALUE
ossl_ssl_get_cipher(VALUE self)
{
    SSL *ssl;
    const SSL_CIPHER *cipher;

    GetSSL(self, ssl);
    cipher = SSL_get_current_cipher(ssl);
    return cipher ? ossl_ssl_cipher_to_ary(cipher) : Qnil;
}</pre> </div>  <p>Returns the cipher suite actually used in the current session, or nil if no session has been established.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-client_ca"> <a href="#method-i-client_ca" title="Link to this method"> <span class="method-callseq"> client_ca → [x509name, ...] </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="client_ca-source"> <pre class="c" data-language="c">static VALUE
ossl_ssl_get_client_ca_list(VALUE self)
{
    SSL *ssl;
    STACK_OF(X509_NAME) *ca;

    GetSSL(self, ssl);

    ca = SSL_get_client_CA_list(ssl);
    return ossl_x509name_sk2ary(ca);
}</pre> </div>  <p>Returns the list of client CAs. Please note that in contrast to <a href="sslcontext.html#attribute-i-client_ca"><code>SSLContext#client_ca=</code></a> no array of <a href="../x509/certificate.html"><code>X509::Certificate</code></a> is returned but <a href="../x509/name.html"><code>X509::Name</code></a> instances of the CA’s subject distinguished name.</p> <p>In server mode, returns the list set by <a href="sslcontext.html#attribute-i-client_ca"><code>SSLContext#client_ca=</code></a>. In client mode, returns the list of client CAs sent from the server.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-close_read"> <a href="#method-i-close_read" title="Link to this method"> <span class="method-name">close_read</span> <span class="method-args">()</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="close_read-source"> <pre class="ruby" data-language="ruby"># File ext/openssl/lib/openssl/ssl.rb, line 464
def close_read
  # Unsupported and ignored.
  # Just don't read any more.
end</pre> </div>  <p>Close the stream for reading. This method is ignored by <a href="../../openssl.html"><code>OpenSSL</code></a> as there is no reasonable way to implement it, but exists for compatibility with <a href="../../io.html"><code>IO</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-close_write"> <a href="#method-i-close_write" title="Link to this method"> <span class="method-name">close_write</span> <span class="method-args">()</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="close_write-source"> <pre class="ruby" data-language="ruby"># File ext/openssl/lib/openssl/ssl.rb, line 483
def close_write
  stop
end</pre> </div>  <p>Closes the stream for writing. The behavior of this method depends on the version of <a href="../../openssl.html"><code>OpenSSL</code></a> and the TLS protocol in use.</p> <ul>
<li> <p>Sends a ‘close_notify’ alert to the peer.</p> </li>
<li> <p>Does not wait for the peer’s ‘close_notify’ alert in response.</p> </li>
</ul> <p>In TLS 1.2 and earlier:</p> <ul><li> <p>On receipt of a ‘close_notify’ alert, responds with a ‘close_notify’ alert of its own and close down the connection immediately, discarding any pending writes.</p> </li></ul> <p>Therefore, on TLS 1.2, this method will cause the connection to be completely shut down. On TLS 1.3, the connection will remain open for reading only.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-connect"> <a href="#method-i-connect" title="Link to this method"> <span class="method-callseq"> connect → self </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="connect-source"> <pre class="c" data-language="c">static VALUE
ossl_ssl_connect(VALUE self)
{
    ossl_ssl_setup(self);

    return ossl_start_ssl(self, SSL_connect, "SSL_connect", Qfalse);
}</pre> </div>  <p>Initiates an SSL/TLS handshake with a server.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-connect_nonblock"> <a href="#method-i-connect_nonblock" title="Link to this method"> <span class="method-callseq"> connect_nonblock([options]) → self </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="connect_nonblock-source"> <pre class="c" data-language="c">static VALUE
ossl_ssl_connect_nonblock(int argc, VALUE *argv, VALUE self)
{
    VALUE opts;
    rb_scan_args(argc, argv, "0:", &amp;opts);

    ossl_ssl_setup(self);

    return ossl_start_ssl(self, SSL_connect, "SSL_connect", opts);
}</pre> </div>  <p>Initiates the SSL/TLS handshake as a client in non-blocking manner.</p> <pre class="ruby" data-language="ruby"># emulates blocking connect
begin
  ssl.connect_nonblock
rescue IO::WaitReadable
  IO.select([s2])
  retry
rescue IO::WaitWritable
  IO.select(nil, [s2])
  retry
end
</pre> <p>By specifying a keyword argument <em>exception</em> to <code>false</code>, you can indicate that <a href="sslsocket.html#method-i-connect_nonblock"><code>connect_nonblock</code></a> should not raise an <a href="../../io/waitreadable.html"><code>IO::WaitReadable</code></a> or <a href="../../io/waitwritable.html"><code>IO::WaitWritable</code></a> exception, but return the symbol <code>:wait_readable</code> or <code>:wait_writable</code> instead.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-export_keying_material"> <a href="#method-i-export_keying_material" title="Link to this method"> <span class="method-callseq"> export_keying_material(label, length) → String </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="export_keying_material-source"> <pre class="c" data-language="c">static VALUE
ossl_ssl_export_keying_material(int argc, VALUE *argv, VALUE self)
{
    SSL *ssl;
    VALUE str;
    VALUE label;
    VALUE length;
    VALUE context;
    unsigned char *p;
    size_t len;
    int use_ctx = 0;
    unsigned char *ctx = NULL;
    size_t ctx_len = 0;
    int ret;

    rb_scan_args(argc, argv, "21", &amp;label, &amp;length, &amp;context);
    StringValue(label);

    GetSSL(self, ssl);

    len = (size_t)NUM2LONG(length);
    str = rb_str_new(0, len);
    p = (unsigned char *)RSTRING_PTR(str);
    if (!NIL_P(context)) {
        use_ctx = 1;
        StringValue(context);
        ctx = (unsigned char *)RSTRING_PTR(context);
        ctx_len = RSTRING_LEN(context);
    }
    ret = SSL_export_keying_material(ssl, p, len, (char *)RSTRING_PTR(label),
                                     RSTRING_LENINT(label), ctx, ctx_len, use_ctx);
    if (ret == 0 || ret == -1) {
        ossl_raise(eSSLError, "SSL_export_keying_material");
    }
    return str;
}</pre> </div>  <p>Enables use of shared session key material in accordance with RFC 5705.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-finished_message"> <a href="#method-i-finished_message" title="Link to this method"> <span class="method-callseq"> finished_message → "finished message" </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="finished_message-source"> <pre class="c" data-language="c">static VALUE
ossl_ssl_get_finished(VALUE self)
{
    SSL *ssl;
    char sizer[1], *buf;
    size_t len;

    GetSSL(self, ssl);

    len = SSL_get_finished(ssl, sizer, 0);
    if (len == 0)
        return Qnil;

    buf = ALLOCA_N(char, len);
    SSL_get_finished(ssl, buf, len);
    return rb_str_new(buf, len);
}</pre> </div>  <p>Returns the last <strong>Finished</strong> message sent</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-hostname-3D"> <a href="#method-i-hostname-3D" title="Link to this method"> <span class="method-callseq"> hostname = hostname → hostname </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="hostname-3D-source"> <pre class="c" data-language="c">static VALUE
ossl_ssl_set_hostname(VALUE self, VALUE arg)
{
    SSL *ssl;
    char *hostname = NULL;

    GetSSL(self, ssl);

    if (!NIL_P(arg))
        hostname = StringValueCStr(arg);

    if (!SSL_set_tlsext_host_name(ssl, hostname))
        ossl_raise(eSSLError, NULL);

    /* for SSLSocket#hostname */
    rb_ivar_set(self, id_i_hostname, arg);

    return arg;
}</pre> </div>  <p>Sets the server hostname used for SNI. This needs to be set before <a href="sslsocket.html#method-i-connect"><code>SSLSocket#connect</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-npn_protocol"> <a href="#method-i-npn_protocol" title="Link to this method"> <span class="method-callseq"> npn_protocol → String | nil </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="npn_protocol-source"> <pre class="c" data-language="c">static VALUE
ossl_ssl_npn_protocol(VALUE self)
{
    SSL *ssl;
    const unsigned char *out;
    unsigned int outlen;

    GetSSL(self, ssl);

    SSL_get0_next_proto_negotiated(ssl, &amp;out, &amp;outlen);
    if (!outlen)
        return Qnil;
    else
        return rb_str_new((const char *) out, outlen);
}</pre> </div>  <p>Returns the protocol string that was finally selected by the client during the handshake.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-peer_cert"> <a href="#method-i-peer_cert" title="Link to this method"> <span class="method-callseq"> peer_cert → cert or nil </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="peer_cert-source"> <pre class="c" data-language="c">static VALUE
ossl_ssl_get_peer_cert(VALUE self)
{
    SSL *ssl;
    X509 *cert = NULL;
    VALUE obj;

    GetSSL(self, ssl);

    cert = SSL_get_peer_certificate(ssl); /* Adds a ref =&gt; Safe to FREE. */

    if (!cert) {
        return Qnil;
    }
    obj = ossl_x509_new(cert);
    X509_free(cert);

    return obj;
}</pre> </div>  <p>The <span><code>X509</code></span> certificate for this socket’s peer.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-peer_cert_chain"> <a href="#method-i-peer_cert_chain" title="Link to this method"> <span class="method-callseq"> peer_cert_chain → [cert, ...] or nil </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="peer_cert_chain-source"> <pre class="c" data-language="c">static VALUE
ossl_ssl_get_peer_cert_chain(VALUE self)
{
    SSL *ssl;
    STACK_OF(X509) *chain;
    X509 *cert;
    VALUE ary;
    int i, num;

    GetSSL(self, ssl);

    chain = SSL_get_peer_cert_chain(ssl);
    if(!chain) return Qnil;
    num = sk_X509_num(chain);
    ary = rb_ary_new2(num);
    for (i = 0; i &lt; num; i++){
        cert = sk_X509_value(chain, i);
        rb_ary_push(ary, ossl_x509_new(cert));
    }

    return ary;
}</pre> </div>  <p>The <span><code>X509</code></span> certificate chain for this socket’s peer.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-peer_finished_message"> <a href="#method-i-peer_finished_message" title="Link to this method"> <span class="method-callseq"> peer_finished_message → "peer finished message" </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="peer_finished_message-source"> <pre class="c" data-language="c">static VALUE
ossl_ssl_get_peer_finished(VALUE self)
{
    SSL *ssl;
    char sizer[1], *buf;
    size_t len;

    GetSSL(self, ssl);

    len = SSL_get_peer_finished(ssl, sizer, 0);
    if (len == 0)
        return Qnil;

    buf = ALLOCA_N(char, len);
    SSL_get_peer_finished(ssl, buf, len);
    return rb_str_new(buf, len);
}</pre> </div>  <p>Returns the last <strong>Finished</strong> message received</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-pending"> <a href="#method-i-pending" title="Link to this method"> <span class="method-callseq"> pending → Integer </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="pending-source"> <pre class="c" data-language="c">static VALUE
ossl_ssl_pending(VALUE self)
{
    SSL *ssl;

    GetSSL(self, ssl);

    return INT2NUM(SSL_pending(ssl));
}</pre> </div>  <p>The number of bytes that are immediately available for reading.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-post_connection_check"> <a href="#method-i-post_connection_check" title="Link to this method"> <span class="method-callseq"> post_connection_check(hostname) → true </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="post_connection_check-source"> <pre class="ruby" data-language="ruby"># File ext/openssl/lib/openssl/ssl.rb, line 434
def post_connection_check(hostname)
  if peer_cert.nil?
    msg = "Peer verification enabled, but no certificate received."
    if using_anon_cipher?
      msg += " Anonymous cipher suite #{cipher[0]} was negotiated. " \
             "Anonymous suites must be disabled to use peer verification."
    end
    raise SSLError, msg
  end

  unless OpenSSL::SSL.verify_certificate_identity(peer_cert, hostname)
    raise SSLError, "hostname \"#{hostname}\" does not match the server certificate"
  end
  return true
end</pre> </div>  <p>Perform hostname verification following RFC 6125.</p> <p>This method MUST be called after calling <a href="sslsocket.html#method-i-connect"><code>connect</code></a> to ensure that the hostname of a remote peer has been verified.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-session"> <a href="#method-i-session" title="Link to this method"> <span class="method-callseq"> session → aSession </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="session-source"> <pre class="ruby" data-language="ruby"># File ext/openssl/lib/openssl/ssl.rb, line 455
def session
  SSL::Session.new(self)
rescue SSL::Session::SessionError
  nil
end</pre> </div>  <p>Returns the SSLSession object currently used, or nil if the session is not established.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-session-3D"> <a href="#method-i-session-3D" title="Link to this method"> <span class="method-callseq"> session = session → session </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="session-3D-source"> <pre class="c" data-language="c">static VALUE
ossl_ssl_set_session(VALUE self, VALUE arg1)
{
    SSL *ssl;
    SSL_SESSION *sess;

    GetSSL(self, ssl);
    GetSSLSession(arg1, sess);

    if (SSL_set_session(ssl, sess) != 1)
        ossl_raise(eSSLError, "SSL_set_session");

    return arg1;
}</pre> </div>  <p>Sets the <a href="session.html"><code>Session</code></a> to be used when the connection is established.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-session_reused-3F"> <a href="#method-i-session_reused-3F" title="Link to this method"> <span class="method-callseq"> session_reused? → true | false </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="session_reused-3F-source"> <pre class="c" data-language="c">static VALUE
ossl_ssl_session_reused(VALUE self)
{
    SSL *ssl;

    GetSSL(self, ssl);

    return SSL_session_reused(ssl) ? Qtrue : Qfalse;
}</pre> </div>  <p>Returns <code>true</code> if a reused session was negotiated during the handshake.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-ssl_version"> <a href="#method-i-ssl_version" title="Link to this method"> <span class="method-callseq"> ssl_version → String </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="ssl_version-source"> <pre class="c" data-language="c">static VALUE
ossl_ssl_get_version(VALUE self)
{
    SSL *ssl;

    GetSSL(self, ssl);

    return rb_str_new2(SSL_get_version(ssl));
}</pre> </div>  <p>Returns a <a href="../../string.html"><code>String</code></a> representing the SSL/TLS version that was negotiated for the connection, for example “TLSv1.2”.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-state"> <a href="#method-i-state" title="Link to this method"> <span class="method-callseq"> state → string </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="state-source"> <pre class="c" data-language="c">static VALUE
ossl_ssl_get_state(VALUE self)
{
    SSL *ssl;
    VALUE ret;

    GetSSL(self, ssl);

    ret = rb_str_new2(SSL_state_string(ssl));
    if (ruby_verbose) {
        rb_str_cat2(ret, ": ");
        rb_str_cat2(ret, SSL_state_string_long(ssl));
    }
    return ret;
}</pre> </div>  <p>A description of the current connection state. This is for diagnostic purposes only.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-sysclose"> <a href="#method-i-sysclose" title="Link to this method"> <span class="method-callseq"> sysclose → nil </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="sysclose-source"> <pre class="ruby" data-language="ruby"># File ext/openssl/lib/openssl/ssl.rb, line 421
def sysclose
  return if closed?
  stop
  io.close if sync_close
end</pre> </div>  <p>Sends “close notify” to the peer and tries to shut down the <a href="../ssl.html"><code>SSL</code></a> connection gracefully.</p> <p>If <a href="sslsocket.html#attribute-i-sync_close"><code>sync_close</code></a> is set to <code>true</code>, the underlying <a href="../../io.html"><code>IO</code></a> is also closed.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-sysread"> <a href="#method-i-sysread" title="Link to this method"> <span class="method-callseq"> sysread(length) → string </span> </a> </div> <div class="method-heading"> <a href="#method-i-sysread" title="Link to this method"> <span class="method-callseq"> sysread(length, buffer) → buffer </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="sysread-source"> <pre class="c" data-language="c">static VALUE
ossl_ssl_read(int argc, VALUE *argv, VALUE self)
{
    return ossl_ssl_read_internal(argc, argv, self, 0);
}</pre> </div>  <p>Reads <em>length</em> bytes from the <a href="../ssl.html"><code>SSL</code></a> connection. If a pre-allocated <em>buffer</em> is provided the data will be written into it.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-syswrite"> <a href="#method-i-syswrite" title="Link to this method"> <span class="method-callseq"> syswrite(string) → Integer </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="syswrite-source"> <pre class="c" data-language="c">static VALUE
ossl_ssl_write(VALUE self, VALUE str)
{
    return ossl_ssl_write_internal(self, str, Qfalse);
}</pre> </div>  <p>Writes <em>string</em> to the <a href="../ssl.html"><code>SSL</code></a> connection.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-tmp_key"> <a href="#method-i-tmp_key" title="Link to this method"> <span class="method-callseq"> tmp_key → PKey or nil </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="tmp_key-source"> <pre class="c" data-language="c">static VALUE
ossl_ssl_tmp_key(VALUE self)
{
    SSL *ssl;
    EVP_PKEY *key;

    GetSSL(self, ssl);
    if (!SSL_get_server_tmp_key(ssl, &amp;key))
        return Qnil;
    return ossl_pkey_new(key);
}</pre> </div>  <p>Returns the ephemeral key used in case of forward secrecy cipher.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-verify_result"> <a href="#method-i-verify_result" title="Link to this method"> <span class="method-callseq"> verify_result → Integer </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="verify_result-source"> <pre class="c" data-language="c">static VALUE
ossl_ssl_get_verify_result(VALUE self)
{
    SSL *ssl;

    GetSSL(self, ssl);

    return LONG2NUM(SSL_get_verify_result(ssl));
}</pre> </div>  <p>Returns the result of the peer certificates verification. See verify(1) for error values and descriptions.</p> <p>If no peer certificate was presented X509_V_OK is returned.</p> </div> </div> </section> <section id="private-instance-5Buntitled-5D-method-details" class="method-section anchor-link"> <header> <h3>Private Instance Methods</h3> </header> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-client_cert_cb"> <a href="#method-i-client_cert_cb" title="Link to this method"> <span class="method-name">client_cert_cb</span> <span class="method-args">()</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="client_cert_cb-source"> <pre class="ruby" data-language="ruby"># File ext/openssl/lib/openssl/ssl.rb, line 495
def client_cert_cb
  @context.client_cert_cb
end</pre> </div>  </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-session_get_cb"> <a href="#method-i-session_get_cb" title="Link to this method"> <span class="method-name">session_get_cb</span> <span class="method-args">()</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="session_get_cb-source"> <pre class="ruby" data-language="ruby"># File ext/openssl/lib/openssl/ssl.rb, line 507
def session_get_cb
  @context.session_get_cb
end</pre> </div>  </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-session_new_cb"> <a href="#method-i-session_new_cb" title="Link to this method"> <span class="method-name">session_new_cb</span> <span class="method-args">()</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="session_new_cb-source"> <pre class="ruby" data-language="ruby"># File ext/openssl/lib/openssl/ssl.rb, line 503
def session_new_cb
  @context.session_new_cb
end</pre> </div>  </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-stop"> <a href="#method-i-stop" title="Link to this method"> <span class="method-callseq"> stop → nil </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="stop-source"> <pre class="c" data-language="c">static VALUE
ossl_ssl_stop(VALUE self)
{
    SSL *ssl;
    int ret;

    GetSSL(self, ssl);
    if (!ssl_started(ssl))
        return Qnil;
    ret = SSL_shutdown(ssl);
    if (ret == 1) /* Have already received close_notify */
        return Qnil;
    if (ret == 0) /* Sent close_notify, but we don't wait for reply */
        return Qnil;

    /*
     * XXX: Something happened. Possibly it failed because the underlying socket
     * is not writable/readable, since it is in non-blocking mode. We should do
     * some proper error handling using SSL_get_error() and maybe retry, but we
     * can't block here. Give up for now.
     */
    ossl_clear_error();
    return Qnil;
}</pre> </div>  <p>Sends “close notify” to the peer and tries to shut down the <a href="../ssl.html"><code>SSL</code></a> connection gracefully.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-sysread_nonblock"> <a href="#method-i-sysread_nonblock" title="Link to this method"> <span class="method-callseq"> sysread_nonblock(length) → string </span> </a> </div> <div class="method-heading"> <a href="#method-i-sysread_nonblock" title="Link to this method"> <span class="method-callseq"> sysread_nonblock(length, buffer) → buffer </span> </a> </div> <div class="method-heading"> <a href="#method-i-sysread_nonblock" title="Link to this method"> <span class="method-callseq"> sysread_nonblock(length[, buffer [, opts]) → buffer </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="sysread_nonblock-source"> <pre class="c" data-language="c">static VALUE
ossl_ssl_read_nonblock(int argc, VALUE *argv, VALUE self)
{
    return ossl_ssl_read_internal(argc, argv, self, 1);
}</pre> </div>  <p>A non-blocking version of <a href="sslsocket.html#method-i-sysread"><code>sysread</code></a>. Raises an <a href="sslerror.html"><code>SSLError</code></a> if reading would block. If “exception: false” is passed, this method returns a symbol of :wait_readable, :wait_writable, or nil, rather than raising an exception.</p> <p>Reads <em>length</em> bytes from the <a href="../ssl.html"><code>SSL</code></a> connection. If a pre-allocated <em>buffer</em> is provided the data will be written into it.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-syswrite_nonblock"> <a href="#method-i-syswrite_nonblock" title="Link to this method"> <span class="method-callseq"> syswrite_nonblock(string) → Integer </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="syswrite_nonblock-source"> <pre class="c" data-language="c">static VALUE
ossl_ssl_write_nonblock(int argc, VALUE *argv, VALUE self)
{
    VALUE str, opts;

    rb_scan_args(argc, argv, "1:", &amp;str, &amp;opts);

    return ossl_ssl_write_internal(self, str, opts);
}</pre> </div>  <p>Writes <em>string</em> to the <a href="../ssl.html"><code>SSL</code></a> connection in a non-blocking manner. Raises an <a href="sslerror.html"><code>SSLError</code></a> if writing would block.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-tmp_dh_callback"> <a href="#method-i-tmp_dh_callback" title="Link to this method"> <span class="method-name">tmp_dh_callback</span> <span class="method-args">()</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="tmp_dh_callback-source"> <pre class="ruby" data-language="ruby"># File ext/openssl/lib/openssl/ssl.rb, line 499
def tmp_dh_callback
  @context.tmp_dh_callback || OpenSSL::SSL::SSLContext::DEFAULT_TMP_DH_CALLBACK
end</pre> </div>  </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-using_anon_cipher-3F"> <a href="#method-i-using_anon_cipher-3F" title="Link to this method"> <span class="method-name">using_anon_cipher?</span> <span class="method-args">()</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="using_anon_cipher-3F-source"> <pre class="ruby" data-language="ruby"># File ext/openssl/lib/openssl/ssl.rb, line 489
def using_anon_cipher?
  ctx = OpenSSL::SSL::SSLContext.new
  ctx.ciphers = "aNULL"
  ctx.ciphers.include?(cipher)
end</pre> </div>  </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core &copy; 1993&ndash;2024 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library &copy; contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>
