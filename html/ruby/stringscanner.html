<h1 id="class-StringScanner" class="anchor-link class"> class StringScanner </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent"><a href="object.html">Object</a></dd>
</dl> <section class="description"> <p>Class <a href="stringscanner.html"><code>StringScanner</code></a> supports processing a stored string as a stream; this code creates a new <a href="stringscanner.html"><code>StringScanner</code></a> object with string <code>'foobarbaz'</code>:</p> <pre class="ruby" data-language="ruby">require 'strscan'
scanner = StringScanner.new('foobarbaz')
</pre> <h2 id="class-StringScanner-label-About+the+Examples">About the Examples</h2> <p>All examples here assume that <a href="stringscanner.html"><code>StringScanner</code></a> has been required:</p> <pre class="ruby" data-language="ruby">require 'strscan'
</pre> <p>Some examples here assume that these constants are defined:</p> <pre class="ruby" data-language="ruby">MULTILINE_TEXT = &lt;&lt;~EOT
Go placidly amid the noise and haste,
and remember what peace there may be in silence.
EOT

HIRAGANA_TEXT = 'こんにちは'

ENGLISH_TEXT = 'Hello'
</pre> <p>Some examples here assume that certain helper methods are defined:</p> <ul>
<li> <p><code>put_situation(scanner)</code>: Displays the values of the scanner’s methods <a href="stringscanner.html#method-i-pos"><code>pos</code></a>, <a href="stringscanner.html#method-i-charpos"><code>charpos</code></a>, <a href="stringscanner.html#method-i-rest"><code>rest</code></a>, and <a href="stringscanner.html#method-i-rest_size"><code>rest_size</code></a>.</p> </li>
<li> <p><code>put_match_values(scanner)</code>: Displays the scanner’s <a href="stringscanner.html#class-StringScanner-label-Match+Values">match values</a>.</p> </li>
<li> <p><code>match_values_cleared?(scanner)</code>: Returns whether the scanner’s <a href="stringscanner.html#class-StringScanner-label-Match+Values">match values</a> are cleared.</p> </li>
</ul> <p>See examples [<span>here]</span>.</p> <h2 id="class-StringScanner-label-The+StringScanner+Object">The <a href="stringscanner.html"><code>StringScanner</code></a> Object</h2> <p>This code creates a <a href="stringscanner.html"><code>StringScanner</code></a> object (we’ll call it simply a <em>scanner</em>), and shows some of its basic properties:</p> <pre class="ruby" data-language="ruby">scanner = StringScanner.new('foobarbaz')
scanner.string # =&gt; "foobarbaz"
put_situation(scanner)
# Situation:
#   pos:       0
#   charpos:   0
#   rest:      "foobarbaz"
#   rest_size: 9
</pre> <p>The scanner has:</p> <ul>
<li> <p>A <em>stored string</em>, which is:</p> <ul>
<li> <p>Initially set by <a href="stringscanner.html#method-c-new"><code>StringScanner.new(string)</code></a> to the given <code>string</code> (<code>'foobarbaz'</code> in the example above).</p> </li>
<li> <p>Modifiable by methods <a href="stringscanner.html#method-i-string-3D"><code>string=(new_string)</code></a> and <a href="stringscanner.html#method-i-concat"><code>concat(more_string)</code></a>.</p> </li>
<li> <p>Returned by method <a href="stringscanner.html#method-i-string"><code>string</code></a>.</p> </li>
</ul> <p>More at <a href="stringscanner.html#class-StringScanner-label-Stored+String">Stored String</a> below.</p> </li>
<li> <p>A <em>position</em>; a zero-based index into the bytes of the stored string (<em>not</em> into its characters):</p> <ul>
<li> <p>Initially set by <a href="stringscanner.html#method-c-new"><code>StringScanner.new</code></a> to <code>0</code>.</p> </li>
<li> <p>Returned by method <a href="stringscanner.html#method-i-pos"><code>pos</code></a>.</p> </li>
<li> <p>Modifiable explicitly by methods <a href="stringscanner.html#method-i-reset"><code>reset</code></a>, <a href="stringscanner.html#method-i-terminate"><code>terminate</code></a>, and <a href="stringscanner.html#method-i-pos-3D"><code>pos=(new_pos)</code></a>.</p> </li>
<li> <p>Modifiable implicitly (various traversing methods, among others).</p> </li>
</ul> <p>More at <a href="stringscanner.html#class-StringScanner-label-Byte+Position+-28Position-29">Byte Position</a> below.</p> </li>
<li> <p>A <em>target substring</em>, which is a trailing substring of the stored string; it extends from the current position to the end of the stored string:</p> <ul>
<li> <p>Initially set by <a href="stringscanner.html#method-c-new"><code>StringScanner.new(string)</code></a> to the given <code>string</code> (<code>'foobarbaz'</code> in the example above).</p> </li>
<li> <p>Returned by method <a href="stringscanner.html#method-i-rest"><code>rest</code></a>.</p> </li>
<li> <p>Modified by any modification to either the stored string or the position.</p> </li>
</ul> <p><strong>Most importantly</strong>: the searching and traversing methods operate on the target substring, which may be (and often is) less than the entire stored string.</p> <p>More at <a href="stringscanner.html#class-StringScanner-label-Target+Substring">Target Substring</a> below.</p> </li>
</ul> <h2 id="class-StringScanner-label-Stored+String">Stored String</h2> <p>The <em>stored string</em> is the string stored in the <a href="stringscanner.html"><code>StringScanner</code></a> object.</p> <p>Each of these methods sets, modifies, or returns the stored string:</p> <table role="table"> <thead> <tr> <th><a href="method.html"><code>Method</code></a></th> <th>Effect</th> </tr> </thead> <tbody> <tr> <td><a href="stringscanner.html#method-c-new"><code>::new(string)</code></a></td> <td>Creates a new scanner for the given string.</td> </tr> <tr> <td><a href="stringscanner.html#method-i-string-3D"><code>string=(new_string)</code></a></td> <td>Replaces the existing stored string.</td> </tr> <tr> <td><a href="stringscanner.html#method-i-concat"><code>concat(more_string)</code></a></td> <td>Appends a string to the existing stored string.</td> </tr> <tr> <td><a href="stringscanner.html#method-i-string"><code>string</code></a></td> <td>Returns the stored string.</td> </tr> </tbody> </table> <h2 id="class-StringScanner-label-Positions">Positions</h2> <p>A <a href="stringscanner.html"><code>StringScanner</code></a> object maintains a zero-based <em>byte position</em> and a zero-based <em>character position</em>.</p> <p>Each of these methods explicitly sets positions:</p> <table role="table"> <thead> <tr> <th><a href="method.html"><code>Method</code></a></th> <th>Effect</th> </tr> </thead> <tbody> <tr> <td><a href="stringscanner.html#method-i-reset"><code>reset</code></a></td> <td>Sets both positions to zero (begining of stored string).</td> </tr> <tr> <td><a href="stringscanner.html#method-i-terminate"><code>terminate</code></a></td> <td>Sets both positions to the end of the stored string.</td> </tr> <tr> <td><a href="stringscanner.html#method-i-pos-3D"><code>pos=(new_byte_position)</code></a></td> <td>Sets byte position; adjusts character position.</td> </tr> </tbody> </table> <h3 id="class-StringScanner-label-Byte+Position+-28Position-29">Byte Position (Position)</h3> <p>The byte position (or simply <em>position</em>) is a zero-based index into the bytes in the scanner’s stored string; for a new <a href="stringscanner.html"><code>StringScanner</code></a> object, the byte position is zero.</p> <p>When the byte position is:</p> <ul>
<li> <p>Zero (at the beginning), the target substring is the entire stored string.</p> </li>
<li> <p>Equal to the size of the stored string (at the end), the target substring is the empty string <code>''</code>.</p> </li>
</ul> <p>To get or set the byte position:</p> <ul>
<li> <p><a href="stringscanner.html#method-i-pos"><code>pos</code></a>: returns the byte position.</p> </li>
<li> <p><a href="stringscanner.html#method-i-pos-3D"><code>pos=(new_pos)</code></a>: sets the byte position.</p> </li>
</ul> <p>Many methods use the byte position as the basis for finding matches; many others set, increment, or decrement the byte position:</p> <pre class="ruby" data-language="ruby">scanner = StringScanner.new('foobar')
scanner.pos # =&gt; 0
scanner.scan(/foo/) # =&gt; "foo" # Match found.
scanner.pos         # =&gt; 3     # Byte position incremented.
scanner.scan(/foo/) # =&gt; nil   # Match not found.
scanner.pos # =&gt; 3             # Byte position not changed.
</pre> <p>Some methods implicitly modify the byte position; see:</p> <ul>
<li> <p><a href="stringscanner.html#class-StringScanner-label-Setting+the+Target+Substring">Setting the Target Substring</a>.</p> </li>
<li> <p><a href="stringscanner.html#class-StringScanner-label-Traversing+the+Target+Substring">Traversing the Target Substring</a>.</p> </li>
</ul> <p>The values of these methods are derived directly from the values of <a href="stringscanner.html#method-i-pos"><code>pos</code></a> and <a href="stringscanner.html#method-i-string"><code>string</code></a>:</p> <ul>
<li> <p><a href="stringscanner.html#method-i-charpos"><code>charpos</code></a>: the <a href="stringscanner.html#class-StringScanner-label-Character+Position">character position</a>.</p> </li>
<li> <p><a href="stringscanner.html#method-i-rest"><code>rest</code></a>: the <a href="stringscanner.html#class-StringScanner-label-Target+Substring">target substring</a>.</p> </li>
<li> <p><a href="stringscanner.html#method-i-rest_size"><code>rest_size</code></a>: <code>rest.size</code>.</p> </li>
</ul> <h3 id="class-StringScanner-label-Character+Position">Character Position</h3> <p>The character position is a zero-based index into the <em>characters</em> in the stored string; for a new <a href="stringscanner.html"><code>StringScanner</code></a> object, the character position is zero.</p> <p>Method <a href="stringscanner.html#method-i-charpos"><code>charpos</code></a> returns the character position; its value may not be reset explicitly.</p> <p>Some methods change (increment or reset) the character position; see:</p> <ul>
<li> <p><a href="stringscanner.html#class-StringScanner-label-Setting+the+Target+Substring">Setting the Target Substring</a>.</p> </li>
<li> <p><a href="stringscanner.html#class-StringScanner-label-Traversing+the+Target+Substring">Traversing the Target Substring</a>.</p> </li>
</ul> <p>Example (string includes multi-byte characters):</p> <pre class="ruby" data-language="ruby">scanner = StringScanner.new(ENGLISH_TEXT) # Five 1-byte characters.
scanner.concat(HIRAGANA_TEXT)             # Five 3-byte characters
scanner.string # =&gt; "Helloこんにちは"       # Twenty bytes in all.
put_situation(scanner)
# Situation:
#   pos:       0
#   charpos:   0
#   rest:      "Helloこんにちは"
#   rest_size: 20
scanner.scan(/Hello/) # =&gt; "Hello" # Five 1-byte characters.
put_situation(scanner)
# Situation:
#   pos:       5
#   charpos:   5
#   rest:      "こんにちは"
#   rest_size: 15
scanner.getch         # =&gt; "こ"    # One 3-byte character.
put_situation(scanner)
# Situation:
#   pos:       8
#   charpos:   6
#   rest:      "んにちは"
#   rest_size: 12
</pre> <h2 id="class-StringScanner-label-Target+Substring">Target Substring</h2> <p>The target substring is the the part of the <a href="stringscanner.html#class-StringScanner-label-Stored+String">stored string</a> that extends from the current <a href="stringscanner.html#class-StringScanner-label-Byte+Position+-28Position-29">byte position</a> to the end of the stored string; it is always either:</p> <ul>
<li> <p>The entire stored string (byte position is zero).</p> </li>
<li> <p>A trailing substring of the stored string (byte position positive).</p> </li>
</ul> <p>The target substring is returned by method <a href="stringscanner.html#method-i-rest"><code>rest</code></a>, and its size is returned by method <a href="stringscanner.html#method-i-rest_size"><code>rest_size</code></a>.</p> <p>Examples:</p> <pre class="ruby" data-language="ruby">scanner = StringScanner.new('foobarbaz')
put_situation(scanner)
# Situation:
#   pos:       0
#   charpos:   0
#   rest:      "foobarbaz"
#   rest_size: 9
scanner.pos = 3
put_situation(scanner)
# Situation:
#   pos:       3
#   charpos:   3
#   rest:      "barbaz"
#   rest_size: 6
scanner.pos = 9
put_situation(scanner)
# Situation:
#   pos:       9
#   charpos:   9
#   rest:      ""
#   rest_size: 0
</pre> <h3 id="class-StringScanner-label-Setting+the+Target+Substring">Setting the Target Substring</h3> <p>The target substring is set whenever:</p> <ul>
<li> <p>The <a href="stringscanner.html#class-StringScanner-label-Stored+String">stored string</a> is set (position reset to zero; target substring set to stored string).</p> </li>
<li> <p>The <a href="stringscanner.html#class-StringScanner-label-Byte+Position+-28Position-29">byte position</a> is set (target substring adjusted accordingly).</p> </li>
</ul> <h3 id="class-StringScanner-label-Querying+the+Target+Substring">Querying the Target Substring</h3> <p>This table summarizes (details and examples at the links):</p> <table role="table"> <thead> <tr> <th><a href="method.html"><code>Method</code></a></th> <th>Returns</th> </tr> </thead> <tbody> <tr> <td><a href="stringscanner.html#method-i-rest"><code>rest</code></a></td> <td>Target substring.</td> </tr> <tr> <td><a href="stringscanner.html#method-i-rest_size"><code>rest_size</code></a></td> <td>Size (bytes) of target substring.</td> </tr> </tbody> </table> <h3 id="class-StringScanner-label-Searching+the+Target+Substring">Searching the Target Substring</h3> <p>A <em>search</em> method examines the target substring, but does not advance the <a href="stringscanner.html#class-StringScanner-label-Positions">positions</a> or (by implication) shorten the target substring.</p> <p>This table summarizes (details and examples at the links):</p> <table role="table"> <thead> <tr> <th><a href="method.html"><code>Method</code></a></th> <th>Returns</th> <th>Sets Match Values?</th> </tr> </thead> <tbody> <tr> <td><a href="stringscanner.html#method-i-check"><code>check(pattern)</code></a></td> <td>Matched leading substring or <code>nil</code>.</td> <td>Yes.</td> </tr> <tr> <td><a href="stringscanner.html#method-i-check_until"><code>check_until(pattern)</code></a></td> <td>Matched substring (anywhere) or <code>nil</code>.</td> <td>Yes.</td> </tr> <tr> <td><a href="stringscanner.html#method-i-exist-3F"><code>exist?(pattern)</code></a></td> <td>Matched substring (anywhere) end index.</td> <td>Yes.</td> </tr> <tr> <td><a href="stringscanner.html#method-i-match-3F"><code>match?(pattern)</code></a></td> <td>Size of matched leading substring or <code>nil</code>.</td> <td>Yes.</td> </tr> <tr> <td><a href="stringscanner.html#method-i-peek"><code>peek(size)</code></a></td> <td>Leading substring of given length (bytes).</td> <td>No.</td> </tr> <tr> <td><a href="stringscanner.html#method-i-peek_byte"><code>peek_byte</code></a></td> <td>
<a href="integer.html"><code>Integer</code></a> leading byte or <code>nil</code>.</td> <td>No.</td> </tr> <tr> <td><a href="stringscanner.html#method-i-rest"><code>rest</code></a></td> <td>Target substring (from byte position to end).</td> <td>No.</td> </tr> </tbody> </table> <h3 id="class-StringScanner-label-Traversing+the+Target+Substring">Traversing the Target Substring</h3> <p>A <em>traversal</em> method examines the target substring, and, if successful:</p> <ul>
<li> <p>Advances the <a href="stringscanner.html#class-StringScanner-label-Positions">positions</a>.</p> </li>
<li> <p>Shortens the target substring.</p> </li>
</ul> <p>This table summarizes (details and examples at links):</p> <table role="table"> <thead> <tr> <th><a href="method.html"><code>Method</code></a></th> <th>Returns</th> <th>Sets Match Values?</th> </tr> </thead> <tbody> <tr> <td><a href="stringscanner.html#method-i-get_byte"><code>get_byte</code></a></td> <td>Leading byte or <code>nil</code>.</td> <td>No.</td> </tr> <tr> <td><a href="stringscanner.html#method-i-getch"><code>getch</code></a></td> <td>Leading character or <code>nil</code>.</td> <td>No.</td> </tr> <tr> <td><a href="stringscanner.html#method-i-scan"><code>scan(pattern)</code></a></td> <td>Matched leading substring or <code>nil</code>.</td> <td>Yes.</td> </tr> <tr> <td><a href="stringscanner.html#method-i-scan_byte"><code>scan_byte</code></a></td> <td>
<a href="integer.html"><code>Integer</code></a> leading byte or <code>nil</code>.</td> <td>No.</td> </tr> <tr> <td><a href="stringscanner.html#method-i-scan_until"><code>scan_until(pattern)</code></a></td> <td>Matched substring (anywhere) or <code>nil</code>.</td> <td>Yes.</td> </tr> <tr> <td><a href="stringscanner.html#method-i-skip"><code>skip(pattern)</code></a></td> <td>Matched leading substring size or <code>nil</code>.</td> <td>Yes.</td> </tr> <tr> <td><a href="stringscanner.html#method-i-skip_until"><code>skip_until(pattern)</code></a></td> <td>Position delta to end-of-matched-substring or <code>nil</code>.</td> <td>Yes.</td> </tr> <tr> <td><a href="stringscanner.html#method-i-unscan"><code>unscan</code></a></td> <td>
<code>self</code>.</td> <td>No.</td> </tr> </tbody> </table> <h2 id="class-StringScanner-label-Querying+the+Scanner">Querying the Scanner</h2> <p>Each of these methods queries the scanner object without modifying it (details and examples at links)</p> <table role="table"> <thead> <tr> <th><a href="method.html"><code>Method</code></a></th> <th>Returns</th> </tr> </thead> <tbody> <tr> <td><a href="stringscanner.html#method-i-beginning_of_line-3F"><code>beginning_of_line?</code></a></td> <td>
<code>true</code> or <code>false</code>.</td> </tr> <tr> <td><a href="stringscanner.html#method-i-charpos"><code>charpos</code></a></td> <td>Character position.</td> </tr> <tr> <td><a href="stringscanner.html#method-i-eos-3F"><code>eos?</code></a></td> <td>
<code>true</code> or <code>false</code>.</td> </tr> <tr> <td><a href="stringscanner.html#method-i-fixed_anchor-3F"><code>fixed_anchor?</code></a></td> <td>
<code>true</code> or <code>false</code>.</td> </tr> <tr> <td><a href="stringscanner.html#method-i-inspect"><code>inspect</code></a></td> <td>
<a href="string.html"><code>String</code></a> representation of <code>self</code>.</td> </tr> <tr> <td><a href="stringscanner.html#method-i-pos"><code>pos</code></a></td> <td>Byte position.</td> </tr> <tr> <td><a href="stringscanner.html#method-i-rest"><code>rest</code></a></td> <td>Target substring.</td> </tr> <tr> <td><a href="stringscanner.html#method-i-rest_size"><code>rest_size</code></a></td> <td>Size of target substring.</td> </tr> <tr> <td><a href="stringscanner.html#method-i-string"><code>string</code></a></td> <td>Stored string.</td> </tr> </tbody> </table> <h2 id="class-StringScanner-label-Matching">Matching</h2> <p><a href="stringscanner.html"><code>StringScanner</code></a> implements pattern matching via Ruby class <a href="https://docs.ruby-lang.org/en/master/Regexp.html">Regexp</a>, and its matching behaviors are the same as Ruby’s except for the <a href="stringscanner.html#class-StringScanner-label-Fixed-Anchor+Property">fixed-anchor property</a>.</p> <h3 id="class-StringScanner-label-Matcher+Methods">Matcher Methods</h3> <p>Each <em>matcher method</em> takes a single argument <code>pattern</code>, and attempts to find a matching substring in the <a href="stringscanner.html#class-StringScanner-label-Target+Substring">target substring</a>.</p> <table role="table"> <thead> <tr> <th><a href="method.html"><code>Method</code></a></th> <th>Pattern Type</th> <th>Matches Target Substring</th> <th>Success Return</th> <th>May Update Positions?</th> </tr> </thead> <tbody> <tr> <td><a href="stringscanner.html#method-i-check"><code>check</code></a></td> <td>
<a href="regexp.html"><code>Regexp</code></a> or <a href="string.html"><code>String</code></a>.</td> <td>At beginning.</td> <td>Matched substring.</td> <td>No.</td> </tr> <tr> <td><a href="stringscanner.html#method-i-check_until"><code>check_until</code></a></td> <td>
<a href="regexp.html"><code>Regexp</code></a> or <a href="string.html"><code>String</code></a>.</td> <td>Anywhere.</td> <td>Substring.</td> <td>No.</td> </tr> <tr> <td><a href="stringscanner.html#method-i-match-3F"><code>match?</code></a></td> <td>
<a href="regexp.html"><code>Regexp</code></a> or <a href="string.html"><code>String</code></a>.</td> <td>At beginning.</td> <td>Match size.</td> <td>No.</td> </tr> <tr> <td><a href="stringscanner.html#method-i-exist-3F"><code>exist?</code></a></td> <td>
<a href="regexp.html"><code>Regexp</code></a> or <a href="string.html"><code>String</code></a>.</td> <td>Anywhere.</td> <td>Substring size.</td> <td>No.</td> </tr> <tr> <td><a href="stringscanner.html#method-i-scan"><code>scan</code></a></td> <td>
<a href="regexp.html"><code>Regexp</code></a> or <a href="string.html"><code>String</code></a>.</td> <td>At beginning.</td> <td>Matched substring.</td> <td>Yes.</td> </tr> <tr> <td><a href="stringscanner.html#method-i-scan_until"><code>scan_until</code></a></td> <td>
<a href="regexp.html"><code>Regexp</code></a> or <a href="string.html"><code>String</code></a>.</td> <td>Anywhere.</td> <td>Substring.</td> <td>Yes.</td> </tr> <tr> <td><a href="stringscanner.html#method-i-skip"><code>skip</code></a></td> <td>
<a href="regexp.html"><code>Regexp</code></a> or <a href="string.html"><code>String</code></a>.</td> <td>At beginning.</td> <td>Match size.</td> <td>Yes.</td> </tr> <tr> <td><a href="stringscanner.html#method-i-skip_until"><code>skip_until</code></a></td> <td>
<a href="regexp.html"><code>Regexp</code></a> or <a href="string.html"><code>String</code></a>.</td> <td>Anywhere.</td> <td>Substring size.</td> <td>Yes.</td> </tr> </tbody> </table> <p><br></p> <p>Which matcher you choose will depend on:</p> <ul>
<li> <p>Where you want to find a match:</p> <ul>
<li> <p>Only at the beginning of the target substring: <a href="stringscanner.html#method-i-check"><code>check</code></a>, <a href="stringscanner.html#method-i-match-3F"><code>match?</code></a>, <a href="stringscanner.html#method-i-scan"><code>scan</code></a>, <a href="stringscanner.html#method-i-skip"><code>skip</code></a>.</p> </li>
<li> <p>Anywhere in the target substring: <a href="stringscanner.html#method-i-check_until"><code>check_until</code></a>, <a href="stringscanner.html#method-i-exist-3F"><code>exist?</code></a>, <a href="stringscanner.html#method-i-scan_until"><code>scan_until</code></a>, <a href="stringscanner.html#method-i-skip_until"><code>skip_until</code></a>.</p> </li>
</ul> </li>
<li> <p>Whether you want to:</p> <ul>
<li> <p>Traverse, by advancing the positions: <a href="stringscanner.html#method-i-scan"><code>scan</code></a>, <a href="stringscanner.html#method-i-scan_until"><code>scan_until</code></a>, <a href="stringscanner.html#method-i-skip"><code>skip</code></a>, <a href="stringscanner.html#method-i-skip_until"><code>skip_until</code></a>.</p> </li>
<li> <p>Keep the positions unchanged: <a href="stringscanner.html#method-i-check"><code>check</code></a>, <a href="stringscanner.html#method-i-check_until"><code>check_until</code></a>, <a href="stringscanner.html#method-i-match-3F"><code>match?</code></a>, <a href="stringscanner.html#method-i-exist-3F"><code>exist?</code></a>.</p> </li>
</ul> </li>
<li> <p>What you want for the return value:</p> <ul>
<li> <p>The matched substring: <a href="stringscanner.html#method-i-check"><code>check</code></a>, <a href="stringscanner.html#method-i-scan"><code>scan</code></a>.</p> </li>
<li> <p>The substring: <a href="stringscanner.html#method-i-check_until"><code>check_until</code></a>, <a href="stringscanner.html#method-i-scan_until"><code>scan_until</code></a>.</p> </li>
<li> <p>The match size: <a href="stringscanner.html#method-i-match-3F"><code>match?</code></a>, <a href="stringscanner.html#method-i-skip"><code>skip</code></a>.</p> </li>
<li> <p>The substring size: <a href="stringscanner.html#method-i-exist-3F"><code>exist?</code></a>, <a href="stringscanner.html#method-i-skip_until"><code>skip_until</code></a>.</p> </li>
</ul> </li>
</ul> <h3 id="class-StringScanner-label-Match+Values">Match Values</h3> <p>The <em>match values</em> in a <a href="stringscanner.html"><code>StringScanner</code></a> object generally contain the results of the most recent attempted match.</p> <p>Each match value may be thought of as:</p> <ul>
<li> <p><em>Clear</em>: Initially, or after an unsuccessful match attempt: usually, <code>false</code>, <code>nil</code>, or <code>{}</code>.</p> </li>
<li> <p><em>Set</em>: After a successful match attempt: <code>true</code>, string, array, or hash.</p> </li>
</ul> <p>Each of these methods clears match values:</p> <ul>
<li> <p><a href="stringscanner.html#method-c-new"><code>::new(string)</code></a>.</p> </li>
<li> <p><a href="stringscanner.html#method-i-reset"><code>reset</code></a>.</p> </li>
<li> <p><a href="stringscanner.html#method-i-terminate"><code>terminate</code></a>.</p> </li>
</ul> <p>Each of these methods attempts a match based on a pattern, and either sets match values (if successful) or clears them (if not);</p> <ul>
<li> <p><a href="stringscanner.html#method-i-check"><code>check(pattern)</code></a></p> </li>
<li> <p><a href="stringscanner.html#method-i-check_until"><code>check_until(pattern)</code></a></p> </li>
<li> <p><a href="stringscanner.html#method-i-exist-3F"><code>exist?(pattern)</code></a></p> </li>
<li> <p><a href="stringscanner.html#method-i-match-3F"><code>match?(pattern)</code></a></p> </li>
<li> <p><a href="stringscanner.html#method-i-scan"><code>scan(pattern)</code></a></p> </li>
<li> <p><a href="stringscanner.html#method-i-scan_until"><code>scan_until(pattern)</code></a></p> </li>
<li> <p><a href="stringscanner.html#method-i-skip"><code>skip(pattern)</code></a></p> </li>
<li> <p><a href="stringscanner.html#method-i-skip_until"><code>skip_until(pattern)</code></a></p> </li>
</ul> <h4 id="class-StringScanner-label-Basic+Match+Values">Basic Match Values</h4> <p>Basic match values are those not related to captures.</p> <p>Each of these methods returns a basic match value:</p> <table role="table"> <thead> <tr> <th><a href="method.html"><code>Method</code></a></th> <th>Return After Match</th> <th>Return After No Match</th> </tr> </thead> <tbody> <tr> <td><a href="stringscanner.html#method-i-matched-3F"><code>matched?</code></a></td> <td>
<code>true</code>.</td> <td>
<code>false</code>.</td> </tr> <tr> <td><a href="stringscanner.html#method-i-matched_size"><code>matched_size</code></a></td> <td>Size of matched substring.</td> <td>
<code>nil</code>.</td> </tr> <tr> <td><a href="stringscanner.html#method-i-matched"><code>matched</code></a></td> <td>Matched substring.</td> <td>
<code>nil</code>.</td> </tr> <tr> <td><a href="stringscanner.html#method-i-pre_match"><code>pre_match</code></a></td> <td>Substring preceding matched substring.</td> <td>
<code>nil</code>.</td> </tr> <tr> <td><a href="stringscanner.html#method-i-post_match"><code>post_match</code></a></td> <td>Substring following matched substring.</td> <td>
<code>nil</code>.</td> </tr> </tbody> </table> <p><br></p> <p>See examples below.</p> <h4 id="class-StringScanner-label-Captured+Match+Values">Captured Match Values</h4> <p>Captured match values are those related to <a href="https://docs.ruby-lang.org/en/master/Regexp.html#class-Regexp-label-Groups+and+Captures">captures</a>.</p> <p>Each of these methods returns a captured match value:</p> <table role="table"> <thead> <tr> <th><a href="method.html"><code>Method</code></a></th> <th>Return After Match</th> <th>Return After No Match</th> </tr> </thead> <tbody> <tr> <td><a href="stringscanner.html#method-i-size"><code>size</code></a></td> <td>Count of captured substrings.</td> <td>
<code>nil</code>.</td> </tr> <tr> <td><a href="stringscanner.html#method-i-5B-5D"><code>[](n)</code></a></td> <td>
<code>n</code>th captured substring.</td> <td>
<code>nil</code>.</td> </tr> <tr> <td><a href="stringscanner.html#method-i-captures"><code>captures</code></a></td> <td>
<a href="array.html"><code>Array</code></a> of all captured substrings.</td> <td>
<code>nil</code>.</td> </tr> <tr> <td><a href="stringscanner.html#method-i-values_at"><code>values_at(*n)</code></a></td> <td>
<a href="array.html"><code>Array</code></a> of specified captured substrings.</td> <td>
<code>nil</code>.</td> </tr> <tr> <td><a href="stringscanner.html#method-i-named_captures"><code>named_captures</code></a></td> <td>
<a href="hash.html"><code>Hash</code></a> of named captures.</td> <td>
<code>{}</code>.</td> </tr> </tbody> </table> <p><br></p> <p>See examples below.</p> <h4 id="class-StringScanner-label-Match+Values+Examples">Match Values Examples</h4> <p>Successful basic match attempt (no captures):</p> <pre class="ruby" data-language="ruby">scanner = StringScanner.new('foobarbaz')
scanner.exist?(/bar/)
put_match_values(scanner)
# Basic match values:
#   matched?:       true
#   matched_size:   3
#   pre_match:      "foo"
#   matched  :      "bar"
#   post_match:     "baz"
# Captured match values:
#   size:           1
#   captures:       []
#   named_captures: {}
#   values_at:      ["bar", nil]
#   []:
#     [0]:          "bar"
#     [1]:          nil
</pre> <p>Failed basic match attempt (no captures);</p> <pre class="ruby" data-language="ruby">scanner = StringScanner.new('foobarbaz')
scanner.exist?(/nope/)
match_values_cleared?(scanner) # =&gt; true
</pre> <p>Successful unnamed capture match attempt:</p> <pre class="ruby" data-language="ruby">scanner = StringScanner.new('foobarbazbatbam')
scanner.exist?(/(foo)bar(baz)bat(bam)/)
put_match_values(scanner)
# Basic match values:
#   matched?:       true
#   matched_size:   15
#   pre_match:      ""
#   matched  :      "foobarbazbatbam"
#   post_match:     ""
# Captured match values:
#   size:           4
#   captures:       ["foo", "baz", "bam"]
#   named_captures: {}
#   values_at:      ["foobarbazbatbam", "foo", "baz", "bam", nil]
#   []:
#     [0]:          "foobarbazbatbam"
#     [1]:          "foo"
#     [2]:          "baz"
#     [3]:          "bam"
#     [4]:          nil
</pre> <p>Successful named capture match attempt; same as unnamed above, except for <a href="stringscanner.html#method-i-named_captures"><code>named_captures</code></a>:</p> <pre class="ruby" data-language="ruby">scanner = StringScanner.new('foobarbazbatbam')
scanner.exist?(/(?&lt;x&gt;foo)bar(?&lt;y&gt;baz)bat(?&lt;z&gt;bam)/)
scanner.named_captures # =&gt; {"x"=&gt;"foo", "y"=&gt;"baz", "z"=&gt;"bam"}
</pre> <p>Failed unnamed capture match attempt:</p> <pre class="ruby" data-language="ruby">scanner = StringScanner.new('somestring')
scanner.exist?(/(foo)bar(baz)bat(bam)/)
match_values_cleared?(scanner) # =&gt; true
</pre> <p>Failed named capture match attempt; same as unnamed above, except for <a href="stringscanner.html#method-i-named_captures"><code>named_captures</code></a>:</p> <pre class="ruby" data-language="ruby">scanner = StringScanner.new('somestring')
scanner.exist?(/(?&lt;x&gt;foo)bar(?&lt;y&gt;baz)bat(?&lt;z&gt;bam)/)
match_values_cleared?(scanner) # =&gt; false
scanner.named_captures # =&gt; {"x"=&gt;nil, "y"=&gt;nil, "z"=&gt;nil}
</pre> <h2 id="class-StringScanner-label-Fixed-Anchor+Property">Fixed-Anchor Property</h2> <p>Pattern matching in <a href="stringscanner.html"><code>StringScanner</code></a> is the same as in Ruby’s, except for its fixed-anchor property, which determines the meaning of <code>'\A'</code>:</p> <ul>
<li> <p><code>false</code> (the default): matches the current byte position.</p> <pre class="ruby" data-language="ruby">scanner = StringScanner.new('foobar')
scanner.scan(/\A./) # =&gt; "f"
scanner.scan(/\A./) # =&gt; "o"
scanner.scan(/\A./) # =&gt; "o"
scanner.scan(/\A./) # =&gt; "b"
</pre> </li>
<li> <p><code>true</code>: matches the beginning of the target substring; never matches unless the byte position is zero:</p> <pre class="ruby" data-language="ruby">scanner = StringScanner.new('foobar', fixed_anchor: true)
scanner.scan(/\A./) # =&gt; "f"
scanner.scan(/\A./) # =&gt; nil
scanner.reset
scanner.scan(/\A./) # =&gt; "f"
</pre> </li>
</ul> <p>The fixed-anchor property is set when the <a href="stringscanner.html"><code>StringScanner</code></a> object is created, and may not be modified (see <a href="stringscanner.html#method-c-new"><code>StringScanner.new</code></a>); method <a href="stringscanner.html#method-i-fixed_anchor-3F"><code>fixed_anchor?</code></a> returns the setting.</p> </section> <section id="5Buntitled-5D" class="documentation-section anchor-link"> <section id="public-class-5Buntitled-5D-method-details" class="method-section anchor-link"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-new"> <a href="#method-c-new" title="Link to this method"> <span class="method-callseq"> new(string, fixed_anchor: false) → string_scanner </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="new-source"> <pre class="c" data-language="c">static VALUE
strscan_initialize(int argc, VALUE *argv, VALUE self)
{
    struct strscanner *p;
    VALUE str, options;

    p = check_strscan(self);
    rb_scan_args(argc, argv, "11", &amp;str, &amp;options);
    options = rb_check_hash_type(options);
    if (!NIL_P(options)) {
        VALUE fixed_anchor;
        ID keyword_ids[1];
        keyword_ids[0] = rb_intern("fixed_anchor");
        rb_get_kwargs(options, keyword_ids, 0, 1, &amp;fixed_anchor);
        if (fixed_anchor == Qundef) {
            p-&gt;fixed_anchor_p = false;
        }
        else {
            p-&gt;fixed_anchor_p = RTEST(fixed_anchor);
        }
    }
    else {
        p-&gt;fixed_anchor_p = false;
    }
    StringValue(str);
    p-&gt;str = str;

    return self;
}</pre> </div>  <p>Returns a new <a href="stringscanner.html"><code>StringScanner</code></a> object whose <a href="stringscanner.html#class-StringScanner-label-Stored+String">stored string</a> is the given <code>string</code>; sets the <a href="stringscanner.html#class-StringScanner-label-Fixed-Anchor+Property">fixed-anchor property</a>:</p> <pre class="ruby" data-language="ruby">scanner = StringScanner.new('foobarbaz')
scanner.string        # =&gt; "foobarbaz"
scanner.fixed_anchor? # =&gt; false
put_situation(scanner)
# Situation:
#   pos:       0
#   charpos:   0
#   rest:      "foobarbaz"
#   rest_size: 9
</pre> </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section anchor-link"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-3C-3C"> <a href="#method-i-3C-3C" title="Link to this method"> <span class="method-name">&lt;&lt;</span> </a> </div> </div> <div class="aliases"> Alias for: <a href="stringscanner.html#method-i-concat">concat</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-5B-5D"> <a href="#method-i-5B-5D" title="Link to this method"> <span class="method-callseq"> [](specifier) → substring or nil </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="5B-5D-source"> <pre class="c" data-language="c">static VALUE
strscan_aref(VALUE self, VALUE idx)
{
    const char *name;
    struct strscanner *p;
    long i;

    GET_SCANNER(self, p);
    if (! MATCHED_P(p))        return Qnil;

    switch (TYPE(idx)) {
        case T_SYMBOL:
            idx = rb_sym2str(idx);
            /* fall through */
        case T_STRING:
            if (!RTEST(p-&gt;regex)) return Qnil;
            RSTRING_GETMEM(idx, name, i);
            i = name_to_backref_number(&amp;(p-&gt;regs), p-&gt;regex, name, name + i, rb_enc_get(idx));
            break;
        default:
            i = NUM2LONG(idx);
    }

    if (i &lt; 0)
        i += p-&gt;regs.num_regs;
    if (i &lt; 0)                 return Qnil;
    if (i &gt;= p-&gt;regs.num_regs) return Qnil;
    if (p-&gt;regs.beg[i] == -1)  return Qnil;

    return extract_range(p,
                         adjust_register_position(p, p-&gt;regs.beg[i]),
                         adjust_register_position(p, p-&gt;regs.end[i]));
}</pre> </div>  <p>Returns a captured substring or <code>nil</code>; see <a href="stringscanner.html#class-StringScanner-label-Captured+Match+Values">Captured Match Values</a>.</p> <p>When there are captures:</p> <pre class="ruby" data-language="ruby">scanner = StringScanner.new('Fri Dec 12 1975 14:39')
scanner.scan(/(?&lt;wday&gt;\w+) (?&lt;month&gt;\w+) (?&lt;day&gt;\d+) /)
</pre> <ul>
<li> <p><code>specifier</code> zero: returns the entire matched substring:</p> <pre class="ruby" data-language="ruby">scanner[0]         # =&gt; "Fri Dec 12 "
scanner.pre_match  # =&gt; ""
scanner.post_match # =&gt; "1975 14:39"
</pre> </li>
<li> <p><code>specifier</code> positive integer. returns the <code>n</code>th capture, or <code>nil</code> if out of range:</p> <pre class="ruby" data-language="ruby">scanner[1] # =&gt; "Fri"
scanner[2] # =&gt; "Dec"
scanner[3] # =&gt; "12"
scanner[4] # =&gt; nil
</pre> </li>
<li> <p><code>specifier</code> negative integer. counts backward from the last subgroup:</p> <pre class="ruby" data-language="ruby">scanner[-1] # =&gt; "12"
scanner[-4] # =&gt; "Fri Dec 12 "
scanner[-5] # =&gt; nil
</pre> </li>
<li> <p><code>specifier</code> symbol or string. returns the named subgroup, or <code>nil</code> if no such:</p> <pre class="ruby" data-language="ruby">scanner[:wday]  # =&gt; "Fri"
scanner['wday'] # =&gt; "Fri"
scanner[:month] # =&gt; "Dec"
scanner[:day]   # =&gt; "12"
scanner[:nope]  # =&gt; nil
</pre> </li>
</ul> <p>When there are no captures, only <code>[0]</code> returns non-<code>nil</code>:</p> <pre class="ruby" data-language="ruby">scanner = StringScanner.new('foobarbaz')
scanner.exist?(/bar/)
scanner[0] # =&gt; "bar"
scanner[1] # =&gt; nil
</pre> <p>For a failed match, even <code>[0]</code> returns <code>nil</code>:</p> <pre class="ruby" data-language="ruby">scanner.scan(/nope/) # =&gt; nil
scanner[0]           # =&gt; nil
scanner[1]           # =&gt; nil
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-beginning_of_line-3F"> <a href="#method-i-beginning_of_line-3F" title="Link to this method"> <span class="method-callseq"> beginning_of_line? → true or false </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="beginning_of_line-3F-source"> <pre class="c" data-language="c">static VALUE
strscan_bol_p(VALUE self)
{
    struct strscanner *p;

    GET_SCANNER(self, p);
    if (CURPTR(p) &gt; S_PEND(p)) return Qnil;
    if (p-&gt;curr == 0) return Qtrue;
    return (*(CURPTR(p) - 1) == '\n') ? Qtrue : Qfalse;
}</pre> </div>  <p>Returns whether the <a href="stringscanner.html#class-StringScanner-label-Byte+Position+-28Position-29">position</a> is at the beginning of a line; that is, at the beginning of the <a href="stringscanner.html#class-StringScanner-label-Stored+String">stored string</a> or immediately after a newline:</p> <pre class="ruby" data-language="ruby">scanner = StringScanner.new(MULTILINE_TEXT)
scanner.string
# =&gt; "Go placidly amid the noise and haste,\nand remember what peace there may be in silence.\n"
scanner.pos                # =&gt; 0
scanner.beginning_of_line? # =&gt; true

scanner.scan_until(/,/)    # =&gt; "Go placidly amid the noise and haste,"
scanner.beginning_of_line? # =&gt; false

scanner.scan(/\n/)         # =&gt; "\n"
scanner.beginning_of_line? # =&gt; true

scanner.terminate
scanner.beginning_of_line? # =&gt; true

scanner.concat('x')
scanner.terminate
scanner.beginning_of_line? # =&gt; false
</pre> <p>StringScanner#bol? is an alias for <a href="stringscanner.html#method-i-beginning_of_line-3F"><code>StringScanner#beginning_of_line?</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-captures"> <a href="#method-i-captures" title="Link to this method"> <span class="method-callseq"> captures → substring_array or nil </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="captures-source"> <pre class="c" data-language="c">static VALUE
strscan_captures(VALUE self)
{
    struct strscanner *p;
    int   i, num_regs;
    VALUE new_ary;

    GET_SCANNER(self, p);
    if (! MATCHED_P(p))        return Qnil;

    num_regs = p-&gt;regs.num_regs;
    new_ary  = rb_ary_new2(num_regs);

    for (i = 1; i &lt; num_regs; i++) {
        VALUE str;
        if (p-&gt;regs.beg[i] == -1)
            str = Qnil;
        else
            str = extract_range(p,
                                adjust_register_position(p, p-&gt;regs.beg[i]),
                                adjust_register_position(p, p-&gt;regs.end[i]));
        rb_ary_push(new_ary, str);
    }

    return new_ary;
}</pre> </div>  <p>Returns the array of <a href="stringscanner.html#class-StringScanner-label-Captured+Match+Values">captured match values</a> at indexes <code>(1..)</code> if the most recent match attempt succeeded, or <code>nil</code> otherwise:</p> <pre class="ruby" data-language="ruby">scanner = StringScanner.new('Fri Dec 12 1975 14:39')
scanner.captures         # =&gt; nil

scanner.exist?(/(?&lt;wday&gt;\w+) (?&lt;month&gt;\w+) (?&lt;day&gt;\d+) /)
scanner.captures         # =&gt; ["Fri", "Dec", "12"]
scanner.values_at(*0..4) # =&gt; ["Fri Dec 12 ", "Fri", "Dec", "12", nil]

scanner.exist?(/Fri/)
scanner.captures         # =&gt; []

scanner.scan(/nope/)
scanner.captures         # =&gt; nil
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-charpos"> <a href="#method-i-charpos" title="Link to this method"> <span class="method-name">charpos</span> <span class="method-args">()</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="charpos-source"> <pre class="c" data-language="c">static VALUE
strscan_get_charpos(VALUE self)
{
    struct strscanner *p;

    GET_SCANNER(self, p);

    return LONG2NUM(rb_enc_strlen(S_PBEG(p), CURPTR(p), rb_enc_get(p-&gt;str)));
}</pre> </div>  <p>call-seq: charpos -&gt; character_position</p> <p>Returns the <a href="stringscanner.html#class-StringScanner-label-Character+Position">character position</a> (initially zero), which may be different from the <a href="stringscanner.html#class-StringScanner-label-Byte+Position+-28Position-29">byte position</a> given by method <a href="stringscanner.html#method-i-pos"><code>pos</code></a>:</p> <pre class="ruby" data-language="ruby">scanner = StringScanner.new(HIRAGANA_TEXT)
scanner.string # =&gt; "こんにちは"
scanner.getch  # =&gt; "こ" # 3-byte character.
scanner.getch  # =&gt; "ん" # 3-byte character.
put_situation(scanner)
# Situation:
#   pos:       6
#   charpos:   2
#   rest:      "にちは"
#   rest_size: 9
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-check"> <a href="#method-i-check" title="Link to this method"> <span class="method-callseq"> check(pattern) → matched_substring or nil </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="check-source"> <pre class="c" data-language="c">static VALUE
strscan_check(VALUE self, VALUE re)
{
    return strscan_do_scan(self, re, 0, 1, 1);
}</pre> </div>  <p>Attempts to <a href="stringscanner.html#class-StringScanner-label-Matching">match</a> the given <code>pattern</code> at the beginning of the <a href="stringscanner.html#class-StringScanner-label-Target+Substring">target substring</a>; does not modify the <a href="stringscanner.html#class-StringScanner-label-Positions">positions</a>.</p> <p>If the match succeeds:</p> <ul>
<li> <p>Returns the matched substring.</p> </li>
<li> <p>Sets all <a href="stringscanner.html#class-StringScanner-label-Match+Values">match values</a>.</p> </li>
</ul> <pre class="ruby" data-language="ruby">scanner = StringScanner.new('foobarbaz')
scanner.pos = 3
scanner.check('bar') # =&gt; "bar"
put_match_values(scanner)
# Basic match values:
#   matched?:       true
#   matched_size:   3
#   pre_match:      "foo"
#   matched  :      "bar"
#   post_match:     "baz"
# Captured match values:
#   size:           1
#   captures:       []
#   named_captures: {}
#   values_at:      ["bar", nil]
#   []:
#     [0]:          "bar"
#     [1]:          nil
# =&gt; 0..1
put_situation(scanner)
# Situation:
#   pos:       3
#   charpos:   3
#   rest:      "barbaz"
#   rest_size: 6
</pre> <p>If the match fails:</p> <ul>
<li> <p>Returns <code>nil</code>.</p> </li>
<li> <p>Clears all <a href="stringscanner.html#class-StringScanner-label-Match+Values">match values</a>.</p> </li>
</ul> <pre class="ruby" data-language="ruby">scanner.check(/nope/)          # =&gt; nil
match_values_cleared?(scanner) # =&gt; true
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-check_until"> <a href="#method-i-check_until" title="Link to this method"> <span class="method-callseq"> check_until(pattern) → substring or nil </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="check_until-source"> <pre class="c" data-language="c">static VALUE
strscan_check_until(VALUE self, VALUE re)
{
    return strscan_do_scan(self, re, 0, 1, 0);
}</pre> </div>  <p>Attempts to <a href="stringscanner.html#class-StringScanner-label-Matching">match</a> the given <code>pattern</code> anywhere (at any <a href="stringscanner.html#class-StringScanner-label-Byte+Position+-28Position-29">position</a>) in the <a href="stringscanner.html#class-StringScanner-label-Target+Substring">target substring</a>; does not modify the <a href="stringscanner.html#class-StringScanner-label-Positions">positions</a>.</p> <p>If the match succeeds:</p> <ul>
<li> <p>Sets all <a href="stringscanner.html#class-StringScanner-label-Match+Values">match values</a>.</p> </li>
<li> <p>Returns the matched substring, which extends from the current <a href="stringscanner.html#class-StringScanner-label-Byte+Position+-28Position-29">position</a> to the end of the matched substring.</p> </li>
</ul> <pre class="ruby" data-language="ruby">scanner = StringScanner.new('foobarbazbatbam')
scanner.pos = 6
scanner.check_until(/bat/) # =&gt; "bazbat"
put_match_values(scanner)
# Basic match values:
#   matched?:       true
#   matched_size:   3
#   pre_match:      "foobarbaz"
#   matched  :      "bat"
#   post_match:     "bam"
# Captured match values:
#   size:           1
#   captures:       []
#   named_captures: {}
#   values_at:      ["bat", nil]
#   []:
#     [0]:          "bat"
#     [1]:          nil
put_situation(scanner)
# Situation:
#   pos:       6
#   charpos:   6
#   rest:      "bazbatbam"
#   rest_size: 9
</pre> <p>If the match fails:</p> <ul>
<li> <p>Clears all <a href="stringscanner.html#class-StringScanner-label-Match+Values">match values</a>.</p> </li>
<li> <p>Returns <code>nil</code>.</p> </li>
</ul> <pre class="ruby" data-language="ruby">scanner.check_until(/nope/)    # =&gt; nil
match_values_cleared?(scanner) # =&gt; true
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-concat"> <a href="#method-i-concat" title="Link to this method"> <span class="method-callseq"> concat(more_string) → self </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="concat-source"> <pre class="c" data-language="c">static VALUE
strscan_concat(VALUE self, VALUE str)
{
    struct strscanner *p;

    GET_SCANNER(self, p);
    StringValue(str);
    rb_str_append(p-&gt;str, str);
    return self;
}</pre> </div>  <ul>
<li> <p>Appends the given <code>more_string</code> to the <a href="stringscanner.html#class-StringScanner-label-Stored+String">stored string</a>.</p> </li>
<li> <p>Returns <code>self</code>.</p> </li>
<li> <p>Does not affect the <a href="stringscanner.html#class-StringScanner-label-Positions">positions</a> or <a href="stringscanner.html#class-StringScanner-label-Match+Values">match values</a>.</p> </li>
</ul> <pre class="ruby" data-language="ruby">scanner = StringScanner.new('foo')
scanner.string           # =&gt; "foo"
scanner.terminate
scanner.concat('barbaz') # =&gt; #&lt;StringScanner 3/9 "foo" @ "barba..."&gt;
scanner.string           # =&gt; "foobarbaz"
put_situation(scanner)
# Situation:
#   pos:       3
#   charpos:   3
#   rest:      "barbaz"
#   rest_size: 6
</pre> </div> <div class="aliases"> Also aliased as: <a href="stringscanner.html#method-i-3C-3C">&lt;&lt;</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-eos-3F"> <a href="#method-i-eos-3F" title="Link to this method"> <span class="method-callseq"> eos? → true or false </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="eos-3F-source"> <pre class="c" data-language="c">static VALUE
strscan_eos_p(VALUE self)
{
    struct strscanner *p;

    GET_SCANNER(self, p);
    return EOS_P(p) ? Qtrue : Qfalse;
}</pre> </div>  <p>Returns whether the <a href="stringscanner.html#class-StringScanner-label-Byte+Position+-28Position-29">position</a> is at the end of the <a href="stringscanner.html#class-StringScanner-label-Stored+String">stored string</a>:</p> <pre class="ruby" data-language="ruby">scanner = StringScanner.new('foobarbaz')
scanner.eos? # =&gt; false
pos = 3
scanner.eos? # =&gt; false
scanner.terminate
scanner.eos? # =&gt; true
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-exist-3F"> <a href="#method-i-exist-3F" title="Link to this method"> <span class="method-callseq"> exist?(pattern) → byte_offset or nil </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="exist-3F-source"> <pre class="c" data-language="c">static VALUE
strscan_exist_p(VALUE self, VALUE re)
{
    return strscan_do_scan(self, re, 0, 0, 0);
}</pre> </div>  <p>Attempts to <a href="stringscanner.html#class-StringScanner-label-Matching">match</a> the given <code>pattern</code> anywhere (at any <a href="stringscanner.html#class-StringScanner-label-Byte+Position+-28Position-29">position</a>) n the <a href="stringscanner.html#class-StringScanner-label-Target+Substring">target substring</a>; does not modify the <a href="stringscanner.html#class-StringScanner-label-Positions">positions</a>.</p> <p>If the match succeeds:</p> <ul>
<li> <p>Returns a byte offset: the distance in bytes between the current <a href="stringscanner.html#class-StringScanner-label-Byte+Position+-28Position-29">position</a> and the end of the matched substring.</p> </li>
<li> <p>Sets all <a href="stringscanner.html#class-StringScanner-label-Match+Values">match values</a>.</p> </li>
</ul> <pre class="ruby" data-language="ruby">scanner = StringScanner.new('foobarbazbatbam')
scanner.pos = 6
scanner.exist?(/bat/) # =&gt; 6
put_match_values(scanner)
# Basic match values:
#   matched?:       true
#   matched_size:   3
#   pre_match:      "foobarbaz"
#   matched  :      "bat"
#   post_match:     "bam"
# Captured match values:
#   size:           1
#   captures:       []
#   named_captures: {}
#   values_at:      ["bat", nil]
#   []:
#     [0]:          "bat"
#     [1]:          nil
put_situation(scanner)
# Situation:
#   pos:       6
#   charpos:   6
#   rest:      "bazbatbam"
#   rest_size: 9
</pre> <p>If the match fails:</p> <ul>
<li> <p>Returns <code>nil</code>.</p> </li>
<li> <p>Clears all <a href="stringscanner.html#class-StringScanner-label-Match+Values">match values</a>.</p> </li>
</ul> <pre class="ruby" data-language="ruby">scanner.exist?(/nope/)         # =&gt; nil
match_values_cleared?(scanner) # =&gt; true
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-fixed_anchor-3F"> <a href="#method-i-fixed_anchor-3F" title="Link to this method"> <span class="method-callseq"> fixed_anchor? → true or false </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="fixed_anchor-3F-source"> <pre class="c" data-language="c">static VALUE
strscan_fixed_anchor_p(VALUE self)
{
    struct strscanner *p;
    p = check_strscan(self);
    return p-&gt;fixed_anchor_p ? Qtrue : Qfalse;
}</pre> </div>  <p>Returns whether the <a href="stringscanner.html#class-StringScanner-label-Fixed-Anchor+Property">fixed-anchor property</a> is set.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-get_byte"> <a href="#method-i-get_byte" title="Link to this method"> <span class="method-name">get_byte</span> <span class="method-args">()</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="get_byte-source"> <pre class="c" data-language="c">static VALUE
strscan_get_byte(VALUE self)
{
    struct strscanner *p;

    GET_SCANNER(self, p);
    CLEAR_MATCH_STATUS(p);
    if (EOS_P(p))
        return Qnil;

    p-&gt;prev = p-&gt;curr;
    p-&gt;curr++;
    MATCHED(p);
    adjust_registers_to_matched(p);
    return extract_range(p,
                         adjust_register_position(p, p-&gt;regs.beg[0]),
                         adjust_register_position(p, p-&gt;regs.end[0]));
}</pre> </div>  <p>call-seq: <a href="stringscanner.html#method-i-get_byte"><code>get_byte</code></a> -&gt; byte_as_character or nil</p> <p>Returns the next byte, if available:</p> <ul>
<li> <p>If the <a href="stringscanner.html#class-StringScanner-label-Byte+Position+-28Position-29">position</a> is not at the end of the <a href="stringscanner.html#class-StringScanner-label-Stored+String">stored string</a>:</p> <ul>
<li> <p>Returns the next byte.</p> </li>
<li> <p>Increments the <a href="stringscanner.html#class-StringScanner-label-Byte+Position+-28Position-29">byte position</a>.</p> </li>
<li> <p>Adjusts the <a href="stringscanner.html#class-StringScanner-label-Character+Position">character position</a>.</p> </li>
</ul> <pre class="ruby" data-language="ruby">scanner = StringScanner.new(HIRAGANA_TEXT)
# =&gt; #&lt;StringScanner 0/15 @ "\xE3\x81\x93\xE3\x82..."&gt;
scanner.string                                   # =&gt; "こんにちは"
[scanner.get_byte, scanner.pos, scanner.charpos] # =&gt; ["\xE3", 1, 1]
[scanner.get_byte, scanner.pos, scanner.charpos] # =&gt; ["\x81", 2, 2]
[scanner.get_byte, scanner.pos, scanner.charpos] # =&gt; ["\x93", 3, 1]
[scanner.get_byte, scanner.pos, scanner.charpos] # =&gt; ["\xE3", 4, 2]
[scanner.get_byte, scanner.pos, scanner.charpos] # =&gt; ["\x82", 5, 3]
[scanner.get_byte, scanner.pos, scanner.charpos] # =&gt; ["\x93", 6, 2]
</pre> </li>
<li> <p>Otherwise, returns <code>nil</code>, and does not change the positions.</p> <pre class="ruby" data-language="ruby">scanner.terminate
[scanner.get_byte, scanner.pos, scanner.charpos] # =&gt; [nil, 15, 5]
</pre> </li>
</ul> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-getch"> <a href="#method-i-getch" title="Link to this method"> <span class="method-name">getch</span> <span class="method-args">()</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="getch-source"> <pre class="c" data-language="c">static VALUE
strscan_getch(VALUE self)
{
    struct strscanner *p;
    long len;

    GET_SCANNER(self, p);
    CLEAR_MATCH_STATUS(p);
    if (EOS_P(p))
        return Qnil;

    len = rb_enc_mbclen(CURPTR(p), S_PEND(p), rb_enc_get(p-&gt;str));
    len = minl(len, S_RESTLEN(p));
    p-&gt;prev = p-&gt;curr;
    p-&gt;curr += len;
    MATCHED(p);
    adjust_registers_to_matched(p);
    return extract_range(p,
                         adjust_register_position(p, p-&gt;regs.beg[0]),
                         adjust_register_position(p, p-&gt;regs.end[0]));
}</pre> </div>  <p>call-seq: getch -&gt; character or nil</p> <p>Returns the next (possibly multibyte) character, if available:</p> <ul>
<li> <p>If the <a href="stringscanner.html#class-StringScanner-label-Byte+Position+-28Position-29">position</a> is at the beginning of a character:</p> <ul>
<li> <p>Returns the character.</p> </li>
<li> <p>Increments the <a href="stringscanner.html#class-StringScanner-label-Character+Position">character position</a> by 1.</p> </li>
<li> <p>Increments the <a href="stringscanner.html#class-StringScanner-label-Byte+Position+-28Position-29">byte position</a> by the size (in bytes) of the character.</p> </li>
</ul> <pre class="ruby" data-language="ruby">scanner = StringScanner.new(HIRAGANA_TEXT)
scanner.string                                # =&gt; "こんにちは"
[scanner.getch, scanner.pos, scanner.charpos] # =&gt; ["こ", 3, 1]
[scanner.getch, scanner.pos, scanner.charpos] # =&gt; ["ん", 6, 2]
[scanner.getch, scanner.pos, scanner.charpos] # =&gt; ["に", 9, 3]
[scanner.getch, scanner.pos, scanner.charpos] # =&gt; ["ち", 12, 4]
[scanner.getch, scanner.pos, scanner.charpos] # =&gt; ["は", 15, 5]
[scanner.getch, scanner.pos, scanner.charpos] # =&gt; [nil, 15, 5]
</pre> </li>
<li> <p>If the <a href="stringscanner.html#class-StringScanner-label-Byte+Position+-28Position-29">position</a> is within a multi-byte character (that is, not at its beginning), behaves like <a href="stringscanner.html#method-i-get_byte"><code>get_byte</code></a> (returns a 1-byte character):</p> <pre class="ruby" data-language="ruby">scanner.pos = 1
[scanner.getch, scanner.pos, scanner.charpos] # =&gt; ["\x81", 2, 2]
[scanner.getch, scanner.pos, scanner.charpos] # =&gt; ["\x93", 3, 1]
[scanner.getch, scanner.pos, scanner.charpos] # =&gt; ["ん", 6, 2]
</pre> </li>
<li> <p>If the <a href="stringscanner.html#class-StringScanner-label-Byte+Position+-28Position-29">position</a> is at the end of the <a href="stringscanner.html#class-StringScanner-label-Stored+String">stored string</a>, returns <code>nil</code> and does not modify the positions:</p> <pre class="ruby" data-language="ruby">scanner.terminate
[scanner.getch, scanner.pos, scanner.charpos] # =&gt; [nil, 15, 5]
</pre> </li>
</ul> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-inspect"> <a href="#method-i-inspect" title="Link to this method"> <span class="method-callseq"> inspect → string </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="inspect-source"> <pre class="c" data-language="c">static VALUE
strscan_inspect(VALUE self)
{
    struct strscanner *p;
    VALUE a, b;

    p = check_strscan(self);
    if (NIL_P(p-&gt;str)) {
        a = rb_sprintf("#&lt;%"PRIsVALUE" (uninitialized)&gt;", rb_obj_class(self));
        return a;
    }
    if (EOS_P(p)) {
        a = rb_sprintf("#&lt;%"PRIsVALUE" fin&gt;", rb_obj_class(self));
        return a;
    }
    if (p-&gt;curr == 0) {
        b = inspect2(p);
        a = rb_sprintf("#&lt;%"PRIsVALUE" %ld/%ld @ %"PRIsVALUE"&gt;",
                       rb_obj_class(self),
                       p-&gt;curr, S_LEN(p),
                       b);
        return a;
    }
    a = inspect1(p);
    b = inspect2(p);
    a = rb_sprintf("#&lt;%"PRIsVALUE" %ld/%ld %"PRIsVALUE" @ %"PRIsVALUE"&gt;",
                   rb_obj_class(self),
                   p-&gt;curr, S_LEN(p),
                   a, b);
    return a;
}</pre> </div>  <p>Returns a string representation of <code>self</code> that may show:</p> <ol>
<li> <p>The current <a href="stringscanner.html#class-StringScanner-label-Byte+Position+-28Position-29">position</a>.</p> </li>
<li> <p>The size (in bytes) of the <a href="stringscanner.html#class-StringScanner-label-Stored+String">stored string</a>.</p> </li>
<li> <p>The substring preceding the current position.</p> </li>
<li> <p>The substring following the current position (which is also the <a href="stringscanner.html#class-StringScanner-label-Target+Substring">target substring</a>).</p> </li>
</ol> <pre class="ruby" data-language="ruby">scanner = StringScanner.new("Fri Dec 12 1975 14:39")
scanner.pos = 11
scanner.inspect # =&gt; "#&lt;StringScanner 11/21 \"...c 12 \" @ \"1975 ...\"&gt;"
</pre> <p>If at beginning-of-string, item 4 above (following substring) is omitted:</p> <pre class="ruby" data-language="ruby">scanner.reset
scanner.inspect # =&gt; "#&lt;StringScanner 0/21 @ \"Fri D...\"&gt;"
</pre> <p>If at end-of-string, all items above are omitted:</p> <pre class="ruby" data-language="ruby">scanner.terminate
scanner.inspect # =&gt; "#&lt;StringScanner fin&gt;"
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-match-3F"> <a href="#method-i-match-3F" title="Link to this method"> <span class="method-callseq"> match?(pattern) → updated_position or nil </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="match-3F-source"> <pre class="c" data-language="c">static VALUE
strscan_match_p(VALUE self, VALUE re)
{
    return strscan_do_scan(self, re, 0, 0, 1);
}</pre> </div>  <p>Attempts to <a href="stringscanner.html#class-StringScanner-label-Matching">match</a> the given <code>pattern</code> at the beginning of the <a href="stringscanner.html#class-StringScanner-label-Target+Substring">target substring</a>; does not modify the <a href="stringscanner.html#class-StringScanner-label-Positions">positions</a>.</p> <p>If the match succeeds:</p> <ul>
<li> <p>Sets <a href="stringscanner.html#class-StringScanner-label-Match+Values">match values</a>.</p> </li>
<li> <p>Returns the size in bytes of the matched substring.</p> </li>
</ul> <pre class="ruby" data-language="ruby">scanner = StringScanner.new('foobarbaz')
scanner.pos = 3
scanner.match?(/bar/) =&gt; 3
put_match_values(scanner)
# Basic match values:
#   matched?:       true
#   matched_size:   3
#   pre_match:      "foo"
#   matched  :      "bar"
#   post_match:     "baz"
# Captured match values:
#   size:           1
#   captures:       []
#   named_captures: {}
#   values_at:      ["bar", nil]
#   []:
#     [0]:          "bar"
#     [1]:          nil
put_situation(scanner)
# Situation:
#   pos:       3
#   charpos:   3
#   rest:      "barbaz"
#   rest_size: 6
</pre> <p>If the match fails:</p> <ul>
<li> <p>Clears match values.</p> </li>
<li> <p>Returns <code>nil</code>.</p> </li>
<li> <p>Does not increment positions.</p> </li>
</ul> <pre class="ruby" data-language="ruby">scanner.match?(/nope/)         # =&gt; nil
match_values_cleared?(scanner) # =&gt; true
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-matched"> <a href="#method-i-matched" title="Link to this method"> <span class="method-callseq"> matched → matched_substring or nil </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="matched-source"> <pre class="c" data-language="c">static VALUE
strscan_matched(VALUE self)
{
    struct strscanner *p;

    GET_SCANNER(self, p);
    if (! MATCHED_P(p)) return Qnil;
    return extract_range(p,
                         adjust_register_position(p, p-&gt;regs.beg[0]),
                         adjust_register_position(p, p-&gt;regs.end[0]));
}</pre> </div>  <p>Returns the matched substring from the most recent <a href="stringscanner.html#class-StringScanner-label-Matching">match</a> attempt if it was successful, or <code>nil</code> otherwise; see <a href="stringscanner.html#class-StringScanner-label-Basic+Match+Values">Basic Matched Values</a>:</p> <pre class="ruby" data-language="ruby">scanner = StringScanner.new('foobarbaz')
scanner.matched        # =&gt; nil
scanner.pos = 3
scanner.match?(/bar/)  # =&gt; 3
scanner.matched        # =&gt; "bar"
scanner.match?(/nope/) # =&gt; nil
scanner.matched        # =&gt; nil
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-matched-3F"> <a href="#method-i-matched-3F" title="Link to this method"> <span class="method-callseq"> matched? → true or false </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="matched-3F-source"> <pre class="c" data-language="c">static VALUE
strscan_matched_p(VALUE self)
{
    struct strscanner *p;

    GET_SCANNER(self, p);
    return MATCHED_P(p) ? Qtrue : Qfalse;
}</pre> </div>  <p>Returns <code>true</code> of the most recent <a href="stringscanner.html#class-StringScanner-label-Matching">match attempt</a> was successful, <code>false</code> otherwise; see <a href="stringscanner.html#class-StringScanner-label-Basic+Match+Values">Basic Matched Values</a>:</p> <pre class="ruby" data-language="ruby">scanner = StringScanner.new('foobarbaz')
scanner.matched?       # =&gt; false
scanner.pos = 3
scanner.exist?(/baz/)  # =&gt; 6
scanner.matched?       # =&gt; true
scanner.exist?(/nope/) # =&gt; nil
scanner.matched?       # =&gt; false
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-matched_size"> <a href="#method-i-matched_size" title="Link to this method"> <span class="method-callseq"> matched_size → substring_size or nil </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="matched_size-source"> <pre class="c" data-language="c">static VALUE
strscan_matched_size(VALUE self)
{
    struct strscanner *p;

    GET_SCANNER(self, p);
    if (! MATCHED_P(p)) return Qnil;
    return LONG2NUM(p-&gt;regs.end[0] - p-&gt;regs.beg[0]);
}</pre> </div>  <p>Returns the size (in bytes) of the matched substring from the most recent match <a href="stringscanner.html#class-StringScanner-label-Matching">match attempt</a> if it was successful, or <code>nil</code> otherwise; see <a href="stringscanner.html#class-StringScanner-label-Basic+Match+Values">Basic Matched Values</a>:</p> <pre class="ruby" data-language="ruby">scanner = StringScanner.new('foobarbaz')
scanner.matched_size   # =&gt; nil

pos = 3
scanner.exist?(/baz/)  # =&gt; 9
scanner.matched_size   # =&gt; 3

scanner.exist?(/nope/) # =&gt; nil
scanner.matched_size   # =&gt; nil
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-named_captures"> <a href="#method-i-named_captures" title="Link to this method"> <span class="method-callseq"> named_captures → hash </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="named_captures-source"> <pre class="c" data-language="c">static VALUE
strscan_named_captures(VALUE self)
{
    struct strscanner *p;
    named_captures_data data;
    GET_SCANNER(self, p);
    data.self = self;
    data.captures = rb_hash_new();
    if (!RB_NIL_P(p-&gt;regex)) {
        onig_foreach_name(RREGEXP_PTR(p-&gt;regex), named_captures_iter, &amp;data);
    }

    return data.captures;
}</pre> </div>  <p>Returns the array of captured match values at indexes (1..) if the most recent match attempt succeeded, or nil otherwise; see <a href="stringscanner.html#class-StringScanner-label-Captured+Match+Values">Captured Match Values</a>:</p> <pre class="ruby" data-language="ruby">scanner = StringScanner.new('Fri Dec 12 1975 14:39')
scanner.named_captures # =&gt; {}

pattern = /(?&lt;wday&gt;\w+) (?&lt;month&gt;\w+) (?&lt;day&gt;\d+) /
scanner.match?(pattern)
scanner.named_captures # =&gt; {"wday"=&gt;"Fri", "month"=&gt;"Dec", "day"=&gt;"12"}

scanner.string = 'nope'
scanner.match?(pattern)
scanner.named_captures # =&gt; {"wday"=&gt;nil, "month"=&gt;nil, "day"=&gt;nil}

scanner.match?(/nosuch/)
scanner.named_captures # =&gt; {}
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-peek"> <a href="#method-i-peek" title="Link to this method"> <span class="method-callseq"> peek(length) → substring </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="peek-source"> <pre class="c" data-language="c">static VALUE
strscan_peek(VALUE self, VALUE vlen)
{
    struct strscanner *p;
    long len;

    GET_SCANNER(self, p);

    len = NUM2LONG(vlen);
    if (EOS_P(p))
        return str_new(p, "", 0);

    len = minl(len, S_RESTLEN(p));
    return extract_beg_len(p, p-&gt;curr, len);
}</pre> </div>  <p>Returns the substring <code>string[pos, length]</code>; does not update <a href="stringscanner.html#class-StringScanner-label-Match+Values">match values</a> or <a href="stringscanner.html#class-StringScanner-label-Positions">positions</a>:</p> <pre class="ruby" data-language="ruby">scanner = StringScanner.new('foobarbaz')
scanner.pos = 3
scanner.peek(3)   # =&gt; "bar"
scanner.terminate
scanner.peek(3)   # =&gt; ""
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-peek_byte"> <a href="#method-i-peek_byte" title="Link to this method"> <span class="method-name">peek_byte</span> <span class="method-args">()</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="peek_byte-source"> <pre class="c" data-language="c">static VALUE
strscan_peek_byte(VALUE self)
{
    struct strscanner *p;

    GET_SCANNER(self, p);
    if (EOS_P(p))
        return Qnil;

    return INT2FIX((unsigned char)*CURPTR(p));
}</pre> </div>  <p>Peeks at the current byte and returns it as an integer.</p> <pre class="ruby" data-language="ruby">s = StringScanner.new('ab')
s.peek_byte         # =&gt; 97
</pre> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-pointer"> <a href="#method-i-pointer" title="Link to this method"> <span class="method-name">pointer</span> <span class="method-args">()</span> </a> </div> </div> <div class="method-description"> <p>call-seq: pos -&gt; byte_position</p> <p>Returns the integer <a href="stringscanner.html#class-StringScanner-label-Byte+Position+-28Position-29">byte position</a>, which may be different from the <a href="stringscanner.html#class-StringScanner-label-Character+Position">character position</a>:</p> <pre class="ruby" data-language="ruby">scanner = StringScanner.new(HIRAGANA_TEXT)
scanner.string  # =&gt; "こんにちは"
scanner.pos     # =&gt; 0
scanner.getch   # =&gt; "こ" # 3-byte character.
scanner.charpos # =&gt; 1
scanner.pos     # =&gt; 3
</pre> </div> <div class="aliases"> Alias for: <a href="stringscanner.html#method-i-pos">pos</a> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-pointer-3D"> <a href="#method-i-pointer-3D" title="Link to this method"> <span class="method-name">pointer=</span> <span class="method-args">(p1)</span> </a> </div> </div> <div class="method-description"> <p>call-seq: pos = n -&gt; n pointer = n -&gt; n</p> <p>Sets the <a href="stringscanner.html#class-StringScanner-label-Byte+Position+-28Position-29">byte position</a> and the <a href="stringscanner.html#class-StringScanner-label-Positions">character position</a>; returns <code>n</code>.</p> <p>Does not affect <a href="stringscanner.html#class-StringScanner-label-Match+Values">match values</a>.</p> <p>For non-negative <code>n</code>, sets the position to <code>n</code>:</p> <pre class="ruby" data-language="ruby">scanner = StringScanner.new(HIRAGANA_TEXT)
scanner.string  # =&gt; "こんにちは"
scanner.pos = 3 # =&gt; 3
scanner.rest    # =&gt; "んにちは"
scanner.charpos # =&gt; 1
</pre> <p>For negative <code>n</code>, counts from the end of the <a href="stringscanner.html#class-StringScanner-label-Stored+String">stored string</a>:</p> <pre class="ruby" data-language="ruby">scanner.pos = -9 # =&gt; -9
scanner.pos      # =&gt; 6
scanner.rest     # =&gt; "にちは"
scanner.charpos  # =&gt; 2
</pre> </div> <div class="aliases"> Alias for: <a href="stringscanner.html#method-i-pos-3D">pos=</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-pos"> <a href="#method-i-pos" title="Link to this method"> <span class="method-name">pos</span> <span class="method-args">()</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="pos-source"> <pre class="c" data-language="c">static VALUE
strscan_get_pos(VALUE self)
{
    struct strscanner *p;

    GET_SCANNER(self, p);
    return INT2FIX(p-&gt;curr);
}</pre> </div>  <p>call-seq: pos -&gt; byte_position</p> <p>Returns the integer <a href="stringscanner.html#class-StringScanner-label-Byte+Position+-28Position-29">byte position</a>, which may be different from the <a href="stringscanner.html#class-StringScanner-label-Character+Position">character position</a>:</p> <pre class="ruby" data-language="ruby">scanner = StringScanner.new(HIRAGANA_TEXT)
scanner.string  # =&gt; "こんにちは"
scanner.pos     # =&gt; 0
scanner.getch   # =&gt; "こ" # 3-byte character.
scanner.charpos # =&gt; 1
scanner.pos     # =&gt; 3
</pre> </div> <div class="aliases"> Also aliased as: <a href="stringscanner.html#method-i-pointer">pointer</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-pos-3D"> <a href="#method-i-pos-3D" title="Link to this method"> <span class="method-name">pos=</span> <span class="method-args">(p1)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="pos-3D-source"> <pre class="c" data-language="c">static VALUE
strscan_set_pos(VALUE self, VALUE v)
{
    struct strscanner *p;
    long i;

    GET_SCANNER(self, p);
    i = NUM2INT(v);
    if (i &lt; 0) i += S_LEN(p);
    if (i &lt; 0) rb_raise(rb_eRangeError, "index out of range");
    if (i &gt; S_LEN(p)) rb_raise(rb_eRangeError, "index out of range");
    p-&gt;curr = i;
    return LONG2NUM(i);
}</pre> </div>  <p>call-seq: pos = n -&gt; n pointer = n -&gt; n</p> <p>Sets the <a href="stringscanner.html#class-StringScanner-label-Byte+Position+-28Position-29">byte position</a> and the <a href="stringscanner.html#class-StringScanner-label-Positions">character position</a>; returns <code>n</code>.</p> <p>Does not affect <a href="stringscanner.html#class-StringScanner-label-Match+Values">match values</a>.</p> <p>For non-negative <code>n</code>, sets the position to <code>n</code>:</p> <pre class="ruby" data-language="ruby">scanner = StringScanner.new(HIRAGANA_TEXT)
scanner.string  # =&gt; "こんにちは"
scanner.pos = 3 # =&gt; 3
scanner.rest    # =&gt; "んにちは"
scanner.charpos # =&gt; 1
</pre> <p>For negative <code>n</code>, counts from the end of the <a href="stringscanner.html#class-StringScanner-label-Stored+String">stored string</a>:</p> <pre class="ruby" data-language="ruby">scanner.pos = -9 # =&gt; -9
scanner.pos      # =&gt; 6
scanner.rest     # =&gt; "にちは"
scanner.charpos  # =&gt; 2
</pre> </div> <div class="aliases"> Also aliased as: <a href="stringscanner.html#method-i-pointer-3D">pointer=</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-post_match"> <a href="#method-i-post_match" title="Link to this method"> <span class="method-callseq"> post_match → substring </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="post_match-source"> <pre class="c" data-language="c">static VALUE
strscan_post_match(VALUE self)
{
    struct strscanner *p;

    GET_SCANNER(self, p);
    if (! MATCHED_P(p)) return Qnil;
    return extract_range(p,
                         adjust_register_position(p, p-&gt;regs.end[0]),
                         S_LEN(p));
}</pre> </div>  <p>Returns the substring that follows the matched substring from the most recent match attempt if it was successful, or <code>nil</code> otherwise; see <a href="stringscanner.html#class-StringScanner-label-Basic+Match+Values">Basic Match Values</a>:</p> <pre class="ruby" data-language="ruby">scanner = StringScanner.new('foobarbaz')
scanner.post_match     # =&gt; nil

scanner.pos = 3
scanner.match?(/bar/)  # =&gt; 3
scanner.post_match     # =&gt; "baz"

scanner.match?(/nope/) # =&gt; nil
scanner.post_match     # =&gt; nil
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-pre_match"> <a href="#method-i-pre_match" title="Link to this method"> <span class="method-callseq"> pre_match → substring </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="pre_match-source"> <pre class="c" data-language="c">static VALUE
strscan_pre_match(VALUE self)
{
    struct strscanner *p;

    GET_SCANNER(self, p);
    if (! MATCHED_P(p)) return Qnil;
    return extract_range(p,
                         0,
                         adjust_register_position(p, p-&gt;regs.beg[0]));
}</pre> </div>  <p>Returns the substring that precedes the matched substring from the most recent match attempt if it was successful, or <code>nil</code> otherwise; see <a href="stringscanner.html#class-StringScanner-label-Basic+Match+Values">Basic Match Values</a>:</p> <pre class="ruby" data-language="ruby">scanner = StringScanner.new('foobarbaz')
scanner.pre_match      # =&gt; nil

scanner.pos = 3
scanner.exist?(/baz/)  # =&gt; 6
scanner.pre_match      # =&gt; "foobar" # Substring of entire string, not just target string.

scanner.exist?(/nope/) # =&gt; nil
scanner.pre_match      # =&gt; nil
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-reset"> <a href="#method-i-reset" title="Link to this method"> <span class="method-callseq"> reset → self </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="reset-source"> <pre class="c" data-language="c">static VALUE
strscan_reset(VALUE self)
{
    struct strscanner *p;

    GET_SCANNER(self, p);
    p-&gt;curr = 0;
    CLEAR_MATCH_STATUS(p);
    return self;
}</pre> </div>  <p>Sets both <a href="stringscanner.html#class-StringScanner-label-Byte+Position+-28Position-29">byte position</a> and <a href="stringscanner.html#class-StringScanner-label-Character+Position">character position</a> to zero, and clears <a href="stringscanner.html#class-StringScanner-label-Match+Values">match values</a>; returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">scanner = StringScanner.new('foobarbaz')
scanner.exist?(/bar/)          # =&gt; 6
scanner.reset                  # =&gt; #&lt;StringScanner 0/9 @ "fooba..."&gt;
put_situation(scanner)
# Situation:
#   pos:       0
#   charpos:   0
#   rest:      "foobarbaz"
#   rest_size: 9
# =&gt; nil
match_values_cleared?(scanner) # =&gt; true
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-rest"> <a href="#method-i-rest" title="Link to this method"> <span class="method-callseq"> rest → target_substring </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="rest-source"> <pre class="c" data-language="c">static VALUE
strscan_rest(VALUE self)
{
    struct strscanner *p;

    GET_SCANNER(self, p);
    if (EOS_P(p)) {
        return str_new(p, "", 0);
    }
    return extract_range(p, p-&gt;curr, S_LEN(p));
}</pre> </div>  <p>Returns the ‘rest’ of the <a href="stringscanner.html#class-StringScanner-label-Stored+String">stored string</a> (all after the current <a href="stringscanner.html#class-StringScanner-label-Byte+Position+-28Position-29">position</a>), which is the <a href="stringscanner.html#class-StringScanner-label-Target+Substring">target substring</a>:</p> <pre class="ruby" data-language="ruby">scanner = StringScanner.new('foobarbaz')
scanner.rest # =&gt; "foobarbaz"
scanner.pos = 3
scanner.rest # =&gt; "barbaz"
scanner.terminate
scanner.rest # =&gt; ""
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-rest_size"> <a href="#method-i-rest_size" title="Link to this method"> <span class="method-callseq"> rest_size → integer </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="rest_size-source"> <pre class="c" data-language="c">static VALUE
strscan_rest_size(VALUE self)
{
    struct strscanner *p;
    long i;

    GET_SCANNER(self, p);
    if (EOS_P(p)) {
        return INT2FIX(0);
    }
    i = S_RESTLEN(p);
    return INT2FIX(i);
}</pre> </div>  <p>Returns the size (in bytes) of the <a href="stringscanner.html#method-i-rest"><code>rest</code></a> of the <a href="stringscanner.html#class-StringScanner-label-Stored+String">stored string</a>:</p> <pre class="ruby" data-language="ruby">scanner = StringScanner.new('foobarbaz')
scanner.rest      # =&gt; "foobarbaz"
scanner.rest_size # =&gt; 9
scanner.pos = 3
scanner.rest      # =&gt; "barbaz"
scanner.rest_size # =&gt; 6
scanner.terminate
scanner.rest      # =&gt; ""
scanner.rest_size # =&gt; 0
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-scan"> <a href="#method-i-scan" title="Link to this method"> <span class="method-name">scan</span> <span class="method-args">(p1)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="scan-source"> <pre class="c" data-language="c">static VALUE
strscan_scan(VALUE self, VALUE re)
{
    return strscan_do_scan(self, re, 1, 1, 1);
}</pre> </div>  <p>call-seq: scan(pattern) -&gt; substring or nil</p> <p>Attempts to <a href="stringscanner.html#class-StringScanner-label-Matching">match</a> the given <code>pattern</code> at the beginning of the <a href="stringscanner.html#class-StringScanner-label-Target+Substring">target substring</a>.</p> <p>If the match succeeds:</p> <ul>
<li> <p>Returns the matched substring.</p> </li>
<li> <p>Increments the <a href="stringscanner.html#class-StringScanner-label-Byte+Position+-28Position-29">byte position</a> by <code>substring.bytesize</code>, and may increment the <a href="stringscanner.html#class-StringScanner-label-Character+Position">character position</a>.</p> </li>
<li> <p>Sets <a href="stringscanner.html#class-StringScanner-label-Match+Values">match values</a>.</p> </li>
</ul> <pre class="ruby" data-language="ruby">scanner = StringScanner.new(HIRAGANA_TEXT)
scanner.string     # =&gt; "こんにちは"
scanner.pos = 6
scanner.scan(/に/) # =&gt; "に"
put_match_values(scanner)
# Basic match values:
#   matched?:       true
#   matched_size:   3
#   pre_match:      "こん"
#   matched  :      "に"
#   post_match:     "ちは"
# Captured match values:
#   size:           1
#   captures:       []
#   named_captures: {}
#   values_at:      ["に", nil]
#   []:
#     [0]:          "に"
#     [1]:          nil
put_situation(scanner)
# Situation:
#   pos:       9
#   charpos:   3
#   rest:      "ちは"
#   rest_size: 6
</pre> <p>If the match fails:</p> <ul>
<li> <p>Returns <code>nil</code>.</p> </li>
<li> <p>Does not increment byte and character positions.</p> </li>
<li> <p>Clears match values.</p> </li>
</ul> <pre class="ruby" data-language="ruby">scanner.scan(/nope/)           # =&gt; nil
match_values_cleared?(scanner) # =&gt; true
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-scan_byte"> <a href="#method-i-scan_byte" title="Link to this method"> <span class="method-callseq"> scan_byte → integer_byte </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="scan_byte-source"> <pre class="c" data-language="c">static VALUE
strscan_scan_byte(VALUE self)
{
    struct strscanner *p;
    VALUE byte;

    GET_SCANNER(self, p);
    CLEAR_MATCH_STATUS(p);
    if (EOS_P(p))
        return Qnil;

    byte = INT2FIX((unsigned char)*CURPTR(p));
    p-&gt;prev = p-&gt;curr;
    p-&gt;curr++;
    MATCHED(p);
    adjust_registers_to_matched(p);
    return byte;
}</pre> </div>  <p>Scans one byte and returns it as an integer. This method is not multibyte character sensitive. See also: <a href="stringscanner.html#method-i-getch"><code>getch</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-scan_until"> <a href="#method-i-scan_until" title="Link to this method"> <span class="method-name">scan_until</span> <span class="method-args">(p1)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="scan_until-source"> <pre class="c" data-language="c">static VALUE
strscan_scan_until(VALUE self, VALUE re)
{
    return strscan_do_scan(self, re, 1, 1, 0);
}</pre> </div>  <p>call-seq: <a href="stringscanner.html#method-i-scan_until"><code>scan_until</code></a>(pattern) -&gt; substring or nil</p> <p>Attempts to <a href="stringscanner.html#class-StringScanner-label-Matching">match</a> the given <code>pattern</code> anywhere (at any <a href="stringscanner.html#class-StringScanner-label-Byte+Position+-28Position-29">position</a>) in the <a href="stringscanner.html#class-StringScanner-label-Target+Substring">target substring</a>.</p> <p>If the match attempt succeeds:</p> <ul>
<li> <p>Sets <a href="stringscanner.html#class-StringScanner-label-Match+Values">match values</a>.</p> </li>
<li> <p>Sets the <a href="stringscanner.html#class-StringScanner-label-Byte+Position+-28Position-29">byte position</a> to the end of the matched substring; may adjust the <a href="stringscanner.html#class-StringScanner-label-Character+Position">character position</a>.</p> </li>
<li> <p>Returns the matched substring.</p> </li>
</ul> <pre class="ruby" data-language="ruby">scanner = StringScanner.new(HIRAGANA_TEXT)
scanner.string           # =&gt; "こんにちは"
scanner.pos = 6
scanner.scan_until(/ち/) # =&gt; "にち"
put_match_values(scanner)
# Basic match values:
#   matched?:       true
#   matched_size:   3
#   pre_match:      "こんに"
#   matched  :      "ち"
#   post_match:     "は"
# Captured match values:
#   size:           1
#   captures:       []
#   named_captures: {}
#   values_at:      ["ち", nil]
#   []:
#     [0]:          "ち"
#     [1]:          nil
put_situation(scanner)
# Situation:
#   pos:       12
#   charpos:   4
#   rest:      "は"
#   rest_size: 3
</pre> <p>If the match attempt fails:</p> <ul>
<li> <p>Clears match data.</p> </li>
<li> <p>Returns <code>nil</code>.</p> </li>
<li> <p>Does not update positions.</p> </li>
</ul> <pre class="ruby" data-language="ruby">scanner.scan_until(/nope/)     # =&gt; nil
match_values_cleared?(scanner) # =&gt; true
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-size"> <a href="#method-i-size" title="Link to this method"> <span class="method-callseq"> size → captures_count </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="size-source"> <pre class="c" data-language="c">static VALUE
strscan_size(VALUE self)
{
    struct strscanner *p;

    GET_SCANNER(self, p);
    if (! MATCHED_P(p))        return Qnil;
    return INT2FIX(p-&gt;regs.num_regs);
}</pre> </div>  <p>Returns the count of captures if the most recent match attempt succeeded, <code>nil</code> otherwise; see <a href="stringscanner.html#class-StringScanner-label-Captured+Match+Values">Captures Match Values</a>:</p> <pre class="ruby" data-language="ruby">scanner = StringScanner.new('Fri Dec 12 1975 14:39')
scanner.size                        # =&gt; nil

pattern = /(?&lt;wday&gt;\w+) (?&lt;month&gt;\w+) (?&lt;day&gt;\d+) /
scanner.match?(pattern)
scanner.values_at(*0..scanner.size) # =&gt; ["Fri Dec 12 ", "Fri", "Dec", "12", nil]
scanner.size                        # =&gt; 4

scanner.match?(/nope/)              # =&gt; nil
scanner.size                        # =&gt; nil
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-skip"> <a href="#method-i-skip" title="Link to this method"> <span class="method-name">skip</span> <span class="method-args">(p1)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="skip-source"> <pre class="c" data-language="c">static VALUE
strscan_skip(VALUE self, VALUE re)
{
    return strscan_do_scan(self, re, 1, 0, 1);
}</pre> </div>  <p>call-seq: skip(pattern) match_size or nil</p> <p>Attempts to <a href="stringscanner.html#class-StringScanner-label-Matching">match</a> the given <code>pattern</code> at the beginning of the <a href="stringscanner.html#class-StringScanner-label-Target+Substring">target substring</a>;</p> <p>If the match succeeds:</p> <ul>
<li> <p>Increments the <a href="stringscanner.html#class-StringScanner-label-Byte+Position+-28Position-29">byte position</a> by substring.bytesize, and may increment the <a href="stringscanner.html#class-StringScanner-label-Character+Position">character position</a>.</p> </li>
<li> <p>Sets <a href="stringscanner.html#class-StringScanner-label-Match+Values">match values</a>.</p> </li>
<li> <p>Returns the size (bytes) of the matched substring.</p> </li>
</ul> <pre class="ruby" data-language="ruby">scanner = StringScanner.new(HIRAGANA_TEXT)
scanner.string                  # =&gt; "こんにちは"
scanner.pos = 6
scanner.skip(/に/)              # =&gt; 3
put_match_values(scanner)
# Basic match values:
#   matched?:       true
#   matched_size:   3
#   pre_match:      "こん"
#   matched  :      "に"
#   post_match:     "ちは"
# Captured match values:
#   size:           1
#   captures:       []
#   named_captures: {}
#   values_at:      ["に", nil]
#   []:
#     [0]:          "に"
#     [1]:          nil
put_situation(scanner)
# Situation:
#   pos:       9
#   charpos:   3
#   rest:      "ちは"
#   rest_size: 6

scanner.skip(/nope/)            # =&gt; nil
match_values_cleared?(scanner)  # =&gt; true
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-skip_until"> <a href="#method-i-skip_until" title="Link to this method"> <span class="method-name">skip_until</span> <span class="method-args">(p1)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="skip_until-source"> <pre class="c" data-language="c">static VALUE
strscan_skip_until(VALUE self, VALUE re)
{
    return strscan_do_scan(self, re, 1, 0, 0);
}</pre> </div>  <p>call-seq: <a href="stringscanner.html#method-i-skip_until"><code>skip_until</code></a>(pattern) -&gt; matched_substring_size or nil</p> <p>Attempts to <a href="stringscanner.html#class-StringScanner-label-Matching">match</a> the given <code>pattern</code> anywhere (at any <a href="stringscanner.html#class-StringScanner-label-Byte+Position+-28Position-29">position</a>) in the <a href="stringscanner.html#class-StringScanner-label-Target+Substring">target substring</a>; does not modify the positions.</p> <p>If the match attempt succeeds:</p> <ul>
<li> <p>Sets <a href="stringscanner.html#class-StringScanner-label-Match+Values">match values</a>.</p> </li>
<li> <p>Returns the size of the matched substring.</p> </li>
</ul> <pre class="ruby" data-language="ruby">scanner = StringScanner.new(HIRAGANA_TEXT)
scanner.string           # =&gt; "こんにちは"
scanner.pos = 6
scanner.skip_until(/ち/) # =&gt; 6
put_match_values(scanner)
# Basic match values:
#   matched?:       true
#   matched_size:   3
#   pre_match:      "こんに"
#   matched  :      "ち"
#   post_match:     "は"
# Captured match values:
#   size:           1
#   captures:       []
#   named_captures: {}
#   values_at:      ["ち", nil]
#   []:
#     [0]:          "ち"
#     [1]:          nil
put_situation(scanner)
# Situation:
#   pos:       12
#   charpos:   4
#   rest:      "は"
#   rest_size: 3
</pre> <p>If the match attempt fails:</p> <ul>
<li> <p>Clears match values.</p> </li>
<li> <p>Returns <code>nil</code>.</p> </li>
</ul> <pre class="ruby" data-language="ruby">scanner.skip_until(/nope/)     # =&gt; nil
match_values_cleared?(scanner) # =&gt; true
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-string"> <a href="#method-i-string" title="Link to this method"> <span class="method-callseq"> string → stored_string </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="string-source"> <pre class="c" data-language="c">static VALUE
strscan_get_string(VALUE self)
{
    struct strscanner *p;

    GET_SCANNER(self, p);
    return p-&gt;str;
}</pre> </div>  <p>Returns the <a href="stringscanner.html#class-StringScanner-label-Stored+String">stored string</a>:</p> <pre class="ruby" data-language="ruby">scanner = StringScanner.new('foobar')
scanner.string # =&gt; "foobar"
scanner.concat('baz')
scanner.string # =&gt; "foobarbaz"
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-string-3D"> <a href="#method-i-string-3D" title="Link to this method"> <span class="method-callseq"> string = other_string → other_string </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="string-3D-source"> <pre class="c" data-language="c">static VALUE
strscan_set_string(VALUE self, VALUE str)
{
    struct strscanner *p = check_strscan(self);

    StringValue(str);
    p-&gt;str = str;
    p-&gt;curr = 0;
    CLEAR_MATCH_STATUS(p);
    return str;
}</pre> </div>  <p>Replaces the <a href="stringscanner.html#class-StringScanner-label-Stored+String">stored string</a> with the given <code>other_string</code>:</p> <ul>
<li> <p>Sets both <a href="stringscanner.html#class-StringScanner-label-Positions">positions</a> to zero.</p> </li>
<li> <p>Clears <a href="stringscanner.html#class-StringScanner-label-Match+Values">match values</a>.</p> </li>
<li> <p>Returns <code>other_string</code>.</p> </li>
</ul> <pre class="ruby" data-language="ruby">scanner = StringScanner.new('foobar')
scanner.scan(/foo/)
put_situation(scanner)
# Situation:
#   pos:       3
#   charpos:   3
#   rest:      "bar"
#   rest_size: 3
match_values_cleared?(scanner) # =&gt; false

scanner.string = 'baz'         # =&gt; "baz"
put_situation(scanner)
# Situation:
#   pos:       0
#   charpos:   0
#   rest:      "baz"
#   rest_size: 3
match_values_cleared?(scanner) # =&gt; true
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-terminate"> <a href="#method-i-terminate" title="Link to this method"> <span class="method-name">terminate</span> <span class="method-args">()</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="terminate-source"> <pre class="c" data-language="c">static VALUE
strscan_terminate(VALUE self)
{
    struct strscanner *p;

    GET_SCANNER(self, p);
    p-&gt;curr = S_LEN(p);
    CLEAR_MATCH_STATUS(p);
    return self;
}</pre> </div>  <p>call-seq: terminate -&gt; self</p> <p>Sets the scanner to end-of-string; returns <code>self</code>:</p> <ul>
<li> <p>Sets both <a href="stringscanner.html#class-StringScanner-label-Positions">positions</a> to end-of-stream.</p> </li>
<li> <p>Clears <a href="stringscanner.html#class-StringScanner-label-Match+Values">match values</a>.</p> </li>
</ul> <pre class="ruby" data-language="ruby">scanner = StringScanner.new(HIRAGANA_TEXT)
scanner.string                 # =&gt; "こんにちは"
scanner.scan_until(/に/)
put_situation(scanner)
# Situation:
#   pos:       9
#   charpos:   3
#   rest:      "ちは"
#   rest_size: 6
match_values_cleared?(scanner) # =&gt; false

scanner.terminate              # =&gt; #&lt;StringScanner fin&gt;
put_situation(scanner)
# Situation:
#   pos:       15
#   charpos:   5
#   rest:      ""
#   rest_size: 0
match_values_cleared?(scanner) # =&gt; true
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-unscan"> <a href="#method-i-unscan" title="Link to this method"> <span class="method-callseq"> unscan → self </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="unscan-source"> <pre class="c" data-language="c">static VALUE
strscan_unscan(VALUE self)
{
    struct strscanner *p;

    GET_SCANNER(self, p);
    if (! MATCHED_P(p))
        rb_raise(ScanError, "unscan failed: previous match record not exist");
    p-&gt;curr = p-&gt;prev;
    CLEAR_MATCH_STATUS(p);
    return self;
}</pre> </div>  <p>Sets the <a href="stringscanner.html#class-StringScanner-label-Byte+Position+-28Position-29">position</a> to its value previous to the recent successful <a href="stringscanner.html#class-StringScanner-label-Matching">match</a> attempt:</p> <pre class="ruby" data-language="ruby">scanner = StringScanner.new('foobarbaz')
scanner.scan(/foo/)
put_situation(scanner)
# Situation:
#   pos:       3
#   charpos:   3
#   rest:      "barbaz"
#   rest_size: 6
scanner.unscan
# =&gt; #&lt;StringScanner 0/9 @ "fooba..."&gt;
put_situation(scanner)
# Situation:
#   pos:       0
#   charpos:   0
#   rest:      "foobarbaz"
#   rest_size: 9
</pre> <p>Raises an exception if match values are clear:</p> <pre class="ruby" data-language="ruby">scanner.scan(/nope/)           # =&gt; nil
match_values_cleared?(scanner) # =&gt; true
scanner.unscan                 # Raises StringScanner::Error.
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-values_at"> <a href="#method-i-values_at" title="Link to this method"> <span class="method-callseq"> values_at(*specifiers) → array_of_captures or nil </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="values_at-source"> <pre class="c" data-language="c">static VALUE
strscan_values_at(int argc, VALUE *argv, VALUE self)
{
    struct strscanner *p;
    long i;
    VALUE new_ary;

    GET_SCANNER(self, p);
    if (! MATCHED_P(p))        return Qnil;

    new_ary = rb_ary_new2(argc);
    for (i = 0; i&lt;argc; i++) {
        rb_ary_push(new_ary, strscan_aref(self, argv[i]));
    }

    return new_ary;
}</pre> </div>  <p>Returns an array of captured substrings, or <code>nil</code> of none.</p> <p>For each <code>specifier</code>, the returned substring is <code>[specifier]</code>; see <a href="stringscanner.html#method-i-5B-5D"><code>[]</code></a>.</p> <pre class="ruby" data-language="ruby">scanner = StringScanner.new('Fri Dec 12 1975 14:39')
pattern = /(?&lt;wday&gt;\w+) (?&lt;month&gt;\w+) (?&lt;day&gt;\d+) /
scanner.match?(pattern)
scanner.values_at(*0..3)               # =&gt; ["Fri Dec 12 ", "Fri", "Dec", "12"]
scanner.values_at(*%i[wday month day]) # =&gt; ["Fri", "Dec", "12"]
</pre> </div> </div> </section> <section id="private-instance-5Buntitled-5D-method-details" class="method-section anchor-link"> <header> <h3>Private Instance Methods</h3> </header> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-initialize_copy"> <a href="#method-i-initialize_copy" title="Link to this method"> <span class="method-callseq"> dup → shallow_copy </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="initialize_copy-source"> <pre class="c" data-language="c">static VALUE
strscan_init_copy(VALUE vself, VALUE vorig)
{
    struct strscanner *self, *orig;

    self = check_strscan(vself);
    orig = check_strscan(vorig);
    if (self != orig) {
        self-&gt;flags = orig-&gt;flags;
        self-&gt;str = orig-&gt;str;
        self-&gt;prev = orig-&gt;prev;
        self-&gt;curr = orig-&gt;curr;
        if (rb_reg_region_copy(&amp;self-&gt;regs, &amp;orig-&gt;regs))
            rb_memerror();
        RB_GC_GUARD(vorig);
    }

    return vself;
}</pre> </div>  <p>Returns a shallow copy of <code>self</code>; the <a href="stringscanner.html#class-StringScanner-label-Stored+String">stored string</a> in the copy is the same string as in <code>self</code>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-scan_base10_integer"> <a href="#method-i-scan_base10_integer" title="Link to this method"> <span class="method-name">scan_base10_integer</span> <span class="method-args">()</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="scan_base10_integer-source"> <pre class="c" data-language="c">static VALUE
strscan_scan_base10_integer(VALUE self)
{
    char *ptr;
    long len = 0;
    struct strscanner *p;

    GET_SCANNER(self, p);
    CLEAR_MATCH_STATUS(p);

    strscan_must_ascii_compat(p-&gt;str);

    ptr = CURPTR(p);

    long remaining_len = S_RESTLEN(p);

    if (remaining_len &lt;= 0) {
        return Qnil;
    }

    if (ptr[len] == '-' || ptr[len] == '+') {
        len++;
    }

    if (!rb_isdigit(ptr[len])) {
        return Qnil;
    }

    MATCHED(p);
    p-&gt;prev = p-&gt;curr;

    while (len &lt; remaining_len &amp;&amp; rb_isdigit(ptr[len])) {
        len++;
    }

    return strscan_parse_integer(p, 10, len);
}</pre> </div>  </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-scan_base16_integer"> <a href="#method-i-scan_base16_integer" title="Link to this method"> <span class="method-name">scan_base16_integer</span> <span class="method-args">()</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="scan_base16_integer-source"> <pre class="c" data-language="c">static VALUE
strscan_scan_base16_integer(VALUE self)
{
    char *ptr;
    long len = 0;
    struct strscanner *p;

    GET_SCANNER(self, p);
    CLEAR_MATCH_STATUS(p);

    strscan_must_ascii_compat(p-&gt;str);

    ptr = CURPTR(p);

    long remaining_len = S_RESTLEN(p);

    if (remaining_len &lt;= 0) {
        return Qnil;
    }

    if (ptr[len] == '-' || ptr[len] == '+') {
        len++;
    }

    if ((remaining_len &gt;= (len + 2)) &amp;&amp; ptr[len] == '0' &amp;&amp; ptr[len + 1] == 'x') {
        len += 2;
    }

    if (len &gt;= remaining_len || !rb_isxdigit(ptr[len])) {
        return Qnil;
    }

    MATCHED(p);
    p-&gt;prev = p-&gt;curr;

    while (len &lt; remaining_len &amp;&amp; rb_isxdigit(ptr[len])) {
        len++;
    }

    return strscan_parse_integer(p, 16, len);
}</pre> </div>  </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core &copy; 1993&ndash;2024 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library &copy; contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>
