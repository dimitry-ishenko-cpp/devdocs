<h1 id="class-OptionParser" class="class"> class OptionParser </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent"><a href="object.html">Object</a></dd>
</dl> <section class="description"> <h2 id="class-OptionParser-label-OptionParser"><a href="optionparser.html"><code>OptionParser</code></a></h2> <h3 id="class-OptionParser-label-New+to+OptionParser-3F">New to <code>OptionParser</code>?</h3> <p>See the <a href="optparse/tutorial_rdoc.html">Tutorial</a>.</p> <h3 id="class-OptionParser-label-Introduction">Introduction</h3> <p><a href="optionparser.html"><code>OptionParser</code></a> is a class for command-line option analysis. It is much more advanced, yet also easier to use, than <a href="getoptlong.html"><code>GetoptLong</code></a>, and is a more Ruby-oriented solution.</p> <h3 id="class-OptionParser-label-Features">Features</h3> <ol>
<li> <p>The argument specification and the code to handle it are written in the same place.</p> </li>
<li> <p>It can output an option summary; you don’t need to maintain this string separately.</p> </li>
<li> <p>Optional and mandatory arguments are specified very gracefully.</p> </li>
<li> <p>Arguments can be automatically converted to a specified class.</p> </li>
<li> <p>Arguments can be restricted to a certain set.</p> </li>
</ol> <p>All of these features are demonstrated in the examples below. See <a href="optionparser.html#method-i-make_switch"><code>make_switch</code></a> for full documentation.</p> <h3 id="class-OptionParser-label-Minimal+example">Minimal example</h3> <pre class="ruby" data-language="ruby">require 'optparse'

options = {}
OptionParser.new do |parser|
  parser.banner = "Usage: example.rb [options]"

  parser.on("-v", "--[no-]verbose", "Run verbosely") do |v|
    options[:verbose] = v
  end
end.parse!

p options
p ARGV
</pre> <h3 id="class-OptionParser-label-Generating+Help">Generating Help</h3> <p><a href="optionparser.html"><code>OptionParser</code></a> can be used to automatically generate help for the commands you write:</p> <pre class="ruby" data-language="ruby">require 'optparse'

Options = Struct.new(:name)

class Parser
  def self.parse(options)
    args = Options.new("world")

    opt_parser = OptionParser.new do |parser|
      parser.banner = "Usage: example.rb [options]"

      parser.on("-nNAME", "--name=NAME", "Name to say hello to") do |n|
        args.name = n
      end

      parser.on("-h", "--help", "Prints this help") do
        puts parser
        exit
      end
    end

    opt_parser.parse!(options)
    return args
  end
end
options = Parser.parse %w[--help]

#=&gt;
   # Usage: example.rb [options]
   #     -n, --name=NAME                  Name to say hello to
   #     -h, --help                       Prints this help
</pre> <h3 id="class-OptionParser-label-Required+Arguments">Required Arguments</h3> <p>For options that require an argument, option specification strings may include an option name in all caps. If an option is used without the required argument, an exception will be raised.</p> <pre class="ruby" data-language="ruby">require 'optparse'

options = {}
OptionParser.new do |parser|
  parser.on("-r", "--require LIBRARY",
            "Require the LIBRARY before executing your script") do |lib|
    puts "You required #{lib}!"
  end
end.parse!
</pre> <p>Used:</p> <pre>$ ruby optparse-test.rb -r
optparse-test.rb:9:in `&lt;main&gt;': missing argument: -r (OptionParser::MissingArgument)
$ ruby optparse-test.rb -r my-library
You required my-library!</pre> <h3 id="class-OptionParser-label-Type+Coercion">Type Coercion</h3> <p><a href="optionparser.html"><code>OptionParser</code></a> supports the ability to coerce command line arguments into objects for us.</p> <p><a href="optionparser.html"><code>OptionParser</code></a> comes with a few ready-to-use kinds of type coercion. They are:</p> <ul>
<li> <p><a href="date.html"><code>Date</code></a> – Anything accepted by <code>Date.parse</code> (need to require <code>optparse/date</code>)</p> </li>
<li> <p><a href="datetime.html"><code>DateTime</code></a> – Anything accepted by <code>DateTime.parse</code> (need to require <code>optparse/date</code>)</p> </li>
<li> <p><a href="time.html"><code>Time</code></a> – Anything accepted by <code>Time.httpdate</code> or <code>Time.parse</code> (need to require <code>optparse/time</code>)</p> </li>
<li> <p><a href="uri.html"><code>URI</code></a> – Anything accepted by <code>URI.parse</code> (need to require <code>optparse/uri</code>)</p> </li>
<li> <p><a href="shellwords.html"><code>Shellwords</code></a> – Anything accepted by <code>Shellwords.shellwords</code> (need to require <code>optparse/shellwords</code>)</p> </li>
<li> <p><a href="string.html"><code>String</code></a> – Any non-empty string</p> </li>
<li> <p><a href="integer.html"><code>Integer</code></a> – Any integer. Will convert octal. (e.g. 124, -3, 040)</p> </li>
<li> <p><a href="float.html"><code>Float</code></a> – Any float. (e.g. 10, 3.14, -100E+13)</p> </li>
<li> <p><a href="numeric.html"><code>Numeric</code></a> – Any integer, float, or rational (1, 3.4, 1/3)</p> </li>
<li> <p><a href="optionparser.html#DecimalInteger"><code>DecimalInteger</code></a> – Like <code>Integer</code>, but no octal format.</p> </li>
<li> <p><a href="optionparser.html#OctalInteger"><code>OctalInteger</code></a> – Like <code>Integer</code>, but no decimal format.</p> </li>
<li> <p><a href="optionparser.html#DecimalNumeric"><code>DecimalNumeric</code></a> – Decimal integer or float.</p> </li>
<li> <p><a href="trueclass.html"><code>TrueClass</code></a> – Accepts ‘+, yes, true, -, no, false’ and defaults as <code>true</code></p> </li>
<li> <p><a href="falseclass.html"><code>FalseClass</code></a> – Same as <code>TrueClass</code>, but defaults to <code>false</code></p> </li>
<li> <p><a href="array.html"><code>Array</code></a> – Strings separated by ‘,’ (e.g. 1,2,3)</p> </li>
<li> <p><a href="regexp.html"><code>Regexp</code></a> – Regular expressions. Also includes options.</p> </li>
</ul> <p>We can also add our own coercions, which we will cover below.</p> <h4 id="class-OptionParser-label-Using+Built-in+Conversions">Using Built-in Conversions</h4> <p>As an example, the built-in <code>Time</code> conversion is used. The other built-in conversions behave in the same way. <a href="optionparser.html"><code>OptionParser</code></a> will attempt to parse the argument as a <code>Time</code>. If it succeeds, that time will be passed to the handler block. Otherwise, an exception will be raised.</p> <pre class="ruby" data-language="ruby">require 'optparse'
require 'optparse/time'
OptionParser.new do |parser|
  parser.on("-t", "--time [TIME]", Time, "Begin execution at given time") do |time|
    p time
  end
end.parse!
</pre> <p>Used:</p> <pre>$ ruby optparse-test.rb  -t nonsense
... invalid argument: -t nonsense (OptionParser::InvalidArgument)
$ ruby optparse-test.rb  -t 10-11-12
2010-11-12 00:00:00 -0500
$ ruby optparse-test.rb  -t 9:30
2014-08-13 09:30:00 -0400</pre> <h4 id="class-OptionParser-label-Creating+Custom+Conversions">Creating Custom Conversions</h4> <p>The <code>accept</code> method on <a href="optionparser.html"><code>OptionParser</code></a> may be used to create converters. It specifies which conversion block to call whenever a class is specified. The example below uses it to fetch a <code>User</code> object before the <code>on</code> handler receives it.</p> <pre class="ruby" data-language="ruby">require 'optparse'

User = Struct.new(:id, :name)

def find_user id
  not_found = -&gt;{ raise "No User Found for id #{id}" }
  [ User.new(1, "Sam"),
    User.new(2, "Gandalf") ].find(not_found) do |u|
    u.id == id
  end
end

op = OptionParser.new
op.accept(User) do |user_id|
  find_user user_id.to_i
end

op.on("--user ID", User) do |user|
  puts user
end

op.parse!
</pre> <p>Used:</p> <pre>$ ruby optparse-test.rb --user 1
#&lt;struct User id=1, name="Sam"&gt;
$ ruby optparse-test.rb --user 2
#&lt;struct User id=2, name="Gandalf"&gt;
$ ruby optparse-test.rb --user 3
optparse-test.rb:15:in `block in find_user': No User Found for id 3 (RuntimeError)</pre> <h3 id="class-OptionParser-label-Store+options+to+a+Hash">Store options to a <a href="hash.html"><code>Hash</code></a>
</h3> <p>The <code>into</code> option of <code>order</code>, <code>parse</code> and so on methods stores command line options into a <a href="hash.html"><code>Hash</code></a>.</p> <pre class="ruby" data-language="ruby">require 'optparse'

options = {}
OptionParser.new do |parser|
  parser.on('-a')
  parser.on('-b NUM', Integer)
  parser.on('-v', '--verbose')
end.parse!(into: options)

p options
</pre> <p>Used:</p> <pre>$ ruby optparse-test.rb -a
{:a=&gt;true}
$ ruby optparse-test.rb -a -v
{:a=&gt;true, :verbose=&gt;true}
$ ruby optparse-test.rb -a -b 100
{:a=&gt;true, :b=&gt;100}</pre> <h3 id="class-OptionParser-label-Complete+example">Complete example</h3> <p>The following example is a complete Ruby program. You can run it and see the effect of specifying various options. This is probably the best way to learn the features of <code>optparse</code>.</p> <pre class="ruby" data-language="ruby">require 'optparse'
require 'optparse/time'
require 'ostruct'
require 'pp'

class OptparseExample
  Version = '1.0.0'

  CODES = %w[iso-2022-jp shift_jis euc-jp utf8 binary]
  CODE_ALIASES = { "jis" =&gt; "iso-2022-jp", "sjis" =&gt; "shift_jis" }

  class ScriptOptions
    attr_accessor :library, :inplace, :encoding, :transfer_type,
                  :verbose, :extension, :delay, :time, :record_separator,
                  :list

    def initialize
      self.library = []
      self.inplace = false
      self.encoding = "utf8"
      self.transfer_type = :auto
      self.verbose = false
    end

    def define_options(parser)
      parser.banner = "Usage: example.rb [options]"
      parser.separator ""
      parser.separator "Specific options:"

      # add additional options
      perform_inplace_option(parser)
      delay_execution_option(parser)
      execute_at_time_option(parser)
      specify_record_separator_option(parser)
      list_example_option(parser)
      specify_encoding_option(parser)
      optional_option_argument_with_keyword_completion_option(parser)
      boolean_verbose_option(parser)

      parser.separator ""
      parser.separator "Common options:"
      # No argument, shows at tail.  This will print an options summary.
      # Try it and see!
      parser.on_tail("-h", "--help", "Show this message") do
        puts parser
        exit
      end
      # Another typical switch to print the version.
      parser.on_tail("--version", "Show version") do
        puts Version
        exit
      end
    end

    def perform_inplace_option(parser)
      # Specifies an optional option argument
      parser.on("-i", "--inplace [EXTENSION]",
                "Edit ARGV files in place",
                "(make backup if EXTENSION supplied)") do |ext|
        self.inplace = true
        self.extension = ext || ''
        self.extension.sub!(/\A\.?(?=.)/, ".")  # Ensure extension begins with dot.
      end
    end

    def delay_execution_option(parser)
      # Cast 'delay' argument to a Float.
      parser.on("--delay N", Float, "Delay N seconds before executing") do |n|
        self.delay = n
      end
    end

    def execute_at_time_option(parser)
      # Cast 'time' argument to a Time object.
      parser.on("-t", "--time [TIME]", Time, "Begin execution at given time") do |time|
        self.time = time
      end
    end

    def specify_record_separator_option(parser)
      # Cast to octal integer.
      parser.on("-F", "--irs [OCTAL]", OptionParser::OctalInteger,
                "Specify record separator (default \\0)") do |rs|
        self.record_separator = rs
      end
    end

    def list_example_option(parser)
      # List of arguments.
      parser.on("--list x,y,z", Array, "Example 'list' of arguments") do |list|
        self.list = list
      end
    end

    def specify_encoding_option(parser)
      # Keyword completion.  We are specifying a specific set of arguments (CODES
      # and CODE_ALIASES - notice the latter is a Hash), and the user may provide
      # the shortest unambiguous text.
      code_list = (CODE_ALIASES.keys + CODES).join(', ')
      parser.on("--code CODE", CODES, CODE_ALIASES, "Select encoding",
                "(#{code_list})") do |encoding|
        self.encoding = encoding
      end
    end

    def optional_option_argument_with_keyword_completion_option(parser)
      # Optional '--type' option argument with keyword completion.
      parser.on("--type [TYPE]", [:text, :binary, :auto],
                "Select transfer type (text, binary, auto)") do |t|
        self.transfer_type = t
      end
    end

    def boolean_verbose_option(parser)
      # Boolean switch.
      parser.on("-v", "--[no-]verbose", "Run verbosely") do |v|
        self.verbose = v
      end
    end
  end

  #
  # Return a structure describing the options.
  #
  def parse(args)
    # The options specified on the command line will be collected in
    # *options*.

    @options = ScriptOptions.new
    @args = OptionParser.new do |parser|
      @options.define_options(parser)
      parser.parse!(args)
    end
    @options
  end

  attr_reader :parser, :options
end  # class OptparseExample

example = OptparseExample.new
options = example.parse(ARGV)
pp options # example.options
pp ARGV
</pre> <h3 id="class-OptionParser-label-Shell+Completion">Shell <a href="optionparser/completion.html"><code>Completion</code></a>
</h3> <p>For modern shells (e.g. bash, zsh, etc.), you can use shell completion for command line options.</p> <h3 id="class-OptionParser-label-Further+documentation">Further documentation</h3> <p>The above examples, along with the accompanying <a href="optparse/tutorial_rdoc.html">Tutorial</a>, should be enough to learn how to use this class. If you have any questions, file a ticket at <a href="http://bugs.ruby-lang.org">bugs.ruby-lang.org</a>.</p> </section> <section id="5Buntitled-5D" class="documentation-section"> <section class="constants-list"> <header> <h3>Constants</h3> </header> <dl> <dt id="DecimalInteger">DecimalInteger </dt>
<dd>
<p>Decimal integer format, to be converted to <a href="integer.html"><code>Integer</code></a>.</p> </dd>
<dt id="DecimalNumeric">DecimalNumeric </dt>
<dd>
<p>Decimal integer/float number format, to be converted to <a href="integer.html"><code>Integer</code></a> for integer format, <a href="float.html"><code>Float</code></a> for float format.</p> </dd>
<dt id="OctalInteger">OctalInteger </dt>
<dd>
<p>Ruby/C like octal/hexadecimal/binary integer format, to be converted to <a href="integer.html"><code>Integer</code></a>.</p> </dd>
<dt id="Version">Version </dt>

</dl> </section> <section class="attribute-method-details"> <header> <h3>Attributes</h3> </header> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-banner"> <span class="method-name">banner</span><span class="attribute-access-type">[W]</span> </div> <div class="method-description"> <p>Heading banner preceding summary.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-default_argv"> <span class="method-name">default_argv</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>Strings to be parsed in default.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-program_name"> <span class="method-name">program_name</span><span class="attribute-access-type">[W]</span> </div> <div class="method-description"> <p>Program name to be emitted in error message and default banner, defaults to $0.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-raise_unknown"> <span class="method-name">raise_unknown</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>Whether to raise at unknown option.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-release"> <span class="method-name">release</span><span class="attribute-access-type">[W]</span> </div> <div class="method-description"> <p>Release code</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-require_exact"> <span class="method-name">require_exact</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>Whether to require that options match exactly (disallows providing abbreviated long option as short option).</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-set_banner"> <span class="method-name">set_banner</span><span class="attribute-access-type">[W]</span> </div> <div class="method-description"> <p>Heading banner preceding summary.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-set_program_name"> <span class="method-name">set_program_name</span><span class="attribute-access-type">[W]</span> </div> <div class="method-description"> <p>Program name to be emitted in error message and default banner, defaults to $0.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-set_summary_indent"> <span class="method-name">set_summary_indent</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>Indentation for summary. Must be <a href="string.html"><code>String</code></a> (or have + <a href="string.html"><code>String</code></a> method).</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-set_summary_width"> <span class="method-name">set_summary_width</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>Width for option list portion of summary. Must be <a href="numeric.html"><code>Numeric</code></a>.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-summary_indent"> <span class="method-name">summary_indent</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>Indentation for summary. Must be <a href="string.html"><code>String</code></a> (or have + <a href="string.html"><code>String</code></a> method).</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-summary_width"> <span class="method-name">summary_width</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>Width for option list portion of summary. Must be <a href="numeric.html"><code>Numeric</code></a>.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-version"> <span class="method-name">version</span><span class="attribute-access-type">[W]</span> </div> <div class="method-description"> <p><a href="optionparser.html#Version"><code>Version</code></a></p> </div> </div> </section> <section id="public-class-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-accept"> <span class="method-name">accept</span><span class="method-args">(*args, &amp;blk)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="accept-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1190
def self.accept(*args, &amp;blk) top.accept(*args, &amp;blk) end</pre> </div> <p>See <a href="optionparser.html#method-i-accept"><code>accept</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-each_const"> <span class="method-name">each_const</span><span class="method-args">(path, base = ::Object)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="each_const-source"> <pre class="ruby" data-language="ruby"># File lib/optparse/version.rb, line 50
def each_const(path, base = ::Object)
  path.split(/::|\//).inject(base) do |klass, name|
    raise NameError, path unless Module === klass
    klass.constants.grep(/#{name}/i) do |c|
      klass.const_defined?(c) or next
      klass.const_get(c)
    end
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-getopts"> <span class="method-name">getopts</span><span class="method-args">(*args, symbolize_names: false)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="getopts-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1822
def self.getopts(*args, symbolize_names: false)
  new.getopts(*args, symbolize_names: symbolize_names)
end</pre> </div> <p>See <a href="optionparser.html#method-i-getopts"><code>getopts</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-inc"> <span class="method-name">inc</span><span class="method-args">(arg, default = nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="inc-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1124
def self.inc(arg, default = nil)
  case arg
  when Integer
    arg.nonzero?
  when nil
    default.to_i + 1
  end
end</pre> </div> <p>Returns an incremented value of <code>default</code> according to <code>arg</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-new"> <span class="method-name">new</span><span class="method-args">(banner = nil, width = 32, indent = ' ' * 4) { |self| ... }</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="new-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1143
def initialize(banner = nil, width = 32, indent = ' ' * 4)
  @stack = [DefaultList, List.new, List.new]
  @program_name = nil
  @banner = banner
  @summary_width = width
  @summary_indent = indent
  @default_argv = ARGV
  @require_exact = false
  @raise_unknown = true
  add_officious
  yield self if block_given?
end</pre> </div> <p>Initializes the instance and yields itself if called with a block.</p> <dl class="rdoc-list note-list">
<dt>
<code>banner</code> </dt>
<dd> <p>Banner message.</p> </dd>
<dt>
<code>width</code> </dt>
<dd> <p>Summary width.</p> </dd>
<dt>
<code>indent</code> </dt>
<dd> <p>Summary indent.</p> </dd>
</dl>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-reject"> <span class="method-name">reject</span><span class="method-args">(*args, &amp;blk)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="reject-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1203
def self.reject(*args, &amp;blk) top.reject(*args, &amp;blk) end</pre> </div> <p>See <a href="optionparser.html#method-i-reject"><code>reject</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-search_const"> <span class="method-name">search_const</span><span class="method-args">(klass, name) { |klass, cname, const| ... }</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="search_const-source"> <pre class="ruby" data-language="ruby"># File lib/optparse/version.rb, line 60
def search_const(klass, name)
  klasses = [klass]
  while klass = klasses.shift
    klass.constants.each do |cname|
      klass.const_defined?(cname) or next
      const = klass.const_get(cname)
      yield klass, cname, const if name === cname
      klasses &lt;&lt; const if Module === const and const != ::Object
    end
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-show_version"> <span class="method-name">show_version</span><span class="method-args">(*pkgs)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="show_version-source"> <pre class="ruby" data-language="ruby"># File lib/optparse/version.rb, line 5
def show_version(*pkgs)
  progname = ARGV.options.program_name
  result = false
  show = proc do |klass, cname, version|
    str = "#{progname}"
    unless klass == ::Object and cname == :VERSION
      version = version.join(".") if Array === version
      str &lt;&lt; ": #{klass}" unless klass == Object
      str &lt;&lt; " version #{version}"
    end
    [:Release, :RELEASE].find do |rel|
      if klass.const_defined?(rel)
        str &lt;&lt; " (#{klass.const_get(rel)})"
      end
    end
    puts str
    result = true
  end
  if pkgs.size == 1 and pkgs[0] == "all"
    self.search_const(::Object, /\AV(?:ERSION|ersion)\z/) do |klass, cname, version|
      unless cname[1] == ?e and klass.const_defined?(:Version)
        show.call(klass, cname.intern, version)
      end
    end
  else
    pkgs.each do |pkg|
      begin
        pkg = pkg.split(/::|\//).inject(::Object) {|m, c| m.const_get(c)}
        v = case
            when pkg.const_defined?(:Version)
              pkg.const_get(n = :Version)
            when pkg.const_defined?(:VERSION)
              pkg.const_get(n = :VERSION)
            else
              n = nil
              "unknown"
            end
        show.call(pkg, n, v)
      rescue NameError
      end
    end
  end
  result
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-terminate"> <span class="method-name">terminate</span><span class="method-args">(arg = nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="terminate-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1170
def self.terminate(arg = nil)
  throw :terminate, arg
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-top"> <span class="method-name">top</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="top-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1175
def self.top() DefaultList end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-with"> <span class="method-name">with</span><span class="method-args">(*args, &amp;block)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="with-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1115
def self.with(*args, &amp;block)
  opts = new(*args)
  opts.instance_eval(&amp;block)
  opts
end</pre> </div> <p>Initializes a new instance and evaluates the optional block in context of the instance. Arguments <code>args</code> are passed to <a href="optionparser.html#method-i-new"><code>new</code></a>, see there for description of parameters.</p> <p>This method is <strong>deprecated</strong>, its behavior corresponds to the older <a href="optionparser.html#method-i-new"><code>new</code></a> method.</p>  </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-abort"> <span class="method-name">abort</span><span class="method-args">(mesg = $!)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="abort-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1291
def abort(mesg = $!)
  super("#{program_name}: #{mesg}")
end</pre> </div> <div class="method-calls-super"> Calls superclass method <a href="kernel.html#method-i-abort"><code>Kernel#abort</code></a> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-accept"> <span class="method-name">accept</span><span class="method-args">(*args, &amp;blk)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="accept-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1186
def accept(*args, &amp;blk) top.accept(*args, &amp;blk) end</pre> </div> <p>Directs to accept specified class <code>t</code>. The argument string is passed to the block in which it should be converted to the desired class.</p> <dl class="rdoc-list note-list">
<dt>
<code>t</code> </dt>
<dd> <p>Argument class specifier, any object including <a href="class.html"><code>Class</code></a>.</p> </dd>
<dt>
<code>pat</code> </dt>
<dd> <p>Pattern for argument, defaults to <code>t</code> if it responds to match.</p> </dd>
</dl> <pre class="ruby" data-language="ruby">accept(t, pat, &amp;block)
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-additional_message"> <span class="method-name">additional_message</span><span class="method-args">(typ, opt)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="additional_message-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1873
def additional_message(typ, opt)
  return unless typ and opt and defined?(DidYouMean::SpellChecker)
  all_candidates = []
  visit(:get_candidates, typ) do |candidates|
    all_candidates.concat(candidates)
  end
  all_candidates.select! {|cand| cand.is_a?(String) }
  checker = DidYouMean::SpellChecker.new(dictionary: all_candidates)
  DidYouMean.formatter.message_for(all_candidates &amp; checker.correct(opt))
end</pre> </div> <p>Returns additional info.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-banner"> <span class="method-name">banner</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="banner-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1235
def banner
  unless @banner
    @banner = +"Usage: #{program_name} [options]"
    visit(:add_banner, @banner)
  end
  @banner
end</pre> </div> <p>Heading banner preceding summary.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-base"> <span class="method-name">base</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="base-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1305
def base
  @stack[1]
end</pre> </div> <p>Subject of <a href="optionparser.html#method-i-on_tail"><code>on_tail</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-candidate"> <span class="method-name">candidate</span><span class="method-args">(word)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="candidate-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1884
def candidate(word)
  list = []
  case word
  when '-'
    long = short = true
  when /\A--/
    word, arg = word.split(/=/, 2)
    argpat = Completion.regexp(arg, false) if arg and !arg.empty?
    long = true
  when /\A-/
    short = true
  end
  pat = Completion.regexp(word, long)
  visit(:each_option) do |opt|
    next unless Switch === opt
    opts = (long ? opt.long : []) + (short ? opt.short : [])
    opts = Completion.candidate(word, true, pat, &amp;opts.method(:each)).map(&amp;:first) if pat
    if /\A=/ =~ opt.arg
      opts.map! {|sw| sw + "="}
      if arg and CompletingHash === opt.pattern
        if opts = opt.pattern.candidate(arg, false, argpat)
          opts.map!(&amp;:last)
        end
      end
    end
    list.concat(opts)
  end
  list
end</pre> </div>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-def_head_option"> <span class="method-name">def_head_option</span> </div> </div> <div class="aliases"> Alias for: <a href="optionparser.html#method-i-define_head">define_head</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-def_option"> <span class="method-name">def_option</span> </div> </div> <div class="aliases"> Alias for: <a href="optionparser.html#method-i-define">define</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-def_tail_option"> <span class="method-name">def_tail_option</span> </div> </div> <div class="aliases"> Alias for: <a href="optionparser.html#method-i-define_tail">define_tail</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-define"> <span class="method-callseq"> define(*params, &amp;block) </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="define-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1540
def define(*opts, &amp;block)
  top.append(*(sw = make_switch(opts, block)))
  sw[0]
end</pre> </div> <p>Creates an option from the given parameters <code>params</code>. See <a href="optparse/option_params_rdoc.html">Parameters for New Options</a>.</p> <p>The block, if given, is the handler for the created option. When the option is encountered during command-line parsing, the block is called with the argument given for the option, if any. See <a href="optparse/option_params_rdoc.html#label-Option+Handlers">Option Handlers</a>.</p>  </div> <div class="aliases"> Also aliased as: <a href="optionparser.html#method-i-def_option">def_option</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-define_by_keywords"> <span class="method-callseq"> define_by_keywords(options, method, **params) </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="define_by_keywords-source"> <pre class="ruby" data-language="ruby"># File lib/optparse/kwargs.rb, line 10
def define_by_keywords(options, meth, **opts)
  meth.parameters.each do |type, name|
    case type
    when :key, :keyreq
      op, cl = *(type == :key ? %w"[ ]" : ["", ""])
      define("--#{name}=#{op}#{name.upcase}#{cl}", *opts[name]) do |o|
        options[name] = o
      end
    end
  end
  options
end</pre> </div> <p>Creates an option from the given parameters <code>params</code>. See <a href="optparse/option_params_rdoc.html">Parameters for New Options</a>.</p> <p>The block, if given, is the handler for the created option. When the option is encountered during command-line parsing, the block is called with the argument given for the option, if any. See <a href="optparse/option_params_rdoc.html#label-Option+Handlers">Option Handlers</a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-define_head"> <span class="method-callseq"> define_head(*params, &amp;block) </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="define_head-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1561
def define_head(*opts, &amp;block)
  top.prepend(*(sw = make_switch(opts, block)))
  sw[0]
end</pre> </div> <p>Creates an option from the given parameters <code>params</code>. See <a href="optparse/option_params_rdoc.html">Parameters for New Options</a>.</p> <p>The block, if given, is the handler for the created option. When the option is encountered during command-line parsing, the block is called with the argument given for the option, if any. See <a href="optparse/option_params_rdoc.html#label-Option+Handlers">Option Handlers</a>.</p>  </div> <div class="aliases"> Also aliased as: <a href="optionparser.html#method-i-def_head_option">def_head_option</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-define_tail"> <span class="method-callseq"> define_tail(*params, &amp;block) </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="define_tail-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1584
def define_tail(*opts, &amp;block)
  base.append(*(sw = make_switch(opts, block)))
  sw[0]
end</pre> </div> <p>Creates an option from the given parameters <code>params</code>. See <a href="optparse/option_params_rdoc.html">Parameters for New Options</a>.</p> <p>The block, if given, is the handler for the created option. When the option is encountered during command-line parsing, the block is called with the argument given for the option, if any. See <a href="optparse/option_params_rdoc.html#label-Option+Handlers">Option Handlers</a>.</p>  </div> <div class="aliases"> Also aliased as: <a href="optionparser.html#method-i-def_tail_option">def_tail_option</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-environment"> <span class="method-name">environment</span><span class="method-args">(env = File.basename($0, '.*'))</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="environment-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1957
def environment(env = File.basename($0, '.*'))
  env = ENV[env] || ENV[env.upcase] or return
  require 'shellwords'
  parse(*Shellwords.shellwords(env))
end</pre> </div> <p>Parses environment variable <code>env</code> or its uppercase with splitting like a shell.</p> <p><code>env</code> defaults to the basename of the program.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-getopts"> <span class="method-name">getopts</span><span class="method-args">(*args, symbolize_names: false)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="getopts-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1787
def getopts(*args, symbolize_names: false)
  argv = Array === args.first ? args.shift : default_argv
  single_options, *long_options = *args

  result = {}

  single_options.scan(/(.)(:)?/) do |opt, val|
    if val
      result[opt] = nil
      define("-#{opt} VAL")
    else
      result[opt] = false
      define("-#{opt}")
    end
  end if single_options

  long_options.each do |arg|
    arg, desc = arg.split(';', 2)
    opt, val = arg.split(':', 2)
    if val
      result[opt] = val.empty? ? nil : val
      define("--#{opt}=#{result[opt] || "VAL"}", *[desc].compact)
    else
      result[opt] = false
      define("--#{opt}", *[desc].compact)
    end
  end

  parse_in_order(argv, result.method(:[]=))
  symbolize_names ? result.transform_keys(&amp;:to_sym) : result
end</pre> </div> <p>Wrapper method for getopts.rb.</p> <pre class="ruby" data-language="ruby">params = ARGV.getopts("ab:", "foo", "bar:", "zot:Z;zot option")
# params["a"] = true   # -a
# params["b"] = "1"    # -b1
# params["foo"] = "1"  # --foo
# params["bar"] = "x"  # --bar x
# params["zot"] = "z"  # --zot Z
</pre> <p>Option <code>symbolize_names</code> (boolean) specifies whether returned <a href="hash.html"><code>Hash</code></a> keys should be Symbols; defaults to <code>false</code> (use Strings).</p> <pre class="ruby" data-language="ruby">params = ARGV.getopts("ab:", "foo", "bar:", "zot:Z;zot option", symbolize_names: true)
# params[:a] = true   # -a
# params[:b] = "1"    # -b1
# params[:foo] = "1"  # --foo
# params[:bar] = "x"  # --bar x
# params[:zot] = "z"  # --zot Z
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-help"> <span class="method-name">help</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="help-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1347
def help; summarize("#{banner}".sub(/\n?\z/, "\n")) end</pre> </div> <p>Returns option summary string.</p>  </div> <div class="aliases"> Also aliased as: <a href="optionparser.html#method-i-to_s">to_s</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-inc"> <span class="method-name">inc</span><span class="method-args">(*args)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="inc-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1132
def inc(*args)
  self.class.inc(*args)
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-load"> <span class="method-name">load</span><span class="method-args">(filename = nil, into: nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="load-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1925
def load(filename = nil, into: nil)
  unless filename
    basename = File.basename($0, '.*')
    return true if load(File.expand_path(basename, '~/.options'), into: into) rescue nil
    basename &lt;&lt; ".options"
    return [
      # XDG
      ENV['XDG_CONFIG_HOME'],
      '~/.config',
      *ENV['XDG_CONFIG_DIRS']&amp;.split(File::PATH_SEPARATOR),

      # Haiku
      '~/config/settings',
    ].any? {|dir|
      next if !dir or dir.empty?
      load(File.expand_path(basename, dir), into: into) rescue nil
    }
  end
  begin
    parse(*File.readlines(filename, chomp: true), into: into)
    true
  rescue Errno::ENOENT, Errno::ENOTDIR
    false
  end
end</pre> </div> <p>Loads options from file names as <code>filename</code>. Does nothing when the file is not present. Returns whether successfully loaded.</p> <p><code>filename</code> defaults to basename of the program without suffix in a directory ~/.options, then the basename with ‘.options’ suffix under XDG and Haiku standard places.</p> <p>The optional <code>into</code> keyword argument works exactly like that accepted in method <a href="optionparser.html#method-i-parse"><code>parse</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-make_switch"> <span class="method-callseq"> make_switch(params, block = nil) </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="make_switch-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1402
def make_switch(opts, block = nil)
  short, long, nolong, style, pattern, conv, not_pattern, not_conv, not_style = [], [], []
  ldesc, sdesc, desc, arg = [], [], []
  default_style = Switch::NoArgument
  default_pattern = nil
  klass = nil
  q, a = nil
  has_arg = false

  opts.each do |o|
    # argument class
    next if search(:atype, o) do |pat, c|
      klass = notwice(o, klass, 'type')
      if not_style and not_style != Switch::NoArgument
        not_pattern, not_conv = pat, c
      else
        default_pattern, conv = pat, c
      end
    end

    # directly specified pattern(any object possible to match)
    if (!(String === o || Symbol === o)) and o.respond_to?(:match)
      pattern = notwice(o, pattern, 'pattern')
      if pattern.respond_to?(:convert)
        conv = pattern.method(:convert).to_proc
      else
        conv = SPLAT_PROC
      end
      next
    end

    # anything others
    case o
    when Proc, Method
      block = notwice(o, block, 'block')
    when Array, Hash
      case pattern
      when CompletingHash
      when nil
        pattern = CompletingHash.new
        conv = pattern.method(:convert).to_proc if pattern.respond_to?(:convert)
      else
        raise ArgumentError, "argument pattern given twice"
      end
      o.each {|pat, *v| pattern[pat] = v.fetch(0) {pat}}
    when Module
      raise ArgumentError, "unsupported argument type: #{o}", ParseError.filter_backtrace(caller(4))
    when *ArgumentStyle.keys
      style = notwice(ArgumentStyle[o], style, 'style')
    when /^--no-([^\[\]=\s]*)(.+)?/
      q, a = $1, $2
      o = notwice(a ? Object : TrueClass, klass, 'type')
      not_pattern, not_conv = search(:atype, o) unless not_style
      not_style = (not_style || default_style).guess(arg = a) if a
      default_style = Switch::NoArgument
      default_pattern, conv = search(:atype, FalseClass) unless default_pattern
      ldesc &lt;&lt; "--no-#{q}"
      (q = q.downcase).tr!('_', '-')
      long &lt;&lt; "no-#{q}"
      nolong &lt;&lt; q
    when /^--\[no-\]([^\[\]=\s]*)(.+)?/
      q, a = $1, $2
      o = notwice(a ? Object : TrueClass, klass, 'type')
      if a
        default_style = default_style.guess(arg = a)
        default_pattern, conv = search(:atype, o) unless default_pattern
      end
      ldesc &lt;&lt; "--[no-]#{q}"
      (o = q.downcase).tr!('_', '-')
      long &lt;&lt; o
      not_pattern, not_conv = search(:atype, FalseClass) unless not_style
      not_style = Switch::NoArgument
      nolong &lt;&lt; "no-#{o}"
    when /^--([^\[\]=\s]*)(.+)?/
      q, a = $1, $2
      if a
        o = notwice(NilClass, klass, 'type')
        default_style = default_style.guess(arg = a)
        default_pattern, conv = search(:atype, o) unless default_pattern
      end
      ldesc &lt;&lt; "--#{q}"
      (o = q.downcase).tr!('_', '-')
      long &lt;&lt; o
    when /^-(\[\^?\]?(?:[^\\\]]|\\.)*\])(.+)?/
      q, a = $1, $2
      o = notwice(Object, klass, 'type')
      if a
        default_style = default_style.guess(arg = a)
        default_pattern, conv = search(:atype, o) unless default_pattern
      else
        has_arg = true
      end
      sdesc &lt;&lt; "-#{q}"
      short &lt;&lt; Regexp.new(q)
    when /^-(.)(.+)?/
      q, a = $1, $2
      if a
        o = notwice(NilClass, klass, 'type')
        default_style = default_style.guess(arg = a)
        default_pattern, conv = search(:atype, o) unless default_pattern
      end
      sdesc &lt;&lt; "-#{q}"
      short &lt;&lt; q
    when /^=/
      style = notwice(default_style.guess(arg = o), style, 'style')
      default_pattern, conv = search(:atype, Object) unless default_pattern
    else
      desc.push(o) if o &amp;&amp; !o.empty?
    end
  end

  default_pattern, conv = search(:atype, default_style.pattern) unless default_pattern
  if !(short.empty? and long.empty?)
    if has_arg and default_style == Switch::NoArgument
      default_style = Switch::RequiredArgument
    end
    s = (style || default_style).new(pattern || default_pattern,
                                     conv, sdesc, ldesc, arg, desc, block)
  elsif !block
    if style or pattern
      raise ArgumentError, "no switch given", ParseError.filter_backtrace(caller)
    end
    s = desc
  else
    short &lt;&lt; pattern
    s = (style || default_style).new(pattern,
                                     conv, nil, nil, arg, desc, block)
  end
  return s, short, long,
    (not_style.new(not_pattern, not_conv, sdesc, ldesc, nil, desc, block) if not_style),
    nolong
end</pre> </div> <p>Creates an option from the given parameters <code>params</code>. See <a href="optparse/option_params_rdoc.html">Parameters for New Options</a>.</p> <p>The block, if given, is the handler for the created option. When the option is encountered during command-line parsing, the block is called with the argument given for the option, if any. See <a href="optparse/option_params_rdoc.html#label-Option+Handlers">Option Handlers</a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-new"> <span class="method-name">new</span><span class="method-args">() { |self| ... }</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="new-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1312
def new
  @stack.push(List.new)
  if block_given?
    yield self
  else
    self
  end
end</pre> </div> <p>Pushes a new <a href="optionparser/list.html"><code>List</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-on"> <span class="method-callseq"> on(*params, &amp;block) </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="on-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1550
def on(*opts, &amp;block)
  define(*opts, &amp;block)
  self
end</pre> </div> <p>Creates an option from the given parameters <code>params</code>. See <a href="optparse/option_params_rdoc.html">Parameters for New Options</a>.</p> <p>The block, if given, is the handler for the created option. When the option is encountered during command-line parsing, the block is called with the argument given for the option, if any. See <a href="optparse/option_params_rdoc.html#label-Option+Handlers">Option Handlers</a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-on_head"> <span class="method-callseq"> on_head(*params, &amp;block) </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="on_head-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1573
def on_head(*opts, &amp;block)
  define_head(*opts, &amp;block)
  self
end</pre> </div> <p>Creates an option from the given parameters <code>params</code>. See <a href="optparse/option_params_rdoc.html">Parameters for New Options</a>.</p> <p>The block, if given, is the handler for the created option. When the option is encountered during command-line parsing, the block is called with the argument given for the option, if any. See <a href="optparse/option_params_rdoc.html#label-Option+Handlers">Option Handlers</a>.</p> <p>The new option is added at the head of the summary.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-on_tail"> <span class="method-callseq"> on_tail(*params, &amp;block) </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="on_tail-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1597
def on_tail(*opts, &amp;block)
  define_tail(*opts, &amp;block)
  self
end</pre> </div> <p>Creates an option from the given parameters <code>params</code>. See <a href="optparse/option_params_rdoc.html">Parameters for New Options</a>.</p> <p>The block, if given, is the handler for the created option. When the option is encountered during command-line parsing, the block is called with the argument given for the option, if any. See <a href="optparse/option_params_rdoc.html#label-Option+Handlers">Option Handlers</a>.</p> <p>The new option is added at the tail of the summary.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-order"> <span class="method-name">order</span><span class="method-args">(*argv, into: nil, &amp;nonopt)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="order-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1619
def order(*argv, into: nil, &amp;nonopt)
  argv = argv[0].dup if argv.size == 1 and Array === argv[0]
  order!(argv, into: into, &amp;nonopt)
end</pre> </div> <p>Parses command line arguments <code>argv</code> in order. When a block is given, each non-option argument is yielded. When optional <code>into</code> keyword argument is provided, the parsed option values are stored there via <code>[]=</code> method (so it can be <a href="hash.html"><code>Hash</code></a>, or <a href="openstruct.html"><code>OpenStruct</code></a>, or other similar object).</p> <p>Returns the rest of <code>argv</code> left unparsed.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-order-21"> <span class="method-name">order!</span><span class="method-args">(argv = default_argv, into: nil, &amp;nonopt)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="order-21-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1628
def order!(argv = default_argv, into: nil, &amp;nonopt)
  setter = -&gt;(name, val) {into[name.to_sym] = val} if into
  parse_in_order(argv, setter, &amp;nonopt)
end</pre> </div> <p>Same as <a href="optionparser.html#method-i-order"><code>order</code></a>, but removes switches destructively. Non-option arguments remain in <code>argv</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-parse"> <span class="method-name">parse</span><span class="method-args">(*argv, into: nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="parse-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1751
def parse(*argv, into: nil)
  argv = argv[0].dup if argv.size == 1 and Array === argv[0]
  parse!(argv, into: into)
end</pre> </div> <p>Parses command line arguments <code>argv</code> in order when environment variable POSIXLY_CORRECT is set, and in permutation mode otherwise. When optional <code>into</code> keyword argument is provided, the parsed option values are stored there via <code>[]=</code> method (so it can be <a href="hash.html"><code>Hash</code></a>, or <a href="openstruct.html"><code>OpenStruct</code></a>, or other similar object).</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-parse-21"> <span class="method-name">parse!</span><span class="method-args">(argv = default_argv, into: nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="parse-21-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1760
def parse!(argv = default_argv, into: nil)
  if ENV.include?('POSIXLY_CORRECT')
    order!(argv, into: into)
  else
    permute!(argv, into: into)
  end
end</pre> </div> <p>Same as <a href="optionparser.html#method-i-parse"><code>parse</code></a>, but removes switches destructively. Non-option arguments remain in <code>argv</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-permute"> <span class="method-name">permute</span><span class="method-args">(*argv, into: nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="permute-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1728
def permute(*argv, into: nil)
  argv = argv[0].dup if argv.size == 1 and Array === argv[0]
  permute!(argv, into: into)
end</pre> </div> <p>Parses command line arguments <code>argv</code> in permutation mode and returns list of non-option arguments. When optional <code>into</code> keyword argument is provided, the parsed option values are stored there via <code>[]=</code> method (so it can be <a href="hash.html"><code>Hash</code></a>, or <a href="openstruct.html"><code>OpenStruct</code></a>, or other similar object).</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-permute-21"> <span class="method-name">permute!</span><span class="method-args">(argv = default_argv, into: nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="permute-21-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1737
def permute!(argv = default_argv, into: nil)
  nonopts = []
  order!(argv, into: into, &amp;nonopts.method(:&lt;&lt;))
  argv[0, 0] = nonopts
  argv
end</pre> </div> <p>Same as <a href="optionparser.html#method-i-permute"><code>permute</code></a>, but removes switches destructively. Non-option arguments remain in <code>argv</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-program_name"> <span class="method-name">program_name</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="program_name-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1247
def program_name
  @program_name || File.basename($0, '.*')
end</pre> </div> <p>Program name to be emitted in error message and default banner, defaults to $0.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-reject"> <span class="method-name">reject</span><span class="method-args">(*args, &amp;blk)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="reject-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1199
def reject(*args, &amp;blk) top.reject(*args, &amp;blk) end</pre> </div> <p>Directs to reject specified class argument.</p> <dl class="rdoc-list note-list">
<dt>
<code>t</code> </dt>
<dd> <p>Argument class specifier, any object including <a href="class.html"><code>Class</code></a>.</p> </dd>
</dl> <pre class="ruby" data-language="ruby">reject(t)
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-release"> <span class="method-name">release</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="release-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1272
def release
  (defined?(@release) &amp;&amp; @release) || (defined?(::Release) &amp;&amp; ::Release) || (defined?(::RELEASE) &amp;&amp; ::RELEASE)
end</pre> </div> <p>Release code</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-remove"> <span class="method-name">remove</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="remove-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1324
def remove
  @stack.pop
end</pre> </div> <p>Removes the last <a href="optionparser/list.html"><code>List</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-separator"> <span class="method-name">separator</span><span class="method-args">(string)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="separator-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1606
def separator(string)
  top.append(string, nil, nil)
end</pre> </div> <p>Add separator in summary.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-summarize"> <span class="method-name">summarize</span><span class="method-args">(to = [], width = @summary_width, max = width - 1, indent = @summary_indent, &amp;blk)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="summarize-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1337
def summarize(to = [], width = @summary_width, max = width - 1, indent = @summary_indent, &amp;blk)
  nl = "\n"
  blk ||= proc {|l| to &lt;&lt; (l.index(nl, -1) ? l : l + nl)}
  visit(:summarize, {}, {}, width, max, indent, &amp;blk)
  to
end</pre> </div> <p>Puts option summary into <code>to</code> and returns <code>to</code>. Yields each line if a block is given.</p> <dl class="rdoc-list note-list">
<dt>
<code>to</code> </dt>
<dd> <p>Output destination, which must have method &lt;&lt;. Defaults to [].</p> </dd>
<dt>
<code>width</code> </dt>
<dd> <p>Width of left side, defaults to @summary_width.</p> </dd>
<dt>
<code>max</code> </dt>
<dd> <p>Maximum length allowed for left side, defaults to <code>width</code> - 1.</p> </dd>
<dt>
<code>indent</code> </dt>
<dd> <p>Indentation, defaults to @summary_indent.</p> </dd>
</dl>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-terminate"> <span class="method-name">terminate</span><span class="method-args">(arg = nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="terminate-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1167
def terminate(arg = nil)
  self.class.terminate(arg)
end</pre> </div> <p>Terminates option parsing. Optional parameter <code>arg</code> is a string pushed back to be the first non-option argument.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-to_a"> <span class="method-name">to_a</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="to_a-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1376
def to_a; summarize("#{banner}".split(/^/)) end</pre> </div> <p>Returns option summary list.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-to_s"> <span class="method-name">to_s</span><span class="method-args">()</span> </div> </div>  <div class="aliases"> Alias for: <a href="optionparser.html#method-i-help">help</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-top"> <span class="method-name">top</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="top-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1298
def top
  @stack[-1]
end</pre> </div> <p>Subject of <a href="optionparser.html#method-i-on"><code>on</code></a> / <a href="optionparser.html#method-i-on_head"><code>on_head</code></a>, <a href="optionparser.html#method-i-accept"><code>accept</code></a> / <a href="optionparser.html#method-i-reject"><code>reject</code></a></p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-ver"> <span class="method-name">ver</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="ver-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1279
def ver
  if v = version
    str = +"#{program_name} #{[v].join('.')}"
    str &lt;&lt; " (#{v})" if v = release
    str
  end
end</pre> </div> <p>Returns version string from <a href="optionparser.html#method-i-program_name"><code>program_name</code></a>, version and release.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-version"> <span class="method-name">version</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="version-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1265
def version
  (defined?(@version) &amp;&amp; @version) || (defined?(::Version) &amp;&amp; ::Version)
end</pre> </div> <p><a href="optionparser.html#Version"><code>Version</code></a></p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-warn"> <span class="method-name">warn</span><span class="method-args">(mesg = $!)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="warn-source"> <pre class="ruby" data-language="ruby"># File lib/optparse.rb, line 1287
def warn(mesg = $!)
  super("#{program_name}: #{mesg}")
end</pre> </div> <div class="method-calls-super"> Calls superclass method <a href="kernel.html#method-i-warn"><code>Kernel#warn</code></a> </div>  </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core &copy; 1993&ndash;2022 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library &copy; contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>
