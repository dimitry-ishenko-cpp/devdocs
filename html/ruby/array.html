<h1 id="class-Array" class="anchor-link class"> class Array </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent"><a href="object.html">Object</a></dd>
<dt>Included modules:</dt>
<dd class="meta-includes"><a class="include" href="enumerable.html">Enumerable</a></dd>
</dl> <section class="description"> <p>An Array object is an ordered, integer-indexed collection of objects, called <em>elements</em>; the object represents an <a href="https://en.wikipedia.org/wiki/Array_(data_structure)">array data structure</a>.</p> <p>An element may be any object (even another array); elements may be any mixture of objects of different types.</p> <p>Important data structures that use arrays include:</p> <ul>
<li> <p><a href="https://en.wikipedia.org/wiki/Coordinate_vector">Coordinate vector</a>.</p> </li>
<li> <p><a href="https://en.wikipedia.org/wiki/Matrix_(mathematics)">Matrix</a>.</p> </li>
<li> <p><a href="https://en.wikipedia.org/wiki/Heap_(data_structure)">Heap</a>.</p> </li>
<li> <p><a href="https://en.wikipedia.org/wiki/Hash_table">Hash table</a>.</p> </li>
<li> <p><a href="https://en.wikipedia.org/wiki/Double-ended_queue">Deque (double-ended queue)</a>.</p> </li>
<li> <p><a href="https://en.wikipedia.org/wiki/Queue_(abstract_data_type)">Queue</a>.</p> </li>
<li> <p><a href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)">Stack</a>.</p> </li>
</ul> <p>There are also array-like data structures:</p> <ul>
<li> <p><a href="https://en.wikipedia.org/wiki/Associative_array">Associative array</a> (see <a href="hash.html"><code>Hash</code></a>).</p> </li>
<li> <p><a href="https://en.wikipedia.org/wiki/Directory_(computing)">Directory</a> (see <a href="dir.html"><code>Dir</code></a>).</p> </li>
<li> <p><a href="https://en.wikipedia.org/wiki/Environment_variable">Environment</a> (see <a href="env.html"><code>ENV</code></a>).</p> </li>
<li> <p><a href="https://en.wikipedia.org/wiki/Set_(abstract_data_type)">Set</a> (see <a href="set.html"><code>Set</code></a>).</p> </li>
<li> <p><a href="https://en.wikipedia.org/wiki/String_(computer_science)">String</a> (see <a href="string.html"><code>String</code></a>).</p> </li>
</ul> <h2 id="class-Array-label-Array+Indexes">Array Indexes</h2> <p>Array indexing starts at 0, as in C or Java.</p> <p>A non-negative index is an offset from the first element:</p> <ul>
<li> <p>Index 0 indicates the first element.</p> </li>
<li> <p>Index 1 indicates the second element.</p> </li>
<li> <p>…</p> </li>
</ul> <p>A negative index is an offset, backwards, from the end of the array:</p> <ul>
<li> <p>Index -1 indicates the last element.</p> </li>
<li> <p>Index -2 indicates the next-to-last element.</p> </li>
<li> <p>…</p> </li>
</ul> <h3 id="class-Array-label-In-Range+and+Out-of-Range+Indexes">In-Range and Out-of-Range Indexes</h3> <p>A non-negative index is <em>in range</em> if and only if it is smaller than the size of the array. For a 3-element array:</p> <ul>
<li> <p>Indexes 0 through 2 are in range.</p> </li>
<li> <p>Index 3 is out of range.</p> </li>
</ul> <p>A negative index is <em>in range</em> if and only if its absolute value is not larger than the size of the array. For a 3-element array:</p> <ul>
<li> <p>Indexes -1 through -3 are in range.</p> </li>
<li> <p>Index -4 is out of range.</p> </li>
</ul> <h3 id="class-Array-label-Effective+Index">Effective Index</h3> <p>Although the effective index into an array is always an integer, some methods (both within class Array and elsewhere) accept one or more non-integer arguments that are <a href="implicit_conversion_rdoc.html#label-Integer-Convertible+Objects">integer-convertible objects</a>.</p> <h2 id="class-Array-label-Creating+Arrays">Creating Arrays</h2> <p>You can create an Array object explicitly with:</p> <ul>
<li> <p>An <a href="syntax/literals_rdoc.html#label-Array+Literals">array literal</a>:</p> <pre class="ruby" data-language="ruby">[1, 'one', :one, [2, 'two', :two]]
</pre> </li>
<li> <p>A <a href="syntax/literals_rdoc.html#label-25w+and+-25W-3A+String-Array+Literals">%w or %W string-array Literal</a>:</p> <pre class="ruby" data-language="ruby">%w[foo bar baz] # =&gt; ["foo", "bar", "baz"]
%w[1 % *]       # =&gt; ["1", "%", "*"]
</pre> </li>
<li> <p>A <a href="syntax/literals_rdoc.html#label-25i+and+-25I-3A+Symbol-Array+Literals">%i or %I symbol-array Literal</a>:</p> <pre class="ruby" data-language="ruby">%i[foo bar baz] # =&gt; [:foo, :bar, :baz]
%i[1 % *]       # =&gt; [:"1", :%, :*]
</pre> </li>
<li> <p>Method <a href="kernel.html#method-i-Array"><code>Kernel#Array</code></a>:</p> <pre class="ruby" data-language="ruby">Array(["a", "b"])             # =&gt; ["a", "b"]
Array(1..5)                   # =&gt; [1, 2, 3, 4, 5]
Array(key: :value)            # =&gt; [[:key, :value]]
Array(nil)                    # =&gt; []
Array(1)                      # =&gt; [1]
Array({:a =&gt; "a", :b =&gt; "b"}) # =&gt; [[:a, "a"], [:b, "b"]]
</pre> </li>
<li> <p>Method <a href="array.html#method-c-new"><code>Array.new</code></a>:</p> <pre class="ruby" data-language="ruby">Array.new               # =&gt; []
Array.new(3)            # =&gt; [nil, nil, nil]
Array.new(4) {Hash.new} # =&gt; [{}, {}, {}, {}]
Array.new(3, true)      # =&gt; [true, true, true]
</pre> <p>Note that the last example above populates the array with references to the same object. This is recommended only in cases where that object is a natively immutable object such as a symbol, a numeric, <code>nil</code>, <code>true</code>, or <code>false</code>.</p> <p>Another way to create an array with various objects, using a block; this usage is safe for mutable objects such as hashes, strings or other arrays:</p> <pre class="ruby" data-language="ruby">Array.new(4) {|i| i.to_s } # =&gt; ["0", "1", "2", "3"]
</pre> <p>Here is a way to create a multi-dimensional array:</p> <pre class="ruby" data-language="ruby">Array.new(3) {Array.new(3)}
# =&gt; [[nil, nil, nil], [nil, nil, nil], [nil, nil, nil]]
</pre> </li>
</ul> <p>A number of Ruby methods, both in the core and in the standard library, provide instance method <a href="array.html#method-i-to_a"><code>to_a</code></a>, which converts an object to an array.</p> <ul>
<li> <p><a href="argf.html#method-i-to_a"><code>ARGF#to_a</code></a></p> </li>
<li> <p><a href="array.html#method-i-to_a"><code>Array#to_a</code></a></p> </li>
<li> <p><a href="enumerable.html#method-i-to_a"><code>Enumerable#to_a</code></a></p> </li>
<li> <p><a href="hash.html#method-i-to_a"><code>Hash#to_a</code></a></p> </li>
<li> <p><a href="matchdata.html#method-i-to_a"><code>MatchData#to_a</code></a></p> </li>
<li> <p><a href="nilclass.html#method-i-to_a"><code>NilClass#to_a</code></a></p> </li>
<li> <p><a href="optionparser.html#method-i-to_a"><code>OptionParser#to_a</code></a></p> </li>
<li> <p><a href="range.html#method-i-to_a"><code>Range#to_a</code></a></p> </li>
<li> <p><a href="set.html#method-i-to_a"><code>Set#to_a</code></a></p> </li>
<li> <p><a href="struct.html#method-i-to_a"><code>Struct#to_a</code></a></p> </li>
<li> <p><a href="time.html#method-i-to_a"><code>Time#to_a</code></a></p> </li>
<li> <p><a href="benchmark/tms.html#method-i-to_a"><code>Benchmark::Tms#to_a</code></a></p> </li>
<li> <p>CSV::Table#to_a</p> </li>
<li> <p><a href="enumerator/lazy.html#method-i-to_a"><code>Enumerator::Lazy#to_a</code></a></p> </li>
<li> <p>Gem::List#to_a</p> </li>
<li> <p><span><code>Gem::NameTuple#to_a</code></span></p> </li>
<li> <p><span><code>Gem::Platform#to_a</code></span></p> </li>
<li> <p><span><code>Gem::RequestSet::Lockfile::Tokenizer#to_a</code></span></p> </li>
<li> <p><span><code>Gem::SourceList#to_a</code></span></p> </li>
<li> <p><a href="openssl/x509/extension.html#method-i-to_a"><code>OpenSSL::X509::Extension#to_a</code></a></p> </li>
<li> <p><a href="openssl/x509/name.html#method-i-to_a"><code>OpenSSL::X509::Name#to_a</code></a></p> </li>
<li> <p>Racc::ISet#to_a</p> </li>
<li> <p>Rinda::RingFinger#to_a</p> </li>
<li> <p>Ripper::Lexer::Elem#to_a</p> </li>
<li> <p><a href="rubyvm/instructionsequence.html#method-i-to_a"><code>RubyVM::InstructionSequence#to_a</code></a></p> </li>
<li> <p><a href="yaml/dbm.html#method-i-to_a"><code>YAML::DBM#to_a</code></a></p> </li>
</ul> <h2 id="class-Array-label-Example+Usage">Example Usage</h2> <p>In addition to the methods it mixes in through the <a href="enumerable.html"><code>Enumerable</code></a> module, the <a href="array.html"><code>Array</code></a> class has proprietary methods for accessing, searching and otherwise manipulating arrays.</p> <p>Some of the more common ones are illustrated below.</p> <h2 id="class-Array-label-Accessing+Elements">Accessing Elements</h2> <p>Elements in an array can be retrieved using the <a href="array.html#method-i-5B-5D"><code>Array#[]</code></a> method. It can take a single integer argument (a numeric index), a pair of arguments (start and length) or a range. Negative indices start counting from the end, with -1 being the last element.</p> <pre class="ruby" data-language="ruby">arr = [1, 2, 3, 4, 5, 6]
arr[2]    #=&gt; 3
arr[100]  #=&gt; nil
arr[-3]   #=&gt; 4
arr[2, 3] #=&gt; [3, 4, 5]
arr[1..4] #=&gt; [2, 3, 4, 5]
arr[1..-3] #=&gt; [2, 3, 4]
</pre> <p>Another way to access a particular array element is by using the <a href="array.html#method-i-at"><code>at</code></a> method</p> <pre class="ruby" data-language="ruby">arr.at(0) #=&gt; 1
</pre> <p>The <a href="array.html#method-i-slice"><code>slice</code></a> method works in an identical manner to <a href="array.html#method-i-5B-5D"><code>Array#[]</code></a>.</p> <p>To raise an error for indices outside of the array bounds or else to provide a default value when that happens, you can use <a href="array.html#method-i-fetch"><code>fetch</code></a>.</p> <pre class="ruby" data-language="ruby">arr = ['a', 'b', 'c', 'd', 'e', 'f']
arr.fetch(100) #=&gt; IndexError: index 100 outside of array bounds: -6...6
arr.fetch(100, "oops") #=&gt; "oops"
</pre> <p>The special methods <a href="array.html#method-i-first"><code>first</code></a> and <a href="array.html#method-i-last"><code>last</code></a> will return the first and last elements of an array, respectively.</p> <pre class="ruby" data-language="ruby">arr.first #=&gt; 1
arr.last  #=&gt; 6
</pre> <p>To return the first <code>n</code> elements of an array, use <a href="array.html#method-i-take"><code>take</code></a></p> <pre class="ruby" data-language="ruby">arr.take(3) #=&gt; [1, 2, 3]
</pre> <p><a href="array.html#method-i-drop"><code>drop</code></a> does the opposite of <a href="array.html#method-i-take"><code>take</code></a>, by returning the elements after <code>n</code> elements have been dropped:</p> <pre class="ruby" data-language="ruby">arr.drop(3) #=&gt; [4, 5, 6]
</pre> <h2 id="class-Array-label-Obtaining+Information+about+an+Array">Obtaining Information about an <a href="array.html"><code>Array</code></a>
</h2> <p>Arrays keep track of their own length at all times. To query an array about the number of elements it contains, use <a href="array.html#method-i-length"><code>length</code></a>, <a href="array.html#method-i-count"><code>count</code></a> or <a href="array.html#method-i-size"><code>size</code></a>.</p> <pre class="ruby" data-language="ruby">browsers = ['Chrome', 'Firefox', 'Safari', 'Opera', 'IE']
browsers.length #=&gt; 5
browsers.count #=&gt; 5
</pre> <p>To check whether an array contains any elements at all</p> <pre class="ruby" data-language="ruby">browsers.empty? #=&gt; false
</pre> <p>To check whether a particular item is included in the array</p> <pre class="ruby" data-language="ruby">browsers.include?('Konqueror') #=&gt; false
</pre> <h2 id="class-Array-label-Adding+Items+to+Arrays">Adding Items to Arrays</h2> <p>Items can be added to the end of an array by using either <a href="array.html#method-i-push"><code>push</code></a> or <a href="array.html#method-i-3C-3C"><code>&lt;&lt;</code></a></p> <pre class="ruby" data-language="ruby">arr = [1, 2, 3, 4]
arr.push(5) #=&gt; [1, 2, 3, 4, 5]
arr &lt;&lt; 6    #=&gt; [1, 2, 3, 4, 5, 6]
</pre> <p><a href="array.html#method-i-unshift"><code>unshift</code></a> will add a new item to the beginning of an array.</p> <pre class="ruby" data-language="ruby">arr.unshift(0) #=&gt; [0, 1, 2, 3, 4, 5, 6]
</pre> <p>With <a href="array.html#method-i-insert"><code>insert</code></a> you can add a new element to an array at any position.</p> <pre class="ruby" data-language="ruby">arr.insert(3, 'apple')  #=&gt; [0, 1, 2, 'apple', 3, 4, 5, 6]
</pre> <p>Using the <a href="array.html#method-i-insert"><code>insert</code></a> method, you can also insert multiple values at once:</p> <pre class="ruby" data-language="ruby">arr.insert(3, 'orange', 'pear', 'grapefruit')
#=&gt; [0, 1, 2, "orange", "pear", "grapefruit", "apple", 3, 4, 5, 6]
</pre> <h2 id="class-Array-label-Removing+Items+from+an+Array">Removing Items from an <a href="array.html"><code>Array</code></a>
</h2> <p>The method <a href="array.html#method-i-pop"><code>pop</code></a> removes the last element in an array and returns it:</p> <pre class="ruby" data-language="ruby">arr =  [1, 2, 3, 4, 5, 6]
arr.pop #=&gt; 6
arr #=&gt; [1, 2, 3, 4, 5]
</pre> <p>To retrieve and at the same time remove the first item, use <a href="array.html#method-i-shift"><code>shift</code></a>:</p> <pre class="ruby" data-language="ruby">arr.shift #=&gt; 1
arr #=&gt; [2, 3, 4, 5]
</pre> <p>To delete an element at a particular index:</p> <pre class="ruby" data-language="ruby">arr.delete_at(2) #=&gt; 4
arr #=&gt; [2, 3, 5]
</pre> <p>To delete a particular element anywhere in an array, use <a href="array.html#method-i-delete"><code>delete</code></a>:</p> <pre class="ruby" data-language="ruby">arr = [1, 2, 2, 3]
arr.delete(2) #=&gt; 2
arr #=&gt; [1,3]
</pre> <p>A useful method if you need to remove <code>nil</code> values from an array is <a href="array.html#method-i-compact"><code>compact</code></a>:</p> <pre class="ruby" data-language="ruby">arr = ['foo', 0, nil, 'bar', 7, 'baz', nil]
arr.compact  #=&gt; ['foo', 0, 'bar', 7, 'baz']
arr          #=&gt; ['foo', 0, nil, 'bar', 7, 'baz', nil]
arr.compact! #=&gt; ['foo', 0, 'bar', 7, 'baz']
arr          #=&gt; ['foo', 0, 'bar', 7, 'baz']
</pre> <p>Another common need is to remove duplicate elements from an array.</p> <p>It has the non-destructive <a href="array.html#method-i-uniq"><code>uniq</code></a>, and destructive method <a href="array.html#method-i-uniq-21"><code>uniq!</code></a></p> <pre class="ruby" data-language="ruby">arr = [2, 5, 6, 556, 6, 6, 8, 9, 0, 123, 556]
arr.uniq #=&gt; [2, 5, 6, 556, 8, 9, 0, 123]
</pre> <h2 id="class-Array-label-Iterating+over+Arrays">Iterating over Arrays</h2> <p>Like all classes that include the <a href="enumerable.html"><code>Enumerable</code></a> module, <a href="array.html"><code>Array</code></a> has an each method, which defines what elements should be iterated over and how. In case of Array’s <a href="array.html#method-i-each"><code>each</code></a>, all elements in the <a href="array.html"><code>Array</code></a> instance are yielded to the supplied block in sequence.</p> <p>Note that this operation leaves the array unchanged.</p> <pre class="ruby" data-language="ruby">arr = [1, 2, 3, 4, 5]
arr.each {|a| print a -= 10, " "}
# prints: -9 -8 -7 -6 -5
#=&gt; [1, 2, 3, 4, 5]
</pre> <p>Another sometimes useful iterator is <a href="array.html#method-i-reverse_each"><code>reverse_each</code></a> which will iterate over the elements in the array in reverse order.</p> <pre class="ruby" data-language="ruby">words = %w[first second third fourth fifth sixth]
str = ""
words.reverse_each {|word| str += "#{word} "}
p str #=&gt; "sixth fifth fourth third second first "
</pre> <p>The <a href="array.html#method-i-map"><code>map</code></a> method can be used to create a new array based on the original array, but with the values modified by the supplied block:</p> <pre class="ruby" data-language="ruby">arr.map {|a| 2*a}     #=&gt; [2, 4, 6, 8, 10]
arr                   #=&gt; [1, 2, 3, 4, 5]
arr.map! {|a| a**2}   #=&gt; [1, 4, 9, 16, 25]
arr                   #=&gt; [1, 4, 9, 16, 25]
</pre> <h2 id="class-Array-label-Selecting+Items+from+an+Array">Selecting Items from an <a href="array.html"><code>Array</code></a>
</h2> <p>Elements can be selected from an array according to criteria defined in a block. The selection can happen in a destructive or a non-destructive manner. While the destructive operations will modify the array they were called on, the non-destructive methods usually return a new array with the selected elements, but leave the original array unchanged.</p> <h3 id="class-Array-label-Non-destructive+Selection">Non-destructive Selection</h3> <pre class="ruby" data-language="ruby">arr = [1, 2, 3, 4, 5, 6]
arr.select {|a| a &gt; 3}       #=&gt; [4, 5, 6]
arr.reject {|a| a &lt; 3}       #=&gt; [3, 4, 5, 6]
arr.drop_while {|a| a &lt; 4}   #=&gt; [4, 5, 6]
arr                          #=&gt; [1, 2, 3, 4, 5, 6]
</pre> <h3 id="class-Array-label-Destructive+Selection">Destructive Selection</h3> <p><a href="array.html#method-i-select-21"><code>select!</code></a> and <a href="array.html#method-i-reject-21"><code>reject!</code></a> are the corresponding destructive methods to <a href="array.html#method-i-select"><code>select</code></a> and <a href="array.html#method-i-reject"><code>reject</code></a></p> <p>Similar to <a href="array.html#method-i-select"><code>select</code></a> vs. <a href="array.html#method-i-reject"><code>reject</code></a>, <a href="array.html#method-i-delete_if"><code>delete_if</code></a> and <a href="array.html#method-i-keep_if"><code>keep_if</code></a> have the exact opposite result when supplied with the same block:</p> <pre class="ruby" data-language="ruby">arr.delete_if {|a| a &lt; 4}   #=&gt; [4, 5, 6]
arr                         #=&gt; [4, 5, 6]

arr = [1, 2, 3, 4, 5, 6]
arr.keep_if {|a| a &lt; 4}   #=&gt; [1, 2, 3]
arr                       #=&gt; [1, 2, 3]
</pre> <h2 id="class-Array-label-What-27s+Here">What’s Here</h2> <p>First, what’s elsewhere. Class <a href="array.html"><code>Array</code></a>:</p> <ul>
<li> <p>Inherits from <a href="object.html#class-Object-label-What-27s+Here">class Object</a>.</p> </li>
<li> <p>Includes <a href="enumerable.html#module-Enumerable-label-What-27s+Here">module Enumerable</a>, which provides dozens of additional methods.</p> </li>
</ul> <p>Here, class <a href="array.html"><code>Array</code></a> provides methods that are useful for:</p> <ul>
<li> <p><a href="array.html#class-Array-label-Methods+for+Creating+an+Array">Creating an Array</a></p> </li>
<li> <p><a href="array.html#class-Array-label-Methods+for+Querying">Querying</a></p> </li>
<li> <p><a href="array.html#class-Array-label-Methods+for+Comparing">Comparing</a></p> </li>
<li> <p><a href="array.html#class-Array-label-Methods+for+Fetching">Fetching</a></p> </li>
<li> <p><a href="array.html#class-Array-label-Methods+for+Assigning">Assigning</a></p> </li>
<li> <p><a href="array.html#class-Array-label-Methods+for+Deleting">Deleting</a></p> </li>
<li> <p><a href="array.html#class-Array-label-Methods+for+Combining">Combining</a></p> </li>
<li> <p><a href="array.html#class-Array-label-Methods+for+Iterating">Iterating</a></p> </li>
<li> <p><a href="array.html#class-Array-label-Methods+for+Converting">Converting</a></p> </li>
<li> <p><a href="array.html#class-Array-label-Other+Methods">And more.…</a></p> </li>
</ul> <h3 id="class-Array-label-Methods+for+Creating+an+Array">Methods for Creating an <a href="array.html"><code>Array</code></a>
</h3> <ul>
<li> <p><a href="array.html#method-c-5B-5D"><code>::[]</code></a>: Returns a new array populated with given objects.</p> </li>
<li> <p><a href="array.html#method-c-new"><code>::new</code></a>: Returns a new array.</p> </li>
<li> <p><a href="array.html#method-c-try_convert"><code>::try_convert</code></a>: Returns a new array created from a given object.</p> </li>
</ul> <p>See also <a href="array.html#class-Array-label-Creating+Arrays">Creating Arrays</a>.</p> <h3 id="class-Array-label-Methods+for+Querying">Methods for Querying</h3> <ul>
<li> <p><a href="array.html#method-i-all-3F"><code>all?</code></a>: Returns whether all elements meet a given criterion.</p> </li>
<li> <p><a href="array.html#method-i-any-3F"><code>any?</code></a>: Returns whether any element meets a given criterion.</p> </li>
<li> <p><a href="array.html#method-i-count"><code>count</code></a>: Returns the count of elements that meet a given criterion.</p> </li>
<li> <p><a href="array.html#method-i-empty-3F"><code>empty?</code></a>: Returns whether there are no elements.</p> </li>
<li> <p><a href="array.html#method-i-find_index"><code>find_index</code></a> (aliased as <a href="array.html#method-i-index"><code>index</code></a>): Returns the index of the first element that meets a given criterion.</p> </li>
<li> <p><a href="array.html#method-i-hash"><code>hash</code></a>: Returns the integer hash code.</p> </li>
<li> <p><a href="array.html#method-i-include-3F"><code>include?</code></a>: Returns whether any element <code>==</code> a given object.</p> </li>
<li> <p><a href="array.html#method-i-length"><code>length</code></a> (aliased as <a href="array.html#method-i-size"><code>size</code></a>): Returns the count of elements.</p> </li>
<li> <p><a href="array.html#method-i-none-3F"><code>none?</code></a>: Returns whether no element <code>==</code> a given object.</p> </li>
<li> <p><a href="array.html#method-i-one-3F"><code>one?</code></a>: Returns whether exactly one element <code>==</code> a given object.</p> </li>
<li> <p><a href="array.html#method-i-rindex"><code>rindex</code></a>: Returns the index of the last element that meets a given criterion.</p> </li>
</ul> <h3 id="class-Array-label-Methods+for+Comparing">Methods for Comparing</h3> <ul>
<li> <p><a href="array.html#method-i-3C-3D-3E"><code>&lt;=&gt;</code></a>: Returns -1, 0, or 1, as <code>self</code> is less than, equal to, or greater than a given object.</p> </li>
<li> <p><a href="array.html#method-i-3D-3D"><code>==</code></a>: Returns whether each element in <code>self</code> is <code>==</code> to the corresponding element in a given object.</p> </li>
<li> <p><a href="array.html#method-i-eql-3F"><code>eql?</code></a>: Returns whether each element in <code>self</code> is <code>eql?</code> to the corresponding element in a given object.</p> </li>
</ul> <h3 id="class-Array-label-Methods+for+Fetching">Methods for Fetching</h3> <p>These methods do not modify <code>self</code>.</p> <ul>
<li> <p><a href="array.html#method-i-5B-5D"><code>[]</code></a> (aliased as <a href="array.html#method-i-slice"><code>slice</code></a>): Returns consecutive elements as determined by a given argument.</p> </li>
<li> <p><a href="array.html#method-i-assoc"><code>assoc</code></a>: Returns the first element that is an array whose first element <code>==</code> a given object.</p> </li>
<li> <p><a href="array.html#method-i-at"><code>at</code></a>: Returns the element at a given offset.</p> </li>
<li> <p><a href="array.html#method-i-bsearch"><code>bsearch</code></a>: Returns an element selected via a binary search as determined by a given block.</p> </li>
<li> <p><a href="array.html#method-i-bsearch_index"><code>bsearch_index</code></a>: Returns the index of an element selected via a binary search as determined by a given block.</p> </li>
<li> <p><a href="array.html#method-i-compact"><code>compact</code></a>: Returns an array containing all non-<code>nil</code> elements.</p> </li>
<li> <p><a href="array.html#method-i-dig"><code>dig</code></a>: Returns the object in nested objects that is specified by a given index and additional arguments.</p> </li>
<li> <p><a href="array.html#method-i-drop"><code>drop</code></a>: Returns trailing elements as determined by a given index.</p> </li>
<li> <p><a href="array.html#method-i-drop_while"><code>drop_while</code></a>: Returns trailing elements as determined by a given block.</p> </li>
<li> <p><a href="array.html#method-i-fetch"><code>fetch</code></a>: Returns the element at a given offset.</p> </li>
<li> <p><a href="array.html#method-i-fetch_values"><code>fetch_values</code></a>: Returns elements at given offsets.</p> </li>
<li> <p><a href="array.html#method-i-first"><code>first</code></a>: Returns one or more leading elements.</p> </li>
<li> <p><a href="array.html#method-i-last"><code>last</code></a>: Returns one or more trailing elements.</p> </li>
<li> <p><a href="array.html#method-i-max"><code>max</code></a>: Returns one or more maximum-valued elements, as determined by <a href="array.html#method-i-3C-3D-3E"><code>&lt;=&gt;</code></a> or a given block.</p> </li>
<li> <p><a href="array.html#method-i-min"><code>min</code></a>: Returns one or more minimum-valued elements, as determined by <a href="array.html#method-i-3C-3D-3E"><code>&lt;=&gt;</code></a> or a given block.</p> </li>
<li> <p><a href="array.html#method-i-minmax"><code>minmax</code></a>: Returns the minimum-valued and maximum-valued elements, as determined by <a href="array.html#method-i-3C-3D-3E"><code>&lt;=&gt;</code></a> or a given block.</p> </li>
<li> <p><a href="array.html#method-i-rassoc"><code>rassoc</code></a>: Returns the first element that is an array whose second element <code>==</code> a given object.</p> </li>
<li> <p><a href="array.html#method-i-reject"><code>reject</code></a>: Returns an array containing elements not rejected by a given block.</p> </li>
<li> <p><a href="array.html#method-i-reverse"><code>reverse</code></a>: Returns all elements in reverse order.</p> </li>
<li> <p><a href="array.html#method-i-rotate"><code>rotate</code></a>: Returns all elements with some rotated from one end to the other.</p> </li>
<li> <p><a href="array.html#method-i-sample"><code>sample</code></a>: Returns one or more random elements.</p> </li>
<li> <p><a href="array.html#method-i-select"><code>select</code></a> (aliased as <a href="array.html#method-i-filter"><code>filter</code></a>): Returns an array containing elements selected by a given block.</p> </li>
<li> <p><a href="array.html#method-i-shuffle"><code>shuffle</code></a>: Returns elements in a random order.</p> </li>
<li> <p><a href="array.html#method-i-sort"><code>sort</code></a>: Returns all elements in an order determined by <a href="array.html#method-i-3C-3D-3E"><code>&lt;=&gt;</code></a> or a given block.</p> </li>
<li> <p><a href="array.html#method-i-take"><code>take</code></a>: Returns leading elements as determined by a given index.</p> </li>
<li> <p><a href="array.html#method-i-take_while"><code>take_while</code></a>: Returns leading elements as determined by a given block.</p> </li>
<li> <p><a href="array.html#method-i-uniq"><code>uniq</code></a>: Returns an array containing non-duplicate elements.</p> </li>
<li> <p><a href="array.html#method-i-values_at"><code>values_at</code></a>: Returns the elements at given offsets.</p> </li>
</ul> <h3 id="class-Array-label-Methods+for+Assigning">Methods for Assigning</h3> <p>These methods add, replace, or reorder elements in <code>self</code>.</p> <ul>
<li> <p><a href="array.html#method-i-3C-3C"><code>&lt;&lt;</code></a>: Appends an element.</p> </li>
<li> <p><a href="array.html#method-i-5B-5D-3D"><code>[]=</code></a>: Assigns specified elements with a given object.</p> </li>
<li> <p><a href="array.html#method-i-concat"><code>concat</code></a>: Appends all elements from given arrays.</p> </li>
<li> <p><a href="array.html#method-i-fill"><code>fill</code></a>: Replaces specified elements with specified objects.</p> </li>
<li> <p><a href="array.html#method-i-flatten-21"><code>flatten!</code></a>: Replaces each nested array in <code>self</code> with the elements from that array.</p> </li>
<li> <p><a href="array.html#method-i-initialize_copy"><code>initialize_copy</code></a> (aliased as <a href="array.html#method-i-replace"><code>replace</code></a>): Replaces the content of <code>self</code> with the content of a given array.</p> </li>
<li> <p><a href="array.html#method-i-insert"><code>insert</code></a>: Inserts given objects at a given offset; does not replace elements.</p> </li>
<li> <p><a href="array.html#method-i-push"><code>push</code></a> (aliased as <a href="array.html#method-i-append"><code>append</code></a>): Appends elements.</p> </li>
<li> <p><a href="array.html#method-i-reverse-21"><code>reverse!</code></a>: Replaces <code>self</code> with its elements reversed.</p> </li>
<li> <p><a href="array.html#method-i-rotate-21"><code>rotate!</code></a>: Replaces <code>self</code> with its elements rotated.</p> </li>
<li> <p><a href="array.html#method-i-shuffle-21"><code>shuffle!</code></a>: Replaces <code>self</code> with its elements in random order.</p> </li>
<li> <p><a href="array.html#method-i-sort-21"><code>sort!</code></a>: Replaces <code>self</code> with its elements sorted, as determined by <a href="array.html#method-i-3C-3D-3E"><code>&lt;=&gt;</code></a> or a given block.</p> </li>
<li> <p><a href="array.html#method-i-sort_by-21"><code>sort_by!</code></a>: Replaces <code>self</code> with its elements sorted, as determined by a given block.</p> </li>
<li> <p><a href="array.html#method-i-unshift"><code>unshift</code></a> (aliased as <a href="array.html#method-i-prepend"><code>prepend</code></a>): Prepends leading elements.</p> </li>
</ul> <h3 id="class-Array-label-Methods+for+Deleting">Methods for Deleting</h3> <p>Each of these methods removes elements from <code>self</code>:</p> <ul>
<li> <p><a href="array.html#method-i-clear"><code>clear</code></a>: Removes all elements.</p> </li>
<li> <p><a href="array.html#method-i-compact-21"><code>compact!</code></a>: Removes all <code>nil</code> elements.</p> </li>
<li> <p><a href="array.html#method-i-delete"><code>delete</code></a>: Removes elements equal to a given object.</p> </li>
<li> <p><a href="array.html#method-i-delete_at"><code>delete_at</code></a>: Removes the element at a given offset.</p> </li>
<li> <p><a href="array.html#method-i-delete_if"><code>delete_if</code></a>: Removes elements specified by a given block.</p> </li>
<li> <p><a href="array.html#method-i-keep_if"><code>keep_if</code></a>: Removes elements not specified by a given block.</p> </li>
<li> <p><a href="array.html#method-i-pop"><code>pop</code></a>: Removes and returns the last element.</p> </li>
<li> <p><a href="array.html#method-i-reject-21"><code>reject!</code></a>: Removes elements specified by a given block.</p> </li>
<li> <p><a href="array.html#method-i-select-21"><code>select!</code></a> (aliased as <a href="array.html#method-i-filter-21"><code>filter!</code></a>): Removes elements not specified by a given block.</p> </li>
<li> <p><a href="array.html#method-i-shift"><code>shift</code></a>: Removes and returns the first element.</p> </li>
<li> <p><a href="array.html#method-i-slice-21"><code>slice!</code></a>: Removes and returns a sequence of elements.</p> </li>
<li> <p><a href="array.html#method-i-uniq-21"><code>uniq!</code></a>: Removes duplicates.</p> </li>
</ul> <h3 id="class-Array-label-Methods+for+Combining">Methods for Combining</h3> <ul>
<li> <p><a href="array.html#method-i-26"><code>&amp;</code></a>: Returns an array containing elements found both in <code>self</code> and a given array.</p> </li>
<li> <p><a href="array.html#method-i-2B"><code>+</code></a>: Returns an array containing all elements of <code>self</code> followed by all elements of a given array.</p> </li>
<li> <p><a href="array.html#method-i-2D"><code>-</code></a>: Returns an array containing all elements of <code>self</code> that are not found in a given array.</p> </li>
<li> <p><a href="array.html#method-i-7C"><code>|</code></a>: Returns an array containing all element of <code>self</code> and all elements of a given array, duplicates removed.</p> </li>
<li> <p><a href="array.html#method-i-difference"><code>difference</code></a>: Returns an array containing all elements of <code>self</code> that are not found in any of the given arrays..</p> </li>
<li> <p><a href="array.html#method-i-intersection"><code>intersection</code></a>: Returns an array containing elements found both in <code>self</code> and in each given array.</p> </li>
<li> <p><a href="array.html#method-i-product"><code>product</code></a>: Returns or yields all combinations of elements from <code>self</code> and given arrays.</p> </li>
<li> <p><a href="array.html#method-i-reverse"><code>reverse</code></a>: Returns an array containing all elements of <code>self</code> in reverse order.</p> </li>
<li> <p><a href="array.html#method-i-union"><code>union</code></a>: Returns an array containing all elements of <code>self</code> and all elements of given arrays, duplicates removed.</p> </li>
</ul> <h3 id="class-Array-label-Methods+for+Iterating">Methods for Iterating</h3> <ul>
<li> <p><a href="array.html#method-i-combination"><code>combination</code></a>: Calls a given block with combinations of elements of <code>self</code>; a combination does not use the same element more than once.</p> </li>
<li> <p><a href="array.html#method-i-cycle"><code>cycle</code></a>: Calls a given block with each element, then does so again, for a specified number of times, or forever.</p> </li>
<li> <p><a href="array.html#method-i-each"><code>each</code></a>: Passes each element to a given block.</p> </li>
<li> <p><a href="array.html#method-i-each_index"><code>each_index</code></a>: Passes each element index to a given block.</p> </li>
<li> <p><a href="array.html#method-i-permutation"><code>permutation</code></a>: Calls a given block with permutations of elements of <code>self</code>; a permutation does not use the same element more than once.</p> </li>
<li> <p><a href="array.html#method-i-repeated_combination"><code>repeated_combination</code></a>: Calls a given block with combinations of elements of <code>self</code>; a combination may use the same element more than once.</p> </li>
<li> <p><a href="array.html#method-i-repeated_permutation"><code>repeated_permutation</code></a>: Calls a given block with permutations of elements of <code>self</code>; a permutation may use the same element more than once.</p> </li>
<li> <p><a href="array.html#method-i-reverse_each"><code>reverse_each</code></a>: Passes each element, in reverse order, to a given block.</p> </li>
</ul> <h3 id="class-Array-label-Methods+for+Converting">Methods for Converting</h3> <ul>
<li> <p><a href="array.html#method-i-collect"><code>collect</code></a> (aliased as <a href="array.html#method-i-map"><code>map</code></a>): Returns an array containing the block return-value for each element.</p> </li>
<li> <p><a href="array.html#method-i-collect-21"><code>collect!</code></a> (aliased as <a href="array.html#method-i-map-21"><code>map!</code></a>): Replaces each element with a block return-value.</p> </li>
<li> <p><a href="array.html#method-i-flatten"><code>flatten</code></a>: Returns an array that is a recursive flattening of <code>self</code>.</p> </li>
<li> <p><a href="array.html#method-i-inspect"><code>inspect</code></a> (aliased as <a href="array.html#method-i-to_s"><code>to_s</code></a>): Returns a new <a href="string.html"><code>String</code></a> containing the elements.</p> </li>
<li> <p><a href="array.html#method-i-join"><code>join</code></a>: Returns a newsString containing the elements joined by the field separator.</p> </li>
<li> <p><a href="array.html#method-i-to_a"><code>to_a</code></a>: Returns <code>self</code> or a new array containing all elements.</p> </li>
<li> <p><a href="array.html#method-i-to_ary"><code>to_ary</code></a>: Returns <code>self</code>.</p> </li>
<li> <p><a href="array.html#method-i-to_h"><code>to_h</code></a>: Returns a new hash formed from the elements.</p> </li>
<li> <p><a href="array.html#method-i-transpose"><code>transpose</code></a>: Transposes <code>self</code>, which must be an array of arrays.</p> </li>
<li> <p><a href="array.html#method-i-zip"><code>zip</code></a>: Returns a new array of arrays containing <code>self</code> and given arrays.</p> </li>
</ul> <h3 id="class-Array-label-Other+Methods">Other Methods</h3> <ul>
<li> <p><a href="array.html#method-i-2A"><code>*</code></a>: Returns one of the following:</p> <ul>
<li> <p>With integer argument <code>n</code>, a new array that is the concatenation of <code>n</code> copies of <code>self</code>.</p> </li>
<li> <p>With string argument <code>field_separator</code>, a new string that is equivalent to <code>join(field_separator)</code>.</p> </li>
</ul> </li>
<li> <p><a href="array.html#method-i-pack"><code>pack</code></a>: Packs the elements into a binary sequence.</p> </li>
<li> <p><a href="array.html#method-i-sum"><code>sum</code></a>: Returns a sum of elements according to either <code>+</code> or a given block.</p> </li>
</ul> </section> <section id="5Buntitled-5D" class="documentation-section anchor-link"> <section id="public-class-5Buntitled-5D-method-details" class="method-section anchor-link"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-5B-5D"> <a href="#method-c-5B-5D" title="Link to this method"> <span class="method-name">[]</span> <span class="method-args">(*args)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="5B-5D-source"> <pre class="c" data-language="c">static VALUE
rb_ary_s_create(int argc, VALUE *argv, VALUE klass)
{
    VALUE ary = ary_new(klass, argc);
    if (argc &gt; 0 &amp;&amp; argv) {
        ary_memcpy(ary, 0, argc, argv);
        ARY_SET_LEN(ary, argc);
    }

    return ary;
}</pre> </div>  <p>Returns a new array, populated with the given objects:</p> <pre class="ruby" data-language="ruby">Array[1, 'a', /^A/]    # =&gt; [1, "a", /^A/]
Array[]                # =&gt; []
Array.[](1, 'a', /^A/) # =&gt; [1, "a", /^A/]
</pre> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Creating+an+Array">Methods for Creating an Array</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-new"> <a href="#method-c-new" title="Link to this method"> <span class="method-callseq"> new → new_empty_array </span> </a> </div> <div class="method-heading"> <a href="#method-c-new" title="Link to this method"> <span class="method-callseq"> new(array) → new_array </span> </a> </div> <div class="method-heading"> <a href="#method-c-new" title="Link to this method"> <span class="method-callseq"> new(size, default_value = nil) → new_array </span> </a> </div> <div class="method-heading"> <a href="#method-c-new" title="Link to this method"> <span class="method-callseq"> new(size = 0) {|index| ... } → new_array </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="new-source"> <pre class="c" data-language="c">static VALUE
rb_ary_initialize(int argc, VALUE *argv, VALUE ary)
{
    long len;
    VALUE size, val;

    rb_ary_modify(ary);
    if (argc == 0) {
        rb_ary_reset(ary);
        RUBY_ASSERT(ARY_EMBED_P(ary));
        RUBY_ASSERT(ARY_EMBED_LEN(ary) == 0);
        if (rb_block_given_p()) {
            rb_warning("given block not used");
        }
        return ary;
    }
    rb_scan_args(argc, argv, "02", &amp;size, &amp;val);
    if (argc == 1 &amp;&amp; !FIXNUM_P(size)) {
        val = rb_check_array_type(size);
        if (!NIL_P(val)) {
            rb_ary_replace(ary, val);
            return ary;
        }
    }

    len = NUM2LONG(size);
    /* NUM2LONG() may call size.to_int, ary can be frozen, modified, etc */
    if (len &lt; 0) {
        rb_raise(rb_eArgError, "negative array size");
    }
    if (len &gt; ARY_MAX_SIZE) {
        rb_raise(rb_eArgError, "array size too big");
    }
    /* recheck after argument conversion */
    rb_ary_modify(ary);
    ary_resize_capa(ary, len);
    if (rb_block_given_p()) {
        long i;

        if (argc == 2) {
            rb_warn("block supersedes default value argument");
        }
        for (i=0; i&lt;len; i++) {
            rb_ary_store(ary, i, rb_yield(LONG2NUM(i)));
            ARY_SET_LEN(ary, i + 1);
        }
    }
    else {
        ary_memfill(ary, 0, len, val);
        ARY_SET_LEN(ary, len);
    }
    return ary;
}</pre> </div>  <p>Returns a new array.</p> <p>With no block and no argument given, returns a new empty array:</p> <pre class="ruby" data-language="ruby">Array.new # =&gt; []
</pre> <p>With no block and array argument given, returns a new array with the same elements:</p> <pre class="ruby" data-language="ruby">Array.new([:foo, 'bar', 2]) # =&gt; [:foo, "bar", 2]
</pre> <p>With no block and integer argument given, returns a new array containing that many instances of the given <code>default_value</code>:</p> <pre class="ruby" data-language="ruby">Array.new(0)    # =&gt; []
Array.new(3)    # =&gt; [nil, nil, nil]
Array.new(2, 3) # =&gt; [3, 3]
</pre> <p>With a block given, returns an array of the given <code>size</code>; calls the block with each <code>index</code> in the range <code>(0...size)</code>; the element at that <code>index</code> in the returned array is the blocks return value:</p> <pre class="ruby" data-language="ruby">Array.new(3)  {|index| "Element #{index}" } # =&gt; ["Element 0", "Element 1", "Element 2"]
</pre> <p>A common pitfall for new Rubyists is providing an expression as <code>default_value</code>:</p> <pre class="ruby" data-language="ruby">array = Array.new(2, {})
array # =&gt; [{}, {}]
array[0][:a] = 1
array # =&gt; [{a: 1}, {a: 1}], as array[0] and array[1] are same object
</pre> <p>If you want the elements of the array to be distinct, you should pass a block:</p> <pre class="ruby" data-language="ruby">array = Array.new(2) { {} }
array # =&gt; [{}, {}]
array[0][:a] = 1
array # =&gt; [{a: 1}, {}], as array[0] and array[1] are different objects
</pre> <p>Raises <a href="typeerror.html"><code>TypeError</code></a> if the first argument is not either an array or an <a href="implicit_conversion_rdoc.html#label-Integer-Convertible+Objects">integer-convertible object</a>). Raises <a href="argumenterror.html"><code>ArgumentError</code></a> if the first argument is a negative integer.</p> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Creating+an+Array">Methods for Creating an Array</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-try_convert"> <a href="#method-c-try_convert" title="Link to this method"> <span class="method-callseq"> try_convert(object) → object, new_array, or nil </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="try_convert-source"> <pre class="c" data-language="c">static VALUE
rb_ary_s_try_convert(VALUE dummy, VALUE ary)
{
    return rb_check_array_type(ary);
}</pre> </div>  <p>Attempts to return an array, based on the given <code>object</code>.</p> <p>If <code>object</code> is an array, returns <code>object</code>.</p> <p>Otherwise if <code>object</code> responds to <code>:to_ary</code>. calls <code>object.to_ary</code>: if the return value is an array or <code>nil</code>, returns that value; if not, raises <a href="typeerror.html"><code>TypeError</code></a>.</p> <p>Otherwise returns <code>nil</code>.</p> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Creating+an+Array">Methods for Creating an Array</a>.</p> </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section anchor-link"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-26"> <a href="#method-i-26" title="Link to this method"> <span class="method-callseq"> self &amp; other_array → new_array </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="26-source"> <pre class="c" data-language="c">static VALUE
rb_ary_and(VALUE ary1, VALUE ary2)
{
    VALUE hash, ary3, v;
    st_data_t vv;
    long i;

    ary2 = to_ary(ary2);
    ary3 = rb_ary_new();
    if (RARRAY_LEN(ary1) == 0 || RARRAY_LEN(ary2) == 0) return ary3;

    if (RARRAY_LEN(ary1) &lt;= SMALL_ARRAY_LEN &amp;&amp; RARRAY_LEN(ary2) &lt;= SMALL_ARRAY_LEN) {
        for (i=0; i&lt;RARRAY_LEN(ary1); i++) {
            v = RARRAY_AREF(ary1, i);
            if (!rb_ary_includes_by_eql(ary2, v)) continue;
            if (rb_ary_includes_by_eql(ary3, v)) continue;
            rb_ary_push(ary3, v);
        }
        return ary3;
    }

    hash = ary_make_hash(ary2);

    for (i=0; i&lt;RARRAY_LEN(ary1); i++) {
        v = RARRAY_AREF(ary1, i);
        vv = (st_data_t)v;
        if (rb_hash_stlike_delete(hash, &amp;vv, 0)) {
            rb_ary_push(ary3, v);
        }
    }

    return ary3;
}</pre> </div>  <p>Returns a new array containing the <em>intersection</em> of <code>self</code> and <code>other_array</code>; that is, containing those elements found in both <code>self</code> and <code>other_array</code>:</p> <pre class="ruby" data-language="ruby">[0, 1, 2, 3] &amp; [1, 2] # =&gt; [1, 2]
</pre> <p>Omits duplicates:</p> <pre class="ruby" data-language="ruby">[0, 1, 1, 0] &amp; [0, 1] # =&gt; [0, 1]
</pre> <p>Preserves order from <code>self</code>:</p> <pre class="ruby" data-language="ruby">[0, 1, 2] &amp; [3, 2, 1, 0] # =&gt; [0, 1, 2]
</pre> <p>Identifies common elements using method <a href="array.html#method-i-eql-3F"><code>eql?</code></a> (as defined in each element of <code>self</code>).</p> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Combining">Methods for Combining</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-2A"> <a href="#method-i-2A" title="Link to this method"> <span class="method-callseq"> self * n → new_array </span> </a> </div> <div class="method-heading"> <a href="#method-i-2A" title="Link to this method"> <span class="method-callseq"> self * string_separator → new_string </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="2A-source"> <pre class="c" data-language="c">static VALUE
rb_ary_times(VALUE ary, VALUE times)
{
    VALUE ary2, tmp;
    const VALUE *ptr;
    long t, len;

    tmp = rb_check_string_type(times);
    if (!NIL_P(tmp)) {
        return rb_ary_join(ary, tmp);
    }

    len = NUM2LONG(times);
    if (len == 0) {
        ary2 = ary_new(rb_cArray, 0);
        goto out;
    }
    if (len &lt; 0) {
        rb_raise(rb_eArgError, "negative argument");
    }
    if (ARY_MAX_SIZE/len &lt; RARRAY_LEN(ary)) {
        rb_raise(rb_eArgError, "argument too big");
    }
    len *= RARRAY_LEN(ary);

    ary2 = ary_new(rb_cArray, len);
    ARY_SET_LEN(ary2, len);

    ptr = RARRAY_CONST_PTR(ary);
    t = RARRAY_LEN(ary);
    if (0 &lt; t) {
        ary_memcpy(ary2, 0, t, ptr);
        while (t &lt;= len/2) {
            ary_memcpy(ary2, t, t, RARRAY_CONST_PTR(ary2));
            t *= 2;
        }
        if (t &lt; len) {
            ary_memcpy(ary2, t, len-t, RARRAY_CONST_PTR(ary2));
        }
    }
  out:
    return ary2;
}</pre> </div>  <p>When non-negative integer argument <code>n</code> is given, returns a new array built by concatenating <code>n</code> copies of <code>self</code>:</p> <pre class="ruby" data-language="ruby">a = ['x', 'y']
a * 3 # =&gt; ["x", "y", "x", "y", "x", "y"]
</pre> <p>When string argument <code>string_separator</code> is given, equivalent to <code>self.join(string_separator)</code>:</p> <pre class="ruby" data-language="ruby">[0, [0, 1], {foo: 0}] * ', ' # =&gt; "0, 0, 1, {foo: 0}"
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-2B"> <a href="#method-i-2B" title="Link to this method"> <span class="method-callseq"> self + other_array → new_array </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="2B-source"> <pre class="c" data-language="c">VALUE
rb_ary_plus(VALUE x, VALUE y)
{
    VALUE z;
    long len, xlen, ylen;

    y = to_ary(y);
    xlen = RARRAY_LEN(x);
    ylen = RARRAY_LEN(y);
    len = xlen + ylen;
    z = rb_ary_new2(len);

    ary_memcpy(z, 0, xlen, RARRAY_CONST_PTR(x));
    ary_memcpy(z, xlen, ylen, RARRAY_CONST_PTR(y));
    ARY_SET_LEN(z, len);
    return z;
}</pre> </div>  <p>Returns a new array containing all elements of <code>self</code> followed by all elements of <code>other_array</code>:</p> <pre class="ruby" data-language="ruby">a = [0, 1] + [2, 3]
a # =&gt; [0, 1, 2, 3]
</pre> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Combining">Methods for Combining</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-2D"> <a href="#method-i-2D" title="Link to this method"> <span class="method-callseq"> self - other_array → new_array </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="2D-source"> <pre class="c" data-language="c">VALUE
rb_ary_diff(VALUE ary1, VALUE ary2)
{
    VALUE ary3;
    VALUE hash;
    long i;

    ary2 = to_ary(ary2);
    if (RARRAY_LEN(ary2) == 0) { return ary_make_shared_copy(ary1); }
    ary3 = rb_ary_new();

    if (RARRAY_LEN(ary1) &lt;= SMALL_ARRAY_LEN || RARRAY_LEN(ary2) &lt;= SMALL_ARRAY_LEN) {
        for (i=0; i&lt;RARRAY_LEN(ary1); i++) {
            VALUE elt = rb_ary_elt(ary1, i);
            if (rb_ary_includes_by_eql(ary2, elt)) continue;
            rb_ary_push(ary3, elt);
        }
        return ary3;
    }

    hash = ary_make_hash(ary2);
    for (i=0; i&lt;RARRAY_LEN(ary1); i++) {
        if (rb_hash_stlike_lookup(hash, RARRAY_AREF(ary1, i), NULL)) continue;
        rb_ary_push(ary3, rb_ary_elt(ary1, i));
    }

    return ary3;
}</pre> </div>  <p>Returns a new array containing only those elements of <code>self</code> that are not found in <code>other_array</code>; the order from <code>self</code> is preserved:</p> <pre class="ruby" data-language="ruby">[0, 1, 1, 2, 1, 1, 3, 1, 1] - [1]             # =&gt; [0, 2, 3]
[0, 1, 1, 2, 1, 1, 3, 1, 1] - [3, 2, 0, :foo] # =&gt; [1, 1, 1, 1, 1, 1]
[0, 1, 2] - [:foo]                            # =&gt; [0, 1, 2]
</pre> <p>Element are compared using method <a href="array.html#method-i-eql-3F"><code>eql?</code></a> (as defined in each element of <code>self</code>).</p> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Combining">Methods for Combining</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-3C-3C"> <a href="#method-i-3C-3C" title="Link to this method"> <span class="method-callseq"> self &lt;&lt; object → self </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="3C-3C-source"> <pre class="c" data-language="c">VALUE
rb_ary_push(VALUE ary, VALUE item)
{
    long idx = RARRAY_LEN((ary_verify(ary), ary));
    VALUE target_ary = ary_ensure_room_for_push(ary, 1);
    RARRAY_PTR_USE(ary, ptr, {
        RB_OBJ_WRITE(target_ary, &amp;ptr[idx], item);
    });
    ARY_SET_LEN(ary, idx + 1);
    ary_verify(ary);
    return ary;
}</pre> </div>  <p>Appends <code>object</code> as the last element in <code>self</code>; returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">[:foo, 'bar', 2] &lt;&lt; :baz # =&gt; [:foo, "bar", 2, :baz]
</pre> <p>Appends <code>object</code> as a single element, even if it is another array:</p> <pre class="ruby" data-language="ruby">[:foo, 'bar', 2] &lt;&lt; [3, 4] # =&gt; [:foo, "bar", 2, [3, 4]]
</pre> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Assigning">Methods for Assigning</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-3C-3D-3E"> <a href="#method-i-3C-3D-3E" title="Link to this method"> <span class="method-callseq"> self &lt;=&gt; other_array → -1, 0, or 1 </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="3C-3D-3E-source"> <pre class="c" data-language="c">VALUE
rb_ary_cmp(VALUE ary1, VALUE ary2)
{
    long len;
    VALUE v;

    ary2 = rb_check_array_type(ary2);
    if (NIL_P(ary2)) return Qnil;
    if (ary1 == ary2) return INT2FIX(0);
    v = rb_exec_recursive_paired(recursive_cmp, ary1, ary2, ary2);
    if (!UNDEF_P(v)) return v;
    len = RARRAY_LEN(ary1) - RARRAY_LEN(ary2);
    if (len == 0) return INT2FIX(0);
    if (len &gt; 0) return INT2FIX(1);
    return INT2FIX(-1);
}</pre> </div>  <p>Returns -1, 0, or 1 as <code>self</code> is determined to be less than, equal to, or greater than <code>other_array</code>.</p> <p>Iterates over each index <code>i</code> in <code>(0...self.size)</code>:</p> <ul>
<li> <p>Computes <code>result[i]</code> as <code>self[i] &lt;=&gt; other_array[i]</code>.</p> </li>
<li> <p>Immediately returns 1 if <code>result[i]</code> is 1:</p> <pre class="ruby" data-language="ruby">[0, 1, 2] &lt;=&gt; [0, 0, 2] # =&gt; 1
</pre> </li>
<li> <p>Immediately returns -1 if <code>result[i]</code> is -1:</p> <pre class="ruby" data-language="ruby">[0, 1, 2] &lt;=&gt; [0, 2, 2] # =&gt; -1
</pre> </li>
<li> <p>Continues if <code>result[i]</code> is 0.</p> </li>
</ul> <p>When every <code>result</code> is 0, returns <code>self.size &lt;=&gt; other_array.size</code> (see <a href="integer.html#method-i-3C-3D-3E"><code>Integer#&lt;=&gt;</code></a>):</p> <pre class="ruby" data-language="ruby">[0, 1, 2] &lt;=&gt; [0, 1]        # =&gt; 1
[0, 1, 2] &lt;=&gt; [0, 1, 2]     # =&gt; 0
[0, 1, 2] &lt;=&gt; [0, 1, 2, 3]  # =&gt; -1
</pre> <p>Note that when <code>other_array</code> is larger than <code>self</code>, its trailing elements do not affect the result:</p> <pre class="ruby" data-language="ruby">[0, 1, 2] &lt;=&gt; [0, 1, 2, -3] # =&gt; -1
[0, 1, 2] &lt;=&gt; [0, 1, 2, 0]  # =&gt; -1
[0, 1, 2] &lt;=&gt; [0, 1, 2, 3]  # =&gt; -1
</pre> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Comparing">Methods for Comparing</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-3D-3D"> <a href="#method-i-3D-3D" title="Link to this method"> <span class="method-callseq"> self == other_array → true or false </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="3D-3D-source"> <pre class="c" data-language="c">static VALUE
rb_ary_equal(VALUE ary1, VALUE ary2)
{
    if (ary1 == ary2) return Qtrue;
    if (!RB_TYPE_P(ary2, T_ARRAY)) {
        if (!rb_respond_to(ary2, idTo_ary)) {
            return Qfalse;
        }
        return rb_equal(ary2, ary1);
    }
    if (RARRAY_LEN(ary1) != RARRAY_LEN(ary2)) return Qfalse;
    if (RARRAY_CONST_PTR(ary1) == RARRAY_CONST_PTR(ary2)) return Qtrue;
    return rb_exec_recursive_paired(recursive_equal, ary1, ary2, ary2);
}</pre> </div>  <p>Returns whether both:</p> <ul>
<li> <p><code>self</code> and <code>other_array</code> are the same size.</p> </li>
<li> <p>Their corresponding elements are the same; that is, for each index <code>i</code> in <code>(0...self.size)</code>, <code>self[i] == other_array[i]</code>.</p> </li>
</ul> <p>Examples:</p> <pre class="ruby" data-language="ruby">[:foo, 'bar', 2] == [:foo, 'bar', 2]   # =&gt; true
[:foo, 'bar', 2] == [:foo, 'bar', 2.0] # =&gt; true
[:foo, 'bar', 2] == [:foo, 'bar']      # =&gt; false # Different sizes.
[:foo, 'bar', 2] == [:foo, 'bar', 3]   # =&gt; false # Different elements.
</pre> <p>This method is different from method <a href="array.html#method-i-eql-3F"><code>Array#eql?</code></a>, which compares elements using <a href="object.html#method-i-eql-3F"><code>Object#eql?</code></a>.</p> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Comparing">Methods for Comparing</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-5B-5D"> <a href="#method-i-5B-5D" title="Link to this method"> <span class="method-callseq"> self[index] → object or nil </span> </a> </div> <div class="method-heading"> <a href="#method-i-5B-5D" title="Link to this method"> <span class="method-callseq"> self[start, length] → object or nil </span> </a> </div> <div class="method-heading"> <a href="#method-i-5B-5D" title="Link to this method"> <span class="method-callseq"> self[range] → object or nil </span> </a> </div> <div class="method-heading"> <a href="#method-i-5B-5D" title="Link to this method"> <span class="method-callseq"> self[aseq] → object or nil </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="5B-5D-source"> <pre class="c" data-language="c">VALUE
rb_ary_aref(int argc, const VALUE *argv, VALUE ary)
{
    rb_check_arity(argc, 1, 2);
    if (argc == 2) {
        return rb_ary_aref2(ary, argv[0], argv[1]);
    }
    return rb_ary_aref1(ary, argv[0]);
}</pre> </div>  <p>Returns elements from <code>self</code>; does not modify <code>self</code>.</p> <p>In brief:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]

# Single argument index: returns one element.
a[0]     # =&gt; :foo          # Zero-based index.
a[-1]    # =&gt; 2             # Negative index counts backwards from end.

# Arguments start and length: returns an array.
a[1, 2]  # =&gt; ["bar", 2]
a[-2, 2] # =&gt; ["bar", 2]    # Negative start counts backwards from end.

# Single argument range: returns an array.
a[0..1]  # =&gt; [:foo, "bar"]
a[0..-2] # =&gt; [:foo, "bar"] # Negative range-begin counts backwards from end.
a[-2..2] # =&gt; ["bar", 2]    # Negative range-end counts backwards from end.
</pre> <p>When a single integer argument <code>index</code> is given, returns the element at offset <code>index</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[0] # =&gt; :foo
a[2] # =&gt; 2
a # =&gt; [:foo, "bar", 2]
</pre> <p>If <code>index</code> is negative, counts backwards from the end of <code>self</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[-1] # =&gt; 2
a[-2] # =&gt; "bar"
</pre> <p>If <code>index</code> is out of range, returns <code>nil</code>.</p> <p>When two <a href="integer.html"><code>Integer</code></a> arguments <code>start</code> and <code>length</code> are given, returns a new <a href="array.html"><code>Array</code></a> of size <code>length</code> containing successive elements beginning at offset <code>start</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[0, 2] # =&gt; [:foo, "bar"]
a[1, 2] # =&gt; ["bar", 2]
</pre> <p>If <code>start + length</code> is greater than <code>self.length</code>, returns all elements from offset <code>start</code> to the end:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[0, 4] # =&gt; [:foo, "bar", 2]
a[1, 3] # =&gt; ["bar", 2]
a[2, 2] # =&gt; [2]
</pre> <p>If <code>start == self.size</code> and <code>length &gt;= 0</code>, returns a new empty <a href="array.html"><code>Array</code></a>.</p> <p>If <code>length</code> is negative, returns <code>nil</code>.</p> <p>When a single <a href="range.html"><code>Range</code></a> argument <code>range</code> is given, treats <code>range.min</code> as <code>start</code> above and <code>range.size</code> as <code>length</code> above:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[0..1] # =&gt; [:foo, "bar"]
a[1..2] # =&gt; ["bar", 2]
</pre> <p>Special case: If <code>range.start == a.size</code>, returns a new empty <a href="array.html"><code>Array</code></a>.</p> <p>If <code>range.end</code> is negative, calculates the end index from the end:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[0..-1] # =&gt; [:foo, "bar", 2]
a[0..-2] # =&gt; [:foo, "bar"]
a[0..-3] # =&gt; [:foo]
</pre> <p>If <code>range.start</code> is negative, calculates the start index from the end:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[-1..2] # =&gt; [2]
a[-2..2] # =&gt; ["bar", 2]
a[-3..2] # =&gt; [:foo, "bar", 2]
</pre> <p>If <code>range.start</code> is larger than the array size, returns <code>nil</code>.</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[4..1] # =&gt; nil
a[4..0] # =&gt; nil
a[4..-1] # =&gt; nil
</pre> <p>When a single <a href="enumerator/arithmeticsequence.html"><code>Enumerator::ArithmeticSequence</code></a> argument <code>aseq</code> is given, returns an <a href="array.html"><code>Array</code></a> of elements corresponding to the indexes produced by the sequence.</p> <pre class="ruby" data-language="ruby">a = ['--', 'data1', '--', 'data2', '--', 'data3']
a[(1..).step(2)] # =&gt; ["data1", "data2", "data3"]
</pre> <p>Unlike slicing with range, if the start or the end of the arithmetic sequence is larger than array size, throws <a href="rangeerror.html"><code>RangeError</code></a>.</p> <pre class="ruby" data-language="ruby">a = ['--', 'data1', '--', 'data2', '--', 'data3']
a[(1..11).step(2)]
# RangeError (((1..11).step(2)) out of range)
a[(7..).step(2)]
# RangeError (((7..).step(2)) out of range)
</pre> <p>If given a single argument, and its type is not one of the listed, tries to convert it to <a href="integer.html"><code>Integer</code></a>, and raises if it is impossible:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
# Raises TypeError (no implicit conversion of Symbol into Integer):
a[:foo]
</pre> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Fetching">Methods for Fetching</a>.</p> </div> <div class="aliases"> Also aliased as: <a href="array.html#method-i-slice">slice</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-5B-5D-3D"> <a href="#method-i-5B-5D-3D" title="Link to this method"> <span class="method-callseq"> self[index] = object → object </span> </a> </div> <div class="method-heading"> <a href="#method-i-5B-5D-3D" title="Link to this method"> <span class="method-callseq"> self[start, length] = object → object </span> </a> </div> <div class="method-heading"> <a href="#method-i-5B-5D-3D" title="Link to this method"> <span class="method-callseq"> self[range] = object → object </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="5B-5D-3D-source"> <pre class="c" data-language="c">static VALUE
rb_ary_aset(int argc, VALUE *argv, VALUE ary)
{
    long offset, beg, len;

    rb_check_arity(argc, 2, 3);
    rb_ary_modify_check(ary);
    if (argc == 3) {
        beg = NUM2LONG(argv[0]);
        len = NUM2LONG(argv[1]);
        return ary_aset_by_rb_ary_splice(ary, beg, len, argv[2]);
    }
    if (FIXNUM_P(argv[0])) {
        offset = FIX2LONG(argv[0]);
        return ary_aset_by_rb_ary_store(ary, offset, argv[1]);
    }
    if (rb_range_beg_len(argv[0], &amp;beg, &amp;len, RARRAY_LEN(ary), 1)) {
        /* check if idx is Range */
        return ary_aset_by_rb_ary_splice(ary, beg, len, argv[1]);
    }

    offset = NUM2LONG(argv[0]);
    return ary_aset_by_rb_ary_store(ary, offset, argv[1]);
}</pre> </div>  <p>Assigns elements in <code>self</code>, based on the given <code>object</code>; returns <code>object</code>.</p> <p>In brief:</p> <pre class="ruby" data-language="ruby">a_orig = [:foo, 'bar', 2]

# With argument index.
a = a_orig.dup
a[0] = 'foo' # =&gt; "foo"
a # =&gt; ["foo", "bar", 2]
a = a_orig.dup
a[7] = 'foo' # =&gt; "foo"
a # =&gt; [:foo, "bar", 2, nil, nil, nil, nil, "foo"]

# With arguments start and length.
a = a_orig.dup
a[0, 2] = 'foo' # =&gt; "foo"
a # =&gt; ["foo", 2]
a = a_orig.dup
a[6, 50] = 'foo' # =&gt; "foo"
a # =&gt; [:foo, "bar", 2, nil, nil, nil, "foo"]

# With argument range.
a = a_orig.dup
a[0..1] = 'foo' # =&gt; "foo"
a # =&gt; ["foo", 2]
a = a_orig.dup
a[6..50] = 'foo' # =&gt; "foo"
a # =&gt; [:foo, "bar", 2, nil, nil, nil, "foo"]
</pre> <p>When <a href="integer.html"><code>Integer</code></a> argument <code>index</code> is given, assigns <code>object</code> to an element in <code>self</code>.</p> <p>If <code>index</code> is non-negative, assigns <code>object</code> the element at offset <code>index</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[0] = 'foo' # =&gt; "foo"
a # =&gt; ["foo", "bar", 2]
</pre> <p>If <code>index</code> is greater than <code>self.length</code>, extends the array:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[7] = 'foo' # =&gt; "foo"
a # =&gt; [:foo, "bar", 2, nil, nil, nil, nil, "foo"]
</pre> <p>If <code>index</code> is negative, counts backwards from the end of the array:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[-1] = 'two' # =&gt; "two"
a # =&gt; [:foo, "bar", "two"]
</pre> <p>When <a href="integer.html"><code>Integer</code></a> arguments <code>start</code> and <code>length</code> are given and <code>object</code> is not an <a href="array.html"><code>Array</code></a>, removes <code>length - 1</code> elements beginning at offset <code>start</code>, and assigns <code>object</code> at offset <code>start</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[0, 2] = 'foo' # =&gt; "foo"
a # =&gt; ["foo", 2]
</pre> <p>If <code>start</code> is negative, counts backwards from the end of the array:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[-2, 2] = 'foo' # =&gt; "foo"
a # =&gt; [:foo, "foo"]
</pre> <p>If <code>start</code> is non-negative and outside the array (<code> &gt;= self.size</code>), extends the array with <code>nil</code>, assigns <code>object</code> at offset <code>start</code>, and ignores <code>length</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[6, 50] = 'foo' # =&gt; "foo"
a # =&gt; [:foo, "bar", 2, nil, nil, nil, "foo"]
</pre> <p>If <code>length</code> is zero, shifts elements at and following offset <code>start</code> and assigns <code>object</code> at offset <code>start</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[1, 0] = 'foo' # =&gt; "foo"
a # =&gt; [:foo, "foo", "bar", 2]
</pre> <p>If <code>length</code> is too large for the existing array, does not extend the array:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[1, 5] = 'foo' # =&gt; "foo"
a # =&gt; [:foo, "foo"]
</pre> <p>When <a href="range.html"><code>Range</code></a> argument <code>range</code> is given and <code>object</code> is not an <a href="array.html"><code>Array</code></a>, removes <code>length - 1</code> elements beginning at offset <code>start</code>, and assigns <code>object</code> at offset <code>start</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[0..1] = 'foo' # =&gt; "foo"
a # =&gt; ["foo", 2]
</pre> <p>if <code>range.begin</code> is negative, counts backwards from the end of the array:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[-2..2] = 'foo' # =&gt; "foo"
a # =&gt; [:foo, "foo"]
</pre> <p>If the array length is less than <code>range.begin</code>, extends the array with <code>nil</code>, assigns <code>object</code> at offset <code>range.begin</code>, and ignores <code>length</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[6..50] = 'foo' # =&gt; "foo"
a # =&gt; [:foo, "bar", 2, nil, nil, nil, "foo"]
</pre> <p>If <code>range.end</code> is zero, shifts elements at and following offset <code>start</code> and assigns <code>object</code> at offset <code>start</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[1..0] = 'foo' # =&gt; "foo"
a # =&gt; [:foo, "foo", "bar", 2]
</pre> <p>If <code>range.end</code> is negative, assigns <code>object</code> at offset <code>start</code>, retains <code>range.end.abs -1</code> elements past that, and removes those beyond:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[1..-1] = 'foo' # =&gt; "foo"
a # =&gt; [:foo, "foo"]
a = [:foo, 'bar', 2]
a[1..-2] = 'foo' # =&gt; "foo"
a # =&gt; [:foo, "foo", 2]
a = [:foo, 'bar', 2]
a[1..-3] = 'foo' # =&gt; "foo"
a # =&gt; [:foo, "foo", "bar", 2]
a = [:foo, 'bar', 2]
</pre> <p>If <code>range.end</code> is too large for the existing array, replaces array elements, but does not extend the array with <code>nil</code> values:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[1..5] = 'foo' # =&gt; "foo"
a # =&gt; [:foo, "foo"]
</pre> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Assigning">Methods for Assigning</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-7C"> <a href="#method-i-7C" title="Link to this method"> <span class="method-callseq"> self | other_array → new_array </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="7C-source"> <pre class="c" data-language="c">static VALUE
rb_ary_or(VALUE ary1, VALUE ary2)
{
    VALUE hash;

    ary2 = to_ary(ary2);
    if (RARRAY_LEN(ary1) + RARRAY_LEN(ary2) &lt;= SMALL_ARRAY_LEN) {
        VALUE ary3 = rb_ary_new();
        rb_ary_union(ary3, ary1);
        rb_ary_union(ary3, ary2);
        return ary3;
    }

    hash = ary_make_hash(ary1);
    rb_ary_union_hash(hash, ary2);

    return rb_hash_values(hash);
}</pre> </div>  <p>Returns the union of <code>self</code> and <code>other_array</code>; duplicates are removed; order is preserved; items are compared using <code>eql?</code>:</p> <pre class="ruby" data-language="ruby">[0, 1] | [2, 3] # =&gt; [0, 1, 2, 3]
[0, 1, 1] | [2, 2, 3] # =&gt; [0, 1, 2, 3]
[0, 1, 2] | [3, 2, 1, 0] # =&gt; [0, 1, 2, 3]
</pre> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Combining">Methods for Combining</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-all-3F"> <a href="#method-i-all-3F" title="Link to this method"> <span class="method-callseq"> all? → true or false </span> </a> </div> <div class="method-heading"> <a href="#method-i-all-3F" title="Link to this method"> <span class="method-callseq"> all?(object) → true or false </span> </a> </div> <div class="method-heading"> <a href="#method-i-all-3F" title="Link to this method"> <span class="method-callseq"> all? {|element| ... } → true or false </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="all-3F-source"> <pre class="c" data-language="c">static VALUE
rb_ary_all_p(int argc, VALUE *argv, VALUE ary)
{
    long i, len = RARRAY_LEN(ary);

    rb_check_arity(argc, 0, 1);
    if (!len) return Qtrue;
    if (argc) {
        if (rb_block_given_p()) {
            rb_warn("given block not used");
        }
        for (i = 0; i &lt; RARRAY_LEN(ary); ++i) {
            if (!RTEST(rb_funcall(argv[0], idEqq, 1, RARRAY_AREF(ary, i)))) return Qfalse;
        }
    }
    else if (!rb_block_given_p()) {
        for (i = 0; i &lt; len; ++i) {
            if (!RTEST(RARRAY_AREF(ary, i))) return Qfalse;
        }
    }
    else {
        for (i = 0; i &lt; RARRAY_LEN(ary); ++i) {
            if (!RTEST(rb_yield(RARRAY_AREF(ary, i)))) return Qfalse;
        }
    }
    return Qtrue;
}</pre> </div>  <p>Returns whether for every element of <code>self</code>, a given criterion is satisfied.</p> <p>With no block and no argument, returns whether every element of <code>self</code> is truthy:</p> <pre class="ruby" data-language="ruby">[[], {}, '', 0, 0.0, Object.new].all? # =&gt; true  # All truthy objects.
[[], {}, '', 0, 0.0, nil].all?        # =&gt; false # nil is not truthy.
[[], {}, '', 0, 0.0, false].all?      # =&gt; false # false is not truthy.
</pre> <p>With argument <code>object</code> given, returns whether <code>object === ele</code> for every element <code>ele</code> in <code>self</code>:</p> <pre class="ruby" data-language="ruby">[0, 0, 0].all?(0)                    # =&gt; true
[0, 1, 2].all?(1)                    # =&gt; false
['food', 'fool', 'foot'].all?(/foo/) # =&gt; true
['food', 'drink'].all?(/foo/)        # =&gt; false
</pre> <p>With a block given, calls the block with each element in <code>self</code>; returns whether the block returns only truthy values:</p> <pre class="ruby" data-language="ruby">[0, 1, 2].all? { |ele| ele &lt; 3 } # =&gt; true
[0, 1, 2].all? { |ele| ele &lt; 2 } # =&gt; false
</pre> <p>With both a block and argument <code>object</code> given, ignores the block and uses <code>object</code> as above.</p> <p><strong>Special case</strong>: returns <code>true</code> if <code>self</code> is empty (regardless of any given argument or block).</p> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Querying">Methods for Querying</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-any-3F"> <a href="#method-i-any-3F" title="Link to this method"> <span class="method-callseq"> any? → true or false </span> </a> </div> <div class="method-heading"> <a href="#method-i-any-3F" title="Link to this method"> <span class="method-callseq"> any?(object) → true or false </span> </a> </div> <div class="method-heading"> <a href="#method-i-any-3F" title="Link to this method"> <span class="method-callseq"> any? {|element| ... } → true or false </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="any-3F-source"> <pre class="c" data-language="c">static VALUE
rb_ary_any_p(int argc, VALUE *argv, VALUE ary)
{
    long i, len = RARRAY_LEN(ary);

    rb_check_arity(argc, 0, 1);
    if (!len) return Qfalse;
    if (argc) {
        if (rb_block_given_p()) {
            rb_warn("given block not used");
        }
        for (i = 0; i &lt; RARRAY_LEN(ary); ++i) {
            if (RTEST(rb_funcall(argv[0], idEqq, 1, RARRAY_AREF(ary, i)))) return Qtrue;
        }
    }
    else if (!rb_block_given_p()) {
        for (i = 0; i &lt; len; ++i) {
            if (RTEST(RARRAY_AREF(ary, i))) return Qtrue;
        }
    }
    else {
        for (i = 0; i &lt; RARRAY_LEN(ary); ++i) {
            if (RTEST(rb_yield(RARRAY_AREF(ary, i)))) return Qtrue;
        }
    }
    return Qfalse;
}</pre> </div>  <p>Returns whether for any element of <code>self</code>, a given criterion is satisfied.</p> <p>With no block and no argument, returns whether any element of <code>self</code> is truthy:</p> <pre class="ruby" data-language="ruby">[nil, false, []].any? # =&gt; true  # Array object is truthy.
[nil, false, {}].any? # =&gt; true  # Hash object is truthy.
[nil, false, ''].any? # =&gt; true  # String object is truthy.
[nil, false].any?     # =&gt; false # Nil and false are not truthy.
</pre> <p>With argument <code>object</code> given, returns whether <code>object === ele</code> for any element <code>ele</code> in <code>self</code>:</p> <pre class="ruby" data-language="ruby">[nil, false, 0].any?(0)          # =&gt; true
[nil, false, 1].any?(0)          # =&gt; false
[nil, false, 'food'].any?(/foo/) # =&gt; true
[nil, false, 'food'].any?(/bar/) # =&gt; false
</pre> <p>With a block given, calls the block with each element in <code>self</code>; returns whether the block returns any truthy value:</p> <pre class="ruby" data-language="ruby">[0, 1, 2].any? {|ele| ele &lt; 1 } # =&gt; true
[0, 1, 2].any? {|ele| ele &lt; 0 } # =&gt; false
</pre> <p>With both a block and argument <code>object</code> given, ignores the block and uses <code>object</code> as above.</p> <p><strong>Special case</strong>: returns <code>false</code> if <code>self</code> is empty (regardless of any given argument or block).</p> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Querying">Methods for Querying</a>.</p> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-append"> <a href="#method-i-append" title="Link to this method"> <span class="method-callseq"> append(*objects) → self </span> </a> </div> </div> <div class="method-description"> <p>Appends each argument in <code>objects</code> to <code>self</code>; returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2] # =&gt; [:foo, "bar", 2]
a.push(:baz, :bat)   # =&gt; [:foo, "bar", 2, :baz, :bat]
</pre> <p>Appends each argument as a single element, even if it is another array:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]               # =&gt; [:foo, "bar", 2]
a.push([:baz, :bat], [:bam, :bad]) # =&gt; [:foo, "bar", 2, [:baz, :bat], [:bam, :bad]]
</pre> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Assigning">Methods for Assigning</a>.</p> </div> <div class="aliases"> Alias for: <a href="array.html#method-i-push">push</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-assoc"> <a href="#method-i-assoc" title="Link to this method"> <span class="method-callseq"> assoc(object) → found_array or nil </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="assoc-source"> <pre class="c" data-language="c">VALUE
rb_ary_assoc(VALUE ary, VALUE key)
{
    long i;
    VALUE v;

    for (i = 0; i &lt; RARRAY_LEN(ary); ++i) {
        v = rb_check_array_type(RARRAY_AREF(ary, i));
        if (!NIL_P(v) &amp;&amp; RARRAY_LEN(v) &gt; 0 &amp;&amp;
            rb_equal(RARRAY_AREF(v, 0), key))
            return v;
    }
    return Qnil;
}</pre> </div>  <p>Returns the first element <code>ele</code> in <code>self</code> such that <code>ele</code> is an array and <code>ele[0] == object</code>:</p> <pre class="ruby" data-language="ruby">a = [{foo: 0}, [2, 4], [4, 5, 6], [4, 5]]
a.assoc(4) # =&gt; [4, 5, 6]
</pre> <p>Returns <code>nil</code> if no such element is found.</p> <p>Related: <a href="array.html#method-i-rassoc"><code>Array#rassoc</code></a>; see also <a href="array.html#class-Array-label-Methods+for+Fetching">Methods for Fetching</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-at"> <a href="#method-i-at" title="Link to this method"> <span class="method-callseq"> at(index) → object or nil </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="at-source"> <pre class="c" data-language="c">VALUE
rb_ary_at(VALUE ary, VALUE pos)
{
    return rb_ary_entry(ary, NUM2LONG(pos));
}</pre> </div>  <p>Returns the element of <code>self</code> specified by the given <code>index</code> or <code>nil</code> if there is no such element; <code>index</code> must be an <a href="implicit_conversion_rdoc.html#label-Integer-Convertible+Objects">integer-convertible object</a>.</p> <p>For non-negative <code>index</code>, returns the element of <code>self</code> at offset <code>index</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.at(0)   # =&gt; :foo
a.at(2)   # =&gt; 2
a.at(2.0) # =&gt; 2
</pre> <p>For negative <code>index</code>, counts backwards from the end of <code>self</code>:</p> <pre class="ruby" data-language="ruby">a.at(-2) # =&gt; "bar"
</pre> <p>Related: <a href="array.html#method-i-5B-5D"><code>Array#[]</code></a>; see also <a href="array.html#class-Array-label-Methods+for+Fetching">Methods for Fetching</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-bsearch"> <a href="#method-i-bsearch" title="Link to this method"> <span class="method-callseq"> bsearch {|element| ... } → found_element or nil </span> </a> </div> <div class="method-heading"> <a href="#method-i-bsearch" title="Link to this method"> <span class="method-callseq"> bsearch → new_enumerator </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="bsearch-source"> <pre class="c" data-language="c">static VALUE
rb_ary_bsearch(VALUE ary)
{
    VALUE index_result = rb_ary_bsearch_index(ary);

    if (FIXNUM_P(index_result)) {
        return rb_ary_entry(ary, FIX2LONG(index_result));
    }
    return index_result;
}</pre> </div>  <p>Returns the element from <code>self</code> found by a binary search, or <code>nil</code> if the search found no suitable element.</p> <p>See <a href="bsearch_rdoc.html">Binary Searching</a>.</p> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Fetching">Methods for Fetching</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-bsearch_index"> <a href="#method-i-bsearch_index" title="Link to this method"> <span class="method-callseq"> bsearch_index {|element| ... } → integer or nil </span> </a> </div> <div class="method-heading"> <a href="#method-i-bsearch_index" title="Link to this method"> <span class="method-callseq"> bsearch_index → new_enumerator </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="bsearch_index-source"> <pre class="c" data-language="c">static VALUE
rb_ary_bsearch_index(VALUE ary)
{
    long low = 0, high = RARRAY_LEN(ary), mid;
    int smaller = 0, satisfied = 0;
    VALUE v, val;

    RETURN_ENUMERATOR(ary, 0, 0);
    while (low &lt; high) {
        mid = low + ((high - low) / 2);
        val = rb_ary_entry(ary, mid);
        v = rb_yield(val);
        if (FIXNUM_P(v)) {
            if (v == INT2FIX(0)) return INT2FIX(mid);
            smaller = (SIGNED_VALUE)v &lt; 0; /* Fixnum preserves its sign-bit */
        }
        else if (v == Qtrue) {
            satisfied = 1;
            smaller = 1;
        }
        else if (!RTEST(v)) {
            smaller = 0;
        }
        else if (rb_obj_is_kind_of(v, rb_cNumeric)) {
            const VALUE zero = INT2FIX(0);
            switch (rb_cmpint(rb_funcallv(v, id_cmp, 1, &amp;zero), v, zero)) {
              case 0: return INT2FIX(mid);
              case 1: smaller = 0; break;
              case -1: smaller = 1;
            }
        }
        else {
            rb_raise(rb_eTypeError, "wrong argument type %"PRIsVALUE
                     " (must be numeric, true, false or nil)",
                     rb_obj_class(v));
        }
        if (smaller) {
            high = mid;
        }
        else {
            low = mid + 1;
        }
    }
    if (!satisfied) return Qnil;
    return INT2FIX(low);
}</pre> </div>  <p>Returns the integer index of the element from <code>self</code> found by a binary search, or <code>nil</code> if the search found no suitable element.</p> <p>See <a href="bsearch_rdoc.html">Binary Searching</a>.</p> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Fetching">Methods for Fetching</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-clear"> <a href="#method-i-clear" title="Link to this method"> <span class="method-callseq"> clear → self </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="clear-source"> <pre class="c" data-language="c">VALUE
rb_ary_clear(VALUE ary)
{
    rb_ary_modify_check(ary);
    if (ARY_SHARED_P(ary)) {
        rb_ary_unshare(ary);
        FL_SET_EMBED(ary);
        ARY_SET_EMBED_LEN(ary, 0);
    }
    else {
        ARY_SET_LEN(ary, 0);
        if (ARY_DEFAULT_SIZE * 2 &lt; ARY_CAPA(ary)) {
            ary_resize_capa(ary, ARY_DEFAULT_SIZE * 2);
        }
    }
    ary_verify(ary);
    return ary;
}</pre> </div>  <p>Removes all elements from <code>self</code>; returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.clear # =&gt; []
</pre> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Deleting">Methods for Deleting</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-collect"> <a href="#method-i-collect" title="Link to this method"> <span class="method-callseq"> collect {|element| ... } → new_array </span> </a> </div> <div class="method-heading"> <a href="#method-i-collect" title="Link to this method"> <span class="method-callseq"> collect → new_enumerator </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="collect-source"> <pre class="c" data-language="c">static VALUE
rb_ary_collect(VALUE ary)
{
    long i;
    VALUE collect;

    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);
    collect = rb_ary_new2(RARRAY_LEN(ary));
    for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
        rb_ary_push(collect, rb_yield(RARRAY_AREF(ary, i)));
    }
    return collect;
}</pre> </div>  <p>With a block given, calls the block with each element of <code>self</code>; returns a new array whose elements are the return values from the block:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a1 = a.map {|element| element.class }
a1 # =&gt; [Symbol, String, Integer]
</pre> <p>With no block given, returns a new <a href="enumerator.html"><code>Enumerator</code></a>.</p> <p>Related: <a href="array.html#method-i-collect-21"><code>collect!</code></a>; see also <a href="array.html#class-Array-label-Methods+for+Converting">Methods for Converting</a>.</p> </div> <div class="aliases"> Also aliased as: <a href="array.html#method-i-map">map</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-collect-21"> <a href="#method-i-collect-21" title="Link to this method"> <span class="method-callseq"> collect! {|element| ... } → new_array </span> </a> </div> <div class="method-heading"> <a href="#method-i-collect-21" title="Link to this method"> <span class="method-callseq"> collect! → new_enumerator </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="collect-21-source"> <pre class="c" data-language="c">static VALUE
rb_ary_collect_bang(VALUE ary)
{
    long i;

    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);
    rb_ary_modify(ary);
    for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
        rb_ary_store(ary, i, rb_yield(RARRAY_AREF(ary, i)));
    }
    return ary;
}</pre> </div>  <p>With a block given, calls the block with each element of <code>self</code> and replaces the element with the block’s return value; returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.map! { |element| element.class } # =&gt; [Symbol, String, Integer]
</pre> <p>With no block given, returns a new <a href="enumerator.html"><code>Enumerator</code></a>.</p> <p>Related: <a href="array.html#method-i-collect"><code>collect</code></a>; see also <a href="array.html#class-Array-label-Methods+for+Converting">Methods for Converting</a>.</p> </div> <div class="aliases"> Also aliased as: <a href="array.html#method-i-map-21">map!</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-combination"> <a href="#method-i-combination" title="Link to this method"> <span class="method-callseq"> combination(count) {|element| ... } → self </span> </a> </div> <div class="method-heading"> <a href="#method-i-combination" title="Link to this method"> <span class="method-callseq"> combination(count) → new_enumerator </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="combination-source"> <pre class="c" data-language="c">static VALUE
rb_ary_combination(VALUE ary, VALUE num)
{
    long i, n, len;

    n = NUM2LONG(num);
    RETURN_SIZED_ENUMERATOR(ary, 1, &amp;num, rb_ary_combination_size);
    len = RARRAY_LEN(ary);
    if (n &lt; 0 || len &lt; n) {
        /* yield nothing */
    }
    else if (n == 0) {
        rb_yield(rb_ary_new2(0));
    }
    else if (n == 1) {
        for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
            rb_yield(rb_ary_new3(1, RARRAY_AREF(ary, i)));
        }
    }
    else {
        VALUE ary0 = ary_make_shared_copy(ary); /* private defensive copy of ary */
        volatile VALUE t0;
        long *stack = ALLOCV_N(long, t0, n+1);

        RBASIC_CLEAR_CLASS(ary0);
        combinate0(len, n, stack, ary0);
        ALLOCV_END(t0);
        RBASIC_SET_CLASS_RAW(ary0, rb_cArray);
    }
    return ary;
}</pre> </div>  <p>When a block and a positive <a href="implicit_conversion_rdoc.html#label-Integer-Convertible+Objects">integer-convertible object</a> argument <code>count</code> (<code>0 &lt; count &lt;= self.size</code>) are given, calls the block with each combination of <code>self</code> of size <code>count</code>; returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">a = %w[a b c]                                   # =&gt; ["a", "b", "c"]
a.combination(2) {|combination| p combination } # =&gt; ["a", "b", "c"]
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">["a", "b"]
["a", "c"]
["b", "c"]
</pre> <p>The order of the yielded combinations is not guaranteed.</p> <p>When <code>count</code> is zero, calls the block once with a new empty array:</p> <pre class="ruby" data-language="ruby">a.combination(0) {|combination| p combination }
[].combination(0) {|combination| p combination }
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">[]
[]
</pre> <p>When <code>count</code> is negative or larger than <code>self.size</code> and <code>self</code> is non-empty, does not call the block:</p> <pre class="ruby" data-language="ruby">a.combination(-1) {|combination| fail 'Cannot happen' } # =&gt; ["a", "b", "c"]
a.combination(4)  {|combination| fail 'Cannot happen' } # =&gt; ["a", "b", "c"]
</pre> <p>With no block given, returns a new <a href="enumerator.html"><code>Enumerator</code></a>.</p> <p>Related: <a href="array.html#method-i-permutation"><code>Array#permutation</code></a>; see also <a href="array.html#class-Array-label-Methods+for+Iterating">Methods for Iterating</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-compact"> <a href="#method-i-compact" title="Link to this method"> <span class="method-callseq"> compact → new_array </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="compact-source"> <pre class="c" data-language="c">static VALUE
rb_ary_compact(VALUE ary)
{
    ary = rb_ary_dup(ary);
    rb_ary_compact_bang(ary);
    return ary;
}</pre> </div>  <p>Returns a new array containing only the non-<code>nil</code> elements from <code>self</code>; element order is preserved:</p> <pre class="ruby" data-language="ruby">a = [nil, 0, nil, false, nil, '', nil, [], nil, {}]
a.compact # =&gt; [0, false, "", [], {}]
</pre> <p>Related: <a href="array.html#method-i-compact-21"><code>Array#compact!</code></a>; see also <a href="array.html#class-Array-label-Methods+for+Deleting">Methods for Deleting</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-compact-21"> <a href="#method-i-compact-21" title="Link to this method"> <span class="method-callseq"> compact! → self or nil </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="compact-21-source"> <pre class="c" data-language="c">static VALUE
rb_ary_compact_bang(VALUE ary)
{
    VALUE *p, *t, *end;
    long n;

    rb_ary_modify(ary);
    p = t = (VALUE *)RARRAY_CONST_PTR(ary); /* WB: no new reference */
    end = p + RARRAY_LEN(ary);

    while (t &lt; end) {
        if (NIL_P(*t)) t++;
        else *p++ = *t++;
    }
    n = p - RARRAY_CONST_PTR(ary);
    if (RARRAY_LEN(ary) == n) {
        return Qnil;
    }
    ary_resize_smaller(ary, n);

    return ary;
}</pre> </div>  <p>Removes all <code>nil</code> elements from <code>self</code>; Returns <code>self</code> if any elements are removed, <code>nil</code> otherwise:</p> <pre class="ruby" data-language="ruby">a = [nil, 0, nil, false, nil, '', nil, [], nil, {}]
a.compact! # =&gt; [0, false, "", [], {}]
a          # =&gt; [0, false, "", [], {}]
a.compact! # =&gt; nil
</pre> <p>Related: <a href="array.html#method-i-compact"><code>Array#compact</code></a>; see also <a href="array.html#class-Array-label-Methods+for+Deleting">Methods for Deleting</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-concat"> <a href="#method-i-concat" title="Link to this method"> <span class="method-callseq"> concat(*other_arrays) → self </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="concat-source"> <pre class="c" data-language="c">static VALUE
rb_ary_concat_multi(int argc, VALUE *argv, VALUE ary)
{
    rb_ary_modify_check(ary);

    if (argc == 1) {
        rb_ary_concat(ary, argv[0]);
    }
    else if (argc &gt; 1) {
        int i;
        VALUE args = rb_ary_hidden_new(argc);
        for (i = 0; i &lt; argc; i++) {
            rb_ary_concat(args, argv[i]);
        }
        ary_append(ary, args);
    }

    ary_verify(ary);
    return ary;
}</pre> </div>  <p>Adds to <code>self</code> all elements from each array in <code>other_arrays</code>; returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">a = [0, 1]
a.concat(['two', 'three'], [:four, :five], a)
# =&gt; [0, 1, "two", "three", :four, :five, 0, 1]
</pre> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Assigning">Methods for Assigning</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-count"> <a href="#method-i-count" title="Link to this method"> <span class="method-callseq"> count → integer </span> </a> </div> <div class="method-heading"> <a href="#method-i-count" title="Link to this method"> <span class="method-callseq"> count(object) → integer </span> </a> </div> <div class="method-heading"> <a href="#method-i-count" title="Link to this method"> <span class="method-callseq"> count {|element| ... } → integer </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="count-source"> <pre class="c" data-language="c">static VALUE
rb_ary_count(int argc, VALUE *argv, VALUE ary)
{
    long i, n = 0;

    if (rb_check_arity(argc, 0, 1) == 0) {
        VALUE v;

        if (!rb_block_given_p())
            return LONG2NUM(RARRAY_LEN(ary));

        for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
            v = RARRAY_AREF(ary, i);
            if (RTEST(rb_yield(v))) n++;
        }
    }
    else {
        VALUE obj = argv[0];

        if (rb_block_given_p()) {
            rb_warn("given block not used");
        }
        for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
            if (rb_equal(RARRAY_AREF(ary, i), obj)) n++;
        }
    }

    return LONG2NUM(n);
}</pre> </div>  <p>Returns a count of specified elements.</p> <p>With no argument and no block, returns the count of all elements:</p> <pre class="ruby" data-language="ruby">[0, :one, 'two', 3, 3.0].count # =&gt; 5
</pre> <p>With argument <code>object</code> given, returns the count of elements <code>==</code> to <code>object</code>:</p> <pre class="ruby" data-language="ruby">[0, :one, 'two', 3, 3.0].count(3) # =&gt; 2
</pre> <p>With no argument and a block given, calls the block with each element; returns the count of elements for which the block returns a truthy value:</p> <pre class="ruby" data-language="ruby">[0, 1, 2, 3].count {|element| element &gt; 1 } # =&gt; 2
</pre> <p>With argument <code>object</code> and a block given, issues a warning, ignores the block, and returns the count of elements <code>==</code> to <code>object</code>.</p> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Querying">Methods for Querying</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-cycle"> <a href="#method-i-cycle" title="Link to this method"> <span class="method-callseq"> cycle(count = nil) {|element| ... } → nil </span> </a> </div> <div class="method-heading"> <a href="#method-i-cycle" title="Link to this method"> <span class="method-callseq"> cycle(count = nil) → new_enumerator </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="cycle-source"> <pre class="c" data-language="c">static VALUE
rb_ary_cycle(int argc, VALUE *argv, VALUE ary)
{
    long n, i;

    rb_check_arity(argc, 0, 1);

    RETURN_SIZED_ENUMERATOR(ary, argc, argv, rb_ary_cycle_size);
    if (argc == 0 || NIL_P(argv[0])) {
        n = -1;
    }
    else {
        n = NUM2LONG(argv[0]);
        if (n &lt;= 0) return Qnil;
    }

    while (RARRAY_LEN(ary) &gt; 0 &amp;&amp; (n &lt; 0 || 0 &lt; n--)) {
        for (i=0; i&lt;RARRAY_LEN(ary); i++) {
            rb_yield(RARRAY_AREF(ary, i));
        }
    }
    return Qnil;
}</pre> </div>  <p>With a block given, may call the block, depending on the value of argument <code>count</code>; <code>count</code> must be an <a href="implicit_conversion_rdoc.html#label-Integer-Convertible+Objects">integer-convertible object</a>, or <code>nil</code>.</p> <p>When <code>count</code> is positive, calls the block with each element, then does so repeatedly, until it has done so <code>count</code> times; returns <code>nil</code>:</p> <pre class="ruby" data-language="ruby">output = []
[0, 1].cycle(2) {|element| output.push(element) } # =&gt; nil
output # =&gt; [0, 1, 0, 1]
</pre> <p>When <code>count</code> is zero or negative, does not call the block:</p> <pre class="ruby" data-language="ruby">[0, 1].cycle(0) {|element| fail 'Cannot happen' }  # =&gt; nil
[0, 1].cycle(-1) {|element| fail 'Cannot happen' } # =&gt; nil
</pre> <p>When <code>count</code> is <code>nil</code>, cycles forever:</p> <pre class="ruby" data-language="ruby"># Prints 0 and 1 forever.
[0, 1].cycle {|element| puts element }
[0, 1].cycle(nil) {|element| puts element }
</pre> <p>With no block given, returns a new <a href="enumerator.html"><code>Enumerator</code></a>.</p> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Iterating">Methods for Iterating</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-delete"> <a href="#method-i-delete" title="Link to this method"> <span class="method-callseq"> delete(object) → last_removed_object </span> </a> </div> <div class="method-heading"> <a href="#method-i-delete" title="Link to this method"> <span class="method-callseq"> delete(object) {|element| ... } → last_removed_object or block_return </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="delete-source"> <pre class="c" data-language="c">VALUE
rb_ary_delete(VALUE ary, VALUE item)
{
    VALUE v = item;
    long i1, i2;

    for (i1 = i2 = 0; i1 &lt; RARRAY_LEN(ary); i1++) {
        VALUE e = RARRAY_AREF(ary, i1);

        if (rb_equal(e, item)) {
            v = e;
            continue;
        }
        if (i1 != i2) {
            rb_ary_store(ary, i2, e);
        }
        i2++;
    }
    if (RARRAY_LEN(ary) == i2) {
        if (rb_block_given_p()) {
            return rb_yield(item);
        }
        return Qnil;
    }

    ary_resize_smaller(ary, i2);

    ary_verify(ary);
    return v;
}</pre> </div>  <p>Removes zero or more elements from <code>self</code>.</p> <p>With no block given, removes from <code>self</code> each element <code>ele</code> such that <code>ele == object</code>; returns the last removed element:</p> <pre class="ruby" data-language="ruby">a = [0, 1, 2, 2.0]
a.delete(2) # =&gt; 2.0
a           # =&gt; [0, 1]
</pre> <p>Returns <code>nil</code> if no elements removed:</p> <pre class="ruby" data-language="ruby">a.delete(2) # =&gt; nil
</pre> <p>With a block given, removes from <code>self</code> each element <code>ele</code> such that <code>ele == object</code>.</p> <p>If any such elements are found, ignores the block and returns the last removed element:</p> <pre class="ruby" data-language="ruby">a = [0, 1, 2, 2.0]
a.delete(2) {|element| fail 'Cannot happen' } # =&gt; 2.0
a                                             # =&gt; [0, 1]
</pre> <p>If no such element is found, returns the block’s return value:</p> <pre class="ruby" data-language="ruby">a.delete(2) {|element| "Element #{element} not found." }
# =&gt; "Element 2 not found."
</pre> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Deleting">Methods for Deleting</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-delete_at"> <a href="#method-i-delete_at" title="Link to this method"> <span class="method-callseq"> delete_at(index) → removed_object or nil </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="delete_at-source"> <pre class="c" data-language="c">static VALUE
rb_ary_delete_at_m(VALUE ary, VALUE pos)
{
    return rb_ary_delete_at(ary, NUM2LONG(pos));
}</pre> </div>  <p>Removes the element of <code>self</code> at the given <code>index</code>, which must be an <a href="implicit_conversion_rdoc.html#label-Integer-Convertible+Objects">integer-convertible object</a>.</p> <p>When <code>index</code> is non-negative, deletes the element at offset <code>index</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.delete_at(1) # =&gt; "bar"
a # =&gt; [:foo, 2]
</pre> <p>When <code>index</code> is negative, counts backward from the end of the array:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.delete_at(-2) # =&gt; "bar"
a # =&gt; [:foo, 2]
</pre> <p>When <code>index</code> is out of range, returns <code>nil</code>.</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.delete_at(3)  # =&gt; nil
a.delete_at(-4) # =&gt; nil
</pre> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Deleting">Methods for Deleting</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-delete_if"> <a href="#method-i-delete_if" title="Link to this method"> <span class="method-callseq"> delete_if {|element| ... } → self </span> </a> </div> <div class="method-heading"> <a href="#method-i-delete_if" title="Link to this method"> <span class="method-callseq"> delete_if → new_numerator </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="delete_if-source"> <pre class="c" data-language="c">static VALUE
rb_ary_delete_if(VALUE ary)
{
    ary_verify(ary);
    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);
    ary_reject_bang(ary);
    return ary;
}</pre> </div>  <p>With a block given, calls the block with each element of <code>self</code>; removes the element if the block returns a truthy value; returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2, 'bat']
a.delete_if {|element| element.to_s.start_with?('b') } # =&gt; [:foo, 2]
</pre> <p>With no block given, returns a new <a href="enumerator.html"><code>Enumerator</code></a>.</p> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Deleting">Methods for Deleting</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-difference"> <a href="#method-i-difference" title="Link to this method"> <span class="method-callseq"> difference(*other_arrays = []) → new_array </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="difference-source"> <pre class="c" data-language="c">static VALUE
rb_ary_difference_multi(int argc, VALUE *argv, VALUE ary)
{
    VALUE ary_diff;
    long i, length;
    volatile VALUE t0;
    bool *is_hash = ALLOCV_N(bool, t0, argc);
    ary_diff = rb_ary_new();
    length = RARRAY_LEN(ary);

    for (i = 0; i &lt; argc; i++) {
        argv[i] = to_ary(argv[i]);
        is_hash[i] = (length &gt; SMALL_ARRAY_LEN &amp;&amp; RARRAY_LEN(argv[i]) &gt; SMALL_ARRAY_LEN);
        if (is_hash[i]) argv[i] = ary_make_hash(argv[i]);
    }

    for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
        int j;
        VALUE elt = rb_ary_elt(ary, i);
        for (j = 0; j &lt; argc; j++) {
            if (is_hash[j]) {
                if (rb_hash_stlike_lookup(argv[j], RARRAY_AREF(ary, i), NULL))
                    break;
            }
            else {
                if (rb_ary_includes_by_eql(argv[j], elt)) break;
            }
        }
        if (j == argc) rb_ary_push(ary_diff, elt);
    }

    ALLOCV_END(t0);

    return ary_diff;
}</pre> </div>  <p>Returns a new array containing only those elements from <code>self</code> that are not found in any of the given <code>other_arrays</code>; items are compared using <code>eql?</code>; order from <code>self</code> is preserved:</p> <pre class="ruby" data-language="ruby">[0, 1, 1, 2, 1, 1, 3, 1, 1].difference([1]) # =&gt; [0, 2, 3]
[0, 1, 2, 3].difference([3, 0], [1, 3])     # =&gt; [2]
[0, 1, 2].difference([4])                   # =&gt; [0, 1, 2]
[0, 1, 2].difference                        # =&gt; [0, 1, 2]
</pre> <p>Returns a copy of <code>self</code> if no arguments are given.</p> <p>Related: <a href="array.html#method-i-2D"><code>Array#-</code></a>; see also <a href="array.html#class-Array-label-Methods+for+Combining">Methods for Combining</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-dig"> <a href="#method-i-dig" title="Link to this method"> <span class="method-callseq"> dig(index, *identifiers) → object </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="dig-source"> <pre class="c" data-language="c">static VALUE
rb_ary_dig(int argc, VALUE *argv, VALUE self)
{
    rb_check_arity(argc, 1, UNLIMITED_ARGUMENTS);
    self = rb_ary_at(self, *argv);
    if (!--argc) return self;
    ++argv;
    return rb_obj_dig(argc, argv, self, Qnil);
}</pre> </div>  <p>Finds and returns the object in nested object specified by <code>index</code> and <code>identifiers</code>; the nested objects may be instances of various classes. See <a href="dig_methods_rdoc.html">Dig Methods</a>.</p> <p>Examples:</p> <pre class="ruby" data-language="ruby">a = [:foo, [:bar, :baz, [:bat, :bam]]]
a.dig(1) # =&gt; [:bar, :baz, [:bat, :bam]]
a.dig(1, 2) # =&gt; [:bat, :bam]
a.dig(1, 2, 0) # =&gt; :bat
a.dig(1, 2, 3) # =&gt; nil
</pre> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Fetching">Methods for Fetching</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-drop"> <a href="#method-i-drop" title="Link to this method"> <span class="method-callseq"> drop(count) → new_array </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="drop-source"> <pre class="c" data-language="c">static VALUE
rb_ary_drop(VALUE ary, VALUE n)
{
    VALUE result;
    long pos = NUM2LONG(n);
    if (pos &lt; 0) {
        rb_raise(rb_eArgError, "attempt to drop negative size");
    }

    result = rb_ary_subseq(ary, pos, RARRAY_LEN(ary));
    if (NIL_P(result)) result = rb_ary_new();
    return result;
}</pre> </div>  <p>Returns a new array containing all but the first <code>count</code> element of <code>self</code>, where <code>count</code> is a non-negative integer; does not modify <code>self</code>.</p> <p>Examples:</p> <pre class="ruby" data-language="ruby">a = [0, 1, 2, 3, 4, 5]
a.drop(0) # =&gt; [0, 1, 2, 3, 4, 5]
a.drop(1) # =&gt; [1, 2, 3, 4, 5]
a.drop(2) # =&gt; [2, 3, 4, 5]
a.drop(9) # =&gt; []
</pre> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Fetching">Methods for Fetching</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-drop_while"> <a href="#method-i-drop_while" title="Link to this method"> <span class="method-callseq"> drop_while {|element| ... } → new_array </span> </a> </div> <div class="method-heading"> <a href="#method-i-drop_while" title="Link to this method"> <span class="method-callseq"> drop_while → new_enumerator </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="drop_while-source"> <pre class="c" data-language="c">static VALUE
rb_ary_drop_while(VALUE ary)
{
    long i;

    RETURN_ENUMERATOR(ary, 0, 0);
    for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
        if (!RTEST(rb_yield(RARRAY_AREF(ary, i)))) break;
    }
    return rb_ary_drop(ary, LONG2FIX(i));
}</pre> </div>  <p>With a block given, calls the block with each successive element of <code>self</code>; stops if the block returns <code>false</code> or <code>nil</code>; returns a new array <em>omitting</em> those elements for which the block returned a truthy value; does not modify <code>self</code>:</p> <pre class="ruby" data-language="ruby">a = [0, 1, 2, 3, 4, 5]
a.drop_while {|element| element &lt; 3 } # =&gt; [3, 4, 5]
</pre> <p>With no block given, returns a new <a href="enumerator.html"><code>Enumerator</code></a>.</p> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Fetching">Methods for Fetching</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-each"> <a href="#method-i-each" title="Link to this method"> <span class="method-callseq"> each {|element| ... } → self </span> </a> </div> <div class="method-heading"> <a href="#method-i-each" title="Link to this method"> <span class="method-callseq"> each → new_enumerator </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="each-source"> <pre class="c" data-language="c">VALUE
rb_ary_each(VALUE ary)
{
    long i;
    ary_verify(ary);
    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);
    for (i=0; i&lt;RARRAY_LEN(ary); i++) {
        rb_yield(RARRAY_AREF(ary, i));
    }
    return ary;
}</pre> </div>  <p>With a block given, iterates over the elements of <code>self</code>, passing each element to the block; returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.each {|element|  puts "#{element.class} #{element}" }
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">Symbol foo
String bar
Integer 2
</pre> <p>Allows the array to be modified during iteration:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.each {|element| puts element; a.clear if element.to_s.start_with?('b') }
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">foo
bar
</pre> <p>With no block given, returns a new <a href="enumerator.html"><code>Enumerator</code></a>.</p> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Iterating">Methods for Iterating</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-each_index"> <a href="#method-i-each_index" title="Link to this method"> <span class="method-callseq"> each_index {|index| ... } → self </span> </a> </div> <div class="method-heading"> <a href="#method-i-each_index" title="Link to this method"> <span class="method-callseq"> each_index → new_enumerator </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="each_index-source"> <pre class="c" data-language="c">static VALUE
rb_ary_each_index(VALUE ary)
{
    long i;
    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);

    for (i=0; i&lt;RARRAY_LEN(ary); i++) {
        rb_yield(LONG2NUM(i));
    }
    return ary;
}</pre> </div>  <p>With a block given, iterates over the elements of <code>self</code>, passing each <em>array index</em> to the block; returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.each_index {|index|  puts "#{index} #{a[index]}" }
</pre> <p>Output:</p> <pre>0 foo
1 bar
2 2</pre> <p>Allows the array to be modified during iteration:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.each_index {|index| puts index; a.clear if index &gt; 0 }
a # =&gt; []
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">0
1
</pre> <p>With no block given, returns a new <a href="enumerator.html"><code>Enumerator</code></a>.</p> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Iterating">Methods for Iterating</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-empty-3F"> <a href="#method-i-empty-3F" title="Link to this method"> <span class="method-callseq"> empty? → true or false </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="empty-3F-source"> <pre class="c" data-language="c">static VALUE
rb_ary_empty_p(VALUE ary)
{
    return RBOOL(RARRAY_LEN(ary) == 0);
}</pre> </div>  <p>Returns <code>true</code> if the count of elements in <code>self</code> is zero, <code>false</code> otherwise.</p> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Querying">Methods for Querying</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-eql-3F"> <a href="#method-i-eql-3F" title="Link to this method"> <span class="method-callseq"> eql?(other_array) → true or false </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="eql-3F-source"> <pre class="c" data-language="c">static VALUE
rb_ary_eql(VALUE ary1, VALUE ary2)
{
    if (ary1 == ary2) return Qtrue;
    if (!RB_TYPE_P(ary2, T_ARRAY)) return Qfalse;
    if (RARRAY_LEN(ary1) != RARRAY_LEN(ary2)) return Qfalse;
    if (RARRAY_CONST_PTR(ary1) == RARRAY_CONST_PTR(ary2)) return Qtrue;
    return rb_exec_recursive_paired(recursive_eql, ary1, ary2, ary2);
}</pre> </div>  <p>Returns <code>true</code> if <code>self</code> and <code>other_array</code> are the same size, and if, for each index <code>i</code> in <code>self</code>, <code>self[i].eql?(other_array[i])</code>:</p> <pre class="ruby" data-language="ruby">a0 = [:foo, 'bar', 2]
a1 = [:foo, 'bar', 2]
a1.eql?(a0) # =&gt; true
</pre> <p>Otherwise, returns <code>false</code>.</p> <p>This method is different from method <a href="array.html#method-i-3D-3D"><code>Array#==</code></a>, which compares using method <a href="basicobject.html#method-i-3D-3D"><code>Object#==</code></a>.</p> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Querying">Methods for Querying</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-fetch"> <a href="#method-i-fetch" title="Link to this method"> <span class="method-callseq"> fetch(index) → element </span> </a> </div> <div class="method-heading"> <a href="#method-i-fetch" title="Link to this method"> <span class="method-callseq"> fetch(index, default_value) → element or default_value </span> </a> </div> <div class="method-heading"> <a href="#method-i-fetch" title="Link to this method"> <span class="method-callseq"> fetch(index) {|index| ... } → element or block_return_value </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="fetch-source"> <pre class="c" data-language="c">static VALUE
rb_ary_fetch(int argc, VALUE *argv, VALUE ary)
{
    VALUE pos, ifnone;
    long block_given;
    long idx;

    rb_scan_args(argc, argv, "11", &amp;pos, &amp;ifnone);
    block_given = rb_block_given_p();
    if (block_given &amp;&amp; argc == 2) {
        rb_warn("block supersedes default value argument");
    }
    idx = NUM2LONG(pos);

    if (idx &lt; 0) {
        idx +=  RARRAY_LEN(ary);
    }
    if (idx &lt; 0 || RARRAY_LEN(ary) &lt;= idx) {
        if (block_given) return rb_yield(pos);
        if (argc == 1) {
            rb_raise(rb_eIndexError, "index %ld outside of array bounds: %ld...%ld",
                        idx - (idx &lt; 0 ? RARRAY_LEN(ary) : 0), -RARRAY_LEN(ary), RARRAY_LEN(ary));
        }
        return ifnone;
    }
    return RARRAY_AREF(ary, idx);
}</pre> </div>  <p>Returns the element of <code>self</code> at offset <code>index</code> if <code>index</code> is in range; <code>index</code> must be an <a href="implicit_conversion_rdoc.html#label-Integer-Convertible+Objects">integer-convertible object</a>.</p> <p>With the single argument <code>index</code> and no block, returns the element at offset <code>index</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.fetch(1)   # =&gt; "bar"
a.fetch(1.1) # =&gt; "bar"
</pre> <p>If <code>index</code> is negative, counts from the end of the array:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.fetch(-1) # =&gt; 2
a.fetch(-2) # =&gt; "bar"
</pre> <p>With arguments <code>index</code> and <code>default_value</code> (which may be any object) and no block, returns <code>default_value</code> if <code>index</code> is out-of-range:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.fetch(1, nil)  # =&gt; "bar"
a.fetch(3, :foo) # =&gt; :foo
</pre> <p>With argument <code>index</code> and a block, returns the element at offset <code>index</code> if index is in range (and the block is not called); otherwise calls the block with index and returns its return value:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.fetch(1) {|index| raise 'Cannot happen' } # =&gt; "bar"
a.fetch(50) {|index| "Value for #{index}" } # =&gt; "Value for 50"
</pre> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Fetching">Methods for Fetching</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-fetch_values"> <a href="#method-i-fetch_values" title="Link to this method"> <span class="method-callseq"> fetch_values(*indexes) → new_array </span> </a> </div> <div class="method-heading"> <a href="#method-i-fetch_values" title="Link to this method"> <span class="method-callseq"> fetch_values(*indexes) { |index| ... } → new_array </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="fetch_values-source"> <pre class="ruby" data-language="ruby"># File array.rb, line 210
def fetch_values(*indexes, &amp;block)
  indexes.map! { |i| fetch(i, &amp;block) }
  indexes
end</pre> </div>  <p>With no block given, returns a new array containing the elements of <code>self</code> at the offsets specified by <code>indexes</code>. Each of the <code>indexes</code> must be an <a href="implicit_conversion_rdoc.html#label-Integer-Convertible+Objects">integer-convertible object</a>:</p> <pre class="ruby" data-language="ruby">a = [:foo, :bar, :baz]
a.fetch_values(2, 0)   # =&gt; [:baz, :foo]
a.fetch_values(2.1, 0) # =&gt; [:baz, :foo]
a.fetch_values         # =&gt; []
</pre> <p>For a negative index, counts backwards from the end of the array:</p> <pre class="ruby" data-language="ruby">a.fetch_values(-2, -1) # [:bar, :baz]
</pre> <p>When no block is given, raises an exception if any index is out of range.</p> <p>With a block given, for each index:</p> <ul>
<li> <p>If the index is in range, uses an element of <code>self</code> (as above).</p> </li>
<li> <p>Otherwise, calls the block with the index and uses the block’s return value.</p> </li>
</ul> <p>Example:</p> <pre class="ruby" data-language="ruby">a = [:foo, :bar, :baz]
a.fetch_values(1, 0, 42, 777) { |index| index.to_s }
# =&gt; [:bar, :foo, "42", "777"]
</pre> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Fetching">Methods for Fetching</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-fill"> <a href="#method-i-fill" title="Link to this method"> <span class="method-callseq"> fill(object, start = nil, count = nil) → new_array </span> </a> </div> <div class="method-heading"> <a href="#method-i-fill" title="Link to this method"> <span class="method-callseq"> fill(object, range) → new_array </span> </a> </div> <div class="method-heading"> <a href="#method-i-fill" title="Link to this method"> <span class="method-callseq"> fill(start = nil, count = nil) {|element| ... } → new_array </span> </a> </div> <div class="method-heading"> <a href="#method-i-fill" title="Link to this method"> <span class="method-callseq"> fill(range) {|element| ... } → new_array </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="fill-source"> <pre class="c" data-language="c">static VALUE
rb_ary_fill(int argc, VALUE *argv, VALUE ary)
{
    VALUE item = Qundef, arg1, arg2;
    long beg = 0, end = 0, len = 0;

    if (rb_block_given_p()) {
        rb_scan_args(argc, argv, "02", &amp;arg1, &amp;arg2);
        argc += 1;              /* hackish */
    }
    else {
        rb_scan_args(argc, argv, "12", &amp;item, &amp;arg1, &amp;arg2);
    }
    switch (argc) {
      case 1:
        beg = 0;
        len = RARRAY_LEN(ary);
        break;
      case 2:
        if (rb_range_beg_len(arg1, &amp;beg, &amp;len, RARRAY_LEN(ary), 1)) {
            break;
        }
        /* fall through */
      case 3:
        beg = NIL_P(arg1) ? 0 : NUM2LONG(arg1);
        if (beg &lt; 0) {
            beg = RARRAY_LEN(ary) + beg;
            if (beg &lt; 0) beg = 0;
        }
        len = NIL_P(arg2) ? RARRAY_LEN(ary) - beg : NUM2LONG(arg2);
        break;
    }
    rb_ary_modify(ary);
    if (len &lt; 0) {
        return ary;
    }
    if (beg &gt;= ARY_MAX_SIZE || len &gt; ARY_MAX_SIZE - beg) {
        rb_raise(rb_eArgError, "argument too big");
    }
    end = beg + len;
    if (RARRAY_LEN(ary) &lt; end) {
        if (end &gt;= ARY_CAPA(ary)) {
            ary_resize_capa(ary, end);
        }
        ary_mem_clear(ary, RARRAY_LEN(ary), end - RARRAY_LEN(ary));
        ARY_SET_LEN(ary, end);
    }

    if (UNDEF_P(item)) {
        VALUE v;
        long i;

        for (i=beg; i&lt;end; i++) {
            v = rb_yield(LONG2NUM(i));
            if (i&gt;=RARRAY_LEN(ary)) break;
            ARY_SET(ary, i, v);
        }
    }
    else {
        ary_memfill(ary, beg, len, item);
    }
    return ary;
}</pre> </div>  <p>Replaces selected elements in <code>self</code>; may add elements to <code>self</code>; always returns <code>self</code> (never a new array).</p> <p>In brief:</p> <pre class="ruby" data-language="ruby"># Non-negative start.
['a', 'b', 'c', 'd'].fill('-', 1, 2)          # =&gt; ["a", "-", "-", "d"]
['a', 'b', 'c', 'd'].fill(1, 2) {|e| e.to_s } # =&gt; ["a", "1", "2", "d"]

# Extends with specified values if necessary.
['a', 'b', 'c', 'd'].fill('-', 3, 2)          # =&gt; ["a", "b", "c", "-", "-"]
['a', 'b', 'c', 'd'].fill(3, 2) {|e| e.to_s } # =&gt; ["a", "b", "c", "3", "4"]

# Fills with nils if necessary.
['a', 'b', 'c', 'd'].fill('-', 6, 2)          # =&gt; ["a", "b", "c", "d", nil, nil, "-", "-"]
['a', 'b', 'c', 'd'].fill(6, 2) {|e| e.to_s } # =&gt; ["a", "b", "c", "d", nil, nil, "6", "7"]

# For negative start, counts backwards from the end.
['a', 'b', 'c', 'd'].fill('-', -3, 3)          # =&gt; ["a", "-", "-", "-"]
['a', 'b', 'c', 'd'].fill(-3, 3) {|e| e.to_s } # =&gt; ["a", "1", "2", "3"]

# Range.
['a', 'b', 'c', 'd'].fill('-', 1..2)          # =&gt; ["a", "-", "-", "d"]
['a', 'b', 'c', 'd'].fill(1..2) {|e| e.to_s } # =&gt; ["a", "1", "2", "d"]
</pre> <p>When arguments <code>start</code> and <code>count</code> are given, they select the elements of <code>self</code> to be replaced; each must be an <a href="implicit_conversion_rdoc.html#label-Integer-Convertible+Objects">integer-convertible object</a> (or <code>nil</code>):</p> <ul>
<li> <p><code>start</code> specifies the zero-based offset of the first element to be replaced; <code>nil</code> means zero.</p> </li>
<li> <p><code>count</code> is the number of consecutive elements to be replaced; <code>nil</code> means “all the rest.”</p> </li>
</ul> <p>With argument <code>object</code> given, that one object is used for all replacements:</p> <pre class="ruby" data-language="ruby">o = Object.new           # =&gt; #&lt;Object:0x0000014e7bff7600&gt;
a = ['a', 'b', 'c', 'd'] # =&gt; ["a", "b", "c", "d"]
a.fill(o, 1, 2)
# =&gt; ["a", #&lt;Object:0x0000014e7bff7600&gt;, #&lt;Object:0x0000014e7bff7600&gt;, "d"]
</pre> <p>With a block given, the block is called once for each element to be replaced; the value passed to the block is the <em>index</em> of the element to be replaced (not the element itself); the block’s return value replaces the element:</p> <pre class="ruby" data-language="ruby">a = ['a', 'b', 'c', 'd']               # =&gt; ["a", "b", "c", "d"]
a.fill(1, 2) {|element| element.to_s } # =&gt; ["a", "1", "2", "d"]
</pre> <p>For arguments <code>start</code> and <code>count</code>:</p> <ul>
<li> <p>If <code>start</code> is non-negative, replaces <code>count</code> elements beginning at offset <code>start</code>:</p> <pre class="ruby" data-language="ruby">['a', 'b', 'c', 'd'].fill('-', 0, 2) # =&gt; ["-", "-", "c", "d"]
['a', 'b', 'c', 'd'].fill('-', 1, 2) # =&gt; ["a", "-", "-", "d"]
['a', 'b', 'c', 'd'].fill('-', 2, 2) # =&gt; ["a", "b", "-", "-"]

['a', 'b', 'c', 'd'].fill(0, 2) {|e| e.to_s } # =&gt; ["0", "1", "c", "d"]
['a', 'b', 'c', 'd'].fill(1, 2) {|e| e.to_s } # =&gt; ["a", "1", "2", "d"]
['a', 'b', 'c', 'd'].fill(2, 2) {|e| e.to_s } # =&gt; ["a", "b", "2", "3"]
</pre> <p>Extends <code>self</code> if necessary:</p> <pre class="ruby" data-language="ruby">['a', 'b', 'c', 'd'].fill('-', 3, 2) # =&gt; ["a", "b", "c", "-", "-"]
['a', 'b', 'c', 'd'].fill('-', 4, 2) # =&gt; ["a", "b", "c", "d", "-", "-"]

['a', 'b', 'c', 'd'].fill(3, 2) {|e| e.to_s } # =&gt; ["a", "b", "c", "3", "4"]
['a', 'b', 'c', 'd'].fill(4, 2) {|e| e.to_s } # =&gt; ["a", "b", "c", "d", "4", "5"]
</pre> <p>Fills with <code>nil</code> if necessary:</p> <pre class="ruby" data-language="ruby">['a', 'b', 'c', 'd'].fill('-', 5, 2) # =&gt; ["a", "b", "c", "d", nil, "-", "-"]
['a', 'b', 'c', 'd'].fill('-', 6, 2) # =&gt; ["a", "b", "c", "d", nil, nil, "-", "-"]

['a', 'b', 'c', 'd'].fill(5, 2) {|e| e.to_s } # =&gt; ["a", "b", "c", "d", nil, "5", "6"]
['a', 'b', 'c', 'd'].fill(6, 2) {|e| e.to_s } # =&gt; ["a", "b", "c", "d", nil, nil, "6", "7"]
</pre> <p>Does nothing if <code>count</code> is non-positive:</p> <pre class="ruby" data-language="ruby">['a', 'b', 'c', 'd'].fill('-', 2, 0)    # =&gt; ["a", "b", "c", "d"]
['a', 'b', 'c', 'd'].fill('-', 2, -100) # =&gt; ["a", "b", "c", "d"]
['a', 'b', 'c', 'd'].fill('-', 6, -100) # =&gt; ["a", "b", "c", "d"]

['a', 'b', 'c', 'd'].fill(2, 0) {|e| fail 'Cannot happen' }    # =&gt; ["a", "b", "c", "d"]
['a', 'b', 'c', 'd'].fill(2, -100) {|e| fail 'Cannot happen' } # =&gt; ["a", "b", "c", "d"]
['a', 'b', 'c', 'd'].fill(6, -100) {|e| fail 'Cannot happen' } # =&gt; ["a", "b", "c", "d"]
</pre> </li>
<li> <p>If <code>start</code> is negative, counts backwards from the end of <code>self</code>:</p> <pre class="ruby" data-language="ruby">['a', 'b', 'c', 'd'].fill('-', -4, 3) # =&gt; ["-", "-", "-", "d"]
['a', 'b', 'c', 'd'].fill('-', -3, 3) # =&gt; ["a", "-", "-", "-"]

['a', 'b', 'c', 'd'].fill(-4, 3) {|e| e.to_s } # =&gt; ["0", "1", "2", "d"]
['a', 'b', 'c', 'd'].fill(-3, 3) {|e| e.to_s } # =&gt; ["a", "1", "2", "3"]
</pre> <p>Extends <code>self</code> if necessary:</p> <pre class="ruby" data-language="ruby">['a', 'b', 'c', 'd'].fill('-', -2, 3) # =&gt; ["a", "b", "-", "-", "-"]
['a', 'b', 'c', 'd'].fill('-', -1, 3) # =&gt; ["a", "b", "c", "-", "-", "-"]

['a', 'b', 'c', 'd'].fill(-2, 3) {|e| e.to_s } # =&gt; ["a", "b", "2", "3", "4"]
['a', 'b', 'c', 'd'].fill(-1, 3) {|e| e.to_s } # =&gt; ["a", "b", "c", "3", "4", "5"]
</pre> <p>Starts at the beginning of <code>self</code> if <code>start</code> is negative and out-of-range:</p> <pre class="ruby" data-language="ruby">['a', 'b', 'c', 'd'].fill('-', -5, 2) # =&gt; ["-", "-", "c", "d"]
['a', 'b', 'c', 'd'].fill('-', -6, 2) # =&gt; ["-", "-", "c", "d"]

['a', 'b', 'c', 'd'].fill(-5, 2) {|e| e.to_s } # =&gt; ["0", "1", "c", "d"]
['a', 'b', 'c', 'd'].fill(-6, 2) {|e| e.to_s } # =&gt; ["0", "1", "c", "d"]
</pre> <p>Does nothing if <code>count</code> is non-positive:</p> <pre class="ruby" data-language="ruby">['a', 'b', 'c', 'd'].fill('-', -2, 0)  # =&gt; ["a", "b", "c", "d"]
['a', 'b', 'c', 'd'].fill('-', -2, -1) # =&gt; ["a", "b", "c", "d"]

['a', 'b', 'c', 'd'].fill(-2, 0) {|e| fail 'Cannot happen' }  # =&gt; ["a", "b", "c", "d"]
['a', 'b', 'c', 'd'].fill(-2, -1) {|e| fail 'Cannot happen' } # =&gt; ["a", "b", "c", "d"]
</pre> </li>
</ul> <p>When argument <code>range</code> is given, it must be a <a href="range.html"><code>Range</code></a> object whose members are numeric; its <code>begin</code> and <code>end</code> values determine the elements of <code>self</code> to be replaced:</p> <ul>
<li> <p>If both <code>begin</code> and <code>end</code> are positive, they specify the first and last elements to be replaced:</p> <pre class="ruby" data-language="ruby">['a', 'b', 'c', 'd'].fill('-', 1..2)          # =&gt; ["a", "-", "-", "d"]
['a', 'b', 'c', 'd'].fill(1..2) {|e| e.to_s } # =&gt; ["a", "1", "2", "d"]
</pre> <p>If <code>end</code> is smaller than <code>begin</code>, replaces no elements:</p> <pre class="ruby" data-language="ruby">['a', 'b', 'c', 'd'].fill('-', 2..1)          # =&gt; ["a", "b", "c", "d"]
['a', 'b', 'c', 'd'].fill(2..1) {|e| e.to_s } # =&gt; ["a", "b", "c", "d"]
</pre> </li>
<li> <p>If either is negative (or both are negative), counts backwards from the end of <code>self</code>:</p> <pre class="ruby" data-language="ruby">['a', 'b', 'c', 'd'].fill('-', -3..2)  # =&gt; ["a", "-", "-", "d"]
['a', 'b', 'c', 'd'].fill('-', 1..-2)  # =&gt; ["a", "-", "-", "d"]
['a', 'b', 'c', 'd'].fill('-', -3..-2) # =&gt; ["a", "-", "-", "d"]

['a', 'b', 'c', 'd'].fill(-3..2) {|e| e.to_s }  # =&gt; ["a", "1", "2", "d"]
['a', 'b', 'c', 'd'].fill(1..-2) {|e| e.to_s }  # =&gt; ["a", "1", "2", "d"]
['a', 'b', 'c', 'd'].fill(-3..-2) {|e| e.to_s } # =&gt; ["a", "1", "2", "d"]
</pre> </li>
<li> <p>If the <code>end</code> value is excluded (see <a href="range.html#method-i-exclude_end-3F"><code>Range#exclude_end?</code></a>), omits the last replacement:</p> <pre class="ruby" data-language="ruby">['a', 'b', 'c', 'd'].fill('-', 1...2)  # =&gt; ["a", "-", "c", "d"]
['a', 'b', 'c', 'd'].fill('-', 1...-2) # =&gt; ["a", "-", "c", "d"]

['a', 'b', 'c', 'd'].fill(1...2) {|e| e.to_s }  # =&gt; ["a", "1", "c", "d"]
['a', 'b', 'c', 'd'].fill(1...-2) {|e| e.to_s } # =&gt; ["a", "1", "c", "d"]
</pre> </li>
<li> <p>If the range is endless (see <a href="range.html#class-Range-label-Endless+Ranges">Endless Ranges</a>), replaces elements to the end of <code>self</code>:</p> <pre class="ruby" data-language="ruby">['a', 'b', 'c', 'd'].fill('-', 1..)          # =&gt; ["a", "-", "-", "-"]
['a', 'b', 'c', 'd'].fill(1..) {|e| e.to_s } # =&gt; ["a", "1", "2", "3"]
</pre> </li>
<li> <p>If the range is beginless (see <a href="range.html#class-Range-label-Beginless+Ranges">Beginless Ranges</a>), replaces elements from the beginning of <code>self</code>:</p> <pre class="ruby" data-language="ruby">['a', 'b', 'c', 'd'].fill('-', ..2)          # =&gt; ["-", "-", "-", "d"]
['a', 'b', 'c', 'd'].fill(..2) {|e| e.to_s } # =&gt; ["0", "1", "2", "d"]
</pre> </li>
</ul> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Assigning">Methods for Assigning</a>.</p> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-filter"> <a href="#method-i-filter" title="Link to this method"> <span class="method-callseq"> filter {|element| ... } → new_array </span> </a> </div> <div class="method-heading"> <a href="#method-i-filter" title="Link to this method"> <span class="method-callseq"> filter → new_enumerator </span> </a> </div> </div> <div class="method-description"> <p>With a block given, calls the block with each element of <code>self</code>; returns a new array containing those elements of <code>self</code> for which the block returns a truthy value:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2, :bam]
a.select {|element| element.to_s.start_with?('b') }
# =&gt; ["bar", :bam]
</pre> <p>With no block given, returns a new <a href="enumerator.html"><code>Enumerator</code></a>.</p> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Fetching">Methods for Fetching</a>.</p> </div> <div class="aliases"> Alias for: <a href="array.html#method-i-select">select</a> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-filter-21"> <a href="#method-i-filter-21" title="Link to this method"> <span class="method-callseq"> filter! {|element| ... } → self or nil </span> </a> </div> <div class="method-heading"> <a href="#method-i-filter-21" title="Link to this method"> <span class="method-callseq"> filter! → new_enumerator </span> </a> </div> </div> <div class="method-description"> <p>With a block given, calls the block with each element of <code>self</code>; removes from <code>self</code> those elements for which the block returns <code>false</code> or <code>nil</code>.</p> <p>Returns <code>self</code> if any elements were removed:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2, :bam]
a.select! {|element| element.to_s.start_with?('b') } # =&gt; ["bar", :bam]
</pre> <p>Returns <code>nil</code> if no elements were removed.</p> <p>With no block given, returns a new <a href="enumerator.html"><code>Enumerator</code></a>.</p> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Deleting">Methods for Deleting</a>.</p> </div> <div class="aliases"> Alias for: <a href="array.html#method-i-select-21">select!</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-find_index"> <a href="#method-i-find_index" title="Link to this method"> <span class="method-name">find_index</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="aliases"> Also aliased as: <a href="array.html#method-i-index">index</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-first"> <a href="#method-i-first" title="Link to this method"> <span class="method-callseq"> first → object or nil </span> </a> </div> <div class="method-heading"> <a href="#method-i-first" title="Link to this method"> <span class="method-callseq"> first(count) → new_array </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="first-source"> <pre class="ruby" data-language="ruby"># File array.rb, line 129
def first n = unspecified = true
  if Primitive.mandatory_only?
    Primitive.attr! :leaf
    Primitive.cexpr! %q{ ary_first(self) }
  else
    if unspecified
      Primitive.cexpr! %q{ ary_first(self) }
    else
      Primitive.cexpr! %q{  ary_take_first_or_last_n(self, NUM2LONG(n), ARY_TAKE_FIRST) }
    end
  end
end</pre> </div>  <p>Returns elements from <code>self</code>, or <code>nil</code>; does not modify <code>self</code>.</p> <p>With no argument given, returns the first element (if available):</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.first # =&gt; :foo
a # =&gt; [:foo, "bar", 2]
</pre> <p>If <code>self</code> is empty, returns <code>nil</code>.</p> <pre class="ruby" data-language="ruby">[].first # =&gt; nil
</pre> <p>With a non-negative integer argument <code>count</code> given, returns the first <code>count</code> elements (as available) in a new array:</p> <pre class="ruby" data-language="ruby">a.first(0)  # =&gt; []
a.first(2)  # =&gt; [:foo, "bar"]
a.first(50) # =&gt; [:foo, "bar", 2]
</pre> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Querying">Methods for Querying</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-flatten"> <a href="#method-i-flatten" title="Link to this method"> <span class="method-callseq"> flatten(depth = nil) → new_array </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="flatten-source"> <pre class="c" data-language="c">static VALUE
rb_ary_flatten(int argc, VALUE *argv, VALUE ary)
{
    int level = -1;
    VALUE result;

    if (rb_check_arity(argc, 0, 1) &amp;&amp; !NIL_P(argv[0])) {
        level = NUM2INT(argv[0]);
        if (level == 0) return ary_make_shared_copy(ary);
    }

    result = flatten(ary, level);
    if (result == ary) {
        result = ary_make_shared_copy(ary);
    }

    return result;
}</pre> </div>  <p>Returns a new array that is a recursive flattening of <code>self</code> to <code>depth</code> levels of recursion; <code>depth</code> must be an <a href="implicit_conversion_rdoc.html#label-Integer-Convertible+Objects">integer-convertible object</a> or <code>nil</code>. At each level of recursion:</p> <ul>
<li> <p>Each element that is an array is “flattened” (that is, replaced by its individual array elements).</p> </li>
<li> <p>Each element that is not an array is unchanged (even if the element is an object that has instance method <code>flatten</code>).</p> </li>
</ul> <p>With non-negative integer argument <code>depth</code>, flattens recursively through <code>depth</code> levels:</p> <pre class="ruby" data-language="ruby">a = [ 0, [ 1, [2, 3], 4 ], 5, {foo: 0}, Set.new([6, 7]) ]
a              # =&gt; [0, [1, [2, 3], 4], 5, {:foo=&gt;0}, #&lt;Set: {6, 7}&gt;]
a.flatten(0)   # =&gt; [0, [1, [2, 3], 4], 5, {:foo=&gt;0}, #&lt;Set: {6, 7}&gt;]
a.flatten(1  ) # =&gt; [0, 1, [2, 3], 4, 5, {:foo=&gt;0}, #&lt;Set: {6, 7}&gt;]
a.flatten(1.1) # =&gt; [0, 1, [2, 3], 4, 5, {:foo=&gt;0}, #&lt;Set: {6, 7}&gt;]
a.flatten(2)   # =&gt; [0, 1, 2, 3, 4, 5, {:foo=&gt;0}, #&lt;Set: {6, 7}&gt;]
a.flatten(3)   # =&gt; [0, 1, 2, 3, 4, 5, {:foo=&gt;0}, #&lt;Set: {6, 7}&gt;]
</pre> <p>With <code>nil</code> or negative <code>depth</code>, flattens all levels.</p> <pre class="ruby" data-language="ruby">a.flatten     # =&gt; [0, 1, 2, 3, 4, 5, {:foo=&gt;0}, #&lt;Set: {6, 7}&gt;]
a.flatten(-1) # =&gt; [0, 1, 2, 3, 4, 5, {:foo=&gt;0}, #&lt;Set: {6, 7}&gt;]
</pre> <p>Related: <a href="array.html#method-i-flatten-21"><code>Array#flatten!</code></a>; see also <a href="array.html#class-Array-label-Methods+for+Converting">Methods for Converting</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-flatten-21"> <a href="#method-i-flatten-21" title="Link to this method"> <span class="method-callseq"> flatten!(depth = nil) → self or nil </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="flatten-21-source"> <pre class="c" data-language="c">static VALUE
rb_ary_flatten_bang(int argc, VALUE *argv, VALUE ary)
{
    int mod = 0, level = -1;
    VALUE result, lv;

    lv = (rb_check_arity(argc, 0, 1) ? argv[0] : Qnil);
    rb_ary_modify_check(ary);
    if (!NIL_P(lv)) level = NUM2INT(lv);
    if (level == 0) return Qnil;

    result = flatten(ary, level);
    if (result == ary) {
        return Qnil;
    }
    if (!(mod = ARY_EMBED_P(result))) rb_ary_freeze(result);
    rb_ary_replace(ary, result);
    if (mod) ARY_SET_EMBED_LEN(result, 0);

    return ary;
}</pre> </div>  <p>Returns <code>self</code> as a recursively flattening of <code>self</code> to <code>depth</code> levels of recursion; <code>depth</code> must be an <a href="implicit_conversion_rdoc.html#label-Integer-Convertible+Objects">integer-convertible object</a>, or <code>nil</code>. At each level of recursion:</p> <ul>
<li> <p>Each element that is an array is “flattened” (that is, replaced by its individual array elements).</p> </li>
<li> <p>Each element that is not an array is unchanged (even if the element is an object that has instance method <code>flatten</code>).</p> </li>
</ul> <p>Returns <code>nil</code> if no elements were flattened.</p> <p>With non-negative integer argument <code>depth</code>, flattens recursively through <code>depth</code> levels:</p> <pre class="ruby" data-language="ruby">a = [ 0, [ 1, [2, 3], 4 ], 5, {foo: 0}, Set.new([6, 7]) ]
a                   # =&gt; [0, [1, [2, 3], 4], 5, {:foo=&gt;0}, #&lt;Set: {6, 7}&gt;]
a.dup.flatten!(1)   # =&gt; [0, 1, [2, 3], 4, 5, {:foo=&gt;0}, #&lt;Set: {6, 7}&gt;]
a.dup.flatten!(1.1) # =&gt; [0, 1, [2, 3], 4, 5, {:foo=&gt;0}, #&lt;Set: {6, 7}&gt;]
a.dup.flatten!(2)   # =&gt; [0, 1, 2, 3, 4, 5, {:foo=&gt;0}, #&lt;Set: {6, 7}&gt;]
a.dup.flatten!(3)   # =&gt; [0, 1, 2, 3, 4, 5, {:foo=&gt;0}, #&lt;Set: {6, 7}&gt;]
</pre> <p>With <code>nil</code> or negative argument <code>depth</code>, flattens all levels:</p> <pre class="ruby" data-language="ruby">a.dup.flatten!     # =&gt; [0, 1, 2, 3, 4, 5, {:foo=&gt;0}, #&lt;Set: {6, 7}&gt;]
a.dup.flatten!(-1) # =&gt; [0, 1, 2, 3, 4, 5, {:foo=&gt;0}, #&lt;Set: {6, 7}&gt;]
</pre> <p>Related: <a href="array.html#method-i-flatten"><code>Array#flatten</code></a>; see also <a href="array.html#class-Array-label-Methods+for+Assigning">Methods for Assigning</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-freeze"> <a href="#method-i-freeze" title="Link to this method"> <span class="method-callseq"> freeze → self </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="freeze-source"> <pre class="c" data-language="c">VALUE
rb_ary_freeze(VALUE ary)
{
    RUBY_ASSERT(RB_TYPE_P(ary, T_ARRAY));

    if (OBJ_FROZEN(ary)) return ary;

    if (!ARY_EMBED_P(ary) &amp;&amp; !ARY_SHARED_P(ary) &amp;&amp; !ARY_SHARED_ROOT_P(ary)) {
        ary_shrink_capa(ary);
    }

    return rb_obj_freeze(ary);
}</pre> </div>  <p>Freezes <code>self</code> (if not already frozen); returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">a = []
a.frozen? # =&gt; false
a.freeze
a.frozen? # =&gt; true
</pre> <p>No further changes may be made to <code>self</code>; raises <a href="frozenerror.html"><code>FrozenError</code></a> if a change is attempted.</p> <p>Related: <a href="kernel.html#method-i-frozen-3F"><code>Kernel#frozen?</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-hash"> <a href="#method-i-hash" title="Link to this method"> <span class="method-callseq"> hash → integer </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="hash-source"> <pre class="c" data-language="c">static VALUE
rb_ary_hash(VALUE ary)
{
    return rb_ary_hash_values(RARRAY_LEN(ary), RARRAY_CONST_PTR(ary));
}</pre> </div>  <p>Returns the integer hash value for <code>self</code>.</p> <p>Two arrays with the same content will have the same hash value (and will compare using eql?):</p> <pre class="ruby" data-language="ruby">['a', 'b'].hash == ['a', 'b'].hash # =&gt; true
['a', 'b'].hash == ['a', 'c'].hash # =&gt; false
['a', 'b'].hash == ['a'].hash      # =&gt; false
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-include-3F"> <a href="#method-i-include-3F" title="Link to this method"> <span class="method-callseq"> include?(object) → true or false </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="include-3F-source"> <pre class="c" data-language="c">VALUE
rb_ary_includes(VALUE ary, VALUE item)
{
    long i;
    VALUE e;

    for (i=0; i&lt;RARRAY_LEN(ary); i++) {
        e = RARRAY_AREF(ary, i);
        if (rb_equal(e, item)) {
            return Qtrue;
        }
    }
    return Qfalse;
}</pre> </div>  <p>Returns whether for some element <code>element</code> in <code>self</code>, <code>object == element</code>:</p> <pre class="ruby" data-language="ruby">[0, 1, 2].include?(2)   # =&gt; true
[0, 1, 2].include?(2.0) # =&gt; true
[0, 1, 2].include?(2.1) # =&gt; false
</pre> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Querying">Methods for Querying</a>.</p> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-index"> <a href="#method-i-index" title="Link to this method"> <span class="method-callseq"> index(object) → integer or nil </span> </a> </div> <div class="method-heading"> <a href="#method-i-index" title="Link to this method"> <span class="method-callseq"> index {|element| ... } → integer or nil </span> </a> </div> <div class="method-heading"> <a href="#method-i-index" title="Link to this method"> <span class="method-callseq"> index → new_enumerator </span> </a> </div> </div> <div class="method-description"> <p>Returns the zero-based integer index of a specified element, or <code>nil</code>.</p> <p>With only argument <code>object</code> given, returns the index of the first element <code>element</code> for which <code>object == element</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2, 'bar']
a.index('bar') # =&gt; 1
</pre> <p>Returns <code>nil</code> if no such element found.</p> <p>With only a block given, calls the block with each successive element; returns the index of the first element for which the block returns a truthy value:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2, 'bar']
a.index {|element| element == 'bar' } # =&gt; 1
</pre> <p>Returns <code>nil</code> if the block never returns a truthy value.</p> <p>With neither an argument nor a block given, returns a new <a href="enumerator.html"><code>Enumerator</code></a>.</p> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Querying">Methods for Querying</a>.</p> </div> <div class="aliases"> Alias for: <a href="array.html#method-i-find_index">find_index</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-initialize_copy"> <a href="#method-i-initialize_copy" title="Link to this method"> <span class="method-callseq"> initialize_copy(other_array) → self </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="initialize_copy-source"> <pre class="c" data-language="c">VALUE
rb_ary_replace(VALUE copy, VALUE orig)
{
    rb_ary_modify_check(copy);
    orig = to_ary(orig);
    if (copy == orig) return copy;

    rb_ary_reset(copy);

    /* orig has enough space to embed the contents of orig. */
    if (RARRAY_LEN(orig) &lt;= ary_embed_capa(copy)) {
        RUBY_ASSERT(ARY_EMBED_P(copy));
        ary_memcpy(copy, 0, RARRAY_LEN(orig), RARRAY_CONST_PTR(orig));
        ARY_SET_EMBED_LEN(copy, RARRAY_LEN(orig));
    }
    /* orig is embedded but copy does not have enough space to embed the
     * contents of orig. */
    else if (ARY_EMBED_P(orig)) {
        long len = ARY_EMBED_LEN(orig);
        VALUE *ptr = ary_heap_alloc_buffer(len);

        FL_UNSET_EMBED(copy);
        ARY_SET_PTR(copy, ptr);
        ARY_SET_LEN(copy, len);
        ARY_SET_CAPA(copy, len);

        // No allocation and exception expected that could leave `copy` in a
        // bad state from the edits above.
        ary_memcpy(copy, 0, len, RARRAY_CONST_PTR(orig));
    }
    /* Otherwise, orig is on heap and copy does not have enough space to embed
     * the contents of orig. */
    else {
        VALUE shared_root = ary_make_shared(orig);
        FL_UNSET_EMBED(copy);
        ARY_SET_PTR(copy, ARY_HEAP_PTR(orig));
        ARY_SET_LEN(copy, ARY_HEAP_LEN(orig));
        rb_ary_set_shared(copy, shared_root);
    }
    ary_verify(copy);
    return copy;
}</pre> </div>  <p>Replaces the elements of <code>self</code> with the elements of <code>other_array</code>, which must be an <a href="implicit_conversion_rdoc.html#label-Array-Convertible+Objects">array-convertible object</a>; returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">a = ['a', 'b', 'c']   # =&gt; ["a", "b", "c"]
a.replace(['d', 'e']) # =&gt; ["d", "e"]
</pre> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Assigning">Methods for Assigning</a>.</p> </div> <div class="aliases"> Also aliased as: <a href="array.html#method-i-replace">replace</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-insert"> <a href="#method-i-insert" title="Link to this method"> <span class="method-callseq"> insert(index, *objects) → self </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="insert-source"> <pre class="c" data-language="c">static VALUE
rb_ary_insert(int argc, VALUE *argv, VALUE ary)
{
    long pos;

    rb_check_arity(argc, 1, UNLIMITED_ARGUMENTS);
    rb_ary_modify_check(ary);
    pos = NUM2LONG(argv[0]);
    if (argc == 1) return ary;
    if (pos == -1) {
        pos = RARRAY_LEN(ary);
    }
    else if (pos &lt; 0) {
        long minpos = -RARRAY_LEN(ary) - 1;
        if (pos &lt; minpos) {
            rb_raise(rb_eIndexError, "index %ld too small for array; minimum: %ld",
                     pos, minpos);
        }
        pos++;
    }
    rb_ary_splice(ary, pos, 0, argv + 1, argc - 1);
    return ary;
}</pre> </div>  <p>Inserts the given <code>objects</code> as elements of <code>self</code>; returns <code>self</code>.</p> <p>When <code>index</code> is non-negative, inserts <code>objects</code> <em>before</em> the element at offset <code>index</code>:</p> <pre class="ruby" data-language="ruby">a = ['a', 'b', 'c']     # =&gt; ["a", "b", "c"]
a.insert(1, :x, :y, :z) # =&gt; ["a", :x, :y, :z, "b", "c"]
</pre> <p>Extends the array if <code>index</code> is beyond the array (<code>index &gt;= self.size</code>):</p> <pre class="ruby" data-language="ruby">a = ['a', 'b', 'c']     # =&gt; ["a", "b", "c"]
a.insert(5, :x, :y, :z) # =&gt; ["a", "b", "c", nil, nil, :x, :y, :z]
</pre> <p>When <code>index</code> is negative, inserts <code>objects</code> <em>after</em> the element at offset <code>index + self.size</code>:</p> <pre class="ruby" data-language="ruby">a = ['a', 'b', 'c']      # =&gt; ["a", "b", "c"]
a.insert(-2, :x, :y, :z) # =&gt; ["a", "b", :x, :y, :z, "c"]
</pre> <p>With no <code>objects</code> given, does nothing:</p> <pre class="ruby" data-language="ruby">a = ['a', 'b', 'c'] # =&gt; ["a", "b", "c"]
a.insert(1)         # =&gt; ["a", "b", "c"]
a.insert(50)        # =&gt; ["a", "b", "c"]
a.insert(-50)       # =&gt; ["a", "b", "c"]
</pre> <p>Raises <a href="indexerror.html"><code>IndexError</code></a> if <code>objects</code> are given and <code>index</code> is negative and out of range.</p> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Assigning">Methods for Assigning</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-inspect"> <a href="#method-i-inspect" title="Link to this method"> <span class="method-callseq"> inspect → new_string </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="inspect-source"> <pre class="c" data-language="c">static VALUE
rb_ary_inspect(VALUE ary)
{
    if (RARRAY_LEN(ary) == 0) return rb_usascii_str_new2("[]");
    return rb_exec_recursive(inspect_ary, ary, 0);
}</pre> </div>  <p>Returns the new string formed by calling method <a href="array.html#method-i-inspect"><code>inspect</code></a> on each array element:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.inspect # =&gt; "[:foo, \"bar\", 2]"
</pre> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Converting">Methods for Converting</a>.</p> </div> <div class="aliases"> Also aliased as: <a href="array.html#method-i-to_s">to_s</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-intersect-3F"> <a href="#method-i-intersect-3F" title="Link to this method"> <span class="method-callseq"> intersect?(other_array) → true or false </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="intersect-3F-source"> <pre class="c" data-language="c">static VALUE
rb_ary_intersect_p(VALUE ary1, VALUE ary2)
{
    VALUE hash, v, result, shorter, longer;
    st_data_t vv;
    long i;

    ary2 = to_ary(ary2);
    if (RARRAY_LEN(ary1) == 0 || RARRAY_LEN(ary2) == 0) return Qfalse;

    if (RARRAY_LEN(ary1) &lt;= SMALL_ARRAY_LEN &amp;&amp; RARRAY_LEN(ary2) &lt;= SMALL_ARRAY_LEN) {
        for (i=0; i&lt;RARRAY_LEN(ary1); i++) {
            v = RARRAY_AREF(ary1, i);
            if (rb_ary_includes_by_eql(ary2, v)) return Qtrue;
        }
        return Qfalse;
    }

    shorter = ary1;
    longer = ary2;
    if (RARRAY_LEN(ary1) &gt; RARRAY_LEN(ary2)) {
        longer = ary1;
        shorter = ary2;
    }

    hash = ary_make_hash(shorter);
    result = Qfalse;

    for (i=0; i&lt;RARRAY_LEN(longer); i++) {
        v = RARRAY_AREF(longer, i);
        vv = (st_data_t)v;
        if (rb_hash_stlike_lookup(hash, vv, 0)) {
            result = Qtrue;
            break;
        }
    }

    return result;
}</pre> </div>  <p>Returns whether <code>other_array</code> has at least one element that is <a href="array.html#method-i-eql-3F"><code>eql?</code></a> to some element of <code>self</code>:</p> <pre class="ruby" data-language="ruby">[1, 2, 3].intersect?([3, 4, 5]) # =&gt; true
[1, 2, 3].intersect?([4, 5, 6]) # =&gt; false
</pre> <p>Each element must correctly implement method <a href="array.html#method-i-hash"><code>hash</code></a>.</p> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Querying">Methods for Querying</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-intersection"> <a href="#method-i-intersection" title="Link to this method"> <span class="method-callseq"> intersection(*other_arrays) → new_array </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="intersection-source"> <pre class="c" data-language="c">static VALUE
rb_ary_intersection_multi(int argc, VALUE *argv, VALUE ary)
{
    VALUE result = rb_ary_dup(ary);
    int i;

    for (i = 0; i &lt; argc; i++) {
        result = rb_ary_and(result, argv[i]);
    }

    return result;
}</pre> </div>  <p>Returns a new array containing each element in <code>self</code> that is <a href="array.html#method-i-eql-3F"><code>eql?</code></a> to at least one element in each of the given <code>other_arrays</code>; duplicates are omitted:</p> <pre class="ruby" data-language="ruby">[0, 0, 1, 1, 2, 3].intersection([0, 1, 2], [0, 1, 3]) # =&gt; [0, 1]
</pre> <p>Each element must correctly implement method <a href="array.html#method-i-hash"><code>hash</code></a>.</p> <p>Order from <code>self</code> is preserved:</p> <pre class="ruby" data-language="ruby">[0, 1, 2].intersection([2, 1, 0]) # =&gt; [0, 1, 2]
</pre> <p>Returns a copy of <code>self</code> if no arguments are given.</p> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Combining">Methods for Combining</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-join"> <a href="#method-i-join" title="Link to this method"> <span class="method-callseq"> join(separator = $,) → new_string </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="join-source"> <pre class="c" data-language="c">static VALUE
rb_ary_join_m(int argc, VALUE *argv, VALUE ary)
{
    VALUE sep;

    if (rb_check_arity(argc, 0, 1) == 0 || NIL_P(sep = argv[0])) {
        sep = rb_output_fs;
        if (!NIL_P(sep)) {
            rb_category_warn(RB_WARN_CATEGORY_DEPRECATED, "$, is set to non-nil value");
        }
    }

    return rb_ary_join(ary, sep);
}</pre> </div>  <p>Returns the new string formed by joining the converted elements of <code>self</code>; for each element <code>element</code>:</p> <ul>
<li> <p>Converts recursively using <code>element.join(separator)</code> if <code>element</code> is a <code>kind_of?(Array)</code>.</p> </li>
<li> <p>Otherwise, converts using <code>element.to_s</code>.</p> </li>
</ul> <p>With no argument given, joins using the output field separator, <code>$,</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
$, # =&gt; nil
a.join # =&gt; "foobar2"
</pre> <p>With string argument <code>separator</code> given, joins using that separator:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.join("\n") # =&gt; "foo\nbar\n2"
</pre> <p>Joins recursively for nested arrays:</p> <pre class="ruby" data-language="ruby">a = [:foo, [:bar, [:baz, :bat]]]
a.join # =&gt; "foobarbazbat"
</pre> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Converting">Methods for Converting</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-keep_if"> <a href="#method-i-keep_if" title="Link to this method"> <span class="method-callseq"> keep_if {|element| ... } → self </span> </a> </div> <div class="method-heading"> <a href="#method-i-keep_if" title="Link to this method"> <span class="method-callseq"> keep_if → new_enumerator </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="keep_if-source"> <pre class="c" data-language="c">static VALUE
rb_ary_keep_if(VALUE ary)
{
    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);
    rb_ary_select_bang(ary);
    return ary;
}</pre> </div>  <p>With a block given, calls the block with each element of <code>self</code>; removes the element from <code>self</code> if the block does not return a truthy value:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2, :bam]
a.keep_if {|element| element.to_s.start_with?('b') } # =&gt; ["bar", :bam]
</pre> <p>With no block given, returns a new <a href="enumerator.html"><code>Enumerator</code></a>.</p> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Deleting">Methods for Deleting</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-last"> <a href="#method-i-last" title="Link to this method"> <span class="method-callseq"> last → last_object or nil </span> </a> </div> <div class="method-heading"> <a href="#method-i-last" title="Link to this method"> <span class="method-callseq"> last(count) → new_array </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="last-source"> <pre class="ruby" data-language="ruby"># File array.rb, line 166
def last n = unspecified = true
  if Primitive.mandatory_only?
    Primitive.attr! :leaf
    Primitive.cexpr! %q{ ary_last(self) }
  else
    if unspecified
      Primitive.cexpr! %q{ ary_last(self) }
    else
      Primitive.cexpr! %q{ ary_take_first_or_last_n(self, NUM2LONG(n), ARY_TAKE_LAST) }
    end
  end
end</pre> </div>  <p>Returns elements from <code>self</code>, or <code>nil</code>; <code>self</code> is not modified.</p> <p>With no argument given, returns the last element, or <code>nil</code> if <code>self</code> is empty:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.last # =&gt; 2
a # =&gt; [:foo, "bar", 2]
[].last # =&gt; nil
</pre> <p>With non-negative integer argument <code>count</code> given, returns a new array containing the trailing <code>count</code> elements of <code>self</code>, as available:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.last(2)  # =&gt; ["bar", 2]
a.last(50) # =&gt; [:foo, "bar", 2]
a.last(0)  # =&gt; []
[].last(3) # =&gt; []
</pre> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Fetching">Methods for Fetching</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-length"> <a href="#method-i-length" title="Link to this method"> <span class="method-callseq"> length → integer </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="length-source"> <pre class="c" data-language="c">static VALUE
rb_ary_length(VALUE ary)
{
    long len = RARRAY_LEN(ary);
    return LONG2NUM(len);
}</pre> </div>  <p>Returns the count of elements in <code>self</code>:</p> <pre class="ruby" data-language="ruby">[0, 1, 2].length # =&gt; 3
[].length        # =&gt; 0
</pre> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Querying">Methods for Querying</a>.</p> </div> <div class="aliases"> Also aliased as: <a href="array.html#method-i-size">size</a> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-map"> <a href="#method-i-map" title="Link to this method"> <span class="method-callseq"> map {|element| ... } → new_array </span> </a> </div> <div class="method-heading"> <a href="#method-i-map" title="Link to this method"> <span class="method-callseq"> map → new_enumerator </span> </a> </div> </div> <div class="method-description"> <p>With a block given, calls the block with each element of <code>self</code>; returns a new array whose elements are the return values from the block:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a1 = a.map {|element| element.class }
a1 # =&gt; [Symbol, String, Integer]
</pre> <p>With no block given, returns a new <a href="enumerator.html"><code>Enumerator</code></a>.</p> <p>Related: <a href="array.html#method-i-collect-21"><code>collect!</code></a>; see also <a href="array.html#class-Array-label-Methods+for+Converting">Methods for Converting</a>.</p> </div> <div class="aliases"> Also aliased as: collect </div> <div class="aliases"> Alias for: <a href="array.html#method-i-collect">collect</a> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-map-21"> <a href="#method-i-map-21" title="Link to this method"> <span class="method-callseq"> map! {|element| ... } → new_array </span> </a> </div> <div class="method-heading"> <a href="#method-i-map-21" title="Link to this method"> <span class="method-callseq"> map! → new_enumerator </span> </a> </div> </div> <div class="method-description"> <p>With a block given, calls the block with each element of <code>self</code> and replaces the element with the block’s return value; returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.map! { |element| element.class } # =&gt; [Symbol, String, Integer]
</pre> <p>With no block given, returns a new <a href="enumerator.html"><code>Enumerator</code></a>.</p> <p>Related: <a href="array.html#method-i-collect"><code>collect</code></a>; see also <a href="array.html#class-Array-label-Methods+for+Converting">Methods for Converting</a>.</p> </div> <div class="aliases"> Alias for: <a href="array.html#method-i-collect-21">collect!</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-max"> <a href="#method-i-max" title="Link to this method"> <span class="method-callseq"> max → element </span> </a> </div> <div class="method-heading"> <a href="#method-i-max" title="Link to this method"> <span class="method-callseq"> max(count) → new_array </span> </a> </div> <div class="method-heading"> <a href="#method-i-max" title="Link to this method"> <span class="method-callseq"> max {|a, b| ... } → element </span> </a> </div> <div class="method-heading"> <a href="#method-i-max" title="Link to this method"> <span class="method-callseq"> max(count) {|a, b| ... } → new_array </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="max-source"> <pre class="c" data-language="c">static VALUE
rb_ary_max(int argc, VALUE *argv, VALUE ary)
{
    VALUE result = Qundef, v;
    VALUE num;
    long i;

    if (rb_check_arity(argc, 0, 1) &amp;&amp; !NIL_P(num = argv[0]))
       return rb_nmin_run(ary, num, 0, 1, 1);

    const long n = RARRAY_LEN(ary);
    if (rb_block_given_p()) {
        for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
           v = RARRAY_AREF(ary, i);
           if (UNDEF_P(result) || rb_cmpint(rb_yield_values(2, v, result), v, result) &gt; 0) {
               result = v;
           }
        }
    }
    else if (n &gt; 0) {
        result = RARRAY_AREF(ary, 0);
        if (n &gt; 1) {
            if (FIXNUM_P(result) &amp;&amp; CMP_OPTIMIZABLE(INTEGER)) {
                return ary_max_opt_fixnum(ary, 1, result);
            }
            else if (STRING_P(result) &amp;&amp; CMP_OPTIMIZABLE(STRING)) {
                return ary_max_opt_string(ary, 1, result);
            }
            else if (RB_FLOAT_TYPE_P(result) &amp;&amp; CMP_OPTIMIZABLE(FLOAT)) {
                return ary_max_opt_float(ary, 1, result);
            }
            else {
                return ary_max_generic(ary, 1, result);
            }
        }
    }
    if (UNDEF_P(result)) return Qnil;
    return result;
}</pre> </div>  <p>Returns one of the following:</p> <ul>
<li> <p>The maximum-valued element from <code>self</code>.</p> </li>
<li> <p>A new array of maximum-valued elements from <code>self</code>.</p> </li>
</ul> <p>Does not modify <code>self</code>.</p> <p>With no block given, each element in <code>self</code> must respond to method <a href="array.html#method-i-3C-3D-3E"><code>&lt;=&gt;</code></a> with a numeric.</p> <p>With no argument and no block, returns the element in <code>self</code> having the maximum value per method <a href="array.html#method-i-3C-3D-3E"><code>&lt;=&gt;</code></a>:</p> <pre class="ruby" data-language="ruby">[1, 0, 3, 2].max # =&gt; 3
</pre> <p>With non-negative numeric argument <code>count</code> and no block, returns a new array with at most <code>count</code> elements, in descending order, per method <a href="array.html#method-i-3C-3D-3E"><code>&lt;=&gt;</code></a>:</p> <pre class="ruby" data-language="ruby">[1, 0, 3, 2].max(3)   # =&gt; [3, 2, 1]
[1, 0, 3, 2].max(3.0) # =&gt; [3, 2, 1]
[1, 0, 3, 2].max(9)   # =&gt; [3, 2, 1, 0]
[1, 0, 3, 2].max(0)   # =&gt; []
</pre> <p>With a block given, the block must return a numeric.</p> <p>With a block and no argument, calls the block <code>self.size - 1</code> times to compare elements; returns the element having the maximum value per the block:</p> <pre class="ruby" data-language="ruby">['0', '', '000', '00'].max {|a, b| a.size &lt;=&gt; b.size }
# =&gt; "000"
</pre> <p>With non-negative numeric argument <code>count</code> and a block, returns a new array with at most <code>count</code> elements, in descending order, per the block:</p> <pre class="ruby" data-language="ruby">['0', '', '000', '00'].max(2) {|a, b| a.size &lt;=&gt; b.size }
# =&gt; ["000", "00"]
</pre> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Fetching">Methods for Fetching</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-min"> <a href="#method-i-min" title="Link to this method"> <span class="method-callseq"> min → element </span> </a> </div> <div class="method-heading"> <a href="#method-i-min" title="Link to this method"> <span class="method-callseq"> min(count) → new_array </span> </a> </div> <div class="method-heading"> <a href="#method-i-min" title="Link to this method"> <span class="method-callseq"> min {|a, b| ... } → element </span> </a> </div> <div class="method-heading"> <a href="#method-i-min" title="Link to this method"> <span class="method-callseq"> min(count) {|a, b| ... } → new_array </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="min-source"> <pre class="c" data-language="c">static VALUE
rb_ary_min(int argc, VALUE *argv, VALUE ary)
{
    VALUE result = Qundef, v;
    VALUE num;
    long i;

    if (rb_check_arity(argc, 0, 1) &amp;&amp; !NIL_P(num = argv[0]))
       return rb_nmin_run(ary, num, 0, 0, 1);

    const long n = RARRAY_LEN(ary);
    if (rb_block_given_p()) {
        for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
           v = RARRAY_AREF(ary, i);
           if (UNDEF_P(result) || rb_cmpint(rb_yield_values(2, v, result), v, result) &lt; 0) {
               result = v;
           }
        }
    }
    else if (n &gt; 0) {
        result = RARRAY_AREF(ary, 0);
        if (n &gt; 1) {
            if (FIXNUM_P(result) &amp;&amp; CMP_OPTIMIZABLE(INTEGER)) {
                return ary_min_opt_fixnum(ary, 1, result);
            }
            else if (STRING_P(result) &amp;&amp; CMP_OPTIMIZABLE(STRING)) {
                return ary_min_opt_string(ary, 1, result);
            }
            else if (RB_FLOAT_TYPE_P(result) &amp;&amp; CMP_OPTIMIZABLE(FLOAT)) {
                return ary_min_opt_float(ary, 1, result);
            }
            else {
                return ary_min_generic(ary, 1, result);
            }
        }
    }
    if (UNDEF_P(result)) return Qnil;
    return result;
}</pre> </div>  <p>Returns one of the following:</p> <ul>
<li> <p>The minimum-valued element from <code>self</code>.</p> </li>
<li> <p>A new array of minimum-valued elements from <code>self</code>.</p> </li>
</ul> <p>Does not modify <code>self</code>.</p> <p>With no block given, each element in <code>self</code> must respond to method <a href="array.html#method-i-3C-3D-3E"><code>&lt;=&gt;</code></a> with a numeric.</p> <p>With no argument and no block, returns the element in <code>self</code> having the minimum value per method <a href="array.html#method-i-3C-3D-3E"><code>&lt;=&gt;</code></a>:</p> <pre class="ruby" data-language="ruby">[1, 0, 3, 2].min # =&gt; 0
</pre> <p>With non-negative numeric argument <code>count</code> and no block, returns a new array with at most <code>count</code> elements, in ascending order, per method <a href="array.html#method-i-3C-3D-3E"><code>&lt;=&gt;</code></a>:</p> <pre class="ruby" data-language="ruby">[1, 0, 3, 2].min(3)   # =&gt; [0, 1, 2]
[1, 0, 3, 2].min(3.0) # =&gt; [0, 1, 2]
[1, 0, 3, 2].min(9)   # =&gt; [0, 1, 2, 3]
[1, 0, 3, 2].min(0)   # =&gt; []
</pre> <p>With a block given, the block must return a numeric.</p> <p>With a block and no argument, calls the block <code>self.size - 1</code> times to compare elements; returns the element having the minimum value per the block:</p> <pre class="ruby" data-language="ruby">['0', '', '000', '00'].min {|a, b| a.size &lt;=&gt; b.size }
# =&gt; ""
</pre> <p>With non-negative numeric argument <code>count</code> and a block, returns a new array with at most <code>count</code> elements, in ascending order, per the block:</p> <pre class="ruby" data-language="ruby">['0', '', '000', '00'].min(2) {|a, b| a.size &lt;=&gt; b.size }
# =&gt; ["", "0"]
</pre> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Fetching">Methods for Fetching</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-minmax"> <a href="#method-i-minmax" title="Link to this method"> <span class="method-callseq"> minmax → array </span> </a> </div> <div class="method-heading"> <a href="#method-i-minmax" title="Link to this method"> <span class="method-callseq"> minmax {|a, b| ... } → array </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="minmax-source"> <pre class="c" data-language="c">static VALUE
rb_ary_minmax(VALUE ary)
{
    if (rb_block_given_p()) {
        return rb_call_super(0, NULL);
    }
    return rb_assoc_new(rb_ary_min(0, 0, ary), rb_ary_max(0, 0, ary));
}</pre> </div>  <p>Returns a 2-element array containing the minimum-valued and maximum-valued elements from <code>self</code>; does not modify <code>self</code>.</p> <p>With no block given, the minimum and maximum values are determined using method <a href="array.html#method-i-3C-3D-3E"><code>&lt;=&gt;</code></a>:</p> <pre class="ruby" data-language="ruby">[1, 0, 3, 2].minmax # =&gt; [0, 3]
</pre> <p>With a block given, the block must return a numeric; the block is called <code>self.size - 1</code> times to compare elements; returns the elements having the minimum and maximum values per the block:</p> <pre class="ruby" data-language="ruby">['0', '', '000', '00'].minmax {|a, b| a.size &lt;=&gt; b.size }
# =&gt; ["", "000"]
</pre> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Fetching">Methods for Fetching</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-none-3F"> <a href="#method-i-none-3F" title="Link to this method"> <span class="method-callseq"> none? → true or false </span> </a> </div> <div class="method-heading"> <a href="#method-i-none-3F" title="Link to this method"> <span class="method-callseq"> none?(object) → true or false </span> </a> </div> <div class="method-heading"> <a href="#method-i-none-3F" title="Link to this method"> <span class="method-callseq"> none? {|element| ... } → true or false </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="none-3F-source"> <pre class="c" data-language="c">static VALUE
rb_ary_none_p(int argc, VALUE *argv, VALUE ary)
{
    long i, len = RARRAY_LEN(ary);

    rb_check_arity(argc, 0, 1);
    if (!len) return Qtrue;
    if (argc) {
        if (rb_block_given_p()) {
            rb_warn("given block not used");
        }
        for (i = 0; i &lt; RARRAY_LEN(ary); ++i) {
            if (RTEST(rb_funcall(argv[0], idEqq, 1, RARRAY_AREF(ary, i)))) return Qfalse;
        }
    }
    else if (!rb_block_given_p()) {
        for (i = 0; i &lt; len; ++i) {
            if (RTEST(RARRAY_AREF(ary, i))) return Qfalse;
        }
    }
    else {
        for (i = 0; i &lt; RARRAY_LEN(ary); ++i) {
            if (RTEST(rb_yield(RARRAY_AREF(ary, i)))) return Qfalse;
        }
    }
    return Qtrue;
}</pre> </div>  <p>Returns <code>true</code> if no element of <code>self</code> meets a given criterion, <code>false</code> otherwise.</p> <p>With no block given and no argument, returns <code>true</code> if <code>self</code> has no truthy elements, <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">[nil, false].none?    # =&gt; true
[nil, 0, false].none? # =&gt; false
[].none?              # =&gt; true
</pre> <p>With argument <code>object</code> given, returns <code>false</code> if for any element <code>element</code>, <code>object === element</code>; <code>true</code> otherwise:</p> <pre class="ruby" data-language="ruby">['food', 'drink'].none?(/bar/) # =&gt; true
['food', 'drink'].none?(/foo/) # =&gt; false
[].none?(/foo/)                # =&gt; true
[0, 1, 2].none?(3)             # =&gt; true
[0, 1, 2].none?(1)             # =&gt; false
</pre> <p>With a block given, calls the block with each element in <code>self</code>; returns <code>true</code> if the block returns no truthy value, <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">[0, 1, 2].none? {|element| element &gt; 3 } # =&gt; true
[0, 1, 2].none? {|element| element &gt; 1 } # =&gt; false
</pre> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Querying">Methods for Querying</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-one-3F"> <a href="#method-i-one-3F" title="Link to this method"> <span class="method-callseq"> one? → true or false </span> </a> </div> <div class="method-heading"> <a href="#method-i-one-3F" title="Link to this method"> <span class="method-callseq"> one? {|element| ... } → true or false </span> </a> </div> <div class="method-heading"> <a href="#method-i-one-3F" title="Link to this method"> <span class="method-callseq"> one?(object) → true or false </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="one-3F-source"> <pre class="c" data-language="c">static VALUE
rb_ary_one_p(int argc, VALUE *argv, VALUE ary)
{
    long i, len = RARRAY_LEN(ary);
    VALUE result = Qfalse;

    rb_check_arity(argc, 0, 1);
    if (!len) return Qfalse;
    if (argc) {
        if (rb_block_given_p()) {
            rb_warn("given block not used");
        }
        for (i = 0; i &lt; RARRAY_LEN(ary); ++i) {
            if (RTEST(rb_funcall(argv[0], idEqq, 1, RARRAY_AREF(ary, i)))) {
                if (result) return Qfalse;
                result = Qtrue;
            }
        }
    }
    else if (!rb_block_given_p()) {
        for (i = 0; i &lt; len; ++i) {
            if (RTEST(RARRAY_AREF(ary, i))) {
                if (result) return Qfalse;
                result = Qtrue;
            }
        }
    }
    else {
        for (i = 0; i &lt; RARRAY_LEN(ary); ++i) {
            if (RTEST(rb_yield(RARRAY_AREF(ary, i)))) {
                if (result) return Qfalse;
                result = Qtrue;
            }
        }
    }
    return result;
}</pre> </div>  <p>Returns <code>true</code> if exactly one element of <code>self</code> meets a given criterion.</p> <p>With no block given and no argument, returns <code>true</code> if <code>self</code> has exactly one truthy element, <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">[nil, 0].one? # =&gt; true
[0, 0].one? # =&gt; false
[nil, nil].one? # =&gt; false
[].one? # =&gt; false
</pre> <p>With a block given, calls the block with each element in <code>self</code>; returns <code>true</code> if the block a truthy value for exactly one element, <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">[0, 1, 2].one? {|element| element &gt; 0 } # =&gt; false
[0, 1, 2].one? {|element| element &gt; 1 } # =&gt; true
[0, 1, 2].one? {|element| element &gt; 2 } # =&gt; false
</pre> <p>With argument <code>object</code> given, returns <code>true</code> if for exactly one element <code>element</code>, <code>object === element</code>; <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">[0, 1, 2].one?(0) # =&gt; true
[0, 0, 1].one?(0) # =&gt; false
[1, 1, 2].one?(0) # =&gt; false
['food', 'drink'].one?(/bar/) # =&gt; false
['food', 'drink'].one?(/foo/) # =&gt; true
[].one?(/foo/) # =&gt; false
</pre> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Querying">Methods for Querying</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-pack"> <a href="#method-i-pack" title="Link to this method"> <span class="method-callseq"> pack(template, buffer: nil) → string </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="pack-source"> <pre class="ruby" data-language="ruby"># File pack.rb, line 7
def pack(fmt, buffer: nil)
  Primitive.pack_pack(fmt, buffer)
end</pre> </div>  <p>Formats each element in <code>self</code> into a binary string; returns that string. See <a href="packed_data_rdoc.html">Packed Data</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-permutation"> <a href="#method-i-permutation" title="Link to this method"> <span class="method-callseq"> permutation(count = self.size) {|permutation| ... } → self </span> </a> </div> <div class="method-heading"> <a href="#method-i-permutation" title="Link to this method"> <span class="method-callseq"> permutation(count = self.size) → new_enumerator </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="permutation-source"> <pre class="c" data-language="c">static VALUE
rb_ary_permutation(int argc, VALUE *argv, VALUE ary)
{
    long r, n, i;

    n = RARRAY_LEN(ary);                  /* Array length */
    RETURN_SIZED_ENUMERATOR(ary, argc, argv, rb_ary_permutation_size);   /* Return enumerator if no block */
    r = n;
    if (rb_check_arity(argc, 0, 1) &amp;&amp; !NIL_P(argv[0]))
        r = NUM2LONG(argv[0]);            /* Permutation size from argument */

    if (r &lt; 0 || n &lt; r) {
        /* no permutations: yield nothing */
    }
    else if (r == 0) { /* exactly one permutation: the zero-length array */
        rb_yield(rb_ary_new2(0));
    }
    else if (r == 1) { /* this is a special, easy case */
        for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
            rb_yield(rb_ary_new3(1, RARRAY_AREF(ary, i)));
        }
    }
    else {             /* this is the general case */
        volatile VALUE t0;
        long *p = ALLOCV_N(long, t0, r+roomof(n, sizeof(long)));
        char *used = (char*)(p + r);
        VALUE ary0 = ary_make_shared_copy(ary); /* private defensive copy of ary */
        RBASIC_CLEAR_CLASS(ary0);

        MEMZERO(used, char, n); /* initialize array */

        permute0(n, r, p, used, ary0); /* compute and yield permutations */
        ALLOCV_END(t0);
        RBASIC_SET_CLASS_RAW(ary0, rb_cArray);
    }
    return ary;
}</pre> </div>  <p>Iterates over permutations of the elements of <code>self</code>; the order of permutations is indeterminate.</p> <p>With a block and an in-range positive integer argument <code>count</code> (<code>0 &lt; count &lt;= self.size</code>) given, calls the block with each permutation of <code>self</code> of size <code>count</code>; returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">a = [0, 1, 2]
perms = []
a.permutation(1) {|perm| perms.push(perm) }
perms # =&gt; [[0], [1], [2]]

perms = []
a.permutation(2) {|perm| perms.push(perm) }
perms # =&gt; [[0, 1], [0, 2], [1, 0], [1, 2], [2, 0], [2, 1]]

perms = []
a.permutation(3) {|perm| perms.push(perm) }
perms # =&gt; [[0, 1, 2], [0, 2, 1], [1, 0, 2], [1, 2, 0], [2, 0, 1], [2, 1, 0]]
</pre> <p>When <code>count</code> is zero, calls the block once with a new empty array:</p> <pre class="ruby" data-language="ruby">perms = []
a.permutation(0) {|perm| perms.push(perm) }
perms # =&gt; [[]]
</pre> <p>When <code>count</code> is out of range (negative or larger than <code>self.size</code>), does not call the block:</p> <pre class="ruby" data-language="ruby">a.permutation(-1) {|permutation| fail 'Cannot happen' }
a.permutation(4) {|permutation| fail 'Cannot happen' }
</pre> <p>With no block given, returns a new <a href="enumerator.html"><code>Enumerator</code></a>.</p> <p>Related: <a href="array.html#class-Array-label-Methods+for+Iterating">Methods for Iterating</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-pop"> <a href="#method-i-pop" title="Link to this method"> <span class="method-callseq"> pop → object or nil </span> </a> </div> <div class="method-heading"> <a href="#method-i-pop" title="Link to this method"> <span class="method-callseq"> pop(count) → new_array </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="pop-source"> <pre class="c" data-language="c">static VALUE
rb_ary_pop_m(int argc, VALUE *argv, VALUE ary)
{
    VALUE result;

    if (argc == 0) {
        return rb_ary_pop(ary);
    }

    rb_ary_modify_check(ary);
    result = ary_take_first_or_last(argc, argv, ary, ARY_TAKE_LAST);
    ARY_INCREASE_LEN(ary, -RARRAY_LEN(result));
    ary_verify(ary);
    return result;
}</pre> </div>  <p>Removes and returns trailing elements of <code>self</code>.</p> <p>With no argument given, removes and returns the last element, if available; otherwise returns <code>nil</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.pop  # =&gt; 2
a      # =&gt; [:foo, "bar"]
[].pop # =&gt; nil
</pre> <p>With non-negative integer argument <code>count</code> given, returns a new array containing the trailing <code>count</code> elements of <code>self</code>, as available:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.pop(2) # =&gt; ["bar", 2]
a        # =&gt; [:foo]

a = [:foo, 'bar', 2]
a.pop(50) # =&gt; [:foo, "bar", 2]
a         # =&gt; []
</pre> <p>Related: <a href="array.html#method-i-push"><code>Array#push</code></a>; see also <a href="array.html#class-Array-label-Methods+for+Deleting">Methods for Deleting</a>.</p> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-prepend"> <a href="#method-i-prepend" title="Link to this method"> <span class="method-callseq"> prepend(*objects) → self </span> </a> </div> </div> <div class="method-description"> <p>Prepends the given <code>objects</code> to <code>self</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.unshift(:bam, :bat) # =&gt; [:bam, :bat, :foo, "bar", 2]
</pre> <p>Related: <a href="array.html#method-i-shift"><code>Array#shift</code></a>; see also <a href="array.html#class-Array-label-Methods+for+Assigning">Methods for Assigning</a>.</p> </div> <div class="aliases"> Alias for: <a href="array.html#method-i-unshift">unshift</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-product"> <a href="#method-i-product" title="Link to this method"> <span class="method-callseq"> product(*other_arrays) → new_array </span> </a> </div> <div class="method-heading"> <a href="#method-i-product" title="Link to this method"> <span class="method-callseq"> product(*other_arrays) {|combination| ... } → self </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="product-source"> <pre class="c" data-language="c">static VALUE
rb_ary_product(int argc, VALUE *argv, VALUE ary)
{
    int n = argc+1;    /* How many arrays we're operating on */
    volatile VALUE t0 = rb_ary_hidden_new(n);
    volatile VALUE t1 = Qundef;
    VALUE *arrays = RARRAY_PTR(t0); /* The arrays we're computing the product of */
    int *counters = ALLOCV_N(int, t1, n); /* The current position in each one */
    VALUE result = Qnil;      /* The array we'll be returning, when no block given */
    long i,j;
    long resultlen = 1;

    RBASIC_CLEAR_CLASS(t0);

    /* initialize the arrays of arrays */
    ARY_SET_LEN(t0, n);
    arrays[0] = ary;
    for (i = 1; i &lt; n; i++) arrays[i] = Qnil;
    for (i = 1; i &lt; n; i++) arrays[i] = to_ary(argv[i-1]);

    /* initialize the counters for the arrays */
    for (i = 0; i &lt; n; i++) counters[i] = 0;

    /* Otherwise, allocate and fill in an array of results */
    if (rb_block_given_p()) {
        /* Make defensive copies of arrays; exit if any is empty */
        for (i = 0; i &lt; n; i++) {
            if (RARRAY_LEN(arrays[i]) == 0) goto done;
            arrays[i] = ary_make_shared_copy(arrays[i]);
        }
    }
    else {
        /* Compute the length of the result array; return [] if any is empty */
        for (i = 0; i &lt; n; i++) {
            long k = RARRAY_LEN(arrays[i]);
            if (k == 0) {
                result = rb_ary_new2(0);
                goto done;
            }
            if (MUL_OVERFLOW_LONG_P(resultlen, k))
                rb_raise(rb_eRangeError, "too big to product");
            resultlen *= k;
        }
        result = rb_ary_new2(resultlen);
    }
    for (;;) {
        int m;
        /* fill in one subarray */
        VALUE subarray = rb_ary_new2(n);
        for (j = 0; j &lt; n; j++) {
            rb_ary_push(subarray, rb_ary_entry(arrays[j], counters[j]));
        }

        /* put it on the result array */
        if (NIL_P(result)) {
            FL_SET(t0, RARRAY_SHARED_ROOT_FLAG);
            rb_yield(subarray);
            if (!FL_TEST(t0, RARRAY_SHARED_ROOT_FLAG)) {
                rb_raise(rb_eRuntimeError, "product reentered");
            }
            else {
                FL_UNSET(t0, RARRAY_SHARED_ROOT_FLAG);
            }
        }
        else {
            rb_ary_push(result, subarray);
        }

        /*
         * Increment the last counter.  If it overflows, reset to 0
         * and increment the one before it.
         */
        m = n-1;
        counters[m]++;
        while (counters[m] == RARRAY_LEN(arrays[m])) {
            counters[m] = 0;
            /* If the first counter overflows, we are done */
            if (--m &lt; 0) goto done;
            counters[m]++;
        }
    }

done:
    ALLOCV_END(t1);

    return NIL_P(result) ? ary : result;
}</pre> </div>  <p>Computes all combinations of elements from all the arrays, including both <code>self</code> and <code>other_arrays</code>:</p> <ul>
<li> <p>The number of combinations is the product of the sizes of all the arrays, including both <code>self</code> and <code>other_arrays</code>.</p> </li>
<li> <p>The order of the returned combinations is indeterminate.</p> </li>
</ul> <p>With no block given, returns the combinations as an array of arrays:</p> <pre class="ruby" data-language="ruby">p = [0, 1].product([2, 3])
# =&gt; [[0, 2], [0, 3], [1, 2], [1, 3]]
p.size # =&gt; 4
p = [0, 1].product([2, 3], [4, 5])
# =&gt; [[0, 2, 4], [0, 2, 5], [0, 3, 4], [0, 3, 5], [1, 2, 4], [1, 2, 5], [1, 3, 4], [1, 3,...
p.size # =&gt; 8
</pre> <p>If <code>self</code> or any argument is empty, returns an empty array:</p> <pre class="ruby" data-language="ruby">[].product([2, 3], [4, 5]) # =&gt; []
[0, 1].product([2, 3], []) # =&gt; []
</pre> <p>If no argument is given, returns an array of 1-element arrays, each containing an element of <code>self</code>:</p> <pre class="ruby" data-language="ruby">a.product # =&gt; [[0], [1], [2]]
</pre> <p>With a block given, calls the block with each combination; returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">p = []
[0, 1].product([2, 3]) {|combination| p.push(combination) }
p # =&gt; [[0, 2], [0, 3], [1, 2], [1, 3]]
</pre> <p>If <code>self</code> or any argument is empty, does not call the block:</p> <pre class="ruby" data-language="ruby">[].product([2, 3], [4, 5]) {|combination| fail 'Cannot happen' }
# =&gt; []
[0, 1].product([2, 3], []) {|combination| fail 'Cannot happen' }
# =&gt; [0, 1]
</pre> <p>If no argument is given, calls the block with each element of <code>self</code> as a 1-element array:</p> <pre class="ruby" data-language="ruby">p = []
[0, 1].product {|combination| p.push(combination) }
p # =&gt; [[0], [1]]
</pre> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Combining">Methods for Combining</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-push"> <a href="#method-i-push" title="Link to this method"> <span class="method-callseq"> push(*objects) → self </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="push-source"> <pre class="c" data-language="c">static VALUE
rb_ary_push_m(int argc, VALUE *argv, VALUE ary)
{
    return rb_ary_cat(ary, argv, argc);
}</pre> </div>  <p>Appends each argument in <code>objects</code> to <code>self</code>; returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2] # =&gt; [:foo, "bar", 2]
a.push(:baz, :bat)   # =&gt; [:foo, "bar", 2, :baz, :bat]
</pre> <p>Appends each argument as a single element, even if it is another array:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]               # =&gt; [:foo, "bar", 2]
a.push([:baz, :bat], [:bam, :bad]) # =&gt; [:foo, "bar", 2, [:baz, :bat], [:bam, :bad]]
</pre> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Assigning">Methods for Assigning</a>.</p> </div> <div class="aliases"> Also aliased as: <a href="array.html#method-i-append">append</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-rassoc"> <a href="#method-i-rassoc" title="Link to this method"> <span class="method-callseq"> rassoc(object) → found_array or nil </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="rassoc-source"> <pre class="c" data-language="c">VALUE
rb_ary_rassoc(VALUE ary, VALUE value)
{
    long i;
    VALUE v;

    for (i = 0; i &lt; RARRAY_LEN(ary); ++i) {
        v = rb_check_array_type(RARRAY_AREF(ary, i));
        if (RB_TYPE_P(v, T_ARRAY) &amp;&amp;
            RARRAY_LEN(v) &gt; 1 &amp;&amp;
            rb_equal(RARRAY_AREF(v, 1), value))
            return v;
    }
    return Qnil;
}</pre> </div>  <p>Returns the first element <code>ele</code> in <code>self</code> such that <code>ele</code> is an array and <code>ele[1] == object</code>:</p> <pre class="ruby" data-language="ruby">a = [{foo: 0}, [2, 4], [4, 5, 6], [4, 5]]
a.rassoc(4) # =&gt; [2, 4]
a.rassoc(5) # =&gt; [4, 5, 6]
</pre> <p>Returns <code>nil</code> if no such element is found.</p> <p>Related: <a href="array.html#method-i-assoc"><code>Array#assoc</code></a>; see also <a href="array.html#class-Array-label-Methods+for+Fetching">Methods for Fetching</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-reject"> <a href="#method-i-reject" title="Link to this method"> <span class="method-callseq"> reject {|element| ... } → new_array </span> </a> </div> <div class="method-heading"> <a href="#method-i-reject" title="Link to this method"> <span class="method-callseq"> reject → new_enumerator </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="reject-source"> <pre class="c" data-language="c">static VALUE
rb_ary_reject(VALUE ary)
{
    VALUE rejected_ary;

    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);
    rejected_ary = rb_ary_new();
    ary_reject(ary, rejected_ary);
    return rejected_ary;
}</pre> </div>  <p>With a block given, returns a new array whose elements are all those from <code>self</code> for which the block returns <code>false</code> or <code>nil</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2, 'bat']
a1 = a.reject {|element| element.to_s.start_with?('b') }
a1 # =&gt; [:foo, 2]
</pre> <p>With no block given, returns a new <a href="enumerator.html"><code>Enumerator</code></a>.</p> <p>Related: <a href="array.html#class-Array-label-Methods+for+Fetching">Methods for Fetching</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-reject-21"> <a href="#method-i-reject-21" title="Link to this method"> <span class="method-callseq"> reject! {|element| ... } → self or nil </span> </a> </div> <div class="method-heading"> <a href="#method-i-reject-21" title="Link to this method"> <span class="method-callseq"> reject! → new_enumerator </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="reject-21-source"> <pre class="c" data-language="c">static VALUE
rb_ary_reject_bang(VALUE ary)
{
    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);
    rb_ary_modify(ary);
    return ary_reject_bang(ary);
}</pre> </div>  <p>With a block given, calls the block with each element of <code>self</code>; removes each element for which the block returns a truthy value.</p> <p>Returns <code>self</code> if any elements removed:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2, 'bat']
a.reject! {|element| element.to_s.start_with?('b') } # =&gt; [:foo, 2]
</pre> <p>Returns <code>nil</code> if no elements removed.</p> <p>With no block given, returns a new <a href="enumerator.html"><code>Enumerator</code></a>.</p> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Deleting">Methods for Deleting</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-repeated_combination"> <a href="#method-i-repeated_combination" title="Link to this method"> <span class="method-callseq"> repeated_combination(size) {|combination| ... } → self </span> </a> </div> <div class="method-heading"> <a href="#method-i-repeated_combination" title="Link to this method"> <span class="method-callseq"> repeated_combination(size) → new_enumerator </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="repeated_combination-source"> <pre class="c" data-language="c">static VALUE
rb_ary_repeated_combination(VALUE ary, VALUE num)
{
    long n, i, len;

    n = NUM2LONG(num);                 /* Combination size from argument */
    RETURN_SIZED_ENUMERATOR(ary, 1, &amp;num, rb_ary_repeated_combination_size);   /* Return enumerator if no block */
    len = RARRAY_LEN(ary);
    if (n &lt; 0) {
        /* yield nothing */
    }
    else if (n == 0) {
        rb_yield(rb_ary_new2(0));
    }
    else if (n == 1) {
        for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
            rb_yield(rb_ary_new3(1, RARRAY_AREF(ary, i)));
        }
    }
    else if (len == 0) {
        /* yield nothing */
    }
    else {
        volatile VALUE t0;
        long *p = ALLOCV_N(long, t0, n);
        VALUE ary0 = ary_make_shared_copy(ary); /* private defensive copy of ary */
        RBASIC_CLEAR_CLASS(ary0);

        rcombinate0(len, n, p, n, ary0); /* compute and yield repeated combinations */
        ALLOCV_END(t0);
        RBASIC_SET_CLASS_RAW(ary0, rb_cArray);
    }
    return ary;
}</pre> </div>  <p>With a block given, calls the block with each repeated combination of length <code>size</code> of the elements of <code>self</code>; each combination is an array; returns <code>self</code>. The order of the combinations is indeterminate.</p> <p>If a positive integer argument <code>size</code> is given, calls the block with each <code>size</code>-tuple repeated combination of the elements of <code>self</code>. The number of combinations is <code>(size+1)(size+2)/2</code>.</p> <p>Examples:</p> <ul>
<li> <p><code>size</code> is 1:</p> <pre class="ruby" data-language="ruby">c = []
[0, 1, 2].repeated_combination(1) {|combination| c.push(combination) }
c # =&gt; [[0], [1], [2]]
</pre> </li>
<li> <p><code>size</code> is 2:</p> <pre class="ruby" data-language="ruby">c = []
[0, 1, 2].repeated_combination(2) {|combination| c.push(combination) }
c # =&gt; [[0, 0], [0, 1], [0, 2], [1, 1], [1, 2], [2, 2]]
</pre> </li>
</ul> <p>If <code>size</code> is zero, calls the block once with an empty array.</p> <p>If <code>size</code> is negative, does not call the block:</p> <pre class="ruby" data-language="ruby">[0, 1, 2].repeated_combination(-1) {|combination| fail 'Cannot happen' }
</pre> <p>With no block given, returns a new <a href="enumerator.html"><code>Enumerator</code></a>.</p> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Combining">Methods for Combining</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-repeated_permutation"> <a href="#method-i-repeated_permutation" title="Link to this method"> <span class="method-callseq"> repeated_permutation(size) {|permutation| ... } → self </span> </a> </div> <div class="method-heading"> <a href="#method-i-repeated_permutation" title="Link to this method"> <span class="method-callseq"> repeated_permutation(size) → new_enumerator </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="repeated_permutation-source"> <pre class="c" data-language="c">static VALUE
rb_ary_repeated_permutation(VALUE ary, VALUE num)
{
    long r, n, i;

    n = RARRAY_LEN(ary);                  /* Array length */
    RETURN_SIZED_ENUMERATOR(ary, 1, &amp;num, rb_ary_repeated_permutation_size);      /* Return Enumerator if no block */
    r = NUM2LONG(num);                    /* Permutation size from argument */

    if (r &lt; 0) {
        /* no permutations: yield nothing */
    }
    else if (r == 0) { /* exactly one permutation: the zero-length array */
        rb_yield(rb_ary_new2(0));
    }
    else if (r == 1) { /* this is a special, easy case */
        for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
            rb_yield(rb_ary_new3(1, RARRAY_AREF(ary, i)));
        }
    }
    else {             /* this is the general case */
        volatile VALUE t0;
        long *p = ALLOCV_N(long, t0, r);
        VALUE ary0 = ary_make_shared_copy(ary); /* private defensive copy of ary */
        RBASIC_CLEAR_CLASS(ary0);

        rpermute0(n, r, p, ary0); /* compute and yield repeated permutations */
        ALLOCV_END(t0);
        RBASIC_SET_CLASS_RAW(ary0, rb_cArray);
    }
    return ary;
}</pre> </div>  <p>With a block given, calls the block with each repeated permutation of length <code>size</code> of the elements of <code>self</code>; each permutation is an array; returns <code>self</code>. The order of the permutations is indeterminate.</p> <p>If a positive integer argument <code>size</code> is given, calls the block with each <code>size</code>-tuple repeated permutation of the elements of <code>self</code>. The number of permutations is <code>self.size**size</code>.</p> <p>Examples:</p> <ul>
<li> <p><code>size</code> is 1:</p> <pre class="ruby" data-language="ruby">p = []
[0, 1, 2].repeated_permutation(1) {|permutation| p.push(permutation) }
p # =&gt; [[0], [1], [2]]
</pre> </li>
<li> <p><code>size</code> is 2:</p> <pre class="ruby" data-language="ruby">p = []
[0, 1, 2].repeated_permutation(2) {|permutation| p.push(permutation) }
p # =&gt; [[0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2], [2, 0], [2, 1], [2, 2]]
</pre> </li>
</ul> <p>If <code>size</code> is zero, calls the block once with an empty array.</p> <p>If <code>size</code> is negative, does not call the block:</p> <pre class="ruby" data-language="ruby">[0, 1, 2].repeated_permutation(-1) {|permutation| fail 'Cannot happen' }
</pre> <p>With no block given, returns a new <a href="enumerator.html"><code>Enumerator</code></a>.</p> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Combining">Methods for Combining</a>.</p> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-replace"> <a href="#method-i-replace" title="Link to this method"> <span class="method-callseq"> replace(other_array) → self </span> </a> </div> </div> <div class="method-description"> <p>Replaces the elements of <code>self</code> with the elements of <code>other_array</code>, which must be an <a href="implicit_conversion_rdoc.html#label-Array-Convertible+Objects">array-convertible object</a>; returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">a = ['a', 'b', 'c']   # =&gt; ["a", "b", "c"]
a.replace(['d', 'e']) # =&gt; ["d", "e"]
</pre> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Assigning">Methods for Assigning</a>.</p> </div> <div class="aliases"> Alias for: <a href="array.html#method-i-initialize_copy">initialize_copy</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-reverse"> <a href="#method-i-reverse" title="Link to this method"> <span class="method-callseq"> reverse → new_array </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="reverse-source"> <pre class="c" data-language="c">static VALUE
rb_ary_reverse_m(VALUE ary)
{
    long len = RARRAY_LEN(ary);
    VALUE dup = rb_ary_new2(len);

    if (len &gt; 0) {
        const VALUE *p1 = RARRAY_CONST_PTR(ary);
        VALUE *p2 = (VALUE *)RARRAY_CONST_PTR(dup) + len - 1;
        do *p2-- = *p1++; while (--len &gt; 0);
    }
    ARY_SET_LEN(dup, RARRAY_LEN(ary));
    return dup;
}</pre> </div>  <p>Returns a new array containing the elements of <code>self</code> in reverse order:</p> <pre class="ruby" data-language="ruby">[0, 1, 2].reverse # =&gt; [2, 1, 0]
</pre> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Combining">Methods for Combining</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-reverse-21"> <a href="#method-i-reverse-21" title="Link to this method"> <span class="method-callseq"> reverse! → self </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="reverse-21-source"> <pre class="c" data-language="c">static VALUE
rb_ary_reverse_bang(VALUE ary)
{
    return rb_ary_reverse(ary);
}</pre> </div>  <p>Reverses the order of the elements of <code>self</code>; returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">a = [0, 1, 2]
a.reverse! # =&gt; [2, 1, 0]
a          # =&gt; [2, 1, 0]
</pre> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Assigning">Methods for Assigning</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-reverse_each"> <a href="#method-i-reverse_each" title="Link to this method"> <span class="method-callseq"> reverse_each {|element| ... } → self </span> </a> </div> <div class="method-heading"> <a href="#method-i-reverse_each" title="Link to this method"> <span class="method-callseq"> reverse_each → Enumerator </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="reverse_each-source"> <pre class="c" data-language="c">static VALUE
rb_ary_reverse_each(VALUE ary)
{
    long len;

    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);
    len = RARRAY_LEN(ary);
    while (len--) {
        long nlen;
        rb_yield(RARRAY_AREF(ary, len));
        nlen = RARRAY_LEN(ary);
        if (nlen &lt; len) {
            len = nlen;
        }
    }
    return ary;
}</pre> </div>  <p>When a block given, iterates backwards over the elements of <code>self</code>, passing, in reverse order, each element to the block; returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">a = []
[0, 1, 2].reverse_each {|element| a.push(element) }
a # =&gt; [2, 1, 0]
</pre> <p>Allows the array to be modified during iteration:</p> <pre class="ruby" data-language="ruby">a = ['a', 'b', 'c']
a.reverse_each {|element| a.clear if element.start_with?('b') }
a # =&gt; []
</pre> <p>When no block given, returns a new <a href="enumerator.html"><code>Enumerator</code></a>.</p> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Iterating">Methods for Iterating</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-rindex"> <a href="#method-i-rindex" title="Link to this method"> <span class="method-callseq"> rindex(object) → integer or nil </span> </a> </div> <div class="method-heading"> <a href="#method-i-rindex" title="Link to this method"> <span class="method-callseq"> rindex {|element| ... } → integer or nil </span> </a> </div> <div class="method-heading"> <a href="#method-i-rindex" title="Link to this method"> <span class="method-callseq"> rindex → new_enumerator </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="rindex-source"> <pre class="c" data-language="c">static VALUE
rb_ary_rindex(int argc, VALUE *argv, VALUE ary)
{
    VALUE val;
    long i = RARRAY_LEN(ary), len;

    if (argc == 0) {
        RETURN_ENUMERATOR(ary, 0, 0);
        while (i--) {
            if (RTEST(rb_yield(RARRAY_AREF(ary, i))))
                return LONG2NUM(i);
            if (i &gt; (len = RARRAY_LEN(ary))) {
                i = len;
            }
        }
        return Qnil;
    }
    rb_check_arity(argc, 0, 1);
    val = argv[0];
    if (rb_block_given_p())
        rb_warn("given block not used");
    while (i--) {
        VALUE e = RARRAY_AREF(ary, i);
        if (rb_equal(e, val)) {
            return LONG2NUM(i);
        }
        if (i &gt; RARRAY_LEN(ary)) {
            break;
        }
    }
    return Qnil;
}</pre> </div>  <p>Returns the index of the last element for which <code>object == element</code>.</p> <p>With argument <code>object</code> given, returns the index of the last such element found:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2, 'bar']
a.rindex('bar') # =&gt; 3
</pre> <p>Returns <code>nil</code> if no such object found.</p> <p>With a block given, calls the block with each successive element; returns the index of the last element for which the block returns a truthy value:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2, 'bar']
a.rindex {|element| element == 'bar' } # =&gt; 3
</pre> <p>Returns <code>nil</code> if the block never returns a truthy value.</p> <p>When neither an argument nor a block is given, returns a new <a href="enumerator.html"><code>Enumerator</code></a>.</p> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Querying">Methods for Querying</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-rotate"> <a href="#method-i-rotate" title="Link to this method"> <span class="method-callseq"> rotate(count = 1) → new_array </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="rotate-source"> <pre class="c" data-language="c">static VALUE
rb_ary_rotate_m(int argc, VALUE *argv, VALUE ary)
{
    VALUE rotated;
    const VALUE *ptr;
    long len;
    long cnt = (rb_check_arity(argc, 0, 1) ? NUM2LONG(argv[0]) : 1);

    len = RARRAY_LEN(ary);
    rotated = rb_ary_new2(len);
    if (len &gt; 0) {
        cnt = rotate_count(cnt, len);
        ptr = RARRAY_CONST_PTR(ary);
        len -= cnt;
        ary_memcpy(rotated, 0, len, ptr + cnt);
        ary_memcpy(rotated, len, cnt, ptr);
    }
    ARY_SET_LEN(rotated, RARRAY_LEN(ary));
    return rotated;
}</pre> </div>  <p>Returns a new array formed from <code>self</code> with elements rotated from one end to the other.</p> <p>With non-negative numeric <code>count</code>, rotates elements from the beginning to the end:</p> <pre class="ruby" data-language="ruby">[0, 1, 2, 3].rotate(2)   # =&gt; [2, 3, 0, 1]
[0, 1, 2, 3].rotate(2.1) # =&gt; [2, 3, 0, 1]
</pre> <p>If <code>count</code> is large, uses <code>count % array.size</code> as the count:</p> <pre class="ruby" data-language="ruby">[0, 1, 2, 3].rotate(22) # =&gt; [2, 3, 0, 1]
</pre> <p>With a <code>count</code> of zero, rotates no elements:</p> <pre class="ruby" data-language="ruby">[0, 1, 2, 3].rotate(0) # =&gt; [0, 1, 2, 3]
</pre> <p>With negative numeric <code>count</code>, rotates in the opposite direction, from the end to the beginning:</p> <pre class="ruby" data-language="ruby">[0, 1, 2, 3].rotate(-1) # =&gt; [3, 0, 1, 2]
</pre> <p>If <code>count</code> is small (far from zero), uses <code>count % array.size</code> as the count:</p> <pre class="ruby" data-language="ruby">[0, 1, 2, 3].rotate(-21) # =&gt; [3, 0, 1, 2]
</pre> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Fetching">Methods for Fetching</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-rotate-21"> <a href="#method-i-rotate-21" title="Link to this method"> <span class="method-callseq"> rotate!(count = 1) → self </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="rotate-21-source"> <pre class="c" data-language="c">static VALUE
rb_ary_rotate_bang(int argc, VALUE *argv, VALUE ary)
{
    long n = (rb_check_arity(argc, 0, 1) ? NUM2LONG(argv[0]) : 1);
    rb_ary_rotate(ary, n);
    return ary;
}</pre> </div>  <p>Rotates <code>self</code> in place by moving elements from one end to the other; returns <code>self</code>.</p> <p>With non-negative numeric <code>count</code>, rotates <code>count</code> elements from the beginning to the end:</p> <pre class="ruby" data-language="ruby">[0, 1, 2, 3].rotate!(2)   # =&gt; [2, 3, 0, 1]
[0, 1, 2, 3].rotate!(2.1) # =&gt; [2, 3, 0, 1]
</pre> <p>If <code>count</code> is large, uses <code>count % array.size</code> as the count:</p> <pre class="ruby" data-language="ruby">[0, 1, 2, 3].rotate!(21) # =&gt; [1, 2, 3, 0]
</pre> <p>If <code>count</code> is zero, rotates no elements:</p> <pre class="ruby" data-language="ruby">[0, 1, 2, 3].rotate!(0) # =&gt; [0, 1, 2, 3]
</pre> <p>With a negative numeric <code>count</code>, rotates in the opposite direction, from end to beginning:</p> <pre class="ruby" data-language="ruby">[0, 1, 2, 3].rotate!(-1) # =&gt; [3, 0, 1, 2]
</pre> <p>If <code>count</code> is small (far from zero), uses <code>count % array.size</code> as the count:</p> <pre class="ruby" data-language="ruby">[0, 1, 2, 3].rotate!(-21) # =&gt; [3, 0, 1, 2]
</pre> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Assigning">Methods for Assigning</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-sample"> <a href="#method-i-sample" title="Link to this method"> <span class="method-callseq"> sample(random: Random) → object </span> </a> </div> <div class="method-heading"> <a href="#method-i-sample" title="Link to this method"> <span class="method-callseq"> sample(count, random: Random) → new_ary </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="sample-source"> <pre class="ruby" data-language="ruby"># File array.rb, line 95
def sample(n = (ary = false), random: Random)
  if Primitive.mandatory_only?
    # Primitive.cexpr! %{ rb_ary_sample(self, rb_cRandom, Qfalse, Qfalse) }
    Primitive.ary_sample0
  else
    # Primitive.cexpr! %{ rb_ary_sample(self, random, n, ary) }
    Primitive.ary_sample(random, n, ary)
  end
end</pre> </div>  <p>Returns random elements from <code>self</code>, as selected by the object given by the keyword argument <code>random</code>.</p> <p>With no argument <code>count</code> given, returns one random element from <code>self</code>:</p> <pre class="ruby" data-language="ruby">a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
a.sample # =&gt; 3
a.sample # =&gt; 8
</pre> <p>Returns <code>nil</code> if <code>self</code> is empty:</p> <pre class="ruby" data-language="ruby">[].sample # =&gt; nil
</pre> <p>With a non-negative numeric argument <code>count</code> given, returns a new array containing <code>count</code> random elements from <code>self</code>:</p> <pre class="ruby" data-language="ruby">a.sample(3) # =&gt; [8, 9, 2]
a.sample(6) # =&gt; [9, 6, 0, 3, 1, 4]
</pre> <p>The order of the result array is unrelated to the order of <code>self</code>.</p> <p>Returns a new empty <a href="array.html"><code>Array</code></a> if <code>self</code> is empty:</p> <pre class="ruby" data-language="ruby">[].sample(4) # =&gt; []
</pre> <p>May return duplicates in <code>self</code>:</p> <pre class="ruby" data-language="ruby">a = [1, 1, 1, 2, 2, 3]
a.sample(a.size) # =&gt; [1, 1, 3, 2, 1, 2]
</pre> <p>Returns no more than <code>a.size</code> elements (because no new duplicates are introduced):</p> <pre class="ruby" data-language="ruby">a.sample(50) # =&gt; [6, 4, 1, 8, 5, 9, 0, 2, 3, 7]
</pre> <p>The object given with the keyword argument <code>random</code> is used as the random number generator:</p> <pre class="ruby" data-language="ruby">a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
a.sample(random: Random.new(1))     # =&gt; 6
a.sample(4, random: Random.new(1))  # =&gt; [6, 10, 9, 2]
</pre> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Fetching">Methods for Fetching</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-select"> <a href="#method-i-select" title="Link to this method"> <span class="method-callseq"> select {|element| ... } → new_array </span> </a> </div> <div class="method-heading"> <a href="#method-i-select" title="Link to this method"> <span class="method-callseq"> select → new_enumerator </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="select-source"> <pre class="c" data-language="c">static VALUE
rb_ary_select(VALUE ary)
{
    VALUE result;
    long i;

    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);
    result = rb_ary_new2(RARRAY_LEN(ary));
    for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
        if (RTEST(rb_yield(RARRAY_AREF(ary, i)))) {
            rb_ary_push(result, rb_ary_elt(ary, i));
        }
    }
    return result;
}</pre> </div>  <p>With a block given, calls the block with each element of <code>self</code>; returns a new array containing those elements of <code>self</code> for which the block returns a truthy value:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2, :bam]
a.select {|element| element.to_s.start_with?('b') }
# =&gt; ["bar", :bam]
</pre> <p>With no block given, returns a new <a href="enumerator.html"><code>Enumerator</code></a>.</p> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Fetching">Methods for Fetching</a>.</p> </div> <div class="aliases"> Also aliased as: <a href="array.html#method-i-filter">filter</a>, filter </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-select-21"> <a href="#method-i-select-21" title="Link to this method"> <span class="method-callseq"> select! {|element| ... } → self or nil </span> </a> </div> <div class="method-heading"> <a href="#method-i-select-21" title="Link to this method"> <span class="method-callseq"> select! → new_enumerator </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="select-21-source"> <pre class="c" data-language="c">static VALUE
rb_ary_select_bang(VALUE ary)
{
    struct select_bang_arg args;

    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);
    rb_ary_modify(ary);

    args.ary = ary;
    args.len[0] = args.len[1] = 0;
    return rb_ensure(select_bang_i, (VALUE)&amp;args, select_bang_ensure, (VALUE)&amp;args);
}</pre> </div>  <p>With a block given, calls the block with each element of <code>self</code>; removes from <code>self</code> those elements for which the block returns <code>false</code> or <code>nil</code>.</p> <p>Returns <code>self</code> if any elements were removed:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2, :bam]
a.select! {|element| element.to_s.start_with?('b') } # =&gt; ["bar", :bam]
</pre> <p>Returns <code>nil</code> if no elements were removed.</p> <p>With no block given, returns a new <a href="enumerator.html"><code>Enumerator</code></a>.</p> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Deleting">Methods for Deleting</a>.</p> </div> <div class="aliases"> Also aliased as: <a href="array.html#method-i-filter-21">filter!</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-shelljoin"> <a href="#method-i-shelljoin" title="Link to this method"> <span class="method-callseq"> shelljoin → string </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="shelljoin-source"> <pre class="ruby" data-language="ruby"># File lib/shellwords.rb, line 251
def shelljoin
  Shellwords.join(self)
end</pre> </div>  <p>Builds a command line string from an argument list <code>array</code> joining all elements escaped for the Bourne shell and separated by a space.</p> <p>See <a href="shellwords.html#method-c-shelljoin"><code>Shellwords.shelljoin</code></a> for details.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-shift"> <a href="#method-i-shift" title="Link to this method"> <span class="method-callseq"> shift → object or nil </span> </a> </div> <div class="method-heading"> <a href="#method-i-shift" title="Link to this method"> <span class="method-callseq"> shift(count) → new_array or nil </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="shift-source"> <pre class="c" data-language="c">static VALUE
rb_ary_shift_m(int argc, VALUE *argv, VALUE ary)
{
    VALUE result;
    long n;

    if (argc == 0) {
        return rb_ary_shift(ary);
    }

    rb_ary_modify_check(ary);
    result = ary_take_first_or_last(argc, argv, ary, ARY_TAKE_FIRST);
    n = RARRAY_LEN(result);
    rb_ary_behead(ary,n);

    return result;
}</pre> </div>  <p>Removes and returns leading elements from <code>self</code>.</p> <p>With no argument, removes and returns one element, if available, or <code>nil</code> otherwise:</p> <pre class="ruby" data-language="ruby">a = [0, 1, 2, 3]
a.shift  # =&gt; 0
a        # =&gt; [1, 2, 3]
[].shift # =&gt; nil
</pre> <p>With non-negative numeric argument <code>count</code> given, removes and returns the first <code>count</code> elements:</p> <pre class="ruby" data-language="ruby">a = [0, 1, 2, 3]
a.shift(2)   # =&gt; [0, 1]
a            # =&gt; [2, 3]
a.shift(1.1) # =&gt; [2]
a            # =&gt; [3]
a.shift(0)   # =&gt; []
a            # =&gt; [3]
</pre> <p>If <code>count</code> is large, removes and returns all elements:</p> <pre class="ruby" data-language="ruby">a = [0, 1, 2, 3]
a.shift(50) # =&gt; [0, 1, 2, 3]
a           # =&gt; []
</pre> <p>If <code>self</code> is empty, returns a new empty array.</p> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Deleting">Methods for Deleting</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-shuffle"> <a href="#method-i-shuffle" title="Link to this method"> <span class="method-callseq"> shuffle(random: Random) → new_array </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="shuffle-source"> <pre class="ruby" data-language="ruby"># File array.rb, line 45
def shuffle(random: Random)
  Primitive.rb_ary_shuffle(random)
end</pre> </div>  <p>Returns a new array containing all elements from <code>self</code> in a random order, as selected by the object given by the keyword argument <code>random</code>:</p> <pre class="ruby" data-language="ruby">a =            [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
a.shuffle # =&gt; [0, 8, 1, 9, 6, 3, 4, 7, 2, 5]
a.shuffle # =&gt; [8, 9, 0, 5, 1, 2, 6, 4, 7, 3]
</pre> <p>Duplicate elements are included:</p> <pre class="ruby" data-language="ruby">a =            [0, 1, 0, 1, 0, 1, 0, 1, 0, 1]
a.shuffle # =&gt; [1, 0, 1, 1, 0, 0, 1, 0, 0, 1]
a.shuffle # =&gt; [1, 1, 0, 0, 0, 1, 1, 0, 0, 1]
</pre> <p>The object given with the keyword argument <code>random</code> is used as the random number generator.</p> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Fetching">Methods for Fetching</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-shuffle-21"> <a href="#method-i-shuffle-21" title="Link to this method"> <span class="method-callseq"> shuffle!(random: Random) → self </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="shuffle-21-source"> <pre class="ruby" data-language="ruby"># File array.rb, line 22
def shuffle!(random: Random)
  Primitive.rb_ary_shuffle_bang(random)
end</pre> </div>  <p>Shuffles all elements in <code>self</code> into a random order, as selected by the object given by the keyword argument <code>random</code>. Returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">a =             [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
a.shuffle! # =&gt; [5, 3, 8, 7, 6, 1, 9, 4, 2, 0]
a.shuffle! # =&gt; [9, 4, 0, 6, 2, 8, 1, 5, 3, 7]
</pre> <p>Duplicate elements are included:</p> <pre class="ruby" data-language="ruby">a =             [0, 1, 0, 1, 0, 1, 0, 1, 0, 1]
a.shuffle! # =&gt; [1, 0, 0, 1, 1, 0, 1, 0, 0, 1]
a.shuffle! # =&gt; [0, 1, 0, 1, 1, 0, 1, 0, 1, 0]
</pre> <p>The object given with the keyword argument <code>random</code> is used as the random number generator.</p> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Assigning">Methods for Assigning</a>.</p> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-size"> <a href="#method-i-size" title="Link to this method"> <span class="method-callseq"> size → integer </span> </a> </div> </div> <div class="method-description"> <p>Returns the count of elements in <code>self</code>:</p> <pre class="ruby" data-language="ruby">[0, 1, 2].length # =&gt; 3
[].length        # =&gt; 0
</pre> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Querying">Methods for Querying</a>.</p> </div> <div class="aliases"> Alias for: <a href="array.html#method-i-length">length</a> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-slice"> <a href="#method-i-slice" title="Link to this method"> <span class="method-callseq"> slice(index) → object or nil </span> </a> </div> <div class="method-heading"> <a href="#method-i-slice" title="Link to this method"> <span class="method-callseq"> slice(start, length) → object or nil </span> </a> </div> <div class="method-heading"> <a href="#method-i-slice" title="Link to this method"> <span class="method-callseq"> slice(range) → object or nil </span> </a> </div> <div class="method-heading"> <a href="#method-i-slice" title="Link to this method"> <span class="method-callseq"> slice(aseq) → object or nil </span> </a> </div> </div> <div class="method-description"> <p>Returns elements from <code>self</code>; does not modify <code>self</code>.</p> <p>In brief:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]

# Single argument index: returns one element.
a[0]     # =&gt; :foo          # Zero-based index.
a[-1]    # =&gt; 2             # Negative index counts backwards from end.

# Arguments start and length: returns an array.
a[1, 2]  # =&gt; ["bar", 2]
a[-2, 2] # =&gt; ["bar", 2]    # Negative start counts backwards from end.

# Single argument range: returns an array.
a[0..1]  # =&gt; [:foo, "bar"]
a[0..-2] # =&gt; [:foo, "bar"] # Negative range-begin counts backwards from end.
a[-2..2] # =&gt; ["bar", 2]    # Negative range-end counts backwards from end.
</pre> <p>When a single integer argument <code>index</code> is given, returns the element at offset <code>index</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[0] # =&gt; :foo
a[2] # =&gt; 2
a # =&gt; [:foo, "bar", 2]
</pre> <p>If <code>index</code> is negative, counts backwards from the end of <code>self</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[-1] # =&gt; 2
a[-2] # =&gt; "bar"
</pre> <p>If <code>index</code> is out of range, returns <code>nil</code>.</p> <p>When two <a href="integer.html"><code>Integer</code></a> arguments <code>start</code> and <code>length</code> are given, returns a new <a href="array.html"><code>Array</code></a> of size <code>length</code> containing successive elements beginning at offset <code>start</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[0, 2] # =&gt; [:foo, "bar"]
a[1, 2] # =&gt; ["bar", 2]
</pre> <p>If <code>start + length</code> is greater than <code>self.length</code>, returns all elements from offset <code>start</code> to the end:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[0, 4] # =&gt; [:foo, "bar", 2]
a[1, 3] # =&gt; ["bar", 2]
a[2, 2] # =&gt; [2]
</pre> <p>If <code>start == self.size</code> and <code>length &gt;= 0</code>, returns a new empty <a href="array.html"><code>Array</code></a>.</p> <p>If <code>length</code> is negative, returns <code>nil</code>.</p> <p>When a single <a href="range.html"><code>Range</code></a> argument <code>range</code> is given, treats <code>range.min</code> as <code>start</code> above and <code>range.size</code> as <code>length</code> above:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[0..1] # =&gt; [:foo, "bar"]
a[1..2] # =&gt; ["bar", 2]
</pre> <p>Special case: If <code>range.start == a.size</code>, returns a new empty <a href="array.html"><code>Array</code></a>.</p> <p>If <code>range.end</code> is negative, calculates the end index from the end:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[0..-1] # =&gt; [:foo, "bar", 2]
a[0..-2] # =&gt; [:foo, "bar"]
a[0..-3] # =&gt; [:foo]
</pre> <p>If <code>range.start</code> is negative, calculates the start index from the end:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[-1..2] # =&gt; [2]
a[-2..2] # =&gt; ["bar", 2]
a[-3..2] # =&gt; [:foo, "bar", 2]
</pre> <p>If <code>range.start</code> is larger than the array size, returns <code>nil</code>.</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a[4..1] # =&gt; nil
a[4..0] # =&gt; nil
a[4..-1] # =&gt; nil
</pre> <p>When a single <a href="enumerator/arithmeticsequence.html"><code>Enumerator::ArithmeticSequence</code></a> argument <code>aseq</code> is given, returns an <a href="array.html"><code>Array</code></a> of elements corresponding to the indexes produced by the sequence.</p> <pre class="ruby" data-language="ruby">a = ['--', 'data1', '--', 'data2', '--', 'data3']
a[(1..).step(2)] # =&gt; ["data1", "data2", "data3"]
</pre> <p>Unlike slicing with range, if the start or the end of the arithmetic sequence is larger than array size, throws <a href="rangeerror.html"><code>RangeError</code></a>.</p> <pre class="ruby" data-language="ruby">a = ['--', 'data1', '--', 'data2', '--', 'data3']
a[(1..11).step(2)]
# RangeError (((1..11).step(2)) out of range)
a[(7..).step(2)]
# RangeError (((7..).step(2)) out of range)
</pre> <p>If given a single argument, and its type is not one of the listed, tries to convert it to <a href="integer.html"><code>Integer</code></a>, and raises if it is impossible:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
# Raises TypeError (no implicit conversion of Symbol into Integer):
a[:foo]
</pre> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Fetching">Methods for Fetching</a>.</p> </div> <div class="aliases"> Alias for: <a href="array.html#method-i-5B-5D">[]</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-slice-21"> <a href="#method-i-slice-21" title="Link to this method"> <span class="method-callseq"> slice!(index) → object or nil </span> </a> </div> <div class="method-heading"> <a href="#method-i-slice-21" title="Link to this method"> <span class="method-callseq"> slice!(start, length) → new_array or nil </span> </a> </div> <div class="method-heading"> <a href="#method-i-slice-21" title="Link to this method"> <span class="method-callseq"> slice!(range) → new_array or nil </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="slice-21-source"> <pre class="c" data-language="c">static VALUE
rb_ary_slice_bang(int argc, VALUE *argv, VALUE ary)
{
    VALUE arg1;
    long pos, len;

    rb_ary_modify_check(ary);
    rb_check_arity(argc, 1, 2);
    arg1 = argv[0];

    if (argc == 2) {
        pos = NUM2LONG(argv[0]);
        len = NUM2LONG(argv[1]);
        return ary_slice_bang_by_rb_ary_splice(ary, pos, len);
    }

    if (!FIXNUM_P(arg1)) {
        switch (rb_range_beg_len(arg1, &amp;pos, &amp;len, RARRAY_LEN(ary), 0)) {
          case Qtrue:
            /* valid range */
            return ary_slice_bang_by_rb_ary_splice(ary, pos, len);
          case Qnil:
            /* invalid range */
            return Qnil;
          default:
            /* not a range */
            break;
        }
    }

    return rb_ary_delete_at(ary, NUM2LONG(arg1));
}</pre> </div>  <p>Removes and returns elements from <code>self</code>.</p> <p>With numeric argument <code>index</code> given, removes and returns the element at offset <code>index</code>:</p> <pre class="ruby" data-language="ruby">a = ['a', 'b', 'c', 'd']
a.slice!(2)   # =&gt; "c"
a             # =&gt; ["a", "b", "d"]
a.slice!(2.1) # =&gt; "d"
a             # =&gt; ["a", "b"]
</pre> <p>If <code>index</code> is negative, counts backwards from the end of <code>self</code>:</p> <pre class="ruby" data-language="ruby">a = ['a', 'b', 'c', 'd']
a.slice!(-2) # =&gt; "c"
a            # =&gt; ["a", "b", "d"]
</pre> <p>If <code>index</code> is out of range, returns <code>nil</code>.</p> <p>With numeric arguments <code>start</code> and <code>length</code> given, removes <code>length</code> elements from <code>self</code> beginning at zero-based offset <code>start</code>; returns the removed objects in a new array:</p> <pre class="ruby" data-language="ruby">a = ['a', 'b', 'c', 'd']
a.slice!(1, 2)     # =&gt; ["b", "c"]
a                  # =&gt; ["a", "d"]
a.slice!(0.1, 1.1) # =&gt; ["a"]
a                  # =&gt; ["d"]
</pre> <p>If <code>start</code> is negative, counts backwards from the end of <code>self</code>:</p> <pre class="ruby" data-language="ruby">a = ['a', 'b', 'c', 'd']
a.slice!(-2, 1) # =&gt; ["c"]
a               # =&gt; ["a", "b", "d"]
</pre> <p>If <code>start</code> is out-of-range, returns <code>nil</code>:</p> <pre class="ruby" data-language="ruby">a = ['a', 'b', 'c', 'd']
a.slice!(5, 1)  # =&gt; nil
a.slice!(-5, 1) # =&gt; nil
</pre> <p>If <code>start + length</code> exceeds the array size, removes and returns all elements from offset <code>start</code> to the end:</p> <pre class="ruby" data-language="ruby">a = ['a', 'b', 'c', 'd']
a.slice!(2, 50) # =&gt; ["c", "d"]
a               # =&gt; ["a", "b"]
</pre> <p>If <code>start == a.size</code> and <code>length</code> is non-negative, returns a new empty array.</p> <p>If <code>length</code> is negative, returns <code>nil</code>.</p> <p>With <a href="range.html"><code>Range</code></a> argument <code>range</code> given, treats <code>range.min</code> as <code>start</code> (as above) and <code>range.size</code> as <code>length</code> (as above):</p> <pre class="ruby" data-language="ruby">a = ['a', 'b', 'c', 'd']
a.slice!(1..2) # =&gt; ["b", "c"]
a              # =&gt; ["a", "d"]
</pre> <p>If <code>range.start == a.size</code>, returns a new empty array:</p> <pre class="ruby" data-language="ruby">a = ['a', 'b', 'c', 'd']
a.slice!(4..5) # =&gt; []
</pre> <p>If <code>range.start</code> is larger than the array size, returns <code>nil</code>:</p> <pre class="ruby" data-language="ruby">a = ['a', 'b', 'c', 'd']
a.slice!(5..6) # =&gt; nil
</pre> <p>If <code>range.start</code> is negative, calculates the start index by counting backwards from the end of <code>self</code>:</p> <pre class="ruby" data-language="ruby">a = ['a', 'b', 'c', 'd']
a.slice!(-2..2) # =&gt; ["c"]
</pre> <p>If <code>range.end</code> is negative, calculates the end index by counting backwards from the end of <code>self</code>:</p> <pre class="ruby" data-language="ruby">a = ['a', 'b', 'c', 'd']
a.slice!(0..-2) # =&gt; ["a", "b", "c"]
</pre> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Deleting">Methods for Deleting</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-sort"> <a href="#method-i-sort" title="Link to this method"> <span class="method-callseq"> sort → new_array </span> </a> </div> <div class="method-heading"> <a href="#method-i-sort" title="Link to this method"> <span class="method-callseq"> sort {|a, b| ... } → new_array </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="sort-source"> <pre class="c" data-language="c">VALUE
rb_ary_sort(VALUE ary)
{
    ary = rb_ary_dup(ary);
    rb_ary_sort_bang(ary);
    return ary;
}</pre> </div>  <p>Returns a new array containing the elements of <code>self</code>, sorted.</p> <p>With no block given, compares elements using operator <a href="array.html#method-i-3C-3D-3E"><code>&lt;=&gt;</code></a> (see <a href="object.html#method-i-3C-3D-3E"><code>Object#&lt;=&gt;</code></a>):</p> <pre class="ruby" data-language="ruby">[0, 2, 3, 1].sort # =&gt; [0, 1, 2, 3]
</pre> <p>With a block given, calls the block with each combination of pairs of elements from <code>self</code>; for each pair <code>a</code> and <code>b</code>, the block should return a numeric:</p> <ul>
<li> <p>Negative when <code>b</code> is to follow <code>a</code>.</p> </li>
<li> <p>Zero when <code>a</code> and <code>b</code> are equivalent.</p> </li>
<li> <p>Positive when <code>a</code> is to follow <code>b</code>.</p> </li>
</ul> <p>Example:</p> <pre class="ruby" data-language="ruby">a = [3, 2, 0, 1]
a.sort {|a, b| a &lt;=&gt; b } # =&gt; [0, 1, 2, 3]
a.sort {|a, b| b &lt;=&gt; a } # =&gt; [3, 2, 1, 0]
</pre> <p>When the block returns zero, the order for <code>a</code> and <code>b</code> is indeterminate, and may be unstable.</p> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Fetching">Methods for Fetching</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-sort-21"> <a href="#method-i-sort-21" title="Link to this method"> <span class="method-callseq"> sort! → self </span> </a> </div> <div class="method-heading"> <a href="#method-i-sort-21" title="Link to this method"> <span class="method-callseq"> sort! {|a, b| ... } → self </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="sort-21-source"> <pre class="c" data-language="c">VALUE
rb_ary_sort_bang(VALUE ary)
{
    rb_ary_modify(ary);
    RUBY_ASSERT(!ARY_SHARED_P(ary));
    if (RARRAY_LEN(ary) &gt; 1) {
        VALUE tmp = ary_make_substitution(ary); /* only ary refers tmp */
        struct ary_sort_data data;
        long len = RARRAY_LEN(ary);
        RBASIC_CLEAR_CLASS(tmp);
        data.ary = tmp;
        data.receiver = ary;
        RARRAY_PTR_USE(tmp, ptr, {
            ruby_qsort(ptr, len, sizeof(VALUE),
                       rb_block_given_p()?sort_1:sort_2, &amp;data);
        }); /* WB: no new reference */
        rb_ary_modify(ary);
        if (ARY_EMBED_P(tmp)) {
            if (ARY_SHARED_P(ary)) { /* ary might be destructively operated in the given block */
                rb_ary_unshare(ary);
                FL_SET_EMBED(ary);
            }
            if (ARY_EMBED_LEN(tmp) &gt; ARY_CAPA(ary)) {
                ary_resize_capa(ary, ARY_EMBED_LEN(tmp));
            }
            ary_memcpy(ary, 0, ARY_EMBED_LEN(tmp), ARY_EMBED_PTR(tmp));
            ARY_SET_LEN(ary, ARY_EMBED_LEN(tmp));
        }
        else {
            if (!ARY_EMBED_P(ary) &amp;&amp; ARY_HEAP_PTR(ary) == ARY_HEAP_PTR(tmp)) {
                FL_UNSET_SHARED(ary);
                ARY_SET_CAPA(ary, RARRAY_LEN(tmp));
            }
            else {
                RUBY_ASSERT(!ARY_SHARED_P(tmp));
                if (ARY_EMBED_P(ary)) {
                    FL_UNSET_EMBED(ary);
                }
                else if (ARY_SHARED_P(ary)) {
                    /* ary might be destructively operated in the given block */
                    rb_ary_unshare(ary);
                }
                else {
                    ary_heap_free(ary);
                }
                ARY_SET_PTR(ary, ARY_HEAP_PTR(tmp));
                ARY_SET_HEAP_LEN(ary, len);
                ARY_SET_CAPA(ary, ARY_HEAP_LEN(tmp));
            }
            /* tmp was lost ownership for the ptr */
            FL_UNSET(tmp, FL_FREEZE);
            FL_SET_EMBED(tmp);
            ARY_SET_EMBED_LEN(tmp, 0);
            FL_SET(tmp, FL_FREEZE);
        }
        /* tmp will be GC'ed. */
        RBASIC_SET_CLASS_RAW(tmp, rb_cArray); /* rb_cArray must be marked */
    }
    ary_verify(ary);
    return ary;
}</pre> </div>  <p>Like <a href="array.html#method-i-sort"><code>Array#sort</code></a>, but returns <code>self</code> with its elements sorted in place.</p> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Assigning">Methods for Assigning</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-sort_by-21"> <a href="#method-i-sort_by-21" title="Link to this method"> <span class="method-callseq"> sort_by! {|element| ... } → self </span> </a> </div> <div class="method-heading"> <a href="#method-i-sort_by-21" title="Link to this method"> <span class="method-callseq"> sort_by! → new_enumerator </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="sort_by-21-source"> <pre class="c" data-language="c">static VALUE
rb_ary_sort_by_bang(VALUE ary)
{
    VALUE sorted;

    RETURN_SIZED_ENUMERATOR(ary, 0, 0, ary_enum_length);
    rb_ary_modify(ary);
    sorted = rb_block_call(ary, rb_intern("sort_by"), 0, 0, sort_by_i, 0);
    rb_ary_replace(ary, sorted);
    return ary;
}</pre> </div>  <p>With a block given, sorts the elements of <code>self</code> in place; returns self.</p> <p>Calls the block with each successive element; sorts elements based on the values returned from the block:</p> <pre class="ruby" data-language="ruby">a = ['aaaa', 'bbb', 'cc', 'd']
a.sort_by! {|element| element.size }
a # =&gt; ["d", "cc", "bbb", "aaaa"]
</pre> <p>For duplicate values returned by the block, the ordering is indeterminate, and may be unstable.</p> <p>With no block given, returns a new <a href="enumerator.html"><code>Enumerator</code></a>.</p> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Assigning">Methods for Assigning</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-sum"> <a href="#method-i-sum" title="Link to this method"> <span class="method-callseq"> sum(init = 0) → object </span> </a> </div> <div class="method-heading"> <a href="#method-i-sum" title="Link to this method"> <span class="method-callseq"> sum(init = 0) {|element| ... } → object </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="sum-source"> <pre class="c" data-language="c">static VALUE
rb_ary_sum(int argc, VALUE *argv, VALUE ary)
{
    VALUE e, v, r;
    long i, n;
    int block_given;

    v = (rb_check_arity(argc, 0, 1) ? argv[0] : LONG2FIX(0));

    block_given = rb_block_given_p();

    if (RARRAY_LEN(ary) == 0)
        return v;

    n = 0;
    r = Qundef;

    if (!FIXNUM_P(v) &amp;&amp; !RB_BIGNUM_TYPE_P(v) &amp;&amp; !RB_TYPE_P(v, T_RATIONAL)) {
        i = 0;
        goto init_is_a_value;
    }

    for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
        e = RARRAY_AREF(ary, i);
        if (block_given)
            e = rb_yield(e);
        if (FIXNUM_P(e)) {
            n += FIX2LONG(e); /* should not overflow long type */
            if (!FIXABLE(n)) {
                v = rb_big_plus(LONG2NUM(n), v);
                n = 0;
            }
        }
        else if (RB_BIGNUM_TYPE_P(e))
            v = rb_big_plus(e, v);
        else if (RB_TYPE_P(e, T_RATIONAL)) {
            if (UNDEF_P(r))
                r = e;
            else
                r = rb_rational_plus(r, e);
        }
        else
            goto not_exact;
    }
    v = finish_exact_sum(n, r, v, argc!=0);
    return v;

  not_exact:
    v = finish_exact_sum(n, r, v, i!=0);

    if (RB_FLOAT_TYPE_P(e)) {
        /*
         * Kahan-Babuska balancing compensated summation algorithm
         * See https://link.springer.com/article/10.1007/s00607-005-0139-x
         */
        double f, c;
        double x, t;

        f = NUM2DBL(v);
        c = 0.0;
        goto has_float_value;
        for (; i &lt; RARRAY_LEN(ary); i++) {
            e = RARRAY_AREF(ary, i);
            if (block_given)
                e = rb_yield(e);
            if (RB_FLOAT_TYPE_P(e))
              has_float_value:
                x = RFLOAT_VALUE(e);
            else if (FIXNUM_P(e))
                x = FIX2LONG(e);
            else if (RB_BIGNUM_TYPE_P(e))
                x = rb_big2dbl(e);
            else if (RB_TYPE_P(e, T_RATIONAL))
                x = rb_num2dbl(e);
            else
                goto not_float;

            if (isnan(f)) continue;
            if (isnan(x)) {
                f = x;
                continue;
            }
            if (isinf(x)) {
                if (isinf(f) &amp;&amp; signbit(x) != signbit(f))
                    f = NAN;
                else
                    f = x;
                continue;
            }
            if (isinf(f)) continue;

            t = f + x;
            if (fabs(f) &gt;= fabs(x))
                c += ((f - t) + x);
            else
                c += ((x - t) + f);
            f = t;
        }
        f += c;
        return DBL2NUM(f);

      not_float:
        v = DBL2NUM(f);
    }

    goto has_some_value;
    init_is_a_value:
    for (; i &lt; RARRAY_LEN(ary); i++) {
        e = RARRAY_AREF(ary, i);
        if (block_given)
            e = rb_yield(e);
      has_some_value:
        v = rb_funcall(v, idPLUS, 1, e);
    }
    return v;
}</pre> </div>  <p>With no block given, returns the sum of <code>init</code> and all elements of <code>self</code>; for array <code>array</code> and value <code>init</code>, equivalent to:</p> <pre class="ruby" data-language="ruby">sum = init
array.each {|element| sum += element }
sum
</pre> <p>For example, <code>[e0, e1, e2].sum</code> returns <code>init + e0 + e1 + e2</code>.</p> <p>Examples:</p> <pre class="ruby" data-language="ruby">[0, 1, 2, 3].sum                 # =&gt; 6
[0, 1, 2, 3].sum(100)            # =&gt; 106
['abc', 'def', 'ghi'].sum('jkl') # =&gt; "jklabcdefghi"
[[:foo, :bar], ['foo', 'bar']].sum([2, 3])
# =&gt; [2, 3, :foo, :bar, "foo", "bar"]
</pre> <p>The <code>init</code> value and elements need not be numeric, but must all be <code>+</code>-compatible:</p> <pre class="ruby" data-language="ruby"># Raises TypeError: Array can't be coerced into Integer.
[[:foo, :bar], ['foo', 'bar']].sum(2)
</pre> <p>With a block given, calls the block with each element of <code>self</code>; the block’s return value (instead of the element itself) is used as the addend:</p> <pre class="ruby" data-language="ruby">['zero', 1, :two].sum('Coerced and concatenated: ') {|element| element.to_s }
# =&gt; "Coerced and concatenated: zero1two"
</pre> <p>Notes:</p> <ul>
<li> <p><a href="array.html#method-i-join"><code>Array#join</code></a> and <a href="array.html#method-i-flatten"><code>Array#flatten</code></a> may be faster than <a href="array.html#method-i-sum"><code>Array#sum</code></a> for an array of strings or an array of arrays.</p> </li>
<li> <p><a href="array.html#method-i-sum"><code>Array#sum</code></a> method may not respect method redefinition of “+” methods such as <a href="integer.html#method-i-2B"><code>Integer#+</code></a>.</p> </li>
</ul> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-take"> <a href="#method-i-take" title="Link to this method"> <span class="method-callseq"> take(count) → new_array </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="take-source"> <pre class="c" data-language="c">static VALUE
rb_ary_take(VALUE obj, VALUE n)
{
    long len = NUM2LONG(n);
    if (len &lt; 0) {
        rb_raise(rb_eArgError, "attempt to take negative size");
    }
    return rb_ary_subseq(obj, 0, len);
}</pre> </div>  <p>Returns a new array containing the first <code>count</code> element of <code>self</code> (as available); <code>count</code> must be a non-negative numeric; does not modify <code>self</code>:</p> <pre class="ruby" data-language="ruby">a = ['a', 'b', 'c', 'd']
a.take(2)   # =&gt; ["a", "b"]
a.take(2.1) # =&gt; ["a", "b"]
a.take(50)  # =&gt; ["a", "b", "c", "d"]
a.take(0)   # =&gt; []
</pre> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Fetching">Methods for Fetching</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-take_while"> <a href="#method-i-take_while" title="Link to this method"> <span class="method-callseq"> take_while {|element| ... } → new_array </span> </a> </div> <div class="method-heading"> <a href="#method-i-take_while" title="Link to this method"> <span class="method-callseq"> take_while → new_enumerator </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="take_while-source"> <pre class="c" data-language="c">static VALUE
rb_ary_take_while(VALUE ary)
{
    long i;

    RETURN_ENUMERATOR(ary, 0, 0);
    for (i = 0; i &lt; RARRAY_LEN(ary); i++) {
        if (!RTEST(rb_yield(RARRAY_AREF(ary, i)))) break;
    }
    return rb_ary_take(ary, LONG2FIX(i));
}</pre> </div>  <p>With a block given, calls the block with each successive element of <code>self</code>; stops iterating if the block returns <code>false</code> or <code>nil</code>; returns a new array containing those elements for which the block returned a truthy value:</p> <pre class="ruby" data-language="ruby">a = [0, 1, 2, 3, 4, 5]
a.take_while {|element| element &lt; 3 } # =&gt; [0, 1, 2]
a.take_while {|element| true }        # =&gt; [0, 1, 2, 3, 4, 5]
a.take_while {|element| false }       # =&gt; []
</pre> <p>With no block given, returns a new <a href="enumerator.html"><code>Enumerator</code></a>.</p> <p>Does not modify <code>self</code>.</p> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Fetching">Methods for Fetching</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-to_a"> <a href="#method-i-to_a" title="Link to this method"> <span class="method-callseq"> to_a → self or new_array </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="to_a-source"> <pre class="c" data-language="c">static VALUE
rb_ary_to_a(VALUE ary)
{
    if (rb_obj_class(ary) != rb_cArray) {
        VALUE dup = rb_ary_new2(RARRAY_LEN(ary));
        rb_ary_replace(dup, ary);
        return dup;
    }
    return ary;
}</pre> </div>  <p>When <code>self</code> is an instance of <a href="array.html"><code>Array</code></a>, returns <code>self</code>.</p> <p>Otherwise, returns a new array containing the elements of <code>self</code>:</p> <pre class="ruby" data-language="ruby">class MyArray &lt; Array; end
my_a = MyArray.new(['foo', 'bar', 'two'])
a = my_a.to_a
a # =&gt; ["foo", "bar", "two"]
a.class # =&gt; Array # Not MyArray.
</pre> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Converting">Methods for Converting</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-to_ary"> <a href="#method-i-to_ary" title="Link to this method"> <span class="method-callseq"> to_ary → self </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="to_ary-source"> <pre class="c" data-language="c">static VALUE
rb_ary_to_ary_m(VALUE ary)
{
    return ary;
}</pre> </div>  <p>Returns <code>self</code>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-to_h"> <a href="#method-i-to_h" title="Link to this method"> <span class="method-callseq"> to_h → new_hash </span> </a> </div> <div class="method-heading"> <a href="#method-i-to_h" title="Link to this method"> <span class="method-callseq"> to_h {|element| ... } → new_hash </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="to_h-source"> <pre class="c" data-language="c">static VALUE
rb_ary_to_h(VALUE ary)
{
    long i;
    VALUE hash = rb_hash_new_with_size(RARRAY_LEN(ary));
    int block_given = rb_block_given_p();

    for (i=0; i&lt;RARRAY_LEN(ary); i++) {
        const VALUE e = rb_ary_elt(ary, i);
        const VALUE elt = block_given ? rb_yield_force_blockarg(e) : e;
        const VALUE key_value_pair = rb_check_array_type(elt);
        if (NIL_P(key_value_pair)) {
            rb_raise(rb_eTypeError, "wrong element type %"PRIsVALUE" at %ld (expected array)",
                     rb_obj_class(elt), i);
        }
        if (RARRAY_LEN(key_value_pair) != 2) {
            rb_raise(rb_eArgError, "wrong array length at %ld (expected 2, was %ld)",
                i, RARRAY_LEN(key_value_pair));
        }
        rb_hash_aset(hash, RARRAY_AREF(key_value_pair, 0), RARRAY_AREF(key_value_pair, 1));
    }
    return hash;
}</pre> </div>  <p>Returns a new hash formed from <code>self</code>.</p> <p>With no block given, each element of <code>self</code> must be a 2-element sub-array; forms each sub-array into a key-value pair in the new hash:</p> <pre class="ruby" data-language="ruby">a = [['foo', 'zero'], ['bar', 'one'], ['baz', 'two']]
a.to_h # =&gt; {"foo"=&gt;"zero", "bar"=&gt;"one", "baz"=&gt;"two"}
[].to_h # =&gt; {}
</pre> <p>With a block given, the block must return a 2-element array; calls the block with each element of <code>self</code>; forms each returned array into a key-value pair in the returned hash:</p> <pre class="ruby" data-language="ruby">a = ['foo', :bar, 1, [2, 3], {baz: 4}]
a.to_h {|element| [element, element.class] }
# =&gt; {"foo"=&gt;String, :bar=&gt;Symbol, 1=&gt;Integer, [2, 3]=&gt;Array, {:baz=&gt;4}=&gt;Hash}
</pre> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Converting">Methods for Converting</a>.</p> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-to_s"> <a href="#method-i-to_s" title="Link to this method"> <span class="method-callseq"> to_s → new_string </span> </a> </div> </div> <div class="method-description"> <p>Returns the new string formed by calling method <a href="array.html#method-i-inspect"><code>inspect</code></a> on each array element:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.inspect # =&gt; "[:foo, \"bar\", 2]"
</pre> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Converting">Methods for Converting</a>.</p> </div> <div class="aliases"> Alias for: <a href="array.html#method-i-inspect">inspect</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-transpose"> <a href="#method-i-transpose" title="Link to this method"> <span class="method-callseq"> transpose → new_array </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="transpose-source"> <pre class="c" data-language="c">static VALUE
rb_ary_transpose(VALUE ary)
{
    long elen = -1, alen, i, j;
    VALUE tmp, result = 0;

    alen = RARRAY_LEN(ary);
    if (alen == 0) return rb_ary_dup(ary);
    for (i=0; i&lt;alen; i++) {
        tmp = to_ary(rb_ary_elt(ary, i));
        if (elen &lt; 0) {         /* first element */
            elen = RARRAY_LEN(tmp);
            result = rb_ary_new2(elen);
            for (j=0; j&lt;elen; j++) {
                rb_ary_store(result, j, rb_ary_new2(alen));
            }
        }
        else if (elen != RARRAY_LEN(tmp)) {
            rb_raise(rb_eIndexError, "element size differs (%ld should be %ld)",
                     RARRAY_LEN(tmp), elen);
        }
        for (j=0; j&lt;elen; j++) {
            rb_ary_store(rb_ary_elt(result, j), i, rb_ary_elt(tmp, j));
        }
    }
    return result;
}</pre> </div>  <p>Returns a new array that is <code>self</code> as a <a href="https://en.wikipedia.org/wiki/Transpose">transposed matrix</a>:</p> <pre class="ruby" data-language="ruby">a = [[:a0, :a1], [:b0, :b1], [:c0, :c1]]
a.transpose # =&gt; [[:a0, :b0, :c0], [:a1, :b1, :c1]]
</pre> <p>The elements of <code>self</code> must all be the same size.</p> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Converting">Methods for Converting</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-union"> <a href="#method-i-union" title="Link to this method"> <span class="method-callseq"> union(*other_arrays) → new_array </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="union-source"> <pre class="c" data-language="c">static VALUE
rb_ary_union_multi(int argc, VALUE *argv, VALUE ary)
{
    int i;
    long sum;
    VALUE hash;

    sum = RARRAY_LEN(ary);
    for (i = 0; i &lt; argc; i++) {
        argv[i] = to_ary(argv[i]);
        sum += RARRAY_LEN(argv[i]);
    }

    if (sum &lt;= SMALL_ARRAY_LEN) {
        VALUE ary_union = rb_ary_new();

        rb_ary_union(ary_union, ary);
        for (i = 0; i &lt; argc; i++) rb_ary_union(ary_union, argv[i]);

        return ary_union;
    }

    hash = ary_make_hash(ary);
    for (i = 0; i &lt; argc; i++) rb_ary_union_hash(hash, argv[i]);

    return rb_hash_values(hash);
}</pre> </div>  <p>Returns a new array that is the union of the elements of <code>self</code> and all given arrays <code>other_arrays</code>; items are compared using <code>eql?</code>:</p> <pre class="ruby" data-language="ruby">[0, 1, 2, 3].union([4, 5], [6, 7]) # =&gt; [0, 1, 2, 3, 4, 5, 6, 7]
</pre> <p>Removes duplicates (preserving the first found):</p> <pre class="ruby" data-language="ruby">[0, 1, 1].union([2, 1], [3, 1]) # =&gt; [0, 1, 2, 3]
</pre> <p>Preserves order (preserving the position of the first found):</p> <pre class="ruby" data-language="ruby">[3, 2, 1, 0].union([5, 3], [4, 2]) # =&gt; [3, 2, 1, 0, 5, 4]
</pre> <p>With no arguments given, returns a copy of <code>self</code>.</p> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Combining">Methods for Combining</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-uniq"> <a href="#method-i-uniq" title="Link to this method"> <span class="method-callseq"> uniq → new_array </span> </a> </div> <div class="method-heading"> <a href="#method-i-uniq" title="Link to this method"> <span class="method-callseq"> uniq {|element| ... } → new_array </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="uniq-source"> <pre class="c" data-language="c">static VALUE
rb_ary_uniq(VALUE ary)
{
    VALUE hash, uniq;

    if (RARRAY_LEN(ary) &lt;= 1) {
        hash = 0;
        uniq = rb_ary_dup(ary);
    }
    else if (rb_block_given_p()) {
        hash = ary_make_hash_by(ary);
        uniq = rb_hash_values(hash);
    }
    else {
        hash = ary_make_hash(ary);
        uniq = rb_hash_values(hash);
    }

    return uniq;
}</pre> </div>  <p>Returns a new array containing those elements from <code>self</code> that are not duplicates, the first occurrence always being retained.</p> <p>With no block given, identifies and omits duplicate elements using method <code>eql?</code> to compare elements:</p> <pre class="ruby" data-language="ruby">a = [0, 0, 1, 1, 2, 2]
a.uniq # =&gt; [0, 1, 2]
</pre> <p>With a block given, calls the block for each element; identifies and omits “duplicate” elements using method <code>eql?</code> to compare <em>block return values</em>; that is, an element is a duplicate if its block return value is the same as that of a previous element:</p> <pre class="ruby" data-language="ruby">a = ['a', 'aa', 'aaa', 'b', 'bb', 'bbb']
a.uniq {|element| element.size } # =&gt; ["a", "aa", "aaa"]
</pre> <p>Related: <a href="array.html#class-Array-label-Methods+for+Fetching">Methods for Fetching</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-uniq-21"> <a href="#method-i-uniq-21" title="Link to this method"> <span class="method-callseq"> uniq! → self or nil </span> </a> </div> <div class="method-heading"> <a href="#method-i-uniq-21" title="Link to this method"> <span class="method-callseq"> uniq! {|element| ... } → self or nil </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="uniq-21-source"> <pre class="c" data-language="c">static VALUE
rb_ary_uniq_bang(VALUE ary)
{
    VALUE hash;
    long hash_size;

    rb_ary_modify_check(ary);
    if (RARRAY_LEN(ary) &lt;= 1)
        return Qnil;
    if (rb_block_given_p())
        hash = ary_make_hash_by(ary);
    else
        hash = ary_make_hash(ary);

    hash_size = RHASH_SIZE(hash);
    if (RARRAY_LEN(ary) == hash_size) {
        return Qnil;
    }
    rb_ary_modify_check(ary);
    ARY_SET_LEN(ary, 0);
    if (ARY_SHARED_P(ary)) {
        rb_ary_unshare(ary);
        FL_SET_EMBED(ary);
    }
    ary_resize_capa(ary, hash_size);
    rb_hash_foreach(hash, push_value, ary);

    return ary;
}</pre> </div>  <p>Removes duplicate elements from <code>self</code>, the first occurrence always being retained; returns <code>self</code> if any elements removed, <code>nil</code> otherwise.</p> <p>With no block given, identifies and removes elements using method <code>eql?</code> to compare elements:</p> <pre class="ruby" data-language="ruby">a = [0, 0, 1, 1, 2, 2]
a.uniq! # =&gt; [0, 1, 2]
a.uniq! # =&gt; nil
</pre> <p>With a block given, calls the block for each element; identifies and omits “duplicate” elements using method <code>eql?</code> to compare <em>block return values</em>; that is, an element is a duplicate if its block return value is the same as that of a previous element:</p> <pre class="ruby" data-language="ruby">a = ['a', 'aa', 'aaa', 'b', 'bb', 'bbb']
a.uniq! {|element| element.size } # =&gt; ["a", "aa", "aaa"]
a.uniq! {|element| element.size } # =&gt; nil
</pre> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Deleting">Methods for Deleting</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-unshift"> <a href="#method-i-unshift" title="Link to this method"> <span class="method-callseq"> unshift(*objects) → self </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="unshift-source"> <pre class="c" data-language="c">VALUE
rb_ary_unshift_m(int argc, VALUE *argv, VALUE ary)
{
    long len = RARRAY_LEN(ary);
    VALUE target_ary;

    if (argc == 0) {
        rb_ary_modify_check(ary);
        return ary;
    }

    target_ary = ary_ensure_room_for_unshift(ary, argc);
    ary_memcpy0(ary, 0, argc, argv, target_ary);
    ARY_SET_LEN(ary, len + argc);
    return ary;
}</pre> </div>  <p>Prepends the given <code>objects</code> to <code>self</code>:</p> <pre class="ruby" data-language="ruby">a = [:foo, 'bar', 2]
a.unshift(:bam, :bat) # =&gt; [:bam, :bat, :foo, "bar", 2]
</pre> <p>Related: <a href="array.html#method-i-shift"><code>Array#shift</code></a>; see also <a href="array.html#class-Array-label-Methods+for+Assigning">Methods for Assigning</a>.</p> </div> <div class="aliases"> Also aliased as: <a href="array.html#method-i-prepend">prepend</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-values_at"> <a href="#method-i-values_at" title="Link to this method"> <span class="method-callseq"> values_at(*specifiers) → new_array </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="values_at-source"> <pre class="c" data-language="c">static VALUE
rb_ary_values_at(int argc, VALUE *argv, VALUE ary)
{
    long i, olen = RARRAY_LEN(ary);
    VALUE result = rb_ary_new_capa(argc);
    for (i = 0; i &lt; argc; ++i) {
        append_values_at_single(result, ary, olen, argv[i]);
    }
    RB_GC_GUARD(ary);
    return result;
}</pre> </div>  <p>Returns elements from <code>self</code> in a new array; does not modify <code>self</code>.</p> <p>The objects included in the returned array are the elements of <code>self</code> selected by the given <code>specifiers</code>, each of which must be a numeric index or a <a href="range.html"><code>Range</code></a>.</p> <p>In brief:</p> <pre class="ruby" data-language="ruby">a = ['a', 'b', 'c', 'd']

# Index specifiers.
a.values_at(2, 0, 2, 0)     # =&gt; ["c", "a", "c", "a"] # May repeat.
a.values_at(-4, -3, -2, -1) # =&gt; ["a", "b", "c", "d"] # Counts backwards if negative.
a.values_at(-50, 50)        # =&gt; [nil, nil]           # Outside of self.

# Range specifiers.
a.values_at(1..3)       # =&gt; ["b", "c", "d"] # From range.begin to range.end.
a.values_at(1...3)      # =&gt; ["b", "c"]      # End excluded.
a.values_at(3..1)       # =&gt; []              # No such elements.

a.values_at(-3..3)  # =&gt; ["b", "c", "d"]     # Negative range.begin counts backwards.
a.values_at(-50..3)                          # Raises RangeError.

a.values_at(1..-2)  # =&gt; ["b", "c"]          # Negative range.end counts backwards.
a.values_at(1..-50) # =&gt; []                  # No such elements.

# Mixture of specifiers.
a.values_at(2..3, 3, 0..1, 0) # =&gt; ["c", "d", "d", "a", "b", "a"]
</pre> <p>With no <code>specifiers</code> given, returns a new empty array:</p> <pre class="ruby" data-language="ruby">a = ['a', 'b', 'c', 'd']
a.values_at # =&gt; []
</pre> <p>For each numeric specifier <code>index</code>, includes an element:</p> <ul>
<li> <p>For each non-negative numeric specifier <code>index</code> that is in-range (less than <code>self.size</code>), includes the element at offset <code>index</code>:</p> <pre class="ruby" data-language="ruby">a.values_at(0, 2)     # =&gt; ["a", "c"]
a.values_at(0.1, 2.9) # =&gt; ["a", "c"]
</pre> </li>
<li> <p>For each negative numeric <code>index</code> that is in-range (greater than or equal to <code>- self.size</code>), counts backwards from the end of <code>self</code>:</p> <pre class="ruby" data-language="ruby">a.values_at(-1, -4) # =&gt; ["d", "a"]
</pre> </li>
</ul> <p>The given indexes may be in any order, and may repeat:</p> <pre class="ruby" data-language="ruby">a.values_at(2, 0, 1, 0, 2) # =&gt; ["c", "a", "b", "a", "c"]
</pre> <p>For each <code>index</code> that is out-of-range, includes <code>nil</code>:</p> <pre class="ruby" data-language="ruby">a.values_at(4, -5) # =&gt; [nil, nil]
</pre> <p>For each <a href="range.html"><code>Range</code></a> specifier <code>range</code>, includes elements according to <code>range.begin</code> and <code>range.end</code>:</p> <ul>
<li> <p>If both <code>range.begin</code> and <code>range.end</code> are non-negative and in-range (less than <code>self.size</code>), includes elements from index <code>range.begin</code> through <code>range.end - 1</code> (if <code>range.exclude_end?</code>), or through <code>range.end</code> (otherwise):</p> <pre class="ruby" data-language="ruby">a.values_at(1..2)  # =&gt; ["b", "c"]
a.values_at(1...2) # =&gt; ["b"]
</pre> </li>
<li> <p>If <code>range.begin</code> is negative and in-range (greater than or equal to <code>- self.size</code>), counts backwards from the end of <code>self</code>:</p> <pre class="ruby" data-language="ruby">a.values_at(-2..3) # =&gt; ["c", "d"]
</pre> </li>
<li> <p>If <code>range.begin</code> is negative and out-of-range, raises an exception:</p> <pre class="ruby" data-language="ruby">a.values_at(-5..3) # Raises RangeError.
</pre> </li>
<li> <p>If <code>range.end</code> is positive and out-of-range, extends the returned array with <code>nil</code> elements:</p> <pre class="ruby" data-language="ruby">a.values_at(1..5) # =&gt; ["b", "c", "d", nil, nil]
</pre> </li>
<li> <p>If <code>range.end</code> is negative and in-range, counts backwards from the end of <code>self</code>:</p> <pre class="ruby" data-language="ruby">a.values_at(1..-2) # =&gt; ["b", "c"]
</pre> </li>
<li> <p>If <code>range.end</code> is negative and out-of-range, returns an empty array:</p> <pre class="ruby" data-language="ruby">a.values_at(1..-5) # =&gt; []
</pre> </li>
</ul> <p>The given ranges may be in any order and may repeat:</p> <pre class="ruby" data-language="ruby">a.values_at(2..3, 0..1, 2..3) # =&gt; ["c", "d", "a", "b", "c", "d"]
</pre> <p>The given specifiers may be any mixture of indexes and ranges:</p> <pre class="ruby" data-language="ruby">a.values_at(3, 1..2, 0, 2..3) # =&gt; ["d", "b", "c", "a", "c", "d"]
</pre> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Fetching">Methods for Fetching</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-zip"> <a href="#method-i-zip" title="Link to this method"> <span class="method-callseq"> zip(*other_arrays) → new_array </span> </a> </div> <div class="method-heading"> <a href="#method-i-zip" title="Link to this method"> <span class="method-callseq"> zip(*other_arrays) {|sub_array| ... } → nil </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="zip-source"> <pre class="c" data-language="c">static VALUE
rb_ary_zip(int argc, VALUE *argv, VALUE ary)
{
    int i, j;
    long len = RARRAY_LEN(ary);
    VALUE result = Qnil;

    for (i=0; i&lt;argc; i++) {
        argv[i] = take_items(argv[i], len);
    }

    if (rb_block_given_p()) {
        int arity = rb_block_arity();

        if (arity &gt; 1) {
            VALUE work, *tmp;

            tmp = ALLOCV_N(VALUE, work, argc+1);

            for (i=0; i&lt;RARRAY_LEN(ary); i++) {
                tmp[0] = RARRAY_AREF(ary, i);
                for (j=0; j&lt;argc; j++) {
                    tmp[j+1] = rb_ary_elt(argv[j], i);
                }
                rb_yield_values2(argc+1, tmp);
            }

            if (work) ALLOCV_END(work);
        }
        else {
            for (i=0; i&lt;RARRAY_LEN(ary); i++) {
                VALUE tmp = rb_ary_new2(argc+1);

                rb_ary_push(tmp, RARRAY_AREF(ary, i));
                for (j=0; j&lt;argc; j++) {
                    rb_ary_push(tmp, rb_ary_elt(argv[j], i));
                }
                rb_yield(tmp);
            }
        }
    }
    else {
        result = rb_ary_new_capa(len);

        for (i=0; i&lt;len; i++) {
            VALUE tmp = rb_ary_new_capa(argc+1);

            rb_ary_push(tmp, RARRAY_AREF(ary, i));
            for (j=0; j&lt;argc; j++) {
                rb_ary_push(tmp, rb_ary_elt(argv[j], i));
            }
            rb_ary_push(result, tmp);
        }
    }

    return result;
}</pre> </div>  <p>With no block given, combines <code>self</code> with the collection of <code>other_arrays</code>; returns a new array of sub-arrays:</p> <pre class="ruby" data-language="ruby">[0, 1].zip(['zero', 'one'], [:zero, :one])
# =&gt; [[0, "zero", :zero], [1, "one", :one]]
</pre> <p>Returned:</p> <ul>
<li> <p>The outer array is of size <code>self.size</code>.</p> </li>
<li> <p>Each sub-array is of size <code>other_arrays.size + 1</code>.</p> </li>
<li> <p>The <em>nth</em> sub-array contains (in order):</p> <ul>
<li> <p>The <em>nth</em> element of <code>self</code>.</p> </li>
<li> <p>The <em>nth</em> element of each of the other arrays, as available.</p> </li>
</ul> </li>
</ul> <p>Example:</p> <pre class="ruby" data-language="ruby">a = [0, 1]
zipped = a.zip(['zero', 'one'], [:zero, :one])
# =&gt; [[0, "zero", :zero], [1, "one", :one]]
zipped.size       # =&gt; 2 # Same size as a.
zipped.first.size # =&gt; 3 # Size of other arrays plus 1.
</pre> <p>When the other arrays are all the same size as <code>self</code>, the returned sub-arrays are a rearrangement containing exactly elements of all the arrays (including <code>self</code>), with no omissions or additions:</p> <pre class="ruby" data-language="ruby">a = [:a0, :a1, :a2, :a3]
b = [:b0, :b1, :b2, :b3]
c = [:c0, :c1, :c2, :c3]
d = a.zip(b, c)
pp d
# =&gt;
[[:a0, :b0, :c0],
 [:a1, :b1, :c1],
 [:a2, :b2, :c2],
 [:a3, :b3, :c3]]
</pre> <p>When one of the other arrays is smaller than <code>self</code>, pads the corresponding sub-array with <code>nil</code> elements:</p> <pre class="ruby" data-language="ruby">a = [:a0, :a1, :a2, :a3]
b = [:b0, :b1, :b2]
c = [:c0, :c1]
d = a.zip(b, c)
pp d
# =&gt;
[[:a0, :b0, :c0],
 [:a1, :b1, :c1],
 [:a2, :b2, nil],
 [:a3, nil, nil]]
</pre> <p>When one of the other arrays is larger than <code>self</code>, <em>ignores</em> its trailing elements:</p> <pre class="ruby" data-language="ruby">a = [:a0, :a1, :a2, :a3]
b = [:b0, :b1, :b2, :b3, :b4]
c = [:c0, :c1, :c2, :c3, :c4, :c5]
d = a.zip(b, c)
pp d
# =&gt;
[[:a0, :b0, :c0],
 [:a1, :b1, :c1],
 [:a2, :b2, :c2],
 [:a3, :b3, :c3]]
</pre> <p>With a block given, calls the block with each of the other arrays; returns <code>nil</code>:</p> <pre class="ruby" data-language="ruby">d = []
a = [:a0, :a1, :a2, :a3]
b = [:b0, :b1, :b2, :b3]
c = [:c0, :c1, :c2, :c3]
a.zip(b, c) {|sub_array| d.push(sub_array.reverse) } # =&gt; nil
pp d
# =&gt;
[[:c0, :b0, :a0],
 [:c1, :b1, :a1],
 [:c2, :b2, :a2],
 [:c3, :b3, :a3]]
</pre> <p>For an <strong>object</strong> in <strong>other_arrays</strong> that is not actually an array, forms the the “other array” as <code>object.to_ary</code>, if defined, or as <code>object.each.to_a</code> otherwise.</p> <p>Related: see <a href="array.html#class-Array-label-Methods+for+Converting">Methods for Converting</a>.</p> </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core &copy; 1993&ndash;2024 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library &copy; contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>
