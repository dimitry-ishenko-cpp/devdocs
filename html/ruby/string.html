<h1 id="class-String" class="class"> class String </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent"><a href="object.html">Object</a></dd>
<dt>Included modules:</dt>
<dd class="meta-includes"><a class="include" href="comparable.html">Comparable</a></dd>
</dl> <section class="description"> <p>A String object has an arbitrary sequence of bytes, typically representing text or binary data. A String object may be created using <a href="string.html#method-c-new"><code>String::new</code></a> or as literals.</p> <p><a href="string.html"><code>String</code></a> objects differ from <a href="symbol.html"><code>Symbol</code></a> objects in that <a href="symbol.html"><code>Symbol</code></a> objects are designed to be used as identifiers, instead of text or data.</p> <p>You can create a String object explicitly with:</p> <ul>
<li> <p>A <a href="syntax/literals_rdoc.html#label-String+Literals">string literal</a>.</p> </li>
<li> <p>A <a href="syntax/literals_rdoc.html#label-Here+Document+Literals">heredoc literal</a>.</p> </li>
</ul> <p>You can convert certain objects to Strings with:</p> <ul><li> <p>Method <a href="kernel.html#method-i-String"><code>String</code></a>.</p> </li></ul> <p>Some String methods modify <code>self</code>. Typically, a method whose name ends with <code>!</code> modifies <code>self</code> and returns <code>self</code>; often a similarly named method (without the <code>!</code>) returns a new string.</p> <p>In general, if there exist both bang and non-bang version of method, the bang! mutates and the non-bang! does not. However, a method without a bang can also mutate, such as <a href="string.html#method-i-replace"><code>String#replace</code></a>.</p> <h2 id="class-String-label-Substitution+Methods">Substitution Methods</h2> <p>These methods perform substitutions:</p> <ul>
<li> <p><a href="string.html#method-i-sub"><code>String#sub</code></a>: One substitution (or none); returns a new string.</p> </li>
<li> <p><a href="string.html#method-i-sub-21"><code>String#sub!</code></a>: One substitution (or none); returns <code>self</code>.</p> </li>
<li> <p><a href="string.html#method-i-gsub"><code>String#gsub</code></a>: Zero or more substitutions; returns a new string.</p> </li>
<li> <p><a href="string.html#method-i-gsub-21"><code>String#gsub!</code></a>: Zero or more substitutions; returns <code>self</code>.</p> </li>
</ul> <p>Each of these methods takes:</p> <ul>
<li> <p>A first argument, <code>pattern</code> (string or regexp), that specifies the substring(s) to be replaced.</p> </li>
<li> <p>Either of these:</p> <ul>
<li> <p>A second argument, <code>replacement</code> (string or hash), that determines the replacing string.</p> </li>
<li> <p>A block that will determine the replacing string.</p> </li>
</ul> </li>
</ul> <p>The examples in this section mostly use methods <a href="string.html#method-i-sub"><code>String#sub</code></a> and <a href="string.html#method-i-gsub"><code>String#gsub</code></a>; the principles illustrated apply to all four substitution methods.</p> <p><strong>Argument <code>pattern</code></strong></p> <p>Argument <code>pattern</code> is commonly a regular expression:</p> <pre class="ruby" data-language="ruby">s = 'hello'
s.sub(/[aeiou]/, '*')# =&gt; "h*llo"
s.gsub(/[aeiou]/, '*') # =&gt; "h*ll*"
s.gsub(/[aeiou]/, '')# =&gt; "hll"
s.sub(/ell/, 'al')   # =&gt; "halo"
s.gsub(/xyzzy/, '*') # =&gt; "hello"
'THX1138'.gsub(/\d+/, '00') # =&gt; "THX00"
</pre> <p>When <code>pattern</code> is a string, all its characters are treated as ordinary characters (not as regexp special characters):</p> <pre class="ruby" data-language="ruby">'THX1138'.gsub('\d+', '00') # =&gt; "THX1138"
</pre> <p><strong>String <code>replacement</code></strong></p> <p>If <code>replacement</code> is a string, that string will determine the replacing string that is to be substituted for the matched text.</p> <p>Each of the examples above uses a simple string as the replacing string.</p> <p>String <code>replacement</code> may contain back-references to the pattern’s captures:</p> <ul>
<li> <p><code>\n</code> (<em>n</em> a non-negative integer) refers to <code>$n</code>.</p> </li>
<li> <p><code>\k&lt;name&gt;</code> refers to the named capture <code>name</code>.</p> </li>
</ul> <p>See <a href="regexp.html"><code>Regexp</code></a> for details.</p> <p>Note that within the string <code>replacement</code>, a character combination such as <code>$&amp;</code> is treated as ordinary text, and not as a special match variable. However, you may refer to some special match variables using these combinations:</p> <ul>
<li> <p><code>\&amp;</code> and <code>\0</code> correspond to <code>$&amp;</code>, which contains the complete matched text.</p> </li>
<li> <p><code>\'</code> corresponds to <code>$'</code>, which contains string after match.</p> </li>
<li> <p><code>\`</code> corresponds to <code>$`</code>, which contains string before match.</p> </li>
<li> <p><code>\+</code> corresponds to <code>$+</code>, which contains last capture group.</p> </li>
</ul> <p>See <a href="regexp.html"><code>Regexp</code></a> for details.</p> <p>Note that <code>\\</code> is interpreted as an escape, i.e., a single backslash.</p> <p>Note also that a string literal consumes backslashes. See <a href="syntax/literals_rdoc.html#label-String+Literals">String Literals</a> for details about string literals.</p> <p>A back-reference is typically preceded by an additional backslash. For example, if you want to write a back-reference <code>\&amp;</code> in <code>replacement</code> with a double-quoted string literal, you need to write <code>"..\\&amp;.."</code>.</p> <p>If you want to write a non-back-reference string <code>\&amp;</code> in <code>replacement</code>, you need first to escape the backslash to prevent this method from interpreting it as a back-reference, and then you need to escape the backslashes again to prevent a string literal from consuming them: <code>"..\\\\&amp;.."</code>.</p> <p>You may want to use the block form to avoid a lot of backslashes.</p> <p><strong>Hash <code>replacement</code></strong></p> <p>If argument <code>replacement</code> is a hash, and <code>pattern</code> matches one of its keys, the replacing string is the value for that key:</p> <pre class="ruby" data-language="ruby">h = {'foo' =&gt; 'bar', 'baz' =&gt; 'bat'}
'food'.sub('foo', h) # =&gt; "bard"
</pre> <p>Note that a symbol key does not match:</p> <pre class="ruby" data-language="ruby">h = {foo: 'bar', baz: 'bat'}
'food'.sub('foo', h) # =&gt; "d"
</pre> <p><strong>Block</strong></p> <p>In the block form, the current match string is passed to the block; the block’s return value becomes the replacing string:</p> <pre class="ruby" data-language="ruby"> s = '@'
'1234'.gsub(/\d/) {|match| s.succ! } # =&gt; "ABCD"
</pre> <p>Special match variables such as <code>$1</code>, <code>$2</code>, <code>$`</code>, <code>$&amp;</code>, and <code>$'</code> are set appropriately.</p> <h2 id="class-String-label-Whitespace+in+Strings">Whitespace in Strings</h2> <p>In class String, <em>whitespace</em> is defined as a contiguous sequence of characters consisting of any mixture of the following:</p> <ul>
<li> <p>NL (null): <code>"\x00"</code>, <code>"\u0000"</code>.</p> </li>
<li> <p>HT (horizontal tab): <code>"\x09"</code>, <code>"\t"</code>.</p> </li>
<li> <p>LF (line feed): <code>"\x0a"</code>, <code>"\n"</code>.</p> </li>
<li> <p>VT (vertical tab): <code>"\x0b"</code>, <code>"\v"</code>.</p> </li>
<li> <p>FF (form feed): <code>"\x0c"</code>, <code>"\f"</code>.</p> </li>
<li> <p>CR (carriage return): <code>"\x0d"</code>, <code>"\r"</code>.</p> </li>
<li> <p>SP (space): <code>"\x20"</code>, <code>" "</code>.</p> </li>
</ul> <p>Whitespace is relevant for these methods:</p> <ul>
<li> <p><a href="string.html#method-i-lstrip"><code>lstrip</code></a>, <a href="string.html#method-i-lstrip-21"><code>lstrip!</code></a>: strip leading whitespace.</p> </li>
<li> <p><a href="string.html#method-i-rstrip"><code>rstrip</code></a>, <a href="string.html#method-i-rstrip-21"><code>rstrip!</code></a>: strip trailing whitespace.</p> </li>
<li> <p><a href="string.html#method-i-strip"><code>strip</code></a>, <a href="string.html#method-i-strip-21"><code>strip!</code></a>: strip leading and trailing whitespace.</p> </li>
</ul> <h2 id="class-String-label-String+Slices">String Slices</h2> <p>A <em>slice</em> of a string is a substring that is selected by certain criteria.</p> <p>These instance methods make use of slicing:</p> <ul>
<li> <p><a href="string.html#method-i-5B-5D"><code>String#[]</code></a> (also aliased as <a href="string.html#method-i-slice"><code>String#slice</code></a>) returns a slice copied from <code>self</code>.</p> </li>
<li> <p><a href="string.html#method-i-5B-5D-3D"><code>String#[]=</code></a> returns a copy of <code>self</code> with a slice replaced.</p> </li>
<li> <p><a href="string.html#method-i-slice-21"><code>String#slice!</code></a> returns <code>self</code> with a slice removed.</p> </li>
</ul> <p>Each of the above methods takes arguments that determine the slice to be copied or replaced.</p> <p>The arguments have several forms. For string <code>string</code>, the forms are:</p> <ul>
<li> <p><code>string[index]</code>.</p> </li>
<li> <p><code>string[start, length]</code>.</p> </li>
<li> <p><code>string[range]</code>.</p> </li>
<li> <p><code>string[regexp, capture = 0]</code>.</p> </li>
<li> <p><code>string[substring]</code>.</p> </li>
</ul> <p><strong><code>string[index]</code></strong></p> <p>When non-negative integer argument <code>index</code> is given, the slice is the 1-character substring found in <code>self</code> at character offset <code>index</code>:</p> <pre class="ruby" data-language="ruby">'bar'[0]       # =&gt; "b"
'bar'[2]       # =&gt; "r"
'bar'[20]      # =&gt; nil
'тест'[2]      # =&gt; "с"
'こんにちは'[4]  # =&gt; "は"
</pre> <p>When negative integer <code>index</code> is given, the slice begins at the offset given by counting backward from the end of <code>self</code>:</p> <pre class="ruby" data-language="ruby">'bar'[-3]         # =&gt; "b"
'bar'[-1]         # =&gt; "r"
'bar'[-20]        # =&gt; nil
</pre> <p><strong><code>string[start, length]</code></strong></p> <p>When non-negative integer arguments <code>start</code> and <code>length</code> are given, the slice begins at character offset <code>start</code>, if it exists, and continues for <code>length</code> characters, if available:</p> <pre class="ruby" data-language="ruby">'foo'[0, 2]       # =&gt; "fo"
'тест'[1, 2]      # =&gt; "ес"
'こんにちは'[2, 2]  # =&gt; "にち"
# Zero length.
'foo'[2, 0]       # =&gt; ""
# Length not entirely available.
'foo'[1, 200]     # =&gt; "oo"
# Start out of range.
'foo'[4, 2]      # =&gt; nil
</pre> <p>Special case: if <code>start</code> is equal to the length of <code>self</code>, the slice is a new empty string:</p> <pre class="ruby" data-language="ruby">'foo'[3, 2]   # =&gt; ""
'foo'[3, 200] # =&gt; ""
</pre> <p>When negative <code>start</code> and non-negative <code>length</code> are given, the slice beginning is determined by counting backward from the end of <code>self</code>, and the slice continues for <code>length</code> characters, if available:</p> <pre class="ruby" data-language="ruby">'foo'[-2, 2]    # =&gt; "oo"
'foo'[-2, 200]  # =&gt; "oo"
# Start out of range.
'foo'[-4, 2]     # =&gt; nil
</pre> <p>When negative <code>length</code> is given, there is no slice:</p> <pre class="ruby" data-language="ruby">'foo'[1, -1]  # =&gt; nil
'foo'[-2, -1] # =&gt; nil
</pre> <p><strong><code>string[range]</code></strong></p> <p>When <a href="range.html"><code>Range</code></a> argument <code>range</code> is given, creates a substring of <code>string</code> using the indices in <code>range</code>. The slice is then determined as above:</p> <pre class="ruby" data-language="ruby">'foo'[0..1]    # =&gt; "fo"
'foo'[0, 2]    # =&gt; "fo"

'foo'[2...2]   # =&gt; ""
'foo'[2, 0]    # =&gt; ""

'foo'[1..200]  # =&gt; "oo"
'foo'[1, 200]  # =&gt; "oo"

'foo'[4..5]    # =&gt; nil
'foo'[4, 2]    # =&gt; nil

'foo'[-4..-3]  # =&gt; nil
'foo'[-4, 2]   # =&gt; nil

'foo'[3..4]    # =&gt; ""
'foo'[3, 2]    # =&gt; ""

'foo'[-2..-1]  # =&gt; "oo"
'foo'[-2, 2]   # =&gt; "oo"

'foo'[-2..197] # =&gt; "oo"
'foo'[-2, 200] # =&gt; "oo"
</pre> <p><strong><code>string[regexp, capture = 0]</code></strong></p> <p>When the <a href="regexp.html"><code>Regexp</code></a> argument <code>regexp</code> is given, and the <code>capture</code> argument is <code>0</code>, the slice is the first matching substring found in <code>self</code>:</p> <pre class="ruby" data-language="ruby">'foo'[/o/] # =&gt; "o"
'foo'[/x/] # =&gt; nil
s = 'hello there'
s[/[aeiou](.)\1/] # =&gt; "ell"
s[/[aeiou](.)\1/, 0] # =&gt; "ell"
</pre> <p>If argument <code>capture</code> is given and not <code>0</code>, it should be either an capture group index (integer) or a capture group name (string or symbol); the slice is the specified capture (see <a href="regexp.html#class-Regexp-label-Groups+and+Captures">Groups and Captures at <code>Regexp</code></a>):</p> <pre class="ruby" data-language="ruby">s = 'hello there'
s[/[aeiou](.)\1/, 1] # =&gt; "l"
s[/(?&lt;vowel&gt;[aeiou])(?&lt;non_vowel&gt;[^aeiou])/, "non_vowel"] # =&gt; "l"
s[/(?&lt;vowel&gt;[aeiou])(?&lt;non_vowel&gt;[^aeiou])/, :vowel] # =&gt; "e"
</pre> <p>If an invalid capture group index is given, there is no slice. If an invalid capture group name is given, <code>IndexError</code> is raised.</p> <p><strong><code>string[substring]</code></strong></p> <p>When the single String argument <code>substring</code> is given, returns the substring from <code>self</code> if found, otherwise <code>nil</code>:</p> <pre class="ruby" data-language="ruby">'foo'['oo'] # =&gt; "oo"
'foo'['xx'] # =&gt; nil
</pre> <h2 id="class-String-label-What-27s+Here">What’s Here</h2> <p>First, what’s elsewhere. Class String:</p> <ul>
<li> <p>Inherits from <a href="object.html#class-Object-label-What-27s+Here">class Object</a>.</p> </li>
<li> <p>Includes <a href="comparable.html#module-Comparable-label-What-27s+Here">module Comparable</a>.</p> </li>
</ul> <p>Here, class String provides methods that are useful for:</p> <ul>
<li> <p><a href="string.html#class-String-label-Methods+for+Creating+a+String">Creating a String</a></p> </li>
<li> <p><a href="string.html#class-String-label-Methods+for+a+Frozen-2FUnfrozen+String">Frozen/Unfrozen Strings</a></p> </li>
<li> <p><a href="string.html#class-String-label-Methods+for+Querying">Querying</a></p> </li>
<li> <p><a href="string.html#class-String-label-Methods+for+Comparing">Comparing</a></p> </li>
<li> <p><a href="string.html#class-String-label-Methods+for+Modifying+a+String">Modifying a String</a></p> </li>
<li> <p><a href="string.html#class-String-label-Methods+for+Converting+to+New+String">Converting to New String</a></p> </li>
<li> <p><a href="string.html#class-String-label-Methods+for+Converting+to+Non--5CString">Converting to Non-String</a></p> </li>
<li> <p><a href="string.html#class-String-label-Methods+for+Iterating">Iterating</a></p> </li>
</ul> <h3 id="class-String-label-Methods+for+Creating+a+String">Methods for Creating a String</h3> <ul>
<li> <p><a href="string.html#method-c-new"><code>::new</code></a>: Returns a new string.</p> </li>
<li> <p><a href="string.html#method-c-try_convert"><code>::try_convert</code></a>: Returns a new string created from a given object.</p> </li>
</ul> <h3 id="class-String-label-Methods+for+a+Frozen-2FUnfrozen+String">Methods for a Frozen/Unfrozen <a href="string.html"><code>String</code></a>
</h3> <ul>
<li> <p><a href="string.html#method-i-2B-40"><code>+@</code></a>: Returns a string that is not frozen: <code>self</code>, if not frozen; <code>self.dup</code> otherwise.</p> </li>
<li> <p><a href="string.html#method-i-2D-40"><code>-@</code></a>: Returns a string that is frozen: <code>self</code>, if already frozen; <code>self.freeze</code> otherwise.</p> </li>
<li> <p><a href="object.html#method-i-freeze"><code>freeze</code></a>: Freezes <code>self</code>, if not already frozen; returns <code>self</code>.</p> </li>
</ul> <h3 id="class-String-label-Methods+for+Querying">Methods for Querying</h3> <p><em>Counts</em></p> <ul>
<li> <p><a href="string.html#method-i-length"><code>length</code></a>, <a href="string.html#method-i-size"><code>size</code></a>: Returns the count of characters (not bytes).</p> </li>
<li> <p><a href="string.html#method-i-empty-3F"><code>empty?</code></a>: Returns <code>true</code> if <code>self.length</code> is zero; <code>false</code> otherwise.</p> </li>
<li> <p><a href="string.html#method-i-bytesize"><code>bytesize</code></a>: Returns the count of bytes.</p> </li>
<li> <p><a href="string.html#method-i-count"><code>count</code></a>: Returns the count of substrings matching given strings.</p> </li>
</ul> <p><em>Substrings</em></p> <ul>
<li> <p><a href="string.html#method-i-3D~"><code>=~</code></a>: Returns the index of the first substring that matches a given <a href="regexp.html"><code>Regexp</code></a> or other object; returns <code>nil</code> if no match is found.</p> </li>
<li> <p><a href="string.html#method-i-index"><code>index</code></a>: Returns the index of the <em>first</em> occurrence of a given substring; returns <code>nil</code> if none found.</p> </li>
<li> <p><a href="string.html#method-i-rindex"><code>rindex</code></a>: Returns the index of the <em>last</em> occurrence of a given substring; returns <code>nil</code> if none found.</p> </li>
<li> <p><a href="string.html#method-i-include-3F"><code>include?</code></a>: Returns <code>true</code> if the string contains a given substring; <code>false</code> otherwise.</p> </li>
<li> <p><a href="string.html#method-i-match"><code>match</code></a>: Returns a <a href="matchdata.html"><code>MatchData</code></a> object if the string matches a given <a href="regexp.html"><code>Regexp</code></a>; <code>nil</code> otherwise.</p> </li>
<li> <p><a href="string.html#method-i-match-3F"><code>match?</code></a>: Returns <code>true</code> if the string matches a given <a href="regexp.html"><code>Regexp</code></a>; <code>false</code> otherwise.</p> </li>
<li> <p><a href="string.html#method-i-start_with-3F"><code>start_with?</code></a>: Returns <code>true</code> if the string begins with any of the given substrings.</p> </li>
<li> <p><a href="string.html#method-i-end_with-3F"><code>end_with?</code></a>: Returns <code>true</code> if the string ends with any of the given substrings.</p> </li>
</ul> <p><em>Encodings</em></p> <ul>
<li> <p><a href="string.html#method-i-encoding"><code>encoding</code></a>: Returns the <a href="encoding.html"><code>Encoding</code></a> object that represents the encoding of the string.</p> </li>
<li> <p><a href="string.html#method-i-unicode_normalized-3F"><code>unicode_normalized?</code></a>: Returns <code>true</code> if the string is in Unicode normalized form; <code>false</code> otherwise.</p> </li>
<li> <p><a href="string.html#method-i-valid_encoding-3F"><code>valid_encoding?</code></a>: Returns <code>true</code> if the string contains only characters that are valid for its encoding.</p> </li>
<li> <p><a href="string.html#method-i-ascii_only-3F"><code>ascii_only?</code></a>: Returns <code>true</code> if the string has only ASCII characters; <code>false</code> otherwise.</p> </li>
</ul> <p><em>Other</em></p> <ul>
<li> <p><a href="string.html#method-i-sum"><code>sum</code></a>: Returns a basic checksum for the string: the sum of each byte.</p> </li>
<li> <p><a href="string.html#method-i-hash"><code>hash</code></a>: Returns the integer hash code.</p> </li>
</ul> <h3 id="class-String-label-Methods+for+Comparing">Methods for Comparing</h3> <ul>
<li> <p><a href="string.html#method-i-3D-3D"><code>==</code></a>, <a href="string.html#method-i-3D-3D-3D"><code>===</code></a>: Returns <code>true</code> if a given other string has the same content as <code>self</code>.</p> </li>
<li> <p><a href="string.html#method-i-eql-3F"><code>eql?</code></a>: Returns <code>true</code> if the content is the same as the given other string.</p> </li>
<li> <p><a href="string.html#method-i-3C-3D-3E"><code>&lt;=&gt;</code></a>: Returns -1, 0, or 1 as a given other string is smaller than, equal to, or larger than <code>self</code>.</p> </li>
<li> <p><a href="string.html#method-i-casecmp"><code>casecmp</code></a>: Ignoring case, returns -1, 0, or 1 as a given other string is smaller than, equal to, or larger than <code>self</code>.</p> </li>
<li> <p><a href="string.html#method-i-casecmp-3F"><code>casecmp?</code></a>: Returns <code>true</code> if the string is equal to a given string after Unicode case folding; <code>false</code> otherwise.</p> </li>
</ul> <h3 id="class-String-label-Methods+for+Modifying+a+String">Methods for Modifying a String</h3> <p>Each of these methods modifies <code>self</code>.</p> <p><em>Insertion</em></p> <ul>
<li> <p><a href="string.html#method-i-insert"><code>insert</code></a>: Returns <code>self</code> with a given string inserted at a given offset.</p> </li>
<li> <p><a href="string.html#method-i-3C-3C"><code>&lt;&lt;</code></a>: Returns <code>self</code> concatenated with a given string or integer.</p> </li>
</ul> <p><em>Substitution</em></p> <ul>
<li> <p><a href="string.html#method-i-sub-21"><code>sub!</code></a>: Replaces the first substring that matches a given pattern with a given replacement string; returns <code>self</code> if any changes, <code>nil</code> otherwise.</p> </li>
<li> <p><a href="string.html#method-i-gsub-21"><code>gsub!</code></a>: Replaces each substring that matches a given pattern with a given replacement string; returns <code>self</code> if any changes, <code>nil</code> otherwise.</p> </li>
<li> <p><a href="string.html#method-i-succ-21"><code>succ!</code></a>, <a href="string.html#method-i-next-21"><code>next!</code></a>: Returns <code>self</code> modified to become its own successor.</p> </li>
<li> <p><a href="string.html#method-i-replace"><code>replace</code></a>: Returns <code>self</code> with its entire content replaced by a given string.</p> </li>
<li> <p><a href="string.html#method-i-reverse-21"><code>reverse!</code></a>: Returns <code>self</code> with its characters in reverse order.</p> </li>
<li> <p><a href="string.html#method-i-setbyte"><code>setbyte</code></a>: Sets the byte at a given integer offset to a given value; returns the argument.</p> </li>
<li> <p><a href="string.html#method-i-tr-21"><code>tr!</code></a>: Replaces specified characters in <code>self</code> with specified replacement characters; returns <code>self</code> if any changes, <code>nil</code> otherwise.</p> </li>
<li> <p><a href="string.html#method-i-tr_s-21"><code>tr_s!</code></a>: Replaces specified characters in <code>self</code> with specified replacement characters, removing duplicates from the substrings that were modified; returns <code>self</code> if any changes, <code>nil</code> otherwise.</p> </li>
</ul> <p><em>Casing</em></p> <ul>
<li> <p><a href="string.html#method-i-capitalize-21"><code>capitalize!</code></a>: Upcases the initial character and downcases all others; returns <code>self</code> if any changes, <code>nil</code> otherwise.</p> </li>
<li> <p><a href="string.html#method-i-downcase-21"><code>downcase!</code></a>: Downcases all characters; returns <code>self</code> if any changes, <code>nil</code> otherwise.</p> </li>
<li> <p><a href="string.html#method-i-upcase-21"><code>upcase!</code></a>: Upcases all characters; returns <code>self</code> if any changes, <code>nil</code> otherwise.</p> </li>
<li> <p><a href="string.html#method-i-swapcase-21"><code>swapcase!</code></a>: Upcases each downcase character and downcases each upcase character; returns <code>self</code> if any changes, <code>nil</code> otherwise.</p> </li>
</ul> <p><em>Encoding</em></p> <ul>
<li> <p><a href="string.html#method-i-encode-21"><code>encode!</code></a>: Returns <code>self</code> with all characters transcoded from one given encoding into another.</p> </li>
<li> <p><a href="string.html#method-i-unicode_normalize-21"><code>unicode_normalize!</code></a>: Unicode-normalizes <code>self</code>; returns <code>self</code>.</p> </li>
<li> <p><a href="string.html#method-i-scrub-21"><code>scrub!</code></a>: Replaces each invalid byte with a given character; returns <code>self</code>.</p> </li>
<li> <p><a href="string.html#method-i-force_encoding"><code>force_encoding</code></a>: Changes the encoding to a given encoding; returns <code>self</code>.</p> </li>
</ul> <p><em>Deletion</em></p> <ul>
<li> <p><a href="string.html#method-i-clear"><code>clear</code></a>: Removes all content, so that <code>self</code> is empty; returns <code>self</code>.</p> </li>
<li> <p><a href="string.html#method-i-slice-21"><code>slice!</code></a>, <a href="string.html#method-i-5B-5D-3D"><code>[]=</code></a>: Removes a substring determined by a given index, start/length, range, regexp, or substring.</p> </li>
<li> <p><a href="string.html#method-i-squeeze-21"><code>squeeze!</code></a>: Removes contiguous duplicate characters; returns <code>self</code>.</p> </li>
<li> <p><a href="string.html#method-i-delete-21"><code>delete!</code></a>: Removes characters as determined by the intersection of substring arguments.</p> </li>
<li> <p><a href="string.html#method-i-lstrip-21"><code>lstrip!</code></a>: Removes leading whitespace; returns <code>self</code> if any changes, <code>nil</code> otherwise.</p> </li>
<li> <p><a href="string.html#method-i-rstrip-21"><code>rstrip!</code></a>: Removes trailing whitespace; returns <code>self</code> if any changes, <code>nil</code> otherwise.</p> </li>
<li> <p><a href="string.html#method-i-strip-21"><code>strip!</code></a>: Removes leading and trailing whitespace; returns <code>self</code> if any changes, <code>nil</code> otherwise.</p> </li>
<li> <p><a href="string.html#method-i-chomp-21"><code>chomp!</code></a>: Removes trailing record separator, if found; returns <code>self</code> if any changes, <code>nil</code> otherwise.</p> </li>
<li> <p><a href="string.html#method-i-chop-21"><code>chop!</code></a>: Removes trailing newline characters if found; otherwise removes the last character; returns <code>self</code> if any changes, <code>nil</code> otherwise.</p> </li>
</ul> <h3 id="class-String-label-Methods+for+Converting+to+New+String">Methods for Converting to New String</h3> <p>Each of these methods returns a new String based on <code>self</code>, often just a modified copy of <code>self</code>.</p> <p><em>Extension</em></p> <ul>
<li> <p><a href="string.html#method-i-2A"><code>*</code></a>: Returns the concatenation of multiple copies of <code>self</code>,</p> </li>
<li> <p><a href="string.html#method-i-2B"><code>+</code></a>: Returns the concatenation of <code>self</code> and a given other string.</p> </li>
<li> <p><a href="string.html#method-i-center"><code>center</code></a>: Returns a copy of <code>self</code> centered between pad substring.</p> </li>
<li> <p><a href="string.html#method-i-concat"><code>concat</code></a>: Returns the concatenation of <code>self</code> with given other strings.</p> </li>
<li> <p><a href="string.html#method-i-prepend"><code>prepend</code></a>: Returns the concatenation of a given other string with <code>self</code>.</p> </li>
<li> <p><a href="string.html#method-i-ljust"><code>ljust</code></a>: Returns a copy of <code>self</code> of a given length, right-padded with a given other string.</p> </li>
<li> <p><a href="string.html#method-i-rjust"><code>rjust</code></a>: Returns a copy of <code>self</code> of a given length, left-padded with a given other string.</p> </li>
</ul> <p><em>Encoding</em></p> <ul>
<li> <p><a href="string.html#method-i-b"><code>b</code></a>: Returns a copy of <code>self</code> with ASCII-8BIT encoding.</p> </li>
<li> <p><a href="string.html#method-i-scrub"><code>scrub</code></a>: Returns a copy of <code>self</code> with each invalid byte replaced with a given character.</p> </li>
<li> <p><a href="string.html#method-i-unicode_normalize"><code>unicode_normalize</code></a>: Returns a copy of <code>self</code> with each character Unicode-normalized.</p> </li>
<li> <p><a href="string.html#method-i-encode"><code>encode</code></a>: Returns a copy of <code>self</code> with all characters transcoded from one given encoding into another.</p> </li>
</ul> <p><em>Substitution</em></p> <ul>
<li> <p><a href="string.html#method-i-dump"><code>dump</code></a>: Returns a copy of <code>self</code> with all non-printing characters replaced by xHH notation and all special characters escaped.</p> </li>
<li> <p><a href="string.html#method-i-undump"><code>undump</code></a>: Returns a copy of <code>self</code> with all <code>\xNN</code> notation replace by <code>\uNNNN</code> notation and all escaped characters unescaped.</p> </li>
<li> <p><a href="string.html#method-i-sub"><code>sub</code></a>: Returns a copy of <code>self</code> with the first substring matching a given pattern replaced with a given replacement string;.</p> </li>
<li> <p><a href="string.html#method-i-gsub"><code>gsub</code></a>: Returns a copy of <code>self</code> with each substring that matches a given pattern replaced with a given replacement string.</p> </li>
<li> <p><a href="string.html#method-i-succ"><code>succ</code></a>, <a href="string.html#method-i-next"><code>next</code></a>: Returns the string that is the successor to <code>self</code>.</p> </li>
<li> <p><a href="string.html#method-i-reverse"><code>reverse</code></a>: Returns a copy of <code>self</code> with its characters in reverse order.</p> </li>
<li> <p><a href="string.html#method-i-tr"><code>tr</code></a>: Returns a copy of <code>self</code> with specified characters replaced with specified replacement characters.</p> </li>
<li> <p><a href="string.html#method-i-tr_s"><code>tr_s</code></a>: Returns a copy of <code>self</code> with specified characters replaced with specified replacement characters, removing duplicates from the substrings that were modified.</p> </li>
<li> <p><a href="string.html#method-i-25"><code>%</code></a>: Returns the string resulting from formatting a given object into <code>self</code></p> </li>
</ul> <p><em>Casing</em></p> <ul>
<li> <p><a href="string.html#method-i-capitalize"><code>capitalize</code></a>: Returns a copy of <code>self</code> with the first character upcased and all other characters downcased.</p> </li>
<li> <p><a href="string.html#method-i-downcase"><code>downcase</code></a>: Returns a copy of <code>self</code> with all characters downcased.</p> </li>
<li> <p><a href="string.html#method-i-upcase"><code>upcase</code></a>: Returns a copy of <code>self</code> with all characters upcased.</p> </li>
<li> <p><a href="string.html#method-i-swapcase"><code>swapcase</code></a>: Returns a copy of <code>self</code> with all upcase characters downcased and all downcase characters upcased.</p> </li>
</ul> <p><em>Deletion</em></p> <ul>
<li> <p><a href="string.html#method-i-delete"><code>delete</code></a>: Returns a copy of <code>self</code> with characters removed</p> </li>
<li> <p><a href="string.html#method-i-delete_prefix"><code>delete_prefix</code></a>: Returns a copy of <code>self</code> with a given prefix removed.</p> </li>
<li> <p><a href="string.html#method-i-delete_suffix"><code>delete_suffix</code></a>: Returns a copy of <code>self</code> with a given suffix removed.</p> </li>
<li> <p><a href="string.html#method-i-lstrip"><code>lstrip</code></a>: Returns a copy of <code>self</code> with leading whitespace removed.</p> </li>
<li> <p><a href="string.html#method-i-rstrip"><code>rstrip</code></a>: Returns a copy of <code>self</code> with trailing whitespace removed.</p> </li>
<li> <p><a href="string.html#method-i-strip"><code>strip</code></a>: Returns a copy of <code>self</code> with leading and trailing whitespace removed.</p> </li>
<li> <p><a href="string.html#method-i-chomp"><code>chomp</code></a>: Returns a copy of <code>self</code> with a trailing record separator removed, if found.</p> </li>
<li> <p><a href="string.html#method-i-chop"><code>chop</code></a>: Returns a copy of <code>self</code> with trailing newline characters or the last character removed.</p> </li>
<li> <p><a href="string.html#method-i-squeeze"><code>squeeze</code></a>: Returns a copy of <code>self</code> with contiguous duplicate characters removed.</p> </li>
<li> <p><a href="string.html#method-i-5B-5D"><code>[]</code></a>, <a href="string.html#method-i-slice"><code>slice</code></a>: Returns a substring determined by a given index, start/length, or range, or string.</p> </li>
<li> <p><a href="string.html#method-i-byteslice"><code>byteslice</code></a>: Returns a substring determined by a given index, start/length, or range.</p> </li>
<li> <p><a href="string.html#method-i-chr"><code>chr</code></a>: Returns the first character.</p> </li>
</ul> <p><em>Duplication</em></p> <ul><li> <p><a href="string.html#method-i-to_s"><code>to_s</code></a>, $to_str: If <code>self</code> is a subclass of String, returns <code>self</code> copied into a String; otherwise, returns <code>self</code>.</p> </li></ul> <h3 id="class-String-label-Methods+for+Converting+to+Non--5CString">Methods for Converting to Non-String</h3> <p>Each of these methods converts the contents of <code>self</code> to a non-String.</p> <p><em>Characters, Bytes, and Clusters</em></p> <ul>
<li> <p><a href="string.html#method-i-bytes"><code>bytes</code></a>: Returns an array of the bytes in <code>self</code>.</p> </li>
<li> <p><a href="string.html#method-i-chars"><code>chars</code></a>: Returns an array of the characters in <code>self</code>.</p> </li>
<li> <p><a href="string.html#method-i-codepoints"><code>codepoints</code></a>: Returns an array of the integer ordinals in <code>self</code>.</p> </li>
<li> <p><a href="string.html#method-i-getbyte"><code>getbyte</code></a>: Returns an integer byte as determined by a given index.</p> </li>
<li> <p><a href="string.html#method-i-grapheme_clusters"><code>grapheme_clusters</code></a>: Returns an array of the grapheme clusters in <code>self</code>.</p> </li>
</ul> <p><em>Splitting</em></p> <ul>
<li> <p><a href="string.html#method-i-lines"><code>lines</code></a>: Returns an array of the lines in <code>self</code>, as determined by a given record separator.</p> </li>
<li> <p><a href="string.html#method-i-partition"><code>partition</code></a>: Returns a 3-element array determined by the first substring that matches a given substring or regexp,</p> </li>
<li> <p><a href="string.html#method-i-rpartition"><code>rpartition</code></a>: Returns a 3-element array determined by the last substring that matches a given substring or regexp,</p> </li>
<li> <p><a href="string.html#method-i-split"><code>split</code></a>: Returns an array of substrings determined by a given delimiter – regexp or string – or, if a block given, passes those substrings to the block.</p> </li>
</ul> <p><em>Matching</em></p> <ul>
<li> <p><a href="string.html#method-i-scan"><code>scan</code></a>: Returns an array of substrings matching a given regexp or string, or, if a block given, passes each matching substring to the block.</p> </li>
<li> <p><a href="string.html#method-i-unpack"><code>unpack</code></a>: Returns an array of substrings extracted from <code>self</code> according to a given format.</p> </li>
<li> <p><a href="string.html#method-i-unpack1"><code>unpack1</code></a>: Returns the first substring extracted from <code>self</code> according to a given format.</p> </li>
</ul> <p><em>Numerics</em></p> <ul>
<li> <p><a href="string.html#method-i-hex"><code>hex</code></a>: Returns the integer value of the leading characters, interpreted as hexadecimal digits.</p> </li>
<li> <p><a href="string.html#method-i-oct"><code>oct</code></a>: Returns the integer value of the leading characters, interpreted as octal digits.</p> </li>
<li> <p><a href="string.html#method-i-ord"><code>ord</code></a>: Returns the integer ordinal of the first character in <code>self</code>.</p> </li>
<li> <p><a href="string.html#method-i-to_i"><code>to_i</code></a>: Returns the integer value of leading characters, interpreted as an integer.</p> </li>
<li> <p><a href="string.html#method-i-to_f"><code>to_f</code></a>: Returns the floating-point value of leading characters, interpreted as a floating-point number.</p> </li>
</ul> <p><em>Strings and Symbols</em></p> <ul>
<li> <p><a href="string.html#method-i-inspect"><code>inspect</code></a>: Returns copy of <code>self</code>, enclosed in double-quotes, with special characters escaped.</p> </li>
<li> <p><a href="string.html#method-i-to_sym"><code>to_sym</code></a>, <a href="string.html#method-i-intern"><code>intern</code></a>: Returns the symbol corresponding to <code>self</code>.</p> </li>
</ul> <h3 id="class-String-label-Methods+for+Iterating">Methods for Iterating</h3> <ul>
<li> <p><a href="string.html#method-i-each_byte"><code>each_byte</code></a>: Calls the given block with each successive byte in <code>self</code>.</p> </li>
<li> <p><a href="string.html#method-i-each_char"><code>each_char</code></a>: Calls the given block with each successive character in <code>self</code>.</p> </li>
<li> <p><a href="string.html#method-i-each_codepoint"><code>each_codepoint</code></a>: Calls the given block with each successive integer codepoint in <code>self</code>.</p> </li>
<li> <p><a href="string.html#method-i-each_grapheme_cluster"><code>each_grapheme_cluster</code></a>: Calls the given block with each successive grapheme cluster in <code>self</code>.</p> </li>
<li> <p><a href="string.html#method-i-each_line"><code>each_line</code></a>: Calls the given block with each successive line in <code>self</code>, as determined by a given record separator.</p> </li>
<li> <p><a href="string.html#method-i-upto"><code>upto</code></a>: Calls the given block with each string value returned by successive calls to <a href="string.html#method-i-succ"><code>succ</code></a>.</p> </li>
</ul> </section> <section id="5Buntitled-5D" class="documentation-section"> <section id="public-class-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-new"> <span class="method-callseq"> new(string = '', **opts) → new_string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="new-source"> <pre class="c" data-language="c">static VALUE
rb_str_init(int argc, VALUE *argv, VALUE str)
{
    static ID keyword_ids[2];
    VALUE orig, opt, venc, vcapa;
    VALUE kwargs[2];
    rb_encoding *enc = 0;
    int n;

    if (!keyword_ids[0]) {
        keyword_ids[0] = rb_id_encoding();
        CONST_ID(keyword_ids[1], "capacity");
    }

    n = rb_scan_args(argc, argv, "01:", &amp;orig, &amp;opt);
    if (!NIL_P(opt)) {
        rb_get_kwargs(opt, keyword_ids, 0, 2, kwargs);
        venc = kwargs[0];
        vcapa = kwargs[1];
        if (!UNDEF_P(venc) &amp;&amp; !NIL_P(venc)) {
            enc = rb_to_encoding(venc);
        }
        if (!UNDEF_P(vcapa) &amp;&amp; !NIL_P(vcapa)) {
            long capa = NUM2LONG(vcapa);
            long len = 0;
            int termlen = enc ? rb_enc_mbminlen(enc) : 1;

            if (capa &lt; STR_BUF_MIN_SIZE) {
                capa = STR_BUF_MIN_SIZE;
            }
            if (n == 1) {
                StringValue(orig);
                len = RSTRING_LEN(orig);
                if (capa &lt; len) {
                    capa = len;
                }
                if (orig == str) n = 0;
            }
            str_modifiable(str);
            if (STR_EMBED_P(str)) { /* make noembed always */
                char *new_ptr = ALLOC_N(char, (size_t)capa + termlen);
                assert(RSTRING_LEN(str) + 1 &lt;= str_embed_capa(str));
                memcpy(new_ptr, RSTRING(str)-&gt;as.embed.ary, RSTRING_LEN(str) + 1);
                RSTRING(str)-&gt;as.heap.ptr = new_ptr;
            }
            else if (FL_TEST(str, STR_SHARED|STR_NOFREE)) {
                const size_t size = (size_t)capa + termlen;
                const char *const old_ptr = RSTRING_PTR(str);
                const size_t osize = RSTRING_LEN(str) + TERM_LEN(str);
                char *new_ptr = ALLOC_N(char, (size_t)capa + termlen);
                memcpy(new_ptr, old_ptr, osize &lt; size ? osize : size);
                FL_UNSET_RAW(str, STR_SHARED|STR_NOFREE);
                RSTRING(str)-&gt;as.heap.ptr = new_ptr;
            }
            else if (STR_HEAP_SIZE(str) != (size_t)capa + termlen) {
                SIZED_REALLOC_N(RSTRING(str)-&gt;as.heap.ptr, char,
                        (size_t)capa + termlen, STR_HEAP_SIZE(str));
            }
            STR_SET_LEN(str, len);
            TERM_FILL(&amp;RSTRING(str)-&gt;as.heap.ptr[len], termlen);
            if (n == 1) {
                memcpy(RSTRING(str)-&gt;as.heap.ptr, RSTRING_PTR(orig), len);
                rb_enc_cr_str_exact_copy(str, orig);
            }
            FL_SET(str, STR_NOEMBED);
            RSTRING(str)-&gt;as.heap.aux.capa = capa;
        }
        else if (n == 1) {
            rb_str_replace(str, orig);
        }
        if (enc) {
            rb_enc_associate(str, enc);
            ENC_CODERANGE_CLEAR(str);
        }
    }
    else if (n == 1) {
        rb_str_replace(str, orig);
    }
    return str;
}</pre> </div> <p>Returns a new String that is a copy of <code>string</code>.</p> <p>With no arguments, returns the empty string with the <a href="encoding.html"><code>Encoding</code></a> <code>ASCII-8BIT</code>:</p> <pre class="ruby" data-language="ruby">s = String.new
s # =&gt; ""
s.encoding # =&gt; #&lt;Encoding:ASCII-8BIT&gt;
</pre> <p>With optional argument <code>string</code> and no keyword arguments, returns a copy of <code>string</code> with the same encoding:</p> <pre class="ruby" data-language="ruby">String.new('foo')               # =&gt; "foo"
String.new('тест')              # =&gt; "тест"
String.new('こんにちは')          # =&gt; "こんにちは"
</pre> <p>(Unlike String.new, a <a href="syntax/literals_rdoc.html#label-String+Literals">string literal</a> like <code>''</code> or a <a href="syntax/literals_rdoc.html#label-Here+Document+Literals">here document literal</a> always has <a href="encodings_rdoc.html#label-Script+Encoding">script encoding</a>.)</p> <p>With optional keyword argument <code>encoding</code>, returns a copy of <code>string</code> with the specified encoding; the <code>encoding</code> may be an <a href="encoding.html"><code>Encoding</code></a> object, an encoding name, or an encoding name alias:</p> <pre class="ruby" data-language="ruby">String.new('foo', encoding: Encoding::US_ASCII).encoding # =&gt; #&lt;Encoding:US-ASCII&gt;
String.new('foo', encoding: 'US-ASCII').encoding         # =&gt; #&lt;Encoding:US-ASCII&gt;
String.new('foo', encoding: 'ASCII').encoding            # =&gt; #&lt;Encoding:US-ASCII&gt;
</pre> <p>The given encoding need not be valid for the string’s content, and that validity is not checked:</p> <pre class="ruby" data-language="ruby">s = String.new('こんにちは', encoding: 'ascii')
s.valid_encoding? # =&gt; false
</pre> <p>But the given <code>encoding</code> itself is checked:</p> <pre class="ruby" data-language="ruby">String.new('foo', encoding: 'bar') # Raises ArgumentError.
</pre> <p>With optional keyword argument <code>capacity</code>, returns a copy of <code>string</code> (or an empty string, if <code>string</code> is not given); the given <code>capacity</code> is advisory only, and may or may not set the size of the internal buffer, which may in turn affect performance:</p> <pre class="ruby" data-language="ruby">String.new(capacity: 1)
String.new('foo', capacity: 4096)
</pre> <p>The <code>string</code>, <code>encoding</code>, and <code>capacity</code> arguments may all be used together:</p> <pre class="ruby" data-language="ruby">String.new('hello', encoding: 'UTF-8', capacity: 25)
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-try_convert"> <span class="method-callseq"> try_convert(object) → object, new_string, or nil </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="try_convert-source"> <pre class="c" data-language="c">static VALUE
rb_str_s_try_convert(VALUE dummy, VALUE str)
{
    return rb_check_string_type(str);
}</pre> </div> <p>If <code>object</code> is a String object, returns <code>object</code>.</p> <p>Otherwise if <code>object</code> responds to <code>:to_str</code>, calls <code>object.to_str</code> and returns the result.</p> <p>Returns <code>nil</code> if <code>object</code> does not respond to <code>:to_str</code>.</p> <p>Raises an exception unless <code>object.to_str</code> returns a String object.</p>  </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-25"> <span class="method-callseq"> string % object → new_string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="25-source"> <pre class="c" data-language="c">static VALUE
rb_str_format_m(VALUE str, VALUE arg)
{
    VALUE tmp = rb_check_array_type(arg);

    if (!NIL_P(tmp)) {
        return rb_str_format(RARRAY_LENINT(tmp), RARRAY_CONST_PTR(tmp), str);
    }
    return rb_str_format(1, &amp;arg, str);
}</pre> </div> <p>Returns the result of formatting <code>object</code> into the format specification <code>self</code> (see <a href="kernel.html#method-i-sprintf"><code>Kernel#sprintf</code></a> for formatting details):</p> <pre class="ruby" data-language="ruby">"%05d" % 123 # =&gt; "00123"
</pre> <p>If <code>self</code> contains multiple substitutions, <code>object</code> must be an <a href="array.html"><code>Array</code></a> or <a href="hash.html"><code>Hash</code></a> containing the values to be substituted:</p> <pre class="ruby" data-language="ruby">"%-5s: %016x" % [ "ID", self.object_id ] # =&gt; "ID   : 00002b054ec93168"
"foo = %{foo}" % {foo: 'bar'} # =&gt; "foo = bar"
"foo = %{foo}, baz = %{baz}" % {foo: 'bar', baz: 'bat'} # =&gt; "foo = bar, baz = bat"
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-2A"> <span class="method-callseq"> string * integer → new_string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="2A-source"> <pre class="c" data-language="c">VALUE
rb_str_times(VALUE str, VALUE times)
{
    VALUE str2;
    long n, len;
    char *ptr2;
    int termlen;

    if (times == INT2FIX(1)) {
        return str_duplicate(rb_cString, str);
    }
    if (times == INT2FIX(0)) {
        str2 = str_alloc_embed(rb_cString, 0);
        rb_enc_copy(str2, str);
        return str2;
    }
    len = NUM2LONG(times);
    if (len &lt; 0) {
        rb_raise(rb_eArgError, "negative argument");
    }
    if (RSTRING_LEN(str) == 1 &amp;&amp; RSTRING_PTR(str)[0] == 0) {
        if (STR_EMBEDDABLE_P(len, 1)) {
            str2 = str_alloc_embed(rb_cString, len + 1);
            memset(RSTRING_PTR(str2), 0, len + 1);
        }
        else {
            str2 = str_alloc_heap(rb_cString);
            RSTRING(str2)-&gt;as.heap.aux.capa = len;
            RSTRING(str2)-&gt;as.heap.ptr = ZALLOC_N(char, (size_t)len + 1);
        }
        STR_SET_LEN(str2, len);
        rb_enc_copy(str2, str);
        return str2;
    }
    if (len &amp;&amp; LONG_MAX/len &lt;  RSTRING_LEN(str)) {
        rb_raise(rb_eArgError, "argument too big");
    }

    len *= RSTRING_LEN(str);
    termlen = TERM_LEN(str);
    str2 = str_new0(rb_cString, 0, len, termlen);
    ptr2 = RSTRING_PTR(str2);
    if (len) {
        n = RSTRING_LEN(str);
        memcpy(ptr2, RSTRING_PTR(str), n);
        while (n &lt;= len/2) {
            memcpy(ptr2 + n, ptr2, n);
            n *= 2;
        }
        memcpy(ptr2 + n, ptr2, len-n);
    }
    STR_SET_LEN(str2, len);
    TERM_FILL(&amp;ptr2[len], termlen);
    rb_enc_cr_str_copy_for_substr(str2, str);

    return str2;
}</pre> </div> <p>Returns a new String containing <code>integer</code> copies of <code>self</code>:</p> <pre class="ruby" data-language="ruby">"Ho! " * 3 # =&gt; "Ho! Ho! Ho! "
"Ho! " * 0 # =&gt; ""
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-2B"> <span class="method-callseq"> string + other_string → new_string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="2B-source"> <pre class="c" data-language="c">VALUE
rb_str_plus(VALUE str1, VALUE str2)
{
    VALUE str3;
    rb_encoding *enc;
    char *ptr1, *ptr2, *ptr3;
    long len1, len2;
    int termlen;

    StringValue(str2);
    enc = rb_enc_check_str(str1, str2);
    RSTRING_GETMEM(str1, ptr1, len1);
    RSTRING_GETMEM(str2, ptr2, len2);
    termlen = rb_enc_mbminlen(enc);
    if (len1 &gt; LONG_MAX - len2) {
        rb_raise(rb_eArgError, "string size too big");
    }
    str3 = str_new0(rb_cString, 0, len1+len2, termlen);
    ptr3 = RSTRING_PTR(str3);
    memcpy(ptr3, ptr1, len1);
    memcpy(ptr3+len1, ptr2, len2);
    TERM_FILL(&amp;ptr3[len1+len2], termlen);

    ENCODING_CODERANGE_SET(str3, rb_enc_to_index(enc),
                           ENC_CODERANGE_AND(ENC_CODERANGE(str1), ENC_CODERANGE(str2)));
    RB_GC_GUARD(str1);
    RB_GC_GUARD(str2);
    return str3;
}</pre> </div> <p>Returns a new String containing <code>other_string</code> concatenated to <code>self</code>:</p> <pre class="ruby" data-language="ruby">"Hello from " + self.to_s # =&gt; "Hello from main"
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-2B-40"> <span class="method-callseq"> +string → new_string or self </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="2B-40-source"> <pre class="c" data-language="c">static VALUE
str_uplus(VALUE str)
{
    if (OBJ_FROZEN(str)) {
        return rb_str_dup(str);
    }
    else {
        return str;
    }
}</pre> </div> <p>Returns <code>self</code> if <code>self</code> is not frozen.</p> <p>Otherwise returns <code>self.dup</code>, which is not frozen.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-2D-40"> <span class="method-callseq"> -string → frozen_string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="2D-40-source"> <pre class="c" data-language="c">static VALUE
str_uminus(VALUE str)
{
    if (!BARE_STRING_P(str) &amp;&amp; !rb_obj_frozen_p(str)) {
        str = rb_str_dup(str);
    }
    return rb_fstring(str);
}</pre> </div> <p>Returns a frozen, possibly pre-existing copy of the string.</p> <p>The returned String will be deduplicated as long as it does not have any instance variables set on it and is not a <a href="string.html"><code>String</code></a> subclass.</p> <p>Note that <code>-string</code> variant is more convenient for defining constants:</p> <pre class="ruby" data-language="ruby">FILENAME = -'config/database.yml'
</pre> <p>while <code>dedup</code> is better suitable for using the method in chains of calculations:</p> <pre class="ruby" data-language="ruby">@url_list.concat(urls.map(&amp;:dedup))
</pre>  </div> <div class="aliases"> Also aliased as: <a href="string.html#method-i-dedup">dedup</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-3C-3C"> <span class="method-callseq"> string &lt;&lt; object → string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="3C-3C-source"> <pre class="c" data-language="c">VALUE
rb_str_concat(VALUE str1, VALUE str2)
{
    unsigned int code;
    rb_encoding *enc = STR_ENC_GET(str1);
    int encidx;

    if (RB_INTEGER_TYPE_P(str2)) {
        if (rb_num_to_uint(str2, &amp;code) == 0) {
        }
        else if (FIXNUM_P(str2)) {
            rb_raise(rb_eRangeError, "%ld out of char range", FIX2LONG(str2));
        }
        else {
            rb_raise(rb_eRangeError, "bignum out of char range");
        }
    }
    else {
        return rb_str_append(str1, str2);
    }

    encidx = rb_ascii8bit_appendable_encoding_index(enc, code);
    if (encidx &gt;= 0) {
        char buf[1];
        buf[0] = (char)code;
        rb_str_cat(str1, buf, 1);
        if (encidx != rb_enc_to_index(enc)) {
            rb_enc_associate_index(str1, encidx);
            ENC_CODERANGE_SET(str1, ENC_CODERANGE_VALID);
        }
    }
    else {
        long pos = RSTRING_LEN(str1);
        int cr = ENC_CODERANGE(str1);
        int len;
        char *buf;

        switch (len = rb_enc_codelen(code, enc)) {
          case ONIGERR_INVALID_CODE_POINT_VALUE:
            rb_raise(rb_eRangeError, "invalid codepoint 0x%X in %s", code, rb_enc_name(enc));
            break;
          case ONIGERR_TOO_BIG_WIDE_CHAR_VALUE:
          case 0:
            rb_raise(rb_eRangeError, "%u out of char range", code);
            break;
        }
        buf = ALLOCA_N(char, len + 1);
        rb_enc_mbcput(code, buf, enc);
        if (rb_enc_precise_mbclen(buf, buf + len + 1, enc) != len) {
            rb_raise(rb_eRangeError, "invalid codepoint 0x%X in %s", code, rb_enc_name(enc));
        }
        rb_str_resize(str1, pos+len);
        memcpy(RSTRING_PTR(str1) + pos, buf, len);
        if (cr == ENC_CODERANGE_7BIT &amp;&amp; code &gt; 127)
            cr = ENC_CODERANGE_VALID;
        ENC_CODERANGE_SET(str1, cr);
    }
    return str1;
}</pre> </div> <p>Concatenates <code>object</code> to <code>self</code> and returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">s = 'foo'
s &lt;&lt; 'bar' # =&gt; "foobar"
s          # =&gt; "foobar"
</pre> <p>If <code>object</code> is an <a href="integer.html"><code>Integer</code></a>, the value is considered a codepoint and converted to a character before concatenation:</p> <pre class="ruby" data-language="ruby">s = 'foo'
s &lt;&lt; 33 # =&gt; "foo!"
</pre> <p>Related: <a href="string.html#method-i-concat"><code>String#concat</code></a>, which takes multiple arguments.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-3C-3D-3E"> <span class="method-callseq"> string &lt;=&gt; other_string → -1, 0, 1, or nil </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="3C-3D-3E-source"> <pre class="c" data-language="c">static VALUE
rb_str_cmp_m(VALUE str1, VALUE str2)
{
    int result;
    VALUE s = rb_check_string_type(str2);
    if (NIL_P(s)) {
        return rb_invcmp(str1, str2);
    }
    result = rb_str_cmp(str1, s);
    return INT2FIX(result);
}</pre> </div> <p>Compares <code>self</code> and <code>other_string</code>, returning:</p> <ul>
<li> <p>-1 if <code>other_string</code> is larger.</p> </li>
<li> <p>0 if the two are equal.</p> </li>
<li> <p>1 if <code>other_string</code> is smaller.</p> </li>
<li> <p><code>nil</code> if the two are incomparable.</p> </li>
</ul> <p>Examples:</p> <pre class="ruby" data-language="ruby">'foo' &lt;=&gt; 'foo' # =&gt; 0
'foo' &lt;=&gt; 'food' # =&gt; -1
'food' &lt;=&gt; 'foo' # =&gt; 1
'FOO' &lt;=&gt; 'foo' # =&gt; -1
'foo' &lt;=&gt; 'FOO' # =&gt; 1
'foo' &lt;=&gt; 1 # =&gt; nil
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-3D-3D"> <span class="method-callseq"> string == object → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="3D-3D-source"> <pre class="c" data-language="c">VALUE
rb_str_equal(VALUE str1, VALUE str2)
{
    if (str1 == str2) return Qtrue;
    if (!RB_TYPE_P(str2, T_STRING)) {
        if (!rb_respond_to(str2, idTo_str)) {
            return Qfalse;
        }
        return rb_equal(str2, str1);
    }
    return rb_str_eql_internal(str1, str2);
}</pre> </div> <p>Returns <code>true</code> if <code>object</code> has the same length and content; as <code>self</code>; <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">s = 'foo'
s == 'foo' # =&gt; true
s == 'food' # =&gt; false
s == 'FOO' # =&gt; false
</pre> <p>Returns <code>false</code> if the two strings’ encodings are not compatible:</p> <pre class="ruby" data-language="ruby">"\u{e4 f6 fc}".encode("ISO-8859-1") == ("\u{c4 d6 dc}") # =&gt; false
</pre> <p>If <code>object</code> is not an instance of String but responds to <code>to_str</code>, then the two strings are compared using <code>object.==</code>.</p>  </div> <div class="aliases"> Also aliased as: <a href="string.html#method-i-3D-3D-3D">===</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-3D-3D-3D"> <span class="method-callseq"> string === object → true or false </span> </div> </div> <div class="method-description"> <p>Returns <code>true</code> if <code>object</code> has the same length and content; as <code>self</code>; <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">s = 'foo'
s == 'foo' # =&gt; true
s == 'food' # =&gt; false
s == 'FOO' # =&gt; false
</pre> <p>Returns <code>false</code> if the two strings’ encodings are not compatible:</p> <pre class="ruby" data-language="ruby">"\u{e4 f6 fc}".encode("ISO-8859-1") == ("\u{c4 d6 dc}") # =&gt; false
</pre> <p>If <code>object</code> is not an instance of String but responds to <code>to_str</code>, then the two strings are compared using <code>object.==</code>.</p> </div> <div class="aliases"> Alias for: <a href="string.html#method-i-3D-3D">==</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-3D~"> <span class="method-callseq"> string =~ regexp → integer or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> string =~ object → integer or nil </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="3D~-source"> <pre class="c" data-language="c">static VALUE
rb_str_match(VALUE x, VALUE y)
{
    switch (OBJ_BUILTIN_TYPE(y)) {
      case T_STRING:
        rb_raise(rb_eTypeError, "type mismatch: String given");

      case T_REGEXP:
        return rb_reg_match(y, x);

      default:
        return rb_funcall(y, idEqTilde, 1, x);
    }
}</pre> </div> <p>Returns the <a href="integer.html"><code>Integer</code></a> index of the first substring that matches the given <code>regexp</code>, or <code>nil</code> if no match found:</p> <pre class="ruby" data-language="ruby">'foo' =~ /f/ # =&gt; 0
'foo' =~ /o/ # =&gt; 1
'foo' =~ /x/ # =&gt; nil
</pre> <p>Note: also updates <a href="regexp.html#class-Regexp-label-Global+Variables">Global Variables at <code>Regexp</code></a>.</p> <p>If the given <code>object</code> is not a <a href="regexp.html"><code>Regexp</code></a>, returns the value returned by <code>object =~ self</code>.</p> <p>Note that <code>string =~ regexp</code> is different from <code>regexp =~ string</code> (see <a href="regexp.html#method-i-3D~"><code>Regexp#=~</code></a>):</p> <pre class="ruby" data-language="ruby">number= nil
"no. 9" =~ /(?&lt;number&gt;\d+)/
number # =&gt; nil (not assigned)
/(?&lt;number&gt;\d+)/ =~ "no. 9"
number #=&gt; "9"
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-5B-5D"> <span class="method-callseq"> string[index] → new_string or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> string[start, length] → new_string or nil </span> </div> <div class="method-heading"> <span class="method-callseq"> string[range] → new_string or nil </span> </div> <div class="method-heading"> <span class="method-callseq"> string[regexp, capture = 0] → new_string or nil </span> </div> <div class="method-heading"> <span class="method-callseq"> string[substring] → new_string or nil </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="5B-5D-source"> <pre class="c" data-language="c">static VALUE
rb_str_aref_m(int argc, VALUE *argv, VALUE str)
{
    if (argc == 2) {
        if (RB_TYPE_P(argv[0], T_REGEXP)) {
            return rb_str_subpat(str, argv[0], argv[1]);
        }
        else {
            long beg = NUM2LONG(argv[0]);
            long len = NUM2LONG(argv[1]);
            return rb_str_substr(str, beg, len);
        }
    }
    rb_check_arity(argc, 1, 2);
    return rb_str_aref(str, argv[0]);
}</pre> </div> <p>Returns the substring of <code>self</code> specified by the arguments. See examples at <a href="string.html#class-String-label-String+Slices">String Slices</a>.</p>  </div> <div class="aliases"> Also aliased as: <a href="string.html#method-i-slice">slice</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-5B-5D-3D"> <span class="method-callseq"> string[index] = new_string </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> string[start, length] = new_string </span> </div> <div class="method-heading"> <span class="method-callseq"> string[range] = new_string </span> </div> <div class="method-heading"> <span class="method-callseq"> string[regexp, capture = 0] = new_string </span> </div> <div class="method-heading"> <span class="method-callseq"> string[substring] = new_string </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="5B-5D-3D-source"> <pre class="c" data-language="c">static VALUE
rb_str_aset_m(int argc, VALUE *argv, VALUE str)
{
    if (argc == 3) {
        if (RB_TYPE_P(argv[0], T_REGEXP)) {
            rb_str_subpat_set(str, argv[0], argv[1], argv[2]);
        }
        else {
            rb_str_update(str, NUM2LONG(argv[0]), NUM2LONG(argv[1]), argv[2]);
        }
        return argv[2];
    }
    rb_check_arity(argc, 2, 3);
    return rb_str_aset(str, argv[0], argv[1]);
}</pre> </div> <p>Replaces all, some, or none of the contents of <code>self</code>; returns <code>new_string</code>. See <a href="string.html#class-String-label-String+Slices">String Slices</a>.</p> <p>A few examples:</p> <pre class="ruby" data-language="ruby">s = 'foo'
s[2] = 'rtune'     # =&gt; "rtune"
s                  # =&gt; "fortune"
s[1, 5] = 'init'   # =&gt; "init"
s                  # =&gt; "finite"
s[3..4] = 'al'     # =&gt; "al"
s                  # =&gt; "finale"
s[/e$/] = 'ly'     # =&gt; "ly"
s                  # =&gt; "finally"
s['lly'] = 'ncial' # =&gt; "ncial"
s                  # =&gt; "financial"
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-ascii_only-3F"> <span class="method-callseq"> ascii_only? → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="ascii_only-3F-source"> <pre class="c" data-language="c">static VALUE
rb_str_is_ascii_only_p(VALUE str)
{
    int cr = rb_enc_str_coderange(str);

    return RBOOL(cr == ENC_CODERANGE_7BIT);
}</pre> </div> <p>Returns <code>true</code> if <code>self</code> contains only ASCII characters, <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">'abc'.ascii_only?         # =&gt; true
"abc\u{6666}".ascii_only? # =&gt; false
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-b"> <span class="method-callseq"> b → string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="b-source"> <pre class="c" data-language="c">static VALUE
rb_str_b(VALUE str)
{
    VALUE str2;
    if (STR_EMBED_P(str)) {
        str2 = str_alloc_embed(rb_cString, RSTRING_LEN(str) + TERM_LEN(str));
    }
    else {
        str2 = str_alloc_heap(rb_cString);
    }
    str_replace_shared_without_enc(str2, str);

    if (rb_enc_asciicompat(STR_ENC_GET(str))) {
        // BINARY strings can never be broken; they're either 7-bit ASCII or VALID.
        // If we know the receiver's code range then we know the result's code range.
        int cr = ENC_CODERANGE(str);
        switch (cr) {
          case ENC_CODERANGE_7BIT:
            ENC_CODERANGE_SET(str2, ENC_CODERANGE_7BIT);
            break;
          case ENC_CODERANGE_BROKEN:
          case ENC_CODERANGE_VALID:
            ENC_CODERANGE_SET(str2, ENC_CODERANGE_VALID);
            break;
          default:
            ENC_CODERANGE_CLEAR(str2);
            break;
        }
    }

    return str2;
}</pre> </div> <p>Returns a copy of <code>self</code> that has ASCII-8BIT encoding; the underlying bytes are not modified:</p> <pre class="ruby" data-language="ruby">s = "\x99"
s.encoding   # =&gt; #&lt;Encoding:UTF-8&gt;
t = s.b      # =&gt; "\x99"
t.encoding   # =&gt; #&lt;Encoding:ASCII-8BIT&gt;

s = "\u4095" # =&gt; "䂕"
s.encoding   # =&gt; #&lt;Encoding:UTF-8&gt;
s.bytes      # =&gt; [228, 130, 149]
t = s.b      # =&gt; "\xE4\x82\x95"
t.encoding   # =&gt; #&lt;Encoding:ASCII-8BIT&gt;
t.bytes      # =&gt; [228, 130, 149]
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-byteindex"> <span class="method-callseq"> byteindex(substring, offset = 0) → integer or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> byteindex(regexp, offset = 0) → integer or nil </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="byteindex-source"> <pre class="c" data-language="c">static VALUE
rb_str_byteindex_m(int argc, VALUE *argv, VALUE str)
{
    VALUE sub;
    VALUE initpos;
    long pos;

    if (rb_scan_args(argc, argv, "11", &amp;sub, &amp;initpos) == 2) {
        long slen = RSTRING_LEN(str);
        pos = NUM2LONG(initpos);
        if (pos &lt; 0 ? (pos += slen) &lt; 0 : pos &gt; slen) {
            if (RB_TYPE_P(sub, T_REGEXP)) {
                rb_backref_set(Qnil);
            }
            return Qnil;
        }
    }
    else {
        pos = 0;
    }

    str_ensure_byte_pos(str, pos);

    if (RB_TYPE_P(sub, T_REGEXP)) {
        if (rb_reg_search(sub, str, pos, 0) &gt;= 0) {
            VALUE match = rb_backref_get();
            struct re_registers *regs = RMATCH_REGS(match);
            pos = BEG(0);
            return LONG2NUM(pos);
        }
    }
    else {
        StringValue(sub);
        pos = rb_str_byteindex(str, sub, pos);
        if (pos &gt;= 0) return LONG2NUM(pos);
    }
    return Qnil;
}</pre> </div> <p>Returns the <a href="integer.html"><code>Integer</code></a> byte-based index of the first occurrence of the given <code>substring</code>, or <code>nil</code> if none found:</p> <pre class="ruby" data-language="ruby">'foo'.byteindex('f') # =&gt; 0
'foo'.byteindex('o') # =&gt; 1
'foo'.byteindex('oo') # =&gt; 1
'foo'.byteindex('ooo') # =&gt; nil
</pre> <p>Returns the <a href="integer.html"><code>Integer</code></a> byte-based index of the first match for the given <a href="regexp.html"><code>Regexp</code></a> <code>regexp</code>, or <code>nil</code> if none found:</p> <pre class="ruby" data-language="ruby">'foo'.byteindex(/f/) # =&gt; 0
'foo'.byteindex(/o/) # =&gt; 1
'foo'.byteindex(/oo/) # =&gt; 1
'foo'.byteindex(/ooo/) # =&gt; nil
</pre> <p><a href="integer.html"><code>Integer</code></a> argument <code>offset</code>, if given, specifies the byte-based position in the string to begin the search:</p> <pre class="ruby" data-language="ruby">'foo'.byteindex('o', 1) # =&gt; 1
'foo'.byteindex('o', 2) # =&gt; 2
'foo'.byteindex('o', 3) # =&gt; nil
</pre> <p>If <code>offset</code> is negative, counts backward from the end of <code>self</code>:</p> <pre class="ruby" data-language="ruby">'foo'.byteindex('o', -1) # =&gt; 2
'foo'.byteindex('o', -2) # =&gt; 1
'foo'.byteindex('o', -3) # =&gt; 1
'foo'.byteindex('o', -4) # =&gt; nil
</pre> <p>If <code>offset</code> does not land on character (codepoint) boundary, <code>IndexError</code> is raised.</p> <p>Related: <a href="string.html#method-i-index"><code>String#index</code></a>, <a href="string.html#method-i-byterindex"><code>String#byterindex</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-byterindex"> <span class="method-callseq"> byterindex(substring, offset = self.bytesize) → integer or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> byterindex(regexp, offset = self.bytesize) → integer or nil </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="byterindex-source"> <pre class="c" data-language="c">static VALUE
rb_str_byterindex_m(int argc, VALUE *argv, VALUE str)
{
    VALUE sub;
    VALUE initpos;
    long pos, len = RSTRING_LEN(str);

    if (rb_scan_args(argc, argv, "11", &amp;sub, &amp;initpos) == 2) {
        pos = NUM2LONG(initpos);
        if (pos &lt; 0 &amp;&amp; (pos += len) &lt; 0) {
            if (RB_TYPE_P(sub, T_REGEXP)) {
                rb_backref_set(Qnil);
            }
            return Qnil;
        }
        if (pos &gt; len) pos = len;
    }
    else {
        pos = len;
    }

    str_ensure_byte_pos(str, pos);

    if (RB_TYPE_P(sub, T_REGEXP)) {
        if (rb_reg_search(sub, str, pos, 1) &gt;= 0) {
            VALUE match = rb_backref_get();
            struct re_registers *regs = RMATCH_REGS(match);
            pos = BEG(0);
            return LONG2NUM(pos);
        }
    }
    else {
        StringValue(sub);
        pos = rb_str_byterindex(str, sub, pos);
        if (pos &gt;= 0) return LONG2NUM(pos);
    }
    return Qnil;
}</pre> </div> <p>Returns the <a href="integer.html"><code>Integer</code></a> byte-based index of the <em>last</em> occurrence of the given <code>substring</code>, or <code>nil</code> if none found:</p> <pre class="ruby" data-language="ruby">'foo'.byterindex('f') # =&gt; 0
'foo'.byterindex('o') # =&gt; 2
'foo'.byterindex('oo') # =&gt; 1
'foo'.byterindex('ooo') # =&gt; nil
</pre> <p>Returns the <a href="integer.html"><code>Integer</code></a> byte-based index of the <em>last</em> match for the given <a href="regexp.html"><code>Regexp</code></a> <code>regexp</code>, or <code>nil</code> if none found:</p> <pre class="ruby" data-language="ruby">'foo'.byterindex(/f/) # =&gt; 0
'foo'.byterindex(/o/) # =&gt; 2
'foo'.byterindex(/oo/) # =&gt; 1
'foo'.byterindex(/ooo/) # =&gt; nil
</pre> <p>The <em>last</em> match means starting at the possible last position, not the last of longest matches.</p> <pre class="ruby" data-language="ruby">'foo'.byterindex(/o+/) # =&gt; 2
$~ #=&gt; #&lt;MatchData "o"&gt;
</pre> <p>To get the last longest match, needs to combine with negative lookbehind.</p> <pre class="ruby" data-language="ruby">'foo'.byterindex(/(?&lt;!o)o+/) # =&gt; 1
$~ #=&gt; #&lt;MatchData "oo"&gt;
</pre> <p>Or <a href="string.html#method-i-byteindex"><code>String#byteindex</code></a> with negative lookforward.</p> <pre class="ruby" data-language="ruby">'foo'.byteindex(/o+(?!.*o)/) # =&gt; 1
$~ #=&gt; #&lt;MatchData "oo"&gt;
</pre> <p><a href="integer.html"><code>Integer</code></a> argument <code>offset</code>, if given and non-negative, specifies the maximum starting byte-based position in the</p> <pre class="ruby" data-language="ruby">string to _end_ the search:

 'foo'.byterindex('o', 0) # =&gt; nil
 'foo'.byterindex('o', 1) # =&gt; 1
 'foo'.byterindex('o', 2) # =&gt; 2
 'foo'.byterindex('o', 3) # =&gt; 2
</pre> <p>If <code>offset</code> is a negative <a href="integer.html"><code>Integer</code></a>, the maximum starting position in the string to <em>end</em> the search is the sum of the string’s length and <code>offset</code>:</p> <pre class="ruby" data-language="ruby">'foo'.byterindex('o', -1) # =&gt; 2
'foo'.byterindex('o', -2) # =&gt; 1
'foo'.byterindex('o', -3) # =&gt; nil
'foo'.byterindex('o', -4) # =&gt; nil
</pre> <p>If <code>offset</code> does not land on character (codepoint) boundary, <code>IndexError</code> is raised.</p> <p>Related: <a href="string.html#method-i-byteindex"><code>String#byteindex</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-bytes"> <span class="method-callseq"> bytes → array_of_bytes </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="bytes-source"> <pre class="c" data-language="c">static VALUE
rb_str_bytes(VALUE str)
{
    VALUE ary = WANTARRAY("bytes", RSTRING_LEN(str));
    return rb_str_enumerate_bytes(str, ary);
}</pre> </div> <p>Returns an array of the bytes in <code>self</code>:</p> <pre class="ruby" data-language="ruby">'hello'.bytes # =&gt; [104, 101, 108, 108, 111]
'тест'.bytes  # =&gt; [209, 130, 208, 181, 209, 129, 209, 130]
'こんにちは'.bytes
# =&gt; [227, 129, 147, 227, 130, 147, 227, 129, 171, 227, 129, 161, 227, 129, 175]
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-bytesize"> <span class="method-callseq"> bytesize → integer </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="bytesize-source"> <pre class="c" data-language="c">VALUE
rb_str_bytesize(VALUE str)
{
    return LONG2NUM(RSTRING_LEN(str));
}</pre> </div> <p>Returns the count of bytes (not characters) in <code>self</code>:</p> <pre class="ruby" data-language="ruby">'foo'.bytesize        # =&gt; 3
'тест'.bytesize       # =&gt; 8
'こんにちは'.bytesize   # =&gt; 15
</pre> <p>Contrast with <a href="string.html#method-i-length"><code>String#length</code></a>:</p> <pre class="ruby" data-language="ruby">'foo'.length       # =&gt; 3
'тест'.length      # =&gt; 4
'こんにちは'.length  # =&gt; 5
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-byteslice"> <span class="method-callseq"> byteslice(index, length = 1) → string or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> byteslice(range) → string or nil </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="byteslice-source"> <pre class="c" data-language="c">static VALUE
rb_str_byteslice(int argc, VALUE *argv, VALUE str)
{
    if (argc == 2) {
        long beg = NUM2LONG(argv[0]);
        long len = NUM2LONG(argv[1]);
        return str_byte_substr(str, beg, len, TRUE);
    }
    rb_check_arity(argc, 1, 2);
    return str_byte_aref(str, argv[0]);
}</pre> </div> <p>Returns a substring of <code>self</code>, or <code>nil</code> if the substring cannot be constructed.</p> <p>With integer arguments <code>index</code> and <code>length</code> given, returns the substring beginning at the given <code>index</code> of the given <code>length</code> (if possible), or <code>nil</code> if <code>length</code> is negative or <code>index</code> falls outside of <code>self</code>:</p> <pre class="ruby" data-language="ruby">s = '0123456789' # =&gt; "0123456789"
s.byteslice(2)   # =&gt; "2"
s.byteslice(200) # =&gt; nil
s.byteslice(4, 3)  # =&gt; "456"
s.byteslice(4, 30) # =&gt; "456789"
s.byteslice(4, -1) # =&gt; nil
s.byteslice(40, 2) # =&gt; nil
</pre> <p>In either case above, counts backwards from the end of <code>self</code> if <code>index</code> is negative:</p> <pre class="ruby" data-language="ruby">s = '0123456789'   # =&gt; "0123456789"
s.byteslice(-4)    # =&gt; "6"
s.byteslice(-4, 3) # =&gt; "678"
</pre> <p>With <a href="range.html"><code>Range</code></a> argument <code>range</code> given, returns <code>byteslice(range.begin, range.size)</code>:</p> <pre class="ruby" data-language="ruby">s = '0123456789'    # =&gt; "0123456789"
s.byteslice(4..6)   # =&gt; "456"
s.byteslice(-6..-4) # =&gt; "456"
s.byteslice(5..2)   # =&gt; "" # range.size is zero.
s.byteslice(40..42) # =&gt; nil
</pre> <p>In all cases, a returned string has the same encoding as <code>self</code>:</p> <pre class="ruby" data-language="ruby">s.encoding              # =&gt; #&lt;Encoding:UTF-8&gt;
s.byteslice(4).encoding # =&gt; #&lt;Encoding:UTF-8&gt;
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-bytesplice"> <span class="method-callseq"> bytesplice(index, length, str) → string </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> bytesplice(index, length, str, str_index, str_length) → string </span> </div> <div class="method-heading"> <span class="method-callseq"> bytesplice(range, str) → string </span> </div> <div class="method-heading"> <span class="method-callseq"> bytesplice(range, str, str_range) → string </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="bytesplice-source"> <pre class="c" data-language="c">static VALUE
rb_str_bytesplice(int argc, VALUE *argv, VALUE str)
{
    long beg, len, vbeg, vlen;
    VALUE val;
    rb_encoding *enc;
    int cr;

    rb_check_arity(argc, 2, 5);
    if (!(argc == 2 || argc == 3 || argc == 5)) {
        rb_raise(rb_eArgError, "wrong number of arguments (given %d, expected 2, 3, or 5)", argc);
    }
    if (argc == 2 || (argc == 3 &amp;&amp; !RB_INTEGER_TYPE_P(argv[0]))) {
        if (!rb_range_beg_len(argv[0], &amp;beg, &amp;len, RSTRING_LEN(str), 2)) {
            rb_raise(rb_eTypeError, "wrong argument type %s (expected Range)",
                     rb_builtin_class_name(argv[0]));
        }
        val = argv[1];
        StringValue(val);
        if (argc == 2) {
            /* bytesplice(range, str) */
            vbeg = 0;
            vlen = RSTRING_LEN(val);
        }
        else {
            /* bytesplice(range, str, str_range) */
            if (!rb_range_beg_len(argv[2], &amp;vbeg, &amp;vlen, RSTRING_LEN(val), 2)) {
                rb_raise(rb_eTypeError, "wrong argument type %s (expected Range)",
                         rb_builtin_class_name(argv[2]));
            }
        }
    }
    else {
        beg = NUM2LONG(argv[0]);
        len = NUM2LONG(argv[1]);
        val = argv[2];
        StringValue(val);
        if (argc == 3) {
            /* bytesplice(index, length, str) */
            vbeg = 0;
            vlen = RSTRING_LEN(val);
        }
        else {
            /* bytesplice(index, length, str, str_index, str_length) */
            vbeg = NUM2LONG(argv[3]);
            vlen = NUM2LONG(argv[4]);
        }
    }
    str_check_beg_len(str, &amp;beg, &amp;len);
    str_check_beg_len(val, &amp;vbeg, &amp;vlen);
    enc = rb_enc_check(str, val);
    str_modify_keep_cr(str);
    rb_str_update_1(str, beg, len, val, vbeg, vlen);
    rb_enc_associate(str, enc);
    cr = ENC_CODERANGE_AND(ENC_CODERANGE(str), ENC_CODERANGE(val));
    if (cr != ENC_CODERANGE_BROKEN)
        ENC_CODERANGE_SET(str, cr);
    return str;
}</pre> </div> <p>Replaces some or all of the content of <code>self</code> with <code>str</code>, and returns <code>self</code>. The portion of the string affected is determined using the same criteria as <a href="string.html#method-i-byteslice"><code>String#byteslice</code></a>, except that <code>length</code> cannot be omitted. If the replacement string is not the same length as the text it is replacing, the string will be adjusted accordingly.</p> <p>If <code>str_index</code> and <code>str_length</code>, or <code>str_range</code> are given, the content of <code>self</code> is replaced by str.byteslice(str_index, str_length) or str.byteslice(str_range); however the substring of <code>str</code> is not allocated as a new string.</p> <p>The form that take an <a href="integer.html"><code>Integer</code></a> will raise an <a href="indexerror.html"><code>IndexError</code></a> if the value is out of range; the <a href="range.html"><code>Range</code></a> form will raise a <a href="rangeerror.html"><code>RangeError</code></a>. If the beginning or ending offset does not land on character (codepoint) boundary, an <a href="indexerror.html"><code>IndexError</code></a> will be raised.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-capitalize"> <span class="method-callseq"> capitalize(*options) → string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="capitalize-source"> <pre class="c" data-language="c">static VALUE
rb_str_capitalize(int argc, VALUE *argv, VALUE str)
{
    rb_encoding *enc;
    OnigCaseFoldType flags = ONIGENC_CASE_UPCASE | ONIGENC_CASE_TITLECASE;
    VALUE ret;

    flags = check_case_options(argc, argv, flags);
    enc = str_true_enc(str);
    if (RSTRING_LEN(str) == 0 || !RSTRING_PTR(str)) return str;
    if (flags&amp;ONIGENC_CASE_ASCII_ONLY) {
        ret = rb_str_new(0, RSTRING_LEN(str));
        rb_str_ascii_casemap(str, ret, &amp;flags, enc);
    }
    else {
        ret = rb_str_casemap(str, &amp;flags, enc);
    }
    return ret;
}</pre> </div> <p>Returns a string containing the characters in <code>self</code>; the first character is upcased; the remaining characters are downcased:</p> <pre class="ruby" data-language="ruby">s = 'hello World!' # =&gt; "hello World!"
s.capitalize       # =&gt; "Hello world!"
</pre> <p>The casing may be affected by the given <code>options</code>; see <a href="case_mapping_rdoc.html">Case Mapping</a>.</p> <p>Related: <a href="string.html#method-i-capitalize-21"><code>String#capitalize!</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-capitalize-21"> <span class="method-callseq"> capitalize!(*options) → self or nil </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="capitalize-21-source"> <pre class="c" data-language="c">static VALUE
rb_str_capitalize_bang(int argc, VALUE *argv, VALUE str)
{
    rb_encoding *enc;
    OnigCaseFoldType flags = ONIGENC_CASE_UPCASE | ONIGENC_CASE_TITLECASE;

    flags = check_case_options(argc, argv, flags);
    str_modify_keep_cr(str);
    enc = str_true_enc(str);
    if (RSTRING_LEN(str) == 0 || !RSTRING_PTR(str)) return Qnil;
    if (flags&amp;ONIGENC_CASE_ASCII_ONLY)
        rb_str_ascii_casemap(str, str, &amp;flags, enc);
    else
        str_shared_replace(str, rb_str_casemap(str, &amp;flags, enc));

    if (ONIGENC_CASE_MODIFIED&amp;flags) return str;
    return Qnil;
}</pre> </div> <p>Upcases the first character in <code>self</code>; downcases the remaining characters; returns <code>self</code> if any changes were made, <code>nil</code> otherwise:</p> <pre class="ruby" data-language="ruby">s = 'hello World!' # =&gt; "hello World!"
s.capitalize!      # =&gt; "Hello world!"
s                  # =&gt; "Hello world!"
s.capitalize!      # =&gt; nil
</pre> <p>The casing may be affected by the given <code>options</code>; see <a href="case_mapping_rdoc.html">Case Mapping</a>.</p> <p>Related: <a href="string.html#method-i-capitalize"><code>String#capitalize</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-casecmp"> <span class="method-callseq"> casecmp(other_string) → -1, 0, 1, or nil </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="casecmp-source"> <pre class="c" data-language="c">static VALUE
rb_str_casecmp(VALUE str1, VALUE str2)
{
    VALUE s = rb_check_string_type(str2);
    if (NIL_P(s)) {
        return Qnil;
    }
    return str_casecmp(str1, s);
}</pre> </div> <p>Compares <code>self.downcase</code> and <code>other_string.downcase</code>; returns:</p> <ul>
<li> <p>-1 if <code>other_string.downcase</code> is larger.</p> </li>
<li> <p>0 if the two are equal.</p> </li>
<li> <p>1 if <code>other_string.downcase</code> is smaller.</p> </li>
<li> <p><code>nil</code> if the two are incomparable.</p> </li>
</ul> <p>Examples:</p> <pre class="ruby" data-language="ruby">'foo'.casecmp('foo') # =&gt; 0
'foo'.casecmp('food') # =&gt; -1
'food'.casecmp('foo') # =&gt; 1
'FOO'.casecmp('foo') # =&gt; 0
'foo'.casecmp('FOO') # =&gt; 0
'foo'.casecmp(1) # =&gt; nil
</pre> <p>See <a href="case_mapping_rdoc.html">Case Mapping</a>.</p> <p>Related: <a href="string.html#method-i-casecmp-3F"><code>String#casecmp?</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-casecmp-3F"> <span class="method-callseq"> casecmp?(other_string) → true, false, or nil </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="casecmp-3F-source"> <pre class="c" data-language="c">static VALUE
rb_str_casecmp_p(VALUE str1, VALUE str2)
{
    VALUE s = rb_check_string_type(str2);
    if (NIL_P(s)) {
        return Qnil;
    }
    return str_casecmp_p(str1, s);
}</pre> </div> <p>Returns <code>true</code> if <code>self</code> and <code>other_string</code> are equal after Unicode case folding, otherwise <code>false</code>:</p> <pre class="ruby" data-language="ruby">'foo'.casecmp?('foo') # =&gt; true
'foo'.casecmp?('food') # =&gt; false
'food'.casecmp?('foo') # =&gt; false
'FOO'.casecmp?('foo') # =&gt; true
'foo'.casecmp?('FOO') # =&gt; true
</pre> <p>Returns <code>nil</code> if the two values are incomparable:</p> <pre class="ruby" data-language="ruby">'foo'.casecmp?(1) # =&gt; nil
</pre> <p>See <a href="case_mapping_rdoc.html">Case Mapping</a>.</p> <p>Related: <a href="string.html#method-i-casecmp"><code>String#casecmp</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-center"> <span class="method-callseq"> center(size, pad_string = ' ') → new_string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="center-source"> <pre class="c" data-language="c">static VALUE
rb_str_center(int argc, VALUE *argv, VALUE str)
{
    return rb_str_justify(argc, argv, str, 'c');
}</pre> </div> <p>Returns a centered copy of <code>self</code>.</p> <p>If integer argument <code>size</code> is greater than the size (in characters) of <code>self</code>, returns a new string of length <code>size</code> that is a copy of <code>self</code>, centered and padded on both ends with <code>pad_string</code>:</p> <pre class="ruby" data-language="ruby">'hello'.center(10)       # =&gt; "  hello   "
'  hello'.center(10)     # =&gt; "   hello  "
'hello'.center(10, 'ab') # =&gt; "abhelloaba"
'тест'.center(10)        # =&gt; "   тест   "
'こんにちは'.center(10)    # =&gt; "  こんにちは   "
</pre> <p>If <code>size</code> is not greater than the size of <code>self</code>, returns a copy of <code>self</code>:</p> <pre class="ruby" data-language="ruby">'hello'.center(5)  # =&gt; "hello"
'hello'.center(1)  # =&gt; "hello"
</pre> <p>Related: <a href="string.html#method-i-ljust"><code>String#ljust</code></a>, <a href="string.html#method-i-rjust"><code>String#rjust</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-chars"> <span class="method-callseq"> chars → array_of_characters </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="chars-source"> <pre class="c" data-language="c">static VALUE
rb_str_chars(VALUE str)
{
    VALUE ary = WANTARRAY("chars", rb_str_strlen(str));
    return rb_str_enumerate_chars(str, ary);
}</pre> </div> <p>Returns an array of the characters in <code>self</code>:</p> <pre class="ruby" data-language="ruby">'hello'.chars     # =&gt; ["h", "e", "l", "l", "o"]
'тест'.chars      # =&gt; ["т", "е", "с", "т"]
'こんにちは'.chars # =&gt; ["こ", "ん", "に", "ち", "は"]
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-chomp"> <span class="method-callseq"> chomp(line_sep = $/) → new_string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="chomp-source"> <pre class="c" data-language="c">static VALUE
rb_str_chomp(int argc, VALUE *argv, VALUE str)
{
    VALUE rs = chomp_rs(argc, argv);
    if (NIL_P(rs)) return str_duplicate(rb_cString, str);
    return rb_str_subseq(str, 0, chompped_length(str, rs));
}</pre> </div> <p>Returns a new string copied from <code>self</code>, with trailing characters possibly removed:</p> <p>When <code>line_sep</code> is <code>"\n"</code>, removes the last one or two characters if they are <code>"\r"</code>, <code>"\n"</code>, or <code>"\r\n"</code> (but not <code>"\n\r"</code>):</p> <pre class="ruby" data-language="ruby">$/                    # =&gt; "\n"
"abc\r".chomp         # =&gt; "abc"
"abc\n".chomp         # =&gt; "abc"
"abc\r\n".chomp       # =&gt; "abc"
"abc\n\r".chomp       # =&gt; "abc\n"
"тест\r\n".chomp      # =&gt; "тест"
"こんにちは\r\n".chomp  # =&gt; "こんにちは"
</pre> <p>When <code>line_sep</code> is <code>''</code> (an empty string), removes multiple trailing occurrences of <code>"\n"</code> or <code>"\r\n"</code> (but not <code>"\r"</code> or <code>"\n\r"</code>):</p> <pre class="ruby" data-language="ruby">"abc\n\n\n".chomp('')           # =&gt; "abc"
"abc\r\n\r\n\r\n".chomp('')     # =&gt; "abc"
"abc\n\n\r\n\r\n\n\n".chomp('') # =&gt; "abc"
"abc\n\r\n\r\n\r".chomp('')     # =&gt; "abc\n\r\n\r\n\r"
"abc\r\r\r".chomp('')           # =&gt; "abc\r\r\r"
</pre> <p>When <code>line_sep</code> is neither <code>"\n"</code> nor <code>''</code>, removes a single trailing line separator if there is one:</p> <pre class="ruby" data-language="ruby">'abcd'.chomp('d')  # =&gt; "abc"
'abcdd'.chomp('d') # =&gt; "abcd"
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-chomp-21"> <span class="method-callseq"> chomp!(line_sep = $/) → self or nil </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="chomp-21-source"> <pre class="c" data-language="c">static VALUE
rb_str_chomp_bang(int argc, VALUE *argv, VALUE str)
{
    VALUE rs;
    str_modifiable(str);
    if (RSTRING_LEN(str) == 0 &amp;&amp; argc &lt; 2) return Qnil;
    rs = chomp_rs(argc, argv);
    if (NIL_P(rs)) return Qnil;
    return rb_str_chomp_string(str, rs);
}</pre> </div> <p>Like <a href="string.html#method-i-chomp"><code>String#chomp</code></a>, but modifies <code>self</code> in place; returns <code>nil</code> if no modification made, <code>self</code> otherwise.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-chop"> <span class="method-callseq"> chop → new_string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="chop-source"> <pre class="c" data-language="c">static VALUE
rb_str_chop(VALUE str)
{
    return rb_str_subseq(str, 0, chopped_length(str));
}</pre> </div> <p>Returns a new string copied from <code>self</code>, with trailing characters possibly removed.</p> <p>Removes <code>"\r\n"</code> if those are the last two characters.</p> <pre class="ruby" data-language="ruby">"abc\r\n".chop      # =&gt; "abc"
"тест\r\n".chop     # =&gt; "тест"
"こんにちは\r\n".chop # =&gt; "こんにちは"
</pre> <p>Otherwise removes the last character if it exists.</p> <pre class="ruby" data-language="ruby">'abcd'.chop     # =&gt; "abc"
'тест'.chop     # =&gt; "тес"
'こんにちは'.chop # =&gt; "こんにち"
''.chop         # =&gt; ""
</pre> <p>If you only need to remove the newline separator at the end of the string, <a href="string.html#method-i-chomp"><code>String#chomp</code></a> is a better alternative.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-chop-21"> <span class="method-callseq"> chop! → self or nil </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="chop-21-source"> <pre class="c" data-language="c">static VALUE
rb_str_chop_bang(VALUE str)
{
    str_modify_keep_cr(str);
    if (RSTRING_LEN(str) &gt; 0) {
        long len;
        len = chopped_length(str);
        STR_SET_LEN(str, len);
        TERM_FILL(&amp;RSTRING_PTR(str)[len], TERM_LEN(str));
        if (ENC_CODERANGE(str) != ENC_CODERANGE_7BIT) {
            ENC_CODERANGE_CLEAR(str);
        }
        return str;
    }
    return Qnil;
}</pre> </div> <p>Like <a href="string.html#method-i-chop"><code>String#chop</code></a>, but modifies <code>self</code> in place; returns <code>nil</code> if <code>self</code> is empty, <code>self</code> otherwise.</p> <p>Related: <a href="string.html#method-i-chomp-21"><code>String#chomp!</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-chr"> <span class="method-callseq"> chr → string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="chr-source"> <pre class="c" data-language="c">static VALUE
rb_str_chr(VALUE str)
{
    return rb_str_substr(str, 0, 1);
}</pre> </div> <p>Returns a string containing the first character of <code>self</code>:</p> <pre class="ruby" data-language="ruby">s = 'foo' # =&gt; "foo"
s.chr     # =&gt; "f"
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-clear"> <span class="method-callseq"> clear → self </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="clear-source"> <pre class="c" data-language="c">static VALUE
rb_str_clear(VALUE str)
{
    str_discard(str);
    STR_SET_EMBED(str);
    STR_SET_LEN(str, 0);
    RSTRING_PTR(str)[0] = 0;
    if (rb_enc_asciicompat(STR_ENC_GET(str)))
        ENC_CODERANGE_SET(str, ENC_CODERANGE_7BIT);
    else
        ENC_CODERANGE_SET(str, ENC_CODERANGE_VALID);
    return str;
}</pre> </div> <p>Removes the contents of <code>self</code>:</p> <pre class="ruby" data-language="ruby">s = 'foo' # =&gt; "foo"
s.clear   # =&gt; ""
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-codepoints"> <span class="method-callseq"> codepoints → array_of_integers </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="codepoints-source"> <pre class="c" data-language="c">static VALUE
rb_str_codepoints(VALUE str)
{
    VALUE ary = WANTARRAY("codepoints", rb_str_strlen(str));
    return rb_str_enumerate_codepoints(str, ary);
}</pre> </div> <p>Returns an array of the codepoints in <code>self</code>; each codepoint is the integer value for a character:</p> <pre class="ruby" data-language="ruby">'hello'.codepoints     # =&gt; [104, 101, 108, 108, 111]
'тест'.codepoints      # =&gt; [1090, 1077, 1089, 1090]
'こんにちは'.codepoints # =&gt; [12371, 12435, 12395, 12385, 12399]
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-concat"> <span class="method-callseq"> concat(*objects) → string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="concat-source"> <pre class="c" data-language="c">static VALUE
rb_str_concat_multi(int argc, VALUE *argv, VALUE str)
{
    str_modifiable(str);

    if (argc == 1) {
        return rb_str_concat(str, argv[0]);
    }
    else if (argc &gt; 1) {
        int i;
        VALUE arg_str = rb_str_tmp_new(0);
        rb_enc_copy(arg_str, str);
        for (i = 0; i &lt; argc; i++) {
            rb_str_concat(arg_str, argv[i]);
        }
        rb_str_buf_append(str, arg_str);
    }

    return str;
}</pre> </div> <p>Concatenates each object in <code>objects</code> to <code>self</code> and returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">s = 'foo'
s.concat('bar', 'baz') # =&gt; "foobarbaz"
s                      # =&gt; "foobarbaz"
</pre> <p>For each given object <code>object</code> that is an <a href="integer.html"><code>Integer</code></a>, the value is considered a codepoint and converted to a character before concatenation:</p> <pre class="ruby" data-language="ruby">s = 'foo'
s.concat(32, 'bar', 32, 'baz') # =&gt; "foo bar baz"
</pre> <p>Related: <a href="string.html#method-i-3C-3C"><code>String#&lt;&lt;</code></a>, which takes a single argument.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-count"> <span class="method-callseq"> count(*selectors) → integer </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="count-source"> <pre class="c" data-language="c">static VALUE
rb_str_count(int argc, VALUE *argv, VALUE str)
{
    char table[TR_TABLE_SIZE];
    rb_encoding *enc = 0;
    VALUE del = 0, nodel = 0, tstr;
    char *s, *send;
    int i;
    int ascompat;
    size_t n = 0;

    rb_check_arity(argc, 1, UNLIMITED_ARGUMENTS);

    tstr = argv[0];
    StringValue(tstr);
    enc = rb_enc_check(str, tstr);
    if (argc == 1) {
        const char *ptstr;
        if (RSTRING_LEN(tstr) == 1 &amp;&amp; rb_enc_asciicompat(enc) &amp;&amp;
            (ptstr = RSTRING_PTR(tstr),
             ONIGENC_IS_ALLOWED_REVERSE_MATCH(enc, (const unsigned char *)ptstr, (const unsigned char *)ptstr+1)) &amp;&amp;
            !is_broken_string(str)) {
            int clen;
            unsigned char c = rb_enc_codepoint_len(ptstr, ptstr+1, &amp;clen, enc);

            s = RSTRING_PTR(str);
            if (!s || RSTRING_LEN(str) == 0) return INT2FIX(0);
            send = RSTRING_END(str);
            while (s &lt; send) {
                if (*(unsigned char*)s++ == c) n++;
            }
            return SIZET2NUM(n);
        }
    }

    tr_setup_table(tstr, table, TRUE, &amp;del, &amp;nodel, enc);
    for (i=1; i&lt;argc; i++) {
        tstr = argv[i];
        StringValue(tstr);
        enc = rb_enc_check(str, tstr);
        tr_setup_table(tstr, table, FALSE, &amp;del, &amp;nodel, enc);
    }

    s = RSTRING_PTR(str);
    if (!s || RSTRING_LEN(str) == 0) return INT2FIX(0);
    send = RSTRING_END(str);
    ascompat = rb_enc_asciicompat(enc);
    while (s &lt; send) {
        unsigned int c;

        if (ascompat &amp;&amp; (c = *(unsigned char*)s) &lt; 0x80) {
            if (table[c]) {
                n++;
            }
            s++;
        }
        else {
            int clen;
            c = rb_enc_codepoint_len(s, send, &amp;clen, enc);
            if (tr_find(c, table, del, nodel)) {
                n++;
            }
            s += clen;
        }
    }

    return SIZET2NUM(n);
}</pre> </div> <p>Returns the total number of characters in <code>self</code> that are specified by the given <code>selectors</code> (see <a href="character_selectors_rdoc.html#label-Multiple+Character+Selectors">Multiple Character Selectors</a>):</p> <pre class="ruby" data-language="ruby">a = "hello world"
a.count "lo"                   #=&gt; 5
a.count "lo", "o"              #=&gt; 2
a.count "hello", "^l"          #=&gt; 4
a.count "ej-m"                 #=&gt; 4

"hello^world".count "\\^aeiou" #=&gt; 4
"hello-world".count "a\\-eo"   #=&gt; 4

c = "hello world\\r\\n"
c.count "\\"                   #=&gt; 2
c.count "\\A"                  #=&gt; 0
c.count "X-\\w"                #=&gt; 3
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-crypt"> <span class="method-callseq"> crypt(salt_str) → new_string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="crypt-source"> <pre class="c" data-language="c">static VALUE
rb_str_crypt(VALUE str, VALUE salt)
{
#ifdef HAVE_CRYPT_R
    VALUE databuf;
    struct crypt_data *data;
#   define CRYPT_END() ALLOCV_END(databuf)
#else
    extern char *crypt(const char *, const char *);
#   define CRYPT_END() rb_nativethread_lock_unlock(&amp;crypt_mutex.lock)
#endif
    VALUE result;
    const char *s, *saltp;
    char *res;
#ifdef BROKEN_CRYPT
    char salt_8bit_clean[3];
#endif

    StringValue(salt);
    mustnot_wchar(str);
    mustnot_wchar(salt);
    s = StringValueCStr(str);
    saltp = RSTRING_PTR(salt);
    if (RSTRING_LEN(salt) &lt; 2 || !saltp[0] || !saltp[1]) {
        rb_raise(rb_eArgError, "salt too short (need &gt;=2 bytes)");
    }

#ifdef BROKEN_CRYPT
    if (!ISASCII((unsigned char)saltp[0]) || !ISASCII((unsigned char)saltp[1])) {
        salt_8bit_clean[0] = saltp[0] &amp; 0x7f;
        salt_8bit_clean[1] = saltp[1] &amp; 0x7f;
        salt_8bit_clean[2] = '\0';
        saltp = salt_8bit_clean;
    }
#endif
#ifdef HAVE_CRYPT_R
    data = ALLOCV(databuf, sizeof(struct crypt_data));
# ifdef HAVE_STRUCT_CRYPT_DATA_INITIALIZED
    data-&gt;initialized = 0;
# endif
    res = crypt_r(s, saltp, data);
#else
    crypt_mutex_initialize();
    rb_nativethread_lock_lock(&amp;crypt_mutex.lock);
    res = crypt(s, saltp);
#endif
    if (!res) {
        int err = errno;
        CRYPT_END();
        rb_syserr_fail(err, "crypt");
    }
    result = rb_str_new_cstr(res);
    CRYPT_END();
    return result;
}</pre> </div> <p>Returns the string generated by calling <code>crypt(3)</code> standard library function with <code>str</code> and <code>salt_str</code>, in this order, as its arguments. Please do not use this method any longer. It is legacy; provided only for backward compatibility with ruby scripts in earlier days. It is bad to use in contemporary programs for several reasons:</p> <ul>
<li> <p>Behaviour of C’s <code>crypt(3)</code> depends on the OS it is run. The generated string lacks data portability.</p> </li>
<li> <p>On some OSes such as Mac OS, <code>crypt(3)</code> never fails (i.e. silently ends up in unexpected results).</p> </li>
<li> <p>On some OSes such as Mac OS, <code>crypt(3)</code> is not thread safe.</p> </li>
<li> <p>So-called “traditional” usage of <code>crypt(3)</code> is very very very weak. According to its manpage, Linux’s traditional <code>crypt(3)</code> output has only 2**56 variations; too easy to brute force today. And this is the default behaviour.</p> </li>
<li> <p>In order to make things robust some OSes implement so-called “modular” usage. To go through, you have to do a complex build-up of the <code>salt_str</code> parameter, by hand. Failure in generation of a proper salt string tends not to yield any errors; typos in parameters are normally not detectable.</p> <ul><li> <p>For instance, in the following example, the second invocation of <a href="string.html#method-i-crypt"><code>String#crypt</code></a> is wrong; it has a typo in “round=” (lacks “s”). However the call does not fail and something unexpected is generated.</p> <pre class="ruby" data-language="ruby">"foo".crypt("$5$rounds=1000$salt$") # OK, proper usage
"foo".crypt("$5$round=1000$salt$")  # Typo not detected
</pre> </li></ul> </li>
<li> <p>Even in the “modular” mode, some hash functions are considered archaic and no longer recommended at all; for instance module <code>$1$</code> is officially abandoned by its author: see <a href="http://phk.freebsd.dk/sagas/md5crypt_eol">phk.freebsd.dk/sagas/md5crypt_eol</a>/ . For another instance module <code>$3$</code> is considered completely broken: see the manpage of FreeBSD.</p> </li>
<li> <p>On some OS such as Mac OS, there is no modular mode. Yet, as written above, <code>crypt(3)</code> on Mac OS never fails. This means even if you build up a proper salt string it generates a traditional DES hash anyways, and there is no way for you to be aware of.</p> <pre class="ruby" data-language="ruby">"foo".crypt("$5$rounds=1000$salt$") # =&gt; "$5fNPQMxC5j6."
</pre> </li>
</ul> <p>If for some reason you cannot migrate to other secure contemporary password hashing algorithms, install the string-crypt gem and <code>require 'string/crypt'</code> to continue using it.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-dedup"> <span class="method-callseq"> -string → frozen_string </span> </div> <div class="method-heading"> <span class="method-callseq"> dedup → frozen_string </span> </div> </div> <div class="method-description"> <p>Returns a frozen, possibly pre-existing copy of the string.</p> <p>The returned String will be deduplicated as long as it does not have any instance variables set on it and is not a <a href="string.html"><code>String</code></a> subclass.</p> <p>Note that <code>-string</code> variant is more convenient for defining constants:</p> <pre class="ruby" data-language="ruby">FILENAME = -'config/database.yml'
</pre> <p>while <code>dedup</code> is better suitable for using the method in chains of calculations:</p> <pre class="ruby" data-language="ruby">@url_list.concat(urls.map(&amp;:dedup))
</pre> </div> <div class="aliases"> Alias for: <a href="string.html#method-i-2D-40">-@</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-delete"> <span class="method-callseq"> delete(*selectors) → new_string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="delete-source"> <pre class="c" data-language="c">static VALUE
rb_str_delete(int argc, VALUE *argv, VALUE str)
{
    str = str_duplicate(rb_cString, str);
    rb_str_delete_bang(argc, argv, str);
    return str;
}</pre> </div> <p>Returns a copy of <code>self</code> with characters specified by <code>selectors</code> removed (see <a href="character_selectors_rdoc.html#label-Multiple+Character+Selectors">Multiple Character Selectors</a>):</p> <pre class="ruby" data-language="ruby">"hello".delete "l","lo"        #=&gt; "heo"
"hello".delete "lo"            #=&gt; "he"
"hello".delete "aeiou", "^e"   #=&gt; "hell"
"hello".delete "ej-m"          #=&gt; "ho"
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-delete-21"> <span class="method-callseq"> delete!(*selectors) → self or nil </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="delete-21-source"> <pre class="c" data-language="c">static VALUE
rb_str_delete_bang(int argc, VALUE *argv, VALUE str)
{
    char squeez[TR_TABLE_SIZE];
    rb_encoding *enc = 0;
    char *s, *send, *t;
    VALUE del = 0, nodel = 0;
    int modify = 0;
    int i, ascompat, cr;

    if (RSTRING_LEN(str) == 0 || !RSTRING_PTR(str)) return Qnil;
    rb_check_arity(argc, 1, UNLIMITED_ARGUMENTS);
    for (i=0; i&lt;argc; i++) {
        VALUE s = argv[i];

        StringValue(s);
        enc = rb_enc_check(str, s);
        tr_setup_table(s, squeez, i==0, &amp;del, &amp;nodel, enc);
    }

    str_modify_keep_cr(str);
    ascompat = rb_enc_asciicompat(enc);
    s = t = RSTRING_PTR(str);
    send = RSTRING_END(str);
    cr = ascompat ? ENC_CODERANGE_7BIT : ENC_CODERANGE_VALID;
    while (s &lt; send) {
        unsigned int c;
        int clen;

        if (ascompat &amp;&amp; (c = *(unsigned char*)s) &lt; 0x80) {
            if (squeez[c]) {
                modify = 1;
            }
            else {
                if (t != s) *t = c;
                t++;
            }
            s++;
        }
        else {
            c = rb_enc_codepoint_len(s, send, &amp;clen, enc);

            if (tr_find(c, squeez, del, nodel)) {
                modify = 1;
            }
            else {
                if (t != s) rb_enc_mbcput(c, t, enc);
                t += clen;
                if (cr == ENC_CODERANGE_7BIT) cr = ENC_CODERANGE_VALID;
            }
            s += clen;
        }
    }
    TERM_FILL(t, TERM_LEN(str));
    STR_SET_LEN(str, t - RSTRING_PTR(str));
    ENC_CODERANGE_SET(str, cr);

    if (modify) return str;
    return Qnil;
}</pre> </div> <p>Like <a href="string.html#method-i-delete"><code>String#delete</code></a>, but modifies <code>self</code> in place. Returns <code>self</code> if any changes were made, <code>nil</code> otherwise.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-delete_prefix"> <span class="method-callseq"> delete_prefix(prefix) → new_string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="delete_prefix-source"> <pre class="c" data-language="c">static VALUE
rb_str_delete_prefix(VALUE str, VALUE prefix)
{
    long prefixlen;

    prefixlen = deleted_prefix_length(str, prefix);
    if (prefixlen &lt;= 0) return str_duplicate(rb_cString, str);

    return rb_str_subseq(str, prefixlen, RSTRING_LEN(str) - prefixlen);
}</pre> </div> <p>Returns a copy of <code>self</code> with leading substring <code>prefix</code> removed:</p> <pre class="ruby" data-language="ruby">'hello'.delete_prefix('hel')      # =&gt; "lo"
'hello'.delete_prefix('llo')      # =&gt; "hello"
'тест'.delete_prefix('те')        # =&gt; "ст"
'こんにちは'.delete_prefix('こん')  # =&gt; "にちは"
</pre> <p>Related: <a href="string.html#method-i-delete_prefix-21"><code>String#delete_prefix!</code></a>, <a href="string.html#method-i-delete_suffix"><code>String#delete_suffix</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-delete_prefix-21"> <span class="method-callseq"> delete_prefix!(prefix) → self or nil </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="delete_prefix-21-source"> <pre class="c" data-language="c">static VALUE
rb_str_delete_prefix_bang(VALUE str, VALUE prefix)
{
    long prefixlen;
    str_modify_keep_cr(str);

    prefixlen = deleted_prefix_length(str, prefix);
    if (prefixlen &lt;= 0) return Qnil;

    return rb_str_drop_bytes(str, prefixlen);
}</pre> </div> <p>Like <a href="string.html#method-i-delete_prefix"><code>String#delete_prefix</code></a>, except that <code>self</code> is modified in place. Returns <code>self</code> if the prefix is removed, <code>nil</code> otherwise.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-delete_suffix"> <span class="method-callseq"> delete_suffix(suffix) → new_string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="delete_suffix-source"> <pre class="c" data-language="c">static VALUE
rb_str_delete_suffix(VALUE str, VALUE suffix)
{
    long suffixlen;

    suffixlen = deleted_suffix_length(str, suffix);
    if (suffixlen &lt;= 0) return str_duplicate(rb_cString, str);

    return rb_str_subseq(str, 0, RSTRING_LEN(str) - suffixlen);
}</pre> </div> <p>Returns a copy of <code>self</code> with trailing substring <code>suffix</code> removed:</p> <pre class="ruby" data-language="ruby">'hello'.delete_suffix('llo')      # =&gt; "he"
'hello'.delete_suffix('hel')      # =&gt; "hello"
'тест'.delete_suffix('ст')        # =&gt; "те"
'こんにちは'.delete_suffix('ちは')  # =&gt; "こんに"
</pre> <p>Related: <a href="string.html#method-i-delete_suffix-21"><code>String#delete_suffix!</code></a>, <a href="string.html#method-i-delete_prefix"><code>String#delete_prefix</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-delete_suffix-21"> <span class="method-callseq"> delete_suffix!(suffix) → self or nil </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="delete_suffix-21-source"> <pre class="c" data-language="c">static VALUE
rb_str_delete_suffix_bang(VALUE str, VALUE suffix)
{
    long olen, suffixlen, len;
    str_modifiable(str);

    suffixlen = deleted_suffix_length(str, suffix);
    if (suffixlen &lt;= 0) return Qnil;

    olen = RSTRING_LEN(str);
    str_modify_keep_cr(str);
    len = olen - suffixlen;
    STR_SET_LEN(str, len);
    TERM_FILL(&amp;RSTRING_PTR(str)[len], TERM_LEN(str));
    if (ENC_CODERANGE(str) != ENC_CODERANGE_7BIT) {
        ENC_CODERANGE_CLEAR(str);
    }
    return str;
}</pre> </div> <p>Like <a href="string.html#method-i-delete_suffix"><code>String#delete_suffix</code></a>, except that <code>self</code> is modified in place. Returns <code>self</code> if the suffix is removed, <code>nil</code> otherwise.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-downcase"> <span class="method-callseq"> downcase(*options) → string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="downcase-source"> <pre class="c" data-language="c">static VALUE
rb_str_downcase(int argc, VALUE *argv, VALUE str)
{
    rb_encoding *enc;
    OnigCaseFoldType flags = ONIGENC_CASE_DOWNCASE;
    VALUE ret;

    flags = check_case_options(argc, argv, flags);
    enc = str_true_enc(str);
    if (case_option_single_p(flags, enc, str)) {
        ret = rb_str_new(RSTRING_PTR(str), RSTRING_LEN(str));
        str_enc_copy_direct(ret, str);
        downcase_single(ret);
    }
    else if (flags&amp;ONIGENC_CASE_ASCII_ONLY) {
        ret = rb_str_new(0, RSTRING_LEN(str));
        rb_str_ascii_casemap(str, ret, &amp;flags, enc);
    }
    else {
        ret = rb_str_casemap(str, &amp;flags, enc);
    }

    return ret;
}</pre> </div> <p>Returns a string containing the downcased characters in <code>self</code>:</p> <pre class="ruby" data-language="ruby">s = 'Hello World!' # =&gt; "Hello World!"
s.downcase         # =&gt; "hello world!"
</pre> <p>The casing may be affected by the given <code>options</code>; see <a href="case_mapping_rdoc.html">Case Mapping</a>.</p> <p>Related: <a href="string.html#method-i-downcase-21"><code>String#downcase!</code></a>, <a href="string.html#method-i-upcase"><code>String#upcase</code></a>, <a href="string.html#method-i-upcase-21"><code>String#upcase!</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-downcase-21"> <span class="method-callseq"> downcase!(*options) → self or nil </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="downcase-21-source"> <pre class="c" data-language="c">static VALUE
rb_str_downcase_bang(int argc, VALUE *argv, VALUE str)
{
    rb_encoding *enc;
    OnigCaseFoldType flags = ONIGENC_CASE_DOWNCASE;

    flags = check_case_options(argc, argv, flags);
    str_modify_keep_cr(str);
    enc = str_true_enc(str);
    if (case_option_single_p(flags, enc, str)) {
        if (downcase_single(str))
            flags |= ONIGENC_CASE_MODIFIED;
    }
    else if (flags&amp;ONIGENC_CASE_ASCII_ONLY)
        rb_str_ascii_casemap(str, str, &amp;flags, enc);
    else
        str_shared_replace(str, rb_str_casemap(str, &amp;flags, enc));

    if (ONIGENC_CASE_MODIFIED&amp;flags) return str;
    return Qnil;
}</pre> </div> <p>Downcases the characters in <code>self</code>; returns <code>self</code> if any changes were made, <code>nil</code> otherwise:</p> <pre class="ruby" data-language="ruby">s = 'Hello World!' # =&gt; "Hello World!"
s.downcase!        # =&gt; "hello world!"
s                  # =&gt; "hello world!"
s.downcase!        # =&gt; nil
</pre> <p>The casing may be affected by the given <code>options</code>; see <a href="case_mapping_rdoc.html">Case Mapping</a>.</p> <p>Related: <a href="string.html#method-i-downcase"><code>String#downcase</code></a>, <a href="string.html#method-i-upcase"><code>String#upcase</code></a>, <a href="string.html#method-i-upcase-21"><code>String#upcase!</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-dump"> <span class="method-callseq"> dump → string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="dump-source"> <pre class="c" data-language="c">VALUE
rb_str_dump(VALUE str)
{
    int encidx = rb_enc_get_index(str);
    rb_encoding *enc = rb_enc_from_index(encidx);
    long len;
    const char *p, *pend;
    char *q, *qend;
    VALUE result;
    int u8 = (encidx == rb_utf8_encindex());
    static const char nonascii_suffix[] = ".dup.force_encoding(\"%s\")";

    len = 2;                    /* "" */
    if (!rb_enc_asciicompat(enc)) {
        len += strlen(nonascii_suffix) - rb_strlen_lit("%s");
        len += strlen(enc-&gt;name);
    }

    p = RSTRING_PTR(str); pend = p + RSTRING_LEN(str);
    while (p &lt; pend) {
        int clen;
        unsigned char c = *p++;

        switch (c) {
          case '"':  case '\\':
          case '\n': case '\r':
          case '\t': case '\f':
          case '\013': case '\010': case '\007': case '\033':
            clen = 2;
            break;

          case '#':
            clen = IS_EVSTR(p, pend) ? 2 : 1;
            break;

          default:
            if (ISPRINT(c)) {
                clen = 1;
            }
            else {
                if (u8 &amp;&amp; c &gt; 0x7F) {   /* \u notation */
                    int n = rb_enc_precise_mbclen(p-1, pend, enc);
                    if (MBCLEN_CHARFOUND_P(n)) {
                        unsigned int cc = rb_enc_mbc_to_codepoint(p-1, pend, enc);
                        if (cc &lt;= 0xFFFF)
                            clen = 6;  /* \uXXXX */
                        else if (cc &lt;= 0xFFFFF)
                            clen = 9;  /* \u{XXXXX} */
                        else
                            clen = 10; /* \u{XXXXXX} */
                        p += MBCLEN_CHARFOUND_LEN(n)-1;
                        break;
                    }
                }
                clen = 4;       /* \xNN */
            }
            break;
        }

        if (clen &gt; LONG_MAX - len) {
            rb_raise(rb_eRuntimeError, "string size too big");
        }
        len += clen;
    }

    result = rb_str_new(0, len);
    p = RSTRING_PTR(str); pend = p + RSTRING_LEN(str);
    q = RSTRING_PTR(result); qend = q + len + 1;

    *q++ = '"';
    while (p &lt; pend) {
        unsigned char c = *p++;

        if (c == '"' || c == '\\') {
            *q++ = '\\';
            *q++ = c;
        }
        else if (c == '#') {
            if (IS_EVSTR(p, pend)) *q++ = '\\';
            *q++ = '#';
        }
        else if (c == '\n') {
            *q++ = '\\';
            *q++ = 'n';
        }
        else if (c == '\r') {
            *q++ = '\\';
            *q++ = 'r';
        }
        else if (c == '\t') {
            *q++ = '\\';
            *q++ = 't';
        }
        else if (c == '\f') {
            *q++ = '\\';
            *q++ = 'f';
        }
        else if (c == '\013') {
            *q++ = '\\';
            *q++ = 'v';
        }
        else if (c == '\010') {
            *q++ = '\\';
            *q++ = 'b';
        }
        else if (c == '\007') {
            *q++ = '\\';
            *q++ = 'a';
        }
        else if (c == '\033') {
            *q++ = '\\';
            *q++ = 'e';
        }
        else if (ISPRINT(c)) {
            *q++ = c;
        }
        else {
            *q++ = '\\';
            if (u8) {
                int n = rb_enc_precise_mbclen(p-1, pend, enc) - 1;
                if (MBCLEN_CHARFOUND_P(n)) {
                    int cc = rb_enc_mbc_to_codepoint(p-1, pend, enc);
                    p += n;
                    if (cc &lt;= 0xFFFF)
                        snprintf(q, qend-q, "u%04X", cc);    /* \uXXXX */
                    else
                        snprintf(q, qend-q, "u{%X}", cc);  /* \u{XXXXX} or \u{XXXXXX} */
                    q += strlen(q);
                    continue;
                }
            }
            snprintf(q, qend-q, "x%02X", c);
            q += 3;
        }
    }
    *q++ = '"';
    *q = '\0';
    if (!rb_enc_asciicompat(enc)) {
        snprintf(q, qend-q, nonascii_suffix, enc-&gt;name);
        encidx = rb_ascii8bit_encindex();
    }
    /* result from dump is ASCII */
    rb_enc_associate_index(result, encidx);
    ENC_CODERANGE_SET(result, ENC_CODERANGE_7BIT);
    return result;
}</pre> </div> <p>Returns a printable version of <code>self</code>, enclosed in double-quotes, with special characters escaped, and with non-printing characters replaced by hexadecimal notation:</p> <pre class="ruby" data-language="ruby">"hello \n ''".dump    # =&gt; "\"hello \\n ''\""
"\f\x00\xff\\\"".dump # =&gt; "\"\\f\\x00\\xFF\\\\\\\"\""
</pre> <p>Related: <a href="string.html#method-i-undump"><code>String#undump</code></a> (inverse of <a href="string.html#method-i-dump"><code>String#dump</code></a>).</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-each_byte"> <span class="method-callseq"> each_byte {|byte| ... } → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> each_byte → enumerator </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="each_byte-source"> <pre class="c" data-language="c">static VALUE
rb_str_each_byte(VALUE str)
{
    RETURN_SIZED_ENUMERATOR(str, 0, 0, rb_str_each_byte_size);
    return rb_str_enumerate_bytes(str, 0);
}</pre> </div> <p>Calls the given block with each successive byte from <code>self</code>; returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">'hello'.each_byte {|byte| print byte, ' ' }
print "\n"
'тест'.each_byte {|byte| print byte, ' ' }
print "\n"
'こんにちは'.each_byte {|byte| print byte, ' ' }
print "\n"
</pre> <p>Output:</p> <pre>104 101 108 108 111
209 130 208 181 209 129 209 130
227 129 147 227 130 147 227 129 171 227 129 161 227 129 175</pre> <p>Returns an enumerator if no block is given.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-each_char"> <span class="method-callseq"> each_char {|c| ... } → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> each_char → enumerator </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="each_char-source"> <pre class="c" data-language="c">static VALUE
rb_str_each_char(VALUE str)
{
    RETURN_SIZED_ENUMERATOR(str, 0, 0, rb_str_each_char_size);
    return rb_str_enumerate_chars(str, 0);
}</pre> </div> <p>Calls the given block with each successive character from <code>self</code>; returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">'hello'.each_char {|char| print char, ' ' }
print "\n"
'тест'.each_char {|char| print char, ' ' }
print "\n"
'こんにちは'.each_char {|char| print char, ' ' }
print "\n"
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">h e l l o
т е с т
こ ん に ち は
</pre> <p>Returns an enumerator if no block is given.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-each_codepoint"> <span class="method-callseq"> each_codepoint {|integer| ... } → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> each_codepoint → enumerator </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="each_codepoint-source"> <pre class="c" data-language="c">static VALUE
rb_str_each_codepoint(VALUE str)
{
    RETURN_SIZED_ENUMERATOR(str, 0, 0, rb_str_each_char_size);
    return rb_str_enumerate_codepoints(str, 0);
}</pre> </div> <p>Calls the given block with each successive codepoint from <code>self</code>; each codepoint is the integer value for a character; returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">'hello'.each_codepoint {|codepoint| print codepoint, ' ' }
print "\n"
'тест'.each_codepoint {|codepoint| print codepoint, ' ' }
print "\n"
'こんにちは'.each_codepoint {|codepoint| print codepoint, ' ' }
print "\n"
</pre> <p>Output:</p> <pre>104 101 108 108 111
1090 1077 1089 1090
12371 12435 12395 12385 12399</pre> <p>Returns an enumerator if no block is given.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-each_grapheme_cluster"> <span class="method-callseq"> each_grapheme_cluster {|gc| ... } → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> each_grapheme_cluster → enumerator </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="each_grapheme_cluster-source"> <pre class="c" data-language="c">static VALUE
rb_str_each_grapheme_cluster(VALUE str)
{
    RETURN_SIZED_ENUMERATOR(str, 0, 0, rb_str_each_grapheme_cluster_size);
    return rb_str_enumerate_grapheme_clusters(str, 0);
}</pre> </div> <p>Calls the given block with each successive grapheme cluster from <code>self</code> (see <a href="https://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries">Unicode Grapheme Cluster Boundaries</a>); returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">s = "\u0061\u0308-pqr-\u0062\u0308-xyz-\u0063\u0308" # =&gt; "ä-pqr-b̈-xyz-c̈"
s.each_grapheme_cluster {|gc| print gc, ' ' }
</pre> <p>Output:</p> <pre>ä - p q r - b̈ - x y z - c̈</pre> <p>Returns an enumerator if no block is given.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-each_line"> <span class="method-callseq"> each_line(line_sep = $/, chomp: false) {|substring| ... } → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> each_line(line_sep = $/, chomp: false) → enumerator </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="each_line-source"> <pre class="c" data-language="c">static VALUE
rb_str_each_line(int argc, VALUE *argv, VALUE str)
{
    RETURN_SIZED_ENUMERATOR(str, argc, argv, 0);
    return rb_str_enumerate_lines(argc, argv, str, 0);
}</pre> </div> <p>With a block given, forms the substrings (“lines”) that are the result of splitting <code>self</code> at each occurrence of the given line separator <code>line_sep</code>; passes each line to the block; returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">s = &lt;&lt;~EOT
This is the first line.
This is line two.

This is line four.
This is line five.
EOT

s.each_line {|line| p line }
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">"This is the first line.\n"
"This is line two.\n"
"\n"
"This is line four.\n"
"This is line five.\n"
</pre> <p>With a different <code>line_sep</code>:</p> <pre class="ruby" data-language="ruby">s.each_line(' is ') {|line| p line }
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">"This is "
"the first line.\nThis is "
"line two.\n\nThis is "
"line four.\nThis is "
"line five.\n"
</pre> <p>With <code>chomp</code> as <code>true</code>, removes the trailing <code>line_sep</code> from each line:</p> <pre class="ruby" data-language="ruby">s.each_line(chomp: true) {|line| p line }
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">"This is the first line."
"This is line two."
""
"This is line four."
"This is line five."
</pre> <p>With an empty string as <code>line_sep</code>, forms and passes “paragraphs” by splitting at each occurrence of two or more newlines:</p> <pre class="ruby" data-language="ruby">s.each_line('') {|line| p line }
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">"This is the first line.\nThis is line two.\n\n"
"This is line four.\nThis is line five.\n"
</pre> <p>With no block given, returns an enumerator.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-empty-3F"> <span class="method-callseq"> empty? → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="empty-3F-source"> <pre class="c" data-language="c">static VALUE
rb_str_empty(VALUE str)
{
    return RBOOL(RSTRING_LEN(str) == 0);
}</pre> </div> <p>Returns <code>true</code> if the length of <code>self</code> is zero, <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">"hello".empty? # =&gt; false
" ".empty? # =&gt; false
"".empty? # =&gt; true
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-encode"> <span class="method-callseq"> encode(dst_encoding = Encoding.default_internal, **enc_opts) → string </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> encode(dst_encoding, src_encoding, **enc_opts) → string </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="encode-source"> <pre class="c" data-language="c">static VALUE
str_encode(int argc, VALUE *argv, VALUE str)
{
    VALUE newstr = str;
    int encidx = str_transcode(argc, argv, &amp;newstr);
    return encoded_dup(newstr, str, encidx);
}</pre> </div> <p>Returns a copy of <code>self</code> transcoded as determined by <code>dst_encoding</code>. By default, raises an exception if <code>self</code> contains an invalid byte or a character not defined in <code>dst_encoding</code>; that behavior may be modified by encoding options; see below.</p> <p>With no arguments:</p> <ul>
<li> <p>Uses the same encoding if <code>Encoding.default_internal</code> is <code>nil</code> (the default):</p> <pre class="ruby" data-language="ruby">Encoding.default_internal # =&gt; nil
s = "Ruby\x99".force_encoding('Windows-1252')
s.encoding                # =&gt; #&lt;Encoding:Windows-1252&gt;
s.bytes                   # =&gt; [82, 117, 98, 121, 153]
t = s.encode              # =&gt; "Ruby\x99"
t.encoding                # =&gt; #&lt;Encoding:Windows-1252&gt;
t.bytes                   # =&gt; [82, 117, 98, 121, 226, 132, 162]
</pre> </li>
<li> <p>Otherwise, uses the encoding <code>Encoding.default_internal</code>:</p> <pre class="ruby" data-language="ruby">Encoding.default_internal = 'UTF-8'
t = s.encode              # =&gt; "Ruby™"
t.encoding                # =&gt; #&lt;Encoding:UTF-8&gt;
</pre> </li>
</ul> <p>With only argument <code>dst_encoding</code> given, uses that encoding:</p> <pre class="ruby" data-language="ruby">s = "Ruby\x99".force_encoding('Windows-1252')
s.encoding            # =&gt; #&lt;Encoding:Windows-1252&gt;
t = s.encode('UTF-8') # =&gt; "Ruby™"
t.encoding            # =&gt; #&lt;Encoding:UTF-8&gt;
</pre> <p>With arguments <code>dst_encoding</code> and <code>src_encoding</code> given, interprets <code>self</code> using <code>src_encoding</code>, encodes the new string using <code>dst_encoding</code>:</p> <pre class="ruby" data-language="ruby">s = "Ruby\x99"
t = s.encode('UTF-8', 'Windows-1252') # =&gt; "Ruby™"
t.encoding                            # =&gt; #&lt;Encoding:UTF-8&gt;
</pre> <p>Optional keyword arguments <code>enc_opts</code> specify encoding options; see <a href="encodings_rdoc.html#label-Encoding+Options">Encoding Options</a>.</p> <p>Please note that, unless <code>invalid: :replace</code> option is given, conversion from an encoding <code>enc</code> to the same encoding <code>enc</code> (independent of whether <code>enc</code> is given explicitly or implicitly) is a no-op, i.e. the string is simply copied without any changes, and no exceptions are raised, even if there are invalid bytes.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-encode-21"> <span class="method-callseq"> encode!(dst_encoding = Encoding.default_internal, **enc_opts) → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> encode!(dst_encoding, src_encoding, **enc_opts) → self </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="encode-21-source"> <pre class="c" data-language="c">static VALUE
str_encode_bang(int argc, VALUE *argv, VALUE str)
{
    VALUE newstr;
    int encidx;

    rb_check_frozen(str);

    newstr = str;
    encidx = str_transcode(argc, argv, &amp;newstr);

    if (encidx &lt; 0) return str;
    if (newstr == str) {
        rb_enc_associate_index(str, encidx);
        return str;
    }
    rb_str_shared_replace(str, newstr);
    return str_encode_associate(str, encidx);
}</pre> </div> <p>Like <a href="string.html#method-i-encode"><code>encode</code></a>, but applies encoding changes to <code>self</code>; returns <code>self</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-encoding"> <span class="method-callseq"> encoding → encoding </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="encoding-source"> <pre class="c" data-language="c">VALUE
rb_obj_encoding(VALUE obj)
{
    int idx = rb_enc_get_index(obj);
    if (idx &lt; 0) {
        rb_raise(rb_eTypeError, "unknown encoding");
    }
    return rb_enc_from_encoding_index(idx &amp; ENC_INDEX_MASK);
}</pre> </div> <p>Returns the <a href="encoding.html"><code>Encoding</code></a> object that represents the encoding of obj.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-end_with-3F"> <span class="method-callseq"> end_with?(*strings) → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="end_with-3F-source"> <pre class="c" data-language="c">static VALUE
rb_str_end_with(int argc, VALUE *argv, VALUE str)
{
    int i;

    for (i=0; i&lt;argc; i++) {
        VALUE tmp = argv[i];
        const char *p, *s, *e;
        long slen, tlen;
        rb_encoding *enc;

        StringValue(tmp);
        enc = rb_enc_check(str, tmp);
        if ((tlen = RSTRING_LEN(tmp)) == 0) return Qtrue;
        if ((slen = RSTRING_LEN(str)) &lt; tlen) continue;
        p = RSTRING_PTR(str);
        e = p + slen;
        s = e - tlen;
        if (!at_char_boundary(p, s, e, enc))
            continue;
        if (memcmp(s, RSTRING_PTR(tmp), tlen) == 0)
            return Qtrue;
    }
    return Qfalse;
}</pre> </div> <p>Returns whether <code>self</code> ends with any of the given <code>strings</code>.</p> <p>Returns <code>true</code> if any given string matches the end, <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">'hello'.end_with?('ello')               #=&gt; true
'hello'.end_with?('heaven', 'ello')     #=&gt; true
'hello'.end_with?('heaven', 'paradise') #=&gt; false
'тест'.end_with?('т')                   # =&gt; true
'こんにちは'.end_with?('は')              # =&gt; true
</pre> <p>Related: <a href="string.html#method-i-start_with-3F"><code>String#start_with?</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-eql-3F"> <span class="method-callseq"> eql?(object) → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="eql-3F-source"> <pre class="c" data-language="c">VALUE
rb_str_eql(VALUE str1, VALUE str2)
{
    if (str1 == str2) return Qtrue;
    if (!RB_TYPE_P(str2, T_STRING)) return Qfalse;
    return rb_str_eql_internal(str1, str2);
}</pre> </div> <p>Returns <code>true</code> if <code>object</code> has the same length and content; as <code>self</code>; <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">s = 'foo'
s.eql?('foo') # =&gt; true
s.eql?('food') # =&gt; false
s.eql?('FOO') # =&gt; false
</pre> <p>Returns <code>false</code> if the two strings’ encodings are not compatible:</p> <pre class="ruby" data-language="ruby">"\u{e4 f6 fc}".encode("ISO-8859-1").eql?("\u{c4 d6 dc}") # =&gt; false
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-force_encoding"> <span class="method-callseq"> force_encoding(encoding) → self </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="force_encoding-source"> <pre class="c" data-language="c">static VALUE
rb_str_force_encoding(VALUE str, VALUE enc)
{
    str_modifiable(str);

    rb_encoding *encoding = rb_to_encoding(enc);
    int idx = rb_enc_to_index(encoding);

    // If the encoding is unchanged, we do nothing.
    if (ENCODING_GET(str) == idx) {
        return str;
    }

    rb_enc_associate_index(str, idx);

    // If the coderange was 7bit and the new encoding is ASCII-compatible
    // we can keep the coderange.
    if (ENC_CODERANGE(str) == ENC_CODERANGE_7BIT &amp;&amp; encoding &amp;&amp; rb_enc_asciicompat(encoding)) {
        return str;
    }

    ENC_CODERANGE_CLEAR(str);
    return str;
}</pre> </div> <p>Changes the encoding of <code>self</code> to <code>encoding</code>, which may be a string encoding name or an <a href="encoding.html"><code>Encoding</code></a> object; returns self:</p> <pre class="ruby" data-language="ruby">s = 'łał'
s.bytes                   # =&gt; [197, 130, 97, 197, 130]
s.encoding                # =&gt; #&lt;Encoding:UTF-8&gt;
s.force_encoding('ascii') # =&gt; "\xC5\x82a\xC5\x82"
s.encoding                # =&gt; #&lt;Encoding:US-ASCII&gt;
</pre> <p>Does not change the underlying bytes:</p> <pre class="ruby" data-language="ruby">s.bytes                   # =&gt; [197, 130, 97, 197, 130]
</pre> <p>Makes the change even if the given <code>encoding</code> is invalid for <code>self</code> (as is the change above):</p> <pre class="ruby" data-language="ruby">s.valid_encoding?                 # =&gt; false
s.force_encoding(Encoding::UTF_8) # =&gt; "łał"
s.valid_encoding?                 # =&gt; true
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-getbyte"> <span class="method-callseq"> getbyte(index) → integer or nil </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="getbyte-source"> <pre class="c" data-language="c">VALUE
rb_str_getbyte(VALUE str, VALUE index)
{
    long pos = NUM2LONG(index);

    if (pos &lt; 0)
        pos += RSTRING_LEN(str);
    if (pos &lt; 0 ||  RSTRING_LEN(str) &lt;= pos)
        return Qnil;

    return INT2FIX((unsigned char)RSTRING_PTR(str)[pos]);
}</pre> </div> <p>Returns the byte at zero-based <code>index</code> as an integer, or <code>nil</code> if <code>index</code> is out of range:</p> <pre class="ruby" data-language="ruby">s = 'abcde'   # =&gt; "abcde"
s.getbyte(0)  # =&gt; 97
s.getbyte(-1) # =&gt; 101
s.getbyte(5)  # =&gt; nil
</pre> <p>Related: <a href="string.html#method-i-setbyte"><code>String#setbyte</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-grapheme_clusters"> <span class="method-callseq"> grapheme_clusters → array_of_grapheme_clusters </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="grapheme_clusters-source"> <pre class="c" data-language="c">static VALUE
rb_str_grapheme_clusters(VALUE str)
{
    VALUE ary = WANTARRAY("grapheme_clusters", rb_str_strlen(str));
    return rb_str_enumerate_grapheme_clusters(str, ary);
}</pre> </div> <p>Returns an array of the grapheme clusters in <code>self</code> (see <a href="https://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries">Unicode Grapheme Cluster Boundaries</a>):</p> <pre class="ruby" data-language="ruby">s = "\u0061\u0308-pqr-\u0062\u0308-xyz-\u0063\u0308" # =&gt; "ä-pqr-b̈-xyz-c̈"
s.grapheme_clusters
# =&gt; ["ä", "-", "p", "q", "r", "-", "b̈", "-", "x", "y", "z", "-", "c̈"]
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-gsub"> <span class="method-callseq"> gsub(pattern, replacement) → new_string </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> gsub(pattern) {|match| ... } → new_string </span> </div> <div class="method-heading"> <span class="method-callseq"> gsub(pattern) → enumerator </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="gsub-source"> <pre class="c" data-language="c">static VALUE
rb_str_gsub(int argc, VALUE *argv, VALUE str)
{
    return str_gsub(argc, argv, str, 0);
}</pre> </div> <p>Returns a copy of <code>self</code> with all occurrences of the given <code>pattern</code> replaced.</p> <p>See <a href="string.html#class-String-label-Substitution+Methods">Substitution Methods</a>.</p> <p>Returns an <a href="enumerator.html"><code>Enumerator</code></a> if no <code>replacement</code> and no block given.</p> <p>Related: <a href="string.html#method-i-sub"><code>String#sub</code></a>, <a href="string.html#method-i-sub-21"><code>String#sub!</code></a>, <a href="string.html#method-i-gsub-21"><code>String#gsub!</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-gsub-21"> <span class="method-callseq"> gsub!(pattern, replacement) → self or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> gsub!(pattern) {|match| ... } → self or nil </span> </div> <div class="method-heading"> <span class="method-callseq"> gsub!(pattern) → an_enumerator </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="gsub-21-source"> <pre class="c" data-language="c">static VALUE
rb_str_gsub_bang(int argc, VALUE *argv, VALUE str)
{
    str_modify_keep_cr(str);
    return str_gsub(argc, argv, str, 1);
}</pre> </div> <p>Performs the specified substring replacement(s) on <code>self</code>; returns <code>self</code> if any replacement occurred, <code>nil</code> otherwise.</p> <p>See <a href="string.html#class-String-label-Substitution+Methods">Substitution Methods</a>.</p> <p>Returns an <a href="enumerator.html"><code>Enumerator</code></a> if no <code>replacement</code> and no block given.</p> <p>Related: <a href="string.html#method-i-sub"><code>String#sub</code></a>, <a href="string.html#method-i-gsub"><code>String#gsub</code></a>, <a href="string.html#method-i-sub-21"><code>String#sub!</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-hash"> <span class="method-callseq"> hash → integer </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="hash-source"> <pre class="c" data-language="c">static VALUE
rb_str_hash_m(VALUE str)
{
    st_index_t hval = rb_str_hash(str);
    return ST2FIX(hval);
}</pre> </div> <p>Returns the integer hash value for <code>self</code>. The value is based on the length, content and encoding of <code>self</code>.</p> <p>Related: <a href="object.html#method-i-hash"><code>Object#hash</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-hex"> <span class="method-callseq"> hex → integer </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="hex-source"> <pre class="c" data-language="c">static VALUE
rb_str_hex(VALUE str)
{
    return rb_str_to_inum(str, 16, FALSE);
}</pre> </div> <p>Interprets the leading substring of <code>self</code> as a string of hexadecimal digits (with an optional sign and an optional <code>0x</code>) and returns the corresponding number; returns zero if there is no such leading substring:</p> <pre class="ruby" data-language="ruby">'0x0a'.hex        # =&gt; 10
'-1234'.hex       # =&gt; -4660
'0'.hex           # =&gt; 0
'non-numeric'.hex # =&gt; 0
</pre> <p>Related: <a href="string.html#method-i-oct"><code>String#oct</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-include-3F"> <span class="method-callseq"> include? other_string → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="include-3F-source"> <pre class="c" data-language="c">VALUE
rb_str_include(VALUE str, VALUE arg)
{
    long i;

    StringValue(arg);
    i = rb_str_index(str, arg, 0);

    return RBOOL(i != -1);
}</pre> </div> <p>Returns <code>true</code> if <code>self</code> contains <code>other_string</code>, <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">s = 'foo'
s.include?('f')    # =&gt; true
s.include?('fo')   # =&gt; true
s.include?('food') # =&gt; false
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-index"> <span class="method-callseq"> index(substring, offset = 0) → integer or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> index(regexp, offset = 0) → integer or nil </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="index-source"> <pre class="c" data-language="c">static VALUE
rb_str_index_m(int argc, VALUE *argv, VALUE str)
{
    VALUE sub;
    VALUE initpos;
    rb_encoding *enc = STR_ENC_GET(str);
    long pos;

    if (rb_scan_args(argc, argv, "11", &amp;sub, &amp;initpos) == 2) {
        long slen = str_strlen(str, enc); /* str's enc */
        pos = NUM2LONG(initpos);
        if (pos &lt; 0 ? (pos += slen) &lt; 0 : pos &gt; slen) {
            if (RB_TYPE_P(sub, T_REGEXP)) {
                rb_backref_set(Qnil);
            }
            return Qnil;
        }
    }
    else {
        pos = 0;
    }

    if (RB_TYPE_P(sub, T_REGEXP)) {
        pos = str_offset(RSTRING_PTR(str), RSTRING_END(str), pos,
                         enc, single_byte_optimizable(str));

        if (rb_reg_search(sub, str, pos, 0) &gt;= 0) {
            VALUE match = rb_backref_get();
            struct re_registers *regs = RMATCH_REGS(match);
            pos = rb_str_sublen(str, BEG(0));
            return LONG2NUM(pos);
        }
    }
    else {
        StringValue(sub);
        pos = rb_str_index(str, sub, pos);
        if (pos &gt;= 0) {
            pos = rb_str_sublen(str, pos);
            return LONG2NUM(pos);
        }
    }
    return Qnil;
}</pre> </div> <p>Returns the integer index of the first match for the given argument, or <code>nil</code> if none found; the search of <code>self</code> is forward, and begins at position <code>offset</code> (in characters).</p> <p>With string argument <code>substring</code>, returns the index of the first matching substring in <code>self</code>:</p> <pre class="ruby" data-language="ruby">'foo'.index('f')         # =&gt; 0
'foo'.index('o')         # =&gt; 1
'foo'.index('oo')        # =&gt; 1
'foo'.index('ooo')       # =&gt; nil
'тест'.index('с')        # =&gt; 2
'こんにちは'.index('ち')   # =&gt; 3
</pre> <p>With <a href="regexp.html"><code>Regexp</code></a> argument <code>regexp</code>, returns the index of the first match in <code>self</code>:</p> <pre class="ruby" data-language="ruby">'foo'.index(/o./) # =&gt; 1
'foo'.index(/.o/) # =&gt; 0
</pre> <p>With positive integer <code>offset</code>, begins the search at position <code>offset</code>:</p> <pre class="ruby" data-language="ruby">'foo'.index('o', 1)        # =&gt; 1
'foo'.index('o', 2)        # =&gt; 2
'foo'.index('o', 3)        # =&gt; nil
'тест'.index('с', 1)       # =&gt; 2
'こんにちは'.index('ち', 2)  # =&gt; 3
</pre> <p>With negative integer <code>offset</code>, selects the search position by counting backward from the end of <code>self</code>:</p> <pre class="ruby" data-language="ruby">'foo'.index('o', -1)  # =&gt; 2
'foo'.index('o', -2)  # =&gt; 1
'foo'.index('o', -3)  # =&gt; 1
'foo'.index('o', -4)  # =&gt; nil
'foo'.index(/o./, -2) # =&gt; 1
'foo'.index(/.o/, -2) # =&gt; 1
</pre> <p>Related: <a href="string.html#method-i-rindex"><code>String#rindex</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-initialize_copy"> <span class="method-name">initialize_copy</span> </div> </div> <div class="aliases"> Also aliased as: <a href="string.html#method-i-replace">replace</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-insert"> <span class="method-callseq"> insert(index, other_string) → self </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="insert-source"> <pre class="c" data-language="c">static VALUE
rb_str_insert(VALUE str, VALUE idx, VALUE str2)
{
    long pos = NUM2LONG(idx);

    if (pos == -1) {
        return rb_str_append(str, str2);
    }
    else if (pos &lt; 0) {
        pos++;
    }
    rb_str_update(str, pos, 0, str2);
    return str;
}</pre> </div> <p>Inserts the given <code>other_string</code> into <code>self</code>; returns <code>self</code>.</p> <p>If the <a href="integer.html"><code>Integer</code></a> <code>index</code> is positive, inserts <code>other_string</code> at offset <code>index</code>:</p> <pre class="ruby" data-language="ruby">'foo'.insert(1, 'bar') # =&gt; "fbaroo"
</pre> <p>If the <a href="integer.html"><code>Integer</code></a> <code>index</code> is negative, counts backward from the end of <code>self</code> and inserts <code>other_string</code> at offset <code>index+1</code> (that is, <em>after</em> <code>self[index]</code>):</p> <pre class="ruby" data-language="ruby">'foo'.insert(-2, 'bar') # =&gt; "fobaro"
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-inspect"> <span class="method-callseq"> inspect → string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="inspect-source"> <pre class="c" data-language="c">VALUE
rb_str_inspect(VALUE str)
{
    int encidx = ENCODING_GET(str);
    rb_encoding *enc = rb_enc_from_index(encidx);
    const char *p, *pend, *prev;
    char buf[CHAR_ESC_LEN + 1];
    VALUE result = rb_str_buf_new(0);
    rb_encoding *resenc = rb_default_internal_encoding();
    int unicode_p = rb_enc_unicode_p(enc);
    int asciicompat = rb_enc_asciicompat(enc);

    if (resenc == NULL) resenc = rb_default_external_encoding();
    if (!rb_enc_asciicompat(resenc)) resenc = rb_usascii_encoding();
    rb_enc_associate(result, resenc);
    str_buf_cat2(result, "\"");

    p = RSTRING_PTR(str); pend = RSTRING_END(str);
    prev = p;
    while (p &lt; pend) {
        unsigned int c, cc;
        int n;

        n = rb_enc_precise_mbclen(p, pend, enc);
        if (!MBCLEN_CHARFOUND_P(n)) {
            if (p &gt; prev) str_buf_cat(result, prev, p - prev);
            n = rb_enc_mbminlen(enc);
            if (pend &lt; p + n)
                n = (int)(pend - p);
            while (n--) {
                snprintf(buf, CHAR_ESC_LEN, "\\x%02X", *p &amp; 0377);
                str_buf_cat(result, buf, strlen(buf));
                prev = ++p;
            }
            continue;
        }
        n = MBCLEN_CHARFOUND_LEN(n);
        c = rb_enc_mbc_to_codepoint(p, pend, enc);
        p += n;
        if ((asciicompat || unicode_p) &amp;&amp;
          (c == '"'|| c == '\\' ||
            (c == '#' &amp;&amp;
             p &lt; pend &amp;&amp;
             MBCLEN_CHARFOUND_P(rb_enc_precise_mbclen(p,pend,enc)) &amp;&amp;
             (cc = rb_enc_codepoint(p,pend,enc),
              (cc == '$' || cc == '@' || cc == '{'))))) {
            if (p - n &gt; prev) str_buf_cat(result, prev, p - n - prev);
            str_buf_cat2(result, "\\");
            if (asciicompat || enc == resenc) {
                prev = p - n;
                continue;
            }
        }
        switch (c) {
          case '\n': cc = 'n'; break;
          case '\r': cc = 'r'; break;
          case '\t': cc = 't'; break;
          case '\f': cc = 'f'; break;
          case '\013': cc = 'v'; break;
          case '\010': cc = 'b'; break;
          case '\007': cc = 'a'; break;
          case 033: cc = 'e'; break;
          default: cc = 0; break;
        }
        if (cc) {
            if (p - n &gt; prev) str_buf_cat(result, prev, p - n - prev);
            buf[0] = '\\';
            buf[1] = (char)cc;
            str_buf_cat(result, buf, 2);
            prev = p;
            continue;
        }
        /* The special casing of 0x85 (NEXT_LINE) here is because
         * Oniguruma historically treats it as printable, but it
         * doesn't match the print POSIX bracket class or character
         * property in regexps.
         *
         * See Ruby Bug #16842 for details:
         * https://bugs.ruby-lang.org/issues/16842
         */
        if ((enc == resenc &amp;&amp; rb_enc_isprint(c, enc) &amp;&amp; c != 0x85) ||
            (asciicompat &amp;&amp; rb_enc_isascii(c, enc) &amp;&amp; ISPRINT(c))) {
            continue;
        }
        else {
            if (p - n &gt; prev) str_buf_cat(result, prev, p - n - prev);
            rb_str_buf_cat_escaped_char(result, c, unicode_p);
            prev = p;
            continue;
        }
    }
    if (p &gt; prev) str_buf_cat(result, prev, p - prev);
    str_buf_cat2(result, "\"");

    return result;
}</pre> </div> <p>Returns a printable version of <code>self</code>, enclosed in double-quotes, and with special characters escaped:</p> <pre class="ruby" data-language="ruby">s = "foo\tbar\tbaz\n"
s.inspect
# =&gt; "\"foo\\tbar\\tbaz\\n\""
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-intern"> <span class="method-callseq"> intern → symbol </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="intern-source"> <pre class="c" data-language="c">VALUE
rb_str_intern(VALUE str)
{
    VALUE sym;

    GLOBAL_SYMBOLS_ENTER(symbols);
    {
        sym = lookup_str_sym_with_lock(symbols, str);

        if (sym) {
            // ok
        }
        else if (USE_SYMBOL_GC) {
            rb_encoding *enc = rb_enc_get(str);
            rb_encoding *ascii = rb_usascii_encoding();
            if (enc != ascii &amp;&amp; sym_check_asciionly(str)) {
                str = rb_str_dup(str);
                rb_enc_associate(str, ascii);
                OBJ_FREEZE(str);
                enc = ascii;
            }
            else {
                str = rb_str_dup(str);
                OBJ_FREEZE(str);
            }
            str = rb_fstring(str);
            int type = rb_str_symname_type(str, IDSET_ATTRSET_FOR_INTERN);
            if (type &lt; 0) type = ID_JUNK;
            sym = dsymbol_alloc(symbols, rb_cSymbol, str, enc, type);
        }
        else {
            ID id = intern_str(str, 0);
            sym = ID2SYM(id);
        }
    }
    GLOBAL_SYMBOLS_LEAVE();
    return sym;
}</pre> </div> <p>Returns the <a href="symbol.html"><code>Symbol</code></a> corresponding to <em>str</em>, creating the symbol if it did not previously exist. See <a href="symbol.html#method-i-id2name"><code>Symbol#id2name</code></a>.</p> <pre class="ruby" data-language="ruby">"Koala".intern         #=&gt; :Koala
s = 'cat'.to_sym       #=&gt; :cat
s == :cat              #=&gt; true
s = '@cat'.to_sym      #=&gt; :@cat
s == :@cat             #=&gt; true
</pre> <p>This can also be used to create symbols that cannot be represented using the <code>:xxx</code> notation.</p> <pre class="ruby" data-language="ruby">'cat and dog'.to_sym   #=&gt; :"cat and dog"
</pre>  </div> <div class="aliases"> Also aliased as: <a href="string.html#method-i-to_sym">to_sym</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-iseuc"> <span class="method-callseq"> String#iseuc → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="iseuc-source"> <pre class="ruby" data-language="ruby"># File ext/nkf/lib/kconv.rb, line 264
def iseuc;    Kconv.iseuc(self) end</pre> </div> <p>Returns whether <code>self</code>‘s encoding is EUC-JP or not.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-isjis"> <span class="method-callseq"> String#isjis → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="isjis-source"> <pre class="ruby" data-language="ruby"># File ext/nkf/lib/kconv.rb, line 276
def isjis;    Kconv.isjis(self) end</pre> </div> <p>Returns whether <code>self</code>‘s encoding is ISO-2022-JP or not.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-issjis"> <span class="method-callseq"> String#issjis → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="issjis-source"> <pre class="ruby" data-language="ruby"># File ext/nkf/lib/kconv.rb, line 270
def issjis;   Kconv.issjis(self) end</pre> </div> <p>Returns whether <code>self</code>‘s encoding is Shift_JIS or not.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-isutf8"> <span class="method-callseq"> String#isutf8 → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="isutf8-source"> <pre class="ruby" data-language="ruby"># File ext/nkf/lib/kconv.rb, line 282
def isutf8;   Kconv.isutf8(self) end</pre> </div> <p>Returns whether <code>self</code>‘s encoding is UTF-8 or not.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-kconv"> <span class="method-callseq"> String#kconv(to_enc, from_enc) </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="kconv-source"> <pre class="ruby" data-language="ruby"># File ext/nkf/lib/kconv.rb, line 205
def kconv(to_enc, from_enc=nil)
  from_enc = self.encoding if !from_enc &amp;&amp; self.encoding != Encoding.list[0]
  Kconv::kconv(self, to_enc, from_enc)
end</pre> </div> <p>Convert <code>self</code> to <code>to_enc</code>. <code>to_enc</code> and <code>from_enc</code> are given as constants of <span><code>Kconv</code></span> or <a href="encoding.html"><code>Encoding</code></a> objects.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-length"> <span class="method-callseq"> length → integer </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="length-source"> <pre class="c" data-language="c">VALUE
rb_str_length(VALUE str)
{
    return LONG2NUM(str_strlen(str, NULL));
}</pre> </div> <p>Returns the count of characters (not bytes) in <code>self</code>:</p> <pre class="ruby" data-language="ruby">'foo'.length        # =&gt; 3
'тест'.length       # =&gt; 4
'こんにちは'.length   # =&gt; 5
</pre> <p>Contrast with <a href="string.html#method-i-bytesize"><code>String#bytesize</code></a>:</p> <pre class="ruby" data-language="ruby">'foo'.bytesize        # =&gt; 3
'тест'.bytesize       # =&gt; 8
'こんにちは'.bytesize   # =&gt; 15
</pre>  </div> <div class="aliases"> Also aliased as: <a href="string.html#method-i-size">size</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-lines"> <span class="method-callseq"> lines(Line_sep = $/, chomp: false) → array_of_strings </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="lines-source"> <pre class="c" data-language="c">static VALUE
rb_str_lines(int argc, VALUE *argv, VALUE str)
{
    VALUE ary = WANTARRAY("lines", 0);
    return rb_str_enumerate_lines(argc, argv, str, ary);
}</pre> </div> <p>Forms substrings (“lines”) of <code>self</code> according to the given arguments (see <a href="string.html#method-i-each_line"><code>String#each_line</code></a> for details); returns the lines in an array.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-ljust"> <span class="method-callseq"> ljust(size, pad_string = ' ') → new_string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="ljust-source"> <pre class="c" data-language="c">static VALUE
rb_str_ljust(int argc, VALUE *argv, VALUE str)
{
    return rb_str_justify(argc, argv, str, 'l');
}</pre> </div> <p>Returns a left-justified copy of <code>self</code>.</p> <p>If integer argument <code>size</code> is greater than the size (in characters) of <code>self</code>, returns a new string of length <code>size</code> that is a copy of <code>self</code>, left justified and padded on the right with <code>pad_string</code>:</p> <pre class="ruby" data-language="ruby">'hello'.ljust(10)       # =&gt; "hello     "
'  hello'.ljust(10)     # =&gt; "  hello   "
'hello'.ljust(10, 'ab') # =&gt; "helloababa"
'тест'.ljust(10)        # =&gt; "тест      "
'こんにちは'.ljust(10)    # =&gt; "こんにちは     "
</pre> <p>If <code>size</code> is not greater than the size of <code>self</code>, returns a copy of <code>self</code>:</p> <pre class="ruby" data-language="ruby">'hello'.ljust(5)  # =&gt; "hello"
'hello'.ljust(1)  # =&gt; "hello"
</pre> <p>Related: <a href="string.html#method-i-rjust"><code>String#rjust</code></a>, <a href="string.html#method-i-center"><code>String#center</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-lstrip"> <span class="method-callseq"> lstrip → new_string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="lstrip-source"> <pre class="c" data-language="c">static VALUE
rb_str_lstrip(VALUE str)
{
    char *start;
    long len, loffset;
    RSTRING_GETMEM(str, start, len);
    loffset = lstrip_offset(str, start, start+len, STR_ENC_GET(str));
    if (loffset &lt;= 0) return str_duplicate(rb_cString, str);
    return rb_str_subseq(str, loffset, len - loffset);
}</pre> </div> <p>Returns a copy of <code>self</code> with leading whitespace removed; see <a href="string.html#class-String-label-Whitespace+in+Strings">Whitespace in Strings</a>:</p> <pre class="ruby" data-language="ruby">whitespace = "\x00\t\n\v\f\r "
s = whitespace + 'abc' + whitespace
s        # =&gt; "\u0000\t\n\v\f\r abc\u0000\t\n\v\f\r "
s.lstrip # =&gt; "abc\u0000\t\n\v\f\r "
</pre> <p>Related: <a href="string.html#method-i-rstrip"><code>String#rstrip</code></a>, <a href="string.html#method-i-strip"><code>String#strip</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-lstrip-21"> <span class="method-callseq"> lstrip! → self or nil </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="lstrip-21-source"> <pre class="c" data-language="c">static VALUE
rb_str_lstrip_bang(VALUE str)
{
    rb_encoding *enc;
    char *start, *s;
    long olen, loffset;

    str_modify_keep_cr(str);
    enc = STR_ENC_GET(str);
    RSTRING_GETMEM(str, start, olen);
    loffset = lstrip_offset(str, start, start+olen, enc);
    if (loffset &gt; 0) {
        long len = olen-loffset;
        s = start + loffset;
        memmove(start, s, len);
        STR_SET_LEN(str, len);
        TERM_FILL(start+len, rb_enc_mbminlen(enc));
        return str;
    }
    return Qnil;
}</pre> </div> <p>Like <a href="string.html#method-i-lstrip"><code>String#lstrip</code></a>, except that any modifications are made in <code>self</code>; returns <code>self</code> if any modification are made, <code>nil</code> otherwise.</p> <p>Related: <a href="string.html#method-i-rstrip-21"><code>String#rstrip!</code></a>, <a href="string.html#method-i-strip-21"><code>String#strip!</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-match"> <span class="method-callseq"> match(pattern, offset = 0) → matchdata or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> match(pattern, offset = 0) {|matchdata| ... } → object </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="match-source"> <pre class="c" data-language="c">static VALUE
rb_str_match_m(int argc, VALUE *argv, VALUE str)
{
    VALUE re, result;
    if (argc &lt; 1)
        rb_check_arity(argc, 1, 2);
    re = argv[0];
    argv[0] = str;
    result = rb_funcallv(get_pat(re), rb_intern("match"), argc, argv);
    if (!NIL_P(result) &amp;&amp; rb_block_given_p()) {
        return rb_yield(result);
    }
    return result;
}</pre> </div> <p>Returns a <a href="matchdata.html"><code>MatchData</code></a> object (or <code>nil</code>) based on <code>self</code> and the given <code>pattern</code>.</p> <p>Note: also updates <a href="regexp.html#class-Regexp-label-Global+Variables">Global Variables at <code>Regexp</code></a>.</p> <ul>
<li> <p>Computes <code>regexp</code> by converting <code>pattern</code> (if not already a <a href="regexp.html"><code>Regexp</code></a>).</p> <pre class="ruby" data-language="ruby">regexp = Regexp.new(pattern)
</pre> </li>
<li> <p>Computes <code>matchdata</code>, which will be either a <a href="matchdata.html"><code>MatchData</code></a> object or <code>nil</code> (see <a href="regexp.html#method-i-match"><code>Regexp#match</code></a>):</p> <pre>matchdata = &lt;tt&gt;regexp.match(self)</pre> </li>
</ul> <p>With no block given, returns the computed <code>matchdata</code>:</p> <pre class="ruby" data-language="ruby">'foo'.match('f') # =&gt; #&lt;MatchData "f"&gt;
'foo'.match('o') # =&gt; #&lt;MatchData "o"&gt;
'foo'.match('x') # =&gt; nil
</pre> <p>If <a href="integer.html"><code>Integer</code></a> argument <code>offset</code> is given, the search begins at index <code>offset</code>:</p> <pre class="ruby" data-language="ruby">'foo'.match('f', 1) # =&gt; nil
'foo'.match('o', 1) # =&gt; #&lt;MatchData "o"&gt;
</pre> <p>With a block given, calls the block with the computed <code>matchdata</code> and returns the block’s return value:</p> <pre class="ruby" data-language="ruby">'foo'.match(/o/) {|matchdata| matchdata } # =&gt; #&lt;MatchData "o"&gt;
'foo'.match(/x/) {|matchdata| matchdata } # =&gt; nil
'foo'.match(/f/, 1) {|matchdata| matchdata } # =&gt; nil
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-match-3F"> <span class="method-callseq"> match?(pattern, offset = 0) → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="match-3F-source"> <pre class="c" data-language="c">static VALUE
rb_str_match_m_p(int argc, VALUE *argv, VALUE str)
{
    VALUE re;
    rb_check_arity(argc, 1, 2);
    re = get_pat(argv[0]);
    return rb_reg_match_p(re, str, argc &gt; 1 ? NUM2LONG(argv[1]) : 0);
}</pre> </div> <p>Returns <code>true</code> or <code>false</code> based on whether a match is found for <code>self</code> and <code>pattern</code>.</p> <p>Note: does not update <a href="regexp.html#class-Regexp-label-Global+Variables">Global Variables at <code>Regexp</code></a>.</p> <p>Computes <code>regexp</code> by converting <code>pattern</code> (if not already a <a href="regexp.html"><code>Regexp</code></a>).</p> <pre class="ruby" data-language="ruby">regexp = Regexp.new(pattern)
</pre> <p>Returns <code>true</code> if <code>self+.match(regexp)</code> returns a <a href="matchdata.html"><code>MatchData</code></a> object, <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">'foo'.match?(/o/) # =&gt; true
'foo'.match?('o') # =&gt; true
'foo'.match?(/x/) # =&gt; false
</pre> <p>If <a href="integer.html"><code>Integer</code></a> argument <code>offset</code> is given, the search begins at index <code>offset</code>:</p> <pre class="ruby" data-language="ruby">'foo'.match?('f', 1) # =&gt; false
'foo'.match?('o', 1) # =&gt; true
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-next"> <span class="method-name">next</span> </div> </div> <div class="aliases"> Alias for: <a href="string.html#method-i-succ">succ</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-next-21"> <span class="method-name">next!</span> </div> </div> <div class="aliases"> Alias for: <a href="string.html#method-i-succ-21">succ!</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-oct"> <span class="method-callseq"> oct → integer </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="oct-source"> <pre class="c" data-language="c">static VALUE
rb_str_oct(VALUE str)
{
    return rb_str_to_inum(str, -8, FALSE);
}</pre> </div> <p>Interprets the leading substring of <code>self</code> as a string of octal digits (with an optional sign) and returns the corresponding number; returns zero if there is no such leading substring:</p> <pre class="ruby" data-language="ruby">'123'.oct             # =&gt; 83
'-377'.oct            # =&gt; -255
'0377non-numeric'.oct # =&gt; 255
'non-numeric'.oct     # =&gt; 0
</pre> <p>If <code>self</code> starts with <code>0</code>, radix indicators are honored; see <a href="kernel.html#method-i-Integer"><code>Kernel#Integer</code></a>.</p> <p>Related: <a href="string.html#method-i-hex"><code>String#hex</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-ord"> <span class="method-callseq"> ord → integer </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="ord-source"> <pre class="c" data-language="c">static VALUE
rb_str_ord(VALUE s)
{
    unsigned int c;

    c = rb_enc_codepoint(RSTRING_PTR(s), RSTRING_END(s), STR_ENC_GET(s));
    return UINT2NUM(c);
}</pre> </div> <p>Returns the integer ordinal of the first character of <code>self</code>:</p> <pre class="ruby" data-language="ruby">'h'.ord         # =&gt; 104
'hello'.ord     # =&gt; 104
'тест'.ord      # =&gt; 1090
'こんにちは'.ord  # =&gt; 12371
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-partition"> <span class="method-callseq"> partition(string_or_regexp) → [head, match, tail] </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="partition-source"> <pre class="c" data-language="c">static VALUE
rb_str_partition(VALUE str, VALUE sep)
{
    long pos;

    sep = get_pat_quoted(sep, 0);
    if (RB_TYPE_P(sep, T_REGEXP)) {
        if (rb_reg_search(sep, str, 0, 0) &lt; 0) {
            goto failed;
        }
        VALUE match = rb_backref_get();
        struct re_registers *regs = RMATCH_REGS(match);

        pos = BEG(0);
        sep = rb_str_subseq(str, pos, END(0) - pos);
    }
    else {
        pos = rb_str_index(str, sep, 0);
        if (pos &lt; 0) goto failed;
    }
    return rb_ary_new3(3, rb_str_subseq(str, 0, pos),
                          sep,
                          rb_str_subseq(str, pos+RSTRING_LEN(sep),
                                             RSTRING_LEN(str)-pos-RSTRING_LEN(sep)));

  failed:
    return rb_ary_new3(3, str_duplicate(rb_cString, str), str_new_empty_String(str), str_new_empty_String(str));
}</pre> </div> <p>Returns a 3-element array of substrings of <code>self</code>.</p> <p>Matches a pattern against <code>self</code>, scanning from the beginning. The pattern is:</p> <ul>
<li> <p><code>string_or_regexp</code> itself, if it is a <a href="regexp.html"><code>Regexp</code></a>.</p> </li>
<li> <p><code>Regexp.quote(string_or_regexp)</code>, if <code>string_or_regexp</code> is a string.</p> </li>
</ul> <p>If the pattern is matched, returns pre-match, first-match, post-match:</p> <pre class="ruby" data-language="ruby">'hello'.partition('l')      # =&gt; ["he", "l", "lo"]
'hello'.partition('ll')     # =&gt; ["he", "ll", "o"]
'hello'.partition('h')      # =&gt; ["", "h", "ello"]
'hello'.partition('o')      # =&gt; ["hell", "o", ""]
'hello'.partition(/l+/)     #=&gt; ["he", "ll", "o"]
'hello'.partition('')       # =&gt; ["", "", "hello"]
'тест'.partition('т')       # =&gt; ["", "т", "ест"]
'こんにちは'.partition('に')  # =&gt; ["こん", "に", "ちは"]
</pre> <p>If the pattern is not matched, returns a copy of <code>self</code> and two empty strings:</p> <pre class="ruby" data-language="ruby">'hello'.partition('x') # =&gt; ["hello", "", ""]
</pre> <p>Related: <a href="string.html#method-i-rpartition"><code>String#rpartition</code></a>, <a href="string.html#method-i-split"><code>String#split</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-prepend"> <span class="method-callseq"> prepend(*other_strings) → string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="prepend-source"> <pre class="c" data-language="c">static VALUE
rb_str_prepend_multi(int argc, VALUE *argv, VALUE str)
{
    str_modifiable(str);

    if (argc == 1) {
        rb_str_update(str, 0L, 0L, argv[0]);
    }
    else if (argc &gt; 1) {
        int i;
        VALUE arg_str = rb_str_tmp_new(0);
        rb_enc_copy(arg_str, str);
        for (i = 0; i &lt; argc; i++) {
            rb_str_append(arg_str, argv[i]);
        }
        rb_str_update(str, 0L, 0L, arg_str);
    }

    return str;
}</pre> </div> <p>Prepends each string in <code>other_strings</code> to <code>self</code> and returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">s = 'foo'
s.prepend('bar', 'baz') # =&gt; "barbazfoo"
s                       # =&gt; "barbazfoo"
</pre> <p>Related: <a href="string.html#method-i-concat"><code>String#concat</code></a>.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-replace"> <span class="method-callseq"> replace(other_string) → self </span> </div> </div> <div class="method-description"> <p>Replaces the contents of <code>self</code> with the contents of <code>other_string</code>:</p> <pre class="ruby" data-language="ruby">s = 'foo'        # =&gt; "foo"
s.replace('bar') # =&gt; "bar"
</pre> </div> <div class="aliases"> Alias for: <a href="string.html#method-i-initialize_copy">initialize_copy</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-reverse"> <span class="method-callseq"> reverse → string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="reverse-source"> <pre class="c" data-language="c">static VALUE
rb_str_reverse(VALUE str)
{
    rb_encoding *enc;
    VALUE rev;
    char *s, *e, *p;
    int cr;

    if (RSTRING_LEN(str) &lt;= 1) return str_duplicate(rb_cString, str);
    enc = STR_ENC_GET(str);
    rev = rb_str_new(0, RSTRING_LEN(str));
    s = RSTRING_PTR(str); e = RSTRING_END(str);
    p = RSTRING_END(rev);
    cr = ENC_CODERANGE(str);

    if (RSTRING_LEN(str) &gt; 1) {
        if (single_byte_optimizable(str)) {
            while (s &lt; e) {
                *--p = *s++;
            }
        }
        else if (cr == ENC_CODERANGE_VALID) {
            while (s &lt; e) {
                int clen = rb_enc_fast_mbclen(s, e, enc);

                p -= clen;
                memcpy(p, s, clen);
                s += clen;
            }
        }
        else {
            cr = rb_enc_asciicompat(enc) ?
                ENC_CODERANGE_7BIT : ENC_CODERANGE_VALID;
            while (s &lt; e) {
                int clen = rb_enc_mbclen(s, e, enc);

                if (clen &gt; 1 || (*s &amp; 0x80)) cr = ENC_CODERANGE_UNKNOWN;
                p -= clen;
                memcpy(p, s, clen);
                s += clen;
            }
        }
    }
    STR_SET_LEN(rev, RSTRING_LEN(str));
    str_enc_copy_direct(rev, str);
    ENC_CODERANGE_SET(rev, cr);

    return rev;
}</pre> </div> <p>Returns a new string with the characters from <code>self</code> in reverse order.</p> <pre class="ruby" data-language="ruby">'stressed'.reverse # =&gt; "desserts"
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-reverse-21"> <span class="method-callseq"> reverse! → self </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="reverse-21-source"> <pre class="c" data-language="c">static VALUE
rb_str_reverse_bang(VALUE str)
{
    if (RSTRING_LEN(str) &gt; 1) {
        if (single_byte_optimizable(str)) {
            char *s, *e, c;

            str_modify_keep_cr(str);
            s = RSTRING_PTR(str);
            e = RSTRING_END(str) - 1;
            while (s &lt; e) {
                c = *s;
                *s++ = *e;
                *e-- = c;
            }
        }
        else {
            str_shared_replace(str, rb_str_reverse(str));
        }
    }
    else {
        str_modify_keep_cr(str);
    }
    return str;
}</pre> </div> <p>Returns <code>self</code> with its characters reversed:</p> <pre class="ruby" data-language="ruby">s = 'stressed'
s.reverse! # =&gt; "desserts"
s          # =&gt; "desserts"
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-rindex"> <span class="method-callseq"> rindex(substring, offset = self.length) → integer or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> rindex(regexp, offset = self.length) → integer or nil </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="rindex-source"> <pre class="c" data-language="c">static VALUE
rb_str_rindex_m(int argc, VALUE *argv, VALUE str)
{
    VALUE sub;
    VALUE initpos;
    rb_encoding *enc = STR_ENC_GET(str);
    long pos, len = str_strlen(str, enc); /* str's enc */

    if (rb_scan_args(argc, argv, "11", &amp;sub, &amp;initpos) == 2) {
        pos = NUM2LONG(initpos);
        if (pos &lt; 0 &amp;&amp; (pos += len) &lt; 0) {
            if (RB_TYPE_P(sub, T_REGEXP)) {
                rb_backref_set(Qnil);
            }
            return Qnil;
        }
        if (pos &gt; len) pos = len;
    }
    else {
        pos = len;
    }

    if (RB_TYPE_P(sub, T_REGEXP)) {
        /* enc = rb_enc_check(str, sub); */
        pos = str_offset(RSTRING_PTR(str), RSTRING_END(str), pos,
                         enc, single_byte_optimizable(str));

        if (rb_reg_search(sub, str, pos, 1) &gt;= 0) {
            VALUE match = rb_backref_get();
            struct re_registers *regs = RMATCH_REGS(match);
            pos = rb_str_sublen(str, BEG(0));
            return LONG2NUM(pos);
        }
    }
    else {
        StringValue(sub);
        pos = rb_str_rindex(str, sub, pos);
        if (pos &gt;= 0) {
            pos = rb_str_sublen(str, pos);
            return LONG2NUM(pos);
        }
    }
    return Qnil;
}</pre> </div> <p>Returns the <a href="integer.html"><code>Integer</code></a> index of the <em>last</em> occurrence of the given <code>substring</code>, or <code>nil</code> if none found:</p> <pre class="ruby" data-language="ruby">'foo'.rindex('f') # =&gt; 0
'foo'.rindex('o') # =&gt; 2
'foo'.rindex('oo') # =&gt; 1
'foo'.rindex('ooo') # =&gt; nil
</pre> <p>Returns the <a href="integer.html"><code>Integer</code></a> index of the <em>last</em> match for the given <a href="regexp.html"><code>Regexp</code></a> <code>regexp</code>, or <code>nil</code> if none found:</p> <pre class="ruby" data-language="ruby">'foo'.rindex(/f/) # =&gt; 0
'foo'.rindex(/o/) # =&gt; 2
'foo'.rindex(/oo/) # =&gt; 1
'foo'.rindex(/ooo/) # =&gt; nil
</pre> <p>The <em>last</em> match means starting at the possible last position, not the last of longest matches.</p> <pre class="ruby" data-language="ruby">'foo'.rindex(/o+/) # =&gt; 2
$~ #=&gt; #&lt;MatchData "o"&gt;
</pre> <p>To get the last longest match, needs to combine with negative lookbehind.</p> <pre class="ruby" data-language="ruby">'foo'.rindex(/(?&lt;!o)o+/) # =&gt; 1
$~ #=&gt; #&lt;MatchData "oo"&gt;
</pre> <p>Or <a href="string.html#method-i-index"><code>String#index</code></a> with negative lookforward.</p> <pre class="ruby" data-language="ruby">'foo'.index(/o+(?!.*o)/) # =&gt; 1
$~ #=&gt; #&lt;MatchData "oo"&gt;
</pre> <p><a href="integer.html"><code>Integer</code></a> argument <code>offset</code>, if given and non-negative, specifies the maximum starting position in the</p> <pre class="ruby" data-language="ruby">string to _end_ the search:

 'foo'.rindex('o', 0) # =&gt; nil
 'foo'.rindex('o', 1) # =&gt; 1
 'foo'.rindex('o', 2) # =&gt; 2
 'foo'.rindex('o', 3) # =&gt; 2
</pre> <p>If <code>offset</code> is a negative <a href="integer.html"><code>Integer</code></a>, the maximum starting position in the string to <em>end</em> the search is the sum of the string’s length and <code>offset</code>:</p> <pre class="ruby" data-language="ruby">'foo'.rindex('o', -1) # =&gt; 2
'foo'.rindex('o', -2) # =&gt; 1
'foo'.rindex('o', -3) # =&gt; nil
'foo'.rindex('o', -4) # =&gt; nil
</pre> <p>Related: <a href="string.html#method-i-index"><code>String#index</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-rjust"> <span class="method-callseq"> rjust(size, pad_string = ' ') → new_string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="rjust-source"> <pre class="c" data-language="c">static VALUE
rb_str_rjust(int argc, VALUE *argv, VALUE str)
{
    return rb_str_justify(argc, argv, str, 'r');
}</pre> </div> <p>Returns a right-justified copy of <code>self</code>.</p> <p>If integer argument <code>size</code> is greater than the size (in characters) of <code>self</code>, returns a new string of length <code>size</code> that is a copy of <code>self</code>, right justified and padded on the left with <code>pad_string</code>:</p> <pre class="ruby" data-language="ruby">'hello'.rjust(10)       # =&gt; "     hello"
'hello  '.rjust(10)     # =&gt; "   hello  "
'hello'.rjust(10, 'ab') # =&gt; "ababahello"
'тест'.rjust(10)        # =&gt; "      тест"
'こんにちは'.rjust(10)    # =&gt; "     こんにちは"
</pre> <p>If <code>size</code> is not greater than the size of <code>self</code>, returns a copy of <code>self</code>:</p> <pre class="ruby" data-language="ruby">'hello'.rjust(5, 'ab')  # =&gt; "hello"
'hello'.rjust(1, 'ab')  # =&gt; "hello"
</pre> <p>Related: <a href="string.html#method-i-ljust"><code>String#ljust</code></a>, <a href="string.html#method-i-center"><code>String#center</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-rpartition"> <span class="method-callseq"> rpartition(sep) → [head, match, tail] </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="rpartition-source"> <pre class="c" data-language="c">static VALUE
rb_str_rpartition(VALUE str, VALUE sep)
{
    long pos = RSTRING_LEN(str);

    sep = get_pat_quoted(sep, 0);
    if (RB_TYPE_P(sep, T_REGEXP)) {
        if (rb_reg_search(sep, str, pos, 1) &lt; 0) {
            goto failed;
        }
        VALUE match = rb_backref_get();
        struct re_registers *regs = RMATCH_REGS(match);

        pos = BEG(0);
        sep = rb_str_subseq(str, pos, END(0) - pos);
    }
    else {
        pos = rb_str_sublen(str, pos);
        pos = rb_str_rindex(str, sep, pos);
        if (pos &lt; 0) {
            goto failed;
        }
    }

    return rb_ary_new3(3, rb_str_subseq(str, 0, pos),
                          sep,
                          rb_str_subseq(str, pos+RSTRING_LEN(sep),
                                        RSTRING_LEN(str)-pos-RSTRING_LEN(sep)));
  failed:
    return rb_ary_new3(3, str_new_empty_String(str), str_new_empty_String(str), str_duplicate(rb_cString, str));
}</pre> </div> <p>Returns a 3-element array of substrings of <code>self</code>.</p> <p>Matches a pattern against <code>self</code>, scanning backwards from the end. The pattern is:</p> <ul>
<li> <p><code>string_or_regexp</code> itself, if it is a <a href="regexp.html"><code>Regexp</code></a>.</p> </li>
<li> <p><code>Regexp.quote(string_or_regexp)</code>, if <code>string_or_regexp</code> is a string.</p> </li>
</ul> <p>If the pattern is matched, returns pre-match, last-match, post-match:</p> <pre class="ruby" data-language="ruby">'hello'.rpartition('l')      # =&gt; ["hel", "l", "o"]
'hello'.rpartition('ll')     # =&gt; ["he", "ll", "o"]
'hello'.rpartition('h')      # =&gt; ["", "h", "ello"]
'hello'.rpartition('o')      # =&gt; ["hell", "o", ""]
'hello'.rpartition(/l+/)     # =&gt; ["hel", "l", "o"]
'hello'.rpartition('')       # =&gt; ["hello", "", ""]
'тест'.rpartition('т')       # =&gt; ["тес", "т", ""]
'こんにちは'.rpartition('に')  # =&gt; ["こん", "に", "ちは"]
</pre> <p>If the pattern is not matched, returns two empty strings and a copy of <code>self</code>:</p> <pre class="ruby" data-language="ruby">'hello'.rpartition('x') # =&gt; ["", "", "hello"]
</pre> <p>Related: <a href="string.html#method-i-partition"><code>String#partition</code></a>, <a href="string.html#method-i-split"><code>String#split</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-rstrip"> <span class="method-callseq"> rstrip → new_string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="rstrip-source"> <pre class="c" data-language="c">static VALUE
rb_str_rstrip(VALUE str)
{
    rb_encoding *enc;
    char *start;
    long olen, roffset;

    enc = STR_ENC_GET(str);
    RSTRING_GETMEM(str, start, olen);
    roffset = rstrip_offset(str, start, start+olen, enc);

    if (roffset &lt;= 0) return str_duplicate(rb_cString, str);
    return rb_str_subseq(str, 0, olen-roffset);
}</pre> </div> <p>Returns a copy of the receiver with trailing whitespace removed; see <a href="string.html#class-String-label-Whitespace+in+Strings">Whitespace in Strings</a>:</p> <pre class="ruby" data-language="ruby">whitespace = "\x00\t\n\v\f\r "
s = whitespace + 'abc' + whitespace
s        # =&gt; "\u0000\t\n\v\f\r abc\u0000\t\n\v\f\r "
s.rstrip # =&gt; "\u0000\t\n\v\f\r abc"
</pre> <p>Related: <a href="string.html#method-i-lstrip"><code>String#lstrip</code></a>, <a href="string.html#method-i-strip"><code>String#strip</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-rstrip-21"> <span class="method-callseq"> rstrip! → self or nil </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="rstrip-21-source"> <pre class="c" data-language="c">static VALUE
rb_str_rstrip_bang(VALUE str)
{
    rb_encoding *enc;
    char *start;
    long olen, roffset;

    str_modify_keep_cr(str);
    enc = STR_ENC_GET(str);
    RSTRING_GETMEM(str, start, olen);
    roffset = rstrip_offset(str, start, start+olen, enc);
    if (roffset &gt; 0) {
        long len = olen - roffset;

        STR_SET_LEN(str, len);
        TERM_FILL(start+len, rb_enc_mbminlen(enc));
        return str;
    }
    return Qnil;
}</pre> </div> <p>Like <a href="string.html#method-i-rstrip"><code>String#rstrip</code></a>, except that any modifications are made in <code>self</code>; returns <code>self</code> if any modification are made, <code>nil</code> otherwise.</p> <p>Related: <a href="string.html#method-i-lstrip-21"><code>String#lstrip!</code></a>, <a href="string.html#method-i-strip-21"><code>String#strip!</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-scan"> <span class="method-callseq"> scan(string_or_regexp) → array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> scan(string_or_regexp) {|matches| ... } → self </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="scan-source"> <pre class="c" data-language="c">static VALUE
rb_str_scan(VALUE str, VALUE pat)
{
    VALUE result;
    long start = 0;
    long last = -1, prev = 0;
    char *p = RSTRING_PTR(str); long len = RSTRING_LEN(str);

    pat = get_pat_quoted(pat, 1);
    mustnot_broken(str);
    if (!rb_block_given_p()) {
        VALUE ary = rb_ary_new();

        while (!NIL_P(result = scan_once(str, pat, &amp;start, 0))) {
            last = prev;
            prev = start;
            rb_ary_push(ary, result);
        }
        if (last &gt;= 0) rb_pat_search(pat, str, last, 1);
        else rb_backref_set(Qnil);
        return ary;
    }

    while (!NIL_P(result = scan_once(str, pat, &amp;start, 1))) {
        last = prev;
        prev = start;
        rb_yield(result);
        str_mod_check(str, p, len);
    }
    if (last &gt;= 0) rb_pat_search(pat, str, last, 1);
    return str;
}</pre> </div> <p>Matches a pattern against <code>self</code>; the pattern is:</p> <ul>
<li> <p><code>string_or_regexp</code> itself, if it is a <a href="regexp.html"><code>Regexp</code></a>.</p> </li>
<li> <p><code>Regexp.quote(string_or_regexp)</code>, if <code>string_or_regexp</code> is a string.</p> </li>
</ul> <p>Iterates through <code>self</code>, generating a collection of matching results:</p> <ul>
<li> <p>If the pattern contains no groups, each result is the matched string, <code>$&amp;</code>.</p> </li>
<li> <p>If the pattern contains groups, each result is an array containing one entry per group.</p> </li>
</ul> <p>With no block given, returns an array of the results:</p> <pre class="ruby" data-language="ruby">s = 'cruel world'
s.scan(/\w+/)      # =&gt; ["cruel", "world"]
s.scan(/.../)      # =&gt; ["cru", "el ", "wor"]
s.scan(/(...)/)    # =&gt; [["cru"], ["el "], ["wor"]]
s.scan(/(..)(..)/) # =&gt; [["cr", "ue"], ["l ", "wo"]]
</pre> <p>With a block given, calls the block with each result; returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">s.scan(/\w+/) {|w| print "&lt;&lt;#{w}&gt;&gt; " }
print "\n"
s.scan(/(.)(.)/) {|x,y| print y, x }
print "\n"
</pre> <p>Output:</p> <pre>&lt;&lt;cruel&gt;&gt; &lt;&lt;world&gt;&gt;
rceu lowlr</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-scrub"> <span class="method-callseq"> scrub(replacement_string = default_replacement) → new_string </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> scrub{|bytes| ... } → new_string </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="scrub-source"> <pre class="c" data-language="c">static VALUE
str_scrub(int argc, VALUE *argv, VALUE str)
{
    VALUE repl = argc ? (rb_check_arity(argc, 0, 1), argv[0]) : Qnil;
    VALUE new = rb_str_scrub(str, repl);
    return NIL_P(new) ? str_duplicate(rb_cString, str): new;
}</pre> </div> <p>Returns a copy of <code>self</code> with each invalid byte sequence replaced by the given <code>replacement_string</code>.</p> <p>With no block given and no argument, replaces each invalid sequence with the default replacement string (<code>"�"</code> for a Unicode encoding, <code>'?'</code> otherwise):</p> <pre class="ruby" data-language="ruby">s = "foo\x81\x81bar"
s.scrub # =&gt; "foo��bar"
</pre> <p>With no block given and argument <code>replacement_string</code> given, replaces each invalid sequence with that string:</p> <pre class="ruby" data-language="ruby">"foo\x81\x81bar".scrub('xyzzy') # =&gt; "fooxyzzyxyzzybar"
</pre> <p>With a block given, replaces each invalid sequence with the value of the block:</p> <pre class="ruby" data-language="ruby">"foo\x81\x81bar".scrub {|bytes| p bytes; 'XYZZY' }
# =&gt; "fooXYZZYXYZZYbar"
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">"\x81"
"\x81"
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-scrub-21"> <span class="method-callseq"> scrub! → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> scrub!(replacement_string = default_replacement) → self </span> </div> <div class="method-heading"> <span class="method-callseq"> scrub!{|bytes| ... } → self </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="scrub-21-source"> <pre class="c" data-language="c">static VALUE
str_scrub_bang(int argc, VALUE *argv, VALUE str)
{
    VALUE repl = argc ? (rb_check_arity(argc, 0, 1), argv[0]) : Qnil;
    VALUE new = rb_str_scrub(str, repl);
    if (!NIL_P(new)) rb_str_replace(str, new);
    return str;
}</pre> </div> <p>Like <a href="string.html#method-i-scrub"><code>String#scrub</code></a>, except that any replacements are made in <code>self</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-setbyte"> <span class="method-callseq"> setbyte(index, integer) → integer </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="setbyte-source"> <pre class="c" data-language="c">static VALUE
rb_str_setbyte(VALUE str, VALUE index, VALUE value)
{
    long pos = NUM2LONG(index);
    long len = RSTRING_LEN(str);
    char *ptr, *head, *left = 0;
    rb_encoding *enc;
    int cr = ENC_CODERANGE_UNKNOWN, width, nlen;

    if (pos &lt; -len || len &lt;= pos)
        rb_raise(rb_eIndexError, "index %ld out of string", pos);
    if (pos &lt; 0)
        pos += len;

    VALUE v = rb_to_int(value);
    VALUE w = rb_int_and(v, INT2FIX(0xff));
    char byte = (char)(NUM2INT(w) &amp; 0xFF);

    if (!str_independent(str))
        str_make_independent(str);
    enc = STR_ENC_GET(str);
    head = RSTRING_PTR(str);
    ptr = &amp;head[pos];
    if (!STR_EMBED_P(str)) {
        cr = ENC_CODERANGE(str);
        switch (cr) {
          case ENC_CODERANGE_7BIT:
            left = ptr;
            *ptr = byte;
            if (ISASCII(byte)) goto end;
            nlen = rb_enc_precise_mbclen(left, head+len, enc);
            if (!MBCLEN_CHARFOUND_P(nlen))
                ENC_CODERANGE_SET(str, ENC_CODERANGE_BROKEN);
            else
                ENC_CODERANGE_SET(str, ENC_CODERANGE_VALID);
            goto end;
          case ENC_CODERANGE_VALID:
            left = rb_enc_left_char_head(head, ptr, head+len, enc);
            width = rb_enc_precise_mbclen(left, head+len, enc);
            *ptr = byte;
            nlen = rb_enc_precise_mbclen(left, head+len, enc);
            if (!MBCLEN_CHARFOUND_P(nlen))
                ENC_CODERANGE_SET(str, ENC_CODERANGE_BROKEN);
            else if (MBCLEN_CHARFOUND_LEN(nlen) != width || ISASCII(byte))
                ENC_CODERANGE_CLEAR(str);
            goto end;
        }
    }
    ENC_CODERANGE_CLEAR(str);
    *ptr = byte;

  end:
    return value;
}</pre> </div> <p>Sets the byte at zero-based <code>index</code> to <code>integer</code>; returns <code>integer</code>:</p> <pre class="ruby" data-language="ruby">s = 'abcde'      # =&gt; "abcde"
s.setbyte(0, 98) # =&gt; 98
s                # =&gt; "bbcde"
</pre> <p>Related: <a href="string.html#method-i-getbyte"><code>String#getbyte</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-shellescape"> <span class="method-callseq"> shellescape → string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="shellescape-source"> <pre class="ruby" data-language="ruby"># File lib/shellwords.rb, line 226
def shellescape
  Shellwords.escape(self)
end</pre> </div> <p>Escapes <code>str</code> so that it can be safely used in a Bourne shell command line.</p> <p>See <a href="shellwords.html#method-c-shellescape"><code>Shellwords.shellescape</code></a> for details.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-shellsplit"> <span class="method-callseq"> shellsplit → array </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="shellsplit-source"> <pre class="ruby" data-language="ruby"># File lib/shellwords.rb, line 215
def shellsplit
  Shellwords.split(self)
end</pre> </div> <p>Splits <code>str</code> into an array of tokens in the same way the UNIX Bourne shell does.</p> <p>See <a href="shellwords.html#method-c-shellsplit"><code>Shellwords.shellsplit</code></a> for details.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-size"> <span class="method-name">size</span> </div> </div> <div class="aliases"> Alias for: <a href="string.html#method-i-length">length</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-slice"> <span class="method-name">slice</span> </div> </div> <div class="aliases"> Alias for: <a href="string.html#method-i-5B-5D">[]</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-slice-21"> <span class="method-callseq"> slice!(index) → new_string or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> slice!(start, length) → new_string or nil </span> </div> <div class="method-heading"> <span class="method-callseq"> slice!(range) → new_string or nil </span> </div> <div class="method-heading"> <span class="method-callseq"> slice!(regexp, capture = 0) → new_string or nil </span> </div> <div class="method-heading"> <span class="method-callseq"> slice!(substring) → new_string or nil </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="slice-21-source"> <pre class="c" data-language="c">static VALUE
rb_str_slice_bang(int argc, VALUE *argv, VALUE str)
{
    VALUE result = Qnil;
    VALUE indx;
    long beg, len = 1;
    char *p;

    rb_check_arity(argc, 1, 2);
    str_modify_keep_cr(str);
    indx = argv[0];
    if (RB_TYPE_P(indx, T_REGEXP)) {
        if (rb_reg_search(indx, str, 0, 0) &lt; 0) return Qnil;
        VALUE match = rb_backref_get();
        struct re_registers *regs = RMATCH_REGS(match);
        int nth = 0;
        if (argc &gt; 1 &amp;&amp; (nth = rb_reg_backref_number(match, argv[1])) &lt; 0) {
            if ((nth += regs-&gt;num_regs) &lt;= 0) return Qnil;
        }
        else if (nth &gt;= regs-&gt;num_regs) return Qnil;
        beg = BEG(nth);
        len = END(nth) - beg;
        goto subseq;
    }
    else if (argc == 2) {
        beg = NUM2LONG(indx);
        len = NUM2LONG(argv[1]);
        goto num_index;
    }
    else if (FIXNUM_P(indx)) {
        beg = FIX2LONG(indx);
        if (!(p = rb_str_subpos(str, beg, &amp;len))) return Qnil;
        if (!len) return Qnil;
        beg = p - RSTRING_PTR(str);
        goto subseq;
    }
    else if (RB_TYPE_P(indx, T_STRING)) {
        beg = rb_str_index(str, indx, 0);
        if (beg == -1) return Qnil;
        len = RSTRING_LEN(indx);
        result = str_duplicate(rb_cString, indx);
        goto squash;
    }
    else {
        switch (rb_range_beg_len(indx, &amp;beg, &amp;len, str_strlen(str, NULL), 0)) {
          case Qnil:
            return Qnil;
          case Qfalse:
            beg = NUM2LONG(indx);
            if (!(p = rb_str_subpos(str, beg, &amp;len))) return Qnil;
            if (!len) return Qnil;
            beg = p - RSTRING_PTR(str);
            goto subseq;
          default:
            goto num_index;
        }
    }

  num_index:
    if (!(p = rb_str_subpos(str, beg, &amp;len))) return Qnil;
    beg = p - RSTRING_PTR(str);

  subseq:
    result = rb_str_new(RSTRING_PTR(str)+beg, len);
    rb_enc_cr_str_copy_for_substr(result, str);

  squash:
    if (len &gt; 0) {
        if (beg == 0) {
            rb_str_drop_bytes(str, len);
        }
        else {
            char *sptr = RSTRING_PTR(str);
            long slen = RSTRING_LEN(str);
            if (beg + len &gt; slen) /* pathological check */
                len = slen - beg;
            memmove(sptr + beg,
                    sptr + beg + len,
                    slen - (beg + len));
            slen -= len;
            STR_SET_LEN(str, slen);
            TERM_FILL(&amp;sptr[slen], TERM_LEN(str));
        }
    }
    return result;
}</pre> </div> <p>Removes and returns the substring of <code>self</code> specified by the arguments. See <a href="string.html#class-String-label-String+Slices">String Slices</a>.</p> <p>A few examples:</p> <pre class="ruby" data-language="ruby">string = "This is a string"
string.slice!(2)        #=&gt; "i"
string.slice!(3..6)     #=&gt; " is "
string.slice!(/s.*t/)   #=&gt; "sa st"
string.slice!("r")      #=&gt; "r"
string                  #=&gt; "Thing"
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-split"> <span class="method-callseq"> split(field_sep = $;, limit = nil) → array </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> split(field_sep = $;, limit = nil) {|substring| ... } → self </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="split-source"> <pre class="c" data-language="c">static VALUE
rb_str_split_m(int argc, VALUE *argv, VALUE str)
{
    rb_encoding *enc;
    VALUE spat;
    VALUE limit;
    split_type_t split_type;
    long beg, end, i = 0, empty_count = -1;
    int lim = 0;
    VALUE result, tmp;

    result = rb_block_given_p() ? Qfalse : Qnil;
    if (rb_scan_args(argc, argv, "02", &amp;spat, &amp;limit) == 2) {
        lim = NUM2INT(limit);
        if (lim &lt;= 0) limit = Qnil;
        else if (lim == 1) {
            if (RSTRING_LEN(str) == 0)
                return result ? rb_ary_new2(0) : str;
            tmp = str_duplicate(rb_cString, str);
            if (!result) {
                rb_yield(tmp);
                return str;
            }
            return rb_ary_new3(1, tmp);
        }
        i = 1;
    }
    if (NIL_P(limit) &amp;&amp; !lim) empty_count = 0;

    enc = STR_ENC_GET(str);
    split_type = SPLIT_TYPE_REGEXP;
    if (!NIL_P(spat)) {
        spat = get_pat_quoted(spat, 0);
    }
    else if (NIL_P(spat = rb_fs)) {
        split_type = SPLIT_TYPE_AWK;
    }
    else if (!(spat = rb_fs_check(spat))) {
        rb_raise(rb_eTypeError, "value of $; must be String or Regexp");
    }
    else {
        rb_category_warn(RB_WARN_CATEGORY_DEPRECATED, "$; is set to non-nil value");
    }
    if (split_type != SPLIT_TYPE_AWK) {
        switch (BUILTIN_TYPE(spat)) {
          case T_REGEXP:
            rb_reg_options(spat); /* check if uninitialized */
            tmp = RREGEXP_SRC(spat);
            split_type = literal_split_pattern(tmp, SPLIT_TYPE_REGEXP);
            if (split_type == SPLIT_TYPE_AWK) {
                spat = tmp;
                split_type = SPLIT_TYPE_STRING;
            }
            break;

          case T_STRING:
            mustnot_broken(spat);
            split_type = literal_split_pattern(spat, SPLIT_TYPE_STRING);
            break;

          default:
            UNREACHABLE_RETURN(Qnil);
        }
    }

#define SPLIT_STR(beg, len) (empty_count = split_string(result, str, beg, len, empty_count))

    beg = 0;
    char *ptr = RSTRING_PTR(str);
    char *eptr = RSTRING_END(str);
    if (split_type == SPLIT_TYPE_AWK) {
        char *bptr = ptr;
        int skip = 1;
        unsigned int c;

        if (result) result = rb_ary_new();
        end = beg;
        if (is_ascii_string(str)) {
            while (ptr &lt; eptr) {
                c = (unsigned char)*ptr++;
                if (skip) {
                    if (ascii_isspace(c)) {
                        beg = ptr - bptr;
                    }
                    else {
                        end = ptr - bptr;
                        skip = 0;
                        if (!NIL_P(limit) &amp;&amp; lim &lt;= i) break;
                    }
                }
                else if (ascii_isspace(c)) {
                    SPLIT_STR(beg, end-beg);
                    skip = 1;
                    beg = ptr - bptr;
                    if (!NIL_P(limit)) ++i;
                }
                else {
                    end = ptr - bptr;
                }
            }
        }
        else {
            while (ptr &lt; eptr) {
                int n;

                c = rb_enc_codepoint_len(ptr, eptr, &amp;n, enc);
                ptr += n;
                if (skip) {
                    if (rb_isspace(c)) {
                        beg = ptr - bptr;
                    }
                    else {
                        end = ptr - bptr;
                        skip = 0;
                        if (!NIL_P(limit) &amp;&amp; lim &lt;= i) break;
                    }
                }
                else if (rb_isspace(c)) {
                    SPLIT_STR(beg, end-beg);
                    skip = 1;
                    beg = ptr - bptr;
                    if (!NIL_P(limit)) ++i;
                }
                else {
                    end = ptr - bptr;
                }
            }
        }
    }
    else if (split_type == SPLIT_TYPE_STRING) {
        char *str_start = ptr;
        char *substr_start = ptr;
        char *sptr = RSTRING_PTR(spat);
        long slen = RSTRING_LEN(spat);

        if (result) result = rb_ary_new();
        mustnot_broken(str);
        enc = rb_enc_check(str, spat);
        while (ptr &lt; eptr &amp;&amp;
               (end = rb_memsearch(sptr, slen, ptr, eptr - ptr, enc)) &gt;= 0) {
            /* Check we are at the start of a char */
            char *t = rb_enc_right_char_head(ptr, ptr + end, eptr, enc);
            if (t != ptr + end) {
                ptr = t;
                continue;
            }
            SPLIT_STR(substr_start - str_start, (ptr+end) - substr_start);
            ptr += end + slen;
            substr_start = ptr;
            if (!NIL_P(limit) &amp;&amp; lim &lt;= ++i) break;
        }
        beg = ptr - str_start;
    }
    else if (split_type == SPLIT_TYPE_CHARS) {
        char *str_start = ptr;
        int n;

        if (result) result = rb_ary_new_capa(RSTRING_LEN(str));
        mustnot_broken(str);
        enc = rb_enc_get(str);
        while (ptr &lt; eptr &amp;&amp;
               (n = rb_enc_precise_mbclen(ptr, eptr, enc)) &gt; 0) {
            SPLIT_STR(ptr - str_start, n);
            ptr += n;
            if (!NIL_P(limit) &amp;&amp; lim &lt;= ++i) break;
        }
        beg = ptr - str_start;
    }
    else {
        if (result) result = rb_ary_new();
        long len = RSTRING_LEN(str);
        long start = beg;
        long idx;
        int last_null = 0;
        struct re_registers *regs;
        VALUE match = 0;

        for (; rb_reg_search(spat, str, start, 0) &gt;= 0;
             (match ? (rb_match_unbusy(match), rb_backref_set(match)) : (void)0)) {
            match = rb_backref_get();
            if (!result) rb_match_busy(match);
            regs = RMATCH_REGS(match);
            end = BEG(0);
            if (start == end &amp;&amp; BEG(0) == END(0)) {
                if (!ptr) {
                    SPLIT_STR(0, 0);
                    break;
                }
                else if (last_null == 1) {
                    SPLIT_STR(beg, rb_enc_fast_mbclen(ptr+beg, eptr, enc));
                    beg = start;
                }
                else {
                    if (start == len)
                        start++;
                    else
                        start += rb_enc_fast_mbclen(ptr+start,eptr,enc);
                    last_null = 1;
                    continue;
                }
            }
            else {
                SPLIT_STR(beg, end-beg);
                beg = start = END(0);
            }
            last_null = 0;

            for (idx=1; idx &lt; regs-&gt;num_regs; idx++) {
                if (BEG(idx) == -1) continue;
                SPLIT_STR(BEG(idx), END(idx)-BEG(idx));
            }
            if (!NIL_P(limit) &amp;&amp; lim &lt;= ++i) break;
        }
        if (match) rb_match_unbusy(match);
    }
    if (RSTRING_LEN(str) &gt; 0 &amp;&amp; (!NIL_P(limit) || RSTRING_LEN(str) &gt; beg || lim &lt; 0)) {
        SPLIT_STR(beg, RSTRING_LEN(str)-beg);
    }

    return result ? result : str;
}</pre> </div> <p>Returns an array of substrings of <code>self</code> that are the result of splitting <code>self</code> at each occurrence of the given field separator <code>field_sep</code>.</p> <p>When <code>field_sep</code> is <code>$;</code>:</p> <ul>
<li> <p>If <code>$;</code> is <code>nil</code> (its default value), the split occurs just as if <code>field_sep</code> were given as a space character (see below).</p> </li>
<li> <p>If <code>$;</code> is a string, the split ocurs just as if <code>field_sep</code> were given as that string (see below).</p> </li>
</ul> <p>When <code>field_sep</code> is <code>' '</code> and <code>limit</code> is <code>nil</code>, the split occurs at each sequence of whitespace:</p> <pre class="ruby" data-language="ruby">'abc def ghi'.split(' ')         =&gt; ["abc", "def", "ghi"]
"abc \n\tdef\t\n  ghi".split(' ') # =&gt; ["abc", "def", "ghi"]
'abc  def   ghi'.split(' ')      =&gt; ["abc", "def", "ghi"]
''.split(' ')                    =&gt; []
</pre> <p>When <code>field_sep</code> is a string different from <code>' '</code> and <code>limit</code> is <code>nil</code>, the split occurs at each occurrence of <code>field_sep</code>; trailing empty substrings are not returned:</p> <pre class="ruby" data-language="ruby">'abracadabra'.split('ab')  =&gt; ["", "racad", "ra"]
'aaabcdaaa'.split('a')     =&gt; ["", "", "", "bcd"]
''.split('a')              =&gt; []
'3.14159'.split('1')       =&gt; ["3.", "4", "59"]
'!@#$%^$&amp;*($)_+'.split('$') # =&gt; ["!@#", "%^", "&amp;*(", ")_+"]
'тест'.split('т')          =&gt; ["", "ес"]
'こんにちは'.split('に')     =&gt; ["こん", "ちは"]
</pre> <p>When <code>field_sep</code> is a <a href="regexp.html"><code>Regexp</code></a> and <code>limit</code> is <code>nil</code>, the split occurs at each occurrence of a match; trailing empty substrings are not returned:</p> <pre class="ruby" data-language="ruby">'abracadabra'.split(/ab/) # =&gt; ["", "racad", "ra"]
'aaabcdaaa'.split(/a/)   =&gt; ["", "", "", "bcd"]
'aaabcdaaa'.split(//)    =&gt; ["a", "a", "a", "b", "c", "d", "a", "a", "a"]
'1 + 1 == 2'.split(/\W+/) # =&gt; ["1", "1", "2"]
</pre> <p>If the Regexp contains groups, their matches are also included in the returned array:</p> <pre class="ruby" data-language="ruby">'1:2:3'.split(/(:)()()/, 2) # =&gt; ["1", ":", "", "", "2:3"]
</pre> <p>As seen above, if <code>limit</code> is <code>nil</code>, trailing empty substrings are not returned; the same is true if <code>limit</code> is zero:</p> <pre class="ruby" data-language="ruby">'aaabcdaaa'.split('a')   =&gt; ["", "", "", "bcd"]
'aaabcdaaa'.split('a', 0) # =&gt; ["", "", "", "bcd"]
</pre> <p>If <code>limit</code> is positive integer <code>n</code>, no more than <code>n - 1-</code> splits occur, so that at most <code>n</code> substrings are returned, and trailing empty substrings are included:</p> <pre class="ruby" data-language="ruby">'aaabcdaaa'.split('a', 1) # =&gt; ["aaabcdaaa"]
'aaabcdaaa'.split('a', 2) # =&gt; ["", "aabcdaaa"]
'aaabcdaaa'.split('a', 5) # =&gt; ["", "", "", "bcd", "aa"]
'aaabcdaaa'.split('a', 7) # =&gt; ["", "", "", "bcd", "", "", ""]
'aaabcdaaa'.split('a', 8) # =&gt; ["", "", "", "bcd", "", "", ""]
</pre> <p>Note that if <code>field_sep</code> is a Regexp containing groups, their matches are in the returned array, but do not count toward the limit.</p> <p>If <code>limit</code> is negative, it behaves the same as if <code>limit</code> was <code>nil</code>, meaning that there is no limit, and trailing empty substrings are included:</p> <pre class="ruby" data-language="ruby">'aaabcdaaa'.split('a', -1) # =&gt; ["", "", "", "bcd", "", "", ""]
</pre> <p>If a block is given, it is called with each substring:</p> <pre class="ruby" data-language="ruby">'abc def ghi'.split(' ') {|substring| p substring }
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">"abc"
"def"
"ghi"
</pre> <p>Related: <a href="string.html#method-i-partition"><code>String#partition</code></a>, <a href="string.html#method-i-rpartition"><code>String#rpartition</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-squeeze"> <span class="method-callseq"> squeeze(*selectors) → new_string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="squeeze-source"> <pre class="c" data-language="c">static VALUE
rb_str_squeeze(int argc, VALUE *argv, VALUE str)
{
    str = str_duplicate(rb_cString, str);
    rb_str_squeeze_bang(argc, argv, str);
    return str;
}</pre> </div> <p>Returns a copy of <code>self</code> with characters specified by <code>selectors</code> “squeezed” (see <a href="character_selectors_rdoc.html#label-Multiple+Character+Selectors">Multiple Character Selectors</a>):</p> <p>“Squeezed” means that each multiple-character run of a selected character is squeezed down to a single character; with no arguments given, squeezes all characters:</p> <pre class="ruby" data-language="ruby">"yellow moon".squeeze                  #=&gt; "yelow mon"
"  now   is  the".squeeze(" ")         #=&gt; " now is the"
"putters shoot balls".squeeze("m-z")   #=&gt; "puters shot balls"
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-squeeze-21"> <span class="method-callseq"> squeeze!(*selectors) → self or nil </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="squeeze-21-source"> <pre class="c" data-language="c">static VALUE
rb_str_squeeze_bang(int argc, VALUE *argv, VALUE str)
{
    char squeez[TR_TABLE_SIZE];
    rb_encoding *enc = 0;
    VALUE del = 0, nodel = 0;
    unsigned char *s, *send, *t;
    int i, modify = 0;
    int ascompat, singlebyte = single_byte_optimizable(str);
    unsigned int save;

    if (argc == 0) {
        enc = STR_ENC_GET(str);
    }
    else {
        for (i=0; i&lt;argc; i++) {
            VALUE s = argv[i];

            StringValue(s);
            enc = rb_enc_check(str, s);
            if (singlebyte &amp;&amp; !single_byte_optimizable(s))
                singlebyte = 0;
            tr_setup_table(s, squeez, i==0, &amp;del, &amp;nodel, enc);
        }
    }

    str_modify_keep_cr(str);
    s = t = (unsigned char *)RSTRING_PTR(str);
    if (!s || RSTRING_LEN(str) == 0) return Qnil;
    send = (unsigned char *)RSTRING_END(str);
    save = -1;
    ascompat = rb_enc_asciicompat(enc);

    if (singlebyte) {
        while (s &lt; send) {
            unsigned int c = *s++;
            if (c != save || (argc &gt; 0 &amp;&amp; !squeez[c])) {
                *t++ = save = c;
            }
        }
    }
    else {
        while (s &lt; send) {
            unsigned int c;
            int clen;

            if (ascompat &amp;&amp; (c = *s) &lt; 0x80) {
                if (c != save || (argc &gt; 0 &amp;&amp; !squeez[c])) {
                    *t++ = save = c;
                }
                s++;
            }
            else {
                c = rb_enc_codepoint_len((char *)s, (char *)send, &amp;clen, enc);

                if (c != save || (argc &gt; 0 &amp;&amp; !tr_find(c, squeez, del, nodel))) {
                    if (t != s) rb_enc_mbcput(c, t, enc);
                    save = c;
                    t += clen;
                }
                s += clen;
            }
        }
    }

    TERM_FILL((char *)t, TERM_LEN(str));
    if ((char *)t - RSTRING_PTR(str) != RSTRING_LEN(str)) {
        STR_SET_LEN(str, (char *)t - RSTRING_PTR(str));
        modify = 1;
    }

    if (modify) return str;
    return Qnil;
}</pre> </div> <p>Like <a href="string.html#method-i-squeeze"><code>String#squeeze</code></a>, but modifies <code>self</code> in place. Returns <code>self</code> if any changes were made, <code>nil</code> otherwise.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-start_with-3F"> <span class="method-callseq"> start_with?(*string_or_regexp) → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="start_with-3F-source"> <pre class="c" data-language="c">static VALUE
rb_str_start_with(int argc, VALUE *argv, VALUE str)
{
    int i;

    for (i=0; i&lt;argc; i++) {
        VALUE tmp = argv[i];
        if (RB_TYPE_P(tmp, T_REGEXP)) {
            if (rb_reg_start_with_p(tmp, str))
                return Qtrue;
        }
        else {
            const char *p, *s, *e;
            long slen, tlen;
            rb_encoding *enc;

            StringValue(tmp);
            enc = rb_enc_check(str, tmp);
            if ((tlen = RSTRING_LEN(tmp)) == 0) return Qtrue;
            if ((slen = RSTRING_LEN(str)) &lt; tlen) continue;
            p = RSTRING_PTR(str);
            e = p + slen;
            s = p + tlen;
            if (!at_char_right_boundary(p, s, e, enc))
                continue;
            if (memcmp(p, RSTRING_PTR(tmp), tlen) == 0)
                return Qtrue;
        }
    }
    return Qfalse;
}</pre> </div> <p>Returns whether <code>self</code> starts with any of the given <code>string_or_regexp</code>.</p> <p>Matches patterns against the beginning of <code>self</code>. For each given <code>string_or_regexp</code>, the pattern is:</p> <ul>
<li> <p><code>string_or_regexp</code> itself, if it is a <a href="regexp.html"><code>Regexp</code></a>.</p> </li>
<li> <p><code>Regexp.quote(string_or_regexp)</code>, if <code>string_or_regexp</code> is a string.</p> </li>
</ul> <p>Returns <code>true</code> if any pattern matches the beginning, <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">'hello'.start_with?('hell')               # =&gt; true
'hello'.start_with?(/H/i)                 # =&gt; true
'hello'.start_with?('heaven', 'hell')     # =&gt; true
'hello'.start_with?('heaven', 'paradise') # =&gt; false
'тест'.start_with?('т')                   # =&gt; true
'こんにちは'.start_with?('こ')              # =&gt; true
</pre> <p>Related: <a href="string.html#method-i-end_with-3F"><code>String#end_with?</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-strip"> <span class="method-callseq"> strip → new_string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="strip-source"> <pre class="c" data-language="c">static VALUE
rb_str_strip(VALUE str)
{
    char *start;
    long olen, loffset, roffset;
    rb_encoding *enc = STR_ENC_GET(str);

    RSTRING_GETMEM(str, start, olen);
    loffset = lstrip_offset(str, start, start+olen, enc);
    roffset = rstrip_offset(str, start+loffset, start+olen, enc);

    if (loffset &lt;= 0 &amp;&amp; roffset &lt;= 0) return str_duplicate(rb_cString, str);
    return rb_str_subseq(str, loffset, olen-loffset-roffset);
}</pre> </div> <p>Returns a copy of the receiver with leading and trailing whitespace removed; see <a href="string.html#class-String-label-Whitespace+in+Strings">Whitespace in Strings</a>:</p> <pre class="ruby" data-language="ruby">whitespace = "\x00\t\n\v\f\r "
s = whitespace + 'abc' + whitespace
s       # =&gt; "\u0000\t\n\v\f\r abc\u0000\t\n\v\f\r "
s.strip # =&gt; "abc"
</pre> <p>Related: <a href="string.html#method-i-lstrip"><code>String#lstrip</code></a>, <a href="string.html#method-i-rstrip"><code>String#rstrip</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-strip-21"> <span class="method-callseq"> strip! → self or nil </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="strip-21-source"> <pre class="c" data-language="c">static VALUE
rb_str_strip_bang(VALUE str)
{
    char *start;
    long olen, loffset, roffset;
    rb_encoding *enc;

    str_modify_keep_cr(str);
    enc = STR_ENC_GET(str);
    RSTRING_GETMEM(str, start, olen);
    loffset = lstrip_offset(str, start, start+olen, enc);
    roffset = rstrip_offset(str, start+loffset, start+olen, enc);

    if (loffset &gt; 0 || roffset &gt; 0) {
        long len = olen-roffset;
        if (loffset &gt; 0) {
            len -= loffset;
            memmove(start, start + loffset, len);
        }
        STR_SET_LEN(str, len);
        TERM_FILL(start+len, rb_enc_mbminlen(enc));
        return str;
    }
    return Qnil;
}</pre> </div> <p>Like <a href="string.html#method-i-strip"><code>String#strip</code></a>, except that any modifications are made in <code>self</code>; returns <code>self</code> if any modification are made, <code>nil</code> otherwise.</p> <p>Related: <a href="string.html#method-i-lstrip-21"><code>String#lstrip!</code></a>, <a href="string.html#method-i-strip-21"><code>String#strip!</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-sub"> <span class="method-callseq"> sub(pattern, replacement) → new_string </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> sub(pattern) {|match| ... } → new_string </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="sub-source"> <pre class="c" data-language="c">static VALUE
rb_str_sub(int argc, VALUE *argv, VALUE str)
{
    str = str_duplicate(rb_cString, str);
    rb_str_sub_bang(argc, argv, str);
    return str;
}</pre> </div> <p>Returns a copy of <code>self</code> with only the first occurrence (not all occurrences) of the given <code>pattern</code> replaced.</p> <p>See <a href="string.html#class-String-label-Substitution+Methods">Substitution Methods</a>.</p> <p>Related: <a href="string.html#method-i-sub-21"><code>String#sub!</code></a>, <a href="string.html#method-i-gsub"><code>String#gsub</code></a>, <a href="string.html#method-i-gsub-21"><code>String#gsub!</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-sub-21"> <span class="method-callseq"> sub!(pattern, replacement) → self or nil </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> sub!(pattern) {|match| ... } → self or nil </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="sub-21-source"> <pre class="c" data-language="c">static VALUE
rb_str_sub_bang(int argc, VALUE *argv, VALUE str)
{
    VALUE pat, repl, hash = Qnil;
    int iter = 0;
    long plen;
    int min_arity = rb_block_given_p() ? 1 : 2;
    long beg;

    rb_check_arity(argc, min_arity, 2);
    if (argc == 1) {
        iter = 1;
    }
    else {
        repl = argv[1];
        hash = rb_check_hash_type(argv[1]);
        if (NIL_P(hash)) {
            StringValue(repl);
        }
    }

    pat = get_pat_quoted(argv[0], 1);

    str_modifiable(str);
    beg = rb_pat_search(pat, str, 0, 1);
    if (beg &gt;= 0) {
        rb_encoding *enc;
        int cr = ENC_CODERANGE(str);
        long beg0, end0;
        VALUE match, match0 = Qnil;
        struct re_registers *regs;
        char *p, *rp;
        long len, rlen;

        match = rb_backref_get();
        regs = RMATCH_REGS(match);
        if (RB_TYPE_P(pat, T_STRING)) {
            beg0 = beg;
            end0 = beg0 + RSTRING_LEN(pat);
            match0 = pat;
        }
        else {
            beg0 = BEG(0);
            end0 = END(0);
            if (iter) match0 = rb_reg_nth_match(0, match);
        }

        if (iter || !NIL_P(hash)) {
            p = RSTRING_PTR(str); len = RSTRING_LEN(str);

            if (iter) {
                repl = rb_obj_as_string(rb_yield(match0));
            }
            else {
                repl = rb_hash_aref(hash, rb_str_subseq(str, beg0, end0 - beg0));
                repl = rb_obj_as_string(repl);
            }
            str_mod_check(str, p, len);
            rb_check_frozen(str);
        }
        else {
            repl = rb_reg_regsub(repl, str, regs, RB_TYPE_P(pat, T_STRING) ? Qnil : pat);
        }

        enc = rb_enc_compatible(str, repl);
        if (!enc) {
            rb_encoding *str_enc = STR_ENC_GET(str);
            p = RSTRING_PTR(str); len = RSTRING_LEN(str);
            if (coderange_scan(p, beg0, str_enc) != ENC_CODERANGE_7BIT ||
                coderange_scan(p+end0, len-end0, str_enc) != ENC_CODERANGE_7BIT) {
                rb_raise(rb_eEncCompatError, "incompatible character encodings: %s and %s",
                         rb_enc_name(str_enc),
                         rb_enc_name(STR_ENC_GET(repl)));
            }
            enc = STR_ENC_GET(repl);
        }
        rb_str_modify(str);
        rb_enc_associate(str, enc);
        if (ENC_CODERANGE_UNKNOWN &lt; cr &amp;&amp; cr &lt; ENC_CODERANGE_BROKEN) {
            int cr2 = ENC_CODERANGE(repl);
            if (cr2 == ENC_CODERANGE_BROKEN ||
                (cr == ENC_CODERANGE_VALID &amp;&amp; cr2 == ENC_CODERANGE_7BIT))
                cr = ENC_CODERANGE_UNKNOWN;
            else
                cr = cr2;
        }
        plen = end0 - beg0;
        rlen = RSTRING_LEN(repl);
        len = RSTRING_LEN(str);
        if (rlen &gt; plen) {
            RESIZE_CAPA(str, len + rlen - plen);
        }
        p = RSTRING_PTR(str);
        if (rlen != plen) {
            memmove(p + beg0 + rlen, p + beg0 + plen, len - beg0 - plen);
        }
        rp = RSTRING_PTR(repl);
        memmove(p + beg0, rp, rlen);
        len += rlen - plen;
        STR_SET_LEN(str, len);
        TERM_FILL(&amp;RSTRING_PTR(str)[len], TERM_LEN(str));
        ENC_CODERANGE_SET(str, cr);

        RB_GC_GUARD(match);

        return str;
    }
    return Qnil;
}</pre> </div> <p>Returns <code>self</code> with only the first occurrence (not all occurrences) of the given <code>pattern</code> replaced.</p> <p>See <a href="string.html#class-String-label-Substitution+Methods">Substitution Methods</a>.</p> <p>Related: <a href="string.html#method-i-sub"><code>String#sub</code></a>, <a href="string.html#method-i-gsub"><code>String#gsub</code></a>, <a href="string.html#method-i-gsub-21"><code>String#gsub!</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-succ"> <span class="method-callseq"> succ → new_str </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="succ-source"> <pre class="c" data-language="c">VALUE
rb_str_succ(VALUE orig)
{
    VALUE str;
    str = rb_str_new(RSTRING_PTR(orig), RSTRING_LEN(orig));
    rb_enc_cr_str_copy_for_substr(str, orig);
    return str_succ(str);
}</pre> </div> <p>Returns the successor to <code>self</code>. The successor is calculated by incrementing characters.</p> <p>The first character to be incremented is the rightmost alphanumeric: or, if no alphanumerics, the rightmost character:</p> <pre class="ruby" data-language="ruby">'THX1138'.succ # =&gt; "THX1139"
'&lt;&lt;koala&gt;&gt;'.succ # =&gt; "&lt;&lt;koalb&gt;&gt;"
'***'.succ # =&gt; '**+'
</pre> <p>The successor to a digit is another digit, “carrying” to the next-left character for a “rollover” from 9 to 0, and prepending another digit if necessary:</p> <pre class="ruby" data-language="ruby">'00'.succ # =&gt; "01"
'09'.succ # =&gt; "10"
'99'.succ # =&gt; "100"
</pre> <p>The successor to a letter is another letter of the same case, carrying to the next-left character for a rollover, and prepending another same-case letter if necessary:</p> <pre class="ruby" data-language="ruby">'aa'.succ # =&gt; "ab"
'az'.succ # =&gt; "ba"
'zz'.succ # =&gt; "aaa"
'AA'.succ # =&gt; "AB"
'AZ'.succ # =&gt; "BA"
'ZZ'.succ # =&gt; "AAA"
</pre> <p>The successor to a non-alphanumeric character is the next character in the underlying character set’s collating sequence, carrying to the next-left character for a rollover, and prepending another character if necessary:</p> <pre class="ruby" data-language="ruby">s = 0.chr * 3
s # =&gt; "\x00\x00\x00"
s.succ # =&gt; "\x00\x00\x01"
s = 255.chr * 3
s # =&gt; "\xFF\xFF\xFF"
s.succ # =&gt; "\x01\x00\x00\x00"
</pre> <p>Carrying can occur between and among mixtures of alphanumeric characters:</p> <pre class="ruby" data-language="ruby">s = 'zz99zz99'
s.succ # =&gt; "aaa00aa00"
s = '99zz99zz'
s.succ # =&gt; "100aa00aa"
</pre> <p>The successor to an empty String is a new empty String:</p> <pre class="ruby" data-language="ruby">''.succ # =&gt; ""
</pre>  </div> <div class="aliases"> Also aliased as: <a href="string.html#method-i-next">next</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-succ-21"> <span class="method-callseq"> succ! → self </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="succ-21-source"> <pre class="c" data-language="c">static VALUE
rb_str_succ_bang(VALUE str)
{
    rb_str_modify(str);
    str_succ(str);
    return str;
}</pre> </div> <p>Equivalent to <a href="string.html#method-i-succ"><code>String#succ</code></a>, but modifies <code>self</code> in place; returns <code>self</code>.</p>  </div> <div class="aliases"> Also aliased as: <a href="string.html#method-i-next-21">next!</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-sum"> <span class="method-callseq"> sum(n = 16) → integer </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="sum-source"> <pre class="c" data-language="c">static VALUE
rb_str_sum(int argc, VALUE *argv, VALUE str)
{
    int bits = 16;
    char *ptr, *p, *pend;
    long len;
    VALUE sum = INT2FIX(0);
    unsigned long sum0 = 0;

    if (rb_check_arity(argc, 0, 1) &amp;&amp; (bits = NUM2INT(argv[0])) &lt; 0) {
        bits = 0;
    }
    ptr = p = RSTRING_PTR(str);
    len = RSTRING_LEN(str);
    pend = p + len;

    while (p &lt; pend) {
        if (FIXNUM_MAX - UCHAR_MAX &lt; sum0) {
            sum = rb_funcall(sum, '+', 1, LONG2FIX(sum0));
            str_mod_check(str, ptr, len);
            sum0 = 0;
        }
        sum0 += (unsigned char)*p;
        p++;
    }

    if (bits == 0) {
        if (sum0) {
            sum = rb_funcall(sum, '+', 1, LONG2FIX(sum0));
        }
    }
    else {
        if (sum == INT2FIX(0)) {
            if (bits &lt; (int)sizeof(long)*CHAR_BIT) {
                sum0 &amp;= (((unsigned long)1)&lt;&lt;bits)-1;
            }
            sum = LONG2FIX(sum0);
        }
        else {
            VALUE mod;

            if (sum0) {
                sum = rb_funcall(sum, '+', 1, LONG2FIX(sum0));
            }

            mod = rb_funcall(INT2FIX(1), idLTLT, 1, INT2FIX(bits));
            mod = rb_funcall(mod, '-', 1, INT2FIX(1));
            sum = rb_funcall(sum, '&amp;', 1, mod);
        }
    }
    return sum;
}</pre> </div> <p>Returns a basic <code>n</code>-bit checksum of the characters in <code>self</code>; the checksum is the sum of the binary value of each byte in <code>self</code>, modulo <code>2**n - 1</code>:</p> <pre class="ruby" data-language="ruby">'hello'.sum     # =&gt; 532
'hello'.sum(4)  # =&gt; 4
'hello'.sum(64) # =&gt; 532
'тест'.sum      # =&gt; 1405
'こんにちは'.sum  # =&gt; 2582
</pre> <p>This is not a particularly strong checksum.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-swapcase"> <span class="method-callseq"> swapcase(*options) → string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="swapcase-source"> <pre class="c" data-language="c">static VALUE
rb_str_swapcase(int argc, VALUE *argv, VALUE str)
{
    rb_encoding *enc;
    OnigCaseFoldType flags = ONIGENC_CASE_UPCASE | ONIGENC_CASE_DOWNCASE;
    VALUE ret;

    flags = check_case_options(argc, argv, flags);
    enc = str_true_enc(str);
    if (RSTRING_LEN(str) == 0 || !RSTRING_PTR(str)) return str_duplicate(rb_cString, str);
    if (flags&amp;ONIGENC_CASE_ASCII_ONLY) {
        ret = rb_str_new(0, RSTRING_LEN(str));
        rb_str_ascii_casemap(str, ret, &amp;flags, enc);
    }
    else {
        ret = rb_str_casemap(str, &amp;flags, enc);
    }
    return ret;
}</pre> </div> <p>Returns a string containing the characters in <code>self</code>, with cases reversed; each uppercase character is downcased; each lowercase character is upcased:</p> <pre class="ruby" data-language="ruby">s = 'Hello World!' # =&gt; "Hello World!"
s.swapcase         # =&gt; "hELLO wORLD!"
</pre> <p>The casing may be affected by the given <code>options</code>; see <a href="case_mapping_rdoc.html">Case Mapping</a>.</p> <p>Related: <a href="string.html#method-i-swapcase-21"><code>String#swapcase!</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-swapcase-21"> <span class="method-callseq"> swapcase!(*options) → self or nil </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="swapcase-21-source"> <pre class="c" data-language="c">static VALUE
rb_str_swapcase_bang(int argc, VALUE *argv, VALUE str)
{
    rb_encoding *enc;
    OnigCaseFoldType flags = ONIGENC_CASE_UPCASE | ONIGENC_CASE_DOWNCASE;

    flags = check_case_options(argc, argv, flags);
    str_modify_keep_cr(str);
    enc = str_true_enc(str);
    if (flags&amp;ONIGENC_CASE_ASCII_ONLY)
        rb_str_ascii_casemap(str, str, &amp;flags, enc);
    else
        str_shared_replace(str, rb_str_casemap(str, &amp;flags, enc));

    if (ONIGENC_CASE_MODIFIED&amp;flags) return str;
    return Qnil;
}</pre> </div> <p>Upcases each lowercase character in <code>self</code>; downcases uppercase character; returns <code>self</code> if any changes were made, <code>nil</code> otherwise:</p> <pre class="ruby" data-language="ruby">s = 'Hello World!' # =&gt; "Hello World!"
s.swapcase!        # =&gt; "hELLO wORLD!"
s                  # =&gt; "hELLO wORLD!"
''.swapcase!       # =&gt; nil
</pre> <p>The casing may be affected by the given <code>options</code>; see <a href="case_mapping_rdoc.html">Case Mapping</a>.</p> <p>Related: <a href="string.html#method-i-swapcase"><code>String#swapcase</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-to_c"> <span class="method-callseq"> to_c → complex </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="to_c-source"> <pre class="c" data-language="c">static VALUE
string_to_c(VALUE self)
{
    VALUE num;

    rb_must_asciicompat(self);

    (void)parse_comp(rb_str_fill_terminator(self, 1), FALSE, &amp;num);

    return num;
}</pre> </div> <p>Returns <code>self</code> interpreted as a <a href="complex.html"><code>Complex</code></a> object; leading whitespace and trailing garbage are ignored:</p> <pre class="ruby" data-language="ruby">'9'.to_c                 # =&gt; (9+0i)
'2.5'.to_c               # =&gt; (2.5+0i)
'2.5/1'.to_c             # =&gt; ((5/2)+0i)
'-3/2'.to_c              # =&gt; ((-3/2)+0i)
'-i'.to_c                # =&gt; (0-1i)
'45i'.to_c               # =&gt; (0+45i)
'3-4i'.to_c              # =&gt; (3-4i)
'-4e2-4e-2i'.to_c        # =&gt; (-400.0-0.04i)
'-0.0-0.0i'.to_c         # =&gt; (-0.0-0.0i)
'1/2+3/4i'.to_c          # =&gt; ((1/2)+(3/4)*i)
'1.0@0'.to_c             # =&gt; (1+0.0i)
"1.0@#{Math::PI/2}".to_c # =&gt; (0.0+1i)
"1.0@#{Math::PI}".to_c   # =&gt; (-1+0.0i)
</pre> <p>Returns Complex zero if the string cannot be converted:</p> <pre class="ruby" data-language="ruby">'ruby'.to_c        # =&gt; (0+0i)
</pre> <p>See <a href="kernel.html#method-i-Complex"><code>Kernel#Complex</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-to_d"> <span class="method-callseq"> to_d → bigdecimal </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="to_d-source"> <pre class="ruby" data-language="ruby"># File ext/bigdecimal/lib/bigdecimal/util.rb, line 72
def to_d
  BigDecimal.interpret_loosely(self)
end</pre> </div> <p>Returns the result of interpreting leading characters in <code>str</code> as a <a href="bigdecimal.html"><code>BigDecimal</code></a>.</p> <pre class="ruby" data-language="ruby">require 'bigdecimal'
require 'bigdecimal/util'

"0.5".to_d             # =&gt; 0.5e0
"123.45e1".to_d        # =&gt; 0.12345e4
"45.67 degrees".to_d   # =&gt; 0.4567e2
</pre> <p>See also <a href="bigdecimal.html"><code>Kernel.BigDecimal</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-to_f"> <span class="method-callseq"> to_f → float </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="to_f-source"> <pre class="c" data-language="c">static VALUE
rb_str_to_f(VALUE str)
{
    return DBL2NUM(rb_str_to_dbl(str, FALSE));
}</pre> </div> <p>Returns the result of interpreting leading characters in <code>self</code> as a Float:</p> <pre class="ruby" data-language="ruby">'3.14159'.to_f  # =&gt; 3.14159
'1.234e-2'.to_f # =&gt; 0.01234
</pre> <p>Characters past a leading valid number (in the given <code>base</code>) are ignored:</p> <pre class="ruby" data-language="ruby">'3.14 (pi to two places)'.to_f # =&gt; 3.14
</pre> <p>Returns zero if there is no leading valid number:</p> <pre class="ruby" data-language="ruby">'abcdef'.to_f # =&gt; 0.0
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-to_i"> <span class="method-callseq"> to_i(base = 10) → integer </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="to_i-source"> <pre class="c" data-language="c">static VALUE
rb_str_to_i(int argc, VALUE *argv, VALUE str)
{
    int base = 10;

    if (rb_check_arity(argc, 0, 1) &amp;&amp; (base = NUM2INT(argv[0])) &lt; 0) {
        rb_raise(rb_eArgError, "invalid radix %d", base);
    }
    return rb_str_to_inum(str, base, FALSE);
}</pre> </div> <p>Returns the result of interpreting leading characters in <code>self</code> as an integer in the given <code>base</code> (which must be in (0, 2..36)):</p> <pre class="ruby" data-language="ruby">'123456'.to_i     # =&gt; 123456
'123def'.to_i(16) # =&gt; 1195503
</pre> <p>With <code>base</code> zero, string <code>object</code> may contain leading characters to specify the actual base:</p> <pre class="ruby" data-language="ruby">'123def'.to_i(0)   # =&gt; 123
'0123def'.to_i(0)  # =&gt; 83
'0b123def'.to_i(0) # =&gt; 1
'0o123def'.to_i(0) # =&gt; 83
'0d123def'.to_i(0) # =&gt; 123
'0x123def'.to_i(0) # =&gt; 1195503
</pre> <p>Characters past a leading valid number (in the given <code>base</code>) are ignored:</p> <pre class="ruby" data-language="ruby">'12.345'.to_i   # =&gt; 12
'12345'.to_i(2) # =&gt; 1
</pre> <p>Returns zero if there is no leading valid number:</p> <pre class="ruby" data-language="ruby">'abcdef'.to_i # =&gt; 0
'2'.to_i(2)   # =&gt; 0
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-to_r"> <span class="method-callseq"> to_r → rational </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="to_r-source"> <pre class="c" data-language="c">static VALUE
string_to_r(VALUE self)
{
    VALUE num;

    rb_must_asciicompat(self);

    num = parse_rat(RSTRING_PTR(self), RSTRING_END(self), 0, TRUE);

    if (RB_FLOAT_TYPE_P(num) &amp;&amp; !FLOAT_ZERO_P(num))
        rb_raise(rb_eFloatDomainError, "Infinity");
    return num;
}</pre> </div> <p>Returns the result of interpreting leading characters in <code>str</code> as a rational. Leading whitespace and extraneous characters past the end of a valid number are ignored. Digit sequences can be separated by an underscore. If there is not a valid number at the start of <code>str</code>, zero is returned. This method never raises an exception.</p> <pre class="ruby" data-language="ruby">'  2  '.to_r       #=&gt; (2/1)
'300/2'.to_r       #=&gt; (150/1)
'-9.2'.to_r        #=&gt; (-46/5)
'-9.2e2'.to_r      #=&gt; (-920/1)
'1_234_567'.to_r   #=&gt; (1234567/1)
'21 June 09'.to_r  #=&gt; (21/1)
'21/06/09'.to_r    #=&gt; (7/2)
'BWV 1079'.to_r    #=&gt; (0/1)
</pre> <p>NOTE: “0.3”.to_r isn’t the same as 0.3.to_r. The former is equivalent to “3/10”.to_r, but the latter isn’t so.</p> <pre class="ruby" data-language="ruby">"0.3".to_r == 3/10r  #=&gt; true
0.3.to_r   == 3/10r  #=&gt; false
</pre> <p>See also <a href="kernel.html#method-i-Rational"><code>Kernel#Rational</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-to_s"> <span class="method-callseq"> to_s → self or string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="to_s-source"> <pre class="c" data-language="c">static VALUE
rb_str_to_s(VALUE str)
{
    if (rb_obj_class(str) != rb_cString) {
        return str_duplicate(rb_cString, str);
    }
    return str;
}</pre> </div> <p>Returns <code>self</code> if <code>self</code> is a String, or <code>self</code> converted to a String if <code>self</code> is a subclass of String.</p>  </div> <div class="aliases"> Also aliased as: <a href="string.html#method-i-to_str">to_str</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-to_str"> <span class="method-name">to_str</span> </div> </div> <div class="aliases"> Alias for: <a href="string.html#method-i-to_s">to_s</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-to_sym"> <span class="method-callseq"> to_sym → symbol </span> </div> </div> <div class="method-description"> <p>Returns the <a href="symbol.html"><code>Symbol</code></a> corresponding to <em>str</em>, creating the symbol if it did not previously exist. See <a href="symbol.html#method-i-id2name"><code>Symbol#id2name</code></a>.</p> <pre class="ruby" data-language="ruby">"Koala".intern         #=&gt; :Koala
s = 'cat'.to_sym       #=&gt; :cat
s == :cat              #=&gt; true
s = '@cat'.to_sym      #=&gt; :@cat
s == :@cat             #=&gt; true
</pre> <p>This can also be used to create symbols that cannot be represented using the <code>:xxx</code> notation.</p> <pre class="ruby" data-language="ruby">'cat and dog'.to_sym   #=&gt; :"cat and dog"
</pre> </div> <div class="aliases"> Alias for: <a href="string.html#method-i-intern">intern</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-toeuc"> <span class="method-callseq"> String#toeuc → string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="toeuc-source"> <pre class="ruby" data-language="ruby"># File ext/nkf/lib/kconv.rb, line 224
def toeuc; Kconv.toeuc(self) end</pre> </div> <p>Convert <code>self</code> to EUC-JP</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-tojis"> <span class="method-callseq"> String#tojis → string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="tojis-source"> <pre class="ruby" data-language="ruby"># File ext/nkf/lib/kconv.rb, line 218
def tojis; Kconv.tojis(self) end</pre> </div> <p>Convert <code>self</code> to ISO-2022-JP</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-tolocale"> <span class="method-callseq"> String#tolocale → string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="tolocale-source"> <pre class="ruby" data-language="ruby"># File ext/nkf/lib/kconv.rb, line 254
def tolocale; Kconv.tolocale(self) end</pre> </div> <p>Convert <code>self</code> to locale encoding</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-tosjis"> <span class="method-callseq"> String#tosjis → string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="tosjis-source"> <pre class="ruby" data-language="ruby"># File ext/nkf/lib/kconv.rb, line 230
def tosjis; Kconv.tosjis(self) end</pre> </div> <p>Convert <code>self</code> to Shift_JIS</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-toutf16"> <span class="method-callseq"> String#toutf16 → string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="toutf16-source"> <pre class="ruby" data-language="ruby"># File ext/nkf/lib/kconv.rb, line 242
def toutf16; Kconv.toutf16(self) end</pre> </div> <p>Convert <code>self</code> to UTF-16</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-toutf32"> <span class="method-callseq"> String#toutf32 → string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="toutf32-source"> <pre class="ruby" data-language="ruby"># File ext/nkf/lib/kconv.rb, line 248
def toutf32; Kconv.toutf32(self) end</pre> </div> <p>Convert <code>self</code> to UTF-32</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-toutf8"> <span class="method-callseq"> String#toutf8 → string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="toutf8-source"> <pre class="ruby" data-language="ruby"># File ext/nkf/lib/kconv.rb, line 236
def toutf8; Kconv.toutf8(self) end</pre> </div> <p>Convert <code>self</code> to UTF-8</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-tr"> <span class="method-callseq"> tr(selector, replacements) → new_string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="tr-source"> <pre class="c" data-language="c">static VALUE
rb_str_tr(VALUE str, VALUE src, VALUE repl)
{
    str = str_duplicate(rb_cString, str);
    tr_trans(str, src, repl, 0);
    return str;
}</pre> </div> <p>Returns a copy of <code>self</code> with each character specified by string <code>selector</code> translated to the corresponding character in string <code>replacements</code>. The correspondence is <em>positional</em>:</p> <ul>
<li> <p>Each occurrence of the first character specified by <code>selector</code> is translated to the first character in <code>replacements</code>.</p> </li>
<li> <p>Each occurrence of the second character specified by <code>selector</code> is translated to the second character in <code>replacements</code>.</p> </li>
<li> <p>And so on.</p> </li>
</ul> <p>Example:</p> <pre class="ruby" data-language="ruby">'hello'.tr('el', 'ip') #=&gt; "hippo"
</pre> <p>If <code>replacements</code> is shorter than <code>selector</code>, it is implicitly padded with its own last character:</p> <pre class="ruby" data-language="ruby">'hello'.tr('aeiou', '-')   # =&gt; "h-ll-"
'hello'.tr('aeiou', 'AA-') # =&gt; "hAll-"
</pre> <p>Arguments <code>selector</code> and <code>replacements</code> must be valid character selectors (see <a href="character_selectors_rdoc.html">Character Selectors</a>), and may use any of its valid forms, including negation, ranges, and escaping:</p> <pre class="ruby" data-language="ruby"># Negation.
'hello'.tr('^aeiou', '-') # =&gt; "-e--o"
# Ranges.
'ibm'.tr('b-z', 'a-z') # =&gt; "hal"
# Escapes.
'hel^lo'.tr('\^aeiou', '-')     # =&gt; "h-l-l-"    # Escaped leading caret.
'i-b-m'.tr('b\-z', 'a-z')       # =&gt; "ibabm"     # Escaped embedded hyphen.
'foo\\bar'.tr('ab\\', 'XYZ')    # =&gt; "fooZYXr"   # Escaped backslash.
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-tr-21"> <span class="method-callseq"> tr!(selector, replacements) → self or nil </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="tr-21-source"> <pre class="c" data-language="c">static VALUE
rb_str_tr_bang(VALUE str, VALUE src, VALUE repl)
{
    return tr_trans(str, src, repl, 0);
}</pre> </div> <p>Like <a href="string.html#method-i-tr"><code>String#tr</code></a>, but modifies <code>self</code> in place. Returns <code>self</code> if any changes were made, <code>nil</code> otherwise.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-tr_s"> <span class="method-callseq"> tr_s(selector, replacements) → string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="tr_s-source"> <pre class="c" data-language="c">static VALUE
rb_str_tr_s(VALUE str, VALUE src, VALUE repl)
{
    str = str_duplicate(rb_cString, str);
    tr_trans(str, src, repl, 1);
    return str;
}</pre> </div> <p>Like <a href="string.html#method-i-tr"><code>String#tr</code></a>, but also squeezes the modified portions of the translated string; returns a new string (translated and squeezed).</p> <pre class="ruby" data-language="ruby">'hello'.tr_s('l', 'r')   #=&gt; "hero"
'hello'.tr_s('el', '-')  #=&gt; "h-o"
'hello'.tr_s('el', 'hx') #=&gt; "hhxo"
</pre> <p>Related: <a href="string.html#method-i-squeeze"><code>String#squeeze</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-tr_s-21"> <span class="method-callseq"> tr_s!(selector, replacements) → self or nil </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="tr_s-21-source"> <pre class="c" data-language="c">static VALUE
rb_str_tr_s_bang(VALUE str, VALUE src, VALUE repl)
{
    return tr_trans(str, src, repl, 1);
}</pre> </div> <p>Like <a href="string.html#method-i-tr_s"><code>String#tr_s</code></a>, but modifies <code>self</code> in place. Returns <code>self</code> if any changes were made, <code>nil</code> otherwise.</p> <p>Related: <a href="string.html#method-i-squeeze-21"><code>String#squeeze!</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-undump"> <span class="method-callseq"> undump → string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="undump-source"> <pre class="c" data-language="c">static VALUE
str_undump(VALUE str)
{
    const char *s = RSTRING_PTR(str);
    const char *s_end = RSTRING_END(str);
    rb_encoding *enc = rb_enc_get(str);
    VALUE undumped = rb_enc_str_new(s, 0L, enc);
    bool utf8 = false;
    bool binary = false;
    int w;

    rb_must_asciicompat(str);
    if (rb_str_is_ascii_only_p(str) == Qfalse) {
        rb_raise(rb_eRuntimeError, "non-ASCII character detected");
    }
    if (!str_null_check(str, &amp;w)) {
        rb_raise(rb_eRuntimeError, "string contains null byte");
    }
    if (RSTRING_LEN(str) &lt; 2) goto invalid_format;
    if (*s != '"') goto invalid_format;

    /* strip '"' at the start */
    s++;

    for (;;) {
        if (s &gt;= s_end) {
            rb_raise(rb_eRuntimeError, "unterminated dumped string");
        }

        if (*s == '"') {
            /* epilogue */
            s++;
            if (s == s_end) {
                /* ascii compatible dumped string */
                break;
            }
            else {
                static const char force_encoding_suffix[] = ".force_encoding(\""; /* "\")" */
                static const char dup_suffix[] = ".dup";
                const char *encname;
                int encidx;
                ptrdiff_t size;

                /* check separately for strings dumped by older versions */
                size = sizeof(dup_suffix) - 1;
                if (s_end - s &gt; size &amp;&amp; memcmp(s, dup_suffix, size) == 0) s += size;

                size = sizeof(force_encoding_suffix) - 1;
                if (s_end - s &lt;= size) goto invalid_format;
                if (memcmp(s, force_encoding_suffix, size) != 0) goto invalid_format;
                s += size;

                if (utf8) {
                    rb_raise(rb_eRuntimeError, "dumped string contained Unicode escape but used force_encoding");
                }

                encname = s;
                s = memchr(s, '"', s_end-s);
                size = s - encname;
                if (!s) goto invalid_format;
                if (s_end - s != 2) goto invalid_format;
                if (s[0] != '"' || s[1] != ')') goto invalid_format;

                encidx = rb_enc_find_index2(encname, (long)size);
                if (encidx &lt; 0) {
                    rb_raise(rb_eRuntimeError, "dumped string has unknown encoding name");
                }
                rb_enc_associate_index(undumped, encidx);
            }
            break;
        }

        if (*s == '\\') {
            s++;
            if (s &gt;= s_end) {
                rb_raise(rb_eRuntimeError, "invalid escape");
            }
            undump_after_backslash(undumped, &amp;s, s_end, &amp;enc, &amp;utf8, &amp;binary);
        }
        else {
            rb_str_cat(undumped, s++, 1);
        }
    }

    RB_GC_GUARD(str);

    return undumped;
invalid_format:
    rb_raise(rb_eRuntimeError, "invalid dumped string; not wrapped with '\"' nor '\"...\".force_encoding(\"...\")' form");
}</pre> </div> <p>Returns an unescaped version of <code>self</code>:</p> <pre class="ruby" data-language="ruby">s_orig = "\f\x00\xff\\\""    # =&gt; "\f\u0000\xFF\\\""
s_dumped = s_orig.dump       # =&gt; "\"\\f\\x00\\xFF\\\\\\\"\""
s_undumped = s_dumped.undump # =&gt; "\f\u0000\xFF\\\""
s_undumped == s_orig         # =&gt; true
</pre> <p>Related: <a href="string.html#method-i-dump"><code>String#dump</code></a> (inverse of <a href="string.html#method-i-undump"><code>String#undump</code></a>).</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-unicode_normalize"> <span class="method-callseq"> unicode_normalize(form = :nfc) → string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="unicode_normalize-source"> <pre class="c" data-language="c">static VALUE
rb_str_unicode_normalize(int argc, VALUE *argv, VALUE str)
{
    return unicode_normalize_common(argc, argv, str, id_normalize);
}</pre> </div> <p>Returns a copy of <code>self</code> with <a href="https://unicode.org/reports/tr15">Unicode normalization</a> applied.</p> <p>Argument <code>form</code> must be one of the following symbols (see <a href="https://unicode.org/reports/tr15/#Norm_Forms">Unicode normalization forms</a>):</p> <ul>
<li> <p><code>:nfc</code>: Canonical decomposition, followed by canonical composition.</p> </li>
<li> <p><code>:nfd</code>: Canonical decomposition.</p> </li>
<li> <p><code>:nfkc</code>: Compatibility decomposition, followed by canonical composition.</p> </li>
<li> <p><code>:nfkd</code>: Compatibility decomposition.</p> </li>
</ul> <p>The encoding of <code>self</code> must be one of:</p> <ul>
<li> <p>Encoding::UTF_8</p> </li>
<li> <p>Encoding::UTF_16BE</p> </li>
<li> <p>Encoding::UTF_16LE</p> </li>
<li> <p>Encoding::UTF_32BE</p> </li>
<li> <p>Encoding::UTF_32LE</p> </li>
<li> <p>Encoding::GB18030</p> </li>
<li> <p>Encoding::UCS_2BE</p> </li>
<li> <p>Encoding::UCS_4BE</p> </li>
</ul> <p>Examples:</p> <pre class="ruby" data-language="ruby">"a\u0300".unicode_normalize      # =&gt; "a"
"\u00E0".unicode_normalize(:nfd) # =&gt; "a "
</pre> <p>Related: <a href="string.html#method-i-unicode_normalize-21"><code>String#unicode_normalize!</code></a>, <a href="string.html#method-i-unicode_normalized-3F"><code>String#unicode_normalized?</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-unicode_normalize-21"> <span class="method-callseq"> unicode_normalize!(form = :nfc) → self </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="unicode_normalize-21-source"> <pre class="c" data-language="c">static VALUE
rb_str_unicode_normalize_bang(int argc, VALUE *argv, VALUE str)
{
    return rb_str_replace(str, unicode_normalize_common(argc, argv, str, id_normalize));
}</pre> </div> <p>Like <a href="string.html#method-i-unicode_normalize"><code>String#unicode_normalize</code></a>, except that the normalization is performed on <code>self</code>.</p> <p>Related <a href="string.html#method-i-unicode_normalized-3F"><code>String#unicode_normalized?</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-unicode_normalized-3F"> <span class="method-callseq"> unicode_normalized?(form = :nfc) → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="unicode_normalized-3F-source"> <pre class="c" data-language="c">static VALUE
rb_str_unicode_normalized_p(int argc, VALUE *argv, VALUE str)
{
    return unicode_normalize_common(argc, argv, str, id_normalized_p);
}</pre> </div> <p>Returns <code>true</code> if <code>self</code> is in the given <code>form</code> of Unicode normalization, <code>false</code> otherwise. The <code>form</code> must be one of <code>:nfc</code>, <code>:nfd</code>, <code>:nfkc</code>, or <code>:nfkd</code>.</p> <p>Examples:</p> <pre class="ruby" data-language="ruby">"a\u0300".unicode_normalized?       # =&gt; false
"a\u0300".unicode_normalized?(:nfd) # =&gt; true
"\u00E0".unicode_normalized?        # =&gt; true
"\u00E0".unicode_normalized?(:nfd)  # =&gt; false
</pre> <p>Raises an exception if <code>self</code> is not in a Unicode encoding:</p> <pre class="ruby" data-language="ruby">s = "\xE0".force_encoding('ISO-8859-1')
s.unicode_normalized? # Raises Encoding::CompatibilityError.
</pre> <p>Related: <a href="string.html#method-i-unicode_normalize"><code>String#unicode_normalize</code></a>, <a href="string.html#method-i-unicode_normalize-21"><code>String#unicode_normalize!</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-unpack"> <span class="method-callseq"> unpack(template, offset: 0) → array </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="unpack-source"> <pre class="ruby" data-language="ruby"># File pack.rb, line 19
def unpack(fmt, offset: 0)
  Primitive.pack_unpack(fmt, offset)
end</pre> </div> <p>Extracts data from <code>self</code>, forming objects that become the elements of a new array; returns that array. See <a href="packed_data_rdoc.html">Packed Data</a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-unpack1"> <span class="method-callseq"> unpack1(template, offset: 0) → object </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="unpack1-source"> <pre class="ruby" data-language="ruby"># File pack.rb, line 28
def unpack1(fmt, offset: 0)
  Primitive.pack_unpack1(fmt, offset)
end</pre> </div> <p>Like <a href="string.html#method-i-unpack"><code>String#unpack</code></a>, but unpacks and returns only the first extracted object. See <a href="packed_data_rdoc.html">Packed Data</a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-upcase"> <span class="method-callseq"> upcase(*options) → string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="upcase-source"> <pre class="c" data-language="c">static VALUE
rb_str_upcase(int argc, VALUE *argv, VALUE str)
{
    rb_encoding *enc;
    OnigCaseFoldType flags = ONIGENC_CASE_UPCASE;
    VALUE ret;

    flags = check_case_options(argc, argv, flags);
    enc = str_true_enc(str);
    if (case_option_single_p(flags, enc, str)) {
        ret = rb_str_new(RSTRING_PTR(str), RSTRING_LEN(str));
        str_enc_copy_direct(ret, str);
        upcase_single(ret);
    }
    else if (flags&amp;ONIGENC_CASE_ASCII_ONLY) {
        ret = rb_str_new(0, RSTRING_LEN(str));
        rb_str_ascii_casemap(str, ret, &amp;flags, enc);
    }
    else {
        ret = rb_str_casemap(str, &amp;flags, enc);
    }

    return ret;
}</pre> </div> <p>Returns a string containing the upcased characters in <code>self</code>:</p> <pre class="ruby" data-language="ruby">s = 'Hello World!' # =&gt; "Hello World!"
s.upcase           # =&gt; "HELLO WORLD!"
</pre> <p>The casing may be affected by the given <code>options</code>; see <a href="case_mapping_rdoc.html">Case Mapping</a>.</p> <p>Related: <a href="string.html#method-i-upcase-21"><code>String#upcase!</code></a>, <a href="string.html#method-i-downcase"><code>String#downcase</code></a>, <a href="string.html#method-i-downcase-21"><code>String#downcase!</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-upcase-21"> <span class="method-callseq"> upcase!(*options) → self or nil </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="upcase-21-source"> <pre class="c" data-language="c">static VALUE
rb_str_upcase_bang(int argc, VALUE *argv, VALUE str)
{
    rb_encoding *enc;
    OnigCaseFoldType flags = ONIGENC_CASE_UPCASE;

    flags = check_case_options(argc, argv, flags);
    str_modify_keep_cr(str);
    enc = str_true_enc(str);
    if (case_option_single_p(flags, enc, str)) {
        if (upcase_single(str))
            flags |= ONIGENC_CASE_MODIFIED;
    }
    else if (flags&amp;ONIGENC_CASE_ASCII_ONLY)
        rb_str_ascii_casemap(str, str, &amp;flags, enc);
    else
        str_shared_replace(str, rb_str_casemap(str, &amp;flags, enc));

    if (ONIGENC_CASE_MODIFIED&amp;flags) return str;
    return Qnil;
}</pre> </div> <p>Upcases the characters in <code>self</code>; returns <code>self</code> if any changes were made, <code>nil</code> otherwise:</p> <pre class="ruby" data-language="ruby">s = 'Hello World!' # =&gt; "Hello World!"
s.upcase!          # =&gt; "HELLO WORLD!"
s                  # =&gt; "HELLO WORLD!"
s.upcase!          # =&gt; nil
</pre> <p>The casing may be affected by the given <code>options</code>; see <a href="case_mapping_rdoc.html">Case Mapping</a>.</p> <p>Related: <a href="string.html#method-i-upcase"><code>String#upcase</code></a>, <a href="string.html#method-i-downcase"><code>String#downcase</code></a>, <a href="string.html#method-i-downcase-21"><code>String#downcase!</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-upto"> <span class="method-callseq"> upto(other_string, exclusive = false) {|string| ... } → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> upto(other_string, exclusive = false) → new_enumerator </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="upto-source"> <pre class="c" data-language="c">static VALUE
rb_str_upto(int argc, VALUE *argv, VALUE beg)
{
    VALUE end, exclusive;

    rb_scan_args(argc, argv, "11", &amp;end, &amp;exclusive);
    RETURN_ENUMERATOR(beg, argc, argv);
    return rb_str_upto_each(beg, end, RTEST(exclusive), str_upto_i, Qnil);
}</pre> </div> <p>With a block given, calls the block with each String value returned by successive calls to <a href="string.html#method-i-succ"><code>String#succ</code></a>; the first value is <code>self</code>, the next is <code>self.succ</code>, and so on; the sequence terminates when value <code>other_string</code> is reached; returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">'a8'.upto('b6') {|s| print s, ' ' } # =&gt; "a8"
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">a8 a9 b0 b1 b2 b3 b4 b5 b6
</pre> <p>If argument <code>exclusive</code> is given as a truthy object, the last value is omitted:</p> <pre class="ruby" data-language="ruby">'a8'.upto('b6', true) {|s| print s, ' ' } # =&gt; "a8"
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">a8 a9 b0 b1 b2 b3 b4 b5
</pre> <p>If <code>other_string</code> would not be reached, does not call the block:</p> <pre class="ruby" data-language="ruby">'25'.upto('5') {|s| fail s }
'aa'.upto('a') {|s| fail s }
</pre> <p>With no block given, returns a new Enumerator:</p> <pre class="ruby" data-language="ruby">'a8'.upto('b6') # =&gt; #&lt;Enumerator: "a8":upto("b6")&gt;
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-valid_encoding-3F"> <span class="method-callseq"> valid_encoding? → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="valid_encoding-3F-source"> <pre class="c" data-language="c">static VALUE
rb_str_valid_encoding_p(VALUE str)
{
    int cr = rb_enc_str_coderange(str);

    return RBOOL(cr != ENC_CODERANGE_BROKEN);
}</pre> </div> <p>Returns <code>true</code> if <code>self</code> is encoded correctly, <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">"\xc2\xa1".force_encoding("UTF-8").valid_encoding? # =&gt; true
"\xc2".force_encoding("UTF-8").valid_encoding?     # =&gt; false
"\x80".force_encoding("UTF-8").valid_encoding?     # =&gt; false
</pre>  </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core &copy; 1993&ndash;2022 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library &copy; contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>
