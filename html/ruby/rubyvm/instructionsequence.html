<h1 id="class-RubyVM::InstructionSequence" class="anchor-link class"> class RubyVM::InstructionSequence </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent"><a href="../object.html">Object</a></dd>
</dl> <section class="description"> <p>The <a href="instructionsequence.html"><code>InstructionSequence</code></a> class represents a compiled sequence of instructions for the Virtual Machine used in MRI. Not all implementations of Ruby may implement this class, and for the implementations that implement it, the methods defined and behavior of the methods can change in any version.</p> <p>With it, you can get a handle to the instructions that make up a method or a proc, compile strings of Ruby code down to VM instructions, and disassemble instruction sequences to strings for easy inspection. It is mostly useful if you want to learn how YARV works, but it also lets you control various settings for the Ruby iseq compiler.</p> <p>You can find the source for the VM instructions in <code>insns.def</code> in the Ruby source.</p> <p>The instruction sequence results will almost certainly change as Ruby changes, so example output in this documentation may be different from what you see.</p> <p>Of course, this class is MRI specific.</p> </section> <section id="5Buntitled-5D" class="documentation-section anchor-link"> <section id="public-class-5Buntitled-5D-method-details" class="method-section anchor-link"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-compile"> <a href="#method-c-compile" title="Link to this method"> <span class="method-callseq"> compile(source[, file[, path[, line[, options]]]]) → iseq </span> </a> </div> <div class="method-heading"> <a href="#method-c-compile" title="Link to this method"> <span class="method-callseq"> new(source[, file[, path[, line[, options]]]]) → iseq </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="compile-source"> <pre class="c" data-language="c">static VALUE
iseqw_s_compile(int argc, VALUE *argv, VALUE self)
{
    return iseqw_s_compile_parser(argc, argv, self, rb_ruby_prism_p());
}</pre> </div>  <p>Takes <code>source</code>, which can be a string of Ruby code, or an open <a href="../file.html"><code>File</code></a> object. that contains Ruby source code.</p> <p>Optionally takes <code>file</code>, <code>path</code>, and <code>line</code> which describe the file path, real path and first line number of the ruby code in <code>source</code> which are metadata attached to the returned <code>iseq</code>.</p> <p><code>file</code> is used for ‘__FILE__` and exception backtrace. <code>path</code> is used for <code>require_relative</code> base. It is recommended these should be the same full path.</p> <p><code>options</code>, which can be <code>true</code>, <code>false</code> or a <a href="../hash.html"><code>Hash</code></a>, is used to modify the default behavior of the Ruby iseq compiler.</p> <p>For details regarding valid compile options see <a href="instructionsequence.html#method-c-compile_option-3D"><code>::compile_option=</code></a>.</p> <pre class="ruby" data-language="ruby">RubyVM::InstructionSequence.compile("a = 1 + 2")
#=&gt; &lt;RubyVM::InstructionSequence:&lt;compiled&gt;@&lt;compiled&gt;&gt;

path = "test.rb"
RubyVM::InstructionSequence.compile(File.read(path), path, File.expand_path(path))
#=&gt; &lt;RubyVM::InstructionSequence:&lt;compiled&gt;@test.rb:1&gt;

file = File.open("test.rb")
RubyVM::InstructionSequence.compile(file)
#=&gt; &lt;RubyVM::InstructionSequence:&lt;compiled&gt;@&lt;compiled&gt;:1&gt;

path = File.expand_path("test.rb")
RubyVM::InstructionSequence.compile(File.read(path), path, path)
#=&gt; &lt;RubyVM::InstructionSequence:&lt;compiled&gt;@/absolute/path/to/test.rb:1&gt;
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-compile_file"> <a href="#method-c-compile_file" title="Link to this method"> <span class="method-callseq"> compile_file(file[, options]) → iseq </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="compile_file-source"> <pre class="c" data-language="c">static VALUE
iseqw_s_compile_file(int argc, VALUE *argv, VALUE self)
{
    VALUE file, opt = Qnil;
    VALUE parser, f, exc = Qnil, ret;
    rb_ast_t *ast;
    VALUE ast_value;
    rb_compile_option_t option;
    int i;

    i = rb_scan_args(argc, argv, "1*:", &amp;file, NULL, &amp;opt);
    if (i &gt; 1+NIL_P(opt)) rb_error_arity(argc, 1, 2);
    switch (i) {
      case 2: opt = argv[--i];
    }
    FilePathValue(file);
    file = rb_fstring(file); /* rb_io_t-&gt;pathv gets frozen anyways */

    f = rb_file_open_str(file, "r");

    rb_execution_context_t *ec = GET_EC();
    VALUE v = rb_vm_push_frame_fname(ec, file);

    parser = rb_parser_new();
    rb_parser_set_context(parser, NULL, FALSE);
    ast_value = rb_parser_load_file(parser, file);
    ast = rb_ruby_ast_data_get(ast_value);
    if (!ast-&gt;body.root) exc = GET_EC()-&gt;errinfo;

    rb_io_close(f);
    if (!ast-&gt;body.root) {
        rb_ast_dispose(ast);
        rb_exc_raise(exc);
    }

    make_compile_option(&amp;option, opt);

    ret = iseqw_new(rb_iseq_new_with_opt(ast_value, rb_fstring_lit("&lt;main&gt;"),
                                         file,
                                         rb_realpath_internal(Qnil, file, 1),
                                         1, NULL, 0, ISEQ_TYPE_TOP, &amp;option,
                                         Qnil));
    rb_ast_dispose(ast);

    rb_vm_pop_frame(ec);
    RB_GC_GUARD(v);
    return ret;
}</pre> </div>  <p>Takes <code>file</code>, a <a href="../string.html"><code>String</code></a> with the location of a Ruby source file, reads, parses and compiles the file, and returns <code>iseq</code>, the compiled <a href="instructionsequence.html"><code>InstructionSequence</code></a> with source location metadata set.</p> <p>Optionally takes <code>options</code>, which can be <code>true</code>, <code>false</code> or a <a href="../hash.html"><code>Hash</code></a>, to modify the default behavior of the Ruby iseq compiler.</p> <p>For details regarding valid compile options see <a href="instructionsequence.html#method-c-compile_option-3D"><code>::compile_option=</code></a>.</p> <pre class="ruby" data-language="ruby"># /tmp/hello.rb
puts "Hello, world!"

# elsewhere
RubyVM::InstructionSequence.compile_file("/tmp/hello.rb")
#=&gt; &lt;RubyVM::InstructionSequence:&lt;main&gt;@/tmp/hello.rb&gt;
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-compile_file_prism"> <a href="#method-c-compile_file_prism" title="Link to this method"> <span class="method-callseq"> compile_file_prism(file[, options]) → iseq </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="compile_file_prism-source"> <pre class="c" data-language="c">static VALUE
iseqw_s_compile_file_prism(int argc, VALUE *argv, VALUE self)
{
    VALUE file, opt = Qnil, ret;
    rb_compile_option_t option;
    int i;

    i = rb_scan_args(argc, argv, "1*:", &amp;file, NULL, &amp;opt);
    if (i &gt; 1+NIL_P(opt)) rb_error_arity(argc, 1, 2);
    switch (i) {
      case 2: opt = argv[--i];
    }
    FilePathValue(file);
    file = rb_fstring(file); /* rb_io_t-&gt;pathv gets frozen anyways */

    rb_execution_context_t *ec = GET_EC();
    VALUE v = rb_vm_push_frame_fname(ec, file);

    pm_parse_result_t result = { 0 };
    result.options.line = 1;
    result.node.coverage_enabled = 1;

    VALUE script_lines;
    VALUE error = pm_load_parse_file(&amp;result, file, ruby_vm_keep_script_lines ? &amp;script_lines : NULL);

    if (error == Qnil) {
        make_compile_option(&amp;option, opt);

        int error_state;
        rb_iseq_t *iseq = pm_iseq_new_with_opt(&amp;result.node, rb_fstring_lit("&lt;main&gt;"),
                                               file,
                                               rb_realpath_internal(Qnil, file, 1),
                                               1, NULL, 0, ISEQ_TYPE_TOP, &amp;option, &amp;error_state);

        pm_parse_result_free(&amp;result);

        if (error_state) {
            RUBY_ASSERT(iseq == NULL);
            rb_jump_tag(error_state);
        }

        ret = iseqw_new(iseq);
        rb_vm_pop_frame(ec);
        RB_GC_GUARD(v);
        return ret;
    } else {
        pm_parse_result_free(&amp;result);
        rb_vm_pop_frame(ec);
        RB_GC_GUARD(v);
        rb_exc_raise(error);
    }
}</pre> </div>  <p>Takes <code>file</code>, a <a href="../string.html"><code>String</code></a> with the location of a Ruby source file, reads, parses and compiles the file, and returns <code>iseq</code>, the compiled <a href="instructionsequence.html"><code>InstructionSequence</code></a> with source location metadata set. It parses and compiles using prism.</p> <p>Optionally takes <code>options</code>, which can be <code>true</code>, <code>false</code> or a <a href="../hash.html"><code>Hash</code></a>, to modify the default behavior of the Ruby iseq compiler.</p> <p>For details regarding valid compile options see <a href="instructionsequence.html#method-c-compile_option-3D"><code>::compile_option=</code></a>.</p> <pre class="ruby" data-language="ruby"># /tmp/hello.rb
puts "Hello, world!"

# elsewhere
RubyVM::InstructionSequence.compile_file_prism("/tmp/hello.rb")
#=&gt; &lt;RubyVM::InstructionSequence:&lt;main&gt;@/tmp/hello.rb&gt;
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-compile_option"> <a href="#method-c-compile_option" title="Link to this method"> <span class="method-callseq"> compile_option → options </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="compile_option-source"> <pre class="c" data-language="c">static VALUE
iseqw_s_compile_option_get(VALUE self)
{
    return make_compile_option_value(&amp;COMPILE_OPTION_DEFAULT);
}</pre> </div>  <p>Returns a hash of default options used by the Ruby iseq compiler.</p> <p>For details, see <a href="instructionsequence.html#method-c-compile_option-3D"><code>InstructionSequence.compile_option=</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-compile_option-3D"> <a href="#method-c-compile_option-3D" title="Link to this method"> <span class="method-callseq"> compile_option = options </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="compile_option-3D-source"> <pre class="c" data-language="c">static VALUE
iseqw_s_compile_option_set(VALUE self, VALUE opt)
{
    rb_compile_option_t option;
    make_compile_option(&amp;option, opt);
    COMPILE_OPTION_DEFAULT = option;
    return opt;
}</pre> </div>  <p>Sets the default values for various optimizations in the Ruby iseq compiler.</p> <p>Possible values for <code>options</code> include <code>true</code>, which enables all options, <code>false</code> which disables all options, and <code>nil</code> which leaves all options unchanged.</p> <p>You can also pass a <a href="../hash.html"><code>Hash</code></a> of <code>options</code> that you want to change, any options not present in the hash will be left unchanged.</p> <p>Possible option names (which are keys in <code>options</code>) which can be set to <code>true</code> or <code>false</code> include:</p> <ul>
<li> <p><code>:inline_const_cache</code></p> </li>
<li> <p><code>:instructions_unification</code></p> </li>
<li> <p><code>:operands_unification</code></p> </li>
<li> <p><code>:peephole_optimization</code></p> </li>
<li> <p><code>:specialized_instruction</code></p> </li>
<li> <p><code>:tailcall_optimization</code></p> </li>
</ul> <p>Additionally, <code>:debug_level</code> can be set to an integer.</p> <p>These default options can be overwritten for a single run of the iseq compiler by passing any of the above values as the <code>options</code> parameter to <a href="instructionsequence.html#method-c-new"><code>::new</code></a>, <a href="instructionsequence.html#method-c-compile"><code>::compile</code></a> and <a href="instructionsequence.html#method-c-compile_file"><code>::compile_file</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-compile_parsey"> <a href="#method-c-compile_parsey" title="Link to this method"> <span class="method-callseq"> compile_parsey(source[, file[, path[, line[, options]]]]) → iseq </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="compile_parsey-source"> <pre class="c" data-language="c">static VALUE
iseqw_s_compile_parsey(int argc, VALUE *argv, VALUE self)
{
    return iseqw_s_compile_parser(argc, argv, self, false);
}</pre> </div>  <p>Takes <code>source</code>, which can be a string of Ruby code, or an open <a href="../file.html"><code>File</code></a> object. that contains Ruby source code. It parses and compiles using parse.y.</p> <p>Optionally takes <code>file</code>, <code>path</code>, and <code>line</code> which describe the file path, real path and first line number of the ruby code in <code>source</code> which are metadata attached to the returned <code>iseq</code>.</p> <p><code>file</code> is used for ‘__FILE__` and exception backtrace. <code>path</code> is used for <code>require_relative</code> base. It is recommended these should be the same full path.</p> <p><code>options</code>, which can be <code>true</code>, <code>false</code> or a <a href="../hash.html"><code>Hash</code></a>, is used to modify the default behavior of the Ruby iseq compiler.</p> <p>For details regarding valid compile options see <a href="instructionsequence.html#method-c-compile_option-3D"><code>::compile_option=</code></a>.</p> <pre class="ruby" data-language="ruby">RubyVM::InstructionSequence.compile_parsey("a = 1 + 2")
#=&gt; &lt;RubyVM::InstructionSequence:&lt;compiled&gt;@&lt;compiled&gt;&gt;

path = "test.rb"
RubyVM::InstructionSequence.compile_parsey(File.read(path), path, File.expand_path(path))
#=&gt; &lt;RubyVM::InstructionSequence:&lt;compiled&gt;@test.rb:1&gt;

file = File.open("test.rb")
RubyVM::InstructionSequence.compile_parsey(file)
#=&gt; &lt;RubyVM::InstructionSequence:&lt;compiled&gt;@&lt;compiled&gt;:1&gt;

path = File.expand_path("test.rb")
RubyVM::InstructionSequence.compile_parsey(File.read(path), path, path)
#=&gt; &lt;RubyVM::InstructionSequence:&lt;compiled&gt;@/absolute/path/to/test.rb:1&gt;
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-compile_prism"> <a href="#method-c-compile_prism" title="Link to this method"> <span class="method-callseq"> compile_prism(source[, file[, path[, line[, options]]]]) → iseq </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="compile_prism-source"> <pre class="c" data-language="c">static VALUE
iseqw_s_compile_prism(int argc, VALUE *argv, VALUE self)
{
    return iseqw_s_compile_parser(argc, argv, self, true);
}</pre> </div>  <p>Takes <code>source</code>, which can be a string of Ruby code, or an open <a href="../file.html"><code>File</code></a> object. that contains Ruby source code. It parses and compiles using prism.</p> <p>Optionally takes <code>file</code>, <code>path</code>, and <code>line</code> which describe the file path, real path and first line number of the ruby code in <code>source</code> which are metadata attached to the returned <code>iseq</code>.</p> <p><code>file</code> is used for ‘__FILE__` and exception backtrace. <code>path</code> is used for <code>require_relative</code> base. It is recommended these should be the same full path.</p> <p><code>options</code>, which can be <code>true</code>, <code>false</code> or a <a href="../hash.html"><code>Hash</code></a>, is used to modify the default behavior of the Ruby iseq compiler.</p> <p>For details regarding valid compile options see <a href="instructionsequence.html#method-c-compile_option-3D"><code>::compile_option=</code></a>.</p> <pre class="ruby" data-language="ruby">RubyVM::InstructionSequence.compile_prism("a = 1 + 2")
#=&gt; &lt;RubyVM::InstructionSequence:&lt;compiled&gt;@&lt;compiled&gt;&gt;

path = "test.rb"
RubyVM::InstructionSequence.compile_prism(File.read(path), path, File.expand_path(path))
#=&gt; &lt;RubyVM::InstructionSequence:&lt;compiled&gt;@test.rb:1&gt;

file = File.open("test.rb")
RubyVM::InstructionSequence.compile_prism(file)
#=&gt; &lt;RubyVM::InstructionSequence:&lt;compiled&gt;@&lt;compiled&gt;:1&gt;

path = File.expand_path("test.rb")
RubyVM::InstructionSequence.compile_prism(File.read(path), path, path)
#=&gt; &lt;RubyVM::InstructionSequence:&lt;compiled&gt;@/absolute/path/to/test.rb:1&gt;
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-disasm"> <a href="#method-c-disasm" title="Link to this method"> <span class="method-callseq"> disasm(body) → str </span> </a> </div> <div class="method-heading"> <a href="#method-c-disasm" title="Link to this method"> <span class="method-callseq"> disassemble(body) → str </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="disasm-source"> <pre class="c" data-language="c">static VALUE
iseqw_s_disasm(VALUE klass, VALUE body)
{
    VALUE iseqw = iseqw_s_of(klass, body);
    return NIL_P(iseqw) ? Qnil : rb_iseq_disasm(iseqw_check(iseqw));
}</pre> </div>  <p>Takes <code>body</code>, a <a href="../method.html"><code>Method</code></a> or <a href="../proc.html"><code>Proc</code></a> object, and returns a <a href="../string.html"><code>String</code></a> with the human readable instructions for <code>body</code>.</p> <p>For a <a href="../method.html"><code>Method</code></a> object:</p> <pre class="ruby" data-language="ruby"># /tmp/method.rb
def hello
  puts "hello, world"
end

puts RubyVM::InstructionSequence.disasm(method(:hello))
</pre> <p>Produces:</p> <pre>== disasm: &lt;RubyVM::InstructionSequence:hello@/tmp/method.rb&gt;============
0000 trace            8                                               (   1)
0002 trace            1                                               (   2)
0004 putself
0005 putstring        "hello, world"
0007 send             :puts, 1, nil, 8, &lt;ic:0&gt;
0013 trace            16                                              (   3)
0015 leave                                                            (   2)</pre> <p>For a Proc:</p> <pre class="ruby" data-language="ruby"># /tmp/proc.rb
p = proc { num = 1 + 2 }
puts RubyVM::InstructionSequence.disasm(p)
</pre> <p>Produces:</p> <pre>== disasm: &lt;RubyVM::InstructionSequence:block in &lt;main&gt;@/tmp/proc.rb&gt;===
== catch table
| catch type: redo   st: 0000 ed: 0012 sp: 0000 cont: 0000
| catch type: next   st: 0000 ed: 0012 sp: 0000 cont: 0012
|------------------------------------------------------------------------
local table (size: 2, argc: 0 [opts: 0, rest: -1, post: 0, block: -1] s1)
[ 2] num
0000 trace            1                                               (   1)
0002 putobject        1
0004 putobject        2
0006 opt_plus         &lt;ic:1&gt;
0008 dup
0009 setlocal         num, 0
0012 leave</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-disassemble"> <a href="#method-c-disassemble" title="Link to this method"> <span class="method-callseq"> disasm(body) → str </span> </a> </div> <div class="method-heading"> <a href="#method-c-disassemble" title="Link to this method"> <span class="method-callseq"> disassemble(body) → str </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="disassemble-source"> <pre class="c" data-language="c">static VALUE
iseqw_s_disasm(VALUE klass, VALUE body)
{
    VALUE iseqw = iseqw_s_of(klass, body);
    return NIL_P(iseqw) ? Qnil : rb_iseq_disasm(iseqw_check(iseqw));
}</pre> </div>  <p>Takes <code>body</code>, a <a href="../method.html"><code>Method</code></a> or <a href="../proc.html"><code>Proc</code></a> object, and returns a <a href="../string.html"><code>String</code></a> with the human readable instructions for <code>body</code>.</p> <p>For a <a href="../method.html"><code>Method</code></a> object:</p> <pre class="ruby" data-language="ruby"># /tmp/method.rb
def hello
  puts "hello, world"
end

puts RubyVM::InstructionSequence.disasm(method(:hello))
</pre> <p>Produces:</p> <pre>== disasm: &lt;RubyVM::InstructionSequence:hello@/tmp/method.rb&gt;============
0000 trace            8                                               (   1)
0002 trace            1                                               (   2)
0004 putself
0005 putstring        "hello, world"
0007 send             :puts, 1, nil, 8, &lt;ic:0&gt;
0013 trace            16                                              (   3)
0015 leave                                                            (   2)</pre> <p>For a Proc:</p> <pre class="ruby" data-language="ruby"># /tmp/proc.rb
p = proc { num = 1 + 2 }
puts RubyVM::InstructionSequence.disasm(p)
</pre> <p>Produces:</p> <pre>== disasm: &lt;RubyVM::InstructionSequence:block in &lt;main&gt;@/tmp/proc.rb&gt;===
== catch table
| catch type: redo   st: 0000 ed: 0012 sp: 0000 cont: 0000
| catch type: next   st: 0000 ed: 0012 sp: 0000 cont: 0012
|------------------------------------------------------------------------
local table (size: 2, argc: 0 [opts: 0, rest: -1, post: 0, block: -1] s1)
[ 2] num
0000 trace            1                                               (   1)
0002 putobject        1
0004 putobject        2
0006 opt_plus         &lt;ic:1&gt;
0008 dup
0009 setlocal         num, 0
0012 leave</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-load_from_binary"> <a href="#method-c-load_from_binary" title="Link to this method"> <span class="method-callseq"> RubyVM::InstructionSequence.load_from_binary(binary) → iseq </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="load_from_binary-source"> <pre class="c" data-language="c">static VALUE
iseqw_s_load_from_binary(VALUE self, VALUE str)
{
    return iseqw_new(rb_iseq_ibf_load(str));
}</pre> </div>  <p>Load an iseq object from binary format <a href="../string.html"><code>String</code></a> object created by <a href="instructionsequence.html#method-i-to_binary"><code>RubyVM::InstructionSequence.to_binary</code></a>.</p> <p>This loader does not have a verifier, so that loading broken/modified binary causes critical problem.</p> <p>You should not load binary data provided by others. You should use binary data translated by yourself.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-load_from_binary_extra_data"> <a href="#method-c-load_from_binary_extra_data" title="Link to this method"> <span class="method-callseq"> RubyVM::InstructionSequence.load_from_binary_extra_data(binary) → str </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="load_from_binary_extra_data-source"> <pre class="c" data-language="c">static VALUE
iseqw_s_load_from_binary_extra_data(VALUE self, VALUE str)
{
    return rb_iseq_ibf_load_extra_data(str);
}</pre> </div>  <p>Load extra data embed into binary format <a href="../string.html"><code>String</code></a> object.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-new"> <a href="#method-c-new" title="Link to this method"> <span class="method-callseq"> compile(source[, file[, path[, line[, options]]]]) → iseq </span> </a> </div> <div class="method-heading"> <a href="#method-c-new" title="Link to this method"> <span class="method-callseq"> new(source[, file[, path[, line[, options]]]]) → iseq </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="new-source"> <pre class="c" data-language="c">static VALUE
iseqw_s_compile(int argc, VALUE *argv, VALUE self)
{
    return iseqw_s_compile_parser(argc, argv, self, rb_ruby_prism_p());
}</pre> </div>  <p>Takes <code>source</code>, which can be a string of Ruby code, or an open <a href="../file.html"><code>File</code></a> object. that contains Ruby source code.</p> <p>Optionally takes <code>file</code>, <code>path</code>, and <code>line</code> which describe the file path, real path and first line number of the ruby code in <code>source</code> which are metadata attached to the returned <code>iseq</code>.</p> <p><code>file</code> is used for ‘__FILE__` and exception backtrace. <code>path</code> is used for <code>require_relative</code> base. It is recommended these should be the same full path.</p> <p><code>options</code>, which can be <code>true</code>, <code>false</code> or a <a href="../hash.html"><code>Hash</code></a>, is used to modify the default behavior of the Ruby iseq compiler.</p> <p>For details regarding valid compile options see <a href="instructionsequence.html#method-c-compile_option-3D"><code>::compile_option=</code></a>.</p> <pre class="ruby" data-language="ruby">RubyVM::InstructionSequence.compile("a = 1 + 2")
#=&gt; &lt;RubyVM::InstructionSequence:&lt;compiled&gt;@&lt;compiled&gt;&gt;

path = "test.rb"
RubyVM::InstructionSequence.compile(File.read(path), path, File.expand_path(path))
#=&gt; &lt;RubyVM::InstructionSequence:&lt;compiled&gt;@test.rb:1&gt;

file = File.open("test.rb")
RubyVM::InstructionSequence.compile(file)
#=&gt; &lt;RubyVM::InstructionSequence:&lt;compiled&gt;@&lt;compiled&gt;:1&gt;

path = File.expand_path("test.rb")
RubyVM::InstructionSequence.compile(File.read(path), path, path)
#=&gt; &lt;RubyVM::InstructionSequence:&lt;compiled&gt;@/absolute/path/to/test.rb:1&gt;
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-of"> <a href="#method-c-of" title="Link to this method"> <span class="method-name">of</span> <span class="method-args">(p1)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="of-source"> <pre class="c" data-language="c">static VALUE
iseqw_s_of(VALUE klass, VALUE body)
{
    const rb_iseq_t *iseq = NULL;

    if (rb_frame_info_p(body)) {
        iseq = rb_get_iseq_from_frame_info(body);
    }
    else if (rb_obj_is_proc(body)) {
        iseq = vm_proc_iseq(body);

        if (!rb_obj_is_iseq((VALUE)iseq)) {
            iseq = NULL;
        }
    }
    else if (rb_obj_is_method(body)) {
        iseq = rb_method_iseq(body);
    }
    else if (rb_typeddata_is_instance_of(body, &amp;iseqw_data_type)) {
        return body;
    }

    return iseq ? iseqw_new(iseq) : Qnil;
}</pre> </div>  <p>Returns the instruction sequence containing the given proc or method.</p> <p>For example, using irb:</p> <pre># a proc
&gt; p = proc { num = 1 + 2 }
&gt; RubyVM::InstructionSequence.of(p)
&gt; #=&gt; &lt;RubyVM::InstructionSequence:block in irb_binding@(irb)&gt;

# for a method
&gt; def foo(bar); puts bar; end
&gt; RubyVM::InstructionSequence.of(method(:foo))
&gt; #=&gt; &lt;RubyVM::InstructionSequence:foo@(irb)&gt;</pre> <p>Using <a href="instructionsequence.html#method-c-compile_file"><code>::compile_file</code></a>:</p> <pre># /tmp/iseq_of.rb
def hello
  puts "hello, world"
end

$a_global_proc = proc { str = 'a' + 'b' }

# in irb
&gt; require '/tmp/iseq_of.rb'

# first the method hello
&gt; RubyVM::InstructionSequence.of(method(:hello))
&gt; #=&gt; #&lt;RubyVM::InstructionSequence:0x007fb73d7cb1d0&gt;

# then the global proc
&gt; RubyVM::InstructionSequence.of($a_global_proc)
&gt; #=&gt; #&lt;RubyVM::InstructionSequence:0x007fb73d7caf78&gt;</pre> </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section anchor-link"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-absolute_path"> <a href="#method-i-absolute_path" title="Link to this method"> <span class="method-name">absolute_path</span> <span class="method-args">()</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="absolute_path-source"> <pre class="c" data-language="c">static VALUE
iseqw_absolute_path(VALUE self)
{
    return rb_iseq_realpath(iseqw_check(self));
}</pre> </div>  <p>Returns the absolute path of this instruction sequence.</p> <p><code>nil</code> if the iseq was evaluated from a string.</p> <p>For example, using <a href="instructionsequence.html#method-c-compile_file"><code>::compile_file</code></a>:</p> <pre># /tmp/method.rb
def hello
  puts "hello, world"
end

# in irb
&gt; iseq = RubyVM::InstructionSequence.compile_file('/tmp/method.rb')
&gt; iseq.absolute_path #=&gt; /tmp/method.rb</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-base_label"> <a href="#method-i-base_label" title="Link to this method"> <span class="method-name">base_label</span> <span class="method-args">()</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="base_label-source"> <pre class="c" data-language="c">static VALUE
iseqw_base_label(VALUE self)
{
    return rb_iseq_base_label(iseqw_check(self));
}</pre> </div>  <p>Returns the base label of this instruction sequence.</p> <p>For example, using irb:</p> <pre class="ruby" data-language="ruby">iseq = RubyVM::InstructionSequence.compile('num = 1 + 2')
#=&gt; &lt;RubyVM::InstructionSequence:&lt;compiled&gt;@&lt;compiled&gt;&gt;
iseq.base_label
#=&gt; "&lt;compiled&gt;"
</pre> <p>Using <a href="instructionsequence.html#method-c-compile_file"><code>::compile_file</code></a>:</p> <pre># /tmp/method.rb
def hello
  puts "hello, world"
end

# in irb
&gt; iseq = RubyVM::InstructionSequence.compile_file('/tmp/method.rb')
&gt; iseq.base_label #=&gt; &lt;main&gt;</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-disasm"> <a href="#method-i-disasm" title="Link to this method"> <span class="method-callseq"> disasm → str </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="disasm-source"> <pre class="c" data-language="c">static VALUE
iseqw_disasm(VALUE self)
{
    return rb_iseq_disasm(iseqw_check(self));
}</pre> </div>  <p>Returns the instruction sequence as a <a href="../string.html"><code>String</code></a> in human readable form.</p> <pre class="ruby" data-language="ruby">puts RubyVM::InstructionSequence.compile('1 + 2').disasm
</pre> <p>Produces:</p> <pre>== disasm: &lt;RubyVM::InstructionSequence:&lt;compiled&gt;@&lt;compiled&gt;&gt;==========
0000 trace            1                                               (   1)
0002 putobject        1
0004 putobject        2
0006 opt_plus         &lt;ic:1&gt;
0008 leave</pre> </div> <div class="aliases"> Also aliased as: <a href="instructionsequence.html#method-i-disassemble">disassemble</a>, disassemble </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-disassemble"> <a href="#method-i-disassemble" title="Link to this method"> <span class="method-callseq"> disassemble → str </span> </a> </div> </div> <div class="method-description"> <p>Returns the instruction sequence as a <a href="../string.html"><code>String</code></a> in human readable form.</p> <pre class="ruby" data-language="ruby">puts RubyVM::InstructionSequence.compile('1 + 2').disasm
</pre> <p>Produces:</p> <pre>== disasm: &lt;RubyVM::InstructionSequence:&lt;compiled&gt;@&lt;compiled&gt;&gt;==========
0000 trace            1                                               (   1)
0002 putobject        1
0004 putobject        2
0006 opt_plus         &lt;ic:1&gt;
0008 leave</pre> </div> <div class="aliases"> Alias for: <a href="instructionsequence.html#method-i-disasm">disasm</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-each_child"> <a href="#method-i-each_child" title="Link to this method"> <span class="method-callseq"> each_child{|child_iseq| ...} → iseq </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="each_child-source"> <pre class="c" data-language="c">static VALUE
iseqw_each_child(VALUE self)
{
    const rb_iseq_t *iseq = iseqw_check(self);
    iseq_iterate_children(iseq, yield_each_children, NULL);
    return self;
}</pre> </div>  <p>Iterate all direct child instruction sequences. Iteration order is implementation/version defined so that people should not rely on the order.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-eval"> <a href="#method-i-eval" title="Link to this method"> <span class="method-callseq"> eval → obj </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="eval-source"> <pre class="c" data-language="c">static VALUE
iseqw_eval(VALUE self)
{
    return rb_iseq_eval(iseqw_check(self));
}</pre> </div>  <p>Evaluates the instruction sequence and returns the result.</p> <pre class="ruby" data-language="ruby">RubyVM::InstructionSequence.compile("1 + 2").eval #=&gt; 3
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-first_lineno"> <a href="#method-i-first_lineno" title="Link to this method"> <span class="method-name">first_lineno</span> <span class="method-args">()</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="first_lineno-source"> <pre class="c" data-language="c">static VALUE
iseqw_first_lineno(VALUE self)
{
    return rb_iseq_first_lineno(iseqw_check(self));
}</pre> </div>  <p>Returns the number of the first source line where the instruction sequence was loaded from.</p> <p>For example, using irb:</p> <pre class="ruby" data-language="ruby">iseq = RubyVM::InstructionSequence.compile('num = 1 + 2')
#=&gt; &lt;RubyVM::InstructionSequence:&lt;compiled&gt;@&lt;compiled&gt;&gt;
iseq.first_lineno
#=&gt; 1
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-inspect"> <a href="#method-i-inspect" title="Link to this method"> <span class="method-name">inspect</span> <span class="method-args">()</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="inspect-source"> <pre class="c" data-language="c">static VALUE
iseqw_inspect(VALUE self)
{
    const rb_iseq_t *iseq = iseqw_check(self);
    const struct rb_iseq_constant_body *const body = ISEQ_BODY(iseq);
    VALUE klass = rb_class_name(rb_obj_class(self));

    if (!body-&gt;location.label) {
        return rb_sprintf("#&lt;%"PRIsVALUE": uninitialized&gt;", klass);
    }
    else {
        return rb_sprintf("&lt;%"PRIsVALUE":%"PRIsVALUE"@%"PRIsVALUE":%d&gt;",
                          klass,
                          body-&gt;location.label, rb_iseq_path(iseq),
                          FIX2INT(rb_iseq_first_lineno(iseq)));
    }
}</pre> </div>  <p>Returns a human-readable string representation of this instruction sequence, including the <a href="instructionsequence.html#method-i-label"><code>label</code></a> and <a href="instructionsequence.html#method-i-path"><code>path</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-label"> <a href="#method-i-label" title="Link to this method"> <span class="method-name">label</span> <span class="method-args">()</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="label-source"> <pre class="c" data-language="c">static VALUE
iseqw_label(VALUE self)
{
    return rb_iseq_label(iseqw_check(self));
}</pre> </div>  <p>Returns the label of this instruction sequence.</p> <p><code>&lt;main&gt;</code> if it’s at the top level, <code>&lt;compiled&gt;</code> if it was evaluated from a string.</p> <p>For example, using irb:</p> <pre class="ruby" data-language="ruby">iseq = RubyVM::InstructionSequence.compile('num = 1 + 2')
#=&gt; &lt;RubyVM::InstructionSequence:&lt;compiled&gt;@&lt;compiled&gt;&gt;
iseq.label
#=&gt; "&lt;compiled&gt;"
</pre> <p>Using <a href="instructionsequence.html#method-c-compile_file"><code>::compile_file</code></a>:</p> <pre># /tmp/method.rb
def hello
  puts "hello, world"
end

# in irb
&gt; iseq = RubyVM::InstructionSequence.compile_file('/tmp/method.rb')
&gt; iseq.label #=&gt; &lt;main&gt;</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-path"> <a href="#method-i-path" title="Link to this method"> <span class="method-name">path</span> <span class="method-args">()</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="path-source"> <pre class="c" data-language="c">static VALUE
iseqw_path(VALUE self)
{
    return rb_iseq_path(iseqw_check(self));
}</pre> </div>  <p>Returns the path of this instruction sequence.</p> <p><code>&lt;compiled&gt;</code> if the iseq was evaluated from a string.</p> <p>For example, using irb:</p> <pre class="ruby" data-language="ruby">iseq = RubyVM::InstructionSequence.compile('num = 1 + 2')
#=&gt; &lt;RubyVM::InstructionSequence:&lt;compiled&gt;@&lt;compiled&gt;&gt;
iseq.path
#=&gt; "&lt;compiled&gt;"
</pre> <p>Using <a href="instructionsequence.html#method-c-compile_file"><code>::compile_file</code></a>:</p> <pre># /tmp/method.rb
def hello
  puts "hello, world"
end

# in irb
&gt; iseq = RubyVM::InstructionSequence.compile_file('/tmp/method.rb')
&gt; iseq.path #=&gt; /tmp/method.rb</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-script_lines"> <a href="#method-i-script_lines" title="Link to this method"> <span class="method-callseq"> script_lines → array or nil </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="script_lines-source"> <pre class="c" data-language="c">static VALUE
iseqw_script_lines(VALUE self)
{
    const rb_iseq_t *iseq = iseqw_check(self);
    return ISEQ_BODY(iseq)-&gt;variable.script_lines;
}</pre> </div>  <p>It returns recorded script lines if it is available. The script lines are not limited to the iseq range, but are entire lines of the source file.</p> <p>Note that this is an API for ruby internal use, debugging, and research. Do not use this for any other purpose. The compatibility is not guaranteed.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-to_a"> <a href="#method-i-to_a" title="Link to this method"> <span class="method-callseq"> to_a → ary </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="to_a-source"> <pre class="c" data-language="c">static VALUE
iseqw_to_a(VALUE self)
{
    const rb_iseq_t *iseq = iseqw_check(self);
    return iseq_data_to_ary(iseq);
}</pre> </div>  <p>Returns an <a href="../array.html"><code>Array</code></a> with 14 elements representing the instruction sequence with the following data:</p> <dl class="rdoc-list label-list">
<dt>magic</dt> <dd> <p>A string identifying the data format. <strong>Always <code>YARVInstructionSequence/SimpleDataFormat</code>.</strong></p> </dd>
<dt>major_version</dt> <dd> <p>The major version of the instruction sequence.</p> </dd>
<dt>minor_version</dt> <dd> <p>The minor version of the instruction sequence.</p> </dd>
<dt>format_type</dt> <dd> <p>A number identifying the data format. <strong>Always 1</strong>.</p> </dd>
<dt>misc</dt> <dd> <p>A hash containing:</p> <dl class="rdoc-list label-list">
<dt><code>:arg_size</code></dt> <dd> <p>the total number of arguments taken by the method or the block (0 if <em>iseq</em> doesn’t represent a method or block)</p> </dd>
<dt><code>:local_size</code></dt> <dd> <p>the number of local variables + 1</p> </dd>
<dt><code>:stack_max</code></dt> <dd> <p>used in calculating the stack depth at which a <a href="../systemstackerror.html"><code>SystemStackError</code></a> is thrown.</p> </dd>
</dl> </dd>
<dt><a href="instructionsequence.html#method-i-label"><code>label</code></a></dt> <dd> <p>The name of the context (block, method, class, module, etc.) that this instruction sequence belongs to.</p> <p><code>&lt;main&gt;</code> if it’s at the top level, <code>&lt;compiled&gt;</code> if it was evaluated from a string.</p> </dd>
<dt><a href="instructionsequence.html#method-i-path"><code>path</code></a></dt> <dd> <p>The relative path to the Ruby file where the instruction sequence was loaded from.</p> <p><code>&lt;compiled&gt;</code> if the iseq was evaluated from a string.</p> </dd>
<dt><a href="instructionsequence.html#method-i-absolute_path"><code>absolute_path</code></a></dt> <dd> <p>The absolute path to the Ruby file where the instruction sequence was loaded from.</p> <p><code>nil</code> if the iseq was evaluated from a string.</p> </dd>
<dt><a href="instructionsequence.html#method-i-first_lineno"><code>first_lineno</code></a></dt> <dd> <p>The number of the first source line where the instruction sequence was loaded from.</p> </dd>
<dt>type</dt> <dd> <p>The type of the instruction sequence.</p> <p>Valid values are <code>:top</code>, <code>:method</code>, <code>:block</code>, <code>:class</code>, <code>:rescue</code>, <code>:ensure</code>, <code>:eval</code>, <code>:main</code>, and <code>plain</code>.</p> </dd>
<dt>locals</dt> <dd> <p>An array containing the names of all arguments and local variables as symbols.</p> </dd>
<dt>params</dt> <dd> <p>An <a href="../hash.html"><code>Hash</code></a> object containing parameter information.</p> <p>More info about these values can be found in <code>vm_core.h</code>.</p> </dd>
<dt>catch_table</dt> <dd> <p>A list of exceptions and control flow operators (rescue, next, redo, break, etc.).</p> </dd>
<dt>bytecode</dt> <dd> <p>An array of arrays containing the instruction names and operands that make up the body of the instruction sequence.</p> </dd>
</dl> <p>Note that this format is MRI specific and version dependent.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-to_binary"> <a href="#method-i-to_binary" title="Link to this method"> <span class="method-callseq"> to_binary(extra_data = nil) → binary str </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="to_binary-source"> <pre class="c" data-language="c">static VALUE
iseqw_to_binary(int argc, VALUE *argv, VALUE self)
{
    VALUE opt = !rb_check_arity(argc, 0, 1) ? Qnil : argv[0];
    return rb_iseq_ibf_dump(iseqw_check(self), opt);
}</pre> </div>  <p>Returns serialized iseq binary format data as a <a href="../string.html"><code>String</code></a> object. A corresponding iseq object is created by <a href="instructionsequence.html#method-c-load_from_binary"><code>RubyVM::InstructionSequence.load_from_binary()</code></a> method.</p> <p><a href="../string.html"><code>String</code></a> extra_data will be saved with binary data. You can access this data with <a href="instructionsequence.html#method-c-load_from_binary_extra_data"><code>RubyVM::InstructionSequence.load_from_binary_extra_data(binary)</code></a>.</p> <p>Note that the translated binary data is not portable. You can not move this binary data to another machine. You can not use the binary data which is created by another version/another architecture of Ruby.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-trace_points"> <a href="#method-i-trace_points" title="Link to this method"> <span class="method-callseq"> trace_points → ary </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="trace_points-source"> <pre class="c" data-language="c">static VALUE
iseqw_trace_points(VALUE self)
{
    const rb_iseq_t *iseq = iseqw_check(self);
    const struct rb_iseq_constant_body *const body = ISEQ_BODY(iseq);
    unsigned int i;
    VALUE ary = rb_ary_new();

    for (i=0; i&lt;body-&gt;insns_info.size; i++) {
        const struct iseq_insn_info_entry *entry = &amp;body-&gt;insns_info.body[i];
        if (entry-&gt;events) {
            push_event_info(iseq, entry-&gt;events, entry-&gt;line_no, ary);
        }
    }
    return ary;
}</pre> </div>  <p>Return trace points in the instruction sequence. Return an array of [line, event_symbol] pair.</p> </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core &copy; 1993&ndash;2024 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library &copy; contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>
