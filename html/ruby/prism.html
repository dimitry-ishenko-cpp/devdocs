<h1 id="module-Prism" class="module"> module Prism </h1> <section class="description"> <p>The <a href="prism.html"><code>Prism</code></a> Ruby parser.</p> <p>“Parsing Ruby is suddenly manageable!”</p> <pre>- You, hopefully</pre> <p>This file is generated by the templates/template.rb script and should not be modified manually. See templates/lib/prism/compiler.rb.erb if you are looking to modify the template</p> <p>This file is generated by the templates/template.rb script and should not be modified manually. See templates/lib/prism/dispatcher.rb.erb if you are looking to modify the template</p> <p>This file is generated by the templates/template.rb script and should not be modified manually. See templates/lib/prism/dsl.rb.erb if you are looking to modify the template</p> <p>This file is generated by the templates/template.rb script and should not be modified manually. See templates/lib/prism/mutation_compiler.rb.erb if you are looking to modify the template</p> <p>This file is generated by the templates/template.rb script and should not be modified manually. See templates/lib/prism/node.rb.erb if you are looking to modify the template</p> <p>Here we are reopening the prism module to provide methods on nodes that aren’t templated and are meant as convenience methods.</p> <p>This file is generated by the templates/template.rb script and should not be modified manually. See templates/lib/prism/visitor.rb.erb if you are looking to modify the template</p> </section> <section id="5Buntitled-5D" class="documentation-section"> <section class="constants-list"> <header> <h3>Constants</h3> </header> <dl> <dt id="BACKEND">BACKEND </dt>

<dt id="VERSION">VERSION </dt>
<dd>
<p>The version constant is set by reading the result of calling pm_version.</p> </dd>
</dl> </section> <section id="public-class-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-dump"> <span class="method-name">dump</span><span class="method-args">(code, **options)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="dump-source"> <pre class="ruby" data-language="ruby"># File lib/prism/ffi.rb, line 182
def dump(code, **options)
  LibRubyParser::PrismBuffer.with do |buffer|
    LibRubyParser.pm_serialize_parse(buffer.pointer, code, code.bytesize, dump_options(options))
    buffer.read
  end
end</pre> </div> <p>Mirror the <a href="prism.html#method-c-dump"><code>Prism.dump</code></a> API by using the serialization API.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-dump_file"> <span class="method-name">dump_file</span><span class="method-args">(filepath, **options)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="dump_file-source"> <pre class="ruby" data-language="ruby"># File lib/prism/ffi.rb, line 190
def dump_file(filepath, **options)
  LibRubyParser::PrismString.with(filepath) do |string|
    dump(string.read, **options, filepath: filepath)
  end
end</pre> </div> <p>Mirror the <a href="prism.html#method-c-dump_file"><code>Prism.dump_file</code></a> API by using the serialization API.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-lex"> <span class="method-name">lex</span><span class="method-args">(code, **options)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="lex-source"> <pre class="ruby" data-language="ruby"># File lib/prism/ffi.rb, line 197
def lex(code, **options)
  LibRubyParser::PrismBuffer.with do |buffer|
    LibRubyParser.pm_serialize_lex(buffer.pointer, code, code.bytesize, dump_options(options))
    Serialize.load_tokens(Source.new(code), buffer.read)
  end
end</pre> </div> <p>Mirror the <a href="prism.html#method-c-lex"><code>Prism.lex</code></a> API by using the serialization API.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-lex_compat"> <span class="method-callseq"> Prism::lex_compat(source, **options) → ParseResult </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="lex_compat-source"> <pre class="ruby" data-language="ruby"># File lib/prism.rb, line 46
def self.lex_compat(source, **options)
  LexCompat.new(source, **options).result
end</pre> </div> <p>Returns a parse result whose value is an array of tokens that closely resembles the return value of <a href="ripper.html#method-c-lex"><code>Ripper::lex</code></a>. The main difference is that the ‘:on_sp` token is not emitted.</p> <p>For supported options, see <a href="prism.html#method-c-parse"><code>Prism::parse</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-lex_file"> <span class="method-name">lex_file</span><span class="method-args">(filepath, **options)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="lex_file-source"> <pre class="ruby" data-language="ruby"># File lib/prism/ffi.rb, line 205
def lex_file(filepath, **options)
  LibRubyParser::PrismString.with(filepath) do |string|
    lex(string.read, **options, filepath: filepath)
  end
end</pre> </div> <p>Mirror the <a href="prism.html#method-c-lex_file"><code>Prism.lex_file</code></a> API by using the serialization API.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-lex_ripper"> <span class="method-callseq"> Prism::lex_ripper(source) → Array </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="lex_ripper-source"> <pre class="ruby" data-language="ruby"># File lib/prism.rb, line 56
def self.lex_ripper(source)
  LexRipper.new(source).result
end</pre> </div> <p>This lexes with the <a href="ripper.html"><code>Ripper</code></a> lex. It drops any space events but otherwise returns the same tokens. Raises <a href="syntaxerror.html"><code>SyntaxError</code></a> if the syntax in source is invalid.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-load"> <span class="method-callseq"> Prism::load(source, serialized) → ParseResult </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="load-source"> <pre class="ruby" data-language="ruby"># File lib/prism.rb, line 64
def self.load(source, serialized)
  Serialize.load(source, serialized)
end</pre> </div> <p>Load the serialized AST using the source as a reference into a tree.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-parse"> <span class="method-name">parse</span><span class="method-args">(code, **options)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="parse-source"> <pre class="ruby" data-language="ruby"># File lib/prism/ffi.rb, line 212
def parse(code, **options)
  Prism.load(code, dump(code, **options))
end</pre> </div> <p>Mirror the <a href="prism.html#method-c-parse"><code>Prism.parse</code></a> API by using the serialization API.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-parse_comments"> <span class="method-name">parse_comments</span><span class="method-args">(code, **options)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="parse_comments-source"> <pre class="ruby" data-language="ruby"># File lib/prism/ffi.rb, line 226
def parse_comments(code, **options)
  LibRubyParser::PrismBuffer.with do |buffer|
    LibRubyParser.pm_serialize_parse_comments(buffer.pointer, code, code.bytesize, dump_options(options))

    source = Source.new(code)
    loader = Serialize::Loader.new(source, buffer.read)

    loader.load_header
    loader.load_encoding
    loader.load_start_line
    loader.load_comments
  end
end</pre> </div> <p>Mirror the <a href="prism.html#method-c-parse_comments"><code>Prism.parse_comments</code></a> API by using the serialization API.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-parse_failure-3F"> <span class="method-callseq"> Prism::parse_failure?(source, **options) → bool </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="parse_failure-3F-source"> <pre class="ruby" data-language="ruby"># File lib/prism.rb, line 72
def self.parse_failure?(source, **options)
  !parse_success?(source, **options)
end</pre> </div> <p>Returns true if the source parses with errors.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-parse_file"> <span class="method-name">parse_file</span><span class="method-args">(filepath, **options)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="parse_file-source"> <pre class="ruby" data-language="ruby"># File lib/prism/ffi.rb, line 219
def parse_file(filepath, **options)
  LibRubyParser::PrismString.with(filepath) do |string|
    parse(string.read, **options, filepath: filepath)
  end
end</pre> </div> <p>Mirror the <a href="prism.html#method-c-parse_file"><code>Prism.parse_file</code></a> API by using the serialization API. This uses native strings instead of Ruby strings because it allows us to use mmap when it is available.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-parse_file_comments"> <span class="method-name">parse_file_comments</span><span class="method-args">(filepath, **options)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="parse_file_comments-source"> <pre class="ruby" data-language="ruby"># File lib/prism/ffi.rb, line 243
def parse_file_comments(filepath, **options)
  LibRubyParser::PrismString.with(filepath) do |string|
    parse_comments(string.read, **options, filepath: filepath)
  end
end</pre> </div> <p>Mirror the <a href="prism.html#method-c-parse_file_comments"><code>Prism.parse_file_comments</code></a> API by using the serialization API. This uses native strings instead of Ruby strings because it allows us to use mmap when it is available.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-parse_file_failure-3F"> <span class="method-callseq"> Prism::parse_file_failure?(filepath, **options) → bool </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="parse_file_failure-3F-source"> <pre class="ruby" data-language="ruby"># File lib/prism.rb, line 80
def self.parse_file_failure?(filepath, **options)
  !parse_file_success?(filepath, **options)
end</pre> </div> <p>Returns true if the file at filepath parses with errors.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-parse_file_success-3F"> <span class="method-name">parse_file_success?</span><span class="method-args">(filepath, **options)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="parse_file_success-3F-source"> <pre class="ruby" data-language="ruby"># File lib/prism/ffi.rb, line 278
def parse_file_success?(filepath, **options)
  LibRubyParser::PrismString.with(filepath) do |string|
    parse_success?(string.read, **options, filepath: filepath)
  end
end</pre> </div> <p>Mirror the <a href="prism.html#method-c-parse_file_success-3F"><code>Prism.parse_file_success?</code></a> API by using the serialization API.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-parse_lex"> <span class="method-name">parse_lex</span><span class="method-args">(code, **options)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="parse_lex-source"> <pre class="ruby" data-language="ruby"># File lib/prism/ffi.rb, line 250
def parse_lex(code, **options)
  LibRubyParser::PrismBuffer.with do |buffer|
    LibRubyParser.pm_serialize_parse_lex(buffer.pointer, code, code.bytesize, dump_options(options))

    source = Source.new(code)
    loader = Serialize::Loader.new(source, buffer.read)

    tokens = loader.load_tokens
    node, comments, magic_comments, data_loc, errors, warnings = loader.load_nodes
    tokens.each { |token,| token.value.force_encoding(loader.encoding) }

    ParseResult.new([node, tokens], comments, magic_comments, data_loc, errors, warnings, source)
  end
end</pre> </div> <p>Mirror the <a href="prism.html#method-c-parse_lex"><code>Prism.parse_lex</code></a> API by using the serialization API.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-parse_lex_file"> <span class="method-name">parse_lex_file</span><span class="method-args">(filepath, **options)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="parse_lex_file-source"> <pre class="ruby" data-language="ruby"># File lib/prism/ffi.rb, line 266
def parse_lex_file(filepath, **options)
  LibRubyParser::PrismString.with(filepath) do |string|
    parse_lex(string.read, **options, filepath: filepath)
  end
end</pre> </div> <p>Mirror the <a href="prism.html#method-c-parse_lex_file"><code>Prism.parse_lex_file</code></a> API by using the serialization API.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-parse_success-3F"> <span class="method-name">parse_success?</span><span class="method-args">(code, **options)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="parse_success-3F-source"> <pre class="ruby" data-language="ruby"># File lib/prism/ffi.rb, line 273
def parse_success?(code, **options)
  LibRubyParser.pm_parse_success_p(code, code.bytesize, dump_options(options))
end</pre> </div> <p>Mirror the <a href="prism.html#method-c-parse_success-3F"><code>Prism.parse_success?</code></a> API by using the serialization API.</p>  </div> </div> </section> <section id="private-class-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Private Class Methods</h3> </header> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-dump_options"> <span class="method-name">dump_options</span><span class="method-args">(options)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="dump_options-source"> <pre class="ruby" data-language="ruby"># File lib/prism/ffi.rb, line 287
def dump_options(options)
  template = +""
  values = []

  template &lt;&lt; "L"
  if (filepath = options[:filepath])
    values.push(filepath.bytesize, filepath.b)
    template &lt;&lt; "A*"
  else
    values &lt;&lt; 0
  end

  template &lt;&lt; "L"
  values &lt;&lt; options.fetch(:line, 1)

  template &lt;&lt; "L"
  if (encoding = options[:encoding])
    name = encoding.name
    values.push(name.bytesize, name.b)
    template &lt;&lt; "A*"
  else
    values &lt;&lt; 0
  end

  template &lt;&lt; "C"
  values &lt;&lt; (options.fetch(:frozen_string_literal, false) ? 1 : 0)

  template &lt;&lt; "C"
  values &lt;&lt; (options.fetch(:verbose, true) ? 0 : 1)

  template &lt;&lt; "L"
  if (scopes = options[:scopes])
    values &lt;&lt; scopes.length

    scopes.each do |scope|
      template &lt;&lt; "L"
      values &lt;&lt; scope.length

      scope.each do |local|
        name = local.name
        template &lt;&lt; "L"
        values &lt;&lt; name.bytesize

        template &lt;&lt; "A*"
        values &lt;&lt; name.b
      end
    end
  else
    values &lt;&lt; 0
  end

  values.pack(template)
end</pre> </div> <p>Convert the given options into a serialized options string.</p>  </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core &copy; 1993&ndash;2022 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library &copy; contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>
