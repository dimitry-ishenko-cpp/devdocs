<h1 id="module-URI" class="anchor-link module"> module URI </h1> <section class="description"> <p><a href="uri.html"><code>URI</code></a> is a module providing classes to handle Uniform Resource Identifiers (<a href="https://www.rfc-editor.org/rfc/rfc2396">RFC2396</a>).</p> <h2 id="module-URI-label-Features">Features</h2> <ul>
<li> <p>Uniform way of handling URIs.</p> </li>
<li> <p>Flexibility to introduce custom <a href="uri.html"><code>URI</code></a> schemes.</p> </li>
<li> <p>Flexibility to have an alternate URI::Parser (or just different patterns and regexp’s).</p> </li>
</ul> <h2 id="module-URI-label-Basic+example">Basic example</h2> <pre class="ruby" data-language="ruby">require 'uri'

uri = URI("http://foo.com/posts?id=30&amp;limit=5#time=1305298413")
#=&gt; #&lt;URI::HTTP http://foo.com/posts?id=30&amp;limit=5#time=1305298413&gt;

uri.scheme    #=&gt; "http"
uri.host      #=&gt; "foo.com"
uri.path      #=&gt; "/posts"
uri.query     #=&gt; "id=30&amp;limit=5"
uri.fragment  #=&gt; "time=1305298413"

uri.to_s      #=&gt; "http://foo.com/posts?id=30&amp;limit=5#time=1305298413"
</pre> <h2 id="module-URI-label-Adding+custom+URIs">Adding custom URIs</h2> <pre class="ruby" data-language="ruby">module URI
  class RSYNC &lt; Generic
    DEFAULT_PORT = 873
  end
  register_scheme 'RSYNC', RSYNC
end
#=&gt; URI::RSYNC

URI.scheme_list
#=&gt; {"FILE"=&gt;URI::File, "FTP"=&gt;URI::FTP, "HTTP"=&gt;URI::HTTP,
#    "HTTPS"=&gt;URI::HTTPS, "LDAP"=&gt;URI::LDAP, "LDAPS"=&gt;URI::LDAPS,
#    "MAILTO"=&gt;URI::MailTo, "RSYNC"=&gt;URI::RSYNC}

uri = URI("rsync://rsync.foo.com")
#=&gt; #&lt;URI::RSYNC rsync://rsync.foo.com&gt;
</pre> <h2 id="module-URI-label-RFC+References">RFC References</h2> <p>A good place to view an RFC spec is <a href="http://www.ietf.org/rfc.html">www.ietf.org/rfc.html</a>.</p> <p>Here is a list of all related RFC’s:</p> <ul>
<li> <p><a href="https://www.rfc-editor.org/rfc/rfc822">RFC822</a></p> </li>
<li> <p><a href="https://www.rfc-editor.org/rfc/rfc1738">RFC1738</a></p> </li>
<li> <p><a href="https://www.rfc-editor.org/rfc/rfc2255">RFC2255</a></p> </li>
<li> <p><a href="https://www.rfc-editor.org/rfc/rfc2368">RFC2368</a></p> </li>
<li> <p><a href="https://www.rfc-editor.org/rfc/rfc2373">RFC2373</a></p> </li>
<li> <p><a href="https://www.rfc-editor.org/rfc/rfc2396">RFC2396</a></p> </li>
<li> <p><a href="https://www.rfc-editor.org/rfc/rfc2732">RFC2732</a></p> </li>
<li> <p><a href="https://www.rfc-editor.org/rfc/rfc3986">RFC3986</a></p> </li>
</ul> <h2 id="module-URI-label-Class+tree">
<a href="class.html"><code>Class</code></a> tree</h2> <ul>
<li> <p><a href="uri/generic.html"><code>URI::Generic</code></a> (in uri/generic.rb)</p> <ul>
<li> <p><a href="uri/file.html"><code>URI::File</code></a> - (in uri/file.rb)</p> </li>
<li> <p><a href="uri/ftp.html"><code>URI::FTP</code></a> - (in uri/ftp.rb)</p> </li>
<li> <p><a href="uri/http.html"><code>URI::HTTP</code></a> - (in uri/http.rb)</p> <ul><li> <p><a href="uri/https.html"><code>URI::HTTPS</code></a> - (in uri/https.rb)</p> </li></ul> </li>
<li> <p><a href="uri/ldap.html"><code>URI::LDAP</code></a> - (in uri/ldap.rb)</p> <ul><li> <p><a href="uri/ldaps.html"><code>URI::LDAPS</code></a> - (in uri/ldaps.rb)</p> </li></ul> </li>
<li> <p><a href="uri/mailto.html"><code>URI::MailTo</code></a> - (in uri/mailto.rb)</p> </li>
</ul> </li>
<li> <p>URI::Parser - (in uri/common.rb)</p> </li>
<li> <p>URI::REGEXP - (in uri/common.rb)</p> <ul><li> <p>URI::REGEXP::PATTERN - (in uri/common.rb)</p> </li></ul> </li>
<li> <p>URI::Util - (in uri/common.rb)</p> </li>
<li> <p><a href="uri/error.html"><code>URI::Error</code></a> - (in uri/common.rb)</p> <ul>
<li> <p><a href="uri/invalidurierror.html"><code>URI::InvalidURIError</code></a> - (in uri/common.rb)</p> </li>
<li> <p><a href="uri/invalidcomponenterror.html"><code>URI::InvalidComponentError</code></a> - (in uri/common.rb)</p> </li>
<li> <p><a href="uri/badurierror.html"><code>URI::BadURIError</code></a> - (in uri/common.rb)</p> </li>
</ul> </li>
</ul> <h2 id="module-URI-label-Copyright+Info">Copyright Info</h2> <dl class="rdoc-list note-list">
<dt>Author</dt> <dd> <p>Akira Yamada &lt;akira@ruby-lang.org&gt;</p> </dd>
<dt>Documentation</dt> <dd> <p>Akira Yamada &lt;akira@ruby-lang.org&gt; Dmitry V. Sabanin &lt;sdmitry@lrn.ru&gt; Vincent Batts &lt;vbatts@hashbangbash.com&gt;</p> </dd>
<dt>License</dt> <dd> <p>Copyright © 2001 akira yamada &lt;akira@ruby-lang.org&gt; You can redistribute it and/or modify it under the same term as Ruby.</p> </dd>
</dl> </section> <section id="5Buntitled-5D" class="documentation-section anchor-link"> <section class="constants-list"> <header> <h3>Constants</h3> </header> <dl> <dt id="DEFAULT_PARSER">DEFAULT_PARSER </dt>

<dt id="INITIAL_SCHEMES">INITIAL_SCHEMES </dt>

<dt id="RFC2396_PARSER">RFC2396_PARSER </dt>

<dt id="RFC3986_PARSER">RFC3986_PARSER </dt>

<dt id="TBLENCURICOMP_">TBLENCURICOMP_ </dt>

</dl> </section> <section id="public-class-5Buntitled-5D-method-details" class="method-section anchor-link"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-const_missing"> <a href="#method-c-const_missing" title="Link to this method"> <span class="method-name">const_missing</span> <span class="method-args">(const)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="const_missing-source"> <pre class="ruby" data-language="ruby"># File lib/uri/common.rb, line 43
def self.const_missing(const)
  if const == :REGEXP
    warn "URI::REGEXP is obsolete. Use URI::RFC2396_REGEXP explicitly.", uplevel: 1 if $VERBOSE
    URI::RFC2396_REGEXP
  elsif value = RFC2396_PARSER.regexp[const]
    warn "URI::#{const} is obsolete. Use RFC2396_PARSER.regexp[#{const.inspect}] explicitly.", uplevel: 1 if $VERBOSE
    value
  elsif value = RFC2396_Parser.const_get(const)
    warn "URI::#{const} is obsolete. Use RFC2396_Parser::#{const} explicitly.", uplevel: 1 if $VERBOSE
    value
  else
    super
  end
end</pre> </div>  <div class="method-calls-super"> Calls superclass method </div> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-decode_uri_component"> <a href="#method-c-decode_uri_component" title="Link to this method"> <span class="method-name">decode_uri_component</span> <span class="method-args">(str, enc=Encoding::UTF_8)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="decode_uri_component-source"> <pre class="ruby" data-language="ruby"># File lib/uri/common.rb, line 402
def self.decode_uri_component(str, enc=Encoding::UTF_8)
  _decode_uri_component(/%\h\h/, str, enc)
end</pre> </div>  <p>Like <a href="uri.html#method-c-decode_www_form_component"><code>URI.decode_www_form_component</code></a>, except that <code>'+'</code> is preserved.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-decode_www_form"> <a href="#method-c-decode_www_form" title="Link to this method"> <span class="method-name">decode_www_form</span> <span class="method-args">(str, enc=Encoding::UTF_8, separator: '&amp;', use__charset_: false, isindex: false)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="decode_www_form-source"> <pre class="ruby" data-language="ruby"># File lib/uri/common.rb, line 577
def self.decode_www_form(str, enc=Encoding::UTF_8, separator: '&amp;', use__charset_: false, isindex: false)
  raise ArgumentError, "the input of #{self.name}.#{__method__} must be ASCII only string" unless str.ascii_only?
  ary = []
  return ary if str.empty?
  enc = Encoding.find(enc)
  str.b.each_line(separator) do |string|
    string.chomp!(separator)
    key, sep, val = string.partition('=')
    if isindex
      if sep.empty?
        val = key
        key = +''
      end
      isindex = false
    end

    if use__charset_ and key == '_charset_' and e = get_encoding(val)
      enc = e
      use__charset_ = false
    end

    key.gsub!(/\+|%\h\h/, TBLDECWWWCOMP_)
    if val
      val.gsub!(/\+|%\h\h/, TBLDECWWWCOMP_)
    else
      val = +''
    end

    ary &lt;&lt; [key, val]
  end
  ary.each do |k, v|
    k.force_encoding(enc)
    k.scrub!
    v.force_encoding(enc)
    v.scrub!
  end
  ary
end</pre> </div>  <p>Returns name/value pairs derived from the given string <code>str</code>, which must be an ASCII string.</p> <p>The method may be used to decode the body of <a href="net/httpresponse.html"><code>Net::HTTPResponse</code></a> object <code>res</code> for which <code>res['Content-Type']</code> is <code>'application/x-www-form-urlencoded'</code>.</p> <p>The returned data is an array of 2-element subarrays; each subarray is a name/value pair (both are strings). Each returned string has encoding <code>enc</code>, and has had invalid characters removed via <a href="string.html#method-i-scrub"><code>String#scrub</code></a>.</p> <p>A simple example:</p> <pre class="ruby" data-language="ruby">URI.decode_www_form('foo=0&amp;bar=1&amp;baz')
# =&gt; [["foo", "0"], ["bar", "1"], ["baz", ""]]
</pre> <p>The returned strings have certain conversions, similar to those performed in <a href="uri.html#method-c-decode_www_form_component"><code>URI.decode_www_form_component</code></a>:</p> <pre class="ruby" data-language="ruby">URI.decode_www_form('f%23o=%2F&amp;b-r=%24&amp;b+z=%40')
# =&gt; [["f#o", "/"], ["b-r", "$"], ["b z", "@"]]
</pre> <p>The given string may contain consecutive separators:</p> <pre class="ruby" data-language="ruby">URI.decode_www_form('foo=0&amp;&amp;bar=1&amp;&amp;baz=2')
# =&gt; [["foo", "0"], ["", ""], ["bar", "1"], ["", ""], ["baz", "2"]]
</pre> <p>A different separator may be specified:</p> <pre class="ruby" data-language="ruby">URI.decode_www_form('foo=0--bar=1--baz', separator: '--')
# =&gt; [["foo", "0"], ["bar", "1"], ["baz", ""]]
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-decode_www_form_component"> <a href="#method-c-decode_www_form_component" title="Link to this method"> <span class="method-name">decode_www_form_component</span> <span class="method-args">(str, enc=Encoding::UTF_8)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="decode_www_form_component-source"> <pre class="ruby" data-language="ruby"># File lib/uri/common.rb, line 391
def self.decode_www_form_component(str, enc=Encoding::UTF_8)
  _decode_uri_component(/\+|%\h\h/, str, enc)
end</pre> </div>  <p>Returns a string decoded from the given URL-encoded string <code>str</code>.</p> <p>The given string is first encoded as Encoding::ASCII-8BIT (using <a href="string.html#method-i-b"><code>String#b</code></a>), then decoded (as below), and finally force-encoded to the given encoding <code>enc</code>.</p> <p>The returned string:</p> <ul>
<li> <p>Preserves:</p> <ul>
<li> <p>Characters <code>'*'</code>, <code>'.'</code>, <code>'-'</code>, and <code>'_'</code>.</p> </li>
<li> <p>Character in ranges <code>'a'..'z'</code>, <code>'A'..'Z'</code>, and <code>'0'..'9'</code>.</p> </li>
</ul> <p>Example:</p> <pre class="ruby" data-language="ruby">URI.decode_www_form_component('*.-_azAZ09')
# =&gt; "*.-_azAZ09"
</pre> </li>
<li> <p>Converts:</p> <ul>
<li> <p>Character <code>'+'</code> to character <code>' '</code>.</p> </li>
<li> <p>Each “percent notation” to an ASCII character.</p> </li>
</ul> <p>Example:</p> <pre class="ruby" data-language="ruby">URI.decode_www_form_component('Here+are+some+punctuation+characters%3A+%2C%3B%3F%3A')
# =&gt; "Here are some punctuation characters: ,;?:"
</pre> </li>
</ul> <p>Related: <a href="uri.html#method-c-decode_uri_component"><code>URI.decode_uri_component</code></a> (preserves <code>'+'</code>).</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-encode_uri_component"> <a href="#method-c-encode_uri_component" title="Link to this method"> <span class="method-name">encode_uri_component</span> <span class="method-args">(str, enc=nil)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="encode_uri_component-source"> <pre class="ruby" data-language="ruby"># File lib/uri/common.rb, line 397
def self.encode_uri_component(str, enc=nil)
  _encode_uri_component(/[^*\-.0-9A-Z_a-z]/, TBLENCURICOMP_, str, enc)
end</pre> </div>  <p>Like <a href="uri.html#method-c-encode_www_form_component"><code>URI.encode_www_form_component</code></a>, except that <code>' '</code> (space) is encoded as <code>'%20'</code> (instead of <code>'+'</code>).</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-encode_www_form"> <a href="#method-c-encode_www_form" title="Link to this method"> <span class="method-name">encode_www_form</span> <span class="method-args">(enum, enc=nil)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="encode_www_form-source"> <pre class="ruby" data-language="ruby"># File lib/uri/common.rb, line 524
def self.encode_www_form(enum, enc=nil)
  enum.map do |k,v|
    if v.nil?
      encode_www_form_component(k, enc)
    elsif v.respond_to?(:to_ary)
      v.to_ary.map do |w|
        str = encode_www_form_component(k, enc)
        unless w.nil?
          str &lt;&lt; '='
          str &lt;&lt; encode_www_form_component(w, enc)
        end
      end.join('&amp;')
    else
      str = encode_www_form_component(k, enc)
      str &lt;&lt; '='
      str &lt;&lt; encode_www_form_component(v, enc)
    end
  end.join('&amp;')
end</pre> </div>  <p>Returns a URL-encoded string derived from the given <a href="enumerable.html#module-Enumerable-label-Enumerable+in+Ruby+Classes">Enumerable</a> <code>enum</code>.</p> <p>The result is suitable for use as form data for an HTTP request whose <code>Content-Type</code> is <code>'application/x-www-form-urlencoded'</code>.</p> <p>The returned string consists of the elements of <code>enum</code>, each converted to one or more URL-encoded strings, and all joined with character <code>'&amp;'</code>.</p> <p>Simple examples:</p> <pre class="ruby" data-language="ruby">URI.encode_www_form([['foo', 0], ['bar', 1], ['baz', 2]])
# =&gt; "foo=0&amp;bar=1&amp;baz=2"
URI.encode_www_form({foo: 0, bar: 1, baz: 2})
# =&gt; "foo=0&amp;bar=1&amp;baz=2"
</pre> <p>The returned string is formed using method <a href="uri.html#method-c-encode_www_form_component"><code>URI.encode_www_form_component</code></a>, which converts certain characters:</p> <pre class="ruby" data-language="ruby">URI.encode_www_form('f#o': '/', 'b-r': '$', 'b z': '@')
# =&gt; "f%23o=%2F&amp;b-r=%24&amp;b+z=%40"
</pre> <p>When <code>enum</code> is Array-like, each element <code>ele</code> is converted to a field:</p> <ul>
<li> <p>If <code>ele</code> is an array of two or more elements, the field is formed from its first two elements (and any additional elements are ignored):</p> <pre class="ruby" data-language="ruby">name = URI.encode_www_form_component(ele[0], enc)
value = URI.encode_www_form_component(ele[1], enc)
"#{name}=#{value}"
</pre> <p>Examples:</p> <pre class="ruby" data-language="ruby">URI.encode_www_form([%w[foo bar], %w[baz bat bah]])
# =&gt; "foo=bar&amp;baz=bat"
URI.encode_www_form([['foo', 0], ['bar', :baz, 'bat']])
# =&gt; "foo=0&amp;bar=baz"
</pre> </li>
<li> <p>If <code>ele</code> is an array of one element, the field is formed from <code>ele[0]</code>:</p> <pre class="ruby" data-language="ruby">URI.encode_www_form_component(ele[0])
</pre> <p>Example:</p> <pre class="ruby" data-language="ruby">URI.encode_www_form([['foo'], [:bar], [0]])
# =&gt; "foo&amp;bar&amp;0"
</pre> </li>
<li> <p>Otherwise the field is formed from <code>ele</code>:</p> <pre class="ruby" data-language="ruby">URI.encode_www_form_component(ele)
</pre> <p>Example:</p> <pre class="ruby" data-language="ruby">URI.encode_www_form(['foo', :bar, 0])
# =&gt; "foo&amp;bar&amp;0"
</pre> </li>
</ul> <p>The elements of an Array-like <code>enum</code> may be mixture:</p> <pre class="ruby" data-language="ruby">URI.encode_www_form([['foo', 0], ['bar', 1, 2], ['baz'], :bat])
# =&gt; "foo=0&amp;bar=1&amp;baz&amp;bat"
</pre> <p>When <code>enum</code> is Hash-like, each <code>key</code>/<code>value</code> pair is converted to one or more fields:</p> <ul>
<li> <p>If <code>value</code> is <a href="implicit_conversion_rdoc.html#label-Array-Convertible+Objects">Array-convertible</a>, each element <code>ele</code> in <code>value</code> is paired with <code>key</code> to form a field:</p> <pre class="ruby" data-language="ruby">name = URI.encode_www_form_component(key, enc)
value = URI.encode_www_form_component(ele, enc)
"#{name}=#{value}"
</pre> <p>Example:</p> <pre class="ruby" data-language="ruby">URI.encode_www_form({foo: [:bar, 1], baz: [:bat, :bam, 2]})
# =&gt; "foo=bar&amp;foo=1&amp;baz=bat&amp;baz=bam&amp;baz=2"
</pre> </li>
<li> <p>Otherwise, <code>key</code> and <code>value</code> are paired to form a field:</p> <pre class="ruby" data-language="ruby">name = URI.encode_www_form_component(key, enc)
value = URI.encode_www_form_component(value, enc)
"#{name}=#{value}"
</pre> <p>Example:</p> <pre class="ruby" data-language="ruby">URI.encode_www_form({foo: 0, bar: 1, baz: 2})
# =&gt; "foo=0&amp;bar=1&amp;baz=2"
</pre> </li>
</ul> <p>The elements of a Hash-like <code>enum</code> may be mixture:</p> <pre class="ruby" data-language="ruby">URI.encode_www_form({foo: [0, 1], bar: 2})
# =&gt; "foo=0&amp;foo=1&amp;bar=2"
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-encode_www_form_component"> <a href="#method-c-encode_www_form_component" title="Link to this method"> <span class="method-name">encode_www_form_component</span> <span class="method-args">(str, enc=nil)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="encode_www_form_component-source"> <pre class="ruby" data-language="ruby"># File lib/uri/common.rb, line 358
def self.encode_www_form_component(str, enc=nil)
  _encode_uri_component(/[^*\-.0-9A-Z_a-z]/, TBLENCWWWCOMP_, str, enc)
end</pre> </div>  <p>Returns a URL-encoded string derived from the given string <code>str</code>.</p> <p>The returned string:</p> <ul>
<li> <p>Preserves:</p> <ul>
<li> <p>Characters <code>'*'</code>, <code>'.'</code>, <code>'-'</code>, and <code>'_'</code>.</p> </li>
<li> <p>Character in ranges <code>'a'..'z'</code>, <code>'A'..'Z'</code>, and <code>'0'..'9'</code>.</p> </li>
</ul> <p>Example:</p> <pre class="ruby" data-language="ruby">URI.encode_www_form_component('*.-_azAZ09')
# =&gt; "*.-_azAZ09"
</pre> </li>
<li> <p>Converts:</p> <ul>
<li> <p>Character <code>' '</code> to character <code>'+'</code>.</p> </li>
<li> <p>Any other character to “percent notation”; the percent notation for character <em>c</em> is <code>'%%%X' % c.ord</code>.</p> </li>
</ul> <p>Example:</p> <pre class="ruby" data-language="ruby">URI.encode_www_form_component('Here are some punctuation characters: ,;?:')
# =&gt; "Here+are+some+punctuation+characters%3A+%2C%3B%3F%3A"
</pre> </li>
</ul> <p>Encoding:</p> <ul>
<li> <p>If <code>str</code> has encoding Encoding::ASCII_8BIT, argument <code>enc</code> is ignored.</p> </li>
<li> <p>Otherwise <code>str</code> is converted first to Encoding::UTF_8 (with suitable character replacements), and then to encoding <code>enc</code>.</p> </li>
</ul> <p>In either case, the returned string has forced encoding Encoding::US_ASCII.</p> <p>Related: <a href="uri.html#method-c-encode_uri_component"><code>URI.encode_uri_component</code></a> (encodes <code>' '</code> as <code>'%20'</code>).</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-for"> <a href="#method-c-for" title="Link to this method"> <span class="method-name">for</span> <span class="method-args">(scheme, *arguments, default: Generic)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="for-source"> <pre class="ruby" data-language="ruby"># File lib/uri/common.rb, line 146
def self.for(scheme, *arguments, default: Generic)
  const_name = scheme.to_s.upcase

  uri_class = INITIAL_SCHEMES[const_name]
  uri_class ||= if /\A[A-Z]\w*\z/.match?(const_name) &amp;&amp; Schemes.const_defined?(const_name, false)
    Schemes.const_get(const_name, false)
  end
  uri_class ||= default

  return uri_class.new(scheme, *arguments)
end</pre> </div>  <p>Returns a new object constructed from the given <code>scheme</code>, <code>arguments</code>, and <code>default</code>:</p> <ul>
<li> <p>The new object is an instance of <a href="uri.html#method-c-scheme_list"><code>URI.scheme_list[scheme.upcase]</code></a>.</p> </li>
<li> <p>The object is initialized by calling the class initializer using <code>scheme</code> and <code>arguments</code>. See <a href="uri/generic.html#method-c-new"><code>URI::Generic.new</code></a>.</p> </li>
</ul> <p>Examples:</p> <pre class="ruby" data-language="ruby">values = ['john.doe', 'www.example.com', '123', nil, '/forum/questions/', nil, 'tag=networking&amp;order=newest', 'top']
URI.for('https', *values)
# =&gt; #&lt;URI::HTTPS https://john.doe@www.example.com:123/forum/questions/?tag=networking&amp;order=newest#top&gt;
URI.for('foo', *values, default: URI::HTTP)
# =&gt; #&lt;URI::HTTP foo://john.doe@www.example.com:123/forum/questions/?tag=networking&amp;order=newest#top&gt;
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-join"> <a href="#method-c-join" title="Link to this method"> <span class="method-name">join</span> <span class="method-args">(*str)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="join-source"> <pre class="ruby" data-language="ruby"># File lib/uri/common.rb, line 234
def self.join(*str)
  DEFAULT_PARSER.join(*str)
end</pre> </div>  <p>Merges the given <a href="uri.html"><code>URI</code></a> strings <code>str</code> per <a href="https://www.rfc-editor.org/rfc/rfc2396.html">RFC 2396</a>.</p> <p>Each string in <code>str</code> is converted to an <a href="https://www.rfc-editor.org/rfc/rfc3986.html">RFC3986 URI</a> before being merged.</p> <p>Examples:</p> <pre class="ruby" data-language="ruby">URI.join("http://example.com/","main.rbx")
# =&gt; #&lt;URI::HTTP http://example.com/main.rbx&gt;

URI.join('http://example.com', 'foo')
# =&gt; #&lt;URI::HTTP http://example.com/foo&gt;

URI.join('http://example.com', '/foo', '/bar')
# =&gt; #&lt;URI::HTTP http://example.com/bar&gt;

URI.join('http://example.com', '/foo', 'bar')
# =&gt; #&lt;URI::HTTP http://example.com/bar&gt;

URI.join('http://example.com', '/foo/', 'bar')
# =&gt; #&lt;URI::HTTP http://example.com/foo/bar&gt;
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-open"> <a href="#method-c-open" title="Link to this method"> <span class="method-name">open</span> <span class="method-args">(name, *rest, &amp;block)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="open-source"> <pre class="ruby" data-language="ruby"># File lib/open-uri.rb, line 23
def self.open(name, *rest, &amp;block)
  if name.respond_to?(:open)
    name.open(*rest, &amp;block)
  elsif name.respond_to?(:to_str) &amp;&amp;
        %r{\A[A-Za-z][A-Za-z0-9+\-\.]*://} =~ name &amp;&amp;
        (uri = URI.parse(name)).respond_to?(:open)
    uri.open(*rest, &amp;block)
  else
    super
  end
end</pre> </div>  <p>Allows the opening of various resources including URIs.</p> <p>If the first argument responds to the ‘open’ method, ‘open’ is called on it with the rest of the arguments.</p> <p>If the first argument is a string that begins with <code>(protocol)://</code>, it is parsed by <a href="uri.html#method-c-parse"><code>URI.parse</code></a>. If the parsed object responds to the ‘open’ method, ‘open’ is called on it with the rest of the arguments.</p> <p>Otherwise, <a href="kernel.html#method-i-open"><code>Kernel#open</code></a> is called.</p> <p><a href="openuri/openread.html#method-i-open"><code>OpenURI::OpenRead#open</code></a> provides <a href="openuri/openread.html#method-i-open"><code>URI::HTTP#open</code></a>, <a href="openuri/openread.html#method-i-open"><code>URI::HTTPS#open</code></a> and <a href="openuri/openread.html#method-i-open"><code>URI::FTP#open</code></a>, <a href="kernel.html#method-i-open"><code>Kernel#open</code></a>.</p> <p>We can accept URIs and strings that begin with http://, https:// and ftp://. In these cases, the opened file object is extended by <a href="openuri/meta.html"><code>OpenURI::Meta</code></a>.</p> <div class="method-calls-super"> Calls superclass method </div> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-parse"> <a href="#method-c-parse" title="Link to this method"> <span class="method-name">parse</span> <span class="method-args">(uri)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="parse-source"> <pre class="ruby" data-language="ruby"># File lib/uri/common.rb, line 207
def self.parse(uri)
  DEFAULT_PARSER.parse(uri)
end</pre> </div>  <p>Returns a new URI object constructed from the given string <code>uri</code>:</p> <pre class="ruby" data-language="ruby">URI.parse('https://john.doe@www.example.com:123/forum/questions/?tag=networking&amp;order=newest#top')
# =&gt; #&lt;URI::HTTPS https://john.doe@www.example.com:123/forum/questions/?tag=networking&amp;order=newest#top&gt;
URI.parse('http://john.doe@www.example.com:123/forum/questions/?tag=networking&amp;order=newest#top')
# =&gt; #&lt;URI::HTTP http://john.doe@www.example.com:123/forum/questions/?tag=networking&amp;order=newest#top&gt;
</pre> <p>It’s recommended to first ::escape string <code>uri</code> if it may contain invalid <a href="uri.html"><code>URI</code></a> characters.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-parser-3D"> <a href="#method-c-parser-3D" title="Link to this method"> <span class="method-name">parser=</span> <span class="method-args">(parser = RFC3986_PARSER)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="parser-3D-source"> <pre class="ruby" data-language="ruby"># File lib/uri/common.rb, line 25
def self.parser=(parser = RFC3986_PARSER)
  remove_const(:Parser) if defined?(::URI::Parser)
  const_set("Parser", parser.class)

  remove_const(:REGEXP) if defined?(::URI::REGEXP)
  remove_const(:PATTERN) if defined?(::URI::PATTERN)
  if Parser == RFC2396_Parser
    const_set("REGEXP", URI::RFC2396_REGEXP)
    const_set("PATTERN", URI::RFC2396_REGEXP::PATTERN)
  end

  Parser.new.regexp.each_pair do |sym, str|
    remove_const(sym) if const_defined?(sym, false)
    const_set(sym, str)
  end
end</pre> </div>  </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-register_scheme"> <a href="#method-c-register_scheme" title="Link to this method"> <span class="method-name">register_scheme</span> <span class="method-args">(scheme, klass)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="register_scheme-source"> <pre class="ruby" data-language="ruby"># File lib/uri/common.rb, line 102
def self.register_scheme(scheme, klass)
  Schemes.const_set(scheme.to_s.upcase, klass)
end</pre> </div>  <p>Registers the given <code>klass</code> as the class to be instantiated when parsing a URI with the given <code>scheme</code>:</p> <pre class="ruby" data-language="ruby">URI.register_scheme('MS_SEARCH', URI::Generic) # =&gt; URI::Generic
URI.scheme_list['MS_SEARCH']                   # =&gt; URI::Generic
</pre> <p>Note that after calling <a href="string.html#method-i-upcase"><code>String#upcase</code></a> on <code>scheme</code>, it must be a valid constant name.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-scheme_list"> <a href="#method-c-scheme_list" title="Link to this method"> <span class="method-name">scheme_list</span> <span class="method-args">()</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="scheme_list-source"> <pre class="ruby" data-language="ruby"># File lib/uri/common.rb, line 120
def self.scheme_list
  Schemes.constants.map { |name|
    [name.to_s.upcase, Schemes.const_get(name)]
  }.to_h
end</pre> </div>  <p>Returns a hash of the defined schemes:</p> <pre class="ruby" data-language="ruby">URI.scheme_list
# =&gt;
{"MAILTO"=&gt;URI::MailTo,
 "LDAPS"=&gt;URI::LDAPS,
 "WS"=&gt;URI::WS,
 "HTTP"=&gt;URI::HTTP,
 "HTTPS"=&gt;URI::HTTPS,
 "LDAP"=&gt;URI::LDAP,
 "FILE"=&gt;URI::File,
 "FTP"=&gt;URI::FTP}
</pre> <p>Related: <a href="uri.html#method-c-register_scheme"><code>URI.register_scheme</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-split"> <a href="#method-c-split" title="Link to this method"> <span class="method-name">split</span> <span class="method-args">(uri)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="split-source"> <pre class="ruby" data-language="ruby"># File lib/uri/common.rb, line 193
def self.split(uri)
  DEFAULT_PARSER.split(uri)
end</pre> </div>  <p>Returns a 9-element array representing the parts of the URI formed from the string <code>uri</code>; each array element is a string or <code>nil</code>:</p> <pre class="ruby" data-language="ruby">names = %w[scheme userinfo host port registry path opaque query fragment]
values = URI.split('https://john.doe@www.example.com:123/forum/questions/?tag=networking&amp;order=newest#top')
names.zip(values)
# =&gt;
[["scheme", "https"],
 ["userinfo", "john.doe"],
 ["host", "www.example.com"],
 ["port", "123"],
 ["registry", nil],
 ["path", "/forum/questions/"],
 ["opaque", nil],
 ["query", "tag=networking&amp;order=newest"],
 ["fragment", "top"]]
</pre> </div> </div> </section> <section id="private-class-5Buntitled-5D-method-details" class="method-section anchor-link"> <header> <h3>Private Class Methods</h3> </header> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-_decode_uri_component"> <a href="#method-c-_decode_uri_component" title="Link to this method"> <span class="method-name">_decode_uri_component</span> <span class="method-args">(regexp, str, enc)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="_decode_uri_component-source"> <pre class="ruby" data-language="ruby"># File lib/uri/common.rb, line 420
def self._decode_uri_component(regexp, str, enc)
  raise ArgumentError, "invalid %-encoding (#{str})" if /%(?!\h\h)/.match?(str)
  str.b.gsub(regexp, TBLDECWWWCOMP_).force_encoding(enc)
end</pre> </div>  </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-_encode_uri_component"> <a href="#method-c-_encode_uri_component" title="Link to this method"> <span class="method-name">_encode_uri_component</span> <span class="method-args">(regexp, table, str, enc)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="_encode_uri_component-source"> <pre class="ruby" data-language="ruby"># File lib/uri/common.rb, line 406
def self._encode_uri_component(regexp, table, str, enc)
  str = str.to_s.dup
  if str.encoding != Encoding::ASCII_8BIT
    if enc &amp;&amp; enc != Encoding::ASCII_8BIT
      str.encode!(Encoding::UTF_8, invalid: :replace, undef: :replace)
      str.encode!(enc, fallback: -&gt;(x){"&amp;##{x.ord};"})
    end
    str.force_encoding(Encoding::ASCII_8BIT)
  end
  str.gsub!(regexp, table)
  str.force_encoding(Encoding::US_ASCII)
end</pre> </div>  </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core &copy; 1993&ndash;2024 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library &copy; contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>
