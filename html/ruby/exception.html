<h1 id="class-Exception" class="class"> class Exception </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent"><a href="object.html">Object</a></dd>
</dl> <section class="description"> <p>Class <a href="exception.html"><code>Exception</code></a> and its subclasses are used to communicate between <a href="kernel.html#method-i-raise"><code>Kernel#raise</code></a> and <code>rescue</code> statements in <code>begin ... end</code> blocks.</p> <p>An <a href="exception.html"><code>Exception</code></a> object carries information about an exception:</p> <ul>
<li> <p>Its type (the exception’s class).</p> </li>
<li> <p>An optional descriptive message.</p> </li>
<li> <p>Optional backtrace information.</p> </li>
</ul> <p>Some built-in subclasses of <a href="exception.html"><code>Exception</code></a> have additional methods: e.g., <a href="nameerror.html#method-i-name"><code>NameError#name</code></a>.</p> <h2 id="class-Exception-label-Defaults">Defaults</h2> <p>Two Ruby statements have default exception classes:</p> <ul>
<li> <p><code>raise</code>: defaults to <a href="runtimeerror.html"><code>RuntimeError</code></a>.</p> </li>
<li> <p><code>rescue</code>: defaults to <a href="standarderror.html"><code>StandardError</code></a>.</p> </li>
</ul> <h2 id="class-Exception-label-Global+Variables">Global Variables</h2> <p>When an exception has been raised but not yet handled (in <code>rescue</code>, <code>ensure</code>, <code>at_exit</code> and <code>END</code> blocks), two global variables are set:</p> <ul>
<li> <p><code>$!</code> contains the current exception.</p> </li>
<li> <p><code>$@</code> contains its backtrace.</p> </li>
</ul> <h2 id="class-Exception-label-Custom+Exceptions">Custom Exceptions</h2> <p>To provide additional or alternate information, a program may create custom exception classes that derive from the built-in exception classes.</p> <p>A good practice is for a library to create a single “generic” exception class (typically a subclass of <a href="standarderror.html"><code>StandardError</code></a> or <a href="runtimeerror.html"><code>RuntimeError</code></a>) and have its other exception classes derive from that class. This allows the user to rescue the generic exception, thus catching all exceptions the library may raise even if future versions of the library add new exception subclasses.</p> <p>For example:</p> <pre class="ruby" data-language="ruby">class MyLibrary
  class Error &lt; ::StandardError
  end

  class WidgetError &lt; Error
  end

  class FrobError &lt; Error
  end

end
</pre> <p>To handle both MyLibrary::WidgetError and MyLibrary::FrobError the library user can rescue MyLibrary::Error.</p> <h2 id="class-Exception-label-Built-In+Exception+Classes">Built-In <a href="exception.html"><code>Exception</code></a> Classes</h2> <p>The built-in subclasses of <a href="exception.html"><code>Exception</code></a> are:</p> <ul>
<li> <p><a href="nomemoryerror.html"><code>NoMemoryError</code></a></p> </li>
<li> <p><a href="scripterror.html"><code>ScriptError</code></a></p> <ul>
<li> <p>LoadError</p> </li>
<li> <p><a href="notimplementederror.html"><code>NotImplementedError</code></a></p> </li>
<li> <p><a href="syntaxerror.html"><code>SyntaxError</code></a></p> </li>
</ul> </li>
<li> <p><a href="securityerror.html"><code>SecurityError</code></a></p> </li>
<li> <p><a href="signalexception.html"><code>SignalException</code></a></p> <ul><li> <p><a href="interrupt.html"><code>Interrupt</code></a></p> </li></ul> </li>
<li> <p><a href="standarderror.html"><code>StandardError</code></a></p> <ul>
<li> <p><a href="argumenterror.html"><code>ArgumentError</code></a></p> <ul><li> <p><a href="uncaughtthrowerror.html"><code>UncaughtThrowError</code></a></p> </li></ul> </li>
<li> <p><a href="encodingerror.html"><code>EncodingError</code></a></p> </li>
<li> <p><a href="fibererror.html"><code>FiberError</code></a></p> </li>
<li> <p><a href="ioerror.html"><code>IOError</code></a></p> <ul><li> <p><a href="eoferror.html"><code>EOFError</code></a></p> </li></ul> </li>
<li> <p><a href="indexerror.html"><code>IndexError</code></a></p> <ul>
<li> <p><a href="keyerror.html"><code>KeyError</code></a></p> </li>
<li> <p><a href="stopiteration.html"><code>StopIteration</code></a></p> <ul><li> <p><a href="closedqueueerror.html"><code>ClosedQueueError</code></a></p> </li></ul> </li>
</ul> </li>
<li> <p><a href="localjumperror.html"><code>LocalJumpError</code></a></p> </li>
<li> <p><a href="nameerror.html"><code>NameError</code></a></p> <ul><li> <p><a href="nomethoderror.html"><code>NoMethodError</code></a></p> </li></ul> </li>
<li> <p><a href="rangeerror.html"><code>RangeError</code></a></p> <ul><li> <p><a href="floatdomainerror.html"><code>FloatDomainError</code></a></p> </li></ul> </li>
<li> <p><a href="regexperror.html"><code>RegexpError</code></a></p> </li>
<li> <p><a href="runtimeerror.html"><code>RuntimeError</code></a></p> <ul><li> <p><a href="frozenerror.html"><code>FrozenError</code></a></p> </li></ul> </li>
<li> <p><a href="systemcallerror.html"><code>SystemCallError</code></a></p> <ul><li> <p>Errno::*</p> </li></ul> </li>
<li> <p><a href="threaderror.html"><code>ThreadError</code></a></p> </li>
<li> <p><a href="typeerror.html"><code>TypeError</code></a></p> </li>
<li> <p><a href="zerodivisionerror.html"><code>ZeroDivisionError</code></a></p> </li>
</ul> </li>
<li> <p><a href="systemexit.html"><code>SystemExit</code></a></p> </li>
<li> <p><a href="systemstackerror.html"><code>SystemStackError</code></a></p> </li>
<li> <p>fatal</p> </li>
</ul> </section> <section id="5Buntitled-5D" class="documentation-section"> <section id="public-class-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-exception"> <span class="method-callseq"> exception([string]) → an_exception or exc </span> </div> </div> <div class="method-description"> <p>With no argument, or if the argument is the same as the receiver, return the receiver. Otherwise, create a new exception object of the same class as the receiver, but with a message equal to <code>string.to_str</code>.</p> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-json_create"> <span class="method-name">json_create</span><span class="method-args">(object)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="json_create-source"> <pre class="ruby" data-language="ruby"># File ext/json/lib/json/add/exception.rb, line 9
def self.json_create(object)
  result = new(object['m'])
  result.set_backtrace object['b']
  result
end</pre> </div> <p>See <a href="exception.html#method-i-as_json"><code>as_json</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-new"> <span class="method-callseq"> new(msg = nil) → exception </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> exception(msg = nil) → exception </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="new-source"> <pre class="c" data-language="c">static VALUE
exc_initialize(int argc, VALUE *argv, VALUE exc)
{
    VALUE arg;

    arg = (!rb_check_arity(argc, 0, 1) ? Qnil : argv[0]);
    return exc_init(exc, arg);
}</pre> </div> <p>Construct a new <a href="exception.html"><code>Exception</code></a> object, optionally passing in a message.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-to_tty-3F"> <span class="method-callseq"> to_tty? → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="to_tty-3F-source"> <pre class="c" data-language="c">static VALUE
exc_s_to_tty_p(VALUE self)
{
    return RBOOL(rb_stderr_tty_p());
}</pre> </div> <p>Returns <code>true</code> if exception messages will be sent to a tty.</p>  </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-3D-3D"> <span class="method-callseq"> exc == obj → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="3D-3D-source"> <pre class="c" data-language="c">static VALUE
exc_equal(VALUE exc, VALUE obj)
{
    VALUE mesg, backtrace;

    if (exc == obj) return Qtrue;

    if (rb_obj_class(exc) != rb_obj_class(obj)) {
        int state;

        obj = rb_protect(try_convert_to_exception, obj, &amp;state);
        if (state || UNDEF_P(obj)) {
            rb_set_errinfo(Qnil);
            return Qfalse;
        }
        if (rb_obj_class(exc) != rb_obj_class(obj)) return Qfalse;
        mesg = rb_check_funcall(obj, id_message, 0, 0);
        if (UNDEF_P(mesg)) return Qfalse;
        backtrace = rb_check_funcall(obj, id_backtrace, 0, 0);
        if (UNDEF_P(backtrace)) return Qfalse;
    }
    else {
        mesg = rb_attr_get(obj, id_mesg);
        backtrace = exc_backtrace(obj);
    }

    if (!rb_equal(rb_attr_get(exc, id_mesg), mesg))
        return Qfalse;
    return rb_equal(exc_backtrace(exc), backtrace);
}</pre> </div> <p>Equality—If <em>obj</em> is not an <a href="exception.html"><code>Exception</code></a>, returns <code>false</code>. Otherwise, returns <code>true</code> if <em>exc</em> and <em>obj</em> share same class, messages, and backtrace.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-as_json"> <span class="method-name">as_json</span><span class="method-args">(*)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="as_json-source"> <pre class="ruby" data-language="ruby"># File ext/json/lib/json/add/exception.rb, line 29
def as_json(*)
  {
    JSON.create_id =&gt; self.class.name,
    'm'            =&gt; message,
    'b'            =&gt; backtrace,
  }
end</pre> </div> <p>Methods <code>Exception#as_json</code> and <code>Exception.json_create</code> may be used to serialize and deserialize a Exception object; see <a href="marshal.html"><code>Marshal</code></a>.</p> <p>Method <code>Exception#as_json</code> serializes <code>self</code>, returning a 2-element hash representing <code>self</code>:</p> <pre class="ruby" data-language="ruby">require 'json/add/exception'
x = Exception.new('Foo').as_json # =&gt; {"json_class"=&gt;"Exception", "m"=&gt;"Foo", "b"=&gt;nil}
</pre> <p>Method <code>JSON.create</code> deserializes such a hash, returning a Exception object:</p> <pre class="ruby" data-language="ruby">Exception.json_create(x) # =&gt; #&lt;Exception: Foo&gt;
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-backtrace"> <span class="method-callseq"> backtrace → array or nil </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="backtrace-source"> <pre class="c" data-language="c">static VALUE
exc_backtrace(VALUE exc)
{
    VALUE obj;

    obj = rb_attr_get(exc, id_bt);

    if (rb_backtrace_p(obj)) {
        obj = rb_backtrace_to_str_ary(obj);
        /* rb_ivar_set(exc, id_bt, obj); */
    }

    return obj;
}</pre> </div> <p>Returns any backtrace associated with the exception. The backtrace is an array of strings, each containing either “filename:lineNo: in ‘method”’ or “filename:lineNo.”</p> <pre class="ruby" data-language="ruby">def a
  raise "boom"
end

def b
  a()
end

begin
  b()
rescue =&gt; detail
  print detail.backtrace.join("\n")
end
</pre> <p><em>produces:</em></p> <pre>prog.rb:2:in `a'
prog.rb:6:in `b'
prog.rb:10</pre> <p>In the case no backtrace has been set, <code>nil</code> is returned</p> <pre class="ruby" data-language="ruby">ex = StandardError.new
ex.backtrace
#=&gt; nil
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-backtrace_locations"> <span class="method-callseq"> backtrace_locations → array or nil </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="backtrace_locations-source"> <pre class="c" data-language="c">static VALUE
exc_backtrace_locations(VALUE exc)
{
    VALUE obj;

    obj = rb_attr_get(exc, id_bt_locations);
    if (!NIL_P(obj)) {
        obj = rb_backtrace_to_location_ary(obj);
    }
    return obj;
}</pre> </div> <p>Returns any backtrace associated with the exception. This method is similar to <a href="exception.html#method-i-backtrace"><code>Exception#backtrace</code></a>, but the backtrace is an array of <a href="thread/backtrace/location.html"><code>Thread::Backtrace::Location</code></a>.</p> <p>This method is not affected by <a href="exception.html#method-i-set_backtrace"><code>Exception#set_backtrace()</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-cause"> <span class="method-callseq"> cause → an_exception or nil </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="cause-source"> <pre class="c" data-language="c">static VALUE
exc_cause(VALUE exc)
{
    return rb_attr_get(exc, id_cause);
}</pre> </div> <p>Returns the previous exception ($!) at the time this exception was raised. This is useful for wrapping exceptions and retaining the original exception information.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-detailed_message"> <span class="method-callseq"> detailed_message(highlight: bool, **opt) → string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="detailed_message-source"> <pre class="c" data-language="c">static VALUE
exc_detailed_message(int argc, VALUE *argv, VALUE exc)
{
    VALUE opt;

    rb_scan_args(argc, argv, "0:", &amp;opt);

    VALUE highlight = check_highlight_keyword(opt, 0);

    extern VALUE rb_decorate_message(const VALUE eclass, const VALUE emesg, int highlight);

    return rb_decorate_message(CLASS_OF(exc), rb_get_message(exc), RTEST(highlight));
}</pre> </div> <p>Processes a string returned by <a href="exception.html#method-i-message"><code>message</code></a>.</p> <p>It may add the class name of the exception to the end of the first line. Also, when <code>highlight</code> keyword is true, it adds ANSI escape sequences to make the message bold.</p> <p>If you override this method, it must be tolerant for unknown keyword arguments. All keyword arguments passed to <a href="exception.html#method-i-full_message"><code>full_message</code></a> are delegated to this method.</p> <p>This method is overridden by did_you_mean and error_highlight to add their information.</p> <p>A user-defined exception class can also define their own <code>detailed_message</code> method to add supplemental information. When <code>highlight</code> is true, it can return a string containing escape sequences, but use widely-supported ones. It is recommended to limit the following codes:</p> <ul>
<li> <p>Reset (<code>\e[0m</code>)</p> </li>
<li> <p>Bold (<code>\e[1m</code>)</p> </li>
<li> <p>Underline (<code>\e[4m</code>)</p> </li>
<li> <p>Foreground color except white and black</p> <ul>
<li> <p>Red (<code>\e[31m</code>)</p> </li>
<li> <p>Green (<code>\e[32m</code>)</p> </li>
<li> <p>Yellow (<code>\e[33m</code>)</p> </li>
<li> <p>Blue (<code>\e[34m</code>)</p> </li>
<li> <p>Magenta (<code>\e[35m</code>)</p> </li>
<li> <p>Cyan (<code>\e[36m</code>)</p> </li>
</ul> </li>
</ul> <p>Use escape sequences carefully even if <code>highlight</code> is true. Do not use escape sequences to express essential information; the message should be readable even if all escape sequences are ignored.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-exception"> <span class="method-callseq"> exception([string]) → an_exception or exc </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="exception-source"> <pre class="c" data-language="c">static VALUE
exc_exception(int argc, VALUE *argv, VALUE self)
{
    VALUE exc;

    argc = rb_check_arity(argc, 0, 1);
    if (argc == 0) return self;
    if (argc == 1 &amp;&amp; self == argv[0]) return self;
    exc = rb_obj_clone(self);
    rb_ivar_set(exc, id_mesg, argv[0]);
    return exc;
}</pre> </div> <p>With no argument, or if the argument is the same as the receiver, return the receiver. Otherwise, create a new exception object of the same class as the receiver, but with a message equal to <code>string.to_str</code>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-full_message"> <span class="method-callseq"> full_message(highlight: bool, order: [:top or :bottom]) → string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="full_message-source"> <pre class="c" data-language="c">static VALUE
exc_full_message(int argc, VALUE *argv, VALUE exc)
{
    VALUE opt, str, emesg, errat;
    VALUE highlight, order;

    rb_scan_args(argc, argv, "0:", &amp;opt);

    highlight = check_highlight_keyword(opt, 1);
    order = check_order_keyword(opt);

    {
        if (NIL_P(opt)) opt = rb_hash_new();
        rb_hash_aset(opt, sym_highlight, highlight);
    }

    str = rb_str_new2("");
    errat = rb_get_backtrace(exc);
    emesg = rb_get_detailed_message(exc, opt);

    rb_error_write(exc, emesg, errat, str, opt, highlight, order);
    return str;
}</pre> </div> <p>Returns formatted string of <em>exception</em>. The returned string is formatted using the same format that Ruby uses when printing an uncaught exceptions to stderr.</p> <p>If <em>highlight</em> is <code>true</code> the default error handler will send the messages to a tty.</p> <p><em>order</em> must be either of <code>:top</code> or <code>:bottom</code>, and places the error message and the innermost backtrace come at the top or the bottom.</p> <p>The default values of these options depend on <code>$stderr</code> and its <code>tty?</code> at the timing of a call.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-inspect"> <span class="method-callseq"> inspect → string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="inspect-source"> <pre class="c" data-language="c">static VALUE
exc_inspect(VALUE exc)
{
    VALUE str, klass;

    klass = CLASS_OF(exc);
    exc = rb_obj_as_string(exc);
    if (RSTRING_LEN(exc) == 0) {
        return rb_class_name(klass);
    }

    str = rb_str_buf_new2("#&lt;");
    klass = rb_class_name(klass);
    rb_str_buf_append(str, klass);

    if (RTEST(rb_str_include(exc, rb_str_new2("\n")))) {
        rb_str_catf(str, ":%+"PRIsVALUE, exc);
    }
    else {
        rb_str_buf_cat(str, ": ", 2);
        rb_str_buf_append(str, exc);
    }

    rb_str_buf_cat(str, "&gt;", 1);

    return str;
}</pre> </div> <p>Return this exception’s class name and message.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-message"> <span class="method-callseq"> message → string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="message-source"> <pre class="c" data-language="c">static VALUE
exc_message(VALUE exc)
{
    return rb_funcallv(exc, idTo_s, 0, 0);
}</pre> </div> <p>Returns the result of invoking <code>exception.to_s</code>. Normally this returns the exception’s message or name.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-set_backtrace"> <span class="method-callseq"> set_backtrace(backtrace) → array </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="set_backtrace-source"> <pre class="c" data-language="c">static VALUE
exc_set_backtrace(VALUE exc, VALUE bt)
{
    return rb_ivar_set(exc, id_bt, rb_check_backtrace(bt));
}</pre> </div> <p>Sets the backtrace information associated with <code>exc</code>. The <code>backtrace</code> must be an array of <a href="string.html"><code>String</code></a> objects or a single <a href="string.html"><code>String</code></a> in the format described in <a href="exception.html#method-i-backtrace"><code>Exception#backtrace</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-to_json"> <span class="method-name">to_json</span><span class="method-args">(*args)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="to_json-source"> <pre class="ruby" data-language="ruby"># File ext/json/lib/json/add/exception.rb, line 46
def to_json(*args)
  as_json.to_json(*args)
end</pre> </div> <p>Returns a <a href="json.html"><code>JSON</code></a> string representing <code>self</code>:</p> <pre class="ruby" data-language="ruby">require 'json/add/exception'
puts Exception.new('Foo').to_json
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">{"json_class":"Exception","m":"Foo","b":null}
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-to_s"> <span class="method-callseq"> to_s → string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="to_s-source"> <pre class="c" data-language="c">static VALUE
exc_to_s(VALUE exc)
{
    VALUE mesg = rb_attr_get(exc, idMesg);

    if (NIL_P(mesg)) return rb_class_name(CLASS_OF(exc));
    return rb_String(mesg);
}</pre> </div> <p>Returns exception’s message (or the name of the exception if no message is set).</p>  </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core &copy; 1993&ndash;2022 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library &copy; contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>
