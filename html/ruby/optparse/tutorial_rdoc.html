<h2 id="label-Tutorial">Tutorial</h2> <h3 id="label-Why+OptionParser-3F">Why <a href="../optionparser.html"><code>OptionParser</code></a>?</h3> <p>When a Ruby program executes, it captures its command-line arguments and options into variable ARGV. This simple program just prints its <code>ARGV</code>:</p> <pre class="ruby" data-language="ruby">p ARGV
</pre> <p>Execution, with arguments and options:</p> <pre>$ ruby argv.rb foo --bar --baz bat bam
["foo", "--bar", "--baz", "bat", "bam"]</pre> <p>The executing program is responsible for parsing and handling the command-line options.</p> <p><a href="../optionparser.html"><code>OptionParser</code></a> offers methods for parsing and handling those options.</p> <p>With <a href="../optionparser.html"><code>OptionParser</code></a>, you can define options so that for each option:</p> <ul>
<li> <p>The code that defines the option and code that handles that option are in the same place.</p> </li>
<li> <p>The option may take no argument, a required argument, or an optional argument.</p> </li>
<li> <p>The argument may be automatically converted to a specified class.</p> </li>
<li> <p>The argument may be restricted to specified <em>forms</em>.</p> </li>
<li> <p>The argument may be restricted to specified <em>values</em>.</p> </li>
</ul> <p>The class also has method help, which displays automatically-generated help text.</p> <h3 id="label-Contents">Contents</h3> <ul>
<li> <p><a href="#label-To+Begin+With">To Begin With</a></p> </li>
<li> <p><a href="#label-Defining+Options">Defining Options</a></p> </li>
<li> <p><a href="#label-Option+Names">Option Names</a></p> <ul>
<li> <p><a href="#label-Short+Option+Names">Short Option Names</a></p> </li>
<li> <p><a href="#label-Long+Option+Names">Long Option Names</a></p> </li>
<li> <p><a href="#label-Mixing+Option+Names">Mixing Option Names</a></p> </li>
<li> <p><a href="#label-Option+Name+Abbreviations">Option Name Abbreviations</a></p> </li>
</ul> </li>
<li> <p><a href="#label-Option+Arguments">Option Arguments</a></p> <ul>
<li> <p><a href="#label-Option+with+No+Argument">Option with No Argument</a></p> </li>
<li> <p><a href="#label-Option+with+Required+Argument">Option with Required Argument</a></p> </li>
<li> <p><a href="#label-Option+with+Optional+Argument">Option with Optional Argument</a></p> </li>
<li> <p><a href="#label-Argument+Abbreviations">Argument Abbreviations</a></p> </li>
</ul> </li>
<li> <p><a href="#label-Argument+Values">Argument Values</a></p> <ul>
<li> <p><a href="#label-Explicit+Argument+Values">Explicit Argument Values</a></p> <ul>
<li> <p><a href="#label-Explicit+Values+in+Array">Explicit Values in Array</a></p> </li>
<li> <p><a href="#label-Explicit+Values+in+Hash">Explicit Values in Hash</a></p> </li>
</ul> </li>
<li> <p><a href="#label-Argument+Value+Patterns">Argument Value Patterns</a></p> </li>
</ul> </li>
<li> <p><a href="#label-Keyword+Argument+into">Keyword Argument into</a></p> <ul>
<li> <p><a href="#label-Collecting+Options">Collecting Options</a></p> </li>
<li> <p><a href="#label-Checking+for+Missing+Options">Checking for Missing Options</a></p> </li>
<li> <p><a href="#label-Default+Values+for+Options">Default Values for Options</a></p> </li>
</ul> </li>
<li> <p><a href="#label-Argument+Converters">Argument Converters</a></p> </li>
<li> <p><a href="#label-Help">Help</a></p> </li>
<li> <p><a href="#label-Top+List+and+Base+List">Top List and Base List</a></p> </li>
<li> <p><a href="#label-Methods+for+Defining+Options">Methods for Defining Options</a></p> </li>
<li> <p><a href="#label-Parsing">Parsing</a></p> <ul>
<li> <p><a href="#label-Method+parse-21">Method parse!</a></p> </li>
<li> <p><a href="#label-Method+parse">Method parse</a></p> </li>
<li> <p><a href="#label-Method+order-21">Method order!</a></p> </li>
<li> <p><a href="#label-Method+order">Method order</a></p> </li>
<li> <p><a href="#label-Method+permute-21">Method permute!</a></p> </li>
<li> <p><a href="#label-Method+permute">Method permute</a></p> </li>
</ul> </li>
</ul> <h3 id="label-To+Begin+With">To Begin With</h3> <p>To use <a href="../optionparser.html"><code>OptionParser</code></a>:</p> <ol>
<li> <p>Require the <a href="../optionparser.html"><code>OptionParser</code></a> code.</p> </li>
<li> <p>Create an <a href="../optionparser.html"><code>OptionParser</code></a> object.</p> </li>
<li> <p>Define one or more options.</p> </li>
<li> <p>Parse the command line.</p> </li>
</ol> <p><a href="../file.html"><code>File</code></a> <code>basic.rb</code> defines three options, <code>-x</code>, <code>-y</code>, and <code>-z</code>, each with a descriptive string, and each with a block.</p> <pre class="ruby" data-language="ruby"># Require the OptionParser code.
require 'optparse'
# Create an OptionParser object.
parser = OptionParser.new
# Define one or more options.
parser.on('-x', 'Whether to X') do |value|
  p ['x', value]
end
parser.on('-y', 'Whether to Y') do |value|
  p ['y', value]
end
parser.on('-z', 'Whether to Z') do |value|
  p ['z', value]
end
# Parse the command line and return pared-down ARGV.
p parser.parse!
</pre> <p>From these defined options, the parser automatically builds help text:</p> <pre>$ ruby basic.rb --help
Usage: basic [options]
    -x                               Whether to X
    -y                               Whether to Y
    -z                               Whether to Z</pre> <p>When an option is found during parsing, the block defined for the option is called with the argument value. An invalid option raises an exception.</p> <p><a href="../method.html"><code>Method</code></a> parse!, which is used most often in this tutorial, removes from <code>ARGV</code> the options and arguments it finds, leaving other non-option arguments for the program to handle on its own. The method returns the possibly-reduced <code>ARGV</code> array.</p> <p>Executions:</p> <pre>$ ruby basic.rb -x -z
["x", true]
["z", true]
[]
$ ruby basic.rb -z -y -x
["z", true]
["y", true]
["x", true]
[]
$ ruby basic.rb -x input_file.txt output_file.txt
["x", true]
["input_file.txt", "output_file.txt"]
$ ruby basic.rb -a
basic.rb:16:in `&lt;main&gt;': invalid option: -a (OptionParser::InvalidOption)</pre> <h3 id="label-Defining+Options">Defining Options</h3> <p>A common way to define an option in <a href="../optionparser.html"><code>OptionParser</code></a> is with instance method <a href="../optionparser.html#method-i-on"><code>OptionParser#on</code></a>.</p> <p>The method may be called with any number of arguments (whose order does not matter), and may also have a trailing optional keyword argument <code>into</code>.</p> <p>The given arguments determine the characteristics of the new option. These may include:</p> <ul>
<li> <p>One or more short option names.</p> </li>
<li> <p>One or more long option names.</p> </li>
<li> <p>Whether the option takes no argument, an optional argument, or a required argument.</p> </li>
<li> <p>Acceptable <em>forms</em> for the argument.</p> </li>
<li> <p>Acceptable <em>values</em> for the argument.</p> </li>
<li> <p>A proc or method to be called when the parser encounters the option.</p> </li>
<li> <p><a href="../string.html"><code>String</code></a> descriptions for the option.</p> </li>
</ul> <h3 id="label-Option+Names">Option Names</h3> <p>You can give an option one or more names of two types:</p> <ul>
<li> <p>Short (1-character) name, beginning with one hyphen (<code>-</code>).</p> </li>
<li> <p>Long (multi-character) name, beginning with two hyphens (<code>--</code>).</p> </li>
</ul> <h4 id="label-Short+Option+Names">Short Option Names</h4> <p>A short option name consists of a hyphen and a single character.</p> <p><a href="../file.html"><code>File</code></a> <code>short_names.rb</code> defines an option with a short name, <code>-x</code>, and an option with two short names (aliases, in effect) <code>-y</code> and <code>-z</code>.</p> <pre class="ruby" data-language="ruby">require 'optparse'
parser = OptionParser.new
parser.on('-x', 'Short name') do |value|
  p ['x', value]
end
parser.on('-1', '-%', 'Two short names') do |value|
  p ['-1 or -%', value]
end
parser.parse!
</pre> <p>Executions:</p> <pre>$ ruby short_names.rb --help
Usage: short_names [options]
    -x                               Short name
    -1, -%                           Two short names
$ ruby short_names.rb -x
["x", true]
$ ruby short_names.rb -1
["-1 or -%", true]
$ ruby short_names.rb -%
["-1 or -%", true]</pre> <p>Multiple short names can “share” a hyphen:</p> <pre>$ ruby short_names.rb -x1%
["x", true]
["-1 or -%", true]
["-1 or -%", true]</pre> <h4 id="label-Long+Option+Names">Long Option Names</h4> <p>A long option name consists of two hyphens and a one or more characters (usually two or more characters).</p> <p><a href="../file.html"><code>File</code></a> <code>long_names.rb</code> defines an option with a long name, <code>--xxx</code>, and an option with two long names (aliases, in effect) <code>--y1%</code> and <code>--z2#</code>.</p> <pre class="ruby" data-language="ruby">require 'optparse'
parser = OptionParser.new
parser.on('--xxx', 'Long name') do |value|
  p ['-xxx', value]
end
parser.on('--y1%', '--z2#', "Two long names") do |value|
  p ['--y1% or --z2#', value]
end
parser.parse!
</pre> <p>Executions:</p> <pre>$ ruby long_names.rb --help
Usage: long_names [options]
        --xxx                        Long name
        --y1%, --z2#                 Two long names
$ ruby long_names.rb --xxx
["-xxx", true]
$ ruby long_names.rb --y1%
["--y1% or --z2#", true]
$ ruby long_names.rb --z2#
["--y1% or --z2#", true]</pre> <p>A long name may be defined with both positive and negative senses.</p> <p><a href="../file.html"><code>File</code></a> <code>long_with_negation.rb</code> defines an option that has both senses.</p> <pre class="ruby" data-language="ruby">require 'optparse'
parser = OptionParser.new
parser.on('--[no-]binary', 'Long name with negation') do |value|
  p [value, value.class]
end
parser.parse!
</pre> <p>Executions:</p> <pre>$ ruby long_with_negation.rb --help
Usage: long_with_negation [options]
        --[no-]binary                Long name with negation
$ ruby long_with_negation.rb --binary
[true, TrueClass]
$ ruby long_with_negation.rb --no-binary
[false, FalseClass]</pre> <h4 id="label-Mixing+Option+Names">Mixing Option Names</h4> <p>Many developers like to mix short and long option names, so that a short name is in effect an abbreviation of a long name.</p> <p><a href="../file.html"><code>File</code></a> <code>mixed_names.rb</code> defines options that each have both a short and a long name.</p> <pre class="ruby" data-language="ruby">require 'optparse'
parser = OptionParser.new
parser.on('-x', '--xxx', 'Short and long, no argument') do |value|
  p ['--xxx', value]
end
parser.on('-yYYY', '--yyy', 'Short and long, required argument') do |value|
  p ['--yyy', value]
end
parser.on('-z [ZZZ]', '--zzz', 'Short and long, optional argument') do |value|
  p ['--zzz', value]
end
parser.parse!
</pre> <p>Executions:</p> <pre>$ ruby mixed_names.rb --help
Usage: mixed_names [options]
    -x, --xxx                        Short and long, no argument
    -y, --yyyYYY                     Short and long, required argument
    -z, --zzz [ZZZ]                  Short and long, optional argument
$ ruby mixed_names.rb -x
["--xxx", true]
$ ruby mixed_names.rb --xxx
["--xxx", true]
$ ruby mixed_names.rb -y
mixed_names.rb:12:in `&lt;main&gt;': missing argument: -y (OptionParser::MissingArgument)
$ ruby mixed_names.rb -y FOO
["--yyy", "FOO"]
$ ruby mixed_names.rb --yyy
mixed_names.rb:12:in `&lt;main&gt;': missing argument: --yyy (OptionParser::MissingArgument)
$ ruby mixed_names.rb --yyy BAR
["--yyy", "BAR"]
$ ruby mixed_names.rb -z
["--zzz", nil]
$ ruby mixed_names.rb -z BAZ
["--zzz", "BAZ"]
$ ruby mixed_names.rb --zzz
["--zzz", nil]
$ ruby mixed_names.rb --zzz BAT
["--zzz", "BAT"]</pre> <h4 id="label-Option+Name+Abbreviations">Option Name Abbreviations</h4> <p>By default, abbreviated option names on the command-line are allowed. An abbreviated name is valid if it is unique among abbreviated option names.</p> <pre class="ruby" data-language="ruby">require 'optparse'
parser = OptionParser.new
parser.on('-n', '--dry-run',) do |value|
  p ['--dry-run', value]
end
parser.on('-d', '--draft',) do |value|
  p ['--draft', value]
end
parser.parse!
</pre> <p>Executions:</p> <pre>$ ruby name_abbrev.rb --help
Usage: name_abbrev [options]
    -n, --dry-run
    -d, --draft
$ ruby name_abbrev.rb -n
["--dry-run", true]
$ ruby name_abbrev.rb --dry-run
["--dry-run", true]
$ ruby name_abbrev.rb -d
["--draft", true]
$ ruby name_abbrev.rb --draft
["--draft", true]
$ ruby name_abbrev.rb --d
name_abbrev.rb:9:in `&lt;main&gt;': ambiguous option: --d (OptionParser::AmbiguousOption)
$ ruby name_abbrev.rb --dr
name_abbrev.rb:9:in `&lt;main&gt;': ambiguous option: --dr (OptionParser::AmbiguousOption)
$ ruby name_abbrev.rb --dry
["--dry-run", true]
$ ruby name_abbrev.rb --dra
["--draft", true]</pre> <p>You can disable abbreviation using method <code>require_exact</code>.</p> <pre class="ruby" data-language="ruby">require 'optparse'
parser = OptionParser.new
parser.on('-n', '--dry-run',) do |value|
  p ['--dry-run', value]
end
parser.on('-d', '--draft',) do |value|
  p ['--draft', value]
end
parser.require_exact = true
parser.parse!
</pre> <p>Executions:</p> <pre>$ ruby no_abbreviation.rb --dry-ru
no_abbreviation.rb:10:in `&lt;main&gt;': invalid option: --dry-ru (OptionParser::InvalidOption)
$ ruby no_abbreviation.rb --dry-run
["--dry-run", true]</pre> <h3 id="label-Option+Arguments">Option Arguments</h3> <p>An option may take no argument, a required argument, or an optional argument.</p> <h4 id="label-Option+with+No+Argument">Option with No Argument</h4> <p>All the examples above define options with no argument.</p> <h4 id="label-Option+with+Required+Argument">Option with Required Argument</h4> <p>Specify a required argument for an option by adding a dummy word to its name definition.</p> <p><a href="../file.html"><code>File</code></a> <code>required_argument.rb</code> defines two options; each has a required argument because the name definition has a following dummy word.</p> <pre class="ruby" data-language="ruby">require 'optparse'
parser = OptionParser.new
parser.on('-x XXX', '--xxx', 'Required argument via short name') do |value|
  p ['--xxx', value]
end
parser.on('-y', '--y YYY', 'Required argument via long name') do |value|
  p ['--yyy', value]
end
parser.parse!
</pre> <p>When an option is found, the given argument is yielded.</p> <p>Executions:</p> <pre>$ ruby required_argument.rb --help
Usage: required_argument [options]
    -x, --xxx XXX                    Required argument via short name
    -y, --y YYY                      Required argument via long name
$ ruby required_argument.rb -x AAA
["--xxx", "AAA"]
$ ruby required_argument.rb -y BBB
["--yyy", "BBB"]</pre> <p>Omitting a required argument raises an error:</p> <pre>$ ruby required_argument.rb -x
required_argument.rb:9:in `&lt;main&gt;': missing argument: -x (OptionParser::MissingArgument)</pre> <h4 id="label-Option+with+Optional+Argument">Option with Optional Argument</h4> <p>Specify an optional argument for an option by adding a dummy word enclosed in square brackets to its name definition.</p> <p><a href="../file.html"><code>File</code></a> <code>optional_argument.rb</code> defines two options; each has an optional argument because the name definition has a following dummy word in square brackets.</p> <pre class="ruby" data-language="ruby">require 'optparse'
parser = OptionParser.new
parser.on('-x [XXX]', '--xxx', 'Optional argument via short  name') do |value|
  p ['--xxx', value]
end
parser.on('-y', '--yyy [YYY]', 'Optional argument via long name') do |value|
  p ['--yyy', value]
end
parser.parse!
</pre> <p>When an option with an argument is found, the given argument yielded.</p> <p>Executions:</p> <pre>$ ruby optional_argument.rb --help
Usage: optional_argument [options]
    -x, --xxx [XXX]                  Optional argument via short  name
    -y, --yyy [YYY]                  Optional argument via long name
$ ruby optional_argument.rb -x AAA
["--xxx", "AAA"]
$ ruby optional_argument.rb -y BBB
["--yyy", "BBB"]</pre> <p>Omitting an optional argument does not raise an error.</p> <h4 id="label-Argument+Abbreviations">Argument Abbreviations</h4> <p>Specify an argument list as an <a href="../array.html"><code>Array</code></a> or a <a href="../hash.html"><code>Hash</code></a>.</p> <pre class="ruby" data-language="ruby">require 'optparse'
parser = OptionParser.new
parser.on('-x', '--xxx=VALUE', %w[ABC def], 'Argument abbreviations') do |value|
  p ['--xxx', value]
end
parser.on('-y', '--yyy=VALUE', {"abc"=&gt;"XYZ", def: "FOO"}, 'Argument abbreviations') do |value|
  p ['--yyy', value]
end
parser.parse!
</pre> <p>When an argument is abbreviated, the expanded argument yielded.</p> <p>Executions:</p> <pre>$ ruby argument_abbreviation.rb --help
Usage: argument_abbreviation [options]
Usage: argument_abbreviation [options]
    -x, --xxx=VALUE                  Argument abbreviations
    -y, --yyy=VALUE                  Argument abbreviations
$ ruby argument_abbreviation.rb --xxx A
["--xxx", "ABC"]
$ ruby argument_abbreviation.rb --xxx c
argument_abbreviation.rb:9:in `&lt;main&gt;': invalid argument: --xxx c (OptionParser::InvalidArgument)
$ ruby argument_abbreviation.rb --yyy a --yyy d
["--yyy", "XYZ"]
["--yyy", "FOO"]</pre> <h3 id="label-Argument+Values">Argument Values</h3> <p>Permissible argument values may be restricted either by specifying explicit values or by providing a pattern that the given value must match.</p> <h4 id="label-Explicit+Argument+Values">Explicit Argument Values</h4> <p>You can specify argument values in either of two ways:</p> <ul>
<li> <p>Specify values an array of strings.</p> </li>
<li> <p>Specify values a hash.</p> </li>
</ul> <h5 id="label-Explicit+Values+in+Array">Explicit Values in <a href="../array.html"><code>Array</code></a>
</h5> <p>You can specify explicit argument values in an array of strings. The argument value must be one of those strings, or an unambiguous abbreviation.</p> <p><a href="../file.html"><code>File</code></a> <code>explicit_array_values.rb</code> defines options with explicit argument values.</p> <pre class="ruby" data-language="ruby">require 'optparse'
parser = OptionParser.new
parser.on('-xXXX', ['foo', 'bar'], 'Values for required argument' ) do |value|
  p ['-x', value]
end
parser.on('-y [YYY]', ['baz', 'bat'], 'Values for optional argument') do |value|
  p ['-y', value]
end
parser.parse!
</pre> <p>Executions:</p> <pre>$ ruby explicit_array_values.rb --help
Usage: explicit_array_values [options]
    -xXXX                            Values for required argument
    -y [YYY]                         Values for optional argument
$ ruby explicit_array_values.rb -x
explicit_array_values.rb:9:in `&lt;main&gt;': missing argument: -x (OptionParser::MissingArgument)
$ ruby explicit_array_values.rb -x foo
["-x", "foo"]
$ ruby explicit_array_values.rb -x f
["-x", "foo"]
$ ruby explicit_array_values.rb -x bar
["-x", "bar"]
$ ruby explicit_array_values.rb -y ba
explicit_array_values.rb:9:in `&lt;main&gt;': ambiguous argument: -y ba (OptionParser::AmbiguousArgument)
$ ruby explicit_array_values.rb -x baz
explicit_array_values.rb:9:in `&lt;main&gt;': invalid argument: -x baz (OptionParser::InvalidArgument)</pre> <h5 id="label-Explicit+Values+in+Hash">Explicit Values in <a href="../hash.html"><code>Hash</code></a>
</h5> <p>You can specify explicit argument values in a hash with string keys. The value passed must be one of those keys, or an unambiguous abbreviation; the value yielded will be the value for that key.</p> <p><a href="../file.html"><code>File</code></a> <code>explicit_hash_values.rb</code> defines options with explicit argument values.</p> <pre class="ruby" data-language="ruby">require 'optparse'
parser = OptionParser.new
parser.on('-xXXX', {foo: 0, bar: 1}, 'Values for required argument' ) do |value|
  p ['-x', value]
end
parser.on('-y [YYY]', {baz: 2, bat: 3}, 'Values for optional argument') do |value|
  p ['-y', value]
end
parser.parse!
</pre> <p>Executions:</p> <pre>$ ruby explicit_hash_values.rb --help
Usage: explicit_hash_values [options]
    -xXXX                            Values for required argument
    -y [YYY]                         Values for optional argument
$ ruby explicit_hash_values.rb -x
explicit_hash_values.rb:9:in `&lt;main&gt;': missing argument: -x (OptionParser::MissingArgument)
$ ruby explicit_hash_values.rb -x foo
["-x", 0]
$ ruby explicit_hash_values.rb -x f
["-x", 0]
$ ruby explicit_hash_values.rb -x bar
["-x", 1]
$ ruby explicit_hash_values.rb -x baz
explicit_hash_values.rb:9:in `&lt;main&gt;': invalid argument: -x baz (OptionParser::InvalidArgument)
$ ruby explicit_hash_values.rb -y
["-y", nil]
$ ruby explicit_hash_values.rb -y baz
["-y", 2]
$ ruby explicit_hash_values.rb -y bat
["-y", 3]
$ ruby explicit_hash_values.rb -y ba
explicit_hash_values.rb:9:in `&lt;main&gt;': ambiguous argument: -y ba (OptionParser::AmbiguousArgument)
$ ruby explicit_hash_values.rb -y bam
["-y", nil]</pre> <h4 id="label-Argument+Value+Patterns">Argument Value Patterns</h4> <p>You can restrict permissible argument values by specifying a <a href="../regexp.html"><code>Regexp</code></a> that the given argument must match.</p> <p><a href="../file.html"><code>File</code></a> <code>matched_values.rb</code> defines options with matched argument values.</p> <pre class="ruby" data-language="ruby">require 'optparse'
parser = OptionParser.new
parser.on('--xxx XXX', /foo/i, 'Matched values') do |value|
  p ['--xxx', value]
end
parser.parse!
</pre> <p>Executions:</p> <pre>$ ruby matched_values.rb --help
Usage: matched_values [options]
        --xxx XXX                    Matched values
$ ruby matched_values.rb --xxx foo
["--xxx", "foo"]
$ ruby matched_values.rb --xxx FOO
["--xxx", "FOO"]
$ ruby matched_values.rb --xxx bar
matched_values.rb:6:in `&lt;main&gt;': invalid argument: --xxx bar (OptionParser::InvalidArgument)</pre> <h3 id="label-Keyword+Argument+into">Keyword Argument <code>into</code>
</h3> <p>In parsing options, you can add keyword option <code>into</code> with a hash-like argument; each parsed option will be added as a name/value pair.</p> <p>This is useful for:</p> <ul>
<li> <p>Collecting options.</p> </li>
<li> <p>Checking for missing options.</p> </li>
<li> <p>Providing default values for options.</p> </li>
</ul> <h4 id="label-Collecting+Options">Collecting Options</h4> <p>Use keyword argument <code>into</code> to collect options.</p> <pre class="ruby" data-language="ruby">require 'optparse'
parser = OptionParser.new
parser.on('-x', '--xxx', 'Short and long, no argument')
parser.on('-yYYY', '--yyy', 'Short and long, required argument')
parser.on('-z [ZZZ]', '--zzz', 'Short and long, optional argument')
options = {}
parser.parse!(into: options)
p options
</pre> <p>Executions:</p> <pre>$ ruby collected_options.rb --help
Usage: into [options]
    -x, --xxx                        Short and long, no argument
    -y, --yyyYYY                     Short and long, required argument
    -z, --zzz [ZZZ]                  Short and long, optional argument
$ ruby collected_options.rb --xxx
{:xxx=&gt;true}
$ ruby collected_options.rb --xxx --yyy FOO
{:xxx=&gt;true, :yyy=&gt;"FOO"}
$ ruby collected_options.rb --xxx --yyy FOO --zzz Bar
{:xxx=&gt;true, :yyy=&gt;"FOO", :zzz=&gt;"Bar"}
$ ruby collected_options.rb --xxx --yyy FOO --yyy BAR
{:xxx=&gt;true, :yyy=&gt;"BAR"}</pre> <p>Note in the last execution that the argument value for option <code>--yyy</code> was overwritten.</p> <h4 id="label-Checking+for+Missing+Options">Checking for Missing Options</h4> <p>Use the collected options to check for missing options.</p> <pre class="ruby" data-language="ruby">require 'optparse'
parser = OptionParser.new
parser.on('-x', '--xxx', 'Short and long, no argument')
parser.on('-yYYY', '--yyy', 'Short and long, required argument')
parser.on('-z [ZZZ]', '--zzz', 'Short and long, optional argument')
options = {}
parser.parse!(into: options)
required_options = [:xxx, :zzz]
missing_options = required_options - options.keys
unless missing_options.empty?
  fail "Missing required options: #{missing_options}"
end
</pre> <p>Executions:</p> <pre>$ ruby missing_options.rb --help
Usage: missing_options [options]
    -x, --xxx                        Short and long, no argument
    -y, --yyyYYY                     Short and long, required argument
    -z, --zzz [ZZZ]                  Short and long, optional argument
$ ruby missing_options.rb --yyy FOO
missing_options.rb:11:in `&lt;main&gt;': Missing required options: [:xxx, :zzz] (RuntimeError)</pre> <h4 id="label-Default+Values+for+Options">Default Values for Options</h4> <p>Initialize the <code>into</code> argument to define default values for options.</p> <pre class="ruby" data-language="ruby">require 'optparse'
parser = OptionParser.new
parser.on('-x', '--xxx', 'Short and long, no argument')
parser.on('-yYYY', '--yyy', 'Short and long, required argument')
parser.on('-z [ZZZ]', '--zzz', 'Short and long, optional argument')
options = {yyy: 'AAA', zzz: 'BBB'}
parser.parse!(into: options)
p options
</pre> <p>Executions:</p> <pre>$ ruby default_values.rb --help
Usage: default_values [options]
    -x, --xxx                        Short and long, no argument
    -y, --yyyYYY                     Short and long, required argument
    -z, --zzz [ZZZ]                  Short and long, optional argument
$ ruby default_values.rb --yyy FOO
{:yyy=&gt;"FOO", :zzz=&gt;"BBB"}</pre> <h3 id="label-Argument+Converters">Argument Converters</h3> <p>An option can specify that its argument is to be converted from the default <a href="../string.html"><code>String</code></a> to an instance of another class. There are a number of built-in converters.</p> <p>Example: <a href="../file.html"><code>File</code></a> <code>date.rb</code> defines an option whose argument is to be converted to a <a href="../date.html"><code>Date</code></a> object. The argument is converted by method Date#parse.</p> <pre class="ruby" data-language="ruby">require 'optparse/date'
parser = OptionParser.new
parser.on('--date=DATE', Date) do |value|
  p [value, value.class]
end
parser.parse!
</pre> <p>Executions:</p> <pre>$ ruby date.rb --date 2001-02-03
[#&lt;Date: 2001-02-03 ((2451944j,0s,0n),+0s,2299161j)&gt;, Date]
$ ruby date.rb --date 20010203
[#&lt;Date: 2001-02-03 ((2451944j,0s,0n),+0s,2299161j)&gt;, Date]
$ ruby date.rb --date "3rd Feb 2001"
[#&lt;Date: 2001-02-03 ((2451944j,0s,0n),+0s,2299161j)&gt;, Date]</pre> <p>You can also define custom converters. See <a href="argument_converters_rdoc.html">Argument Converters</a> for both built-in and custom converters.</p> <h3 id="label-Help">Help</h3> <p><a href="../optionparser.html"><code>OptionParser</code></a> makes automatically generated help text available.</p> <p>The help text consists of:</p> <ul>
<li> <p>A banner, showing the usage.</p> </li>
<li> <p>Option short and long names.</p> </li>
<li> <p>Option dummy argument names.</p> </li>
<li> <p>Option descriptions.</p> </li>
</ul> <p>Example code:</p> <pre class="ruby" data-language="ruby">require 'optparse'
parser = OptionParser.new
parser.on(
  '-x', '--xxx',
  'Adipiscing elit. Aenean commodo ligula eget.',
  'Aenean massa. Cum sociis natoque penatibus',
  )
parser.on(
  '-y', '--yyy YYY',
  'Lorem ipsum dolor sit amet, consectetuer.'
)
parser.on(
  '-z', '--zzz [ZZZ]',
  'Et magnis dis parturient montes, nascetur',
  'ridiculus mus. Donec quam felis, ultricies',
  'nec, pellentesque eu, pretium quis, sem.',
  )
parser.parse!
</pre> <p>The option names and dummy argument names are defined as described above.</p> <p>The option description consists of the strings that are not themselves option names; An option can have more than one description string. Execution:</p> <pre>Usage: help [options]
    -x, --xxx                        Adipiscing elit. Aenean commodo ligula eget.
                                     Aenean massa. Cum sociis natoque penatibus
    -y, --yyy YYY                    Lorem ipsum dolor sit amet, consectetuer.
    -z, --zzz [ZZZ]                  Et magnis dis parturient montes, nascetur
                                     ridiculus mus. Donec quam felis, ultricies
                                     nec, pellentesque eu, pretium quis, sem.</pre> <p>The program name is included in the default banner: <code>Usage: #{program_name} [options]</code>; you can change the program name.</p> <pre class="ruby" data-language="ruby">require 'optparse'
parser = OptionParser.new
parser.program_name = 'help_program_name.rb'
parser.parse!
</pre> <p>Execution:</p> <pre>$ ruby help_program_name.rb --help
Usage: help_program_name.rb [options]</pre> <p>You can also change the entire banner.</p> <pre class="ruby" data-language="ruby">require 'optparse'
parser = OptionParser.new
parser.banner = "Usage: ruby help_banner.rb"
parser.parse!
</pre> <p>Execution:</p> <pre>$ ruby help_banner.rb --help
Usage: ruby help_banner.rb</pre> <p>By default, the option names are indented 4 spaces and the width of the option-names field is 32 spaces.</p> <p>You can change these values, along with the banner, by passing parameters to <a href="../optionparser.html#method-c-new"><code>OptionParser.new</code></a>.</p> <pre class="ruby" data-language="ruby">require 'optparse'
parser = OptionParser.new(
  'ruby help_format.rb [options]', # Banner
  20,                               # Width of options field
  ' ' * 2                               # Indentation
)
parser.on(
  '-x', '--xxx',
  'Adipiscing elit. Aenean commodo ligula eget.',
  'Aenean massa. Cum sociis natoque penatibus',
  )
parser.on(
  '-y', '--yyy YYY',
  'Lorem ipsum dolor sit amet, consectetuer.'
)
parser.on(
  '-z', '--zzz [ZZZ]',
  'Et magnis dis parturient montes, nascetur',
  'ridiculus mus. Donec quam felis, ultricies',
  'nec, pellentesque eu, pretium quis, sem.',
  )
parser.parse!
</pre> <p>Execution:</p> <pre>$ ruby help_format.rb --help
ruby help_format.rb [options]
  -x, --xxx            Adipiscing elit. Aenean commodo ligula eget.
                       Aenean massa. Cum sociis natoque penatibus
  -y, --yyy YYY        Lorem ipsum dolor sit amet, consectetuer.
  -z, --zzz [ZZZ]      Et magnis dis parturient montes, nascetur
                       ridiculus mus. Donec quam felis, ultricies
                       nec, pellentesque eu, pretium quis, sem.</pre> <h3 id="label-Top+List+and+Base+List">Top List and Base List</h3> <p>An <a href="../optionparser.html"><code>OptionParser</code></a> object maintains a stack of <a href="../optionparser/list.html"><code>OptionParser::List</code></a> objects, each of which has a collection of zero or more options. It is unlikely that you’ll need to add or take away from that stack.</p> <p>The stack includes:</p> <ul>
<li> <p>The <em>top list</em>, given by <a href="../optionparser.html#method-i-top"><code>OptionParser#top</code></a>.</p> </li>
<li> <p>The <em>base list</em>, given by <a href="../optionparser.html#method-i-base"><code>OptionParser#base</code></a>.</p> </li>
</ul> <p>When <a href="../optionparser.html"><code>OptionParser</code></a> builds its help text, the options in the top list precede those in the base list.</p> <h3 id="label-Methods+for+Defining+Options">Methods for Defining Options</h3> <p>Option-defining methods allow you to create an option, and also append/prepend it to the top list or append it to the base list.</p> <p>Each of these next three methods accepts a sequence of parameter arguments and a block, creates an option object using method <a href="../optionparser.html#method-i-make_switch"><code>OptionParser#make_switch</code></a> (see below), and returns the created option:</p> <ul>
<li> <p>Method <a href="../optionparser.html#method-i-define"><code>OptionParser#define</code></a> appends the created option to the top list.</p> </li>
<li> <p>Method <a href="../optionparser.html#method-i-define_head"><code>OptionParser#define_head</code></a> prepends the created option to the top list.</p> </li>
<li> <p>Method <a href="../optionparser.html#method-i-define_tail"><code>OptionParser#define_tail</code></a> appends the created option to the base list.</p> </li>
</ul> <p>These next three methods are identical to the three above, except for their return values:</p> <ul>
<li> <p>Method <a href="../optionparser.html#method-i-on"><code>OptionParser#on</code></a> is identical to method <a href="../optionparser.html#method-i-define"><code>OptionParser#define</code></a>, except that it returns the parser object <code>self</code>.</p> </li>
<li> <p>Method <a href="../optionparser.html#method-i-on_head"><code>OptionParser#on_head</code></a> is identical to method <a href="../optionparser.html#method-i-define_head"><code>OptionParser#define_head</code></a>, except that it returns the parser object <code>self</code>.</p> </li>
<li> <p>Method <a href="../optionparser.html#method-i-on_tail"><code>OptionParser#on_tail</code></a> is identical to method <a href="../optionparser.html#method-i-define_tail"><code>OptionParser#define_tail</code></a>, except that it returns the parser object <code>self</code>.</p> </li>
</ul> <p>Though you may never need to call it directly, here’s the core method for defining an option:</p> <ul><li> <p>Method <a href="../optionparser.html#method-i-make_switch"><code>OptionParser#make_switch</code></a> accepts an array of parameters and a block. See <span>Parameters for New Options</span>. This method is unlike others here in that it:</p> <ul>
<li> <p>Accepts an <em>array of parameters</em>; others accept a <em>sequence of parameter arguments</em>.</p> </li>
<li> <p>Returns an array containing the created option object, option names, and other values; others return either the created option object or the parser object <code>self</code>.</p> </li>
</ul> </li></ul> <h3 id="label-Parsing">Parsing</h3> <p><a href="../optionparser.html"><code>OptionParser</code></a> has six instance methods for parsing.</p> <p>Three have names ending with a “bang” (<code>!</code>):</p> <ul>
<li> <p>parse!</p> </li>
<li> <p>order!</p> </li>
<li> <p>permute!</p> </li>
</ul> <p>Each of these methods:</p> <ul>
<li> <p>Accepts an optional array of string arguments <code>argv</code>; if not given, <code>argv</code> defaults to the value of <a href="../optionparser.html#attribute-i-default_argv"><code>OptionParser#default_argv</code></a>, whose initial value is ARGV.</p> </li>
<li> <p>Accepts an optional keyword argument <code>into</code> (see <a href="#label-Keyword+Argument+into">Keyword Argument into</a>).</p> </li>
<li> <p>Returns <code>argv</code>, possibly with some elements removed.</p> </li>
</ul> <p>The three other methods have names <em>not</em> ending with a “bang”:</p> <ul>
<li> <p>parse</p> </li>
<li> <p>order</p> </li>
<li> <p>permute</p> </li>
</ul> <p>Each of these methods:</p> <ul>
<li> <p>Accepts an array of string arguments <em>or</em> zero or more string arguments.</p> </li>
<li> <p>Accepts an optional keyword argument <code>into</code> and its value <em>into</em>. (see <a href="#label-Keyword+Argument+into">Keyword Argument into</a>).</p> </li>
<li> <p>Returns <code>argv</code>, possibly with some elements removed.</p> </li>
</ul> <h4 id="label-Method+parse-21">Method <code>parse!</code>
</h4> <p>Method <code>parse!</code>:</p> <ul>
<li> <p>Accepts an optional array of string arguments <code>argv</code>; if not given, <code>argv</code> defaults to the value of <a href="../optionparser.html#attribute-i-default_argv"><code>OptionParser#default_argv</code></a>, whose initial value is ARGV.</p> </li>
<li> <p>Accepts an optional keyword argument <code>into</code> (see <a href="#label-Keyword+Argument+into">Keyword Argument into</a>).</p> </li>
<li> <p>Returns <code>argv</code>, possibly with some elements removed.</p> </li>
</ul> <p>The method processes the elements in <code>argv</code> beginning at <code>argv[0]</code>, and ending, by default, at the end.</p> <p>Otherwise processing ends and the method returns when:</p> <ul>
<li> <p>The terminator argument <code>--</code> is found; the terminator argument is removed before the return.</p> </li>
<li> <p>Environment variable <code>POSIXLY_CORRECT</code> is defined and a non-option argument is found; the non-option argument is not removed. Note that the <em>value</em> of that variable does not matter, as only its existence is checked.</p> </li>
</ul> <p><a href="../file.html"><code>File</code></a> <code>parse_bang.rb</code>:</p> <pre class="ruby" data-language="ruby">require 'optparse'
parser = OptionParser.new
parser.on('--xxx') do |value|
  p ['--xxx', value]
end
parser.on('--yyy YYY') do |value|
  p ['--yyy', value]
end
parser.on('--zzz [ZZZ]') do |value|
  p ['--zzz', value]
end
ret = parser.parse!
puts "Returned: #{ret} (#{ret.class})"
</pre> <p>Help:</p> <pre>$ ruby parse_bang.rb --help
Usage: parse_bang [options]
        --xxx
        --yyy YYY
        --zzz [ZZZ]</pre> <p>Default behavior:</p> <pre>$ ruby parse_bang.rb input_file.txt output_file.txt --xxx --yyy FOO --zzz BAR
["--xxx", true]
["--yyy", "FOO"]
["--zzz", "BAR"]
Returned: ["input_file.txt", "output_file.txt"] (Array)</pre> <p>Processing ended by terminator argument:</p> <pre>$ ruby parse_bang.rb input_file.txt output_file.txt --xxx --yyy FOO -- --zzz BAR
["--xxx", true]
["--yyy", "FOO"]
Returned: ["input_file.txt", "output_file.txt", "--zzz", "BAR"] (Array)</pre> <p>Processing ended by non-option found when <code>POSIXLY_CORRECT</code> is defined:</p> <pre>$ POSIXLY_CORRECT=true ruby parse_bang.rb --xxx input_file.txt output_file.txt -yyy FOO
["--xxx", true]
Returned: ["input_file.txt", "output_file.txt", "-yyy", "FOO"] (Array)</pre> <h4 id="label-Method+parse">Method <code>parse</code>
</h4> <p>Method <code>parse</code>:</p> <ul>
<li> <p>Accepts an array of string arguments <em>or</em> zero or more string arguments.</p> </li>
<li> <p>Accepts an optional keyword argument <code>into</code> and its value <em>into</em>. (see <a href="#label-Keyword+Argument+into">Keyword Argument into</a>).</p> </li>
<li> <p>Returns <code>argv</code>, possibly with some elements removed.</p> </li>
</ul> <p>If given an array <code>ary</code>, the method forms array <code>argv</code> as <code>ary.dup</code>. If given zero or more string arguments, those arguments are formed into array <code>argv</code>.</p> <p>The method calls</p> <pre class="ruby" data-language="ruby">parse!(argv, into: into)
</pre> <p>Note that environment variable <code>POSIXLY_CORRECT</code> and the terminator argument <code>--</code> are honored.</p> <p><a href="../file.html"><code>File</code></a> <code>parse.rb</code>:</p> <pre class="ruby" data-language="ruby">require 'optparse'
parser = OptionParser.new
parser.on('--xxx') do |value|
  p ['--xxx', value]
end
parser.on('--yyy YYY') do |value|
  p ['--yyy', value]
end
parser.on('--zzz [ZZZ]') do |value|
  p ['--zzz', value]
end
ret = parser.parse(ARGV)
puts "Returned: #{ret} (#{ret.class})"
</pre> <p>Help:</p> <pre>$ ruby parse.rb --help
Usage: parse [options]
        --xxx
        --yyy YYY
        --zzz [ZZZ]</pre> <p>Default behavior:</p> <pre>$ ruby parse.rb input_file.txt output_file.txt --xxx --yyy FOO --zzz BAR
["--xxx", true]
["--yyy", "FOO"]
["--zzz", "BAR"]
Returned: ["input_file.txt", "output_file.txt"] (Array)</pre> <p>Processing ended by terminator argument:</p> <pre>$ ruby parse.rb input_file.txt output_file.txt --xxx --yyy FOO -- --zzz BAR
["--xxx", true]
["--yyy", "FOO"]
Returned: ["input_file.txt", "output_file.txt", "--zzz", "BAR"] (Array)</pre> <p>Processing ended by non-option found when <code>POSIXLY_CORRECT</code> is defined:</p> <pre>$ POSIXLY_CORRECT=true ruby parse.rb --xxx input_file.txt output_file.txt -yyy FOO
["--xxx", true]
Returned: ["input_file.txt", "output_file.txt", "-yyy", "FOO"] (Array)</pre> <h4 id="label-Method+order-21">Method <code>order!</code>
</h4> <p>Calling method <a href="../optionparser.html#method-i-order-21"><code>OptionParser#order!</code></a> gives exactly the same result as calling method <a href="../optionparser.html#method-i-parse-21"><code>OptionParser#parse!</code></a> with environment variable <code>POSIXLY_CORRECT</code> defined.</p> <h4 id="label-Method+order">Method <code>order</code>
</h4> <p>Calling method <a href="../optionparser.html#method-i-order"><code>OptionParser#order</code></a> gives exactly the same result as calling method <a href="../optionparser.html#method-i-parse"><code>OptionParser#parse</code></a> with environment variable <code>POSIXLY_CORRECT</code> defined.</p> <h4 id="label-Method+permute-21">Method <code>permute!</code>
</h4> <p>Calling method <a href="../optionparser.html#method-i-permute-21"><code>OptionParser#permute!</code></a> gives exactly the same result as calling method <a href="../optionparser.html#method-i-parse-21"><code>OptionParser#parse!</code></a> with environment variable <code>POSIXLY_CORRECT</code> <em>not</em> defined.</p> <h4 id="label-Method+permute">Method <code>permute</code>
</h4> <p>Calling method <a href="../optionparser.html#method-i-permute"><code>OptionParser#permute</code></a> gives exactly the same result as calling method <a href="../optionparser.html#method-i-parse"><code>OptionParser#parse</code></a> with environment variable <code>POSIXLY_CORRECT</code> <em>not</em> defined.</p><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core &copy; 1993&ndash;2024 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library &copy; contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>
