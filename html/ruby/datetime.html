<h1 id="class-DateTime" class="anchor-link class"> class DateTime </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent"><a href="date.html">Date</a></dd>
</dl> <section class="description"> <h2 id="class-DateTime-label-DateTime"><a href="datetime.html"><code>DateTime</code></a></h2> <p>A subclass of <a href="date.html"><code>Date</code></a> that easily handles date, hour, minute, second, and offset.</p> <p><a href="datetime.html"><code>DateTime</code></a> class is considered deprecated. Use <a href="time.html"><code>Time</code></a> class.</p> <p><a href="datetime.html"><code>DateTime</code></a> does not consider any leap seconds, does not track any summer time rules.</p> <p>A <a href="datetime.html"><code>DateTime</code></a> object is created with <a href="datetime.html#method-c-new"><code>DateTime::new</code></a>, <a href="datetime.html#method-c-jd"><code>DateTime::jd</code></a>, <a href="datetime.html#method-c-ordinal"><code>DateTime::ordinal</code></a>, <a href="datetime.html#method-c-commercial"><code>DateTime::commercial</code></a>, <a href="datetime.html#method-c-parse"><code>DateTime::parse</code></a>, <a href="datetime.html#method-c-strptime"><code>DateTime::strptime</code></a>, <a href="datetime.html#method-c-now"><code>DateTime::now</code></a>, <a href="time.html#method-i-to_datetime"><code>Time#to_datetime</code></a>, etc.</p> <pre class="ruby" data-language="ruby">require 'date'

DateTime.new(2001,2,3,4,5,6)
                    #=&gt; #&lt;DateTime: 2001-02-03T04:05:06+00:00 ...&gt;
</pre> <p>The last element of day, hour, minute, or second can be a fractional number. The fractional number’s precision is assumed at most nanosecond.</p> <pre class="ruby" data-language="ruby">DateTime.new(2001,2,3.5)
                    #=&gt; #&lt;DateTime: 2001-02-03T12:00:00+00:00 ...&gt;
</pre> <p>An optional argument, the offset, indicates the difference between the local time and UTC. For example, <code>Rational(3,24)</code> represents ahead of 3 hours of UTC, <code>Rational(-5,24)</code> represents behind of 5 hours of UTC. The offset should be -1 to +1, and its precision is assumed at most second. The default value is zero (equals to UTC).</p> <pre class="ruby" data-language="ruby">DateTime.new(2001,2,3,4,5,6,Rational(3,24))
                    #=&gt; #&lt;DateTime: 2001-02-03T04:05:06+03:00 ...&gt;
</pre> <p>The offset also accepts string form:</p> <pre class="ruby" data-language="ruby">DateTime.new(2001,2,3,4,5,6,'+03:00')
                    #=&gt; #&lt;DateTime: 2001-02-03T04:05:06+03:00 ...&gt;
</pre> <p>An optional argument, the day of calendar reform (<code>start</code>), denotes a Julian day number, which should be 2298874 to 2426355 or negative/positive infinity. The default value is <code>Date::ITALY</code> (2299161=1582-10-15).</p> <p>A <a href="datetime.html"><code>DateTime</code></a> object has various methods. See each reference.</p> <pre class="ruby" data-language="ruby">d = DateTime.parse('3rd Feb 2001 04:05:06+03:30')
                    #=&gt; #&lt;DateTime: 2001-02-03T04:05:06+03:30 ...&gt;
d.hour              #=&gt; 4
d.min               #=&gt; 5
d.sec               #=&gt; 6
d.offset            #=&gt; (7/48)
d.zone              #=&gt; "+03:30"
d += Rational('1.5')
                    #=&gt; #&lt;DateTime: 2001-02-04%16:05:06+03:30 ...&gt;
d = d.new_offset('+09:00')
                    #=&gt; #&lt;DateTime: 2001-02-04%21:35:06+09:00 ...&gt;
d.strftime('%I:%M:%S %p')
                    #=&gt; "09:35:06 PM"
d &gt; DateTime.new(1999)
                    #=&gt; true
</pre> <h3 id="class-DateTime-label-When+should+you+use+DateTime+and+when+should+you+use+Time-3F">When should you use <a href="datetime.html"><code>DateTime</code></a> and when should you use <a href="time.html"><code>Time</code></a>?</h3> <p>It’s a common misconception that <a href="https://en.wikipedia.org/wiki/William_Shakespeare">William Shakespeare</a> and <a href="https://en.wikipedia.org/wiki/Miguel_de_Cervantes">Miguel de Cervantes</a> died on the same day in history - so much so that UNESCO named April 23 as <a href="https://en.wikipedia.org/wiki/World_Book_Day">World Book Day because of this fact</a>. However, because England hadn’t yet adopted the <a href="https://en.wikipedia.org/wiki/Gregorian_calendar#Gregorian_reform">Gregorian Calendar Reform</a> (and wouldn’t until <a href="https://en.wikipedia.org/wiki/Calendar_(New_Style)_Act_1750">1752</a>) their deaths are actually 10 days apart. Since Ruby’s <a href="time.html"><code>Time</code></a> class implements a <a href="https://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar">proleptic Gregorian calendar</a> and has no concept of calendar reform there’s no way to express this with <a href="time.html"><code>Time</code></a> objects. This is where <a href="datetime.html"><code>DateTime</code></a> steps in:</p> <pre class="ruby" data-language="ruby">shakespeare = DateTime.iso8601('1616-04-23', Date::ENGLAND)
 #=&gt; Tue, 23 Apr 1616 00:00:00 +0000
cervantes = DateTime.iso8601('1616-04-23', Date::ITALY)
 #=&gt; Sat, 23 Apr 1616 00:00:00 +0000
</pre> <p>Already you can see something is weird - the days of the week are different. Taking this further:</p> <pre class="ruby" data-language="ruby">cervantes == shakespeare
 #=&gt; false
(shakespeare - cervantes).to_i
 #=&gt; 10
</pre> <p>This shows that in fact they died 10 days apart (in reality 11 days since Cervantes died a day earlier but was buried on the 23rd). We can see the actual date of Shakespeare’s death by using the <a href="date.html#method-i-gregorian"><code>gregorian</code></a> method to convert it:</p> <pre class="ruby" data-language="ruby">shakespeare.gregorian
 #=&gt; Tue, 03 May 1616 00:00:00 +0000
</pre> <p>So there’s an argument that all the celebrations that take place on the 23rd April in Stratford-upon-Avon are actually the wrong date since England is now using the Gregorian calendar. You can see why when we transition across the reform date boundary:</p> <pre class="ruby" data-language="ruby"># start off with the anniversary of Shakespeare's birth in 1751
shakespeare = DateTime.iso8601('1751-04-23', Date::ENGLAND)
 #=&gt; Tue, 23 Apr 1751 00:00:00 +0000

# add 366 days since 1752 is a leap year and April 23 is after February 29
shakespeare + 366
 #=&gt; Thu, 23 Apr 1752 00:00:00 +0000

# add another 365 days to take us to the anniversary in 1753
shakespeare + 366 + 365
 #=&gt; Fri, 04 May 1753 00:00:00 +0000
</pre> <p>As you can see, if we’re accurately tracking the number of <a href="https://en.wikipedia.org/wiki/Tropical_year">solar years</a> since Shakespeare’s birthday then the correct anniversary date would be the 4th May and not the 23rd April.</p> <p>So when should you use <a href="datetime.html"><code>DateTime</code></a> in Ruby and when should you use <a href="time.html"><code>Time</code></a>? Almost certainly you’ll want to use <a href="time.html"><code>Time</code></a> since your app is probably dealing with current dates and times. However, if you need to deal with dates and times in a historical context you’ll want to use <a href="datetime.html"><code>DateTime</code></a> to avoid making the same mistakes as UNESCO. If you also have to deal with timezones then best of luck - just bear in mind that you’ll probably be dealing with <a href="https://en.wikipedia.org/wiki/Solar_time">local solar times</a>, since it wasn’t until the 19th century that the introduction of the railways necessitated the need for <a href="https://en.wikipedia.org/wiki/Standard_time#Great_Britain">Standard Time</a> and eventually timezones.</p> </section> <section id="5Buntitled-5D" class="documentation-section anchor-link"> <section id="public-class-5Buntitled-5D-method-details" class="method-section anchor-link"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-_strptime"> <a href="#method-c-_strptime" title="Link to this method"> <span class="method-callseq"> _strptime(string[, format='%FT%T%z']) → hash </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="_strptime-source"> <pre class="c" data-language="c">static VALUE
datetime_s__strptime(int argc, VALUE *argv, VALUE klass)
{
    return date_s__strptime_internal(argc, argv, klass, "%FT%T%z");
}</pre> </div>  <p>Parses the given representation of date and time with the given template, and returns a hash of parsed elements. _strptime does not support specification of flags and width unlike strftime.</p> <p>See also strptime(3) and <a href="datetime.html#method-i-strftime"><code>strftime</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-civil"> <a href="#method-c-civil" title="Link to this method"> <span class="method-name">civil</span> <span class="method-args">(*args)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="civil-source"> <pre class="c" data-language="c">static VALUE
datetime_s_civil(int argc, VALUE *argv, VALUE klass)
{
    return datetime_initialize(argc, argv, d_lite_s_alloc_complex(klass));
}</pre> </div>  <p>Same as <a href="datetime.html#method-c-new"><code>DateTime.new</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-commercial"> <a href="#method-c-commercial" title="Link to this method"> <span class="method-callseq"> commercial([cwyear=-4712[, cweek=1[, cwday=1[, hour=0[, minute=0[, second=0[, offset=0[, start=Date::ITALY]]]]]]]]) → datetime </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="commercial-source"> <pre class="c" data-language="c">static VALUE
datetime_s_commercial(int argc, VALUE *argv, VALUE klass)
{
    VALUE vy, vw, vd, vh, vmin, vs, vof, vsg, y, fr, fr2, ret;
    int w, d, h, min, s, rof;
    double sg;

    rb_scan_args(argc, argv, "08", &amp;vy, &amp;vw, &amp;vd, &amp;vh, &amp;vmin, &amp;vs, &amp;vof, &amp;vsg);

    y = INT2FIX(-4712);
    w = 1;
    d = 1;

    h = min = s = 0;
    fr2 = INT2FIX(0);
    rof = 0;
    sg = DEFAULT_SG;

    switch (argc) {
      case 8:
        val2sg(vsg, sg);
      case 7:
        val2off(vof, rof);
      case 6:
        check_numeric(vs, "second");
        num2int_with_frac(s, positive_inf);
      case 5:
        check_numeric(vmin, "minute");
        num2int_with_frac(min, 5);
      case 4:
        check_numeric(vh, "hour");
        num2int_with_frac(h, 4);
      case 3:
        check_numeric(vd, "cwday");
        num2int_with_frac(d, 3);
      case 2:
        check_numeric(vw, "cweek");
        w = NUM2INT(vw);
      case 1:
        check_numeric(vy, "year");
        y = vy;
    }

    {
        VALUE nth;
        int ry, rw, rd, rh, rmin, rs, rjd, rjd2, ns;

        if (!valid_commercial_p(y, w, d, sg,
                                &amp;nth, &amp;ry,
                                &amp;rw, &amp;rd, &amp;rjd,
                                &amp;ns))
            rb_raise(eDateError, "invalid date");
        if (!c_valid_time_p(h, min, s, &amp;rh, &amp;rmin, &amp;rs))
            rb_raise(eDateError, "invalid date");
        canon24oc();

        rjd2 = jd_local_to_utc(rjd,
                               time_to_df(rh, rmin, rs),
                               rof);

        ret = d_complex_new_internal(klass,
                                     nth, rjd2,
                                     0, INT2FIX(0),
                                     rof, sg,
                                     0, 0, 0,
                                     rh, rmin, rs,
                                     HAVE_JD | HAVE_TIME);
    }
    add_frac();
    return ret;
}</pre> </div>  <p>Creates a <a href="datetime.html"><code>DateTime</code></a> object denoting the given week date.</p> <pre class="ruby" data-language="ruby">DateTime.commercial(2001) #=&gt; #&lt;DateTime: 2001-01-01T00:00:00+00:00 ...&gt;
DateTime.commercial(2002) #=&gt; #&lt;DateTime: 2001-12-31T00:00:00+00:00 ...&gt;
DateTime.commercial(2001,5,6,4,5,6,'+7')
                          #=&gt; #&lt;DateTime: 2001-02-03T04:05:06+07:00 ...&gt;
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-httpdate"> <a href="#method-c-httpdate" title="Link to this method"> <span class="method-callseq"> httpdate(string='Mon, 01 Jan -4712 00:00:00 GMT'[, start=Date::ITALY]) → datetime </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="httpdate-source"> <pre class="c" data-language="c">static VALUE
datetime_s_httpdate(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, sg, opt;

    argc = rb_scan_args(argc, argv, "02:", &amp;str, &amp;sg, &amp;opt);

    switch (argc) {
      case 0:
        str = rb_str_new2(JULIAN_EPOCH_DATETIME_HTTPDATE);
      case 1:
        sg = INT2FIX(DEFAULT_SG);
    }

    {
        int argc2 = 1;
        VALUE argv2[2], hash;
        argv2[0] = str;
        argv2[1] = opt;
        if (!NIL_P(opt)) argc2++;
        hash = date_s__httpdate(argc2, argv2, klass);
        return dt_new_by_frags(klass, hash, sg);
    }
}</pre> </div>  <p>Creates a new <a href="datetime.html"><code>DateTime</code></a> object by parsing from a string according to some RFC 2616 format.</p> <pre class="ruby" data-language="ruby">DateTime.httpdate('Sat, 03 Feb 2001 04:05:06 GMT')
                          #=&gt; #&lt;DateTime: 2001-02-03T04:05:06+00:00 ...&gt;
</pre> <p>Raise an <a href="argumenterror.html"><code>ArgumentError</code></a> when the string length is longer than <em>limit</em>. You can stop this check by passing <code>limit: nil</code>, but note that it may take a long time to parse.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-iso8601"> <a href="#method-c-iso8601" title="Link to this method"> <span class="method-callseq"> iso8601(string='-4712-01-01T00:00:00+00:00'[, start=Date::ITALY], limit: 128) → datetime </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="iso8601-source"> <pre class="c" data-language="c">static VALUE
datetime_s_iso8601(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, sg, opt;

    argc = rb_scan_args(argc, argv, "02:", &amp;str, &amp;sg, &amp;opt);

    switch (argc) {
      case 0:
        str = rb_str_new2(JULIAN_EPOCH_DATETIME);
      case 1:
        sg = INT2FIX(DEFAULT_SG);
    }

    {
        int argc2 = 1;
        VALUE argv2[2], hash;
        argv2[0] = str;
        argv2[1] = opt;
        if (!NIL_P(opt)) argc2++;
        hash = date_s__iso8601(argc2, argv2, klass);
        return dt_new_by_frags(klass, hash, sg);
    }
}</pre> </div>  <p>Creates a new <a href="datetime.html"><code>DateTime</code></a> object by parsing from a string according to some typical ISO 8601 formats.</p> <pre class="ruby" data-language="ruby">DateTime.iso8601('2001-02-03T04:05:06+07:00')
                          #=&gt; #&lt;DateTime: 2001-02-03T04:05:06+07:00 ...&gt;
DateTime.iso8601('20010203T040506+0700')
                          #=&gt; #&lt;DateTime: 2001-02-03T04:05:06+07:00 ...&gt;
DateTime.iso8601('2001-W05-6T04:05:06+07:00')
                          #=&gt; #&lt;DateTime: 2001-02-03T04:05:06+07:00 ...&gt;
</pre> <p>Raise an <a href="argumenterror.html"><code>ArgumentError</code></a> when the string length is longer than <em>limit</em>. You can stop this check by passing <code>limit: nil</code>, but note that it may take a long time to parse.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-jd"> <a href="#method-c-jd" title="Link to this method"> <span class="method-callseq"> jd([jd=0[, hour=0[, minute=0[, second=0[, offset=0[, start=Date::ITALY]]]]]]) → datetime </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="jd-source"> <pre class="c" data-language="c">static VALUE
datetime_s_jd(int argc, VALUE *argv, VALUE klass)
{
    VALUE vjd, vh, vmin, vs, vof, vsg, jd, fr, fr2, ret;
    int h, min, s, rof;
    double sg;

    rb_scan_args(argc, argv, "06", &amp;vjd, &amp;vh, &amp;vmin, &amp;vs, &amp;vof, &amp;vsg);

    jd = INT2FIX(0);

    h = min = s = 0;
    fr2 = INT2FIX(0);
    rof = 0;
    sg = DEFAULT_SG;

    switch (argc) {
      case 6:
        val2sg(vsg, sg);
      case 5:
        val2off(vof, rof);
      case 4:
        check_numeric(vs, "second");
        num2int_with_frac(s, positive_inf);
      case 3:
        check_numeric(vmin, "minute");
        num2int_with_frac(min, 3);
      case 2:
        check_numeric(vh, "hour");
        num2int_with_frac(h, 2);
      case 1:
        check_numeric(vjd, "jd");
        num2num_with_frac(jd, 1);
    }

    {
        VALUE nth;
        int rh, rmin, rs, rjd, rjd2;

        if (!c_valid_time_p(h, min, s, &amp;rh, &amp;rmin, &amp;rs))
            rb_raise(eDateError, "invalid date");
        canon24oc();

        decode_jd(jd, &amp;nth, &amp;rjd);
        rjd2 = jd_local_to_utc(rjd,
                               time_to_df(rh, rmin, rs),
                               rof);

        ret = d_complex_new_internal(klass,
                                     nth, rjd2,
                                     0, INT2FIX(0),
                                     rof, sg,
                                     0, 0, 0,
                                     rh, rmin, rs,
                                     HAVE_JD | HAVE_TIME);
    }
    add_frac();
    return ret;
}</pre> </div>  <p>Creates a <a href="datetime.html"><code>DateTime</code></a> object denoting the given chronological Julian day number.</p> <pre class="ruby" data-language="ruby">DateTime.jd(2451944)      #=&gt; #&lt;DateTime: 2001-02-03T00:00:00+00:00 ...&gt;
DateTime.jd(2451945)      #=&gt; #&lt;DateTime: 2001-02-04T00:00:00+00:00 ...&gt;
DateTime.jd(Rational('0.5'))
                          #=&gt; #&lt;DateTime: -4712-01-01T12:00:00+00:00 ...&gt;
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-jisx0301"> <a href="#method-c-jisx0301" title="Link to this method"> <span class="method-callseq"> jisx0301(string='-4712-01-01T00:00:00+00:00'[, start=Date::ITALY], limit: 128) → datetime </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="jisx0301-source"> <pre class="c" data-language="c">static VALUE
datetime_s_jisx0301(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, sg, opt;

    argc = rb_scan_args(argc, argv, "02:", &amp;str, &amp;sg, &amp;opt);

    switch (argc) {
      case 0:
        str = rb_str_new2(JULIAN_EPOCH_DATETIME);
      case 1:
        sg = INT2FIX(DEFAULT_SG);
    }

    {
        int argc2 = 1;
        VALUE argv2[2], hash;
        argv2[0] = str;
        argv2[1] = opt;
        if (!NIL_P(opt)) argc2++;
        hash = date_s__jisx0301(argc2, argv2, klass);
        return dt_new_by_frags(klass, hash, sg);
    }
}</pre> </div>  <p>Creates a new <a href="datetime.html"><code>DateTime</code></a> object by parsing from a string according to some typical JIS X 0301 formats.</p> <pre class="ruby" data-language="ruby">DateTime.jisx0301('H13.02.03T04:05:06+07:00')
                          #=&gt; #&lt;DateTime: 2001-02-03T04:05:06+07:00 ...&gt;
</pre> <p>For no-era year, legacy format, Heisei is assumed.</p> <pre class="ruby" data-language="ruby">DateTime.jisx0301('13.02.03T04:05:06+07:00')
                          #=&gt; #&lt;DateTime: 2001-02-03T04:05:06+07:00 ...&gt;
</pre> <p>Raise an <a href="argumenterror.html"><code>ArgumentError</code></a> when the string length is longer than <em>limit</em>. You can stop this check by passing <code>limit: nil</code>, but note that it may take a long time to parse.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-json_create"> <a href="#method-c-json_create" title="Link to this method"> <span class="method-name">json_create</span> <span class="method-args">(object)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="json_create-source"> <pre class="ruby" data-language="ruby"># File ext/json/lib/json/add/date_time.rb, line 10
def self.json_create(object)
  args = object.values_at('y', 'm', 'd', 'H', 'M', 'S')
  of_a, of_b = object['of'].split('/')
  if of_b and of_b != '0'
    args &lt;&lt; Rational(of_a.to_i, of_b.to_i)
  else
    args &lt;&lt; of_a
  end
  args &lt;&lt; object['sg']
  civil(*args)
end</pre> </div>  <p>See <a href="datetime.html#method-i-as_json"><code>as_json</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-new"> <a href="#method-c-new" title="Link to this method"> <span class="method-name">new</span> <span class="method-args">(*args)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="new-source"> <pre class="c" data-language="c">static VALUE
datetime_s_civil(int argc, VALUE *argv, VALUE klass)
{
    return datetime_initialize(argc, argv, d_lite_s_alloc_complex(klass));
}</pre> </div>  <p>Same as <a href="datetime.html#method-c-new"><code>DateTime.new</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-now"> <a href="#method-c-now" title="Link to this method"> <span class="method-callseq"> now([start=Date::ITALY]) → datetime </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="now-source"> <pre class="c" data-language="c">static VALUE
datetime_s_now(int argc, VALUE *argv, VALUE klass)
{
    VALUE vsg, nth, ret;
    double sg;
#ifdef HAVE_CLOCK_GETTIME
    struct timespec ts;
#else
    struct timeval tv;
#endif
    time_t sec;
    struct tm tm;
    long sf, of;
    int y, ry, m, d, h, min, s;

    rb_scan_args(argc, argv, "01", &amp;vsg);

    if (argc &lt; 1)
        sg = DEFAULT_SG;
    else
        sg = NUM2DBL(vsg);

#ifdef HAVE_CLOCK_GETTIME
    if (clock_gettime(CLOCK_REALTIME, &amp;ts) == -1)
        rb_sys_fail("clock_gettime");
    sec = ts.tv_sec;
#else
    if (gettimeofday(&amp;tv, NULL) == -1)
        rb_sys_fail("gettimeofday");
    sec = tv.tv_sec;
#endif
    tzset();
    if (!localtime_r(&amp;sec, &amp;tm))
        rb_sys_fail("localtime");

    y = tm.tm_year + 1900;
    m = tm.tm_mon + 1;
    d = tm.tm_mday;
    h = tm.tm_hour;
    min = tm.tm_min;
    s = tm.tm_sec;
    if (s == 60)
        s = 59;
#ifdef HAVE_STRUCT_TM_TM_GMTOFF
    of = tm.tm_gmtoff;
#elif defined(HAVE_TIMEZONE)
#if defined(HAVE_ALTZONE) &amp;&amp; !defined(_AIX)
    of = (long)-((tm.tm_isdst &gt; 0) ? altzone : timezone);
#else
    of = (long)-timezone;
    if (tm.tm_isdst) {
        time_t sec2;

        tm.tm_isdst = 0;
        sec2 = mktime(&amp;tm);
        of += (long)difftime(sec2, sec);
    }
#endif
#elif defined(HAVE_TIMEGM)
    {
        time_t sec2;

        sec2 = timegm(&amp;tm);
        of = (long)difftime(sec2, sec);
    }
#else
    {
        struct tm tm2;
        time_t sec2;

        if (!gmtime_r(&amp;sec, &amp;tm2))
            rb_sys_fail("gmtime");
        tm2.tm_isdst = tm.tm_isdst;
        sec2 = mktime(&amp;tm2);
        of = (long)difftime(sec, sec2);
    }
#endif
#ifdef HAVE_CLOCK_GETTIME
    sf = ts.tv_nsec;
#else
    sf = tv.tv_usec * 1000;
#endif

    if (of &lt; -DAY_IN_SECONDS || of &gt; DAY_IN_SECONDS) {
        of = 0;
        rb_warning("invalid offset is ignored");
    }

    decode_year(INT2FIX(y), -1, &amp;nth, &amp;ry);

    ret = d_complex_new_internal(klass,
                                 nth, 0,
                                 0, LONG2NUM(sf),
                                 (int)of, GREGORIAN,
                                 ry, m, d,
                                 h, min, s,
                                 HAVE_CIVIL | HAVE_TIME);
    {
        get_d1(ret);
        set_sg(dat, sg);
    }
    return ret;
}</pre> </div>  <p>Creates a <a href="datetime.html"><code>DateTime</code></a> object denoting the present time.</p> <pre class="ruby" data-language="ruby">DateTime.now              #=&gt; #&lt;DateTime: 2011-06-11T21:20:44+09:00 ...&gt;
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-ordinal"> <a href="#method-c-ordinal" title="Link to this method"> <span class="method-callseq"> ordinal([year=-4712[, yday=1[, hour=0[, minute=0[, second=0[, offset=0[, start=Date::ITALY]]]]]]]) → datetime </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="ordinal-source"> <pre class="c" data-language="c">static VALUE
datetime_s_ordinal(int argc, VALUE *argv, VALUE klass)
{
    VALUE vy, vd, vh, vmin, vs, vof, vsg, y, fr, fr2, ret;
    int d, h, min, s, rof;
    double sg;

    rb_scan_args(argc, argv, "07", &amp;vy, &amp;vd, &amp;vh, &amp;vmin, &amp;vs, &amp;vof, &amp;vsg);

    y = INT2FIX(-4712);
    d = 1;

    h = min = s = 0;
    fr2 = INT2FIX(0);
    rof = 0;
    sg = DEFAULT_SG;

    switch (argc) {
      case 7:
        val2sg(vsg, sg);
      case 6:
        val2off(vof, rof);
      case 5:
        check_numeric(vs, "second");
        num2int_with_frac(s, positive_inf);
      case 4:
        check_numeric(vmin, "minute");
        num2int_with_frac(min, 4);
      case 3:
        check_numeric(vh, "hour");
        num2int_with_frac(h, 3);
      case 2:
        check_numeric(vd, "yday");
        num2int_with_frac(d, 2);
      case 1:
        check_numeric(vy, "year");
        y = vy;
    }

    {
        VALUE nth;
        int ry, rd, rh, rmin, rs, rjd, rjd2, ns;

        if (!valid_ordinal_p(y, d, sg,
                             &amp;nth, &amp;ry,
                             &amp;rd, &amp;rjd,
                             &amp;ns))
            rb_raise(eDateError, "invalid date");
        if (!c_valid_time_p(h, min, s, &amp;rh, &amp;rmin, &amp;rs))
            rb_raise(eDateError, "invalid date");
        canon24oc();

        rjd2 = jd_local_to_utc(rjd,
                               time_to_df(rh, rmin, rs),
                               rof);

        ret = d_complex_new_internal(klass,
                                     nth, rjd2,
                                     0, INT2FIX(0),
                                     rof, sg,
                                     0, 0, 0,
                                     rh, rmin, rs,
                                     HAVE_JD | HAVE_TIME);
    }
    add_frac();
    return ret;
}</pre> </div>  <p>Creates a <a href="datetime.html"><code>DateTime</code></a> object denoting the given ordinal date.</p> <pre class="ruby" data-language="ruby">DateTime.ordinal(2001,34) #=&gt; #&lt;DateTime: 2001-02-03T00:00:00+00:00 ...&gt;
DateTime.ordinal(2001,34,4,5,6,'+7')
                          #=&gt; #&lt;DateTime: 2001-02-03T04:05:06+07:00 ...&gt;
DateTime.ordinal(2001,-332,-20,-55,-54,'+7')
                          #=&gt; #&lt;DateTime: 2001-02-03T04:05:06+07:00 ...&gt;
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-parse"> <a href="#method-c-parse" title="Link to this method"> <span class="method-callseq"> parse(string='-4712-01-01T00:00:00+00:00'[, comp=true[, start=Date::ITALY]], limit: 128) → datetime </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="parse-source"> <pre class="c" data-language="c">static VALUE
datetime_s_parse(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, comp, sg, opt;

    argc = rb_scan_args(argc, argv, "03:", &amp;str, &amp;comp, &amp;sg, &amp;opt);

    switch (argc) {
      case 0:
        str = rb_str_new2(JULIAN_EPOCH_DATETIME);
      case 1:
        comp = Qtrue;
      case 2:
        sg = INT2FIX(DEFAULT_SG);
    }

    {
        int argc2 = 2;
        VALUE argv2[3], hash;
        argv2[0] = str;
        argv2[1] = comp;
        argv2[2] = opt;
        if (!NIL_P(opt)) argc2++;
        hash = date_s__parse(argc2, argv2, klass);
        return dt_new_by_frags(klass, hash, sg);
    }
}</pre> </div>  <p>Parses the given representation of date and time, and creates a <a href="datetime.html"><code>DateTime</code></a> object.</p> <p>This method <strong>does</strong> <strong>not</strong> function as a validator. If the input string does not match valid formats strictly, you may get a cryptic result. Should consider to use <a href="datetime.html#method-c-strptime"><code>DateTime.strptime</code></a> instead of this method as possible.</p> <p>If the optional second argument is true and the detected year is in the range “00” to “99”, makes it full.</p> <pre class="ruby" data-language="ruby">DateTime.parse('2001-02-03T04:05:06+07:00')
                          #=&gt; #&lt;DateTime: 2001-02-03T04:05:06+07:00 ...&gt;
DateTime.parse('20010203T040506+0700')
                          #=&gt; #&lt;DateTime: 2001-02-03T04:05:06+07:00 ...&gt;
DateTime.parse('3rd Feb 2001 04:05:06 PM')
                          #=&gt; #&lt;DateTime: 2001-02-03T16:05:06+00:00 ...&gt;
</pre> <p>Raise an <a href="argumenterror.html"><code>ArgumentError</code></a> when the string length is longer than <em>limit</em>. You can stop this check by passing <code>limit: nil</code>, but note that it may take a long time to parse.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-rfc2822"> <a href="#method-c-rfc2822" title="Link to this method"> <span class="method-callseq"> rfc2822(string='Mon, 1 Jan -4712 00:00:00 +0000'[, start=Date::ITALY], limit: 128) → datetime </span> </a> </div> <div class="method-heading"> <a href="#method-c-rfc2822" title="Link to this method"> <span class="method-callseq"> rfc822(string='Mon, 1 Jan -4712 00:00:00 +0000'[, start=Date::ITALY], limit: 128) → datetime </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="rfc2822-source"> <pre class="c" data-language="c">static VALUE
datetime_s_rfc2822(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, sg, opt;

    argc = rb_scan_args(argc, argv, "02:", &amp;str, &amp;sg, &amp;opt);

    switch (argc) {
      case 0:
        str = rb_str_new2(JULIAN_EPOCH_DATETIME_RFC3339);
      case 1:
        sg = INT2FIX(DEFAULT_SG);
    }

    {
        int argc2 = 1;
        VALUE argv2[2], hash;
        argv2[0] = str;
        argv2[1] = opt;
        if (!NIL_P(opt)) argc2++;
        hash = date_s__rfc2822(argc2, argv2, klass);
        return dt_new_by_frags(klass, hash, sg);
    }
}</pre> </div>  <p>Creates a new <a href="datetime.html"><code>DateTime</code></a> object by parsing from a string according to some typical RFC 2822 formats.</p> <pre class="ruby" data-language="ruby">DateTime.rfc2822('Sat, 3 Feb 2001 04:05:06 +0700')
                         #=&gt; #&lt;DateTime: 2001-02-03T04:05:06+07:00 ...&gt;
</pre> <p>Raise an <a href="argumenterror.html"><code>ArgumentError</code></a> when the string length is longer than <em>limit</em>. You can stop this check by passing <code>limit: nil</code>, but note that it may take a long time to parse.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-rfc3339"> <a href="#method-c-rfc3339" title="Link to this method"> <span class="method-callseq"> rfc3339(string='-4712-01-01T00:00:00+00:00'[, start=Date::ITALY], limit: 128) → datetime </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="rfc3339-source"> <pre class="c" data-language="c">static VALUE
datetime_s_rfc3339(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, sg, opt;

    argc = rb_scan_args(argc, argv, "02:", &amp;str, &amp;sg, &amp;opt);

    switch (argc) {
      case 0:
        str = rb_str_new2(JULIAN_EPOCH_DATETIME);
      case 1:
        sg = INT2FIX(DEFAULT_SG);
    }

    {
        int argc2 = 1;
        VALUE argv2[2], hash;
        argv2[0] = str;
        argv2[1] = opt;
        if (!NIL_P(opt)) argc2++;
        hash = date_s__rfc3339(argc2, argv2, klass);
        return dt_new_by_frags(klass, hash, sg);
    }
}</pre> </div>  <p>Creates a new <a href="datetime.html"><code>DateTime</code></a> object by parsing from a string according to some typical RFC 3339 formats.</p> <pre class="ruby" data-language="ruby">DateTime.rfc3339('2001-02-03T04:05:06+07:00')
                          #=&gt; #&lt;DateTime: 2001-02-03T04:05:06+07:00 ...&gt;
</pre> <p>Raise an <a href="argumenterror.html"><code>ArgumentError</code></a> when the string length is longer than <em>limit</em>. You can stop this check by passing <code>limit: nil</code>, but note that it may take a long time to parse.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-rfc822"> <a href="#method-c-rfc822" title="Link to this method"> <span class="method-callseq"> rfc2822(string='Mon, 1 Jan -4712 00:00:00 +0000'[, start=Date::ITALY], limit: 128) → datetime </span> </a> </div> <div class="method-heading"> <a href="#method-c-rfc822" title="Link to this method"> <span class="method-callseq"> rfc822(string='Mon, 1 Jan -4712 00:00:00 +0000'[, start=Date::ITALY], limit: 128) → datetime </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="rfc822-source"> <pre class="c" data-language="c">static VALUE
datetime_s_rfc2822(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, sg, opt;

    argc = rb_scan_args(argc, argv, "02:", &amp;str, &amp;sg, &amp;opt);

    switch (argc) {
      case 0:
        str = rb_str_new2(JULIAN_EPOCH_DATETIME_RFC3339);
      case 1:
        sg = INT2FIX(DEFAULT_SG);
    }

    {
        int argc2 = 1;
        VALUE argv2[2], hash;
        argv2[0] = str;
        argv2[1] = opt;
        if (!NIL_P(opt)) argc2++;
        hash = date_s__rfc2822(argc2, argv2, klass);
        return dt_new_by_frags(klass, hash, sg);
    }
}</pre> </div>  <p>Creates a new <a href="datetime.html"><code>DateTime</code></a> object by parsing from a string according to some typical RFC 2822 formats.</p> <pre class="ruby" data-language="ruby">DateTime.rfc2822('Sat, 3 Feb 2001 04:05:06 +0700')
                         #=&gt; #&lt;DateTime: 2001-02-03T04:05:06+07:00 ...&gt;
</pre> <p>Raise an <a href="argumenterror.html"><code>ArgumentError</code></a> when the string length is longer than <em>limit</em>. You can stop this check by passing <code>limit: nil</code>, but note that it may take a long time to parse.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-strptime"> <a href="#method-c-strptime" title="Link to this method"> <span class="method-callseq"> strptime([string='-4712-01-01T00:00:00+00:00'[, format='%FT%T%z'[ ,start=Date::ITALY]]]) → datetime </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="strptime-source"> <pre class="c" data-language="c">static VALUE
datetime_s_strptime(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, fmt, sg;

    rb_scan_args(argc, argv, "03", &amp;str, &amp;fmt, &amp;sg);

    switch (argc) {
      case 0:
        str = rb_str_new2(JULIAN_EPOCH_DATETIME);
      case 1:
        fmt = rb_str_new2("%FT%T%z");
      case 2:
        sg = INT2FIX(DEFAULT_SG);
    }

    {
        VALUE argv2[2], hash;

        argv2[0] = str;
        argv2[1] = fmt;
        hash = date_s__strptime(2, argv2, klass);
        return dt_new_by_frags(klass, hash, sg);
    }
}</pre> </div>  <p>Parses the given representation of date and time with the given template, and creates a <a href="datetime.html"><code>DateTime</code></a> object. strptime does not support specification of flags and width unlike strftime.</p> <pre class="ruby" data-language="ruby">DateTime.strptime('2001-02-03T04:05:06+07:00', '%Y-%m-%dT%H:%M:%S%z')
                          #=&gt; #&lt;DateTime: 2001-02-03T04:05:06+07:00 ...&gt;
DateTime.strptime('03-02-2001 04:05:06 PM', '%d-%m-%Y %I:%M:%S %p')
                          #=&gt; #&lt;DateTime: 2001-02-03T16:05:06+00:00 ...&gt;
DateTime.strptime('2001-W05-6T04:05:06+07:00', '%G-W%V-%uT%H:%M:%S%z')
                          #=&gt; #&lt;DateTime: 2001-02-03T04:05:06+07:00 ...&gt;
DateTime.strptime('2001 04 6 04 05 06 +7', '%Y %U %w %H %M %S %z')
                          #=&gt; #&lt;DateTime: 2001-02-03T04:05:06+07:00 ...&gt;
DateTime.strptime('2001 05 6 04 05 06 +7', '%Y %W %u %H %M %S %z')
                          #=&gt; #&lt;DateTime: 2001-02-03T04:05:06+07:00 ...&gt;
DateTime.strptime('-1', '%s')
                          #=&gt; #&lt;DateTime: 1969-12-31T23:59:59+00:00 ...&gt;
DateTime.strptime('-1000', '%Q')
                          #=&gt; #&lt;DateTime: 1969-12-31T23:59:59+00:00 ...&gt;
DateTime.strptime('sat3feb014pm+7', '%a%d%b%y%H%p%z')
                          #=&gt; #&lt;DateTime: 2001-02-03T16:00:00+07:00 ...&gt;
</pre> <p>See also strptime(3) and <a href="datetime.html#method-i-strftime"><code>strftime</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-xmlschema"> <a href="#method-c-xmlschema" title="Link to this method"> <span class="method-callseq"> xmlschema(string='-4712-01-01T00:00:00+00:00'[, start=Date::ITALY], limit: 128) → datetime </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="xmlschema-source"> <pre class="c" data-language="c">static VALUE
datetime_s_xmlschema(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, sg, opt;

    argc = rb_scan_args(argc, argv, "02:", &amp;str, &amp;sg, &amp;opt);

    switch (argc) {
      case 0:
        str = rb_str_new2(JULIAN_EPOCH_DATETIME);
      case 1:
        sg = INT2FIX(DEFAULT_SG);
    }

    {
        int argc2 = 1;
        VALUE argv2[2], hash;
        argv2[0] = str;
        argv2[1] = opt;
        if (!NIL_P(opt)) argc2++;
        hash = date_s__xmlschema(argc2, argv2, klass);
        return dt_new_by_frags(klass, hash, sg);
    }
}</pre> </div>  <p>Creates a new <a href="datetime.html"><code>DateTime</code></a> object by parsing from a string according to some typical XML Schema formats.</p> <pre class="ruby" data-language="ruby">DateTime.xmlschema('2001-02-03T04:05:06+07:00')
                          #=&gt; #&lt;DateTime: 2001-02-03T04:05:06+07:00 ...&gt;
</pre> <p>Raise an <a href="argumenterror.html"><code>ArgumentError</code></a> when the string length is longer than <em>limit</em>. You can stop this check by passing <code>limit: nil</code>, but note that it may take a long time to parse.</p> </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section anchor-link"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-as_json"> <a href="#method-i-as_json" title="Link to this method"> <span class="method-name">as_json</span> <span class="method-args">(*)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="as_json-source"> <pre class="ruby" data-language="ruby"># File ext/json/lib/json/add/date_time.rb, line 39
def as_json(*)
  {
    JSON.create_id =&gt; self.class.name,
    'y' =&gt; year,
    'm' =&gt; month,
    'd' =&gt; day,
    'H' =&gt; hour,
    'M' =&gt; min,
    'S' =&gt; sec,
    'of' =&gt; offset.to_s,
    'sg' =&gt; start,
  }
end</pre> </div>  <p>Methods <a href="datetime.html#method-i-as_json"><code>DateTime#as_json</code></a> and <a href="datetime.html#method-c-json_create"><code>DateTime.json_create</code></a> may be used to serialize and deserialize a DateTime object; see <a href="marshal.html"><code>Marshal</code></a>.</p> <p>Method <a href="datetime.html#method-i-as_json"><code>DateTime#as_json</code></a> serializes <code>self</code>, returning a 2-element hash representing <code>self</code>:</p> <pre class="ruby" data-language="ruby">require 'json/add/datetime'
x = DateTime.now.as_json
# =&gt; {"json_class"=&gt;"DateTime", "y"=&gt;2023, "m"=&gt;11, "d"=&gt;21, "sg"=&gt;2299161.0}
</pre> <p>Method <code>JSON.create</code> deserializes such a hash, returning a DateTime object:</p> <pre class="ruby" data-language="ruby">DateTime.json_create(x) # BUG? Raises Date::Error "invalid date"
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-deconstruct_keys"> <a href="#method-i-deconstruct_keys" title="Link to this method"> <span class="method-callseq"> deconstruct_keys(array_of_names_or_nil) → hash </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="deconstruct_keys-source"> <pre class="c" data-language="c">static VALUE
dt_lite_deconstruct_keys(VALUE self, VALUE keys)
{
    return deconstruct_keys(self, keys, /* is_datetime=true */ 1);
}</pre> </div>  <p>Returns a hash of the name/value pairs, to use in pattern matching. Possible keys are: <code>:year</code>, <code>:month</code>, <code>:day</code>, <code>:wday</code>, <code>:yday</code>, <code>:hour</code>, <code>:min</code>, <code>:sec</code>, <code>:sec_fraction</code>, <code>:zone</code>.</p> <p>Possible usages:</p> <pre class="ruby" data-language="ruby">dt = DateTime.new(2022, 10, 5, 13, 30)

if d in wday: 1..5, hour: 10..18  # uses deconstruct_keys underneath
  puts "Working time"
end
#=&gt; prints "Working time"

case dt
in year: ...2022
  puts "too old"
in month: ..9
  puts "quarter 1-3"
in wday: 1..5, month:
  puts "working day in month #{month}"
end
#=&gt; prints "working day in month 10"
</pre> <p>Note that deconstruction by pattern can also be combined with class check:</p> <pre class="ruby" data-language="ruby">if d in DateTime(wday: 1..5, hour: 10..18, day: ..7)
  puts "Working time, first week of the month"
end
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-hour"> <a href="#method-i-hour" title="Link to this method"> <span class="method-callseq"> hour → integer </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="hour-source"> <pre class="c" data-language="c">static VALUE
d_lite_hour(VALUE self)
{
    get_d1(self);
    return INT2FIX(m_hour(dat));
}</pre> </div>  <p>Returns the hour in range (0..23):</p> <pre class="ruby" data-language="ruby">DateTime.new(2001, 2, 3, 4, 5, 6).hour # =&gt; 4
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-iso8601"> <a href="#method-i-iso8601" title="Link to this method"> <span class="method-callseq"> iso8601([n=0]) → string </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="iso8601-source"> <pre class="c" data-language="c">static VALUE
dt_lite_iso8601(int argc, VALUE *argv, VALUE self)
{
    long n = 0;

    rb_check_arity(argc, 0, 1);
    if (argc &gt;= 1)
        n = NUM2LONG(argv[0]);

    return rb_str_append(strftimev("%Y-%m-%d", self, set_tmx),
                         iso8601_timediv(self, n));
}</pre> </div>  <p>This method is equivalent to strftime(‘%FT%T%:z’). The optional argument <code>n</code> is the number of digits for fractional seconds.</p> <pre class="ruby" data-language="ruby">DateTime.parse('2001-02-03T04:05:06.123456789+07:00').iso8601(9)
                          #=&gt; "2001-02-03T04:05:06.123456789+07:00"
</pre> </div> <div class="aliases"> Also aliased as: <a href="datetime.html#method-i-xmlschema">xmlschema</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-jisx0301"> <a href="#method-i-jisx0301" title="Link to this method"> <span class="method-callseq"> jisx0301([n=0]) → string </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="jisx0301-source"> <pre class="c" data-language="c">static VALUE
dt_lite_jisx0301(int argc, VALUE *argv, VALUE self)
{
    long n = 0;

    rb_check_arity(argc, 0, 1);
    if (argc &gt;= 1)
        n = NUM2LONG(argv[0]);

    return rb_str_append(d_lite_jisx0301(self),
                         iso8601_timediv(self, n));
}</pre> </div>  <p>Returns a string in a JIS X 0301 format. The optional argument <code>n</code> is the number of digits for fractional seconds.</p> <pre class="ruby" data-language="ruby">DateTime.parse('2001-02-03T04:05:06.123456789+07:00').jisx0301(9)
                          #=&gt; "H13.02.03T04:05:06.123456789+07:00"
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-min"> <a href="#method-i-min" title="Link to this method"> <span class="method-callseq"> min → integer </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="min-source"> <pre class="c" data-language="c">static VALUE
d_lite_min(VALUE self)
{
    get_d1(self);
    return INT2FIX(m_min(dat));
}</pre> </div>  <p>Returns the minute in range (0..59):</p> <pre class="ruby" data-language="ruby">DateTime.new(2001, 2, 3, 4, 5, 6).min # =&gt; 5
</pre> </div> <div class="aliases"> Also aliased as: <a href="datetime.html#method-i-minute">minute</a> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-minute"> <a href="#method-i-minute" title="Link to this method"> <span class="method-name">minute</span> </a> </div> </div> <div class="aliases"> Alias for: <a href="datetime.html#method-i-min">min</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-new_offset"> <a href="#method-i-new_offset" title="Link to this method"> <span class="method-callseq"> new_offset([offset=0]) → date </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="new_offset-source"> <pre class="c" data-language="c">static VALUE
d_lite_new_offset(int argc, VALUE *argv, VALUE self)
{
    VALUE vof;
    int rof;

    rb_scan_args(argc, argv, "01", &amp;vof);

    rof = 0;
    if (argc &gt;= 1)
        val2off(vof, rof);

    return dup_obj_with_new_offset(self, rof);
}</pre> </div>  <p>Duplicates self and resets its offset.</p> <pre class="ruby" data-language="ruby">d = DateTime.new(2001,2,3,4,5,6,'-02:00')
                          #=&gt; #&lt;DateTime: 2001-02-03T04:05:06-02:00 ...&gt;
d.new_offset('+09:00')    #=&gt; #&lt;DateTime: 2001-02-03T15:05:06+09:00 ...&gt;
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-offset"> <a href="#method-i-offset" title="Link to this method"> <span class="method-callseq"> offset → rational </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="offset-source"> <pre class="c" data-language="c">static VALUE
d_lite_offset(VALUE self)
{
    get_d1(self);
    return m_of_in_day(dat);
}</pre> </div>  <p>Returns the offset.</p> <pre class="ruby" data-language="ruby">DateTime.parse('04pm+0730').offset        #=&gt; (5/16)
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-rfc3339"> <a href="#method-i-rfc3339" title="Link to this method"> <span class="method-callseq"> rfc3339([n=0]) → string </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="rfc3339-source"> <pre class="c" data-language="c">static VALUE
dt_lite_rfc3339(int argc, VALUE *argv, VALUE self)
{
    return dt_lite_iso8601(argc, argv, self);
}</pre> </div>  <p>This method is equivalent to strftime(‘%FT%T%:z’). The optional argument <code>n</code> is the number of digits for fractional seconds.</p> <pre class="ruby" data-language="ruby">DateTime.parse('2001-02-03T04:05:06.123456789+07:00').rfc3339(9)
                          #=&gt; "2001-02-03T04:05:06.123456789+07:00"
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-sec"> <a href="#method-i-sec" title="Link to this method"> <span class="method-callseq"> sec → integer </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="sec-source"> <pre class="c" data-language="c">static VALUE
d_lite_sec(VALUE self)
{
    get_d1(self);
    return INT2FIX(m_sec(dat));
}</pre> </div>  <p>Returns the second in range (0..59):</p> <pre class="ruby" data-language="ruby">DateTime.new(2001, 2, 3, 4, 5, 6).sec # =&gt; 6
</pre> </div> <div class="aliases"> Also aliased as: <a href="datetime.html#method-i-second">second</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-sec_fraction"> <a href="#method-i-sec_fraction" title="Link to this method"> <span class="method-callseq"> sec_fraction → rational </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="sec_fraction-source"> <pre class="c" data-language="c">static VALUE
d_lite_sec_fraction(VALUE self)
{
    get_d1(self);
    return m_sf_in_sec(dat);
}</pre> </div>  <p>Returns the fractional part of the second in range (Rational(0, 1)…Rational(1, 1)):</p> <pre class="ruby" data-language="ruby">DateTime.new(2001, 2, 3, 4, 5, 6.5).sec_fraction # =&gt; (1/2)
</pre> </div> <div class="aliases"> Also aliased as: <a href="datetime.html#method-i-second_fraction">second_fraction</a> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-second"> <a href="#method-i-second" title="Link to this method"> <span class="method-name">second</span> </a> </div> </div> <div class="aliases"> Alias for: <a href="datetime.html#method-i-sec">sec</a> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-second_fraction"> <a href="#method-i-second_fraction" title="Link to this method"> <span class="method-name">second_fraction</span> </a> </div> </div> <div class="aliases"> Alias for: <a href="datetime.html#method-i-sec_fraction">sec_fraction</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-strftime"> <a href="#method-i-strftime" title="Link to this method"> <span class="method-callseq"> strftime(format = '%FT%T%:z') → string </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="strftime-source"> <pre class="c" data-language="c">static VALUE
dt_lite_strftime(int argc, VALUE *argv, VALUE self)
{
    return date_strftime_internal(argc, argv, self,
                                  "%Y-%m-%dT%H:%M:%S%:z", set_tmx);
}</pre> </div>  <p>Returns a string representation of <code>self</code>, formatted according the given +format:</p> <pre class="ruby" data-language="ruby">DateTime.now.strftime # =&gt; "2022-07-01T11:03:19-05:00"
</pre> <p>For other formats, see <a href="strftime_formatting_rdoc.html">Formats for Dates and Times</a>:</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-to_date"> <a href="#method-i-to_date" title="Link to this method"> <span class="method-callseq"> to_date → date </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="to_date-source"> <pre class="c" data-language="c">static VALUE
datetime_to_date(VALUE self)
{
    get_d1a(self);

    if (simple_dat_p(adat)) {
        VALUE new = d_lite_s_alloc_simple(cDate);
        {
            get_d1b(new);
            bdat-&gt;s = adat-&gt;s;
            bdat-&gt;s.jd = m_local_jd(adat);
            return new;
        }
    }
    else {
        VALUE new = d_lite_s_alloc_simple(cDate);
        {
            get_d1b(new);
            copy_complex_to_simple(new, &amp;bdat-&gt;s, &amp;adat-&gt;c);
            bdat-&gt;s.jd = m_local_jd(adat);
            bdat-&gt;s.flags &amp;= ~(HAVE_DF | HAVE_TIME | COMPLEX_DAT);
            return new;
        }
    }
}</pre> </div>  <p>Returns a <a href="date.html"><code>Date</code></a> object which denotes self.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-to_datetime"> <a href="#method-i-to_datetime" title="Link to this method"> <span class="method-callseq"> to_datetime → self </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="to_datetime-source"> <pre class="c" data-language="c">static VALUE
datetime_to_datetime(VALUE self)
{
    return self;
}</pre> </div>  <p>Returns self.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-to_json"> <a href="#method-i-to_json" title="Link to this method"> <span class="method-name">to_json</span> <span class="method-args">(*args)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="to_json-source"> <pre class="ruby" data-language="ruby"># File ext/json/lib/json/add/date_time.rb, line 62
def to_json(*args)
  as_json.to_json(*args)
end</pre> </div>  <p>Returns a <a href="json.html"><code>JSON</code></a> string representing <code>self</code>:</p> <pre class="ruby" data-language="ruby">require 'json/add/datetime'
puts DateTime.now.to_json
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">{"json_class":"DateTime","y":2023,"m":11,"d":21,"sg":2299161.0}
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-to_s"> <a href="#method-i-to_s" title="Link to this method"> <span class="method-callseq"> to_s → string </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="to_s-source"> <pre class="c" data-language="c">static VALUE
dt_lite_to_s(VALUE self)
{
    return strftimev("%Y-%m-%dT%H:%M:%S%:z", self, set_tmx);
}</pre> </div>  <p>Returns a string in an ISO 8601 format. (This method doesn’t use the expanded representations.)</p> <pre class="ruby" data-language="ruby">DateTime.new(2001,2,3,4,5,6,'-7').to_s
                         #=&gt; "2001-02-03T04:05:06-07:00"
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-to_time"> <a href="#method-i-to_time" title="Link to this method"> <span class="method-callseq"> to_time → time </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="to_time-source"> <pre class="c" data-language="c">static VALUE
datetime_to_time(VALUE self)
{
    get_d1(self);

    if (m_julian_p(dat)) {
        VALUE g = d_lite_gregorian(self);
        get_d1a(g);
        dat = adat;
        self = g;
    }

    {
        VALUE t;

        t = rb_funcall(rb_cTime,
                   rb_intern("new"),
                   7,
                   m_real_year(dat),
                   INT2FIX(m_mon(dat)),
                   INT2FIX(m_mday(dat)),
                   INT2FIX(m_hour(dat)),
                   INT2FIX(m_min(dat)),
                   f_add(INT2FIX(m_sec(dat)),
                         m_sf_in_sec(dat)),
                   INT2FIX(m_of(dat)));
        RB_GC_GUARD(self); /* may be the converted gregorian */
        return t;
    }
}</pre> </div>  <p>Returns a <a href="time.html"><code>Time</code></a> object which denotes self.</p> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-xmlschema"> <a href="#method-i-xmlschema" title="Link to this method"> <span class="method-callseq"> xmlschema([n=0]) → string </span> </a> </div> </div> <div class="method-description"> <p>This method is equivalent to strftime(‘%FT%T%:z’). The optional argument <code>n</code> is the number of digits for fractional seconds.</p> <pre class="ruby" data-language="ruby">DateTime.parse('2001-02-03T04:05:06.123456789+07:00').iso8601(9)
                          #=&gt; "2001-02-03T04:05:06.123456789+07:00"
</pre> </div> <div class="aliases"> Alias for: <a href="datetime.html#method-i-iso8601">iso8601</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-zone"> <a href="#method-i-zone" title="Link to this method"> <span class="method-callseq"> zone → string </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="zone-source"> <pre class="c" data-language="c">static VALUE
d_lite_zone(VALUE self)
{
    get_d1(self);
    return m_zone(dat);
}</pre> </div>  <p>Returns the timezone.</p> <pre class="ruby" data-language="ruby">DateTime.parse('04pm+0730').zone          #=&gt; "+07:30"
</pre> </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core &copy; 1993&ndash;2024 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library &copy; contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>
