<h1 id="class-Complex" class="anchor-link class"> class Complex </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent"><a href="numeric.html">Numeric</a></dd>
</dl> <section class="description"> <p>A Complex object houses a pair of values, given when the object is created as either <em>rectangular coordinates</em> or <em>polar coordinates</em>.</p> <h2 id="class-Complex-label-Rectangular+Coordinates">Rectangular Coordinates</h2> <p>The rectangular coordinates of a complex number are called the <em>real</em> and <em>imaginary</em> parts; see <a href="https://en.wikipedia.org/wiki/Complex_number#Definition_and_basic_operations">Complex number definition</a>.</p> <p>You can create a Complex object from rectangular coordinates with:</p> <ul>
<li> <p>A <a href="syntax/literals_rdoc.html#label-Complex+Literals">complex literal</a>.</p> </li>
<li> <p>Method <a href="complex.html#method-c-rect"><code>Complex.rect</code></a>.</p> </li>
<li> <p>Method <a href="kernel.html#method-i-Complex"><code>Kernel#Complex</code></a>, either with numeric arguments or with certain string arguments.</p> </li>
<li> <p>Method <a href="string.html#method-i-to_c"><code>String#to_c</code></a>, for certain strings.</p> </li>
</ul> <p>Note that each of the stored parts may be a an instance one of the classes <a href="complex.html"><code>Complex</code></a>, <a href="float.html"><code>Float</code></a>, <a href="integer.html"><code>Integer</code></a>, or <a href="rational.html"><code>Rational</code></a>; they may be retrieved:</p> <ul>
<li> <p>Separately, with methods <a href="complex.html#method-i-real"><code>Complex#real</code></a> and <a href="complex.html#method-i-imaginary"><code>Complex#imaginary</code></a>.</p> </li>
<li> <p>Together, with method <a href="complex.html#method-i-rect"><code>Complex#rect</code></a>.</p> </li>
</ul> <p>The corresponding (computed) polar values may be retrieved:</p> <ul>
<li> <p>Separately, with methods <a href="complex.html#method-i-abs"><code>Complex#abs</code></a> and <a href="complex.html#method-i-arg"><code>Complex#arg</code></a>.</p> </li>
<li> <p>Together, with method <a href="complex.html#method-i-polar"><code>Complex#polar</code></a>.</p> </li>
</ul> <h2 id="class-Complex-label-Polar+Coordinates">Polar Coordinates</h2> <p>The polar coordinates of a complex number are called the <em>absolute</em> and <em>argument</em> parts; see <a href="https://en.wikipedia.org/wiki/Complex_number#Polar_form">Complex polar plane</a>.</p> <p>In this class, the argument part in expressed <a href="https://en.wikipedia.org/wiki/Radian">radians</a> (not <a href="https://en.wikipedia.org/wiki/Degree_(angle)">degrees</a>).</p> <p>You can create a Complex object from polar coordinates with:</p> <ul>
<li> <p>Method <a href="complex.html#method-c-polar"><code>Complex.polar</code></a>.</p> </li>
<li> <p>Method <a href="kernel.html#method-i-Complex"><code>Kernel#Complex</code></a>, with certain string arguments.</p> </li>
<li> <p>Method <a href="string.html#method-i-to_c"><code>String#to_c</code></a>, for certain strings.</p> </li>
</ul> <p>Note that each of the stored parts may be a an instance one of the classes <a href="complex.html"><code>Complex</code></a>, <a href="float.html"><code>Float</code></a>, <a href="integer.html"><code>Integer</code></a>, or <a href="rational.html"><code>Rational</code></a>; they may be retrieved:</p> <ul>
<li> <p>Separately, with methods <a href="complex.html#method-i-abs"><code>Complex#abs</code></a> and <a href="complex.html#method-i-arg"><code>Complex#arg</code></a>.</p> </li>
<li> <p>Together, with method <a href="complex.html#method-i-polar"><code>Complex#polar</code></a>.</p> </li>
</ul> <p>The corresponding (computed) rectangular values may be retrieved:</p> <ul>
<li> <p>Separately, with methods <a href="complex.html#method-i-real"><code>Complex#real</code></a> and <a href="complex.html#method-i-imag"><code>Complex#imag</code></a>.</p> </li>
<li> <p>Together, with method <a href="complex.html#method-i-rect"><code>Complex#rect</code></a>.</p> </li>
</ul> <h2 id="class-Complex-label-What-27s+Here">What’s Here</h2> <p>First, what’s elsewhere:</p> <ul>
<li> <p>Class Complex inherits (directly or indirectly) from classes <a href="numeric.html#class-Numeric-label-What-27s+Here">Numeric</a> and <a href="object.html#class-Object-label-What-27s+Here">Object</a>.</p> </li>
<li> <p>Includes (indirectly) module <a href="comparable.html#module-Comparable-label-What-27s+Here">Comparable</a>.</p> </li>
</ul> <p>Here, class Complex has methods for:</p> <h3 id="class-Complex-label-Creating+Complex+Objects">Creating Complex Objects</h3> <ul>
<li> <p><a href="complex.html#method-c-polar"><code>::polar</code></a>: Returns a new Complex object based on given polar coordinates.</p> </li>
<li> <p><a href="complex.html#method-c-rect"><code>::rect</code></a> (and its alias <a href="complex.html#method-c-rectangular"><code>::rectangular</code></a>): Returns a new Complex object based on given rectangular coordinates.</p> </li>
</ul> <h3 id="class-Complex-label-Querying">Querying</h3> <ul>
<li> <p><a href="complex.html#method-i-abs"><code>abs</code></a> (and its alias <a href="complex.html#method-i-magnitude"><code>magnitude</code></a>): Returns the absolute value for <code>self</code>.</p> </li>
<li> <p><a href="complex.html#method-i-arg"><code>arg</code></a> (and its aliases <a href="complex.html#method-i-angle"><code>angle</code></a> and <a href="complex.html#method-i-phase"><code>phase</code></a>): Returns the argument (angle) for <code>self</code> in radians.</p> </li>
<li> <p><a href="complex.html#method-i-denominator"><code>denominator</code></a>: Returns the denominator of <code>self</code>.</p> </li>
<li> <p><a href="complex.html#method-i-finite-3F"><code>finite?</code></a>: Returns whether both <code>self.real</code> and <code>self.image</code> are finite.</p> </li>
<li> <p><a href="complex.html#method-i-hash"><code>hash</code></a>: Returns the integer hash value for <code>self</code>.</p> </li>
<li> <p><a href="complex.html#method-i-imag"><code>imag</code></a> (and its alias <a href="complex.html#method-i-imaginary"><code>imaginary</code></a>): Returns the imaginary value for <code>self</code>.</p> </li>
<li> <p><a href="complex.html#method-i-infinite-3F"><code>infinite?</code></a>: Returns whether <code>self.real</code> or <code>self.image</code> is infinite.</p> </li>
<li> <p><a href="complex.html#method-i-numerator"><code>numerator</code></a>: Returns the numerator of <code>self</code>.</p> </li>
<li> <p><a href="complex.html#method-i-polar"><code>polar</code></a>: Returns the array <code>[self.abs, self.arg]</code>.</p> </li>
<li> <p><a href="complex.html#method-i-inspect"><code>inspect</code></a>: Returns a string representation of <code>self</code>.</p> </li>
<li> <p><a href="complex.html#method-i-real"><code>real</code></a>: Returns the real value for <code>self</code>.</p> </li>
<li> <p><a href="complex.html#method-i-real-3F"><code>real?</code></a>: Returns <code>false</code>; for compatibility with <a href="numeric.html#method-i-real-3F"><code>Numeric#real?</code></a>.</p> </li>
<li> <p><a href="complex.html#method-i-rect"><code>rect</code></a> (and its alias <a href="complex.html#method-i-rectangular"><code>rectangular</code></a>): Returns the array <code>[self.real, self.imag]</code>.</p> </li>
</ul> <h3 id="class-Complex-label-Comparing">Comparing</h3> <ul>
<li> <p><a href="complex.html#method-i-3C-3D-3E"><code>&lt;=&gt;</code></a>: Returns whether <code>self</code> is less than, equal to, or greater than the given argument.</p> </li>
<li> <p><a href="complex.html#method-i-3D-3D"><code>==</code></a>: Returns whether <code>self</code> is equal to the given argument.</p> </li>
</ul> <h3 id="class-Complex-label-Converting">Converting</h3> <ul>
<li> <p><a href="complex.html#method-i-rationalize"><code>rationalize</code></a>: Returns a <a href="rational.html"><code>Rational</code></a> object whose value is exactly or approximately equivalent to that of <code>self.real</code>.</p> </li>
<li> <p><a href="complex.html#method-i-to_c"><code>to_c</code></a>: Returns <code>self</code>.</p> </li>
<li> <p>to_d: Returns the value as a <a href="bigdecimal.html"><code>BigDecimal</code></a> object.</p> </li>
<li> <p><a href="complex.html#method-i-to_f"><code>to_f</code></a>: Returns the value of <code>self.real</code> as a <a href="float.html"><code>Float</code></a>, if possible.</p> </li>
<li> <p><a href="complex.html#method-i-to_i"><code>to_i</code></a>: Returns the value of <code>self.real</code> as an <a href="integer.html"><code>Integer</code></a>, if possible.</p> </li>
<li> <p><a href="complex.html#method-i-to_r"><code>to_r</code></a>: Returns the value of <code>self.real</code> as a <a href="rational.html"><code>Rational</code></a>, if possible.</p> </li>
<li> <p><a href="complex.html#method-i-to_s"><code>to_s</code></a>: Returns a string representation of <code>self</code>.</p> </li>
</ul> <h3 id="class-Complex-label-Performing+Complex+Arithmetic">Performing <a href="complex.html"><code>Complex</code></a> Arithmetic</h3> <ul>
<li> <p><a href="complex.html#method-i-2A"><code>*</code></a>: Returns the product of <code>self</code> and the given numeric.</p> </li>
<li> <p><a href="complex.html#method-i-2A-2A"><code>**</code></a>: Returns <code>self</code> raised to power of the given numeric.</p> </li>
<li> <p><a href="complex.html#method-i-2B"><code>+</code></a>: Returns the sum of <code>self</code> and the given numeric.</p> </li>
<li> <p><a href="complex.html#method-i-2D"><code>-</code></a>: Returns the difference of <code>self</code> and the given numeric.</p> </li>
<li> <p><a href="complex.html#method-i-2D-40"><code>-@</code></a>: Returns the negation of <code>self</code>.</p> </li>
<li> <p><a href="complex.html#method-i-2F"><code>/</code></a>: Returns the quotient of <code>self</code> and the given numeric.</p> </li>
<li> <p><a href="complex.html#method-i-abs2"><code>abs2</code></a>: Returns square of the absolute value (magnitude) for <code>self</code>.</p> </li>
<li> <p><a href="complex.html#method-i-conj"><code>conj</code></a> (and its alias <a href="complex.html#method-i-conjugate"><code>conjugate</code></a>): Returns the conjugate of <code>self</code>.</p> </li>
<li> <p><a href="complex.html#method-i-fdiv"><code>fdiv</code></a>: Returns <a href="complex.html#method-c-rect"><code>Complex.rect(self.real/numeric, self.imag/numeric)</code></a>.</p> </li>
</ul> <h3 id="class-Complex-label-Working+with+JSON">Working with <a href="json.html"><code>JSON</code></a>
</h3> <ul>
<li> <p><a href="complex.html#method-c-json_create"><code>::json_create</code></a>: Returns a new Complex object, deserialized from the given serialized hash.</p> </li>
<li> <p><a href="complex.html#method-i-as_json"><code>as_json</code></a>: Returns a serialized hash constructed from <code>self</code>.</p> </li>
<li> <p><a href="complex.html#method-i-to_json"><code>to_json</code></a>: Returns a <a href="json.html"><code>JSON</code></a> string representing <code>self</code>.</p> </li>
</ul> <p>These methods are provided by the <a href="https://github.com/ruby/json">JSON gem</a>. To make these methods available:</p> <pre class="ruby" data-language="ruby">require 'json/add/complex'
</pre> </section> <section id="5Buntitled-5D" class="documentation-section anchor-link"> <section class="constants-list"> <header> <h3>Constants</h3> </header> <dl> <dt id="I">I </dt>
<dd> <p>Equivalent to <a href="complex.html#method-c-rect"><code>Complex.rect(0, 1)</code></a>:</p> <pre class="ruby" data-language="ruby">Complex::I # =&gt; (0+1i)
</pre> </dd>
</dl> </section> <section id="public-class-5Buntitled-5D-method-details" class="method-section anchor-link"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-json_create"> <a href="#method-c-json_create" title="Link to this method"> <span class="method-name">json_create</span> <span class="method-args">(object)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="json_create-source"> <pre class="ruby" data-language="ruby"># File ext/json/lib/json/add/complex.rb, line 9
def self.json_create(object)
  Complex(object['r'], object['i'])
end</pre> </div>  <p>See <a href="complex.html#method-i-as_json"><code>as_json</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-polar"> <a href="#method-c-polar" title="Link to this method"> <span class="method-callseq"> polar(abs, arg = 0) → complex </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="polar-source"> <pre class="c" data-language="c">static VALUE
nucomp_s_polar(int argc, VALUE *argv, VALUE klass)
{
    VALUE abs, arg;

    argc = rb_scan_args(argc, argv, "11", &amp;abs, &amp;arg);
    abs = nucomp_real_check(abs);
    if (argc == 2) {
        arg = nucomp_real_check(arg);
    }
    else {
        arg = ZERO;
    }
    return f_complex_polar_real(klass, abs, arg);
}</pre> </div>  <p>Returns a new Complex object formed from the arguments, each of which must be an instance of <a href="numeric.html"><code>Numeric</code></a>, or an instance of one of its subclasses: Complex, <a href="float.html"><code>Float</code></a>, <a href="integer.html"><code>Integer</code></a>, <a href="rational.html"><code>Rational</code></a>. Argument <code>arg</code> is given in radians; see <a href="complex.html#class-Complex-label-Polar+Coordinates">Polar Coordinates</a>:</p> <pre class="ruby" data-language="ruby">Complex.polar(3)        # =&gt; (3+0i)
Complex.polar(3, 2.0)   # =&gt; (-1.2484405096414273+2.727892280477045i)
Complex.polar(-3, -2.0) # =&gt; (1.2484405096414273+2.727892280477045i)
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-rect"> <a href="#method-c-rect" title="Link to this method"> <span class="method-callseq"> rect(real, imag = 0) → complex </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="rect-source"> <pre class="c" data-language="c">static VALUE
nucomp_s_new(int argc, VALUE *argv, VALUE klass)
{
    VALUE real, imag;

    switch (rb_scan_args(argc, argv, "11", &amp;real, &amp;imag)) {
      case 1:
        real = nucomp_real_check(real);
        imag = ZERO;
        break;
      default:
        real = nucomp_real_check(real);
        imag = nucomp_real_check(imag);
        break;
    }

    return nucomp_s_new_internal(klass, real, imag);
}</pre> </div>  <p>Returns a new Complex object formed from the arguments, each of which must be an instance of <a href="numeric.html"><code>Numeric</code></a>, or an instance of one of its subclasses: Complex, <a href="float.html"><code>Float</code></a>, <a href="integer.html"><code>Integer</code></a>, <a href="rational.html"><code>Rational</code></a>; see <a href="complex.html#class-Complex-label-Rectangular+Coordinates">Rectangular Coordinates</a>:</p> <pre class="ruby" data-language="ruby">Complex.rect(3)             # =&gt; (3+0i)
Complex.rect(3, Math::PI)   # =&gt; (3+3.141592653589793i)
Complex.rect(-3, -Math::PI) # =&gt; (-3-3.141592653589793i)
</pre> <p>Complex.rectangular is an alias for Complex.rect.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-rectangular"> <a href="#method-c-rectangular" title="Link to this method"> <span class="method-callseq"> rect(real, imag = 0) → complex </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="rectangular-source"> <pre class="c" data-language="c">static VALUE
nucomp_s_new(int argc, VALUE *argv, VALUE klass)
{
    VALUE real, imag;

    switch (rb_scan_args(argc, argv, "11", &amp;real, &amp;imag)) {
      case 1:
        real = nucomp_real_check(real);
        imag = ZERO;
        break;
      default:
        real = nucomp_real_check(real);
        imag = nucomp_real_check(imag);
        break;
    }

    return nucomp_s_new_internal(klass, real, imag);
}</pre> </div>  <p>Returns a new Complex object formed from the arguments, each of which must be an instance of <a href="numeric.html"><code>Numeric</code></a>, or an instance of one of its subclasses: Complex, <a href="float.html"><code>Float</code></a>, <a href="integer.html"><code>Integer</code></a>, <a href="rational.html"><code>Rational</code></a>; see <a href="complex.html#class-Complex-label-Rectangular+Coordinates">Rectangular Coordinates</a>:</p> <pre class="ruby" data-language="ruby">Complex.rect(3)             # =&gt; (3+0i)
Complex.rect(3, Math::PI)   # =&gt; (3+3.141592653589793i)
Complex.rect(-3, -Math::PI) # =&gt; (-3-3.141592653589793i)
</pre> <p>Complex.rectangular is an alias for Complex.rect.</p> </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section anchor-link"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-2A"> <a href="#method-i-2A" title="Link to this method"> <span class="method-callseq"> complex * numeric → new_complex </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="2A-source"> <pre class="c" data-language="c">VALUE
rb_complex_mul(VALUE self, VALUE other)
{
    if (RB_TYPE_P(other, T_COMPLEX)) {
        VALUE real, imag;
        get_dat2(self, other);

        comp_mul(adat-&gt;real, adat-&gt;imag, bdat-&gt;real, bdat-&gt;imag, &amp;real, &amp;imag);

        return f_complex_new2(CLASS_OF(self), real, imag);
    }
    if (k_numeric_p(other) &amp;&amp; f_real_p(other)) {
        get_dat1(self);

        return f_complex_new2(CLASS_OF(self),
                              f_mul(dat-&gt;real, other),
                              f_mul(dat-&gt;imag, other));
    }
    return rb_num_coerce_bin(self, other, '*');
}</pre> </div>  <p>Returns the product of <code>self</code> and <code>numeric</code>:</p> <pre class="ruby" data-language="ruby">Complex.rect(2, 3)  * Complex.rect(2, 3)  # =&gt; (-5+12i)
Complex.rect(900)   * Complex.rect(1)     # =&gt; (900+0i)
Complex.rect(-2, 9) * Complex.rect(-9, 2) # =&gt; (0-85i)
Complex.rect(9, 8)  * 4                   # =&gt; (36+32i)
Complex.rect(20, 9) * 9.8                 # =&gt; (196.0+88.2i)
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-2A-2A"> <a href="#method-i-2A-2A" title="Link to this method"> <span class="method-callseq"> complex ** numeric → new_complex </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="2A-2A-source"> <pre class="c" data-language="c">VALUE
rb_complex_pow(VALUE self, VALUE other)
{
    if (k_numeric_p(other) &amp;&amp; k_exact_zero_p(other))
        return f_complex_new_bang1(CLASS_OF(self), ONE);

    if (RB_TYPE_P(other, T_RATIONAL) &amp;&amp; RRATIONAL(other)-&gt;den == LONG2FIX(1))
        other = RRATIONAL(other)-&gt;num; /* c14n */

    if (RB_TYPE_P(other, T_COMPLEX)) {
        get_dat1(other);

        if (k_exact_zero_p(dat-&gt;imag))
            other = dat-&gt;real; /* c14n */
    }

    if (other == ONE) {
        get_dat1(self);
        return nucomp_s_new_internal(CLASS_OF(self), dat-&gt;real, dat-&gt;imag);
    }

    VALUE result = complex_pow_for_special_angle(self, other);
    if (!UNDEF_P(result)) return result;

    if (RB_TYPE_P(other, T_COMPLEX)) {
        VALUE r, theta, nr, ntheta;

        get_dat1(other);

        r = f_abs(self);
        theta = f_arg(self);

        nr = m_exp_bang(f_sub(f_mul(dat-&gt;real, m_log_bang(r)),
                              f_mul(dat-&gt;imag, theta)));
        ntheta = f_add(f_mul(theta, dat-&gt;real),
                       f_mul(dat-&gt;imag, m_log_bang(r)));
        return f_complex_polar(CLASS_OF(self), nr, ntheta);
    }
    if (FIXNUM_P(other)) {
        long n = FIX2LONG(other);
        if (n == 0) {
            return nucomp_s_new_internal(CLASS_OF(self), ONE, ZERO);
        }
        if (n &lt; 0) {
            self = f_reciprocal(self);
            other = rb_int_uminus(other);
            n = -n;
        }
        {
            get_dat1(self);
            VALUE xr = dat-&gt;real, xi = dat-&gt;imag, zr = xr, zi = xi;

            if (f_zero_p(xi)) {
                zr = rb_num_pow(zr, other);
            }
            else if (f_zero_p(xr)) {
                zi = rb_num_pow(zi, other);
                if (n &amp; 2) zi = f_negate(zi);
                if (!(n &amp; 1)) {
                    VALUE tmp = zr;
                    zr = zi;
                    zi = tmp;
                }
            }
            else {
                while (--n) {
                    long q, r;

                    for (; q = n / 2, r = n % 2, r == 0; n = q) {
                        VALUE tmp = f_sub(f_mul(xr, xr), f_mul(xi, xi));
                        xi = f_mul(f_mul(TWO, xr), xi);
                        xr = tmp;
                    }
                    comp_mul(zr, zi, xr, xi, &amp;zr, &amp;zi);
                }
            }
            return nucomp_s_new_internal(CLASS_OF(self), zr, zi);
        }
    }
    if (k_numeric_p(other) &amp;&amp; f_real_p(other)) {
        VALUE r, theta;

        if (RB_BIGNUM_TYPE_P(other))
            rb_warn("in a**b, b may be too big");

        r = f_abs(self);
        theta = f_arg(self);

        return f_complex_polar(CLASS_OF(self), f_expt(r, other),
                               f_mul(theta, other));
    }
    return rb_num_coerce_bin(self, other, id_expt);
}</pre> </div>  <p>Returns <code>self</code> raised to power <code>numeric</code>:</p> <pre class="ruby" data-language="ruby">Complex.rect(0, 1) ** 2            # =&gt; (-1+0i)
Complex.rect(-8) ** Rational(1, 3) # =&gt; (1.0000000000000002+1.7320508075688772i)
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-2B"> <a href="#method-i-2B" title="Link to this method"> <span class="method-callseq"> complex + numeric → new_complex </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="2B-source"> <pre class="c" data-language="c">VALUE
rb_complex_plus(VALUE self, VALUE other)
{
    if (RB_TYPE_P(other, T_COMPLEX)) {
        VALUE real, imag;

        get_dat2(self, other);

        real = f_add(adat-&gt;real, bdat-&gt;real);
        imag = f_add(adat-&gt;imag, bdat-&gt;imag);

        return f_complex_new2(CLASS_OF(self), real, imag);
    }
    if (k_numeric_p(other) &amp;&amp; f_real_p(other)) {
        get_dat1(self);

        return f_complex_new2(CLASS_OF(self),
                              f_add(dat-&gt;real, other), dat-&gt;imag);
    }
    return rb_num_coerce_bin(self, other, '+');
}</pre> </div>  <p>Returns the sum of <code>self</code> and <code>numeric</code>:</p> <pre class="ruby" data-language="ruby">Complex.rect(2, 3)  + Complex.rect(2, 3)  # =&gt; (4+6i)
Complex.rect(900)   + Complex.rect(1)     # =&gt; (901+0i)
Complex.rect(-2, 9) + Complex.rect(-9, 2) # =&gt; (-11+11i)
Complex.rect(9, 8)  + 4                   # =&gt; (13+8i)
Complex.rect(20, 9) + 9.8                 # =&gt; (29.8+9i)
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-2D"> <a href="#method-i-2D" title="Link to this method"> <span class="method-callseq"> complex - numeric → new_complex </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="2D-source"> <pre class="c" data-language="c">VALUE
rb_complex_minus(VALUE self, VALUE other)
{
    if (RB_TYPE_P(other, T_COMPLEX)) {
        VALUE real, imag;

        get_dat2(self, other);

        real = f_sub(adat-&gt;real, bdat-&gt;real);
        imag = f_sub(adat-&gt;imag, bdat-&gt;imag);

        return f_complex_new2(CLASS_OF(self), real, imag);
    }
    if (k_numeric_p(other) &amp;&amp; f_real_p(other)) {
        get_dat1(self);

        return f_complex_new2(CLASS_OF(self),
                              f_sub(dat-&gt;real, other), dat-&gt;imag);
    }
    return rb_num_coerce_bin(self, other, '-');
}</pre> </div>  <p>Returns the difference of <code>self</code> and <code>numeric</code>:</p> <pre class="ruby" data-language="ruby">Complex.rect(2, 3)  - Complex.rect(2, 3)  # =&gt; (0+0i)
Complex.rect(900)   - Complex.rect(1)     # =&gt; (899+0i)
Complex.rect(-2, 9) - Complex.rect(-9, 2) # =&gt; (7+7i)
Complex.rect(9, 8)  - 4                   # =&gt; (5+8i)
Complex.rect(20, 9) - 9.8                 # =&gt; (10.2+9i)
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-2D-40"> <a href="#method-i-2D-40" title="Link to this method"> <span class="method-callseq"> -complex → new_complex </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="2D-40-source"> <pre class="c" data-language="c">VALUE
rb_complex_uminus(VALUE self)
{
    get_dat1(self);
    return f_complex_new2(CLASS_OF(self),
                          f_negate(dat-&gt;real), f_negate(dat-&gt;imag));
}</pre> </div>  <p>Returns the negation of <code>self</code>, which is the negation of each of its parts:</p> <pre class="ruby" data-language="ruby">-Complex.rect(1, 2)   # =&gt; (-1-2i)
-Complex.rect(-1, -2) # =&gt; (1+2i)
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-2F"> <a href="#method-i-2F" title="Link to this method"> <span class="method-callseq"> complex / numeric → new_complex </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="2F-source"> <pre class="c" data-language="c">VALUE
rb_complex_div(VALUE self, VALUE other)
{
    return f_divide(self, other, f_quo, id_quo);
}</pre> </div>  <p>Returns the quotient of <code>self</code> and <code>numeric</code>:</p> <pre class="ruby" data-language="ruby">Complex.rect(2, 3)  / Complex.rect(2, 3)  # =&gt; (1+0i)
Complex.rect(900)   / Complex.rect(1)     # =&gt; (900+0i)
Complex.rect(-2, 9) / Complex.rect(-9, 2) # =&gt; ((36/85)-(77/85)*i)
Complex.rect(9, 8)  / 4                   # =&gt; ((9/4)+2i)
Complex.rect(20, 9) / 9.8                 # =&gt; (2.0408163265306123+0.9183673469387754i)
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-3C-3D-3E"> <a href="#method-i-3C-3D-3E" title="Link to this method"> <span class="method-callseq"> complex &lt;=&gt; object → -1, 0, 1, or nil </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="3C-3D-3E-source"> <pre class="c" data-language="c">static VALUE
nucomp_cmp(VALUE self, VALUE other)
{
    if (!k_numeric_p(other)) {
        return rb_num_coerce_cmp(self, other, idCmp);
    }
    if (!nucomp_real_p(self)) {
        return Qnil;
    }
    if (RB_TYPE_P(other, T_COMPLEX)) {
        if (nucomp_real_p(other)) {
            get_dat2(self, other);
            return rb_funcall(adat-&gt;real, idCmp, 1, bdat-&gt;real);
        }
    }
    else {
        get_dat1(self);
        if (f_real_p(other)) {
            return rb_funcall(dat-&gt;real, idCmp, 1, other);
        }
        else {
            return rb_num_coerce_cmp(dat-&gt;real, other, idCmp);
        }
    }
    return Qnil;
}</pre> </div>  <p>Returns:</p> <ul>
<li> <p><code>self.real &lt;=&gt; object.real</code> if both of the following are true:</p> <ul>
<li> <p><code>self.imag == 0</code>.</p> </li>
<li> <p><code>object.imag == 0</code>. # Always true if object is numeric but not complex.</p> </li>
</ul> </li>
<li> <p><code>nil</code> otherwise.</p> </li>
</ul> <p>Examples:</p> <pre class="ruby" data-language="ruby">Complex.rect(2) &lt;=&gt; 3                  # =&gt; -1
Complex.rect(2) &lt;=&gt; 2                  # =&gt; 0
Complex.rect(2) &lt;=&gt; 1                  # =&gt; 1
Complex.rect(2, 1) &lt;=&gt; 1               # =&gt; nil # self.imag not zero.
Complex.rect(1) &lt;=&gt; Complex.rect(1, 1) # =&gt; nil # object.imag not zero.
Complex.rect(1) &lt;=&gt; 'Foo'              # =&gt; nil # object.imag not defined.
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-3D-3D"> <a href="#method-i-3D-3D" title="Link to this method"> <span class="method-callseq"> complex == object → true or false </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="3D-3D-source"> <pre class="c" data-language="c">static VALUE
nucomp_eqeq_p(VALUE self, VALUE other)
{
    if (RB_TYPE_P(other, T_COMPLEX)) {
        get_dat2(self, other);

        return RBOOL(f_eqeq_p(adat-&gt;real, bdat-&gt;real) &amp;&amp;
                          f_eqeq_p(adat-&gt;imag, bdat-&gt;imag));
    }
    if (k_numeric_p(other) &amp;&amp; f_real_p(other)) {
        get_dat1(self);

        return RBOOL(f_eqeq_p(dat-&gt;real, other) &amp;&amp; f_zero_p(dat-&gt;imag));
    }
    return RBOOL(f_eqeq_p(other, self));
}</pre> </div>  <p>Returns <code>true</code> if <code>self.real == object.real</code> and <code>self.imag == object.imag</code>:</p> <pre class="ruby" data-language="ruby">Complex.rect(2, 3)  == Complex.rect(2.0, 3.0) # =&gt; true
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-abs"> <a href="#method-i-abs" title="Link to this method"> <span class="method-callseq"> abs → float </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="abs-source"> <pre class="c" data-language="c">VALUE
rb_complex_abs(VALUE self)
{
    get_dat1(self);

    if (f_zero_p(dat-&gt;real)) {
        VALUE a = f_abs(dat-&gt;imag);
        if (RB_FLOAT_TYPE_P(dat-&gt;real) &amp;&amp; !RB_FLOAT_TYPE_P(dat-&gt;imag))
            a = f_to_f(a);
        return a;
    }
    if (f_zero_p(dat-&gt;imag)) {
        VALUE a = f_abs(dat-&gt;real);
        if (!RB_FLOAT_TYPE_P(dat-&gt;real) &amp;&amp; RB_FLOAT_TYPE_P(dat-&gt;imag))
            a = f_to_f(a);
        return a;
    }
    return rb_math_hypot(dat-&gt;real, dat-&gt;imag);
}</pre> </div>  <p>Returns the absolute value (magnitude) for <code>self</code>; see <a href="complex.html#class-Complex-label-Polar+Coordinates">polar coordinates</a>:</p> <pre class="ruby" data-language="ruby">Complex.polar(-1, 0).abs # =&gt; 1.0
</pre> <p>If <code>self</code> was created with <a href="complex.html#class-Complex-label-Rectangular+Coordinates">rectangular coordinates</a>, the returned value is computed, and may be inexact:</p> <pre class="ruby" data-language="ruby">Complex.rectangular(1, 1).abs # =&gt; 1.4142135623730951 # The square root of 2.
</pre> </div> <div class="aliases"> Also aliased as: <a href="complex.html#method-i-magnitude">magnitude</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-abs2"> <a href="#method-i-abs2" title="Link to this method"> <span class="method-callseq"> abs2 → float </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="abs2-source"> <pre class="c" data-language="c">static VALUE
nucomp_abs2(VALUE self)
{
    get_dat1(self);
    return f_add(f_mul(dat-&gt;real, dat-&gt;real),
                 f_mul(dat-&gt;imag, dat-&gt;imag));
}</pre> </div>  <p>Returns square of the absolute value (magnitude) for <code>self</code>; see <a href="complex.html#class-Complex-label-Polar+Coordinates">polar coordinates</a>:</p> <pre class="ruby" data-language="ruby">Complex.polar(2, 2).abs2 # =&gt; 4.0
</pre> <p>If <code>self</code> was created with <a href="complex.html#class-Complex-label-Rectangular+Coordinates">rectangular coordinates</a>, the returned value is computed, and may be inexact:</p> <pre class="ruby" data-language="ruby">Complex.rectangular(1.0/3, 1.0/3).abs2 # =&gt; 0.2222222222222222
</pre> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-angle"> <a href="#method-i-angle" title="Link to this method"> <span class="method-name">angle</span> </a> </div> </div> <div class="aliases"> Alias for: <a href="complex.html#method-i-arg">arg</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-arg"> <a href="#method-i-arg" title="Link to this method"> <span class="method-callseq"> arg → float </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="arg-source"> <pre class="c" data-language="c">VALUE
rb_complex_arg(VALUE self)
{
    get_dat1(self);
    return rb_math_atan2(dat-&gt;imag, dat-&gt;real);
}</pre> </div>  <p>Returns the argument (angle) for <code>self</code> in radians; see <a href="complex.html#class-Complex-label-Polar+Coordinates">polar coordinates</a>:</p> <pre class="ruby" data-language="ruby">Complex.polar(3, Math::PI/2).arg  # =&gt; 1.57079632679489660
</pre> <p>If <code>self</code> was created with <a href="complex.html#class-Complex-label-Rectangular+Coordinates">rectangular coordinates</a>, the returned value is computed, and may be inexact:</p> <pre class="ruby" data-language="ruby">Complex.polar(1, 1.0/3).arg # =&gt; 0.33333333333333326
</pre> </div> <div class="aliases"> Also aliased as: <a href="complex.html#method-i-angle">angle</a>, <a href="complex.html#method-i-phase">phase</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-as_json"> <a href="#method-i-as_json" title="Link to this method"> <span class="method-name">as_json</span> <span class="method-args">(*)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="as_json-source"> <pre class="ruby" data-language="ruby"># File ext/json/lib/json/add/complex.rb, line 29
def as_json(*)
  {
    JSON.create_id =&gt; self.class.name,
    'r'            =&gt; real,
    'i'            =&gt; imag,
  }
end</pre> </div>  <p>Methods <a href="complex.html#method-i-as_json"><code>Complex#as_json</code></a> and <a href="complex.html#method-c-json_create"><code>Complex.json_create</code></a> may be used to serialize and deserialize a Complex object; see <a href="marshal.html"><code>Marshal</code></a>.</p> <p>Method <a href="complex.html#method-i-as_json"><code>Complex#as_json</code></a> serializes <code>self</code>, returning a 2-element hash representing <code>self</code>:</p> <pre class="ruby" data-language="ruby">require 'json/add/complex'
x = Complex(2).as_json      # =&gt; {"json_class"=&gt;"Complex", "r"=&gt;2, "i"=&gt;0}
y = Complex(2.0, 4).as_json # =&gt; {"json_class"=&gt;"Complex", "r"=&gt;2.0, "i"=&gt;4}
</pre> <p>Method <code>JSON.create</code> deserializes such a hash, returning a Complex object:</p> <pre class="ruby" data-language="ruby">Complex.json_create(x) # =&gt; (2+0i)
Complex.json_create(y) # =&gt; (2.0+4i)
</pre> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-conj"> <a href="#method-i-conj" title="Link to this method"> <span class="method-callseq"> conj → complex </span> </a> </div> </div> <div class="method-description"> <p>Returns the conjugate of <code>self</code>, <a href="complex.html#method-c-rect"><code>Complex.rect(self.imag, self.real)</code></a>:</p> <pre class="ruby" data-language="ruby">Complex.rect(1, 2).conj # =&gt; (1-2i)
</pre> </div> <div class="aliases"> Alias for: <a href="complex.html#method-i-conjugate">conjugate</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-conjugate"> <a href="#method-i-conjugate" title="Link to this method"> <span class="method-name">conjugate</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="aliases"> Also aliased as: <a href="complex.html#method-i-conj">conj</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-denominator"> <a href="#method-i-denominator" title="Link to this method"> <span class="method-callseq"> denominator → integer </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="denominator-source"> <pre class="c" data-language="c">static VALUE
nucomp_denominator(VALUE self)
{
    get_dat1(self);
    return rb_lcm(f_denominator(dat-&gt;real), f_denominator(dat-&gt;imag));
}</pre> </div>  <p>Returns the denominator of <code>self</code>, which is the <a href="https://en.wikipedia.org/wiki/Least_common_multiple">least common multiple</a> of <code>self.real.denominator</code> and <code>self.imag.denominator</code>:</p> <pre class="ruby" data-language="ruby">Complex.rect(Rational(1, 2), Rational(2, 3)).denominator # =&gt; 6
</pre> <p>Note that <code>n.denominator</code> of a non-rational numeric is <code>1</code>.</p> <p>Related: <a href="complex.html#method-i-numerator"><code>Complex#numerator</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-fdiv"> <a href="#method-i-fdiv" title="Link to this method"> <span class="method-callseq"> fdiv(numeric) → new_complex </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="fdiv-source"> <pre class="c" data-language="c">static VALUE
nucomp_fdiv(VALUE self, VALUE other)
{
    return f_divide(self, other, f_fdiv, id_fdiv);
}</pre> </div>  <p>Returns <a href="complex.html#method-c-rect"><code>Complex.rect(self.real/numeric, self.imag/numeric)</code></a>:</p> <pre class="ruby" data-language="ruby">Complex.rect(11, 22).fdiv(3) # =&gt; (3.6666666666666665+7.333333333333333i)
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-finite-3F"> <a href="#method-i-finite-3F" title="Link to this method"> <span class="method-callseq"> finite? → true or false </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="finite-3F-source"> <pre class="c" data-language="c">static VALUE
rb_complex_finite_p(VALUE self)
{
    get_dat1(self);

    return RBOOL(f_finite_p(dat-&gt;real) &amp;&amp; f_finite_p(dat-&gt;imag));
}</pre> </div>  <p>Returns <code>true</code> if both <code>self.real.finite?</code> and <code>self.imag.finite?</code> are true, <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">Complex.rect(1, 1).finite?               # =&gt; true
Complex.rect(Float::INFINITY, 0).finite? # =&gt; false
</pre> <p>Related: <a href="numeric.html#method-i-finite-3F"><code>Numeric#finite?</code></a>, <a href="float.html#method-i-finite-3F"><code>Float#finite?</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-hash"> <a href="#method-i-hash" title="Link to this method"> <span class="method-callseq"> hash → integer </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="hash-source"> <pre class="c" data-language="c">static VALUE
nucomp_hash(VALUE self)
{
    return ST2FIX(rb_complex_hash(self));
}</pre> </div>  <p>Returns the integer hash value for <code>self</code>.</p> <p>Two Complex objects created from the same values will have the same hash value (and will compare using <a href="numeric.html#method-i-eql-3F"><code>eql?</code></a>):</p> <pre class="ruby" data-language="ruby">Complex.rect(1, 2).hash == Complex.rect(1, 2).hash # =&gt; true
</pre> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-imag"> <a href="#method-i-imag" title="Link to this method"> <span class="method-callseq"> imag → numeric </span> </a> </div> </div> <div class="method-description"> <p>Returns the imaginary value for <code>self</code>:</p> <pre class="ruby" data-language="ruby">Complex.rect(7).imag     # =&gt; 0
Complex.rect(9, -4).imag # =&gt; -4
</pre> <p>If <code>self</code> was created with <a href="complex.html#class-Complex-label-Polar+Coordinates">polar coordinates</a>, the returned value is computed, and may be inexact:</p> <pre class="ruby" data-language="ruby">Complex.polar(1, Math::PI/4).imag # =&gt; 0.7071067811865476 # Square root of 2.
</pre> </div> <div class="aliases"> Alias for: <a href="complex.html#method-i-imaginary">imaginary</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-imaginary"> <a href="#method-i-imaginary" title="Link to this method"> <span class="method-name">imaginary</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="aliases"> Also aliased as: <a href="complex.html#method-i-imag">imag</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-infinite-3F"> <a href="#method-i-infinite-3F" title="Link to this method"> <span class="method-callseq"> infinite? → 1 or nil </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="infinite-3F-source"> <pre class="c" data-language="c">static VALUE
rb_complex_infinite_p(VALUE self)
{
    get_dat1(self);

    if (!f_infinite_p(dat-&gt;real) &amp;&amp; !f_infinite_p(dat-&gt;imag)) {
        return Qnil;
    }
    return ONE;
}</pre> </div>  <p>Returns <code>1</code> if either <code>self.real.infinite?</code> or <code>self.imag.infinite?</code> is true, <code>nil</code> otherwise:</p> <pre class="ruby" data-language="ruby">Complex.rect(Float::INFINITY, 0).infinite? # =&gt; 1
Complex.rect(1, 1).infinite?               # =&gt; nil
</pre> <p>Related: <a href="numeric.html#method-i-infinite-3F"><code>Numeric#infinite?</code></a>, <a href="float.html#method-i-infinite-3F"><code>Float#infinite?</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-inspect"> <a href="#method-i-inspect" title="Link to this method"> <span class="method-callseq"> inspect → string </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="inspect-source"> <pre class="c" data-language="c">static VALUE
nucomp_inspect(VALUE self)
{
    VALUE s;

    s = rb_usascii_str_new2("(");
    f_format(self, s, rb_inspect);
    rb_str_cat2(s, ")");

    return s;
}</pre> </div>  <p>Returns a string representation of <code>self</code>:</p> <pre class="ruby" data-language="ruby">Complex.rect(2).inspect                      # =&gt; "(2+0i)"
Complex.rect(-8, 6).inspect                  # =&gt; "(-8+6i)"
Complex.rect(0, Rational(1, 2)).inspect      # =&gt; "(0+(1/2)*i)"
Complex.rect(0, Float::INFINITY).inspect     # =&gt; "(0+Infinity*i)"
Complex.rect(Float::NAN, Float::NAN).inspect # =&gt; "(NaN+NaN*i)"
</pre> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-magnitude"> <a href="#method-i-magnitude" title="Link to this method"> <span class="method-name">magnitude</span> </a> </div> </div> <div class="aliases"> Alias for: <a href="complex.html#method-i-abs">abs</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-numerator"> <a href="#method-i-numerator" title="Link to this method"> <span class="method-callseq"> numerator → new_complex </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="numerator-source"> <pre class="c" data-language="c">static VALUE
nucomp_numerator(VALUE self)
{
    VALUE cd;

    get_dat1(self);

    cd = nucomp_denominator(self);
    return f_complex_new2(CLASS_OF(self),
                          f_mul(f_numerator(dat-&gt;real),
                                f_div(cd, f_denominator(dat-&gt;real))),
                          f_mul(f_numerator(dat-&gt;imag),
                                f_div(cd, f_denominator(dat-&gt;imag))));
}</pre> </div>  <p>Returns the Complex object created from the numerators of the real and imaginary parts of <code>self</code>, after converting each part to the <a href="https://en.wikipedia.org/wiki/Lowest_common_denominator">lowest common denominator</a> of the two:</p> <pre class="ruby" data-language="ruby">c = Complex.rect(Rational(2, 3), Rational(3, 4)) # =&gt; ((2/3)+(3/4)*i)
c.numerator                                      # =&gt; (8+9i)
</pre> <p>In this example, the lowest common denominator of the two parts is 12; the two converted parts may be thought of as Rational(8, 12) and Rational(9, 12), whose numerators, respectively, are 8 and 9; so the returned value of <code>c.numerator</code> is <a href="complex.html#method-c-rect"><code>Complex.rect(8, 9)</code></a>.</p> <p>Related: <a href="complex.html#method-i-denominator"><code>Complex#denominator</code></a>.</p> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-phase"> <a href="#method-i-phase" title="Link to this method"> <span class="method-name">phase</span> </a> </div> </div> <div class="aliases"> Alias for: <a href="complex.html#method-i-arg">arg</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-polar"> <a href="#method-i-polar" title="Link to this method"> <span class="method-callseq"> polar → array </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="polar-source"> <pre class="c" data-language="c">static VALUE
nucomp_polar(VALUE self)
{
    return rb_assoc_new(f_abs(self), f_arg(self));
}</pre> </div>  <p>Returns the array <code>[self.abs, self.arg]</code>:</p> <pre class="ruby" data-language="ruby">Complex.polar(1, 2).polar # =&gt; [1.0, 2.0]
</pre> <p>See <a href="complex.html#class-Complex-label-Polar+Coordinates">Polar Coordinates</a>.</p> <p>If <code>self</code> was created with <a href="complex.html#class-Complex-label-Rectangular+Coordinates">rectangular coordinates</a>, the returned value is computed, and may be inexact:</p> <pre class="ruby" data-language="ruby">Complex.rect(1, 1).polar # =&gt; [1.4142135623730951, 0.7853981633974483]
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-quo"> <a href="#method-i-quo" title="Link to this method"> <span class="method-callseq"> complex / numeric → new_complex </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="quo-source"> <pre class="c" data-language="c">VALUE
rb_complex_div(VALUE self, VALUE other)
{
    return f_divide(self, other, f_quo, id_quo);
}</pre> </div>  <p>Returns the quotient of <code>self</code> and <code>numeric</code>:</p> <pre class="ruby" data-language="ruby">Complex.rect(2, 3)  / Complex.rect(2, 3)  # =&gt; (1+0i)
Complex.rect(900)   / Complex.rect(1)     # =&gt; (900+0i)
Complex.rect(-2, 9) / Complex.rect(-9, 2) # =&gt; ((36/85)-(77/85)*i)
Complex.rect(9, 8)  / 4                   # =&gt; ((9/4)+2i)
Complex.rect(20, 9) / 9.8                 # =&gt; (2.0408163265306123+0.9183673469387754i)
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-rationalize"> <a href="#method-i-rationalize" title="Link to this method"> <span class="method-callseq"> rationalize(epsilon = nil) → rational </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="rationalize-source"> <pre class="c" data-language="c">static VALUE
nucomp_rationalize(int argc, VALUE *argv, VALUE self)
{
    get_dat1(self);

    rb_check_arity(argc, 0, 1);

    if (!k_exact_zero_p(dat-&gt;imag)) {
       rb_raise(rb_eRangeError, "can't convert %"PRIsVALUE" into Rational",
                self);
    }
    return rb_funcallv(dat-&gt;real, id_rationalize, argc, argv);
}</pre> </div>  <p>Returns a <a href="rational.html"><code>Rational</code></a> object whose value is exactly or approximately equivalent to that of <code>self.real</code>.</p> <p>With no argument <code>epsilon</code> given, returns a Rational object whose value is exactly equal to that of <code>self.real.rationalize</code>:</p> <pre class="ruby" data-language="ruby">Complex.rect(1, 0).rationalize              # =&gt; (1/1)
Complex.rect(1, Rational(0, 1)).rationalize # =&gt; (1/1)
Complex.rect(3.14159, 0).rationalize        # =&gt; (314159/100000)
</pre> <p>With argument <code>epsilon</code> given, returns a Rational object whose value is exactly or approximately equal to that of <code>self.real</code> to the given precision:</p> <pre class="ruby" data-language="ruby">Complex.rect(3.14159, 0).rationalize(0.1)          # =&gt; (16/5)
Complex.rect(3.14159, 0).rationalize(0.01)         # =&gt; (22/7)
Complex.rect(3.14159, 0).rationalize(0.001)        # =&gt; (201/64)
Complex.rect(3.14159, 0).rationalize(0.0001)       # =&gt; (333/106)
Complex.rect(3.14159, 0).rationalize(0.00001)      # =&gt; (355/113)
Complex.rect(3.14159, 0).rationalize(0.000001)     # =&gt; (7433/2366)
Complex.rect(3.14159, 0).rationalize(0.0000001)    # =&gt; (9208/2931)
Complex.rect(3.14159, 0).rationalize(0.00000001)   # =&gt; (47460/15107)
Complex.rect(3.14159, 0).rationalize(0.000000001)  # =&gt; (76149/24239)
Complex.rect(3.14159, 0).rationalize(0.0000000001) # =&gt; (314159/100000)
Complex.rect(3.14159, 0).rationalize(0.0)          # =&gt; (3537115888337719/1125899906842624)
</pre> <p>Related: <a href="complex.html#method-i-to_r"><code>Complex#to_r</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-real"> <a href="#method-i-real" title="Link to this method"> <span class="method-callseq"> real → numeric </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="real-source"> <pre class="c" data-language="c">VALUE
rb_complex_real(VALUE self)
{
    get_dat1(self);
    return dat-&gt;real;
}</pre> </div>  <p>Returns the real value for <code>self</code>:</p> <pre class="ruby" data-language="ruby">Complex.rect(7).real     # =&gt; 7
Complex.rect(9, -4).real # =&gt; 9
</pre> <p>If <code>self</code> was created with <a href="complex.html#class-Complex-label-Polar+Coordinates">polar coordinates</a>, the returned value is computed, and may be inexact:</p> <pre class="ruby" data-language="ruby">Complex.polar(1, Math::PI/4).real # =&gt; 0.7071067811865476 # Square root of 2.
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-real-3F"> <a href="#method-i-real-3F" title="Link to this method"> <span class="method-callseq"> real? → false </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="real-3F-source"> <pre class="c" data-language="c">static VALUE
nucomp_real_p_m(VALUE self)
{
    return Qfalse;
}</pre> </div>  <p>Returns <code>false</code>; for compatibility with <a href="numeric.html#method-i-real-3F"><code>Numeric#real?</code></a>.</p> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-rect"> <a href="#method-i-rect" title="Link to this method"> <span class="method-callseq"> rect → array </span> </a> </div> </div> <div class="method-description"> <p>Returns a new Complex object formed from the arguments, each of which must be an instance of <a href="numeric.html"><code>Numeric</code></a>, or an instance of one of its subclasses: Complex, <a href="float.html"><code>Float</code></a>, <a href="integer.html"><code>Integer</code></a>, <a href="rational.html"><code>Rational</code></a>; see <a href="complex.html#class-Complex-label-Rectangular+Coordinates">Rectangular Coordinates</a>:</p> <pre class="ruby" data-language="ruby">Complex.rect(3)             # =&gt; (3+0i)
Complex.rect(3, Math::PI)   # =&gt; (3+3.141592653589793i)
Complex.rect(-3, -Math::PI) # =&gt; (-3-3.141592653589793i)
</pre> <p>Complex.rectangular is an alias for Complex.rect.</p> </div> <div class="aliases"> Alias for: <a href="complex.html#method-i-rectangular">rectangular</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-rectangular"> <a href="#method-i-rectangular" title="Link to this method"> <span class="method-name">rectangular</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="aliases"> Also aliased as: <a href="complex.html#method-i-rect">rect</a>, rect </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-to_c"> <a href="#method-i-to_c" title="Link to this method"> <span class="method-callseq"> to_c → self </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="to_c-source"> <pre class="c" data-language="c">static VALUE
nucomp_to_c(VALUE self)
{
    return self;
}</pre> </div>  <p>Returns <code>self</code>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-to_f"> <a href="#method-i-to_f" title="Link to this method"> <span class="method-callseq"> to_f → float </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="to_f-source"> <pre class="c" data-language="c">static VALUE
nucomp_to_f(VALUE self)
{
    get_dat1(self);

    if (!k_exact_zero_p(dat-&gt;imag)) {
        rb_raise(rb_eRangeError, "can't convert %"PRIsVALUE" into Float",
                 self);
    }
    return f_to_f(dat-&gt;real);
}</pre> </div>  <p>Returns the value of <code>self.real</code> as a <a href="float.html"><code>Float</code></a>, if possible:</p> <pre class="ruby" data-language="ruby">Complex.rect(1, 0).to_f              # =&gt; 1.0
Complex.rect(1, Rational(0, 1)).to_f # =&gt; 1.0
</pre> <p>Raises <a href="rangeerror.html"><code>RangeError</code></a> if <code>self.imag</code> is not exactly zero (either <code>Integer(0)</code> or <code>Rational(0, <em>n</em>)</code>).</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-to_i"> <a href="#method-i-to_i" title="Link to this method"> <span class="method-callseq"> to_i → integer </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="to_i-source"> <pre class="c" data-language="c">static VALUE
nucomp_to_i(VALUE self)
{
    get_dat1(self);

    if (!k_exact_zero_p(dat-&gt;imag)) {
        rb_raise(rb_eRangeError, "can't convert %"PRIsVALUE" into Integer",
                 self);
    }
    return f_to_i(dat-&gt;real);
}</pre> </div>  <p>Returns the value of <code>self.real</code> as an <a href="integer.html"><code>Integer</code></a>, if possible:</p> <pre class="ruby" data-language="ruby">Complex.rect(1, 0).to_i              # =&gt; 1
Complex.rect(1, Rational(0, 1)).to_i # =&gt; 1
</pre> <p>Raises <a href="rangeerror.html"><code>RangeError</code></a> if <code>self.imag</code> is not exactly zero (either <code>Integer(0)</code> or <code>Rational(0, <em>n</em>)</code>).</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-to_json"> <a href="#method-i-to_json" title="Link to this method"> <span class="method-name">to_json</span> <span class="method-args">(*args)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="to_json-source"> <pre class="ruby" data-language="ruby"># File ext/json/lib/json/add/complex.rb, line 48
def to_json(*args)
  as_json.to_json(*args)
end</pre> </div>  <p>Returns a <a href="json.html"><code>JSON</code></a> string representing <code>self</code>:</p> <pre class="ruby" data-language="ruby">require 'json/add/complex'
puts Complex(2).to_json
puts Complex(2.0, 4).to_json
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">{"json_class":"Complex","r":2,"i":0}
{"json_class":"Complex","r":2.0,"i":4}
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-to_r"> <a href="#method-i-to_r" title="Link to this method"> <span class="method-callseq"> to_r → rational </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="to_r-source"> <pre class="c" data-language="c">static VALUE
nucomp_to_r(VALUE self)
{
    get_dat1(self);

    if (RB_FLOAT_TYPE_P(dat-&gt;imag) &amp;&amp; FLOAT_ZERO_P(dat-&gt;imag)) {
        /* Do nothing here */
    }
    else if (!k_exact_zero_p(dat-&gt;imag)) {
        VALUE imag = rb_check_convert_type_with_id(dat-&gt;imag, T_RATIONAL, "Rational", idTo_r);
        if (NIL_P(imag) || !k_exact_zero_p(imag)) {
            rb_raise(rb_eRangeError, "can't convert %"PRIsVALUE" into Rational",
                     self);
        }
    }
    return f_to_r(dat-&gt;real);
}</pre> </div>  <p>Returns the value of <code>self.real</code> as a <a href="rational.html"><code>Rational</code></a>, if possible:</p> <pre class="ruby" data-language="ruby">Complex.rect(1, 0).to_r              # =&gt; (1/1)
Complex.rect(1, Rational(0, 1)).to_r # =&gt; (1/1)
Complex.rect(1, 0.0).to_r            # =&gt; (1/1)
</pre> <p>Raises <a href="rangeerror.html"><code>RangeError</code></a> if <code>self.imag</code> is not exactly zero (either <code>Integer(0)</code> or <code>Rational(0, <em>n</em>)</code>) and <code>self.imag.to_r</code> is not exactly zero.</p> <p>Related: <a href="complex.html#method-i-rationalize"><code>Complex#rationalize</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-to_s"> <a href="#method-i-to_s" title="Link to this method"> <span class="method-callseq"> to_s → string </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="to_s-source"> <pre class="c" data-language="c">static VALUE
nucomp_to_s(VALUE self)
{
    return f_format(self, rb_usascii_str_new2(""), rb_String);
}</pre> </div>  <p>Returns a string representation of <code>self</code>:</p> <pre class="ruby" data-language="ruby">Complex.rect(2).to_s                      # =&gt; "2+0i"
Complex.rect(-8, 6).to_s                  # =&gt; "-8+6i"
Complex.rect(0, Rational(1, 2)).to_s      # =&gt; "0+1/2i"
Complex.rect(0, Float::INFINITY).to_s     # =&gt; "0+Infinity*i"
Complex.rect(Float::NAN, Float::NAN).to_s # =&gt; "NaN+NaN*i"
</pre> </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core &copy; 1993&ndash;2024 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library &copy; contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>
