<h1 id="module-JSON" class="module"> module JSON </h1> <section class="description"> <h1 id="module-JSON-label-JavaScript+Object+Notation+-28JSON-29">JavaScript Object Notation (JSON)</h1> <p>JSON is a lightweight data-interchange format.</p> <p>A JSON value is one of the following:</p> <ul>
<li> <p>Double-quoted text: <code>"foo"</code>.</p> </li>
<li> <p>Number: <code>1</code>, <code>1.0</code>, <code>2.0e2</code>.</p> </li>
<li> <p>Boolean: <code>true</code>, <code>false</code>.</p> </li>
<li> <p>Null: <code>null</code>.</p> </li>
<li> <p>Array: an ordered list of values, enclosed by square brackets:</p> <pre class="ruby" data-language="ruby">["foo", 1, 1.0, 2.0e2, true, false, null]
</pre> </li>
<li> <p>Object: a collection of name/value pairs, enclosed by curly braces; each name is double-quoted text; the values may be any JSON values:</p> <pre class="ruby" data-language="ruby">{"a": "foo", "b": 1, "c": 1.0, "d": 2.0e2, "e": true, "f": false, "g": null}
</pre> </li>
</ul> <p>A JSON array or object may contain nested arrays, objects, and scalars to any depth:</p> <pre class="ruby" data-language="ruby">{"foo": {"bar": 1, "baz": 2}, "bat": [0, 1, 2]}
[{"foo": 0, "bar": 1}, ["baz", 2]]
</pre> <h2 id="module-JSON-label-Using+Module+JSON">Using Module JSON</h2> <p>To make module JSON available in your code, begin with:</p> <pre class="ruby" data-language="ruby">require 'json'
</pre> <p>All examples here assume that this has been done.</p> <h3 id="module-JSON-label-Parsing+JSON">Parsing JSON</h3> <p>You can parse a String containing JSON data using either of two methods:</p> <ul>
<li> <p><code>JSON.parse(source, opts)</code></p> </li>
<li> <p><code>JSON.parse!(source, opts)</code></p> </li>
</ul> <p>where</p> <ul>
<li> <p><code>source</code> is a Ruby object.</p> </li>
<li> <p><code>opts</code> is a Hash object containing options that control both input allowed and output formatting.</p> </li>
</ul> <p>The difference between the two methods is that <a href="json.html#method-i-parse-21"><code>JSON.parse!</code></a> omits some checks and may not be safe for some <code>source</code> data; use it only for data from trusted sources. Use the safer method <a href="json.html#method-i-parse"><code>JSON.parse</code></a> for less trusted sources.</p> <h4 id="module-JSON-label-Parsing+JSON+Arrays">Parsing JSON Arrays</h4> <p>When <code>source</code> is a JSON array, <a href="json.html#method-i-parse"><code>JSON.parse</code></a> by default returns a Ruby Array:</p> <pre class="ruby" data-language="ruby">json = '["foo", 1, 1.0, 2.0e2, true, false, null]'
ruby = JSON.parse(json)
ruby # =&gt; ["foo", 1, 1.0, 200.0, true, false, nil]
ruby.class # =&gt; Array
</pre> <p>The JSON array may contain nested arrays, objects, and scalars to any depth:</p> <pre class="ruby" data-language="ruby">json = '[{"foo": 0, "bar": 1}, ["baz", 2]]'
JSON.parse(json) # =&gt; [{"foo"=&gt;0, "bar"=&gt;1}, ["baz", 2]]
</pre> <h4 id="module-JSON-label-Parsing+JSON+Objects">Parsing JSON Objects</h4> <p>When the source is a JSON object, <a href="json.html#method-i-parse"><code>JSON.parse</code></a> by default returns a Ruby Hash:</p> <pre class="ruby" data-language="ruby">json = '{"a": "foo", "b": 1, "c": 1.0, "d": 2.0e2, "e": true, "f": false, "g": null}'
ruby = JSON.parse(json)
ruby # =&gt; {"a"=&gt;"foo", "b"=&gt;1, "c"=&gt;1.0, "d"=&gt;200.0, "e"=&gt;true, "f"=&gt;false, "g"=&gt;nil}
ruby.class # =&gt; Hash
</pre> <p>The JSON object may contain nested arrays, objects, and scalars to any depth:</p> <pre class="ruby" data-language="ruby">json = '{"foo": {"bar": 1, "baz": 2}, "bat": [0, 1, 2]}'
JSON.parse(json) # =&gt; {"foo"=&gt;{"bar"=&gt;1, "baz"=&gt;2}, "bat"=&gt;[0, 1, 2]}
</pre> <h4 id="module-JSON-label-Parsing+JSON+Scalars">Parsing JSON Scalars</h4> <p>When the source is a JSON scalar (not an array or object), <a href="json.html#method-i-parse"><code>JSON.parse</code></a> returns a Ruby scalar.</p> <p>String:</p> <pre class="ruby" data-language="ruby">ruby = JSON.parse('"foo"')
ruby # =&gt; 'foo'
ruby.class # =&gt; String
</pre> <p>Integer:</p> <pre class="ruby" data-language="ruby">ruby = JSON.parse('1')
ruby # =&gt; 1
ruby.class # =&gt; Integer
</pre> <p>Float:</p> <pre class="ruby" data-language="ruby">ruby = JSON.parse('1.0')
ruby # =&gt; 1.0
ruby.class # =&gt; Float
ruby = JSON.parse('2.0e2')
ruby # =&gt; 200
ruby.class # =&gt; Float
</pre> <p>Boolean:</p> <pre class="ruby" data-language="ruby">ruby = JSON.parse('true')
ruby # =&gt; true
ruby.class # =&gt; TrueClass
ruby = JSON.parse('false')
ruby # =&gt; false
ruby.class # =&gt; FalseClass
</pre> <p>Null:</p> <pre class="ruby" data-language="ruby">ruby = JSON.parse('null')
ruby # =&gt; nil
ruby.class # =&gt; NilClass
</pre> <h4 id="module-JSON-label-Parsing+Options">Parsing Options</h4> <h6 id="module-JSON-label-Input+Options">Input Options</h6> <p>Option <code>max_nesting</code> (Integer) specifies the maximum nesting depth allowed; defaults to <code>100</code>; specify <code>false</code> to disable depth checking.</p> <p>With the default, <code>false</code>:</p> <pre class="ruby" data-language="ruby">source = '[0, [1, [2, [3]]]]'
ruby = JSON.parse(source)
ruby # =&gt; [0, [1, [2, [3]]]]
</pre> <p>Too deep:</p> <pre class="ruby" data-language="ruby"># Raises JSON::NestingError (nesting of 2 is too deep):
JSON.parse(source, {max_nesting: 1})
</pre> <p>Bad value:</p> <pre class="ruby" data-language="ruby"># Raises TypeError (wrong argument type Symbol (expected Fixnum)):
JSON.parse(source, {max_nesting: :foo})
</pre>  <p>Option <code>allow_nan</code> (boolean) specifies whether to allow <a href="json.html#NaN"><code>NaN</code></a>, <a href="json.html#Infinity"><code>Infinity</code></a>, and <a href="json.html#MinusInfinity"><code>MinusInfinity</code></a> in <code>source</code>; defaults to <code>false</code>.</p> <p>With the default, <code>false</code>:</p> <pre class="ruby" data-language="ruby"># Raises JSON::ParserError (225: unexpected token at '[NaN]'):
JSON.parse('[NaN]')
# Raises JSON::ParserError (232: unexpected token at '[Infinity]'):
JSON.parse('[Infinity]')
# Raises JSON::ParserError (248: unexpected token at '[-Infinity]'):
JSON.parse('[-Infinity]')
</pre> <p>Allow:</p> <pre class="ruby" data-language="ruby">source = '[NaN, Infinity, -Infinity]'
ruby = JSON.parse(source, {allow_nan: true})
ruby # =&gt; [NaN, Infinity, -Infinity]
</pre> <h6 id="module-JSON-label-Output+Options">Output Options</h6> <p>Option <code>symbolize_names</code> (boolean) specifies whether returned Hash keys should be Symbols; defaults to <code>false</code> (use Strings).</p> <p>With the default, <code>false</code>:</p> <pre class="ruby" data-language="ruby">source = '{"a": "foo", "b": 1.0, "c": true, "d": false, "e": null}'
ruby = JSON.parse(source)
ruby # =&gt; {"a"=&gt;"foo", "b"=&gt;1.0, "c"=&gt;true, "d"=&gt;false, "e"=&gt;nil}
</pre> <p>Use Symbols:</p> <pre class="ruby" data-language="ruby">ruby = JSON.parse(source, {symbolize_names: true})
ruby # =&gt; {:a=&gt;"foo", :b=&gt;1.0, :c=&gt;true, :d=&gt;false, :e=&gt;nil}
</pre>  <p>Option <code>object_class</code> (Class) specifies the Ruby class to be used for each JSON object; defaults to Hash.</p> <p>With the default, Hash:</p> <pre class="ruby" data-language="ruby">source = '{"a": "foo", "b": 1.0, "c": true, "d": false, "e": null}'
ruby = JSON.parse(source)
ruby.class # =&gt; Hash
</pre> <p>Use class OpenStruct:</p> <pre class="ruby" data-language="ruby">ruby = JSON.parse(source, {object_class: OpenStruct})
ruby # =&gt; #&lt;OpenStruct a="foo", b=1.0, c=true, d=false, e=nil&gt;
</pre>  <p>Option <code>array_class</code> (Class) specifies the Ruby class to be used for each JSON array; defaults to Array.</p> <p>With the default, Array:</p> <pre class="ruby" data-language="ruby">source = '["foo", 1.0, true, false, null]'
ruby = JSON.parse(source)
ruby.class # =&gt; Array
</pre> <p>Use class Set:</p> <pre class="ruby" data-language="ruby">ruby = JSON.parse(source, {array_class: Set})
ruby # =&gt; #&lt;Set: {"foo", 1.0, true, false, nil}&gt;
</pre>  <p>Option <code>create_additions</code> (boolean) specifies whether to use JSON additions in parsing. See <a href="#module-JSON-label-JSON+Additions">JSON Additions</a>.</p> <h3 id="module-JSON-label-Generating+JSON">Generating JSON</h3> <p>To generate a Ruby String containing JSON data, use method <code>JSON.generate(source, opts)</code>, where</p> <ul>
<li> <p><code>source</code> is a Ruby object.</p> </li>
<li> <p><code>opts</code> is a Hash object containing options that control both input allowed and output formatting.</p> </li>
</ul> <h4 id="module-JSON-label-Generating+JSON+from+Arrays">Generating JSON from Arrays</h4> <p>When the source is a Ruby Array, <a href="json.html#method-i-generate"><code>JSON.generate</code></a> returns a String containing a JSON array:</p> <pre class="ruby" data-language="ruby">ruby = [0, 's', :foo]
json = JSON.generate(ruby)
json # =&gt; '[0,"s","foo"]'
</pre> <p>The Ruby Array array may contain nested arrays, hashes, and scalars to any depth:</p> <pre class="ruby" data-language="ruby">ruby = [0, [1, 2], {foo: 3, bar: 4}]
json = JSON.generate(ruby)
json # =&gt; '[0,[1,2],{"foo":3,"bar":4}]'
</pre> <h4 id="module-JSON-label-Generating+JSON+from+Hashes">Generating JSON from Hashes</h4> <p>When the source is a Ruby Hash, <a href="json.html#method-i-generate"><code>JSON.generate</code></a> returns a String containing a JSON object:</p> <pre class="ruby" data-language="ruby">ruby = {foo: 0, bar: 's', baz: :bat}
json = JSON.generate(ruby)
json # =&gt; '{"foo":0,"bar":"s","baz":"bat"}'
</pre> <p>The Ruby Hash array may contain nested arrays, hashes, and scalars to any depth:</p> <pre class="ruby" data-language="ruby">ruby = {foo: [0, 1], bar: {baz: 2, bat: 3}, bam: :bad}
json = JSON.generate(ruby)
json # =&gt; '{"foo":[0,1],"bar":{"baz":2,"bat":3},"bam":"bad"}'
</pre> <h4 id="module-JSON-label-Generating+JSON+from+Other+Objects">Generating JSON from Other Objects</h4> <p>When the source is neither an Array nor a Hash, the generated JSON data depends on the class of the source.</p> <p>When the source is a Ruby Integer or Float, <a href="json.html#method-i-generate"><code>JSON.generate</code></a> returns a String containing a JSON number:</p> <pre class="ruby" data-language="ruby">JSON.generate(42) # =&gt; '42'
JSON.generate(0.42) # =&gt; '0.42'
</pre> <p>When the source is a Ruby String, <a href="json.html#method-i-generate"><code>JSON.generate</code></a> returns a String containing a JSON string (with double-quotes):</p> <pre class="ruby" data-language="ruby">JSON.generate('A string') # =&gt; '"A string"'
</pre> <p>When the source is <code>true</code>, <code>false</code> or <code>nil</code>, <a href="json.html#method-i-generate"><code>JSON.generate</code></a> returns a String containing the corresponding JSON token:</p> <pre class="ruby" data-language="ruby">JSON.generate(true) # =&gt; 'true'
JSON.generate(false) # =&gt; 'false'
JSON.generate(nil) # =&gt; 'null'
</pre> <p>When the source is none of the above, <a href="json.html#method-i-generate"><code>JSON.generate</code></a> returns a String containing a JSON string representation of the source:</p> <pre class="ruby" data-language="ruby">JSON.generate(:foo) # =&gt; '"foo"'
JSON.generate(Complex(0, 0)) # =&gt; '"0+0i"'
JSON.generate(Dir.new('.')) # =&gt; '"#&lt;Dir&gt;"'
</pre> <h4 id="module-JSON-label-Generating+Options">Generating Options</h4> <h6 id="module-JSON-label-Input+Options">Input Options</h6> <p>Option <code>allow_nan</code> (boolean) specifies whether <code>NaN</code>, <code>Infinity</code>, and <code>-Infinity</code> may be generated; defaults to <code>false</code>.</p> <p>With the default, <code>false</code>:</p> <pre class="ruby" data-language="ruby"># Raises JSON::GeneratorError (920: NaN not allowed in JSON):
JSON.generate(JSON::NaN)
# Raises JSON::GeneratorError (917: Infinity not allowed in JSON):
JSON.generate(JSON::Infinity)
# Raises JSON::GeneratorError (917: -Infinity not allowed in JSON):
JSON.generate(JSON::MinusInfinity)
</pre> <p>Allow:</p> <pre class="ruby" data-language="ruby">ruby = [Float::NaN, Float::Infinity, Float::MinusInfinity]
JSON.generate(ruby, allow_nan: true) # =&gt; '[NaN,Infinity,-Infinity]'
</pre>  <p>Option <code>max_nesting</code> (Integer) specifies the maximum nesting depth in <code>obj</code>; defaults to <code>100</code>.</p> <p>With the default, <code>100</code>:</p> <pre class="ruby" data-language="ruby">obj = [[[[[[0]]]]]]
JSON.generate(obj) # =&gt; '[[[[[[0]]]]]]'
</pre> <p>Too deep:</p> <pre class="ruby" data-language="ruby"># Raises JSON::NestingError (nesting of 2 is too deep):
JSON.generate(obj, max_nesting: 2)
</pre> <h6 id="module-JSON-label-Escaping+Options">Escaping Options</h6> <p>Options <code>script_safe</code> (boolean) specifies wether <code>'\u2028'</code>, <code>'\u2029'</code> and <code>'/'</code> should be escaped as to make the <a href="json.html"><code>JSON</code></a> object safe to interpolate in script tags.</p> <p>Options <code>ascii_only</code> (boolean) specifies wether all characters outside the ASCII range should be escaped.</p> <h6 id="module-JSON-label-Output+Options">Output Options</h6> <p>The default formatting options generate the most compact JSON data, all on one line and with no whitespace.</p> <p>You can use these formatting options to generate JSON data in a more open format, using whitespace. See also <a href="json.html#method-i-pretty_generate"><code>JSON.pretty_generate</code></a>.</p> <ul>
<li> <p>Option <code>array_nl</code> (String) specifies a string (usually a newline) to be inserted after each JSON array; defaults to the empty String, <code>''</code>.</p> </li>
<li> <p>Option <code>object_nl</code> (String) specifies a string (usually a newline) to be inserted after each JSON object; defaults to the empty String, <code>''</code>.</p> </li>
<li> <p>Option <code>indent</code> (String) specifies the string (usually spaces) to be used for indentation; defaults to the empty String, <code>''</code>; defaults to the empty String, <code>''</code>; has no effect unless options <code>array_nl</code> or <code>object_nl</code> specify newlines.</p> </li>
<li> <p>Option <code>space</code> (String) specifies a string (usually a space) to be inserted after the colon in each JSON object’s pair; defaults to the empty String, <code>''</code>.</p> </li>
<li> <p>Option <code>space_before</code> (String) specifies a string (usually a space) to be inserted before the colon in each JSON object’s pair; defaults to the empty String, <code>''</code>.</p> </li>
</ul> <p>In this example, <code>obj</code> is used first to generate the shortest JSON data (no whitespace), then again with all formatting options specified:</p> <pre class="ruby" data-language="ruby">obj = {foo: [:bar, :baz], bat: {bam: 0, bad: 1}}
json = JSON.generate(obj)
puts 'Compact:', json
opts = {
  array_nl: "\n",
  object_nl: "\n",
  indent: '  ',
  space_before: ' ',
  space: ' '
}
puts 'Open:', JSON.generate(obj, opts)
</pre> <p>Output:</p> <pre>Compact:
{"foo":["bar","baz"],"bat":{"bam":0,"bad":1}}
Open:
{
  "foo" : [
    "bar",
    "baz"
],
  "bat" : {
    "bam" : 0,
    "bad" : 1
  }
}</pre> <h2 id="module-JSON-label-JSON+Additions">JSON Additions</h2> <p>When you “round trip” a non-String object from Ruby to JSON and back, you have a new String, instead of the object you began with:</p> <pre class="ruby" data-language="ruby">ruby0 = Range.new(0, 2)
json = JSON.generate(ruby0)
json # =&gt; '0..2"'
ruby1 = JSON.parse(json)
ruby1 # =&gt; '0..2'
ruby1.class # =&gt; String
</pre> <p>You can use JSON <em>additions</em> to preserve the original object. The addition is an extension of a ruby class, so that:</p> <ul>
<li> <p>JSON.generate stores more information in the JSON string.</p> </li>
<li> <p>JSON.parse, called with option <code>create_additions</code>, uses that information to create a proper Ruby object.</p> </li>
</ul> <p>This example shows a Range being generated into JSON and parsed back into Ruby, both without and with the addition for Range:</p> <pre class="ruby" data-language="ruby">ruby = Range.new(0, 2)
# This passage does not use the addition for Range.
json0 = JSON.generate(ruby)
ruby0 = JSON.parse(json0)
# This passage uses the addition for Range.
require 'json/add/range'
json1 = JSON.generate(ruby)
ruby1 = JSON.parse(json1, create_additions: true)
# Make a nice display.
display = &lt;&lt;EOT
Generated JSON:
  Without addition:  #{json0} (#{json0.class})
  With addition:     #{json1} (#{json1.class})
Parsed JSON:
  Without addition:  #{ruby0.inspect} (#{ruby0.class})
  With addition:     #{ruby1.inspect} (#{ruby1.class})
EOT
puts display
</pre> <p>This output shows the different results:</p> <pre>Generated JSON:
  Without addition:  "0..2" (String)
  With addition:     {"json_class":"Range","a":[0,2,false]} (String)
Parsed JSON:
  Without addition:  "0..2" (String)
  With addition:     0..2 (Range)</pre> <p>The JSON module includes additions for certain classes. You can also craft custom additions. See <a href="#module-JSON-label-Custom+JSON+Additions">Custom JSON Additions</a>.</p> <h3 id="module-JSON-label-Built-in+Additions">Built-in Additions</h3> <p>The JSON module includes additions for certain classes. To use an addition, <code>require</code> its source:</p> <ul>
<li> <p>BigDecimal: <code>require 'json/add/bigdecimal'</code></p> </li>
<li> <p>Complex: <code>require 'json/add/complex'</code></p> </li>
<li> <p>Date: <code>require 'json/add/date'</code></p> </li>
<li> <p>DateTime: <code>require 'json/add/date_time'</code></p> </li>
<li> <p>Exception: <code>require 'json/add/exception'</code></p> </li>
<li> <p>OpenStruct: <code>require 'json/add/ostruct'</code></p> </li>
<li> <p>Range: <code>require 'json/add/range'</code></p> </li>
<li> <p>Rational: <code>require 'json/add/rational'</code></p> </li>
<li> <p>Regexp: <code>require 'json/add/regexp'</code></p> </li>
<li> <p>Set: <code>require 'json/add/set'</code></p> </li>
<li> <p>Struct: <code>require 'json/add/struct'</code></p> </li>
<li> <p>Symbol: <code>require 'json/add/symbol'</code></p> </li>
<li> <p>Time: <code>require 'json/add/time'</code></p> </li>
</ul> <p>To reduce punctuation clutter, the examples below show the generated JSON via <code>puts</code>, rather than the usual <code>inspect</code>,</p> <p>BigDecimal:</p> <pre class="ruby" data-language="ruby">require 'json/add/bigdecimal'
ruby0 = BigDecimal(0) # 0.0
json = JSON.generate(ruby0) # {"json_class":"BigDecimal","b":"27:0.0"}
ruby1 = JSON.parse(json, create_additions: true) # 0.0
ruby1.class # =&gt; BigDecimal
</pre> <p>Complex:</p> <pre class="ruby" data-language="ruby">require 'json/add/complex'
ruby0 = Complex(1+0i) # 1+0i
json = JSON.generate(ruby0) # {"json_class":"Complex","r":1,"i":0}
ruby1 = JSON.parse(json, create_additions: true) # 1+0i
ruby1.class # Complex
</pre> <p>Date:</p> <pre class="ruby" data-language="ruby">require 'json/add/date'
ruby0 = Date.today # 2020-05-02
json = JSON.generate(ruby0) # {"json_class":"Date","y":2020,"m":5,"d":2,"sg":2299161.0}
ruby1 = JSON.parse(json, create_additions: true) # 2020-05-02
ruby1.class # Date
</pre> <p>DateTime:</p> <pre class="ruby" data-language="ruby">require 'json/add/date_time'
ruby0 = DateTime.now # 2020-05-02T10:38:13-05:00
json = JSON.generate(ruby0) # {"json_class":"DateTime","y":2020,"m":5,"d":2,"H":10,"M":38,"S":13,"of":"-5/24","sg":2299161.0}
ruby1 = JSON.parse(json, create_additions: true) # 2020-05-02T10:38:13-05:00
ruby1.class # DateTime
</pre> <p>Exception (and its subclasses including RuntimeError):</p> <pre class="ruby" data-language="ruby">require 'json/add/exception'
ruby0 = Exception.new('A message') # A message
json = JSON.generate(ruby0) # {"json_class":"Exception","m":"A message","b":null}
ruby1 = JSON.parse(json, create_additions: true) # A message
ruby1.class # Exception
ruby0 = RuntimeError.new('Another message') # Another message
json = JSON.generate(ruby0) # {"json_class":"RuntimeError","m":"Another message","b":null}
ruby1 = JSON.parse(json, create_additions: true) # Another message
ruby1.class # RuntimeError
</pre> <p>OpenStruct:</p> <pre class="ruby" data-language="ruby">require 'json/add/ostruct'
ruby0 = OpenStruct.new(name: 'Matz', language: 'Ruby') # #&lt;OpenStruct name="Matz", language="Ruby"&gt;
json = JSON.generate(ruby0) # {"json_class":"OpenStruct","t":{"name":"Matz","language":"Ruby"}}
ruby1 = JSON.parse(json, create_additions: true) # #&lt;OpenStruct name="Matz", language="Ruby"&gt;
ruby1.class # OpenStruct
</pre> <p>Range:</p> <pre class="ruby" data-language="ruby">require 'json/add/range'
ruby0 = Range.new(0, 2) # 0..2
json = JSON.generate(ruby0) # {"json_class":"Range","a":[0,2,false]}
ruby1 = JSON.parse(json, create_additions: true) # 0..2
ruby1.class # Range
</pre> <p>Rational:</p> <pre class="ruby" data-language="ruby">require 'json/add/rational'
ruby0 = Rational(1, 3) # 1/3
json = JSON.generate(ruby0) # {"json_class":"Rational","n":1,"d":3}
ruby1 = JSON.parse(json, create_additions: true) # 1/3
ruby1.class # Rational
</pre> <p>Regexp:</p> <pre class="ruby" data-language="ruby">require 'json/add/regexp'
ruby0 = Regexp.new('foo') # (?-mix:foo)
json = JSON.generate(ruby0) # {"json_class":"Regexp","o":0,"s":"foo"}
ruby1 = JSON.parse(json, create_additions: true) # (?-mix:foo)
ruby1.class # Regexp
</pre> <p>Set:</p> <pre class="ruby" data-language="ruby">require 'json/add/set'
ruby0 = Set.new([0, 1, 2]) # #&lt;Set: {0, 1, 2}&gt;
json = JSON.generate(ruby0) # {"json_class":"Set","a":[0,1,2]}
ruby1 = JSON.parse(json, create_additions: true) # #&lt;Set: {0, 1, 2}&gt;
ruby1.class # Set
</pre> <p>Struct:</p> <pre class="ruby" data-language="ruby">require 'json/add/struct'
Customer = Struct.new(:name, :address) # Customer
ruby0 = Customer.new("Dave", "123 Main") # #&lt;struct Customer name="Dave", address="123 Main"&gt;
json = JSON.generate(ruby0) # {"json_class":"Customer","v":["Dave","123 Main"]}
ruby1 = JSON.parse(json, create_additions: true) # #&lt;struct Customer name="Dave", address="123 Main"&gt;
ruby1.class # Customer
</pre> <p>Symbol:</p> <pre class="ruby" data-language="ruby">require 'json/add/symbol'
ruby0 = :foo # foo
json = JSON.generate(ruby0) # {"json_class":"Symbol","s":"foo"}
ruby1 = JSON.parse(json, create_additions: true) # foo
ruby1.class # Symbol
</pre> <p>Time:</p> <pre class="ruby" data-language="ruby">require 'json/add/time'
ruby0 = Time.now # 2020-05-02 11:28:26 -0500
json = JSON.generate(ruby0) # {"json_class":"Time","s":1588436906,"n":840560000}
ruby1 = JSON.parse(json, create_additions: true) # 2020-05-02 11:28:26 -0500
ruby1.class # Time
</pre> <h3 id="module-JSON-label-Custom+JSON+Additions">Custom JSON Additions</h3> <p>In addition to the JSON additions provided, you can craft JSON additions of your own, either for Ruby built-in classes or for user-defined classes.</p> <p>Here’s a user-defined class <code>Foo</code>:</p> <pre class="ruby" data-language="ruby">class Foo
  attr_accessor :bar, :baz
  def initialize(bar, baz)
    self.bar = bar
    self.baz = baz
  end
end
</pre> <p>Here’s the JSON addition for it:</p> <pre class="ruby" data-language="ruby"># Extend class Foo with JSON addition.
class Foo
  # Serialize Foo object with its class name and arguments
  def to_json(*args)
    {
      JSON.create_id  =&gt; self.class.name,
      'a'             =&gt; [ bar, baz ]
    }.to_json(*args)
  end
  # Deserialize JSON string by constructing new Foo object with arguments.
  def self.json_create(object)
    new(*object['a'])
  end
end
</pre> <p>Demonstration:</p> <pre class="ruby" data-language="ruby">require 'json'
# This Foo object has no custom addition.
foo0 = Foo.new(0, 1)
json0 = JSON.generate(foo0)
obj0 = JSON.parse(json0)
# Lood the custom addition.
require_relative 'foo_addition'
# This foo has the custom addition.
foo1 = Foo.new(0, 1)
json1 = JSON.generate(foo1)
obj1 = JSON.parse(json1, create_additions: true)
#   Make a nice display.
display = &lt;&lt;EOT
Generated JSON:
  Without custom addition:  #{json0} (#{json0.class})
  With custom addition:     #{json1} (#{json1.class})
Parsed JSON:
  Without custom addition:  #{obj0.inspect} (#{obj0.class})
  With custom addition:     #{obj1.inspect} (#{obj1.class})
EOT
puts display
</pre> <p>Output:</p> <pre>Generated JSON:
  Without custom addition:  "#&lt;Foo:0x0000000006534e80&gt;" (String)
  With custom addition:     {"json_class":"Foo","a":[0,1]} (String)
Parsed JSON:
  Without custom addition:  "#&lt;Foo:0x0000000006534e80&gt;" (String)
  With custom addition:     #&lt;Foo:0x0000000006473bb8 @bar=0, @baz=1&gt; (Foo)</pre> </section> <section id="5Buntitled-5D" class="documentation-section"> <section class="constants-list"> <header> <h3>Constants</h3> </header> <dl> <dt id="CREATE_ID_TLS_KEY">CREATE_ID_TLS_KEY </dt>

<dt id="DEFAULT_CREATE_ID">DEFAULT_CREATE_ID </dt>

<dt id="Infinity">Infinity </dt>

<dt id="JSON_LOADED">JSON_LOADED </dt>

<dt id="MinusInfinity">MinusInfinity </dt>

<dt id="NOT_SET">NOT_SET </dt>

<dt id="NaN">NaN </dt>

<dt id="VERSION">VERSION </dt>
<dd>
<p><a href="json.html"><code>JSON</code></a> version</p> </dd>
</dl> </section> <section class="attribute-method-details"> <header> <h3>Attributes</h3> </header> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-c-dump_default_options"> <span class="method-name">dump_default_options</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>Sets or returns the default options for the <a href="json.html#method-i-dump"><code>JSON.dump</code></a> method. Initially:</p> <pre class="ruby" data-language="ruby">opts = JSON.dump_default_options
opts # =&gt; {:max_nesting=&gt;false, :allow_nan=&gt;true, :script_safe=&gt;false}
</pre> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-c-generator"> <span class="method-name">generator</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>Returns the <a href="json.html"><code>JSON</code></a> generator module that is used by <a href="json.html"><code>JSON</code></a>. This is either <span><code>JSON::Ext::Generator</code></span> or JSON::Pure::Generator:</p> <pre class="ruby" data-language="ruby">JSON.generator # =&gt; JSON::Ext::Generator
</pre> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-c-load_default_options"> <span class="method-name">load_default_options</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>Sets or returns default options for the <a href="json.html#method-i-load"><code>JSON.load</code></a> method. Initially:</p> <pre class="ruby" data-language="ruby">opts = JSON.load_default_options
opts # =&gt; {:max_nesting=&gt;false, :allow_nan=&gt;true, :allow_blank=&gt;true, :create_additions=&gt;true}
</pre> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-c-parser"> <span class="method-name">parser</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>Returns the <a href="json.html"><code>JSON</code></a> parser class that is used by <a href="json.html"><code>JSON</code></a>. This is either <span><code>JSON::Ext::Parser</code></span> or JSON::Pure::Parser:</p> <pre class="ruby" data-language="ruby">JSON.parser # =&gt; JSON::Ext::Parser
</pre> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-c-state"> <span class="method-name">state</span><span class="attribute-access-type">[RW]</span> </div> <div class="method-description"> <p>Sets or Returns the <a href="json.html"><code>JSON</code></a> generator state class that is used by <a href="json.html"><code>JSON</code></a>. This is either <span><code>JSON::Ext::Generator::State</code></span> or JSON::Pure::Generator::State:</p> <pre class="ruby" data-language="ruby">JSON.state # =&gt; JSON::Ext::Generator::State
</pre> </div> </div> </section> <section id="public-class-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-5B-5D"> <span class="method-callseq"> JSON[object] → new_array or new_string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="5B-5D-source"> <pre class="ruby" data-language="ruby"># File ext/json/lib/json/common.rb, line 21
def [](object, opts = {})
  if object.respond_to? :to_str
    JSON.parse(object.to_str, opts)
  else
    JSON.generate(object, opts)
  end
end</pre> </div> <p>If <code>object</code> is a String, calls <a href="json.html#method-i-parse"><code>JSON.parse</code></a> with <code>object</code> and <code>opts</code> (see method <a href="json.html#method-i-parse"><code>parse</code></a>):</p> <pre class="ruby" data-language="ruby">json = '[0, 1, null]'
JSON[json]# =&gt; [0, 1, nil]
</pre> <p>Otherwise, calls <a href="json.html#method-i-generate"><code>JSON.generate</code></a> with <code>object</code> and <code>opts</code> (see method <a href="json.html#method-i-generate"><code>generate</code></a>):</p> <pre class="ruby" data-language="ruby">ruby = [0, 1, nil]
JSON[ruby] # =&gt; '[0,1,null]'
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-create_fast_state"> <span class="method-name">create_fast_state</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="create_fast_state-source"> <pre class="ruby" data-language="ruby"># File ext/json/lib/json/common.rb, line 84
def create_fast_state
  State.new(
    :indent         =&gt; '',
    :space          =&gt; '',
    :object_nl      =&gt; "",
    :array_nl       =&gt; "",
    :max_nesting    =&gt; false
  )
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-create_id"> <span class="method-name">create_id</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="create_id-source"> <pre class="ruby" data-language="ruby"># File ext/json/lib/json/common.rb, line 129
def self.create_id
  Thread.current[CREATE_ID_TLS_KEY] || DEFAULT_CREATE_ID
end</pre> </div> <p>Returns the current create identifier. See also <a href="json.html#method-c-create_id-3D"><code>JSON.create_id=</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-create_id-3D"> <span class="method-name">create_id=</span><span class="method-args">(new_value)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="create_id-3D-source"> <pre class="ruby" data-language="ruby"># File ext/json/lib/json/common.rb, line 123
def self.create_id=(new_value)
  Thread.current[CREATE_ID_TLS_KEY] = new_value.dup.freeze
end</pre> </div> <p>Sets create identifier, which is used to decide if the <em>json_create</em> hook of a class should be called; initial value is <code>json_class</code>:</p> <pre class="ruby" data-language="ruby">JSON.create_id # =&gt; 'json_class'
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-create_pretty_state"> <span class="method-name">create_pretty_state</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="create_pretty_state-source"> <pre class="ruby" data-language="ruby"># File ext/json/lib/json/common.rb, line 94
def create_pretty_state
  State.new(
    :indent         =&gt; '  ',
    :space          =&gt; ' ',
    :object_nl      =&gt; "\n",
    :array_nl       =&gt; "\n"
  )
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-iconv"> <span class="method-name">iconv</span><span class="method-args">(to, from, string)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="iconv-source"> <pre class="ruby" data-language="ruby"># File ext/json/lib/json/common.rb, line 638
def self.iconv(to, from, string)
  string.encode(to, from)
end</pre> </div> <p>Encodes string using <a href="string.html#method-i-encode"><code>String.encode</code></a>.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-c-restore"> <span class="method-name">restore</span> </div> </div> <div class="aliases"> Alias for: <a href="json.html#method-i-load">load</a> </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-dump"> <span class="method-callseq"> dump(obj, io = nil, limit = nil) </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="dump-source"> <pre class="ruby" data-language="ruby"># File ext/json/lib/json/common.rb, line 614
def dump(obj, anIO = nil, limit = nil, kwargs = nil)
  io_limit_opt = [anIO, limit, kwargs].compact
  kwargs = io_limit_opt.pop if io_limit_opt.last.is_a?(Hash)
  anIO, limit = io_limit_opt
  if anIO.respond_to?(:to_io)
    anIO = anIO.to_io
  elsif limit.nil? &amp;&amp; !anIO.respond_to?(:write)
    anIO, limit = nil, anIO
  end
  opts = JSON.dump_default_options
  opts = opts.merge(:max_nesting =&gt; limit) if limit
  opts = merge_dump_options(opts, **kwargs) if kwargs
  result = generate(obj, opts)
  if anIO
    anIO.write result
    anIO
  else
    result
  end
rescue JSON::NestingError
  raise ArgumentError, "exceed depth limit"
end</pre> </div> <p>Dumps <code>obj</code> as a JSON string, i.e. calls generate on the object and returns the result.</p> <p>The default options can be changed via method <a href="json.html#attribute-c-dump_default_options"><code>JSON.dump_default_options</code></a>.</p> <ul>
<li> <p>Argument <code>io</code>, if given, should respond to method <code>write</code>; the JSON String is written to <code>io</code>, and <code>io</code> is returned. If <code>io</code> is not given, the JSON String is returned.</p> </li>
<li> <p>Argument <code>limit</code>, if given, is passed to <a href="json.html#method-i-generate"><code>JSON.generate</code></a> as option <code>max_nesting</code>.</p> </li>
</ul>  <p>When argument <code>io</code> is not given, returns the JSON String generated from <code>obj</code>:</p> <pre class="ruby" data-language="ruby">obj = {foo: [0, 1], bar: {baz: 2, bat: 3}, bam: :bad}
json = JSON.dump(obj)
json # =&gt; "{\"foo\":[0,1],\"bar\":{\"baz\":2,\"bat\":3},\"bam\":\"bad\"}"
</pre> <p>When argument <code>io</code> is given, writes the JSON String to <code>io</code> and returns <code>io</code>:</p> <pre class="ruby" data-language="ruby">path = 't.json'
File.open(path, 'w') do |file|
  JSON.dump(obj, file)
end # =&gt; #&lt;File:t.json (closed)&gt;
puts File.read(path)
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">{"foo":[0,1],"bar":{"baz":2,"bat":3},"bam":"bad"}
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-fast_generate"> <span class="method-callseq"> fast_generate(obj, opts) → new_string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="fast_generate-source"> <pre class="ruby" data-language="ruby"># File ext/json/lib/json/common.rb, line 328
def fast_generate(obj, opts = nil)
  if State === opts
    state = opts
  else
    state = JSON.create_fast_state.configure(opts)
  end
  state.generate(obj)
end</pre> </div> <p>Arguments <code>obj</code> and <code>opts</code> here are the same as arguments <code>obj</code> and <code>opts</code> in <a href="json.html#method-i-generate"><code>JSON.generate</code></a>.</p> <p>By default, generates JSON data without checking for circular references in <code>obj</code> (option <code>max_nesting</code> set to <code>false</code>, disabled).</p> <p>Raises an exception if <code>obj</code> contains circular references:</p> <pre class="ruby" data-language="ruby">a = []; b = []; a.push(b); b.push(a)
# Raises SystemStackError (stack level too deep):
JSON.fast_generate(a)
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-generate"> <span class="method-callseq"> generate(obj, opts = nil) → new_string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="generate-source"> <pre class="ruby" data-language="ruby"># File ext/json/lib/json/common.rb, line 299
def generate(obj, opts = nil)
  if State === opts
    state = opts
  else
    state = State.new(opts)
  end
  state.generate(obj)
end</pre> </div> <p>Returns a String containing the generated JSON data.</p> <p>See also <a href="json.html#method-i-fast_generate"><code>JSON.fast_generate</code></a>, <a href="json.html#method-i-pretty_generate"><code>JSON.pretty_generate</code></a>.</p> <p>Argument <code>obj</code> is the Ruby object to be converted to JSON.</p> <p>Argument <code>opts</code>, if given, contains a Hash of options for the generation. See <a href="#module-JSON-label-Generating+Options">Generating Options</a>.</p>  <p>When <code>obj</code> is an Array, returns a String containing a JSON array:</p> <pre class="ruby" data-language="ruby">obj = ["foo", 1.0, true, false, nil]
json = JSON.generate(obj)
json # =&gt; '["foo",1.0,true,false,null]'
</pre> <p>When <code>obj</code> is a Hash, returns a String containing a JSON object:</p> <pre class="ruby" data-language="ruby">obj = {foo: 0, bar: 's', baz: :bat}
json = JSON.generate(obj)
json # =&gt; '{"foo":0,"bar":"s","baz":"bat"}'
</pre> <p>For examples of generating from other Ruby objects, see <a href="#module-JSON-label-Generating+JSON+from+Other+Objects">Generating JSON from Other Objects</a>.</p>  <p>Raises an exception if any formatting option is not a String.</p> <p>Raises an exception if <code>obj</code> contains circular references:</p> <pre class="ruby" data-language="ruby">a = []; b = []; a.push(b); b.push(a)
# Raises JSON::NestingError (nesting of 100 is too deep):
JSON.generate(a)
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-load"> <span class="method-callseq"> load(source, proc = nil, options = {}) → object </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="load-source"> <pre class="ruby" data-language="ruby"># File ext/json/lib/json/common.rb, line 540
def load(source, proc = nil, options = {})
  opts = load_default_options.merge options
  if source.respond_to? :to_str
    source = source.to_str
  elsif source.respond_to? :to_io
    source = source.to_io.read
  elsif source.respond_to?(:read)
    source = source.read
  end
  if opts[:allow_blank] &amp;&amp; (source.nil? || source.empty?)
    source = 'null'
  end
  result = parse(source, opts)
  recurse_proc(result, &amp;proc) if proc
  result
end</pre> </div> <p>Returns the Ruby objects created by parsing the given <code>source</code>.</p> <ul>
<li> <p>Argument <code>source</code> must be, or be convertible to, a String:</p> <ul>
<li> <p>If <code>source</code> responds to instance method <code>to_str</code>, <code>source.to_str</code> becomes the source.</p> </li>
<li> <p>If <code>source</code> responds to instance method <code>to_io</code>, <code>source.to_io.read</code> becomes the source.</p> </li>
<li> <p>If <code>source</code> responds to instance method <code>read</code>, <code>source.read</code> becomes the source.</p> </li>
<li> <p>If both of the following are true, source becomes the String <code>'null'</code>:</p> <ul>
<li> <p>Option <code>allow_blank</code> specifies a truthy value.</p> </li>
<li> <p>The source, as defined above, is <code>nil</code> or the empty String <code>''</code>.</p> </li>
</ul> </li>
<li> <p>Otherwise, <code>source</code> remains the source.</p> </li>
</ul> </li>
<li> <p>Argument <code>proc</code>, if given, must be a Proc that accepts one argument. It will be called recursively with each result (depth-first order). See details below. BEWARE: This method is meant to serialise data from trusted user input, like from your own database server or clients under your control, it could be dangerous to allow untrusted users to pass <a href="json.html"><code>JSON</code></a> sources into it.</p> </li>
<li> <p>Argument <code>opts</code>, if given, contains a Hash of options for the parsing. See <a href="#module-JSON-label-Parsing+Options">Parsing Options</a>. The default options can be changed via method <a href="json.html#attribute-c-load_default_options"><code>JSON.load_default_options=</code></a>.</p> </li>
</ul>  <p>When no <code>proc</code> is given, modifies <code>source</code> as above and returns the result of <code>parse(source, opts)</code>; see <a href="json.html#method-i-parse"><code>parse</code></a>.</p> <p>Source for following examples:</p> <pre class="ruby" data-language="ruby">source = &lt;&lt;-EOT
{
"name": "Dave",
  "age" :40,
  "hats": [
    "Cattleman's",
    "Panama",
    "Tophat"
  ]
}
EOT
</pre> <p>Load a String:</p> <pre class="ruby" data-language="ruby">ruby = JSON.load(source)
ruby # =&gt; {"name"=&gt;"Dave", "age"=&gt;40, "hats"=&gt;["Cattleman's", "Panama", "Tophat"]}
</pre> <p>Load an IO object:</p> <pre class="ruby" data-language="ruby">require 'stringio'
object = JSON.load(StringIO.new(source))
object # =&gt; {"name"=&gt;"Dave", "age"=&gt;40, "hats"=&gt;["Cattleman's", "Panama", "Tophat"]}
</pre> <p>Load a File object:</p> <pre class="ruby" data-language="ruby">path = 't.json'
File.write(path, source)
File.open(path) do |file|
  JSON.load(file)
end # =&gt; {"name"=&gt;"Dave", "age"=&gt;40, "hats"=&gt;["Cattleman's", "Panama", "Tophat"]}
</pre>  <p>When <code>proc</code> is given:</p> <ul>
<li> <p>Modifies <code>source</code> as above.</p> </li>
<li> <p>Gets the <code>result</code> from calling <code>parse(source, opts)</code>.</p> </li>
<li> <p>Recursively calls <code>proc(result)</code>.</p> </li>
<li> <p>Returns the final result.</p> </li>
</ul> <p>Example:</p> <pre class="ruby" data-language="ruby">require 'json'

# Some classes for the example.
class Base
  def initialize(attributes)
    @attributes = attributes
  end
end
class User    &lt; Base; end
class Account &lt; Base; end
class Admin   &lt; Base; end
# The JSON source.
json = &lt;&lt;-EOF
{
  "users": [
      {"type": "User", "username": "jane", "email": "jane@example.com"},
      {"type": "User", "username": "john", "email": "john@example.com"}
  ],
  "accounts": [
      {"account": {"type": "Account", "paid": true, "account_id": "1234"}},
      {"account": {"type": "Account", "paid": false, "account_id": "1235"}}
  ],
  "admins": {"type": "Admin", "password": "0wn3d"}
}
EOF
# Deserializer method.
def deserialize_obj(obj, safe_types = %w(User Account Admin))
  type = obj.is_a?(Hash) &amp;&amp; obj["type"]
  safe_types.include?(type) ? Object.const_get(type).new(obj) : obj
end
# Call to JSON.load
ruby = JSON.load(json, proc {|obj|
  case obj
  when Hash
    obj.each {|k, v| obj[k] = deserialize_obj v }
  when Array
    obj.map! {|v| deserialize_obj v }
  end
})
pp ruby
</pre> <p>Output:</p> <pre>{"users"=&gt;
   [#&lt;User:0x00000000064c4c98
     @attributes=
       {"type"=&gt;"User", "username"=&gt;"jane", "email"=&gt;"jane@example.com"}&gt;,
     #&lt;User:0x00000000064c4bd0
     @attributes=
       {"type"=&gt;"User", "username"=&gt;"john", "email"=&gt;"john@example.com"}&gt;],
 "accounts"=&gt;
   [{"account"=&gt;
       #&lt;Account:0x00000000064c4928
       @attributes={"type"=&gt;"Account", "paid"=&gt;true, "account_id"=&gt;"1234"}&gt;},
    {"account"=&gt;
       #&lt;Account:0x00000000064c4680
       @attributes={"type"=&gt;"Account", "paid"=&gt;false, "account_id"=&gt;"1235"}&gt;}],
 "admins"=&gt;
   #&lt;Admin:0x00000000064c41f8
   @attributes={"type"=&gt;"Admin", "password"=&gt;"0wn3d"}&gt;}</pre>  </div> <div class="aliases"> Also aliased as: <a href="json.html#method-i-restore">restore</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-load_file"> <span class="method-callseq"> load_file(path, opts={}) → object </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="load_file-source"> <pre class="ruby" data-language="ruby"># File ext/json/lib/json/common.rb, line 248
def load_file(filespec, opts = {})
  parse(File.read(filespec), opts)
end</pre> </div> <p>Calls:</p> <pre class="ruby" data-language="ruby">parse(File.read(path), opts)
</pre> <p>See method <a href="json.html#method-i-parse"><code>parse</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-load_file-21"> <span class="method-callseq"> load_file!(path, opts = {}) </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="load_file-21-source"> <pre class="ruby" data-language="ruby"># File ext/json/lib/json/common.rb, line 259
def load_file!(filespec, opts = {})
  parse!(File.read(filespec), opts)
end</pre> </div> <p>Calls:</p> <pre class="ruby" data-language="ruby">JSON.parse!(File.read(path, opts))
</pre> <p>See method <a href="json.html#method-i-parse-21"><code>parse!</code></a></p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-merge_dump_options"> <span class="method-name">merge_dump_options</span><span class="method-args">(opts, strict: NOT_SET)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="merge_dump_options-source"> <pre class="ruby" data-language="ruby"># File ext/json/lib/json/common.rb, line 642
def merge_dump_options(opts, strict: NOT_SET)
  opts = opts.merge(strict: strict) if NOT_SET != strict
  opts
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-parse"> <span class="method-callseq"> parse(source, opts) → object </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="parse-source"> <pre class="ruby" data-language="ruby"># File ext/json/lib/json/common.rb, line 218
def parse(source, opts = {})
  Parser.new(source, **(opts||{})).parse
end</pre> </div> <p>Returns the Ruby objects created by parsing the given <code>source</code>.</p> <p>Argument <code>source</code> contains the String to be parsed.</p> <p>Argument <code>opts</code>, if given, contains a Hash of options for the parsing. See <a href="#module-JSON-label-Parsing+Options">Parsing Options</a>.</p>  <p>When <code>source</code> is a JSON array, returns a Ruby Array:</p> <pre class="ruby" data-language="ruby">source = '["foo", 1.0, true, false, null]'
ruby = JSON.parse(source)
ruby # =&gt; ["foo", 1.0, true, false, nil]
ruby.class # =&gt; Array
</pre> <p>When <code>source</code> is a JSON object, returns a Ruby Hash:</p> <pre class="ruby" data-language="ruby">source = '{"a": "foo", "b": 1.0, "c": true, "d": false, "e": null}'
ruby = JSON.parse(source)
ruby # =&gt; {"a"=&gt;"foo", "b"=&gt;1.0, "c"=&gt;true, "d"=&gt;false, "e"=&gt;nil}
ruby.class # =&gt; Hash
</pre> <p>For examples of parsing for all JSON data types, see <a href="#module-JSON-label-Parsing+JSON">Parsing JSON</a>.</p> <p>Parses nested <a href="json.html"><code>JSON</code></a> objects:</p> <pre class="ruby" data-language="ruby">source = &lt;&lt;-EOT
{
"name": "Dave",
  "age" :40,
  "hats": [
    "Cattleman's",
    "Panama",
    "Tophat"
  ]
}
EOT
ruby = JSON.parse(source)
ruby # =&gt; {"name"=&gt;"Dave", "age"=&gt;40, "hats"=&gt;["Cattleman's", "Panama", "Tophat"]}
</pre>  <p>Raises an exception if <code>source</code> is not valid JSON:</p> <pre class="ruby" data-language="ruby"># Raises JSON::ParserError (783: unexpected token at ''):
JSON.parse('')
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-parse-21"> <span class="method-callseq"> parse!(source, opts) → object </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="parse-21-source"> <pre class="ruby" data-language="ruby"># File ext/json/lib/json/common.rb, line 233
def parse!(source, opts = {})
  opts = {
    :max_nesting  =&gt; false,
    :allow_nan    =&gt; true
  }.merge(opts)
  Parser.new(source, **(opts||{})).parse
end</pre> </div> <p>Calls</p> <pre class="ruby" data-language="ruby">parse(source, opts)
</pre> <p>with <code>source</code> and possibly modified <code>opts</code>.</p> <p>Differences from <a href="json.html#method-i-parse"><code>JSON.parse</code></a>:</p> <ul>
<li> <p>Option <code>max_nesting</code>, if not provided, defaults to <code>false</code>, which disables checking for nesting depth.</p> </li>
<li> <p>Option <code>allow_nan</code>, if not provided, defaults to <code>true</code>.</p> </li>
</ul>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-pretty_generate"> <span class="method-callseq"> pretty_generate(obj, opts = nil) → new_string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="pretty_generate-source"> <pre class="ruby" data-language="ruby"># File ext/json/lib/json/common.rb, line 373
def pretty_generate(obj, opts = nil)
  if State === opts
    state, opts = opts, nil
  else
    state = JSON.create_pretty_state
  end
  if opts
    if opts.respond_to? :to_hash
      opts = opts.to_hash
    elsif opts.respond_to? :to_h
      opts = opts.to_h
    else
      raise TypeError, "can't convert #{opts.class} into Hash"
    end
    state.configure(opts)
  end
  state.generate(obj)
end</pre> </div> <p>Arguments <code>obj</code> and <code>opts</code> here are the same as arguments <code>obj</code> and <code>opts</code> in <a href="json.html#method-i-generate"><code>JSON.generate</code></a>.</p> <p>Default options are:</p> <pre class="ruby" data-language="ruby">{
  indent: '  ',   # Two spaces
  space: ' ',     # One space
  array_nl: "\n", # Newline
  object_nl: "\n" # Newline
}
</pre> <p>Example:</p> <pre class="ruby" data-language="ruby">obj = {foo: [:bar, :baz], bat: {bam: 0, bad: 1}}
json = JSON.pretty_generate(obj)
puts json
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">{
  "foo": [
    "bar",
    "baz"
  ],
  "bat": {
    "bam": 0,
    "bad": 1
  }
}
</pre>  </div> </div> </section> <section id="private-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Private Instance Methods</h3> </header> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-restore"> <span class="method-name">restore</span> </div> </div> <div class="aliases"> Alias for: <a href="json.html#method-i-load">load</a> </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core &copy; 1993&ndash;2022 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library &copy; contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>
