<h1 id="module-FileUtils" class="anchor-link module"> module FileUtils </h1> <section class="description"> <p>Namespace for file utility methods for copying, moving, removing, etc.</p> <h2 id="module-FileUtils-label-What-27s+Here">What’s Here</h2> <p>First, what’s elsewhere. Module FileUtils:</p> <ul>
<li> <p>Inherits from <a href="object.html">class Object</a>.</p> </li>
<li> <p>Supplements <a href="file.html">class File</a> (but is not included or extended there).</p> </li>
</ul> <p>Here, module FileUtils provides methods that are useful for:</p> <ul>
<li> <p><a href="fileutils.html#module-FileUtils-label-Creating">Creating</a>.</p> </li>
<li> <p><a href="fileutils.html#module-FileUtils-label-Deleting">Deleting</a>.</p> </li>
<li> <p><a href="fileutils.html#module-FileUtils-label-Querying">Querying</a>.</p> </li>
<li> <p><a href="fileutils.html#module-FileUtils-label-Setting">Setting</a>.</p> </li>
<li> <p><a href="fileutils.html#module-FileUtils-label-Comparing">Comparing</a>.</p> </li>
<li> <p><a href="fileutils.html#module-FileUtils-label-Copying">Copying</a>.</p> </li>
<li> <p><a href="fileutils.html#module-FileUtils-label-Moving">Moving</a>.</p> </li>
<li> <p><a href="fileutils.html#module-FileUtils-label-Options">Options</a>.</p> </li>
</ul> <h3 id="module-FileUtils-label-Creating">Creating</h3> <ul>
<li> <p><a href="fileutils.html#method-c-mkdir"><code>::mkdir</code></a>: Creates directories.</p> </li>
<li> <p><a href="fileutils.html#method-c-mkdir_p"><code>::mkdir_p</code></a>, <a href="fileutils.html#method-c-makedirs"><code>::makedirs</code></a>, <a href="fileutils.html#method-c-mkpath"><code>::mkpath</code></a>: Creates directories, also creating ancestor directories as needed.</p> </li>
<li> <p><a href="fileutils.html#method-c-link_entry"><code>::link_entry</code></a>: Creates a hard link.</p> </li>
<li> <p><a href="fileutils.html#method-c-ln"><code>::ln</code></a>, <a href="fileutils.html#method-c-link"><code>::link</code></a>: Creates hard links.</p> </li>
<li> <p><a href="fileutils.html#method-c-ln_s"><code>::ln_s</code></a>, <a href="fileutils.html#method-c-symlink"><code>::symlink</code></a>: Creates symbolic links.</p> </li>
<li> <p><a href="fileutils.html#method-c-ln_sf"><code>::ln_sf</code></a>: Creates symbolic links, overwriting if necessary.</p> </li>
<li> <p><a href="fileutils.html#method-c-ln_sr"><code>::ln_sr</code></a>: Creates symbolic links relative to targets</p> </li>
</ul> <h3 id="module-FileUtils-label-Deleting">Deleting</h3> <ul>
<li> <p><a href="fileutils.html#method-c-remove_dir"><code>::remove_dir</code></a>: Removes a directory and its descendants.</p> </li>
<li> <p><a href="fileutils.html#method-c-remove_entry"><code>::remove_entry</code></a>: Removes an entry, including its descendants if it is a directory.</p> </li>
<li> <p><a href="fileutils.html#method-c-remove_entry_secure"><code>::remove_entry_secure</code></a>: Like <a href="fileutils.html#method-c-remove_entry"><code>::remove_entry</code></a>, but removes securely.</p> </li>
<li> <p><a href="fileutils.html#method-c-remove_file"><code>::remove_file</code></a>: Removes a file entry.</p> </li>
<li> <p><a href="fileutils.html#method-c-rm"><code>::rm</code></a>, <a href="fileutils.html#method-c-remove"><code>::remove</code></a>: Removes entries.</p> </li>
<li> <p><a href="fileutils.html#method-c-rm_f"><code>::rm_f</code></a>, <a href="fileutils.html#method-c-safe_unlink"><code>::safe_unlink</code></a>: Like <a href="fileutils.html#method-c-rm"><code>::rm</code></a>, but removes forcibly.</p> </li>
<li> <p><a href="fileutils.html#method-c-rm_r"><code>::rm_r</code></a>: Removes entries and their descendants.</p> </li>
<li> <p><a href="fileutils.html#method-c-rm_rf"><code>::rm_rf</code></a>, <a href="fileutils.html#method-c-rmtree"><code>::rmtree</code></a>: Like <a href="fileutils.html#method-c-rm_r"><code>::rm_r</code></a>, but removes forcibly.</p> </li>
<li> <p><a href="fileutils.html#method-c-rmdir"><code>::rmdir</code></a>: Removes directories.</p> </li>
</ul> <h3 id="module-FileUtils-label-Querying">Querying</h3> <ul>
<li> <p><a href="fileutils.html#method-c-pwd"><code>::pwd</code></a>, <a href="fileutils.html#method-c-getwd"><code>::getwd</code></a>: Returns the path to the working directory.</p> </li>
<li> <p><a href="fileutils.html#method-c-uptodate-3F"><code>::uptodate?</code></a>: Returns whether a given entry is newer than given other entries.</p> </li>
</ul> <h3 id="module-FileUtils-label-Setting">Setting</h3> <ul>
<li> <p><a href="fileutils.html#method-c-cd"><code>::cd</code></a>, <a href="fileutils.html#method-c-chdir"><code>::chdir</code></a>: Sets the working directory.</p> </li>
<li> <p><a href="fileutils.html#method-c-chmod"><code>::chmod</code></a>: Sets permissions for an entry.</p> </li>
<li> <p><a href="fileutils.html#method-c-chmod_R"><code>::chmod_R</code></a>: Sets permissions for an entry and its descendants.</p> </li>
<li> <p><a href="fileutils.html#method-c-chown"><code>::chown</code></a>: Sets the owner and group for entries.</p> </li>
<li> <p><a href="fileutils.html#method-c-chown_R"><code>::chown_R</code></a>: Sets the owner and group for entries and their descendants.</p> </li>
<li> <p><a href="fileutils.html#method-c-touch"><code>::touch</code></a>: Sets modification and access times for entries, creating if necessary.</p> </li>
</ul> <h3 id="module-FileUtils-label-Comparing">Comparing</h3> <ul>
<li> <p><a href="fileutils.html#method-c-compare_file"><code>::compare_file</code></a>, <a href="fileutils.html#method-c-cmp"><code>::cmp</code></a>, <a href="fileutils.html#method-c-identical-3F"><code>::identical?</code></a>: Returns whether two entries are identical.</p> </li>
<li> <p><a href="fileutils.html#method-c-compare_stream"><code>::compare_stream</code></a>: Returns whether two streams are identical.</p> </li>
</ul> <h3 id="module-FileUtils-label-Copying">Copying</h3> <ul>
<li> <p><a href="fileutils.html#method-c-copy_entry"><code>::copy_entry</code></a>: Recursively copies an entry.</p> </li>
<li> <p><a href="fileutils.html#method-c-copy_file"><code>::copy_file</code></a>: Copies an entry.</p> </li>
<li> <p><a href="fileutils.html#method-c-copy_stream"><code>::copy_stream</code></a>: Copies a stream.</p> </li>
<li> <p><a href="fileutils.html#method-c-cp"><code>::cp</code></a>, <a href="fileutils.html#method-c-copy"><code>::copy</code></a>: Copies files.</p> </li>
<li> <p><a href="fileutils.html#method-c-cp_lr"><code>::cp_lr</code></a>: Recursively creates hard links.</p> </li>
<li> <p><a href="fileutils.html#method-c-cp_r"><code>::cp_r</code></a>: Recursively copies files, retaining mode, owner, and group.</p> </li>
<li> <p><a href="fileutils.html#method-c-install"><code>::install</code></a>: Recursively copies files, optionally setting mode, owner, and group.</p> </li>
</ul> <h3 id="module-FileUtils-label-Moving">Moving</h3> <ul><li> <p><a href="fileutils.html#method-c-mv"><code>::mv</code></a>, <a href="fileutils.html#method-c-move"><code>::move</code></a>: Moves entries.</p> </li></ul> <h3 id="module-FileUtils-label-Options">Options</h3> <ul>
<li> <p><a href="fileutils.html#method-c-collect_method"><code>::collect_method</code></a>: Returns the names of methods that accept a given option.</p> </li>
<li> <p><a href="fileutils.html#method-c-commands"><code>::commands</code></a>: Returns the names of methods that accept options.</p> </li>
<li> <p><a href="fileutils.html#method-c-have_option-3F"><code>::have_option?</code></a>: Returns whether a given method accepts a given option.</p> </li>
<li> <p><a href="fileutils.html#method-c-options"><code>::options</code></a>: Returns all option names.</p> </li>
<li> <p><a href="fileutils.html#method-c-options_of"><code>::options_of</code></a>: Returns the names of the options for a given method.</p> </li>
</ul> <h2 id="module-FileUtils-label-Path+Arguments">Path Arguments</h2> <p>Some methods in FileUtils accept <em>path</em> arguments, which are interpreted as paths to filesystem entries:</p> <ul>
<li> <p>If the argument is a string, that value is the path.</p> </li>
<li> <p>If the argument has method <code>:to_path</code>, it is converted via that method.</p> </li>
<li> <p>If the argument has method <code>:to_str</code>, it is converted via that method.</p> </li>
</ul> <h2 id="module-FileUtils-label-About+the+Examples">About the Examples</h2> <p>Some examples here involve trees of file entries. For these, we sometimes display trees using the <a href="https://en.wikipedia.org/wiki/Tree_(command)">tree command-line utility</a>, which is a recursive directory-listing utility that produces a depth-indented listing of files and directories.</p> <p>We use a helper method to launch the command and control the format:</p> <pre class="ruby" data-language="ruby">def tree(dirpath = '.')
  command = "tree --noreport --charset=ascii #{dirpath}"
  system(command)
end
</pre> <p>To illustrate:</p> <pre class="ruby" data-language="ruby">tree('src0')
# =&gt; src0
#    |-- sub0
#    |   |-- src0.txt
#    |   `-- src1.txt
#    `-- sub1
#        |-- src2.txt
#        `-- src3.txt
</pre> <h2 id="module-FileUtils-label-Avoiding+the+TOCTTOU+Vulnerability">Avoiding the TOCTTOU Vulnerability</h2> <p>For certain methods that recursively remove entries, there is a potential vulnerability called the <a href="https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use">Time-of-check to time-of-use</a>, or TOCTTOU, vulnerability that can exist when:</p> <ul>
<li> <p>An ancestor directory of the entry at the target path is world writable; such directories include <code>/tmp</code>.</p> </li>
<li> <p>The directory tree at the target path includes:</p> <ul>
<li> <p>A world-writable descendant directory.</p> </li>
<li> <p>A symbolic link.</p> </li>
</ul> </li>
</ul> <p>To avoid that vulnerability, you can use this method to remove entries:</p> <ul><li> <p><a href="fileutils.html#method-c-remove_entry_secure"><code>FileUtils.remove_entry_secure</code></a>: removes recursively if the target path points to a directory.</p> </li></ul> <p>Also available are these methods, each of which calls FileUtils.remove_entry_secure:</p> <ul>
<li> <p><a href="fileutils.html#method-c-rm_r"><code>FileUtils.rm_r</code></a> with keyword argument <code>secure: true</code>.</p> </li>
<li> <p><a href="fileutils.html#method-c-rm_rf"><code>FileUtils.rm_rf</code></a> with keyword argument <code>secure: true</code>.</p> </li>
</ul> <p>Finally, this method for moving entries calls FileUtils.remove_entry_secure if the source and destination are on different file systems (which means that the “move” is really a copy and remove):</p> <ul><li> <p><a href="fileutils.html#method-c-mv"><code>FileUtils.mv</code></a> with keyword argument <code>secure: true</code>.</p> </li></ul> <p>Method FileUtils.remove_entry_secure removes securely by applying a special pre-process:</p> <ul>
<li> <p>If the target path points to a directory, this method uses methods <a href="file.html#method-i-chown"><code>File#chown</code></a> and <a href="file.html#method-i-chmod"><code>File#chmod</code></a> in removing directories.</p> </li>
<li> <p>The owner of the target directory should be either the current process or the super user (root).</p> </li>
</ul> <p>WARNING: You must ensure that <strong>ALL</strong> parent directories cannot be moved by other untrusted users. For example, parent directories should not be owned by untrusted users, and should not be world writable except when the sticky bit is set.</p> <p>For details of this security vulnerability, see Perl cases:</p> <ul>
<li> <p><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CAN-2005-0448">CVE-2005-0448</a>.</p> </li>
<li> <p><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CAN-2004-0452">CVE-2004-0452</a>.</p> </li>
</ul> </section> <section id="5Buntitled-5D" class="documentation-section anchor-link"> <section class="constants-list"> <header> <h3>Constants</h3> </header> <dl> <dt id="VERSION">VERSION </dt>
<dd> <p>The version number.</p> </dd>
</dl> </section> <section id="public-class-5Buntitled-5D-method-details" class="method-section anchor-link"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-cd"> <a href="#method-c-cd" title="Link to this method"> <span class="method-name">cd</span> <span class="method-args">(dir, verbose: nil) { |dir| ... }</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="cd-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 239
def cd(dir, verbose: nil, &amp;block) # :yield: dir
  fu_output_message "cd #{dir}" if verbose
  result = Dir.chdir(dir, &amp;block)
  fu_output_message 'cd -' if verbose and block
  result
end</pre> </div>  <p>Changes the working directory to the given <code>dir</code>, which should be <a href="fileutils.html#module-FileUtils-label-Path+Arguments">interpretable as a path</a>:</p> <p>With no block given, changes the current directory to the directory at <code>dir</code>; returns zero:</p> <pre class="ruby" data-language="ruby">FileUtils.pwd # =&gt; "/rdoc/fileutils"
FileUtils.cd('..')
FileUtils.pwd # =&gt; "/rdoc"
FileUtils.cd('fileutils')
</pre> <p>With a block given, changes the current directory to the directory at <code>dir</code>, calls the block with argument <code>dir</code>, and restores the original current directory; returns the block’s value:</p> <pre class="ruby" data-language="ruby">FileUtils.pwd                                     # =&gt; "/rdoc/fileutils"
FileUtils.cd('..') { |arg| [arg, FileUtils.pwd] } # =&gt; ["..", "/rdoc"]
FileUtils.pwd                                     # =&gt; "/rdoc/fileutils"
</pre> <p>Keyword arguments:</p> <ul><li> <p><code>verbose: true</code> - prints an equivalent command:</p> <pre class="ruby" data-language="ruby">FileUtils.cd('..')
FileUtils.cd('fileutils')
</pre> <p>Output:</p> <pre>cd ..
cd fileutils</pre> </li></ul> <p>Related: <a href="fileutils.html#method-c-pwd"><code>FileUtils.pwd</code></a>.</p> </div> <div class="aliases"> Also aliased as: <a href="fileutils.html#method-i-chdir">chdir</a> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-c-chdir"> <a href="#method-c-chdir" title="Link to this method"> <span class="method-name">chdir</span> <span class="method-args">(dir, verbose: nil)</span> </a> </div> </div>  <div class="aliases"> Alias for: <a href="fileutils.html#method-i-cd">cd</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-chmod"> <a href="#method-c-chmod" title="Link to this method"> <span class="method-name">chmod</span> <span class="method-args">(mode, list, noop: nil, verbose: nil)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="chmod-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 1804
def chmod(mode, list, noop: nil, verbose: nil)
  list = fu_list(list)
  fu_output_message sprintf('chmod %s %s', mode_to_s(mode), list.join(' ')) if verbose
  return if noop
  list.each do |path|
    Entry_.new(path).chmod(fu_mode(mode, path))
  end
end</pre> </div>  <p>Changes permissions on the entries at the paths given in <code>list</code> (a single path or an array of paths) to the permissions given by <code>mode</code>; returns <code>list</code> if it is an array, <code>[list]</code> otherwise:</p> <ul>
<li> <p>Modifies each entry that is a regular file using <a href="file.html#method-c-chmod"><code>File.chmod</code></a>.</p> </li>
<li> <p>Modifies each entry that is a symbolic link using <a href="file.html#method-c-lchmod"><code>File.lchmod</code></a>.</p> </li>
</ul> <p>Argument <code>list</code> or its elements should be <a href="fileutils.html#module-FileUtils-label-Path+Arguments">interpretable as paths</a>.</p> <p>Argument <code>mode</code> may be either an integer or a string:</p> <ul>
<li> <p>Integer <code>mode</code>: represents the permission bits to be set:</p> <pre class="ruby" data-language="ruby">FileUtils.chmod(0755, 'src0.txt')
FileUtils.chmod(0644, ['src0.txt', 'src0.dat'])
</pre> </li>
<li> <p>String <code>mode</code>: represents the permissions to be set:</p> <p>The string is of the form <code>[targets][[operator][perms[,perms]]</code>, where:</p> <ul>
<li> <p><code>targets</code> may be any combination of these letters:</p> <ul>
<li> <p><code>'u'</code>: permissions apply to the file’s owner.</p> </li>
<li> <p><code>'g'</code>: permissions apply to users in the file’s group.</p> </li>
<li> <p><code>'o'</code>: permissions apply to other users not in the file’s group.</p> </li>
<li> <p><code>'a'</code> (the default): permissions apply to all users.</p> </li>
</ul> </li>
<li> <p><code>operator</code> may be one of these letters:</p> <ul>
<li> <p><code>'+'</code>: adds permissions.</p> </li>
<li> <p><code>'-'</code>: removes permissions.</p> </li>
<li> <p><code>'='</code>: sets (replaces) permissions.</p> </li>
</ul> </li>
<li> <p><code>perms</code> (may be repeated, with separating commas) may be any combination of these letters:</p> <ul>
<li> <p><code>'r'</code>: Read.</p> </li>
<li> <p><code>'w'</code>: Write.</p> </li>
<li> <p><code>'x'</code>: Execute (search, for a directory).</p> </li>
<li> <p><code>'X'</code>: Search (for a directories only; must be used with <code>'+'</code>)</p> </li>
<li> <p><code>'s'</code>: Uid or gid.</p> </li>
<li> <p><code>'t'</code>: Sticky bit.</p> </li>
</ul> </li>
</ul> <p>Examples:</p> <pre class="ruby" data-language="ruby">FileUtils.chmod('u=wrx,go=rx', 'src1.txt')
FileUtils.chmod('u=wrx,go=rx', '/usr/bin/ruby')
</pre> </li>
</ul> <p>Keyword arguments:</p> <ul>
<li> <p><code>noop: true</code> - does not change permissions; returns <code>nil</code>.</p> </li>
<li> <p><code>verbose: true</code> - prints an equivalent command:</p> <pre class="ruby" data-language="ruby">FileUtils.chmod(0755, 'src0.txt', noop: true, verbose: true)
FileUtils.chmod(0644, ['src0.txt', 'src0.dat'], noop: true, verbose: true)
FileUtils.chmod('u=wrx,go=rx', 'src1.txt', noop: true, verbose: true)
FileUtils.chmod('u=wrx,go=rx', '/usr/bin/ruby', noop: true, verbose: true)
</pre> <p>Output:</p> <pre>chmod 755 src0.txt
chmod 644 src0.txt src0.dat
chmod u=wrx,go=rx src1.txt
chmod u=wrx,go=rx /usr/bin/ruby</pre> </li>
</ul> <p>Related: <a href="fileutils.html#method-c-chmod_R"><code>FileUtils.chmod_R</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-chmod_R"> <a href="#method-c-chmod_R" title="Link to this method"> <span class="method-name">chmod_R</span> <span class="method-args">(mode, list, noop: nil, verbose: nil, force: nil)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="chmod_R-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 1816
def chmod_R(mode, list, noop: nil, verbose: nil, force: nil)
  list = fu_list(list)
  fu_output_message sprintf('chmod -R%s %s %s',
                            (force ? 'f' : ''),
                            mode_to_s(mode), list.join(' ')) if verbose
  return if noop
  list.each do |root|
    Entry_.new(root).traverse do |ent|
      begin
        ent.chmod(fu_mode(mode, ent.path))
      rescue
        raise unless force
      end
    end
  end
end</pre> </div>  <p>Like <a href="fileutils.html#method-c-chmod"><code>FileUtils.chmod</code></a>, but changes permissions recursively.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-chown"> <a href="#method-c-chown" title="Link to this method"> <span class="method-name">chown</span> <span class="method-args">(user, group, list, noop: nil, verbose: nil)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="chown-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 1897
def chown(user, group, list, noop: nil, verbose: nil)
  list = fu_list(list)
  fu_output_message sprintf('chown %s %s',
                            (group ? "#{user}:#{group}" : user || ':'),
                            list.join(' ')) if verbose
  return if noop
  uid = fu_get_uid(user)
  gid = fu_get_gid(group)
  list.each do |path|
    Entry_.new(path).chown uid, gid
  end
end</pre> </div>  <p>Changes the owner and group on the entries at the paths given in <code>list</code> (a single path or an array of paths) to the given <code>user</code> and <code>group</code>; returns <code>list</code> if it is an array, <code>[list]</code> otherwise:</p> <ul>
<li> <p>Modifies each entry that is a regular file using <a href="file.html#method-c-chown"><code>File.chown</code></a>.</p> </li>
<li> <p>Modifies each entry that is a symbolic link using <a href="file.html#method-c-lchown"><code>File.lchown</code></a>.</p> </li>
</ul> <p>Argument <code>list</code> or its elements should be <a href="fileutils.html#module-FileUtils-label-Path+Arguments">interpretable as paths</a>.</p> <p>User and group:</p> <ul>
<li> <p>Argument <code>user</code> may be a user name or a user id; if <code>nil</code> or <code>-1</code>, the user is not changed.</p> </li>
<li> <p>Argument <code>group</code> may be a group name or a group id; if <code>nil</code> or <code>-1</code>, the group is not changed.</p> </li>
<li> <p>The user must be a member of the group.</p> </li>
</ul> <p>Examples:</p> <pre class="ruby" data-language="ruby"># One path.
# User and group as string names.
File.stat('src0.txt').uid # =&gt; 1004
File.stat('src0.txt').gid # =&gt; 1004
FileUtils.chown('user2', 'group1', 'src0.txt')
File.stat('src0.txt').uid # =&gt; 1006
File.stat('src0.txt').gid # =&gt; 1005

# User and group as uid and gid.
FileUtils.chown(1004, 1004, 'src0.txt')
File.stat('src0.txt').uid # =&gt; 1004
File.stat('src0.txt').gid # =&gt; 1004

# Array of paths.
FileUtils.chown(1006, 1005, ['src0.txt', 'src0.dat'])

# Directory (not recursive).
FileUtils.chown('user2', 'group1', '.')
</pre> <p>Keyword arguments:</p> <ul>
<li> <p><code>noop: true</code> - does not change permissions; returns <code>nil</code>.</p> </li>
<li> <p><code>verbose: true</code> - prints an equivalent command:</p> <pre class="ruby" data-language="ruby">FileUtils.chown('user2', 'group1', 'src0.txt', noop: true, verbose: true)
FileUtils.chown(1004, 1004, 'src0.txt', noop: true, verbose: true)
FileUtils.chown(1006, 1005, ['src0.txt', 'src0.dat'], noop: true, verbose: true)
FileUtils.chown('user2', 'group1', path, noop: true, verbose: true)
FileUtils.chown('user2', 'group1', '.', noop: true, verbose: true)
</pre> <p>Output:</p> <pre>chown user2:group1 src0.txt
chown 1004:1004 src0.txt
chown 1006:1005 src0.txt src0.dat
chown user2:group1 src0.txt
chown user2:group1 .</pre> </li>
</ul> <p>Related: <a href="fileutils.html#method-c-chown_R"><code>FileUtils.chown_R</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-chown_R"> <a href="#method-c-chown_R" title="Link to this method"> <span class="method-name">chown_R</span> <span class="method-args">(user, group, list, noop: nil, verbose: nil, force: nil)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="chown_R-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 1913
def chown_R(user, group, list, noop: nil, verbose: nil, force: nil)
  list = fu_list(list)
  fu_output_message sprintf('chown -R%s %s %s',
                            (force ? 'f' : ''),
                            (group ? "#{user}:#{group}" : user || ':'),
                            list.join(' ')) if verbose
  return if noop
  uid = fu_get_uid(user)
  gid = fu_get_gid(group)
  list.each do |root|
    Entry_.new(root).traverse do |ent|
      begin
        ent.chown uid, gid
      rescue
        raise unless force
      end
    end
  end
end</pre> </div>  <p>Like <a href="fileutils.html#method-c-chown"><code>FileUtils.chown</code></a>, but changes owner and group recursively.</p> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-c-cmp"> <a href="#method-c-cmp" title="Link to this method"> <span class="method-name">cmp</span> <span class="method-args">(a, b)</span> </a> </div> </div>  <div class="aliases"> Alias for: <a href="fileutils.html#method-i-compare_file">compare_file</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-collect_method"> <a href="#method-c-collect_method" title="Link to this method"> <span class="method-name">collect_method</span> <span class="method-args">(opt)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="collect_method-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 2611
def self.collect_method(opt)
  OPT_TABLE.keys.select {|m| OPT_TABLE[m].include?(opt) }
end</pre> </div>  <p>Returns an array of the string method names of the methods that accept the given keyword option <code>opt</code>; the argument must be a symbol:</p> <pre class="ruby" data-language="ruby">FileUtils.collect_method(:preserve) # =&gt; ["cp", "copy", "cp_r", "install"]
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-commands"> <a href="#method-c-commands" title="Link to this method"> <span class="method-name">commands</span> <span class="method-args">()</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="commands-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 2572
def self.commands
  OPT_TABLE.keys
end</pre> </div>  <p>Returns an array of the string names of FileUtils methods that accept one or more keyword arguments:</p> <pre class="ruby" data-language="ruby">FileUtils.commands.sort.take(3) # =&gt; ["cd", "chdir", "chmod"]
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-compare_file"> <a href="#method-c-compare_file" title="Link to this method"> <span class="method-name">compare_file</span> <span class="method-args">(a, b)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="compare_file-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 1508
def compare_file(a, b)
  return false unless File.size(a) == File.size(b)
  File.open(a, 'rb') {|fa|
    File.open(b, 'rb') {|fb|
      return compare_stream(fa, fb)
    }
  }
end</pre> </div>  <p>Returns <code>true</code> if the contents of files <code>a</code> and <code>b</code> are identical, <code>false</code> otherwise.</p> <p>Arguments <code>a</code> and <code>b</code> should be <a href="fileutils.html#module-FileUtils-label-Path+Arguments">interpretable as a path</a>.</p> <p><a href="fileutils.html#method-c-identical-3F"><code>FileUtils.identical?</code></a> and <a href="fileutils.html#method-c-cmp"><code>FileUtils.cmp</code></a> are aliases for <a href="fileutils.html#method-c-compare_file"><code>FileUtils.compare_file</code></a>.</p> <p>Related: <a href="fileutils.html#method-c-compare_stream"><code>FileUtils.compare_stream</code></a>.</p> </div> <div class="aliases"> Also aliased as: <a href="fileutils.html#method-i-identical-3F">identical?</a>, <a href="fileutils.html#method-i-cmp">cmp</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-compare_stream"> <a href="#method-c-compare_stream" title="Link to this method"> <span class="method-name">compare_stream</span> <span class="method-args">(a, b)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="compare_stream-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 1531
def compare_stream(a, b)
  bsize = fu_stream_blksize(a, b)

  sa = String.new(capacity: bsize)
  sb = String.new(capacity: bsize)

  begin
    a.read(bsize, sa)
    b.read(bsize, sb)
    return true if sa.empty? &amp;&amp; sb.empty?
  end while sa == sb
  false
end</pre> </div>  <p>Returns <code>true</code> if the contents of streams <code>a</code> and <code>b</code> are identical, <code>false</code> otherwise.</p> <p>Arguments <code>a</code> and <code>b</code> should be <a href="fileutils.html#module-FileUtils-label-Path+Arguments">interpretable as a path</a>.</p> <p>Related: <a href="fileutils.html#method-c-compare_file"><code>FileUtils.compare_file</code></a>.</p> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-c-copy"> <a href="#method-c-copy" title="Link to this method"> <span class="method-name">copy</span> <span class="method-args">(src, dest, preserve: nil, noop: nil, verbose: nil)</span> </a> </div> </div>  <div class="aliases"> Alias for: <a href="fileutils.html#method-i-cp">cp</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-copy_entry"> <a href="#method-c-copy_entry" title="Link to this method"> <span class="method-name">copy_entry</span> <span class="method-args">(src, dest, preserve = false, dereference_root = false, remove_destination = false)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="copy_entry-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 1041
def copy_entry(src, dest, preserve = false, dereference_root = false, remove_destination = false)
  if dereference_root
    src = File.realpath(src)
  end

  Entry_.new(src, nil, false).wrap_traverse(proc do |ent|
    destent = Entry_.new(dest, ent.rel, false)
    File.unlink destent.path if remove_destination &amp;&amp; (File.file?(destent.path) || File.symlink?(destent.path))
    ent.copy destent.path
  end, proc do |ent|
    destent = Entry_.new(dest, ent.rel, false)
    ent.copy_metadata destent.path if preserve
  end)
end</pre> </div>  <p>Recursively copies files from <code>src</code> to <code>dest</code>.</p> <p>Arguments <code>src</code> and <code>dest</code> should be <a href="fileutils.html#module-FileUtils-label-Path+Arguments">interpretable as paths</a>.</p> <p>If <code>src</code> is the path to a file, copies <code>src</code> to <code>dest</code>:</p> <pre class="ruby" data-language="ruby">FileUtils.touch('src0.txt')
File.exist?('dest0.txt') # =&gt; false
FileUtils.copy_entry('src0.txt', 'dest0.txt')
File.file?('dest0.txt')  # =&gt; true
</pre> <p>If <code>src</code> is a directory, recursively copies <code>src</code> to <code>dest</code>:</p> <pre class="ruby" data-language="ruby">tree('src1')
# =&gt; src1
#    |-- dir0
#    |   |-- src0.txt
#    |   `-- src1.txt
#    `-- dir1
#        |-- src2.txt
#        `-- src3.txt
FileUtils.copy_entry('src1', 'dest1')
tree('dest1')
# =&gt; dest1
#    |-- dir0
#    |   |-- src0.txt
#    |   `-- src1.txt
#    `-- dir1
#        |-- src2.txt
#        `-- src3.txt
</pre> <p>The recursive copying preserves file types for regular files, directories, and symbolic links; other file types (FIFO streams, device files, etc.) are not supported.</p> <p>Keyword arguments:</p> <ul>
<li> <p><code>dereference_root: true</code> - if <code>src</code> is a symbolic link, follows the link.</p> </li>
<li> <p><code>preserve: true</code> - preserves file times.</p> </li>
<li> <p><code>remove_destination: true</code> - removes <code>dest</code> before copying files.</p> </li>
</ul> <p>Related: <a href="fileutils.html#module-FileUtils-label-Copying">methods for copying</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-copy_file"> <a href="#method-c-copy_file" title="Link to this method"> <span class="method-name">copy_file</span> <span class="method-args">(src, dest, preserve = false, dereference = true)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="copy_file-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 1077
def copy_file(src, dest, preserve = false, dereference = true)
  ent = Entry_.new(src, nil, dereference)
  ent.copy_file dest
  ent.copy_metadata dest if preserve
end</pre> </div>  <p>Copies file from <code>src</code> to <code>dest</code>, which should not be directories.</p> <p>Arguments <code>src</code> and <code>dest</code> should be <a href="fileutils.html#module-FileUtils-label-Path+Arguments">interpretable as paths</a>.</p> <p>Examples:</p> <pre class="ruby" data-language="ruby">FileUtils.touch('src0.txt')
FileUtils.copy_file('src0.txt', 'dest0.txt')
File.file?('dest0.txt') # =&gt; true
</pre> <p>Keyword arguments:</p> <ul>
<li> <p><code>dereference: false</code> - if <code>src</code> is a symbolic link, does not follow the link.</p> </li>
<li> <p><code>preserve: true</code> - preserves file times.</p> </li>
<li> <p><code>remove_destination: true</code> - removes <code>dest</code> before copying files.</p> </li>
</ul> <p>Related: <a href="fileutils.html#module-FileUtils-label-Copying">methods for copying</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-copy_stream"> <a href="#method-c-copy_stream" title="Link to this method"> <span class="method-name">copy_stream</span> <span class="method-args">(src, dest)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="copy_stream-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 1089
def copy_stream(src, dest)
  IO.copy_stream(src, dest)
end</pre> </div>  <p>Copies IO stream <code>src</code> to IO stream <code>dest</code> via <a href="io.html#method-c-copy_stream"><code>IO.copy_stream</code></a>.</p> <p>Related: <a href="fileutils.html#module-FileUtils-label-Copying">methods for copying</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-cp"> <a href="#method-c-cp" title="Link to this method"> <span class="method-name">cp</span> <span class="method-args">(src, dest, preserve: nil, noop: nil, verbose: nil)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="cp-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 874
def cp(src, dest, preserve: nil, noop: nil, verbose: nil)
  fu_output_message "cp#{preserve ? ' -p' : ''} #{[src,dest].flatten.join ' '}" if verbose
  return if noop
  fu_each_src_dest(src, dest) do |s, d|
    copy_file s, d, preserve
  end
end</pre> </div>  <p>Copies files.</p> <p>Arguments <code>src</code> (a single path or an array of paths) and <code>dest</code> (a single path) should be <a href="fileutils.html#module-FileUtils-label-Path+Arguments">interpretable as paths</a>.</p> <p>If <code>src</code> is the path to a file and <code>dest</code> is not the path to a directory, copies <code>src</code> to <code>dest</code>:</p> <pre class="ruby" data-language="ruby">FileUtils.touch('src0.txt')
File.exist?('dest0.txt') # =&gt; false
FileUtils.cp('src0.txt', 'dest0.txt')
File.file?('dest0.txt')  # =&gt; true
</pre> <p>If <code>src</code> is the path to a file and <code>dest</code> is the path to a directory, copies <code>src</code> to <code>dest/src</code>:</p> <pre class="ruby" data-language="ruby">FileUtils.touch('src1.txt')
FileUtils.mkdir('dest1')
FileUtils.cp('src1.txt', 'dest1')
File.file?('dest1/src1.txt') # =&gt; true
</pre> <p>If <code>src</code> is an array of paths to files and <code>dest</code> is the path to a directory, copies from each <code>src</code> to <code>dest</code>:</p> <pre class="ruby" data-language="ruby">src_file_paths = ['src2.txt', 'src2.dat']
FileUtils.touch(src_file_paths)
FileUtils.mkdir('dest2')
FileUtils.cp(src_file_paths, 'dest2')
File.file?('dest2/src2.txt') # =&gt; true
File.file?('dest2/src2.dat') # =&gt; true
</pre> <p>Keyword arguments:</p> <ul>
<li> <p><code>preserve: true</code> - preserves file times.</p> </li>
<li> <p><code>noop: true</code> - does not copy files.</p> </li>
<li> <p><code>verbose: true</code> - prints an equivalent command:</p> <pre class="ruby" data-language="ruby">FileUtils.cp('src0.txt', 'dest0.txt', noop: true, verbose: true)
FileUtils.cp('src1.txt', 'dest1', noop: true, verbose: true)
FileUtils.cp(src_file_paths, 'dest2', noop: true, verbose: true)
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">cp src0.txt dest0.txt
cp src1.txt dest1
cp src2.txt src2.dat dest2
</pre> </li>
</ul> <p>Raises an exception if <code>src</code> is a directory.</p> <p>Related: <a href="fileutils.html#module-FileUtils-label-Copying">methods for copying</a>.</p> </div> <div class="aliases"> Also aliased as: <a href="fileutils.html#method-i-copy">copy</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-cp_lr"> <a href="#method-c-cp_lr" title="Link to this method"> <span class="method-name">cp_lr</span> <span class="method-args">(src, dest, noop: nil, verbose: nil, dereference_root: true, remove_destination: false)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="cp_lr-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 628
def cp_lr(src, dest, noop: nil, verbose: nil,
          dereference_root: true, remove_destination: false)
  fu_output_message "cp -lr#{remove_destination ? ' --remove-destination' : ''} #{[src,dest].flatten.join ' '}" if verbose
  return if noop
  fu_each_src_dest(src, dest) do |s, d|
    link_entry s, d, dereference_root, remove_destination
  end
end</pre> </div>  <p>Creates <a href="https://en.wikipedia.org/wiki/Hard_link">hard links</a>.</p> <p>Arguments <code>src</code> (a single path or an array of paths) and <code>dest</code> (a single path) should be <a href="fileutils.html#module-FileUtils-label-Path+Arguments">interpretable as paths</a>.</p> <p>If <code>src</code> is the path to a directory and <code>dest</code> does not exist, creates links <code>dest</code> and descendents pointing to <code>src</code> and its descendents:</p> <pre class="ruby" data-language="ruby">tree('src0')
# =&gt; src0
#    |-- sub0
#    |   |-- src0.txt
#    |   `-- src1.txt
#    `-- sub1
#        |-- src2.txt
#        `-- src3.txt
File.exist?('dest0') # =&gt; false
FileUtils.cp_lr('src0', 'dest0')
tree('dest0')
# =&gt; dest0
#    |-- sub0
#    |   |-- src0.txt
#    |   `-- src1.txt
#    `-- sub1
#        |-- src2.txt
#        `-- src3.txt
</pre> <p>If <code>src</code> and <code>dest</code> are both paths to directories, creates links <code>dest/src</code> and descendents pointing to <code>src</code> and its descendents:</p> <pre class="ruby" data-language="ruby">tree('src1')
# =&gt; src1
#    |-- sub0
#    |   |-- src0.txt
#    |   `-- src1.txt
#    `-- sub1
#        |-- src2.txt
#        `-- src3.txt
FileUtils.mkdir('dest1')
FileUtils.cp_lr('src1', 'dest1')
tree('dest1')
# =&gt; dest1
#    `-- src1
#        |-- sub0
#        |   |-- src0.txt
#        |   `-- src1.txt
#        `-- sub1
#            |-- src2.txt
#            `-- src3.txt
</pre> <p>If <code>src</code> is an array of paths to entries and <code>dest</code> is the path to a directory, for each path <code>filepath</code> in <code>src</code>, creates a link at <code>dest/filepath</code> pointing to that path:</p> <pre class="ruby" data-language="ruby">tree('src2')
# =&gt; src2
#    |-- sub0
#    |   |-- src0.txt
#    |   `-- src1.txt
#    `-- sub1
#        |-- src2.txt
#        `-- src3.txt
FileUtils.mkdir('dest2')
FileUtils.cp_lr(['src2/sub0', 'src2/sub1'], 'dest2')
tree('dest2')
# =&gt; dest2
#    |-- sub0
#    |   |-- src0.txt
#    |   `-- src1.txt
#    `-- sub1
#        |-- src2.txt
#        `-- src3.txt
</pre> <p>Keyword arguments:</p> <ul>
<li> <p><code>dereference_root: false</code> - if <code>src</code> is a symbolic link, does not dereference it.</p> </li>
<li> <p><code>noop: true</code> - does not create links.</p> </li>
<li> <p><code>remove_destination: true</code> - removes <code>dest</code> before creating links.</p> </li>
<li> <p><code>verbose: true</code> - prints an equivalent command:</p> <pre class="ruby" data-language="ruby">FileUtils.cp_lr('src0', 'dest0', noop: true, verbose: true)
FileUtils.cp_lr('src1', 'dest1', noop: true, verbose: true)
FileUtils.cp_lr(['src2/sub0', 'src2/sub1'], 'dest2', noop: true, verbose: true)
</pre> <p>Output:</p> <pre>cp -lr src0 dest0
cp -lr src1 dest1
cp -lr src2/sub0 src2/sub1 dest2</pre> </li>
</ul> <p>Raises an exception if <code>dest</code> is the path to an existing file or directory and keyword argument <code>remove_destination: true</code> is not given.</p> <p>Related: <a href="fileutils.html#module-FileUtils-label-Copying">methods for copying</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-cp_r"> <a href="#method-c-cp_r" title="Link to this method"> <span class="method-name">cp_r</span> <span class="method-args">(src, dest, preserve: nil, noop: nil, verbose: nil, dereference_root: true, remove_destination: nil)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="cp_r-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 986
def cp_r(src, dest, preserve: nil, noop: nil, verbose: nil,
         dereference_root: true, remove_destination: nil)
  fu_output_message "cp -r#{preserve ? 'p' : ''}#{remove_destination ? ' --remove-destination' : ''} #{[src,dest].flatten.join ' '}" if verbose
  return if noop
  fu_each_src_dest(src, dest) do |s, d|
    copy_entry s, d, preserve, dereference_root, remove_destination
  end
end</pre> </div>  <p>Recursively copies files.</p> <p>Arguments <code>src</code> (a single path or an array of paths) and <code>dest</code> (a single path) should be <a href="fileutils.html#module-FileUtils-label-Path+Arguments">interpretable as paths</a>.</p> <p>The mode, owner, and group are retained in the copy; to change those, use <a href="fileutils.html#method-c-install"><code>FileUtils.install</code></a> instead.</p> <p>If <code>src</code> is the path to a file and <code>dest</code> is not the path to a directory, copies <code>src</code> to <code>dest</code>:</p> <pre class="ruby" data-language="ruby">FileUtils.touch('src0.txt')
File.exist?('dest0.txt') # =&gt; false
FileUtils.cp_r('src0.txt', 'dest0.txt')
File.file?('dest0.txt')  # =&gt; true
</pre> <p>If <code>src</code> is the path to a file and <code>dest</code> is the path to a directory, copies <code>src</code> to <code>dest/src</code>:</p> <pre class="ruby" data-language="ruby">FileUtils.touch('src1.txt')
FileUtils.mkdir('dest1')
FileUtils.cp_r('src1.txt', 'dest1')
File.file?('dest1/src1.txt') # =&gt; true
</pre> <p>If <code>src</code> is the path to a directory and <code>dest</code> does not exist, recursively copies <code>src</code> to <code>dest</code>:</p> <pre class="ruby" data-language="ruby">tree('src2')
# =&gt; src2
#    |-- dir0
#    |   |-- src0.txt
#    |   `-- src1.txt
#    `-- dir1
#    |-- src2.txt
#    `-- src3.txt
FileUtils.exist?('dest2') # =&gt; false
FileUtils.cp_r('src2', 'dest2')
tree('dest2')
# =&gt; dest2
#    |-- dir0
#    |   |-- src0.txt
#    |   `-- src1.txt
#    `-- dir1
#    |-- src2.txt
#    `-- src3.txt
</pre> <p>If <code>src</code> and <code>dest</code> are paths to directories, recursively copies <code>src</code> to <code>dest/src</code>:</p> <pre class="ruby" data-language="ruby">tree('src3')
# =&gt; src3
#    |-- dir0
#    |   |-- src0.txt
#    |   `-- src1.txt
#    `-- dir1
#    |-- src2.txt
#    `-- src3.txt
FileUtils.mkdir('dest3')
FileUtils.cp_r('src3', 'dest3')
tree('dest3')
# =&gt; dest3
#    `-- src3
#      |-- dir0
#      |   |-- src0.txt
#      |   `-- src1.txt
#      `-- dir1
#          |-- src2.txt
#          `-- src3.txt
</pre> <p>If <code>src</code> is an array of paths and <code>dest</code> is a directory, recursively copies from each path in <code>src</code> to <code>dest</code>; the paths in <code>src</code> may point to files and/or directories.</p> <p>Keyword arguments:</p> <ul>
<li> <p><code>dereference_root: false</code> - if <code>src</code> is a symbolic link, does not dereference it.</p> </li>
<li> <p><code>noop: true</code> - does not copy files.</p> </li>
<li> <p><code>preserve: true</code> - preserves file times.</p> </li>
<li> <p><code>remove_destination: true</code> - removes <code>dest</code> before copying files.</p> </li>
<li> <p><code>verbose: true</code> - prints an equivalent command:</p> <pre class="ruby" data-language="ruby">FileUtils.cp_r('src0.txt', 'dest0.txt', noop: true, verbose: true)
FileUtils.cp_r('src1.txt', 'dest1', noop: true, verbose: true)
FileUtils.cp_r('src2', 'dest2', noop: true, verbose: true)
FileUtils.cp_r('src3', 'dest3', noop: true, verbose: true)
</pre> <p>Output:</p> <pre>cp -r src0.txt dest0.txt
cp -r src1.txt dest1
cp -r src2 dest2
cp -r src3 dest3</pre> </li>
</ul> <p>Raises an exception of <code>src</code> is the path to a directory and <code>dest</code> is the path to a file.</p> <p>Related: <a href="fileutils.html#module-FileUtils-label-Copying">methods for copying</a>.</p> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-c-getwd"> <a href="#method-c-getwd" title="Link to this method"> <span class="method-name">getwd</span> <span class="method-args">()</span> </a> </div> </div>  <div class="aliases"> Alias for: <a href="fileutils.html#method-i-pwd">pwd</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-have_option-3F"> <a href="#method-c-have_option-3F" title="Link to this method"> <span class="method-name">have_option?</span> <span class="method-args">(mid, opt)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="have_option-3F-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 2590
def self.have_option?(mid, opt)
  li = OPT_TABLE[mid.to_s] or raise ArgumentError, "no such method: #{mid}"
  li.include?(opt)
end</pre> </div>  <p>Returns <code>true</code> if method <code>mid</code> accepts the given option <code>opt</code>, <code>false</code> otherwise; the arguments may be strings or symbols:</p> <pre class="ruby" data-language="ruby">FileUtils.have_option?(:chmod, :noop) # =&gt; true
FileUtils.have_option?('chmod', 'secure') # =&gt; false
</pre> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-c-identical-3F"> <a href="#method-c-identical-3F" title="Link to this method"> <span class="method-name">identical?</span> <span class="method-args">(a, b)</span> </a> </div> </div>  <div class="aliases"> Alias for: <a href="fileutils.html#method-i-compare_file">compare_file</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-install"> <a href="#method-c-install" title="Link to this method"> <span class="method-name">install</span> <span class="method-args">(src, dest, mode: nil, owner: nil, group: nil, preserve: nil, noop: nil, verbose: nil)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="install-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 1610
def install(src, dest, mode: nil, owner: nil, group: nil, preserve: nil,
            noop: nil, verbose: nil)
  if verbose
    msg = +"install -c"
    msg &lt;&lt; ' -p' if preserve
    msg &lt;&lt; ' -m ' &lt;&lt; mode_to_s(mode) if mode
    msg &lt;&lt; " -o #{owner}" if owner
    msg &lt;&lt; " -g #{group}" if group
    msg &lt;&lt; ' ' &lt;&lt; [src,dest].flatten.join(' ')
    fu_output_message msg
  end
  return if noop
  uid = fu_get_uid(owner)
  gid = fu_get_gid(group)
  fu_each_src_dest(src, dest) do |s, d|
    st = File.stat(s)
    unless File.exist?(d) and compare_file(s, d)
      remove_file d, true
      if d.end_with?('/')
        mkdir_p d
        copy_file s, d + File.basename(s)
      else
        mkdir_p File.expand_path('..', d)
        copy_file s, d
      end
      File.utime st.atime, st.mtime, d if preserve
      File.chmod fu_mode(mode, st), d if mode
      File.chown uid, gid, d if uid or gid
    end
  end
end</pre> </div>  <p>Copies a file entry. See <a href="https://man7.org/linux/man-pages/man1/install.1.html">install(1)</a>.</p> <p>Arguments <code>src</code> (a single path or an array of paths) and <code>dest</code> (a single path) should be <a href="fileutils.html#module-FileUtils-label-Path+Arguments">interpretable as paths</a>;</p> <p>If the entry at <code>dest</code> does not exist, copies from <code>src</code> to <code>dest</code>:</p> <pre class="ruby" data-language="ruby">File.read('src0.txt')    # =&gt; "aaa\n"
File.exist?('dest0.txt') # =&gt; false
FileUtils.install('src0.txt', 'dest0.txt')
File.read('dest0.txt')   # =&gt; "aaa\n"
</pre> <p>If <code>dest</code> is a file entry, copies from <code>src</code> to <code>dest</code>, overwriting:</p> <pre class="ruby" data-language="ruby">File.read('src1.txt')  # =&gt; "aaa\n"
File.read('dest1.txt') # =&gt; "bbb\n"
FileUtils.install('src1.txt', 'dest1.txt')
File.read('dest1.txt') # =&gt; "aaa\n"
</pre> <p>If <code>dest</code> is a directory entry, copies from <code>src</code> to <code>dest/src</code>, overwriting if necessary:</p> <pre class="ruby" data-language="ruby">File.read('src2.txt')       # =&gt; "aaa\n"
File.read('dest2/src2.txt') # =&gt; "bbb\n"
FileUtils.install('src2.txt', 'dest2')
File.read('dest2/src2.txt') # =&gt; "aaa\n"
</pre> <p>If <code>src</code> is an array of paths and <code>dest</code> points to a directory, copies each path <code>path</code> in <code>src</code> to <code>dest/path</code>:</p> <pre class="ruby" data-language="ruby">File.file?('src3.txt') # =&gt; true
File.file?('src3.dat') # =&gt; true
FileUtils.mkdir('dest3')
FileUtils.install(['src3.txt', 'src3.dat'], 'dest3')
File.file?('dest3/src3.txt') # =&gt; true
File.file?('dest3/src3.dat') # =&gt; true
</pre> <p>Keyword arguments:</p> <ul>
<li> <p><code>group: <em>group</em></code> - changes the group if not <code>nil</code>, using <a href="file.html#method-c-chown"><code>File.chown</code></a>.</p> </li>
<li> <p><code>mode: <em>permissions</em></code> - changes the permissions. using <a href="file.html#method-c-chmod"><code>File.chmod</code></a>.</p> </li>
<li> <p><code>noop: true</code> - does not copy entries; returns <code>nil</code>.</p> </li>
<li> <p><code>owner: <em>owner</em></code> - changes the owner if not <code>nil</code>, using <a href="file.html#method-c-chown"><code>File.chown</code></a>.</p> </li>
<li> <p><code>preserve: true</code> - preserve timestamps using <a href="file.html#method-c-utime"><code>File.utime</code></a>.</p> </li>
<li> <p><code>verbose: true</code> - prints an equivalent command:</p> <pre class="ruby" data-language="ruby">FileUtils.install('src0.txt', 'dest0.txt', noop: true, verbose: true)
FileUtils.install('src1.txt', 'dest1.txt', noop: true, verbose: true)
FileUtils.install('src2.txt', 'dest2', noop: true, verbose: true)
</pre> <p>Output:</p> <pre>install -c src0.txt dest0.txt
install -c src1.txt dest1.txt
install -c src2.txt dest2</pre> </li>
</ul> <p>Related: <a href="fileutils.html#module-FileUtils-label-Copying">methods for copying</a>.</p> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-c-link"> <a href="#method-c-link" title="Link to this method"> <span class="method-name">link</span> <span class="method-args">(src, dest, force: nil, noop: nil, verbose: nil)</span> </a> </div> </div>  <div class="aliases"> Alias for: <a href="fileutils.html#method-i-ln">ln</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-link_entry"> <a href="#method-c-link_entry" title="Link to this method"> <span class="method-name">link_entry</span> <span class="method-args">(src, dest, dereference_root = false, remove_destination = false)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="link_entry-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 813
def link_entry(src, dest, dereference_root = false, remove_destination = false)
  Entry_.new(src, nil, dereference_root).traverse do |ent|
    destent = Entry_.new(dest, ent.rel, false)
    File.unlink destent.path if remove_destination &amp;&amp; File.file?(destent.path)
    ent.link destent.path
  end
end</pre> </div>  <p>Creates <a href="https://en.wikipedia.org/wiki/Hard_link">hard links</a>; returns <code>nil</code>.</p> <p>Arguments <code>src</code> and <code>dest</code> should be <a href="fileutils.html#module-FileUtils-label-Path+Arguments">interpretable as paths</a>.</p> <p>If <code>src</code> is the path to a file and <code>dest</code> does not exist, creates a hard link at <code>dest</code> pointing to <code>src</code>:</p> <pre class="ruby" data-language="ruby">FileUtils.touch('src0.txt')
File.exist?('dest0.txt') # =&gt; false
FileUtils.link_entry('src0.txt', 'dest0.txt')
File.file?('dest0.txt')  # =&gt; true
</pre> <p>If <code>src</code> is the path to a directory and <code>dest</code> does not exist, recursively creates hard links at <code>dest</code> pointing to paths in <code>src</code>:</p> <pre class="ruby" data-language="ruby">FileUtils.mkdir_p(['src1/dir0', 'src1/dir1'])
src_file_paths = [
  'src1/dir0/t0.txt',
  'src1/dir0/t1.txt',
  'src1/dir1/t2.txt',
  'src1/dir1/t3.txt',
  ]
FileUtils.touch(src_file_paths)
File.directory?('dest1')        # =&gt; true
FileUtils.link_entry('src1', 'dest1')
File.file?('dest1/dir0/t0.txt') # =&gt; true
File.file?('dest1/dir0/t1.txt') # =&gt; true
File.file?('dest1/dir1/t2.txt') # =&gt; true
File.file?('dest1/dir1/t3.txt') # =&gt; true
</pre> <p>Keyword arguments:</p> <ul>
<li> <p><code>dereference_root: true</code> - dereferences <code>src</code> if it is a symbolic link.</p> </li>
<li> <p><code>remove_destination: true</code> - removes <code>dest</code> before creating links.</p> </li>
</ul> <p>Raises an exception if <code>dest</code> is the path to an existing file or directory and keyword argument <code>remove_destination: true</code> is not given.</p> <p>Related: <a href="fileutils.html#method-c-ln"><code>FileUtils.ln</code></a> (has different options).</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-ln"> <a href="#method-c-ln" title="Link to this method"> <span class="method-name">ln</span> <span class="method-args">(src, dest, force: nil, noop: nil, verbose: nil)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="ln-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 517
def ln(src, dest, force: nil, noop: nil, verbose: nil)
  fu_output_message "ln#{force ? ' -f' : ''} #{[src,dest].flatten.join ' '}" if verbose
  return if noop
  fu_each_src_dest0(src, dest) do |s,d|
    remove_file d, true if force
    File.link s, d
  end
end</pre> </div>  <p>Creates <a href="https://en.wikipedia.org/wiki/Hard_link">hard links</a>.</p> <p>Arguments <code>src</code> (a single path or an array of paths) and <code>dest</code> (a single path) should be <a href="fileutils.html#module-FileUtils-label-Path+Arguments">interpretable as paths</a>.</p> <p>When <code>src</code> is the path to an existing file and <code>dest</code> is the path to a non-existent file, creates a hard link at <code>dest</code> pointing to <code>src</code>; returns zero:</p> <pre class="ruby" data-language="ruby">Dir.children('tmp0/')                    # =&gt; ["t.txt"]
Dir.children('tmp1/')                    # =&gt; []
FileUtils.ln('tmp0/t.txt', 'tmp1/t.lnk') # =&gt; 0
Dir.children('tmp1/')                    # =&gt; ["t.lnk"]
</pre> <p>When <code>src</code> is the path to an existing file and <code>dest</code> is the path to an existing directory, creates a hard link at <code>dest/src</code> pointing to <code>src</code>; returns zero:</p> <pre class="ruby" data-language="ruby">Dir.children('tmp2')               # =&gt; ["t.dat"]
Dir.children('tmp3')               # =&gt; []
FileUtils.ln('tmp2/t.dat', 'tmp3') # =&gt; 0
Dir.children('tmp3')               # =&gt; ["t.dat"]
</pre> <p>When <code>src</code> is an array of paths to existing files and <code>dest</code> is the path to an existing directory, then for each path <code>target</code> in <code>src</code>, creates a hard link at <code>dest/target</code> pointing to <code>target</code>; returns <code>src</code>:</p> <pre class="ruby" data-language="ruby">Dir.children('tmp4/')                               # =&gt; []
FileUtils.ln(['tmp0/t.txt', 'tmp2/t.dat'], 'tmp4/') # =&gt; ["tmp0/t.txt", "tmp2/t.dat"]
Dir.children('tmp4/')                               # =&gt; ["t.dat", "t.txt"]
</pre> <p>Keyword arguments:</p> <ul>
<li> <p><code>force: true</code> - overwrites <code>dest</code> if it exists.</p> </li>
<li> <p><code>noop: true</code> - does not create links.</p> </li>
<li> <p><code>verbose: true</code> - prints an equivalent command:</p> <pre class="ruby" data-language="ruby">FileUtils.ln('tmp0/t.txt', 'tmp1/t.lnk', verbose: true)
FileUtils.ln('tmp2/t.dat', 'tmp3', verbose: true)
FileUtils.ln(['tmp0/t.txt', 'tmp2/t.dat'], 'tmp4/', verbose: true)
</pre> <p>Output:</p> <pre>ln tmp0/t.txt tmp1/t.lnk
ln tmp2/t.dat tmp3
ln tmp0/t.txt tmp2/t.dat tmp4/</pre> </li>
</ul> <p>Raises an exception if <code>dest</code> is the path to an existing file and keyword argument <code>force</code> is not <code>true</code>.</p> <p>Related: <a href="fileutils.html#method-c-link_entry"><code>FileUtils.link_entry</code></a> (has different options).</p> </div> <div class="aliases"> Also aliased as: <a href="fileutils.html#method-i-link">link</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-ln_s"> <a href="#method-c-ln_s" title="Link to this method"> <span class="method-name">ln_s</span> <span class="method-args">(src, dest, force: nil, relative: false, target_directory: true, noop: nil, verbose: nil)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="ln_s-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 707
def ln_s(src, dest, force: nil, relative: false, target_directory: true, noop: nil, verbose: nil)
  if relative
    return ln_sr(src, dest, force: force, noop: noop, verbose: verbose)
  end
  fu_output_message "ln -s#{force ? 'f' : ''} #{[src,dest].flatten.join ' '}" if verbose
  return if noop
  fu_each_src_dest0(src, dest) do |s,d|
    remove_file d, true if force
    File.symlink s, d
  end
end</pre> </div>  <p>Creates <a href="https://en.wikipedia.org/wiki/Symbolic_link">symbolic links</a>.</p> <p>Arguments <code>src</code> (a single path or an array of paths) and <code>dest</code> (a single path) should be <a href="fileutils.html#module-FileUtils-label-Path+Arguments">interpretable as paths</a>.</p> <p>If <code>src</code> is the path to an existing file:</p> <ul>
<li> <p>When <code>dest</code> is the path to a non-existent file, creates a symbolic link at <code>dest</code> pointing to <code>src</code>:</p> <pre class="ruby" data-language="ruby">FileUtils.touch('src0.txt')
File.exist?('dest0.txt')   # =&gt; false
FileUtils.ln_s('src0.txt', 'dest0.txt')
File.symlink?('dest0.txt') # =&gt; true
</pre> </li>
<li> <p>When <code>dest</code> is the path to an existing file, creates a symbolic link at <code>dest</code> pointing to <code>src</code> if and only if keyword argument <code>force: true</code> is given (raises an exception otherwise):</p> <pre class="ruby" data-language="ruby">FileUtils.touch('src1.txt')
FileUtils.touch('dest1.txt')
FileUtils.ln_s('src1.txt', 'dest1.txt', force: true)
FileTest.symlink?('dest1.txt') # =&gt; true

FileUtils.ln_s('src1.txt', 'dest1.txt') # Raises Errno::EEXIST.
</pre> </li>
</ul> <p>If <code>dest</code> is the path to a directory, creates a symbolic link at <code>dest/src</code> pointing to <code>src</code>:</p> <pre class="ruby" data-language="ruby">FileUtils.touch('src2.txt')
FileUtils.mkdir('destdir2')
FileUtils.ln_s('src2.txt', 'destdir2')
File.symlink?('destdir2/src2.txt') # =&gt; true
</pre> <p>If <code>src</code> is an array of paths to existing files and <code>dest</code> is a directory, for each child <code>child</code> in <code>src</code> creates a symbolic link <code>dest/child</code> pointing to <code>child</code>:</p> <pre class="ruby" data-language="ruby">FileUtils.mkdir('srcdir3')
FileUtils.touch('srcdir3/src0.txt')
FileUtils.touch('srcdir3/src1.txt')
FileUtils.mkdir('destdir3')
FileUtils.ln_s(['srcdir3/src0.txt', 'srcdir3/src1.txt'], 'destdir3')
File.symlink?('destdir3/src0.txt') # =&gt; true
File.symlink?('destdir3/src1.txt') # =&gt; true
</pre> <p>Keyword arguments:</p> <ul>
<li> <p><code>force: true</code> - overwrites <code>dest</code> if it exists.</p> </li>
<li> <p><code>relative: false</code> - create links relative to <code>dest</code>.</p> </li>
<li> <p><code>noop: true</code> - does not create links.</p> </li>
<li> <p><code>verbose: true</code> - prints an equivalent command:</p> <pre class="ruby" data-language="ruby">FileUtils.ln_s('src0.txt', 'dest0.txt', noop: true, verbose: true)
FileUtils.ln_s('src1.txt', 'destdir1', noop: true, verbose: true)
FileUtils.ln_s('src2.txt', 'dest2.txt', force: true, noop: true, verbose: true)
FileUtils.ln_s(['srcdir3/src0.txt', 'srcdir3/src1.txt'], 'destdir3', noop: true, verbose: true)
</pre> <p>Output:</p> <pre>ln -s src0.txt dest0.txt
ln -s src1.txt destdir1
ln -sf src2.txt dest2.txt
ln -s srcdir3/src0.txt srcdir3/src1.txt destdir3</pre> </li>
</ul> <p>Related: <a href="fileutils.html#method-c-ln_sf"><code>FileUtils.ln_sf</code></a>.</p> </div> <div class="aliases"> Also aliased as: <a href="fileutils.html#method-i-symlink">symlink</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-ln_sf"> <a href="#method-c-ln_sf" title="Link to this method"> <span class="method-name">ln_sf</span> <span class="method-args">(src, dest, noop: nil, verbose: nil)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="ln_sf-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 725
def ln_sf(src, dest, noop: nil, verbose: nil)
  ln_s src, dest, force: true, noop: noop, verbose: verbose
end</pre> </div>  <p>Like <a href="fileutils.html#method-c-ln_s"><code>FileUtils.ln_s</code></a>, but always with keyword argument <code>force: true</code> given.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-ln_sr"> <a href="#method-c-ln_sr" title="Link to this method"> <span class="method-name">ln_sr</span> <span class="method-args">(src, dest, target_directory: true, force: nil, noop: nil, verbose: nil)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="ln_sr-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 732
def ln_sr(src, dest, target_directory: true, force: nil, noop: nil, verbose: nil)
  options = "#{force ? 'f' : ''}#{target_directory ? '' : 'T'}"
  dest = File.path(dest)
  srcs = Array(src)
  link = proc do |s, target_dir_p = true|
    s = File.path(s)
    if target_dir_p
      d = File.join(destdirs = dest, File.basename(s))
    else
      destdirs = File.dirname(d = dest)
    end
    destdirs = fu_split_path(File.realpath(destdirs))
    if fu_starting_path?(s)
      srcdirs = fu_split_path((File.realdirpath(s) rescue File.expand_path(s)))
      base = fu_relative_components_from(srcdirs, destdirs)
      s = File.join(*base)
    else
      srcdirs = fu_clean_components(*fu_split_path(s))
      base = fu_relative_components_from(fu_split_path(Dir.pwd), destdirs)
      while srcdirs.first&amp;. == ".." and base.last&amp;.!=("..") and !fu_starting_path?(base.last)
        srcdirs.shift
        base.pop
      end
      s = File.join(*base, *srcdirs)
    end
    fu_output_message "ln -s#{options} #{s} #{d}" if verbose
    next if noop
    remove_file d, true if force
    File.symlink s, d
  end
  case srcs.size
  when 0
  when 1
    link[srcs[0], target_directory &amp;&amp; File.directory?(dest)]
  else
    srcs.each(&amp;link)
  end
end</pre> </div>  <p>Like <a href="fileutils.html#method-c-ln_s"><code>FileUtils.ln_s</code></a>, but create links relative to <code>dest</code>.</p> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-c-makedirs"> <a href="#method-c-makedirs" title="Link to this method"> <span class="method-name">makedirs</span> <span class="method-args">(list, mode: nil, noop: nil, verbose: nil)</span> </a> </div> </div>  <div class="aliases"> Alias for: <a href="fileutils.html#method-i-mkdir_p">mkdir_p</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-mkdir"> <a href="#method-c-mkdir" title="Link to this method"> <span class="method-name">mkdir</span> <span class="method-args">(list, mode: nil, noop: nil, verbose: nil)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="mkdir-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 317
def mkdir(list, mode: nil, noop: nil, verbose: nil)
  list = fu_list(list)
  fu_output_message "mkdir #{mode ? ('-m %03o ' % mode) : ''}#{list.join ' '}" if verbose
  return if noop

  list.each do |dir|
    fu_mkdir dir, mode
  end
end</pre> </div>  <p>Creates directories at the paths in the given <code>list</code> (a single path or an array of paths); returns <code>list</code> if it is an array, <code>[list]</code> otherwise.</p> <p>Argument <code>list</code> or its elements should be <a href="fileutils.html#module-FileUtils-label-Path+Arguments">interpretable as paths</a>.</p> <p>With no keyword arguments, creates a directory at each <code>path</code> in <code>list</code> by calling: <a href="dir.html#method-c-mkdir"><code>Dir.mkdir(path, mode)</code></a>; see <a href="dir.html#method-c-mkdir"><code>Dir.mkdir</code></a>:</p> <pre class="ruby" data-language="ruby">FileUtils.mkdir(%w[tmp0 tmp1]) # =&gt; ["tmp0", "tmp1"]
FileUtils.mkdir('tmp4')        # =&gt; ["tmp4"]
</pre> <p>Keyword arguments:</p> <ul>
<li> <p><code>mode: <em>mode</em></code> - also calls <a href="file.html#method-c-chmod"><code>File.chmod(mode, path)</code></a>; see <a href="file.html#method-c-chmod"><code>File.chmod</code></a>.</p> </li>
<li> <p><code>noop: true</code> - does not create directories.</p> </li>
<li> <p><code>verbose: true</code> - prints an equivalent command:</p> <pre class="ruby" data-language="ruby">FileUtils.mkdir(%w[tmp0 tmp1], verbose: true)
FileUtils.mkdir(%w[tmp2 tmp3], mode: 0700, verbose: true)
</pre> <p>Output:</p> <pre>mkdir tmp0 tmp1
mkdir -m 700 tmp2 tmp3</pre> </li>
</ul> <p>Raises an exception if any path points to an existing file or directory, or if for any reason a directory cannot be created.</p> <p>Related: <a href="fileutils.html#method-c-mkdir_p"><code>FileUtils.mkdir_p</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-mkdir_p"> <a href="#method-c-mkdir_p" title="Link to this method"> <span class="method-name">mkdir_p</span> <span class="method-args">(list, mode: nil, noop: nil, verbose: nil)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="mkdir_p-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 366
def mkdir_p(list, mode: nil, noop: nil, verbose: nil)
  list = fu_list(list)
  fu_output_message "mkdir -p #{mode ? ('-m %03o ' % mode) : ''}#{list.join ' '}" if verbose
  return *list if noop

  list.each do |item|
    path = remove_trailing_slash(item)

    stack = []
    until File.directory?(path) || File.dirname(path) == path
      stack.push path
      path = File.dirname(path)
    end
    stack.reverse_each do |dir|
      begin
        fu_mkdir dir, mode
      rescue SystemCallError
        raise unless File.directory?(dir)
      end
    end
  end

  return *list
end</pre> </div>  <p>Creates directories at the paths in the given <code>list</code> (a single path or an array of paths), also creating ancestor directories as needed; returns <code>list</code> if it is an array, <code>[list]</code> otherwise.</p> <p>Argument <code>list</code> or its elements should be <a href="fileutils.html#module-FileUtils-label-Path+Arguments">interpretable as paths</a>.</p> <p>With no keyword arguments, creates a directory at each <code>path</code> in <code>list</code>, along with any needed ancestor directories, by calling: <a href="dir.html#method-c-mkdir"><code>Dir.mkdir(path, mode)</code></a>; see <a href="dir.html#method-c-mkdir"><code>Dir.mkdir</code></a>:</p> <pre class="ruby" data-language="ruby">FileUtils.mkdir_p(%w[tmp0/tmp1 tmp2/tmp3]) # =&gt; ["tmp0/tmp1", "tmp2/tmp3"]
FileUtils.mkdir_p('tmp4/tmp5')             # =&gt; ["tmp4/tmp5"]
</pre> <p>Keyword arguments:</p> <ul>
<li> <p><code>mode: <em>mode</em></code> - also calls <a href="file.html#method-c-chmod"><code>File.chmod(mode, path)</code></a>; see <a href="file.html#method-c-chmod"><code>File.chmod</code></a>.</p> </li>
<li> <p><code>noop: true</code> - does not create directories.</p> </li>
<li> <p><code>verbose: true</code> - prints an equivalent command:</p> <pre class="ruby" data-language="ruby">FileUtils.mkdir_p(%w[tmp0 tmp1], verbose: true)
FileUtils.mkdir_p(%w[tmp2 tmp3], mode: 0700, verbose: true)
</pre> <p>Output:</p> <pre>mkdir -p tmp0 tmp1
mkdir -p -m 700 tmp2 tmp3</pre> </li>
</ul> <p>Raises an exception if for any reason a directory cannot be created.</p> <p><a href="fileutils.html#method-c-mkpath"><code>FileUtils.mkpath</code></a> and <a href="fileutils.html#method-c-makedirs"><code>FileUtils.makedirs</code></a> are aliases for <a href="fileutils.html#method-c-mkdir_p"><code>FileUtils.mkdir_p</code></a>.</p> <p>Related: <a href="fileutils.html#method-c-mkdir"><code>FileUtils.mkdir</code></a>.</p> </div> <div class="aliases"> Also aliased as: <a href="fileutils.html#method-i-mkpath">mkpath</a>, <a href="fileutils.html#method-i-makedirs">makedirs</a> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-c-mkpath"> <a href="#method-c-mkpath" title="Link to this method"> <span class="method-name">mkpath</span> <span class="method-args">(list, mode: nil, noop: nil, verbose: nil)</span> </a> </div> </div>  <div class="aliases"> Alias for: <a href="fileutils.html#method-i-mkdir_p">mkdir_p</a> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-c-move"> <a href="#method-c-move" title="Link to this method"> <span class="method-name">move</span> <span class="method-args">(src, dest, force: nil, noop: nil, verbose: nil, secure: nil)</span> </a> </div> </div>  <div class="aliases"> Alias for: <a href="fileutils.html#method-i-mv">mv</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-mv"> <a href="#method-c-mv" title="Link to this method"> <span class="method-name">mv</span> <span class="method-args">(src, dest, force: nil, noop: nil, verbose: nil, secure: nil)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="mv-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 1158
def mv(src, dest, force: nil, noop: nil, verbose: nil, secure: nil)
  fu_output_message "mv#{force ? ' -f' : ''} #{[src,dest].flatten.join ' '}" if verbose
  return if noop
  fu_each_src_dest(src, dest) do |s, d|
    destent = Entry_.new(d, nil, true)
    begin
      if destent.exist?
        if destent.directory?
          raise Errno::EEXIST, d
        end
      end
      begin
        File.rename s, d
      rescue Errno::EXDEV,
             Errno::EPERM # move from unencrypted to encrypted dir (ext4)
        copy_entry s, d, true
        if secure
          remove_entry_secure s, force
        else
          remove_entry s, force
        end
      end
    rescue SystemCallError
      raise unless force
    end
  end
end</pre> </div>  <p>Moves entries.</p> <p>Arguments <code>src</code> (a single path or an array of paths) and <code>dest</code> (a single path) should be <a href="fileutils.html#module-FileUtils-label-Path+Arguments">interpretable as paths</a>.</p> <p>If <code>src</code> and <code>dest</code> are on different file systems, first copies, then removes <code>src</code>.</p> <p>May cause a local vulnerability if not called with keyword argument <code>secure: true</code>; see <a href="fileutils.html#module-FileUtils-label-Avoiding+the+TOCTTOU+Vulnerability">Avoiding the TOCTTOU Vulnerability</a>.</p> <p>If <code>src</code> is the path to a single file or directory and <code>dest</code> does not exist, moves <code>src</code> to <code>dest</code>:</p> <pre class="ruby" data-language="ruby">tree('src0')
# =&gt; src0
#    |-- src0.txt
#    `-- src1.txt
File.exist?('dest0') # =&gt; false
FileUtils.mv('src0', 'dest0')
File.exist?('src0')  # =&gt; false
tree('dest0')
# =&gt; dest0
#    |-- src0.txt
#    `-- src1.txt
</pre> <p>If <code>src</code> is an array of paths to files and directories and <code>dest</code> is the path to a directory, copies from each path in the array to <code>dest</code>:</p> <pre class="ruby" data-language="ruby">File.file?('src1.txt') # =&gt; true
tree('src1')
# =&gt; src1
#    |-- src.dat
#    `-- src.txt
Dir.empty?('dest1')    # =&gt; true
FileUtils.mv(['src1.txt', 'src1'], 'dest1')
tree('dest1')
# =&gt; dest1
#    |-- src1
#    |   |-- src.dat
#    |   `-- src.txt
#    `-- src1.txt
</pre> <p>Keyword arguments:</p> <ul>
<li> <p><code>force: true</code> - if the move includes removing <code>src</code> (that is, if <code>src</code> and <code>dest</code> are on different file systems), ignores raised exceptions of <a href="standarderror.html"><code>StandardError</code></a> and its descendants.</p> </li>
<li> <p><code>noop: true</code> - does not move files.</p> </li>
<li> <p><code>secure: true</code> - removes <code>src</code> securely; see details at <a href="fileutils.html#method-c-remove_entry_secure"><code>FileUtils.remove_entry_secure</code></a>.</p> </li>
<li> <p><code>verbose: true</code> - prints an equivalent command:</p> <pre class="ruby" data-language="ruby">FileUtils.mv('src0', 'dest0', noop: true, verbose: true)
FileUtils.mv(['src1.txt', 'src1'], 'dest1', noop: true, verbose: true)
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">mv src0 dest0
mv src1.txt src1 dest1
</pre> </li>
</ul> </div> <div class="aliases"> Also aliased as: <a href="fileutils.html#method-i-move">move</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-options"> <a href="#method-c-options" title="Link to this method"> <span class="method-name">options</span> <span class="method-args">()</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="options-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 2580
def self.options
  OPT_TABLE.values.flatten.uniq.map {|sym| sym.to_s }
end</pre> </div>  <p>Returns an array of the string keyword names:</p> <pre class="ruby" data-language="ruby">FileUtils.options.take(3) # =&gt; ["noop", "verbose", "force"]
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-options_of"> <a href="#method-c-options_of" title="Link to this method"> <span class="method-name">options_of</span> <span class="method-args">(mid)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="options_of-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 2601
def self.options_of(mid)
  OPT_TABLE[mid.to_s].map {|sym| sym.to_s }
end</pre> </div>  <p>Returns an array of the string keyword name for method <code>mid</code>; the argument may be a string or a symbol:</p> <pre class="ruby" data-language="ruby">FileUtils.options_of(:rm) # =&gt; ["force", "noop", "verbose"]
FileUtils.options_of('mv') # =&gt; ["force", "noop", "verbose", "secure"]
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-pwd"> <a href="#method-c-pwd" title="Link to this method"> <span class="method-name">pwd</span> <span class="method-args">()</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="pwd-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 198
def pwd
  Dir.pwd
end</pre> </div>  <p>Returns a string containing the path to the current directory:</p> <pre class="ruby" data-language="ruby">FileUtils.pwd # =&gt; "/rdoc/fileutils"
</pre> <p>Related: <a href="fileutils.html#method-c-cd"><code>FileUtils.cd</code></a>.</p> </div> <div class="aliases"> Also aliased as: <a href="fileutils.html#method-i-getwd">getwd</a> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-c-remove"> <a href="#method-c-remove" title="Link to this method"> <span class="method-name">remove</span> <span class="method-args">(list, force: nil, noop: nil, verbose: nil)</span> </a> </div> </div>  <div class="aliases"> Alias for: <a href="fileutils.html#method-i-rm">rm</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-remove_dir"> <a href="#method-c-remove_dir" title="Link to this method"> <span class="method-name">remove_dir</span> <span class="method-args">(path, force = false)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="remove_dir-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 1493
def remove_dir(path, force = false)
  remove_entry path, force   # FIXME?? check if it is a directory
end</pre> </div>  <p>Recursively removes the directory entry given by <code>path</code>, which should be the entry for a regular file, a symbolic link, or a directory.</p> <p>Argument <code>path</code> should be <a href="fileutils.html#module-FileUtils-label-Path+Arguments">interpretable as a path</a>.</p> <p>Optional argument <code>force</code> specifies whether to ignore raised exceptions of <a href="standarderror.html"><code>StandardError</code></a> and its descendants.</p> <p>Related: <a href="fileutils.html#module-FileUtils-label-Deleting">methods for deleting</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-remove_entry"> <a href="#method-c-remove_entry" title="Link to this method"> <span class="method-name">remove_entry</span> <span class="method-args">(path, force = false)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="remove_entry-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 1450
def remove_entry(path, force = false)
  Entry_.new(path).postorder_traverse do |ent|
    begin
      ent.remove
    rescue
      raise unless force
    end
  end
rescue
  raise unless force
end</pre> </div>  <p>Removes the entry given by <code>path</code>, which should be the entry for a regular file, a symbolic link, or a directory.</p> <p>Argument <code>path</code> should be <a href="fileutils.html#module-FileUtils-label-Path+Arguments">interpretable as a path</a>.</p> <p>Optional argument <code>force</code> specifies whether to ignore raised exceptions of <a href="standarderror.html"><code>StandardError</code></a> and its descendants.</p> <p>Related: <a href="fileutils.html#method-c-remove_entry_secure"><code>FileUtils.remove_entry_secure</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-remove_entry_secure"> <a href="#method-c-remove_entry_secure" title="Link to this method"> <span class="method-name">remove_entry_secure</span> <span class="method-args">(path, force = false)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="remove_entry_secure-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 1352
def remove_entry_secure(path, force = false)
  unless fu_have_symlink?
    remove_entry path, force
    return
  end
  fullpath = File.expand_path(path)
  st = File.lstat(fullpath)
  unless st.directory?
    File.unlink fullpath
    return
  end
  # is a directory.
  parent_st = File.stat(File.dirname(fullpath))
  unless parent_st.world_writable?
    remove_entry path, force
    return
  end
  unless parent_st.sticky?
    raise ArgumentError, "parent directory is world writable, FileUtils#remove_entry_secure does not work; abort: #{path.inspect} (parent directory mode #{'%o' % parent_st.mode})"
  end

  # freeze tree root
  euid = Process.euid
  dot_file = fullpath + "/."
  begin
    File.open(dot_file) {|f|
      unless fu_stat_identical_entry?(st, f.stat)
        # symlink (TOC-to-TOU attack?)
        File.unlink fullpath
        return
      end
      f.chown euid, -1
      f.chmod 0700
    }
  rescue Errno::EISDIR # JRuby in non-native mode can't open files as dirs
    File.lstat(dot_file).tap {|fstat|
      unless fu_stat_identical_entry?(st, fstat)
        # symlink (TOC-to-TOU attack?)
        File.unlink fullpath
        return
      end
      File.chown euid, -1, dot_file
      File.chmod 0700, dot_file
    }
  end

  unless fu_stat_identical_entry?(st, File.lstat(fullpath))
    # TOC-to-TOU attack?
    File.unlink fullpath
    return
  end

  # ---- tree root is frozen ----
  root = Entry_.new(path)
  root.preorder_traverse do |ent|
    if ent.directory?
      ent.chown euid, -1
      ent.chmod 0700
    end
  end
  root.postorder_traverse do |ent|
    begin
      ent.remove
    rescue
      raise unless force
    end
  end
rescue
  raise unless force
end</pre> </div>  <p>Securely removes the entry given by <code>path</code>, which should be the entry for a regular file, a symbolic link, or a directory.</p> <p>Argument <code>path</code> should be <a href="fileutils.html#module-FileUtils-label-Path+Arguments">interpretable as a path</a>.</p> <p>Avoids a local vulnerability that can exist in certain circumstances; see <a href="fileutils.html#module-FileUtils-label-Avoiding+the+TOCTTOU+Vulnerability">Avoiding the TOCTTOU Vulnerability</a>.</p> <p>Optional argument <code>force</code> specifies whether to ignore raised exceptions of <a href="standarderror.html"><code>StandardError</code></a> and its descendants.</p> <p>Related: <a href="fileutils.html#module-FileUtils-label-Deleting">methods for deleting</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-remove_file"> <a href="#method-c-remove_file" title="Link to this method"> <span class="method-name">remove_file</span> <span class="method-args">(path, force = false)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="remove_file-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 1474
def remove_file(path, force = false)
  Entry_.new(path).remove_file
rescue
  raise unless force
end</pre> </div>  <p>Removes the file entry given by <code>path</code>, which should be the entry for a regular file or a symbolic link.</p> <p>Argument <code>path</code> should be <a href="fileutils.html#module-FileUtils-label-Path+Arguments">interpretable as a path</a>.</p> <p>Optional argument <code>force</code> specifies whether to ignore raised exceptions of <a href="standarderror.html"><code>StandardError</code></a> and its descendants.</p> <p>Related: <a href="fileutils.html#module-FileUtils-label-Deleting">methods for deleting</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-rm"> <a href="#method-c-rm" title="Link to this method"> <span class="method-name">rm</span> <span class="method-args">(list, force: nil, noop: nil, verbose: nil)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="rm-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 1217
def rm(list, force: nil, noop: nil, verbose: nil)
  list = fu_list(list)
  fu_output_message "rm#{force ? ' -f' : ''} #{list.join ' '}" if verbose
  return if noop

  list.each do |path|
    remove_file path, force
  end
end</pre> </div>  <p>Removes entries at the paths in the given <code>list</code> (a single path or an array of paths) returns <code>list</code>, if it is an array, <code>[list]</code> otherwise.</p> <p>Argument <code>list</code> or its elements should be <a href="fileutils.html#module-FileUtils-label-Path+Arguments">interpretable as paths</a>.</p> <p>With no keyword arguments, removes files at the paths given in <code>list</code>:</p> <pre class="ruby" data-language="ruby">FileUtils.touch(['src0.txt', 'src0.dat'])
FileUtils.rm(['src0.dat', 'src0.txt']) # =&gt; ["src0.dat", "src0.txt"]
</pre> <p>Keyword arguments:</p> <ul>
<li> <p><code>force: true</code> - ignores raised exceptions of <a href="standarderror.html"><code>StandardError</code></a> and its descendants.</p> </li>
<li> <p><code>noop: true</code> - does not remove files; returns <code>nil</code>.</p> </li>
<li> <p><code>verbose: true</code> - prints an equivalent command:</p> <pre class="ruby" data-language="ruby">FileUtils.rm(['src0.dat', 'src0.txt'], noop: true, verbose: true)
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">rm src0.dat src0.txt
</pre> </li>
</ul> <p>Related: <a href="fileutils.html#module-FileUtils-label-Deleting">methods for deleting</a>.</p> </div> <div class="aliases"> Also aliased as: <a href="fileutils.html#method-i-remove">remove</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-rm_f"> <a href="#method-c-rm_f" title="Link to this method"> <span class="method-name">rm_f</span> <span class="method-args">(list, noop: nil, verbose: nil)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="rm_f-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 1242
def rm_f(list, noop: nil, verbose: nil)
  rm list, force: true, noop: noop, verbose: verbose
end</pre> </div>  <p>Equivalent to:</p> <pre class="ruby" data-language="ruby">FileUtils.rm(list, force: true, **kwargs)
</pre> <p>Argument <code>list</code> (a single path or an array of paths) should be <a href="fileutils.html#module-FileUtils-label-Path+Arguments">interpretable as paths</a>.</p> <p>See <a href="fileutils.html#method-c-rm"><code>FileUtils.rm</code></a> for keyword arguments.</p> <p>Related: <a href="fileutils.html#module-FileUtils-label-Deleting">methods for deleting</a>.</p> </div> <div class="aliases"> Also aliased as: <a href="fileutils.html#method-i-safe_unlink">safe_unlink</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-rm_r"> <a href="#method-c-rm_r" title="Link to this method"> <span class="method-name">rm_r</span> <span class="method-args">(list, force: nil, noop: nil, verbose: nil, secure: nil)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="rm_r-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 1300
def rm_r(list, force: nil, noop: nil, verbose: nil, secure: nil)
  list = fu_list(list)
  fu_output_message "rm -r#{force ? 'f' : ''} #{list.join ' '}" if verbose
  return if noop
  list.each do |path|
    if secure
      remove_entry_secure path, force
    else
      remove_entry path, force
    end
  end
end</pre> </div>  <p>Removes entries at the paths in the given <code>list</code> (a single path or an array of paths); returns <code>list</code>, if it is an array, <code>[list]</code> otherwise.</p> <p>Argument <code>list</code> or its elements should be <a href="fileutils.html#module-FileUtils-label-Path+Arguments">interpretable as paths</a>.</p> <p>May cause a local vulnerability if not called with keyword argument <code>secure: true</code>; see <a href="fileutils.html#module-FileUtils-label-Avoiding+the+TOCTTOU+Vulnerability">Avoiding the TOCTTOU Vulnerability</a>.</p> <p>For each file path, removes the file at that path:</p> <pre class="ruby" data-language="ruby">FileUtils.touch(['src0.txt', 'src0.dat'])
FileUtils.rm_r(['src0.dat', 'src0.txt'])
File.exist?('src0.txt') # =&gt; false
File.exist?('src0.dat') # =&gt; false
</pre> <p>For each directory path, recursively removes files and directories:</p> <pre class="ruby" data-language="ruby">tree('src1')
# =&gt; src1
#    |-- dir0
#    |   |-- src0.txt
#    |   `-- src1.txt
#    `-- dir1
#        |-- src2.txt
#        `-- src3.txt
FileUtils.rm_r('src1')
File.exist?('src1') # =&gt; false
</pre> <p>Keyword arguments:</p> <ul>
<li> <p><code>force: true</code> - ignores raised exceptions of <a href="standarderror.html"><code>StandardError</code></a> and its descendants.</p> </li>
<li> <p><code>noop: true</code> - does not remove entries; returns <code>nil</code>.</p> </li>
<li> <p><code>secure: true</code> - removes <code>src</code> securely; see details at <a href="fileutils.html#method-c-remove_entry_secure"><code>FileUtils.remove_entry_secure</code></a>.</p> </li>
<li> <p><code>verbose: true</code> - prints an equivalent command:</p> <pre class="ruby" data-language="ruby">FileUtils.rm_r(['src0.dat', 'src0.txt'], noop: true, verbose: true)
FileUtils.rm_r('src1', noop: true, verbose: true)
</pre> <p>Output:</p> <pre>rm -r src0.dat src0.txt
rm -r src1</pre> </li>
</ul> <p>Related: <a href="fileutils.html#module-FileUtils-label-Deleting">methods for deleting</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-rm_rf"> <a href="#method-c-rm_rf" title="Link to this method"> <span class="method-name">rm_rf</span> <span class="method-args">(list, noop: nil, verbose: nil, secure: nil)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="rm_rf-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 1329
def rm_rf(list, noop: nil, verbose: nil, secure: nil)
  rm_r list, force: true, noop: noop, verbose: verbose, secure: secure
end</pre> </div>  <p>Equivalent to:</p> <pre class="ruby" data-language="ruby">FileUtils.rm_r(list, force: true, **kwargs)
</pre> <p>Argument <code>list</code> or its elements should be <a href="fileutils.html#module-FileUtils-label-Path+Arguments">interpretable as paths</a>.</p> <p>May cause a local vulnerability if not called with keyword argument <code>secure: true</code>; see <a href="fileutils.html#module-FileUtils-label-Avoiding+the+TOCTTOU+Vulnerability">Avoiding the TOCTTOU Vulnerability</a>.</p> <p>See <a href="fileutils.html#method-c-rm_r"><code>FileUtils.rm_r</code></a> for keyword arguments.</p> <p>Related: <a href="fileutils.html#module-FileUtils-label-Deleting">methods for deleting</a>.</p> </div> <div class="aliases"> Also aliased as: <a href="fileutils.html#method-i-rmtree">rmtree</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-rmdir"> <a href="#method-c-rmdir" title="Link to this method"> <span class="method-name">rmdir</span> <span class="method-args">(list, parents: nil, noop: nil, verbose: nil)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="rmdir-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 443
def rmdir(list, parents: nil, noop: nil, verbose: nil)
  list = fu_list(list)
  fu_output_message "rmdir #{parents ? '-p ' : ''}#{list.join ' '}" if verbose
  return if noop
  list.each do |dir|
    Dir.rmdir(dir = remove_trailing_slash(dir))
    if parents
      begin
        until (parent = File.dirname(dir)) == '.' or parent == dir
          dir = parent
          Dir.rmdir(dir)
        end
      rescue Errno::ENOTEMPTY, Errno::EEXIST, Errno::ENOENT
      end
    end
  end
end</pre> </div>  <p>Removes directories at the paths in the given <code>list</code> (a single path or an array of paths); returns <code>list</code>, if it is an array, <code>[list]</code> otherwise.</p> <p>Argument <code>list</code> or its elements should be <a href="fileutils.html#module-FileUtils-label-Path+Arguments">interpretable as paths</a>.</p> <p>With no keyword arguments, removes the directory at each <code>path</code> in <code>list</code>, by calling: <a href="dir.html#method-c-rmdir"><code>Dir.rmdir(path)</code></a>; see <a href="dir.html#method-c-rmdir"><code>Dir.rmdir</code></a>:</p> <pre class="ruby" data-language="ruby">FileUtils.rmdir(%w[tmp0/tmp1 tmp2/tmp3]) # =&gt; ["tmp0/tmp1", "tmp2/tmp3"]
FileUtils.rmdir('tmp4/tmp5')             # =&gt; ["tmp4/tmp5"]
</pre> <p>Keyword arguments:</p> <ul>
<li> <p><code>parents: true</code> - removes successive ancestor directories if empty.</p> </li>
<li> <p><code>noop: true</code> - does not remove directories.</p> </li>
<li> <p><code>verbose: true</code> - prints an equivalent command:</p> <pre class="ruby" data-language="ruby">FileUtils.rmdir(%w[tmp0/tmp1 tmp2/tmp3], parents: true, verbose: true)
FileUtils.rmdir('tmp4/tmp5', parents: true, verbose: true)
</pre> <p>Output:</p> <pre>rmdir -p tmp0/tmp1 tmp2/tmp3
rmdir -p tmp4/tmp5</pre> </li>
</ul> <p>Raises an exception if a directory does not exist or if for any reason a directory cannot be removed.</p> <p>Related: <a href="fileutils.html#module-FileUtils-label-Deleting">methods for deleting</a>.</p> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-c-rmtree"> <a href="#method-c-rmtree" title="Link to this method"> <span class="method-name">rmtree</span> <span class="method-args">(list, noop: nil, verbose: nil, secure: nil)</span> </a> </div> </div>  <div class="aliases"> Alias for: <a href="fileutils.html#method-i-rm_rf">rm_rf</a> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-c-safe_unlink"> <a href="#method-c-safe_unlink" title="Link to this method"> <span class="method-name">safe_unlink</span> <span class="method-args">(list, noop: nil, verbose: nil)</span> </a> </div> </div>  <div class="aliases"> Alias for: <a href="fileutils.html#method-i-rm_f">rm_f</a> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-c-symlink"> <a href="#method-c-symlink" title="Link to this method"> <span class="method-name">symlink</span> <span class="method-args">(src, dest, force: nil, relative: false, target_directory: true, noop: nil, verbose: nil)</span> </a> </div> </div>  <div class="aliases"> Alias for: <a href="fileutils.html#method-i-ln_s">ln_s</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-touch"> <a href="#method-c-touch" title="Link to this method"> <span class="method-name">touch</span> <span class="method-args">(list, noop: nil, verbose: nil, mtime: nil, nocreate: nil)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="touch-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 2007
def touch(list, noop: nil, verbose: nil, mtime: nil, nocreate: nil)
  list = fu_list(list)
  t = mtime
  if verbose
    fu_output_message "touch #{nocreate ? '-c ' : ''}#{t ? t.strftime('-t %Y%m%d%H%M.%S ') : ''}#{list.join ' '}"
  end
  return if noop
  list.each do |path|
    created = nocreate
    begin
      File.utime(t, t, path)
    rescue Errno::ENOENT
      raise if created
      File.open(path, 'a') {
        ;
      }
      created = true
      retry if t
    end
  end
end</pre> </div>  <p>Updates modification times (mtime) and access times (atime) of the entries given by the paths in <code>list</code> (a single path or an array of paths); returns <code>list</code> if it is an array, <code>[list]</code> otherwise.</p> <p>By default, creates an empty file for any path to a non-existent entry; use keyword argument <code>nocreate</code> to raise an exception instead.</p> <p>Argument <code>list</code> or its elements should be <a href="fileutils.html#module-FileUtils-label-Path+Arguments">interpretable as paths</a>.</p> <p>Examples:</p> <pre class="ruby" data-language="ruby"># Single path.
f = File.new('src0.txt') # Existing file.
f.atime # =&gt; 2022-06-10 11:11:21.200277 -0700
f.mtime # =&gt; 2022-06-10 11:11:21.200277 -0700
FileUtils.touch('src0.txt')
f = File.new('src0.txt')
f.atime # =&gt; 2022-06-11 08:28:09.8185343 -0700
f.mtime # =&gt; 2022-06-11 08:28:09.8185343 -0700

# Array of paths.
FileUtils.touch(['src0.txt', 'src0.dat'])
</pre> <p>Keyword arguments:</p> <ul>
<li> <p><code>mtime: <em>time</em></code> - sets the entry’s mtime to the given time, instead of the current time.</p> </li>
<li> <p><code>nocreate: true</code> - raises an exception if the entry does not exist.</p> </li>
<li> <p><code>noop: true</code> - does not touch entries; returns <code>nil</code>.</p> </li>
<li> <p><code>verbose: true</code> - prints an equivalent command:</p> <pre class="ruby" data-language="ruby">FileUtils.touch('src0.txt', noop: true, verbose: true)
FileUtils.touch(['src0.txt', 'src0.dat'], noop: true, verbose: true)
FileUtils.touch(path, noop: true, verbose: true)
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">touch src0.txt
touch src0.txt src0.dat
touch src0.txt
</pre> </li>
</ul> <p>Related: <a href="fileutils.html#method-c-uptodate-3F"><code>FileUtils.uptodate?</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-uptodate-3F"> <a href="#method-c-uptodate-3F" title="Link to this method"> <span class="method-name">uptodate?</span> <span class="method-args">(new, old_list)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="uptodate-3F-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 265
def uptodate?(new, old_list)
  return false unless File.exist?(new)
  new_time = File.mtime(new)
  old_list.each do |old|
    if File.exist?(old)
      return false unless new_time &gt; File.mtime(old)
    end
  end
  true
end</pre> </div>  <p>Returns <code>true</code> if the file at path <code>new</code> is newer than all the files at paths in array <code>old_list</code>; <code>false</code> otherwise.</p> <p>Argument <code>new</code> and the elements of <code>old_list</code> should be <a href="fileutils.html#module-FileUtils-label-Path+Arguments">interpretable as paths</a>:</p> <pre class="ruby" data-language="ruby">FileUtils.uptodate?('Rakefile', ['Gemfile', 'README.md']) # =&gt; true
FileUtils.uptodate?('Gemfile', ['Rakefile', 'README.md']) # =&gt; false
</pre> <p>A non-existent file is considered to be infinitely old.</p> <p>Related: <a href="fileutils.html#method-c-touch"><code>FileUtils.touch</code></a>.</p> </div> </div> </section> <section id="private-instance-5Buntitled-5D-method-details" class="method-section anchor-link"> <header> <h3>Private Instance Methods</h3> </header> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-cd"> <a href="#method-i-cd" title="Link to this method"> <span class="method-name">cd</span> <span class="method-args">(dir, verbose: nil) { |dir| ... }</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="cd-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 239
def cd(dir, verbose: nil, &amp;block) # :yield: dir
  fu_output_message "cd #{dir}" if verbose
  result = Dir.chdir(dir, &amp;block)
  fu_output_message 'cd -' if verbose and block
  result
end</pre> </div>  <p>Changes the working directory to the given <code>dir</code>, which should be <a href="fileutils.html#module-FileUtils-label-Path+Arguments">interpretable as a path</a>:</p> <p>With no block given, changes the current directory to the directory at <code>dir</code>; returns zero:</p> <pre class="ruby" data-language="ruby">FileUtils.pwd # =&gt; "/rdoc/fileutils"
FileUtils.cd('..')
FileUtils.pwd # =&gt; "/rdoc"
FileUtils.cd('fileutils')
</pre> <p>With a block given, changes the current directory to the directory at <code>dir</code>, calls the block with argument <code>dir</code>, and restores the original current directory; returns the block’s value:</p> <pre class="ruby" data-language="ruby">FileUtils.pwd                                     # =&gt; "/rdoc/fileutils"
FileUtils.cd('..') { |arg| [arg, FileUtils.pwd] } # =&gt; ["..", "/rdoc"]
FileUtils.pwd                                     # =&gt; "/rdoc/fileutils"
</pre> <p>Keyword arguments:</p> <ul><li> <p><code>verbose: true</code> - prints an equivalent command:</p> <pre class="ruby" data-language="ruby">FileUtils.cd('..')
FileUtils.cd('fileutils')
</pre> <p>Output:</p> <pre>cd ..
cd fileutils</pre> </li></ul> <p>Related: <a href="fileutils.html#method-c-pwd"><code>FileUtils.pwd</code></a>.</p> </div> <div class="aliases"> Also aliased as: <a href="fileutils.html#method-i-chdir">chdir</a> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-chdir"> <a href="#method-i-chdir" title="Link to this method"> <span class="method-name">chdir</span> <span class="method-args">(dir, verbose: nil)</span> </a> </div> </div>  <div class="aliases"> Alias for: <a href="fileutils.html#method-i-cd">cd</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-chmod"> <a href="#method-i-chmod" title="Link to this method"> <span class="method-name">chmod</span> <span class="method-args">(mode, list, noop: nil, verbose: nil)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="chmod-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 1804
def chmod(mode, list, noop: nil, verbose: nil)
  list = fu_list(list)
  fu_output_message sprintf('chmod %s %s', mode_to_s(mode), list.join(' ')) if verbose
  return if noop
  list.each do |path|
    Entry_.new(path).chmod(fu_mode(mode, path))
  end
end</pre> </div>  <p>Changes permissions on the entries at the paths given in <code>list</code> (a single path or an array of paths) to the permissions given by <code>mode</code>; returns <code>list</code> if it is an array, <code>[list]</code> otherwise:</p> <ul>
<li> <p>Modifies each entry that is a regular file using <a href="file.html#method-c-chmod"><code>File.chmod</code></a>.</p> </li>
<li> <p>Modifies each entry that is a symbolic link using <a href="file.html#method-c-lchmod"><code>File.lchmod</code></a>.</p> </li>
</ul> <p>Argument <code>list</code> or its elements should be <a href="fileutils.html#module-FileUtils-label-Path+Arguments">interpretable as paths</a>.</p> <p>Argument <code>mode</code> may be either an integer or a string:</p> <ul>
<li> <p>Integer <code>mode</code>: represents the permission bits to be set:</p> <pre class="ruby" data-language="ruby">FileUtils.chmod(0755, 'src0.txt')
FileUtils.chmod(0644, ['src0.txt', 'src0.dat'])
</pre> </li>
<li> <p>String <code>mode</code>: represents the permissions to be set:</p> <p>The string is of the form <code>[targets][[operator][perms[,perms]]</code>, where:</p> <ul>
<li> <p><code>targets</code> may be any combination of these letters:</p> <ul>
<li> <p><code>'u'</code>: permissions apply to the file’s owner.</p> </li>
<li> <p><code>'g'</code>: permissions apply to users in the file’s group.</p> </li>
<li> <p><code>'o'</code>: permissions apply to other users not in the file’s group.</p> </li>
<li> <p><code>'a'</code> (the default): permissions apply to all users.</p> </li>
</ul> </li>
<li> <p><code>operator</code> may be one of these letters:</p> <ul>
<li> <p><code>'+'</code>: adds permissions.</p> </li>
<li> <p><code>'-'</code>: removes permissions.</p> </li>
<li> <p><code>'='</code>: sets (replaces) permissions.</p> </li>
</ul> </li>
<li> <p><code>perms</code> (may be repeated, with separating commas) may be any combination of these letters:</p> <ul>
<li> <p><code>'r'</code>: Read.</p> </li>
<li> <p><code>'w'</code>: Write.</p> </li>
<li> <p><code>'x'</code>: Execute (search, for a directory).</p> </li>
<li> <p><code>'X'</code>: Search (for a directories only; must be used with <code>'+'</code>)</p> </li>
<li> <p><code>'s'</code>: Uid or gid.</p> </li>
<li> <p><code>'t'</code>: Sticky bit.</p> </li>
</ul> </li>
</ul> <p>Examples:</p> <pre class="ruby" data-language="ruby">FileUtils.chmod('u=wrx,go=rx', 'src1.txt')
FileUtils.chmod('u=wrx,go=rx', '/usr/bin/ruby')
</pre> </li>
</ul> <p>Keyword arguments:</p> <ul>
<li> <p><code>noop: true</code> - does not change permissions; returns <code>nil</code>.</p> </li>
<li> <p><code>verbose: true</code> - prints an equivalent command:</p> <pre class="ruby" data-language="ruby">FileUtils.chmod(0755, 'src0.txt', noop: true, verbose: true)
FileUtils.chmod(0644, ['src0.txt', 'src0.dat'], noop: true, verbose: true)
FileUtils.chmod('u=wrx,go=rx', 'src1.txt', noop: true, verbose: true)
FileUtils.chmod('u=wrx,go=rx', '/usr/bin/ruby', noop: true, verbose: true)
</pre> <p>Output:</p> <pre>chmod 755 src0.txt
chmod 644 src0.txt src0.dat
chmod u=wrx,go=rx src1.txt
chmod u=wrx,go=rx /usr/bin/ruby</pre> </li>
</ul> <p>Related: <a href="fileutils.html#method-c-chmod_R"><code>FileUtils.chmod_R</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-chmod_R"> <a href="#method-i-chmod_R" title="Link to this method"> <span class="method-name">chmod_R</span> <span class="method-args">(mode, list, noop: nil, verbose: nil, force: nil)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="chmod_R-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 1816
def chmod_R(mode, list, noop: nil, verbose: nil, force: nil)
  list = fu_list(list)
  fu_output_message sprintf('chmod -R%s %s %s',
                            (force ? 'f' : ''),
                            mode_to_s(mode), list.join(' ')) if verbose
  return if noop
  list.each do |root|
    Entry_.new(root).traverse do |ent|
      begin
        ent.chmod(fu_mode(mode, ent.path))
      rescue
        raise unless force
      end
    end
  end
end</pre> </div>  <p>Like <a href="fileutils.html#method-c-chmod"><code>FileUtils.chmod</code></a>, but changes permissions recursively.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-chown"> <a href="#method-i-chown" title="Link to this method"> <span class="method-name">chown</span> <span class="method-args">(user, group, list, noop: nil, verbose: nil)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="chown-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 1897
def chown(user, group, list, noop: nil, verbose: nil)
  list = fu_list(list)
  fu_output_message sprintf('chown %s %s',
                            (group ? "#{user}:#{group}" : user || ':'),
                            list.join(' ')) if verbose
  return if noop
  uid = fu_get_uid(user)
  gid = fu_get_gid(group)
  list.each do |path|
    Entry_.new(path).chown uid, gid
  end
end</pre> </div>  <p>Changes the owner and group on the entries at the paths given in <code>list</code> (a single path or an array of paths) to the given <code>user</code> and <code>group</code>; returns <code>list</code> if it is an array, <code>[list]</code> otherwise:</p> <ul>
<li> <p>Modifies each entry that is a regular file using <a href="file.html#method-c-chown"><code>File.chown</code></a>.</p> </li>
<li> <p>Modifies each entry that is a symbolic link using <a href="file.html#method-c-lchown"><code>File.lchown</code></a>.</p> </li>
</ul> <p>Argument <code>list</code> or its elements should be <a href="fileutils.html#module-FileUtils-label-Path+Arguments">interpretable as paths</a>.</p> <p>User and group:</p> <ul>
<li> <p>Argument <code>user</code> may be a user name or a user id; if <code>nil</code> or <code>-1</code>, the user is not changed.</p> </li>
<li> <p>Argument <code>group</code> may be a group name or a group id; if <code>nil</code> or <code>-1</code>, the group is not changed.</p> </li>
<li> <p>The user must be a member of the group.</p> </li>
</ul> <p>Examples:</p> <pre class="ruby" data-language="ruby"># One path.
# User and group as string names.
File.stat('src0.txt').uid # =&gt; 1004
File.stat('src0.txt').gid # =&gt; 1004
FileUtils.chown('user2', 'group1', 'src0.txt')
File.stat('src0.txt').uid # =&gt; 1006
File.stat('src0.txt').gid # =&gt; 1005

# User and group as uid and gid.
FileUtils.chown(1004, 1004, 'src0.txt')
File.stat('src0.txt').uid # =&gt; 1004
File.stat('src0.txt').gid # =&gt; 1004

# Array of paths.
FileUtils.chown(1006, 1005, ['src0.txt', 'src0.dat'])

# Directory (not recursive).
FileUtils.chown('user2', 'group1', '.')
</pre> <p>Keyword arguments:</p> <ul>
<li> <p><code>noop: true</code> - does not change permissions; returns <code>nil</code>.</p> </li>
<li> <p><code>verbose: true</code> - prints an equivalent command:</p> <pre class="ruby" data-language="ruby">FileUtils.chown('user2', 'group1', 'src0.txt', noop: true, verbose: true)
FileUtils.chown(1004, 1004, 'src0.txt', noop: true, verbose: true)
FileUtils.chown(1006, 1005, ['src0.txt', 'src0.dat'], noop: true, verbose: true)
FileUtils.chown('user2', 'group1', path, noop: true, verbose: true)
FileUtils.chown('user2', 'group1', '.', noop: true, verbose: true)
</pre> <p>Output:</p> <pre>chown user2:group1 src0.txt
chown 1004:1004 src0.txt
chown 1006:1005 src0.txt src0.dat
chown user2:group1 src0.txt
chown user2:group1 .</pre> </li>
</ul> <p>Related: <a href="fileutils.html#method-c-chown_R"><code>FileUtils.chown_R</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-chown_R"> <a href="#method-i-chown_R" title="Link to this method"> <span class="method-name">chown_R</span> <span class="method-args">(user, group, list, noop: nil, verbose: nil, force: nil)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="chown_R-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 1913
def chown_R(user, group, list, noop: nil, verbose: nil, force: nil)
  list = fu_list(list)
  fu_output_message sprintf('chown -R%s %s %s',
                            (force ? 'f' : ''),
                            (group ? "#{user}:#{group}" : user || ':'),
                            list.join(' ')) if verbose
  return if noop
  uid = fu_get_uid(user)
  gid = fu_get_gid(group)
  list.each do |root|
    Entry_.new(root).traverse do |ent|
      begin
        ent.chown uid, gid
      rescue
        raise unless force
      end
    end
  end
end</pre> </div>  <p>Like <a href="fileutils.html#method-c-chown"><code>FileUtils.chown</code></a>, but changes owner and group recursively.</p> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-cmp"> <a href="#method-i-cmp" title="Link to this method"> <span class="method-name">cmp</span> <span class="method-args">(a, b)</span> </a> </div> </div>  <div class="aliases"> Alias for: <a href="fileutils.html#method-i-compare_file">compare_file</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-compare_file"> <a href="#method-i-compare_file" title="Link to this method"> <span class="method-name">compare_file</span> <span class="method-args">(a, b)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="compare_file-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 1508
def compare_file(a, b)
  return false unless File.size(a) == File.size(b)
  File.open(a, 'rb') {|fa|
    File.open(b, 'rb') {|fb|
      return compare_stream(fa, fb)
    }
  }
end</pre> </div>  <p>Returns <code>true</code> if the contents of files <code>a</code> and <code>b</code> are identical, <code>false</code> otherwise.</p> <p>Arguments <code>a</code> and <code>b</code> should be <a href="fileutils.html#module-FileUtils-label-Path+Arguments">interpretable as a path</a>.</p> <p><a href="fileutils.html#method-c-identical-3F"><code>FileUtils.identical?</code></a> and <a href="fileutils.html#method-c-cmp"><code>FileUtils.cmp</code></a> are aliases for <a href="fileutils.html#method-c-compare_file"><code>FileUtils.compare_file</code></a>.</p> <p>Related: <a href="fileutils.html#method-c-compare_stream"><code>FileUtils.compare_stream</code></a>.</p> </div> <div class="aliases"> Also aliased as: <a href="fileutils.html#method-i-identical-3F">identical?</a>, <a href="fileutils.html#method-i-cmp">cmp</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-compare_stream"> <a href="#method-i-compare_stream" title="Link to this method"> <span class="method-name">compare_stream</span> <span class="method-args">(a, b)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="compare_stream-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 1531
def compare_stream(a, b)
  bsize = fu_stream_blksize(a, b)

  sa = String.new(capacity: bsize)
  sb = String.new(capacity: bsize)

  begin
    a.read(bsize, sa)
    b.read(bsize, sb)
    return true if sa.empty? &amp;&amp; sb.empty?
  end while sa == sb
  false
end</pre> </div>  <p>Returns <code>true</code> if the contents of streams <code>a</code> and <code>b</code> are identical, <code>false</code> otherwise.</p> <p>Arguments <code>a</code> and <code>b</code> should be <a href="fileutils.html#module-FileUtils-label-Path+Arguments">interpretable as a path</a>.</p> <p>Related: <a href="fileutils.html#method-c-compare_file"><code>FileUtils.compare_file</code></a>.</p> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-copy"> <a href="#method-i-copy" title="Link to this method"> <span class="method-name">copy</span> <span class="method-args">(src, dest, preserve: nil, noop: nil, verbose: nil)</span> </a> </div> </div>  <div class="aliases"> Alias for: <a href="fileutils.html#method-i-cp">cp</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-copy_entry"> <a href="#method-i-copy_entry" title="Link to this method"> <span class="method-name">copy_entry</span> <span class="method-args">(src, dest, preserve = false, dereference_root = false, remove_destination = false)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="copy_entry-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 1041
def copy_entry(src, dest, preserve = false, dereference_root = false, remove_destination = false)
  if dereference_root
    src = File.realpath(src)
  end

  Entry_.new(src, nil, false).wrap_traverse(proc do |ent|
    destent = Entry_.new(dest, ent.rel, false)
    File.unlink destent.path if remove_destination &amp;&amp; (File.file?(destent.path) || File.symlink?(destent.path))
    ent.copy destent.path
  end, proc do |ent|
    destent = Entry_.new(dest, ent.rel, false)
    ent.copy_metadata destent.path if preserve
  end)
end</pre> </div>  <p>Recursively copies files from <code>src</code> to <code>dest</code>.</p> <p>Arguments <code>src</code> and <code>dest</code> should be <a href="fileutils.html#module-FileUtils-label-Path+Arguments">interpretable as paths</a>.</p> <p>If <code>src</code> is the path to a file, copies <code>src</code> to <code>dest</code>:</p> <pre class="ruby" data-language="ruby">FileUtils.touch('src0.txt')
File.exist?('dest0.txt') # =&gt; false
FileUtils.copy_entry('src0.txt', 'dest0.txt')
File.file?('dest0.txt')  # =&gt; true
</pre> <p>If <code>src</code> is a directory, recursively copies <code>src</code> to <code>dest</code>:</p> <pre class="ruby" data-language="ruby">tree('src1')
# =&gt; src1
#    |-- dir0
#    |   |-- src0.txt
#    |   `-- src1.txt
#    `-- dir1
#        |-- src2.txt
#        `-- src3.txt
FileUtils.copy_entry('src1', 'dest1')
tree('dest1')
# =&gt; dest1
#    |-- dir0
#    |   |-- src0.txt
#    |   `-- src1.txt
#    `-- dir1
#        |-- src2.txt
#        `-- src3.txt
</pre> <p>The recursive copying preserves file types for regular files, directories, and symbolic links; other file types (FIFO streams, device files, etc.) are not supported.</p> <p>Keyword arguments:</p> <ul>
<li> <p><code>dereference_root: true</code> - if <code>src</code> is a symbolic link, follows the link.</p> </li>
<li> <p><code>preserve: true</code> - preserves file times.</p> </li>
<li> <p><code>remove_destination: true</code> - removes <code>dest</code> before copying files.</p> </li>
</ul> <p>Related: <a href="fileutils.html#module-FileUtils-label-Copying">methods for copying</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-copy_file"> <a href="#method-i-copy_file" title="Link to this method"> <span class="method-name">copy_file</span> <span class="method-args">(src, dest, preserve = false, dereference = true)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="copy_file-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 1077
def copy_file(src, dest, preserve = false, dereference = true)
  ent = Entry_.new(src, nil, dereference)
  ent.copy_file dest
  ent.copy_metadata dest if preserve
end</pre> </div>  <p>Copies file from <code>src</code> to <code>dest</code>, which should not be directories.</p> <p>Arguments <code>src</code> and <code>dest</code> should be <a href="fileutils.html#module-FileUtils-label-Path+Arguments">interpretable as paths</a>.</p> <p>Examples:</p> <pre class="ruby" data-language="ruby">FileUtils.touch('src0.txt')
FileUtils.copy_file('src0.txt', 'dest0.txt')
File.file?('dest0.txt') # =&gt; true
</pre> <p>Keyword arguments:</p> <ul>
<li> <p><code>dereference: false</code> - if <code>src</code> is a symbolic link, does not follow the link.</p> </li>
<li> <p><code>preserve: true</code> - preserves file times.</p> </li>
<li> <p><code>remove_destination: true</code> - removes <code>dest</code> before copying files.</p> </li>
</ul> <p>Related: <a href="fileutils.html#module-FileUtils-label-Copying">methods for copying</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-copy_stream"> <a href="#method-i-copy_stream" title="Link to this method"> <span class="method-name">copy_stream</span> <span class="method-args">(src, dest)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="copy_stream-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 1089
def copy_stream(src, dest)
  IO.copy_stream(src, dest)
end</pre> </div>  <p>Copies IO stream <code>src</code> to IO stream <code>dest</code> via <a href="io.html#method-c-copy_stream"><code>IO.copy_stream</code></a>.</p> <p>Related: <a href="fileutils.html#module-FileUtils-label-Copying">methods for copying</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-cp"> <a href="#method-i-cp" title="Link to this method"> <span class="method-name">cp</span> <span class="method-args">(src, dest, preserve: nil, noop: nil, verbose: nil)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="cp-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 874
def cp(src, dest, preserve: nil, noop: nil, verbose: nil)
  fu_output_message "cp#{preserve ? ' -p' : ''} #{[src,dest].flatten.join ' '}" if verbose
  return if noop
  fu_each_src_dest(src, dest) do |s, d|
    copy_file s, d, preserve
  end
end</pre> </div>  <p>Copies files.</p> <p>Arguments <code>src</code> (a single path or an array of paths) and <code>dest</code> (a single path) should be <a href="fileutils.html#module-FileUtils-label-Path+Arguments">interpretable as paths</a>.</p> <p>If <code>src</code> is the path to a file and <code>dest</code> is not the path to a directory, copies <code>src</code> to <code>dest</code>:</p> <pre class="ruby" data-language="ruby">FileUtils.touch('src0.txt')
File.exist?('dest0.txt') # =&gt; false
FileUtils.cp('src0.txt', 'dest0.txt')
File.file?('dest0.txt')  # =&gt; true
</pre> <p>If <code>src</code> is the path to a file and <code>dest</code> is the path to a directory, copies <code>src</code> to <code>dest/src</code>:</p> <pre class="ruby" data-language="ruby">FileUtils.touch('src1.txt')
FileUtils.mkdir('dest1')
FileUtils.cp('src1.txt', 'dest1')
File.file?('dest1/src1.txt') # =&gt; true
</pre> <p>If <code>src</code> is an array of paths to files and <code>dest</code> is the path to a directory, copies from each <code>src</code> to <code>dest</code>:</p> <pre class="ruby" data-language="ruby">src_file_paths = ['src2.txt', 'src2.dat']
FileUtils.touch(src_file_paths)
FileUtils.mkdir('dest2')
FileUtils.cp(src_file_paths, 'dest2')
File.file?('dest2/src2.txt') # =&gt; true
File.file?('dest2/src2.dat') # =&gt; true
</pre> <p>Keyword arguments:</p> <ul>
<li> <p><code>preserve: true</code> - preserves file times.</p> </li>
<li> <p><code>noop: true</code> - does not copy files.</p> </li>
<li> <p><code>verbose: true</code> - prints an equivalent command:</p> <pre class="ruby" data-language="ruby">FileUtils.cp('src0.txt', 'dest0.txt', noop: true, verbose: true)
FileUtils.cp('src1.txt', 'dest1', noop: true, verbose: true)
FileUtils.cp(src_file_paths, 'dest2', noop: true, verbose: true)
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">cp src0.txt dest0.txt
cp src1.txt dest1
cp src2.txt src2.dat dest2
</pre> </li>
</ul> <p>Raises an exception if <code>src</code> is a directory.</p> <p>Related: <a href="fileutils.html#module-FileUtils-label-Copying">methods for copying</a>.</p> </div> <div class="aliases"> Also aliased as: <a href="fileutils.html#method-i-copy">copy</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-cp_lr"> <a href="#method-i-cp_lr" title="Link to this method"> <span class="method-name">cp_lr</span> <span class="method-args">(src, dest, noop: nil, verbose: nil, dereference_root: true, remove_destination: false)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="cp_lr-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 628
def cp_lr(src, dest, noop: nil, verbose: nil,
          dereference_root: true, remove_destination: false)
  fu_output_message "cp -lr#{remove_destination ? ' --remove-destination' : ''} #{[src,dest].flatten.join ' '}" if verbose
  return if noop
  fu_each_src_dest(src, dest) do |s, d|
    link_entry s, d, dereference_root, remove_destination
  end
end</pre> </div>  <p>Creates <a href="https://en.wikipedia.org/wiki/Hard_link">hard links</a>.</p> <p>Arguments <code>src</code> (a single path or an array of paths) and <code>dest</code> (a single path) should be <a href="fileutils.html#module-FileUtils-label-Path+Arguments">interpretable as paths</a>.</p> <p>If <code>src</code> is the path to a directory and <code>dest</code> does not exist, creates links <code>dest</code> and descendents pointing to <code>src</code> and its descendents:</p> <pre class="ruby" data-language="ruby">tree('src0')
# =&gt; src0
#    |-- sub0
#    |   |-- src0.txt
#    |   `-- src1.txt
#    `-- sub1
#        |-- src2.txt
#        `-- src3.txt
File.exist?('dest0') # =&gt; false
FileUtils.cp_lr('src0', 'dest0')
tree('dest0')
# =&gt; dest0
#    |-- sub0
#    |   |-- src0.txt
#    |   `-- src1.txt
#    `-- sub1
#        |-- src2.txt
#        `-- src3.txt
</pre> <p>If <code>src</code> and <code>dest</code> are both paths to directories, creates links <code>dest/src</code> and descendents pointing to <code>src</code> and its descendents:</p> <pre class="ruby" data-language="ruby">tree('src1')
# =&gt; src1
#    |-- sub0
#    |   |-- src0.txt
#    |   `-- src1.txt
#    `-- sub1
#        |-- src2.txt
#        `-- src3.txt
FileUtils.mkdir('dest1')
FileUtils.cp_lr('src1', 'dest1')
tree('dest1')
# =&gt; dest1
#    `-- src1
#        |-- sub0
#        |   |-- src0.txt
#        |   `-- src1.txt
#        `-- sub1
#            |-- src2.txt
#            `-- src3.txt
</pre> <p>If <code>src</code> is an array of paths to entries and <code>dest</code> is the path to a directory, for each path <code>filepath</code> in <code>src</code>, creates a link at <code>dest/filepath</code> pointing to that path:</p> <pre class="ruby" data-language="ruby">tree('src2')
# =&gt; src2
#    |-- sub0
#    |   |-- src0.txt
#    |   `-- src1.txt
#    `-- sub1
#        |-- src2.txt
#        `-- src3.txt
FileUtils.mkdir('dest2')
FileUtils.cp_lr(['src2/sub0', 'src2/sub1'], 'dest2')
tree('dest2')
# =&gt; dest2
#    |-- sub0
#    |   |-- src0.txt
#    |   `-- src1.txt
#    `-- sub1
#        |-- src2.txt
#        `-- src3.txt
</pre> <p>Keyword arguments:</p> <ul>
<li> <p><code>dereference_root: false</code> - if <code>src</code> is a symbolic link, does not dereference it.</p> </li>
<li> <p><code>noop: true</code> - does not create links.</p> </li>
<li> <p><code>remove_destination: true</code> - removes <code>dest</code> before creating links.</p> </li>
<li> <p><code>verbose: true</code> - prints an equivalent command:</p> <pre class="ruby" data-language="ruby">FileUtils.cp_lr('src0', 'dest0', noop: true, verbose: true)
FileUtils.cp_lr('src1', 'dest1', noop: true, verbose: true)
FileUtils.cp_lr(['src2/sub0', 'src2/sub1'], 'dest2', noop: true, verbose: true)
</pre> <p>Output:</p> <pre>cp -lr src0 dest0
cp -lr src1 dest1
cp -lr src2/sub0 src2/sub1 dest2</pre> </li>
</ul> <p>Raises an exception if <code>dest</code> is the path to an existing file or directory and keyword argument <code>remove_destination: true</code> is not given.</p> <p>Related: <a href="fileutils.html#module-FileUtils-label-Copying">methods for copying</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-cp_r"> <a href="#method-i-cp_r" title="Link to this method"> <span class="method-name">cp_r</span> <span class="method-args">(src, dest, preserve: nil, noop: nil, verbose: nil, dereference_root: true, remove_destination: nil)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="cp_r-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 986
def cp_r(src, dest, preserve: nil, noop: nil, verbose: nil,
         dereference_root: true, remove_destination: nil)
  fu_output_message "cp -r#{preserve ? 'p' : ''}#{remove_destination ? ' --remove-destination' : ''} #{[src,dest].flatten.join ' '}" if verbose
  return if noop
  fu_each_src_dest(src, dest) do |s, d|
    copy_entry s, d, preserve, dereference_root, remove_destination
  end
end</pre> </div>  <p>Recursively copies files.</p> <p>Arguments <code>src</code> (a single path or an array of paths) and <code>dest</code> (a single path) should be <a href="fileutils.html#module-FileUtils-label-Path+Arguments">interpretable as paths</a>.</p> <p>The mode, owner, and group are retained in the copy; to change those, use <a href="fileutils.html#method-c-install"><code>FileUtils.install</code></a> instead.</p> <p>If <code>src</code> is the path to a file and <code>dest</code> is not the path to a directory, copies <code>src</code> to <code>dest</code>:</p> <pre class="ruby" data-language="ruby">FileUtils.touch('src0.txt')
File.exist?('dest0.txt') # =&gt; false
FileUtils.cp_r('src0.txt', 'dest0.txt')
File.file?('dest0.txt')  # =&gt; true
</pre> <p>If <code>src</code> is the path to a file and <code>dest</code> is the path to a directory, copies <code>src</code> to <code>dest/src</code>:</p> <pre class="ruby" data-language="ruby">FileUtils.touch('src1.txt')
FileUtils.mkdir('dest1')
FileUtils.cp_r('src1.txt', 'dest1')
File.file?('dest1/src1.txt') # =&gt; true
</pre> <p>If <code>src</code> is the path to a directory and <code>dest</code> does not exist, recursively copies <code>src</code> to <code>dest</code>:</p> <pre class="ruby" data-language="ruby">tree('src2')
# =&gt; src2
#    |-- dir0
#    |   |-- src0.txt
#    |   `-- src1.txt
#    `-- dir1
#    |-- src2.txt
#    `-- src3.txt
FileUtils.exist?('dest2') # =&gt; false
FileUtils.cp_r('src2', 'dest2')
tree('dest2')
# =&gt; dest2
#    |-- dir0
#    |   |-- src0.txt
#    |   `-- src1.txt
#    `-- dir1
#    |-- src2.txt
#    `-- src3.txt
</pre> <p>If <code>src</code> and <code>dest</code> are paths to directories, recursively copies <code>src</code> to <code>dest/src</code>:</p> <pre class="ruby" data-language="ruby">tree('src3')
# =&gt; src3
#    |-- dir0
#    |   |-- src0.txt
#    |   `-- src1.txt
#    `-- dir1
#    |-- src2.txt
#    `-- src3.txt
FileUtils.mkdir('dest3')
FileUtils.cp_r('src3', 'dest3')
tree('dest3')
# =&gt; dest3
#    `-- src3
#      |-- dir0
#      |   |-- src0.txt
#      |   `-- src1.txt
#      `-- dir1
#          |-- src2.txt
#          `-- src3.txt
</pre> <p>If <code>src</code> is an array of paths and <code>dest</code> is a directory, recursively copies from each path in <code>src</code> to <code>dest</code>; the paths in <code>src</code> may point to files and/or directories.</p> <p>Keyword arguments:</p> <ul>
<li> <p><code>dereference_root: false</code> - if <code>src</code> is a symbolic link, does not dereference it.</p> </li>
<li> <p><code>noop: true</code> - does not copy files.</p> </li>
<li> <p><code>preserve: true</code> - preserves file times.</p> </li>
<li> <p><code>remove_destination: true</code> - removes <code>dest</code> before copying files.</p> </li>
<li> <p><code>verbose: true</code> - prints an equivalent command:</p> <pre class="ruby" data-language="ruby">FileUtils.cp_r('src0.txt', 'dest0.txt', noop: true, verbose: true)
FileUtils.cp_r('src1.txt', 'dest1', noop: true, verbose: true)
FileUtils.cp_r('src2', 'dest2', noop: true, verbose: true)
FileUtils.cp_r('src3', 'dest3', noop: true, verbose: true)
</pre> <p>Output:</p> <pre>cp -r src0.txt dest0.txt
cp -r src1.txt dest1
cp -r src2 dest2
cp -r src3 dest3</pre> </li>
</ul> <p>Raises an exception of <code>src</code> is the path to a directory and <code>dest</code> is the path to a file.</p> <p>Related: <a href="fileutils.html#module-FileUtils-label-Copying">methods for copying</a>.</p> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-getwd"> <a href="#method-i-getwd" title="Link to this method"> <span class="method-name">getwd</span> <span class="method-args">()</span> </a> </div> </div>  <div class="aliases"> Alias for: <a href="fileutils.html#method-i-pwd">pwd</a> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-identical-3F"> <a href="#method-i-identical-3F" title="Link to this method"> <span class="method-name">identical?</span> <span class="method-args">(a, b)</span> </a> </div> </div>  <div class="aliases"> Alias for: <a href="fileutils.html#method-i-compare_file">compare_file</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-install"> <a href="#method-i-install" title="Link to this method"> <span class="method-name">install</span> <span class="method-args">(src, dest, mode: nil, owner: nil, group: nil, preserve: nil, noop: nil, verbose: nil)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="install-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 1610
def install(src, dest, mode: nil, owner: nil, group: nil, preserve: nil,
            noop: nil, verbose: nil)
  if verbose
    msg = +"install -c"
    msg &lt;&lt; ' -p' if preserve
    msg &lt;&lt; ' -m ' &lt;&lt; mode_to_s(mode) if mode
    msg &lt;&lt; " -o #{owner}" if owner
    msg &lt;&lt; " -g #{group}" if group
    msg &lt;&lt; ' ' &lt;&lt; [src,dest].flatten.join(' ')
    fu_output_message msg
  end
  return if noop
  uid = fu_get_uid(owner)
  gid = fu_get_gid(group)
  fu_each_src_dest(src, dest) do |s, d|
    st = File.stat(s)
    unless File.exist?(d) and compare_file(s, d)
      remove_file d, true
      if d.end_with?('/')
        mkdir_p d
        copy_file s, d + File.basename(s)
      else
        mkdir_p File.expand_path('..', d)
        copy_file s, d
      end
      File.utime st.atime, st.mtime, d if preserve
      File.chmod fu_mode(mode, st), d if mode
      File.chown uid, gid, d if uid or gid
    end
  end
end</pre> </div>  <p>Copies a file entry. See <a href="https://man7.org/linux/man-pages/man1/install.1.html">install(1)</a>.</p> <p>Arguments <code>src</code> (a single path or an array of paths) and <code>dest</code> (a single path) should be <a href="fileutils.html#module-FileUtils-label-Path+Arguments">interpretable as paths</a>;</p> <p>If the entry at <code>dest</code> does not exist, copies from <code>src</code> to <code>dest</code>:</p> <pre class="ruby" data-language="ruby">File.read('src0.txt')    # =&gt; "aaa\n"
File.exist?('dest0.txt') # =&gt; false
FileUtils.install('src0.txt', 'dest0.txt')
File.read('dest0.txt')   # =&gt; "aaa\n"
</pre> <p>If <code>dest</code> is a file entry, copies from <code>src</code> to <code>dest</code>, overwriting:</p> <pre class="ruby" data-language="ruby">File.read('src1.txt')  # =&gt; "aaa\n"
File.read('dest1.txt') # =&gt; "bbb\n"
FileUtils.install('src1.txt', 'dest1.txt')
File.read('dest1.txt') # =&gt; "aaa\n"
</pre> <p>If <code>dest</code> is a directory entry, copies from <code>src</code> to <code>dest/src</code>, overwriting if necessary:</p> <pre class="ruby" data-language="ruby">File.read('src2.txt')       # =&gt; "aaa\n"
File.read('dest2/src2.txt') # =&gt; "bbb\n"
FileUtils.install('src2.txt', 'dest2')
File.read('dest2/src2.txt') # =&gt; "aaa\n"
</pre> <p>If <code>src</code> is an array of paths and <code>dest</code> points to a directory, copies each path <code>path</code> in <code>src</code> to <code>dest/path</code>:</p> <pre class="ruby" data-language="ruby">File.file?('src3.txt') # =&gt; true
File.file?('src3.dat') # =&gt; true
FileUtils.mkdir('dest3')
FileUtils.install(['src3.txt', 'src3.dat'], 'dest3')
File.file?('dest3/src3.txt') # =&gt; true
File.file?('dest3/src3.dat') # =&gt; true
</pre> <p>Keyword arguments:</p> <ul>
<li> <p><code>group: <em>group</em></code> - changes the group if not <code>nil</code>, using <a href="file.html#method-c-chown"><code>File.chown</code></a>.</p> </li>
<li> <p><code>mode: <em>permissions</em></code> - changes the permissions. using <a href="file.html#method-c-chmod"><code>File.chmod</code></a>.</p> </li>
<li> <p><code>noop: true</code> - does not copy entries; returns <code>nil</code>.</p> </li>
<li> <p><code>owner: <em>owner</em></code> - changes the owner if not <code>nil</code>, using <a href="file.html#method-c-chown"><code>File.chown</code></a>.</p> </li>
<li> <p><code>preserve: true</code> - preserve timestamps using <a href="file.html#method-c-utime"><code>File.utime</code></a>.</p> </li>
<li> <p><code>verbose: true</code> - prints an equivalent command:</p> <pre class="ruby" data-language="ruby">FileUtils.install('src0.txt', 'dest0.txt', noop: true, verbose: true)
FileUtils.install('src1.txt', 'dest1.txt', noop: true, verbose: true)
FileUtils.install('src2.txt', 'dest2', noop: true, verbose: true)
</pre> <p>Output:</p> <pre>install -c src0.txt dest0.txt
install -c src1.txt dest1.txt
install -c src2.txt dest2</pre> </li>
</ul> <p>Related: <a href="fileutils.html#module-FileUtils-label-Copying">methods for copying</a>.</p> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-link"> <a href="#method-i-link" title="Link to this method"> <span class="method-name">link</span> <span class="method-args">(src, dest, force: nil, noop: nil, verbose: nil)</span> </a> </div> </div>  <div class="aliases"> Alias for: <a href="fileutils.html#method-i-ln">ln</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-link_entry"> <a href="#method-i-link_entry" title="Link to this method"> <span class="method-name">link_entry</span> <span class="method-args">(src, dest, dereference_root = false, remove_destination = false)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="link_entry-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 813
def link_entry(src, dest, dereference_root = false, remove_destination = false)
  Entry_.new(src, nil, dereference_root).traverse do |ent|
    destent = Entry_.new(dest, ent.rel, false)
    File.unlink destent.path if remove_destination &amp;&amp; File.file?(destent.path)
    ent.link destent.path
  end
end</pre> </div>  <p>Creates <a href="https://en.wikipedia.org/wiki/Hard_link">hard links</a>; returns <code>nil</code>.</p> <p>Arguments <code>src</code> and <code>dest</code> should be <a href="fileutils.html#module-FileUtils-label-Path+Arguments">interpretable as paths</a>.</p> <p>If <code>src</code> is the path to a file and <code>dest</code> does not exist, creates a hard link at <code>dest</code> pointing to <code>src</code>:</p> <pre class="ruby" data-language="ruby">FileUtils.touch('src0.txt')
File.exist?('dest0.txt') # =&gt; false
FileUtils.link_entry('src0.txt', 'dest0.txt')
File.file?('dest0.txt')  # =&gt; true
</pre> <p>If <code>src</code> is the path to a directory and <code>dest</code> does not exist, recursively creates hard links at <code>dest</code> pointing to paths in <code>src</code>:</p> <pre class="ruby" data-language="ruby">FileUtils.mkdir_p(['src1/dir0', 'src1/dir1'])
src_file_paths = [
  'src1/dir0/t0.txt',
  'src1/dir0/t1.txt',
  'src1/dir1/t2.txt',
  'src1/dir1/t3.txt',
  ]
FileUtils.touch(src_file_paths)
File.directory?('dest1')        # =&gt; true
FileUtils.link_entry('src1', 'dest1')
File.file?('dest1/dir0/t0.txt') # =&gt; true
File.file?('dest1/dir0/t1.txt') # =&gt; true
File.file?('dest1/dir1/t2.txt') # =&gt; true
File.file?('dest1/dir1/t3.txt') # =&gt; true
</pre> <p>Keyword arguments:</p> <ul>
<li> <p><code>dereference_root: true</code> - dereferences <code>src</code> if it is a symbolic link.</p> </li>
<li> <p><code>remove_destination: true</code> - removes <code>dest</code> before creating links.</p> </li>
</ul> <p>Raises an exception if <code>dest</code> is the path to an existing file or directory and keyword argument <code>remove_destination: true</code> is not given.</p> <p>Related: <a href="fileutils.html#method-c-ln"><code>FileUtils.ln</code></a> (has different options).</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-ln"> <a href="#method-i-ln" title="Link to this method"> <span class="method-name">ln</span> <span class="method-args">(src, dest, force: nil, noop: nil, verbose: nil)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="ln-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 517
def ln(src, dest, force: nil, noop: nil, verbose: nil)
  fu_output_message "ln#{force ? ' -f' : ''} #{[src,dest].flatten.join ' '}" if verbose
  return if noop
  fu_each_src_dest0(src, dest) do |s,d|
    remove_file d, true if force
    File.link s, d
  end
end</pre> </div>  <p>Creates <a href="https://en.wikipedia.org/wiki/Hard_link">hard links</a>.</p> <p>Arguments <code>src</code> (a single path or an array of paths) and <code>dest</code> (a single path) should be <a href="fileutils.html#module-FileUtils-label-Path+Arguments">interpretable as paths</a>.</p> <p>When <code>src</code> is the path to an existing file and <code>dest</code> is the path to a non-existent file, creates a hard link at <code>dest</code> pointing to <code>src</code>; returns zero:</p> <pre class="ruby" data-language="ruby">Dir.children('tmp0/')                    # =&gt; ["t.txt"]
Dir.children('tmp1/')                    # =&gt; []
FileUtils.ln('tmp0/t.txt', 'tmp1/t.lnk') # =&gt; 0
Dir.children('tmp1/')                    # =&gt; ["t.lnk"]
</pre> <p>When <code>src</code> is the path to an existing file and <code>dest</code> is the path to an existing directory, creates a hard link at <code>dest/src</code> pointing to <code>src</code>; returns zero:</p> <pre class="ruby" data-language="ruby">Dir.children('tmp2')               # =&gt; ["t.dat"]
Dir.children('tmp3')               # =&gt; []
FileUtils.ln('tmp2/t.dat', 'tmp3') # =&gt; 0
Dir.children('tmp3')               # =&gt; ["t.dat"]
</pre> <p>When <code>src</code> is an array of paths to existing files and <code>dest</code> is the path to an existing directory, then for each path <code>target</code> in <code>src</code>, creates a hard link at <code>dest/target</code> pointing to <code>target</code>; returns <code>src</code>:</p> <pre class="ruby" data-language="ruby">Dir.children('tmp4/')                               # =&gt; []
FileUtils.ln(['tmp0/t.txt', 'tmp2/t.dat'], 'tmp4/') # =&gt; ["tmp0/t.txt", "tmp2/t.dat"]
Dir.children('tmp4/')                               # =&gt; ["t.dat", "t.txt"]
</pre> <p>Keyword arguments:</p> <ul>
<li> <p><code>force: true</code> - overwrites <code>dest</code> if it exists.</p> </li>
<li> <p><code>noop: true</code> - does not create links.</p> </li>
<li> <p><code>verbose: true</code> - prints an equivalent command:</p> <pre class="ruby" data-language="ruby">FileUtils.ln('tmp0/t.txt', 'tmp1/t.lnk', verbose: true)
FileUtils.ln('tmp2/t.dat', 'tmp3', verbose: true)
FileUtils.ln(['tmp0/t.txt', 'tmp2/t.dat'], 'tmp4/', verbose: true)
</pre> <p>Output:</p> <pre>ln tmp0/t.txt tmp1/t.lnk
ln tmp2/t.dat tmp3
ln tmp0/t.txt tmp2/t.dat tmp4/</pre> </li>
</ul> <p>Raises an exception if <code>dest</code> is the path to an existing file and keyword argument <code>force</code> is not <code>true</code>.</p> <p>Related: <a href="fileutils.html#method-c-link_entry"><code>FileUtils.link_entry</code></a> (has different options).</p> </div> <div class="aliases"> Also aliased as: <a href="fileutils.html#method-i-link">link</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-ln_s"> <a href="#method-i-ln_s" title="Link to this method"> <span class="method-name">ln_s</span> <span class="method-args">(src, dest, force: nil, relative: false, target_directory: true, noop: nil, verbose: nil)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="ln_s-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 707
def ln_s(src, dest, force: nil, relative: false, target_directory: true, noop: nil, verbose: nil)
  if relative
    return ln_sr(src, dest, force: force, noop: noop, verbose: verbose)
  end
  fu_output_message "ln -s#{force ? 'f' : ''} #{[src,dest].flatten.join ' '}" if verbose
  return if noop
  fu_each_src_dest0(src, dest) do |s,d|
    remove_file d, true if force
    File.symlink s, d
  end
end</pre> </div>  <p>Creates <a href="https://en.wikipedia.org/wiki/Symbolic_link">symbolic links</a>.</p> <p>Arguments <code>src</code> (a single path or an array of paths) and <code>dest</code> (a single path) should be <a href="fileutils.html#module-FileUtils-label-Path+Arguments">interpretable as paths</a>.</p> <p>If <code>src</code> is the path to an existing file:</p> <ul>
<li> <p>When <code>dest</code> is the path to a non-existent file, creates a symbolic link at <code>dest</code> pointing to <code>src</code>:</p> <pre class="ruby" data-language="ruby">FileUtils.touch('src0.txt')
File.exist?('dest0.txt')   # =&gt; false
FileUtils.ln_s('src0.txt', 'dest0.txt')
File.symlink?('dest0.txt') # =&gt; true
</pre> </li>
<li> <p>When <code>dest</code> is the path to an existing file, creates a symbolic link at <code>dest</code> pointing to <code>src</code> if and only if keyword argument <code>force: true</code> is given (raises an exception otherwise):</p> <pre class="ruby" data-language="ruby">FileUtils.touch('src1.txt')
FileUtils.touch('dest1.txt')
FileUtils.ln_s('src1.txt', 'dest1.txt', force: true)
FileTest.symlink?('dest1.txt') # =&gt; true

FileUtils.ln_s('src1.txt', 'dest1.txt') # Raises Errno::EEXIST.
</pre> </li>
</ul> <p>If <code>dest</code> is the path to a directory, creates a symbolic link at <code>dest/src</code> pointing to <code>src</code>:</p> <pre class="ruby" data-language="ruby">FileUtils.touch('src2.txt')
FileUtils.mkdir('destdir2')
FileUtils.ln_s('src2.txt', 'destdir2')
File.symlink?('destdir2/src2.txt') # =&gt; true
</pre> <p>If <code>src</code> is an array of paths to existing files and <code>dest</code> is a directory, for each child <code>child</code> in <code>src</code> creates a symbolic link <code>dest/child</code> pointing to <code>child</code>:</p> <pre class="ruby" data-language="ruby">FileUtils.mkdir('srcdir3')
FileUtils.touch('srcdir3/src0.txt')
FileUtils.touch('srcdir3/src1.txt')
FileUtils.mkdir('destdir3')
FileUtils.ln_s(['srcdir3/src0.txt', 'srcdir3/src1.txt'], 'destdir3')
File.symlink?('destdir3/src0.txt') # =&gt; true
File.symlink?('destdir3/src1.txt') # =&gt; true
</pre> <p>Keyword arguments:</p> <ul>
<li> <p><code>force: true</code> - overwrites <code>dest</code> if it exists.</p> </li>
<li> <p><code>relative: false</code> - create links relative to <code>dest</code>.</p> </li>
<li> <p><code>noop: true</code> - does not create links.</p> </li>
<li> <p><code>verbose: true</code> - prints an equivalent command:</p> <pre class="ruby" data-language="ruby">FileUtils.ln_s('src0.txt', 'dest0.txt', noop: true, verbose: true)
FileUtils.ln_s('src1.txt', 'destdir1', noop: true, verbose: true)
FileUtils.ln_s('src2.txt', 'dest2.txt', force: true, noop: true, verbose: true)
FileUtils.ln_s(['srcdir3/src0.txt', 'srcdir3/src1.txt'], 'destdir3', noop: true, verbose: true)
</pre> <p>Output:</p> <pre>ln -s src0.txt dest0.txt
ln -s src1.txt destdir1
ln -sf src2.txt dest2.txt
ln -s srcdir3/src0.txt srcdir3/src1.txt destdir3</pre> </li>
</ul> <p>Related: <a href="fileutils.html#method-c-ln_sf"><code>FileUtils.ln_sf</code></a>.</p> </div> <div class="aliases"> Also aliased as: <a href="fileutils.html#method-i-symlink">symlink</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-ln_sf"> <a href="#method-i-ln_sf" title="Link to this method"> <span class="method-name">ln_sf</span> <span class="method-args">(src, dest, noop: nil, verbose: nil)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="ln_sf-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 725
def ln_sf(src, dest, noop: nil, verbose: nil)
  ln_s src, dest, force: true, noop: noop, verbose: verbose
end</pre> </div>  <p>Like <a href="fileutils.html#method-c-ln_s"><code>FileUtils.ln_s</code></a>, but always with keyword argument <code>force: true</code> given.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-ln_sr"> <a href="#method-i-ln_sr" title="Link to this method"> <span class="method-name">ln_sr</span> <span class="method-args">(src, dest, target_directory: true, force: nil, noop: nil, verbose: nil)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="ln_sr-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 732
def ln_sr(src, dest, target_directory: true, force: nil, noop: nil, verbose: nil)
  options = "#{force ? 'f' : ''}#{target_directory ? '' : 'T'}"
  dest = File.path(dest)
  srcs = Array(src)
  link = proc do |s, target_dir_p = true|
    s = File.path(s)
    if target_dir_p
      d = File.join(destdirs = dest, File.basename(s))
    else
      destdirs = File.dirname(d = dest)
    end
    destdirs = fu_split_path(File.realpath(destdirs))
    if fu_starting_path?(s)
      srcdirs = fu_split_path((File.realdirpath(s) rescue File.expand_path(s)))
      base = fu_relative_components_from(srcdirs, destdirs)
      s = File.join(*base)
    else
      srcdirs = fu_clean_components(*fu_split_path(s))
      base = fu_relative_components_from(fu_split_path(Dir.pwd), destdirs)
      while srcdirs.first&amp;. == ".." and base.last&amp;.!=("..") and !fu_starting_path?(base.last)
        srcdirs.shift
        base.pop
      end
      s = File.join(*base, *srcdirs)
    end
    fu_output_message "ln -s#{options} #{s} #{d}" if verbose
    next if noop
    remove_file d, true if force
    File.symlink s, d
  end
  case srcs.size
  when 0
  when 1
    link[srcs[0], target_directory &amp;&amp; File.directory?(dest)]
  else
    srcs.each(&amp;link)
  end
end</pre> </div>  <p>Like <a href="fileutils.html#method-c-ln_s"><code>FileUtils.ln_s</code></a>, but create links relative to <code>dest</code>.</p> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-makedirs"> <a href="#method-i-makedirs" title="Link to this method"> <span class="method-name">makedirs</span> <span class="method-args">(list, mode: nil, noop: nil, verbose: nil)</span> </a> </div> </div>  <div class="aliases"> Alias for: <a href="fileutils.html#method-i-mkdir_p">mkdir_p</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-mkdir"> <a href="#method-i-mkdir" title="Link to this method"> <span class="method-name">mkdir</span> <span class="method-args">(list, mode: nil, noop: nil, verbose: nil)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="mkdir-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 317
def mkdir(list, mode: nil, noop: nil, verbose: nil)
  list = fu_list(list)
  fu_output_message "mkdir #{mode ? ('-m %03o ' % mode) : ''}#{list.join ' '}" if verbose
  return if noop

  list.each do |dir|
    fu_mkdir dir, mode
  end
end</pre> </div>  <p>Creates directories at the paths in the given <code>list</code> (a single path or an array of paths); returns <code>list</code> if it is an array, <code>[list]</code> otherwise.</p> <p>Argument <code>list</code> or its elements should be <a href="fileutils.html#module-FileUtils-label-Path+Arguments">interpretable as paths</a>.</p> <p>With no keyword arguments, creates a directory at each <code>path</code> in <code>list</code> by calling: <a href="dir.html#method-c-mkdir"><code>Dir.mkdir(path, mode)</code></a>; see <a href="dir.html#method-c-mkdir"><code>Dir.mkdir</code></a>:</p> <pre class="ruby" data-language="ruby">FileUtils.mkdir(%w[tmp0 tmp1]) # =&gt; ["tmp0", "tmp1"]
FileUtils.mkdir('tmp4')        # =&gt; ["tmp4"]
</pre> <p>Keyword arguments:</p> <ul>
<li> <p><code>mode: <em>mode</em></code> - also calls <a href="file.html#method-c-chmod"><code>File.chmod(mode, path)</code></a>; see <a href="file.html#method-c-chmod"><code>File.chmod</code></a>.</p> </li>
<li> <p><code>noop: true</code> - does not create directories.</p> </li>
<li> <p><code>verbose: true</code> - prints an equivalent command:</p> <pre class="ruby" data-language="ruby">FileUtils.mkdir(%w[tmp0 tmp1], verbose: true)
FileUtils.mkdir(%w[tmp2 tmp3], mode: 0700, verbose: true)
</pre> <p>Output:</p> <pre>mkdir tmp0 tmp1
mkdir -m 700 tmp2 tmp3</pre> </li>
</ul> <p>Raises an exception if any path points to an existing file or directory, or if for any reason a directory cannot be created.</p> <p>Related: <a href="fileutils.html#method-c-mkdir_p"><code>FileUtils.mkdir_p</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-mkdir_p"> <a href="#method-i-mkdir_p" title="Link to this method"> <span class="method-name">mkdir_p</span> <span class="method-args">(list, mode: nil, noop: nil, verbose: nil)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="mkdir_p-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 366
def mkdir_p(list, mode: nil, noop: nil, verbose: nil)
  list = fu_list(list)
  fu_output_message "mkdir -p #{mode ? ('-m %03o ' % mode) : ''}#{list.join ' '}" if verbose
  return *list if noop

  list.each do |item|
    path = remove_trailing_slash(item)

    stack = []
    until File.directory?(path) || File.dirname(path) == path
      stack.push path
      path = File.dirname(path)
    end
    stack.reverse_each do |dir|
      begin
        fu_mkdir dir, mode
      rescue SystemCallError
        raise unless File.directory?(dir)
      end
    end
  end

  return *list
end</pre> </div>  <p>Creates directories at the paths in the given <code>list</code> (a single path or an array of paths), also creating ancestor directories as needed; returns <code>list</code> if it is an array, <code>[list]</code> otherwise.</p> <p>Argument <code>list</code> or its elements should be <a href="fileutils.html#module-FileUtils-label-Path+Arguments">interpretable as paths</a>.</p> <p>With no keyword arguments, creates a directory at each <code>path</code> in <code>list</code>, along with any needed ancestor directories, by calling: <a href="dir.html#method-c-mkdir"><code>Dir.mkdir(path, mode)</code></a>; see <a href="dir.html#method-c-mkdir"><code>Dir.mkdir</code></a>:</p> <pre class="ruby" data-language="ruby">FileUtils.mkdir_p(%w[tmp0/tmp1 tmp2/tmp3]) # =&gt; ["tmp0/tmp1", "tmp2/tmp3"]
FileUtils.mkdir_p('tmp4/tmp5')             # =&gt; ["tmp4/tmp5"]
</pre> <p>Keyword arguments:</p> <ul>
<li> <p><code>mode: <em>mode</em></code> - also calls <a href="file.html#method-c-chmod"><code>File.chmod(mode, path)</code></a>; see <a href="file.html#method-c-chmod"><code>File.chmod</code></a>.</p> </li>
<li> <p><code>noop: true</code> - does not create directories.</p> </li>
<li> <p><code>verbose: true</code> - prints an equivalent command:</p> <pre class="ruby" data-language="ruby">FileUtils.mkdir_p(%w[tmp0 tmp1], verbose: true)
FileUtils.mkdir_p(%w[tmp2 tmp3], mode: 0700, verbose: true)
</pre> <p>Output:</p> <pre>mkdir -p tmp0 tmp1
mkdir -p -m 700 tmp2 tmp3</pre> </li>
</ul> <p>Raises an exception if for any reason a directory cannot be created.</p> <p><a href="fileutils.html#method-c-mkpath"><code>FileUtils.mkpath</code></a> and <a href="fileutils.html#method-c-makedirs"><code>FileUtils.makedirs</code></a> are aliases for <a href="fileutils.html#method-c-mkdir_p"><code>FileUtils.mkdir_p</code></a>.</p> <p>Related: <a href="fileutils.html#method-c-mkdir"><code>FileUtils.mkdir</code></a>.</p> </div> <div class="aliases"> Also aliased as: <a href="fileutils.html#method-i-mkpath">mkpath</a>, <a href="fileutils.html#method-i-makedirs">makedirs</a> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-mkpath"> <a href="#method-i-mkpath" title="Link to this method"> <span class="method-name">mkpath</span> <span class="method-args">(list, mode: nil, noop: nil, verbose: nil)</span> </a> </div> </div>  <div class="aliases"> Alias for: <a href="fileutils.html#method-i-mkdir_p">mkdir_p</a> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-move"> <a href="#method-i-move" title="Link to this method"> <span class="method-name">move</span> <span class="method-args">(src, dest, force: nil, noop: nil, verbose: nil, secure: nil)</span> </a> </div> </div>  <div class="aliases"> Alias for: <a href="fileutils.html#method-i-mv">mv</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-mv"> <a href="#method-i-mv" title="Link to this method"> <span class="method-name">mv</span> <span class="method-args">(src, dest, force: nil, noop: nil, verbose: nil, secure: nil)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="mv-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 1158
def mv(src, dest, force: nil, noop: nil, verbose: nil, secure: nil)
  fu_output_message "mv#{force ? ' -f' : ''} #{[src,dest].flatten.join ' '}" if verbose
  return if noop
  fu_each_src_dest(src, dest) do |s, d|
    destent = Entry_.new(d, nil, true)
    begin
      if destent.exist?
        if destent.directory?
          raise Errno::EEXIST, d
        end
      end
      begin
        File.rename s, d
      rescue Errno::EXDEV,
             Errno::EPERM # move from unencrypted to encrypted dir (ext4)
        copy_entry s, d, true
        if secure
          remove_entry_secure s, force
        else
          remove_entry s, force
        end
      end
    rescue SystemCallError
      raise unless force
    end
  end
end</pre> </div>  <p>Moves entries.</p> <p>Arguments <code>src</code> (a single path or an array of paths) and <code>dest</code> (a single path) should be <a href="fileutils.html#module-FileUtils-label-Path+Arguments">interpretable as paths</a>.</p> <p>If <code>src</code> and <code>dest</code> are on different file systems, first copies, then removes <code>src</code>.</p> <p>May cause a local vulnerability if not called with keyword argument <code>secure: true</code>; see <a href="fileutils.html#module-FileUtils-label-Avoiding+the+TOCTTOU+Vulnerability">Avoiding the TOCTTOU Vulnerability</a>.</p> <p>If <code>src</code> is the path to a single file or directory and <code>dest</code> does not exist, moves <code>src</code> to <code>dest</code>:</p> <pre class="ruby" data-language="ruby">tree('src0')
# =&gt; src0
#    |-- src0.txt
#    `-- src1.txt
File.exist?('dest0') # =&gt; false
FileUtils.mv('src0', 'dest0')
File.exist?('src0')  # =&gt; false
tree('dest0')
# =&gt; dest0
#    |-- src0.txt
#    `-- src1.txt
</pre> <p>If <code>src</code> is an array of paths to files and directories and <code>dest</code> is the path to a directory, copies from each path in the array to <code>dest</code>:</p> <pre class="ruby" data-language="ruby">File.file?('src1.txt') # =&gt; true
tree('src1')
# =&gt; src1
#    |-- src.dat
#    `-- src.txt
Dir.empty?('dest1')    # =&gt; true
FileUtils.mv(['src1.txt', 'src1'], 'dest1')
tree('dest1')
# =&gt; dest1
#    |-- src1
#    |   |-- src.dat
#    |   `-- src.txt
#    `-- src1.txt
</pre> <p>Keyword arguments:</p> <ul>
<li> <p><code>force: true</code> - if the move includes removing <code>src</code> (that is, if <code>src</code> and <code>dest</code> are on different file systems), ignores raised exceptions of <a href="standarderror.html"><code>StandardError</code></a> and its descendants.</p> </li>
<li> <p><code>noop: true</code> - does not move files.</p> </li>
<li> <p><code>secure: true</code> - removes <code>src</code> securely; see details at <a href="fileutils.html#method-c-remove_entry_secure"><code>FileUtils.remove_entry_secure</code></a>.</p> </li>
<li> <p><code>verbose: true</code> - prints an equivalent command:</p> <pre class="ruby" data-language="ruby">FileUtils.mv('src0', 'dest0', noop: true, verbose: true)
FileUtils.mv(['src1.txt', 'src1'], 'dest1', noop: true, verbose: true)
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">mv src0 dest0
mv src1.txt src1 dest1
</pre> </li>
</ul> </div> <div class="aliases"> Also aliased as: <a href="fileutils.html#method-i-move">move</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-pwd"> <a href="#method-i-pwd" title="Link to this method"> <span class="method-name">pwd</span> <span class="method-args">()</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="pwd-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 198
def pwd
  Dir.pwd
end</pre> </div>  <p>Returns a string containing the path to the current directory:</p> <pre class="ruby" data-language="ruby">FileUtils.pwd # =&gt; "/rdoc/fileutils"
</pre> <p>Related: <a href="fileutils.html#method-c-cd"><code>FileUtils.cd</code></a>.</p> </div> <div class="aliases"> Also aliased as: <a href="fileutils.html#method-i-getwd">getwd</a> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-remove"> <a href="#method-i-remove" title="Link to this method"> <span class="method-name">remove</span> <span class="method-args">(list, force: nil, noop: nil, verbose: nil)</span> </a> </div> </div>  <div class="aliases"> Alias for: <a href="fileutils.html#method-i-rm">rm</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-remove_dir"> <a href="#method-i-remove_dir" title="Link to this method"> <span class="method-name">remove_dir</span> <span class="method-args">(path, force = false)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="remove_dir-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 1493
def remove_dir(path, force = false)
  remove_entry path, force   # FIXME?? check if it is a directory
end</pre> </div>  <p>Recursively removes the directory entry given by <code>path</code>, which should be the entry for a regular file, a symbolic link, or a directory.</p> <p>Argument <code>path</code> should be <a href="fileutils.html#module-FileUtils-label-Path+Arguments">interpretable as a path</a>.</p> <p>Optional argument <code>force</code> specifies whether to ignore raised exceptions of <a href="standarderror.html"><code>StandardError</code></a> and its descendants.</p> <p>Related: <a href="fileutils.html#module-FileUtils-label-Deleting">methods for deleting</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-remove_entry"> <a href="#method-i-remove_entry" title="Link to this method"> <span class="method-name">remove_entry</span> <span class="method-args">(path, force = false)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="remove_entry-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 1450
def remove_entry(path, force = false)
  Entry_.new(path).postorder_traverse do |ent|
    begin
      ent.remove
    rescue
      raise unless force
    end
  end
rescue
  raise unless force
end</pre> </div>  <p>Removes the entry given by <code>path</code>, which should be the entry for a regular file, a symbolic link, or a directory.</p> <p>Argument <code>path</code> should be <a href="fileutils.html#module-FileUtils-label-Path+Arguments">interpretable as a path</a>.</p> <p>Optional argument <code>force</code> specifies whether to ignore raised exceptions of <a href="standarderror.html"><code>StandardError</code></a> and its descendants.</p> <p>Related: <a href="fileutils.html#method-c-remove_entry_secure"><code>FileUtils.remove_entry_secure</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-remove_entry_secure"> <a href="#method-i-remove_entry_secure" title="Link to this method"> <span class="method-name">remove_entry_secure</span> <span class="method-args">(path, force = false)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="remove_entry_secure-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 1352
def remove_entry_secure(path, force = false)
  unless fu_have_symlink?
    remove_entry path, force
    return
  end
  fullpath = File.expand_path(path)
  st = File.lstat(fullpath)
  unless st.directory?
    File.unlink fullpath
    return
  end
  # is a directory.
  parent_st = File.stat(File.dirname(fullpath))
  unless parent_st.world_writable?
    remove_entry path, force
    return
  end
  unless parent_st.sticky?
    raise ArgumentError, "parent directory is world writable, FileUtils#remove_entry_secure does not work; abort: #{path.inspect} (parent directory mode #{'%o' % parent_st.mode})"
  end

  # freeze tree root
  euid = Process.euid
  dot_file = fullpath + "/."
  begin
    File.open(dot_file) {|f|
      unless fu_stat_identical_entry?(st, f.stat)
        # symlink (TOC-to-TOU attack?)
        File.unlink fullpath
        return
      end
      f.chown euid, -1
      f.chmod 0700
    }
  rescue Errno::EISDIR # JRuby in non-native mode can't open files as dirs
    File.lstat(dot_file).tap {|fstat|
      unless fu_stat_identical_entry?(st, fstat)
        # symlink (TOC-to-TOU attack?)
        File.unlink fullpath
        return
      end
      File.chown euid, -1, dot_file
      File.chmod 0700, dot_file
    }
  end

  unless fu_stat_identical_entry?(st, File.lstat(fullpath))
    # TOC-to-TOU attack?
    File.unlink fullpath
    return
  end

  # ---- tree root is frozen ----
  root = Entry_.new(path)
  root.preorder_traverse do |ent|
    if ent.directory?
      ent.chown euid, -1
      ent.chmod 0700
    end
  end
  root.postorder_traverse do |ent|
    begin
      ent.remove
    rescue
      raise unless force
    end
  end
rescue
  raise unless force
end</pre> </div>  <p>Securely removes the entry given by <code>path</code>, which should be the entry for a regular file, a symbolic link, or a directory.</p> <p>Argument <code>path</code> should be <a href="fileutils.html#module-FileUtils-label-Path+Arguments">interpretable as a path</a>.</p> <p>Avoids a local vulnerability that can exist in certain circumstances; see <a href="fileutils.html#module-FileUtils-label-Avoiding+the+TOCTTOU+Vulnerability">Avoiding the TOCTTOU Vulnerability</a>.</p> <p>Optional argument <code>force</code> specifies whether to ignore raised exceptions of <a href="standarderror.html"><code>StandardError</code></a> and its descendants.</p> <p>Related: <a href="fileutils.html#module-FileUtils-label-Deleting">methods for deleting</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-remove_file"> <a href="#method-i-remove_file" title="Link to this method"> <span class="method-name">remove_file</span> <span class="method-args">(path, force = false)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="remove_file-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 1474
def remove_file(path, force = false)
  Entry_.new(path).remove_file
rescue
  raise unless force
end</pre> </div>  <p>Removes the file entry given by <code>path</code>, which should be the entry for a regular file or a symbolic link.</p> <p>Argument <code>path</code> should be <a href="fileutils.html#module-FileUtils-label-Path+Arguments">interpretable as a path</a>.</p> <p>Optional argument <code>force</code> specifies whether to ignore raised exceptions of <a href="standarderror.html"><code>StandardError</code></a> and its descendants.</p> <p>Related: <a href="fileutils.html#module-FileUtils-label-Deleting">methods for deleting</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-rm"> <a href="#method-i-rm" title="Link to this method"> <span class="method-name">rm</span> <span class="method-args">(list, force: nil, noop: nil, verbose: nil)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="rm-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 1217
def rm(list, force: nil, noop: nil, verbose: nil)
  list = fu_list(list)
  fu_output_message "rm#{force ? ' -f' : ''} #{list.join ' '}" if verbose
  return if noop

  list.each do |path|
    remove_file path, force
  end
end</pre> </div>  <p>Removes entries at the paths in the given <code>list</code> (a single path or an array of paths) returns <code>list</code>, if it is an array, <code>[list]</code> otherwise.</p> <p>Argument <code>list</code> or its elements should be <a href="fileutils.html#module-FileUtils-label-Path+Arguments">interpretable as paths</a>.</p> <p>With no keyword arguments, removes files at the paths given in <code>list</code>:</p> <pre class="ruby" data-language="ruby">FileUtils.touch(['src0.txt', 'src0.dat'])
FileUtils.rm(['src0.dat', 'src0.txt']) # =&gt; ["src0.dat", "src0.txt"]
</pre> <p>Keyword arguments:</p> <ul>
<li> <p><code>force: true</code> - ignores raised exceptions of <a href="standarderror.html"><code>StandardError</code></a> and its descendants.</p> </li>
<li> <p><code>noop: true</code> - does not remove files; returns <code>nil</code>.</p> </li>
<li> <p><code>verbose: true</code> - prints an equivalent command:</p> <pre class="ruby" data-language="ruby">FileUtils.rm(['src0.dat', 'src0.txt'], noop: true, verbose: true)
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">rm src0.dat src0.txt
</pre> </li>
</ul> <p>Related: <a href="fileutils.html#module-FileUtils-label-Deleting">methods for deleting</a>.</p> </div> <div class="aliases"> Also aliased as: <a href="fileutils.html#method-i-remove">remove</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-rm_f"> <a href="#method-i-rm_f" title="Link to this method"> <span class="method-name">rm_f</span> <span class="method-args">(list, noop: nil, verbose: nil)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="rm_f-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 1242
def rm_f(list, noop: nil, verbose: nil)
  rm list, force: true, noop: noop, verbose: verbose
end</pre> </div>  <p>Equivalent to:</p> <pre class="ruby" data-language="ruby">FileUtils.rm(list, force: true, **kwargs)
</pre> <p>Argument <code>list</code> (a single path or an array of paths) should be <a href="fileutils.html#module-FileUtils-label-Path+Arguments">interpretable as paths</a>.</p> <p>See <a href="fileutils.html#method-c-rm"><code>FileUtils.rm</code></a> for keyword arguments.</p> <p>Related: <a href="fileutils.html#module-FileUtils-label-Deleting">methods for deleting</a>.</p> </div> <div class="aliases"> Also aliased as: <a href="fileutils.html#method-i-safe_unlink">safe_unlink</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-rm_r"> <a href="#method-i-rm_r" title="Link to this method"> <span class="method-name">rm_r</span> <span class="method-args">(list, force: nil, noop: nil, verbose: nil, secure: nil)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="rm_r-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 1300
def rm_r(list, force: nil, noop: nil, verbose: nil, secure: nil)
  list = fu_list(list)
  fu_output_message "rm -r#{force ? 'f' : ''} #{list.join ' '}" if verbose
  return if noop
  list.each do |path|
    if secure
      remove_entry_secure path, force
    else
      remove_entry path, force
    end
  end
end</pre> </div>  <p>Removes entries at the paths in the given <code>list</code> (a single path or an array of paths); returns <code>list</code>, if it is an array, <code>[list]</code> otherwise.</p> <p>Argument <code>list</code> or its elements should be <a href="fileutils.html#module-FileUtils-label-Path+Arguments">interpretable as paths</a>.</p> <p>May cause a local vulnerability if not called with keyword argument <code>secure: true</code>; see <a href="fileutils.html#module-FileUtils-label-Avoiding+the+TOCTTOU+Vulnerability">Avoiding the TOCTTOU Vulnerability</a>.</p> <p>For each file path, removes the file at that path:</p> <pre class="ruby" data-language="ruby">FileUtils.touch(['src0.txt', 'src0.dat'])
FileUtils.rm_r(['src0.dat', 'src0.txt'])
File.exist?('src0.txt') # =&gt; false
File.exist?('src0.dat') # =&gt; false
</pre> <p>For each directory path, recursively removes files and directories:</p> <pre class="ruby" data-language="ruby">tree('src1')
# =&gt; src1
#    |-- dir0
#    |   |-- src0.txt
#    |   `-- src1.txt
#    `-- dir1
#        |-- src2.txt
#        `-- src3.txt
FileUtils.rm_r('src1')
File.exist?('src1') # =&gt; false
</pre> <p>Keyword arguments:</p> <ul>
<li> <p><code>force: true</code> - ignores raised exceptions of <a href="standarderror.html"><code>StandardError</code></a> and its descendants.</p> </li>
<li> <p><code>noop: true</code> - does not remove entries; returns <code>nil</code>.</p> </li>
<li> <p><code>secure: true</code> - removes <code>src</code> securely; see details at <a href="fileutils.html#method-c-remove_entry_secure"><code>FileUtils.remove_entry_secure</code></a>.</p> </li>
<li> <p><code>verbose: true</code> - prints an equivalent command:</p> <pre class="ruby" data-language="ruby">FileUtils.rm_r(['src0.dat', 'src0.txt'], noop: true, verbose: true)
FileUtils.rm_r('src1', noop: true, verbose: true)
</pre> <p>Output:</p> <pre>rm -r src0.dat src0.txt
rm -r src1</pre> </li>
</ul> <p>Related: <a href="fileutils.html#module-FileUtils-label-Deleting">methods for deleting</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-rm_rf"> <a href="#method-i-rm_rf" title="Link to this method"> <span class="method-name">rm_rf</span> <span class="method-args">(list, noop: nil, verbose: nil, secure: nil)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="rm_rf-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 1329
def rm_rf(list, noop: nil, verbose: nil, secure: nil)
  rm_r list, force: true, noop: noop, verbose: verbose, secure: secure
end</pre> </div>  <p>Equivalent to:</p> <pre class="ruby" data-language="ruby">FileUtils.rm_r(list, force: true, **kwargs)
</pre> <p>Argument <code>list</code> or its elements should be <a href="fileutils.html#module-FileUtils-label-Path+Arguments">interpretable as paths</a>.</p> <p>May cause a local vulnerability if not called with keyword argument <code>secure: true</code>; see <a href="fileutils.html#module-FileUtils-label-Avoiding+the+TOCTTOU+Vulnerability">Avoiding the TOCTTOU Vulnerability</a>.</p> <p>See <a href="fileutils.html#method-c-rm_r"><code>FileUtils.rm_r</code></a> for keyword arguments.</p> <p>Related: <a href="fileutils.html#module-FileUtils-label-Deleting">methods for deleting</a>.</p> </div> <div class="aliases"> Also aliased as: <a href="fileutils.html#method-i-rmtree">rmtree</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-rmdir"> <a href="#method-i-rmdir" title="Link to this method"> <span class="method-name">rmdir</span> <span class="method-args">(list, parents: nil, noop: nil, verbose: nil)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="rmdir-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 443
def rmdir(list, parents: nil, noop: nil, verbose: nil)
  list = fu_list(list)
  fu_output_message "rmdir #{parents ? '-p ' : ''}#{list.join ' '}" if verbose
  return if noop
  list.each do |dir|
    Dir.rmdir(dir = remove_trailing_slash(dir))
    if parents
      begin
        until (parent = File.dirname(dir)) == '.' or parent == dir
          dir = parent
          Dir.rmdir(dir)
        end
      rescue Errno::ENOTEMPTY, Errno::EEXIST, Errno::ENOENT
      end
    end
  end
end</pre> </div>  <p>Removes directories at the paths in the given <code>list</code> (a single path or an array of paths); returns <code>list</code>, if it is an array, <code>[list]</code> otherwise.</p> <p>Argument <code>list</code> or its elements should be <a href="fileutils.html#module-FileUtils-label-Path+Arguments">interpretable as paths</a>.</p> <p>With no keyword arguments, removes the directory at each <code>path</code> in <code>list</code>, by calling: <a href="dir.html#method-c-rmdir"><code>Dir.rmdir(path)</code></a>; see <a href="dir.html#method-c-rmdir"><code>Dir.rmdir</code></a>:</p> <pre class="ruby" data-language="ruby">FileUtils.rmdir(%w[tmp0/tmp1 tmp2/tmp3]) # =&gt; ["tmp0/tmp1", "tmp2/tmp3"]
FileUtils.rmdir('tmp4/tmp5')             # =&gt; ["tmp4/tmp5"]
</pre> <p>Keyword arguments:</p> <ul>
<li> <p><code>parents: true</code> - removes successive ancestor directories if empty.</p> </li>
<li> <p><code>noop: true</code> - does not remove directories.</p> </li>
<li> <p><code>verbose: true</code> - prints an equivalent command:</p> <pre class="ruby" data-language="ruby">FileUtils.rmdir(%w[tmp0/tmp1 tmp2/tmp3], parents: true, verbose: true)
FileUtils.rmdir('tmp4/tmp5', parents: true, verbose: true)
</pre> <p>Output:</p> <pre>rmdir -p tmp0/tmp1 tmp2/tmp3
rmdir -p tmp4/tmp5</pre> </li>
</ul> <p>Raises an exception if a directory does not exist or if for any reason a directory cannot be removed.</p> <p>Related: <a href="fileutils.html#module-FileUtils-label-Deleting">methods for deleting</a>.</p> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-rmtree"> <a href="#method-i-rmtree" title="Link to this method"> <span class="method-name">rmtree</span> <span class="method-args">(list, noop: nil, verbose: nil, secure: nil)</span> </a> </div> </div>  <div class="aliases"> Alias for: <a href="fileutils.html#method-i-rm_rf">rm_rf</a> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-safe_unlink"> <a href="#method-i-safe_unlink" title="Link to this method"> <span class="method-name">safe_unlink</span> <span class="method-args">(list, noop: nil, verbose: nil)</span> </a> </div> </div>  <div class="aliases"> Alias for: <a href="fileutils.html#method-i-rm_f">rm_f</a> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-symlink"> <a href="#method-i-symlink" title="Link to this method"> <span class="method-name">symlink</span> <span class="method-args">(src, dest, force: nil, relative: false, target_directory: true, noop: nil, verbose: nil)</span> </a> </div> </div>  <div class="aliases"> Alias for: <a href="fileutils.html#method-i-ln_s">ln_s</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-touch"> <a href="#method-i-touch" title="Link to this method"> <span class="method-name">touch</span> <span class="method-args">(list, noop: nil, verbose: nil, mtime: nil, nocreate: nil)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="touch-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 2007
def touch(list, noop: nil, verbose: nil, mtime: nil, nocreate: nil)
  list = fu_list(list)
  t = mtime
  if verbose
    fu_output_message "touch #{nocreate ? '-c ' : ''}#{t ? t.strftime('-t %Y%m%d%H%M.%S ') : ''}#{list.join ' '}"
  end
  return if noop
  list.each do |path|
    created = nocreate
    begin
      File.utime(t, t, path)
    rescue Errno::ENOENT
      raise if created
      File.open(path, 'a') {
        ;
      }
      created = true
      retry if t
    end
  end
end</pre> </div>  <p>Updates modification times (mtime) and access times (atime) of the entries given by the paths in <code>list</code> (a single path or an array of paths); returns <code>list</code> if it is an array, <code>[list]</code> otherwise.</p> <p>By default, creates an empty file for any path to a non-existent entry; use keyword argument <code>nocreate</code> to raise an exception instead.</p> <p>Argument <code>list</code> or its elements should be <a href="fileutils.html#module-FileUtils-label-Path+Arguments">interpretable as paths</a>.</p> <p>Examples:</p> <pre class="ruby" data-language="ruby"># Single path.
f = File.new('src0.txt') # Existing file.
f.atime # =&gt; 2022-06-10 11:11:21.200277 -0700
f.mtime # =&gt; 2022-06-10 11:11:21.200277 -0700
FileUtils.touch('src0.txt')
f = File.new('src0.txt')
f.atime # =&gt; 2022-06-11 08:28:09.8185343 -0700
f.mtime # =&gt; 2022-06-11 08:28:09.8185343 -0700

# Array of paths.
FileUtils.touch(['src0.txt', 'src0.dat'])
</pre> <p>Keyword arguments:</p> <ul>
<li> <p><code>mtime: <em>time</em></code> - sets the entry’s mtime to the given time, instead of the current time.</p> </li>
<li> <p><code>nocreate: true</code> - raises an exception if the entry does not exist.</p> </li>
<li> <p><code>noop: true</code> - does not touch entries; returns <code>nil</code>.</p> </li>
<li> <p><code>verbose: true</code> - prints an equivalent command:</p> <pre class="ruby" data-language="ruby">FileUtils.touch('src0.txt', noop: true, verbose: true)
FileUtils.touch(['src0.txt', 'src0.dat'], noop: true, verbose: true)
FileUtils.touch(path, noop: true, verbose: true)
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">touch src0.txt
touch src0.txt src0.dat
touch src0.txt
</pre> </li>
</ul> <p>Related: <a href="fileutils.html#method-c-uptodate-3F"><code>FileUtils.uptodate?</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-uptodate-3F"> <a href="#method-i-uptodate-3F" title="Link to this method"> <span class="method-name">uptodate?</span> <span class="method-args">(new, old_list)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="uptodate-3F-source"> <pre class="ruby" data-language="ruby"># File lib/fileutils.rb, line 265
def uptodate?(new, old_list)
  return false unless File.exist?(new)
  new_time = File.mtime(new)
  old_list.each do |old|
    if File.exist?(old)
      return false unless new_time &gt; File.mtime(old)
    end
  end
  true
end</pre> </div>  <p>Returns <code>true</code> if the file at path <code>new</code> is newer than all the files at paths in array <code>old_list</code>; <code>false</code> otherwise.</p> <p>Argument <code>new</code> and the elements of <code>old_list</code> should be <a href="fileutils.html#module-FileUtils-label-Path+Arguments">interpretable as paths</a>:</p> <pre class="ruby" data-language="ruby">FileUtils.uptodate?('Rakefile', ['Gemfile', 'README.md']) # =&gt; true
FileUtils.uptodate?('Gemfile', ['Rakefile', 'README.md']) # =&gt; false
</pre> <p>A non-existent file is considered to be infinitely old.</p> <p>Related: <a href="fileutils.html#method-c-touch"><code>FileUtils.touch</code></a>.</p> </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core &copy; 1993&ndash;2024 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library &copy; contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>
