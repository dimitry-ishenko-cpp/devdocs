<h1 id="class-BasicSocket" class="anchor-link class"> class BasicSocket </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent"><a href="io.html">IO</a></dd>
</dl> <section class="description"> <p><a href="basicsocket.html"><code>BasicSocket</code></a> is the super class for all the <a href="socket.html"><code>Socket</code></a> classes.</p> </section> <section id="5Buntitled-5D" class="documentation-section anchor-link"> <section id="public-class-5Buntitled-5D-method-details" class="method-section anchor-link"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-do_not_reverse_lookup"> <a href="#method-c-do_not_reverse_lookup" title="Link to this method"> <span class="method-callseq"> do_not_reverse_lookup → true or false </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="do_not_reverse_lookup-source"> <pre class="c" data-language="c">static VALUE
bsock_do_not_rev_lookup(VALUE _)
{
    return rsock_do_not_reverse_lookup?Qtrue:Qfalse;
}</pre> </div>  <p>Gets the global <a href="basicsocket.html#method-c-do_not_reverse_lookup"><code>do_not_reverse_lookup</code></a> flag.</p> <pre class="ruby" data-language="ruby">BasicSocket.do_not_reverse_lookup  #=&gt; false
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-do_not_reverse_lookup-3D"> <a href="#method-c-do_not_reverse_lookup-3D" title="Link to this method"> <span class="method-callseq"> do_not_reverse_lookup = bool </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="do_not_reverse_lookup-3D-source"> <pre class="c" data-language="c">static VALUE
bsock_do_not_rev_lookup_set(VALUE self, VALUE val)
{
    rsock_do_not_reverse_lookup = RTEST(val);
    return val;
}</pre> </div>  <p>Sets the global <a href="basicsocket.html#method-c-do_not_reverse_lookup"><code>do_not_reverse_lookup</code></a> flag.</p> <p>The flag is used for initial value of <a href="basicsocket.html#method-c-do_not_reverse_lookup"><code>do_not_reverse_lookup</code></a> for each socket.</p> <pre class="ruby" data-language="ruby">s1 = TCPSocket.new("localhost", 80)
p s1.do_not_reverse_lookup                 #=&gt; true
BasicSocket.do_not_reverse_lookup = false
s2 = TCPSocket.new("localhost", 80)
p s2.do_not_reverse_lookup                 #=&gt; false
p s1.do_not_reverse_lookup                 #=&gt; true
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-for_fd"> <a href="#method-c-for_fd" title="Link to this method"> <span class="method-callseq"> for_fd(fd) → basicsocket </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="for_fd-source"> <pre class="c" data-language="c">static VALUE
bsock_s_for_fd(VALUE klass, VALUE _descriptor)
{
    rb_io_t *fptr;

    int descriptor = RB_NUM2INT(_descriptor);
    rsock_validate_descriptor(descriptor);

    VALUE sock = rsock_init_sock(rb_obj_alloc(klass), descriptor);

    GetOpenFile(sock, fptr);

    return sock;
}</pre> </div>  <p>Returns a socket object which contains the file descriptor, <em>fd</em>.</p> <pre class="ruby" data-language="ruby"># If invoked by inetd, STDIN/STDOUT/STDERR is a socket.
STDIN_SOCK = Socket.for_fd(STDIN.fileno)
p STDIN_SOCK.remote_address
</pre> </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section anchor-link"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-close_read"> <a href="#method-i-close_read" title="Link to this method"> <span class="method-callseq"> close_read → nil </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="close_read-source"> <pre class="c" data-language="c">static VALUE
bsock_close_read(VALUE sock)
{
    rb_io_t *fptr;

    GetOpenFile(sock, fptr);
    shutdown(fptr-&gt;fd, SHUT_RD);
    if (!(fptr-&gt;mode &amp; FMODE_WRITABLE)) {
        return rb_io_close(sock);
    }
    fptr-&gt;mode &amp;= ~FMODE_READABLE;

    return Qnil;
}</pre> </div>  <p>Disallows further read using shutdown system call.</p> <pre class="ruby" data-language="ruby">s1, s2 = UNIXSocket.pair
s1.close_read
s2.puts #=&gt; Broken pipe (Errno::EPIPE)
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-close_write"> <a href="#method-i-close_write" title="Link to this method"> <span class="method-callseq"> close_write → nil </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="close_write-source"> <pre class="c" data-language="c">static VALUE
bsock_close_write(VALUE sock)
{
    rb_io_t *fptr;

    GetOpenFile(sock, fptr);
    if (!(fptr-&gt;mode &amp; FMODE_READABLE)) {
        return rb_io_close(sock);
    }
    shutdown(fptr-&gt;fd, SHUT_WR);
    fptr-&gt;mode &amp;= ~FMODE_WRITABLE;

    return Qnil;
}</pre> </div>  <p>Disallows further write using shutdown system call.</p> <pre class="ruby" data-language="ruby">UNIXSocket.pair {|s1, s2|
  s1.print "ping"
  s1.close_write
  p s2.read        #=&gt; "ping"
  s2.print "pong"
  s2.close
  p s1.read        #=&gt; "pong"
}
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-connect_address"> <a href="#method-i-connect_address" title="Link to this method"> <span class="method-name">connect_address</span> <span class="method-args">()</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="connect_address-source"> <pre class="ruby" data-language="ruby"># File ext/socket/lib/socket.rb, line 255
def connect_address
  addr = local_address
  afamily = addr.afamily
  if afamily == Socket::AF_INET
    raise SocketError, "unbound IPv4 socket" if addr.ip_port == 0
    if addr.ip_address == "0.0.0.0"
      addr = Addrinfo.new(["AF_INET", addr.ip_port, nil, "127.0.0.1"], addr.pfamily, addr.socktype, addr.protocol)
    end
  elsif defined?(Socket::AF_INET6) &amp;&amp; afamily == Socket::AF_INET6
    raise SocketError, "unbound IPv6 socket" if addr.ip_port == 0
    if addr.ip_address == "::"
      addr = Addrinfo.new(["AF_INET6", addr.ip_port, nil, "::1"], addr.pfamily, addr.socktype, addr.protocol)
    elsif addr.ip_address == "0.0.0.0" # MacOS X 10.4 returns "a.b.c.d" for IPv4-mapped IPv6 address.
      addr = Addrinfo.new(["AF_INET6", addr.ip_port, nil, "::1"], addr.pfamily, addr.socktype, addr.protocol)
    elsif addr.ip_address == "::ffff:0.0.0.0" # MacOS X 10.6 returns "::ffff:a.b.c.d" for IPv4-mapped IPv6 address.
      addr = Addrinfo.new(["AF_INET6", addr.ip_port, nil, "::1"], addr.pfamily, addr.socktype, addr.protocol)
    end
  elsif defined?(Socket::AF_UNIX) &amp;&amp; afamily == Socket::AF_UNIX
    raise SocketError, "unbound Unix socket" if addr.unix_path == ""
  end
  addr
end</pre> </div>  <p>Returns an address of the socket suitable for connect in the local machine.</p> <p>This method returns <em>self</em>.local_address, except following condition.</p> <ul>
<li> <p>IPv4 unspecified address (0.0.0.0) is replaced by IPv4 loopback address (127.0.0.1).</p> </li>
<li> <p>IPv6 unspecified address (::) is replaced by IPv6 loopback address (::1).</p> </li>
</ul> <p>If the local address is not suitable for connect, <a href="socketerror.html"><code>SocketError</code></a> is raised. IPv4 and IPv6 address which port is 0 is not suitable for connect. Unix domain socket which has no path is not suitable for connect.</p> <pre class="ruby" data-language="ruby">Addrinfo.tcp("0.0.0.0", 0).listen {|serv|
  p serv.connect_address #=&gt; #&lt;Addrinfo: 127.0.0.1:53660 TCP&gt;
  serv.connect_address.connect {|c|
    s, _ = serv.accept
    p [c, s] #=&gt; [#&lt;Socket:fd 4&gt;, #&lt;Socket:fd 6&gt;]
  }
}
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-do_not_reverse_lookup"> <a href="#method-i-do_not_reverse_lookup" title="Link to this method"> <span class="method-callseq"> do_not_reverse_lookup → true or false </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="do_not_reverse_lookup-source"> <pre class="c" data-language="c">static VALUE
bsock_do_not_reverse_lookup(VALUE sock)
{
    rb_io_t *fptr;

    GetOpenFile(sock, fptr);
    return (fptr-&gt;mode &amp; FMODE_NOREVLOOKUP) ? Qtrue : Qfalse;
}</pre> </div>  <p>Gets the <a href="basicsocket.html#method-c-do_not_reverse_lookup"><code>do_not_reverse_lookup</code></a> flag of <em>basicsocket</em>.</p> <pre class="ruby" data-language="ruby">require 'socket'

BasicSocket.do_not_reverse_lookup = false
TCPSocket.open("www.ruby-lang.org", 80) {|sock|
  p sock.do_not_reverse_lookup      #=&gt; false
}
BasicSocket.do_not_reverse_lookup = true
TCPSocket.open("www.ruby-lang.org", 80) {|sock|
  p sock.do_not_reverse_lookup      #=&gt; true
}
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-do_not_reverse_lookup-3D"> <a href="#method-i-do_not_reverse_lookup-3D" title="Link to this method"> <span class="method-callseq"> do_not_reverse_lookup = bool </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="do_not_reverse_lookup-3D-source"> <pre class="c" data-language="c">static VALUE
bsock_do_not_reverse_lookup_set(VALUE sock, VALUE state)
{
    rb_io_t *fptr;

    GetOpenFile(sock, fptr);
    if (RTEST(state)) {
        fptr-&gt;mode |= FMODE_NOREVLOOKUP;
    }
    else {
        fptr-&gt;mode &amp;= ~FMODE_NOREVLOOKUP;
    }
    return sock;
}</pre> </div>  <p>Sets the <a href="basicsocket.html#method-c-do_not_reverse_lookup"><code>do_not_reverse_lookup</code></a> flag of <em>basicsocket</em>.</p> <pre class="ruby" data-language="ruby">TCPSocket.open("www.ruby-lang.org", 80) {|sock|
  p sock.do_not_reverse_lookup       #=&gt; true
  p sock.peeraddr                    #=&gt; ["AF_INET", 80, "221.186.184.68", "221.186.184.68"]
  sock.do_not_reverse_lookup = false
  p sock.peeraddr                    #=&gt; ["AF_INET", 80, "carbon.ruby-lang.org", "54.163.249.195"]
}
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-getpeereid"> <a href="#method-i-getpeereid" title="Link to this method"> <span class="method-callseq"> getpeereid → [euid, egid] </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="getpeereid-source"> <pre class="c" data-language="c">static VALUE
bsock_getpeereid(VALUE self)
{
#if defined(HAVE_GETPEEREID)
    rb_io_t *fptr;
    uid_t euid;
    gid_t egid;
    GetOpenFile(self, fptr);
    if (getpeereid(fptr-&gt;fd, &amp;euid, &amp;egid) == -1)
        rb_sys_fail("getpeereid(3)");
    return rb_assoc_new(UIDT2NUM(euid), GIDT2NUM(egid));
#elif defined(SO_PEERCRED) /* GNU/Linux */
    rb_io_t *fptr;
    struct ucred cred;
    socklen_t len = sizeof(cred);
    GetOpenFile(self, fptr);
    if (getsockopt(fptr-&gt;fd, SOL_SOCKET, SO_PEERCRED, &amp;cred, &amp;len) == -1)
        rb_sys_fail("getsockopt(SO_PEERCRED)");
    return rb_assoc_new(UIDT2NUM(cred.uid), GIDT2NUM(cred.gid));
#elif defined(HAVE_GETPEERUCRED) /* Solaris */
    rb_io_t *fptr;
    ucred_t *uc = NULL;
    VALUE ret;
    GetOpenFile(self, fptr);
    if (getpeerucred(fptr-&gt;fd, &amp;uc) == -1)
        rb_sys_fail("getpeerucred(3C)");
    ret = rb_assoc_new(UIDT2NUM(ucred_geteuid(uc)), GIDT2NUM(ucred_getegid(uc)));
    ucred_free(uc);
    return ret;
#endif
}</pre> </div>  <p>Returns the user and group on the peer of the UNIX socket. The result is a two element array which contains the effective uid and the effective gid.</p> <pre class="ruby" data-language="ruby">Socket.unix_server_loop("/tmp/sock") {|s|
  begin
    euid, egid = s.getpeereid

    # Check the connected client is myself or not.
    next if euid != Process.uid

    # do something about my resource.

  ensure
    s.close
  end
}
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-getpeername"> <a href="#method-i-getpeername" title="Link to this method"> <span class="method-callseq"> getpeername → sockaddr </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="getpeername-source"> <pre class="c" data-language="c">static VALUE
bsock_getpeername(VALUE sock)
{
    union_sockaddr buf;
    socklen_t len = (socklen_t)sizeof buf;
    socklen_t len0 = len;
    rb_io_t *fptr;

    GetOpenFile(sock, fptr);
    if (getpeername(fptr-&gt;fd, &amp;buf.addr, &amp;len) &lt; 0)
        rb_sys_fail("getpeername(2)");
    if (len0 &lt; len) len = len0;
    return rb_str_new((char*)&amp;buf, len);
}</pre> </div>  <p>Returns the remote address of the socket as a sockaddr string.</p> <pre class="ruby" data-language="ruby">TCPServer.open("127.0.0.1", 1440) {|serv|
  c = TCPSocket.new("127.0.0.1", 1440)
  s = serv.accept
  p s.getpeername #=&gt; "\x02\x00\x82u\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00"
}
</pre> <p>If <a href="addrinfo.html"><code>Addrinfo</code></a> object is preferred over the binary string, use <a href="basicsocket.html#method-i-remote_address"><code>BasicSocket#remote_address</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-getsockname"> <a href="#method-i-getsockname" title="Link to this method"> <span class="method-callseq"> getsockname → sockaddr </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="getsockname-source"> <pre class="c" data-language="c">static VALUE
bsock_getsockname(VALUE sock)
{
    union_sockaddr buf;
    socklen_t len = (socklen_t)sizeof buf;
    socklen_t len0 = len;
    rb_io_t *fptr;

    GetOpenFile(sock, fptr);
    if (getsockname(fptr-&gt;fd, &amp;buf.addr, &amp;len) &lt; 0)
        rb_sys_fail("getsockname(2)");
    if (len0 &lt; len) len = len0;
    return rb_str_new((char*)&amp;buf, len);
}</pre> </div>  <p>Returns the local address of the socket as a sockaddr string.</p> <pre class="ruby" data-language="ruby">TCPServer.open("127.0.0.1", 15120) {|serv|
  p serv.getsockname #=&gt; "\x02\x00;\x10\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00"
}
</pre> <p>If <a href="addrinfo.html"><code>Addrinfo</code></a> object is preferred over the binary string, use <a href="basicsocket.html#method-i-local_address"><code>BasicSocket#local_address</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-getsockopt"> <a href="#method-i-getsockopt" title="Link to this method"> <span class="method-callseq"> getsockopt(level, optname) → socketoption </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="getsockopt-source"> <pre class="c" data-language="c">static VALUE
bsock_getsockopt(VALUE sock, VALUE lev, VALUE optname)
{
    int level, option;
    socklen_t len;
    char *buf;
    rb_io_t *fptr;
    int family;

    GetOpenFile(sock, fptr);
    family = rsock_getfamily(fptr);
    level = rsock_level_arg(family, lev);
    option = rsock_optname_arg(family, level, optname);
    len = 256;
#ifdef _AIX
    switch (option) {
      case SO_DEBUG:
      case SO_REUSEADDR:
      case SO_KEEPALIVE:
      case SO_DONTROUTE:
      case SO_BROADCAST:
      case SO_OOBINLINE:
        /* AIX doesn't set len for boolean options */
        len = sizeof(int);
    }
#endif
    buf = ALLOCA_N(char,len);

    rb_io_check_closed(fptr);

    if (getsockopt(fptr-&gt;fd, level, option, buf, &amp;len) &lt; 0)
        rsock_sys_fail_path("getsockopt(2)", fptr-&gt;pathv);

    return rsock_sockopt_new(family, level, option, rb_str_new(buf, len));
}</pre> </div>  <p>Gets a socket option. These are protocol and system specific, see your local system documentation for details. The option is returned as a <a href="socket/option.html"><code>Socket::Option</code></a> object.</p> <h3 id="method-i-getsockopt-label-Parameters">Parameters</h3> <ul>
<li> <p><code>level</code> is an integer, usually one of the SOL_ constants such as Socket::SOL_SOCKET, or a protocol level. A string or symbol of the name, possibly without prefix, is also accepted.</p> </li>
<li> <p><code>optname</code> is an integer, usually one of the SO_ constants, such as Socket::SO_REUSEADDR. A string or symbol of the name, possibly without prefix, is also accepted.</p> </li>
</ul> <h3 id="method-i-getsockopt-label-Examples">Examples</h3> <p>Some socket options are integers with boolean values, in this case <a href="basicsocket.html#method-i-getsockopt"><code>getsockopt</code></a> could be called like this:</p> <pre class="ruby" data-language="ruby">reuseaddr = sock.getsockopt(:SOCKET, :REUSEADDR).bool

optval = sock.getsockopt(Socket::SOL_SOCKET,Socket::SO_REUSEADDR)
optval = optval.unpack "i"
reuseaddr = optval[0] == 0 ? false : true
</pre> <p>Some socket options are integers with numeric values, in this case <a href="basicsocket.html#method-i-getsockopt"><code>getsockopt</code></a> could be called like this:</p> <pre class="ruby" data-language="ruby">ipttl = sock.getsockopt(:IP, :TTL).int

optval = sock.getsockopt(Socket::IPPROTO_IP, Socket::IP_TTL)
ipttl = optval.unpack1("i")
</pre> <p>Option values may be structs. Decoding them can be complex as it involves examining your system headers to determine the correct definition. An example is a +struct linger+, which may be defined in your system headers as:</p> <pre class="ruby" data-language="ruby">struct linger {
  int l_onoff;
  int l_linger;
};
</pre> <p>In this case <a href="basicsocket.html#method-i-getsockopt"><code>getsockopt</code></a> could be called like this:</p> <pre class="ruby" data-language="ruby"># Socket::Option knows linger structure.
onoff, linger = sock.getsockopt(:SOCKET, :LINGER).linger

optval =  sock.getsockopt(Socket::SOL_SOCKET, Socket::SO_LINGER)
onoff, linger = optval.unpack "ii"
onoff = onoff == 0 ? false : true
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-local_address"> <a href="#method-i-local_address" title="Link to this method"> <span class="method-callseq"> local_address → addrinfo </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="local_address-source"> <pre class="c" data-language="c">static VALUE
bsock_local_address(VALUE sock)
{
    union_sockaddr buf;
    socklen_t len = (socklen_t)sizeof buf;
    socklen_t len0 = len;
    rb_io_t *fptr;

    GetOpenFile(sock, fptr);
    if (getsockname(fptr-&gt;fd, &amp;buf.addr, &amp;len) &lt; 0)
        rb_sys_fail("getsockname(2)");
    if (len0 &lt; len) len = len0;
    return rsock_fd_socket_addrinfo(fptr-&gt;fd, &amp;buf.addr, len);
}</pre> </div>  <p>Returns an <a href="addrinfo.html"><code>Addrinfo</code></a> object for local address obtained by getsockname.</p> <p>Note that addrinfo.protocol is filled by 0.</p> <pre class="ruby" data-language="ruby">TCPSocket.open("www.ruby-lang.org", 80) {|s|
  p s.local_address #=&gt; #&lt;Addrinfo: 192.168.0.129:36873 TCP&gt;
}

TCPServer.open("127.0.0.1", 1512) {|serv|
  p serv.local_address #=&gt; #&lt;Addrinfo: 127.0.0.1:1512 TCP&gt;
}
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-recv"> <a href="#method-i-recv" title="Link to this method"> <span class="method-callseq"> recv(maxlen[, flags[, outbuf]]) → mesg </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="recv-source"> <pre class="c" data-language="c">static VALUE
bsock_recv(int argc, VALUE *argv, VALUE sock)
{
    return rsock_s_recvfrom(sock, argc, argv, RECV_RECV);
}</pre> </div>  <p>Receives a message.</p> <p><em>maxlen</em> is the maximum number of bytes to receive.</p> <p><em>flags</em> should be a bitwise OR of Socket::MSG_* constants.</p> <p><em>outbuf</em> will contain only the received data after the method call even if it is not empty at the beginning.</p> <pre class="ruby" data-language="ruby">UNIXSocket.pair {|s1, s2|
  s1.puts "Hello World"
  p s2.recv(4)                     #=&gt; "Hell"
  p s2.recv(4, Socket::MSG_PEEK)   #=&gt; "o Wo"
  p s2.recv(4)                     #=&gt; "o Wo"
  p s2.recv(10)                    #=&gt; "rld\n"
}
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-recv_nonblock"> <a href="#method-i-recv_nonblock" title="Link to this method"> <span class="method-callseq"> recv_nonblock(maxlen [, flags [, buf [, options ]]]) → mesg </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="recv_nonblock-source"> <pre class="ruby" data-language="ruby"># File ext/socket/lib/socket.rb, line 376
def recv_nonblock(len, flag = 0, str = nil, exception: true)
  __recv_nonblock(len, flag, str, exception)
end</pre> </div>  <p>Receives up to <em>maxlen</em> bytes from <code>socket</code> using recvfrom(2) after O_NONBLOCK is set for the underlying file descriptor. <em>flags</em> is zero or more of the <code>MSG_</code> options. The result, <em>mesg</em>, is the data received.</p> <p>When recvfrom(2) returns 0, <a href="basicsocket.html#method-i-recv_nonblock"><code>Socket#recv_nonblock</code></a> returns nil. In most cases it means the connection was closed, but for UDP connections it may mean an empty packet was received, as the underlying API makes it impossible to distinguish these two cases.</p> <h3 id="method-i-recv_nonblock-label-Parameters">Parameters</h3> <ul>
<li> <p><code>maxlen</code> - the number of bytes to receive from the socket</p> </li>
<li> <p><code>flags</code> - zero or more of the <code>MSG_</code> options</p> </li>
<li> <p><code>buf</code> - destination <a href="string.html"><code>String</code></a> buffer</p> </li>
<li> <p><code>options</code> - keyword hash, supporting ‘exception: false`</p> </li>
</ul> <h3 id="method-i-recv_nonblock-label-Example">Example</h3> <pre class="ruby" data-language="ruby">serv = TCPServer.new("127.0.0.1", 0)
af, port, host, addr = serv.addr
c = TCPSocket.new(addr, port)
s = serv.accept
c.send "aaa", 0
begin # emulate blocking recv.
  p s.recv_nonblock(10) #=&gt; "aaa"
rescue IO::WaitReadable
  IO.select([s])
  retry
end
</pre> <p>Refer to <a href="socket.html#method-i-recvfrom"><code>Socket#recvfrom</code></a> for the exceptions that may be thrown if the call to <em>recv_nonblock</em> fails.</p> <p><a href="basicsocket.html#method-i-recv_nonblock"><code>BasicSocket#recv_nonblock</code></a> may raise any error corresponding to recvfrom(2) failure, including Errno::EWOULDBLOCK.</p> <p>If the exception is Errno::EWOULDBLOCK or Errno::EAGAIN, it is extended by <a href="io/waitreadable.html"><code>IO::WaitReadable</code></a>. So <a href="io/waitreadable.html"><code>IO::WaitReadable</code></a> can be used to rescue the exceptions for retrying recv_nonblock.</p> <p>By specifying a keyword argument <em>exception</em> to <code>false</code>, you can indicate that <a href="basicsocket.html#method-i-recv_nonblock"><code>recv_nonblock</code></a> should not raise an <a href="io/waitreadable.html"><code>IO::WaitReadable</code></a> exception, but return the symbol <code>:wait_readable</code> instead.</p> <h3 id="method-i-recv_nonblock-label-See">See</h3> <ul><li> <p><a href="socket.html#method-i-recvfrom"><code>Socket#recvfrom</code></a></p> </li></ul> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-recvmsg"> <a href="#method-i-recvmsg" title="Link to this method"> <span class="method-callseq"> recvmsg(maxmesglen=nil, flags=0, maxcontrollen=nil, opts={}) → [mesg, sender_addrinfo, rflags, *controls] </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="recvmsg-source"> <pre class="ruby" data-language="ruby"># File ext/socket/lib/socket.rb, line 431
def recvmsg(dlen = nil, flags = 0, clen = nil, scm_rights: false)
  __recvmsg(dlen, flags, clen, scm_rights)
end</pre> </div>  <p>recvmsg receives a message using recvmsg(2) system call in blocking manner.</p> <p><em>maxmesglen</em> is the maximum length of mesg to receive.</p> <p><em>flags</em> is bitwise OR of MSG_* constants such as Socket::MSG_PEEK.</p> <p><em>maxcontrollen</em> is the maximum length of controls (ancillary data) to receive.</p> <p><em>opts</em> is option hash. Currently :scm_rights=&gt;bool is the only option.</p> <p>:scm_rights option specifies that application expects SCM_RIGHTS control message. If the value is nil or false, application don’t expects SCM_RIGHTS control message. In this case, recvmsg closes the passed file descriptors immediately. This is the default behavior.</p> <p>If :scm_rights value is neither nil nor false, application expects SCM_RIGHTS control message. In this case, recvmsg creates <a href="io.html"><code>IO</code></a> objects for each file descriptors for <a href="socket/ancillarydata.html#method-i-unix_rights"><code>Socket::AncillaryData#unix_rights</code></a> method.</p> <p>The return value is 4-elements array.</p> <p><em>mesg</em> is a string of the received message.</p> <p><em>sender_addrinfo</em> is a sender socket address for connection-less socket. It is an <a href="addrinfo.html"><code>Addrinfo</code></a> object. For connection-oriented socket such as TCP, sender_addrinfo is platform dependent.</p> <p><em>rflags</em> is a flags on the received message which is bitwise OR of MSG_* constants such as Socket::MSG_TRUNC. It will be nil if the system uses 4.3BSD style old recvmsg system call.</p> <p><em>controls</em> is ancillary data which is an array of <a href="socket/ancillarydata.html"><code>Socket::AncillaryData</code></a> objects such as:</p> <pre class="ruby" data-language="ruby">#&lt;Socket::AncillaryData: AF_UNIX SOCKET RIGHTS 7&gt;
</pre> <p><em>maxmesglen</em> and <em>maxcontrollen</em> can be nil. In that case, the buffer will be grown until the message is not truncated. Internally, MSG_PEEK is used. Buffer full and MSG_CTRUNC are checked for truncation.</p> <p>recvmsg can be used to implement recv_io as follows:</p> <pre class="ruby" data-language="ruby">mesg, sender_sockaddr, rflags, *controls = sock.recvmsg(:scm_rights=&gt;true)
controls.each {|ancdata|
  if ancdata.cmsg_is?(:SOCKET, :RIGHTS)
    return ancdata.unix_rights[0]
  end
}
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-recvmsg_nonblock"> <a href="#method-i-recvmsg_nonblock" title="Link to this method"> <span class="method-callseq"> recvmsg_nonblock(maxdatalen=nil, flags=0, maxcontrollen=nil, opts={}) → [data, sender_addrinfo, rflags, *controls] </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="recvmsg_nonblock-source"> <pre class="ruby" data-language="ruby"># File ext/socket/lib/socket.rb, line 447
def recvmsg_nonblock(dlen = nil, flags = 0, clen = nil,
                     scm_rights: false, exception: true)
  __recvmsg_nonblock(dlen, flags, clen, scm_rights, exception)
end</pre> </div>  <p>recvmsg receives a message using recvmsg(2) system call in non-blocking manner.</p> <p>It is similar to <a href="basicsocket.html#method-i-recvmsg"><code>BasicSocket#recvmsg</code></a> but non-blocking flag is set before the system call and it doesn’t retry the system call.</p> <p>By specifying a keyword argument <em>exception</em> to <code>false</code>, you can indicate that <a href="basicsocket.html#method-i-recvmsg_nonblock"><code>recvmsg_nonblock</code></a> should not raise an <a href="io/waitreadable.html"><code>IO::WaitReadable</code></a> exception, but return the symbol <code>:wait_readable</code> instead.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-remote_address"> <a href="#method-i-remote_address" title="Link to this method"> <span class="method-callseq"> remote_address → addrinfo </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="remote_address-source"> <pre class="c" data-language="c">static VALUE
bsock_remote_address(VALUE sock)
{
    union_sockaddr buf;
    socklen_t len = (socklen_t)sizeof buf;
    socklen_t len0 = len;
    rb_io_t *fptr;

    GetOpenFile(sock, fptr);
    if (getpeername(fptr-&gt;fd, &amp;buf.addr, &amp;len) &lt; 0)
        rb_sys_fail("getpeername(2)");
    if (len0 &lt; len) len = len0;
    return rsock_fd_socket_addrinfo(fptr-&gt;fd, &amp;buf.addr, len);
}</pre> </div>  <p>Returns an <a href="addrinfo.html"><code>Addrinfo</code></a> object for remote address obtained by getpeername.</p> <p>Note that addrinfo.protocol is filled by 0.</p> <pre class="ruby" data-language="ruby">TCPSocket.open("www.ruby-lang.org", 80) {|s|
  p s.remote_address #=&gt; #&lt;Addrinfo: 221.186.184.68:80 TCP&gt;
}

TCPServer.open("127.0.0.1", 1728) {|serv|
  c = TCPSocket.new("127.0.0.1", 1728)
  s = serv.accept
  p s.remote_address #=&gt; #&lt;Addrinfo: 127.0.0.1:36504 TCP&gt;
}
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-send"> <a href="#method-i-send" title="Link to this method"> <span class="method-callseq"> send(mesg, flags [, dest_sockaddr]) → numbytes_sent </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="send-source"> <pre class="c" data-language="c">VALUE
rsock_bsock_send(int argc, VALUE *argv, VALUE socket)
{
    struct rsock_send_arg arg;
    VALUE flags, to;
    rb_io_t *fptr;
    rb_blocking_function_t *func;
    const char *funcname;

    rb_scan_args(argc, argv, "21", &amp;arg.mesg, &amp;flags, &amp;to);

    StringValue(arg.mesg);
    if (!NIL_P(to)) {
        SockAddrStringValue(to);
        to = rb_str_new4(to);
        arg.to = (struct sockaddr *)RSTRING_PTR(to);
        arg.tolen = RSTRING_SOCKLEN(to);
        func = rsock_sendto_blocking;
        funcname = "sendto(2)";
    }
    else {
        func = rsock_send_blocking;
        funcname = "send(2)";
    }

    RB_IO_POINTER(socket, fptr);

    arg.fd = fptr-&gt;fd;
    arg.flags = NUM2INT(flags);

    while (true) {
#ifdef RSOCK_WAIT_BEFORE_BLOCKING
        rb_io_wait(socket, RB_INT2NUM(RUBY_IO_WRITABLE), Qnil);
#endif

        ssize_t n = (ssize_t)rb_io_blocking_region(fptr, func, &amp;arg);

        if (n &gt;= 0) return SSIZET2NUM(n);

        if (rb_io_maybe_wait_writable(errno, socket, RUBY_IO_TIMEOUT_DEFAULT)) {
            continue;
        }

        rb_sys_fail(funcname);
    }
}</pre> </div>  <p>send <em>mesg</em> via <em>basicsocket</em>.</p> <p><em>mesg</em> should be a string.</p> <p><em>flags</em> should be a bitwise OR of Socket::MSG_* constants.</p> <p><em>dest_sockaddr</em> should be a packed sockaddr string or an addrinfo.</p> <pre class="ruby" data-language="ruby">TCPSocket.open("localhost", 80) {|s|
  s.send "GET / HTTP/1.0\r\n\r\n", 0
  p s.read
}
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-sendmsg"> <a href="#method-i-sendmsg" title="Link to this method"> <span class="method-callseq"> sendmsg(mesg, flags=0, dest_sockaddr=nil, *controls) → numbytes_sent </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="sendmsg-source"> <pre class="ruby" data-language="ruby"># File ext/socket/lib/socket.rb, line 307
def sendmsg(mesg, flags = 0, dest_sockaddr = nil, *controls)
  __sendmsg(mesg, flags, dest_sockaddr, controls)
end</pre> </div>  <p>sendmsg sends a message using sendmsg(2) system call in blocking manner.</p> <p><em>mesg</em> is a string to send.</p> <p><em>flags</em> is bitwise OR of MSG_* constants such as Socket::MSG_OOB.</p> <p><em>dest_sockaddr</em> is a destination socket address for connection-less socket. It should be a sockaddr such as a result of <a href="socket.html#method-c-sockaddr_in"><code>Socket.sockaddr_in</code></a>. An <a href="addrinfo.html"><code>Addrinfo</code></a> object can be used too.</p> <p><em>controls</em> is a list of ancillary data. The element of <em>controls</em> should be <a href="socket/ancillarydata.html"><code>Socket::AncillaryData</code></a> or 3-elements array. The 3-element array should contains cmsg_level, cmsg_type and data.</p> <p>The return value, <em>numbytes_sent</em> is an integer which is the number of bytes sent.</p> <p>sendmsg can be used to implement send_io as follows:</p> <pre class="ruby" data-language="ruby"># use Socket::AncillaryData.
ancdata = Socket::AncillaryData.int(:UNIX, :SOCKET, :RIGHTS, io.fileno)
sock.sendmsg("a", 0, nil, ancdata)

# use 3-element array.
ancdata = [:SOCKET, :RIGHTS, [io.fileno].pack("i!")]
sock.sendmsg("\0", 0, nil, ancdata)
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-sendmsg_nonblock"> <a href="#method-i-sendmsg_nonblock" title="Link to this method"> <span class="method-callseq"> sendmsg_nonblock(mesg, flags=0, dest_sockaddr=nil, *controls, opts={}) → numbytes_sent </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="sendmsg_nonblock-source"> <pre class="ruby" data-language="ruby"># File ext/socket/lib/socket.rb, line 323
def sendmsg_nonblock(mesg, flags = 0, dest_sockaddr = nil, *controls,
                     exception: true)
  __sendmsg_nonblock(mesg, flags, dest_sockaddr, controls, exception)
end</pre> </div>  <p><a href="basicsocket.html#method-i-sendmsg_nonblock"><code>sendmsg_nonblock</code></a> sends a message using sendmsg(2) system call in non-blocking manner.</p> <p>It is similar to <a href="basicsocket.html#method-i-sendmsg"><code>BasicSocket#sendmsg</code></a> but the non-blocking flag is set before the system call and it doesn’t retry the system call.</p> <p>By specifying a keyword argument <em>exception</em> to <code>false</code>, you can indicate that <a href="basicsocket.html#method-i-sendmsg_nonblock"><code>sendmsg_nonblock</code></a> should not raise an <a href="io/waitwritable.html"><code>IO::WaitWritable</code></a> exception, but return the symbol <code>:wait_writable</code> instead.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-setsockopt"> <a href="#method-i-setsockopt" title="Link to this method"> <span class="method-callseq"> setsockopt(level, optname, optval) </span> </a> </div> <div class="method-heading"> <a href="#method-i-setsockopt" title="Link to this method"> <span class="method-callseq"> setsockopt(socketoption) </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="setsockopt-source"> <pre class="c" data-language="c">static VALUE
bsock_setsockopt(int argc, VALUE *argv, VALUE sock)
{
    VALUE lev, optname, val;
    int family, level, option;
    rb_io_t *fptr;
    int i;
    char *v;
    int vlen;

    if (argc == 1) {
        lev = rb_funcall(argv[0], rb_intern("level"), 0);
        optname = rb_funcall(argv[0], rb_intern("optname"), 0);
        val = rb_funcall(argv[0], rb_intern("data"), 0);
    }
    else {
        rb_scan_args(argc, argv, "30", &amp;lev, &amp;optname, &amp;val);
    }

    GetOpenFile(sock, fptr);
    family = rsock_getfamily(fptr);
    level = rsock_level_arg(family, lev);
    option = rsock_optname_arg(family, level, optname);

    switch (TYPE(val)) {
      case T_FIXNUM:
        i = FIX2INT(val);
        goto numval;
      case T_FALSE:
        i = 0;
        goto numval;
      case T_TRUE:
        i = 1;
      numval:
        v = (char*)&amp;i; vlen = (int)sizeof(i);
        break;
      default:
        StringValue(val);
        v = RSTRING_PTR(val);
        vlen = RSTRING_SOCKLEN(val);
        break;
    }

    rb_io_check_closed(fptr);
    if (setsockopt(fptr-&gt;fd, level, option, v, vlen) &lt; 0)
        rsock_sys_fail_path("setsockopt(2)", fptr-&gt;pathv);

    return INT2FIX(0);
}</pre> </div>  <p>Sets a socket option. These are protocol and system specific, see your local system documentation for details.</p> <h3 id="method-i-setsockopt-label-Parameters">Parameters</h3> <ul>
<li> <p><code>level</code> is an integer, usually one of the SOL_ constants such as Socket::SOL_SOCKET, or a protocol level. A string or symbol of the name, possibly without prefix, is also accepted.</p> </li>
<li> <p><code>optname</code> is an integer, usually one of the SO_ constants, such as Socket::SO_REUSEADDR. A string or symbol of the name, possibly without prefix, is also accepted.</p> </li>
<li> <p><code>optval</code> is the value of the option, it is passed to the underlying setsockopt() as a pointer to a certain number of bytes. How this is done depends on the type:</p> <ul>
<li> <p>Integer: value is assigned to an int, and a pointer to the int is passed, with length of sizeof(int).</p> </li>
<li> <p>true or false: 1 or 0 (respectively) is assigned to an int, and the int is passed as for an <a href="integer.html"><code>Integer</code></a>. Note that <code>false</code> must be passed, not <code>nil</code>.</p> </li>
<li> <p>String: the string’s data and length is passed to the socket.</p> </li>
</ul> </li>
<li> <p><code>socketoption</code> is an instance of <a href="socket/option.html"><code>Socket::Option</code></a></p> </li>
</ul> <h3 id="method-i-setsockopt-label-Examples">Examples</h3> <p>Some socket options are integers with boolean values, in this case <a href="basicsocket.html#method-i-setsockopt"><code>setsockopt</code></a> could be called like this:</p> <pre class="ruby" data-language="ruby">sock.setsockopt(:SOCKET, :REUSEADDR, true)
sock.setsockopt(Socket::SOL_SOCKET,Socket::SO_REUSEADDR, true)
sock.setsockopt(Socket::Option.bool(:INET, :SOCKET, :REUSEADDR, true))
</pre> <p>Some socket options are integers with numeric values, in this case <a href="basicsocket.html#method-i-setsockopt"><code>setsockopt</code></a> could be called like this:</p> <pre class="ruby" data-language="ruby">sock.setsockopt(:IP, :TTL, 255)
sock.setsockopt(Socket::IPPROTO_IP, Socket::IP_TTL, 255)
sock.setsockopt(Socket::Option.int(:INET, :IP, :TTL, 255))
</pre> <p>Option values may be structs. Passing them can be complex as it involves examining your system headers to determine the correct definition. An example is an <code>ip_mreq</code>, which may be defined in your system headers as:</p> <pre class="ruby" data-language="ruby">struct ip_mreq {
  struct  in_addr imr_multiaddr;
  struct  in_addr imr_interface;
};
</pre> <p>In this case <a href="basicsocket.html#method-i-setsockopt"><code>setsockopt</code></a> could be called like this:</p> <pre class="ruby" data-language="ruby">optval = IPAddr.new("224.0.0.251").hton +
         IPAddr.new(Socket::INADDR_ANY, Socket::AF_INET).hton
sock.setsockopt(Socket::IPPROTO_IP, Socket::IP_ADD_MEMBERSHIP, optval)
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-shutdown"> <a href="#method-i-shutdown" title="Link to this method"> <span class="method-callseq"> shutdown([how]) → 0 </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="shutdown-source"> <pre class="c" data-language="c">static VALUE
bsock_shutdown(int argc, VALUE *argv, VALUE sock)
{
    VALUE howto;
    int how;
    rb_io_t *fptr;

    rb_scan_args(argc, argv, "01", &amp;howto);
    if (howto == Qnil)
        how = SHUT_RDWR;
    else {
        how = rsock_shutdown_how_arg(howto);
        if (how != SHUT_WR &amp;&amp; how != SHUT_RD &amp;&amp; how != SHUT_RDWR) {
            rb_raise(rb_eArgError, "`how' should be either :SHUT_RD, :SHUT_WR, :SHUT_RDWR");
        }
    }
    GetOpenFile(sock, fptr);
    if (shutdown(fptr-&gt;fd, how) == -1)
        rb_sys_fail("shutdown(2)");

    return INT2FIX(0);
}</pre> </div>  <p>Calls shutdown(2) system call.</p> <p>s.shutdown(Socket::SHUT_RD) disallows further read.</p> <p>s.shutdown(Socket::SHUT_WR) disallows further write.</p> <p>s.shutdown(Socket::SHUT_RDWR) disallows further read and write.</p> <p><em>how</em> can be symbol or string:</p> <ul>
<li> <p>:RD, :SHUT_RD, “RD” and “SHUT_RD” are accepted as Socket::SHUT_RD.</p> </li>
<li> <p>:WR, :SHUT_WR, “WR” and “SHUT_WR” are accepted as Socket::SHUT_WR.</p> </li>
<li> <p>:RDWR, :SHUT_RDWR, “RDWR” and “SHUT_RDWR” are accepted as Socket::SHUT_RDWR.</p> <p><a href="unixsocket.html#method-c-pair"><code>UNIXSocket.pair</code></a> {|s1, s2|</p> <pre class="ruby" data-language="ruby">s1.puts "ping"
s1.shutdown(:WR)
p s2.read          #=&gt; "ping\n"
s2.puts "pong"
s2.close
p s1.read          #=&gt; "pong\n"
</pre> <p>}</p> </li>
</ul> </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core &copy; 1993&ndash;2024 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library &copy; contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>
