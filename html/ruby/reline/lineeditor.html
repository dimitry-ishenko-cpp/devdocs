<h1 id="class-Reline::LineEditor" class="class"> class Reline::LineEditor </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent"><a href="../object.html">Object</a></dd>
</dl>  <section id="5Buntitled-5D" class="documentation-section"> <section class="constants-list"> <header> <h3>Constants</h3> </header> <dl> <dt id="CompletionJourneyData">CompletionJourneyData </dt>

<dt id="DIALOG_DEFAULT_HEIGHT">DIALOG_DEFAULT_HEIGHT </dt>

<dt id="MINIMUM_SCROLLBAR_HEIGHT">MINIMUM_SCROLLBAR_HEIGHT </dt>

<dt id="MenuInfo">MenuInfo </dt>

<dt id="PROMPT_LIST_CACHE_TIMEOUT">PROMPT_LIST_CACHE_TIMEOUT </dt>

<dt id="VI_MOTIONS">VI_MOTIONS </dt>

</dl> </section> <section class="attribute-method-details"> <header> <h3>Attributes</h3> </header> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-auto_indent_proc"> <span class="method-name">auto_indent_proc</span><span class="attribute-access-type">[RW]</span> </div>  </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-byte_pointer"> <span class="method-name">byte_pointer</span><span class="attribute-access-type">[R]</span> </div>  </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-completion_append_character"> <span class="method-name">completion_append_character</span><span class="attribute-access-type">[RW]</span> </div>  </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-completion_proc"> <span class="method-name">completion_proc</span><span class="attribute-access-type">[RW]</span> </div>  </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-confirm_multiline_termination_proc"> <span class="method-name">confirm_multiline_termination_proc</span><span class="attribute-access-type">[RW]</span> </div>  </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-dig_perfect_match_proc"> <span class="method-name">dig_perfect_match_proc</span><span class="attribute-access-type">[RW]</span> </div>  </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-line"> <span class="method-name">line</span><span class="attribute-access-type">[R]</span> </div> <div class="method-description"> <p>TODO: undo TODO: Use “private alias_method” idiom after drop Ruby 2.5.</p> </div> </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-output"> <span class="method-name">output</span><span class="attribute-access-type">[W]</span> </div>  </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-output_modifier_proc"> <span class="method-name">output_modifier_proc</span><span class="attribute-access-type">[RW]</span> </div>  </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-pre_input_hook"> <span class="method-name">pre_input_hook</span><span class="attribute-access-type">[RW]</span> </div>  </div> <div class="method-detail"> <div class="method-heading attribute-method-heading" id="attribute-i-prompt_proc"> <span class="method-name">prompt_proc</span><span class="attribute-access-type">[RW]</span> </div>  </div> </section> <section id="public-class-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-new"> <span class="method-name">new</span><span class="method-args">(config, encoding)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="new-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 57
def initialize(config, encoding)
  @config = config
  @completion_append_character = ''
  reset_variables(encoding: encoding)
end</pre> </div>  </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-add_dialog_proc"> <span class="method-name">add_dialog_proc</span><span class="method-args">(name, p, context = nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="add_dialog_proc-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 639
def add_dialog_proc(name, p, context = nil)
  dialog = Dialog.new(name, @config, DialogProcScope.new(self, @config, p, context))
  if index = @dialogs.find_index { |d| d.name == name }
    @dialogs[index] = dialog
  else
    @dialogs &lt;&lt; dialog
  end
end</pre> </div>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-backward_char"> <span class="method-name">backward_char</span><span class="method-args">(key, arg: 1)</span> </div> </div>  <div class="aliases"> Alias for: <a href="lineeditor.html#method-i-ed_prev_char">ed_prev_char</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-backward_delete_char"> <span class="method-name">backward_delete_char</span><span class="method-args">(key, arg: 1)</span> </div> </div>  <div class="aliases"> Alias for: <a href="lineeditor.html#method-i-em_delete_prev_char">em_delete_prev_char</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-backward_kill_word"> <span class="method-name">backward_kill_word</span><span class="method-args">(key)</span> </div> </div>  <div class="aliases"> Alias for: <a href="lineeditor.html#method-i-ed_delete_prev_word">ed_delete_prev_word</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-backward_word"> <span class="method-name">backward_word</span><span class="method-args">(key)</span> </div> </div>  <div class="aliases"> Alias for: <a href="lineeditor.html#method-i-ed_prev_word">ed_prev_word</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-beginning_of_line"> <span class="method-name">beginning_of_line</span><span class="method-args">(key)</span> </div> </div>  <div class="aliases"> Alias for: <a href="lineeditor.html#method-i-ed_move_to_beg">ed_move_to_beg</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-byte_pointer-3D"> <span class="method-name">byte_pointer=</span><span class="method-args">(val)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="byte_pointer-3D-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 1839
def byte_pointer=(val)
  @byte_pointer = val
  str = @line.byteslice(0, @byte_pointer)
  @cursor = calculate_width(str)
  @cursor_max = calculate_width(@line)
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-call_completion_proc"> <span class="method-name">call_completion_proc</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="call_completion_proc-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 1610
def call_completion_proc
  result = retrieve_completion_block(true)
  pre, target, post = result
  result = call_completion_proc_with_checking_args(pre, target, post)
  Reline.core.instance_variable_set(:@completion_quote_character, nil)
  result
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-call_completion_proc_with_checking_args"> <span class="method-name">call_completion_proc_with_checking_args</span><span class="method-args">(pre, target, post)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="call_completion_proc_with_checking_args-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 1618
def call_completion_proc_with_checking_args(pre, target, post)
  if @completion_proc and target
    argnum = @completion_proc.parameters.inject(0) { |result, item|
      case item.first
      when :req, :opt
        result + 1
      when :rest
        break 3
      end
    }
    case argnum
    when 1
      result = @completion_proc.(target)
    when 2
      result = @completion_proc.(target, pre)
    when 3..Float::INFINITY
      result = @completion_proc.(target, pre, post)
    end
  end
  result
end</pre> </div>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-capitalize_word"> <span class="method-name">capitalize_word</span><span class="method-args">(key)</span> </div> </div>  <div class="aliases"> Alias for: <a href="lineeditor.html#method-i-em_capitol_case">em_capitol_case</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-clear_screen"> <span class="method-name">clear_screen</span><span class="method-args">(key)</span> </div> </div>  <div class="aliases"> Alias for: <a href="lineeditor.html#method-i-ed_clear_screen">ed_clear_screen</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-confirm_multiline_termination"> <span class="method-name">confirm_multiline_termination</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="confirm_multiline_termination-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 1757
def confirm_multiline_termination
  temp_buffer = @buffer_of_lines.dup
  if @previous_line_index and @line_index == (@buffer_of_lines.size - 1)
    temp_buffer[@previous_line_index] = @line
  else
    temp_buffer[@line_index] = @line
  end
  @confirm_multiline_termination_proc.(temp_buffer.join("\n") + "\n")
end</pre> </div>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-delete_char"> <span class="method-name">delete_char</span><span class="method-args">(key)</span> </div> </div>  <div class="aliases"> Alias for: <a href="lineeditor.html#method-i-em_delete">em_delete</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-delete_char_or_list"> <span class="method-name">delete_char_or_list</span><span class="method-args">(key)</span> </div> </div>  <div class="aliases"> Alias for: <a href="lineeditor.html#method-i-em_delete_or_list">em_delete_or_list</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-delete_text"> <span class="method-name">delete_text</span><span class="method-args">(start = nil, length = nil)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="delete_text-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 1779
def delete_text(start = nil, length = nil)
  if start.nil? and length.nil?
    if @is_multiline
      if @buffer_of_lines.size == 1
        @line&amp;.clear
        @byte_pointer = 0
        @cursor = 0
        @cursor_max = 0
      elsif @line_index == (@buffer_of_lines.size - 1) and @line_index &gt; 0
        @buffer_of_lines.pop
        @line_index -= 1
        @line = @buffer_of_lines[@line_index]
        @byte_pointer = 0
        @cursor = 0
        @cursor_max = calculate_width(@line)
      elsif @line_index &lt; (@buffer_of_lines.size - 1)
        @buffer_of_lines.delete_at(@line_index)
        @line = @buffer_of_lines[@line_index]
        @byte_pointer = 0
        @cursor = 0
        @cursor_max = calculate_width(@line)
      end
    else
      @line&amp;.clear
      @byte_pointer = 0
      @cursor = 0
      @cursor_max = 0
    end
  elsif not start.nil? and not length.nil?
    if @line
      before = @line.byteslice(0, start)
      after = @line.byteslice(start + length, @line.bytesize)
      @line = before + after
      @byte_pointer = @line.bytesize if @byte_pointer &gt; @line.bytesize
      str = @line.byteslice(0, @byte_pointer)
      @cursor = calculate_width(str)
      @cursor_max = calculate_width(@line)
    end
  elsif start.is_a?(Range)
    range = start
    first = range.first
    last = range.last
    last = @line.bytesize - 1 if last &gt; @line.bytesize
    last += @line.bytesize if last &lt; 0
    first += @line.bytesize if first &lt; 0
    range = range.exclude_end? ? first...last : first..last
    @line = @line.bytes.reject.with_index{ |c, i| range.include?(i) }.map{ |c| c.chr(Encoding::ASCII_8BIT) }.join.force_encoding(@encoding)
    @byte_pointer = @line.bytesize if @byte_pointer &gt; @line.bytesize
    str = @line.byteslice(0, @byte_pointer)
    @cursor = calculate_width(str)
    @cursor_max = calculate_width(@line)
  else
    @line = @line.byteslice(0, start)
    @byte_pointer = @line.bytesize if @byte_pointer &gt; @line.bytesize
    str = @line.byteslice(0, @byte_pointer)
    @cursor = calculate_width(str)
    @cursor_max = calculate_width(@line)
  end
end</pre> </div>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-downcase_word"> <span class="method-name">downcase_word</span><span class="method-args">(key)</span> </div> </div>  <div class="aliases"> Alias for: <a href="lineeditor.html#method-i-em_lower_case">em_lower_case</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-ed_digit"> <span class="method-name">ed_digit</span><span class="method-args">(key)</span> </div> </div>  <div class="aliases"> Alias for: <a href="lineeditor.html#method-i-ed_insert">ed_insert</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-editing_mode"> <span class="method-name">editing_mode</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="editing_mode-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 1226
def editing_mode
  @config.editing_mode
end</pre> </div>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-end_of_line"> <span class="method-name">end_of_line</span><span class="method-args">(key)</span> </div> </div>  <div class="aliases"> Alias for: <a href="lineeditor.html#method-i-ed_move_to_end">ed_move_to_end</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-eof-3F"> <span class="method-name">eof?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="eof-3F-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 252
def eof?
  @eof
end</pre> </div>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-exchange_point_and_mark"> <span class="method-name">exchange_point_and_mark</span><span class="method-args">(key)</span> </div> </div>  <div class="aliases"> Alias for: <a href="lineeditor.html#method-i-em_exchange_mark">em_exchange_mark</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-finalize"> <span class="method-name">finalize</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="finalize-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 248
def finalize
  Signal.trap('INT', @old_trap)
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-finish"> <span class="method-name">finish</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="finish-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 1865
def finish
  @finished = true
  @rerender_all = true
  @config.reset
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-finished-3F"> <span class="method-name">finished?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="finished-3F-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 1861
def finished?
  @finished
end</pre> </div>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-forward_char"> <span class="method-name">forward_char</span><span class="method-args">(key, arg: 1)</span> </div> </div>  <div class="aliases"> Alias for: <a href="lineeditor.html#method-i-ed_next_char">ed_next_char</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-forward_search_history"> <span class="method-name">forward_search_history</span><span class="method-args">(key)</span> </div> </div>  <div class="aliases"> Alias for: <a href="lineeditor.html#method-i-vi_search_next">vi_search_next</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-forward_word"> <span class="method-name">forward_word</span><span class="method-args">(key)</span> </div> </div>  <div class="aliases"> Alias for: <a href="lineeditor.html#method-i-em_next_word">em_next_word</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-history_search_backward"> <span class="method-name">history_search_backward</span><span class="method-args">(key, arg: 1)</span> </div> </div>  <div class="aliases"> Alias for: <a href="lineeditor.html#method-i-ed_search_prev_history">ed_search_prev_history</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-history_search_forward"> <span class="method-name">history_search_forward</span><span class="method-args">(key, arg: 1)</span> </div> </div>  <div class="aliases"> Alias for: <a href="lineeditor.html#method-i-ed_search_next_history">ed_search_next_history</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-input_key"> <span class="method-name">input_key</span><span class="method-args">(key)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="input_key-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 1535
def input_key(key)
  @last_key = key
  @config.reset_oneshot_key_bindings
  @dialogs.each do |dialog|
    if key.char.instance_of?(Symbol) and key.char == dialog.name
      return
    end
  end
  @just_cursor_moving = nil
  if key.char.nil?
    if @first_char
      @line = nil
    end
    finish
    return
  end
  old_line = @line.dup
  @first_char = false
  completion_occurs = false
  if @config.editing_mode_is?(:emacs, :vi_insert) and key.char == "\C-i".ord
    unless @config.disable_completion
      result = call_completion_proc
      if result.is_a?(Array)
        completion_occurs = true
        process_insert
        if @config.autocompletion
          move_completed_list(result, :down)
        else
          complete(result)
        end
      end
    end
  elsif @config.editing_mode_is?(:emacs, :vi_insert) and key.char == :completion_journey_up
    if not @config.disable_completion and @config.autocompletion
      result = call_completion_proc
      if result.is_a?(Array)
        completion_occurs = true
        process_insert
        move_completed_list(result, :up)
      end
    end
  elsif not @config.disable_completion and @config.editing_mode_is?(:vi_insert) and ["\C-p".ord, "\C-n".ord].include?(key.char)
    unless @config.disable_completion
      result = call_completion_proc
      if result.is_a?(Array)
        completion_occurs = true
        process_insert
        move_completed_list(result, "\C-p".ord == key.char ? :up : :down)
      end
    end
  elsif Symbol === key.char and respond_to?(key.char, true)
    process_key(key.char, key.char)
  else
    normal_char(key)
  end
  unless completion_occurs
    @completion_state = CompletionState::NORMAL
    @completion_journey_data = nil
  end
  if not @in_pasting and @just_cursor_moving.nil?
    if @previous_line_index and @buffer_of_lines[@previous_line_index] == @line
      @just_cursor_moving = true
    elsif @previous_line_index.nil? and @buffer_of_lines[@line_index] == @line and old_line == @line
      @just_cursor_moving = true
    else
      @just_cursor_moving = false
    end
  else
    @just_cursor_moving = false
  end
  if @is_multiline and @auto_indent_proc and not simplified_rendering? and @line
    process_auto_indent
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-insert_text"> <span class="method-name">insert_text</span><span class="method-args">(text)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="insert_text-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 1767
def insert_text(text)
  width = calculate_width(text)
  if @cursor == @cursor_max
    @line += text
  else
    @line = byteinsert(@line, @byte_pointer, text)
  end
  @byte_pointer += text.bytesize
  @cursor += width
  @cursor_max += width
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-io_gate"> <span class="method-name">io_gate</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="io_gate-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 63
def io_gate
  Reline::IOGate
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-just_move_cursor"> <span class="method-name">just_move_cursor</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="just_move_cursor-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 932
def just_move_cursor
  prompt, prompt_width, prompt_list = check_multiline_prompt(@buffer_of_lines)
  move_cursor_up(@started_from)
  new_first_line_started_from =
    if @line_index.zero?
      0
    else
      calculate_height_by_lines(@buffer_of_lines[0..(@line_index - 1)], prompt_list || prompt)
    end
  first_line_diff = new_first_line_started_from - @first_line_started_from
  @cursor, @cursor_max, _, @byte_pointer = calculate_nearest_cursor(@buffer_of_lines[@line_index], @cursor, @started_from, @byte_pointer, false)
  new_started_from = calculate_height_by_width(prompt_width + @cursor) - 1
  calculate_scroll_partial_screen(@highest_in_all, new_first_line_started_from + new_started_from)
  @previous_line_index = nil
  @line = @buffer_of_lines[@line_index]
  if @rerender_all
    rerender_all_lines
    @rerender_all = false
    true
  else
    @first_line_started_from = new_first_line_started_from
    @started_from = new_started_from
    move_cursor_down(first_line_diff + @started_from)
    Reline::IOGate.move_cursor_column((prompt_width + @cursor) % @screen_size.last)
    false
  end
end</pre> </div>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-kill_line"> <span class="method-name">kill_line</span><span class="method-args">(key)</span> </div> </div>  <div class="aliases"> Alias for: <a href="lineeditor.html#method-i-ed_kill_line">ed_kill_line</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-kill_whole_line"> <span class="method-name">kill_whole_line</span><span class="method-args">(key)</span> </div> </div>  <div class="aliases"> Alias for: <a href="lineeditor.html#method-i-em_kill_line">em_kill_line</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-kill_word"> <span class="method-name">kill_word</span><span class="method-args">(key)</span> </div> </div>  <div class="aliases"> Alias for: <a href="lineeditor.html#method-i-em_delete_next_word">em_delete_next_word</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-multiline_off"> <span class="method-name">multiline_off</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="multiline_off-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 318
def multiline_off
  @is_multiline = false
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-multiline_on"> <span class="method-name">multiline_on</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="multiline_on-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 314
def multiline_on
  @is_multiline = true
end</pre> </div>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-next_history"> <span class="method-name">next_history</span><span class="method-args">(key, arg: 1)</span> </div> </div>  <div class="aliases"> Alias for: <a href="lineeditor.html#method-i-ed_next_history">ed_next_history</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-previous_history"> <span class="method-name">previous_history</span><span class="method-args">(key, arg: 1)</span> </div> </div>  <div class="aliases"> Alias for: <a href="lineeditor.html#method-i-ed_prev_history">ed_prev_history</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-quoted_insert"> <span class="method-name">quoted_insert</span><span class="method-args">(str, arg: 1)</span> </div> </div>  <div class="aliases"> Alias for: <a href="lineeditor.html#method-i-ed_quoted_insert">ed_quoted_insert</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-rerender"> <span class="method-name">rerender</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="rerender-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 426
def rerender
  return if @line.nil?
  if @menu_info
    scroll_down(@highest_in_all - @first_line_started_from)
    @rerender_all = true
  end
  if @menu_info
    show_menu
    @menu_info = nil
  end
  prompt, prompt_width, prompt_list = check_multiline_prompt(whole_lines)
  cursor_column = (prompt_width + @cursor) % @screen_size.last
  if @cleared
    clear_screen_buffer(prompt, prompt_list, prompt_width)
    @cleared = false
    return
  end
  if @is_multiline and finished? and @scroll_partial_screen
    # Re-output all code higher than the screen when finished.
    Reline::IOGate.move_cursor_up(@first_line_started_from + @started_from - @scroll_partial_screen)
    Reline::IOGate.move_cursor_column(0)
    @scroll_partial_screen = nil
    new_lines = whole_lines
    prompt, prompt_width, prompt_list = check_multiline_prompt(new_lines)
    modify_lines(new_lines).each_with_index do |line, index|
      @output.write "#{prompt_list ? prompt_list[index] : prompt}#{line}\r\n"
      Reline::IOGate.erase_after_cursor
    end
    @output.flush
    clear_dialog(cursor_column)
    return
  end
  new_highest_in_this = calculate_height_by_width(prompt_width + calculate_width(@line.nil? ? '' : @line))
  rendered = false
  if @add_newline_to_end_of_buffer
    clear_dialog_with_trap_key(cursor_column)
    rerender_added_newline(prompt, prompt_width, prompt_list)
    @add_newline_to_end_of_buffer = false
  else
    if @just_cursor_moving and not @rerender_all
      clear_dialog_with_trap_key(cursor_column)
      rendered = just_move_cursor
      @just_cursor_moving = false
      return
    elsif @previous_line_index or new_highest_in_this != @highest_in_this
      clear_dialog_with_trap_key(cursor_column)
      rerender_changed_current_line
      @previous_line_index = nil
      rendered = true
    elsif @rerender_all
      rerender_all_lines
      @rerender_all = false
      rendered = true
    else
    end
  end
  if @is_multiline
    if finished?
      # Always rerender on finish because output_modifier_proc may return a different output.
      new_lines = whole_lines
      line = modify_lines(new_lines)[@line_index]
      clear_dialog(cursor_column)
      prompt, prompt_width, prompt_list = check_multiline_prompt(new_lines)
      render_partial(prompt, prompt_width, line, @first_line_started_from)
      move_cursor_down(@highest_in_all - (@first_line_started_from + @highest_in_this - 1) - 1)
      scroll_down(1)
      Reline::IOGate.move_cursor_column(0)
      Reline::IOGate.erase_after_cursor
    else
      if not rendered and not @in_pasting
        line = modify_lines(whole_lines)[@line_index]
        prompt, prompt_width, prompt_list = check_multiline_prompt(whole_lines)
        render_partial(prompt, prompt_width, line, @first_line_started_from)
      end
      render_dialog(cursor_column)
    end
    @buffer_of_lines[@line_index] = @line
    @rest_height = 0 if @scroll_partial_screen
  else
    line = modify_lines(whole_lines)[@line_index]
    render_partial(prompt, prompt_width, line, 0)
    if finished?
      scroll_down(1)
      Reline::IOGate.move_cursor_column(0)
      Reline::IOGate.erase_after_cursor
    end
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-rerender_all"> <span class="method-name">rerender_all</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="rerender_all-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 420
def rerender_all
  @rerender_all = true
  process_insert(force: true)
  rerender
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-reset"> <span class="method-name">reset</span><span class="method-args">(prompt = '', encoding:)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="reset-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 154
def reset(prompt = '', encoding:)
  @rest_height = (Reline::IOGate.get_screen_size.first - 1) - Reline::IOGate.cursor_pos.y
  @screen_size = Reline::IOGate.get_screen_size
  @screen_height = @screen_size.first
  reset_variables(prompt, encoding: encoding)
  Reline::IOGate.set_winch_handler do
    @resized = true
  end
  if ENV.key?('RELINE_ALT_SCROLLBAR')
    @full_block = '::'
    @upper_half_block = "''"
    @lower_half_block = '..'
    @block_elem_width = 2
  elsif Reline::IOGate.win?
    @full_block = '█'
    @upper_half_block = '▀'
    @lower_half_block = '▄'
    @block_elem_width = 1
  elsif @encoding == Encoding::UTF_8
    @full_block = '█'
    @upper_half_block = '▀'
    @lower_half_block = '▄'
    @block_elem_width = Reline::Unicode.calculate_width('█')
  else
    @full_block = '::'
    @upper_half_block = "''"
    @lower_half_block = '..'
    @block_elem_width = 2
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-reset_line"> <span class="method-name">reset_line</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="reset_line-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 296
def reset_line
  @cursor = 0
  @cursor_max = 0
  @byte_pointer = 0
  @buffer_of_lines = [String.new(encoding: @encoding)]
  @line_index = 0
  @previous_line_index = nil
  @line = @buffer_of_lines[0]
  @first_line_started_from = 0
  @move_up = 0
  @started_from = 0
  @highest_in_this = 1
  @highest_in_all = 1
  @line_backup_in_history = nil
  @multibyte_buffer = String.new(encoding: 'ASCII-8BIT')
  @check_new_auto_indent = false
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-reset_variables"> <span class="method-name">reset_variables</span><span class="method-args">(prompt = '', encoding:)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="reset_variables-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 256
def reset_variables(prompt = '', encoding:)
  @prompt = prompt.gsub("\n", "\\n")
  @mark_pointer = nil
  @encoding = encoding
  @is_multiline = false
  @finished = false
  @cleared = false
  @rerender_all = false
  @history_pointer = nil
  @kill_ring ||= Reline::KillRing.new
  @vi_clipboard = ''
  @vi_arg = nil
  @waiting_proc = nil
  @waiting_operator_proc = nil
  @waiting_operator_vi_arg = nil
  @completion_journey_data = nil
  @completion_state = CompletionState::NORMAL
  @perfect_matched = nil
  @menu_info = nil
  @first_prompt = true
  @searching_prompt = nil
  @first_char = true
  @add_newline_to_end_of_buffer = false
  @just_cursor_moving = nil
  @cached_prompt_list = nil
  @prompt_cache_time = nil
  @eof = false
  @continuous_insertion_buffer = String.new(encoding: @encoding)
  @scroll_partial_screen = nil
  @prev_mode_string = nil
  @drop_terminate_spaces = false
  @in_pasting = false
  @auto_indent_proc = nil
  @dialogs = []
  @previous_rendered_dialog_y = 0
  @last_key = nil
  @resized = false
  reset_line
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-resize"> <span class="method-name">resize</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="resize-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 185
def resize
  return unless @resized
  @resized = false
  @rest_height = (Reline::IOGate.get_screen_size.first - 1) - Reline::IOGate.cursor_pos.y
  old_screen_size = @screen_size
  @screen_size = Reline::IOGate.get_screen_size
  @screen_height = @screen_size.first
  if old_screen_size.last &lt; @screen_size.last # columns increase
    @rerender_all = true
    rerender
  else
    back = 0
    new_buffer = whole_lines
    prompt, prompt_width, prompt_list = check_multiline_prompt(new_buffer)
    new_buffer.each_with_index do |line, index|
      prompt_width = calculate_width(prompt_list[index], true) if @prompt_proc
      width = prompt_width + calculate_width(line)
      height = calculate_height_by_width(width)
      back += height
    end
    @highest_in_all = back
    @highest_in_this = calculate_height_by_width(prompt_width + @cursor_max)
    @first_line_started_from =
      if @line_index.zero?
        0
      else
        calculate_height_by_lines(@buffer_of_lines[0..(@line_index - 1)], prompt_list || prompt)
      end
    if @prompt_proc
      prompt = prompt_list[@line_index]
      prompt_width = calculate_width(prompt, true)
    end
    calculate_nearest_cursor
    @started_from = calculate_height_by_width(prompt_width + @cursor) - 1
    Reline::IOGate.move_cursor_column((prompt_width + @cursor) % @screen_size.last)
    @highest_in_this = calculate_height_by_width(prompt_width + @cursor_max)
    @rerender_all = true
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-retrieve_completion_block"> <span class="method-name">retrieve_completion_block</span><span class="method-args">(set_completion_quote_character = false)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="retrieve_completion_block-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 1679
def retrieve_completion_block(set_completion_quote_character = false)
  if Reline.completer_word_break_characters.empty?
    word_break_regexp = nil
  else
    word_break_regexp = /\A[#{Regexp.escape(Reline.completer_word_break_characters)}]/
  end
  if Reline.completer_quote_characters.empty?
    quote_characters_regexp = nil
  else
    quote_characters_regexp = /\A[#{Regexp.escape(Reline.completer_quote_characters)}]/
  end
  before = @line.byteslice(0, @byte_pointer)
  rest = nil
  break_pointer = nil
  quote = nil
  closing_quote = nil
  escaped_quote = nil
  i = 0
  while i &lt; @byte_pointer do
    slice = @line.byteslice(i, @byte_pointer - i)
    unless slice.valid_encoding?
      i += 1
      next
    end
    if quote and slice.start_with?(closing_quote)
      quote = nil
      i += 1
      rest = nil
    elsif quote and slice.start_with?(escaped_quote)
      # skip
      i += 2
    elsif quote_characters_regexp and slice =~ quote_characters_regexp # find new "
      rest = $'
      quote = $&amp;
      closing_quote = /(?!\\)#{Regexp.escape(quote)}/
      escaped_quote = /\\#{Regexp.escape(quote)}/
      i += 1
      break_pointer = i - 1
    elsif word_break_regexp and not quote and slice =~ word_break_regexp
      rest = $'
      i += 1
      before = @line.byteslice(i, @byte_pointer - i)
      break_pointer = i
    else
      i += 1
    end
  end
  postposing = @line.byteslice(@byte_pointer, @line.bytesize - @byte_pointer)
  if rest
    preposing = @line.byteslice(0, break_pointer)
    target = rest
    if set_completion_quote_character and quote
      Reline.core.instance_variable_set(:@completion_quote_character, quote)
      if postposing !~ /(?!\\)#{Regexp.escape(quote)}/ # closing quote
        insert_text(quote)
      end
    end
  else
    preposing = ''
    if break_pointer
      preposing = @line.byteslice(0, break_pointer)
    else
      preposing = ''
    end
    target = before
  end
  if @is_multiline
    lines = whole_lines
    if @line_index &gt; 0
      preposing = lines[0..(@line_index - 1)].join("\n") + "\n" + preposing
    end
    if (lines.size - 1) &gt; @line_index
      postposing = postposing + "\n" + lines[(@line_index + 1)..-1].join("\n")
    end
  end
  [preposing.encode(@encoding), target.encode(@encoding), postposing.encode(@encoding)]
end</pre> </div>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-reverse_search_history"> <span class="method-name">reverse_search_history</span><span class="method-args">(key)</span> </div> </div>  <div class="aliases"> Alias for: <a href="lineeditor.html#method-i-vi_search_prev">vi_search_prev</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-self_insert"> <span class="method-name">self_insert</span><span class="method-args">(key)</span> </div> </div>  <div class="aliases"> Alias for: <a href="lineeditor.html#method-i-ed_insert">ed_insert</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-set_mark"> <span class="method-name">set_mark</span><span class="method-args">(key)</span> </div> </div>  <div class="aliases"> Alias for: <a href="lineeditor.html#method-i-em_set_mark">em_set_mark</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-set_pasting_state"> <span class="method-name">set_pasting_state</span><span class="method-args">(in_pasting)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="set_pasting_state-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 67
def set_pasting_state(in_pasting)
  @in_pasting = in_pasting
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-set_signal_handlers"> <span class="method-name">set_signal_handlers</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="set_signal_handlers-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 225
def set_signal_handlers
  @old_trap = Signal.trap('INT') {
    clear_dialog(0)
    if @scroll_partial_screen
      move_cursor_down(@screen_height - (@line_index - @scroll_partial_screen) - 1)
    else
      move_cursor_down(@highest_in_all - @line_index - 1)
    end
    Reline::IOGate.move_cursor_column(0)
    scroll_down(1)
    case @old_trap
    when 'DEFAULT', 'SYSTEM_DEFAULT'
      raise Interrupt
    when 'IGNORE'
      # Do nothing
    when 'EXIT'
      exit
    else
      @old_trap.call if @old_trap.respond_to?(:call)
    end
  }
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-simplified_rendering-3F"> <span class="method-name">simplified_rendering?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="simplified_rendering-3F-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 71
def simplified_rendering?
  if finished?
    false
  elsif @just_cursor_moving and not @rerender_all
    true
  else
    not @rerender_all and not finished? and @in_pasting
  end
end</pre> </div>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-transpose_chars"> <span class="method-name">transpose_chars</span><span class="method-args">(key)</span> </div> </div>  <div class="aliases"> Alias for: <a href="lineeditor.html#method-i-ed_transpose_chars">ed_transpose_chars</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-transpose_words"> <span class="method-name">transpose_words</span><span class="method-args">(key)</span> </div> </div>  <div class="aliases"> Alias for: <a href="lineeditor.html#method-i-ed_transpose_words">ed_transpose_words</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-unix_line_discard"> <span class="method-name">unix_line_discard</span><span class="method-args">(key)</span> </div> </div>  <div class="aliases"> Alias for: <a href="lineeditor.html#method-i-vi_kill_line_prev">vi_kill_line_prev</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-unix_word_rubout"> <span class="method-name">unix_word_rubout</span><span class="method-args">(key)</span> </div> </div>  <div class="aliases"> Alias for: <a href="lineeditor.html#method-i-em_kill_region">em_kill_region</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-upcase_word"> <span class="method-name">upcase_word</span><span class="method-args">(key)</span> </div> </div>  <div class="aliases"> Alias for: <a href="lineeditor.html#method-i-em_upper_case">em_upper_case</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-vi_end_of_transmission"> <span class="method-name">vi_end_of_transmission</span><span class="method-args">(key)</span> </div> </div>  <div class="aliases"> Alias for: <a href="lineeditor.html#method-i-vi_list_or_eof">vi_list_or_eof</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-vi_eof_maybe"> <span class="method-name">vi_eof_maybe</span><span class="method-args">(key)</span> </div> </div>  <div class="aliases"> Alias for: <a href="lineeditor.html#method-i-vi_list_or_eof">vi_list_or_eof</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-vi_movement_mode"> <span class="method-name">vi_movement_mode</span><span class="method-args">(key)</span> </div> </div>  <div class="aliases"> Alias for: <a href="lineeditor.html#method-i-vi_command_mode">vi_command_mode</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-whole_buffer"> <span class="method-name">whole_buffer</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="whole_buffer-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 1853
def whole_buffer
  if @buffer_of_lines.size == 1 and @line.nil?
    nil
  else
    whole_lines.join("\n")
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-whole_lines"> <span class="method-name">whole_lines</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="whole_lines-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 1846
def whole_lines
  index = @previous_line_index || @line_index
  temp_lines = @buffer_of_lines.dup
  temp_lines[index] = @line
  temp_lines
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-wrap_method_call"> <span class="method-name">wrap_method_call</span><span class="method-args">(method_symbol, method_obj, key, with_operator = false)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="wrap_method_call-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 1418
def wrap_method_call(method_symbol, method_obj, key, with_operator = false)
  if @config.editing_mode_is?(:emacs, :vi_insert) and @waiting_proc.nil? and @waiting_operator_proc.nil?
    not_insertion = method_symbol != :ed_insert
    process_insert(force: not_insertion)
  end
  if @vi_arg and argumentable?(method_obj)
    if with_operator and inclusive?(method_obj)
      method_obj.(key, arg: @vi_arg, inclusive: true)
    else
      method_obj.(key, arg: @vi_arg)
    end
  else
    if with_operator and inclusive?(method_obj)
      method_obj.(key, inclusive: true)
    else
      method_obj.(key)
    end
  end
end</pre> </div>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-yank"> <span class="method-name">yank</span><span class="method-args">(key)</span> </div> </div>  <div class="aliases"> Alias for: <a href="lineeditor.html#method-i-em_yank">em_yank</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-yank_pop"> <span class="method-name">yank_pop</span><span class="method-args">(key)</span> </div> </div>  <div class="aliases"> Alias for: <a href="lineeditor.html#method-i-em_yank_pop">em_yank_pop</a> </div> </div> </section> <section id="private-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Private Instance Methods</h3> </header> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-argumentable-3F"> <span class="method-name">argumentable?</span><span class="method-args">(method_obj)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="argumentable-3F-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 1408
        def argumentable?(method_obj)
  method_obj and method_obj.parameters.any? { |param| param[0] == :key and param[1] == :arg }
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-byteinsert"> <span class="method-name">byteinsert</span><span class="method-args">(str, byte_pointer, other)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="byteinsert-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 1877
        def byteinsert(str, byte_pointer, other)
  new_str = str.byteslice(0, byte_pointer)
  new_str &lt;&lt; other
  new_str &lt;&lt; str.byteslice(byte_pointer, str.bytesize)
  new_str
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-byteslice-21"> <span class="method-name">byteslice!</span><span class="method-args">(str, byte_pointer, size)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="byteslice-21-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 1871
        def byteslice!(str, byte_pointer, size)
  new_str = str.byteslice(0, byte_pointer)
  new_str &lt;&lt; str.byteslice(byte_pointer + size, str.bytesize)
  [new_str, str.byteslice(byte_pointer, size)]
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-calculate_height_by_lines"> <span class="method-name">calculate_height_by_lines</span><span class="method-args">(lines, prompt)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="calculate_height_by_lines-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 322
        def calculate_height_by_lines(lines, prompt)
  result = 0
  prompt_list = prompt.is_a?(Array) ? prompt : nil
  lines.each_with_index { |line, i|
    prompt = prompt_list[i] if prompt_list and prompt_list[i]
    result += calculate_height_by_width(calculate_width(prompt, true) + calculate_width(line))
  }
  result
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-calculate_height_by_width"> <span class="method-name">calculate_height_by_width</span><span class="method-args">(width)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="calculate_height_by_width-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 340
        def calculate_height_by_width(width)
  width.div(@screen_size.last) + 1
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-calculate_nearest_cursor"> <span class="method-name">calculate_nearest_cursor</span><span class="method-args">(line_to_calc = @line, cursor = @cursor, started_from = @started_from, byte_pointer = @byte_pointer, update = true)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="calculate_nearest_cursor-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 378
        def calculate_nearest_cursor(line_to_calc = @line, cursor = @cursor, started_from = @started_from, byte_pointer = @byte_pointer, update = true)
  new_cursor_max = calculate_width(line_to_calc)
  new_cursor = 0
  new_byte_pointer = 0
  height = 1
  max_width = @screen_size.last
  if @config.editing_mode_is?(:vi_command)
    last_byte_size = Reline::Unicode.get_prev_mbchar_size(line_to_calc, line_to_calc.bytesize)
    if last_byte_size &gt; 0
      last_mbchar = line_to_calc.byteslice(line_to_calc.bytesize - last_byte_size, last_byte_size)
      last_width = Reline::Unicode.get_mbchar_width(last_mbchar)
      end_of_line_cursor = new_cursor_max - last_width
    else
    end_of_line_cursor = new_cursor_max
    end
  else
  end_of_line_cursor = new_cursor_max
  end
  line_to_calc.grapheme_clusters.each do |gc|
    mbchar = gc.encode(Encoding::UTF_8)
    mbchar_width = Reline::Unicode.get_mbchar_width(mbchar)
    now = new_cursor + mbchar_width
    if now &gt; end_of_line_cursor or now &gt; cursor
      break
    end
    new_cursor += mbchar_width
    if new_cursor &gt; max_width * height
      height += 1
    end
    new_byte_pointer += gc.bytesize
  end
  new_started_from = height - 1
  if update
    @cursor = new_cursor
    @cursor_max = new_cursor_max
    @started_from = new_started_from
    @byte_pointer = new_byte_pointer
  else
    [new_cursor, new_cursor_max, new_started_from, new_byte_pointer]
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-calculate_scroll_partial_screen"> <span class="method-name">calculate_scroll_partial_screen</span><span class="method-args">(highest_in_all, cursor_y)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="calculate_scroll_partial_screen-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 875
        def calculate_scroll_partial_screen(highest_in_all, cursor_y)
  if @screen_height &lt; highest_in_all
    old_scroll_partial_screen = @scroll_partial_screen
    if cursor_y == 0
      @scroll_partial_screen = 0
    elsif cursor_y == (highest_in_all - 1)
      @scroll_partial_screen = highest_in_all - @screen_height
    else
      if @scroll_partial_screen
        if cursor_y &lt;= @scroll_partial_screen
          @scroll_partial_screen = cursor_y
        elsif (@scroll_partial_screen + @screen_height - 1) &lt; cursor_y
          @scroll_partial_screen = cursor_y - (@screen_height - 1)
        end
      else
        if cursor_y &gt; (@screen_height - 1)
          @scroll_partial_screen = cursor_y - (@screen_height - 1)
        else
          @scroll_partial_screen = 0
        end
      end
    end
    if @scroll_partial_screen != old_scroll_partial_screen
      @rerender_all = true
    end
  else
    if @scroll_partial_screen
      @rerender_all = true
    end
    @scroll_partial_screen = nil
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-calculate_width"> <span class="method-name">calculate_width</span><span class="method-args">(str, allow_escape_code = false)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="calculate_width-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 1884
        def calculate_width(str, allow_escape_code = false)
  Reline::Unicode.calculate_width(str, allow_escape_code)
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-check_mode_string"> <span class="method-name">check_mode_string</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="check_mode_string-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 81
        def check_mode_string
  mode_string = nil
  if @config.show_mode_in_prompt
    if @config.editing_mode_is?(:vi_command)
      mode_string = @config.vi_cmd_mode_string
    elsif @config.editing_mode_is?(:vi_insert)
      mode_string = @config.vi_ins_mode_string
    elsif @config.editing_mode_is?(:emacs)
      mode_string = @config.emacs_mode_string
    else
      mode_string = '?'
    end
  end
  if mode_string != @prev_mode_string
    @rerender_all = true
  end
  @prev_mode_string = mode_string
  mode_string
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-check_multiline_prompt"> <span class="method-name">check_multiline_prompt</span><span class="method-args">(buffer, force_recalc: false)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="check_multiline_prompt-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 101
        def check_multiline_prompt(buffer, force_recalc: false)
  if @vi_arg
    prompt = "(arg: #{@vi_arg}) "
    @rerender_all = true
  elsif @searching_prompt
    prompt = @searching_prompt
    @rerender_all = true
  else
    prompt = @prompt
  end
  if simplified_rendering? &amp;&amp; !force_recalc
    mode_string = check_mode_string
    prompt = mode_string + prompt if mode_string
    return [prompt, calculate_width(prompt, true), [prompt] * buffer.size]
  end
  if @prompt_proc
    use_cached_prompt_list = false
    if @cached_prompt_list
      if @just_cursor_moving
        use_cached_prompt_list = true
      elsif Time.now.to_f &lt; (@prompt_cache_time + PROMPT_LIST_CACHE_TIMEOUT) and buffer.size == @cached_prompt_list.size
        use_cached_prompt_list = true
      end
    end
    use_cached_prompt_list = false if @rerender_all
    if use_cached_prompt_list
      prompt_list = @cached_prompt_list
    else
      prompt_list = @cached_prompt_list = @prompt_proc.(buffer).map { |pr| pr.gsub("\n", "\\n") }
      @prompt_cache_time = Time.now.to_f
    end
    prompt_list.map!{ prompt } if @vi_arg or @searching_prompt
    prompt_list = [prompt] if prompt_list.empty?
    mode_string = check_mode_string
    prompt_list = prompt_list.map{ |pr| mode_string + pr } if mode_string
    prompt = prompt_list[@line_index]
    prompt = prompt_list[0] if prompt.nil?
    prompt = prompt_list.last if prompt.nil?
    if buffer.size &gt; prompt_list.size
      (buffer.size - prompt_list.size).times do
        prompt_list &lt;&lt; prompt_list.last
      end
    end
    prompt_width = calculate_width(prompt, true)
    [prompt, prompt_width, prompt_list]
  else
    mode_string = check_mode_string
    prompt = mode_string + prompt if mode_string
    prompt_width = calculate_width(prompt, true)
    [prompt, prompt_width, nil]
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-clear_dialog"> <span class="method-name">clear_dialog</span><span class="method-args">(cursor_column)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="clear_dialog-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 859
        def clear_dialog(cursor_column)
  changes = @dialogs.map do |dialog|
    old_dialog = dialog.dup
    dialog.contents = nil
    [old_dialog, dialog]
  end
  render_dialog_changes(changes, cursor_column)
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-clear_dialog_with_trap_key"> <span class="method-name">clear_dialog_with_trap_key</span><span class="method-args">(cursor_column)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="clear_dialog_with_trap_key-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 868
        def clear_dialog_with_trap_key(cursor_column)
  clear_dialog(cursor_column)
  @dialogs.each do |dialog|
    dialog.trap_key = nil
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-clear_screen_buffer"> <span class="method-name">clear_screen_buffer</span><span class="method-args">(prompt, prompt_list, prompt_width)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="clear_screen_buffer-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 1205
        def clear_screen_buffer(prompt, prompt_list, prompt_width)
  Reline::IOGate.clear_screen
  back = 0
  modify_lines(whole_lines).each_with_index do |line, index|
    if @prompt_proc
      pr = prompt_list[index]
      height = render_partial(pr, calculate_width(pr), line, back, with_control: false)
    else
      height = render_partial(prompt, prompt_width, line, back, with_control: false)
    end
    if index &lt; (@buffer_of_lines.size - 1)
      move_cursor_down(1)
      back += height
    end
  end
  move_cursor_up(back)
  move_cursor_down(@first_line_started_from + @started_from)
  @rest_height = (Reline::IOGate.get_screen_size.first - 1) - Reline::IOGate.cursor_pos.y
  Reline::IOGate.move_cursor_column((prompt_width + @cursor) % @screen_size.last)
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-complete"> <span class="method-name">complete</span><span class="method-args">(list, just_show_list = false)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="complete-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 1280
        def complete(list, just_show_list = false)
  case @completion_state
  when CompletionState::NORMAL, CompletionState::JOURNEY
    @completion_state = CompletionState::COMPLETION
  when CompletionState::PERFECT_MATCH
    @dig_perfect_match_proc&amp;.(@perfect_matched)
  end
  if just_show_list
    is_menu = true
  elsif @completion_state == CompletionState::MENU
    is_menu = true
  elsif @completion_state == CompletionState::MENU_WITH_PERFECT_MATCH
    is_menu = true
  else
    is_menu = false
  end
  result = complete_internal_proc(list, is_menu)
  if @completion_state == CompletionState::MENU_WITH_PERFECT_MATCH
    @completion_state = CompletionState::PERFECT_MATCH
  end
  return if result.nil?
  target, preposing, completed, postposing = result
  return if completed.nil?
  if target &lt;= completed and (@completion_state == CompletionState::COMPLETION)
    if list.include?(completed)
      if list.one?
        @completion_state = CompletionState::PERFECT_MATCH
      else
        @completion_state = CompletionState::MENU_WITH_PERFECT_MATCH
      end
      @perfect_matched = completed
    else
      @completion_state = CompletionState::MENU
    end
    if not just_show_list and target &lt; completed
      @line = (preposing + completed + completion_append_character.to_s + postposing).split("\n")[@line_index] || String.new(encoding: @encoding)
      line_to_pointer = (preposing + completed + completion_append_character.to_s).split("\n").last || String.new(encoding: @encoding)
      @cursor_max = calculate_width(@line)
      @cursor = calculate_width(line_to_pointer)
      @byte_pointer = line_to_pointer.bytesize
    end
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-complete_internal_proc"> <span class="method-name">complete_internal_proc</span><span class="method-args">(list, is_menu)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="complete_internal_proc-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 1234
        def complete_internal_proc(list, is_menu)
  preposing, target, postposing = retrieve_completion_block
  list = list.select { |i|
    if i and not Encoding.compatible?(target.encoding, i.encoding)
      raise Encoding::CompatibilityError, "#{target.encoding.name} is not compatible with #{i.encoding.name}"
    end
    if @config.completion_ignore_case
      i&amp;.downcase&amp;.start_with?(target.downcase)
    else
      i&amp;.start_with?(target)
    end
  }.uniq
  if is_menu
    menu(target, list)
    return nil
  end
  completed = list.inject { |memo, item|
    begin
      memo_mbchars = memo.unicode_normalize.grapheme_clusters
      item_mbchars = item.unicode_normalize.grapheme_clusters
    rescue Encoding::CompatibilityError
      memo_mbchars = memo.grapheme_clusters
      item_mbchars = item.grapheme_clusters
    end
    size = [memo_mbchars.size, item_mbchars.size].min
    result = ''
    size.times do |i|
      if @config.completion_ignore_case
        if memo_mbchars[i].casecmp?(item_mbchars[i])
          result &lt;&lt; memo_mbchars[i]
        else
          break
        end
      else
        if memo_mbchars[i] == item_mbchars[i]
          result &lt;&lt; memo_mbchars[i]
        else
          break
        end
      end
    end
    result
  }
  [target, preposing, completed, postposing]
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-copy_for_vi"> <span class="method-name">copy_for_vi</span><span class="method-args">(text)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="copy_for_vi-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 2801
        def copy_for_vi(text)
  if @config.editing_mode_is?(:vi_insert) or @config.editing_mode_is?(:vi_command)
    @vi_clipboard = text
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-dialog_range"> <span class="method-name">dialog_range</span><span class="method-args">(dialog, dialog_y)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="dialog_range-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 671
        def dialog_range(dialog, dialog_y)
  x_range = dialog.column...dialog.column + dialog.width
  y_range = dialog_y + dialog.vertical_offset...dialog_y + dialog.vertical_offset + dialog.contents.size
  [x_range, y_range]
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-ed_argument_digit"> <span class="method-name">ed_argument_digit</span><span class="method-args">(key)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="ed_argument_digit-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 3100
        def ed_argument_digit(key)
  if @vi_arg.nil?
    if key.chr.to_i.zero?
      if key.anybits?(0b10000000)
        unescaped_key = key ^ 0b10000000
        unless unescaped_key.chr.to_i.zero?
          @vi_arg = unescaped_key.chr.to_i
        end
      end
    else
      @vi_arg = key.chr.to_i
    end
  else
    @vi_arg = @vi_arg * 10 + key.chr.to_i
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-ed_clear_screen"> <span class="method-name">ed_clear_screen</span><span class="method-args">(key)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="ed_clear_screen-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 2665
        def ed_clear_screen(key)
  @cleared = true
end</pre> </div>  </div> <div class="aliases"> Also aliased as: <a href="lineeditor.html#method-i-clear_screen">clear_screen</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-ed_delete_next_char"> <span class="method-name">ed_delete_next_char</span><span class="method-args">(key, arg: 1)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="ed_delete_next_char-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 3012
        def ed_delete_next_char(key, arg: 1)
  byte_size = Reline::Unicode.get_next_mbchar_size(@line, @byte_pointer)
  unless @line.empty? || byte_size == 0
    @line, mbchar = byteslice!(@line, @byte_pointer, byte_size)
    copy_for_vi(mbchar)
    width = Reline::Unicode.get_mbchar_width(mbchar)
    @cursor_max -= width
    if @cursor &gt; 0 and @cursor &gt;= @cursor_max
      byte_size = Reline::Unicode.get_prev_mbchar_size(@line, @byte_pointer)
      mbchar = @line.byteslice(@byte_pointer - byte_size, byte_size)
      width = Reline::Unicode.get_mbchar_width(mbchar)
      @byte_pointer -= byte_size
      @cursor -= width
    end
  end
  arg -= 1
  ed_delete_next_char(key, arg: arg) if arg &gt; 0
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-ed_delete_prev_char"> <span class="method-name">ed_delete_prev_char</span><span class="method-args">(key, arg: 1)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="ed_delete_prev_char-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 2930
        def ed_delete_prev_char(key, arg: 1)
  deleted = ''
  arg.times do
    if @cursor &gt; 0
      byte_size = Reline::Unicode.get_prev_mbchar_size(@line, @byte_pointer)
      @byte_pointer -= byte_size
      @line, mbchar = byteslice!(@line, @byte_pointer, byte_size)
      deleted.prepend(mbchar)
      width = Reline::Unicode.get_mbchar_width(mbchar)
      @cursor -= width
      @cursor_max -= width
    end
  end
  copy_for_vi(deleted)
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-ed_delete_prev_word"> <span class="method-name">ed_delete_prev_word</span><span class="method-args">(key)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="ed_delete_prev_word-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 2698
        def ed_delete_prev_word(key)
  if @byte_pointer &gt; 0
    byte_size, width = Reline::Unicode.em_backward_word(@line, @byte_pointer)
    @line, word = byteslice!(@line, @byte_pointer - byte_size, byte_size)
    @kill_ring.append(word, true)
    @byte_pointer -= byte_size
    @cursor -= width
    @cursor_max -= width
  end
end</pre> </div>  </div> <div class="aliases"> Also aliased as: <a href="lineeditor.html#method-i-backward_kill_word">backward_kill_word</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-ed_insert"> <span class="method-name">ed_insert</span><span class="method-args">(key)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="ed_insert-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 1941
        def ed_insert(key)
  str = nil
  width = nil
  bytesize = nil
  if key.instance_of?(String)
    begin
      key.encode(Encoding::UTF_8)
    rescue Encoding::UndefinedConversionError
      return
    end
    str = key
    bytesize = key.bytesize
  else
    begin
      key.chr.encode(Encoding::UTF_8)
    rescue Encoding::UndefinedConversionError
      return
    end
    str = key.chr
    bytesize = 1
  end
  if @in_pasting
    @continuous_insertion_buffer &lt;&lt; str
    return
  elsif not @continuous_insertion_buffer.empty?
    process_insert
  end
  width = Reline::Unicode.get_mbchar_width(str)
  if @cursor == @cursor_max
    @line += str
  else
    @line = byteinsert(@line, @byte_pointer, str)
  end
  last_byte_size = Reline::Unicode.get_prev_mbchar_size(@line, @byte_pointer)
  @byte_pointer += bytesize
  last_mbchar = @line.byteslice((@byte_pointer - bytesize - last_byte_size), last_byte_size)
  combined_char = last_mbchar + str
  if last_byte_size != 0 and combined_char.grapheme_clusters.size == 1
    # combined char
    last_mbchar_width = Reline::Unicode.get_mbchar_width(last_mbchar)
    combined_char_width = Reline::Unicode.get_mbchar_width(combined_char)
    if combined_char_width &gt; last_mbchar_width
      width = combined_char_width - last_mbchar_width
    else
      width = 0
    end
  end
  @cursor += width
  @cursor_max += width
end</pre> </div> <dl class="rdoc-list note-list">
<dt>Editline </dt>
<dd> <p><code>ed-insert</code> (vi input: almost all; emacs: printable characters) In insert mode, insert the input character left of the cursor position. In replace mode, overwrite the character at the cursor and move the cursor to the right by one character position. Accept an argument to do this repeatedly. It is an error if the input character is the NUL character (<code>Ctrl-@</code>). Failure to enlarge the edit buffer also results in an error.</p> </dd>
<dt>Editline </dt>
<dd> <p><code>ed-digit</code> (emacs: 0 to 9) If in argument input mode, append the input digit to the argument being read. Otherwise, call <code>ed-insert</code>. It is an error if the input character is not a digit or if the existing argument is already greater than a million.</p> </dd>
<dt>GNU <a href="../readline.html"><code>Readline</code></a> </dt>
<dd> <p><code>self-insert</code> (a, b, A, 1, !, …) Insert yourself.</p> </dd>
</dl>  </div> <div class="aliases"> Also aliased as: <a href="lineeditor.html#method-i-ed_digit">ed_digit</a>, <a href="lineeditor.html#method-i-self_insert">self_insert</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-ed_kill_line"> <span class="method-name">ed_kill_line</span><span class="method-args">(key)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="ed_kill_line-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 2548
        def ed_kill_line(key)
  if @line.bytesize &gt; @byte_pointer
    @line, deleted = byteslice!(@line, @byte_pointer, @line.bytesize - @byte_pointer)
    @byte_pointer = @line.bytesize
    @cursor = @cursor_max = calculate_width(@line)
    @kill_ring.append(deleted)
  elsif @is_multiline and @byte_pointer == @line.bytesize and @buffer_of_lines.size &gt; @line_index + 1
    @cursor = calculate_width(@line)
    @byte_pointer = @line.bytesize
    @line += @buffer_of_lines.delete_at(@line_index + 1)
    @cursor_max = calculate_width(@line)
    @buffer_of_lines[@line_index] = @line
    @rerender_all = true
    @rest_height += 1
  end
end</pre> </div> <dl class="rdoc-list note-list">
<dt>Editline </dt>
<dd> <p><code>ed-kill-line</code> (vi command: <code>D</code>, <code>Ctrl-K</code>; emacs: <code>Ctrl-K</code>, <code>Ctrl-U</code>) + Kill from the cursor to the end of the line.</p> </dd>
<dt>GNU <a href="../readline.html"><code>Readline</code></a> </dt>
<dd> <p><code>kill-line</code> (<code>C-k</code>) Kill the text from point to the end of the line. With a negative numeric argument, kill backward from the cursor to the beginning of the current line.</p> </dd>
</dl>  </div> <div class="aliases"> Also aliased as: <a href="lineeditor.html#method-i-kill_line">kill_line</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-ed_move_to_beg"> <span class="method-name">ed_move_to_beg</span><span class="method-args">(key)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="ed_move_to_beg-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 2054
        def ed_move_to_beg(key)
  @byte_pointer = @cursor = 0
end</pre> </div>  </div> <div class="aliases"> Also aliased as: <a href="lineeditor.html#method-i-beginning_of_line">beginning_of_line</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-ed_move_to_end"> <span class="method-name">ed_move_to_end</span><span class="method-args">(key)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="ed_move_to_end-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 2059
        def ed_move_to_end(key)
  @byte_pointer = 0
  @cursor = 0
  byte_size = 0
  while @byte_pointer &lt; @line.bytesize
    byte_size = Reline::Unicode.get_next_mbchar_size(@line, @byte_pointer)
    if byte_size &gt; 0
      mbchar = @line.byteslice(@byte_pointer, byte_size)
      @cursor += Reline::Unicode.get_mbchar_width(mbchar)
    end
    @byte_pointer += byte_size
  end
end</pre> </div>  </div> <div class="aliases"> Also aliased as: <a href="lineeditor.html#method-i-end_of_line">end_of_line</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-ed_newline"> <span class="method-name">ed_newline</span><span class="method-args">(key)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="ed_newline-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 2487
        def ed_newline(key)
  process_insert(force: true)
  if @is_multiline
    if @config.editing_mode_is?(:vi_command)
      if @line_index &lt; (@buffer_of_lines.size - 1)
        ed_next_history(key) # means cursor down
      else
        # should check confirm_multiline_termination to finish?
        finish
      end
    else
      if @line_index == (@buffer_of_lines.size - 1)
        if confirm_multiline_termination
          finish
        else
          key_newline(key)
        end
      else
        # should check confirm_multiline_termination to finish?
        @previous_line_index = @line_index
        @line_index = @buffer_of_lines.size - 1
        finish
      end
    end
  else
    if @history_pointer
      Reline::HISTORY[@history_pointer] = @line
      @history_pointer = nil
    end
    finish
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-ed_next_char"> <span class="method-name">ed_next_char</span><span class="method-args">(key, arg: 1)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="ed_next_char-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 2010
        def ed_next_char(key, arg: 1)
  byte_size = Reline::Unicode.get_next_mbchar_size(@line, @byte_pointer)
  if (@byte_pointer &lt; @line.bytesize)
    mbchar = @line.byteslice(@byte_pointer, byte_size)
    width = Reline::Unicode.get_mbchar_width(mbchar)
    @cursor += width if width
    @byte_pointer += byte_size
  elsif @is_multiline and @config.editing_mode_is?(:emacs) and @byte_pointer == @line.bytesize and @line_index &lt; @buffer_of_lines.size - 1
    next_line = @buffer_of_lines[@line_index + 1]
    @cursor = 0
    @byte_pointer = 0
    @cursor_max = calculate_width(next_line)
    @previous_line_index = @line_index
    @line_index += 1
  end
  arg -= 1
  ed_next_char(key, arg: arg) if arg &gt; 0
end</pre> </div>  </div> <div class="aliases"> Also aliased as: <a href="lineeditor.html#method-i-forward_char">forward_char</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-ed_next_history"> <span class="method-name">ed_next_history</span><span class="method-args">(key, arg: 1)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="ed_next_history-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 2439
        def ed_next_history(key, arg: 1)
  if @is_multiline and @line_index &lt; (@buffer_of_lines.size - 1)
    @previous_line_index = @line_index
    @line_index += 1
    return
  end
  if @history_pointer.nil?
    return
  elsif @history_pointer == (Reline::HISTORY.size - 1)
    if @is_multiline
      @history_pointer = nil
      @buffer_of_lines = @line_backup_in_history.split("\n")
      @buffer_of_lines = [String.new(encoding: @encoding)] if @buffer_of_lines.empty?
      @line_index = 0
      @line = @buffer_of_lines.first
      @rerender_all = true
    else
      @history_pointer = nil
      @line = @line_backup_in_history
    end
  else
    if @is_multiline
      Reline::HISTORY[@history_pointer] = whole_buffer
      @history_pointer += 1
      @buffer_of_lines = Reline::HISTORY[@history_pointer].split("\n")
      @buffer_of_lines = [String.new(encoding: @encoding)] if @buffer_of_lines.empty?
      @line_index = 0
      @line = @buffer_of_lines.first
      @rerender_all = true
    else
      Reline::HISTORY[@history_pointer] = @line
      @history_pointer += 1
      @line = Reline::HISTORY[@history_pointer]
    end
  end
  @line = '' unless @line
  if @config.editing_mode_is?(:emacs, :vi_insert)
    @cursor_max = @cursor = calculate_width(@line)
    @byte_pointer = @line.bytesize
  elsif @config.editing_mode_is?(:vi_command)
    @byte_pointer = @cursor = 0
    @cursor_max = calculate_width(@line)
  end
  arg -= 1
  ed_next_history(key, arg: arg) if arg &gt; 0
end</pre> </div>  </div> <div class="aliases"> Also aliased as: <a href="lineeditor.html#method-i-next_history">next_history</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-ed_prev_char"> <span class="method-name">ed_prev_char</span><span class="method-args">(key, arg: 1)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="ed_prev_char-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 2030
        def ed_prev_char(key, arg: 1)
  if @cursor &gt; 0
    byte_size = Reline::Unicode.get_prev_mbchar_size(@line, @byte_pointer)
    @byte_pointer -= byte_size
    mbchar = @line.byteslice(@byte_pointer, byte_size)
    width = Reline::Unicode.get_mbchar_width(mbchar)
    @cursor -= width
  elsif @is_multiline and @config.editing_mode_is?(:emacs) and @byte_pointer == 0 and @line_index &gt; 0
    prev_line = @buffer_of_lines[@line_index - 1]
    @cursor = calculate_width(prev_line)
    @byte_pointer = prev_line.bytesize
    @cursor_max = calculate_width(prev_line)
    @previous_line_index = @line_index
    @line_index -= 1
  end
  arg -= 1
  ed_prev_char(key, arg: arg) if arg &gt; 0
end</pre> </div>  </div> <div class="aliases"> Also aliased as: <a href="lineeditor.html#method-i-backward_char">backward_char</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-ed_prev_history"> <span class="method-name">ed_prev_history</span><span class="method-args">(key, arg: 1)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="ed_prev_history-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 2388
        def ed_prev_history(key, arg: 1)
  if @is_multiline and @line_index &gt; 0
    @previous_line_index = @line_index
    @line_index -= 1
    return
  end
  if Reline::HISTORY.empty?
    return
  end
  if @history_pointer.nil?
    @history_pointer = Reline::HISTORY.size - 1
    if @is_multiline
      @line_backup_in_history = whole_buffer
      @buffer_of_lines = Reline::HISTORY[@history_pointer].split("\n")
      @buffer_of_lines = [String.new(encoding: @encoding)] if @buffer_of_lines.empty?
      @line_index = @buffer_of_lines.size - 1
      @line = @buffer_of_lines.last
      @rerender_all = true
    else
      @line_backup_in_history = @line
      @line = Reline::HISTORY[@history_pointer]
    end
  elsif @history_pointer.zero?
    return
  else
    if @is_multiline
      Reline::HISTORY[@history_pointer] = whole_buffer
      @history_pointer -= 1
      @buffer_of_lines = Reline::HISTORY[@history_pointer].split("\n")
      @buffer_of_lines = [String.new(encoding: @encoding)] if @buffer_of_lines.empty?
      @line_index = @buffer_of_lines.size - 1
      @line = @buffer_of_lines.last
      @rerender_all = true
    else
      Reline::HISTORY[@history_pointer] = @line
      @history_pointer -= 1
      @line = Reline::HISTORY[@history_pointer]
    end
  end
  if @config.editing_mode_is?(:emacs, :vi_insert)
    @cursor_max = @cursor = calculate_width(@line)
    @byte_pointer = @line.bytesize
  elsif @config.editing_mode_is?(:vi_command)
    @byte_pointer = @cursor = 0
    @cursor_max = calculate_width(@line)
  end
  arg -= 1
  ed_prev_history(key, arg: arg) if arg &gt; 0
end</pre> </div>  </div> <div class="aliases"> Also aliased as: <a href="lineeditor.html#method-i-previous_history">previous_history</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-ed_prev_word"> <span class="method-name">ed_prev_word</span><span class="method-args">(key)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="ed_prev_word-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 2679
        def ed_prev_word(key)
  if @byte_pointer &gt; 0
    byte_size, width = Reline::Unicode.em_backward_word(@line, @byte_pointer)
    @byte_pointer -= byte_size
    @cursor -= width
  end
end</pre> </div>  </div> <div class="aliases"> Also aliased as: <a href="lineeditor.html#method-i-backward_word">backward_word</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-ed_quoted_insert"> <span class="method-name">ed_quoted_insert</span><span class="method-args">(str, arg: 1)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="ed_quoted_insert-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 1994
        def ed_quoted_insert(str, arg: 1)
  @waiting_proc = proc { |key|
    arg.times do
      if key == "\C-j".ord or key == "\C-m".ord
        key_newline(key)
      elsif key == 0
        # Ignore NUL.
      else
        ed_insert(key)
      end
    end
    @waiting_proc = nil
  }
end</pre> </div>  </div> <div class="aliases"> Also aliased as: <a href="lineeditor.html#method-i-quoted_insert">quoted_insert</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-ed_search_next_history"> <span class="method-name">ed_search_next_history</span><span class="method-args">(key, arg: 1)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="ed_search_next_history-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 2336
        def ed_search_next_history(key, arg: 1)
  substr = @line.slice(0, @byte_pointer)
  if @history_pointer.nil?
    return
  elsif @history_pointer == (Reline::HISTORY.size - 1) and not substr.empty?
    return
  end
  history = Reline::HISTORY.slice((@history_pointer + 1)..-1)
  h_pointer = nil
  line_no = nil
  if @is_multiline
    h_pointer = history.index { |h|
      h.split("\n").each_with_index { |l, i|
        if l.start_with?(substr)
          line_no = i
          break
        end
      }
      not line_no.nil?
    }
  else
    h_pointer = history.index { |l|
      l.start_with?(substr)
    }
  end
  h_pointer += @history_pointer + 1 if h_pointer and @history_pointer
  return if h_pointer.nil? and not substr.empty?
  @history_pointer = h_pointer
  if @is_multiline
    if @history_pointer.nil? and substr.empty?
      @buffer_of_lines = []
      @line_index = 0
    else
      @buffer_of_lines = Reline::HISTORY[@history_pointer].split("\n")
      @line_index = line_no
    end
    @buffer_of_lines = [String.new(encoding: @encoding)] if @buffer_of_lines.empty?
    @line = @buffer_of_lines[@line_index]
    @rerender_all = true
  else
    if @history_pointer.nil? and substr.empty?
      @line = ''
    else
      @line = Reline::HISTORY[@history_pointer]
    end
  end
  @cursor_max = calculate_width(@line)
  arg -= 1
  ed_search_next_history(key, arg: arg) if arg &gt; 0
end</pre> </div>  </div> <div class="aliases"> Also aliased as: <a href="lineeditor.html#method-i-history_search_forward">history_search_forward</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-ed_search_prev_history"> <span class="method-name">ed_search_prev_history</span><span class="method-args">(key, arg: 1)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="ed_search_prev_history-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 2289
        def ed_search_prev_history(key, arg: 1)
  history = nil
  h_pointer = nil
  line_no = nil
  substr = @line.slice(0, @byte_pointer)
  if @history_pointer.nil?
    return if not @line.empty? and substr.empty?
    history = Reline::HISTORY
  elsif @history_pointer.zero?
    history = nil
    h_pointer = nil
  else
    history = Reline::HISTORY.slice(0, @history_pointer)
  end
  return if history.nil?
  if @is_multiline
    h_pointer = history.rindex { |h|
      h.split("\n").each_with_index { |l, i|
        if l.start_with?(substr)
          line_no = i
          break
        end
      }
      not line_no.nil?
    }
  else
    h_pointer = history.rindex { |l|
      l.start_with?(substr)
    }
  end
  return if h_pointer.nil?
  @history_pointer = h_pointer
  if @is_multiline
    @buffer_of_lines = Reline::HISTORY[@history_pointer].split("\n")
    @buffer_of_lines = [String.new(encoding: @encoding)] if @buffer_of_lines.empty?
    @line_index = line_no
    @line = @buffer_of_lines[@line_index]
    @rerender_all = true
  else
    @line = Reline::HISTORY[@history_pointer]
  end
  @cursor_max = calculate_width(@line)
  arg -= 1
  ed_search_prev_history(key, arg: arg) if arg &gt; 0
end</pre> </div>  </div> <div class="aliases"> Also aliased as: <a href="lineeditor.html#method-i-history_search_backward">history_search_backward</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-ed_transpose_chars"> <span class="method-name">ed_transpose_chars</span><span class="method-args">(key)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="ed_transpose_chars-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 2710
        def ed_transpose_chars(key)
  if @byte_pointer &gt; 0
    if @cursor_max &gt; @cursor
      byte_size = Reline::Unicode.get_next_mbchar_size(@line, @byte_pointer)
      mbchar = @line.byteslice(@byte_pointer, byte_size)
      width = Reline::Unicode.get_mbchar_width(mbchar)
      @cursor += width
      @byte_pointer += byte_size
    end
    back1_byte_size = Reline::Unicode.get_prev_mbchar_size(@line, @byte_pointer)
    if (@byte_pointer - back1_byte_size) &gt; 0
      back2_byte_size = Reline::Unicode.get_prev_mbchar_size(@line, @byte_pointer - back1_byte_size)
      back2_pointer = @byte_pointer - back1_byte_size - back2_byte_size
      @line, back2_mbchar = byteslice!(@line, back2_pointer, back2_byte_size)
      @line = byteinsert(@line, @byte_pointer - back2_byte_size, back2_mbchar)
    end
  end
end</pre> </div>  </div> <div class="aliases"> Also aliased as: <a href="lineeditor.html#method-i-transpose_chars">transpose_chars</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-ed_transpose_words"> <span class="method-name">ed_transpose_words</span><span class="method-args">(key)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="ed_transpose_words-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 2730
        def ed_transpose_words(key)
  left_word_start, middle_start, right_word_start, after_start = Reline::Unicode.ed_transpose_words(@line, @byte_pointer)
  before = @line.byteslice(0, left_word_start)
  left_word = @line.byteslice(left_word_start, middle_start - left_word_start)
  middle = @line.byteslice(middle_start, right_word_start - middle_start)
  right_word = @line.byteslice(right_word_start, after_start - right_word_start)
  after = @line.byteslice(after_start, @line.bytesize - after_start)
  return if left_word.empty? or right_word.empty?
  @line = before + right_word + middle + left_word + after
  from_head_to_left_word = before + right_word + middle + left_word
  @byte_pointer = from_head_to_left_word.bytesize
  @cursor = calculate_width(from_head_to_left_word)
end</pre> </div>  </div> <div class="aliases"> Also aliased as: <a href="lineeditor.html#method-i-transpose_words">transpose_words</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-ed_unassigned"> <span class="method-name">ed_unassigned</span><span class="method-args">(key)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="ed_unassigned-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 1911
def ed_unassigned(key) end</pre> </div> <dl class="rdoc-list note-list">
<dt>Editline </dt>
<dd> <p><code>ed-unassigned</code> This editor command always results in an error.</p> </dd>
<dt>GNU <a href="../readline.html"><code>Readline</code></a> </dt>
<dd> <p>There is no corresponding macro.</p> </dd>
</dl>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-em_capitol_case"> <span class="method-name">em_capitol_case</span><span class="method-args">(key)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="em_capitol_case-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 2745
        def em_capitol_case(key)
  if @line.bytesize &gt; @byte_pointer
    byte_size, _, new_str = Reline::Unicode.em_forward_word_with_capitalization(@line, @byte_pointer)
    before = @line.byteslice(0, @byte_pointer)
    after = @line.byteslice((@byte_pointer + byte_size)..-1)
    @line = before + new_str + after
    @byte_pointer += new_str.bytesize
    @cursor += calculate_width(new_str)
  end
end</pre> </div>  </div> <div class="aliases"> Also aliased as: <a href="lineeditor.html#method-i-capitalize_word">capitalize_word</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-em_delete"> <span class="method-name">em_delete</span><span class="method-args">(key)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="em_delete-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 2597
        def em_delete(key)
  if @line.empty? and (not @is_multiline or @buffer_of_lines.size == 1) and key == "\C-d".ord
    @line = nil
    if @buffer_of_lines.size &gt; 1
      scroll_down(@highest_in_all - @first_line_started_from)
    end
    Reline::IOGate.move_cursor_column(0)
    @eof = true
    finish
  elsif @byte_pointer &lt; @line.bytesize
    splitted_last = @line.byteslice(@byte_pointer, @line.bytesize)
    mbchar = splitted_last.grapheme_clusters.first
    width = Reline::Unicode.get_mbchar_width(mbchar)
    @cursor_max -= width
    @line, = byteslice!(@line, @byte_pointer, mbchar.bytesize)
  elsif @is_multiline and @byte_pointer == @line.bytesize and @buffer_of_lines.size &gt; @line_index + 1
    @cursor = calculate_width(@line)
    @byte_pointer = @line.bytesize
    @line += @buffer_of_lines.delete_at(@line_index + 1)
    @cursor_max = calculate_width(@line)
    @buffer_of_lines[@line_index] = @line
    @rerender_all = true
    @rest_height += 1
  end
end</pre> </div>  </div> <div class="aliases"> Also aliased as: <a href="lineeditor.html#method-i-delete_char">delete_char</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-em_delete_next_word"> <span class="method-name">em_delete_next_word</span><span class="method-args">(key)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="em_delete_next_word-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 2688
        def em_delete_next_word(key)
  if @line.bytesize &gt; @byte_pointer
    byte_size, width = Reline::Unicode.em_forward_word(@line, @byte_pointer)
    @line, word = byteslice!(@line, @byte_pointer, byte_size)
    @kill_ring.append(word)
    @cursor_max -= width
  end
end</pre> </div>  </div> <div class="aliases"> Also aliased as: <a href="lineeditor.html#method-i-kill_word">kill_word</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-em_delete_or_list"> <span class="method-name">em_delete_or_list</span><span class="method-args">(key)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="em_delete_or_list-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 2624
        def em_delete_or_list(key)
  if @line.empty? or @byte_pointer &lt; @line.bytesize
    em_delete(key)
  else # show completed list
    result = call_completion_proc
    if result.is_a?(Array)
      complete(result, true)
    end
  end
end</pre> </div>  </div> <div class="aliases"> Also aliased as: <a href="lineeditor.html#method-i-delete_char_or_list">delete_char_or_list</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-em_delete_prev_char"> <span class="method-name">em_delete_prev_char</span><span class="method-args">(key, arg: 1)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="em_delete_prev_char-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 2520
        def em_delete_prev_char(key, arg: 1)
  if @is_multiline and @cursor == 0 and @line_index &gt; 0
    @buffer_of_lines[@line_index] = @line
    @cursor = calculate_width(@buffer_of_lines[@line_index - 1])
    @byte_pointer = @buffer_of_lines[@line_index - 1].bytesize
    @buffer_of_lines[@line_index - 1] += @buffer_of_lines.delete_at(@line_index)
    @line_index -= 1
    @line = @buffer_of_lines[@line_index]
    @cursor_max = calculate_width(@line)
    @rerender_all = true
  elsif @cursor &gt; 0
    byte_size = Reline::Unicode.get_prev_mbchar_size(@line, @byte_pointer)
    @byte_pointer -= byte_size
    @line, mbchar = byteslice!(@line, @byte_pointer, byte_size)
    width = Reline::Unicode.get_mbchar_width(mbchar)
    @cursor -= width
    @cursor_max -= width
  end
  arg -= 1
  em_delete_prev_char(key, arg: arg) if arg &gt; 0
end</pre> </div>  </div> <div class="aliases"> Also aliased as: <a href="lineeditor.html#method-i-backward_delete_char">backward_delete_char</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-em_exchange_mark"> <span class="method-name">em_exchange_mark</span><span class="method-args">(key)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="em_exchange_mark-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 3284
        def em_exchange_mark(key)
  return unless @mark_pointer
  new_pointer = [@byte_pointer, @line_index]
  @previous_line_index = @line_index
  @byte_pointer, @line_index = @mark_pointer
  @cursor = calculate_width(@line.byteslice(0, @byte_pointer))
  @cursor_max = calculate_width(@line)
  @mark_pointer = new_pointer
end</pre> </div>  </div> <div class="aliases"> Also aliased as: <a href="lineeditor.html#method-i-exchange_point_and_mark">exchange_point_and_mark</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-em_kill_line"> <span class="method-name">em_kill_line</span><span class="method-args">(key)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="em_kill_line-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 2586
        def em_kill_line(key)
  if @line.size &gt; 0
    @kill_ring.append(@line.dup, true)
    @line.clear
    @byte_pointer = 0
    @cursor_max = 0
    @cursor = 0
  end
end</pre> </div> <dl class="rdoc-list note-list">
<dt>Editline </dt>
<dd> <p><code>em-kill-line</code> (not bound) Delete the entire contents of the edit buffer and save it to the cut buffer. <code>vi-kill-line-prev</code></p> </dd>
<dt>GNU <a href="../readline.html"><code>Readline</code></a> </dt>
<dd> <p><code>kill-whole-line</code> (not bound) Kill all characters on the current line, no matter where point is.</p> </dd>
</dl>  </div> <div class="aliases"> Also aliased as: <a href="lineeditor.html#method-i-kill_whole_line">kill_whole_line</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-em_kill_region"> <span class="method-name">em_kill_region</span><span class="method-args">(key)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="em_kill_region-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 2789
        def em_kill_region(key)
  if @byte_pointer &gt; 0
    byte_size, width = Reline::Unicode.em_big_backward_word(@line, @byte_pointer)
    @line, deleted = byteslice!(@line, @byte_pointer - byte_size, byte_size)
    @byte_pointer -= byte_size
    @cursor -= width
    @cursor_max -= width
    @kill_ring.append(deleted, true)
  end
end</pre> </div>  </div> <div class="aliases"> Also aliased as: <a href="lineeditor.html#method-i-unix_word_rubout">unix_word_rubout</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-em_lower_case"> <span class="method-name">em_lower_case</span><span class="method-args">(key)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="em_lower_case-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 2757
        def em_lower_case(key)
  if @line.bytesize &gt; @byte_pointer
    byte_size, = Reline::Unicode.em_forward_word(@line, @byte_pointer)
    part = @line.byteslice(@byte_pointer, byte_size).grapheme_clusters.map { |mbchar|
      mbchar =~ /[A-Z]/ ? mbchar.downcase : mbchar
    }.join
    rest = @line.byteslice((@byte_pointer + byte_size)..-1)
    @line = @line.byteslice(0, @byte_pointer) + part
    @byte_pointer = @line.bytesize
    @cursor = calculate_width(@line)
    @cursor_max = @cursor + calculate_width(rest)
    @line += rest
  end
end</pre> </div>  </div> <div class="aliases"> Also aliased as: <a href="lineeditor.html#method-i-downcase_word">downcase_word</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-em_meta_next"> <span class="method-name">em_meta_next</span><span class="method-args">(key)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="em_meta_next-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 3295
        def em_meta_next(key)
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-em_next_word"> <span class="method-name">em_next_word</span><span class="method-args">(key)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="em_next_word-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 2670
        def em_next_word(key)
  if @line.bytesize &gt; @byte_pointer
    byte_size, width = Reline::Unicode.em_forward_word(@line, @byte_pointer)
    @byte_pointer += byte_size
    @cursor += width
  end
end</pre> </div>  </div> <div class="aliases"> Also aliased as: <a href="lineeditor.html#method-i-forward_word">forward_word</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-em_set_mark"> <span class="method-name">em_set_mark</span><span class="method-args">(key)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="em_set_mark-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 3279
        def em_set_mark(key)
  @mark_pointer = [@byte_pointer, @line_index]
end</pre> </div>  </div> <div class="aliases"> Also aliased as: <a href="lineeditor.html#method-i-set_mark">set_mark</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-em_upper_case"> <span class="method-name">em_upper_case</span><span class="method-args">(key)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="em_upper_case-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 2773
        def em_upper_case(key)
  if @line.bytesize &gt; @byte_pointer
    byte_size, = Reline::Unicode.em_forward_word(@line, @byte_pointer)
    part = @line.byteslice(@byte_pointer, byte_size).grapheme_clusters.map { |mbchar|
      mbchar =~ /[a-z]/ ? mbchar.upcase : mbchar
    }.join
    rest = @line.byteslice((@byte_pointer + byte_size)..-1)
    @line = @line.byteslice(0, @byte_pointer) + part
    @byte_pointer = @line.bytesize
    @cursor = calculate_width(@line)
    @cursor_max = @cursor + calculate_width(rest)
    @line += rest
  end
end</pre> </div>  </div> <div class="aliases"> Also aliased as: <a href="lineeditor.html#method-i-upcase_word">upcase_word</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-em_yank"> <span class="method-name">em_yank</span><span class="method-args">(key)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="em_yank-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 2636
        def em_yank(key)
  yanked = @kill_ring.yank
  if yanked
    @line = byteinsert(@line, @byte_pointer, yanked)
    yanked_width = calculate_width(yanked)
    @cursor += yanked_width
    @cursor_max += yanked_width
    @byte_pointer += yanked.bytesize
  end
end</pre> </div>  </div> <div class="aliases"> Also aliased as: <a href="lineeditor.html#method-i-yank">yank</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-em_yank_pop"> <span class="method-name">em_yank_pop</span><span class="method-args">(key)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="em_yank_pop-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 2648
        def em_yank_pop(key)
  yanked, prev_yank = @kill_ring.yank_pop
  if yanked
    prev_yank_width = calculate_width(prev_yank)
    @cursor -= prev_yank_width
    @cursor_max -= prev_yank_width
    @byte_pointer -= prev_yank.bytesize
    @line, = byteslice!(@line, @byte_pointer, prev_yank.bytesize)
    @line = byteinsert(@line, @byte_pointer, yanked)
    yanked_width = calculate_width(yanked)
    @cursor += yanked_width
    @cursor_max += yanked_width
    @byte_pointer += yanked.bytesize
  end
end</pre> </div>  </div> <div class="aliases"> Also aliased as: <a href="lineeditor.html#method-i-yank_pop">yank_pop</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-generate_searcher"> <span class="method-name">generate_searcher</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="generate_searcher-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 2074
        def generate_searcher
  Fiber.new do |first_key|
    prev_search_key = first_key
    search_word = String.new(encoding: @encoding)
    multibyte_buf = String.new(encoding: 'ASCII-8BIT')
    last_hit = nil
    case first_key
    when "\C-r".ord
      prompt_name = 'reverse-i-search'
    when "\C-s".ord
      prompt_name = 'i-search'
    end
    loop do
      key = Fiber.yield(search_word)
      search_again = false
      case key
      when -1 # determined
        Reline.last_incremental_search = search_word
        break
      when "\C-h".ord, "\C-?".ord
        grapheme_clusters = search_word.grapheme_clusters
        if grapheme_clusters.size &gt; 0
          grapheme_clusters.pop
          search_word = grapheme_clusters.join
        end
      when "\C-r".ord, "\C-s".ord
        search_again = true if prev_search_key == key
        prev_search_key = key
      else
        multibyte_buf &lt;&lt; key
        if multibyte_buf.dup.force_encoding(@encoding).valid_encoding?
          search_word &lt;&lt; multibyte_buf.dup.force_encoding(@encoding)
          multibyte_buf.clear
        end
      end
      hit = nil
      if not search_word.empty? and @line_backup_in_history&amp;.include?(search_word)
        @history_pointer = nil
        hit = @line_backup_in_history
      else
        if search_again
          if search_word.empty? and Reline.last_incremental_search
            search_word = Reline.last_incremental_search
          end
          if @history_pointer
            case prev_search_key
            when "\C-r".ord
              history_pointer_base = 0
              history = Reline::HISTORY[0..(@history_pointer - 1)]
            when "\C-s".ord
              history_pointer_base = @history_pointer + 1
              history = Reline::HISTORY[(@history_pointer + 1)..-1]
            end
          else
            history_pointer_base = 0
            history = Reline::HISTORY
          end
        elsif @history_pointer
          case prev_search_key
          when "\C-r".ord
            history_pointer_base = 0
            history = Reline::HISTORY[0..@history_pointer]
          when "\C-s".ord
            history_pointer_base = @history_pointer
            history = Reline::HISTORY[@history_pointer..-1]
          end
        else
          history_pointer_base = 0
          history = Reline::HISTORY
        end
        case prev_search_key
        when "\C-r".ord
          hit_index = history.rindex { |item|
            item.include?(search_word)
          }
        when "\C-s".ord
          hit_index = history.index { |item|
            item.include?(search_word)
          }
        end
        if hit_index
          @history_pointer = history_pointer_base + hit_index
          hit = Reline::HISTORY[@history_pointer]
        end
      end
      case prev_search_key
      when "\C-r".ord
        prompt_name = 'reverse-i-search'
      when "\C-s".ord
        prompt_name = 'i-search'
      end
      if hit
        if @is_multiline
          @buffer_of_lines = hit.split("\n")
          @buffer_of_lines = [String.new(encoding: @encoding)] if @buffer_of_lines.empty?
          @line_index = @buffer_of_lines.size - 1
          @line = @buffer_of_lines.last
          @byte_pointer = @line.bytesize
          @cursor = @cursor_max = calculate_width(@line)
          @rerender_all = true
          @searching_prompt = "(%s)`%s'" % [prompt_name, search_word]
        else
          @line = hit
          @searching_prompt = "(%s)`%s': %s" % [prompt_name, search_word, hit]
        end
        last_hit = hit
      else
        if @is_multiline
          @rerender_all = true
          @searching_prompt = "(failed %s)`%s'" % [prompt_name, search_word]
        else
          @searching_prompt = "(failed %s)`%s': %s" % [prompt_name, search_word, last_hit]
        end
      end
    end
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-inclusive-3F"> <span class="method-name">inclusive?</span><span class="method-args">(method_obj)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="inclusive-3F-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 1412
        def inclusive?(method_obj)
  # If a motion method with the keyword argument "inclusive" follows the
  # operator, it must contain the character at the cursor position.
  method_obj and method_obj.parameters.any? { |param| param[0] == :key and param[1] == :inclusive }
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-incremental_search_history"> <span class="method-name">incremental_search_history</span><span class="method-args">(key)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="incremental_search_history-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 2192
        def incremental_search_history(key)
  unless @history_pointer
    if @is_multiline
      @line_backup_in_history = whole_buffer
    else
      @line_backup_in_history = @line
    end
  end
  searcher = generate_searcher
  searcher.resume(key)
  @searching_prompt = "(reverse-i-search)`': "
  termination_keys = ["\C-j".ord]
  termination_keys.concat(@config.isearch_terminators&amp;.chars&amp;.map(&amp;:ord)) if @config.isearch_terminators
  @waiting_proc = -&gt;(k) {
    case k
    when *termination_keys
      if @history_pointer
        buffer = Reline::HISTORY[@history_pointer]
      else
        buffer = @line_backup_in_history
      end
      if @is_multiline
        @buffer_of_lines = buffer.split("\n")
        @buffer_of_lines = [String.new(encoding: @encoding)] if @buffer_of_lines.empty?
        @line_index = @buffer_of_lines.size - 1
        @line = @buffer_of_lines.last
        @rerender_all = true
      else
        @line = buffer
      end
      @searching_prompt = nil
      @waiting_proc = nil
      @cursor_max = calculate_width(@line)
      @cursor = @byte_pointer = 0
      @rerender_all = true
      @cached_prompt_list = nil
      searcher.resume(-1)
    when "\C-g".ord
      if @is_multiline
        @buffer_of_lines = @line_backup_in_history.split("\n")
        @buffer_of_lines = [String.new(encoding: @encoding)] if @buffer_of_lines.empty?
        @line_index = @buffer_of_lines.size - 1
        @line = @buffer_of_lines.last
        @rerender_all = true
      else
        @line = @line_backup_in_history
      end
      @history_pointer = nil
      @searching_prompt = nil
      @waiting_proc = nil
      @line_backup_in_history = nil
      @cursor_max = calculate_width(@line)
      @cursor = @byte_pointer = 0
      @rerender_all = true
    else
      chr = k.is_a?(String) ? k : k.chr(Encoding::ASCII_8BIT)
      if chr.match?(/[[:print:]]/) or k == "\C-h".ord or k == "\C-?".ord or k == "\C-r".ord or k == "\C-s".ord
        searcher.resume(k)
      else
        if @history_pointer
          line = Reline::HISTORY[@history_pointer]
        else
          line = @line_backup_in_history
        end
        if @is_multiline
          @line_backup_in_history = whole_buffer
          @buffer_of_lines = line.split("\n")
          @buffer_of_lines = [String.new(encoding: @encoding)] if @buffer_of_lines.empty?
          @line_index = @buffer_of_lines.size - 1
          @line = @buffer_of_lines.last
          @rerender_all = true
        else
          @line_backup_in_history = @line
          @line = line
        end
        @searching_prompt = nil
        @waiting_proc = nil
        @cursor_max = calculate_width(@line)
        @cursor = @byte_pointer = 0
        @rerender_all = true
        @cached_prompt_list = nil
        searcher.resume(-1)
      end
    end
  }
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-insert_new_line"> <span class="method-name">insert_new_line</span><span class="method-args">(cursor_line, next_line)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="insert_new_line-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 332
        def insert_new_line(cursor_line, next_line)
  @line = cursor_line
  @buffer_of_lines.insert(@line_index + 1, String.new(next_line, encoding: @encoding))
  @previous_line_index = @line_index
  @line_index += 1
  @just_cursor_moving = false
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-key_delete"> <span class="method-name">key_delete</span><span class="method-args">(key)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="key_delete-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 1888
        def key_delete(key)
  if @config.editing_mode_is?(:vi_insert)
    ed_delete_next_char(key)
  elsif @config.editing_mode_is?(:emacs)
    em_delete(key)
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-key_newline"> <span class="method-name">key_newline</span><span class="method-args">(key)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="key_newline-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 1896
        def key_newline(key)
  if @is_multiline
    if (@buffer_of_lines.size - 1) == @line_index and @line.bytesize == @byte_pointer
      @add_newline_to_end_of_buffer = true
    end
    next_line = @line.byteslice(@byte_pointer, @line.bytesize - @byte_pointer)
    cursor_line = @line.byteslice(0, @byte_pointer)
    insert_new_line(cursor_line, next_line)
    @cursor = 0
    @check_new_auto_indent = true unless @in_pasting
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-menu"> <span class="method-name">menu</span><span class="method-args">(target, list)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="menu-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 1230
        def menu(target, list)
  @menu_info = MenuInfo.new(target, list)
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-modify_lines"> <span class="method-name">modify_lines</span><span class="method-args">(before, force_recalc: false)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="modify_lines-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 1182
        def modify_lines(before, force_recalc: false)
  return before if !force_recalc &amp;&amp; (before.nil? || before.empty? || simplified_rendering?)

  if after = @output_modifier_proc&amp;.call("#{before.join("\n")}\n", complete: finished?)
    after.lines("\n").map { |l| l.chomp('') }
  else
    before
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-move_completed_list"> <span class="method-name">move_completed_list</span><span class="method-args">(list, direction)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="move_completed_list-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 1324
        def move_completed_list(list, direction)
  case @completion_state
  when CompletionState::NORMAL, CompletionState::COMPLETION,
       CompletionState::MENU, CompletionState::MENU_WITH_PERFECT_MATCH
    @completion_state = CompletionState::JOURNEY
    result = retrieve_completion_block
    return if result.nil?
    preposing, target, postposing = result
    @completion_journey_data = CompletionJourneyData.new(
      preposing, postposing,
      [target] + list.select{ |item| item.start_with?(target) }, 0)
    if @completion_journey_data.list.size == 1
      @completion_journey_data.pointer = 0
    else
      case direction
      when :up
        @completion_journey_data.pointer = @completion_journey_data.list.size - 1
      when :down
        @completion_journey_data.pointer = 1
      end
    end
    @completion_state = CompletionState::JOURNEY
  else
    case direction
    when :up
      @completion_journey_data.pointer -= 1
      if @completion_journey_data.pointer &lt; 0
        @completion_journey_data.pointer = @completion_journey_data.list.size - 1
      end
    when :down
      @completion_journey_data.pointer += 1
      if @completion_journey_data.pointer &gt;= @completion_journey_data.list.size
        @completion_journey_data.pointer = 0
      end
    end
  end
  completed = @completion_journey_data.list[@completion_journey_data.pointer]
  new_line = (@completion_journey_data.preposing + completed + @completion_journey_data.postposing).split("\n")[@line_index]
  @line = new_line.nil? ? String.new(encoding: @encoding) : new_line
  line_to_pointer = (@completion_journey_data.preposing + completed).split("\n").last
  line_to_pointer = String.new(encoding: @encoding) if line_to_pointer.nil?
  @cursor_max = calculate_width(@line)
  @cursor = calculate_width(line_to_pointer)
  @byte_pointer = line_to_pointer.bytesize
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-move_cursor_down"> <span class="method-name">move_cursor_down</span><span class="method-args">(val)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="move_cursor_down-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 368
        def move_cursor_down(val)
  if val &gt; 0
    Reline::IOGate.move_cursor_down(val)
    @rest_height -= val
    @rest_height = 0 if @rest_height &lt; 0
  elsif val &lt; 0
    move_cursor_up(-val)
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-move_cursor_up"> <span class="method-name">move_cursor_up</span><span class="method-args">(val)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="move_cursor_up-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 359
        def move_cursor_up(val)
  if val &gt; 0
    Reline::IOGate.move_cursor_up(val)
    @rest_height += val
  elsif val &lt; 0
    move_cursor_down(-val)
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-normal_char"> <span class="method-name">normal_char</span><span class="method-args">(key)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="normal_char-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 1495
        def normal_char(key)
  method_symbol = method_obj = nil
  if key.combined_char.is_a?(Symbol)
    process_key(key.combined_char, key.combined_char)
    return
  end
  @multibyte_buffer &lt;&lt; key.combined_char
  if @multibyte_buffer.size &gt; 1
    if @multibyte_buffer.dup.force_encoding(@encoding).valid_encoding?
      process_key(@multibyte_buffer.dup.force_encoding(@encoding), nil)
      @multibyte_buffer.clear
    else
      # invalid
      return
    end
  else # single byte
    return if key.char &gt;= 128 # maybe, first byte of multi byte
    method_symbol = @config.editing_mode.get_method(key.combined_char)
    if key.with_meta and method_symbol == :ed_unassigned
      if @config.editing_mode_is?(:vi_command, :vi_insert)
        # split ESC + key in vi mode
        method_symbol = @config.editing_mode.get_method("\e".ord)
        process_key("\e".ord, method_symbol)
        method_symbol = @config.editing_mode.get_method(key.char)
        process_key(key.char, method_symbol)
      end
    else
      process_key(key.combined_char, method_symbol)
    end
    @multibyte_buffer.clear
  end
  if @config.editing_mode_is?(:vi_command) and @cursor &gt; 0 and @cursor == @cursor_max
    byte_size = Reline::Unicode.get_prev_mbchar_size(@line, @byte_pointer)
    @byte_pointer -= byte_size
    mbchar = @line.byteslice(@byte_pointer, byte_size)
    width = Reline::Unicode.get_mbchar_width(mbchar)
    @cursor -= width
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-padding_space_with_escape_sequences"> <span class="method-name">padding_space_with_escape_sequences</span><span class="method-args">(str, width)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="padding_space_with_escape_sequences-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 658
        def padding_space_with_escape_sequences(str, width)
  padding_width = width - calculate_width(str, true)
  # padding_width should be only positive value. But macOS and Alacritty returns negative value.
  padding_width = 0 if padding_width &lt; 0
  str + (' ' * padding_width)
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-process_auto_indent"> <span class="method-name">process_auto_indent</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="process_auto_indent-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 1640
        def process_auto_indent
  return if not @check_new_auto_indent and @previous_line_index # move cursor up or down
  if @check_new_auto_indent and @previous_line_index and @previous_line_index &gt; 0 and @line_index &gt; @previous_line_index
    # Fix indent of a line when a newline is inserted to the next
    new_lines = whole_lines
    new_indent = @auto_indent_proc.(new_lines[0..-3].push(''), @line_index - 1, 0, true)
    md = @line.match(/\A */)
    prev_indent = md[0].count(' ')
    @line = ' ' * new_indent + @line.lstrip

    new_indent = nil
    result = @auto_indent_proc.(new_lines[0..-2], @line_index - 1, (new_lines[@line_index - 1].bytesize + 1), false)
    if result
      new_indent = result
    end
    if new_indent&amp;.&gt;= 0
      @line = ' ' * new_indent + @line.lstrip
    end
  end
  new_lines = whole_lines
  new_indent = @auto_indent_proc.(new_lines, @line_index, @byte_pointer, @check_new_auto_indent)
  if new_indent&amp;.&gt;= 0
    md = new_lines[@line_index].match(/\A */)
    prev_indent = md[0].count(' ')
    if @check_new_auto_indent
      line = @buffer_of_lines[@line_index] = ' ' * new_indent + @buffer_of_lines[@line_index].lstrip
      @cursor = new_indent
      @cursor_max = calculate_width(line)
      @byte_pointer = new_indent
    else
      @line = ' ' * new_indent + @line.lstrip
      @cursor += new_indent - prev_indent
      @cursor_max = calculate_width(@line)
      @byte_pointer += new_indent - prev_indent
    end
  end
  @check_new_auto_indent = false
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-process_insert"> <span class="method-name">process_insert</span><span class="method-args">(force: false)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="process_insert-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 1913
        def process_insert(force: false)
  return if @continuous_insertion_buffer.empty? or (@in_pasting and not force)
  width = Reline::Unicode.calculate_width(@continuous_insertion_buffer)
  bytesize = @continuous_insertion_buffer.bytesize
  if @cursor == @cursor_max
    @line += @continuous_insertion_buffer
  else
    @line = byteinsert(@line, @byte_pointer, @continuous_insertion_buffer)
  end
  @byte_pointer += bytesize
  @cursor += width
  @cursor_max += width
  @continuous_insertion_buffer.clear
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-process_key"> <span class="method-name">process_key</span><span class="method-args">(key, method_symbol)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="process_key-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 1438
        def process_key(key, method_symbol)
  if method_symbol and respond_to?(method_symbol, true)
    method_obj = method(method_symbol)
  else
    method_obj = nil
  end
  if method_symbol and key.is_a?(Symbol)
    if @vi_arg and argumentable?(method_obj)
      run_for_operators(key, method_symbol) do |with_operator|
        wrap_method_call(method_symbol, method_obj, key, with_operator)
      end
    else
      wrap_method_call(method_symbol, method_obj, key) if method_obj
    end
    @kill_ring.process
    if @vi_arg
      @rerender_al = true
      @vi_arg = nil
    end
  elsif @vi_arg
    if key.chr =~ /[0-9]/
      ed_argument_digit(key)
    else
      if argumentable?(method_obj)
        run_for_operators(key, method_symbol) do |with_operator|
          wrap_method_call(method_symbol, method_obj, key, with_operator)
        end
      elsif @waiting_proc
        @waiting_proc.(key)
      elsif method_obj
        wrap_method_call(method_symbol, method_obj, key)
      else
        ed_insert(key) unless @config.editing_mode_is?(:vi_command)
      end
      @kill_ring.process
      if @vi_arg
        @rerender_all = true
        @vi_arg = nil
      end
    end
  elsif @waiting_proc
    @waiting_proc.(key)
    @kill_ring.process
  elsif method_obj
    if method_symbol == :ed_argument_digit
      wrap_method_call(method_symbol, method_obj, key)
    else
      run_for_operators(key, method_symbol) do |with_operator|
        wrap_method_call(method_symbol, method_obj, key, with_operator)
      end
    end
    @kill_ring.process
  else
    ed_insert(key) unless @config.editing_mode_is?(:vi_command)
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-range_subtract"> <span class="method-name">range_subtract</span><span class="method-args">(base_ranges, subtract_ranges)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="range_subtract-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 665
        def range_subtract(base_ranges, subtract_ranges)
  indices = base_ranges.flat_map(&amp;:to_a).uniq.sort - subtract_ranges.flat_map(&amp;:to_a)
  chunks = indices.chunk_while { |a, b| a + 1 == b }
  chunks.map { |a| a.first...a.last + 1 }
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-render_dialog"> <span class="method-name">render_dialog</span><span class="method-args">(cursor_column)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="render_dialog-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 649
        def render_dialog(cursor_column)
  changes = @dialogs.map do |dialog|
    old_dialog = dialog.dup
    update_each_dialog(dialog, cursor_column)
    [old_dialog, dialog]
  end
  render_dialog_changes(changes, cursor_column)
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-render_dialog_changes"> <span class="method-name">render_dialog_changes</span><span class="method-args">(changes, cursor_column)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="render_dialog_changes-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 677
        def render_dialog_changes(changes, cursor_column)
  # Collect x-coordinate range and content of previous and current dialogs for each line
  old_dialog_ranges = {}
  new_dialog_ranges = {}
  new_dialog_contents = {}
  changes.each do |old_dialog, new_dialog|
    if old_dialog.contents
      x_range, y_range = dialog_range(old_dialog, @previous_rendered_dialog_y)
      y_range.each do |y|
        (old_dialog_ranges[y] ||= []) &lt;&lt; x_range
      end
    end
    if new_dialog.contents
      x_range, y_range = dialog_range(new_dialog, @first_line_started_from + @started_from)
      y_range.each do |y|
        (new_dialog_ranges[y] ||= []) &lt;&lt; x_range
        (new_dialog_contents[y] ||= []) &lt;&lt; [x_range, new_dialog.contents[y - y_range.begin]]
      end
    end
  end
  return if old_dialog_ranges.empty? &amp;&amp; new_dialog_ranges.empty?

  # Calculate x-coordinate ranges to restore text that was hidden behind dialogs for each line
  ranges_to_restore = {}
  subtract_cache = {}
  old_dialog_ranges.each do |y, old_x_ranges|
    new_x_ranges = new_dialog_ranges[y] || []
    ranges = subtract_cache[[old_x_ranges, new_x_ranges]] ||= range_subtract(old_x_ranges, new_x_ranges)
    ranges_to_restore[y] = ranges if ranges.any?
  end

  # Create visual_lines for restoring text hidden behind dialogs
  if ranges_to_restore.any?
    lines = whole_lines
    prompt, _prompt_width, prompt_list = check_multiline_prompt(lines, force_recalc: true)
    modified_lines = modify_lines(lines, force_recalc: true)
    visual_lines = []
    modified_lines.each_with_index { |l, i|
      pr = prompt_list ? prompt_list[i] : prompt
      vl, = split_by_width(pr + l, @screen_size.last)
      vl.compact!
      visual_lines.concat(vl)
    }
  end

  # Clear and rerender all dialogs line by line
  Reline::IOGate.hide_cursor
  ymin, ymax = (ranges_to_restore.keys + new_dialog_ranges.keys).minmax
  scroll_partial_screen = @scroll_partial_screen || 0
  screen_y_range = scroll_partial_screen..(scroll_partial_screen + @screen_height - 1)
  ymin = ymin.clamp(screen_y_range.begin, screen_y_range.end)
  ymax = ymax.clamp(screen_y_range.begin, screen_y_range.end)
  dialog_y = @first_line_started_from + @started_from
  cursor_y = dialog_y
  if @highest_in_all &lt;= ymax
    scroll_down(ymax - cursor_y)
    move_cursor_up(ymax - cursor_y)
  end
  (ymin..ymax).each do |y|
    move_cursor_down(y - cursor_y)
    cursor_y = y
    new_x_ranges = new_dialog_ranges[y]
    restore_ranges = ranges_to_restore[y]
    # Restore text that was hidden behind dialogs
    if restore_ranges
      line = visual_lines[y] || ''
      restore_ranges.each do |range|
        col = range.begin
        width = range.end - range.begin
        s = padding_space_with_escape_sequences(Reline::Unicode.take_range(line, col, width), width)
        Reline::IOGate.move_cursor_column(col)
        @output.write "\e[0m#{s}\e[0m"
      end
      max_column = [calculate_width(line, true), new_x_ranges&amp;.map(&amp;:end)&amp;.max || 0].max
      if max_column &lt; restore_ranges.map(&amp;:end).max
        Reline::IOGate.move_cursor_column(max_column)
        Reline::IOGate.erase_after_cursor
      end
    end
    # Render dialog contents
    new_dialog_contents[y]&amp;.each do |x_range, content|
      Reline::IOGate.move_cursor_column(x_range.begin)
      @output.write "\e[0m#{content}\e[0m"
    end
  end
  move_cursor_up(cursor_y - dialog_y)
  Reline::IOGate.move_cursor_column(cursor_column)
  Reline::IOGate.show_cursor

  @previous_rendered_dialog_y = dialog_y
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-render_partial"> <span class="method-name">render_partial</span><span class="method-args">(prompt, prompt_width, line_to_render, this_started_from, with_control: true)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="render_partial-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 1085
        def render_partial(prompt, prompt_width, line_to_render, this_started_from, with_control: true)
  visual_lines, height = split_by_width(line_to_render.nil? ? prompt : prompt + line_to_render, @screen_size.last)
  cursor_up_from_last_line = 0
  if @scroll_partial_screen
    last_visual_line = this_started_from + (height - 1)
    last_screen_line = @scroll_partial_screen + (@screen_height - 1)
    if (@scroll_partial_screen - this_started_from) &gt;= height
      # Render nothing because this line is before the screen.
      visual_lines = []
    elsif this_started_from &gt; last_screen_line
      # Render nothing because this line is after the screen.
      visual_lines = []
    else
      deleted_lines_before_screen = []
      if @scroll_partial_screen &gt; this_started_from and last_visual_line &gt;= @scroll_partial_screen
        # A part of visual lines are before the screen.
        deleted_lines_before_screen = visual_lines.shift((@scroll_partial_screen - this_started_from) * 2)
        deleted_lines_before_screen.compact!
      end
      if this_started_from &lt;= last_screen_line and last_screen_line &lt; last_visual_line
        # A part of visual lines are after the screen.
        visual_lines.pop((last_visual_line - last_screen_line) * 2)
      end
      move_cursor_up(deleted_lines_before_screen.size - @started_from)
      cursor_up_from_last_line = @started_from - deleted_lines_before_screen.size
    end
  end
  if with_control
    if height &gt; @highest_in_this
      diff = height - @highest_in_this
      scroll_down(diff)
      @highest_in_all += diff
      @highest_in_this = height
      move_cursor_up(diff)
    elsif height &lt; @highest_in_this
      diff = @highest_in_this - height
      @highest_in_all -= diff
      @highest_in_this = height
    end
    move_cursor_up(@started_from)
    @started_from = calculate_height_by_width(prompt_width + @cursor) - 1
    cursor_up_from_last_line = height - 1 - @started_from
  end
  if Reline::Unicode::CSI_REGEXP.match?(prompt + line_to_render)
    @output.write "\e[0m" # clear character decorations
  end
  visual_lines.each_with_index do |line, index|
    Reline::IOGate.move_cursor_column(0)
    if line.nil?
      if calculate_width(visual_lines[index - 1], true) == Reline::IOGate.get_screen_size.last
        # reaches the end of line
        if Reline::IOGate.win? and Reline::IOGate.win_legacy_console?
          # A newline is automatically inserted if a character is rendered at
          # eol on command prompt.
        else
          # When the cursor is at the end of the line and erases characters
          # after the cursor, some terminals delete the character at the
          # cursor position.
          move_cursor_down(1)
          Reline::IOGate.move_cursor_column(0)
        end
      else
        Reline::IOGate.erase_after_cursor
        move_cursor_down(1)
        Reline::IOGate.move_cursor_column(0)
      end
      next
    end
    @output.write line
    if Reline::IOGate.win? and Reline::IOGate.win_legacy_console? and calculate_width(line, true) == Reline::IOGate.get_screen_size.last
      # A newline is automatically inserted if a character is rendered at eol on command prompt.
      @rest_height -= 1 if @rest_height &gt; 0
    end
    @output.flush
    if @first_prompt
      @first_prompt = false
      @pre_input_hook&amp;.call
    end
  end
  unless visual_lines.empty?
    Reline::IOGate.erase_after_cursor
    Reline::IOGate.move_cursor_column(0)
  end
  if with_control
    # Just after rendring, so the cursor is on the last line.
    if finished?
      Reline::IOGate.move_cursor_column(0)
    else
      # Moves up from bottom of lines to the cursor position.
      move_cursor_up(cursor_up_from_last_line)
      # This logic is buggy if a fullwidth char is wrapped because there is only one halfwidth at end of a line.
      Reline::IOGate.move_cursor_column((prompt_width + @cursor) % @screen_size.last)
    end
  end
  height
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-render_whole_lines"> <span class="method-name">render_whole_lines</span><span class="method-args">(lines, prompt, prompt_width)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="render_whole_lines-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 1059
        def render_whole_lines(lines, prompt, prompt_width)
  rendered_height = 0
  modify_lines(lines).each_with_index do |line, index|
    if prompt.is_a?(Array)
      line_prompt = prompt[index]
      prompt_width = calculate_width(line_prompt, true)
    else
      line_prompt = prompt
    end
    height = render_partial(line_prompt, prompt_width, line, rendered_height, with_control: false)
    if index &lt; (lines.size - 1)
      if @scroll_partial_screen
        if (@scroll_partial_screen - height) &lt; rendered_height and (@scroll_partial_screen + @screen_height - 1) &gt;= (rendered_height + height)
          move_cursor_down(1)
        end
      else
        scroll_down(1)
      end
      rendered_height += height
    else
      rendered_height += height - 1
    end
  end
  rendered_height
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-rerender_added_newline"> <span class="method-name">rerender_added_newline</span><span class="method-args">(prompt, prompt_width, prompt_list)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="rerender_added_newline-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 908
        def rerender_added_newline(prompt, prompt_width, prompt_list)
  @buffer_of_lines[@previous_line_index] = @line
  @line = @buffer_of_lines[@line_index]
  @previous_line_index = nil
  if @in_pasting
    scroll_down(1)
  else
    lines = whole_lines
    prev_line_prompt = @prompt_proc ? prompt_list[@line_index - 1] : prompt
    prev_line_prompt_width = @prompt_proc ? calculate_width(prev_line_prompt, true) : prompt_width
    prev_line = modify_lines(lines)[@line_index - 1]
    move_cursor_up(@started_from)
    render_partial(prev_line_prompt, prev_line_prompt_width, prev_line, @first_line_started_from + @started_from, with_control: false)
    scroll_down(1)
    render_partial(prompt, prompt_width, @line, @first_line_started_from + @started_from + 1, with_control: false)
  end
  @cursor = @cursor_max = calculate_width(@line)
  @byte_pointer = @line.bytesize
  @highest_in_all += @highest_in_this
  @highest_in_this = calculate_height_by_width(prompt_width + @cursor_max)
  @first_line_started_from += @started_from + 1
  @started_from = calculate_height_by_width(prompt_width + @cursor) - 1
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-rerender_all_lines"> <span class="method-name">rerender_all_lines</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="rerender_all_lines-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 1004
        def rerender_all_lines
  move_cursor_up(@first_line_started_from + @started_from)
  Reline::IOGate.move_cursor_column(0)
  back = 0
  new_buffer = whole_lines
  prompt, prompt_width, prompt_list = check_multiline_prompt(new_buffer)
  new_buffer.each_with_index do |line, index|
    prompt_width = calculate_width(prompt_list[index], true) if @prompt_proc
    width = prompt_width + calculate_width(line)
    height = calculate_height_by_width(width)
    back += height
  end
  old_highest_in_all = @highest_in_all
  if @line_index.zero?
    new_first_line_started_from = 0
  else
    new_first_line_started_from = calculate_height_by_lines(new_buffer[0..(@line_index - 1)], prompt_list || prompt)
  end
  new_started_from = calculate_height_by_width(prompt_width + @cursor) - 1
  calculate_scroll_partial_screen(back, new_first_line_started_from + new_started_from)
  if @scroll_partial_screen
    move_cursor_up(@first_line_started_from + @started_from)
    scroll_down(@screen_height - 1)
    move_cursor_up(@screen_height)
    Reline::IOGate.move_cursor_column(0)
  elsif back &gt; old_highest_in_all
    scroll_down(back - 1)
    move_cursor_up(back - 1)
  elsif back &lt; old_highest_in_all
    scroll_down(back)
    Reline::IOGate.erase_after_cursor
    (old_highest_in_all - back - 1).times do
      scroll_down(1)
      Reline::IOGate.erase_after_cursor
    end
    move_cursor_up(old_highest_in_all - 1)
  end
  render_whole_lines(new_buffer, prompt_list || prompt, prompt_width)
  if @prompt_proc
    prompt = prompt_list[@line_index]
    prompt_width = calculate_width(prompt, true)
  end
  @highest_in_this = calculate_height_by_width(prompt_width + @cursor_max)
  @highest_in_all = back
  @first_line_started_from = new_first_line_started_from
  @started_from = new_started_from
  if @scroll_partial_screen
    Reline::IOGate.move_cursor_up(@screen_height - (@first_line_started_from + @started_from - @scroll_partial_screen) - 1)
    Reline::IOGate.move_cursor_column((prompt_width + @cursor) % @screen_size.last)
  else
    move_cursor_down(@first_line_started_from + @started_from - back + 1)
    Reline::IOGate.move_cursor_column((prompt_width + @cursor) % @screen_size.last)
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-rerender_changed_current_line"> <span class="method-name">rerender_changed_current_line</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="rerender_changed_current_line-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 960
        def rerender_changed_current_line
  new_lines = whole_lines
  prompt, prompt_width, prompt_list = check_multiline_prompt(new_lines)
  all_height = calculate_height_by_lines(new_lines, prompt_list || prompt)
  diff = all_height - @highest_in_all
  move_cursor_down(@highest_in_all - @first_line_started_from - @started_from - 1)
  if diff &gt; 0
    scroll_down(diff)
    move_cursor_up(all_height - 1)
  elsif diff &lt; 0
    (-diff).times do
      Reline::IOGate.move_cursor_column(0)
      Reline::IOGate.erase_after_cursor
      move_cursor_up(1)
    end
    move_cursor_up(all_height - 1)
  else
    move_cursor_up(all_height - 1)
  end
  @highest_in_all = all_height
  back = render_whole_lines(new_lines, prompt_list || prompt, prompt_width)
  move_cursor_up(back)
  if @previous_line_index
    @buffer_of_lines[@previous_line_index] = @line
    @line = @buffer_of_lines[@line_index]
  end
  @first_line_started_from =
    if @line_index.zero?
      0
    else
      calculate_height_by_lines(@buffer_of_lines[0..(@line_index - 1)], prompt_list || prompt)
    end
  if @prompt_proc
    prompt = prompt_list[@line_index]
    prompt_width = calculate_width(prompt, true)
  end
  move_cursor_down(@first_line_started_from)
  calculate_nearest_cursor
  @started_from = calculate_height_by_width(prompt_width + @cursor) - 1
  move_cursor_down(@started_from)
  Reline::IOGate.move_cursor_column((prompt_width + @cursor) % @screen_size.last)
  @highest_in_this = calculate_height_by_width(prompt_width + @cursor_max)
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-run_for_operators"> <span class="method-name">run_for_operators</span><span class="method-args">(key, method_symbol, &amp;block)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="run_for_operators-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 1370
        def run_for_operators(key, method_symbol, &amp;block)
  if @waiting_operator_proc
    if VI_MOTIONS.include?(method_symbol)
      old_cursor, old_byte_pointer = @cursor, @byte_pointer
      @vi_arg = @waiting_operator_vi_arg if @waiting_operator_vi_arg&amp;.&gt; 1
      block.(true)
      unless @waiting_proc
        cursor_diff, byte_pointer_diff = @cursor - old_cursor, @byte_pointer - old_byte_pointer
        @cursor, @byte_pointer = old_cursor, old_byte_pointer
        @waiting_operator_proc.(cursor_diff, byte_pointer_diff)
      else
        old_waiting_proc = @waiting_proc
        old_waiting_operator_proc = @waiting_operator_proc
        current_waiting_operator_proc = @waiting_operator_proc
        @waiting_proc = proc { |k|
          old_cursor, old_byte_pointer = @cursor, @byte_pointer
          old_waiting_proc.(k)
          cursor_diff, byte_pointer_diff = @cursor - old_cursor, @byte_pointer - old_byte_pointer
          @cursor, @byte_pointer = old_cursor, old_byte_pointer
          current_waiting_operator_proc.(cursor_diff, byte_pointer_diff)
          @waiting_operator_proc = old_waiting_operator_proc
        }
      end
    else
      # Ignores operator when not motion is given.
      block.(false)
    end
    @waiting_operator_proc = nil
    @waiting_operator_vi_arg = nil
    if @vi_arg
      @rerender_all = true
      @vi_arg = nil
    end
  else
    block.(false)
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-scroll_down"> <span class="method-name">scroll_down</span><span class="method-args">(val)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="scroll_down-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 348
        def scroll_down(val)
  if val &lt;= @rest_height
    Reline::IOGate.move_cursor_down(val)
    @rest_height -= val
  else
    Reline::IOGate.move_cursor_down(@rest_height)
    Reline::IOGate.scroll_down(val - @rest_height)
    @rest_height = 0
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-search_next_char"> <span class="method-name">search_next_char</span><span class="method-args">(key, arg, need_prev_char: false, inclusive: false)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="search_next_char-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 3168
        def search_next_char(key, arg, need_prev_char: false, inclusive: false)
  if key.instance_of?(String)
    inputed_char = key
  else
    inputed_char = key.chr
  end
  prev_total = nil
  total = nil
  found = false
  @line.byteslice(@byte_pointer..-1).grapheme_clusters.each do |mbchar|
    # total has [byte_size, cursor]
    unless total
      # skip cursor point
      width = Reline::Unicode.get_mbchar_width(mbchar)
      total = [mbchar.bytesize, width]
    else
      if inputed_char == mbchar
        arg -= 1
        if arg.zero?
          found = true
          break
        end
      end
      width = Reline::Unicode.get_mbchar_width(mbchar)
      prev_total = total
      total = [total.first + mbchar.bytesize, total.last + width]
    end
  end
  if not need_prev_char and found and total
    byte_size, width = total
    @byte_pointer += byte_size
    @cursor += width
  elsif need_prev_char and found and prev_total
    byte_size, width = prev_total
    @byte_pointer += byte_size
    @cursor += width
  end
  if inclusive
    byte_size = Reline::Unicode.get_next_mbchar_size(@line, @byte_pointer)
    if byte_size &gt; 0
      c = @line.byteslice(@byte_pointer, byte_size)
      width = Reline::Unicode.get_mbchar_width(c)
      @byte_pointer += byte_size
      @cursor += width
    end
  end
  @waiting_proc = nil
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-search_prev_char"> <span class="method-name">search_prev_char</span><span class="method-args">(key, arg, need_next_char = false)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="search_prev_char-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 3225
        def search_prev_char(key, arg, need_next_char = false)
  if key.instance_of?(String)
    inputed_char = key
  else
    inputed_char = key.chr
  end
  prev_total = nil
  total = nil
  found = false
  @line.byteslice(0..@byte_pointer).grapheme_clusters.reverse_each do |mbchar|
    # total has [byte_size, cursor]
    unless total
      # skip cursor point
      width = Reline::Unicode.get_mbchar_width(mbchar)
      total = [mbchar.bytesize, width]
    else
      if inputed_char == mbchar
        arg -= 1
        if arg.zero?
          found = true
          break
        end
      end
      width = Reline::Unicode.get_mbchar_width(mbchar)
      prev_total = total
      total = [total.first + mbchar.bytesize, total.last + width]
    end
  end
  if not need_next_char and found and total
    byte_size, width = total
    @byte_pointer -= byte_size
    @cursor -= width
  elsif need_next_char and found and prev_total
    byte_size, width = prev_total
    @byte_pointer -= byte_size
    @cursor -= width
  end
  @waiting_proc = nil
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-show_menu"> <span class="method-name">show_menu</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="show_menu-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 1192
        def show_menu
  scroll_down(@highest_in_all - @first_line_started_from)
  @rerender_all = true
  @menu_info.list.sort!.each do |item|
    Reline::IOGate.move_cursor_column(0)
    @output.write item
    @output.flush
    scroll_down(1)
  end
  scroll_down(@highest_in_all - 1)
  move_cursor_up(@highest_in_all - 1 - @first_line_started_from)
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-split_by_width"> <span class="method-name">split_by_width</span><span class="method-args">(str, max_width)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="split_by_width-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 344
        def split_by_width(str, max_width)
  Reline::Unicode.split_by_width(str, max_width, @encoding)
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-update_each_dialog"> <span class="method-name">update_each_dialog</span><span class="method-args">(dialog, cursor_column)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="update_each_dialog-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 769
        def update_each_dialog(dialog, cursor_column)
  if @in_pasting
    dialog.contents = nil
    dialog.trap_key = nil
    return
  end
  dialog.set_cursor_pos(cursor_column, @first_line_started_from + @started_from)
  dialog_render_info = dialog.call(@last_key)
  if dialog_render_info.nil? or dialog_render_info.contents.nil? or dialog_render_info.contents.empty?
    dialog.contents = nil
    dialog.trap_key = nil
    return
  end
  contents = dialog_render_info.contents
  pointer = dialog.pointer
  if dialog_render_info.width
    dialog.width = dialog_render_info.width
  else
    dialog.width = contents.map { |l| calculate_width(l, true) }.max
  end
  height = dialog_render_info.height || DIALOG_DEFAULT_HEIGHT
  height = contents.size if contents.size &lt; height
  if contents.size &gt; height
    if dialog.pointer
      if dialog.pointer &lt; 0
        dialog.scroll_top = 0
      elsif (dialog.pointer - dialog.scroll_top) &gt;= (height - 1)
        dialog.scroll_top = dialog.pointer - (height - 1)
      elsif (dialog.pointer - dialog.scroll_top) &lt; 0
        dialog.scroll_top = dialog.pointer
      end
      pointer = dialog.pointer - dialog.scroll_top
    else
      dialog.scroll_top = 0
    end
    contents = contents[dialog.scroll_top, height]
  end
  if dialog_render_info.scrollbar and dialog_render_info.contents.size &gt; height
    bar_max_height = height * 2
    moving_distance = (dialog_render_info.contents.size - height) * 2
    position_ratio = dialog.scroll_top.zero? ? 0.0 : ((dialog.scroll_top * 2).to_f / moving_distance)
    bar_height = (bar_max_height * ((contents.size * 2).to_f / (dialog_render_info.contents.size * 2))).floor.to_i
    bar_height = MINIMUM_SCROLLBAR_HEIGHT if bar_height &lt; MINIMUM_SCROLLBAR_HEIGHT
    scrollbar_pos = ((bar_max_height - bar_height) * position_ratio).floor.to_i
  else
    scrollbar_pos = nil
  end
  upper_space = @first_line_started_from - @started_from
  dialog.column = dialog_render_info.pos.x
  dialog.width += @block_elem_width if scrollbar_pos
  diff = (dialog.column + dialog.width) - (@screen_size.last)
  if diff &gt; 0
    dialog.column -= diff
  end
  if (@rest_height - dialog_render_info.pos.y) &gt;= height
    dialog.vertical_offset = dialog_render_info.pos.y + 1
  elsif upper_space &gt;= height
    dialog.vertical_offset = dialog_render_info.pos.y - height
  else
    dialog.vertical_offset = dialog_render_info.pos.y + 1
  end
  if dialog.column &lt; 0
    dialog.column = 0
    dialog.width = @screen_size.last
  end
  face = Reline::Face[dialog_render_info.face || :default]
  scrollbar_sgr = face[:scrollbar]
  default_sgr = face[:default]
  enhanced_sgr = face[:enhanced]
  dialog.contents = contents.map.with_index do |item, i|
    line_sgr = i == pointer ? enhanced_sgr : default_sgr
    str_width = dialog.width - (scrollbar_pos.nil? ? 0 : @block_elem_width)
    str = padding_space_with_escape_sequences(Reline::Unicode.take_range(item, 0, str_width), str_width)
    colored_content = "#{line_sgr}#{str}"
    if scrollbar_pos
      if scrollbar_pos &lt;= (i * 2) and (i * 2 + 1) &lt; (scrollbar_pos + bar_height)
        colored_content + scrollbar_sgr + @full_block
      elsif scrollbar_pos &lt;= (i * 2) and (i * 2) &lt; (scrollbar_pos + bar_height)
        colored_content + scrollbar_sgr + @upper_half_block
      elsif scrollbar_pos &lt;= (i * 2 + 1) and (i * 2) &lt; (scrollbar_pos + bar_height)
        colored_content + scrollbar_sgr + @lower_half_block
      else
        colored_content + scrollbar_sgr + ' ' * @block_elem_width
      end
    else
      colored_content
    end
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-vi_add"> <span class="method-name">vi_add</span><span class="method-args">(key)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="vi_add-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 2811
        def vi_add(key)
  @config.editing_mode = :vi_insert
  ed_next_char(key)
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-vi_add_at_eol"> <span class="method-name">vi_add_at_eol</span><span class="method-args">(key)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="vi_add_at_eol-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 2925
        def vi_add_at_eol(key)
  ed_move_to_end(key)
  @config.editing_mode = :vi_insert
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-vi_change_meta"> <span class="method-name">vi_change_meta</span><span class="method-args">(key, arg: 1)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="vi_change_meta-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 2951
        def vi_change_meta(key, arg: 1)
  @drop_terminate_spaces = true
  @waiting_operator_proc = proc { |cursor_diff, byte_pointer_diff|
    if byte_pointer_diff &gt; 0
      @line, cut = byteslice!(@line, @byte_pointer, byte_pointer_diff)
    elsif byte_pointer_diff &lt; 0
      @line, cut = byteslice!(@line, @byte_pointer + byte_pointer_diff, -byte_pointer_diff)
    end
    copy_for_vi(cut)
    @cursor += cursor_diff if cursor_diff &lt; 0
    @cursor_max -= cursor_diff.abs
    @byte_pointer += byte_pointer_diff if byte_pointer_diff &lt; 0
    @config.editing_mode = :vi_insert
    @drop_terminate_spaces = false
  }
  @waiting_operator_vi_arg = arg
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-vi_command_mode"> <span class="method-name">vi_command_mode</span><span class="method-args">(key)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="vi_command_mode-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 2816
        def vi_command_mode(key)
  ed_prev_char(key)
  @config.editing_mode = :vi_command
end</pre> </div>  </div> <div class="aliases"> Also aliased as: <a href="lineeditor.html#method-i-vi_movement_mode">vi_movement_mode</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-vi_delete_meta"> <span class="method-name">vi_delete_meta</span><span class="method-args">(key, arg: 1)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="vi_delete_meta-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 2969
        def vi_delete_meta(key, arg: 1)
  @waiting_operator_proc = proc { |cursor_diff, byte_pointer_diff|
    if byte_pointer_diff &gt; 0
      @line, cut = byteslice!(@line, @byte_pointer, byte_pointer_diff)
    elsif byte_pointer_diff &lt; 0
      @line, cut = byteslice!(@line, @byte_pointer + byte_pointer_diff, -byte_pointer_diff)
    end
    copy_for_vi(cut)
    @cursor += cursor_diff if cursor_diff &lt; 0
    @cursor_max -= cursor_diff.abs
    @byte_pointer += byte_pointer_diff if byte_pointer_diff &lt; 0
  }
  @waiting_operator_vi_arg = arg
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-vi_delete_prev_char"> <span class="method-name">vi_delete_prev_char</span><span class="method-args">(key)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="vi_delete_prev_char-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 2900
        def vi_delete_prev_char(key)
  if @is_multiline and @cursor == 0 and @line_index &gt; 0
    @buffer_of_lines[@line_index] = @line
    @cursor = calculate_width(@buffer_of_lines[@line_index - 1])
    @byte_pointer = @buffer_of_lines[@line_index - 1].bytesize
    @buffer_of_lines[@line_index - 1] += @buffer_of_lines.delete_at(@line_index)
    @line_index -= 1
    @line = @buffer_of_lines[@line_index]
    @cursor_max = calculate_width(@line)
    @rerender_all = true
  elsif @cursor &gt; 0
    byte_size = Reline::Unicode.get_prev_mbchar_size(@line, @byte_pointer)
    @byte_pointer -= byte_size
    @line, mbchar = byteslice!(@line, @byte_pointer, byte_size)
    width = Reline::Unicode.get_mbchar_width(mbchar)
    @cursor -= width
    @cursor_max -= width
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-vi_end_big_word"> <span class="method-name">vi_end_big_word</span><span class="method-args">(key, arg: 1, inclusive: false)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="vi_end_big_word-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 2881
        def vi_end_big_word(key, arg: 1, inclusive: false)
  if @line.bytesize &gt; @byte_pointer
    byte_size, width = Reline::Unicode.vi_big_forward_end_word(@line, @byte_pointer)
    @byte_pointer += byte_size
    @cursor += width
  end
  arg -= 1
  if inclusive and arg.zero?
    byte_size = Reline::Unicode.get_next_mbchar_size(@line, @byte_pointer)
    if byte_size &gt; 0
      c = @line.byteslice(@byte_pointer, byte_size)
      width = Reline::Unicode.get_mbchar_width(c)
      @byte_pointer += byte_size
      @cursor += width
    end
  end
  vi_end_big_word(key, arg: arg) if arg &gt; 0
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-vi_end_word"> <span class="method-name">vi_end_word</span><span class="method-args">(key, arg: 1, inclusive: false)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="vi_end_word-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 2842
        def vi_end_word(key, arg: 1, inclusive: false)
  if @line.bytesize &gt; @byte_pointer
    byte_size, width = Reline::Unicode.vi_forward_end_word(@line, @byte_pointer)
    @byte_pointer += byte_size
    @cursor += width
  end
  arg -= 1
  if inclusive and arg.zero?
    byte_size = Reline::Unicode.get_next_mbchar_size(@line, @byte_pointer)
    if byte_size &gt; 0
      c = @line.byteslice(@byte_pointer, byte_size)
      width = Reline::Unicode.get_mbchar_width(c)
      @byte_pointer += byte_size
      @cursor += width
    end
  end
  vi_end_word(key, arg: arg) if arg &gt; 0
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-vi_first_print"> <span class="method-name">vi_first_print</span><span class="method-args">(key)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="vi_first_print-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 2050
        def vi_first_print(key)
  @byte_pointer, @cursor = Reline::Unicode.vi_first_print(@line)
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-vi_histedit"> <span class="method-name">vi_histedit</span><span class="method-args">(key)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="vi_histedit-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 3054
        def vi_histedit(key)
  path = Tempfile.open { |fp|
    if @is_multiline
      fp.write whole_lines.join("\n")
    else
      fp.write @line
    end
    fp.path
  }
  system("#{ENV['EDITOR']} #{path}")
  if @is_multiline
    @buffer_of_lines = File.read(path).split("\n")
    @buffer_of_lines = [String.new(encoding: @encoding)] if @buffer_of_lines.empty?
    @line_index = 0
    @line = @buffer_of_lines[@line_index]
    @rerender_all = true
  else
    @line = File.read(path)
  end
  finish
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-vi_insert"> <span class="method-name">vi_insert</span><span class="method-args">(key)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="vi_insert-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 2807
        def vi_insert(key)
  @config.editing_mode = :vi_insert
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-vi_insert_at_bol"> <span class="method-name">vi_insert_at_bol</span><span class="method-args">(key)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="vi_insert_at_bol-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 2920
        def vi_insert_at_bol(key)
  ed_move_to_beg(key)
  @config.editing_mode = :vi_insert
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-vi_join_lines"> <span class="method-name">vi_join_lines</span><span class="method-args">(key, arg: 1)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="vi_join_lines-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 3265
        def vi_join_lines(key, arg: 1)
  if @is_multiline and @buffer_of_lines.size &gt; @line_index + 1
    @cursor = calculate_width(@line)
    @byte_pointer = @line.bytesize
    @line += ' ' + @buffer_of_lines.delete_at(@line_index + 1).lstrip
    @cursor_max = calculate_width(@line)
    @buffer_of_lines[@line_index] = @line
    @rerender_all = true
    @rest_height += 1
  end
  arg -= 1
  vi_join_lines(key, arg: arg) if arg &gt; 0
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-vi_kill_line_prev"> <span class="method-name">vi_kill_line_prev</span><span class="method-args">(key)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="vi_kill_line_prev-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 2571
        def vi_kill_line_prev(key)
  if @byte_pointer &gt; 0
    @line, deleted = byteslice!(@line, 0, @byte_pointer)
    @byte_pointer = 0
    @kill_ring.append(deleted, true)
    @cursor_max = calculate_width(@line)
    @cursor = 0
  end
end</pre> </div> <dl class="rdoc-list note-list">
<dt>Editline </dt>
<dd> <p><code>vi-kill-line-prev</code> (vi: <code>Ctrl-U</code>) Delete the string from the beginning of the edit buffer to the cursor and save it to the cut buffer.</p> </dd>
<dt>GNU <a href="../readline.html"><code>Readline</code></a> </dt>
<dd> <p><code>unix-line-discard</code> (<code>C-u</code>) Kill backward from the cursor to the beginning of the current line.</p> </dd>
</dl>  </div> <div class="aliases"> Also aliased as: <a href="lineeditor.html#method-i-unix_line_discard">unix_line_discard</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-vi_list_or_eof"> <span class="method-name">vi_list_or_eof</span><span class="method-args">(key)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="vi_list_or_eof-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 2996
        def vi_list_or_eof(key)
  if (not @is_multiline and @line.empty?) or (@is_multiline and @line.empty? and @buffer_of_lines.size == 1)
    @line = nil
    if @buffer_of_lines.size &gt; 1
      scroll_down(@highest_in_all - @first_line_started_from)
    end
    Reline::IOGate.move_cursor_column(0)
    @eof = true
    finish
  else
    ed_newline(key)
  end
end</pre> </div>  </div> <div class="aliases"> Also aliased as: <a href="lineeditor.html#method-i-vi_end_of_transmission">vi_end_of_transmission</a>, <a href="lineeditor.html#method-i-vi_eof_maybe">vi_eof_maybe</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-vi_next_big_word"> <span class="method-name">vi_next_big_word</span><span class="method-args">(key, arg: 1)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="vi_next_big_word-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 2861
        def vi_next_big_word(key, arg: 1)
  if @line.bytesize &gt; @byte_pointer
    byte_size, width = Reline::Unicode.vi_big_forward_word(@line, @byte_pointer)
    @byte_pointer += byte_size
    @cursor += width
  end
  arg -= 1
  vi_next_big_word(key, arg: arg) if arg &gt; 0
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-vi_next_char"> <span class="method-name">vi_next_char</span><span class="method-args">(key, arg: 1, inclusive: false)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="vi_next_char-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 3160
        def vi_next_char(key, arg: 1, inclusive: false)
  @waiting_proc = -&gt;(key_for_proc) { search_next_char(key_for_proc, arg, inclusive: inclusive) }
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-vi_next_word"> <span class="method-name">vi_next_word</span><span class="method-args">(key, arg: 1)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="vi_next_word-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 2822
        def vi_next_word(key, arg: 1)
  if @line.bytesize &gt; @byte_pointer
    byte_size, width = Reline::Unicode.vi_forward_word(@line, @byte_pointer, @drop_terminate_spaces)
    @byte_pointer += byte_size
    @cursor += width
  end
  arg -= 1
  vi_next_word(key, arg: arg) if arg &gt; 0
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-vi_paste_next"> <span class="method-name">vi_paste_next</span><span class="method-args">(key, arg: 1)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="vi_paste_next-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 3088
        def vi_paste_next(key, arg: 1)
  if @vi_clipboard.size &gt; 0
    byte_size = Reline::Unicode.get_next_mbchar_size(@line, @byte_pointer)
    @line = byteinsert(@line, @byte_pointer + byte_size, @vi_clipboard)
    @cursor_max += calculate_width(@vi_clipboard)
    @cursor += calculate_width(@vi_clipboard)
    @byte_pointer += @vi_clipboard.bytesize
  end
  arg -= 1
  vi_paste_next(key, arg: arg) if arg &gt; 0
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-vi_paste_prev"> <span class="method-name">vi_paste_prev</span><span class="method-args">(key, arg: 1)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="vi_paste_prev-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 3076
        def vi_paste_prev(key, arg: 1)
  if @vi_clipboard.size &gt; 0
    @line = byteinsert(@line, @byte_pointer, @vi_clipboard)
    @cursor_max += calculate_width(@vi_clipboard)
    cursor_point = @vi_clipboard.grapheme_clusters[0..-2].join
    @cursor += calculate_width(cursor_point)
    @byte_pointer += cursor_point.bytesize
  end
  arg -= 1
  vi_paste_prev(key, arg: arg) if arg &gt; 0
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-vi_prev_big_word"> <span class="method-name">vi_prev_big_word</span><span class="method-args">(key, arg: 1)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="vi_prev_big_word-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 2871
        def vi_prev_big_word(key, arg: 1)
  if @byte_pointer &gt; 0
    byte_size, width = Reline::Unicode.vi_big_backward_word(@line, @byte_pointer)
    @byte_pointer -= byte_size
    @cursor -= width
  end
  arg -= 1
  vi_prev_big_word(key, arg: arg) if arg &gt; 0
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-vi_prev_char"> <span class="method-name">vi_prev_char</span><span class="method-args">(key, arg: 1)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="vi_prev_char-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 3217
        def vi_prev_char(key, arg: 1)
  @waiting_proc = -&gt;(key_for_proc) { search_prev_char(key_for_proc, arg) }
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-vi_prev_word"> <span class="method-name">vi_prev_word</span><span class="method-args">(key, arg: 1)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="vi_prev_word-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 2832
        def vi_prev_word(key, arg: 1)
  if @byte_pointer &gt; 0
    byte_size, width = Reline::Unicode.vi_backward_word(@line, @byte_pointer)
    @byte_pointer -= byte_size
    @cursor -= width
  end
  arg -= 1
  vi_prev_word(key, arg: arg) if arg &gt; 0
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-vi_replace_char"> <span class="method-name">vi_replace_char</span><span class="method-args">(key, arg: 1)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="vi_replace_char-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 3132
        def vi_replace_char(key, arg: 1)
  @waiting_proc = -&gt;(k) {
    if arg == 1
      byte_size = Reline::Unicode.get_next_mbchar_size(@line, @byte_pointer)
      before = @line.byteslice(0, @byte_pointer)
      remaining_point = @byte_pointer + byte_size
      after = @line.byteslice(remaining_point, @line.bytesize - remaining_point)
      @line = before + k.chr + after
      @cursor_max = calculate_width(@line)
      @waiting_proc = nil
    elsif arg &gt; 1
      byte_size = 0
      arg.times do
        byte_size += Reline::Unicode.get_next_mbchar_size(@line, @byte_pointer + byte_size)
      end
      before = @line.byteslice(0, @byte_pointer)
      remaining_point = @byte_pointer + byte_size
      after = @line.byteslice(remaining_point, @line.bytesize - remaining_point)
      replaced = k.chr * arg
      @line = before + replaced + after
      @byte_pointer += replaced.bytesize
      @cursor += calculate_width(replaced)
      @cursor_max = calculate_width(@line)
      @waiting_proc = nil
    end
  }
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-vi_search_next"> <span class="method-name">vi_search_next</span><span class="method-args">(key)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="vi_search_next-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 2284
        def vi_search_next(key)
  incremental_search_history(key)
end</pre> </div>  </div> <div class="aliases"> Also aliased as: <a href="lineeditor.html#method-i-forward_search_history">forward_search_history</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-vi_search_prev"> <span class="method-name">vi_search_prev</span><span class="method-args">(key)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="vi_search_prev-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 2279
        def vi_search_prev(key)
  incremental_search_history(key)
end</pre> </div>  </div> <div class="aliases"> Also aliased as: <a href="lineeditor.html#method-i-reverse_search_history">reverse_search_history</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-vi_to_column"> <span class="method-name">vi_to_column</span><span class="method-args">(key, arg: 0)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="vi_to_column-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 3117
        def vi_to_column(key, arg: 0)
  @byte_pointer, @cursor = @line.grapheme_clusters.inject([0, 0]) { |total, gc|
    # total has [byte_size, cursor]
    mbchar_width = Reline::Unicode.get_mbchar_width(gc)
    if (total.last + mbchar_width) &gt;= arg
      break total
    elsif (total.last + mbchar_width) &gt;= @cursor_max
      break total
    else
      total = [total.first + gc.bytesize, total.last + mbchar_width]
      total
    end
  }
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-vi_to_history_line"> <span class="method-name">vi_to_history_line</span><span class="method-args">(key)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="vi_to_history_line-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 3031
        def vi_to_history_line(key)
  if Reline::HISTORY.empty?
    return
  end
  if @history_pointer.nil?
    @history_pointer = 0
    @line_backup_in_history = @line
    @line = Reline::HISTORY[@history_pointer]
    @cursor_max = calculate_width(@line)
    @cursor = 0
    @byte_pointer = 0
  elsif @history_pointer.zero?
    return
  else
    Reline::HISTORY[@history_pointer] = @line
    @history_pointer = 0
    @line = Reline::HISTORY[@history_pointer]
    @cursor_max = calculate_width(@line)
    @cursor = 0
    @byte_pointer = 0
  end
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-vi_to_next_char"> <span class="method-name">vi_to_next_char</span><span class="method-args">(key, arg: 1, inclusive: false)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="vi_to_next_char-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 3164
        def vi_to_next_char(key, arg: 1, inclusive: false)
  @waiting_proc = -&gt;(key_for_proc) { search_next_char(key_for_proc, arg, need_prev_char: true, inclusive: inclusive) }
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-vi_to_prev_char"> <span class="method-name">vi_to_prev_char</span><span class="method-args">(key, arg: 1)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="vi_to_prev_char-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 3221
        def vi_to_prev_char(key, arg: 1)
  @waiting_proc = -&gt;(key_for_proc) { search_prev_char(key_for_proc, arg, true) }
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-vi_yank"> <span class="method-name">vi_yank</span><span class="method-args">(key, arg: 1)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="vi_yank-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 2984
        def vi_yank(key, arg: 1)
  @waiting_operator_proc = proc { |cursor_diff, byte_pointer_diff|
    if byte_pointer_diff &gt; 0
      cut = @line.byteslice(@byte_pointer, byte_pointer_diff)
    elsif byte_pointer_diff &lt; 0
      cut = @line.byteslice(@byte_pointer + byte_pointer_diff, -byte_pointer_diff)
    end
    copy_for_vi(cut)
  }
  @waiting_operator_vi_arg = arg
end</pre> </div>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-vi_zero"> <span class="method-name">vi_zero</span><span class="method-args">(key)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="vi_zero-source"> <pre class="ruby" data-language="ruby"># File lib/reline/line_editor.rb, line 2946
        def vi_zero(key)
  @byte_pointer = 0
  @cursor = 0
end</pre> </div>  </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core &copy; 1993&ndash;2022 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library &copy; contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>
