<h1 id="class-Proc" class="class"> class Proc </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent"><a href="object.html">Object</a></dd>
</dl> <section class="description"> <p>A <code>Proc</code> object is an encapsulation of a block of code, which can be stored in a local variable, passed to a method or another <a href="proc.html"><code>Proc</code></a>, and can be called. <a href="proc.html"><code>Proc</code></a> is an essential concept in Ruby and a core of its functional programming features.</p> <pre class="ruby" data-language="ruby">square = Proc.new {|x| x**2 }

square.call(3)  #=&gt; 9
# shorthands:
square.(3)      #=&gt; 9
square[3]       #=&gt; 9
</pre> <p><a href="proc.html"><code>Proc</code></a> objects are <em>closures</em>, meaning they remember and can use the entire context in which they were created.</p> <pre class="ruby" data-language="ruby">def gen_times(factor)
  Proc.new {|n| n*factor } # remembers the value of factor at the moment of creation
end

times3 = gen_times(3)
times5 = gen_times(5)

times3.call(12)               #=&gt; 36
times5.call(5)                #=&gt; 25
times3.call(times5.call(4))   #=&gt; 60
</pre> <h2 id="class-Proc-label-Creation">Creation</h2> <p>There are several methods to create a <a href="proc.html"><code>Proc</code></a></p> <ul>
<li> <p>Use the <a href="proc.html"><code>Proc</code></a> class constructor:</p> <pre class="ruby" data-language="ruby">proc1 = Proc.new {|x| x**2 }
</pre> </li>
<li> <p>Use the <a href="kernel.html#method-i-proc"><code>Kernel#proc</code></a> method as a shorthand of <a href="proc.html#method-c-new"><code>Proc.new</code></a>:</p> <pre class="ruby" data-language="ruby">proc2 = proc {|x| x**2 }
</pre> </li>
<li> <p>Receiving a block of code into proc argument (note the <code>&amp;</code>):</p> <pre class="ruby" data-language="ruby">def make_proc(&amp;block)
  block
end

proc3 = make_proc {|x| x**2 }
</pre> </li>
<li> <p>Construct a proc with lambda semantics using the <a href="kernel.html#method-i-lambda"><code>Kernel#lambda</code></a> method (see below for explanations about lambdas):</p> <pre class="ruby" data-language="ruby">lambda1 = lambda {|x| x**2 }
</pre> </li>
<li> <p>Use the <a href="syntax/literals_rdoc.html#label-Lambda+Proc+Literals">Lambda proc literal</a> syntax (also constructs a proc with lambda semantics):</p> <pre class="ruby" data-language="ruby">lambda2 = -&gt;(x) { x**2 }
</pre> </li>
</ul> <h2 id="class-Proc-label-Lambda+and+non-lambda+semantics">Lambda and non-lambda semantics</h2> <p>Procs are coming in two flavors: lambda and non-lambda (regular procs). Differences are:</p> <ul>
<li> <p>In lambdas, <code>return</code> and <code>break</code> means exit from this lambda;</p> </li>
<li> <p>In non-lambda procs, <code>return</code> means exit from embracing method (and will throw <code>LocalJumpError</code> if invoked outside the method);</p> </li>
<li> <p>In non-lambda procs, <code>break</code> means exit from the method which the block given for. (and will throw <code>LocalJumpError</code> if invoked after the method returns);</p> </li>
<li> <p>In lambdas, arguments are treated in the same way as in methods: strict, with <code>ArgumentError</code> for mismatching argument number, and no additional argument processing;</p> </li>
<li> <p>Regular procs accept arguments more generously: missing arguments are filled with <code>nil</code>, single <a href="array.html"><code>Array</code></a> arguments are deconstructed if the proc has multiple arguments, and there is no error raised on extra arguments.</p> </li>
</ul> <p>Examples:</p> <pre class="ruby" data-language="ruby"># +return+ in non-lambda proc, +b+, exits +m2+.
# (The block +{ return }+ is given for +m1+ and embraced by +m2+.)
$a = []; def m1(&amp;b) b.call; $a &lt;&lt; :m1 end; def m2() m1 { return }; $a &lt;&lt; :m2 end; m2; p $a
#=&gt; []

# +break+ in non-lambda proc, +b+, exits +m1+.
# (The block +{ break }+ is given for +m1+ and embraced by +m2+.)
$a = []; def m1(&amp;b) b.call; $a &lt;&lt; :m1 end; def m2() m1 { break }; $a &lt;&lt; :m2 end; m2; p $a
#=&gt; [:m2]

# +next+ in non-lambda proc, +b+, exits the block.
# (The block +{ next }+ is given for +m1+ and embraced by +m2+.)
$a = []; def m1(&amp;b) b.call; $a &lt;&lt; :m1 end; def m2() m1 { next }; $a &lt;&lt; :m2 end; m2; p $a
#=&gt; [:m1, :m2]

# Using +proc+ method changes the behavior as follows because
# The block is given for +proc+ method and embraced by +m2+.
$a = []; def m1(&amp;b) b.call; $a &lt;&lt; :m1 end; def m2() m1(&amp;proc { return }); $a &lt;&lt; :m2 end; m2; p $a
#=&gt; []
$a = []; def m1(&amp;b) b.call; $a &lt;&lt; :m1 end; def m2() m1(&amp;proc { break }); $a &lt;&lt; :m2 end; m2; p $a
# break from proc-closure (LocalJumpError)
$a = []; def m1(&amp;b) b.call; $a &lt;&lt; :m1 end; def m2() m1(&amp;proc { next }); $a &lt;&lt; :m2 end; m2; p $a
#=&gt; [:m1, :m2]

# +return+, +break+ and +next+ in the stubby lambda exits the block.
# (+lambda+ method behaves same.)
# (The block is given for stubby lambda syntax and embraced by +m2+.)
$a = []; def m1(&amp;b) b.call; $a &lt;&lt; :m1 end; def m2() m1(&amp;-&gt; { return }); $a &lt;&lt; :m2 end; m2; p $a
#=&gt; [:m1, :m2]
$a = []; def m1(&amp;b) b.call; $a &lt;&lt; :m1 end; def m2() m1(&amp;-&gt; { break }); $a &lt;&lt; :m2 end; m2; p $a
#=&gt; [:m1, :m2]
$a = []; def m1(&amp;b) b.call; $a &lt;&lt; :m1 end; def m2() m1(&amp;-&gt; { next }); $a &lt;&lt; :m2 end; m2; p $a
#=&gt; [:m1, :m2]

p = proc {|x, y| "x=#{x}, y=#{y}" }
p.call(1, 2)      #=&gt; "x=1, y=2"
p.call([1, 2])    #=&gt; "x=1, y=2", array deconstructed
p.call(1, 2, 8)   #=&gt; "x=1, y=2", extra argument discarded
p.call(1)         #=&gt; "x=1, y=", nil substituted instead of error

l = lambda {|x, y| "x=#{x}, y=#{y}" }
l.call(1, 2)      #=&gt; "x=1, y=2"
l.call([1, 2])    # ArgumentError: wrong number of arguments (given 1, expected 2)
l.call(1, 2, 8)   # ArgumentError: wrong number of arguments (given 3, expected 2)
l.call(1)         # ArgumentError: wrong number of arguments (given 1, expected 2)

def test_return
  -&gt; { return 3 }.call      # just returns from lambda into method body
  proc { return 4 }.call    # returns from method
  return 5
end

test_return # =&gt; 4, return from proc
</pre> <p>Lambdas are useful as self-sufficient functions, in particular useful as arguments to higher-order functions, behaving exactly like Ruby methods.</p> <p>Procs are useful for implementing iterators:</p> <pre class="ruby" data-language="ruby">def test
  [[1, 2], [3, 4], [5, 6]].map {|a, b| return a if a + b &gt; 10 }
                            #  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
end
</pre> <p>Inside <code>map</code>, the block of code is treated as a regular (non-lambda) proc, which means that the internal arrays will be deconstructed to pairs of arguments, and <code>return</code> will exit from the method <code>test</code>. That would not be possible with a stricter lambda.</p> <p>You can tell a lambda from a regular proc by using the <a href="proc.html#method-i-lambda-3F"><code>lambda?</code></a> instance method.</p> <p>Lambda semantics is typically preserved during the proc lifetime, including <code>&amp;</code>-deconstruction to a block of code:</p> <pre class="ruby" data-language="ruby">p = proc {|x, y| x }
l = lambda {|x, y| x }
[[1, 2], [3, 4]].map(&amp;p) #=&gt; [1, 3]
[[1, 2], [3, 4]].map(&amp;l) # ArgumentError: wrong number of arguments (given 1, expected 2)
</pre> <p>The only exception is dynamic method definition: even if defined by passing a non-lambda proc, methods still have normal semantics of argument checking.</p> <pre class="ruby" data-language="ruby">class C
  define_method(:e, &amp;proc {})
end
C.new.e(1,2)       #=&gt; ArgumentError
C.new.method(:e).to_proc.lambda?   #=&gt; true
</pre> <p>This exception ensures that methods never have unusual argument passing conventions, and makes it easy to have wrappers defining methods that behave as usual.</p> <pre class="ruby" data-language="ruby">class C
  def self.def2(name, &amp;body)
    define_method(name, &amp;body)
  end

  def2(:f) {}
end
C.new.f(1,2)       #=&gt; ArgumentError
</pre> <p>The wrapper <code>def2</code> receives <em>body</em> as a non-lambda proc, yet defines a method which has normal semantics.</p> <h2 id="class-Proc-label-Conversion+of+other+objects+to+procs">Conversion of other objects to procs</h2> <p>Any object that implements the <code>to_proc</code> method can be converted into a proc by the <code>&amp;</code> operator, and therefore can be consumed by iterators.</p> <pre class="ruby" data-language="ruby">class Greeter
  def initialize(greeting)
    @greeting = greeting
  end

  def to_proc
    proc {|name| "#{@greeting}, #{name}!" }
  end
end

hi = Greeter.new("Hi")
hey = Greeter.new("Hey")
["Bob", "Jane"].map(&amp;hi)    #=&gt; ["Hi, Bob!", "Hi, Jane!"]
["Bob", "Jane"].map(&amp;hey)   #=&gt; ["Hey, Bob!", "Hey, Jane!"]
</pre> <p>Of the Ruby core classes, this method is implemented by <a href="symbol.html"><code>Symbol</code></a>, <a href="method.html"><code>Method</code></a>, and <a href="hash.html"><code>Hash</code></a>.</p> <pre class="ruby" data-language="ruby">:to_s.to_proc.call(1)           #=&gt; "1"
[1, 2].map(&amp;:to_s)              #=&gt; ["1", "2"]

method(:puts).to_proc.call(1)   # prints 1
[1, 2].each(&amp;method(:puts))     # prints 1, 2

{test: 1}.to_proc.call(:test)       #=&gt; 1
%i[test many keys].map(&amp;{test: 1})  #=&gt; [1, nil, nil]
</pre> <h2 id="class-Proc-label-Orphaned+Proc">Orphaned <a href="proc.html"><code>Proc</code></a>
</h2> <p><code>return</code> and <code>break</code> in a block exit a method. If a <a href="proc.html"><code>Proc</code></a> object is generated from the block and the <a href="proc.html"><code>Proc</code></a> object survives until the method is returned, <code>return</code> and <code>break</code> cannot work. In such case, <code>return</code> and <code>break</code> raises <a href="localjumperror.html"><code>LocalJumpError</code></a>. A <a href="proc.html"><code>Proc</code></a> object in such situation is called as orphaned <a href="proc.html"><code>Proc</code></a> object.</p> <p>Note that the method to exit is different for <code>return</code> and <code>break</code>. There is a situation that orphaned for <code>break</code> but not orphaned for <code>return</code>.</p> <pre class="ruby" data-language="ruby">def m1(&amp;b) b.call end; def m2(); m1 { return } end; m2 # ok
def m1(&amp;b) b.call end; def m2(); m1 { break } end; m2 # ok

def m1(&amp;b) b end; def m2(); m1 { return }.call end; m2 # ok
def m1(&amp;b) b end; def m2(); m1 { break }.call end; m2 # LocalJumpError

def m1(&amp;b) b end; def m2(); m1 { return } end; m2.call # LocalJumpError
def m1(&amp;b) b end; def m2(); m1 { break } end; m2.call # LocalJumpError
</pre> <p>Since <code>return</code> and <code>break</code> exits the block itself in lambdas, lambdas cannot be orphaned.</p> <h2 id="class-Proc-label-Numbered+parameters">Numbered parameters</h2> <p>Numbered parameters are implicitly defined block parameters intended to simplify writing short blocks:</p> <pre class="ruby" data-language="ruby"># Explicit parameter:
%w[test me please].each { |str| puts str.upcase } # prints TEST, ME, PLEASE
(1..5).map { |i| i**2 } # =&gt; [1, 4, 9, 16, 25]

# Implicit parameter:
%w[test me please].each { puts _1.upcase } # prints TEST, ME, PLEASE
(1..5).map { _1**2 } # =&gt; [1, 4, 9, 16, 25]
</pre> <p>Parameter names from <code>_1</code> to <code>_9</code> are supported:</p> <pre class="ruby" data-language="ruby">[10, 20, 30].zip([40, 50, 60], [70, 80, 90]).map { _1 + _2 + _3 }
# =&gt; [120, 150, 180]
</pre> <p>Though, it is advised to resort to them wisely, probably limiting yourself to <code>_1</code> and <code>_2</code>, and to one-line blocks.</p> <p>Numbered parameters can’t be used together with explicitly named ones:</p> <pre>[10, 20, 30].map { |x| _1**2 }
# SyntaxError (ordinary parameter is defined)</pre> <p>To avoid conflicts, naming local variables or method arguments <code>_1</code>, <code>_2</code> and so on, causes a warning.</p> <pre>_1 = 'test'
# warning: `_1' is reserved as numbered parameter</pre> <p>Using implicit numbered parameters affects block’s arity:</p> <pre class="ruby" data-language="ruby">p = proc { _1 + _2 }
l = lambda { _1 + _2 }
p.parameters     # =&gt; [[:opt, :_1], [:opt, :_2]]
p.arity          # =&gt; 2
l.parameters     # =&gt; [[:req, :_1], [:req, :_2]]
l.arity          # =&gt; 2
</pre> <p>Blocks with numbered parameters can’t be nested:</p> <pre>%w[test me].each { _1.each_char { p _1 } }
# SyntaxError (numbered parameter is already used in outer block here)
# %w[test me].each { _1.each_char { p _1 } }
#                    ^~</pre> <p>Numbered parameters were introduced in Ruby 2.7.</p> </section> <section id="5Buntitled-5D" class="documentation-section"> <section id="public-class-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-new"> <span class="method-callseq"> new {|...| block } → a_proc </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="new-source"> <pre class="c" data-language="c">static VALUE
rb_proc_s_new(int argc, VALUE *argv, VALUE klass)
{
    VALUE block = proc_new(klass, FALSE);

    rb_obj_call_init_kw(block, argc, argv, RB_PASS_CALLED_KEYWORDS);
    return block;
}</pre> </div> <p>Creates a new <a href="proc.html"><code>Proc</code></a> object, bound to the current context.</p> <pre class="ruby" data-language="ruby">proc = Proc.new { "hello" }
proc.call   #=&gt; "hello"
</pre> <p>Raises <a href="argumenterror.html"><code>ArgumentError</code></a> if called without a block.</p> <pre class="ruby" data-language="ruby">Proc.new    #=&gt; ArgumentError
</pre>  </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-3C-3C"> <span class="method-callseq"> prc &lt;&lt; g → a_proc </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="3C-3C-source"> <pre class="c" data-language="c">static VALUE
proc_compose_to_left(VALUE self, VALUE g)
{
    return rb_proc_compose_to_left(self, to_callable(g));
}</pre> </div> <p>Returns a proc that is the composition of this proc and the given <em>g</em>. The returned proc takes a variable number of arguments, calls <em>g</em> with them then calls this proc with the result.</p> <pre class="ruby" data-language="ruby">f = proc {|x| x * x }
g = proc {|x| x + x }
p (f &lt;&lt; g).call(2) #=&gt; 16
</pre> <p>See <a href="proc.html#method-i-3E-3E"><code>Proc#&gt;&gt;</code></a> for detailed explanations.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-3D-3D"> <span class="method-callseq"> prc == other → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="3D-3D-source"> <pre class="c" data-language="c">static VALUE
proc_eq(VALUE self, VALUE other)
{
    const rb_proc_t *self_proc, *other_proc;
    const struct rb_block *self_block, *other_block;

    if (rb_obj_class(self) !=  rb_obj_class(other)) {
        return Qfalse;
    }

    GetProcPtr(self, self_proc);
    GetProcPtr(other, other_proc);

    if (self_proc-&gt;is_from_method != other_proc-&gt;is_from_method ||
            self_proc-&gt;is_lambda != other_proc-&gt;is_lambda) {
        return Qfalse;
    }

    self_block = &amp;self_proc-&gt;block;
    other_block = &amp;other_proc-&gt;block;

    if (vm_block_type(self_block) != vm_block_type(other_block)) {
        return Qfalse;
    }

    switch (vm_block_type(self_block)) {
      case block_type_iseq:
        if (self_block-&gt;as.captured.ep != \
                other_block-&gt;as.captured.ep ||
                self_block-&gt;as.captured.code.iseq != \
                other_block-&gt;as.captured.code.iseq) {
            return Qfalse;
        }
        break;
      case block_type_ifunc:
        if (self_block-&gt;as.captured.ep != \
                other_block-&gt;as.captured.ep ||
                self_block-&gt;as.captured.code.ifunc != \
                other_block-&gt;as.captured.code.ifunc) {
            return Qfalse;
        }
        break;
      case block_type_proc:
        if (self_block-&gt;as.proc != other_block-&gt;as.proc) {
            return Qfalse;
        }
        break;
      case block_type_symbol:
        if (self_block-&gt;as.symbol != other_block-&gt;as.symbol) {
            return Qfalse;
        }
        break;
    }

    return Qtrue;
}</pre> </div> <p>Two procs are the same if, and only if, they were created from the same code block.</p> <pre class="ruby" data-language="ruby">def return_block(&amp;block)
  block
end

def pass_block_twice(&amp;block)
  [return_block(&amp;block), return_block(&amp;block)]
end

block1, block2 = pass_block_twice { puts 'test' }
# Blocks might be instantiated into Proc's lazily, so they may, or may not,
# be the same object.
# But they are produced from the same code block, so they are equal
block1 == block2
#=&gt; true

# Another Proc will never be equal, even if the code is the "same"
block1 == proc { puts 'test' }
#=&gt; false
</pre>  </div> <div class="aliases"> Also aliased as: <a href="proc.html#method-i-eql-3F">eql?</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-3D-3D-3D"> <span class="method-callseq"> (params,...) → obj </span> </div> </div> <div class="method-description"> <p>Invokes the block, setting the block’s parameters to the values in <em>params</em> using something close to method calling semantics. Returns the value of the last expression evaluated in the block.</p> <pre class="ruby" data-language="ruby">a_proc = Proc.new {|scalar, *values| values.map {|value| value*scalar } }
a_proc.call(9, 1, 2, 3)    #=&gt; [9, 18, 27]
a_proc[9, 1, 2, 3]         #=&gt; [9, 18, 27]
a_proc.(9, 1, 2, 3)        #=&gt; [9, 18, 27]
a_proc.yield(9, 1, 2, 3)   #=&gt; [9, 18, 27]
</pre> <p>Note that <code>prc.()</code> invokes <code>prc.call()</code> with the parameters given. It’s syntactic sugar to hide “call”.</p> <p>For procs created using <a href="kernel.html#method-i-lambda"><code>lambda</code></a> or <code>-&gt;()</code> an error is generated if the wrong number of parameters are passed to the proc. For procs created using <a href="proc.html#method-c-new"><code>Proc.new</code></a> or <a href="kernel.html#method-i-proc"><code>Kernel.proc</code></a>, extra parameters are silently discarded and missing parameters are set to <code>nil</code>.</p> <pre class="ruby" data-language="ruby">a_proc = proc {|a,b| [a,b] }
a_proc.call(1)   #=&gt; [1, nil]

a_proc = lambda {|a,b| [a,b] }
a_proc.call(1)   # ArgumentError: wrong number of arguments (given 1, expected 2)
</pre> <p>See also <a href="proc.html#method-i-lambda-3F"><code>Proc#lambda?</code></a>.</p> </div> <div class="aliases"> Alias for: <a href="proc.html#method-i-call">call</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-3E-3E"> <span class="method-callseq"> prc &gt;&gt; g → a_proc </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="3E-3E-source"> <pre class="c" data-language="c">static VALUE
proc_compose_to_right(VALUE self, VALUE g)
{
    return rb_proc_compose_to_right(self, to_callable(g));
}</pre> </div> <p>Returns a proc that is the composition of this proc and the given <em>g</em>. The returned proc takes a variable number of arguments, calls this proc with them then calls <em>g</em> with the result.</p> <pre class="ruby" data-language="ruby">f = proc {|x| x * x }
g = proc {|x| x + x }
p (f &gt;&gt; g).call(2) #=&gt; 8
</pre> <p><em>g</em> could be other <a href="proc.html"><code>Proc</code></a>, or <a href="method.html"><code>Method</code></a>, or any other object responding to <code>call</code> method:</p> <pre class="ruby" data-language="ruby">class Parser
  def self.call(text)
     # ...some complicated parsing logic...
  end
end

pipeline = File.method(:read) &gt;&gt; Parser &gt;&gt; proc { |data| puts "data size: #{data.count}" }
pipeline.call('data.json')
</pre> <p>See also <a href="method.html#method-i-3E-3E"><code>Method#&gt;&gt;</code></a> and <a href="method.html#method-i-3C-3C"><code>Method#&lt;&lt;</code></a>.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-5B-5D"> <span class="method-callseq"> (params,...) → obj </span> </div> </div> <div class="method-description"> <p>Invokes the block, setting the block’s parameters to the values in <em>params</em> using something close to method calling semantics. Returns the value of the last expression evaluated in the block.</p> <pre class="ruby" data-language="ruby">a_proc = Proc.new {|scalar, *values| values.map {|value| value*scalar } }
a_proc.call(9, 1, 2, 3)    #=&gt; [9, 18, 27]
a_proc[9, 1, 2, 3]         #=&gt; [9, 18, 27]
a_proc.(9, 1, 2, 3)        #=&gt; [9, 18, 27]
a_proc.yield(9, 1, 2, 3)   #=&gt; [9, 18, 27]
</pre> <p>Note that <code>prc.()</code> invokes <code>prc.call()</code> with the parameters given. It’s syntactic sugar to hide “call”.</p> <p>For procs created using <a href="kernel.html#method-i-lambda"><code>lambda</code></a> or <code>-&gt;()</code> an error is generated if the wrong number of parameters are passed to the proc. For procs created using <a href="proc.html#method-c-new"><code>Proc.new</code></a> or <a href="kernel.html#method-i-proc"><code>Kernel.proc</code></a>, extra parameters are silently discarded and missing parameters are set to <code>nil</code>.</p> <pre class="ruby" data-language="ruby">a_proc = proc {|a,b| [a,b] }
a_proc.call(1)   #=&gt; [1, nil]

a_proc = lambda {|a,b| [a,b] }
a_proc.call(1)   # ArgumentError: wrong number of arguments (given 1, expected 2)
</pre> <p>See also <a href="proc.html#method-i-lambda-3F"><code>Proc#lambda?</code></a>.</p> </div> <div class="aliases"> Alias for: <a href="proc.html#method-i-call">call</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-arity"> <span class="method-callseq"> arity → integer </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="arity-source"> <pre class="c" data-language="c">static VALUE
proc_arity(VALUE self)
{
    int arity = rb_proc_arity(self);
    return INT2FIX(arity);
}</pre> </div> <p>Returns the number of mandatory arguments. If the block is declared to take no arguments, returns 0. If the block is known to take exactly n arguments, returns n. If the block has optional arguments, returns -n-1, where n is the number of mandatory arguments, with the exception for blocks that are not lambdas and have only a finite number of optional arguments; in this latter case, returns n. Keyword arguments will be considered as a single additional argument, that argument being mandatory if any keyword argument is mandatory. A <a href="kernel.html#method-i-proc"><code>proc</code></a> with no argument declarations is the same as a block declaring <code>||</code> as its arguments.</p> <pre class="ruby" data-language="ruby">proc {}.arity                  #=&gt;  0
proc { || }.arity              #=&gt;  0
proc { |a| }.arity             #=&gt;  1
proc { |a, b| }.arity          #=&gt;  2
proc { |a, b, c| }.arity       #=&gt;  3
proc { |*a| }.arity            #=&gt; -1
proc { |a, *b| }.arity         #=&gt; -2
proc { |a, *b, c| }.arity      #=&gt; -3
proc { |x:, y:, z:0| }.arity   #=&gt;  1
proc { |*a, x:, y:0| }.arity   #=&gt; -2

proc   { |a=0| }.arity         #=&gt;  0
lambda { |a=0| }.arity         #=&gt; -1
proc   { |a=0, b| }.arity      #=&gt;  1
lambda { |a=0, b| }.arity      #=&gt; -2
proc   { |a=0, b=0| }.arity    #=&gt;  0
lambda { |a=0, b=0| }.arity    #=&gt; -1
proc   { |a, b=0| }.arity      #=&gt;  1
lambda { |a, b=0| }.arity      #=&gt; -2
proc   { |(a, b), c=0| }.arity #=&gt;  1
lambda { |(a, b), c=0| }.arity #=&gt; -2
proc   { |a, x:0, y:0| }.arity #=&gt;  1
lambda { |a, x:0, y:0| }.arity #=&gt; -2
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-binding"> <span class="method-callseq"> binding → binding </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="binding-source"> <pre class="c" data-language="c">static VALUE
proc_binding(VALUE self)
{
    VALUE bindval, binding_self = Qundef;
    rb_binding_t *bind;
    const rb_proc_t *proc;
    const rb_iseq_t *iseq = NULL;
    const struct rb_block *block;
    const rb_env_t *env = NULL;

    GetProcPtr(self, proc);
    block = &amp;proc-&gt;block;

    if (proc-&gt;is_isolated) rb_raise(rb_eArgError, "Can't create Binding from isolated Proc");

  again:
    switch (vm_block_type(block)) {
      case block_type_iseq:
        iseq = block-&gt;as.captured.code.iseq;
        binding_self = block-&gt;as.captured.self;
        env = VM_ENV_ENVVAL_PTR(block-&gt;as.captured.ep);
        break;
      case block_type_proc:
        GetProcPtr(block-&gt;as.proc, proc);
        block = &amp;proc-&gt;block;
        goto again;
      case block_type_ifunc:
        {
            const struct vm_ifunc *ifunc = block-&gt;as.captured.code.ifunc;
            if (IS_METHOD_PROC_IFUNC(ifunc)) {
                VALUE method = (VALUE)ifunc-&gt;data;
                VALUE name = rb_fstring_lit("&lt;empty_iseq&gt;");
                rb_iseq_t *empty;
                binding_self = method_receiver(method);
                iseq = rb_method_iseq(method);
                env = VM_ENV_ENVVAL_PTR(block-&gt;as.captured.ep);
                env = env_clone(env, method_cref(method));
                /* set empty iseq */
                empty = rb_iseq_new(NULL, name, name, Qnil, 0, ISEQ_TYPE_TOP);
                RB_OBJ_WRITE(env, &amp;env-&gt;iseq, empty);
                break;
            }
        }
        /* FALLTHROUGH */
      case block_type_symbol:
        rb_raise(rb_eArgError, "Can't create Binding from C level Proc");
        UNREACHABLE_RETURN(Qnil);
    }

    bindval = rb_binding_alloc(rb_cBinding);
    GetBindingPtr(bindval, bind);
    RB_OBJ_WRITE(bindval, &amp;bind-&gt;block.as.captured.self, binding_self);
    RB_OBJ_WRITE(bindval, &amp;bind-&gt;block.as.captured.code.iseq, env-&gt;iseq);
    rb_vm_block_ep_update(bindval, &amp;bind-&gt;block, env-&gt;ep);
    RB_OBJ_WRITTEN(bindval, Qundef, VM_ENV_ENVVAL(env-&gt;ep));

    if (iseq) {
        rb_iseq_check(iseq);
        RB_OBJ_WRITE(bindval, &amp;bind-&gt;pathobj, ISEQ_BODY(iseq)-&gt;location.pathobj);
        bind-&gt;first_lineno = ISEQ_BODY(iseq)-&gt;location.first_lineno;
    }
    else {
        RB_OBJ_WRITE(bindval, &amp;bind-&gt;pathobj,
                     rb_iseq_pathobj_new(rb_fstring_lit("(binding)"), Qnil));
        bind-&gt;first_lineno = 1;
    }

    return bindval;
}</pre> </div> <p>Returns the binding associated with <em>prc</em>.</p> <pre class="ruby" data-language="ruby">def fred(param)
  proc {}
end

b = fred(99)
eval("param", b.binding)   #=&gt; 99
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-call"> <span class="method-callseq"> call(params,...) → obj </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> (params,...) → obj </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="call-source"> <pre class="c" data-language="c">0
static VALUE
proc_call(int argc, VALUE *argv, VALUE procval)
{
    /* removed */
}</pre> </div> <p>Invokes the block, setting the block’s parameters to the values in <em>params</em> using something close to method calling semantics. Returns the value of the last expression evaluated in the block.</p> <pre class="ruby" data-language="ruby">a_proc = Proc.new {|scalar, *values| values.map {|value| value*scalar } }
a_proc.call(9, 1, 2, 3)    #=&gt; [9, 18, 27]
a_proc[9, 1, 2, 3]         #=&gt; [9, 18, 27]
a_proc.(9, 1, 2, 3)        #=&gt; [9, 18, 27]
a_proc.yield(9, 1, 2, 3)   #=&gt; [9, 18, 27]
</pre> <p>Note that <code>prc.()</code> invokes <code>prc.call()</code> with the parameters given. It’s syntactic sugar to hide “call”.</p> <p>For procs created using <a href="kernel.html#method-i-lambda"><code>lambda</code></a> or <code>-&gt;()</code> an error is generated if the wrong number of parameters are passed to the proc. For procs created using <a href="proc.html#method-c-new"><code>Proc.new</code></a> or <a href="kernel.html#method-i-proc"><code>Kernel.proc</code></a>, extra parameters are silently discarded and missing parameters are set to <code>nil</code>.</p> <pre class="ruby" data-language="ruby">a_proc = proc {|a,b| [a,b] }
a_proc.call(1)   #=&gt; [1, nil]

a_proc = lambda {|a,b| [a,b] }
a_proc.call(1)   # ArgumentError: wrong number of arguments (given 1, expected 2)
</pre> <p>See also <a href="proc.html#method-i-lambda-3F"><code>Proc#lambda?</code></a>.</p>  </div> <div class="aliases"> Also aliased as: <a href="proc.html#method-i-5B-5D">[]</a>, <a href="proc.html#method-i-3D-3D-3D">===</a>, <a href="proc.html#method-i-yield">yield</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-curry"> <span class="method-callseq"> curry → a_proc </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> curry(arity) → a_proc </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="curry-source"> <pre class="c" data-language="c">static VALUE
proc_curry(int argc, const VALUE *argv, VALUE self)
{
    int sarity, max_arity, min_arity = rb_proc_min_max_arity(self, &amp;max_arity);
    VALUE arity;

    if (rb_check_arity(argc, 0, 1) == 0 || NIL_P(arity = argv[0])) {
        arity = INT2FIX(min_arity);
    }
    else {
        sarity = FIX2INT(arity);
        if (rb_proc_lambda_p(self)) {
            rb_check_arity(sarity, min_arity, max_arity);
        }
    }

    return make_curry_proc(self, rb_ary_new(), arity);
}</pre> </div> <p>Returns a curried proc. If the optional <em>arity</em> argument is given, it determines the number of arguments. A curried proc receives some arguments. If a sufficient number of arguments are supplied, it passes the supplied arguments to the original proc and returns the result. Otherwise, returns another curried proc that takes the rest of arguments.</p> <p>The optional <em>arity</em> argument should be supplied when currying procs with variable arguments to determine how many arguments are needed before the proc is called.</p> <pre class="ruby" data-language="ruby">b = proc {|x, y, z| (x||0) + (y||0) + (z||0) }
p b.curry[1][2][3]           #=&gt; 6
p b.curry[1, 2][3, 4]        #=&gt; 6
p b.curry(5)[1][2][3][4][5]  #=&gt; 6
p b.curry(5)[1, 2][3, 4][5]  #=&gt; 6
p b.curry(1)[1]              #=&gt; 1

b = proc {|x, y, z, *w| (x||0) + (y||0) + (z||0) + w.inject(0, &amp;:+) }
p b.curry[1][2][3]           #=&gt; 6
p b.curry[1, 2][3, 4]        #=&gt; 10
p b.curry(5)[1][2][3][4][5]  #=&gt; 15
p b.curry(5)[1, 2][3, 4][5]  #=&gt; 15
p b.curry(1)[1]              #=&gt; 1

b = lambda {|x, y, z| (x||0) + (y||0) + (z||0) }
p b.curry[1][2][3]           #=&gt; 6
p b.curry[1, 2][3, 4]        #=&gt; wrong number of arguments (given 4, expected 3)
p b.curry(5)                 #=&gt; wrong number of arguments (given 5, expected 3)
p b.curry(1)                 #=&gt; wrong number of arguments (given 1, expected 3)

b = lambda {|x, y, z, *w| (x||0) + (y||0) + (z||0) + w.inject(0, &amp;:+) }
p b.curry[1][2][3]           #=&gt; 6
p b.curry[1, 2][3, 4]        #=&gt; 10
p b.curry(5)[1][2][3][4][5]  #=&gt; 15
p b.curry(5)[1, 2][3, 4][5]  #=&gt; 15
p b.curry(1)                 #=&gt; wrong number of arguments (given 1, expected 3)

b = proc { :foo }
p b.curry[]                  #=&gt; :foo
</pre>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-eql-3F"> <span class="method-callseq"> eql?(other) → true or false </span> </div> </div> <div class="method-description"> <p>Two procs are the same if, and only if, they were created from the same code block.</p> <pre class="ruby" data-language="ruby">def return_block(&amp;block)
  block
end

def pass_block_twice(&amp;block)
  [return_block(&amp;block), return_block(&amp;block)]
end

block1, block2 = pass_block_twice { puts 'test' }
# Blocks might be instantiated into Proc's lazily, so they may, or may not,
# be the same object.
# But they are produced from the same code block, so they are equal
block1 == block2
#=&gt; true

# Another Proc will never be equal, even if the code is the "same"
block1 == proc { puts 'test' }
#=&gt; false
</pre> </div> <div class="aliases"> Alias for: <a href="proc.html#method-i-3D-3D">==</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-hash"> <span class="method-callseq"> hash → integer </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="hash-source"> <pre class="c" data-language="c">static VALUE
proc_hash(VALUE self)
{
    st_index_t hash;
    hash = rb_hash_start(0);
    hash = rb_hash_proc(hash, self);
    hash = rb_hash_end(hash);
    return ST2FIX(hash);
}</pre> </div> <p>Returns a hash value corresponding to proc body.</p> <p>See also <a href="object.html#method-i-hash"><code>Object#hash</code></a>.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-inspect"> <span class="method-name">inspect</span> </div> </div> <div class="aliases"> Alias for: <a href="proc.html#method-i-to_s">to_s</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-lambda-3F"> <span class="method-callseq"> lambda? → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="lambda-3F-source"> <pre class="c" data-language="c">VALUE
rb_proc_lambda_p(VALUE procval)
{
    rb_proc_t *proc;
    GetProcPtr(procval, proc);

    return RBOOL(proc-&gt;is_lambda);
}</pre> </div> <p>Returns <code>true</code> if a <a href="proc.html"><code>Proc</code></a> object is lambda. <code>false</code> if non-lambda.</p> <p>The lambda-ness affects argument handling and the behavior of <code>return</code> and <code>break</code>.</p> <p>A <a href="proc.html"><code>Proc</code></a> object generated by <code>proc</code> ignores extra arguments.</p> <pre class="ruby" data-language="ruby">proc {|a,b| [a,b] }.call(1,2,3)    #=&gt; [1,2]
</pre> <p>It provides <code>nil</code> for missing arguments.</p> <pre class="ruby" data-language="ruby">proc {|a,b| [a,b] }.call(1)        #=&gt; [1,nil]
</pre> <p>It expands a single array argument.</p> <pre class="ruby" data-language="ruby">proc {|a,b| [a,b] }.call([1,2])    #=&gt; [1,2]
</pre> <p>A <a href="proc.html"><code>Proc</code></a> object generated by <code>lambda</code> doesn’t have such tricks.</p> <pre class="ruby" data-language="ruby">lambda {|a,b| [a,b] }.call(1,2,3)  #=&gt; ArgumentError
lambda {|a,b| [a,b] }.call(1)      #=&gt; ArgumentError
lambda {|a,b| [a,b] }.call([1,2])  #=&gt; ArgumentError
</pre> <p><a href="proc.html#method-i-lambda-3F"><code>Proc#lambda?</code></a> is a predicate for the tricks. It returns <code>true</code> if no tricks apply.</p> <pre class="ruby" data-language="ruby">lambda {}.lambda?            #=&gt; true
proc {}.lambda?              #=&gt; false
</pre> <p><a href="proc.html#method-c-new"><code>Proc.new</code></a> is the same as <code>proc</code>.</p> <pre class="ruby" data-language="ruby">Proc.new {}.lambda?          #=&gt; false
</pre> <p><code>lambda</code>, <code>proc</code> and <a href="proc.html#method-c-new"><code>Proc.new</code></a> preserve the tricks of a <a href="proc.html"><code>Proc</code></a> object given by <code>&amp;</code> argument.</p> <pre class="ruby" data-language="ruby">lambda(&amp;lambda {}).lambda?   #=&gt; true
proc(&amp;lambda {}).lambda?     #=&gt; true
Proc.new(&amp;lambda {}).lambda? #=&gt; true

lambda(&amp;proc {}).lambda?     #=&gt; false
proc(&amp;proc {}).lambda?       #=&gt; false
Proc.new(&amp;proc {}).lambda?   #=&gt; false
</pre> <p>A <a href="proc.html"><code>Proc</code></a> object generated by <code>&amp;</code> argument has the tricks</p> <pre class="ruby" data-language="ruby">def n(&amp;b) b.lambda? end
n {}                         #=&gt; false
</pre> <p>The <code>&amp;</code> argument preserves the tricks if a <a href="proc.html"><code>Proc</code></a> object is given by <code>&amp;</code> argument.</p> <pre class="ruby" data-language="ruby">n(&amp;lambda {})                #=&gt; true
n(&amp;proc {})                  #=&gt; false
n(&amp;Proc.new {})              #=&gt; false
</pre> <p>A <a href="proc.html"><code>Proc</code></a> object converted from a method has no tricks.</p> <pre class="ruby" data-language="ruby">def m() end
method(:m).to_proc.lambda?   #=&gt; true

n(&amp;method(:m))               #=&gt; true
n(&amp;method(:m).to_proc)       #=&gt; true
</pre> <p><code>define_method</code> is treated the same as method definition. The defined method has no tricks.</p> <pre class="ruby" data-language="ruby">class C
  define_method(:d) {}
end
C.new.d(1,2)       #=&gt; ArgumentError
C.new.method(:d).to_proc.lambda?   #=&gt; true
</pre> <p><code>define_method</code> always defines a method without the tricks, even if a non-lambda <a href="proc.html"><code>Proc</code></a> object is given. This is the only exception for which the tricks are not preserved.</p> <pre class="ruby" data-language="ruby">class C
  define_method(:e, &amp;proc {})
end
C.new.e(1,2)       #=&gt; ArgumentError
C.new.method(:e).to_proc.lambda?   #=&gt; true
</pre> <p>This exception ensures that methods never have tricks and makes it easy to have wrappers to define methods that behave as usual.</p> <pre class="ruby" data-language="ruby">class C
  def self.def2(name, &amp;body)
    define_method(name, &amp;body)
  end

  def2(:f) {}
end
C.new.f(1,2)       #=&gt; ArgumentError
</pre> <p>The wrapper <em>def2</em> defines a method which has no tricks.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-parameters"> <span class="method-callseq"> parameters(lambda: nil) → array </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="parameters-source"> <pre class="c" data-language="c">static VALUE
rb_proc_parameters(int argc, VALUE *argv, VALUE self)
{
    static ID keyword_ids[1];
    VALUE opt, lambda;
    VALUE kwargs[1];
    int is_proc ;
    const rb_iseq_t *iseq;

    iseq = rb_proc_get_iseq(self, &amp;is_proc);

    if (!keyword_ids[0]) {
        CONST_ID(keyword_ids[0], "lambda");
    }

    rb_scan_args(argc, argv, "0:", &amp;opt);
    if (!NIL_P(opt)) {
        rb_get_kwargs(opt, keyword_ids, 0, 1, kwargs);
        lambda = kwargs[0];
        if (!NIL_P(lambda)) {
            is_proc = !RTEST(lambda);
        }
    }

    if (!iseq) {
        return rb_unnamed_parameters(rb_proc_arity(self));
    }
    return rb_iseq_parameters(iseq, is_proc);
}</pre> </div> <p>Returns the parameter information of this proc. If the lambda keyword is provided and not nil, treats the proc as a lambda if true and as a non-lambda if false.</p> <pre class="ruby" data-language="ruby">prc = proc{|x, y=42, *other|}
prc.parameters  #=&gt; [[:opt, :x], [:opt, :y], [:rest, :other]]
prc = lambda{|x, y=42, *other|}
prc.parameters  #=&gt; [[:req, :x], [:opt, :y], [:rest, :other]]
prc = proc{|x, y=42, *other|}
prc.parameters(lambda: true)  #=&gt; [[:req, :x], [:opt, :y], [:rest, :other]]
prc = lambda{|x, y=42, *other|}
prc.parameters(lambda: false) #=&gt; [[:opt, :x], [:opt, :y], [:rest, :other]]
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-ruby2_keywords"> <span class="method-callseq"> ruby2_keywords → proc </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="ruby2_keywords-source"> <pre class="c" data-language="c">static VALUE
proc_ruby2_keywords(VALUE procval)
{
    rb_proc_t *proc;
    GetProcPtr(procval, proc);

    rb_check_frozen(procval);

    if (proc-&gt;is_from_method) {
            rb_warn("Skipping set of ruby2_keywords flag for proc (proc created from method)");
            return procval;
    }

    switch (proc-&gt;block.type) {
      case block_type_iseq:
        if (ISEQ_BODY(proc-&gt;block.as.captured.code.iseq)-&gt;param.flags.has_rest &amp;&amp;
                !ISEQ_BODY(proc-&gt;block.as.captured.code.iseq)-&gt;param.flags.has_kw &amp;&amp;
                !ISEQ_BODY(proc-&gt;block.as.captured.code.iseq)-&gt;param.flags.has_kwrest) {
            ISEQ_BODY(proc-&gt;block.as.captured.code.iseq)-&gt;param.flags.ruby2_keywords = 1;
        }
        else {
            rb_warn("Skipping set of ruby2_keywords flag for proc (proc accepts keywords or proc does not accept argument splat)");
        }
        break;
      default:
        rb_warn("Skipping set of ruby2_keywords flag for proc (proc not defined in Ruby)");
        break;
    }

    return procval;
}</pre> </div> <p>Marks the proc as passing keywords through a normal argument splat. This should only be called on procs that accept an argument splat (<code>*args</code>) but not explicit keywords or a keyword splat. It marks the proc such that if the proc is called with keyword arguments, the final hash argument is marked with a special flag such that if it is the final element of a normal argument splat to another method call, and that method call does not include explicit keywords or a keyword splat, the final element is interpreted as keywords. In other words, keywords will be passed through the proc to other methods.</p> <p>This should only be used for procs that delegate keywords to another method, and only for backwards compatibility with Ruby versions before 2.7.</p> <p>This method will probably be removed at some point, as it exists only for backwards compatibility. As it does not exist in Ruby versions before 2.7, check that the proc responds to this method before calling it. Also, be aware that if this method is removed, the behavior of the proc will change so that it does not pass through keywords.</p> <pre class="ruby" data-language="ruby">module Mod
  foo = -&gt;(meth, *args, &amp;block) do
    send(:"do_#{meth}", *args, &amp;block)
  end
  foo.ruby2_keywords if foo.respond_to?(:ruby2_keywords)
end
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-source_location"> <span class="method-callseq"> source_location → [String, Integer] </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="source_location-source"> <pre class="c" data-language="c">VALUE
rb_proc_location(VALUE self)
{
    return iseq_location(rb_proc_get_iseq(self, 0));
}</pre> </div> <p>Returns the Ruby source filename and line number containing this proc or <code>nil</code> if this proc was not defined in Ruby (i.e. native).</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-to_proc"> <span class="method-callseq"> to_proc → proc </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="to_proc-source"> <pre class="c" data-language="c">static VALUE
proc_to_proc(VALUE self)
{
    return self;
}</pre> </div> <p>Part of the protocol for converting objects to <a href="proc.html"><code>Proc</code></a> objects. Instances of class <a href="proc.html"><code>Proc</code></a> simply return themselves.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-to_s"> <span class="method-callseq"> to_s → string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="to_s-source"> <pre class="c" data-language="c">static VALUE
proc_to_s(VALUE self)
{
    const rb_proc_t *proc;
    GetProcPtr(self, proc);
    return rb_block_to_s(self, &amp;proc-&gt;block, proc-&gt;is_lambda ? " (lambda)" : NULL);
}</pre> </div> <p>Returns the unique identifier for this proc, along with an indication of where the proc was defined.</p>  </div> <div class="aliases"> Also aliased as: <a href="proc.html#method-i-inspect">inspect</a> </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-yield"> <span class="method-callseq"> (params,...) → obj </span> </div> <div class="method-heading"> <span class="method-callseq"> yield(params,...) → obj </span> </div> </div> <div class="method-description"> <p>Invokes the block, setting the block’s parameters to the values in <em>params</em> using something close to method calling semantics. Returns the value of the last expression evaluated in the block.</p> <pre class="ruby" data-language="ruby">a_proc = Proc.new {|scalar, *values| values.map {|value| value*scalar } }
a_proc.call(9, 1, 2, 3)    #=&gt; [9, 18, 27]
a_proc[9, 1, 2, 3]         #=&gt; [9, 18, 27]
a_proc.(9, 1, 2, 3)        #=&gt; [9, 18, 27]
a_proc.yield(9, 1, 2, 3)   #=&gt; [9, 18, 27]
</pre> <p>Note that <code>prc.()</code> invokes <code>prc.call()</code> with the parameters given. It’s syntactic sugar to hide “call”.</p> <p>For procs created using <a href="kernel.html#method-i-lambda"><code>lambda</code></a> or <code>-&gt;()</code> an error is generated if the wrong number of parameters are passed to the proc. For procs created using <a href="proc.html#method-c-new"><code>Proc.new</code></a> or <a href="kernel.html#method-i-proc"><code>Kernel.proc</code></a>, extra parameters are silently discarded and missing parameters are set to <code>nil</code>.</p> <pre class="ruby" data-language="ruby">a_proc = proc {|a,b| [a,b] }
a_proc.call(1)   #=&gt; [1, nil]

a_proc = lambda {|a,b| [a,b] }
a_proc.call(1)   # ArgumentError: wrong number of arguments (given 1, expected 2)
</pre> <p>See also <a href="proc.html#method-i-lambda-3F"><code>Proc#lambda?</code></a>.</p> </div> <div class="aliases"> Alias for: <a href="proc.html#method-i-call">call</a> </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core &copy; 1993&ndash;2022 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library &copy; contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>
