<h1 id="module-Open3" class="anchor-link module"> module Open3 </h1> <section class="description"> <p>Module Open3 supports creating child processes with access to their $stdin, $stdout, and $stderr streams.</p> <h2 id="module-Open3-label-What-27s+Here">What’s Here</h2> <p>Each of these methods executes a given command in a new process or subshell, or multiple commands in new processes and/or subshells:</p> <ul>
<li> <p>Each of these methods executes a single command in a process or subshell, accepts a string for input to $stdin, and returns string output from $stdout, $stderr, or both:</p> <ul>
<li> <p><a href="open3.html#method-c-capture2"><code>Open3.capture2</code></a>: Executes the command; returns the string from $stdout.</p> </li>
<li> <p><a href="open3.html#method-c-capture2e"><code>Open3.capture2e</code></a>: Executes the command; returns the string from merged $stdout and $stderr.</p> </li>
<li> <p><a href="open3.html#method-c-capture3"><code>Open3.capture3</code></a>: Executes the command; returns strings from $stdout and $stderr.</p> </li>
</ul> </li>
<li> <p>Each of these methods executes a single command in a process or subshell, and returns pipes for $stdin, $stdout, and/or $stderr:</p> <ul>
<li> <p><a href="open3.html#method-c-popen2"><code>Open3.popen2</code></a>: Executes the command; returns pipes for $stdin and $stdout.</p> </li>
<li> <p><a href="open3.html#method-c-popen2e"><code>Open3.popen2e</code></a>: Executes the command; returns pipes for $stdin and merged $stdout and $stderr.</p> </li>
<li> <p><a href="open3.html#method-c-popen3"><code>Open3.popen3</code></a>: Executes the command; returns pipes for $stdin, $stdout, and $stderr.</p> </li>
</ul> </li>
<li> <p>Each of these methods executes one or more commands in processes and/or subshells, returns pipes for the first $stdin, the last $stdout, or both:</p> <ul>
<li> <p><a href="open3.html#method-c-pipeline_r"><code>Open3.pipeline_r</code></a>: Returns a pipe for the last $stdout.</p> </li>
<li> <p><a href="open3.html#method-c-pipeline_rw"><code>Open3.pipeline_rw</code></a>: Returns pipes for the first $stdin and the last $stdout.</p> </li>
<li> <p><a href="open3.html#method-c-pipeline_w"><code>Open3.pipeline_w</code></a>: Returns a pipe for the first $stdin.</p> </li>
<li> <p><a href="open3.html#method-c-pipeline_start"><code>Open3.pipeline_start</code></a>: Does not wait for processes to complete.</p> </li>
<li> <p><a href="open3.html#method-c-pipeline"><code>Open3.pipeline</code></a>: Waits for processes to complete.</p> </li>
</ul> </li>
</ul> <p>Each of the methods above accepts:</p> <ul>
<li> <p>An optional hash of environment variable names and values; see <a href="process.html#module-Process-label-Execution+Environment">Execution Environment</a>.</p> </li>
<li> <p>A required string argument that is a <code>command_line</code> or <code>exe_path</code>; see <a href="process.html#module-Process-label-Argument+command_line+or+exe_path">Argument command_line or exe_path</a>.</p> </li>
<li> <p>An optional hash of execution options; see <a href="process.html#module-Process-label-Execution+Options">Execution Options</a>.</p> </li>
</ul> </section> <section id="5Buntitled-5D" class="documentation-section anchor-link"> <section class="constants-list"> <header> <h3>Constants</h3> </header> <dl> <dt id="VERSION">VERSION </dt>

</dl> </section> <section id="public-class-5Buntitled-5D-method-details" class="method-section anchor-link"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-capture2"> <a href="#method-c-capture2" title="Link to this method"> <span class="method-callseq"> capture2([env, ] command_line, options = {}) → [stdout_s, status] </span> </a> </div> <div class="method-heading"> <a href="#method-c-capture2" title="Link to this method"> <span class="method-callseq"> capture2([env, ] exe_path, *args, options = {}) → [stdout_s, status] </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="capture2-source"> <pre class="ruby" data-language="ruby"># File lib/open3.rb, line 775
def capture2(*cmd)
  if Hash === cmd.last
    opts = cmd.pop.dup
  else
    opts = {}
  end

  stdin_data = opts.delete(:stdin_data)
  binmode = opts.delete(:binmode)

  popen2(*cmd, opts) {|i, o, t|
    if binmode
      i.binmode
      o.binmode
    end
    out_reader = Thread.new { o.read }
    if stdin_data
      begin
        if stdin_data.respond_to? :readpartial
          IO.copy_stream(stdin_data, i)
        else
          i.write stdin_data
        end
      rescue Errno::EPIPE
      end
    end
    i.close
    [out_reader.value, t.value]
  }
end</pre> </div>  <p>Basically a wrapper for <a href="open3.html#method-c-popen3"><code>Open3.popen3</code></a> that:</p> <ul>
<li> <p>Creates a child process, by calling <a href="open3.html#method-c-popen3"><code>Open3.popen3</code></a> with the given arguments (except for certain entries in hash <code>options</code>; see below).</p> </li>
<li> <p>Returns as string <code>stdout_s</code> the standard output of the child process.</p> </li>
<li> <p>Returns as <code>status</code> a <a href="process/status.html"><code>Process::Status</code></a> object that represents the exit status of the child process.</p> </li>
</ul> <p>Returns the array <code>[stdout_s, status]</code>:</p> <pre class="ruby" data-language="ruby">stdout_s, status = Open3.capture2('echo "Foo"')
# =&gt; ["Foo\n", #&lt;Process::Status: pid 2326047 exit 0&gt;]
</pre> <p>Like <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>, this method has potential security vulnerabilities if called with untrusted input; see <a href="command_injection_rdoc.html#label-Command+Injection">Command Injection</a>.</p> <p>Unlike <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>, this method waits for the child process to exit before returning, so the caller need not do so.</p> <p>If the first argument is a hash, it becomes leading argument <code>env</code> in the call to <a href="open3.html#method-c-popen3"><code>Open3.popen3</code></a>; see <a href="process.html#module-Process-label-Execution+Environment">Execution Environment</a>.</p> <p>If the last argument is a hash, it becomes trailing argument <code>options</code> in the call to <a href="open3.html#method-c-popen3"><code>Open3.popen3</code></a>; see <a href="process.html#module-Process-label-Execution+Options">Execution Options</a>.</p> <p>The hash <code>options</code> is given; two options have local effect in method <a href="open3.html#method-c-capture2"><code>Open3.capture2</code></a>:</p> <ul>
<li> <p>If entry <code>options[:stdin_data]</code> exists, the entry is removed and its string value is sent to the command’s standard input:</p> <pre class="ruby" data-language="ruby">Open3.capture2('tee', stdin_data: 'Foo')

# =&gt; ["Foo", #&lt;Process::Status: pid 2326087 exit 0&gt;]
</pre> </li>
<li> <p>If entry <code>options[:binmode]</code> exists, the entry is removed and the internal streams are set to binary mode.</p> </li>
</ul> <p>The single required argument is one of the following:</p> <ul>
<li> <p><code>command_line</code> if it is a string, and if it begins with a shell reserved word or special built-in, or if it contains one or more metacharacters.</p> </li>
<li> <p><code>exe_path</code> otherwise.</p> </li>
</ul> <p><strong>Argument <code>command_line</code></strong></p> <p>String argument <code>command_line</code> is a command line to be passed to a shell; it must begin with a shell reserved word, begin with a special built-in, or contain meta characters:</p> <pre class="ruby" data-language="ruby">Open3.capture2('if true; then echo "Foo"; fi') # Shell reserved word.
# =&gt; ["Foo\n", #&lt;Process::Status: pid 2326131 exit 0&gt;]
Open3.capture2('echo')                         # Built-in.
# =&gt; ["\n", #&lt;Process::Status: pid 2326139 exit 0&gt;]
Open3.capture2('date &gt; date.tmp')              # Contains meta character.
# =&gt; ["", #&lt;Process::Status: pid 2326174 exit 0&gt;]
</pre> <p>The command line may also contain arguments and options for the command:</p> <pre class="ruby" data-language="ruby">Open3.capture2('echo "Foo"')
# =&gt; ["Foo\n", #&lt;Process::Status: pid 2326183 exit 0&gt;]
</pre> <p><strong>Argument <code>exe_path</code></strong></p> <p>Argument <code>exe_path</code> is one of the following:</p> <ul>
<li> <p>The string path to an executable to be called.</p> </li>
<li> <p>A 2-element array containing the path to an executable and the string to be used as the name of the executing process.</p> </li>
</ul> <p>Example:</p> <pre class="ruby" data-language="ruby">Open3.capture2('/usr/bin/date')
# =&gt; ["Fri Sep 29 01:00:39 PM CDT 2023\n", #&lt;Process::Status: pid 2326222 exit 0&gt;]
</pre> <p>Ruby invokes the executable directly, with no shell and no shell expansion:</p> <pre class="ruby" data-language="ruby">Open3.capture2('doesnt_exist') # Raises Errno::ENOENT
</pre> <p>If one or more <code>args</code> is given, each is an argument or option to be passed to the executable:</p> <pre class="ruby" data-language="ruby">Open3.capture2('echo', 'C #')
# =&gt; ["C #\n", #&lt;Process::Status: pid 2326267 exit 0&gt;]
Open3.capture2('echo', 'hello', 'world')
# =&gt; ["hello world\n", #&lt;Process::Status: pid 2326299 exit 0&gt;]
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-capture2e"> <a href="#method-c-capture2e" title="Link to this method"> <span class="method-callseq"> capture2e([env, ] command_line, options = {}) → [stdout_and_stderr_s, status] </span> </a> </div> <div class="method-heading"> <a href="#method-c-capture2e" title="Link to this method"> <span class="method-callseq"> capture2e([env, ] exe_path, *args, options = {}) → [stdout_and_stderr_s, status] </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="capture2e-source"> <pre class="ruby" data-language="ruby"># File lib/open3.rb, line 902
def capture2e(*cmd)
  if Hash === cmd.last
    opts = cmd.pop.dup
  else
    opts = {}
  end

  stdin_data = opts.delete(:stdin_data)
  binmode = opts.delete(:binmode)

  popen2e(*cmd, opts) {|i, oe, t|
    if binmode
      i.binmode
      oe.binmode
    end
    outerr_reader = Thread.new { oe.read }
    if stdin_data
      begin
        if stdin_data.respond_to? :readpartial
          IO.copy_stream(stdin_data, i)
        else
          i.write stdin_data
        end
      rescue Errno::EPIPE
      end
    end
    i.close
    [outerr_reader.value, t.value]
  }
end</pre> </div>  <p>Basically a wrapper for <a href="open3.html#method-c-popen3"><code>Open3.popen3</code></a> that:</p> <ul>
<li> <p>Creates a child process, by calling <a href="open3.html#method-c-popen3"><code>Open3.popen3</code></a> with the given arguments (except for certain entries in hash <code>options</code>; see below).</p> </li>
<li> <p>Returns as string <code>stdout_and_stderr_s</code> the merged standard output and standard error of the child process.</p> </li>
<li> <p>Returns as <code>status</code> a <a href="process/status.html"><code>Process::Status</code></a> object that represents the exit status of the child process.</p> </li>
</ul> <p>Returns the array <code>[stdout_and_stderr_s, status]</code>:</p> <pre class="ruby" data-language="ruby">stdout_and_stderr_s, status = Open3.capture2e('echo "Foo"')
# =&gt; ["Foo\n", #&lt;Process::Status: pid 2371692 exit 0&gt;]
</pre> <p>Like <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>, this method has potential security vulnerabilities if called with untrusted input; see <a href="command_injection_rdoc.html#label-Command+Injection">Command Injection</a>.</p> <p>Unlike <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>, this method waits for the child process to exit before returning, so the caller need not do so.</p> <p>If the first argument is a hash, it becomes leading argument <code>env</code> in the call to <a href="open3.html#method-c-popen3"><code>Open3.popen3</code></a>; see <a href="process.html#module-Process-label-Execution+Environment">Execution Environment</a>.</p> <p>If the last argument is a hash, it becomes trailing argument <code>options</code> in the call to <a href="open3.html#method-c-popen3"><code>Open3.popen3</code></a>; see <a href="process.html#module-Process-label-Execution+Options">Execution Options</a>.</p> <p>The hash <code>options</code> is given; two options have local effect in method <a href="open3.html#method-c-capture2e"><code>Open3.capture2e</code></a>:</p> <ul>
<li> <p>If entry <code>options[:stdin_data]</code> exists, the entry is removed and its string value is sent to the command’s standard input:</p> <pre class="ruby" data-language="ruby">Open3.capture2e('tee', stdin_data: 'Foo')
# =&gt; ["Foo", #&lt;Process::Status: pid 2371732 exit 0&gt;]
</pre> </li>
<li> <p>If entry <code>options[:binmode]</code> exists, the entry is removed and the internal streams are set to binary mode.</p> </li>
</ul> <p>The single required argument is one of the following:</p> <ul>
<li> <p><code>command_line</code> if it is a string, and if it begins with a shell reserved word or special built-in, or if it contains one or more metacharacters.</p> </li>
<li> <p><code>exe_path</code> otherwise.</p> </li>
</ul> <p><strong>Argument <code>command_line</code></strong></p> <p>String argument <code>command_line</code> is a command line to be passed to a shell; it must begin with a shell reserved word, begin with a special built-in, or contain meta characters:</p> <pre class="ruby" data-language="ruby">Open3.capture2e('if true; then echo "Foo"; fi') # Shell reserved word.
# =&gt; ["Foo\n", #&lt;Process::Status: pid 2371740 exit 0&gt;]
Open3.capture2e('echo')                         # Built-in.
# =&gt; ["\n", #&lt;Process::Status: pid 2371774 exit 0&gt;]
Open3.capture2e('date &gt; date.tmp')              # Contains meta character.
# =&gt; ["", #&lt;Process::Status: pid 2371812 exit 0&gt;]
</pre> <p>The command line may also contain arguments and options for the command:</p> <pre class="ruby" data-language="ruby">Open3.capture2e('echo "Foo"')
# =&gt; ["Foo\n", #&lt;Process::Status: pid 2326183 exit 0&gt;]
</pre> <p><strong>Argument <code>exe_path</code></strong></p> <p>Argument <code>exe_path</code> is one of the following:</p> <ul>
<li> <p>The string path to an executable to be called.</p> </li>
<li> <p>A 2-element array containing the path to an executable and the string to be used as the name of the executing process.</p> </li>
</ul> <p>Example:</p> <pre class="ruby" data-language="ruby">Open3.capture2e('/usr/bin/date')
# =&gt; ["Sat Sep 30 09:01:46 AM CDT 2023\n", #&lt;Process::Status: pid 2371820 exit 0&gt;]
</pre> <p>Ruby invokes the executable directly, with no shell and no shell expansion:</p> <pre class="ruby" data-language="ruby">Open3.capture2e('doesnt_exist') # Raises Errno::ENOENT
</pre> <p>If one or more <code>args</code> is given, each is an argument or option to be passed to the executable:</p> <pre class="ruby" data-language="ruby">Open3.capture2e('echo', 'C #')
# =&gt; ["C #\n", #&lt;Process::Status: pid 2371856 exit 0&gt;]
Open3.capture2e('echo', 'hello', 'world')
# =&gt; ["hello world\n", #&lt;Process::Status: pid 2371894 exit 0&gt;]
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-capture3"> <a href="#method-c-capture3" title="Link to this method"> <span class="method-callseq"> capture3([env, ] command_line, options = {}) → [stdout_s, stderr_s, status] </span> </a> </div> <div class="method-heading"> <a href="#method-c-capture3" title="Link to this method"> <span class="method-callseq"> capture3([env, ] exe_path, *args, options = {}) → [stdout_s, stderr_s, status] </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="capture3-source"> <pre class="ruby" data-language="ruby"># File lib/open3.rb, line 648
def capture3(*cmd)
  if Hash === cmd.last
    opts = cmd.pop.dup
  else
    opts = {}
  end

  stdin_data = opts.delete(:stdin_data) || ''
  binmode = opts.delete(:binmode)

  popen3(*cmd, opts) {|i, o, e, t|
    if binmode
      i.binmode
      o.binmode
      e.binmode
    end
    out_reader = Thread.new { o.read }
    err_reader = Thread.new { e.read }
    begin
      if stdin_data.respond_to? :readpartial
        IO.copy_stream(stdin_data, i)
      else
        i.write stdin_data
      end
    rescue Errno::EPIPE
    end
    i.close
    [out_reader.value, err_reader.value, t.value]
  }
end</pre> </div>  <p>Basically a wrapper for <a href="open3.html#method-c-popen3"><code>Open3.popen3</code></a> that:</p> <ul>
<li> <p>Creates a child process, by calling <a href="open3.html#method-c-popen3"><code>Open3.popen3</code></a> with the given arguments (except for certain entries in hash <code>options</code>; see below).</p> </li>
<li> <p>Returns as strings <code>stdout_s</code> and <code>stderr_s</code> the standard output and standard error of the child process.</p> </li>
<li> <p>Returns as <code>status</code> a <a href="process/status.html"><code>Process::Status</code></a> object that represents the exit status of the child process.</p> </li>
</ul> <p>Returns the array <code>[stdout_s, stderr_s, status]</code>:</p> <pre class="ruby" data-language="ruby">stdout_s, stderr_s, status = Open3.capture3('echo "Foo"')
# =&gt; ["Foo\n", "", #&lt;Process::Status: pid 2281954 exit 0&gt;]
</pre> <p>Like <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>, this method has potential security vulnerabilities if called with untrusted input; see <a href="command_injection_rdoc.html#label-Command+Injection">Command Injection</a>.</p> <p>Unlike <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>, this method waits for the child process to exit before returning, so the caller need not do so.</p> <p>If the first argument is a hash, it becomes leading argument <code>env</code> in the call to <a href="open3.html#method-c-popen3"><code>Open3.popen3</code></a>; see <a href="process.html#module-Process-label-Execution+Environment">Execution Environment</a>.</p> <p>If the last argument is a hash, it becomes trailing argument <code>options</code> in the call to <a href="open3.html#method-c-popen3"><code>Open3.popen3</code></a>; see <a href="process.html#module-Process-label-Execution+Options">Execution Options</a>.</p> <p>The hash <code>options</code> is given; two options have local effect in method <a href="open3.html#method-c-capture3"><code>Open3.capture3</code></a>:</p> <ul>
<li> <p>If entry <code>options[:stdin_data]</code> exists, the entry is removed and its string value is sent to the command’s standard input:</p> <pre class="ruby" data-language="ruby">Open3.capture3('tee', stdin_data: 'Foo')
# =&gt; ["Foo", "", #&lt;Process::Status: pid 2319575 exit 0&gt;]
</pre> </li>
<li> <p>If entry <code>options[:binmode]</code> exists, the entry is removed and the internal streams are set to binary mode.</p> </li>
</ul> <p>The single required argument is one of the following:</p> <ul>
<li> <p><code>command_line</code> if it is a string, and if it begins with a shell reserved word or special built-in, or if it contains one or more metacharacters.</p> </li>
<li> <p><code>exe_path</code> otherwise.</p> </li>
</ul> <p><strong>Argument <code>command_line</code></strong></p> <p>String argument <code>command_line</code> is a command line to be passed to a shell; it must begin with a shell reserved word, begin with a special built-in, or contain meta characters:</p> <pre class="ruby" data-language="ruby">Open3.capture3('if true; then echo "Foo"; fi') # Shell reserved word.
# =&gt; ["Foo\n", "", #&lt;Process::Status: pid 2282025 exit 0&gt;]
Open3.capture3('echo')                         # Built-in.
# =&gt; ["\n", "", #&lt;Process::Status: pid 2282092 exit 0&gt;]
Open3.capture3('date &gt; date.tmp')              # Contains meta character.
# =&gt; ["", "", #&lt;Process::Status: pid 2282110 exit 0&gt;]
</pre> <p>The command line may also contain arguments and options for the command:</p> <pre class="ruby" data-language="ruby">Open3.capture3('echo "Foo"')
# =&gt; ["Foo\n", "", #&lt;Process::Status: pid 2282092 exit 0&gt;]
</pre> <p><strong>Argument <code>exe_path</code></strong></p> <p>Argument <code>exe_path</code> is one of the following:</p> <ul>
<li> <p>The string path to an executable to be called.</p> </li>
<li> <p>A 2-element array containing the path to an executable and the string to be used as the name of the executing process.</p> </li>
</ul> <p>Example:</p> <pre class="ruby" data-language="ruby">Open3.capture3('/usr/bin/date')
# =&gt; ["Thu Sep 28 05:03:51 PM CDT 2023\n", "", #&lt;Process::Status: pid 2282300 exit 0&gt;]
</pre> <p>Ruby invokes the executable directly, with no shell and no shell expansion:</p> <pre class="ruby" data-language="ruby">Open3.capture3('doesnt_exist') # Raises Errno::ENOENT
</pre> <p>If one or more <code>args</code> is given, each is an argument or option to be passed to the executable:</p> <pre class="ruby" data-language="ruby">Open3.capture3('echo', 'C #')
# =&gt; ["C #\n", "", #&lt;Process::Status: pid 2282368 exit 0&gt;]
Open3.capture3('echo', 'hello', 'world')
# =&gt; ["hello world\n", "", #&lt;Process::Status: pid 2282372 exit 0&gt;]
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-pipeline"> <a href="#method-c-pipeline" title="Link to this method"> <span class="method-callseq"> pipeline([env, ] *cmds, options = {}) → array_of_statuses </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="pipeline-source"> <pre class="ruby" data-language="ruby"># File lib/open3.rb, line 1334
def pipeline(*cmds)
  if Hash === cmds.last
    opts = cmds.pop.dup
  else
    opts = {}
  end

  pipeline_run(cmds, opts, [], []) {|ts|
    ts.map(&amp;:value)
  }
end</pre> </div>  <p>Basically a wrapper for <a href="process.html#method-c-spawn"><code>Process.spawn</code></a> that:</p> <ul>
<li> <p>Creates a child process for each of the given <code>cmds</code> by calling <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>.</p> </li>
<li> <p>Pipes the <code>stdout</code> from each child to the <code>stdin</code> of the next child, or, for the last child, to the caller’s <code>stdout</code>.</p> </li>
<li> <p>Waits for the child processes to exit.</p> </li>
<li> <p>Returns an array of <a href="process/status.html"><code>Process::Status</code></a> objects (one for each child).</p> </li>
</ul> <p>Example:</p> <pre class="ruby" data-language="ruby">wait_threads = Open3.pipeline('ls', 'grep R')
# =&gt; [#&lt;Process::Status: pid 2139200 exit 0&gt;, #&lt;Process::Status: pid 2139202 exit 0&gt;]
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">Rakefile
README.md
</pre> <p>Like <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>, this method has potential security vulnerabilities if called with untrusted input; see <a href="command_injection_rdoc.html#label-Command+Injection">Command Injection</a>.</p> <p>If the first argument is a hash, it becomes leading argument <code>env</code> in each call to <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>; see <a href="process.html#module-Process-label-Execution+Environment">Execution Environment</a>.</p> <p>If the last argument is a hash, it becomes trailing argument <code>options</code> in each call to <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>‘ see <a href="process.html#module-Process-label-Execution+Options">Execution Options</a>.</p> <p>Each remaining argument in <code>cmds</code> is one of:</p> <ul>
<li> <p>A <code>command_line</code>: a string that begins with a shell reserved word or special built-in, or contains one or more metacharacters.</p> </li>
<li> <p>An <code>exe_path</code>: the string path to an executable to be called.</p> </li>
<li> <p>An array containing a <code>command_line</code> or an <code>exe_path</code>, along with zero or more string arguments for the command.</p> </li>
</ul> <p>See <a href="process.html#module-Process-label-Argument+command_line+or+exe_path">Argument command_line or exe_path</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-pipeline_r"> <a href="#method-c-pipeline_r" title="Link to this method"> <span class="method-callseq"> pipeline_r([env, ] *cmds, options = {}) → [last_stdout, wait_threads] </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="pipeline_r-source"> <pre class="ruby" data-language="ruby"># File lib/open3.rb, line 1104
def pipeline_r(*cmds, &amp;block)
  if Hash === cmds.last
    opts = cmds.pop.dup
  else
    opts = {}
  end

  out_r, out_w = IO.pipe
  opts[:out] = out_w

  pipeline_run(cmds, opts, [out_w], [out_r], &amp;block)
end</pre> </div>  <p>Basically a wrapper for <a href="process.html#method-c-spawn"><code>Process.spawn</code></a> that:</p> <ul>
<li> <p>Creates a child process for each of the given <code>cmds</code> by calling <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>.</p> </li>
<li> <p>Pipes the <code>stdout</code> from each child to the <code>stdin</code> of the next child, or, for the last child, to the caller’s <code>stdout</code>.</p> </li>
</ul> <p>The method does not wait for child processes to exit, so the caller must do so.</p> <p>With no block given, returns a 2-element array containing:</p> <ul>
<li> <p>The <code>stdout</code> stream of the last child process.</p> </li>
<li> <p>An array of the wait threads for all of the child processes.</p> </li>
</ul> <p>Example:</p> <pre class="ruby" data-language="ruby">last_stdout, wait_threads = Open3.pipeline_r('ls', 'grep R')
# =&gt; [#&lt;IO:fd 5&gt;, [#&lt;Process::Waiter:0x000055e8de2f9898 dead&gt;, #&lt;Process::Waiter:0x000055e8de2f94b0 sleep&gt;]]
puts last_stdout.read
wait_threads.each do |wait_thread|
  wait_thread.join
end
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">Rakefile
README.md
</pre> <p>With a block given, calls the block with the <code>stdout</code> stream of the last child process, and an array of the wait processes:</p> <pre class="ruby" data-language="ruby">Open3.pipeline_r('ls', 'grep R') do |last_stdout, wait_threads|
  puts last_stdout.read
  wait_threads.each do |wait_thread|
    wait_thread.join
  end
end
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">Rakefile
README.md
</pre> <p>Like <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>, this method has potential security vulnerabilities if called with untrusted input; see <a href="command_injection_rdoc.html#label-Command+Injection">Command Injection</a>.</p> <p>If the first argument is a hash, it becomes leading argument <code>env</code> in each call to <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>; see <a href="process.html#module-Process-label-Execution+Environment">Execution Environment</a>.</p> <p>If the last argument is a hash, it becomes trailing argument <code>options</code> in each call to <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>; see <a href="process.html#module-Process-label-Execution+Options">Execution Options</a>.</p> <p>Each remaining argument in <code>cmds</code> is one of:</p> <ul>
<li> <p>A <code>command_line</code>: a string that begins with a shell reserved word or special built-in, or contains one or more metacharacters.</p> </li>
<li> <p>An <code>exe_path</code>: the string path to an executable to be called.</p> </li>
<li> <p>An array containing a <code>command_line</code> or an <code>exe_path</code>, along with zero or more string arguments for the command.</p> </li>
</ul> <p>See <a href="process.html#module-Process-label-Argument+command_line+or+exe_path">Argument command_line or exe_path</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-pipeline_rw"> <a href="#method-c-pipeline_rw" title="Link to this method"> <span class="method-callseq"> pipeline_rw([env, ] *cmds, options = {}) → [first_stdin, last_stdout, wait_threads] </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="pipeline_rw-source"> <pre class="ruby" data-language="ruby"># File lib/open3.rb, line 1014
def pipeline_rw(*cmds, &amp;block)
  if Hash === cmds.last
    opts = cmds.pop.dup
  else
    opts = {}
  end

  in_r, in_w = IO.pipe
  opts[:in] = in_r
  in_w.sync = true

  out_r, out_w = IO.pipe
  opts[:out] = out_w

  pipeline_run(cmds, opts, [in_r, out_w], [in_w, out_r], &amp;block)
end</pre> </div>  <p>Basically a wrapper for <a href="process.html#method-c-spawn"><code>Process.spawn</code></a> that:</p> <ul>
<li> <p>Creates a child process for each of the given <code>cmds</code> by calling <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>.</p> </li>
<li> <p>Pipes the <code>stdout</code> from each child to the <code>stdin</code> of the next child, or, for the first child, from the caller’s <code>stdin</code>, or, for the last child, to the caller’s <code>stdout</code>.</p> </li>
</ul> <p>The method does not wait for child processes to exit, so the caller must do so.</p> <p>With no block given, returns a 3-element array containing:</p> <ul>
<li> <p>The <code>stdin</code> stream of the first child process.</p> </li>
<li> <p>The <code>stdout</code> stream of the last child process.</p> </li>
<li> <p>An array of the wait threads for all of the child processes.</p> </li>
</ul> <p>Example:</p> <pre class="ruby" data-language="ruby">first_stdin, last_stdout, wait_threads = Open3.pipeline_rw('sort', 'cat -n')
# =&gt; [#&lt;IO:fd 20&gt;, #&lt;IO:fd 21&gt;, [#&lt;Process::Waiter:0x000055e8de29ab40 sleep&gt;, #&lt;Process::Waiter:0x000055e8de29a690 sleep&gt;]]
first_stdin.puts("foo\nbar\nbaz")
first_stdin.close # Send EOF to sort.
puts last_stdout.read
wait_threads.each do |wait_thread|
  wait_thread.join
end
</pre> <p>Output:</p> <pre>1 bar
2 baz
3 foo</pre> <p>With a block given, calls the block with the <code>stdin</code> stream of the first child, the <code>stdout</code> stream of the last child, and an array of the wait processes:</p> <pre class="ruby" data-language="ruby">Open3.pipeline_rw('sort', 'cat -n') do |first_stdin, last_stdout, wait_threads|
  first_stdin.puts "foo\nbar\nbaz"
  first_stdin.close # send EOF to sort.
  puts last_stdout.read
  wait_threads.each do |wait_thread|
    wait_thread.join
  end
end
</pre> <p>Output:</p> <pre>1 bar
2 baz
3 foo</pre> <p>Like <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>, this method has potential security vulnerabilities if called with untrusted input; see <a href="command_injection_rdoc.html#label-Command+Injection">Command Injection</a>.</p> <p>If the first argument is a hash, it becomes leading argument <code>env</code> in each call to <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>; see <a href="process.html#module-Process-label-Execution+Environment">Execution Environment</a>.</p> <p>If the last argument is a hash, it becomes trailing argument <code>options</code> in each call to <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>; see <a href="process.html#module-Process-label-Execution+Options">Execution Options</a>.</p> <p>Each remaining argument in <code>cmds</code> is one of:</p> <ul>
<li> <p>A <code>command_line</code>: a string that begins with a shell reserved word or special built-in, or contains one or more metacharacters.</p> </li>
<li> <p>An <code>exe_path</code>: the string path to an executable to be called.</p> </li>
<li> <p>An array containing a <code>command_line</code> or an <code>exe_path</code>, along with zero or more string arguments for the command.</p> </li>
</ul> <p>See <a href="process.html#module-Process-label-Argument+command_line+or+exe_path">Argument command_line or exe_path</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-pipeline_start"> <a href="#method-c-pipeline_start" title="Link to this method"> <span class="method-callseq"> pipeline_start([env, ] *cmds, options = {}) → [wait_threads] </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="pipeline_start-source"> <pre class="ruby" data-language="ruby"># File lib/open3.rb, line 1272
def pipeline_start(*cmds, &amp;block)
  if Hash === cmds.last
    opts = cmds.pop.dup
  else
    opts = {}
  end

  if block
    pipeline_run(cmds, opts, [], [], &amp;block)
  else
    ts, = pipeline_run(cmds, opts, [], [])
    ts
  end
end</pre> </div>  <p>Basically a wrapper for <a href="process.html#method-c-spawn"><code>Process.spawn</code></a> that:</p> <ul>
<li> <p>Creates a child process for each of the given <code>cmds</code> by calling <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>.</p> </li>
<li> <p>Does not wait for child processes to exit.</p> </li>
</ul> <p>With no block given, returns an array of the wait threads for all of the child processes.</p> <p>Example:</p> <pre class="ruby" data-language="ruby">wait_threads = Open3.pipeline_start('ls', 'grep R')
# =&gt; [#&lt;Process::Waiter:0x000055e8de9d2bb0 run&gt;, #&lt;Process::Waiter:0x000055e8de9d2890 run&gt;]
wait_threads.each do |wait_thread|
  wait_thread.join
end
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">Rakefile
README.md
</pre> <p>With a block given, calls the block with an array of the wait processes:</p> <pre class="ruby" data-language="ruby">Open3.pipeline_start('ls', 'grep R') do |wait_threads|
  wait_threads.each do |wait_thread|
    wait_thread.join
  end
end
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">Rakefile
README.md
</pre> <p>Like <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>, this method has potential security vulnerabilities if called with untrusted input; see <a href="command_injection_rdoc.html#label-Command+Injection">Command Injection</a>.</p> <p>If the first argument is a hash, it becomes leading argument <code>env</code> in each call to <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>; see <a href="process.html#module-Process-label-Execution+Environment">Execution Environment</a>.</p> <p>If the last argument is a hash, it becomes trailing argument <code>options</code> in each call to <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>; see <a href="process.html#module-Process-label-Execution+Options">Execution Options</a>.</p> <p>Each remaining argument in <code>cmds</code> is one of:</p> <ul>
<li> <p>A <code>command_line</code>: a string that begins with a shell reserved word or special built-in, or contains one or more metacharacters.</p> </li>
<li> <p>An <code>exe_path</code>: the string path to an executable to be called.</p> </li>
<li> <p>An array containing a <code>command_line</code> or an <code>exe_path</code>, along with zero or more string arguments for the command.</p> </li>
</ul> <p>See <a href="process.html#module-Process-label-Argument+command_line+or+exe_path">Argument command_line or exe_path</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-pipeline_w"> <a href="#method-c-pipeline_w" title="Link to this method"> <span class="method-callseq"> pipeline_w([env, ] *cmds, options = {}) → [first_stdin, wait_threads] </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="pipeline_w-source"> <pre class="ruby" data-language="ruby"># File lib/open3.rb, line 1195
def pipeline_w(*cmds, &amp;block)
  if Hash === cmds.last
    opts = cmds.pop.dup
  else
    opts = {}
  end

  in_r, in_w = IO.pipe
  opts[:in] = in_r
  in_w.sync = true

  pipeline_run(cmds, opts, [in_r], [in_w], &amp;block)
end</pre> </div>  <p>Basically a wrapper for <a href="process.html#method-c-spawn"><code>Process.spawn</code></a> that:</p> <ul>
<li> <p>Creates a child process for each of the given <code>cmds</code> by calling <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>.</p> </li>
<li> <p>Pipes the <code>stdout</code> from each child to the <code>stdin</code> of the next child, or, for the first child, pipes the caller’s <code>stdout</code> to the child’s <code>stdin</code>.</p> </li>
</ul> <p>The method does not wait for child processes to exit, so the caller must do so.</p> <p>With no block given, returns a 2-element array containing:</p> <ul>
<li> <p>The <code>stdin</code> stream of the first child process.</p> </li>
<li> <p>An array of the wait threads for all of the child processes.</p> </li>
</ul> <p>Example:</p> <pre class="ruby" data-language="ruby">first_stdin, wait_threads = Open3.pipeline_w('sort', 'cat -n')
# =&gt; [#&lt;IO:fd 7&gt;, [#&lt;Process::Waiter:0x000055e8de928278 run&gt;, #&lt;Process::Waiter:0x000055e8de923e80 run&gt;]]
first_stdin.puts("foo\nbar\nbaz")
first_stdin.close # Send EOF to sort.
wait_threads.each do |wait_thread|
  wait_thread.join
end
</pre> <p>Output:</p> <pre>1 bar
2 baz
3 foo</pre> <p>With a block given, calls the block with the <code>stdin</code> stream of the first child process, and an array of the wait processes:</p> <pre class="ruby" data-language="ruby">Open3.pipeline_w('sort', 'cat -n') do |first_stdin, wait_threads|
  first_stdin.puts("foo\nbar\nbaz")
  first_stdin.close # Send EOF to sort.
  wait_threads.each do |wait_thread|
    wait_thread.join
  end
end
</pre> <p>Output:</p> <pre>1 bar
2 baz
3 foo</pre> <p>Like <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>, this method has potential security vulnerabilities if called with untrusted input; see <a href="command_injection_rdoc.html#label-Command+Injection">Command Injection</a>.</p> <p>If the first argument is a hash, it becomes leading argument <code>env</code> in each call to <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>; see <a href="process.html#module-Process-label-Execution+Environment">Execution Environment</a>.</p> <p>If the last argument is a hash, it becomes trailing argument <code>options</code> in each call to <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>; see <a href="process.html#module-Process-label-Execution+Options">Execution Options</a>.</p> <p>Each remaining argument in <code>cmds</code> is one of:</p> <ul>
<li> <p>A <code>command_line</code>: a string that begins with a shell reserved word or special built-in, or contains one or more metacharacters.</p> </li>
<li> <p>An <code>exe_path</code>: the string path to an executable to be called.</p> </li>
<li> <p>An array containing a <code>command_line</code> or an <code>exe_path</code>, along with zero or more string arguments for the command.</p> </li>
</ul> <p>See <a href="process.html#module-Process-label-Argument+command_line+or+exe_path">Argument command_line or exe_path</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-popen2"> <a href="#method-c-popen2" title="Link to this method"> <span class="method-callseq"> popen2([env, ] command_line, options = {}) → [stdin, stdout, wait_thread] </span> </a> </div> <div class="method-heading"> <a href="#method-c-popen2" title="Link to this method"> <span class="method-callseq"> popen2([env, ] exe_path, *args, options = {}) → [stdin, stdout, wait_thread] </span> </a> </div> <div class="method-heading"> <a href="#method-c-popen2" title="Link to this method"> <span class="method-callseq"> popen2([env, ] command_line, options = {}) {|stdin, stdout, wait_thread| ... } → object </span> </a> </div> <div class="method-heading"> <a href="#method-c-popen2" title="Link to this method"> <span class="method-callseq"> popen2([env, ] exe_path, *args, options = {}) {|stdin, stdout, wait_thread| ... } → object </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="popen2-source"> <pre class="ruby" data-language="ruby"># File lib/open3.rb, line 365
def popen2(*cmd, &amp;block)
  if Hash === cmd.last
    opts = cmd.pop.dup
  else
    opts = {}
  end

  in_r, in_w = IO.pipe
  opts[:in] = in_r
  in_w.sync = true

  out_r, out_w = IO.pipe
  opts[:out] = out_w

  popen_run(cmd, opts, [in_r, out_w], [in_w, out_r], &amp;block)
end</pre> </div>  <p>Basically a wrapper for <a href="process.html#method-c-spawn"><code>Process.spawn</code></a> that:</p> <ul>
<li> <p>Creates a child process, by calling <a href="process.html#method-c-spawn"><code>Process.spawn</code></a> with the given arguments.</p> </li>
<li> <p>Creates streams <code>stdin</code> and <code>stdout</code>, which are the standard input and standard output streams in the child process.</p> </li>
<li> <p>Creates thread <code>wait_thread</code> that waits for the child process to exit; the thread has method <code>pid</code>, which returns the process ID of the child process.</p> </li>
</ul> <p>With no block given, returns the array <code>[stdin, stdout, wait_thread]</code>. The caller should close each of the two returned streams.</p> <pre class="ruby" data-language="ruby">stdin, stdout, wait_thread = Open3.popen2('echo')
# =&gt; [#&lt;IO:fd 6&gt;, #&lt;IO:fd 7&gt;, #&lt;Process::Waiter:0x00007f58d52dbe98 run&gt;]
stdin.close
stdout.close
wait_thread.pid   # =&gt; 2263572
wait_thread.value # =&gt; #&lt;Process::Status: pid 2263572 exit 0&gt;
</pre> <p>With a block given, calls the block with the three variables (two streams and the wait thread) and returns the block’s return value. The caller need not close the streams:</p> <pre class="ruby" data-language="ruby">Open3.popen2('echo') do |stdin, stdout, wait_thread|
  p stdin
  p stdout
  p wait_thread
  p wait_thread.pid
  p wait_thread.value
end
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">#&lt;IO:fd 6&gt;
#&lt;IO:fd 7&gt;
#&lt;Process::Waiter:0x00007f58d59a34b0 sleep&gt;
2263636
#&lt;Process::Status: pid 2263636 exit 0&gt;
</pre> <p>Like <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>, this method has potential security vulnerabilities if called with untrusted input; see <a href="command_injection_rdoc.html#label-Command+Injection">Command Injection</a>.</p> <p>Unlike <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>, this method waits for the child process to exit before returning, so the caller need not do so.</p> <p>If the first argument is a hash, it becomes leading argument <code>env</code> in the call to <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>; see <a href="process.html#module-Process-label-Execution+Environment">Execution Environment</a>.</p> <p>If the last argument is a hash, it becomes trailing argument <code>options</code> in the call to <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>; see <a href="process.html#module-Process-label-Execution+Options">Execution Options</a>.</p> <p>The single required argument is one of the following:</p> <ul>
<li> <p><code>command_line</code> if it is a string, and if it begins with a shell reserved word or special built-in, or if it contains one or more metacharacters.</p> </li>
<li> <p><code>exe_path</code> otherwise.</p> </li>
</ul> <p><strong>Argument <code>command_line</code></strong></p> <p>String argument <code>command_line</code> is a command line to be passed to a shell; it must begin with a shell reserved word, begin with a special built-in, or contain meta characters:</p> <pre class="ruby" data-language="ruby">Open3.popen2('if true; then echo "Foo"; fi') {|*args| p args } # Shell reserved word.
Open3.popen2('echo') {|*args| p args }                         # Built-in.
Open3.popen2('date &gt; date.tmp') {|*args| p args }              # Contains meta character.
</pre> <p>Output (similar for each call above):</p> <pre class="ruby" data-language="ruby"># =&gt; [#&lt;IO:(closed)&gt;, #&lt;IO:(closed)&gt;, #&lt;Process::Waiter:0x00007f7577dfe410 dead&gt;]
</pre> <p>The command line may also contain arguments and options for the command:</p> <pre class="ruby" data-language="ruby">Open3.popen2('echo "Foo"') { |i, o, t| o.gets }
"Foo\n"
</pre> <p><strong>Argument <code>exe_path</code></strong></p> <p>Argument <code>exe_path</code> is one of the following:</p> <ul>
<li> <p>The string path to an executable to be called.</p> </li>
<li> <p>A 2-element array containing the path to an executable and the string to be used as the name of the executing process.</p> </li>
</ul> <p>Example:</p> <pre class="ruby" data-language="ruby">Open3.popen2('/usr/bin/date') { |i, o, t| o.gets }
# =&gt; "Thu Sep 28 09:41:06 AM CDT 2023\n"
</pre> <p>Ruby invokes the executable directly, with no shell and no shell expansion:</p> <pre class="ruby" data-language="ruby">Open3.popen2('doesnt_exist') { |i, o, t| o.gets } # Raises Errno::ENOENT
</pre> <p>If one or more <code>args</code> is given, each is an argument or option to be passed to the executable:</p> <pre class="ruby" data-language="ruby">Open3.popen2('echo', 'C #') { |i, o, t| o.gets }
# =&gt; "C #\n"
Open3.popen2('echo', 'hello', 'world') { |i, o, t| o.gets }
# =&gt; "hello world\n"
</pre> <p>Related:</p> <ul>
<li> <p><a href="open3.html#method-c-popen2e"><code>Open3.popen2e</code></a>: Makes the standard input and the merge of the standard output and standard error streams of the child process available as separate streams.</p> </li>
<li> <p><a href="open3.html#method-c-popen3"><code>Open3.popen3</code></a>: Makes the standard input, standard output, and standard error streams of the child process available as separate streams.</p> </li>
</ul> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-popen2e"> <a href="#method-c-popen2e" title="Link to this method"> <span class="method-callseq"> popen2e([env, ] command_line, options = {}) → [stdin, stdout_and_stderr, wait_thread] </span> </a> </div> <div class="method-heading"> <a href="#method-c-popen2e" title="Link to this method"> <span class="method-callseq"> popen2e([env, ] exe_path, *args, options = {}) → [stdin, stdout_and_stderr, wait_thread] </span> </a> </div> <div class="method-heading"> <a href="#method-c-popen2e" title="Link to this method"> <span class="method-callseq"> popen2e([env, ] command_line, options = {}) {|stdin, stdout_and_stderr, wait_thread| ... } → object </span> </a> </div> <div class="method-heading"> <a href="#method-c-popen2e" title="Link to this method"> <span class="method-callseq"> popen2e([env, ] exe_path, *args, options = {}) {|stdin, stdout_and_stderr, wait_thread| ... } → object </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="popen2e-source"> <pre class="ruby" data-language="ruby"># File lib/open3.rb, line 508
def popen2e(*cmd, &amp;block)
  if Hash === cmd.last
    opts = cmd.pop.dup
  else
    opts = {}
  end

  in_r, in_w = IO.pipe
  opts[:in] = in_r
  in_w.sync = true

  out_r, out_w = IO.pipe
  opts[[:out, :err]] = out_w

  popen_run(cmd, opts, [in_r, out_w], [in_w, out_r], &amp;block)
ensure
  if block
    in_r.close
    in_w.close
    out_r.close
    out_w.close
  end
end</pre> </div>  <p>Basically a wrapper for <a href="process.html#method-c-spawn"><code>Process.spawn</code></a> that:</p> <ul>
<li> <p>Creates a child process, by calling <a href="process.html#method-c-spawn"><code>Process.spawn</code></a> with the given arguments.</p> </li>
<li> <p>Creates streams <code>stdin</code>, <code>stdout_and_stderr</code>, which are the standard input and the merge of the standard output and standard error streams in the child process.</p> </li>
<li> <p>Creates thread <code>wait_thread</code> that waits for the child process to exit; the thread has method <code>pid</code>, which returns the process ID of the child process.</p> </li>
</ul> <p>With no block given, returns the array <code>[stdin, stdout_and_stderr, wait_thread]</code>. The caller should close each of the two returned streams.</p> <pre class="ruby" data-language="ruby">stdin, stdout_and_stderr, wait_thread = Open3.popen2e('echo')
# =&gt; [#&lt;IO:fd 6&gt;, #&lt;IO:fd 7&gt;, #&lt;Process::Waiter:0x00007f7577da4398 run&gt;]
stdin.close
stdout_and_stderr.close
wait_thread.pid   # =&gt; 2274600
wait_thread.value # =&gt; #&lt;Process::Status: pid 2274600 exit 0&gt;
</pre> <p>With a block given, calls the block with the three variables (two streams and the wait thread) and returns the block’s return value. The caller need not close the streams:</p> <pre class="ruby" data-language="ruby">Open3.popen2e('echo') do |stdin, stdout_and_stderr, wait_thread|
  p stdin
  p stdout_and_stderr
  p wait_thread
  p wait_thread.pid
  p wait_thread.value
end
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">#&lt;IO:fd 6&gt;
#&lt;IO:fd 7&gt;
#&lt;Process::Waiter:0x00007f75777578c8 sleep&gt;
2274763
#&lt;Process::Status: pid 2274763 exit 0&gt;
</pre> <p>Like <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>, this method has potential security vulnerabilities if called with untrusted input; see <a href="command_injection_rdoc.html#label-Command+Injection">Command Injection</a>.</p> <p>Unlike <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>, this method waits for the child process to exit before returning, so the caller need not do so.</p> <p>If the first argument is a hash, it becomes leading argument <code>env</code> in the call to <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>; see <a href="process.html#module-Process-label-Execution+Environment">Execution Environment</a>.</p> <p>If the last argument is a hash, it becomes trailing argument <code>options</code> in the call to <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>; see <a href="process.html#module-Process-label-Execution+Options">Execution Options</a>.</p> <p>The single required argument is one of the following:</p> <ul>
<li> <p><code>command_line</code> if it is a string, and if it begins with a shell reserved word or special built-in, or if it contains one or more metacharacters.</p> </li>
<li> <p><code>exe_path</code> otherwise.</p> </li>
</ul> <p><strong>Argument <code>command_line</code></strong></p> <p>String argument <code>command_line</code> is a command line to be passed to a shell; it must begin with a shell reserved word, begin with a special built-in, or contain meta characters:</p> <pre class="ruby" data-language="ruby">Open3.popen2e('if true; then echo "Foo"; fi') {|*args| p args } # Shell reserved word.
Open3.popen2e('echo') {|*args| p args }                         # Built-in.
Open3.popen2e('date &gt; date.tmp') {|*args| p args }              # Contains meta character.
</pre> <p>Output (similar for each call above):</p> <pre class="ruby" data-language="ruby"># =&gt; [#&lt;IO:(closed)&gt;, #&lt;IO:(closed)&gt;, #&lt;Process::Waiter:0x00007f7577d8a1f0 dead&gt;]
</pre> <p>The command line may also contain arguments and options for the command:</p> <pre class="ruby" data-language="ruby">Open3.popen2e('echo "Foo"') { |i, o_and_e, t| o_and_e.gets }
"Foo\n"
</pre> <p><strong>Argument <code>exe_path</code></strong></p> <p>Argument <code>exe_path</code> is one of the following:</p> <ul>
<li> <p>The string path to an executable to be called.</p> </li>
<li> <p>A 2-element array containing the path to an executable and the string to be used as the name of the executing process.</p> </li>
</ul> <p>Example:</p> <pre class="ruby" data-language="ruby">Open3.popen2e('/usr/bin/date') { |i, o_and_e, t| o_and_e.gets }
# =&gt; "Thu Sep 28 01:58:45 PM CDT 2023\n"
</pre> <p>Ruby invokes the executable directly, with no shell and no shell expansion:</p> <pre class="ruby" data-language="ruby">Open3.popen2e('doesnt_exist') { |i, o_and_e, t| o_and_e.gets } # Raises Errno::ENOENT
</pre> <p>If one or more <code>args</code> is given, each is an argument or option to be passed to the executable:</p> <pre class="ruby" data-language="ruby">Open3.popen2e('echo', 'C #') { |i, o_and_e, t| o_and_e.gets }
# =&gt; "C #\n"
Open3.popen2e('echo', 'hello', 'world') { |i, o_and_e, t| o_and_e.gets }
# =&gt; "hello world\n"
</pre> <p>Related:</p> <ul>
<li> <p><a href="open3.html#method-c-popen2"><code>Open3.popen2</code></a>: Makes the standard input and standard output streams of the child process available as separate streams, with no access to the standard error stream.</p> </li>
<li> <p><a href="open3.html#method-c-popen3"><code>Open3.popen3</code></a>: Makes the standard input, standard output, and standard error streams of the child process available as separate streams.</p> </li>
</ul> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-popen3"> <a href="#method-c-popen3" title="Link to this method"> <span class="method-callseq"> popen3([env, ] command_line, options = {}) → [stdin, stdout, stderr, wait_thread] </span> </a> </div> <div class="method-heading"> <a href="#method-c-popen3" title="Link to this method"> <span class="method-callseq"> popen3([env, ] exe_path, *args, options = {}) → [stdin, stdout, stderr, wait_thread] </span> </a> </div> <div class="method-heading"> <a href="#method-c-popen3" title="Link to this method"> <span class="method-callseq"> popen3([env, ] command_line, options = {}) {|stdin, stdout, stderr, wait_thread| ... } → object </span> </a> </div> <div class="method-heading"> <a href="#method-c-popen3" title="Link to this method"> <span class="method-callseq"> popen3([env, ] exe_path, *args, options = {}) {|stdin, stdout, stderr, wait_thread| ... } → object </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="popen3-source"> <pre class="ruby" data-language="ruby"># File lib/open3.rb, line 218
def popen3(*cmd, &amp;block)
  if Hash === cmd.last
    opts = cmd.pop.dup
  else
    opts = {}
  end

  in_r, in_w = IO.pipe
  opts[:in] = in_r
  in_w.sync = true

  out_r, out_w = IO.pipe
  opts[:out] = out_w

  err_r, err_w = IO.pipe
  opts[:err] = err_w

  popen_run(cmd, opts, [in_r, out_w, err_w], [in_w, out_r, err_r], &amp;block)
end</pre> </div>  <p>Basically a wrapper for <a href="process.html#method-c-spawn"><code>Process.spawn</code></a> that:</p> <ul>
<li> <p>Creates a child process, by calling <a href="process.html#method-c-spawn"><code>Process.spawn</code></a> with the given arguments.</p> </li>
<li> <p>Creates streams <code>stdin</code>, <code>stdout</code>, and <code>stderr</code>, which are the standard input, standard output, and standard error streams in the child process.</p> </li>
<li> <p>Creates thread <code>wait_thread</code> that waits for the child process to exit; the thread has method <code>pid</code>, which returns the process ID of the child process.</p> </li>
</ul> <p>With no block given, returns the array <code>[stdin, stdout, stderr, wait_thread]</code>. The caller should close each of the three returned streams.</p> <pre class="ruby" data-language="ruby">stdin, stdout, stderr, wait_thread = Open3.popen3('echo')
# =&gt; [#&lt;IO:fd 8&gt;, #&lt;IO:fd 10&gt;, #&lt;IO:fd 12&gt;, #&lt;Process::Waiter:0x00007f58d5428f58 run&gt;]
stdin.close
stdout.close
stderr.close
wait_thread.pid   # =&gt; 2210481
wait_thread.value # =&gt; #&lt;Process::Status: pid 2210481 exit 0&gt;
</pre> <p>With a block given, calls the block with the four variables (three streams and the wait thread) and returns the block’s return value. The caller need not close the streams:</p> <pre class="ruby" data-language="ruby">Open3.popen3('echo') do |stdin, stdout, stderr, wait_thread|
  p stdin
  p stdout
  p stderr
  p wait_thread
  p wait_thread.pid
  p wait_thread.value
end
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">#&lt;IO:fd 6&gt;
#&lt;IO:fd 7&gt;
#&lt;IO:fd 9&gt;
#&lt;Process::Waiter:0x00007f58d53606e8 sleep&gt;
2211047
#&lt;Process::Status: pid 2211047 exit 0&gt;
</pre> <p>Like <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>, this method has potential security vulnerabilities if called with untrusted input; see <a href="command_injection_rdoc.html#label-Command+Injection">Command Injection</a>.</p> <p>Unlike <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>, this method waits for the child process to exit before returning, so the caller need not do so.</p> <p>If the first argument is a hash, it becomes leading argument <code>env</code> in the call to <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>; see <a href="process.html#module-Process-label-Execution+Environment">Execution Environment</a>.</p> <p>If the last argument is a hash, it becomes trailing argument <code>options</code> in the call to <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>; see <a href="process.html#module-Process-label-Execution+Options">Execution Options</a>.</p> <p>The single required argument is one of the following:</p> <ul>
<li> <p><code>command_line</code> if it is a string, and if it begins with a shell reserved word or special built-in, or if it contains one or more metacharacters.</p> </li>
<li> <p><code>exe_path</code> otherwise.</p> </li>
</ul> <p><strong>Argument <code>command_line</code></strong></p> <p>String argument <code>command_line</code> is a command line to be passed to a shell; it must begin with a shell reserved word, begin with a special built-in, or contain meta characters:</p> <pre class="ruby" data-language="ruby">Open3.popen3('if true; then echo "Foo"; fi') {|*args| p args } # Shell reserved word.
Open3.popen3('echo') {|*args| p args }                         # Built-in.
Open3.popen3('date &gt; date.tmp') {|*args| p args }              # Contains meta character.
</pre> <p>Output (similar for each call above):</p> <pre>[#&lt;IO:(closed)&gt;, #&lt;IO:(closed)&gt;, #&lt;IO:(closed)&gt;, #&lt;Process::Waiter:0x00007f58d52f28c8 dead&gt;]</pre> <p>The command line may also contain arguments and options for the command:</p> <pre class="ruby" data-language="ruby">Open3.popen3('echo "Foo"') { |i, o, e, t| o.gets }
"Foo\n"
</pre> <p><strong>Argument <code>exe_path</code></strong></p> <p>Argument <code>exe_path</code> is one of the following:</p> <ul>
<li> <p>The string path to an executable to be called.</p> </li>
<li> <p>A 2-element array containing the path to an executable and the string to be used as the name of the executing process.</p> </li>
</ul> <p>Example:</p> <pre class="ruby" data-language="ruby">Open3.popen3('/usr/bin/date') { |i, o, e, t| o.gets }
# =&gt; "Wed Sep 27 02:56:44 PM CDT 2023\n"
</pre> <p>Ruby invokes the executable directly, with no shell and no shell expansion:</p> <pre class="ruby" data-language="ruby">Open3.popen3('doesnt_exist') { |i, o, e, t| o.gets } # Raises Errno::ENOENT
</pre> <p>If one or more <code>args</code> is given, each is an argument or option to be passed to the executable:</p> <pre class="ruby" data-language="ruby">Open3.popen3('echo', 'C #') { |i, o, e, t| o.gets }
# =&gt; "C #\n"
Open3.popen3('echo', 'hello', 'world') { |i, o, e, t| o.gets }
# =&gt; "hello world\n"
</pre> <p>Take care to avoid deadlocks. Output streams <code>stdout</code> and <code>stderr</code> have fixed-size buffers, so reading extensively from one but not the other can cause a deadlock when the unread buffer fills. To avoid that, <code>stdout</code> and <code>stderr</code> should be read simultaneously (using threads or <a href="io.html#method-c-select"><code>IO.select</code></a>).</p> <p>Related:</p> <ul>
<li> <p><a href="open3.html#method-c-popen2"><code>Open3.popen2</code></a>: Makes the standard input and standard output streams of the child process available as separate streams, with no access to the standard error stream.</p> </li>
<li> <p><a href="open3.html#method-c-popen2e"><code>Open3.popen2e</code></a>: Makes the standard input and the merge of the standard output and standard error streams of the child process available as separate streams.</p> </li>
</ul> </div> </div> </section> <section id="private-instance-5Buntitled-5D-method-details" class="method-section anchor-link"> <header> <h3>Private Instance Methods</h3> </header> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-capture2"> <a href="#method-i-capture2" title="Link to this method"> <span class="method-callseq"> capture2([env, ] command_line, options = {}) → [stdout_s, status] </span> </a> </div> <div class="method-heading"> <a href="#method-i-capture2" title="Link to this method"> <span class="method-callseq"> capture2([env, ] exe_path, *args, options = {}) → [stdout_s, status] </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="capture2-source"> <pre class="ruby" data-language="ruby"># File lib/open3.rb, line 775
def capture2(*cmd)
  if Hash === cmd.last
    opts = cmd.pop.dup
  else
    opts = {}
  end

  stdin_data = opts.delete(:stdin_data)
  binmode = opts.delete(:binmode)

  popen2(*cmd, opts) {|i, o, t|
    if binmode
      i.binmode
      o.binmode
    end
    out_reader = Thread.new { o.read }
    if stdin_data
      begin
        if stdin_data.respond_to? :readpartial
          IO.copy_stream(stdin_data, i)
        else
          i.write stdin_data
        end
      rescue Errno::EPIPE
      end
    end
    i.close
    [out_reader.value, t.value]
  }
end</pre> </div>  <p>Basically a wrapper for <a href="open3.html#method-c-popen3"><code>Open3.popen3</code></a> that:</p> <ul>
<li> <p>Creates a child process, by calling <a href="open3.html#method-c-popen3"><code>Open3.popen3</code></a> with the given arguments (except for certain entries in hash <code>options</code>; see below).</p> </li>
<li> <p>Returns as string <code>stdout_s</code> the standard output of the child process.</p> </li>
<li> <p>Returns as <code>status</code> a <a href="process/status.html"><code>Process::Status</code></a> object that represents the exit status of the child process.</p> </li>
</ul> <p>Returns the array <code>[stdout_s, status]</code>:</p> <pre class="ruby" data-language="ruby">stdout_s, status = Open3.capture2('echo "Foo"')
# =&gt; ["Foo\n", #&lt;Process::Status: pid 2326047 exit 0&gt;]
</pre> <p>Like <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>, this method has potential security vulnerabilities if called with untrusted input; see <a href="command_injection_rdoc.html#label-Command+Injection">Command Injection</a>.</p> <p>Unlike <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>, this method waits for the child process to exit before returning, so the caller need not do so.</p> <p>If the first argument is a hash, it becomes leading argument <code>env</code> in the call to <a href="open3.html#method-c-popen3"><code>Open3.popen3</code></a>; see <a href="process.html#module-Process-label-Execution+Environment">Execution Environment</a>.</p> <p>If the last argument is a hash, it becomes trailing argument <code>options</code> in the call to <a href="open3.html#method-c-popen3"><code>Open3.popen3</code></a>; see <a href="process.html#module-Process-label-Execution+Options">Execution Options</a>.</p> <p>The hash <code>options</code> is given; two options have local effect in method <a href="open3.html#method-c-capture2"><code>Open3.capture2</code></a>:</p> <ul>
<li> <p>If entry <code>options[:stdin_data]</code> exists, the entry is removed and its string value is sent to the command’s standard input:</p> <pre class="ruby" data-language="ruby">Open3.capture2('tee', stdin_data: 'Foo')

# =&gt; ["Foo", #&lt;Process::Status: pid 2326087 exit 0&gt;]
</pre> </li>
<li> <p>If entry <code>options[:binmode]</code> exists, the entry is removed and the internal streams are set to binary mode.</p> </li>
</ul> <p>The single required argument is one of the following:</p> <ul>
<li> <p><code>command_line</code> if it is a string, and if it begins with a shell reserved word or special built-in, or if it contains one or more metacharacters.</p> </li>
<li> <p><code>exe_path</code> otherwise.</p> </li>
</ul> <p><strong>Argument <code>command_line</code></strong></p> <p>String argument <code>command_line</code> is a command line to be passed to a shell; it must begin with a shell reserved word, begin with a special built-in, or contain meta characters:</p> <pre class="ruby" data-language="ruby">Open3.capture2('if true; then echo "Foo"; fi') # Shell reserved word.
# =&gt; ["Foo\n", #&lt;Process::Status: pid 2326131 exit 0&gt;]
Open3.capture2('echo')                         # Built-in.
# =&gt; ["\n", #&lt;Process::Status: pid 2326139 exit 0&gt;]
Open3.capture2('date &gt; date.tmp')              # Contains meta character.
# =&gt; ["", #&lt;Process::Status: pid 2326174 exit 0&gt;]
</pre> <p>The command line may also contain arguments and options for the command:</p> <pre class="ruby" data-language="ruby">Open3.capture2('echo "Foo"')
# =&gt; ["Foo\n", #&lt;Process::Status: pid 2326183 exit 0&gt;]
</pre> <p><strong>Argument <code>exe_path</code></strong></p> <p>Argument <code>exe_path</code> is one of the following:</p> <ul>
<li> <p>The string path to an executable to be called.</p> </li>
<li> <p>A 2-element array containing the path to an executable and the string to be used as the name of the executing process.</p> </li>
</ul> <p>Example:</p> <pre class="ruby" data-language="ruby">Open3.capture2('/usr/bin/date')
# =&gt; ["Fri Sep 29 01:00:39 PM CDT 2023\n", #&lt;Process::Status: pid 2326222 exit 0&gt;]
</pre> <p>Ruby invokes the executable directly, with no shell and no shell expansion:</p> <pre class="ruby" data-language="ruby">Open3.capture2('doesnt_exist') # Raises Errno::ENOENT
</pre> <p>If one or more <code>args</code> is given, each is an argument or option to be passed to the executable:</p> <pre class="ruby" data-language="ruby">Open3.capture2('echo', 'C #')
# =&gt; ["C #\n", #&lt;Process::Status: pid 2326267 exit 0&gt;]
Open3.capture2('echo', 'hello', 'world')
# =&gt; ["hello world\n", #&lt;Process::Status: pid 2326299 exit 0&gt;]
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-capture2e"> <a href="#method-i-capture2e" title="Link to this method"> <span class="method-callseq"> capture2e([env, ] command_line, options = {}) → [stdout_and_stderr_s, status] </span> </a> </div> <div class="method-heading"> <a href="#method-i-capture2e" title="Link to this method"> <span class="method-callseq"> capture2e([env, ] exe_path, *args, options = {}) → [stdout_and_stderr_s, status] </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="capture2e-source"> <pre class="ruby" data-language="ruby"># File lib/open3.rb, line 902
def capture2e(*cmd)
  if Hash === cmd.last
    opts = cmd.pop.dup
  else
    opts = {}
  end

  stdin_data = opts.delete(:stdin_data)
  binmode = opts.delete(:binmode)

  popen2e(*cmd, opts) {|i, oe, t|
    if binmode
      i.binmode
      oe.binmode
    end
    outerr_reader = Thread.new { oe.read }
    if stdin_data
      begin
        if stdin_data.respond_to? :readpartial
          IO.copy_stream(stdin_data, i)
        else
          i.write stdin_data
        end
      rescue Errno::EPIPE
      end
    end
    i.close
    [outerr_reader.value, t.value]
  }
end</pre> </div>  <p>Basically a wrapper for <a href="open3.html#method-c-popen3"><code>Open3.popen3</code></a> that:</p> <ul>
<li> <p>Creates a child process, by calling <a href="open3.html#method-c-popen3"><code>Open3.popen3</code></a> with the given arguments (except for certain entries in hash <code>options</code>; see below).</p> </li>
<li> <p>Returns as string <code>stdout_and_stderr_s</code> the merged standard output and standard error of the child process.</p> </li>
<li> <p>Returns as <code>status</code> a <a href="process/status.html"><code>Process::Status</code></a> object that represents the exit status of the child process.</p> </li>
</ul> <p>Returns the array <code>[stdout_and_stderr_s, status]</code>:</p> <pre class="ruby" data-language="ruby">stdout_and_stderr_s, status = Open3.capture2e('echo "Foo"')
# =&gt; ["Foo\n", #&lt;Process::Status: pid 2371692 exit 0&gt;]
</pre> <p>Like <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>, this method has potential security vulnerabilities if called with untrusted input; see <a href="command_injection_rdoc.html#label-Command+Injection">Command Injection</a>.</p> <p>Unlike <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>, this method waits for the child process to exit before returning, so the caller need not do so.</p> <p>If the first argument is a hash, it becomes leading argument <code>env</code> in the call to <a href="open3.html#method-c-popen3"><code>Open3.popen3</code></a>; see <a href="process.html#module-Process-label-Execution+Environment">Execution Environment</a>.</p> <p>If the last argument is a hash, it becomes trailing argument <code>options</code> in the call to <a href="open3.html#method-c-popen3"><code>Open3.popen3</code></a>; see <a href="process.html#module-Process-label-Execution+Options">Execution Options</a>.</p> <p>The hash <code>options</code> is given; two options have local effect in method <a href="open3.html#method-c-capture2e"><code>Open3.capture2e</code></a>:</p> <ul>
<li> <p>If entry <code>options[:stdin_data]</code> exists, the entry is removed and its string value is sent to the command’s standard input:</p> <pre class="ruby" data-language="ruby">Open3.capture2e('tee', stdin_data: 'Foo')
# =&gt; ["Foo", #&lt;Process::Status: pid 2371732 exit 0&gt;]
</pre> </li>
<li> <p>If entry <code>options[:binmode]</code> exists, the entry is removed and the internal streams are set to binary mode.</p> </li>
</ul> <p>The single required argument is one of the following:</p> <ul>
<li> <p><code>command_line</code> if it is a string, and if it begins with a shell reserved word or special built-in, or if it contains one or more metacharacters.</p> </li>
<li> <p><code>exe_path</code> otherwise.</p> </li>
</ul> <p><strong>Argument <code>command_line</code></strong></p> <p>String argument <code>command_line</code> is a command line to be passed to a shell; it must begin with a shell reserved word, begin with a special built-in, or contain meta characters:</p> <pre class="ruby" data-language="ruby">Open3.capture2e('if true; then echo "Foo"; fi') # Shell reserved word.
# =&gt; ["Foo\n", #&lt;Process::Status: pid 2371740 exit 0&gt;]
Open3.capture2e('echo')                         # Built-in.
# =&gt; ["\n", #&lt;Process::Status: pid 2371774 exit 0&gt;]
Open3.capture2e('date &gt; date.tmp')              # Contains meta character.
# =&gt; ["", #&lt;Process::Status: pid 2371812 exit 0&gt;]
</pre> <p>The command line may also contain arguments and options for the command:</p> <pre class="ruby" data-language="ruby">Open3.capture2e('echo "Foo"')
# =&gt; ["Foo\n", #&lt;Process::Status: pid 2326183 exit 0&gt;]
</pre> <p><strong>Argument <code>exe_path</code></strong></p> <p>Argument <code>exe_path</code> is one of the following:</p> <ul>
<li> <p>The string path to an executable to be called.</p> </li>
<li> <p>A 2-element array containing the path to an executable and the string to be used as the name of the executing process.</p> </li>
</ul> <p>Example:</p> <pre class="ruby" data-language="ruby">Open3.capture2e('/usr/bin/date')
# =&gt; ["Sat Sep 30 09:01:46 AM CDT 2023\n", #&lt;Process::Status: pid 2371820 exit 0&gt;]
</pre> <p>Ruby invokes the executable directly, with no shell and no shell expansion:</p> <pre class="ruby" data-language="ruby">Open3.capture2e('doesnt_exist') # Raises Errno::ENOENT
</pre> <p>If one or more <code>args</code> is given, each is an argument or option to be passed to the executable:</p> <pre class="ruby" data-language="ruby">Open3.capture2e('echo', 'C #')
# =&gt; ["C #\n", #&lt;Process::Status: pid 2371856 exit 0&gt;]
Open3.capture2e('echo', 'hello', 'world')
# =&gt; ["hello world\n", #&lt;Process::Status: pid 2371894 exit 0&gt;]
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-capture3"> <a href="#method-i-capture3" title="Link to this method"> <span class="method-callseq"> capture3([env, ] command_line, options = {}) → [stdout_s, stderr_s, status] </span> </a> </div> <div class="method-heading"> <a href="#method-i-capture3" title="Link to this method"> <span class="method-callseq"> capture3([env, ] exe_path, *args, options = {}) → [stdout_s, stderr_s, status] </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="capture3-source"> <pre class="ruby" data-language="ruby"># File lib/open3.rb, line 648
def capture3(*cmd)
  if Hash === cmd.last
    opts = cmd.pop.dup
  else
    opts = {}
  end

  stdin_data = opts.delete(:stdin_data) || ''
  binmode = opts.delete(:binmode)

  popen3(*cmd, opts) {|i, o, e, t|
    if binmode
      i.binmode
      o.binmode
      e.binmode
    end
    out_reader = Thread.new { o.read }
    err_reader = Thread.new { e.read }
    begin
      if stdin_data.respond_to? :readpartial
        IO.copy_stream(stdin_data, i)
      else
        i.write stdin_data
      end
    rescue Errno::EPIPE
    end
    i.close
    [out_reader.value, err_reader.value, t.value]
  }
end</pre> </div>  <p>Basically a wrapper for <a href="open3.html#method-c-popen3"><code>Open3.popen3</code></a> that:</p> <ul>
<li> <p>Creates a child process, by calling <a href="open3.html#method-c-popen3"><code>Open3.popen3</code></a> with the given arguments (except for certain entries in hash <code>options</code>; see below).</p> </li>
<li> <p>Returns as strings <code>stdout_s</code> and <code>stderr_s</code> the standard output and standard error of the child process.</p> </li>
<li> <p>Returns as <code>status</code> a <a href="process/status.html"><code>Process::Status</code></a> object that represents the exit status of the child process.</p> </li>
</ul> <p>Returns the array <code>[stdout_s, stderr_s, status]</code>:</p> <pre class="ruby" data-language="ruby">stdout_s, stderr_s, status = Open3.capture3('echo "Foo"')
# =&gt; ["Foo\n", "", #&lt;Process::Status: pid 2281954 exit 0&gt;]
</pre> <p>Like <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>, this method has potential security vulnerabilities if called with untrusted input; see <a href="command_injection_rdoc.html#label-Command+Injection">Command Injection</a>.</p> <p>Unlike <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>, this method waits for the child process to exit before returning, so the caller need not do so.</p> <p>If the first argument is a hash, it becomes leading argument <code>env</code> in the call to <a href="open3.html#method-c-popen3"><code>Open3.popen3</code></a>; see <a href="process.html#module-Process-label-Execution+Environment">Execution Environment</a>.</p> <p>If the last argument is a hash, it becomes trailing argument <code>options</code> in the call to <a href="open3.html#method-c-popen3"><code>Open3.popen3</code></a>; see <a href="process.html#module-Process-label-Execution+Options">Execution Options</a>.</p> <p>The hash <code>options</code> is given; two options have local effect in method <a href="open3.html#method-c-capture3"><code>Open3.capture3</code></a>:</p> <ul>
<li> <p>If entry <code>options[:stdin_data]</code> exists, the entry is removed and its string value is sent to the command’s standard input:</p> <pre class="ruby" data-language="ruby">Open3.capture3('tee', stdin_data: 'Foo')
# =&gt; ["Foo", "", #&lt;Process::Status: pid 2319575 exit 0&gt;]
</pre> </li>
<li> <p>If entry <code>options[:binmode]</code> exists, the entry is removed and the internal streams are set to binary mode.</p> </li>
</ul> <p>The single required argument is one of the following:</p> <ul>
<li> <p><code>command_line</code> if it is a string, and if it begins with a shell reserved word or special built-in, or if it contains one or more metacharacters.</p> </li>
<li> <p><code>exe_path</code> otherwise.</p> </li>
</ul> <p><strong>Argument <code>command_line</code></strong></p> <p>String argument <code>command_line</code> is a command line to be passed to a shell; it must begin with a shell reserved word, begin with a special built-in, or contain meta characters:</p> <pre class="ruby" data-language="ruby">Open3.capture3('if true; then echo "Foo"; fi') # Shell reserved word.
# =&gt; ["Foo\n", "", #&lt;Process::Status: pid 2282025 exit 0&gt;]
Open3.capture3('echo')                         # Built-in.
# =&gt; ["\n", "", #&lt;Process::Status: pid 2282092 exit 0&gt;]
Open3.capture3('date &gt; date.tmp')              # Contains meta character.
# =&gt; ["", "", #&lt;Process::Status: pid 2282110 exit 0&gt;]
</pre> <p>The command line may also contain arguments and options for the command:</p> <pre class="ruby" data-language="ruby">Open3.capture3('echo "Foo"')
# =&gt; ["Foo\n", "", #&lt;Process::Status: pid 2282092 exit 0&gt;]
</pre> <p><strong>Argument <code>exe_path</code></strong></p> <p>Argument <code>exe_path</code> is one of the following:</p> <ul>
<li> <p>The string path to an executable to be called.</p> </li>
<li> <p>A 2-element array containing the path to an executable and the string to be used as the name of the executing process.</p> </li>
</ul> <p>Example:</p> <pre class="ruby" data-language="ruby">Open3.capture3('/usr/bin/date')
# =&gt; ["Thu Sep 28 05:03:51 PM CDT 2023\n", "", #&lt;Process::Status: pid 2282300 exit 0&gt;]
</pre> <p>Ruby invokes the executable directly, with no shell and no shell expansion:</p> <pre class="ruby" data-language="ruby">Open3.capture3('doesnt_exist') # Raises Errno::ENOENT
</pre> <p>If one or more <code>args</code> is given, each is an argument or option to be passed to the executable:</p> <pre class="ruby" data-language="ruby">Open3.capture3('echo', 'C #')
# =&gt; ["C #\n", "", #&lt;Process::Status: pid 2282368 exit 0&gt;]
Open3.capture3('echo', 'hello', 'world')
# =&gt; ["hello world\n", "", #&lt;Process::Status: pid 2282372 exit 0&gt;]
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-pipeline"> <a href="#method-i-pipeline" title="Link to this method"> <span class="method-callseq"> pipeline([env, ] *cmds, options = {}) → array_of_statuses </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="pipeline-source"> <pre class="ruby" data-language="ruby"># File lib/open3.rb, line 1334
def pipeline(*cmds)
  if Hash === cmds.last
    opts = cmds.pop.dup
  else
    opts = {}
  end

  pipeline_run(cmds, opts, [], []) {|ts|
    ts.map(&amp;:value)
  }
end</pre> </div>  <p>Basically a wrapper for <a href="process.html#method-c-spawn"><code>Process.spawn</code></a> that:</p> <ul>
<li> <p>Creates a child process for each of the given <code>cmds</code> by calling <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>.</p> </li>
<li> <p>Pipes the <code>stdout</code> from each child to the <code>stdin</code> of the next child, or, for the last child, to the caller’s <code>stdout</code>.</p> </li>
<li> <p>Waits for the child processes to exit.</p> </li>
<li> <p>Returns an array of <a href="process/status.html"><code>Process::Status</code></a> objects (one for each child).</p> </li>
</ul> <p>Example:</p> <pre class="ruby" data-language="ruby">wait_threads = Open3.pipeline('ls', 'grep R')
# =&gt; [#&lt;Process::Status: pid 2139200 exit 0&gt;, #&lt;Process::Status: pid 2139202 exit 0&gt;]
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">Rakefile
README.md
</pre> <p>Like <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>, this method has potential security vulnerabilities if called with untrusted input; see <a href="command_injection_rdoc.html#label-Command+Injection">Command Injection</a>.</p> <p>If the first argument is a hash, it becomes leading argument <code>env</code> in each call to <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>; see <a href="process.html#module-Process-label-Execution+Environment">Execution Environment</a>.</p> <p>If the last argument is a hash, it becomes trailing argument <code>options</code> in each call to <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>‘ see <a href="process.html#module-Process-label-Execution+Options">Execution Options</a>.</p> <p>Each remaining argument in <code>cmds</code> is one of:</p> <ul>
<li> <p>A <code>command_line</code>: a string that begins with a shell reserved word or special built-in, or contains one or more metacharacters.</p> </li>
<li> <p>An <code>exe_path</code>: the string path to an executable to be called.</p> </li>
<li> <p>An array containing a <code>command_line</code> or an <code>exe_path</code>, along with zero or more string arguments for the command.</p> </li>
</ul> <p>See <a href="process.html#module-Process-label-Argument+command_line+or+exe_path">Argument command_line or exe_path</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-pipeline_r"> <a href="#method-i-pipeline_r" title="Link to this method"> <span class="method-callseq"> pipeline_r([env, ] *cmds, options = {}) → [last_stdout, wait_threads] </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="pipeline_r-source"> <pre class="ruby" data-language="ruby"># File lib/open3.rb, line 1104
def pipeline_r(*cmds, &amp;block)
  if Hash === cmds.last
    opts = cmds.pop.dup
  else
    opts = {}
  end

  out_r, out_w = IO.pipe
  opts[:out] = out_w

  pipeline_run(cmds, opts, [out_w], [out_r], &amp;block)
end</pre> </div>  <p>Basically a wrapper for <a href="process.html#method-c-spawn"><code>Process.spawn</code></a> that:</p> <ul>
<li> <p>Creates a child process for each of the given <code>cmds</code> by calling <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>.</p> </li>
<li> <p>Pipes the <code>stdout</code> from each child to the <code>stdin</code> of the next child, or, for the last child, to the caller’s <code>stdout</code>.</p> </li>
</ul> <p>The method does not wait for child processes to exit, so the caller must do so.</p> <p>With no block given, returns a 2-element array containing:</p> <ul>
<li> <p>The <code>stdout</code> stream of the last child process.</p> </li>
<li> <p>An array of the wait threads for all of the child processes.</p> </li>
</ul> <p>Example:</p> <pre class="ruby" data-language="ruby">last_stdout, wait_threads = Open3.pipeline_r('ls', 'grep R')
# =&gt; [#&lt;IO:fd 5&gt;, [#&lt;Process::Waiter:0x000055e8de2f9898 dead&gt;, #&lt;Process::Waiter:0x000055e8de2f94b0 sleep&gt;]]
puts last_stdout.read
wait_threads.each do |wait_thread|
  wait_thread.join
end
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">Rakefile
README.md
</pre> <p>With a block given, calls the block with the <code>stdout</code> stream of the last child process, and an array of the wait processes:</p> <pre class="ruby" data-language="ruby">Open3.pipeline_r('ls', 'grep R') do |last_stdout, wait_threads|
  puts last_stdout.read
  wait_threads.each do |wait_thread|
    wait_thread.join
  end
end
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">Rakefile
README.md
</pre> <p>Like <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>, this method has potential security vulnerabilities if called with untrusted input; see <a href="command_injection_rdoc.html#label-Command+Injection">Command Injection</a>.</p> <p>If the first argument is a hash, it becomes leading argument <code>env</code> in each call to <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>; see <a href="process.html#module-Process-label-Execution+Environment">Execution Environment</a>.</p> <p>If the last argument is a hash, it becomes trailing argument <code>options</code> in each call to <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>; see <a href="process.html#module-Process-label-Execution+Options">Execution Options</a>.</p> <p>Each remaining argument in <code>cmds</code> is one of:</p> <ul>
<li> <p>A <code>command_line</code>: a string that begins with a shell reserved word or special built-in, or contains one or more metacharacters.</p> </li>
<li> <p>An <code>exe_path</code>: the string path to an executable to be called.</p> </li>
<li> <p>An array containing a <code>command_line</code> or an <code>exe_path</code>, along with zero or more string arguments for the command.</p> </li>
</ul> <p>See <a href="process.html#module-Process-label-Argument+command_line+or+exe_path">Argument command_line or exe_path</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-pipeline_rw"> <a href="#method-i-pipeline_rw" title="Link to this method"> <span class="method-callseq"> pipeline_rw([env, ] *cmds, options = {}) → [first_stdin, last_stdout, wait_threads] </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="pipeline_rw-source"> <pre class="ruby" data-language="ruby"># File lib/open3.rb, line 1014
def pipeline_rw(*cmds, &amp;block)
  if Hash === cmds.last
    opts = cmds.pop.dup
  else
    opts = {}
  end

  in_r, in_w = IO.pipe
  opts[:in] = in_r
  in_w.sync = true

  out_r, out_w = IO.pipe
  opts[:out] = out_w

  pipeline_run(cmds, opts, [in_r, out_w], [in_w, out_r], &amp;block)
end</pre> </div>  <p>Basically a wrapper for <a href="process.html#method-c-spawn"><code>Process.spawn</code></a> that:</p> <ul>
<li> <p>Creates a child process for each of the given <code>cmds</code> by calling <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>.</p> </li>
<li> <p>Pipes the <code>stdout</code> from each child to the <code>stdin</code> of the next child, or, for the first child, from the caller’s <code>stdin</code>, or, for the last child, to the caller’s <code>stdout</code>.</p> </li>
</ul> <p>The method does not wait for child processes to exit, so the caller must do so.</p> <p>With no block given, returns a 3-element array containing:</p> <ul>
<li> <p>The <code>stdin</code> stream of the first child process.</p> </li>
<li> <p>The <code>stdout</code> stream of the last child process.</p> </li>
<li> <p>An array of the wait threads for all of the child processes.</p> </li>
</ul> <p>Example:</p> <pre class="ruby" data-language="ruby">first_stdin, last_stdout, wait_threads = Open3.pipeline_rw('sort', 'cat -n')
# =&gt; [#&lt;IO:fd 20&gt;, #&lt;IO:fd 21&gt;, [#&lt;Process::Waiter:0x000055e8de29ab40 sleep&gt;, #&lt;Process::Waiter:0x000055e8de29a690 sleep&gt;]]
first_stdin.puts("foo\nbar\nbaz")
first_stdin.close # Send EOF to sort.
puts last_stdout.read
wait_threads.each do |wait_thread|
  wait_thread.join
end
</pre> <p>Output:</p> <pre>1 bar
2 baz
3 foo</pre> <p>With a block given, calls the block with the <code>stdin</code> stream of the first child, the <code>stdout</code> stream of the last child, and an array of the wait processes:</p> <pre class="ruby" data-language="ruby">Open3.pipeline_rw('sort', 'cat -n') do |first_stdin, last_stdout, wait_threads|
  first_stdin.puts "foo\nbar\nbaz"
  first_stdin.close # send EOF to sort.
  puts last_stdout.read
  wait_threads.each do |wait_thread|
    wait_thread.join
  end
end
</pre> <p>Output:</p> <pre>1 bar
2 baz
3 foo</pre> <p>Like <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>, this method has potential security vulnerabilities if called with untrusted input; see <a href="command_injection_rdoc.html#label-Command+Injection">Command Injection</a>.</p> <p>If the first argument is a hash, it becomes leading argument <code>env</code> in each call to <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>; see <a href="process.html#module-Process-label-Execution+Environment">Execution Environment</a>.</p> <p>If the last argument is a hash, it becomes trailing argument <code>options</code> in each call to <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>; see <a href="process.html#module-Process-label-Execution+Options">Execution Options</a>.</p> <p>Each remaining argument in <code>cmds</code> is one of:</p> <ul>
<li> <p>A <code>command_line</code>: a string that begins with a shell reserved word or special built-in, or contains one or more metacharacters.</p> </li>
<li> <p>An <code>exe_path</code>: the string path to an executable to be called.</p> </li>
<li> <p>An array containing a <code>command_line</code> or an <code>exe_path</code>, along with zero or more string arguments for the command.</p> </li>
</ul> <p>See <a href="process.html#module-Process-label-Argument+command_line+or+exe_path">Argument command_line or exe_path</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-pipeline_start"> <a href="#method-i-pipeline_start" title="Link to this method"> <span class="method-callseq"> pipeline_start([env, ] *cmds, options = {}) → [wait_threads] </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="pipeline_start-source"> <pre class="ruby" data-language="ruby"># File lib/open3.rb, line 1272
def pipeline_start(*cmds, &amp;block)
  if Hash === cmds.last
    opts = cmds.pop.dup
  else
    opts = {}
  end

  if block
    pipeline_run(cmds, opts, [], [], &amp;block)
  else
    ts, = pipeline_run(cmds, opts, [], [])
    ts
  end
end</pre> </div>  <p>Basically a wrapper for <a href="process.html#method-c-spawn"><code>Process.spawn</code></a> that:</p> <ul>
<li> <p>Creates a child process for each of the given <code>cmds</code> by calling <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>.</p> </li>
<li> <p>Does not wait for child processes to exit.</p> </li>
</ul> <p>With no block given, returns an array of the wait threads for all of the child processes.</p> <p>Example:</p> <pre class="ruby" data-language="ruby">wait_threads = Open3.pipeline_start('ls', 'grep R')
# =&gt; [#&lt;Process::Waiter:0x000055e8de9d2bb0 run&gt;, #&lt;Process::Waiter:0x000055e8de9d2890 run&gt;]
wait_threads.each do |wait_thread|
  wait_thread.join
end
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">Rakefile
README.md
</pre> <p>With a block given, calls the block with an array of the wait processes:</p> <pre class="ruby" data-language="ruby">Open3.pipeline_start('ls', 'grep R') do |wait_threads|
  wait_threads.each do |wait_thread|
    wait_thread.join
  end
end
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">Rakefile
README.md
</pre> <p>Like <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>, this method has potential security vulnerabilities if called with untrusted input; see <a href="command_injection_rdoc.html#label-Command+Injection">Command Injection</a>.</p> <p>If the first argument is a hash, it becomes leading argument <code>env</code> in each call to <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>; see <a href="process.html#module-Process-label-Execution+Environment">Execution Environment</a>.</p> <p>If the last argument is a hash, it becomes trailing argument <code>options</code> in each call to <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>; see <a href="process.html#module-Process-label-Execution+Options">Execution Options</a>.</p> <p>Each remaining argument in <code>cmds</code> is one of:</p> <ul>
<li> <p>A <code>command_line</code>: a string that begins with a shell reserved word or special built-in, or contains one or more metacharacters.</p> </li>
<li> <p>An <code>exe_path</code>: the string path to an executable to be called.</p> </li>
<li> <p>An array containing a <code>command_line</code> or an <code>exe_path</code>, along with zero or more string arguments for the command.</p> </li>
</ul> <p>See <a href="process.html#module-Process-label-Argument+command_line+or+exe_path">Argument command_line or exe_path</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-pipeline_w"> <a href="#method-i-pipeline_w" title="Link to this method"> <span class="method-callseq"> pipeline_w([env, ] *cmds, options = {}) → [first_stdin, wait_threads] </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="pipeline_w-source"> <pre class="ruby" data-language="ruby"># File lib/open3.rb, line 1195
def pipeline_w(*cmds, &amp;block)
  if Hash === cmds.last
    opts = cmds.pop.dup
  else
    opts = {}
  end

  in_r, in_w = IO.pipe
  opts[:in] = in_r
  in_w.sync = true

  pipeline_run(cmds, opts, [in_r], [in_w], &amp;block)
end</pre> </div>  <p>Basically a wrapper for <a href="process.html#method-c-spawn"><code>Process.spawn</code></a> that:</p> <ul>
<li> <p>Creates a child process for each of the given <code>cmds</code> by calling <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>.</p> </li>
<li> <p>Pipes the <code>stdout</code> from each child to the <code>stdin</code> of the next child, or, for the first child, pipes the caller’s <code>stdout</code> to the child’s <code>stdin</code>.</p> </li>
</ul> <p>The method does not wait for child processes to exit, so the caller must do so.</p> <p>With no block given, returns a 2-element array containing:</p> <ul>
<li> <p>The <code>stdin</code> stream of the first child process.</p> </li>
<li> <p>An array of the wait threads for all of the child processes.</p> </li>
</ul> <p>Example:</p> <pre class="ruby" data-language="ruby">first_stdin, wait_threads = Open3.pipeline_w('sort', 'cat -n')
# =&gt; [#&lt;IO:fd 7&gt;, [#&lt;Process::Waiter:0x000055e8de928278 run&gt;, #&lt;Process::Waiter:0x000055e8de923e80 run&gt;]]
first_stdin.puts("foo\nbar\nbaz")
first_stdin.close # Send EOF to sort.
wait_threads.each do |wait_thread|
  wait_thread.join
end
</pre> <p>Output:</p> <pre>1 bar
2 baz
3 foo</pre> <p>With a block given, calls the block with the <code>stdin</code> stream of the first child process, and an array of the wait processes:</p> <pre class="ruby" data-language="ruby">Open3.pipeline_w('sort', 'cat -n') do |first_stdin, wait_threads|
  first_stdin.puts("foo\nbar\nbaz")
  first_stdin.close # Send EOF to sort.
  wait_threads.each do |wait_thread|
    wait_thread.join
  end
end
</pre> <p>Output:</p> <pre>1 bar
2 baz
3 foo</pre> <p>Like <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>, this method has potential security vulnerabilities if called with untrusted input; see <a href="command_injection_rdoc.html#label-Command+Injection">Command Injection</a>.</p> <p>If the first argument is a hash, it becomes leading argument <code>env</code> in each call to <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>; see <a href="process.html#module-Process-label-Execution+Environment">Execution Environment</a>.</p> <p>If the last argument is a hash, it becomes trailing argument <code>options</code> in each call to <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>; see <a href="process.html#module-Process-label-Execution+Options">Execution Options</a>.</p> <p>Each remaining argument in <code>cmds</code> is one of:</p> <ul>
<li> <p>A <code>command_line</code>: a string that begins with a shell reserved word or special built-in, or contains one or more metacharacters.</p> </li>
<li> <p>An <code>exe_path</code>: the string path to an executable to be called.</p> </li>
<li> <p>An array containing a <code>command_line</code> or an <code>exe_path</code>, along with zero or more string arguments for the command.</p> </li>
</ul> <p>See <a href="process.html#module-Process-label-Argument+command_line+or+exe_path">Argument command_line or exe_path</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-popen2"> <a href="#method-i-popen2" title="Link to this method"> <span class="method-callseq"> popen2([env, ] command_line, options = {}) → [stdin, stdout, wait_thread] </span> </a> </div> <div class="method-heading"> <a href="#method-i-popen2" title="Link to this method"> <span class="method-callseq"> popen2([env, ] exe_path, *args, options = {}) → [stdin, stdout, wait_thread] </span> </a> </div> <div class="method-heading"> <a href="#method-i-popen2" title="Link to this method"> <span class="method-callseq"> popen2([env, ] command_line, options = {}) {|stdin, stdout, wait_thread| ... } → object </span> </a> </div> <div class="method-heading"> <a href="#method-i-popen2" title="Link to this method"> <span class="method-callseq"> popen2([env, ] exe_path, *args, options = {}) {|stdin, stdout, wait_thread| ... } → object </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="popen2-source"> <pre class="ruby" data-language="ruby"># File lib/open3.rb, line 365
def popen2(*cmd, &amp;block)
  if Hash === cmd.last
    opts = cmd.pop.dup
  else
    opts = {}
  end

  in_r, in_w = IO.pipe
  opts[:in] = in_r
  in_w.sync = true

  out_r, out_w = IO.pipe
  opts[:out] = out_w

  popen_run(cmd, opts, [in_r, out_w], [in_w, out_r], &amp;block)
end</pre> </div>  <p>Basically a wrapper for <a href="process.html#method-c-spawn"><code>Process.spawn</code></a> that:</p> <ul>
<li> <p>Creates a child process, by calling <a href="process.html#method-c-spawn"><code>Process.spawn</code></a> with the given arguments.</p> </li>
<li> <p>Creates streams <code>stdin</code> and <code>stdout</code>, which are the standard input and standard output streams in the child process.</p> </li>
<li> <p>Creates thread <code>wait_thread</code> that waits for the child process to exit; the thread has method <code>pid</code>, which returns the process ID of the child process.</p> </li>
</ul> <p>With no block given, returns the array <code>[stdin, stdout, wait_thread]</code>. The caller should close each of the two returned streams.</p> <pre class="ruby" data-language="ruby">stdin, stdout, wait_thread = Open3.popen2('echo')
# =&gt; [#&lt;IO:fd 6&gt;, #&lt;IO:fd 7&gt;, #&lt;Process::Waiter:0x00007f58d52dbe98 run&gt;]
stdin.close
stdout.close
wait_thread.pid   # =&gt; 2263572
wait_thread.value # =&gt; #&lt;Process::Status: pid 2263572 exit 0&gt;
</pre> <p>With a block given, calls the block with the three variables (two streams and the wait thread) and returns the block’s return value. The caller need not close the streams:</p> <pre class="ruby" data-language="ruby">Open3.popen2('echo') do |stdin, stdout, wait_thread|
  p stdin
  p stdout
  p wait_thread
  p wait_thread.pid
  p wait_thread.value
end
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">#&lt;IO:fd 6&gt;
#&lt;IO:fd 7&gt;
#&lt;Process::Waiter:0x00007f58d59a34b0 sleep&gt;
2263636
#&lt;Process::Status: pid 2263636 exit 0&gt;
</pre> <p>Like <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>, this method has potential security vulnerabilities if called with untrusted input; see <a href="command_injection_rdoc.html#label-Command+Injection">Command Injection</a>.</p> <p>Unlike <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>, this method waits for the child process to exit before returning, so the caller need not do so.</p> <p>If the first argument is a hash, it becomes leading argument <code>env</code> in the call to <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>; see <a href="process.html#module-Process-label-Execution+Environment">Execution Environment</a>.</p> <p>If the last argument is a hash, it becomes trailing argument <code>options</code> in the call to <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>; see <a href="process.html#module-Process-label-Execution+Options">Execution Options</a>.</p> <p>The single required argument is one of the following:</p> <ul>
<li> <p><code>command_line</code> if it is a string, and if it begins with a shell reserved word or special built-in, or if it contains one or more metacharacters.</p> </li>
<li> <p><code>exe_path</code> otherwise.</p> </li>
</ul> <p><strong>Argument <code>command_line</code></strong></p> <p>String argument <code>command_line</code> is a command line to be passed to a shell; it must begin with a shell reserved word, begin with a special built-in, or contain meta characters:</p> <pre class="ruby" data-language="ruby">Open3.popen2('if true; then echo "Foo"; fi') {|*args| p args } # Shell reserved word.
Open3.popen2('echo') {|*args| p args }                         # Built-in.
Open3.popen2('date &gt; date.tmp') {|*args| p args }              # Contains meta character.
</pre> <p>Output (similar for each call above):</p> <pre class="ruby" data-language="ruby"># =&gt; [#&lt;IO:(closed)&gt;, #&lt;IO:(closed)&gt;, #&lt;Process::Waiter:0x00007f7577dfe410 dead&gt;]
</pre> <p>The command line may also contain arguments and options for the command:</p> <pre class="ruby" data-language="ruby">Open3.popen2('echo "Foo"') { |i, o, t| o.gets }
"Foo\n"
</pre> <p><strong>Argument <code>exe_path</code></strong></p> <p>Argument <code>exe_path</code> is one of the following:</p> <ul>
<li> <p>The string path to an executable to be called.</p> </li>
<li> <p>A 2-element array containing the path to an executable and the string to be used as the name of the executing process.</p> </li>
</ul> <p>Example:</p> <pre class="ruby" data-language="ruby">Open3.popen2('/usr/bin/date') { |i, o, t| o.gets }
# =&gt; "Thu Sep 28 09:41:06 AM CDT 2023\n"
</pre> <p>Ruby invokes the executable directly, with no shell and no shell expansion:</p> <pre class="ruby" data-language="ruby">Open3.popen2('doesnt_exist') { |i, o, t| o.gets } # Raises Errno::ENOENT
</pre> <p>If one or more <code>args</code> is given, each is an argument or option to be passed to the executable:</p> <pre class="ruby" data-language="ruby">Open3.popen2('echo', 'C #') { |i, o, t| o.gets }
# =&gt; "C #\n"
Open3.popen2('echo', 'hello', 'world') { |i, o, t| o.gets }
# =&gt; "hello world\n"
</pre> <p>Related:</p> <ul>
<li> <p><a href="open3.html#method-c-popen2e"><code>Open3.popen2e</code></a>: Makes the standard input and the merge of the standard output and standard error streams of the child process available as separate streams.</p> </li>
<li> <p><a href="open3.html#method-c-popen3"><code>Open3.popen3</code></a>: Makes the standard input, standard output, and standard error streams of the child process available as separate streams.</p> </li>
</ul> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-popen2e"> <a href="#method-i-popen2e" title="Link to this method"> <span class="method-callseq"> popen2e([env, ] command_line, options = {}) → [stdin, stdout_and_stderr, wait_thread] </span> </a> </div> <div class="method-heading"> <a href="#method-i-popen2e" title="Link to this method"> <span class="method-callseq"> popen2e([env, ] exe_path, *args, options = {}) → [stdin, stdout_and_stderr, wait_thread] </span> </a> </div> <div class="method-heading"> <a href="#method-i-popen2e" title="Link to this method"> <span class="method-callseq"> popen2e([env, ] command_line, options = {}) {|stdin, stdout_and_stderr, wait_thread| ... } → object </span> </a> </div> <div class="method-heading"> <a href="#method-i-popen2e" title="Link to this method"> <span class="method-callseq"> popen2e([env, ] exe_path, *args, options = {}) {|stdin, stdout_and_stderr, wait_thread| ... } → object </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="popen2e-source"> <pre class="ruby" data-language="ruby"># File lib/open3.rb, line 508
def popen2e(*cmd, &amp;block)
  if Hash === cmd.last
    opts = cmd.pop.dup
  else
    opts = {}
  end

  in_r, in_w = IO.pipe
  opts[:in] = in_r
  in_w.sync = true

  out_r, out_w = IO.pipe
  opts[[:out, :err]] = out_w

  popen_run(cmd, opts, [in_r, out_w], [in_w, out_r], &amp;block)
ensure
  if block
    in_r.close
    in_w.close
    out_r.close
    out_w.close
  end
end</pre> </div>  <p>Basically a wrapper for <a href="process.html#method-c-spawn"><code>Process.spawn</code></a> that:</p> <ul>
<li> <p>Creates a child process, by calling <a href="process.html#method-c-spawn"><code>Process.spawn</code></a> with the given arguments.</p> </li>
<li> <p>Creates streams <code>stdin</code>, <code>stdout_and_stderr</code>, which are the standard input and the merge of the standard output and standard error streams in the child process.</p> </li>
<li> <p>Creates thread <code>wait_thread</code> that waits for the child process to exit; the thread has method <code>pid</code>, which returns the process ID of the child process.</p> </li>
</ul> <p>With no block given, returns the array <code>[stdin, stdout_and_stderr, wait_thread]</code>. The caller should close each of the two returned streams.</p> <pre class="ruby" data-language="ruby">stdin, stdout_and_stderr, wait_thread = Open3.popen2e('echo')
# =&gt; [#&lt;IO:fd 6&gt;, #&lt;IO:fd 7&gt;, #&lt;Process::Waiter:0x00007f7577da4398 run&gt;]
stdin.close
stdout_and_stderr.close
wait_thread.pid   # =&gt; 2274600
wait_thread.value # =&gt; #&lt;Process::Status: pid 2274600 exit 0&gt;
</pre> <p>With a block given, calls the block with the three variables (two streams and the wait thread) and returns the block’s return value. The caller need not close the streams:</p> <pre class="ruby" data-language="ruby">Open3.popen2e('echo') do |stdin, stdout_and_stderr, wait_thread|
  p stdin
  p stdout_and_stderr
  p wait_thread
  p wait_thread.pid
  p wait_thread.value
end
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">#&lt;IO:fd 6&gt;
#&lt;IO:fd 7&gt;
#&lt;Process::Waiter:0x00007f75777578c8 sleep&gt;
2274763
#&lt;Process::Status: pid 2274763 exit 0&gt;
</pre> <p>Like <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>, this method has potential security vulnerabilities if called with untrusted input; see <a href="command_injection_rdoc.html#label-Command+Injection">Command Injection</a>.</p> <p>Unlike <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>, this method waits for the child process to exit before returning, so the caller need not do so.</p> <p>If the first argument is a hash, it becomes leading argument <code>env</code> in the call to <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>; see <a href="process.html#module-Process-label-Execution+Environment">Execution Environment</a>.</p> <p>If the last argument is a hash, it becomes trailing argument <code>options</code> in the call to <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>; see <a href="process.html#module-Process-label-Execution+Options">Execution Options</a>.</p> <p>The single required argument is one of the following:</p> <ul>
<li> <p><code>command_line</code> if it is a string, and if it begins with a shell reserved word or special built-in, or if it contains one or more metacharacters.</p> </li>
<li> <p><code>exe_path</code> otherwise.</p> </li>
</ul> <p><strong>Argument <code>command_line</code></strong></p> <p>String argument <code>command_line</code> is a command line to be passed to a shell; it must begin with a shell reserved word, begin with a special built-in, or contain meta characters:</p> <pre class="ruby" data-language="ruby">Open3.popen2e('if true; then echo "Foo"; fi') {|*args| p args } # Shell reserved word.
Open3.popen2e('echo') {|*args| p args }                         # Built-in.
Open3.popen2e('date &gt; date.tmp') {|*args| p args }              # Contains meta character.
</pre> <p>Output (similar for each call above):</p> <pre class="ruby" data-language="ruby"># =&gt; [#&lt;IO:(closed)&gt;, #&lt;IO:(closed)&gt;, #&lt;Process::Waiter:0x00007f7577d8a1f0 dead&gt;]
</pre> <p>The command line may also contain arguments and options for the command:</p> <pre class="ruby" data-language="ruby">Open3.popen2e('echo "Foo"') { |i, o_and_e, t| o_and_e.gets }
"Foo\n"
</pre> <p><strong>Argument <code>exe_path</code></strong></p> <p>Argument <code>exe_path</code> is one of the following:</p> <ul>
<li> <p>The string path to an executable to be called.</p> </li>
<li> <p>A 2-element array containing the path to an executable and the string to be used as the name of the executing process.</p> </li>
</ul> <p>Example:</p> <pre class="ruby" data-language="ruby">Open3.popen2e('/usr/bin/date') { |i, o_and_e, t| o_and_e.gets }
# =&gt; "Thu Sep 28 01:58:45 PM CDT 2023\n"
</pre> <p>Ruby invokes the executable directly, with no shell and no shell expansion:</p> <pre class="ruby" data-language="ruby">Open3.popen2e('doesnt_exist') { |i, o_and_e, t| o_and_e.gets } # Raises Errno::ENOENT
</pre> <p>If one or more <code>args</code> is given, each is an argument or option to be passed to the executable:</p> <pre class="ruby" data-language="ruby">Open3.popen2e('echo', 'C #') { |i, o_and_e, t| o_and_e.gets }
# =&gt; "C #\n"
Open3.popen2e('echo', 'hello', 'world') { |i, o_and_e, t| o_and_e.gets }
# =&gt; "hello world\n"
</pre> <p>Related:</p> <ul>
<li> <p><a href="open3.html#method-c-popen2"><code>Open3.popen2</code></a>: Makes the standard input and standard output streams of the child process available as separate streams, with no access to the standard error stream.</p> </li>
<li> <p><a href="open3.html#method-c-popen3"><code>Open3.popen3</code></a>: Makes the standard input, standard output, and standard error streams of the child process available as separate streams.</p> </li>
</ul> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-popen3"> <a href="#method-i-popen3" title="Link to this method"> <span class="method-callseq"> popen3([env, ] command_line, options = {}) → [stdin, stdout, stderr, wait_thread] </span> </a> </div> <div class="method-heading"> <a href="#method-i-popen3" title="Link to this method"> <span class="method-callseq"> popen3([env, ] exe_path, *args, options = {}) → [stdin, stdout, stderr, wait_thread] </span> </a> </div> <div class="method-heading"> <a href="#method-i-popen3" title="Link to this method"> <span class="method-callseq"> popen3([env, ] command_line, options = {}) {|stdin, stdout, stderr, wait_thread| ... } → object </span> </a> </div> <div class="method-heading"> <a href="#method-i-popen3" title="Link to this method"> <span class="method-callseq"> popen3([env, ] exe_path, *args, options = {}) {|stdin, stdout, stderr, wait_thread| ... } → object </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="popen3-source"> <pre class="ruby" data-language="ruby"># File lib/open3.rb, line 218
def popen3(*cmd, &amp;block)
  if Hash === cmd.last
    opts = cmd.pop.dup
  else
    opts = {}
  end

  in_r, in_w = IO.pipe
  opts[:in] = in_r
  in_w.sync = true

  out_r, out_w = IO.pipe
  opts[:out] = out_w

  err_r, err_w = IO.pipe
  opts[:err] = err_w

  popen_run(cmd, opts, [in_r, out_w, err_w], [in_w, out_r, err_r], &amp;block)
end</pre> </div>  <p>Basically a wrapper for <a href="process.html#method-c-spawn"><code>Process.spawn</code></a> that:</p> <ul>
<li> <p>Creates a child process, by calling <a href="process.html#method-c-spawn"><code>Process.spawn</code></a> with the given arguments.</p> </li>
<li> <p>Creates streams <code>stdin</code>, <code>stdout</code>, and <code>stderr</code>, which are the standard input, standard output, and standard error streams in the child process.</p> </li>
<li> <p>Creates thread <code>wait_thread</code> that waits for the child process to exit; the thread has method <code>pid</code>, which returns the process ID of the child process.</p> </li>
</ul> <p>With no block given, returns the array <code>[stdin, stdout, stderr, wait_thread]</code>. The caller should close each of the three returned streams.</p> <pre class="ruby" data-language="ruby">stdin, stdout, stderr, wait_thread = Open3.popen3('echo')
# =&gt; [#&lt;IO:fd 8&gt;, #&lt;IO:fd 10&gt;, #&lt;IO:fd 12&gt;, #&lt;Process::Waiter:0x00007f58d5428f58 run&gt;]
stdin.close
stdout.close
stderr.close
wait_thread.pid   # =&gt; 2210481
wait_thread.value # =&gt; #&lt;Process::Status: pid 2210481 exit 0&gt;
</pre> <p>With a block given, calls the block with the four variables (three streams and the wait thread) and returns the block’s return value. The caller need not close the streams:</p> <pre class="ruby" data-language="ruby">Open3.popen3('echo') do |stdin, stdout, stderr, wait_thread|
  p stdin
  p stdout
  p stderr
  p wait_thread
  p wait_thread.pid
  p wait_thread.value
end
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">#&lt;IO:fd 6&gt;
#&lt;IO:fd 7&gt;
#&lt;IO:fd 9&gt;
#&lt;Process::Waiter:0x00007f58d53606e8 sleep&gt;
2211047
#&lt;Process::Status: pid 2211047 exit 0&gt;
</pre> <p>Like <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>, this method has potential security vulnerabilities if called with untrusted input; see <a href="command_injection_rdoc.html#label-Command+Injection">Command Injection</a>.</p> <p>Unlike <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>, this method waits for the child process to exit before returning, so the caller need not do so.</p> <p>If the first argument is a hash, it becomes leading argument <code>env</code> in the call to <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>; see <a href="process.html#module-Process-label-Execution+Environment">Execution Environment</a>.</p> <p>If the last argument is a hash, it becomes trailing argument <code>options</code> in the call to <a href="process.html#method-c-spawn"><code>Process.spawn</code></a>; see <a href="process.html#module-Process-label-Execution+Options">Execution Options</a>.</p> <p>The single required argument is one of the following:</p> <ul>
<li> <p><code>command_line</code> if it is a string, and if it begins with a shell reserved word or special built-in, or if it contains one or more metacharacters.</p> </li>
<li> <p><code>exe_path</code> otherwise.</p> </li>
</ul> <p><strong>Argument <code>command_line</code></strong></p> <p>String argument <code>command_line</code> is a command line to be passed to a shell; it must begin with a shell reserved word, begin with a special built-in, or contain meta characters:</p> <pre class="ruby" data-language="ruby">Open3.popen3('if true; then echo "Foo"; fi') {|*args| p args } # Shell reserved word.
Open3.popen3('echo') {|*args| p args }                         # Built-in.
Open3.popen3('date &gt; date.tmp') {|*args| p args }              # Contains meta character.
</pre> <p>Output (similar for each call above):</p> <pre>[#&lt;IO:(closed)&gt;, #&lt;IO:(closed)&gt;, #&lt;IO:(closed)&gt;, #&lt;Process::Waiter:0x00007f58d52f28c8 dead&gt;]</pre> <p>The command line may also contain arguments and options for the command:</p> <pre class="ruby" data-language="ruby">Open3.popen3('echo "Foo"') { |i, o, e, t| o.gets }
"Foo\n"
</pre> <p><strong>Argument <code>exe_path</code></strong></p> <p>Argument <code>exe_path</code> is one of the following:</p> <ul>
<li> <p>The string path to an executable to be called.</p> </li>
<li> <p>A 2-element array containing the path to an executable and the string to be used as the name of the executing process.</p> </li>
</ul> <p>Example:</p> <pre class="ruby" data-language="ruby">Open3.popen3('/usr/bin/date') { |i, o, e, t| o.gets }
# =&gt; "Wed Sep 27 02:56:44 PM CDT 2023\n"
</pre> <p>Ruby invokes the executable directly, with no shell and no shell expansion:</p> <pre class="ruby" data-language="ruby">Open3.popen3('doesnt_exist') { |i, o, e, t| o.gets } # Raises Errno::ENOENT
</pre> <p>If one or more <code>args</code> is given, each is an argument or option to be passed to the executable:</p> <pre class="ruby" data-language="ruby">Open3.popen3('echo', 'C #') { |i, o, e, t| o.gets }
# =&gt; "C #\n"
Open3.popen3('echo', 'hello', 'world') { |i, o, e, t| o.gets }
# =&gt; "hello world\n"
</pre> <p>Take care to avoid deadlocks. Output streams <code>stdout</code> and <code>stderr</code> have fixed-size buffers, so reading extensively from one but not the other can cause a deadlock when the unread buffer fills. To avoid that, <code>stdout</code> and <code>stderr</code> should be read simultaneously (using threads or <a href="io.html#method-c-select"><code>IO.select</code></a>).</p> <p>Related:</p> <ul>
<li> <p><a href="open3.html#method-c-popen2"><code>Open3.popen2</code></a>: Makes the standard input and standard output streams of the child process available as separate streams, with no access to the standard error stream.</p> </li>
<li> <p><a href="open3.html#method-c-popen2e"><code>Open3.popen2e</code></a>: Makes the standard input and the merge of the standard output and standard error streams of the child process available as separate streams.</p> </li>
</ul> </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core &copy; 1993&ndash;2024 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library &copy; contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>
