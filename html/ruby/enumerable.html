<h1 id="module-Enumerable" class="anchor-link module"> module Enumerable </h1> <section class="description"> <h2 id="module-Enumerable-label-What-27s+Here">What’s Here</h2> <p>Module Enumerable provides methods that are useful to a collection class for:</p> <ul>
<li> <p><a href="enumerable.html#module-Enumerable-label-Methods+for+Querying">Querying</a></p> </li>
<li> <p><a href="enumerable.html#module-Enumerable-label-Methods+for+Fetching">Fetching</a></p> </li>
<li> <p><a href="enumerable.html#module-Enumerable-label-Methods+for+Searching+and+Filtering">Searching and Filtering</a></p> </li>
<li> <p><a href="enumerable.html#module-Enumerable-label-Methods+for+Sorting">Sorting</a></p> </li>
<li> <p><a href="enumerable.html#module-Enumerable-label-Methods+for+Iterating">Iterating</a></p> </li>
<li> <p><a href="enumerable.html#module-Enumerable-label-Other+Methods">And more.…</a></p> </li>
</ul> <h3 id="module-Enumerable-label-Methods+for+Querying">Methods for Querying</h3> <p>These methods return information about the Enumerable other than the elements themselves:</p> <ul>
<li> <p><a href="enumerable.html#method-i-member-3F"><code>member?</code></a> (aliased as <a href="enumerable.html#method-i-include-3F"><code>include?</code></a>): Returns <code>true</code> if <code>self == object</code>, <code>false</code> otherwise.</p> </li>
<li> <p><a href="enumerable.html#method-i-all-3F"><code>all?</code></a>: Returns <code>true</code> if all elements meet a specified criterion; <code>false</code> otherwise.</p> </li>
<li> <p><a href="enumerable.html#method-i-any-3F"><code>any?</code></a>: Returns <code>true</code> if any element meets a specified criterion; <code>false</code> otherwise.</p> </li>
<li> <p><a href="enumerable.html#method-i-none-3F"><code>none?</code></a>: Returns <code>true</code> if no element meets a specified criterion; <code>false</code> otherwise.</p> </li>
<li> <p><a href="enumerable.html#method-i-one-3F"><code>one?</code></a>: Returns <code>true</code> if exactly one element meets a specified criterion; <code>false</code> otherwise.</p> </li>
<li> <p><a href="enumerable.html#method-i-count"><code>count</code></a>: Returns the count of elements, based on an argument or block criterion, if given.</p> </li>
<li> <p><a href="enumerable.html#method-i-tally"><code>tally</code></a>: Returns a new <a href="hash.html"><code>Hash</code></a> containing the counts of occurrences of each element.</p> </li>
</ul> <h3 id="module-Enumerable-label-Methods+for+Fetching">Methods for Fetching</h3> <p>These methods return entries from the Enumerable, without modifying it:</p> <p><em>Leading, trailing, or all elements</em>:</p> <ul>
<li> <p><a href="enumerable.html#method-i-to_a"><code>to_a</code></a> (aliased as <a href="enumerable.html#method-i-entries"><code>entries</code></a>): Returns all elements.</p> </li>
<li> <p><a href="enumerable.html#method-i-first"><code>first</code></a>: Returns the first element or leading elements.</p> </li>
<li> <p><a href="enumerable.html#method-i-take"><code>take</code></a>: Returns a specified number of leading elements.</p> </li>
<li> <p><a href="enumerable.html#method-i-drop"><code>drop</code></a>: Returns a specified number of trailing elements.</p> </li>
<li> <p><a href="enumerable.html#method-i-take_while"><code>take_while</code></a>: Returns leading elements as specified by the given block.</p> </li>
<li> <p><a href="enumerable.html#method-i-drop_while"><code>drop_while</code></a>: Returns trailing elements as specified by the given block.</p> </li>
</ul> <p><em>Minimum and maximum value elements</em>:</p> <ul>
<li> <p><a href="enumerable.html#method-i-min"><code>min</code></a>: Returns the elements whose values are smallest among the elements, as determined by &lt;=&gt; or a given block.</p> </li>
<li> <p><a href="enumerable.html#method-i-max"><code>max</code></a>: Returns the elements whose values are largest among the elements, as determined by &lt;=&gt; or a given block.</p> </li>
<li> <p><a href="enumerable.html#method-i-minmax"><code>minmax</code></a>: Returns a 2-element <a href="array.html"><code>Array</code></a> containing the smallest and largest elements.</p> </li>
<li> <p><a href="enumerable.html#method-i-min_by"><code>min_by</code></a>: Returns the smallest element, as determined by the given block.</p> </li>
<li> <p><a href="enumerable.html#method-i-max_by"><code>max_by</code></a>: Returns the largest element, as determined by the given block.</p> </li>
<li> <p><a href="enumerable.html#method-i-minmax_by"><code>minmax_by</code></a>: Returns the smallest and largest elements, as determined by the given block.</p> </li>
</ul> <p><em>Groups, slices, and partitions</em>:</p> <ul>
<li> <p><a href="enumerable.html#method-i-group_by"><code>group_by</code></a>: Returns a <a href="hash.html"><code>Hash</code></a> that partitions the elements into groups.</p> </li>
<li> <p><a href="enumerable.html#method-i-partition"><code>partition</code></a>: Returns elements partitioned into two new Arrays, as determined by the given block.</p> </li>
<li> <p><a href="enumerable.html#method-i-slice_after"><code>slice_after</code></a>: Returns a new <a href="enumerator.html"><code>Enumerator</code></a> whose entries are a partition of <code>self</code>, based either on a given <code>object</code> or a given block.</p> </li>
<li> <p><a href="enumerable.html#method-i-slice_before"><code>slice_before</code></a>: Returns a new <a href="enumerator.html"><code>Enumerator</code></a> whose entries are a partition of <code>self</code>, based either on a given <code>object</code> or a given block.</p> </li>
<li> <p><a href="enumerable.html#method-i-slice_when"><code>slice_when</code></a>: Returns a new <a href="enumerator.html"><code>Enumerator</code></a> whose entries are a partition of <code>self</code> based on the given block.</p> </li>
<li> <p><a href="enumerable.html#method-i-chunk"><code>chunk</code></a>: Returns elements organized into chunks as specified by the given block.</p> </li>
<li> <p><a href="enumerable.html#method-i-chunk_while"><code>chunk_while</code></a>: Returns elements organized into chunks as specified by the given block.</p> </li>
</ul> <h3 id="module-Enumerable-label-Methods+for+Searching+and+Filtering">Methods for Searching and Filtering</h3> <p>These methods return elements that meet a specified criterion:</p> <ul>
<li> <p><a href="enumerable.html#method-i-find"><code>find</code></a> (aliased as <a href="enumerable.html#method-i-detect"><code>detect</code></a>): Returns an element selected by the block.</p> </li>
<li> <p><a href="enumerable.html#method-i-find_all"><code>find_all</code></a> (aliased as <a href="enumerable.html#method-i-filter"><code>filter</code></a>, <a href="enumerable.html#method-i-select"><code>select</code></a>): Returns elements selected by the block.</p> </li>
<li> <p><a href="enumerable.html#method-i-find_index"><code>find_index</code></a>: Returns the index of an element selected by a given object or block.</p> </li>
<li> <p><a href="enumerable.html#method-i-reject"><code>reject</code></a>: Returns elements not rejected by the block.</p> </li>
<li> <p><a href="enumerable.html#method-i-uniq"><code>uniq</code></a>: Returns elements that are not duplicates.</p> </li>
</ul> <h3 id="module-Enumerable-label-Methods+for+Sorting">Methods for Sorting</h3> <p>These methods return elements in sorted order:</p> <ul>
<li> <p><a href="enumerable.html#method-i-sort"><code>sort</code></a>: Returns the elements, sorted by &lt;=&gt; or the given block.</p> </li>
<li> <p><a href="enumerable.html#method-i-sort_by"><code>sort_by</code></a>: Returns the elements, sorted by the given block.</p> </li>
</ul> <h3 id="module-Enumerable-label-Methods+for+Iterating">Methods for Iterating</h3> <ul>
<li> <p><a href="enumerable.html#method-i-each_entry"><code>each_entry</code></a>: Calls the block with each successive element (slightly different from each).</p> </li>
<li> <p><a href="enumerable.html#method-i-each_with_index"><code>each_with_index</code></a>: Calls the block with each successive element and its index.</p> </li>
<li> <p><a href="enumerable.html#method-i-each_with_object"><code>each_with_object</code></a>: Calls the block with each successive element and a given object.</p> </li>
<li> <p><a href="enumerable.html#method-i-each_slice"><code>each_slice</code></a>: Calls the block with successive non-overlapping slices.</p> </li>
<li> <p><a href="enumerable.html#method-i-each_cons"><code>each_cons</code></a>: Calls the block with successive overlapping slices. (different from <a href="enumerable.html#method-i-each_slice"><code>each_slice</code></a>).</p> </li>
<li> <p><a href="enumerable.html#method-i-reverse_each"><code>reverse_each</code></a>: Calls the block with each successive element, in reverse order.</p> </li>
</ul> <h3 id="module-Enumerable-label-Other+Methods">Other Methods</h3> <ul>
<li> <p><a href="enumerable.html#method-i-collect"><code>collect</code></a> (aliased as <a href="enumerable.html#method-i-map"><code>map</code></a>): Returns objects returned by the block.</p> </li>
<li> <p><a href="enumerable.html#method-i-filter_map"><code>filter_map</code></a>: Returns truthy objects returned by the block.</p> </li>
<li> <p><a href="enumerable.html#method-i-flat_map"><code>flat_map</code></a> (aliased as <a href="enumerable.html#method-i-collect_concat"><code>collect_concat</code></a>): Returns flattened objects returned by the block.</p> </li>
<li> <p><a href="enumerable.html#method-i-grep"><code>grep</code></a>: Returns elements selected by a given object or objects returned by a given block.</p> </li>
<li> <p><a href="enumerable.html#method-i-grep_v"><code>grep_v</code></a>: Returns elements selected by a given object or objects returned by a given block.</p> </li>
<li> <p><a href="enumerable.html#method-i-inject"><code>inject</code></a> (aliased as <a href="enumerable.html#method-i-reduce"><code>reduce</code></a>): Returns the object formed by combining all elements.</p> </li>
<li> <p><a href="enumerable.html#method-i-sum"><code>sum</code></a>: Returns the sum of the elements, using method <code>+</code>.</p> </li>
<li> <p><a href="enumerable.html#method-i-zip"><code>zip</code></a>: Combines each element with elements from other enumerables; returns the n-tuples or calls the block with each.</p> </li>
<li> <p><a href="enumerable.html#method-i-cycle"><code>cycle</code></a>: Calls the block with each element, cycling repeatedly.</p> </li>
</ul> <h2 id="module-Enumerable-label-Usage">Usage</h2> <p>To use module Enumerable in a collection class:</p> <ul>
<li> <p>Include it:</p> <pre class="ruby" data-language="ruby">include Enumerable
</pre> </li>
<li> <p>Implement method each which must yield successive elements of the collection. The method will be called by almost any Enumerable method.</p> </li>
</ul> <p>Example:</p> <pre class="ruby" data-language="ruby">class Foo
  include Enumerable
  def each
    yield 1
    yield 1, 2
    yield
  end
end
Foo.new.each_entry{ |element| p element }
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">1
[1, 2]
nil
</pre> <h2 id="module-Enumerable-label-Enumerable+in+Ruby+Classes">Enumerable in Ruby Classes</h2> <p>These Ruby core classes include (or extend) Enumerable:</p> <ul>
<li> <p><a href="argf.html"><code>ARGF</code></a></p> </li>
<li> <p><a href="array.html"><code>Array</code></a></p> </li>
<li> <p><a href="dir.html"><code>Dir</code></a></p> </li>
<li> <p><a href="enumerator.html"><code>Enumerator</code></a></p> </li>
<li> <p><a href="env.html"><code>ENV</code></a> (extends)</p> </li>
<li> <p><a href="hash.html"><code>Hash</code></a></p> </li>
<li> <p><a href="io.html"><code>IO</code></a></p> </li>
<li> <p><a href="range.html"><code>Range</code></a></p> </li>
<li> <p><a href="struct.html"><code>Struct</code></a></p> </li>
</ul> <p>These Ruby standard library classes include Enumerable:</p> <ul>
<li> <p>CSV</p> </li>
<li> <p>CSV::Table</p> </li>
<li> <p>CSV::Row</p> </li>
<li> <p><a href="set.html"><code>Set</code></a></p> </li>
</ul> <p>Virtually all methods in Enumerable call method each in the including class:</p> <ul>
<li> <p><a href="hash.html#method-i-each"><code>Hash#each</code></a> yields the next key-value pair as a 2-element <a href="array.html"><code>Array</code></a>.</p> </li>
<li> <p><a href="struct.html#method-i-each"><code>Struct#each</code></a> yields the next name-value pair as a 2-element <a href="array.html"><code>Array</code></a>.</p> </li>
<li> <p>For the other classes above, each yields the next object from the collection.</p> </li>
</ul> <h2 id="module-Enumerable-label-About+the+Examples">About the Examples</h2> <p>The example code snippets for the Enumerable methods:</p> <ul>
<li> <p>Always show the use of one or more Array-like classes (often <a href="array.html"><code>Array</code></a> itself).</p> </li>
<li> <p>Sometimes show the use of a Hash-like class. For some methods, though, the usage would not make sense, and so it is not shown. Example: <a href="enumerable.html#method-i-tally"><code>tally</code></a> would find exactly one of each <a href="hash.html"><code>Hash</code></a> entry.</p> </li>
</ul> </section> <section id="5Buntitled-5D" class="documentation-section anchor-link"> <section id="public-instance-5Buntitled-5D-method-details" class="method-section anchor-link"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-all-3F"> <a href="#method-i-all-3F" title="Link to this method"> <span class="method-callseq"> all? → true or false </span> </a> </div> <div class="method-heading"> <a href="#method-i-all-3F" title="Link to this method"> <span class="method-callseq"> all?(pattern) → true or false </span> </a> </div> <div class="method-heading"> <a href="#method-i-all-3F" title="Link to this method"> <span class="method-callseq"> all? {|element| ... } → true or false </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="all-3F-source"> <pre class="c" data-language="c">static VALUE
enum_all(int argc, VALUE *argv, VALUE obj)
{
    struct MEMO *memo = MEMO_ENUM_NEW(Qtrue);
    WARN_UNUSED_BLOCK(argc);
    ENUM_BLOCK_CALL(all);
    return memo-&gt;v1;
}</pre> </div>  <p>Returns whether every element meets a given criterion.</p> <p>If <code>self</code> has no element, returns <code>true</code> and argument or block are not used.</p> <p>With no argument and no block, returns whether every element is truthy:</p> <pre class="ruby" data-language="ruby">(1..4).all?           # =&gt; true
%w[a b c d].all?      # =&gt; true
[1, 2, nil].all?      # =&gt; false
['a','b', false].all? # =&gt; false
[].all?               # =&gt; true
</pre> <p>With argument <code>pattern</code> and no block, returns whether for each element <code>element</code>, <code>pattern === element</code>:</p> <pre class="ruby" data-language="ruby">(1..4).all?(Integer)                 # =&gt; true
(1..4).all?(Numeric)                 # =&gt; true
(1..4).all?(Float)                   # =&gt; false
%w[bar baz bat bam].all?(/ba/)       # =&gt; true
%w[bar baz bat bam].all?(/bar/)      # =&gt; false
%w[bar baz bat bam].all?('ba')       # =&gt; false
{foo: 0, bar: 1, baz: 2}.all?(Array) # =&gt; true
{foo: 0, bar: 1, baz: 2}.all?(Hash)  # =&gt; false
[].all?(Integer)                     # =&gt; true
</pre> <p>With a block given, returns whether the block returns a truthy value for every element:</p> <pre class="ruby" data-language="ruby">(1..4).all? {|element| element &lt; 5 }                    # =&gt; true
(1..4).all? {|element| element &lt; 4 }                    # =&gt; false
{foo: 0, bar: 1, baz: 2}.all? {|key, value| value &lt; 3 } # =&gt; true
{foo: 0, bar: 1, baz: 2}.all? {|key, value| value &lt; 2 } # =&gt; false
</pre> <p>Related: <a href="enumerable.html#method-i-any-3F"><code>any?</code></a>, <a href="enumerable.html#method-i-none-3F"><code>none?</code></a> <a href="enumerable.html#method-i-one-3F"><code>one?</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-any-3F"> <a href="#method-i-any-3F" title="Link to this method"> <span class="method-callseq"> any? → true or false </span> </a> </div> <div class="method-heading"> <a href="#method-i-any-3F" title="Link to this method"> <span class="method-callseq"> any?(pattern) → true or false </span> </a> </div> <div class="method-heading"> <a href="#method-i-any-3F" title="Link to this method"> <span class="method-callseq"> any? {|element| ... } → true or false </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="any-3F-source"> <pre class="c" data-language="c">static VALUE
enum_any(int argc, VALUE *argv, VALUE obj)
{
    struct MEMO *memo = MEMO_ENUM_NEW(Qfalse);
    WARN_UNUSED_BLOCK(argc);
    ENUM_BLOCK_CALL(any);
    return memo-&gt;v1;
}</pre> </div>  <p>Returns whether any element meets a given criterion.</p> <p>If <code>self</code> has no element, returns <code>false</code> and argument or block are not used.</p> <p>With no argument and no block, returns whether any element is truthy:</p> <pre class="ruby" data-language="ruby">(1..4).any?          # =&gt; true
%w[a b c d].any?     # =&gt; true
[1, false, nil].any? # =&gt; true
[].any?              # =&gt; false
</pre> <p>With argument <code>pattern</code> and no block, returns whether for any element <code>element</code>, <code>pattern === element</code>:</p> <pre class="ruby" data-language="ruby">[nil, false, 0].any?(Integer)        # =&gt; true
[nil, false, 0].any?(Numeric)        # =&gt; true
[nil, false, 0].any?(Float)          # =&gt; false
%w[bar baz bat bam].any?(/m/)        # =&gt; true
%w[bar baz bat bam].any?(/foo/)      # =&gt; false
%w[bar baz bat bam].any?('ba')       # =&gt; false
{foo: 0, bar: 1, baz: 2}.any?(Array) # =&gt; true
{foo: 0, bar: 1, baz: 2}.any?(Hash)  # =&gt; false
[].any?(Integer)                     # =&gt; false
</pre> <p>With a block given, returns whether the block returns a truthy value for any element:</p> <pre class="ruby" data-language="ruby">(1..4).any? {|element| element &lt; 2 }                    # =&gt; true
(1..4).any? {|element| element &lt; 1 }                    # =&gt; false
{foo: 0, bar: 1, baz: 2}.any? {|key, value| value &lt; 1 } # =&gt; true
{foo: 0, bar: 1, baz: 2}.any? {|key, value| value &lt; 0 } # =&gt; false
</pre> <p>Related: <a href="enumerable.html#method-i-all-3F"><code>all?</code></a>, <a href="enumerable.html#method-i-none-3F"><code>none?</code></a>, <a href="enumerable.html#method-i-one-3F"><code>one?</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-chain"> <a href="#method-i-chain" title="Link to this method"> <span class="method-callseq"> chain(*enums) → enumerator </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="chain-source"> <pre class="c" data-language="c">static VALUE
enum_chain(int argc, VALUE *argv, VALUE obj)
{
    VALUE enums = rb_ary_new_from_values(1, &amp;obj);
    rb_ary_cat(enums, argv, argc);
    return new_enum_chain(enums);
}</pre> </div>  <p>Returns an enumerator object generated from this enumerator and given enumerables.</p> <pre class="ruby" data-language="ruby">e = (1..3).chain([4, 5])
e.to_a #=&gt; [1, 2, 3, 4, 5]
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-chunk"> <a href="#method-i-chunk" title="Link to this method"> <span class="method-callseq"> chunk {|array| ... } → enumerator </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="chunk-source"> <pre class="c" data-language="c">static VALUE
enum_chunk(VALUE enumerable)
{
    VALUE enumerator;

    RETURN_SIZED_ENUMERATOR(enumerable, 0, 0, enum_size);

    enumerator = rb_obj_alloc(rb_cEnumerator);
    rb_ivar_set(enumerator, id_chunk_enumerable, enumerable);
    rb_ivar_set(enumerator, id_chunk_categorize, rb_block_proc());
    rb_block_call(enumerator, idInitialize, 0, 0, chunk_i, enumerator);
    return enumerator;
}</pre> </div>  <p>Each element in the returned enumerator is a 2-element array consisting of:</p> <ul>
<li> <p>A value returned by the block.</p> </li>
<li> <p>An array (“chunk”) containing the element for which that value was returned, and all following elements for which the block returned the same value:</p> </li>
</ul> <p>So that:</p> <ul>
<li> <p>Each block return value that is different from its predecessor begins a new chunk.</p> </li>
<li> <p>Each block return value that is the same as its predecessor continues the same chunk.</p> </li>
</ul> <p>Example:</p> <pre class="ruby" data-language="ruby">e = (0..10).chunk {|i| (i / 3).floor } # =&gt; #&lt;Enumerator: ...&gt;
# The enumerator elements.
e.next # =&gt; [0, [0, 1, 2]]
e.next # =&gt; [1, [3, 4, 5]]
e.next # =&gt; [2, [6, 7, 8]]
e.next # =&gt; [3, [9, 10]]
</pre> <p>Method <code>chunk</code> is especially useful for an enumerable that is already sorted. This example counts words for each initial letter in a large array of words:</p> <pre class="ruby" data-language="ruby"># Get sorted words from a web page.
url = 'https://raw.githubusercontent.com/eneko/data-repository/master/data/words.txt'
words = URI::open(url).readlines
# Make chunks, one for each letter.
e = words.chunk {|word| word.upcase[0] } # =&gt; #&lt;Enumerator: ...&gt;
# Display 'A' through 'F'.
e.each {|c, words| p [c, words.length]; break if c == 'F' }
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">["A", 17096]
["B", 11070]
["C", 19901]
["D", 10896]
["E", 8736]
["F", 6860]
</pre> <p>You can use the special symbol <code>:_alone</code> to force an element into its own separate chuck:</p> <pre class="ruby" data-language="ruby">a = [0, 0, 1, 1]
e = a.chunk{|i| i.even? ? :_alone : true }
e.to_a # =&gt; [[:_alone, [0]], [:_alone, [0]], [true, [1, 1]]]
</pre> <p>For example, you can put each line that contains a URL into its own chunk:</p> <pre class="ruby" data-language="ruby">pattern = /http/
open(filename) { |f|
  f.chunk { |line| line =~ pattern ? :_alone : true }.each { |key, lines|
    pp lines
  }
}
</pre> <p>You can use the special symbol <code>:_separator</code> or <code>nil</code> to force an element to be ignored (not included in any chunk):</p> <pre class="ruby" data-language="ruby">a = [0, 0, -1, 1, 1]
e = a.chunk{|i| i &lt; 0 ? :_separator : true }
e.to_a # =&gt; [[true, [0, 0]], [true, [1, 1]]]
</pre> <p>Note that the separator does end the chunk:</p> <pre class="ruby" data-language="ruby">a = [0, 0, -1, 1, -1, 1]
e = a.chunk{|i| i &lt; 0 ? :_separator : true }
e.to_a # =&gt; [[true, [0, 0]], [true, [1]], [true, [1]]]
</pre> <p>For example, the sequence of hyphens in svn log can be eliminated as follows:</p> <pre class="ruby" data-language="ruby">sep = "-"*72 + "\n"
IO.popen("svn log README") { |f|
  f.chunk { |line|
    line != sep || nil
  }.each { |_, lines|
    pp lines
  }
}
#=&gt; ["r20018 | knu | 2008-10-29 13:20:42 +0900 (Wed, 29 Oct 2008) | 2 lines\n",
#    "\n",
#    "* README, README.ja: Update the portability section.\n",
#    "\n"]
#   ["r16725 | knu | 2008-05-31 23:34:23 +0900 (Sat, 31 May 2008) | 2 lines\n",
#    "\n",
#    "* README, README.ja: Add a note about default C flags.\n",
#    "\n"]
#   ...
</pre> <p>Paragraphs separated by empty lines can be parsed as follows:</p> <pre class="ruby" data-language="ruby">File.foreach("README").chunk { |line|
  /\A\s*\z/ !~ line || nil
}.each { |_, lines|
  pp lines
}
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-chunk_while"> <a href="#method-i-chunk_while" title="Link to this method"> <span class="method-callseq"> chunk_while {|elt_before, elt_after| bool } → an_enumerator </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="chunk_while-source"> <pre class="c" data-language="c">static VALUE
enum_chunk_while(VALUE enumerable)
{
    VALUE enumerator;
    VALUE pred;

    pred = rb_block_proc();

    enumerator = rb_obj_alloc(rb_cEnumerator);
    rb_ivar_set(enumerator, id_slicewhen_enum, enumerable);
    rb_ivar_set(enumerator, id_slicewhen_pred, pred);
    rb_ivar_set(enumerator, id_slicewhen_inverted, Qtrue);

    rb_block_call(enumerator, idInitialize, 0, 0, slicewhen_i, enumerator);
    return enumerator;
}</pre> </div>  <p>Creates an enumerator for each chunked elements. The beginnings of chunks are defined by the block.</p> <p>This method splits each chunk using adjacent elements, <em>elt_before</em> and <em>elt_after</em>, in the receiver enumerator. This method split chunks between <em>elt_before</em> and <em>elt_after</em> where the block returns <code>false</code>.</p> <p>The block is called the length of the receiver enumerator minus one.</p> <p>The result enumerator yields the chunked elements as an array. So <code>each</code> method can be called as follows:</p> <pre>enum.chunk_while { |elt_before, elt_after| bool }.each { |ary| ... }</pre> <p>Other methods of the <a href="enumerator.html"><code>Enumerator</code></a> class and <a href="enumerable.html"><code>Enumerable</code></a> module, such as <a href="enumerable.html#method-i-to_a"><code>to_a</code></a>, <code>map</code>, etc., are also usable.</p> <p>For example, one-by-one increasing subsequence can be chunked as follows:</p> <pre class="ruby" data-language="ruby">a = [1,2,4,9,10,11,12,15,16,19,20,21]
b = a.chunk_while {|i, j| i+1 == j }
p b.to_a #=&gt; [[1, 2], [4], [9, 10, 11, 12], [15, 16], [19, 20, 21]]
c = b.map {|a| a.length &lt; 3 ? a : "#{a.first}-#{a.last}" }
p c #=&gt; [[1, 2], [4], "9-12", [15, 16], "19-21"]
d = c.join(",")
p d #=&gt; "1,2,4,9-12,15,16,19-21"
</pre> <p>Increasing (non-decreasing) subsequence can be chunked as follows:</p> <pre class="ruby" data-language="ruby">a = [0, 9, 2, 2, 3, 2, 7, 5, 9, 5]
p a.chunk_while {|i, j| i &lt;= j }.to_a
#=&gt; [[0, 9], [2, 2, 3], [2, 7], [5, 9], [5]]
</pre> <p>Adjacent evens and odds can be chunked as follows: (<a href="enumerable.html#method-i-chunk"><code>Enumerable#chunk</code></a> is another way to do it.)</p> <pre class="ruby" data-language="ruby">a = [7, 5, 9, 2, 0, 7, 9, 4, 2, 0]
p a.chunk_while {|i, j| i.even? == j.even? }.to_a
#=&gt; [[7, 5, 9], [2, 0], [7, 9], [4, 2, 0]]
</pre> <p><a href="enumerable.html#method-i-slice_when"><code>Enumerable#slice_when</code></a> does the same, except splitting when the block returns <code>true</code> instead of <code>false</code>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-collect"> <a href="#method-i-collect" title="Link to this method"> <span class="method-name">collect</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="aliases"> Also aliased as: <a href="enumerable.html#method-i-map">map</a> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-collect_concat"> <a href="#method-i-collect_concat" title="Link to this method"> <span class="method-name">collect_concat</span> </a> </div> </div> <div class="aliases"> Alias for: <a href="enumerable.html#method-i-flat_map">flat_map</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-compact"> <a href="#method-i-compact" title="Link to this method"> <span class="method-callseq"> compact → array </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="compact-source"> <pre class="c" data-language="c">static VALUE
enum_compact(VALUE obj)
{
    VALUE ary;

    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, compact_i, ary);

    return ary;
}</pre> </div>  <p>Returns an array of all non-<code>nil</code> elements:</p> <pre class="ruby" data-language="ruby">a = [nil, 0, nil, 'a', false, nil, false, nil, 'a', nil, 0, nil]
a.compact # =&gt; [0, "a", false, false, "a", 0]
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-count"> <a href="#method-i-count" title="Link to this method"> <span class="method-callseq"> count → integer </span> </a> </div> <div class="method-heading"> <a href="#method-i-count" title="Link to this method"> <span class="method-callseq"> count(object) → integer </span> </a> </div> <div class="method-heading"> <a href="#method-i-count" title="Link to this method"> <span class="method-callseq"> count {|element| ... } → integer </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="count-source"> <pre class="c" data-language="c">static VALUE
enum_count(int argc, VALUE *argv, VALUE obj)
{
    VALUE item = Qnil;
    struct MEMO *memo;
    rb_block_call_func *func;

    if (argc == 0) {
        if (rb_block_given_p()) {
            func = count_iter_i;
        }
        else {
            func = count_all_i;
        }
    }
    else {
        rb_scan_args(argc, argv, "1", &amp;item);
        if (rb_block_given_p()) {
            rb_warn("given block not used");
        }
        func = count_i;
    }

    memo = MEMO_NEW(item, 0, 0);
    rb_block_call(obj, id_each, 0, 0, func, (VALUE)memo);
    return imemo_count_value(memo);
}</pre> </div>  <p>Returns the count of elements, based on an argument or block criterion, if given.</p> <p>With no argument and no block given, returns the number of elements:</p> <pre class="ruby" data-language="ruby">[0, 1, 2].count                # =&gt; 3
{foo: 0, bar: 1, baz: 2}.count # =&gt; 3
</pre> <p>With argument <code>object</code> given, returns the number of elements that are <code>==</code> to <code>object</code>:</p> <pre class="ruby" data-language="ruby">[0, 1, 2, 1].count(1)           # =&gt; 2
</pre> <p>With a block given, calls the block with each element and returns the number of elements for which the block returns a truthy value:</p> <pre class="ruby" data-language="ruby">[0, 1, 2, 3].count {|element| element &lt; 2}              # =&gt; 2
{foo: 0, bar: 1, baz: 2}.count {|key, value| value &lt; 2} # =&gt; 2
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-cycle"> <a href="#method-i-cycle" title="Link to this method"> <span class="method-callseq"> cycle(n = nil) {|element| ...} → nil </span> </a> </div> <div class="method-heading"> <a href="#method-i-cycle" title="Link to this method"> <span class="method-callseq"> cycle(n = nil) → enumerator </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="cycle-source"> <pre class="c" data-language="c">static VALUE
enum_cycle(int argc, VALUE *argv, VALUE obj)
{
    VALUE ary;
    VALUE nv = Qnil;
    long n, i, len;

    rb_check_arity(argc, 0, 1);

    RETURN_SIZED_ENUMERATOR(obj, argc, argv, enum_cycle_size);
    if (!argc || NIL_P(nv = argv[0])) {
        n = -1;
    }
    else {
        n = NUM2LONG(nv);
        if (n &lt;= 0) return Qnil;
    }
    ary = rb_ary_new();
    RBASIC_CLEAR_CLASS(ary);
    rb_block_call(obj, id_each, 0, 0, cycle_i, ary);
    len = RARRAY_LEN(ary);
    if (len == 0) return Qnil;
    while (n &lt; 0 || 0 &lt; --n) {
        for (i=0; i&lt;len; i++) {
            enum_yield_array(RARRAY_AREF(ary, i));
        }
    }
    return Qnil;
}</pre> </div>  <p>When called with positive integer argument <code>n</code> and a block, calls the block with each element, then does so again, until it has done so <code>n</code> times; returns <code>nil</code>:</p> <pre class="ruby" data-language="ruby">a = []
(1..4).cycle(3) {|element| a.push(element) } # =&gt; nil
a # =&gt; [1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]
a = []
('a'..'d').cycle(2) {|element| a.push(element) }
a # =&gt; ["a", "b", "c", "d", "a", "b", "c", "d"]
a = []
{foo: 0, bar: 1, baz: 2}.cycle(2) {|element| a.push(element) }
a # =&gt; [[:foo, 0], [:bar, 1], [:baz, 2], [:foo, 0], [:bar, 1], [:baz, 2]]
</pre> <p>If count is zero or negative, does not call the block.</p> <p>When called with a block and <code>n</code> is <code>nil</code>, cycles forever.</p> <p>When no block is given, returns an <a href="enumerator.html"><code>Enumerator</code></a>.</p> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-detect"> <a href="#method-i-detect" title="Link to this method"> <span class="method-name">detect</span> </a> </div> </div> <div class="aliases"> Alias for: <a href="enumerable.html#method-i-find">find</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-drop"> <a href="#method-i-drop" title="Link to this method"> <span class="method-callseq"> drop(n) → array </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="drop-source"> <pre class="c" data-language="c">static VALUE
enum_drop(VALUE obj, VALUE n)
{
    VALUE result;
    struct MEMO *memo;
    long len = NUM2LONG(n);

    if (len &lt; 0) {
        rb_raise(rb_eArgError, "attempt to drop negative size");
    }

    result = rb_ary_new();
    memo = MEMO_NEW(result, 0, len);
    rb_block_call(obj, id_each, 0, 0, drop_i, (VALUE)memo);
    return result;
}</pre> </div>  <p>For positive integer <code>n</code>, returns an array containing all but the first <code>n</code> elements:</p> <pre class="ruby" data-language="ruby">r = (1..4)
r.drop(3)  # =&gt; [4]
r.drop(2)  # =&gt; [3, 4]
r.drop(1)  # =&gt; [2, 3, 4]
r.drop(0)  # =&gt; [1, 2, 3, 4]
r.drop(50) # =&gt; []

h = {foo: 0, bar: 1, baz: 2, bat: 3}
h.drop(2) # =&gt; [[:baz, 2], [:bat, 3]]
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-drop_while"> <a href="#method-i-drop_while" title="Link to this method"> <span class="method-callseq"> drop_while {|element| ... } → array </span> </a> </div> <div class="method-heading"> <a href="#method-i-drop_while" title="Link to this method"> <span class="method-callseq"> drop_while → enumerator </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="drop_while-source"> <pre class="c" data-language="c">static VALUE
enum_drop_while(VALUE obj)
{
    VALUE result;
    struct MEMO *memo;

    RETURN_ENUMERATOR(obj, 0, 0);
    result = rb_ary_new();
    memo = MEMO_NEW(result, 0, FALSE);
    rb_block_call(obj, id_each, 0, 0, drop_while_i, (VALUE)memo);
    return result;
}</pre> </div>  <p>Calls the block with successive elements as long as the block returns a truthy value; returns an array of all elements after that point:</p> <pre class="ruby" data-language="ruby">(1..4).drop_while{|i| i &lt; 3 } # =&gt; [3, 4]
h = {foo: 0, bar: 1, baz: 2}
a = h.drop_while{|element| key, value = *element; value &lt; 2 }
a # =&gt; [[:baz, 2]]
</pre> <p>With no block given, returns an <a href="enumerator.html"><code>Enumerator</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-each_cons"> <a href="#method-i-each_cons" title="Link to this method"> <span class="method-callseq"> each_cons(n) { ... } → self </span> </a> </div> <div class="method-heading"> <a href="#method-i-each_cons" title="Link to this method"> <span class="method-callseq"> each_cons(n) → enumerator </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="each_cons-source"> <pre class="c" data-language="c">static VALUE
enum_each_cons(VALUE obj, VALUE n)
{
    long size = NUM2LONG(n);
    struct MEMO *memo;
    int arity;

    if (size &lt;= 0) rb_raise(rb_eArgError, "invalid size");
    RETURN_SIZED_ENUMERATOR(obj, 1, &amp;n, enum_each_cons_size);
    arity = rb_block_arity();
    if (enum_size_over_p(obj, size)) return obj;
    memo = MEMO_NEW(rb_ary_new2(size), dont_recycle_block_arg(arity), size);
    rb_block_call(obj, id_each, 0, 0, each_cons_i, (VALUE)memo);

    return obj;
}</pre> </div>  <p>Calls the block with each successive overlapped <code>n</code>-tuple of elements; returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">a = []
(1..5).each_cons(3) {|element| a.push(element) }
a # =&gt; [[1, 2, 3], [2, 3, 4], [3, 4, 5]]

a = []
h = {foo: 0,  bar: 1, baz: 2, bam: 3}
h.each_cons(2) {|element| a.push(element) }
a # =&gt; [[[:foo, 0], [:bar, 1]], [[:bar, 1], [:baz, 2]], [[:baz, 2], [:bam, 3]]]
</pre> <p>With no block given, returns an <a href="enumerator.html"><code>Enumerator</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-each_entry"> <a href="#method-i-each_entry" title="Link to this method"> <span class="method-callseq"> each_entry(*args) {|element| ... } → self </span> </a> </div> <div class="method-heading"> <a href="#method-i-each_entry" title="Link to this method"> <span class="method-callseq"> each_entry(*args) → enumerator </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="each_entry-source"> <pre class="c" data-language="c">static VALUE
enum_each_entry(int argc, VALUE *argv, VALUE obj)
{
    RETURN_SIZED_ENUMERATOR(obj, argc, argv, enum_size);
    rb_block_call(obj, id_each, argc, argv, each_val_i, 0);
    return obj;
}</pre> </div>  <p>Calls the given block with each element, converting multiple values from yield to an array; returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">a = []
(1..4).each_entry {|element| a.push(element) } # =&gt; 1..4
a # =&gt; [1, 2, 3, 4]

a = []
h = {foo: 0, bar: 1, baz:2}
h.each_entry {|element| a.push(element) }
# =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}
a # =&gt; [[:foo, 0], [:bar, 1], [:baz, 2]]

class Foo
  include Enumerable
  def each
    yield 1
    yield 1, 2
    yield
  end
end
Foo.new.each_entry {|yielded| p yielded }
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">1
[1, 2]
nil
</pre> <p>With no block given, returns an <a href="enumerator.html"><code>Enumerator</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-each_slice"> <a href="#method-i-each_slice" title="Link to this method"> <span class="method-callseq"> each_slice(n) { ... } → self </span> </a> </div> <div class="method-heading"> <a href="#method-i-each_slice" title="Link to this method"> <span class="method-callseq"> each_slice(n) → enumerator </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="each_slice-source"> <pre class="c" data-language="c">static VALUE
enum_each_slice(VALUE obj, VALUE n)
{
    long size = NUM2LONG(n);
    VALUE ary;
    struct MEMO *memo;
    int arity;

    if (size &lt;= 0) rb_raise(rb_eArgError, "invalid slice size");
    RETURN_SIZED_ENUMERATOR(obj, 1, &amp;n, enum_each_slice_size);
    size = limit_by_enum_size(obj, size);
    ary = rb_ary_new2(size);
    arity = rb_block_arity();
    memo = MEMO_NEW(ary, dont_recycle_block_arg(arity), size);
    rb_block_call(obj, id_each, 0, 0, each_slice_i, (VALUE)memo);
    ary = memo-&gt;v1;
    if (RARRAY_LEN(ary) &gt; 0) rb_yield(ary);

    return obj;
}</pre> </div>  <p>Calls the block with each successive disjoint <code>n</code>-tuple of elements; returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">a = []
(1..10).each_slice(3) {|tuple| a.push(tuple) }
a # =&gt; [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]]

a = []
h = {foo: 0, bar: 1, baz: 2, bat: 3, bam: 4}
h.each_slice(2) {|tuple| a.push(tuple) }
a # =&gt; [[[:foo, 0], [:bar, 1]], [[:baz, 2], [:bat, 3]], [[:bam, 4]]]
</pre> <p>With no block given, returns an <a href="enumerator.html"><code>Enumerator</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-each_with_index"> <a href="#method-i-each_with_index" title="Link to this method"> <span class="method-callseq"> each_with_index(*args) {|element, i| ..... } → self </span> </a> </div> <div class="method-heading"> <a href="#method-i-each_with_index" title="Link to this method"> <span class="method-callseq"> each_with_index(*args) → enumerator </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="each_with_index-source"> <pre class="c" data-language="c">static VALUE
enum_each_with_index(int argc, VALUE *argv, VALUE obj)
{
    RETURN_SIZED_ENUMERATOR(obj, argc, argv, enum_size);

    rb_block_call(obj, id_each, argc, argv, each_with_index_i, INT2FIX(0));
    return obj;
}</pre> </div>  <p>Invoke <code>self.each</code> with <code>*args</code>. With a block given, the block receives each element and its index; returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">h = {}
(1..4).each_with_index {|element, i| h[element] = i } # =&gt; 1..4
h # =&gt; {1=&gt;0, 2=&gt;1, 3=&gt;2, 4=&gt;3}

h = {}
%w[a b c d].each_with_index {|element, i| h[element] = i }
# =&gt; ["a", "b", "c", "d"]
h # =&gt; {"a"=&gt;0, "b"=&gt;1, "c"=&gt;2, "d"=&gt;3}

a = []
h = {foo: 0, bar: 1, baz: 2}
h.each_with_index {|element, i| a.push([i, element]) }
# =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}
a # =&gt; [[0, [:foo, 0]], [1, [:bar, 1]], [2, [:baz, 2]]]
</pre> <p>With no block given, returns an <a href="enumerator.html"><code>Enumerator</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-each_with_object"> <a href="#method-i-each_with_object" title="Link to this method"> <span class="method-callseq"> each_with_object(object) { |(*args), memo_object| ... } → object </span> </a> </div> <div class="method-heading"> <a href="#method-i-each_with_object" title="Link to this method"> <span class="method-callseq"> each_with_object(object) → enumerator </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="each_with_object-source"> <pre class="c" data-language="c">static VALUE
enum_each_with_object(VALUE obj, VALUE memo)
{
    RETURN_SIZED_ENUMERATOR(obj, 1, &amp;memo, enum_size);

    rb_block_call(obj, id_each, 0, 0, each_with_object_i, memo);

    return memo;
}</pre> </div>  <p>Calls the block once for each element, passing both the element and the given object:</p> <pre class="ruby" data-language="ruby">(1..4).each_with_object([]) {|i, a| a.push(i**2) }
# =&gt; [1, 4, 9, 16]

{foo: 0, bar: 1, baz: 2}.each_with_object({}) {|(k, v), h| h[v] = k }
# =&gt; {0=&gt;:foo, 1=&gt;:bar, 2=&gt;:baz}
</pre> <p>With no block given, returns an <a href="enumerator.html"><code>Enumerator</code></a>.</p> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-entries"> <a href="#method-i-entries" title="Link to this method"> <span class="method-name">entries</span> </a> </div> </div> <div class="aliases"> Alias for: <a href="enumerable.html#method-i-to_a">to_a</a> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-filter"> <a href="#method-i-filter" title="Link to this method"> <span class="method-name">filter</span> </a> </div> </div> <div class="aliases"> Alias for: <a href="enumerable.html#method-i-find_all">find_all</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-filter_map"> <a href="#method-i-filter_map" title="Link to this method"> <span class="method-callseq"> filter_map {|element| ... } → array </span> </a> </div> <div class="method-heading"> <a href="#method-i-filter_map" title="Link to this method"> <span class="method-callseq"> filter_map → enumerator </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="filter_map-source"> <pre class="c" data-language="c">static VALUE
enum_filter_map(VALUE obj)
{
    VALUE ary;

    RETURN_SIZED_ENUMERATOR(obj, 0, 0, enum_size);

    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, filter_map_i, ary);

    return ary;
}</pre> </div>  <p>Returns an array containing truthy elements returned by the block.</p> <p>With a block given, calls the block with successive elements; returns an array containing each truthy value returned by the block:</p> <pre class="ruby" data-language="ruby">(0..9).filter_map {|i| i * 2 if i.even? }                              # =&gt; [0, 4, 8, 12, 16]
{foo: 0, bar: 1, baz: 2}.filter_map {|key, value| key if value.even? } # =&gt; [:foo, :baz]
</pre> <p>When no block given, returns an <a href="enumerator.html"><code>Enumerator</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-find"> <a href="#method-i-find" title="Link to this method"> <span class="method-callseq"> find(if_none_proc = nil) {|element| ... } → object or nil </span> </a> </div> <div class="method-heading"> <a href="#method-i-find" title="Link to this method"> <span class="method-callseq"> find(if_none_proc = nil) → enumerator </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="find-source"> <pre class="c" data-language="c">static VALUE
enum_find(int argc, VALUE *argv, VALUE obj)
{
    struct MEMO *memo;
    VALUE if_none;

    if_none = rb_check_arity(argc, 0, 1) ? argv[0] : Qnil;
    RETURN_ENUMERATOR(obj, argc, argv);
    memo = MEMO_NEW(Qundef, 0, 0);
    if (rb_block_pair_yield_optimizable())
        rb_block_call2(obj, id_each, 0, 0, find_i_fast, (VALUE)memo, RB_BLOCK_NO_USE_PACKED_ARGS);
    else
        rb_block_call2(obj, id_each, 0, 0, find_i, (VALUE)memo, RB_BLOCK_NO_USE_PACKED_ARGS);
    if (memo-&gt;u3.cnt) {
        return memo-&gt;v1;
    }
    if (!NIL_P(if_none)) {
        return rb_funcallv(if_none, id_call, 0, 0);
    }
    return Qnil;
}</pre> </div>  <p>Returns the first element for which the block returns a truthy value.</p> <p>With a block given, calls the block with successive elements of the collection; returns the first element for which the block returns a truthy value:</p> <pre class="ruby" data-language="ruby">(0..9).find {|element| element &gt; 2}                # =&gt; 3
</pre> <p>If no such element is found, calls <code>if_none_proc</code> and returns its return value.</p> <pre class="ruby" data-language="ruby">(0..9).find(proc {false}) {|element| element &gt; 12} # =&gt; false
{foo: 0, bar: 1, baz: 2}.find {|key, value| key.start_with?('b') }            # =&gt; [:bar, 1]
{foo: 0, bar: 1, baz: 2}.find(proc {[]}) {|key, value| key.start_with?('c') } # =&gt; []
</pre> <p>With no block given, returns an <a href="enumerator.html"><code>Enumerator</code></a>.</p> </div> <div class="aliases"> Also aliased as: <a href="enumerable.html#method-i-detect">detect</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-find_all"> <a href="#method-i-find_all" title="Link to this method"> <span class="method-name">find_all</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="aliases"> Also aliased as: <a href="enumerable.html#method-i-select">select</a>, <a href="enumerable.html#method-i-filter">filter</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-find_index"> <a href="#method-i-find_index" title="Link to this method"> <span class="method-callseq"> find_index(object) → integer or nil </span> </a> </div> <div class="method-heading"> <a href="#method-i-find_index" title="Link to this method"> <span class="method-callseq"> find_index {|element| ... } → integer or nil </span> </a> </div> <div class="method-heading"> <a href="#method-i-find_index" title="Link to this method"> <span class="method-callseq"> find_index → enumerator </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="find_index-source"> <pre class="c" data-language="c">static VALUE
enum_find_index(int argc, VALUE *argv, VALUE obj)
{
    struct MEMO *memo;  /* [return value, current index, ] */
    VALUE condition_value = Qnil;
    rb_block_call_func *func;

    if (argc == 0) {
        RETURN_ENUMERATOR(obj, 0, 0);
        func = find_index_iter_i;
    }
    else {
        rb_scan_args(argc, argv, "1", &amp;condition_value);
        if (rb_block_given_p()) {
            rb_warn("given block not used");
        }
        func = find_index_i;
    }

    memo = MEMO_NEW(Qnil, condition_value, 0);
    rb_block_call(obj, id_each, 0, 0, func, (VALUE)memo);
    return memo-&gt;v1;
}</pre> </div>  <p>Returns the index of the first element that meets a specified criterion, or <code>nil</code> if no such element is found.</p> <p>With argument <code>object</code> given, returns the index of the first element that is <code>==</code> <code>object</code>:</p> <pre class="ruby" data-language="ruby">['a', 'b', 'c', 'b'].find_index('b') # =&gt; 1
</pre> <p>With a block given, calls the block with successive elements; returns the first element for which the block returns a truthy value:</p> <pre class="ruby" data-language="ruby">['a', 'b', 'c', 'b'].find_index {|element| element.start_with?('b') } # =&gt; 1
{foo: 0, bar: 1, baz: 2}.find_index {|key, value| value &gt; 1 }         # =&gt; 2
</pre> <p>With no argument and no block given, returns an <a href="enumerator.html"><code>Enumerator</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-first"> <a href="#method-i-first" title="Link to this method"> <span class="method-callseq"> first → element or nil </span> </a> </div> <div class="method-heading"> <a href="#method-i-first" title="Link to this method"> <span class="method-callseq"> first(n) → array </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="first-source"> <pre class="c" data-language="c">static VALUE
enum_first(int argc, VALUE *argv, VALUE obj)
{
    struct MEMO *memo;
    rb_check_arity(argc, 0, 1);
    if (argc &gt; 0) {
        return enum_take(obj, argv[0]);
    }
    else {
        memo = MEMO_NEW(Qnil, 0, 0);
        rb_block_call(obj, id_each, 0, 0, first_i, (VALUE)memo);
        return memo-&gt;v1;
    }
}</pre> </div>  <p>Returns the first element or elements.</p> <p>With no argument, returns the first element, or <code>nil</code> if there is none:</p> <pre class="ruby" data-language="ruby">(1..4).first                   # =&gt; 1
%w[a b c].first                # =&gt; "a"
{foo: 1, bar: 1, baz: 2}.first # =&gt; [:foo, 1]
[].first                       # =&gt; nil
</pre> <p>With integer argument <code>n</code>, returns an array containing the first <code>n</code> elements that exist:</p> <pre class="ruby" data-language="ruby">(1..4).first(2)                   # =&gt; [1, 2]
%w[a b c d].first(3)              # =&gt; ["a", "b", "c"]
%w[a b c d].first(50)             # =&gt; ["a", "b", "c", "d"]
{foo: 1, bar: 1, baz: 2}.first(2) # =&gt; [[:foo, 1], [:bar, 1]]
[].first(2)                       # =&gt; []
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-flat_map"> <a href="#method-i-flat_map" title="Link to this method"> <span class="method-callseq"> flat_map {|element| ... } → array </span> </a> </div> <div class="method-heading"> <a href="#method-i-flat_map" title="Link to this method"> <span class="method-callseq"> flat_map → enumerator </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="flat_map-source"> <pre class="c" data-language="c">static VALUE
enum_flat_map(VALUE obj)
{
    VALUE ary;

    RETURN_SIZED_ENUMERATOR(obj, 0, 0, enum_size);

    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, flat_map_i, ary);

    return ary;
}</pre> </div>  <p>Returns an array of flattened objects returned by the block.</p> <p>With a block given, calls the block with successive elements; returns a flattened array of objects returned by the block:</p> <pre class="ruby" data-language="ruby">[0, 1, 2, 3].flat_map {|element| -element }                    # =&gt; [0, -1, -2, -3]
[0, 1, 2, 3].flat_map {|element| [element, -element] }         # =&gt; [0, 0, 1, -1, 2, -2, 3, -3]
[[0, 1], [2, 3]].flat_map {|e| e + [100] }                     # =&gt; [0, 1, 100, 2, 3, 100]
{foo: 0, bar: 1, baz: 2}.flat_map {|key, value| [key, value] } # =&gt; [:foo, 0, :bar, 1, :baz, 2]
</pre> <p>With no block given, returns an <a href="enumerator.html"><code>Enumerator</code></a>.</p> <p>Alias: <a href="enumerable.html#method-i-collect_concat"><code>collect_concat</code></a>.</p> </div> <div class="aliases"> Also aliased as: <a href="enumerable.html#method-i-collect_concat">collect_concat</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-grep"> <a href="#method-i-grep" title="Link to this method"> <span class="method-callseq"> grep(pattern) → array </span> </a> </div> <div class="method-heading"> <a href="#method-i-grep" title="Link to this method"> <span class="method-callseq"> grep(pattern) {|element| ... } → array </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="grep-source"> <pre class="c" data-language="c">static VALUE
enum_grep(VALUE obj, VALUE pat)
{
    return enum_grep0(obj, pat, Qtrue);
}</pre> </div>  <p>Returns an array of objects based elements of <code>self</code> that match the given pattern.</p> <p>With no block given, returns an array containing each element for which <code>pattern === element</code> is <code>true</code>:</p> <pre class="ruby" data-language="ruby">a = ['foo', 'bar', 'car', 'moo']
a.grep(/ar/)                   # =&gt; ["bar", "car"]
(1..10).grep(3..8)             # =&gt; [3, 4, 5, 6, 7, 8]
['a', 'b', 0, 1].grep(Integer) # =&gt; [0, 1]
</pre> <p>With a block given, calls the block with each matching element and returns an array containing each object returned by the block:</p> <pre class="ruby" data-language="ruby">a = ['foo', 'bar', 'car', 'moo']
a.grep(/ar/) {|element| element.upcase } # =&gt; ["BAR", "CAR"]
</pre> <p>Related: <a href="enumerable.html#method-i-grep_v"><code>grep_v</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-grep_v"> <a href="#method-i-grep_v" title="Link to this method"> <span class="method-callseq"> grep_v(pattern) → array </span> </a> </div> <div class="method-heading"> <a href="#method-i-grep_v" title="Link to this method"> <span class="method-callseq"> grep_v(pattern) {|element| ... } → array </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="grep_v-source"> <pre class="c" data-language="c">static VALUE
enum_grep_v(VALUE obj, VALUE pat)
{
    return enum_grep0(obj, pat, Qfalse);
}</pre> </div>  <p>Returns an array of objects based on elements of <code>self</code> that <em>don’t</em> match the given pattern.</p> <p>With no block given, returns an array containing each element for which <code>pattern === element</code> is <code>false</code>:</p> <pre class="ruby" data-language="ruby">a = ['foo', 'bar', 'car', 'moo']
a.grep_v(/ar/)                   # =&gt; ["foo", "moo"]
(1..10).grep_v(3..8)             # =&gt; [1, 2, 9, 10]
['a', 'b', 0, 1].grep_v(Integer) # =&gt; ["a", "b"]
</pre> <p>With a block given, calls the block with each non-matching element and returns an array containing each object returned by the block:</p> <pre class="ruby" data-language="ruby">a = ['foo', 'bar', 'car', 'moo']
a.grep_v(/ar/) {|element| element.upcase } # =&gt; ["FOO", "MOO"]
</pre> <p>Related: <a href="enumerable.html#method-i-grep"><code>grep</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-group_by"> <a href="#method-i-group_by" title="Link to this method"> <span class="method-callseq"> group_by {|element| ... } → hash </span> </a> </div> <div class="method-heading"> <a href="#method-i-group_by" title="Link to this method"> <span class="method-callseq"> group_by → enumerator </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="group_by-source"> <pre class="c" data-language="c">static VALUE
enum_group_by(VALUE obj)
{
    RETURN_SIZED_ENUMERATOR(obj, 0, 0, enum_size);

    return enum_hashify(obj, 0, 0, group_by_i);
}</pre> </div>  <p>With a block given returns a hash:</p> <ul>
<li> <p>Each key is a return value from the block.</p> </li>
<li> <p>Each value is an array of those elements for which the block returned that key.</p> </li>
</ul> <p>Examples:</p> <pre class="ruby" data-language="ruby">g = (1..6).group_by {|i| i%3 }
g # =&gt; {1=&gt;[1, 4], 2=&gt;[2, 5], 0=&gt;[3, 6]}
h = {foo: 0, bar: 1, baz: 0, bat: 1}
g = h.group_by {|key, value| value }
g # =&gt; {0=&gt;[[:foo, 0], [:baz, 0]], 1=&gt;[[:bar, 1], [:bat, 1]]}
</pre> <p>With no block given, returns an <a href="enumerator.html"><code>Enumerator</code></a>.</p> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-include-3F"> <a href="#method-i-include-3F" title="Link to this method"> <span class="method-callseq"> include?(object) → true or false </span> </a> </div> </div> <div class="method-description"> <p>Returns whether for any element <code>object == element</code>:</p> <pre class="ruby" data-language="ruby">(1..4).include?(2)                       # =&gt; true
(1..4).include?(5)                       # =&gt; false
(1..4).include?('2')                     # =&gt; false
%w[a b c d].include?('b')                # =&gt; true
%w[a b c d].include?('2')                # =&gt; false
{foo: 0, bar: 1, baz: 2}.include?(:foo)  # =&gt; true
{foo: 0, bar: 1, baz: 2}.include?('foo') # =&gt; false
{foo: 0, bar: 1, baz: 2}.include?(0)     # =&gt; false
</pre> </div> <div class="aliases"> Alias for: <a href="enumerable.html#method-i-member-3F">member?</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-inject"> <a href="#method-i-inject" title="Link to this method"> <span class="method-callseq"> inject(symbol) → object </span> </a> </div> <div class="method-heading"> <a href="#method-i-inject" title="Link to this method"> <span class="method-callseq"> inject(initial_value, symbol) → object </span> </a> </div> <div class="method-heading"> <a href="#method-i-inject" title="Link to this method"> <span class="method-callseq"> inject {|memo, value| ... } → object </span> </a> </div> <div class="method-heading"> <a href="#method-i-inject" title="Link to this method"> <span class="method-callseq"> inject(initial_value) {|memo, value| ... } → object </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="inject-source"> <pre class="c" data-language="c">static VALUE
enum_inject(int argc, VALUE *argv, VALUE obj)
{
    struct MEMO *memo;
    VALUE init, op;
    rb_block_call_func *iter = inject_i;
    ID id;
    int num_args;

    if (rb_block_given_p()) {
        num_args = rb_scan_args(argc, argv, "02", &amp;init, &amp;op);
    }
    else {
        num_args = rb_scan_args(argc, argv, "11", &amp;init, &amp;op);
    }

    switch (num_args) {
      case 0:
        init = Qundef;
        break;
      case 1:
        if (rb_block_given_p()) {
            break;
        }
        id = rb_check_id(&amp;init);
        op = id ? ID2SYM(id) : init;
        init = Qundef;
        iter = inject_op_i;
        break;
      case 2:
        if (rb_block_given_p()) {
            rb_warning("given block not used");
        }
        id = rb_check_id(&amp;op);
        if (id) op = ID2SYM(id);
        iter = inject_op_i;
        break;
    }

    if (iter == inject_op_i &amp;&amp;
        SYMBOL_P(op) &amp;&amp;
        RB_TYPE_P(obj, T_ARRAY) &amp;&amp;
        rb_method_basic_definition_p(CLASS_OF(obj), id_each)) {
        return ary_inject_op(obj, init, op);
    }

    memo = MEMO_NEW(init, Qnil, op);
    rb_block_call(obj, id_each, 0, 0, iter, (VALUE)memo);
    if (UNDEF_P(memo-&gt;v1)) return Qnil;
    return memo-&gt;v1;
}</pre> </div>  <p>Returns the result of applying a reducer to an initial value and the first element of the <a href="enumerable.html"><code>Enumerable</code></a>. It then takes the result and applies the function to it and the second element of the collection, and so on. The return value is the result returned by the final call to the function.</p> <p>You can think of</p> <pre class="ruby" data-language="ruby">[ a, b, c, d ].inject(i) { |r, v| fn(r, v) }
</pre> <p>as being</p> <pre class="ruby" data-language="ruby">fn(fn(fn(fn(i, a), b), c), d)
</pre> <p>In a way the <code>inject</code> function <em>injects</em> the function between the elements of the enumerable.</p> <p><code>inject</code> is aliased as <code>reduce</code>. You use it when you want to <em>reduce</em> a collection to a single value.</p> <p><strong>The Calling Sequences</strong></p> <p>Let’s start with the most verbose:</p> <pre class="ruby" data-language="ruby">enum.inject(initial_value) do |result, next_value|
  # do something with +result+ and +next_value+
  # the value returned by the block becomes the
  # value passed in to the next iteration
  # as +result+
end
</pre> <p>For example:</p> <pre class="ruby" data-language="ruby">product = [ 2, 3, 4 ].inject(1) do |result, next_value|
  result * next_value
end
product #=&gt; 24
</pre> <p>When this runs, the block is first called with <code>1</code> (the initial value) and <code>2</code> (the first element of the array). The block returns <code>1*2</code>, so on the next iteration the block is called with <code>2</code> (the previous result) and <code>3</code>. The block returns <code>6</code>, and is called one last time with <code>6</code> and <code>4</code>. The result of the block, <code>24</code> becomes the value returned by <code>inject</code>. This code returns the product of the elements in the enumerable.</p> <p><strong>First Shortcut: Default Initial value</strong></p> <p>In the case of the previous example, the initial value, <code>1</code>, wasn’t really necessary: the calculation of the product of a list of numbers is self-contained.</p> <p>In these circumstances, you can omit the <code>initial_value</code> parameter. <code>inject</code> will then initially call the block with the first element of the collection as the <code>result</code> parameter and the second element as the <code>next_value</code>.</p> <pre class="ruby" data-language="ruby">[ 2, 3, 4 ].inject do |result, next_value|
  result * next_value
end
</pre> <p>This shortcut is convenient, but can only be used when the block produces a result which can be passed back to it as a first parameter.</p> <p>Here’s an example where that’s not the case: it returns a hash where the keys are words and the values are the number of occurrences of that word in the enumerable.</p> <pre>freqs = File.read("README.md")
  .scan(/\w{2,}/)
  .reduce(Hash.new(0)) do |counts, word|
    counts[word] += 1
    counts
  end
freqs #=&gt; {"Actions"=&gt;4,
           "Status"=&gt;5,
           "MinGW"=&gt;3,
           "https"=&gt;27,
           "github"=&gt;10,
           "com"=&gt;15, ...</pre> <p>Note that the last line of the block is just the word <code>counts</code>. This ensures the return value of the block is the result that’s being calculated.</p> <p><strong>Second Shortcut: a Reducer function</strong></p> <p>A <em>reducer function</em> is a function that takes a partial result and the next value, returning the next partial result. The block that is given to <code>inject</code> is a reducer.</p> <p>You can also write a reducer as a function and pass the name of that function (as a symbol) to <code>inject</code>. However, for this to work, the function</p> <ol>
<li> <p>Must be defined on the type of the result value</p> </li>
<li> <p>Must accept a single parameter, the next value in the collection, and</p> </li>
<li> <p>Must return an updated result which will also implement the function.</p> </li>
</ol> <p>Here’s an example that adds elements to a string. The two calls invoke the functions <a href="string.html#method-i-concat"><code>String#concat</code></a> and <a href="string.html#method-i-2B"><code>String#+</code></a> on the result so far, passing it the next value.</p> <pre class="ruby" data-language="ruby">s = [ "cat", " ", "dog" ].inject("", :concat)
s #=&gt; "cat dog"
s = [ "cat", " ", "dog" ].inject("The result is:", :+)
s #=&gt; "The result is: cat dog"
</pre> <p>Here’s a more complex example when the result object maintains state of a different type to the enumerable elements.</p> <pre class="ruby" data-language="ruby">class Turtle

  def initialize
    @x = @y = 0
  end

  def move(dir)
    case dir
    when "n" then @y += 1
    when "s" then @y -= 1
    when "e" then @x += 1
    when "w" then @x -= 1
    end
    self
  end
end

position = "nnneesw".chars.reduce(Turtle.new, :move)
position  #=&gt;&gt; #&lt;Turtle:0x00000001052f4698 @y=2, @x=1&gt;
</pre> <p><strong>Third Shortcut: Reducer With no Initial Value</strong></p> <p>If your reducer returns a value that it can accept as a parameter, then you don’t have to pass in an initial value. Here <code>:*</code> is the name of the <em>times</em> function:</p> <pre class="ruby" data-language="ruby">product = [ 2, 3, 4 ].inject(:*)
product # =&gt; 24
</pre> <p><a href="string.html"><code>String</code></a> concatenation again:</p> <pre class="ruby" data-language="ruby">s = [ "cat", " ", "dog" ].inject(:+)
s #=&gt; "cat dog"
</pre> <p>And an example that converts a hash to an array of two-element subarrays.</p> <pre class="ruby" data-language="ruby">nested = {foo: 0, bar: 1}.inject([], :push)
nested # =&gt; [[:foo, 0], [:bar, 1]]
</pre> </div> <div class="aliases"> Also aliased as: <a href="enumerable.html#method-i-reduce">reduce</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-lazy"> <a href="#method-i-lazy" title="Link to this method"> <span class="method-callseq"> lazy → lazy_enumerator </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="lazy-source"> <pre class="c" data-language="c">static VALUE
enumerable_lazy(VALUE obj)
{
    VALUE result = lazy_to_enum_i(obj, sym_each, 0, 0, lazyenum_size, rb_keyword_given_p());
    /* Qfalse indicates that the Enumerator::Lazy has no method name */
    rb_ivar_set(result, id_method, Qfalse);
    return result;
}</pre> </div>  <p>Returns an <a href="enumerator/lazy.html"><code>Enumerator::Lazy</code></a>, which redefines most <a href="enumerable.html"><code>Enumerable</code></a> methods to postpone enumeration and enumerate values only on an as-needed basis.</p> <h3 id="method-i-lazy-label-Example">Example</h3> <p>The following program finds pythagorean triples:</p> <pre class="ruby" data-language="ruby">def pythagorean_triples
  (1..Float::INFINITY).lazy.flat_map {|z|
    (1..z).flat_map {|x|
      (x..z).select {|y|
        x**2 + y**2 == z**2
      }.map {|y|
        [x, y, z]
      }
    }
  }
end
# show first ten pythagorean triples
p pythagorean_triples.take(10).force # take is lazy, so force is needed
p pythagorean_triples.first(10)      # first is eager
# show pythagorean triples less than 100
p pythagorean_triples.take_while { |*, z| z &lt; 100 }.force
</pre> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-map"> <a href="#method-i-map" title="Link to this method"> <span class="method-callseq"> map {|element| ... } → array </span> </a> </div> <div class="method-heading"> <a href="#method-i-map" title="Link to this method"> <span class="method-callseq"> map → enumerator </span> </a> </div> </div> <div class="method-description"> <p>Returns an array of objects returned by the block.</p> <p>With a block given, calls the block with successive elements; returns an array of the objects returned by the block:</p> <pre class="ruby" data-language="ruby">(0..4).map {|i| i*i }                               # =&gt; [0, 1, 4, 9, 16]
{foo: 0, bar: 1, baz: 2}.map {|key, value| value*2} # =&gt; [0, 2, 4]
</pre> <p>With no block given, returns an <a href="enumerator.html"><code>Enumerator</code></a>.</p> </div> <div class="aliases"> Alias for: <a href="enumerable.html#method-i-collect">collect</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-max"> <a href="#method-i-max" title="Link to this method"> <span class="method-callseq"> max → element </span> </a> </div> <div class="method-heading"> <a href="#method-i-max" title="Link to this method"> <span class="method-callseq"> max(n) → array </span> </a> </div> <div class="method-heading"> <a href="#method-i-max" title="Link to this method"> <span class="method-callseq"> max {|a, b| ... } → element </span> </a> </div> <div class="method-heading"> <a href="#method-i-max" title="Link to this method"> <span class="method-callseq"> max(n) {|a, b| ... } → array </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="max-source"> <pre class="c" data-language="c">static VALUE
enum_max(int argc, VALUE *argv, VALUE obj)
{
    VALUE memo;
    struct max_t *m = NEW_MEMO_FOR(struct max_t, memo);
    VALUE result;
    VALUE num;

    if (rb_check_arity(argc, 0, 1) &amp;&amp; !NIL_P(num = argv[0]))
       return rb_nmin_run(obj, num, 0, 1, 0);

    m-&gt;max = Qundef;
    if (rb_block_given_p()) {
        rb_block_call(obj, id_each, 0, 0, max_ii, (VALUE)memo);
    }
    else {
        rb_block_call(obj, id_each, 0, 0, max_i, (VALUE)memo);
    }
    result = m-&gt;max;
    if (UNDEF_P(result)) return Qnil;
    return result;
}</pre> </div>  <p>Returns the element with the maximum element according to a given criterion. The ordering of equal elements is indeterminate and may be unstable.</p> <p>With no argument and no block, returns the maximum element, using the elements’ own method &lt;=&gt; for comparison:</p> <pre class="ruby" data-language="ruby">(1..4).max                   # =&gt; 4
(-4..-1).max                 # =&gt; -1
%w[d c b a].max              # =&gt; "d"
{foo: 0, bar: 1, baz: 2}.max # =&gt; [:foo, 0]
[].max                       # =&gt; nil
</pre> <p>With positive integer argument <code>n</code> given, and no block, returns an array containing the first <code>n</code> maximum elements that exist:</p> <pre class="ruby" data-language="ruby">(1..4).max(2)                   # =&gt; [4, 3]
(-4..-1).max(2)                # =&gt; [-1, -2]
%w[d c b a].max(2)              # =&gt; ["d", "c"]
{foo: 0, bar: 1, baz: 2}.max(2) # =&gt; [[:foo, 0], [:baz, 2]]
[].max(2)                       # =&gt; []
</pre> <p>With a block given, the block determines the maximum elements. The block is called with two elements <code>a</code> and <code>b</code>, and must return:</p> <ul>
<li> <p>A negative integer if <code>a &lt; b</code>.</p> </li>
<li> <p>Zero if <code>a == b</code>.</p> </li>
<li> <p>A positive integer if <code>a &gt; b</code>.</p> </li>
</ul> <p>With a block given and no argument, returns the maximum element as determined by the block:</p> <pre class="ruby" data-language="ruby">%w[xxx x xxxx xx].max {|a, b| a.size &lt;=&gt; b.size } # =&gt; "xxxx"
h = {foo: 0, bar: 1, baz: 2}
h.max {|pair1, pair2| pair1[1] &lt;=&gt; pair2[1] }     # =&gt; [:baz, 2]
[].max {|a, b| a &lt;=&gt; b }                          # =&gt; nil
</pre> <p>With a block given and positive integer argument <code>n</code> given, returns an array containing the first <code>n</code> maximum elements that exist, as determined by the block.</p> <pre class="ruby" data-language="ruby">%w[xxx x xxxx xx].max(2) {|a, b| a.size &lt;=&gt; b.size } # =&gt; ["xxxx", "xxx"]
h = {foo: 0, bar: 1, baz: 2}
h.max(2) {|pair1, pair2| pair1[1] &lt;=&gt; pair2[1] }
# =&gt; [[:baz, 2], [:bar, 1]]
[].max(2) {|a, b| a &lt;=&gt; b }                          # =&gt; []
</pre> <p>Related: <a href="enumerable.html#method-i-min"><code>min</code></a>, <a href="enumerable.html#method-i-minmax"><code>minmax</code></a>, <a href="enumerable.html#method-i-max_by"><code>max_by</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-max_by"> <a href="#method-i-max_by" title="Link to this method"> <span class="method-callseq"> max_by {|element| ... } → element </span> </a> </div> <div class="method-heading"> <a href="#method-i-max_by" title="Link to this method"> <span class="method-callseq"> max_by(n) {|element| ... } → array </span> </a> </div> <div class="method-heading"> <a href="#method-i-max_by" title="Link to this method"> <span class="method-callseq"> max_by → enumerator </span> </a> </div> <div class="method-heading"> <a href="#method-i-max_by" title="Link to this method"> <span class="method-callseq"> max_by(n) → enumerator </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="max_by-source"> <pre class="c" data-language="c">static VALUE
enum_max_by(int argc, VALUE *argv, VALUE obj)
{
    struct MEMO *memo;
    VALUE num;

    rb_check_arity(argc, 0, 1);

    RETURN_SIZED_ENUMERATOR(obj, argc, argv, enum_size);

    if (argc &amp;&amp; !NIL_P(num = argv[0]))
        return rb_nmin_run(obj, num, 1, 1, 0);

    memo = MEMO_NEW(Qundef, Qnil, 0);
    rb_block_call(obj, id_each, 0, 0, max_by_i, (VALUE)memo);
    return memo-&gt;v2;
}</pre> </div>  <p>Returns the elements for which the block returns the maximum values.</p> <p>With a block given and no argument, returns the element for which the block returns the maximum value:</p> <pre class="ruby" data-language="ruby">(1..4).max_by {|element| -element }                    # =&gt; 1
%w[a b c d].max_by {|element| -element.ord }           # =&gt; "a"
{foo: 0, bar: 1, baz: 2}.max_by {|key, value| -value } # =&gt; [:foo, 0]
[].max_by {|element| -element }                        # =&gt; nil
</pre> <p>With a block given and positive integer argument <code>n</code> given, returns an array containing the <code>n</code> elements for which the block returns maximum values:</p> <pre class="ruby" data-language="ruby">(1..4).max_by(2) {|element| -element }
# =&gt; [1, 2]
%w[a b c d].max_by(2) {|element| -element.ord }
# =&gt; ["a", "b"]
{foo: 0, bar: 1, baz: 2}.max_by(2) {|key, value| -value }
# =&gt; [[:foo, 0], [:bar, 1]]
[].max_by(2) {|element| -element }
# =&gt; []
</pre> <p>Returns an <a href="enumerator.html"><code>Enumerator</code></a> if no block is given.</p> <p>Related: <a href="enumerable.html#method-i-max"><code>max</code></a>, <a href="enumerable.html#method-i-minmax"><code>minmax</code></a>, <a href="enumerable.html#method-i-min_by"><code>min_by</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-member-3F"> <a href="#method-i-member-3F" title="Link to this method"> <span class="method-name">member?</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="aliases"> Also aliased as: <a href="enumerable.html#method-i-include-3F">include?</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-min"> <a href="#method-i-min" title="Link to this method"> <span class="method-callseq"> min → element </span> </a> </div> <div class="method-heading"> <a href="#method-i-min" title="Link to this method"> <span class="method-callseq"> min(n) → array </span> </a> </div> <div class="method-heading"> <a href="#method-i-min" title="Link to this method"> <span class="method-callseq"> min {|a, b| ... } → element </span> </a> </div> <div class="method-heading"> <a href="#method-i-min" title="Link to this method"> <span class="method-callseq"> min(n) {|a, b| ... } → array </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="min-source"> <pre class="c" data-language="c">static VALUE
enum_min(int argc, VALUE *argv, VALUE obj)
{
    VALUE memo;
    struct min_t *m = NEW_MEMO_FOR(struct min_t, memo);
    VALUE result;
    VALUE num;

    if (rb_check_arity(argc, 0, 1) &amp;&amp; !NIL_P(num = argv[0]))
       return rb_nmin_run(obj, num, 0, 0, 0);

    m-&gt;min = Qundef;
    if (rb_block_given_p()) {
        rb_block_call(obj, id_each, 0, 0, min_ii, memo);
    }
    else {
        rb_block_call(obj, id_each, 0, 0, min_i, memo);
    }
    result = m-&gt;min;
    if (UNDEF_P(result)) return Qnil;
    return result;
}</pre> </div>  <p>Returns the element with the minimum element according to a given criterion. The ordering of equal elements is indeterminate and may be unstable.</p> <p>With no argument and no block, returns the minimum element, using the elements’ own method &lt;=&gt; for comparison:</p> <pre class="ruby" data-language="ruby">(1..4).min                   # =&gt; 1
(-4..-1).min                 # =&gt; -4
%w[d c b a].min              # =&gt; "a"
{foo: 0, bar: 1, baz: 2}.min # =&gt; [:bar, 1]
[].min                       # =&gt; nil
</pre> <p>With positive integer argument <code>n</code> given, and no block, returns an array containing the first <code>n</code> minimum elements that exist:</p> <pre class="ruby" data-language="ruby">(1..4).min(2)                   # =&gt; [1, 2]
(-4..-1).min(2)                 # =&gt; [-4, -3]
%w[d c b a].min(2)              # =&gt; ["a", "b"]
{foo: 0, bar: 1, baz: 2}.min(2) # =&gt; [[:bar, 1], [:baz, 2]]
[].min(2)                       # =&gt; []
</pre> <p>With a block given, the block determines the minimum elements. The block is called with two elements <code>a</code> and <code>b</code>, and must return:</p> <ul>
<li> <p>A negative integer if <code>a &lt; b</code>.</p> </li>
<li> <p>Zero if <code>a == b</code>.</p> </li>
<li> <p>A positive integer if <code>a &gt; b</code>.</p> </li>
</ul> <p>With a block given and no argument, returns the minimum element as determined by the block:</p> <pre class="ruby" data-language="ruby">%w[xxx x xxxx xx].min {|a, b| a.size &lt;=&gt; b.size } # =&gt; "x"
h = {foo: 0, bar: 1, baz: 2}
h.min {|pair1, pair2| pair1[1] &lt;=&gt; pair2[1] } # =&gt; [:foo, 0]
[].min {|a, b| a &lt;=&gt; b }                          # =&gt; nil
</pre> <p>With a block given and positive integer argument <code>n</code> given, returns an array containing the first <code>n</code> minimum elements that exist, as determined by the block.</p> <pre class="ruby" data-language="ruby">%w[xxx x xxxx xx].min(2) {|a, b| a.size &lt;=&gt; b.size } # =&gt; ["x", "xx"]
h = {foo: 0, bar: 1, baz: 2}
h.min(2) {|pair1, pair2| pair1[1] &lt;=&gt; pair2[1] }
# =&gt; [[:foo, 0], [:bar, 1]]
[].min(2) {|a, b| a &lt;=&gt; b }                          # =&gt; []
</pre> <p>Related: <a href="enumerable.html#method-i-min_by"><code>min_by</code></a>, <a href="enumerable.html#method-i-minmax"><code>minmax</code></a>, <a href="enumerable.html#method-i-max"><code>max</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-min_by"> <a href="#method-i-min_by" title="Link to this method"> <span class="method-callseq"> min_by {|element| ... } → element </span> </a> </div> <div class="method-heading"> <a href="#method-i-min_by" title="Link to this method"> <span class="method-callseq"> min_by(n) {|element| ... } → array </span> </a> </div> <div class="method-heading"> <a href="#method-i-min_by" title="Link to this method"> <span class="method-callseq"> min_by → enumerator </span> </a> </div> <div class="method-heading"> <a href="#method-i-min_by" title="Link to this method"> <span class="method-callseq"> min_by(n) → enumerator </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="min_by-source"> <pre class="c" data-language="c">static VALUE
enum_min_by(int argc, VALUE *argv, VALUE obj)
{
    struct MEMO *memo;
    VALUE num;

    rb_check_arity(argc, 0, 1);

    RETURN_SIZED_ENUMERATOR(obj, argc, argv, enum_size);

    if (argc &amp;&amp; !NIL_P(num = argv[0]))
        return rb_nmin_run(obj, num, 1, 0, 0);

    memo = MEMO_NEW(Qundef, Qnil, 0);
    rb_block_call(obj, id_each, 0, 0, min_by_i, (VALUE)memo);
    return memo-&gt;v2;
}</pre> </div>  <p>Returns the elements for which the block returns the minimum values.</p> <p>With a block given and no argument, returns the element for which the block returns the minimum value:</p> <pre class="ruby" data-language="ruby">(1..4).min_by {|element| -element }                    # =&gt; 4
%w[a b c d].min_by {|element| -element.ord }           # =&gt; "d"
{foo: 0, bar: 1, baz: 2}.min_by {|key, value| -value } # =&gt; [:baz, 2]
[].min_by {|element| -element }                        # =&gt; nil
</pre> <p>With a block given and positive integer argument <code>n</code> given, returns an array containing the <code>n</code> elements for which the block returns minimum values:</p> <pre class="ruby" data-language="ruby">(1..4).min_by(2) {|element| -element }
# =&gt; [4, 3]
%w[a b c d].min_by(2) {|element| -element.ord }
# =&gt; ["d", "c"]
{foo: 0, bar: 1, baz: 2}.min_by(2) {|key, value| -value }
# =&gt; [[:baz, 2], [:bar, 1]]
[].min_by(2) {|element| -element }
# =&gt; []
</pre> <p>Returns an <a href="enumerator.html"><code>Enumerator</code></a> if no block is given.</p> <p>Related: <a href="enumerable.html#method-i-min"><code>min</code></a>, <a href="enumerable.html#method-i-minmax"><code>minmax</code></a>, <a href="enumerable.html#method-i-max_by"><code>max_by</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-minmax"> <a href="#method-i-minmax" title="Link to this method"> <span class="method-callseq"> minmax → [minimum, maximum] </span> </a> </div> <div class="method-heading"> <a href="#method-i-minmax" title="Link to this method"> <span class="method-callseq"> minmax {|a, b| ... } → [minimum, maximum] </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="minmax-source"> <pre class="c" data-language="c">static VALUE
enum_minmax(VALUE obj)
{
    VALUE memo;
    struct minmax_t *m = NEW_MEMO_FOR(struct minmax_t, memo);

    m-&gt;min = Qundef;
    m-&gt;last = Qundef;
    if (rb_block_given_p()) {
        rb_block_call(obj, id_each, 0, 0, minmax_ii, memo);
        if (!UNDEF_P(m-&gt;last))
            minmax_ii_update(m-&gt;last, m-&gt;last, m);
    }
    else {
        rb_block_call(obj, id_each, 0, 0, minmax_i, memo);
        if (!UNDEF_P(m-&gt;last))
            minmax_i_update(m-&gt;last, m-&gt;last, m);
    }
    if (!UNDEF_P(m-&gt;min)) {
        return rb_assoc_new(m-&gt;min, m-&gt;max);
    }
    return rb_assoc_new(Qnil, Qnil);
}</pre> </div>  <p>Returns a 2-element array containing the minimum and maximum elements according to a given criterion. The ordering of equal elements is indeterminate and may be unstable.</p> <p>With no argument and no block, returns the minimum and maximum elements, using the elements’ own method &lt;=&gt; for comparison:</p> <pre class="ruby" data-language="ruby">(1..4).minmax                   # =&gt; [1, 4]
(-4..-1).minmax                 # =&gt; [-4, -1]
%w[d c b a].minmax              # =&gt; ["a", "d"]
{foo: 0, bar: 1, baz: 2}.minmax # =&gt; [[:bar, 1], [:foo, 0]]
[].minmax                       # =&gt; [nil, nil]
</pre> <p>With a block given, returns the minimum and maximum elements as determined by the block:</p> <pre class="ruby" data-language="ruby">%w[xxx x xxxx xx].minmax {|a, b| a.size &lt;=&gt; b.size } # =&gt; ["x", "xxxx"]
h = {foo: 0, bar: 1, baz: 2}
h.minmax {|pair1, pair2| pair1[1] &lt;=&gt; pair2[1] }
# =&gt; [[:foo, 0], [:baz, 2]]
[].minmax {|a, b| a &lt;=&gt; b }                          # =&gt; [nil, nil]
</pre> <p>Related: <a href="enumerable.html#method-i-min"><code>min</code></a>, <a href="enumerable.html#method-i-max"><code>max</code></a>, <a href="enumerable.html#method-i-minmax_by"><code>minmax_by</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-minmax_by"> <a href="#method-i-minmax_by" title="Link to this method"> <span class="method-callseq"> minmax_by {|element| ... } → [minimum, maximum] </span> </a> </div> <div class="method-heading"> <a href="#method-i-minmax_by" title="Link to this method"> <span class="method-callseq"> minmax_by → enumerator </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="minmax_by-source"> <pre class="c" data-language="c">static VALUE
enum_minmax_by(VALUE obj)
{
    VALUE memo;
    struct minmax_by_t *m = NEW_MEMO_FOR(struct minmax_by_t, memo);

    RETURN_SIZED_ENUMERATOR(obj, 0, 0, enum_size);

    m-&gt;min_bv = Qundef;
    m-&gt;max_bv = Qundef;
    m-&gt;min = Qnil;
    m-&gt;max = Qnil;
    m-&gt;last_bv = Qundef;
    m-&gt;last = Qundef;
    rb_block_call(obj, id_each, 0, 0, minmax_by_i, memo);
    if (!UNDEF_P(m-&gt;last_bv))
        minmax_by_i_update(m-&gt;last_bv, m-&gt;last_bv, m-&gt;last, m-&gt;last, m);
    m = MEMO_FOR(struct minmax_by_t, memo);
    return rb_assoc_new(m-&gt;min, m-&gt;max);
}</pre> </div>  <p>Returns a 2-element array containing the elements for which the block returns minimum and maximum values:</p> <pre class="ruby" data-language="ruby">(1..4).minmax_by {|element| -element }
# =&gt; [4, 1]
%w[a b c d].minmax_by {|element| -element.ord }
# =&gt; ["d", "a"]
{foo: 0, bar: 1, baz: 2}.minmax_by {|key, value| -value }
# =&gt; [[:baz, 2], [:foo, 0]]
[].minmax_by {|element| -element }
# =&gt; [nil, nil]
</pre> <p>Returns an <a href="enumerator.html"><code>Enumerator</code></a> if no block is given.</p> <p>Related: <a href="enumerable.html#method-i-max_by"><code>max_by</code></a>, <a href="enumerable.html#method-i-minmax"><code>minmax</code></a>, <a href="enumerable.html#method-i-min_by"><code>min_by</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-none-3F"> <a href="#method-i-none-3F" title="Link to this method"> <span class="method-callseq"> none? → true or false </span> </a> </div> <div class="method-heading"> <a href="#method-i-none-3F" title="Link to this method"> <span class="method-callseq"> none?(pattern) → true or false </span> </a> </div> <div class="method-heading"> <a href="#method-i-none-3F" title="Link to this method"> <span class="method-callseq"> none? {|element| ... } → true or false </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="none-3F-source"> <pre class="c" data-language="c">static VALUE
enum_none(int argc, VALUE *argv, VALUE obj)
{
    struct MEMO *memo = MEMO_ENUM_NEW(Qtrue);

    WARN_UNUSED_BLOCK(argc);
    ENUM_BLOCK_CALL(none);
    return memo-&gt;v1;
}</pre> </div>  <p>Returns whether no element meets a given criterion.</p> <p>With no argument and no block, returns whether no element is truthy:</p> <pre class="ruby" data-language="ruby">(1..4).none?           # =&gt; false
[nil, false].none?     # =&gt; true
{foo: 0}.none?         # =&gt; false
{foo: 0, bar: 1}.none? # =&gt; false
[].none?               # =&gt; true
</pre> <p>With argument <code>pattern</code> and no block, returns whether for no element <code>element</code>, <code>pattern === element</code>:</p> <pre class="ruby" data-language="ruby">[nil, false, 1.1].none?(Integer)      # =&gt; true
%w[bar baz bat bam].none?(/m/)        # =&gt; false
%w[bar baz bat bam].none?(/foo/)      # =&gt; true
%w[bar baz bat bam].none?('ba')       # =&gt; true
{foo: 0, bar: 1, baz: 2}.none?(Hash)  # =&gt; true
{foo: 0}.none?(Array)                 # =&gt; false
[].none?(Integer)                     # =&gt; true
</pre> <p>With a block given, returns whether the block returns a truthy value for no element:</p> <pre class="ruby" data-language="ruby">(1..4).none? {|element| element &lt; 1 }                     # =&gt; true
(1..4).none? {|element| element &lt; 2 }                     # =&gt; false
{foo: 0, bar: 1, baz: 2}.none? {|key, value| value &lt; 0 }  # =&gt; true
{foo: 0, bar: 1, baz: 2}.none? {|key, value| value &lt; 1 } # =&gt; false
</pre> <p>Related: <a href="enumerable.html#method-i-one-3F"><code>one?</code></a>, <a href="enumerable.html#method-i-all-3F"><code>all?</code></a>, <a href="enumerable.html#method-i-any-3F"><code>any?</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-one-3F"> <a href="#method-i-one-3F" title="Link to this method"> <span class="method-callseq"> one? → true or false </span> </a> </div> <div class="method-heading"> <a href="#method-i-one-3F" title="Link to this method"> <span class="method-callseq"> one?(pattern) → true or false </span> </a> </div> <div class="method-heading"> <a href="#method-i-one-3F" title="Link to this method"> <span class="method-callseq"> one? {|element| ... } → true or false </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="one-3F-source"> <pre class="c" data-language="c">static VALUE
enum_one(int argc, VALUE *argv, VALUE obj)
{
    struct MEMO *memo = MEMO_ENUM_NEW(Qundef);
    VALUE result;

    WARN_UNUSED_BLOCK(argc);
    ENUM_BLOCK_CALL(one);
    result = memo-&gt;v1;
    if (UNDEF_P(result)) return Qfalse;
    return result;
}</pre> </div>  <p>Returns whether exactly one element meets a given criterion.</p> <p>With no argument and no block, returns whether exactly one element is truthy:</p> <pre class="ruby" data-language="ruby">(1..1).one?           # =&gt; true
[1, nil, false].one?  # =&gt; true
(1..4).one?           # =&gt; false
{foo: 0}.one?         # =&gt; true
{foo: 0, bar: 1}.one? # =&gt; false
[].one?               # =&gt; false
</pre> <p>With argument <code>pattern</code> and no block, returns whether for exactly one element <code>element</code>, <code>pattern === element</code>:</p> <pre class="ruby" data-language="ruby">[nil, false, 0].one?(Integer)        # =&gt; true
[nil, false, 0].one?(Numeric)        # =&gt; true
[nil, false, 0].one?(Float)          # =&gt; false
%w[bar baz bat bam].one?(/m/)        # =&gt; true
%w[bar baz bat bam].one?(/foo/)      # =&gt; false
%w[bar baz bat bam].one?('ba')       # =&gt; false
{foo: 0, bar: 1, baz: 2}.one?(Array) # =&gt; false
{foo: 0}.one?(Array)                 # =&gt; true
[].one?(Integer)                     # =&gt; false
</pre> <p>With a block given, returns whether the block returns a truthy value for exactly one element:</p> <pre class="ruby" data-language="ruby">(1..4).one? {|element| element &lt; 2 }                     # =&gt; true
(1..4).one? {|element| element &lt; 1 }                     # =&gt; false
{foo: 0, bar: 1, baz: 2}.one? {|key, value| value &lt; 1 }  # =&gt; true
{foo: 0, bar: 1, baz: 2}.one? {|key, value| value &lt; 2 } # =&gt; false
</pre> <p>Related: <a href="enumerable.html#method-i-none-3F"><code>none?</code></a>, <a href="enumerable.html#method-i-all-3F"><code>all?</code></a>, <a href="enumerable.html#method-i-any-3F"><code>any?</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-partition"> <a href="#method-i-partition" title="Link to this method"> <span class="method-callseq"> partition {|element| ... } → [true_array, false_array] </span> </a> </div> <div class="method-heading"> <a href="#method-i-partition" title="Link to this method"> <span class="method-callseq"> partition → enumerator </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="partition-source"> <pre class="c" data-language="c">static VALUE
enum_partition(VALUE obj)
{
    struct MEMO *memo;

    RETURN_SIZED_ENUMERATOR(obj, 0, 0, enum_size);

    memo = MEMO_NEW(rb_ary_new(), rb_ary_new(), 0);
    rb_block_call(obj, id_each, 0, 0, partition_i, (VALUE)memo);

    return rb_assoc_new(memo-&gt;v1, memo-&gt;v2);
}</pre> </div>  <p>With a block given, returns an array of two arrays:</p> <ul>
<li> <p>The first having those elements for which the block returns a truthy value.</p> </li>
<li> <p>The other having all other elements.</p> </li>
</ul> <p>Examples:</p> <pre class="ruby" data-language="ruby">p = (1..4).partition {|i| i.even? }
p # =&gt; [[2, 4], [1, 3]]
p = ('a'..'d').partition {|c| c &lt; 'c' }
p # =&gt; [["a", "b"], ["c", "d"]]
h = {foo: 0, bar: 1, baz: 2, bat: 3}
p = h.partition {|key, value| key.start_with?('b') }
p # =&gt; [[[:bar, 1], [:baz, 2], [:bat, 3]], [[:foo, 0]]]
p = h.partition {|key, value| value &lt; 2 }
p # =&gt; [[[:foo, 0], [:bar, 1]], [[:baz, 2], [:bat, 3]]]
</pre> <p>With no block given, returns an <a href="enumerator.html"><code>Enumerator</code></a>.</p> <p>Related: <a href="enumerable.html#method-i-group_by"><code>Enumerable#group_by</code></a>.</p> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-reduce"> <a href="#method-i-reduce" title="Link to this method"> <span class="method-name">reduce</span> </a> </div> </div> <div class="aliases"> Alias for: <a href="enumerable.html#method-i-inject">inject</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-reject"> <a href="#method-i-reject" title="Link to this method"> <span class="method-callseq"> reject {|element| ... } → array </span> </a> </div> <div class="method-heading"> <a href="#method-i-reject" title="Link to this method"> <span class="method-callseq"> reject → enumerator </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="reject-source"> <pre class="c" data-language="c">static VALUE
enum_reject(VALUE obj)
{
    VALUE ary;

    RETURN_SIZED_ENUMERATOR(obj, 0, 0, enum_size);

    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, reject_i, ary);

    return ary;
}</pre> </div>  <p>Returns an array of objects rejected by the block.</p> <p>With a block given, calls the block with successive elements; returns an array of those elements for which the block returns <code>nil</code> or <code>false</code>:</p> <pre class="ruby" data-language="ruby">(0..9).reject {|i| i * 2 if i.even? }                             # =&gt; [1, 3, 5, 7, 9]
{foo: 0, bar: 1, baz: 2}.reject {|key, value| key if value.odd? } # =&gt; {:foo=&gt;0, :baz=&gt;2}
</pre> <p>When no block given, returns an <a href="enumerator.html"><code>Enumerator</code></a>.</p> <p>Related: <a href="enumerable.html#method-i-select"><code>select</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-reverse_each"> <a href="#method-i-reverse_each" title="Link to this method"> <span class="method-callseq"> reverse_each(*args) {|element| ... } → self </span> </a> </div> <div class="method-heading"> <a href="#method-i-reverse_each" title="Link to this method"> <span class="method-callseq"> reverse_each(*args) → enumerator </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="reverse_each-source"> <pre class="c" data-language="c">static VALUE
enum_reverse_each(int argc, VALUE *argv, VALUE obj)
{
    VALUE ary;
    long len;

    RETURN_SIZED_ENUMERATOR(obj, argc, argv, enum_size);

    ary = enum_to_a(argc, argv, obj);

    len = RARRAY_LEN(ary);
    while (len--) {
        long nlen;
        rb_yield(RARRAY_AREF(ary, len));
        nlen = RARRAY_LEN(ary);
        if (nlen &lt; len) {
            len = nlen;
        }
    }

    return obj;
}</pre> </div>  <p>With a block given, calls the block with each element, but in reverse order; returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">a = []
(1..4).reverse_each {|element| a.push(-element) } # =&gt; 1..4
a # =&gt; [-4, -3, -2, -1]

a = []
%w[a b c d].reverse_each {|element| a.push(element) }
# =&gt; ["a", "b", "c", "d"]
a # =&gt; ["d", "c", "b", "a"]

a = []
h.reverse_each {|element| a.push(element) }
# =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}
a # =&gt; [[:baz, 2], [:bar, 1], [:foo, 0]]
</pre> <p>With no block given, returns an <a href="enumerator.html"><code>Enumerator</code></a>.</p> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-select"> <a href="#method-i-select" title="Link to this method"> <span class="method-callseq"> select {|element| ... } → array </span> </a> </div> <div class="method-heading"> <a href="#method-i-select" title="Link to this method"> <span class="method-callseq"> select → enumerator </span> </a> </div> </div> <div class="method-description"> <p>Returns an array containing elements selected by the block.</p> <p>With a block given, calls the block with successive elements; returns an array of those elements for which the block returns a truthy value:</p> <pre class="ruby" data-language="ruby">(0..9).select {|element| element % 3 == 0 } # =&gt; [0, 3, 6, 9]
a = {foo: 0, bar: 1, baz: 2}.select {|key, value| key.start_with?('b') }
a # =&gt; {:bar=&gt;1, :baz=&gt;2}
</pre> <p>With no block given, returns an <a href="enumerator.html"><code>Enumerator</code></a>.</p> <p>Related: <a href="enumerable.html#method-i-reject"><code>reject</code></a>.</p> </div> <div class="aliases"> Alias for: <a href="enumerable.html#method-i-find_all">find_all</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-slice_after"> <a href="#method-i-slice_after" title="Link to this method"> <span class="method-callseq"> slice_after(pattern) → an_enumerator </span> </a> </div> <div class="method-heading"> <a href="#method-i-slice_after" title="Link to this method"> <span class="method-callseq"> slice_after { |elt| bool } → an_enumerator </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="slice_after-source"> <pre class="c" data-language="c">static VALUE
enum_slice_after(int argc, VALUE *argv, VALUE enumerable)
{
    VALUE enumerator;
    VALUE pat = Qnil, pred = Qnil;

    if (rb_block_given_p()) {
        if (0 &lt; argc)
            rb_raise(rb_eArgError, "both pattern and block are given");
        pred = rb_block_proc();
    }
    else {
        rb_scan_args(argc, argv, "1", &amp;pat);
    }

    enumerator = rb_obj_alloc(rb_cEnumerator);
    rb_ivar_set(enumerator, id_sliceafter_enum, enumerable);
    rb_ivar_set(enumerator, id_sliceafter_pat, pat);
    rb_ivar_set(enumerator, id_sliceafter_pred, pred);

    rb_block_call(enumerator, idInitialize, 0, 0, sliceafter_i, enumerator);
    return enumerator;
}</pre> </div>  <p>Creates an enumerator for each chunked elements. The ends of chunks are defined by <em>pattern</em> and the block.</p> <p>If <code><em>pattern</em> === <em>elt</em></code> returns <code>true</code> or the block returns <code>true</code> for the element, the element is end of a chunk.</p> <p>The <code>===</code> and <em>block</em> is called from the first element to the last element of <em>enum</em>.</p> <p>The result enumerator yields the chunked elements as an array. So <code>each</code> method can be called as follows:</p> <pre>enum.slice_after(pattern).each { |ary| ... }
enum.slice_after { |elt| bool }.each { |ary| ... }</pre> <p>Other methods of the <a href="enumerator.html"><code>Enumerator</code></a> class and <a href="enumerable.html"><code>Enumerable</code></a> module, such as <code>map</code>, etc., are also usable.</p> <p>For example, continuation lines (lines end with backslash) can be concatenated as follows:</p> <pre class="ruby" data-language="ruby">lines = ["foo\n", "bar\\\n", "baz\n", "\n", "qux\n"]
e = lines.slice_after(/(?&lt;!\\)\n\z/)
p e.to_a
#=&gt; [["foo\n"], ["bar\\\n", "baz\n"], ["\n"], ["qux\n"]]
p e.map {|ll| ll[0...-1].map {|l| l.sub(/\\\n\z/, "") }.join + ll.last }
#=&gt;["foo\n", "barbaz\n", "\n", "qux\n"]
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-slice_before"> <a href="#method-i-slice_before" title="Link to this method"> <span class="method-callseq"> slice_before(pattern) → enumerator </span> </a> </div> <div class="method-heading"> <a href="#method-i-slice_before" title="Link to this method"> <span class="method-callseq"> slice_before {|elt| ... } → enumerator </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="slice_before-source"> <pre class="c" data-language="c">static VALUE
enum_slice_before(int argc, VALUE *argv, VALUE enumerable)
{
    VALUE enumerator;

    if (rb_block_given_p()) {
        if (argc != 0)
            rb_error_arity(argc, 0, 0);
        enumerator = rb_obj_alloc(rb_cEnumerator);
        rb_ivar_set(enumerator, id_slicebefore_sep_pred, rb_block_proc());
    }
    else {
        VALUE sep_pat;
        rb_scan_args(argc, argv, "1", &amp;sep_pat);
        enumerator = rb_obj_alloc(rb_cEnumerator);
        rb_ivar_set(enumerator, id_slicebefore_sep_pat, sep_pat);
    }
    rb_ivar_set(enumerator, id_slicebefore_enumerable, enumerable);
    rb_block_call(enumerator, idInitialize, 0, 0, slicebefore_i, enumerator);
    return enumerator;
}</pre> </div>  <p>With argument <code>pattern</code>, returns an enumerator that uses the pattern to partition elements into arrays (“slices”). An element begins a new slice if <code>element === pattern</code> (or if it is the first element).</p> <pre class="ruby" data-language="ruby">a = %w[foo bar fop for baz fob fog bam foy]
e = a.slice_before(/ba/) # =&gt; #&lt;Enumerator: ...&gt;
e.each {|array| p array }
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">["foo"]
["bar", "fop", "for"]
["baz", "fob", "fog"]
["bam", "foy"]
</pre> <p>With a block, returns an enumerator that uses the block to partition elements into arrays. An element begins a new slice if its block return is a truthy value (or if it is the first element):</p> <pre class="ruby" data-language="ruby">e = (1..20).slice_before {|i| i % 4 == 2 } # =&gt; #&lt;Enumerator: ...&gt;
e.each {|array| p array }
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">[1]
[2, 3, 4, 5]
[6, 7, 8, 9]
[10, 11, 12, 13]
[14, 15, 16, 17]
[18, 19, 20]
</pre> <p>Other methods of the <a href="enumerator.html"><code>Enumerator</code></a> class and <a href="enumerable.html"><code>Enumerable</code></a> module, such as <a href="enumerable.html#method-i-to_a"><code>to_a</code></a>, <code>map</code>, etc., are also usable.</p> <p>For example, iteration over ChangeLog entries can be implemented as follows:</p> <pre class="ruby" data-language="ruby"># iterate over ChangeLog entries.
open("ChangeLog") { |f|
  f.slice_before(/\A\S/).each { |e| pp e }
}

# same as above.  block is used instead of pattern argument.
open("ChangeLog") { |f|
  f.slice_before { |line| /\A\S/ === line }.each { |e| pp e }
}
</pre> <p>“svn proplist -R” produces multiline output for each file. They can be chunked as follows:</p> <pre class="ruby" data-language="ruby">IO.popen([{"LC_ALL"=&gt;"C"}, "svn", "proplist", "-R"]) { |f|
  f.lines.slice_before(/\AProp/).each { |lines| p lines }
}
#=&gt; ["Properties on '.':\n", "  svn:ignore\n", "  svk:merge\n"]
#   ["Properties on 'goruby.c':\n", "  svn:eol-style\n"]
#   ["Properties on 'complex.c':\n", "  svn:mime-type\n", "  svn:eol-style\n"]
#   ["Properties on 'regparse.c':\n", "  svn:eol-style\n"]
#   ...
</pre> <p>If the block needs to maintain state over multiple elements, local variables can be used. For example, three or more consecutive increasing numbers can be squashed as follows (see <a href="enumerable.html#method-i-chunk_while"><code>chunk_while</code></a> for a better way):</p> <pre class="ruby" data-language="ruby">a = [0, 2, 3, 4, 6, 7, 9]
prev = a[0]
p a.slice_before { |e|
  prev, prev2 = e, prev
  prev2 + 1 != e
}.map { |es|
  es.length &lt;= 2 ? es.join(",") : "#{es.first}-#{es.last}"
}.join(",")
#=&gt; "0,2-4,6,7,9"
</pre> <p>However local variables should be used carefully if the result enumerator is enumerated twice or more. The local variables should be initialized for each enumeration. <a href="enumerator.html#method-c-new"><code>Enumerator.new</code></a> can be used to do it.</p> <pre class="ruby" data-language="ruby"># Word wrapping.  This assumes all characters have same width.
def wordwrap(words, maxwidth)
  Enumerator.new {|y|
    # cols is initialized in Enumerator.new.
    cols = 0
    words.slice_before { |w|
      cols += 1 if cols != 0
      cols += w.length
      if maxwidth &lt; cols
        cols = w.length
        true
      else
        false
      end
    }.each {|ws| y.yield ws }
  }
end
text = (1..20).to_a.join(" ")
enum = wordwrap(text.split(/\s+/), 10)
puts "-"*10
enum.each { |ws| puts ws.join(" ") } # first enumeration.
puts "-"*10
enum.each { |ws| puts ws.join(" ") } # second enumeration generates same result as the first.
puts "-"*10
#=&gt; ----------
#   1 2 3 4 5
#   6 7 8 9 10
#   11 12 13
#   14 15 16
#   17 18 19
#   20
#   ----------
#   1 2 3 4 5
#   6 7 8 9 10
#   11 12 13
#   14 15 16
#   17 18 19
#   20
#   ----------
</pre> <p>mbox contains series of mails which start with Unix From line. So each mail can be extracted by slice before Unix From line.</p> <pre class="ruby" data-language="ruby"># parse mbox
open("mbox") { |f|
  f.slice_before { |line|
    line.start_with? "From "
  }.each { |mail|
    unix_from = mail.shift
    i = mail.index("\n")
    header = mail[0...i]
    body = mail[(i+1)..-1]
    body.pop if body.last == "\n"
    fields = header.slice_before { |line| !" \t".include?(line[0]) }.to_a
    p unix_from
    pp fields
    pp body
  }
}

# split mails in mbox (slice before Unix From line after an empty line)
open("mbox") { |f|
  emp = true
  f.slice_before { |line|
    prevemp = emp
    emp = line == "\n"
    prevemp &amp;&amp; line.start_with?("From ")
  }.each { |mail|
    mail.pop if mail.last == "\n"
    pp mail
  }
}
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-slice_when"> <a href="#method-i-slice_when" title="Link to this method"> <span class="method-callseq"> slice_when {|elt_before, elt_after| bool } → an_enumerator </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="slice_when-source"> <pre class="c" data-language="c">static VALUE
enum_slice_when(VALUE enumerable)
{
    VALUE enumerator;
    VALUE pred;

    pred = rb_block_proc();

    enumerator = rb_obj_alloc(rb_cEnumerator);
    rb_ivar_set(enumerator, id_slicewhen_enum, enumerable);
    rb_ivar_set(enumerator, id_slicewhen_pred, pred);
    rb_ivar_set(enumerator, id_slicewhen_inverted, Qfalse);

    rb_block_call(enumerator, idInitialize, 0, 0, slicewhen_i, enumerator);
    return enumerator;
}</pre> </div>  <p>Creates an enumerator for each chunked elements. The beginnings of chunks are defined by the block.</p> <p>This method splits each chunk using adjacent elements, <em>elt_before</em> and <em>elt_after</em>, in the receiver enumerator. This method split chunks between <em>elt_before</em> and <em>elt_after</em> where the block returns <code>true</code>.</p> <p>The block is called the length of the receiver enumerator minus one.</p> <p>The result enumerator yields the chunked elements as an array. So <code>each</code> method can be called as follows:</p> <pre>enum.slice_when { |elt_before, elt_after| bool }.each { |ary| ... }</pre> <p>Other methods of the <a href="enumerator.html"><code>Enumerator</code></a> class and <a href="enumerable.html"><code>Enumerable</code></a> module, such as <a href="enumerable.html#method-i-to_a"><code>to_a</code></a>, <code>map</code>, etc., are also usable.</p> <p>For example, one-by-one increasing subsequence can be chunked as follows:</p> <pre class="ruby" data-language="ruby">a = [1,2,4,9,10,11,12,15,16,19,20,21]
b = a.slice_when {|i, j| i+1 != j }
p b.to_a #=&gt; [[1, 2], [4], [9, 10, 11, 12], [15, 16], [19, 20, 21]]
c = b.map {|a| a.length &lt; 3 ? a : "#{a.first}-#{a.last}" }
p c #=&gt; [[1, 2], [4], "9-12", [15, 16], "19-21"]
d = c.join(",")
p d #=&gt; "1,2,4,9-12,15,16,19-21"
</pre> <p>Near elements (threshold: 6) in sorted array can be chunked as follows:</p> <pre class="ruby" data-language="ruby">a = [3, 11, 14, 25, 28, 29, 29, 41, 55, 57]
p a.slice_when {|i, j| 6 &lt; j - i }.to_a
#=&gt; [[3], [11, 14], [25, 28, 29, 29], [41], [55, 57]]
</pre> <p>Increasing (non-decreasing) subsequence can be chunked as follows:</p> <pre class="ruby" data-language="ruby">a = [0, 9, 2, 2, 3, 2, 7, 5, 9, 5]
p a.slice_when {|i, j| i &gt; j }.to_a
#=&gt; [[0, 9], [2, 2, 3], [2, 7], [5, 9], [5]]
</pre> <p>Adjacent evens and odds can be chunked as follows: (<a href="enumerable.html#method-i-chunk"><code>Enumerable#chunk</code></a> is another way to do it.)</p> <pre class="ruby" data-language="ruby">a = [7, 5, 9, 2, 0, 7, 9, 4, 2, 0]
p a.slice_when {|i, j| i.even? != j.even? }.to_a
#=&gt; [[7, 5, 9], [2, 0], [7, 9], [4, 2, 0]]
</pre> <p>Paragraphs (non-empty lines with trailing empty lines) can be chunked as follows: (See <a href="enumerable.html#method-i-chunk"><code>Enumerable#chunk</code></a> to ignore empty lines.)</p> <pre class="ruby" data-language="ruby">lines = ["foo\n", "bar\n", "\n", "baz\n", "qux\n"]
p lines.slice_when {|l1, l2| /\A\s*\z/ =~ l1 &amp;&amp; /\S/ =~ l2 }.to_a
#=&gt; [["foo\n", "bar\n", "\n"], ["baz\n", "qux\n"]]
</pre> <p><a href="enumerable.html#method-i-chunk_while"><code>Enumerable#chunk_while</code></a> does the same, except splitting when the block returns <code>false</code> instead of <code>true</code>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-sort"> <a href="#method-i-sort" title="Link to this method"> <span class="method-callseq"> sort → array </span> </a> </div> <div class="method-heading"> <a href="#method-i-sort" title="Link to this method"> <span class="method-callseq"> sort {|a, b| ... } → array </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="sort-source"> <pre class="c" data-language="c">static VALUE
enum_sort(VALUE obj)
{
    return rb_ary_sort_bang(enum_to_a(0, 0, obj));
}</pre> </div>  <p>Returns an array containing the sorted elements of <code>self</code>. The ordering of equal elements is indeterminate and may be unstable.</p> <p>With no block given, the sort compares using the elements’ own method &lt;=&gt;:</p> <pre class="ruby" data-language="ruby">%w[b c a d].sort              # =&gt; ["a", "b", "c", "d"]
{foo: 0, bar: 1, baz: 2}.sort # =&gt; [[:bar, 1], [:baz, 2], [:foo, 0]]
</pre> <p>With a block given, comparisons in the block determine the ordering. The block is called with two elements <code>a</code> and <code>b</code>, and must return:</p> <ul>
<li> <p>A negative integer if <code>a &lt; b</code>.</p> </li>
<li> <p>Zero if <code>a == b</code>.</p> </li>
<li> <p>A positive integer if <code>a &gt; b</code>.</p> </li>
</ul> <p>Examples:</p> <pre class="ruby" data-language="ruby">a = %w[b c a d]
a.sort {|a, b| b &lt;=&gt; a } # =&gt; ["d", "c", "b", "a"]
h = {foo: 0, bar: 1, baz: 2}
h.sort {|a, b| b &lt;=&gt; a } # =&gt; [[:foo, 0], [:baz, 2], [:bar, 1]]
</pre> <p>See also <a href="enumerable.html#method-i-sort_by"><code>sort_by</code></a>. It implements a Schwartzian transform which is useful when key computation or comparison is expensive.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-sort_by"> <a href="#method-i-sort_by" title="Link to this method"> <span class="method-callseq"> sort_by {|element| ... } → array </span> </a> </div> <div class="method-heading"> <a href="#method-i-sort_by" title="Link to this method"> <span class="method-callseq"> sort_by → enumerator </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="sort_by-source"> <pre class="c" data-language="c">static VALUE
enum_sort_by(VALUE obj)
{
    VALUE ary, buf;
    struct MEMO *memo;
    long i;
    struct sort_by_data *data;

    RETURN_SIZED_ENUMERATOR(obj, 0, 0, enum_size);

    if (RB_TYPE_P(obj, T_ARRAY) &amp;&amp; RARRAY_LEN(obj) &lt;= LONG_MAX/2) {
        ary = rb_ary_new2(RARRAY_LEN(obj)*2);
    }
    else {
        ary = rb_ary_new();
    }
    RBASIC_CLEAR_CLASS(ary);
    buf = rb_ary_hidden_new(SORT_BY_BUFSIZE*2);
    rb_ary_store(buf, SORT_BY_BUFSIZE*2-1, Qnil);
    memo = MEMO_NEW(0, 0, 0);
    data = (struct sort_by_data *)&amp;memo-&gt;v1;
    RB_OBJ_WRITE(memo, &amp;data-&gt;ary, ary);
    RB_OBJ_WRITE(memo, &amp;data-&gt;buf, buf);
    data-&gt;n = 0;
    data-&gt;primitive_uniformed = SORT_BY_UNIFORMED((CMP_OPTIMIZABLE(FLOAT) &amp;&amp; CMP_OPTIMIZABLE(INTEGER)),
                                                  CMP_OPTIMIZABLE(FLOAT),
                                                  CMP_OPTIMIZABLE(INTEGER));
    rb_block_call(obj, id_each, 0, 0, sort_by_i, (VALUE)memo);
    ary = data-&gt;ary;
    buf = data-&gt;buf;
    if (data-&gt;n) {
        rb_ary_resize(buf, data-&gt;n*2);
        rb_ary_concat(ary, buf);
    }
    if (RARRAY_LEN(ary) &gt; 2) {
        if (data-&gt;primitive_uniformed) {
            RARRAY_PTR_USE(ary, ptr,
                           rb_uniform_intro_sort_2((struct rb_uniform_sort_data*)ptr,
                                                   (struct rb_uniform_sort_data*)(ptr + RARRAY_LEN(ary))));
        }
        else {
            RARRAY_PTR_USE(ary, ptr,
                           ruby_qsort(ptr, RARRAY_LEN(ary)/2, 2*sizeof(VALUE),
                                      sort_by_cmp, (void *)ary));
        }
    }
    if (RBASIC(ary)-&gt;klass) {
        rb_raise(rb_eRuntimeError, "sort_by reentered");
    }
    for (i=1; i&lt;RARRAY_LEN(ary); i+=2) {
        RARRAY_ASET(ary, i/2, RARRAY_AREF(ary, i));
    }
    rb_ary_resize(ary, RARRAY_LEN(ary)/2);
    RBASIC_SET_CLASS_RAW(ary, rb_cArray);

    return ary;
}</pre> </div>  <p>With a block given, returns an array of elements of <code>self</code>, sorted according to the value returned by the block for each element. The ordering of equal elements is indeterminate and may be unstable.</p> <p>Examples:</p> <pre class="ruby" data-language="ruby">a = %w[xx xxx x xxxx]
a.sort_by {|s| s.size }        # =&gt; ["x", "xx", "xxx", "xxxx"]
a.sort_by {|s| -s.size }       # =&gt; ["xxxx", "xxx", "xx", "x"]
h = {foo: 2, bar: 1, baz: 0}
h.sort_by{|key, value| value } # =&gt; [[:baz, 0], [:bar, 1], [:foo, 2]]
h.sort_by{|key, value| key }   # =&gt; [[:bar, 1], [:baz, 0], [:foo, 2]]
</pre> <p>With no block given, returns an <a href="enumerator.html"><code>Enumerator</code></a>.</p> <p>The current implementation of <a href="enumerable.html#method-i-sort_by"><code>sort_by</code></a> generates an array of tuples containing the original collection element and the mapped value. This makes <a href="enumerable.html#method-i-sort_by"><code>sort_by</code></a> fairly expensive when the keysets are simple.</p> <pre class="ruby" data-language="ruby">require 'benchmark'

a = (1..100000).map { rand(100000) }

Benchmark.bm(10) do |b|
  b.report("Sort")    { a.sort }
  b.report("Sort by") { a.sort_by { |a| a } }
end
</pre> <p><em>produces:</em></p> <pre>user     system      total        real
Sort        0.180000   0.000000   0.180000 (  0.175469)
Sort by     1.980000   0.040000   2.020000 (  2.013586)</pre> <p>However, consider the case where comparing the keys is a non-trivial operation. The following code sorts some files on modification time using the basic <a href="enumerable.html#method-i-sort"><code>sort</code></a> method.</p> <pre class="ruby" data-language="ruby">files = Dir["*"]
sorted = files.sort { |a, b| File.new(a).mtime &lt;=&gt; File.new(b).mtime }
sorted   #=&gt; ["mon", "tues", "wed", "thurs"]
</pre> <p>This sort is inefficient: it generates two new <a href="file.html"><code>File</code></a> objects during every comparison. A slightly better technique is to use the <a href="kernel.html#method-i-test"><code>Kernel#test</code></a> method to generate the modification times directly.</p> <pre class="ruby" data-language="ruby">files = Dir["*"]
sorted = files.sort { |a, b|
  test(?M, a) &lt;=&gt; test(?M, b)
}
sorted   #=&gt; ["mon", "tues", "wed", "thurs"]
</pre> <p>This still generates many unnecessary <a href="time.html"><code>Time</code></a> objects. A more efficient technique is to cache the sort keys (modification times in this case) before the sort. Perl users often call this approach a Schwartzian transform, after Randal Schwartz. We construct a temporary array, where each element is an array containing our sort key along with the filename. We sort this array, and then extract the filename from the result.</p> <pre class="ruby" data-language="ruby">sorted = Dir["*"].collect { |f|
   [test(?M, f), f]
}.sort.collect { |f| f[1] }
sorted   #=&gt; ["mon", "tues", "wed", "thurs"]
</pre> <p>This is exactly what <a href="enumerable.html#method-i-sort_by"><code>sort_by</code></a> does internally.</p> <pre class="ruby" data-language="ruby">sorted = Dir["*"].sort_by { |f| test(?M, f) }
sorted   #=&gt; ["mon", "tues", "wed", "thurs"]
</pre> <p>To produce the reverse of a specific order, the following can be used:</p> <pre>ary.sort_by { ... }.reverse!</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-sum"> <a href="#method-i-sum" title="Link to this method"> <span class="method-callseq"> sum(initial_value = 0) → number </span> </a> </div> <div class="method-heading"> <a href="#method-i-sum" title="Link to this method"> <span class="method-callseq"> sum(initial_value = 0) {|element| ... } → object </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="sum-source"> <pre class="c" data-language="c">static VALUE
enum_sum(int argc, VALUE* argv, VALUE obj)
{
    struct enum_sum_memo memo;
    VALUE beg, end;
    int excl;

    memo.v = (rb_check_arity(argc, 0, 1) == 0) ? LONG2FIX(0) : argv[0];
    memo.block_given = rb_block_given_p();
    memo.n = 0;
    memo.r = Qundef;

    if ((memo.float_value = RB_FLOAT_TYPE_P(memo.v))) {
        memo.f = RFLOAT_VALUE(memo.v);
        memo.c = 0.0;
    }
    else {
        memo.f = 0.0;
        memo.c = 0.0;
    }

    if (RTEST(rb_range_values(obj, &amp;beg, &amp;end, &amp;excl))) {
        if (!memo.block_given &amp;&amp; !memo.float_value &amp;&amp;
                (FIXNUM_P(beg) || RB_BIGNUM_TYPE_P(beg)) &amp;&amp;
                (FIXNUM_P(end) || RB_BIGNUM_TYPE_P(end))) {
            return int_range_sum(beg, end, excl, memo.v);
        }
    }

    if (RB_TYPE_P(obj, T_HASH) &amp;&amp;
            rb_method_basic_definition_p(CLASS_OF(obj), id_each))
        hash_sum(obj, &amp;memo);
    else
        rb_block_call(obj, id_each, 0, 0, enum_sum_i, (VALUE)&amp;memo);

    if (memo.float_value) {
        return DBL2NUM(memo.f + memo.c);
    }
    else {
        if (memo.n != 0)
            memo.v = rb_fix_plus(LONG2FIX(memo.n), memo.v);
        if (!UNDEF_P(memo.r)) {
            memo.v = rb_rational_plus(memo.r, memo.v);
        }
        return memo.v;
    }
}</pre> </div>  <p>With no block given, returns the sum of <code>initial_value</code> and the elements:</p> <pre class="ruby" data-language="ruby">(1..100).sum          # =&gt; 5050
(1..100).sum(1)       # =&gt; 5051
('a'..'d').sum('foo') # =&gt; "fooabcd"
</pre> <p>Generally, the sum is computed using methods <code>+</code> and <code>each</code>; for performance optimizations, those methods may not be used, and so any redefinition of those methods may not have effect here.</p> <p>One such optimization: When possible, computes using Gauss’s summation formula <em>n(n+1)/2</em>:</p> <pre class="ruby" data-language="ruby">100 * (100 + 1) / 2 # =&gt; 5050
</pre> <p>With a block given, calls the block with each element; returns the sum of <code>initial_value</code> and the block return values:</p> <pre class="ruby" data-language="ruby">(1..4).sum {|i| i*i }                        # =&gt; 30
(1..4).sum(100) {|i| i*i }                   # =&gt; 130
h = {a: 0, b: 1, c: 2, d: 3, e: 4, f: 5}
h.sum {|key, value| value.odd? ? value : 0 } # =&gt; 9
('a'..'f').sum('x') {|c| c &lt; 'd' ? c : '' }  # =&gt; "xabc"
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-take"> <a href="#method-i-take" title="Link to this method"> <span class="method-callseq"> take(n) → array </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="take-source"> <pre class="c" data-language="c">static VALUE
enum_take(VALUE obj, VALUE n)
{
    struct MEMO *memo;
    VALUE result;
    long len = NUM2LONG(n);

    if (len &lt; 0) {
        rb_raise(rb_eArgError, "attempt to take negative size");
    }

    if (len == 0) return rb_ary_new2(0);
    result = rb_ary_new2(len);
    memo = MEMO_NEW(result, 0, len);
    rb_block_call(obj, id_each, 0, 0, take_i, (VALUE)memo);
    return result;
}</pre> </div>  <p>For non-negative integer <code>n</code>, returns the first <code>n</code> elements:</p> <pre class="ruby" data-language="ruby">r = (1..4)
r.take(2) # =&gt; [1, 2]
r.take(0) # =&gt; []

h = {foo: 0, bar: 1, baz: 2, bat: 3}
h.take(2) # =&gt; [[:foo, 0], [:bar, 1]]
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-take_while"> <a href="#method-i-take_while" title="Link to this method"> <span class="method-callseq"> take_while {|element| ... } → array </span> </a> </div> <div class="method-heading"> <a href="#method-i-take_while" title="Link to this method"> <span class="method-callseq"> take_while → enumerator </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="take_while-source"> <pre class="c" data-language="c">static VALUE
enum_take_while(VALUE obj)
{
    VALUE ary;

    RETURN_ENUMERATOR(obj, 0, 0);
    ary = rb_ary_new();
    rb_block_call(obj, id_each, 0, 0, take_while_i, ary);
    return ary;
}</pre> </div>  <p>Calls the block with successive elements as long as the block returns a truthy value; returns an array of all elements up to that point:</p> <pre class="ruby" data-language="ruby">(1..4).take_while{|i| i &lt; 3 } # =&gt; [1, 2]
h = {foo: 0, bar: 1, baz: 2}
h.take_while{|element| key, value = *element; value &lt; 2 }
# =&gt; [[:foo, 0], [:bar, 1]]
</pre> <p>With no block given, returns an <a href="enumerator.html"><code>Enumerator</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-tally"> <a href="#method-i-tally" title="Link to this method"> <span class="method-callseq"> tally(hash = {}) → hash </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="tally-source"> <pre class="c" data-language="c">static VALUE
enum_tally(int argc, VALUE *argv, VALUE obj)
{
    VALUE hash;
    if (rb_check_arity(argc, 0, 1)) {
        hash = rb_to_hash_type(argv[0]);
        rb_check_frozen(hash);
    }
    else {
        hash = rb_hash_new();
    }

    return enum_hashify_into(obj, 0, 0, tally_i, hash);
}</pre> </div>  <p>When argument <code>hash</code> is not given, returns a new hash whose keys are the distinct elements in <code>self</code>; each integer value is the count of occurrences of each element:</p> <pre class="ruby" data-language="ruby">%w[a b c b c a c b].tally # =&gt; {"a"=&gt;2, "b"=&gt;3, "c"=&gt;3}
</pre> <p>When argument <code>hash</code> is given, returns <code>hash</code>, possibly augmented; for each element <code>ele</code> in <code>self</code>:</p> <ul>
<li> <p>Adds it as a key with a zero value if that key does not already exist:</p> <pre class="ruby" data-language="ruby">hash[ele] = 0 unless hash.include?(ele)
</pre> </li>
<li> <p>Increments the value of key <code>ele</code>:</p> <pre class="ruby" data-language="ruby">hash[ele] += 1
</pre> </li>
</ul> <p>This is useful for accumulating tallies across multiple enumerables:</p> <pre class="ruby" data-language="ruby">h = {}                   # =&gt; {}
%w[a c d b c a].tally(h) # =&gt; {"a"=&gt;2, "c"=&gt;2, "d"=&gt;1, "b"=&gt;1}
%w[b a z].tally(h)       # =&gt; {"a"=&gt;3, "c"=&gt;2, "d"=&gt;1, "b"=&gt;2, "z"=&gt;1}
%w[b a m].tally(h)       # =&gt; {"a"=&gt;4, "c"=&gt;2, "d"=&gt;1, "b"=&gt;3, "z"=&gt;1, "m"=&gt;1}
</pre> <p>The key to be added or found for an element depends on the class of <code>self</code>; see <a href="enumerable.html#module-Enumerable-label-Enumerable+in+Ruby+Classes">Enumerable in Ruby Classes</a>.</p> <p>Examples:</p> <ul>
<li> <p><a href="array.html"><code>Array</code></a> (and certain array-like classes): the key is the element (as above).</p> </li>
<li> <p><a href="hash.html"><code>Hash</code></a> (and certain hash-like classes): the key is the 2-element array formed from the key-value pair:</p> <pre class="ruby" data-language="ruby">h = {}                        # =&gt; {}
{foo: 'a', bar: 'b'}.tally(h) # =&gt; {[:foo, "a"]=&gt;1, [:bar, "b"]=&gt;1}
{foo: 'c', bar: 'd'}.tally(h) # =&gt; {[:foo, "a"]=&gt;1, [:bar, "b"]=&gt;1, [:foo, "c"]=&gt;1, [:bar, "d"]=&gt;1}
{foo: 'a', bar: 'b'}.tally(h) # =&gt; {[:foo, "a"]=&gt;2, [:bar, "b"]=&gt;2, [:foo, "c"]=&gt;1, [:bar, "d"]=&gt;1}
{foo: 'c', bar: 'd'}.tally(h) # =&gt; {[:foo, "a"]=&gt;2, [:bar, "b"]=&gt;2, [:foo, "c"]=&gt;2, [:bar, "d"]=&gt;2}
</pre> </li>
</ul> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-to_a"> <a href="#method-i-to_a" title="Link to this method"> <span class="method-callseq"> to_a(*args) → array </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="to_a-source"> <pre class="c" data-language="c">static VALUE
enum_to_a(int argc, VALUE *argv, VALUE obj)
{
    VALUE ary = rb_ary_new();

    rb_block_call_kw(obj, id_each, argc, argv, collect_all, ary, RB_PASS_CALLED_KEYWORDS);

    return ary;
}</pre> </div>  <p>Returns an array containing the items in <code>self</code>:</p> <pre class="ruby" data-language="ruby">(0..4).to_a # =&gt; [0, 1, 2, 3, 4]
</pre> </div> <div class="aliases"> Also aliased as: <a href="enumerable.html#method-i-entries">entries</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-to_h"> <a href="#method-i-to_h" title="Link to this method"> <span class="method-callseq"> to_h(*args) → hash </span> </a> </div> <div class="method-heading"> <a href="#method-i-to_h" title="Link to this method"> <span class="method-callseq"> to_h(*args) {|element| ... } → hash </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="to_h-source"> <pre class="c" data-language="c">static VALUE
enum_to_h(int argc, VALUE *argv, VALUE obj)
{
    rb_block_call_func *iter = rb_block_given_p() ? enum_to_h_ii : enum_to_h_i;
    return enum_hashify(obj, argc, argv, iter);
}</pre> </div>  <p>When <code>self</code> consists of 2-element arrays, returns a hash each of whose entries is the key-value pair formed from one of those arrays:</p> <pre class="ruby" data-language="ruby">[[:foo, 0], [:bar, 1], [:baz, 2]].to_h # =&gt; {:foo=&gt;0, :bar=&gt;1, :baz=&gt;2}
</pre> <p>When a block is given, the block is called with each element of <code>self</code>; the block should return a 2-element array which becomes a key-value pair in the returned hash:</p> <pre class="ruby" data-language="ruby">(0..3).to_h {|i| [i, i ** 2]} # =&gt; {0=&gt;0, 1=&gt;1, 2=&gt;4, 3=&gt;9}
</pre> <p>Raises an exception if an element of <code>self</code> is not a 2-element array, and a block is not passed.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-to_set"> <a href="#method-i-to_set" title="Link to this method"> <span class="method-name">to_set</span> <span class="method-args">(klass = Set, *args, &amp;block)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="to_set-source"> <pre class="ruby" data-language="ruby"># File lib/set.rb, line 850
def to_set(klass = Set, *args, &amp;block)
  klass.new(self, *args, &amp;block)
end</pre> </div>  <p>Makes a set from the enumerable object with given arguments. Needs to <code>require "set"</code> to use this method.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-uniq"> <a href="#method-i-uniq" title="Link to this method"> <span class="method-callseq"> uniq → array </span> </a> </div> <div class="method-heading"> <a href="#method-i-uniq" title="Link to this method"> <span class="method-callseq"> uniq {|element| ... } → array </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="uniq-source"> <pre class="c" data-language="c">static VALUE
enum_uniq(VALUE obj)
{
    VALUE hash, ret;
    rb_block_call_func *const func =
        rb_block_given_p() ? uniq_iter : uniq_func;

    hash = rb_obj_hide(rb_hash_new());
    rb_block_call(obj, id_each, 0, 0, func, hash);
    ret = rb_hash_values(hash);
    rb_hash_clear(hash);
    return ret;
}</pre> </div>  <p>With no block, returns a new array containing only unique elements; the array has no two elements <code>e0</code> and <code>e1</code> such that <code>e0.eql?(e1)</code>:</p> <pre class="ruby" data-language="ruby">%w[a b c c b a a b c].uniq       # =&gt; ["a", "b", "c"]
[0, 1, 2, 2, 1, 0, 0, 1, 2].uniq # =&gt; [0, 1, 2]
</pre> <p>With a block, returns a new array containing elements only for which the block returns a unique value:</p> <pre class="ruby" data-language="ruby">a = [0, 1, 2, 3, 4, 5, 5, 4, 3, 2, 1]
a.uniq {|i| i.even? ? i : 0 } # =&gt; [0, 2, 4]
a = %w[a b c d e e d c b a a b c d e]
a.uniq {|c| c &lt; 'c' }         # =&gt; ["a", "c"]
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-zip"> <a href="#method-i-zip" title="Link to this method"> <span class="method-callseq"> zip(*other_enums) → array </span> </a> </div> <div class="method-heading"> <a href="#method-i-zip" title="Link to this method"> <span class="method-callseq"> zip(*other_enums) {|array| ... } → nil </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="zip-source"> <pre class="c" data-language="c">static VALUE
enum_zip(int argc, VALUE *argv, VALUE obj)
{
    int i;
    ID conv;
    struct MEMO *memo;
    VALUE result = Qnil;
    VALUE args = rb_ary_new4(argc, argv);
    int allary = TRUE;

    argv = RARRAY_PTR(args);
    for (i=0; i&lt;argc; i++) {
        VALUE ary = rb_check_array_type(argv[i]);
        if (NIL_P(ary)) {
            allary = FALSE;
            break;
        }
        argv[i] = ary;
    }
    if (!allary) {
        static const VALUE sym_each = STATIC_ID2SYM(id_each);
        CONST_ID(conv, "to_enum");
        for (i=0; i&lt;argc; i++) {
            if (!rb_respond_to(argv[i], id_each)) {
                rb_raise(rb_eTypeError, "wrong argument type %"PRIsVALUE" (must respond to :each)",
                         rb_obj_class(argv[i]));
            }
            argv[i] = rb_funcallv(argv[i], conv, 1, &amp;sym_each);
        }
    }
    if (!rb_block_given_p()) {
        result = rb_ary_new();
    }

    /* TODO: use NODE_DOT2 as memo(v, v, -) */
    memo = MEMO_NEW(result, args, 0);
    rb_block_call(obj, id_each, 0, 0, allary ? zip_ary : zip_i, (VALUE)memo);

    return result;
}</pre> </div>  <p>With no block given, returns a new array <code>new_array</code> of size self.size whose elements are arrays. Each nested array <code>new_array[n]</code> is of size <code>other_enums.size+1</code>, and contains:</p> <ul>
<li> <p>The <code>n</code>-th element of self.</p> </li>
<li> <p>The <code>n</code>-th element of each of the <code>other_enums</code>.</p> </li>
</ul> <p>If all <code>other_enums</code> and self are the same size, all elements are included in the result, and there is no <code>nil</code>-filling:</p> <pre class="ruby" data-language="ruby">a = [:a0, :a1, :a2, :a3]
b = [:b0, :b1, :b2, :b3]
c = [:c0, :c1, :c2, :c3]
d = a.zip(b, c)
d # =&gt; [[:a0, :b0, :c0], [:a1, :b1, :c1], [:a2, :b2, :c2], [:a3, :b3, :c3]]

f = {foo: 0, bar: 1, baz: 2}
g = {goo: 3, gar: 4, gaz: 5}
h = {hoo: 6, har: 7, haz: 8}
d = f.zip(g, h)
d # =&gt; [
  #      [[:foo, 0], [:goo, 3], [:hoo, 6]],
  #      [[:bar, 1], [:gar, 4], [:har, 7]],
  #      [[:baz, 2], [:gaz, 5], [:haz, 8]]
  #    ]
</pre> <p>If any enumerable in other_enums is smaller than self, fills to <code>self.size</code> with <code>nil</code>:</p> <pre class="ruby" data-language="ruby">a = [:a0, :a1, :a2, :a3]
b = [:b0, :b1, :b2]
c = [:c0, :c1]
d = a.zip(b, c)
d # =&gt; [[:a0, :b0, :c0], [:a1, :b1, :c1], [:a2, :b2, nil], [:a3, nil, nil]]
</pre> <p>If any enumerable in other_enums is larger than self, its trailing elements are ignored:</p> <pre class="ruby" data-language="ruby">a = [:a0, :a1, :a2, :a3]
b = [:b0, :b1, :b2, :b3, :b4]
c = [:c0, :c1, :c2, :c3, :c4, :c5]
d = a.zip(b, c)
d # =&gt; [[:a0, :b0, :c0], [:a1, :b1, :c1], [:a2, :b2, :c2], [:a3, :b3, :c3]]
</pre> <p>When a block is given, calls the block with each of the sub-arrays (formed as above); returns nil:</p> <pre class="ruby" data-language="ruby">a = [:a0, :a1, :a2, :a3]
b = [:b0, :b1, :b2, :b3]
c = [:c0, :c1, :c2, :c3]
a.zip(b, c) {|sub_array| p sub_array} # =&gt; nil
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">[:a0, :b0, :c0]
[:a1, :b1, :c1]
[:a2, :b2, :c2]
[:a3, :b3, :c3]
</pre> </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core &copy; 1993&ndash;2024 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library &copy; contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>
