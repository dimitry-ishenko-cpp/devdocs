<h1 id="class-Range" class="class"> class Range </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent"><a href="object.html">Object</a></dd>
<dt>Included modules:</dt>
<dd class="meta-includes"><a class="include" href="enumerable.html">Enumerable</a></dd>
</dl> <section class="description"> <p>A Range object represents a collection of values that are between given begin and end values.</p> <p>You can create an Range object explicitly with:</p> <ul><li> <p>A <a href="syntax/literals_rdoc.html#label-Range+Literals">range literal</a>:</p> <pre class="ruby" data-language="ruby"># Ranges that use '..' to include the given end value.
(1..4).to_a      # =&gt; [1, 2, 3, 4]
('a'..'d').to_a  # =&gt; ["a", "b", "c", "d"]
# Ranges that use '...' to exclude the given end value.
(1...4).to_a     # =&gt; [1, 2, 3]
('a'...'d').to_a # =&gt; ["a", "b", "c"]
</pre> </li></ul> <p>A range may be created using method <a href="range.html#method-c-new"><code>Range.new</code></a>:</p> <pre class="ruby" data-language="ruby"># Ranges that by default include the given end value.
Range.new(1, 4).to_a     # =&gt; [1, 2, 3, 4]
Range.new('a', 'd').to_a # =&gt; ["a", "b", "c", "d"]
# Ranges that use third argument +exclude_end+ to exclude the given end value.
Range.new(1, 4, true).to_a     # =&gt; [1, 2, 3]
Range.new('a', 'd', true).to_a # =&gt; ["a", "b", "c"]
</pre> <h2 id="class-Range-label-Beginless+Ranges">Beginless Ranges</h2> <p>A <em>beginless</em> <em>range</em> has a definite end value, but a <code>nil</code> begin value. Such a range includes all values up to the end value.</p> <pre class="ruby" data-language="ruby">r = (..4)               # =&gt; nil..4
r.begin                 # =&gt; nil
r.include?(-50)         # =&gt; true
r.include?(4)           # =&gt; true

r = (...4)              # =&gt; nil...4
r.include?(4)           # =&gt; false

Range.new(nil, 4)       # =&gt; nil..4
Range.new(nil, 4, true) # =&gt; nil...4
</pre> <p>A beginless range may be used to slice an array:</p> <pre class="ruby" data-language="ruby">a = [1, 2, 3, 4]
r = (..2) # =&gt; nil...2
a[r]      # =&gt; [1, 2]
</pre> <p>Method <code>each</code> for a beginless range raises an exception.</p> <h2 id="class-Range-label-Endless+Ranges">Endless Ranges</h2> <p>An <em>endless</em> <em>range</em> has a definite begin value, but a <code>nil</code> end value. Such a range includes all values from the begin value.</p> <pre class="ruby" data-language="ruby">r = (1..)         # =&gt; 1..
r.end             # =&gt; nil
r.include?(50)    # =&gt; true

Range.new(1, nil) # =&gt; 1..
</pre> <p>The literal for an endless range may be written with either two dots or three. The range has the same elements, either way. But note that the two are not equal:</p> <pre class="ruby" data-language="ruby">r0 = (1..)           # =&gt; 1..
r1 = (1...)          # =&gt; 1...
r0.begin == r1.begin # =&gt; true
r0.end == r1.end     # =&gt; true
r0 == r1             # =&gt; false
</pre> <p>An endless range may be used to slice an array:</p> <pre class="ruby" data-language="ruby">a = [1, 2, 3, 4]
r = (2..) # =&gt; 2..
a[r]      # =&gt; [3, 4]
</pre> <p>Method <code>each</code> for an endless range calls the given block indefinitely:</p> <pre class="ruby" data-language="ruby">a = []
r = (1..)
r.each do |i|
  a.push(i) if i.even?
  break if i &gt; 10
end
a # =&gt; [2, 4, 6, 8, 10]
</pre> <p>A range can be both beginless and endless. For literal beginless, endless ranges, at least the beginning or end of the range must be given as an explicit nil value. It is recommended to use an explicit nil beginning and implicit nil end, since that is what Ruby uses for <a href="range.html#method-i-inspect"><code>Range#inspect</code></a>:</p> <pre class="ruby" data-language="ruby">(nil..)    # =&gt; (nil..)
(..nil)    # =&gt; (nil..)
(nil..nil) # =&gt; (nil..)
</pre> <h2 id="class-Range-label-Ranges+and+Other+Classes">Ranges and Other Classes</h2> <p>An object may be put into a range if its class implements instance method <code>&lt;=&gt;</code>. Ruby core classes that do so include <a href="array.html"><code>Array</code></a>, <a href="complex.html"><code>Complex</code></a>, <a href="file/stat.html"><code>File::Stat</code></a>, <a href="float.html"><code>Float</code></a>, <a href="integer.html"><code>Integer</code></a>, <a href="kernel.html"><code>Kernel</code></a>, <a href="module.html"><code>Module</code></a>, <a href="numeric.html"><code>Numeric</code></a>, <a href="rational.html"><code>Rational</code></a>, <a href="string.html"><code>String</code></a>, <a href="symbol.html"><code>Symbol</code></a>, and <a href="time.html"><code>Time</code></a>.</p> <p>Example:</p> <pre class="ruby" data-language="ruby">t0 = Time.now         # =&gt; 2021-09-19 09:22:48.4854986 -0500
t1 = Time.now         # =&gt; 2021-09-19 09:22:56.0365079 -0500
t2 = Time.now         # =&gt; 2021-09-19 09:23:08.5263283 -0500
(t0..t2).include?(t1) # =&gt; true
(t0..t1).include?(t2) # =&gt; false
</pre> <p>A range can be iterated over only if its elements implement instance method <code>succ</code>. Ruby core classes that do so include <a href="integer.html"><code>Integer</code></a>, <a href="string.html"><code>String</code></a>, and <a href="symbol.html"><code>Symbol</code></a> (but not the other classes mentioned above).</p> <p>Iterator methods include:</p> <ul>
<li> <p>In Range itself: <a href="range.html#method-i-each"><code>each</code></a>, <a href="range.html#method-i-step"><code>step</code></a>, and <a href="range.html#method-i-25"><code>%</code></a></p> </li>
<li> <p>Included from module Enumerable: <a href="enumerable.html#method-i-each_entry"><code>each_entry</code></a>, <a href="enumerable.html#method-i-each_with_index"><code>each_with_index</code></a>, <a href="enumerable.html#method-i-each_with_object"><code>each_with_object</code></a>, <a href="enumerable.html#method-i-each_slice"><code>each_slice</code></a>, <a href="enumerable.html#method-i-each_cons"><code>each_cons</code></a>, and <a href="range.html#method-i-reverse_each"><code>reverse_each</code></a>.</p> </li>
</ul> <p>Example:</p> <pre class="ruby" data-language="ruby">a = []
(1..4).each {|i| a.push(i) }
a # =&gt; [1, 2, 3, 4]
</pre> <h2 id="class-Range-label-Ranges+and+User-Defined+Classes">Ranges and User-Defined Classes</h2> <p>A user-defined class that is to be used in a range must implement instance <code>&lt;=&gt;</code>; see <a href="integer.html#method-i-3C-3D-3E"><code>Integer#&lt;=&gt;</code></a>. To make iteration available, it must also implement instance method <code>succ</code>; see <a href="integer.html#method-i-succ"><code>Integer#succ</code></a>.</p> <p>The class below implements both <code>&lt;=&gt;</code> and <code>succ</code>, and so can be used both to construct ranges and to iterate over them. Note that the <a href="comparable.html"><code>Comparable</code></a> module is included so the <code>==</code> method is defined in terms of <code>&lt;=&gt;</code>.</p> <pre class="ruby" data-language="ruby"># Represent a string of 'X' characters.
class Xs
  include Comparable
  attr_accessor :length
  def initialize(n)
    @length = n
  end
  def succ
    Xs.new(@length + 1)
  end
  def &lt;=&gt;(other)
    @length &lt;=&gt; other.length
  end
  def to_s
    sprintf "%2d #{inspect}", @length
  end
  def inspect
    'X' * @length
  end
end

r = Xs.new(3)..Xs.new(6) #=&gt; XXX..XXXXXX
r.to_a                   #=&gt; [XXX, XXXX, XXXXX, XXXXXX]
r.include?(Xs.new(5))    #=&gt; true
r.include?(Xs.new(7))    #=&gt; false
</pre> <h2 id="class-Range-label-What-27s+Here">What’s Here</h2> <p>First, what’s elsewhere. Class Range:</p> <ul>
<li> <p>Inherits from <a href="object.html#class-Object-label-What-27s+Here">class Object</a>.</p> </li>
<li> <p>Includes <a href="enumerable.html#module-Enumerable-label-What-27s+Here">module Enumerable</a>, which provides dozens of additional methods.</p> </li>
</ul> <p>Here, class Range provides methods that are useful for:</p> <ul>
<li> <p><a href="range.html#class-Range-label-Methods+for+Creating+a+Range">Creating a Range</a></p> </li>
<li> <p><a href="range.html#class-Range-label-Methods+for+Querying">Querying</a></p> </li>
<li> <p><a href="range.html#class-Range-label-Methods+for+Comparing">Comparing</a></p> </li>
<li> <p><a href="range.html#class-Range-label-Methods+for+Iterating">Iterating</a></p> </li>
<li> <p><a href="range.html#class-Range-label-Methods+for+Converting">Converting</a></p> </li>
<li> <p><a href="range.html#class-Range-label-Methods+for+Working+with+JSON">Methods for Working with JSON</a></p> </li>
</ul> <h3 id="class-Range-label-Methods+for+Creating+a+Range">Methods for Creating a Range</h3> <ul><li> <p><a href="range.html#method-c-new"><code>::new</code></a>: Returns a new range.</p> </li></ul> <h3 id="class-Range-label-Methods+for+Querying">Methods for Querying</h3> <ul>
<li> <p><a href="range.html#method-i-begin"><code>begin</code></a>: Returns the begin value given for <code>self</code>.</p> </li>
<li> <p><a href="range.html#method-i-bsearch"><code>bsearch</code></a>: Returns an element from <code>self</code> selected by a binary search.</p> </li>
<li> <p><a href="range.html#method-i-count"><code>count</code></a>: Returns a count of elements in <code>self</code>.</p> </li>
<li> <p><a href="range.html#method-i-end"><code>end</code></a>: Returns the end value given for <code>self</code>.</p> </li>
<li> <p><a href="range.html#method-i-exclude_end-3F"><code>exclude_end?</code></a>: Returns whether the end object is excluded.</p> </li>
<li> <p><a href="range.html#method-i-first"><code>first</code></a>: Returns the first elements of <code>self</code>.</p> </li>
<li> <p><a href="range.html#method-i-hash"><code>hash</code></a>: Returns the integer hash code.</p> </li>
<li> <p><a href="range.html#method-i-last"><code>last</code></a>: Returns the last elements of <code>self</code>.</p> </li>
<li> <p><a href="range.html#method-i-max"><code>max</code></a>: Returns the maximum values in <code>self</code>.</p> </li>
<li> <p><a href="range.html#method-i-min"><code>min</code></a>: Returns the minimum values in <code>self</code>.</p> </li>
<li> <p><a href="range.html#method-i-minmax"><code>minmax</code></a>: Returns the minimum and maximum values in <code>self</code>.</p> </li>
<li> <p><a href="range.html#method-i-size"><code>size</code></a>: Returns the count of elements in <code>self</code>.</p> </li>
</ul> <h3 id="class-Range-label-Methods+for+Comparing">Methods for Comparing</h3> <ul>
<li> <p><a href="range.html#method-i-3D-3D"><code>==</code></a>: Returns whether a given object is equal to <code>self</code> (uses <a href="range.html#method-i-3D-3D"><code>==</code></a>).</p> </li>
<li> <p><a href="range.html#method-i-3D-3D-3D"><code>===</code></a>: Returns whether the given object is between the begin and end values.</p> </li>
<li> <p><a href="range.html#method-i-cover-3F"><code>cover?</code></a>: Returns whether a given object is within <code>self</code>.</p> </li>
<li> <p><a href="range.html#method-i-eql-3F"><code>eql?</code></a>: Returns whether a given object is equal to <code>self</code> (uses <a href="range.html#method-i-eql-3F"><code>eql?</code></a>).</p> </li>
<li> <p><a href="range.html#method-i-include-3F"><code>include?</code></a> (aliased as <a href="range.html#method-i-member-3F"><code>member?</code></a>): Returns whether a given object is an element of <code>self</code>.</p> </li>
</ul> <h3 id="class-Range-label-Methods+for+Iterating">Methods for Iterating</h3> <ul>
<li> <p><a href="range.html#method-i-25"><code>%</code></a>: Requires argument <code>n</code>; calls the block with each <code>n</code>-th element of <code>self</code>.</p> </li>
<li> <p><a href="range.html#method-i-each"><code>each</code></a>: Calls the block with each element of <code>self</code>.</p> </li>
<li> <p><a href="range.html#method-i-step"><code>step</code></a>: Takes optional argument <code>n</code> (defaults to 1); calls the block with each <code>n</code>-th element of <code>self</code>.</p> </li>
</ul> <h3 id="class-Range-label-Methods+for+Converting">Methods for Converting</h3> <ul>
<li> <p><a href="range.html#method-i-inspect"><code>inspect</code></a>: Returns a string representation of <code>self</code> (uses <a href="range.html#method-i-inspect"><code>inspect</code></a>).</p> </li>
<li> <p><a href="range.html#method-i-to_a"><code>to_a</code></a> (aliased as <a href="range.html#method-i-entries"><code>entries</code></a>): Returns elements of <code>self</code> in an array.</p> </li>
<li> <p><a href="range.html#method-i-to_s"><code>to_s</code></a>: Returns a string representation of <code>self</code> (uses <a href="range.html#method-i-to_s"><code>to_s</code></a>).</p> </li>
</ul> <h3 id="class-Range-label-Methods+for+Working+with+JSON">Methods for Working with JSON</h3> <ul>
<li> <p><a href="range.html#method-c-json_create"><code>::json_create</code></a>: Returns a new Range object constructed from the given object.</p> </li>
<li> <p><a href="range.html#method-i-as_json"><code>as_json</code></a>: Returns a 2-element hash representing <code>self</code>.</p> </li>
<li> <p><a href="range.html#method-i-to_json"><code>to_json</code></a>: Returns a JSON string representing <code>self</code>.</p> </li>
</ul> <p>To make these methods available:</p> <pre class="ruby" data-language="ruby">require 'json/add/range'
</pre> </section> <section id="5Buntitled-5D" class="documentation-section"> <section id="public-class-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-json_create"> <span class="method-name">json_create</span><span class="method-args">(object)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="json_create-source"> <pre class="ruby" data-language="ruby"># File ext/json/lib/json/add/range.rb, line 9
def self.json_create(object)
  new(*object['a'])
end</pre> </div> <p>See <a href="range.html#method-i-as_json"><code>as_json</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-c-new"> <span class="method-callseq"> new(begin, end, exclude_end = false) → new_range </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="new-source"> <pre class="c" data-language="c">static VALUE
range_initialize(int argc, VALUE *argv, VALUE range)
{
    VALUE beg, end, flags;

    rb_scan_args(argc, argv, "21", &amp;beg, &amp;end, &amp;flags);
    range_modify(range);
    range_init(range, beg, end, RBOOL(RTEST(flags)));
    return Qnil;
}</pre> </div> <p>Returns a new range based on the given objects <code>begin</code> and <code>end</code>. Optional argument <code>exclude_end</code> determines whether object <code>end</code> is included as the last object in the range:</p> <pre class="ruby" data-language="ruby">Range.new(2, 5).to_a            # =&gt; [2, 3, 4, 5]
Range.new(2, 5, true).to_a      # =&gt; [2, 3, 4]
Range.new('a', 'd').to_a        # =&gt; ["a", "b", "c", "d"]
Range.new('a', 'd', true).to_a  # =&gt; ["a", "b", "c"]
</pre>  </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-25"> <span class="method-callseq"> %(n) {|element| ... } → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> %(n) → enumerator </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="25-source"> <pre class="c" data-language="c">static VALUE
range_percent_step(VALUE range, VALUE step)
{
    return range_step(1, &amp;step, range);
}</pre> </div> <p>Iterates over the elements of <code>self</code>.</p> <p>With a block given, calls the block with selected elements of the range; returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">a = []
(1..5).%(2) {|element| a.push(element) } # =&gt; 1..5
a # =&gt; [1, 3, 5]
a = []
('a'..'e').%(2) {|element| a.push(element) } # =&gt; "a".."e"
a # =&gt; ["a", "c", "e"]
</pre> <p>With no block given, returns an enumerator, which will be of class <a href="enumerator/arithmeticsequence.html"><code>Enumerator::ArithmeticSequence</code></a> if <code>self</code> is numeric; otherwise of class Enumerator:</p> <pre class="ruby" data-language="ruby">e = (1..5) % 2 # =&gt; ((1..5).%(2))
e.class        # =&gt; Enumerator::ArithmeticSequence
('a'..'e') % 2 # =&gt;  #&lt;Enumerator: ...&gt;
</pre> <p>Related: <a href="range.html#method-i-step"><code>Range#step</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-3D-3D"> <span class="method-callseq"> self == other → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="3D-3D-source"> <pre class="c" data-language="c">static VALUE
range_eq(VALUE range, VALUE obj)
{
    if (range == obj)
        return Qtrue;
    if (!rb_obj_is_kind_of(obj, rb_cRange))
        return Qfalse;

    return rb_exec_recursive_paired(recursive_equal, range, obj, obj);
}</pre> </div> <p>Returns <code>true</code> if and only if:</p> <ul>
<li> <p><code>other</code> is a range.</p> </li>
<li> <p><code>other.begin == self.begin</code>.</p> </li>
<li> <p><code>other.end == self.end</code>.</p> </li>
<li> <p><code>other.exclude_end? == self.exclude_end?</code>.</p> </li>
</ul> <p>Otherwise returns <code>false</code>.</p> <pre class="ruby" data-language="ruby">r = (1..5)
r == (1..5)                # =&gt; true
r = Range.new(1, 5)
r == 'foo'                 # =&gt; false
r == (2..5)                # =&gt; false
r == (1..4)                # =&gt; false
r == (1...5)               # =&gt; false
r == Range.new(1, 5, true) # =&gt; false
</pre> <p>Note that even with the same argument, the return values of <a href="range.html#method-i-3D-3D"><code>==</code></a> and <a href="range.html#method-i-eql-3F"><code>eql?</code></a> can differ:</p> <pre class="ruby" data-language="ruby">(1..2) == (1..2.0)   # =&gt; true
(1..2).eql? (1..2.0) # =&gt; false
</pre> <p>Related: <a href="range.html#method-i-eql-3F"><code>Range#eql?</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-3D-3D-3D"> <span class="method-callseq"> self === object → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="3D-3D-3D-source"> <pre class="c" data-language="c">static VALUE
range_eqq(VALUE range, VALUE val)
{
    return r_cover_p(range, RANGE_BEG(range), RANGE_END(range), val);
}</pre> </div> <p>Returns <code>true</code> if <code>object</code> is between <code>self.begin</code> and <code>self.end</code>. <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">(1..4) === 2       # =&gt; true
(1..4) === 5       # =&gt; false
(1..4) === 'a'     # =&gt; false
(1..4) === 4       # =&gt; true
(1...4) === 4      # =&gt; false
('a'..'d') === 'c' # =&gt; true
('a'..'d') === 'e' # =&gt; false
</pre> <p>A case statement uses method <code>===</code>, and so:</p> <pre class="ruby" data-language="ruby">case 79
when (1..50)
  "low"
when (51..75)
  "medium"
when (76..100)
  "high"
end # =&gt; "high"

case "2.6.5"
when ..."2.4"
  "EOL"
when "2.4"..."2.5"
  "maintenance"
when "2.5"..."3.0"
  "stable"
when "3.1"..
  "upcoming"
end # =&gt; "stable"
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-as_json"> <span class="method-name">as_json</span><span class="method-args">(*)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="as_json-source"> <pre class="ruby" data-language="ruby"># File ext/json/lib/json/add/range.rb, line 31
def as_json(*)
  {
    JSON.create_id  =&gt; self.class.name,
    'a'             =&gt; [ first, last, exclude_end? ]
  }
end</pre> </div> <p>Methods <code>Range#as_json</code> and <code>Range.json_create</code> may be used to serialize and deserialize a Range object; see <a href="marshal.html"><code>Marshal</code></a>.</p> <p>Method <code>Range#as_json</code> serializes <code>self</code>, returning a 2-element hash representing <code>self</code>:</p> <pre class="ruby" data-language="ruby">require 'json/add/range'
x = (1..4).as_json     # =&gt; {"json_class"=&gt;"Range", "a"=&gt;[1, 4, false]}
y = (1...4).as_json    # =&gt; {"json_class"=&gt;"Range", "a"=&gt;[1, 4, true]}
z = ('a'..'d').as_json # =&gt; {"json_class"=&gt;"Range", "a"=&gt;["a", "d", false]}
</pre> <p>Method <code>JSON.create</code> deserializes such a hash, returning a Range object:</p> <pre class="ruby" data-language="ruby">Range.json_create(x) # =&gt; 1..4
Range.json_create(y) # =&gt; 1...4
Range.json_create(z) # =&gt; "a".."d"
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-begin"> <span class="method-callseq"> begin → object </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="begin-source"> <pre class="c" data-language="c">static VALUE
range_begin(VALUE range)
{
    return RANGE_BEG(range);
}</pre> </div> <p>Returns the object that defines the beginning of <code>self</code>.</p> <pre class="ruby" data-language="ruby">(1..4).begin # =&gt; 1
(..2).begin  # =&gt; nil
</pre> <p>Related: <a href="range.html#method-i-first"><code>Range#first</code></a>, <a href="range.html#method-i-end"><code>Range#end</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-bsearch"> <span class="method-callseq"> bsearch {|obj| block } → value </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="bsearch-source"> <pre class="c" data-language="c">static VALUE
range_bsearch(VALUE range)
{
    VALUE beg, end, satisfied = Qnil;
    int smaller;

    /* Implementation notes:
     * Floats are handled by mapping them to 64 bits integers.
     * Apart from sign issues, floats and their 64 bits integer have the
     * same order, assuming they are represented as exponent followed
     * by the mantissa. This is true with or without implicit bit.
     *
     * Finding the average of two ints needs to be careful about
     * potential overflow (since float to long can use 64 bits).
     *
     * The half-open interval (low, high] indicates where the target is located.
     * The loop continues until low and high are adjacent.
     *
     * -1/2 can be either 0 or -1 in C89. However, when low and high are not adjacent,
     * the rounding direction of mid = (low + high) / 2 does not affect the result of
     * the binary search.
     *
     * Note that -0.0 is mapped to the same int as 0.0 as we don't want
     * (-1...0.0).bsearch to yield -0.0.
     */

#define BSEARCH(conv, excl) \
    do { \
        RETURN_ENUMERATOR(range, 0, 0); \
        if (!(excl)) high++; \
        low--; \
        while (low + 1 &lt; high) { \
            mid = ((high &lt; 0) == (low &lt; 0)) ? low + ((high - low) / 2) \
                : (low + high) / 2; \
            BSEARCH_CHECK(conv(mid)); \
            if (smaller) { \
                high = mid; \
            } \
            else { \
                low = mid; \
            } \
        } \
        return satisfied; \
    } while (0)

#define BSEARCH_FIXNUM(beg, end, excl) \
    do { \
        long low = FIX2LONG(beg); \
        long high = FIX2LONG(end); \
        long mid; \
        BSEARCH(INT2FIX, (excl)); \
    } while (0)

    beg = RANGE_BEG(range);
    end = RANGE_END(range);

    if (FIXNUM_P(beg) &amp;&amp; FIXNUM_P(end)) {
        BSEARCH_FIXNUM(beg, end, EXCL(range));
    }
#if SIZEOF_DOUBLE == 8 &amp;&amp; defined(HAVE_INT64_T)
    else if (RB_FLOAT_TYPE_P(beg) || RB_FLOAT_TYPE_P(end)) {
        int64_t low  = double_as_int64(NIL_P(beg) ? -HUGE_VAL : RFLOAT_VALUE(rb_Float(beg)));
        int64_t high = double_as_int64(NIL_P(end) ?  HUGE_VAL : RFLOAT_VALUE(rb_Float(end)));
        int64_t mid;
        BSEARCH(int64_as_double_to_num, EXCL(range));
    }
#endif
    else if (is_integer_p(beg) &amp;&amp; is_integer_p(end)) {
        RETURN_ENUMERATOR(range, 0, 0);
        return bsearch_integer_range(beg, end, EXCL(range));
    }
    else if (is_integer_p(beg) &amp;&amp; NIL_P(end)) {
        VALUE diff = LONG2FIX(1);
        RETURN_ENUMERATOR(range, 0, 0);
        while (1) {
            VALUE mid = rb_funcall(beg, '+', 1, diff);
            BSEARCH_CHECK(mid);
            if (smaller) {
                if (FIXNUM_P(beg) &amp;&amp; FIXNUM_P(mid)) {
                    BSEARCH_FIXNUM(beg, mid, false);
                }
                else {
                    return bsearch_integer_range(beg, mid, false);
                }
            }
            diff = rb_funcall(diff, '*', 1, LONG2FIX(2));
            beg = mid;
        }
    }
    else if (NIL_P(beg) &amp;&amp; is_integer_p(end)) {
        VALUE diff = LONG2FIX(-1);
        RETURN_ENUMERATOR(range, 0, 0);
        while (1) {
            VALUE mid = rb_funcall(end, '+', 1, diff);
            BSEARCH_CHECK(mid);
            if (!smaller) {
                if (FIXNUM_P(mid) &amp;&amp; FIXNUM_P(end)) {
                    BSEARCH_FIXNUM(mid, end, false);
                }
                else {
                    return bsearch_integer_range(mid, end, false);
                }
            }
            diff = rb_funcall(diff, '*', 1, LONG2FIX(2));
            end = mid;
        }
    }
    else {
        rb_raise(rb_eTypeError, "can't do binary search for %s", rb_obj_classname(beg));
    }
    return range;
}</pre> </div> <p>Returns an element from <code>self</code> selected by a binary search.</p> <p>See <a href="bsearch_rdoc.html">Binary Searching</a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-count"> <span class="method-callseq"> count → integer </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> count(object) → integer </span> </div> <div class="method-heading"> <span class="method-callseq"> count {|element| ... } → integer </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="count-source"> <pre class="c" data-language="c">static VALUE
range_count(int argc, VALUE *argv, VALUE range)
{
    if (argc != 0) {
        /* It is odd for instance (1...).count(0) to return Infinity. Just let
         * it loop. */
        return rb_call_super(argc, argv);
    }
    else if (rb_block_given_p()) {
        /* Likewise it is odd for instance (1...).count {|x| x == 0 } to return
         * Infinity. Just let it loop. */
        return rb_call_super(argc, argv);
    }

    VALUE beg = RANGE_BEG(range), end = RANGE_END(range);

    if (NIL_P(beg) || NIL_P(end)) {
        /* We are confident that the answer is Infinity. */
        return DBL2NUM(HUGE_VAL);
    }

    if (is_integer_p(beg)) {
        VALUE size = range_size(range);
        if (!NIL_P(size)) {
            return size;
        }
    }

    return rb_call_super(argc, argv);
}</pre> </div> <p>Returns the count of elements, based on an argument or block criterion, if given.</p> <p>With no argument and no block given, returns the number of elements:</p> <pre class="ruby" data-language="ruby">(1..4).count      # =&gt; 4
(1...4).count     # =&gt; 3
('a'..'d').count  # =&gt; 4
('a'...'d').count # =&gt; 3
(1..).count       # =&gt; Infinity
(..4).count       # =&gt; Infinity
</pre> <p>With argument <code>object</code>, returns the number of <code>object</code> found in <code>self</code>, which will usually be zero or one:</p> <pre class="ruby" data-language="ruby">(1..4).count(2)   # =&gt; 1
(1..4).count(5)   # =&gt; 0
(1..4).count('a')  # =&gt; 0
</pre> <p>With a block given, calls the block with each element; returns the number of elements for which the block returns a truthy value:</p> <pre class="ruby" data-language="ruby">(1..4).count {|element| element &lt; 3 } # =&gt; 2
</pre> <p>Related: <a href="range.html#method-i-size"><code>Range#size</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-cover-3F"> <span class="method-callseq"> cover?(object) → true or false </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> cover?(range) → true or false </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="cover-3F-source"> <pre class="c" data-language="c">static VALUE
range_cover(VALUE range, VALUE val)
{
    VALUE beg, end;

    beg = RANGE_BEG(range);
    end = RANGE_END(range);

    if (rb_obj_is_kind_of(val, rb_cRange)) {
        return RBOOL(r_cover_range_p(range, beg, end, val));
    }
    return r_cover_p(range, beg, end, val);
}</pre> </div> <p>Returns <code>true</code> if the given argument is within <code>self</code>, <code>false</code> otherwise.</p> <p>With non-range argument <code>object</code>, evaluates with <code>&lt;=</code> and <code>&lt;</code>.</p> <p>For range <code>self</code> with included end value (<code>#exclude_end? == false</code>), evaluates thus:</p> <pre class="ruby" data-language="ruby">self.begin &lt;= object &lt;= self.end
</pre> <p>Examples:</p> <pre class="ruby" data-language="ruby">r = (1..4)
r.cover?(1)     # =&gt; true
r.cover?(4)     # =&gt; true
r.cover?(0)     # =&gt; false
r.cover?(5)     # =&gt; false
r.cover?('foo') # =&gt; false

r = ('a'..'d')
r.cover?('a')     # =&gt; true
r.cover?('d')     # =&gt; true
r.cover?(' ')     # =&gt; false
r.cover?('e')     # =&gt; false
r.cover?(0)       # =&gt; false
</pre> <p>For range <code>r</code> with excluded end value (<code>#exclude_end? == true</code>), evaluates thus:</p> <pre class="ruby" data-language="ruby">r.begin &lt;= object &lt; r.end
</pre> <p>Examples:</p> <pre class="ruby" data-language="ruby">r = (1...4)
r.cover?(1)     # =&gt; true
r.cover?(3)     # =&gt; true
r.cover?(0)     # =&gt; false
r.cover?(4)     # =&gt; false
r.cover?('foo') # =&gt; false

r = ('a'...'d')
r.cover?('a')     # =&gt; true
r.cover?('c')     # =&gt; true
r.cover?(' ')     # =&gt; false
r.cover?('d')     # =&gt; false
r.cover?(0)       # =&gt; false
</pre> <p>With range argument <code>range</code>, compares the first and last elements of <code>self</code> and <code>range</code>:</p> <pre class="ruby" data-language="ruby">r = (1..4)
r.cover?(1..4)     # =&gt; true
r.cover?(0..4)     # =&gt; false
r.cover?(1..5)     # =&gt; false
r.cover?('a'..'d') # =&gt; false

r = (1...4)
r.cover?(1..3)     # =&gt; true
r.cover?(1..4)     # =&gt; false
</pre> <p>If begin and end are numeric, <a href="range.html#method-i-cover-3F"><code>cover?</code></a> behaves like <a href="range.html#method-i-include-3F"><code>include?</code></a></p> <pre class="ruby" data-language="ruby">(1..3).cover?(1.5) # =&gt; true
(1..3).include?(1.5) # =&gt; true
</pre> <p>But when not numeric, the two methods may differ:</p> <pre class="ruby" data-language="ruby">('a'..'d').cover?('cc')   # =&gt; true
('a'..'d').include?('cc') # =&gt; false
</pre> <p>Returns <code>false</code> if either:</p> <ul>
<li> <p>The begin value of <code>self</code> is larger than its end value.</p> </li>
<li> <p>An internal call to <code>&lt;=&gt;</code> returns <code>nil</code>; that is, the operands are not comparable.</p> </li>
</ul> <p>Beginless ranges cover all values of the same type before the end, excluding the end for exclusive ranges. Beginless ranges cover ranges that end before the end of the beginless range, or at the end of the beginless range for inclusive ranges.</p> <pre class="ruby" data-language="ruby">(..2).cover?(1)     # =&gt; true
(..2).cover?(2)     # =&gt; true
(..2).cover?(3)     # =&gt; false
(...2).cover?(2)    # =&gt; false
(..2).cover?("2")   # =&gt; false
(..2).cover?(..2)   # =&gt; true
(..2).cover?(...2)  # =&gt; true
(..2).cover?(.."2") # =&gt; false
(...2).cover?(..2)  # =&gt; false
</pre> <p>Endless ranges cover all values of the same type after the beginning. Endless exclusive ranges do not cover endless inclusive ranges.</p> <pre class="ruby" data-language="ruby">(2..).cover?(1)     # =&gt; false
(2..).cover?(3)     # =&gt; true
(2...).cover?(3)    # =&gt; true
(2..).cover?(2)     # =&gt; true
(2..).cover?("2")   # =&gt; false
(2..).cover?(2..)   # =&gt; true
(2..).cover?(2...)  # =&gt; true
(2..).cover?("2"..) # =&gt; false
(2...).cover?(2..)  # =&gt; false
(2...).cover?(3...) # =&gt; true
(2...).cover?(3..)  # =&gt; false
(3..).cover?(2..)   # =&gt; false
</pre> <p>Ranges that are both beginless and endless cover all values and ranges, and return true for all arguments, with the exception that beginless and endless exclusive ranges do not cover endless inclusive ranges.</p> <pre class="ruby" data-language="ruby">(nil...).cover?(Object.new) # =&gt; true
(nil...).cover?(nil...)     # =&gt; true
(nil..).cover?(nil...)      # =&gt; true
(nil...).cover?(nil..)      # =&gt; false
(nil...).cover?(1..)        # =&gt; false
</pre> <p>Related: <a href="range.html#method-i-include-3F"><code>Range#include?</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-each"> <span class="method-callseq"> each {|element| ... } → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> each → an_enumerator </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="each-source"> <pre class="c" data-language="c">static VALUE
range_each(VALUE range)
{
    VALUE beg, end;
    long i;

    RETURN_SIZED_ENUMERATOR(range, 0, 0, range_enum_size);

    beg = RANGE_BEG(range);
    end = RANGE_END(range);

    if (FIXNUM_P(beg) &amp;&amp; NIL_P(end)) {
        range_each_fixnum_endless(beg);
    }
    else if (FIXNUM_P(beg) &amp;&amp; FIXNUM_P(end)) { /* fixnums are special */
        return range_each_fixnum_loop(beg, end, range);
    }
    else if (RB_INTEGER_TYPE_P(beg) &amp;&amp; (NIL_P(end) || RB_INTEGER_TYPE_P(end))) {
        if (SPECIAL_CONST_P(end) || RBIGNUM_POSITIVE_P(end)) { /* end &gt;= FIXNUM_MIN */
            if (!FIXNUM_P(beg)) {
                if (RBIGNUM_NEGATIVE_P(beg)) {
                    do {
                        rb_yield(beg);
                    } while (!FIXNUM_P(beg = rb_big_plus(beg, INT2FIX(1))));
                    if (NIL_P(end)) range_each_fixnum_endless(beg);
                    if (FIXNUM_P(end)) return range_each_fixnum_loop(beg, end, range);
                }
                else {
                    if (NIL_P(end)) range_each_bignum_endless(beg);
                    if (FIXNUM_P(end)) return range;
                }
            }
            if (FIXNUM_P(beg)) {
                i = FIX2LONG(beg);
                do {
                    rb_yield(LONG2FIX(i));
                } while (POSFIXABLE(++i));
                beg = LONG2NUM(i);
            }
            ASSUME(!FIXNUM_P(beg));
            ASSUME(!SPECIAL_CONST_P(end));
        }
        if (!FIXNUM_P(beg) &amp;&amp; RBIGNUM_SIGN(beg) == RBIGNUM_SIGN(end)) {
            if (EXCL(range)) {
                while (rb_big_cmp(beg, end) == INT2FIX(-1)) {
                    rb_yield(beg);
                    beg = rb_big_plus(beg, INT2FIX(1));
                }
            }
            else {
                VALUE c;
                while ((c = rb_big_cmp(beg, end)) != INT2FIX(1)) {
                    rb_yield(beg);
                    if (c == INT2FIX(0)) break;
                    beg = rb_big_plus(beg, INT2FIX(1));
                }
            }
        }
    }
    else if (SYMBOL_P(beg) &amp;&amp; (NIL_P(end) || SYMBOL_P(end))) { /* symbols are special */
        beg = rb_sym2str(beg);
        if (NIL_P(end)) {
            rb_str_upto_endless_each(beg, sym_each_i, 0);
        }
        else {
            rb_str_upto_each(beg, rb_sym2str(end), EXCL(range), sym_each_i, 0);
        }
    }
    else {
        VALUE tmp = rb_check_string_type(beg);

        if (!NIL_P(tmp)) {
            if (!NIL_P(end)) {
                rb_str_upto_each(tmp, end, EXCL(range), each_i, 0);
            }
            else {
                rb_str_upto_endless_each(tmp, each_i, 0);
            }
        }
        else {
            if (!discrete_object_p(beg)) {
                rb_raise(rb_eTypeError, "can't iterate from %s",
                         rb_obj_classname(beg));
            }
            if (!NIL_P(end))
                range_each_func(range, each_i, 0);
            else
                for (;; beg = rb_funcallv(beg, id_succ, 0, 0))
                    rb_yield(beg);
        }
    }
    return range;
}</pre> </div> <p>With a block given, passes each element of <code>self</code> to the block:</p> <pre class="ruby" data-language="ruby">a = []
(1..4).each {|element| a.push(element) } # =&gt; 1..4
a # =&gt; [1, 2, 3, 4]
</pre> <p>Raises an exception unless <code>self.first.respond_to?(:succ)</code>.</p> <p>With no block given, returns an enumerator.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-end"> <span class="method-callseq"> end → object </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="end-source"> <pre class="c" data-language="c">static VALUE
range_end(VALUE range)
{
    return RANGE_END(range);
}</pre> </div> <p>Returns the object that defines the end of <code>self</code>.</p> <pre class="ruby" data-language="ruby">(1..4).end  # =&gt; 4
(1...4).end # =&gt; 4
(1..).end   # =&gt; nil
</pre> <p>Related: <a href="range.html#method-i-begin"><code>Range#begin</code></a>, <a href="range.html#method-i-last"><code>Range#last</code></a>.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-entries"> <span class="method-name">entries</span> </div> </div> <div class="aliases"> Alias for: <a href="range.html#method-i-to_a">to_a</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-eql-3F"> <span class="method-callseq"> eql?(other) → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="eql-3F-source"> <pre class="c" data-language="c">static VALUE
range_eql(VALUE range, VALUE obj)
{
    if (range == obj)
        return Qtrue;
    if (!rb_obj_is_kind_of(obj, rb_cRange))
        return Qfalse;
    return rb_exec_recursive_paired(recursive_eql, range, obj, obj);
}</pre> </div> <p>Returns <code>true</code> if and only if:</p> <ul>
<li> <p><code>other</code> is a range.</p> </li>
<li> <p><code>other.begin eql? self.begin</code>.</p> </li>
<li> <p><code>other.end eql? self.end</code>.</p> </li>
<li> <p><code>other.exclude_end? == self.exclude_end?</code>.</p> </li>
</ul> <p>Otherwise returns <code>false</code>.</p> <pre class="ruby" data-language="ruby">r = (1..5)
r.eql?(1..5)                  # =&gt; true
r = Range.new(1, 5)
r.eql?('foo')                 # =&gt; false
r.eql?(2..5)                  # =&gt; false
r.eql?(1..4)                  # =&gt; false
r.eql?(1...5)                 # =&gt; false
r.eql?(Range.new(1, 5, true)) # =&gt; false
</pre> <p>Note that even with the same argument, the return values of <a href="range.html#method-i-3D-3D"><code>==</code></a> and <a href="range.html#method-i-eql-3F"><code>eql?</code></a> can differ:</p> <pre class="ruby" data-language="ruby">(1..2) == (1..2.0)   # =&gt; true
(1..2).eql? (1..2.0) # =&gt; false
</pre> <p>Related: <a href="range.html#method-i-3D-3D"><code>Range#==</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-exclude_end-3F"> <span class="method-callseq"> exclude_end? → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="exclude_end-3F-source"> <pre class="c" data-language="c">static VALUE
range_exclude_end_p(VALUE range)
{
    return RBOOL(EXCL(range));
}</pre> </div> <p>Returns <code>true</code> if <code>self</code> excludes its end value; <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">Range.new(2, 5).exclude_end?       # =&gt; false
Range.new(2, 5, true).exclude_end? # =&gt; true
(2..5).exclude_end?                # =&gt; false
(2...5).exclude_end?               # =&gt; true
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-first"> <span class="method-callseq"> first → object </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> first(n) → array </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="first-source"> <pre class="c" data-language="c">static VALUE
range_first(int argc, VALUE *argv, VALUE range)
{
    VALUE n, ary[2];

    if (NIL_P(RANGE_BEG(range))) {
        rb_raise(rb_eRangeError, "cannot get the first element of beginless range");
    }
    if (argc == 0) return RANGE_BEG(range);

    rb_scan_args(argc, argv, "1", &amp;n);
    ary[0] = n;
    ary[1] = rb_ary_new2(NUM2LONG(n));
    rb_block_call(range, idEach, 0, 0, first_i, (VALUE)ary);

    return ary[1];
}</pre> </div> <p>With no argument, returns the first element of <code>self</code>, if it exists:</p> <pre class="ruby" data-language="ruby">(1..4).first     # =&gt; 1
('a'..'d').first # =&gt; "a"
</pre> <p>With non-negative integer argument <code>n</code> given, returns the first <code>n</code> elements in an array:</p> <pre class="ruby" data-language="ruby">(1..10).first(3) # =&gt; [1, 2, 3]
(1..10).first(0) # =&gt; []
(1..4).first(50) # =&gt; [1, 2, 3, 4]
</pre> <p>Raises an exception if there is no first element:</p> <pre class="ruby" data-language="ruby">(..4).first # Raises RangeError
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-hash"> <span class="method-callseq"> hash → integer </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="hash-source"> <pre class="c" data-language="c">static VALUE
range_hash(VALUE range)
{
    st_index_t hash = EXCL(range);
    VALUE v;

    hash = rb_hash_start(hash);
    v = rb_hash(RANGE_BEG(range));
    hash = rb_hash_uint(hash, NUM2LONG(v));
    v = rb_hash(RANGE_END(range));
    hash = rb_hash_uint(hash, NUM2LONG(v));
    hash = rb_hash_uint(hash, EXCL(range) &lt;&lt; 24);
    hash = rb_hash_end(hash);

    return ST2FIX(hash);
}</pre> </div> <p>Returns the integer hash value for <code>self</code>. Two range objects <code>r0</code> and <code>r1</code> have the same hash value if and only if <code>r0.eql?(r1)</code>.</p> <p>Related: <a href="range.html#method-i-eql-3F"><code>Range#eql?</code></a>, <a href="object.html#method-i-hash"><code>Object#hash</code></a>.</p>  </div> </div> <div class="method-detail method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-include-3F"> <span class="method-callseq"> include?(object) → true or false </span> </div> </div> <div class="method-description"> <p>Returns <code>true</code> if <code>object</code> is an element of <code>self</code>, <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">(1..4).include?(2)        # =&gt; true
(1..4).include?(5)        # =&gt; false
(1..4).include?(4)        # =&gt; true
(1...4).include?(4)       # =&gt; false
('a'..'d').include?('b')  # =&gt; true
('a'..'d').include?('e')  # =&gt; false
('a'..'d').include?('B')  # =&gt; false
('a'..'d').include?('d')  # =&gt; true
('a'...'d').include?('d') # =&gt; false
</pre> <p>If begin and end are numeric, <a href="range.html#method-i-include-3F"><code>include?</code></a> behaves like <a href="range.html#method-i-cover-3F"><code>cover?</code></a></p> <pre class="ruby" data-language="ruby">(1..3).include?(1.5) # =&gt; true
(1..3).cover?(1.5) # =&gt; true
</pre> <p>But when not numeric, the two methods may differ:</p> <pre class="ruby" data-language="ruby">('a'..'d').include?('cc') # =&gt; false
('a'..'d').cover?('cc')   # =&gt; true
</pre> <p>Related: <a href="range.html#method-i-cover-3F"><code>Range#cover?</code></a>.</p> </div> <div class="aliases"> Alias for: <a href="range.html#method-i-member-3F">member?</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-inspect"> <span class="method-callseq"> inspect → string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="inspect-source"> <pre class="c" data-language="c">static VALUE
range_inspect(VALUE range)
{
    return rb_exec_recursive(inspect_range, range, 0);
}</pre> </div> <p>Returns a string representation of <code>self</code>, including <code>begin.inspect</code> and <code>end.inspect</code>:</p> <pre class="ruby" data-language="ruby">(1..4).inspect  # =&gt; "1..4"
(1...4).inspect # =&gt; "1...4"
(1..).inspect   # =&gt; "1.."
(..4).inspect   # =&gt; "..4"
</pre> <p>Note that returns from <a href="range.html#method-i-to_s"><code>to_s</code></a> and <a href="range.html#method-i-inspect"><code>inspect</code></a> may differ:</p> <pre class="ruby" data-language="ruby">('a'..'d').to_s    # =&gt; "a..d"
('a'..'d').inspect # =&gt; "\"a\"..\"d\""
</pre> <p>Related: <a href="range.html#method-i-to_s"><code>Range#to_s</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-last"> <span class="method-callseq"> last → object </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> last(n) → array </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="last-source"> <pre class="c" data-language="c">static VALUE
range_last(int argc, VALUE *argv, VALUE range)
{
    VALUE b, e;

    if (NIL_P(RANGE_END(range))) {
        rb_raise(rb_eRangeError, "cannot get the last element of endless range");
    }
    if (argc == 0) return RANGE_END(range);

    b = RANGE_BEG(range);
    e = RANGE_END(range);
    if (RB_INTEGER_TYPE_P(b) &amp;&amp; RB_INTEGER_TYPE_P(e) &amp;&amp;
        RB_LIKELY(rb_method_basic_definition_p(rb_cRange, idEach))) {
        return rb_int_range_last(argc, argv, range);
    }
    return rb_ary_last(argc, argv, rb_Array(range));
}</pre> </div> <p>With no argument, returns the last element of <code>self</code>, if it exists:</p> <pre class="ruby" data-language="ruby">(1..4).last     # =&gt; 4
('a'..'d').last # =&gt; "d"
</pre> <p>Note that <code>last</code> with no argument returns the end element of <code>self</code> even if <a href="range.html#method-i-exclude_end-3F"><code>exclude_end?</code></a> is <code>true</code>:</p> <pre class="ruby" data-language="ruby">(1...4).last     # =&gt; 4
('a'...'d').last # =&gt; "d"
</pre> <p>With non-negative integer argument <code>n</code> given, returns the last <code>n</code> elements in an array:</p> <pre class="ruby" data-language="ruby">(1..10).last(3) # =&gt; [8, 9, 10]
(1..10).last(0) # =&gt; []
(1..4).last(50) # =&gt; [1, 2, 3, 4]
</pre> <p>Note that <code>last</code> with argument does not return the end element of <code>self</code> if <a href="range.html#method-i-exclude_end-3F"><code>exclude_end?</code></a> it <code>true</code>:</p> <pre class="ruby" data-language="ruby">(1...4).last(3)     # =&gt; [1, 2, 3]
('a'...'d').last(3) # =&gt; ["a", "b", "c"]
</pre> <p>Raises an exception if there is no last element:</p> <pre class="ruby" data-language="ruby">(1..).last # Raises RangeError
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-max"> <span class="method-callseq"> max → object </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> max(n) → array </span> </div> <div class="method-heading"> <span class="method-callseq"> max {|a, b| ... } → object </span> </div> <div class="method-heading"> <span class="method-callseq"> max(n) {|a, b| ... } → array </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="max-source"> <pre class="c" data-language="c">static VALUE
range_max(int argc, VALUE *argv, VALUE range)
{
    VALUE e = RANGE_END(range);
    int nm = FIXNUM_P(e) || rb_obj_is_kind_of(e, rb_cNumeric);

    if (NIL_P(RANGE_END(range))) {
        rb_raise(rb_eRangeError, "cannot get the maximum of endless range");
    }

    VALUE b = RANGE_BEG(range);

    if (rb_block_given_p() || (EXCL(range) &amp;&amp; !nm) || argc) {
        if (NIL_P(b)) {
            rb_raise(rb_eRangeError, "cannot get the maximum of beginless range with custom comparison method");
        }
        return rb_call_super(argc, argv);
    }
    else {
        int c = NIL_P(b) ? -1 : OPTIMIZED_CMP(b, e);

        if (c &gt; 0)
            return Qnil;
        if (EXCL(range)) {
            if (!RB_INTEGER_TYPE_P(e)) {
                rb_raise(rb_eTypeError, "cannot exclude non Integer end value");
            }
            if (c == 0) return Qnil;
            if (!RB_INTEGER_TYPE_P(b)) {
                rb_raise(rb_eTypeError, "cannot exclude end value with non Integer begin value");
            }
            if (FIXNUM_P(e)) {
                return LONG2NUM(FIX2LONG(e) - 1);
            }
            return rb_funcall(e, '-', 1, INT2FIX(1));
        }
        return e;
    }
}</pre> </div> <p>Returns the maximum value in <code>self</code>, using method <code>&lt;=&gt;</code> or a given block for comparison.</p> <p>With no argument and no block given, returns the maximum-valued element of <code>self</code>.</p> <pre class="ruby" data-language="ruby">(1..4).max     # =&gt; 4
('a'..'d').max # =&gt; "d"
(-4..-1).max   # =&gt; -1
</pre> <p>With non-negative integer argument <code>n</code> given, and no block given, returns the <code>n</code> maximum-valued elements of <code>self</code> in an array:</p> <pre class="ruby" data-language="ruby">(1..4).max(2)     # =&gt; [4, 3]
('a'..'d').max(2) # =&gt; ["d", "c"]
(-4..-1).max(2)   # =&gt; [-1, -2]
(1..4).max(50)    # =&gt; [4, 3, 2, 1]
</pre> <p>If a block is given, it is called:</p> <ul>
<li> <p>First, with the first two element of <code>self</code>.</p> </li>
<li> <p>Then, sequentially, with the so-far maximum value and the next element of <code>self</code>.</p> </li>
</ul> <p>To illustrate:</p> <pre class="ruby" data-language="ruby">(1..4).max {|a, b| p [a, b]; a &lt;=&gt; b } # =&gt; 4
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">[2, 1]
[3, 2]
[4, 3]
</pre> <p>With no argument and a block given, returns the return value of the last call to the block:</p> <pre class="ruby" data-language="ruby">(1..4).max {|a, b| -(a &lt;=&gt; b) } # =&gt; 1
</pre> <p>With non-negative integer argument <code>n</code> given, and a block given, returns the return values of the last <code>n</code> calls to the block in an array:</p> <pre class="ruby" data-language="ruby">(1..4).max(2) {|a, b| -(a &lt;=&gt; b) }  # =&gt; [1, 2]
(1..4).max(50) {|a, b| -(a &lt;=&gt; b) } # =&gt; [1, 2, 3, 4]
</pre> <p>Returns an empty array if <code>n</code> is zero:</p> <pre class="ruby" data-language="ruby">(1..4).max(0)                      # =&gt; []
(1..4).max(0) {|a, b| -(a &lt;=&gt; b) } # =&gt; []
</pre> <p>Returns <code>nil</code> or an empty array if:</p> <ul>
<li> <p>The begin value of the range is larger than the end value:</p> <pre class="ruby" data-language="ruby">(4..1).max                         # =&gt; nil
(4..1).max(2)                      # =&gt; []
(4..1).max {|a, b| -(a &lt;=&gt; b) }    # =&gt; nil
(4..1).max(2) {|a, b| -(a &lt;=&gt; b) } # =&gt; []
</pre> </li>
<li> <p>The begin value of an exclusive range is equal to the end value:</p> <pre class="ruby" data-language="ruby">(1...1).max                          # =&gt; nil
(1...1).max(2)                       # =&gt; []
(1...1).max  {|a, b| -(a &lt;=&gt; b) }    # =&gt; nil
(1...1).max(2)  {|a, b| -(a &lt;=&gt; b) } # =&gt; []
</pre> </li>
</ul> <p>Raises an exception if either:</p> <ul>
<li> <p><code>self</code> is a endless range: <code>(1..)</code>.</p> </li>
<li> <p>A block is given and <code>self</code> is a beginless range.</p> </li>
</ul> <p>Related: <a href="range.html#method-i-min"><code>Range#min</code></a>, <a href="range.html#method-i-minmax"><code>Range#minmax</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-member-3F"> <span class="method-name">member?</span> </div> </div> <div class="aliases"> Also aliased as: <a href="range.html#method-i-include-3F">include?</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-min"> <span class="method-callseq"> min → object </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> min(n) → array </span> </div> <div class="method-heading"> <span class="method-callseq"> min {|a, b| ... } → object </span> </div> <div class="method-heading"> <span class="method-callseq"> min(n) {|a, b| ... } → array </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="min-source"> <pre class="c" data-language="c">static VALUE
range_min(int argc, VALUE *argv, VALUE range)
{
    if (NIL_P(RANGE_BEG(range))) {
        rb_raise(rb_eRangeError, "cannot get the minimum of beginless range");
    }

    if (rb_block_given_p()) {
        if (NIL_P(RANGE_END(range))) {
            rb_raise(rb_eRangeError, "cannot get the minimum of endless range with custom comparison method");
        }
        return rb_call_super(argc, argv);
    }
    else if (argc != 0) {
        return range_first(argc, argv, range);
    }
    else {
        VALUE b = RANGE_BEG(range);
        VALUE e = RANGE_END(range);
        int c = NIL_P(e) ? -1 : OPTIMIZED_CMP(b, e);

        if (c &gt; 0 || (c == 0 &amp;&amp; EXCL(range)))
            return Qnil;
        return b;
    }
}</pre> </div> <p>Returns the minimum value in <code>self</code>, using method <code>&lt;=&gt;</code> or a given block for comparison.</p> <p>With no argument and no block given, returns the minimum-valued element of <code>self</code>.</p> <pre class="ruby" data-language="ruby">(1..4).min     # =&gt; 1
('a'..'d').min # =&gt; "a"
(-4..-1).min   # =&gt; -4
</pre> <p>With non-negative integer argument <code>n</code> given, and no block given, returns the <code>n</code> minimum-valued elements of <code>self</code> in an array:</p> <pre class="ruby" data-language="ruby">(1..4).min(2)     # =&gt; [1, 2]
('a'..'d').min(2) # =&gt; ["a", "b"]
(-4..-1).min(2)   # =&gt; [-4, -3]
(1..4).min(50)    # =&gt; [1, 2, 3, 4]
</pre> <p>If a block is given, it is called:</p> <ul>
<li> <p>First, with the first two element of <code>self</code>.</p> </li>
<li> <p>Then, sequentially, with the so-far minimum value and the next element of <code>self</code>.</p> </li>
</ul> <p>To illustrate:</p> <pre class="ruby" data-language="ruby">(1..4).min {|a, b| p [a, b]; a &lt;=&gt; b } # =&gt; 1
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">[2, 1]
[3, 1]
[4, 1]
</pre> <p>With no argument and a block given, returns the return value of the last call to the block:</p> <pre class="ruby" data-language="ruby">(1..4).min {|a, b| -(a &lt;=&gt; b) } # =&gt; 4
</pre> <p>With non-negative integer argument <code>n</code> given, and a block given, returns the return values of the last <code>n</code> calls to the block in an array:</p> <pre class="ruby" data-language="ruby">(1..4).min(2) {|a, b| -(a &lt;=&gt; b) }  # =&gt; [4, 3]
(1..4).min(50) {|a, b| -(a &lt;=&gt; b) } # =&gt; [4, 3, 2, 1]
</pre> <p>Returns an empty array if <code>n</code> is zero:</p> <pre class="ruby" data-language="ruby">(1..4).min(0)                      # =&gt; []
(1..4).min(0) {|a, b| -(a &lt;=&gt; b) } # =&gt; []
</pre> <p>Returns <code>nil</code> or an empty array if:</p> <ul>
<li> <p>The begin value of the range is larger than the end value:</p> <pre class="ruby" data-language="ruby">(4..1).min                         # =&gt; nil
(4..1).min(2)                      # =&gt; []
(4..1).min {|a, b| -(a &lt;=&gt; b) }    # =&gt; nil
(4..1).min(2) {|a, b| -(a &lt;=&gt; b) } # =&gt; []
</pre> </li>
<li> <p>The begin value of an exclusive range is equal to the end value:</p> <pre class="ruby" data-language="ruby">(1...1).min                          # =&gt; nil
(1...1).min(2)                       # =&gt; []
(1...1).min  {|a, b| -(a &lt;=&gt; b) }    # =&gt; nil
(1...1).min(2)  {|a, b| -(a &lt;=&gt; b) } # =&gt; []
</pre> </li>
</ul> <p>Raises an exception if either:</p> <ul>
<li> <p><code>self</code> is a beginless range: <code>(..4)</code>.</p> </li>
<li> <p>A block is given and <code>self</code> is an endless range.</p> </li>
</ul> <p>Related: <a href="range.html#method-i-max"><code>Range#max</code></a>, <a href="range.html#method-i-minmax"><code>Range#minmax</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-minmax"> <span class="method-callseq"> minmax → [object, object] </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> minmax {|a, b| ... } → [object, object] </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="minmax-source"> <pre class="c" data-language="c">static VALUE
range_minmax(VALUE range)
{
    if (rb_block_given_p()) {
        return rb_call_super(0, NULL);
    }
    return rb_assoc_new(
        rb_funcall(range, id_min, 0),
        rb_funcall(range, id_max, 0)
    );
}</pre> </div> <p>Returns a 2-element array containing the minimum and maximum value in <code>self</code>, either according to comparison method <code>&lt;=&gt;</code> or a given block.</p> <p>With no block given, returns the minimum and maximum values, using <code>&lt;=&gt;</code> for comparison:</p> <pre class="ruby" data-language="ruby">(1..4).minmax     # =&gt; [1, 4]
(1...4).minmax    # =&gt; [1, 3]
('a'..'d').minmax # =&gt; ["a", "d"]
(-4..-1).minmax   # =&gt; [-4, -1]
</pre> <p>With a block given, the block must return an integer:</p> <ul>
<li> <p>Negative if <code>a</code> is smaller than <code>b</code>.</p> </li>
<li> <p>Zero if <code>a</code> and <code>b</code> are equal.</p> </li>
<li> <p>Positive if <code>a</code> is larger than <code>b</code>.</p> </li>
</ul> <p>The block is called <code>self.size</code> times to compare elements; returns a 2-element <a href="array.html"><code>Array</code></a> containing the minimum and maximum values from <code>self</code>, per the block:</p> <pre class="ruby" data-language="ruby">(1..4).minmax {|a, b| -(a &lt;=&gt; b) } # =&gt; [4, 1]
</pre> <p>Returns <code>[nil, nil]</code> if:</p> <ul>
<li> <p>The begin value of the range is larger than the end value:</p> <pre class="ruby" data-language="ruby">(4..1).minmax                      # =&gt; [nil, nil]
(4..1).minmax {|a, b| -(a &lt;=&gt; b) } # =&gt; [nil, nil]
</pre> </li>
<li> <p>The begin value of an exclusive range is equal to the end value:</p> <pre class="ruby" data-language="ruby">(1...1).minmax                          # =&gt; [nil, nil]
(1...1).minmax  {|a, b| -(a &lt;=&gt; b) }    # =&gt; [nil, nil]
</pre> </li>
</ul> <p>Raises an exception if <code>self</code> is a beginless or an endless range.</p> <p>Related: <a href="range.html#method-i-min"><code>Range#min</code></a>, <a href="range.html#method-i-max"><code>Range#max</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-overlap-3F"> <span class="method-callseq"> overlap?(range) → true or false </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="overlap-3F-source"> <pre class="c" data-language="c">static VALUE
range_overlap(VALUE range, VALUE other)
{
    if (!rb_obj_is_kind_of(other, rb_cRange)) {
        rb_raise(rb_eTypeError, "wrong argument type %"PRIsVALUE" (expected Range)",
                 rb_class_name(rb_obj_class(other)));
    }

    VALUE self_beg = RANGE_BEG(range);
    VALUE self_end = RANGE_END(range);
    int self_excl = EXCL(range);
    VALUE other_beg = RANGE_BEG(other);
    VALUE other_end = RANGE_END(other);
    int other_excl = EXCL(other);

    if (empty_region_p(self_beg, other_end, other_excl)) return Qfalse;
    if (empty_region_p(other_beg, self_end, self_excl)) return Qfalse;

    /* if both begin values are equal, no more comparisons needed */
    if (rb_equal(self_beg, other_beg)) return Qtrue;

    if (empty_region_p(self_beg, self_end, self_excl)) return Qfalse;
    if (empty_region_p(other_beg, other_end, other_excl)) return Qfalse;

    return Qtrue;
}</pre> </div> <p>Returns <code>true</code> if <code>range</code> overlaps with <code>self</code>, <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">(0..2).overlap?(1..3) #=&gt; true
(0..2).overlap?(3..4) #=&gt; false
(0..).overlap?(..0)   #=&gt; true
</pre> <p>With non-range argument, raises <a href="typeerror.html"><code>TypeError</code></a>.</p> <pre class="ruby" data-language="ruby">(1..3).overlap?(1)         # TypeError
</pre> <p>Returns <code>false</code> if an internal call to <code>&lt;=&gt;</code> returns <code>nil</code>; that is, the operands are not comparable.</p> <pre class="ruby" data-language="ruby">(1..3).overlap?('a'..'d')  # =&gt; false
</pre> <p>Returns <code>false</code> if <code>self</code> or <code>range</code> is empty. “Empty range” means that its begin value is larger than, or equal for an exclusive range, its end value.</p> <pre class="ruby" data-language="ruby">(4..1).overlap?(2..3)      # =&gt; false
(4..1).overlap?(..3)       # =&gt; false
(4..1).overlap?(2..)       # =&gt; false
(2...2).overlap?(1..2)     # =&gt; false

(1..4).overlap?(3..2)      # =&gt; false
(..4).overlap?(3..2)       # =&gt; false
(1..).overlap?(3..2)       # =&gt; false
(1..2).overlap?(2...2)     # =&gt; false
</pre> <p>Returns <code>false</code> if the begin value one of <code>self</code> and <code>range</code> is larger than, or equal if the other is an exclusive range, the end value of the other:</p> <pre class="ruby" data-language="ruby">(4..5).overlap?(2..3)      # =&gt; false
(4..5).overlap?(2...4)     # =&gt; false

(1..2).overlap?(3..4)      # =&gt; false
(1...3).overlap?(3..4)     # =&gt; false
</pre> <p>Returns <code>false</code> if the end value one of <code>self</code> and <code>range</code> is larger than, or equal for an exclusive range, the end value of the other:</p> <pre class="ruby" data-language="ruby">(4..5).overlap?(2..3)      # =&gt; false
(4..5).overlap?(2...4)     # =&gt; false

(1..2).overlap?(3..4)      # =&gt; false
(1...3).overlap?(3..4)     # =&gt; false
</pre> <p>Note that the method wouldn’t make any assumptions about the beginless range being actually empty, even if its upper bound is the minimum possible value of its type, so all this would return <code>true</code>:</p> <pre class="ruby" data-language="ruby">(...-Float::INFINITY).overlap?(...-Float::INFINITY) # =&gt; true
(..."").overlap?(..."") # =&gt; true
(...[]).overlap?(...[]) # =&gt; true
</pre> <p>Even if those ranges are effectively empty (no number can be smaller than <code>-Float::INFINITY</code>), they are still considered overlapping with themselves.</p> <p>Related: <a href="range.html#method-i-cover-3F"><code>Range#cover?</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-reverse_each"> <span class="method-callseq"> reverse_each {|element| ... } → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> reverse_each → an_enumerator </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="reverse_each-source"> <pre class="c" data-language="c">static VALUE
range_reverse_each(VALUE range)
{
    RETURN_SIZED_ENUMERATOR(range, 0, 0, range_enum_size);

    VALUE beg = RANGE_BEG(range);
    VALUE end = RANGE_END(range);
    int excl = EXCL(range);

    if (NIL_P(end)) {
        rb_raise(rb_eTypeError, "can't iterate from %s",
                 rb_obj_classname(end));
    }

    if (FIXNUM_P(beg) &amp;&amp; FIXNUM_P(end)) {
        if (excl) {
            if (end == LONG2FIX(FIXNUM_MIN)) return range;

            end = rb_int_minus(end, INT2FIX(1));
        }

        range_reverse_each_fixnum_section(beg, end);
    }
    else if ((NIL_P(beg) || RB_INTEGER_TYPE_P(beg)) &amp;&amp; RB_INTEGER_TYPE_P(end)) {
        if (excl) {
            end = rb_int_minus(end, INT2FIX(1));
        }
        range_reverse_each_positive_bignum_section(beg, end);
        range_reverse_each_fixnum_section(beg, end);
        range_reverse_each_negative_bignum_section(beg, end);
    }
    else {
        return rb_call_super(0, NULL);
    }

    return range;
}</pre> </div> <p>With a block given, passes each element of <code>self</code> to the block in reverse order:</p> <pre class="ruby" data-language="ruby">a = []
(1..4).reverse_each {|element| a.push(element) } # =&gt; 1..4
a # =&gt; [4, 3, 2, 1]

a = []
(1...4).reverse_each {|element| a.push(element) } # =&gt; 1...4
a # =&gt; [3, 2, 1]
</pre> <p>With no block given, returns an enumerator.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-size"> <span class="method-callseq"> size → non_negative_integer or Infinity or nil </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="size-source"> <pre class="c" data-language="c">static VALUE
range_size(VALUE range)
{
    VALUE b = RANGE_BEG(range), e = RANGE_END(range);
    if (rb_obj_is_kind_of(b, rb_cNumeric)) {
        if (rb_obj_is_kind_of(e, rb_cNumeric)) {
            return ruby_num_interval_step_size(b, e, INT2FIX(1), EXCL(range));
        }
        if (NIL_P(e)) {
            return DBL2NUM(HUGE_VAL);
        }
    }
    else if (NIL_P(b)) {
        if (rb_obj_is_kind_of(e, rb_cNumeric)) {
            return DBL2NUM(HUGE_VAL);
        }
    }

    return Qnil;
}</pre> </div> <p>Returns the count of elements in <code>self</code> if both begin and end values are numeric; otherwise, returns <code>nil</code>:</p> <pre class="ruby" data-language="ruby">(1..4).size      # =&gt; 4
(1...4).size     # =&gt; 3
(1..).size       # =&gt; Infinity
('a'..'z').size  #=&gt; nil
</pre> <p>Related: <a href="range.html#method-i-count"><code>Range#count</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-step"> <span class="method-callseq"> step(n = 1) {|element| ... } → self </span> <a class="method-click-advice">Show source</a> </div> <div class="method-heading"> <span class="method-callseq"> step(n = 1) → enumerator </span> </div> </div> <div class="method-description">
<div class="method-source-code" id="step-source"> <pre class="c" data-language="c">static VALUE
range_step(int argc, VALUE *argv, VALUE range)
{
    VALUE b, e, step, tmp;

    b = RANGE_BEG(range);
    e = RANGE_END(range);
    step = (!rb_check_arity(argc, 0, 1) ? INT2FIX(1) : argv[0]);

    if (!rb_block_given_p()) {
        if (!rb_obj_is_kind_of(step, rb_cNumeric)) {
            step = rb_to_int(step);
        }
        if (rb_equal(step, INT2FIX(0))) {
            rb_raise(rb_eArgError, "step can't be 0");
        }

        const VALUE b_num_p = rb_obj_is_kind_of(b, rb_cNumeric);
        const VALUE e_num_p = rb_obj_is_kind_of(e, rb_cNumeric);
        if ((b_num_p &amp;&amp; (NIL_P(e) || e_num_p)) || (NIL_P(b) &amp;&amp; e_num_p)) {
            return rb_arith_seq_new(range, ID2SYM(rb_frame_this_func()), argc, argv,
                    range_step_size, b, e, step, EXCL(range));
        }

        RETURN_SIZED_ENUMERATOR(range, argc, argv, range_step_size);
    }

    step = check_step_domain(step);
    VALUE iter[2] = {INT2FIX(1), step};

    if (FIXNUM_P(b) &amp;&amp; NIL_P(e) &amp;&amp; FIXNUM_P(step)) {
        long i = FIX2LONG(b), unit = FIX2LONG(step);
        do {
            rb_yield(LONG2FIX(i));
            i += unit;          /* FIXABLE+FIXABLE never overflow */
        } while (FIXABLE(i));
        b = LONG2NUM(i);

        for (;; b = rb_big_plus(b, step))
            rb_yield(b);
    }
    else if (FIXNUM_P(b) &amp;&amp; FIXNUM_P(e) &amp;&amp; FIXNUM_P(step)) { /* fixnums are special */
        long end = FIX2LONG(e);
        long i, unit = FIX2LONG(step);

        if (!EXCL(range))
            end += 1;
        i = FIX2LONG(b);
        while (i &lt; end) {
            rb_yield(LONG2NUM(i));
            if (i + unit &lt; i) break;
            i += unit;
        }

    }
    else if (SYMBOL_P(b) &amp;&amp; (NIL_P(e) || SYMBOL_P(e))) { /* symbols are special */
        b = rb_sym2str(b);
        if (NIL_P(e)) {
            rb_str_upto_endless_each(b, sym_step_i, (VALUE)iter);
        }
        else {
            rb_str_upto_each(b, rb_sym2str(e), EXCL(range), sym_step_i, (VALUE)iter);
        }
    }
    else if (ruby_float_step(b, e, step, EXCL(range), TRUE)) {
        /* done */
    }
    else if (rb_obj_is_kind_of(b, rb_cNumeric) ||
             !NIL_P(rb_check_to_integer(b, "to_int")) ||
             !NIL_P(rb_check_to_integer(e, "to_int"))) {
        ID op = EXCL(range) ? '&lt;' : idLE;
        VALUE v = b;
        int i = 0;

        while (NIL_P(e) || RTEST(rb_funcall(v, op, 1, e))) {
            rb_yield(v);
            i++;
            v = rb_funcall(b, '+', 1, rb_funcall(INT2NUM(i), '*', 1, step));
        }
    }
    else {
        tmp = rb_check_string_type(b);

        if (!NIL_P(tmp)) {
            b = tmp;
            if (NIL_P(e)) {
                rb_str_upto_endless_each(b, step_i, (VALUE)iter);
            }
            else {
                rb_str_upto_each(b, e, EXCL(range), step_i, (VALUE)iter);
            }
        }
        else {
            if (!discrete_object_p(b)) {
                rb_raise(rb_eTypeError, "can't iterate from %s",
                         rb_obj_classname(b));
            }
            if (!NIL_P(e))
                range_each_func(range, step_i, (VALUE)iter);
            else
                for (;; b = rb_funcallv(b, id_succ, 0, 0))
                    step_i(b, (VALUE)iter);
        }
    }
    return range;
}</pre> </div> <p>Iterates over the elements of <code>self</code>.</p> <p>With a block given and no argument, calls the block each element of the range; returns <code>self</code>:</p> <pre class="ruby" data-language="ruby">a = []
(1..5).step {|element| a.push(element) } # =&gt; 1..5
a # =&gt; [1, 2, 3, 4, 5]
a = []
('a'..'e').step {|element| a.push(element) } # =&gt; "a".."e"
a # =&gt; ["a", "b", "c", "d", "e"]
</pre> <p>With a block given and a positive integer argument <code>n</code> given, calls the block with element <code>0</code>, element <code>n</code>, element <code>2n</code>, and so on:</p> <pre class="ruby" data-language="ruby">a = []
(1..5).step(2) {|element| a.push(element) } # =&gt; 1..5
a # =&gt; [1, 3, 5]
a = []
('a'..'e').step(2) {|element| a.push(element) } # =&gt; "a".."e"
a # =&gt; ["a", "c", "e"]
</pre> <p>With no block given, returns an enumerator, which will be of class <a href="enumerator/arithmeticsequence.html"><code>Enumerator::ArithmeticSequence</code></a> if <code>self</code> is numeric; otherwise of class Enumerator:</p> <pre class="ruby" data-language="ruby">e = (1..5).step(2) # =&gt; ((1..5).step(2))
e.class            # =&gt; Enumerator::ArithmeticSequence
('a'..'e').step # =&gt; #&lt;Enumerator: ...&gt;
</pre> <p>Related: <a href="range.html#method-i-25"><code>Range#%</code></a>.</p>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-to_a"> <span class="method-callseq"> to_a → array </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="to_a-source"> <pre class="c" data-language="c">static VALUE
range_to_a(VALUE range)
{
    if (NIL_P(RANGE_END(range))) {
        rb_raise(rb_eRangeError, "cannot convert endless range to an array");
    }
    return rb_call_super(0, 0);
}</pre> </div> <p>Returns an array containing the elements in <code>self</code>, if a finite collection; raises an exception otherwise.</p> <pre class="ruby" data-language="ruby">(1..4).to_a     # =&gt; [1, 2, 3, 4]
(1...4).to_a    # =&gt; [1, 2, 3]
('a'..'d').to_a # =&gt; ["a", "b", "c", "d"]
</pre>  </div> <div class="aliases"> Also aliased as: <a href="range.html#method-i-entries">entries</a> </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-to_json"> <span class="method-name">to_json</span><span class="method-args">(*args)</span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="to_json-source"> <pre class="ruby" data-language="ruby"># File ext/json/lib/json/add/range.rb, line 51
def to_json(*args)
  as_json.to_json(*args)
end</pre> </div> <p>Returns a <a href="json.html"><code>JSON</code></a> string representing <code>self</code>:</p> <pre class="ruby" data-language="ruby">require 'json/add/range'
puts (1..4).to_json
puts (1...4).to_json
puts ('a'..'d').to_json
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">{"json_class":"Range","a":[1,4,false]}
{"json_class":"Range","a":[1,4,true]}
{"json_class":"Range","a":["a","d",false]}
</pre>  </div> </div> <div class="method-detail "> <div class="method-header"> <div class="method-heading" id="method-i-to_s"> <span class="method-callseq"> to_s → string </span> <a class="method-click-advice">Show source</a> </div> </div> <div class="method-description">
<div class="method-source-code" id="to_s-source"> <pre class="c" data-language="c">static VALUE
range_to_s(VALUE range)
{
    VALUE str, str2;

    str = rb_obj_as_string(RANGE_BEG(range));
    str2 = rb_obj_as_string(RANGE_END(range));
    str = rb_str_dup(str);
    rb_str_cat(str, "...", EXCL(range) ? 3 : 2);
    rb_str_append(str, str2);

    return str;
}</pre> </div> <p>Returns a string representation of <code>self</code>, including <code>begin.to_s</code> and <code>end.to_s</code>:</p> <pre class="ruby" data-language="ruby">(1..4).to_s  # =&gt; "1..4"
(1...4).to_s # =&gt; "1...4"
(1..).to_s   # =&gt; "1.."
(..4).to_s   # =&gt; "..4"
</pre> <p>Note that returns from <a href="range.html#method-i-to_s"><code>to_s</code></a> and <a href="range.html#method-i-inspect"><code>inspect</code></a> may differ:</p> <pre class="ruby" data-language="ruby">('a'..'d').to_s    # =&gt; "a..d"
('a'..'d').inspect # =&gt; "\"a\"..\"d\""
</pre> <p>Related: <a href="range.html#method-i-inspect"><code>Range#inspect</code></a>.</p>  </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core &copy; 1993&ndash;2022 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library &copy; contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>
