<h1 id="class-Date" class="anchor-link class"> class Date </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent"><a href="object.html">Object</a></dd>
<dt>Included modules:</dt>
<dd class="meta-includes"><a class="include" href="comparable.html">Comparable</a></dd>
</dl> <section class="description"> <p>Class Date provides methods for storing and manipulating calendar dates.</p> <p>Consider using <a href="time.html">class Time</a> instead of class Date if:</p> <ul>
<li> <p>You need both dates and times; Date handles only dates.</p> </li>
<li> <p>You need only Gregorian dates (and not Julian dates); see <a href="date/calendars_rdoc.html">Julian and Gregorian Calendars</a>.</p> </li>
</ul> <p>A Date object, once created, is immutable, and cannot be modified.</p> <h2 id="class-Date-label-Creating+a+Date">Creating a Date</h2> <p>You can create a date for the current date, using <a href="date.html#method-c-today"><code>Date.today</code></a>:</p> <pre class="ruby" data-language="ruby">Date.today # =&gt; #&lt;Date: 1999-12-31&gt;
</pre> <p>You can create a specific date from various combinations of arguments:</p> <ul>
<li> <p><a href="date.html#method-c-new"><code>Date.new</code></a> takes integer year, month, and day-of-month:</p> <pre class="ruby" data-language="ruby">Date.new(1999, 12, 31) # =&gt; #&lt;Date: 1999-12-31&gt;
</pre> </li>
<li> <p><a href="date.html#method-c-ordinal"><code>Date.ordinal</code></a> takes integer year and day-of-year:</p> <pre class="ruby" data-language="ruby">Date.ordinal(1999, 365) # =&gt; #&lt;Date: 1999-12-31&gt;
</pre> </li>
<li> <p><a href="date.html#method-c-jd"><code>Date.jd</code></a> takes integer Julian day:</p> <pre class="ruby" data-language="ruby">Date.jd(2451544) # =&gt; #&lt;Date: 1999-12-31&gt;
</pre> </li>
<li> <p><a href="date.html#method-c-commercial"><code>Date.commercial</code></a> takes integer commercial data (year, week, day-of-week):</p> <pre class="ruby" data-language="ruby">Date.commercial(1999, 52, 5) # =&gt; #&lt;Date: 1999-12-31&gt;
</pre> </li>
<li> <p><a href="date.html#method-c-parse"><code>Date.parse</code></a> takes a string, which it parses heuristically:</p> <pre class="ruby" data-language="ruby">Date.parse('1999-12-31')    # =&gt; #&lt;Date: 1999-12-31&gt;
Date.parse('31-12-1999')    # =&gt; #&lt;Date: 1999-12-31&gt;
Date.parse('1999-365')      # =&gt; #&lt;Date: 1999-12-31&gt;
Date.parse('1999-W52-5')    # =&gt; #&lt;Date: 1999-12-31&gt;
</pre> </li>
<li> <p><a href="date.html#method-c-strptime"><code>Date.strptime</code></a> takes a date string and a format string, then parses the date string according to the format string:</p> <pre class="ruby" data-language="ruby">Date.strptime('1999-12-31', '%Y-%m-%d')  # =&gt; #&lt;Date: 1999-12-31&gt;
Date.strptime('31-12-1999', '%d-%m-%Y')  # =&gt; #&lt;Date: 1999-12-31&gt;
Date.strptime('1999-365', '%Y-%j')       # =&gt; #&lt;Date: 1999-12-31&gt;
Date.strptime('1999-W52-5', '%G-W%V-%u') # =&gt; #&lt;Date: 1999-12-31&gt;
Date.strptime('1999 52 5', '%Y %U %w')   # =&gt; #&lt;Date: 1999-12-31&gt;
Date.strptime('1999 52 5', '%Y %W %u')   # =&gt; #&lt;Date: 1999-12-31&gt;
Date.strptime('fri31dec99', '%a%d%b%y')  # =&gt; #&lt;Date: 1999-12-31&gt;
</pre> </li>
</ul> <p>See also the specialized methods in <a href="strftime_formatting_rdoc.html#label-Specialized+Format+Strings">“Specialized Format Strings” in Formats for Dates and Times</a></p> <h2 id="class-Date-label-Argument+limit">Argument <code>limit</code>
</h2> <p>Certain singleton methods in Date that parse string arguments also take optional keyword argument <code>limit</code>, which can limit the length of the string argument.</p> <p>When <code>limit</code> is:</p> <ul>
<li> <p>Non-negative: raises <a href="argumenterror.html"><code>ArgumentError</code></a> if the string length is greater than <em>limit</em>.</p> </li>
<li> <p>Other numeric or <code>nil</code>: ignores <code>limit</code>.</p> </li>
<li> <p>Other non-numeric: raises <a href="typeerror.html"><code>TypeError</code></a>.</p> </li>
</ul> </section> <section id="5Buntitled-5D" class="documentation-section anchor-link"> <section class="constants-list"> <header> <h3>Constants</h3> </header> <dl> <dt id="ABBR_DAYNAMES">ABBR_DAYNAMES </dt>
<dd> <p>An array of strings of abbreviated day names in <span><code>English</code></span>. The first is “Sun”.</p> </dd>
<dt id="ABBR_MONTHNAMES">ABBR_MONTHNAMES </dt>
<dd> <p>An array of strings of abbreviated month names in <span><code>English</code></span>. The first element is nil.</p> </dd>
<dt id="DAYNAMES">DAYNAMES </dt>
<dd> <p>An array of strings of the full names of days of the week in <span><code>English</code></span>. The first is “Sunday”.</p> </dd>
<dt id="ENGLAND">ENGLAND </dt>
<dd> <p>The Julian day number of the day of calendar reform for England and her colonies.</p> </dd>
<dt id="GREGORIAN">GREGORIAN </dt>
<dd> <p>The Julian day number of the day of calendar reform for the proleptic Gregorian calendar.</p> </dd>
<dt id="ITALY">ITALY </dt>
<dd> <p>The Julian day number of the day of calendar reform for Italy and some catholic countries.</p> </dd>
<dt id="JULIAN">JULIAN </dt>
<dd> <p>The Julian day number of the day of calendar reform for the proleptic Julian calendar.</p> </dd>
<dt id="MONTHNAMES">MONTHNAMES </dt>
<dd> <p>An array of strings of full month names in <span><code>English</code></span>. The first element is nil.</p> </dd>
</dl> </section> <section id="public-class-5Buntitled-5D-method-details" class="method-section anchor-link"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-_httpdate"> <a href="#method-c-_httpdate" title="Link to this method"> <span class="method-callseq"> _httpdate(string, limit: 128) → hash </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="_httpdate-source"> <pre class="c" data-language="c">static VALUE
date_s__httpdate(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, opt;

    rb_scan_args(argc, argv, "1:", &amp;str, &amp;opt);
    check_limit(str, opt);

    return date__httpdate(str);
}</pre> </div>  <p>Returns a hash of values parsed from <code>string</code>, which should be a valid <a href="strftime_formatting_rdoc.html#label-HTTP+Format">HTTP date format</a>:</p> <pre class="ruby" data-language="ruby">d = Date.new(2001, 2, 3)
s = d.httpdate # =&gt; "Sat, 03 Feb 2001 00:00:00 GMT"
Date._httpdate(s)
# =&gt; {:wday=&gt;6, :mday=&gt;3, :mon=&gt;2, :year=&gt;2001, :hour=&gt;0, :min=&gt;0, :sec=&gt;0, :zone=&gt;"GMT", :offset=&gt;0}
</pre> <p>Related: <a href="date.html#method-c-httpdate"><code>Date.httpdate</code></a> (returns a Date object).</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-_iso8601"> <a href="#method-c-_iso8601" title="Link to this method"> <span class="method-callseq"> _iso8601(string, limit: 128) → hash </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="_iso8601-source"> <pre class="c" data-language="c">static VALUE
date_s__iso8601(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, opt;

    rb_scan_args(argc, argv, "1:", &amp;str, &amp;opt);
    check_limit(str, opt);

    return date__iso8601(str);
}</pre> </div>  <p>Returns a hash of values parsed from <code>string</code>, which should contain an <a href="strftime_formatting_rdoc.html#label-ISO+8601+Format+Specifications">ISO 8601 formatted date</a>:</p> <pre class="ruby" data-language="ruby">d = Date.new(2001, 2, 3)
s = d.iso8601    # =&gt; "2001-02-03"
Date._iso8601(s) # =&gt; {:mday=&gt;3, :year=&gt;2001, :mon=&gt;2}
</pre> <p>See argument <a href="date.html#class-Date-label-Argument+limit">limit</a>.</p> <p>Related: <a href="date.html#method-c-iso8601"><code>Date.iso8601</code></a> (returns a Date object).</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-_jisx0301"> <a href="#method-c-_jisx0301" title="Link to this method"> <span class="method-callseq"> _jisx0301(string, limit: 128) → hash </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="_jisx0301-source"> <pre class="c" data-language="c">static VALUE
date_s__jisx0301(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, opt;

    rb_scan_args(argc, argv, "1:", &amp;str, &amp;opt);
    check_limit(str, opt);

    return date__jisx0301(str);
}</pre> </div>  <p>Returns a hash of values parsed from <code>string</code>, which should be a valid <a href="strftime_formatting_rdoc.html#label-JIS+X+0301+Format">JIS X 0301 date format</a>:</p> <pre class="ruby" data-language="ruby">d = Date.new(2001, 2, 3)
s = d.jisx0301    # =&gt; "H13.02.03"
Date._jisx0301(s) # =&gt; {:year=&gt;2001, :mon=&gt;2, :mday=&gt;3}
</pre> <p>See argument <a href="date.html#class-Date-label-Argument+limit">limit</a>.</p> <p>Related: <a href="date.html#method-c-jisx0301"><code>Date.jisx0301</code></a> (returns a Date object).</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-_parse"> <a href="#method-c-_parse" title="Link to this method"> <span class="method-callseq"> _parse(string, comp = true, limit: 128) → hash </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="_parse-source"> <pre class="c" data-language="c">static VALUE
date_s__parse(int argc, VALUE *argv, VALUE klass)
{
    return date_s__parse_internal(argc, argv, klass);
}</pre> </div>  <p><strong>Note</strong>: This method recognizes many forms in <code>string</code>, but it is not a validator. For formats, see <a href="strftime_formatting_rdoc.html#label-Specialized+Format+Strings">“Specialized Format Strings” in Formats for Dates and Times</a></p> <p>If <code>string</code> does not specify a valid date, the result is unpredictable; consider using <a href="date.html#method-c-_strptime"><code>Date._strptime</code></a> instead.</p> <p>Returns a hash of values parsed from <code>string</code>:</p> <pre class="ruby" data-language="ruby">Date._parse('2001-02-03') # =&gt; {:year=&gt;2001, :mon=&gt;2, :mday=&gt;3}
</pre> <p>If <code>comp</code> is <code>true</code> and the given year is in the range <code>(0..99)</code>, the current century is supplied; otherwise, the year is taken as given:</p> <pre class="ruby" data-language="ruby">Date._parse('01-02-03', true)  # =&gt; {:year=&gt;2001, :mon=&gt;2, :mday=&gt;3}
Date._parse('01-02-03', false) # =&gt; {:year=&gt;1, :mon=&gt;2, :mday=&gt;3}
</pre> <p>See argument <a href="date.html#class-Date-label-Argument+limit">limit</a>.</p> <p>Related: <a href="date.html#method-c-parse"><code>Date.parse</code></a>(returns a Date object).</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-_rfc2822"> <a href="#method-c-_rfc2822" title="Link to this method"> <span class="method-callseq"> _rfc2822(string, limit: 128) → hash </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="_rfc2822-source"> <pre class="c" data-language="c">static VALUE
date_s__rfc2822(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, opt;

    rb_scan_args(argc, argv, "1:", &amp;str, &amp;opt);
    check_limit(str, opt);

    return date__rfc2822(str);
}</pre> </div>  <p>Returns a hash of values parsed from <code>string</code>, which should be a valid <a href="strftime_formatting_rdoc.html#label-RFC+2822+Format">RFC 2822 date format</a>:</p> <pre class="ruby" data-language="ruby">d = Date.new(2001, 2, 3)
s = d.rfc2822 # =&gt; "Sat, 3 Feb 2001 00:00:00 +0000"
Date._rfc2822(s)
# =&gt; {:wday=&gt;6, :mday=&gt;3, :mon=&gt;2, :year=&gt;2001, :hour=&gt;0, :min=&gt;0, :sec=&gt;0, :zone=&gt;"+0000", :offset=&gt;0}
</pre> <p>See argument <a href="date.html#class-Date-label-Argument+limit">limit</a>.</p> <p>Related: <a href="date.html#method-c-rfc2822"><code>Date.rfc2822</code></a> (returns a Date object).</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-_rfc3339"> <a href="#method-c-_rfc3339" title="Link to this method"> <span class="method-callseq"> _rfc3339(string, limit: 128) → hash </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="_rfc3339-source"> <pre class="c" data-language="c">static VALUE
date_s__rfc3339(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, opt;

    rb_scan_args(argc, argv, "1:", &amp;str, &amp;opt);
    check_limit(str, opt);

    return date__rfc3339(str);
}</pre> </div>  <p>Returns a hash of values parsed from <code>string</code>, which should be a valid <a href="strftime_formatting_rdoc.html#label-RFC+3339+Format">RFC 3339 format</a>:</p> <pre class="ruby" data-language="ruby">d = Date.new(2001, 2, 3)
s = d.rfc3339     # =&gt; "2001-02-03T00:00:00+00:00"
Date._rfc3339(s)
# =&gt; {:year=&gt;2001, :mon=&gt;2, :mday=&gt;3, :hour=&gt;0, :min=&gt;0, :sec=&gt;0, :zone=&gt;"+00:00", :offset=&gt;0}
</pre> <p>See argument <a href="date.html#class-Date-label-Argument+limit">limit</a>.</p> <p>Related: <a href="date.html#method-c-rfc3339"><code>Date.rfc3339</code></a> (returns a Date object).</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-_rfc822"> <a href="#method-c-_rfc822" title="Link to this method"> <span class="method-callseq"> _rfc2822(string, limit: 128) → hash </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="_rfc822-source"> <pre class="c" data-language="c">static VALUE
date_s__rfc2822(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, opt;

    rb_scan_args(argc, argv, "1:", &amp;str, &amp;opt);
    check_limit(str, opt);

    return date__rfc2822(str);
}</pre> </div>  <p>Returns a hash of values parsed from <code>string</code>, which should be a valid <a href="strftime_formatting_rdoc.html#label-RFC+2822+Format">RFC 2822 date format</a>:</p> <pre class="ruby" data-language="ruby">d = Date.new(2001, 2, 3)
s = d.rfc2822 # =&gt; "Sat, 3 Feb 2001 00:00:00 +0000"
Date._rfc2822(s)
# =&gt; {:wday=&gt;6, :mday=&gt;3, :mon=&gt;2, :year=&gt;2001, :hour=&gt;0, :min=&gt;0, :sec=&gt;0, :zone=&gt;"+0000", :offset=&gt;0}
</pre> <p>See argument <a href="date.html#class-Date-label-Argument+limit">limit</a>.</p> <p>Related: <a href="date.html#method-c-rfc2822"><code>Date.rfc2822</code></a> (returns a Date object).</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-_strptime"> <a href="#method-c-_strptime" title="Link to this method"> <span class="method-callseq"> _strptime(string, format = '%F') → hash </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="_strptime-source"> <pre class="c" data-language="c">static VALUE
date_s__strptime(int argc, VALUE *argv, VALUE klass)
{
    return date_s__strptime_internal(argc, argv, klass, "%F");
}</pre> </div>  <p>Returns a hash of values parsed from <code>string</code> according to the given <code>format</code>:</p> <pre class="ruby" data-language="ruby">Date._strptime('2001-02-03', '%Y-%m-%d') # =&gt; {:year=&gt;2001, :mon=&gt;2, :mday=&gt;3}
</pre> <p>For other formats, see <a href="strftime_formatting_rdoc.html">Formats for Dates and Times</a>. (Unlike <a href="date.html#method-i-strftime"><code>Date.strftime</code></a>, does not support flags and width.)</p> <p>See also <a href="https://man7.org/linux/man-pages/man3/strptime.3.html">strptime(3)</a>.</p> <p>Related: <a href="date.html#method-c-strptime"><code>Date.strptime</code></a> (returns a Date object).</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-_xmlschema"> <a href="#method-c-_xmlschema" title="Link to this method"> <span class="method-callseq"> _xmlschema(string, limit: 128) → hash </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="_xmlschema-source"> <pre class="c" data-language="c">static VALUE
date_s__xmlschema(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, opt;

    rb_scan_args(argc, argv, "1:", &amp;str, &amp;opt);
    check_limit(str, opt);

    return date__xmlschema(str);
}</pre> </div>  <p>Returns a hash of values parsed from <code>string</code>, which should be a valid XML date format:</p> <pre class="ruby" data-language="ruby">d = Date.new(2001, 2, 3)
s = d.xmlschema    # =&gt; "2001-02-03"
Date._xmlschema(s) # =&gt; {:year=&gt;2001, :mon=&gt;2, :mday=&gt;3}
</pre> <p>See argument <a href="date.html#class-Date-label-Argument+limit">limit</a>.</p> <p>Related: <a href="date.html#method-c-xmlschema"><code>Date.xmlschema</code></a> (returns a Date object).</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-civil"> <a href="#method-c-civil" title="Link to this method"> <span class="method-name">civil</span> <span class="method-args">(*args)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="civil-source"> <pre class="c" data-language="c">static VALUE
date_s_civil(int argc, VALUE *argv, VALUE klass)
{
    return date_initialize(argc, argv, d_lite_s_alloc_simple(klass));
}</pre> </div>  <p>Same as <a href="date.html#method-c-new"><code>Date.new</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-commercial"> <a href="#method-c-commercial" title="Link to this method"> <span class="method-callseq"> commercial(cwyear = -4712, cweek = 1, cwday = 1, start = Date::ITALY) → date </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="commercial-source"> <pre class="c" data-language="c">static VALUE
date_s_commercial(int argc, VALUE *argv, VALUE klass)
{
    VALUE vy, vw, vd, vsg, y, fr, fr2, ret;
    int w, d;
    double sg;

    rb_scan_args(argc, argv, "04", &amp;vy, &amp;vw, &amp;vd, &amp;vsg);

    y = INT2FIX(-4712);
    w = 1;
    d = 1;
    fr2 = INT2FIX(0);
    sg = DEFAULT_SG;

    switch (argc) {
      case 4:
        val2sg(vsg, sg);
      case 3:
        check_numeric(vd, "cwday");
        num2int_with_frac(d, positive_inf);
      case 2:
        check_numeric(vw, "cweek");
        w = NUM2INT(vw);
      case 1:
        check_numeric(vy, "year");
        y = vy;
    }

    {
        VALUE nth;
        int ry, rw, rd, rjd, ns;

        if (!valid_commercial_p(y, w, d, sg,
                                &amp;nth, &amp;ry,
                                &amp;rw, &amp;rd, &amp;rjd,
                                &amp;ns))
            rb_raise(eDateError, "invalid date");

        ret = d_simple_new_internal(klass,
                                    nth, rjd,
                                    sg,
                                    0, 0, 0,
                                    HAVE_JD);
    }
    add_frac();
    return ret;
}</pre> </div>  <p>Returns a new Date object constructed from the arguments.</p> <p>Argument <code>cwyear</code> gives the year, and should be an integer.</p> <p>Argument <code>cweek</code> gives the index of the week within the year, and should be in range (1..53) or (-53..-1); in some years, 53 or -53 will be out-of-range; if negative, counts backward from the end of the year:</p> <pre class="ruby" data-language="ruby">Date.commercial(2022, 1, 1).to_s  # =&gt; "2022-01-03"
Date.commercial(2022, 52, 1).to_s # =&gt; "2022-12-26"
</pre> <p>Argument <code>cwday</code> gives the indes of the weekday within the week, and should be in range (1..7) or (-7..-1); 1 or -7 is Monday; if negative, counts backward from the end of the week:</p> <pre class="ruby" data-language="ruby">Date.commercial(2022, 1, 1).to_s  # =&gt; "2022-01-03"
Date.commercial(2022, 1, -7).to_s # =&gt; "2022-01-03"
</pre> <p>When <code>cweek</code> is 1:</p> <ul>
<li> <p>If January 1 is a Friday, Saturday, or Sunday, the first week begins in the week after:</p> <pre class="ruby" data-language="ruby">Date::ABBR_DAYNAMES[Date.new(2023, 1, 1).wday] # =&gt; "Sun"
Date.commercial(2023, 1, 1).to_s # =&gt; "2023-01-02"
Date.commercial(2023, 1, 7).to_s # =&gt; "2023-01-08"
</pre> </li>
<li> <p>Otherwise, the first week is the week of January 1, which may mean some of the days fall on the year before:</p> <pre class="ruby" data-language="ruby">Date::ABBR_DAYNAMES[Date.new(2020, 1, 1).wday] # =&gt; "Wed"
Date.commercial(2020, 1, 1).to_s # =&gt; "2019-12-30"
Date.commercial(2020, 1, 7).to_s # =&gt; "2020-01-05"
</pre> </li>
</ul> <p>See argument <a href="date/calendars_rdoc.html#label-Argument+start">start</a>.</p> <p>Related: <a href="date.html#method-c-jd"><code>Date.jd</code></a>, <a href="date.html#method-c-new"><code>Date.new</code></a>, <a href="date.html#method-c-ordinal"><code>Date.ordinal</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-gregorian_leap-3F"> <a href="#method-c-gregorian_leap-3F" title="Link to this method"> <span class="method-callseq"> gregorian_leap?(year) → true or false </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="gregorian_leap-3F-source"> <pre class="c" data-language="c">static VALUE
date_s_gregorian_leap_p(VALUE klass, VALUE y)
{
    VALUE nth;
    int ry;

    check_numeric(y, "year");
    decode_year(y, -1, &amp;nth, &amp;ry);
    return f_boolcast(c_gregorian_leap_p(ry));
}</pre> </div>  <p>Returns <code>true</code> if the given year is a leap year in the <a href="https://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar">proleptic Gregorian calendar</a>, <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">Date.gregorian_leap?(2000) # =&gt; true
Date.gregorian_leap?(2001) # =&gt; false
</pre> <p>Related: <a href="date.html#method-c-julian_leap-3F"><code>Date.julian_leap?</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-httpdate"> <a href="#method-c-httpdate" title="Link to this method"> <span class="method-callseq"> httpdate(string = 'Mon, 01 Jan -4712 00:00:00 GMT', start = Date::ITALY, limit: 128) → date </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="httpdate-source"> <pre class="c" data-language="c">static VALUE
date_s_httpdate(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, sg, opt;

    argc = rb_scan_args(argc, argv, "02:", &amp;str, &amp;sg, &amp;opt);

    switch (argc) {
      case 0:
        str = rb_str_new2(JULIAN_EPOCH_DATETIME_HTTPDATE);
      case 1:
        sg = INT2FIX(DEFAULT_SG);
    }

    {
        int argc2 = 1;
        VALUE argv2[2], hash;
        argv2[0] = str;
        if (!NIL_P(opt)) argv2[argc2++] = opt;
        hash = date_s__httpdate(argc2, argv2, klass);
        return d_new_by_frags(klass, hash, sg);
    }
}</pre> </div>  <p>Returns a new Date object with values parsed from <code>string</code>, which should be a valid <a href="strftime_formatting_rdoc.html#label-HTTP+Format">HTTP date format</a>:</p> <pre class="ruby" data-language="ruby">d = Date.new(2001, 2, 3)
s = d.httpdate   # =&gt; "Sat, 03 Feb 2001 00:00:00 GMT"
Date.httpdate(s) # =&gt; #&lt;Date: 2001-02-03&gt;
</pre> <p>See:</p> <ul>
<li> <p>Argument <a href="date/calendars_rdoc.html#label-Argument+start">start</a>.</p> </li>
<li> <p>Argument <a href="date.html#class-Date-label-Argument+limit">limit</a>.</p> </li>
</ul> <p>Related: <a href="date.html#method-c-_httpdate"><code>Date._httpdate</code></a> (returns a hash).</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-iso8601"> <a href="#method-c-iso8601" title="Link to this method"> <span class="method-callseq"> iso8601(string = '-4712-01-01', start = Date::ITALY, limit: 128) → date </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="iso8601-source"> <pre class="c" data-language="c">static VALUE
date_s_iso8601(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, sg, opt;

    argc = rb_scan_args(argc, argv, "02:", &amp;str, &amp;sg, &amp;opt);

    switch (argc) {
      case 0:
        str = rb_str_new2(JULIAN_EPOCH_DATE);
      case 1:
        sg = INT2FIX(DEFAULT_SG);
    }

    {
        int argc2 = 1;
        VALUE argv2[2], hash;
        argv2[0] = str;
        if (!NIL_P(opt)) argv2[argc2++] = opt;
        hash = date_s__iso8601(argc2, argv2, klass);
        return d_new_by_frags(klass, hash, sg);
    }
}</pre> </div>  <p>Returns a new Date object with values parsed from <code>string</code>, which should contain an <a href="strftime_formatting_rdoc.html#label-ISO+8601+Format+Specifications">ISO 8601 formatted date</a>:</p> <pre class="ruby" data-language="ruby">d = Date.new(2001, 2, 3)
s = d.iso8601   # =&gt; "2001-02-03"
Date.iso8601(s) # =&gt; #&lt;Date: 2001-02-03&gt;
</pre> <p>See:</p> <ul>
<li> <p>Argument <a href="date/calendars_rdoc.html#label-Argument+start">start</a>.</p> </li>
<li> <p>Argument <a href="date.html#class-Date-label-Argument+limit">limit</a>.</p> </li>
</ul> <p>Related: <a href="date.html#method-c-_iso8601"><code>Date._iso8601</code></a> (returns a hash).</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-jd"> <a href="#method-c-jd" title="Link to this method"> <span class="method-callseq"> jd(jd = 0, start = Date::ITALY) → date </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="jd-source"> <pre class="c" data-language="c">static VALUE
date_s_jd(int argc, VALUE *argv, VALUE klass)
{
    VALUE vjd, vsg, jd, fr, fr2, ret;
    double sg;

    rb_scan_args(argc, argv, "02", &amp;vjd, &amp;vsg);

    jd = INT2FIX(0);
    fr2 = INT2FIX(0);
    sg = DEFAULT_SG;

    switch (argc) {
      case 2:
        val2sg(vsg, sg);
      case 1:
        check_numeric(vjd, "jd");
        num2num_with_frac(jd, positive_inf);
    }

    {
        VALUE nth;
        int rjd;

        decode_jd(jd, &amp;nth, &amp;rjd);
        ret = d_simple_new_internal(klass,
                                    nth, rjd,
                                    sg,
                                    0, 0, 0,
                                    HAVE_JD);
    }
    add_frac();
    return ret;
}</pre> </div>  <p>Returns a new Date object formed from the arguments:</p> <pre class="ruby" data-language="ruby">Date.jd(2451944).to_s # =&gt; "2001-02-03"
Date.jd(2451945).to_s # =&gt; "2001-02-04"
Date.jd(0).to_s       # =&gt; "-4712-01-01"
</pre> <p>The returned date is:</p> <ul>
<li> <p>Gregorian, if the argument is greater than or equal to <code>start</code>:</p> <pre class="ruby" data-language="ruby">Date::ITALY                         # =&gt; 2299161
Date.jd(Date::ITALY).gregorian?     # =&gt; true
Date.jd(Date::ITALY + 1).gregorian? # =&gt; true
</pre> </li>
<li> <p>Julian, otherwise</p> <pre class="ruby" data-language="ruby">Date.jd(Date::ITALY - 1).julian?    # =&gt; true
</pre> </li>
</ul> <p>See argument <a href="date/calendars_rdoc.html#label-Argument+start">start</a>.</p> <p>Related: <a href="date.html#method-c-new"><code>Date.new</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-jisx0301"> <a href="#method-c-jisx0301" title="Link to this method"> <span class="method-callseq"> jisx0301(string = '-4712-01-01', start = Date::ITALY, limit: 128) → date </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="jisx0301-source"> <pre class="c" data-language="c">static VALUE
date_s_jisx0301(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, sg, opt;

    argc = rb_scan_args(argc, argv, "02:", &amp;str, &amp;sg, &amp;opt);

    switch (argc) {
      case 0:
        str = rb_str_new2(JULIAN_EPOCH_DATE);
      case 1:
        sg = INT2FIX(DEFAULT_SG);
    }

    {
        int argc2 = 1;
        VALUE argv2[2], hash;
        argv2[0] = str;
        if (!NIL_P(opt)) argv2[argc2++] = opt;
        hash = date_s__jisx0301(argc2, argv2, klass);
        return d_new_by_frags(klass, hash, sg);
    }
}</pre> </div>  <p>Returns a new Date object with values parsed from <code>string</code>, which should be a valid <a href="strftime_formatting_rdoc.html#label-JIS+X+0301+Format">JIS X 0301 format</a>:</p> <pre class="ruby" data-language="ruby">d = Date.new(2001, 2, 3)
s = d.jisx0301   # =&gt; "H13.02.03"
Date.jisx0301(s) # =&gt; #&lt;Date: 2001-02-03&gt;
</pre> <p>For no-era year, legacy format, Heisei is assumed.</p> <pre class="ruby" data-language="ruby">Date.jisx0301('13.02.03') # =&gt; #&lt;Date: 2001-02-03&gt;
</pre> <p>See:</p> <ul>
<li> <p>Argument <a href="date/calendars_rdoc.html#label-Argument+start">start</a>.</p> </li>
<li> <p>Argument <a href="date.html#class-Date-label-Argument+limit">limit</a>.</p> </li>
</ul> <p>Related: <a href="date.html#method-c-_jisx0301"><code>Date._jisx0301</code></a> (returns a hash).</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-json_create"> <a href="#method-c-json_create" title="Link to this method"> <span class="method-name">json_create</span> <span class="method-args">(object)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="json_create-source"> <pre class="ruby" data-language="ruby"># File ext/json/lib/json/add/date.rb, line 10
def self.json_create(object)
  civil(*object.values_at('y', 'm', 'd', 'sg'))
end</pre> </div>  <p>See <a href="date.html#method-i-as_json"><code>as_json</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-julian_leap-3F"> <a href="#method-c-julian_leap-3F" title="Link to this method"> <span class="method-callseq"> julian_leap?(year) → true or false </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="julian_leap-3F-source"> <pre class="c" data-language="c">static VALUE
date_s_julian_leap_p(VALUE klass, VALUE y)
{
    VALUE nth;
    int ry;

    check_numeric(y, "year");
    decode_year(y, +1, &amp;nth, &amp;ry);
    return f_boolcast(c_julian_leap_p(ry));
}</pre> </div>  <p>Returns <code>true</code> if the given year is a leap year in the <a href="https://en.wikipedia.org/wiki/Proleptic_Julian_calendar">proleptic Julian calendar</a>, <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">Date.julian_leap?(1900) # =&gt; true
Date.julian_leap?(1901) # =&gt; false
</pre> <p>Related: <a href="date.html#method-c-gregorian_leap-3F"><code>Date.gregorian_leap?</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-leap-3F"> <a href="#method-c-leap-3F" title="Link to this method"> <span class="method-callseq"> gregorian_leap?(year) → true or false </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="leap-3F-source"> <pre class="c" data-language="c">static VALUE
date_s_gregorian_leap_p(VALUE klass, VALUE y)
{
    VALUE nth;
    int ry;

    check_numeric(y, "year");
    decode_year(y, -1, &amp;nth, &amp;ry);
    return f_boolcast(c_gregorian_leap_p(ry));
}</pre> </div>  <p>Returns <code>true</code> if the given year is a leap year in the <a href="https://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar">proleptic Gregorian calendar</a>, <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">Date.gregorian_leap?(2000) # =&gt; true
Date.gregorian_leap?(2001) # =&gt; false
</pre> <p>Related: <a href="date.html#method-c-julian_leap-3F"><code>Date.julian_leap?</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-new"> <a href="#method-c-new" title="Link to this method"> <span class="method-callseq"> new(year = -4712, month = 1, mday = 1, start = Date::ITALY) → date </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="new-source"> <pre class="c" data-language="c">static VALUE
date_initialize(int argc, VALUE *argv, VALUE self)
{
    VALUE vy, vm, vd, vsg, y, fr, fr2, ret;
    int m, d;
    double sg;
    struct SimpleDateData *dat = rb_check_typeddata(self, &amp;d_lite_type);

    if (!simple_dat_p(dat)) {
        rb_raise(rb_eTypeError, "Date expected");
    }

    rb_scan_args(argc, argv, "04", &amp;vy, &amp;vm, &amp;vd, &amp;vsg);

    y = INT2FIX(-4712);
    m = 1;
    d = 1;
    fr2 = INT2FIX(0);
    sg = DEFAULT_SG;

    switch (argc) {
      case 4:
        val2sg(vsg, sg);
      case 3:
        check_numeric(vd, "day");
        num2int_with_frac(d, positive_inf);
      case 2:
        check_numeric(vm, "month");
        m = NUM2INT(vm);
      case 1:
        check_numeric(vy, "year");
        y = vy;
    }

    if (guess_style(y, sg) &lt; 0) {
        VALUE nth;
        int ry, rm, rd;

        if (!valid_gregorian_p(y, m, d,
                               &amp;nth, &amp;ry,
                               &amp;rm, &amp;rd))
            rb_raise(eDateError, "invalid date");

        set_to_simple(self, dat, nth, 0, sg, ry, rm, rd, HAVE_CIVIL);
    }
    else {
        VALUE nth;
        int ry, rm, rd, rjd, ns;

        if (!valid_civil_p(y, m, d, sg,
                           &amp;nth, &amp;ry,
                           &amp;rm, &amp;rd, &amp;rjd,
                           &amp;ns))
            rb_raise(eDateError, "invalid date");

        set_to_simple(self, dat, nth, rjd, sg, ry, rm, rd, HAVE_JD | HAVE_CIVIL);
    }
    ret = self;
    add_frac();
    return ret;
}</pre> </div>  <p>Returns a new Date object constructed from the given arguments:</p> <pre class="ruby" data-language="ruby">Date.new(2022).to_s        # =&gt; "2022-01-01"
Date.new(2022, 2).to_s     # =&gt; "2022-02-01"
Date.new(2022, 2, 4).to_s  # =&gt; "2022-02-04"
</pre> <p>Argument <code>month</code> should be in range (1..12) or range (-12..-1); when the argument is negative, counts backward from the end of the year:</p> <pre class="ruby" data-language="ruby">Date.new(2022, -11, 4).to_s # =&gt; "2022-02-04"
</pre> <p>Argument <code>mday</code> should be in range (1..n) or range (-n..-1) where <code>n</code> is the number of days in the month; when the argument is negative, counts backward from the end of the month.</p> <p>See argument <a href="date/calendars_rdoc.html#label-Argument+start">start</a>.</p> <p>Related: <a href="date.html#method-c-jd"><code>Date.jd</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-ordinal"> <a href="#method-c-ordinal" title="Link to this method"> <span class="method-callseq"> ordinal(year = -4712, yday = 1, start = Date::ITALY) → date </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="ordinal-source"> <pre class="c" data-language="c">static VALUE
date_s_ordinal(int argc, VALUE *argv, VALUE klass)
{
    VALUE vy, vd, vsg, y, fr, fr2, ret;
    int d;
    double sg;

    rb_scan_args(argc, argv, "03", &amp;vy, &amp;vd, &amp;vsg);

    y = INT2FIX(-4712);
    d = 1;
    fr2 = INT2FIX(0);
    sg = DEFAULT_SG;

    switch (argc) {
      case 3:
        val2sg(vsg, sg);
      case 2:
        check_numeric(vd, "yday");
        num2int_with_frac(d, positive_inf);
      case 1:
        check_numeric(vy, "year");
        y = vy;
    }

    {
        VALUE nth;
        int ry, rd, rjd, ns;

        if (!valid_ordinal_p(y, d, sg,
                             &amp;nth, &amp;ry,
                             &amp;rd, &amp;rjd,
                             &amp;ns))
            rb_raise(eDateError, "invalid date");

        ret = d_simple_new_internal(klass,
                                     nth, rjd,
                                     sg,
                                     0, 0, 0,
                                     HAVE_JD);
    }
    add_frac();
    return ret;
}</pre> </div>  <p>Returns a new Date object formed fom the arguments.</p> <p>With no arguments, returns the date for January 1, -4712:</p> <pre class="ruby" data-language="ruby">Date.ordinal.to_s # =&gt; "-4712-01-01"
</pre> <p>With argument <code>year</code>, returns the date for January 1 of that year:</p> <pre class="ruby" data-language="ruby">Date.ordinal(2001).to_s  # =&gt; "2001-01-01"
Date.ordinal(-2001).to_s # =&gt; "-2001-01-01"
</pre> <p>With positive argument <code>yday</code> == <code>n</code>, returns the date for the <code>nth</code> day of the given year:</p> <pre class="ruby" data-language="ruby">Date.ordinal(2001, 14).to_s # =&gt; "2001-01-14"
</pre> <p>With negative argument <code>yday</code>, counts backward from the end of the year:</p> <pre class="ruby" data-language="ruby">Date.ordinal(2001, -14).to_s # =&gt; "2001-12-18"
</pre> <p>Raises an exception if <code>yday</code> is zero or out of range.</p> <p>See argument <a href="date/calendars_rdoc.html#label-Argument+start">start</a>.</p> <p>Related: <a href="date.html#method-c-jd"><code>Date.jd</code></a>, <a href="date.html#method-c-new"><code>Date.new</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-parse"> <a href="#method-c-parse" title="Link to this method"> <span class="method-callseq"> parse(string = '-4712-01-01', comp = true, start = Date::ITALY, limit: 128) → date </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="parse-source"> <pre class="c" data-language="c">static VALUE
date_s_parse(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, comp, sg, opt;

    argc = rb_scan_args(argc, argv, "03:", &amp;str, &amp;comp, &amp;sg, &amp;opt);

    switch (argc) {
      case 0:
        str = rb_str_new2(JULIAN_EPOCH_DATE);
      case 1:
        comp = Qtrue;
      case 2:
        sg = INT2FIX(DEFAULT_SG);
    }

    {
        int argc2 = 2;
        VALUE argv2[3], hash;
        argv2[0] = str;
        argv2[1] = comp;
        if (!NIL_P(opt)) argv2[argc2++] = opt;
        hash = date_s__parse(argc2, argv2, klass);
        return d_new_by_frags(klass, hash, sg);
    }
}</pre> </div>  <p><strong>Note</strong>: This method recognizes many forms in <code>string</code>, but it is not a validator. For formats, see <a href="strftime_formatting_rdoc.html#label-Specialized+Format+Strings">“Specialized Format Strings” in Formats for Dates and Times</a> If <code>string</code> does not specify a valid date, the result is unpredictable; consider using <a href="date.html#method-c-_strptime"><code>Date._strptime</code></a> instead.</p> <p>Returns a new Date object with values parsed from <code>string</code>:</p> <pre class="ruby" data-language="ruby">Date.parse('2001-02-03')   # =&gt; #&lt;Date: 2001-02-03&gt;
Date.parse('20010203')     # =&gt; #&lt;Date: 2001-02-03&gt;
Date.parse('3rd Feb 2001') # =&gt; #&lt;Date: 2001-02-03&gt;
</pre> <p>If <code>comp</code> is <code>true</code> and the given year is in the range <code>(0..99)</code>, the current century is supplied; otherwise, the year is taken as given:</p> <pre class="ruby" data-language="ruby">Date.parse('01-02-03', true)  # =&gt; #&lt;Date: 2001-02-03&gt;
Date.parse('01-02-03', false) # =&gt; #&lt;Date: 0001-02-03&gt;
</pre> <p>See:</p> <ul>
<li> <p>Argument <a href="date/calendars_rdoc.html#label-Argument+start">start</a>.</p> </li>
<li> <p>Argument <a href="date.html#class-Date-label-Argument+limit">limit</a>.</p> </li>
</ul> <p>Related: <a href="date.html#method-c-_parse"><code>Date._parse</code></a> (returns a hash).</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-rfc2822"> <a href="#method-c-rfc2822" title="Link to this method"> <span class="method-callseq"> rfc2822(string = 'Mon, 1 Jan -4712 00:00:00 +0000', start = Date::ITALY, limit: 128) → date </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="rfc2822-source"> <pre class="c" data-language="c">static VALUE
date_s_rfc2822(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, sg, opt;

    argc = rb_scan_args(argc, argv, "02:", &amp;str, &amp;sg, &amp;opt);

    switch (argc) {
      case 0:
        str = rb_str_new2(JULIAN_EPOCH_DATETIME_RFC3339);
      case 1:
        sg = INT2FIX(DEFAULT_SG);
    }

    {
        int argc2 = 1;
        VALUE argv2[2], hash;
        argv2[0] = str;
        if (!NIL_P(opt)) argv2[argc2++] = opt;
        hash = date_s__rfc2822(argc2, argv2, klass);
        return d_new_by_frags(klass, hash, sg);
    }
}</pre> </div>  <p>Returns a new Date object with values parsed from <code>string</code>, which should be a valid <a href="strftime_formatting_rdoc.html#label-RFC+2822+Format">RFC 2822 date format</a>:</p> <pre class="ruby" data-language="ruby">d = Date.new(2001, 2, 3)
s = d.rfc2822   # =&gt; "Sat, 3 Feb 2001 00:00:00 +0000"
Date.rfc2822(s) # =&gt; #&lt;Date: 2001-02-03&gt;
</pre> <p>See:</p> <ul>
<li> <p>Argument <a href="date/calendars_rdoc.html#label-Argument+start">start</a>.</p> </li>
<li> <p>Argument <a href="date.html#class-Date-label-Argument+limit">limit</a>.</p> </li>
</ul> <p>Related: <a href="date.html#method-c-_rfc2822"><code>Date._rfc2822</code></a> (returns a hash).</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-rfc3339"> <a href="#method-c-rfc3339" title="Link to this method"> <span class="method-callseq"> rfc3339(string = '-4712-01-01T00:00:00+00:00', start = Date::ITALY, limit: 128) → date </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="rfc3339-source"> <pre class="c" data-language="c">static VALUE
date_s_rfc3339(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, sg, opt;

    argc = rb_scan_args(argc, argv, "02:", &amp;str, &amp;sg, &amp;opt);

    switch (argc) {
      case 0:
        str = rb_str_new2(JULIAN_EPOCH_DATETIME);
      case 1:
        sg = INT2FIX(DEFAULT_SG);
    }

    {
        int argc2 = 1;
        VALUE argv2[2], hash;
        argv2[0] = str;
        if (!NIL_P(opt)) argv2[argc2++] = opt;
        hash = date_s__rfc3339(argc2, argv2, klass);
        return d_new_by_frags(klass, hash, sg);
    }
}</pre> </div>  <p>Returns a new Date object with values parsed from <code>string</code>, which should be a valid <a href="strftime_formatting_rdoc.html#label-RFC+3339+Format">RFC 3339 format</a>:</p> <pre class="ruby" data-language="ruby">d = Date.new(2001, 2, 3)
s = d.rfc3339   # =&gt; "2001-02-03T00:00:00+00:00"
Date.rfc3339(s) # =&gt; #&lt;Date: 2001-02-03&gt;
</pre> <p>See:</p> <ul>
<li> <p>Argument <a href="date/calendars_rdoc.html#label-Argument+start">start</a>.</p> </li>
<li> <p>Argument <a href="date.html#class-Date-label-Argument+limit">limit</a>.</p> </li>
</ul> <p>Related: <a href="date.html#method-c-_rfc3339"><code>Date._rfc3339</code></a> (returns a hash).</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-rfc822"> <a href="#method-c-rfc822" title="Link to this method"> <span class="method-callseq"> rfc2822(string = 'Mon, 1 Jan -4712 00:00:00 +0000', start = Date::ITALY, limit: 128) → date </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="rfc822-source"> <pre class="c" data-language="c">static VALUE
date_s_rfc2822(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, sg, opt;

    argc = rb_scan_args(argc, argv, "02:", &amp;str, &amp;sg, &amp;opt);

    switch (argc) {
      case 0:
        str = rb_str_new2(JULIAN_EPOCH_DATETIME_RFC3339);
      case 1:
        sg = INT2FIX(DEFAULT_SG);
    }

    {
        int argc2 = 1;
        VALUE argv2[2], hash;
        argv2[0] = str;
        if (!NIL_P(opt)) argv2[argc2++] = opt;
        hash = date_s__rfc2822(argc2, argv2, klass);
        return d_new_by_frags(klass, hash, sg);
    }
}</pre> </div>  <p>Returns a new Date object with values parsed from <code>string</code>, which should be a valid <a href="strftime_formatting_rdoc.html#label-RFC+2822+Format">RFC 2822 date format</a>:</p> <pre class="ruby" data-language="ruby">d = Date.new(2001, 2, 3)
s = d.rfc2822   # =&gt; "Sat, 3 Feb 2001 00:00:00 +0000"
Date.rfc2822(s) # =&gt; #&lt;Date: 2001-02-03&gt;
</pre> <p>See:</p> <ul>
<li> <p>Argument <a href="date/calendars_rdoc.html#label-Argument+start">start</a>.</p> </li>
<li> <p>Argument <a href="date.html#class-Date-label-Argument+limit">limit</a>.</p> </li>
</ul> <p>Related: <a href="date.html#method-c-_rfc2822"><code>Date._rfc2822</code></a> (returns a hash).</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-strptime"> <a href="#method-c-strptime" title="Link to this method"> <span class="method-callseq"> strptime(string = '-4712-01-01', format = '%F', start = Date::ITALY) → date </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="strptime-source"> <pre class="c" data-language="c">static VALUE
date_s_strptime(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, fmt, sg;

    rb_scan_args(argc, argv, "03", &amp;str, &amp;fmt, &amp;sg);

    switch (argc) {
      case 0:
        str = rb_str_new2(JULIAN_EPOCH_DATE);
      case 1:
        fmt = rb_str_new2("%F");
      case 2:
        sg = INT2FIX(DEFAULT_SG);
    }

    {
        VALUE argv2[2], hash;

        argv2[0] = str;
        argv2[1] = fmt;
        hash = date_s__strptime(2, argv2, klass);
        return d_new_by_frags(klass, hash, sg);
    }
}</pre> </div>  <p>Returns a new Date object with values parsed from <code>string</code>, according to the given <code>format</code>:</p> <pre class="ruby" data-language="ruby">Date.strptime('2001-02-03', '%Y-%m-%d')  # =&gt; #&lt;Date: 2001-02-03&gt;
Date.strptime('03-02-2001', '%d-%m-%Y')  # =&gt; #&lt;Date: 2001-02-03&gt;
Date.strptime('2001-034', '%Y-%j')       # =&gt; #&lt;Date: 2001-02-03&gt;
Date.strptime('2001-W05-6', '%G-W%V-%u') # =&gt; #&lt;Date: 2001-02-03&gt;
Date.strptime('2001 04 6', '%Y %U %w')   # =&gt; #&lt;Date: 2001-02-03&gt;
Date.strptime('2001 05 6', '%Y %W %u')   # =&gt; #&lt;Date: 2001-02-03&gt;
Date.strptime('sat3feb01', '%a%d%b%y')   # =&gt; #&lt;Date: 2001-02-03&gt;
</pre> <p>For other formats, see <a href="strftime_formatting_rdoc.html">Formats for Dates and Times</a>. (Unlike <a href="date.html#method-i-strftime"><code>Date.strftime</code></a>, does not support flags and width.)</p> <p>See argument <a href="date/calendars_rdoc.html#label-Argument+start">start</a>.</p> <p>See also <a href="https://man7.org/linux/man-pages/man3/strptime.3.html">strptime(3)</a>.</p> <p>Related: <a href="date.html#method-c-_strptime"><code>Date._strptime</code></a> (returns a hash).</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-today"> <a href="#method-c-today" title="Link to this method"> <span class="method-callseq"> today(start = Date::ITALY) → date </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="today-source"> <pre class="c" data-language="c">static VALUE
date_s_today(int argc, VALUE *argv, VALUE klass)
{
    VALUE vsg, nth, ret;
    double sg;
    time_t t;
    struct tm tm;
    int y, ry, m, d;

    rb_scan_args(argc, argv, "01", &amp;vsg);

    if (argc &lt; 1)
        sg = DEFAULT_SG;
    else
        val2sg(vsg, sg);

    if (time(&amp;t) == -1)
        rb_sys_fail("time");
    tzset();
    if (!localtime_r(&amp;t, &amp;tm))
        rb_sys_fail("localtime");

    y = tm.tm_year + 1900;
    m = tm.tm_mon + 1;
    d = tm.tm_mday;

    decode_year(INT2FIX(y), -1, &amp;nth, &amp;ry);

    ret = d_simple_new_internal(klass,
                                nth, 0,
                                GREGORIAN,
                                ry, m, d,
                                HAVE_CIVIL);
    {
        get_d1(ret);
        set_sg(dat, sg);
    }
    return ret;
}</pre> </div>  <p>Returns a new Date object constructed from the present date:</p> <pre class="ruby" data-language="ruby">Date.today.to_s # =&gt; "2022-07-06"
</pre> <p>See argument <a href="date/calendars_rdoc.html#label-Argument+start">start</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-valid_civil-3F"> <a href="#method-c-valid_civil-3F" title="Link to this method"> <span class="method-callseq"> valid_civil?(year, month, mday, start = Date::ITALY) → true or false </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="valid_civil-3F-source"> <pre class="c" data-language="c">static VALUE
date_s_valid_civil_p(int argc, VALUE *argv, VALUE klass)
{
    VALUE vy, vm, vd, vsg;
    VALUE argv2[4];

    rb_scan_args(argc, argv, "31", &amp;vy, &amp;vm, &amp;vd, &amp;vsg);

    RETURN_FALSE_UNLESS_NUMERIC(vy);
    RETURN_FALSE_UNLESS_NUMERIC(vm);
    RETURN_FALSE_UNLESS_NUMERIC(vd);
    argv2[0] = vy;
    argv2[1] = vm;
    argv2[2] = vd;
    if (argc &lt; 4)
        argv2[3] = INT2FIX(DEFAULT_SG);
    else
        argv2[3] = vsg;

    if (NIL_P(valid_civil_sub(4, argv2, klass, 0)))
        return Qfalse;
    return Qtrue;
}</pre> </div>  <p>Returns <code>true</code> if the arguments define a valid ordinal date, <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">Date.valid_date?(2001, 2, 3)  # =&gt; true
Date.valid_date?(2001, 2, 29) # =&gt; false
Date.valid_date?(2001, 2, -1) # =&gt; true
</pre> <p>See argument <a href="date/calendars_rdoc.html#label-Argument+start">start</a>.</p> <p>Related: <a href="date.html#method-c-jd"><code>Date.jd</code></a>, <a href="date.html#method-c-new"><code>Date.new</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-valid_commercial-3F"> <a href="#method-c-valid_commercial-3F" title="Link to this method"> <span class="method-callseq"> valid_commercial?(cwyear, cweek, cwday, start = Date::ITALY) → true or false </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="valid_commercial-3F-source"> <pre class="c" data-language="c">static VALUE
date_s_valid_commercial_p(int argc, VALUE *argv, VALUE klass)
{
    VALUE vy, vw, vd, vsg;
    VALUE argv2[4];

    rb_scan_args(argc, argv, "31", &amp;vy, &amp;vw, &amp;vd, &amp;vsg);

    RETURN_FALSE_UNLESS_NUMERIC(vy);
    RETURN_FALSE_UNLESS_NUMERIC(vw);
    RETURN_FALSE_UNLESS_NUMERIC(vd);
    argv2[0] = vy;
    argv2[1] = vw;
    argv2[2] = vd;
    if (argc &lt; 4)
        argv2[3] = INT2FIX(DEFAULT_SG);
    else
        argv2[3] = vsg;

    if (NIL_P(valid_commercial_sub(4, argv2, klass, 0)))
        return Qfalse;
    return Qtrue;
}</pre> </div>  <p>Returns <code>true</code> if the arguments define a valid commercial date, <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">Date.valid_commercial?(2001, 5, 6) # =&gt; true
Date.valid_commercial?(2001, 5, 8) # =&gt; false
</pre> <p>See <a href="date.html#method-c-commercial"><code>Date.commercial</code></a>.</p> <p>See argument <a href="date/calendars_rdoc.html#label-Argument+start">start</a>.</p> <p>Related: <a href="date.html#method-c-jd"><code>Date.jd</code></a>, <a href="date.html#method-c-commercial"><code>Date.commercial</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-valid_date-3F"> <a href="#method-c-valid_date-3F" title="Link to this method"> <span class="method-callseq"> valid_civil?(year, month, mday, start = Date::ITALY) → true or false </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="valid_date-3F-source"> <pre class="c" data-language="c">static VALUE
date_s_valid_civil_p(int argc, VALUE *argv, VALUE klass)
{
    VALUE vy, vm, vd, vsg;
    VALUE argv2[4];

    rb_scan_args(argc, argv, "31", &amp;vy, &amp;vm, &amp;vd, &amp;vsg);

    RETURN_FALSE_UNLESS_NUMERIC(vy);
    RETURN_FALSE_UNLESS_NUMERIC(vm);
    RETURN_FALSE_UNLESS_NUMERIC(vd);
    argv2[0] = vy;
    argv2[1] = vm;
    argv2[2] = vd;
    if (argc &lt; 4)
        argv2[3] = INT2FIX(DEFAULT_SG);
    else
        argv2[3] = vsg;

    if (NIL_P(valid_civil_sub(4, argv2, klass, 0)))
        return Qfalse;
    return Qtrue;
}</pre> </div>  <p>Returns <code>true</code> if the arguments define a valid ordinal date, <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">Date.valid_date?(2001, 2, 3)  # =&gt; true
Date.valid_date?(2001, 2, 29) # =&gt; false
Date.valid_date?(2001, 2, -1) # =&gt; true
</pre> <p>See argument <a href="date/calendars_rdoc.html#label-Argument+start">start</a>.</p> <p>Related: <a href="date.html#method-c-jd"><code>Date.jd</code></a>, <a href="date.html#method-c-new"><code>Date.new</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-valid_jd-3F"> <a href="#method-c-valid_jd-3F" title="Link to this method"> <span class="method-callseq"> valid_jd?(jd, start = Date::ITALY) → true </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="valid_jd-3F-source"> <pre class="c" data-language="c">static VALUE
date_s_valid_jd_p(int argc, VALUE *argv, VALUE klass)
{
    VALUE vjd, vsg;
    VALUE argv2[2];

    rb_scan_args(argc, argv, "11", &amp;vjd, &amp;vsg);

    RETURN_FALSE_UNLESS_NUMERIC(vjd);
    argv2[0] = vjd;
    if (argc &lt; 2)
        argv2[1] = INT2FIX(DEFAULT_SG);
    else
        argv2[1] = vsg;

    if (NIL_P(valid_jd_sub(2, argv2, klass, 0)))
        return Qfalse;
    return Qtrue;
}</pre> </div>  <p>Implemented for compatibility; returns <code>true</code> unless <code>jd</code> is invalid (i.e., not a <a href="numeric.html"><code>Numeric</code></a>).</p> <pre class="ruby" data-language="ruby">Date.valid_jd?(2451944) # =&gt; true
</pre> <p>See argument <a href="date/calendars_rdoc.html#label-Argument+start">start</a>.</p> <p>Related: <a href="date.html#method-c-jd"><code>Date.jd</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-valid_ordinal-3F"> <a href="#method-c-valid_ordinal-3F" title="Link to this method"> <span class="method-callseq"> valid_ordinal?(year, yday, start = Date::ITALY) → true or false </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="valid_ordinal-3F-source"> <pre class="c" data-language="c">static VALUE
date_s_valid_ordinal_p(int argc, VALUE *argv, VALUE klass)
{
    VALUE vy, vd, vsg;
    VALUE argv2[3];

    rb_scan_args(argc, argv, "21", &amp;vy, &amp;vd, &amp;vsg);

    RETURN_FALSE_UNLESS_NUMERIC(vy);
    RETURN_FALSE_UNLESS_NUMERIC(vd);
    argv2[0] = vy;
    argv2[1] = vd;
    if (argc &lt; 3)
        argv2[2] = INT2FIX(DEFAULT_SG);
    else
        argv2[2] = vsg;

    if (NIL_P(valid_ordinal_sub(3, argv2, klass, 0)))
        return Qfalse;
    return Qtrue;
}</pre> </div>  <p>Returns <code>true</code> if the arguments define a valid ordinal date, <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">Date.valid_ordinal?(2001, 34)  # =&gt; true
Date.valid_ordinal?(2001, 366) # =&gt; false
</pre> <p>See argument <a href="date/calendars_rdoc.html#label-Argument+start">start</a>.</p> <p>Related: <a href="date.html#method-c-jd"><code>Date.jd</code></a>, <a href="date.html#method-c-ordinal"><code>Date.ordinal</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-c-xmlschema"> <a href="#method-c-xmlschema" title="Link to this method"> <span class="method-callseq"> xmlschema(string = '-4712-01-01', start = Date::ITALY, limit: 128) → date </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="xmlschema-source"> <pre class="c" data-language="c">static VALUE
date_s_xmlschema(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, sg, opt;

    argc = rb_scan_args(argc, argv, "02:", &amp;str, &amp;sg, &amp;opt);

    switch (argc) {
      case 0:
        str = rb_str_new2(JULIAN_EPOCH_DATE);
      case 1:
        sg = INT2FIX(DEFAULT_SG);
    }

    {
        int argc2 = 1;
        VALUE argv2[2], hash;
        argv2[0] = str;
        if (!NIL_P(opt)) argv2[argc2++] = opt;
        hash = date_s__xmlschema(argc2, argv2, klass);
        return d_new_by_frags(klass, hash, sg);
    }
}</pre> </div>  <p>Returns a new Date object with values parsed from <code>string</code>, which should be a valid XML date format:</p> <pre class="ruby" data-language="ruby">d = Date.new(2001, 2, 3)
s = d.xmlschema   # =&gt; "2001-02-03"
Date.xmlschema(s) # =&gt; #&lt;Date: 2001-02-03&gt;
</pre> <p>See:</p> <ul>
<li> <p>Argument <a href="date/calendars_rdoc.html#label-Argument+start">start</a>.</p> </li>
<li> <p>Argument <a href="date.html#class-Date-label-Argument+limit">limit</a>.</p> </li>
</ul> <p>Related: <a href="date.html#method-c-_xmlschema"><code>Date._xmlschema</code></a> (returns a hash).</p> </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section anchor-link"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-2B"> <a href="#method-i-2B" title="Link to this method"> <span class="method-callseq"> d + other → date </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="2B-source"> <pre class="c" data-language="c">static VALUE
d_lite_plus(VALUE self, VALUE other)
{
    int try_rational = 1;
    get_d1(self);

  again:
    switch (TYPE(other)) {
      case T_FIXNUM:
        {
            VALUE nth;
            long t;
            int jd;

            nth = m_nth(dat);
            t = FIX2LONG(other);
            if (DIV(t, CM_PERIOD)) {
                nth = f_add(nth, INT2FIX(DIV(t, CM_PERIOD)));
                t = MOD(t, CM_PERIOD);
            }

            if (!t)
                jd = m_jd(dat);
            else {
                jd = m_jd(dat) + (int)t;
                canonicalize_jd(nth, jd);
            }

            if (simple_dat_p(dat))
                return d_simple_new_internal(rb_obj_class(self),
                                             nth, jd,
                                             dat-&gt;s.sg,
                                             0, 0, 0,
                                             (dat-&gt;s.flags | HAVE_JD) &amp;
                                             ~HAVE_CIVIL);
            else
                return d_complex_new_internal(rb_obj_class(self),
                                              nth, jd,
                                              dat-&gt;c.df, dat-&gt;c.sf,
                                              dat-&gt;c.of, dat-&gt;c.sg,
                                              0, 0, 0,
#ifndef USE_PACK
                                              dat-&gt;c.hour,
                                              dat-&gt;c.min,
                                              dat-&gt;c.sec,
#else
                                              EX_HOUR(dat-&gt;c.pc),
                                              EX_MIN(dat-&gt;c.pc),
                                              EX_SEC(dat-&gt;c.pc),
#endif
                                              (dat-&gt;c.flags | HAVE_JD) &amp;
                                              ~HAVE_CIVIL);
        }
        break;
      case T_BIGNUM:
        {
            VALUE nth;
            int jd, s;

            if (f_positive_p(other))
                s = +1;
            else {
                s = -1;
                other = f_negate(other);
            }

            nth = f_idiv(other, INT2FIX(CM_PERIOD));
            jd = FIX2INT(f_mod(other, INT2FIX(CM_PERIOD)));

            if (s &lt; 0) {
                nth = f_negate(nth);
                jd = -jd;
            }

            if (!jd)
                jd = m_jd(dat);
            else {
                jd = m_jd(dat) + jd;
                canonicalize_jd(nth, jd);
            }

            if (f_zero_p(nth))
                nth = m_nth(dat);
            else
                nth = f_add(m_nth(dat), nth);

            if (simple_dat_p(dat))
                return d_simple_new_internal(rb_obj_class(self),
                                             nth, jd,
                                             dat-&gt;s.sg,
                                             0, 0, 0,
                                             (dat-&gt;s.flags | HAVE_JD) &amp;
                                             ~HAVE_CIVIL);
            else
                return d_complex_new_internal(rb_obj_class(self),
                                              nth, jd,
                                              dat-&gt;c.df, dat-&gt;c.sf,
                                              dat-&gt;c.of, dat-&gt;c.sg,
                                              0, 0, 0,
#ifndef USE_PACK
                                              dat-&gt;c.hour,
                                              dat-&gt;c.min,
                                              dat-&gt;c.sec,
#else
                                              EX_HOUR(dat-&gt;c.pc),
                                              EX_MIN(dat-&gt;c.pc),
                                              EX_SEC(dat-&gt;c.pc),
#endif
                                              (dat-&gt;c.flags | HAVE_JD) &amp;
                                              ~HAVE_CIVIL);
        }
        break;
      case T_FLOAT:
        {
            double jd, o, tmp;
            int s, df;
            VALUE nth, sf;

            o = RFLOAT_VALUE(other);

            if (o &gt; 0)
                s = +1;
            else {
                s = -1;
                o = -o;
            }

            o = modf(o, &amp;tmp);

            if (!floor(tmp / CM_PERIOD)) {
                nth = INT2FIX(0);
                jd = (int)tmp;
            }
            else {
                double i, f;

                f = modf(tmp / CM_PERIOD, &amp;i);
                nth = f_floor(DBL2NUM(i));
                jd = (int)(f * CM_PERIOD);
            }

            o *= DAY_IN_SECONDS;
            o = modf(o, &amp;tmp);
            df = (int)tmp;
            o *= SECOND_IN_NANOSECONDS;
            sf = INT2FIX((int)round(o));

            if (s &lt; 0) {
                jd = -jd;
                df = -df;
                sf = f_negate(sf);
            }

            if (f_zero_p(sf))
                sf = m_sf(dat);
            else {
                sf = f_add(m_sf(dat), sf);
                if (f_lt_p(sf, INT2FIX(0))) {
                    df -= 1;
                    sf = f_add(sf, INT2FIX(SECOND_IN_NANOSECONDS));
                }
                else if (f_ge_p(sf, INT2FIX(SECOND_IN_NANOSECONDS))) {
                    df += 1;
                    sf = f_sub(sf, INT2FIX(SECOND_IN_NANOSECONDS));
                }
            }

            if (!df)
                df = m_df(dat);
            else {
                df = m_df(dat) + df;
                if (df &lt; 0) {
                    jd -= 1;
                    df += DAY_IN_SECONDS;
                }
                else if (df &gt;= DAY_IN_SECONDS) {
                    jd += 1;
                    df -= DAY_IN_SECONDS;
                }
            }

            if (!jd)
                jd = m_jd(dat);
            else {
                jd = m_jd(dat) + jd;
                canonicalize_jd(nth, jd);
            }

            if (f_zero_p(nth))
                nth = m_nth(dat);
            else
                nth = f_add(m_nth(dat), nth);

            if (!df &amp;&amp; f_zero_p(sf) &amp;&amp; !m_of(dat))
                return d_simple_new_internal(rb_obj_class(self),
                                             nth, (int)jd,
                                             m_sg(dat),
                                             0, 0, 0,
                                             (dat-&gt;s.flags | HAVE_JD) &amp;
                                             ~(HAVE_CIVIL | HAVE_TIME |
                                               COMPLEX_DAT));
            else
                return d_complex_new_internal(rb_obj_class(self),
                                              nth, (int)jd,
                                              df, sf,
                                              m_of(dat), m_sg(dat),
                                              0, 0, 0,
                                              0, 0, 0,
                                              (dat-&gt;c.flags |
                                               HAVE_JD | HAVE_DF) &amp;
                                              ~(HAVE_CIVIL | HAVE_TIME));
        }
        break;
      default:
        expect_numeric(other);
        other = f_to_r(other);
        if (!k_rational_p(other)) {
            if (!try_rational) Check_Type(other, T_RATIONAL);
            try_rational = 0;
            goto again;
        }
        /* fall through */
      case T_RATIONAL:
        {
            VALUE nth, sf, t;
            int jd, df, s;

            if (wholenum_p(other)) {
                other = rb_rational_num(other);
                goto again;
            }

            if (f_positive_p(other))
                s = +1;
            else {
                s = -1;
                other = f_negate(other);
            }

            nth = f_idiv(other, INT2FIX(CM_PERIOD));
            t = f_mod(other, INT2FIX(CM_PERIOD));

            jd = FIX2INT(f_idiv(t, INT2FIX(1)));
            t = f_mod(t, INT2FIX(1));

            t = f_mul(t, INT2FIX(DAY_IN_SECONDS));
            df = FIX2INT(f_idiv(t, INT2FIX(1)));
            t = f_mod(t, INT2FIX(1));

            sf = f_mul(t, INT2FIX(SECOND_IN_NANOSECONDS));

            if (s &lt; 0) {
                nth = f_negate(nth);
                jd = -jd;
                df = -df;
                sf = f_negate(sf);
            }

            if (f_zero_p(sf))
                sf = m_sf(dat);
            else {
                sf = f_add(m_sf(dat), sf);
                if (f_lt_p(sf, INT2FIX(0))) {
                    df -= 1;
                    sf = f_add(sf, INT2FIX(SECOND_IN_NANOSECONDS));
                }
                else if (f_ge_p(sf, INT2FIX(SECOND_IN_NANOSECONDS))) {
                    df += 1;
                    sf = f_sub(sf, INT2FIX(SECOND_IN_NANOSECONDS));
                }
            }

            if (!df)
                df = m_df(dat);
            else {
                df = m_df(dat) + df;
                if (df &lt; 0) {
                    jd -= 1;
                    df += DAY_IN_SECONDS;
                }
                else if (df &gt;= DAY_IN_SECONDS) {
                    jd += 1;
                    df -= DAY_IN_SECONDS;
                }
            }

            if (!jd)
                jd = m_jd(dat);
            else {
                jd = m_jd(dat) + jd;
                canonicalize_jd(nth, jd);
            }

            if (f_zero_p(nth))
                nth = m_nth(dat);
            else
                nth = f_add(m_nth(dat), nth);

            if (!df &amp;&amp; f_zero_p(sf) &amp;&amp; !m_of(dat))
                return d_simple_new_internal(rb_obj_class(self),
                                             nth, jd,
                                             m_sg(dat),
                                             0, 0, 0,
                                             (dat-&gt;s.flags | HAVE_JD) &amp;
                                             ~(HAVE_CIVIL | HAVE_TIME |
                                               COMPLEX_DAT));
            else
                return d_complex_new_internal(rb_obj_class(self),
                                              nth, jd,
                                              df, sf,
                                              m_of(dat), m_sg(dat),
                                              0, 0, 0,
                                              0, 0, 0,
                                              (dat-&gt;c.flags |
                                               HAVE_JD | HAVE_DF) &amp;
                                              ~(HAVE_CIVIL | HAVE_TIME));
        }
        break;
    }
}</pre> </div>  <p>Returns a date object pointing <code>other</code> days after self. The other should be a numeric value. If the other is a fractional number, assumes its precision is at most nanosecond.</p> <pre class="ruby" data-language="ruby">Date.new(2001,2,3) + 1    #=&gt; #&lt;Date: 2001-02-04 ...&gt;
DateTime.new(2001,2,3) + Rational(1,2)
                          #=&gt; #&lt;DateTime: 2001-02-03T12:00:00+00:00 ...&gt;
DateTime.new(2001,2,3) + Rational(-1,2)
                          #=&gt; #&lt;DateTime: 2001-02-02T12:00:00+00:00 ...&gt;
DateTime.jd(0,12) + DateTime.new(2001,2,3).ajd
                          #=&gt; #&lt;DateTime: 2001-02-03T00:00:00+00:00 ...&gt;
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-2D"> <a href="#method-i-2D" title="Link to this method"> <span class="method-callseq"> d - other → date or rational </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="2D-source"> <pre class="c" data-language="c">static VALUE
d_lite_minus(VALUE self, VALUE other)
{
    if (k_date_p(other))
        return minus_dd(self, other);

    switch (TYPE(other)) {
      case T_FIXNUM:
        return d_lite_plus(self, LONG2NUM(-FIX2LONG(other)));
      case T_FLOAT:
        return d_lite_plus(self, DBL2NUM(-RFLOAT_VALUE(other)));
      default:
        expect_numeric(other);
        /* fall through */
      case T_BIGNUM:
      case T_RATIONAL:
        return d_lite_plus(self, f_negate(other));
    }
}</pre> </div>  <p>If the other is a date object, returns a <a href="rational.html"><code>Rational</code></a> whose value is the difference between the two dates in days. If the other is a numeric value, returns a date object pointing <code>other</code> days before self. If the other is a fractional number, assumes its precision is at most nanosecond.</p> <pre class="ruby" data-language="ruby">Date.new(2001,2,3) - 1   #=&gt; #&lt;Date: 2001-02-02 ...&gt;
DateTime.new(2001,2,3) - Rational(1,2)
                         #=&gt; #&lt;DateTime: 2001-02-02T12:00:00+00:00 ...&gt;
Date.new(2001,2,3) - Date.new(2001)
                         #=&gt; (33/1)
DateTime.new(2001,2,3) - DateTime.new(2001,2,2,12)
                         #=&gt; (1/2)
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-3C-3C"> <a href="#method-i-3C-3C" title="Link to this method"> <span class="method-callseq"> d &lt;&lt; n → date </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="3C-3C-source"> <pre class="c" data-language="c">static VALUE
d_lite_lshift(VALUE self, VALUE other)
{
    expect_numeric(other);
    return d_lite_rshift(self, f_negate(other));
}</pre> </div>  <p>Returns a new Date object representing the date <code>n</code> months earlier; <code>n</code> should be a numeric:</p> <pre class="ruby" data-language="ruby">(Date.new(2001, 2, 3) &lt;&lt; 1).to_s  # =&gt; "2001-01-03"
(Date.new(2001, 2, 3) &lt;&lt; -2).to_s # =&gt; "2001-04-03"
</pre> <p>When the same day does not exist for the new month, the last day of that month is used instead:</p> <pre class="ruby" data-language="ruby">(Date.new(2001, 3, 31) &lt;&lt; 1).to_s  # =&gt; "2001-02-28"
(Date.new(2001, 3, 31) &lt;&lt; -6).to_s # =&gt; "2001-09-30"
</pre> <p>This results in the following, possibly unexpected, behaviors:</p> <pre class="ruby" data-language="ruby">d0 = Date.new(2001, 3, 31)
d0 &lt;&lt; 2      # =&gt; #&lt;Date: 2001-01-31&gt;
d0 &lt;&lt; 1 &lt;&lt; 1 # =&gt; #&lt;Date: 2001-01-28&gt;

d0 = Date.new(2001, 3, 31)
d1 = d0 &lt;&lt; 1  # =&gt; #&lt;Date: 2001-02-28&gt;
d2 = d1 &lt;&lt; -1 # =&gt; #&lt;Date: 2001-03-28&gt;
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-3C-3D-3E"> <a href="#method-i-3C-3D-3E" title="Link to this method"> <span class="method-callseq"> self &lt;=&gt; other → -1, 0, 1 or nil </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="3C-3D-3E-source"> <pre class="c" data-language="c">static VALUE
d_lite_cmp(VALUE self, VALUE other)
{
    if (!k_date_p(other))
        return cmp_gen(self, other);

    {
        get_d2(self, other);

        if (!(simple_dat_p(adat) &amp;&amp; simple_dat_p(bdat) &amp;&amp;
              m_gregorian_p(adat) == m_gregorian_p(bdat)))
            return cmp_dd(self, other);

        {
            VALUE a_nth, b_nth;
            int a_jd, b_jd;

            m_canonicalize_jd(self, adat);
            m_canonicalize_jd(other, bdat);
            a_nth = m_nth(adat);
            b_nth = m_nth(bdat);
            if (f_eqeq_p(a_nth, b_nth)) {
                a_jd = m_jd(adat);
                b_jd = m_jd(bdat);
                if (a_jd == b_jd) {
                    return INT2FIX(0);
                }
                else if (a_jd &lt; b_jd) {
                    return INT2FIX(-1);
                }
                else {
                    return INT2FIX(1);
                }
            }
            else if (f_lt_p(a_nth, b_nth)) {
                return INT2FIX(-1);
            }
            else {
                return INT2FIX(1);
            }
        }
    }
}</pre> </div>  <p>Compares <code>self</code> and <code>other</code>, returning:</p> <ul>
<li> <p><code>-1</code> if <code>other</code> is larger.</p> </li>
<li> <p><code>0</code> if the two are equal.</p> </li>
<li> <p><code>1</code> if <code>other</code> is smaller.</p> </li>
<li> <p><code>nil</code> if the two are incomparable.</p> </li>
</ul> <p>Argument <code>other</code> may be:</p> <ul>
<li> <p>Another Date object:</p> <pre class="ruby" data-language="ruby">d = Date.new(2022, 7, 27) # =&gt; #&lt;Date: 2022-07-27 ((2459788j,0s,0n),+0s,2299161j)&gt;
prev_date = d.prev_day    # =&gt; #&lt;Date: 2022-07-26 ((2459787j,0s,0n),+0s,2299161j)&gt;
next_date = d.next_day    # =&gt; #&lt;Date: 2022-07-28 ((2459789j,0s,0n),+0s,2299161j)&gt;
d &lt;=&gt; next_date           # =&gt; -1
d &lt;=&gt; d                   # =&gt; 0
d &lt;=&gt; prev_date           # =&gt; 1
</pre> </li>
<li> <p>A <a href="datetime.html"><code>DateTime</code></a> object:</p> <pre class="ruby" data-language="ruby">d &lt;=&gt; DateTime.new(2022, 7, 26) # =&gt; 1
d &lt;=&gt; DateTime.new(2022, 7, 27) # =&gt; 0
d &lt;=&gt; DateTime.new(2022, 7, 28) # =&gt; -1
</pre> </li>
<li> <p>A numeric (compares <code>self.ajd</code> to <code>other</code>):</p> <pre class="ruby" data-language="ruby">d &lt;=&gt; 2459788 # =&gt; -1
d &lt;=&gt; 2459787 # =&gt; 1
d &lt;=&gt; 2459786 # =&gt; 1
d &lt;=&gt; d.ajd   # =&gt; 0
</pre> </li>
<li> <p>Any other object:</p> <pre class="ruby" data-language="ruby">d &lt;=&gt; Object.new # =&gt; nil
</pre> </li>
</ul> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-3D-3D-3D"> <a href="#method-i-3D-3D-3D" title="Link to this method"> <span class="method-callseq"> self === other → true, false, or nil. </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="3D-3D-3D-source"> <pre class="c" data-language="c">static VALUE
d_lite_equal(VALUE self, VALUE other)
{
    if (!k_date_p(other))
        return equal_gen(self, other);

    {
        get_d2(self, other);

        if (!(m_gregorian_p(adat) == m_gregorian_p(bdat)))
            return equal_gen(self, other);

        {
            VALUE a_nth, b_nth;
            int a_jd, b_jd;

            m_canonicalize_jd(self, adat);
            m_canonicalize_jd(other, bdat);
            a_nth = m_nth(adat);
            b_nth = m_nth(bdat);
            a_jd = m_local_jd(adat);
            b_jd = m_local_jd(bdat);
            if (f_eqeq_p(a_nth, b_nth) &amp;&amp;
                a_jd == b_jd)
                return Qtrue;
            return Qfalse;
        }
    }
}</pre> </div>  <p>Returns <code>true</code> if <code>self</code> and <code>other</code> represent the same date, <code>false</code> if not, <code>nil</code> if the two are not comparable.</p> <p>Argument <code>other</code> may be:</p> <ul>
<li> <p>Another Date object:</p> <pre class="ruby" data-language="ruby">d = Date.new(2022, 7, 27) # =&gt; #&lt;Date: 2022-07-27 ((2459788j,0s,0n),+0s,2299161j)&gt;
prev_date = d.prev_day    # =&gt; #&lt;Date: 2022-07-26 ((2459787j,0s,0n),+0s,2299161j)&gt;
next_date = d.next_day    # =&gt; #&lt;Date: 2022-07-28 ((2459789j,0s,0n),+0s,2299161j)&gt;
d === prev_date           # =&gt; false
d === d                   # =&gt; true
d === next_date           # =&gt; false
</pre> </li>
<li> <p>A <a href="datetime.html"><code>DateTime</code></a> object:</p> <pre class="ruby" data-language="ruby">d === DateTime.new(2022, 7, 26) # =&gt; false
d === DateTime.new(2022, 7, 27) # =&gt; true
d === DateTime.new(2022, 7, 28) # =&gt; false
</pre> </li>
<li> <p>A numeric (compares <code>self.jd</code> to <code>other</code>):</p> <pre class="ruby" data-language="ruby">d === 2459788 # =&gt; true
d === 2459787 # =&gt; false
d === 2459786 # =&gt; false
d === d.jd    # =&gt; true
</pre> </li>
<li> <p>An object not comparable:</p> <pre class="ruby" data-language="ruby">d === Object.new # =&gt; nil
</pre> </li>
</ul> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-3E-3E"> <a href="#method-i-3E-3E" title="Link to this method"> <span class="method-callseq"> d &gt;&gt; n → new_date </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="3E-3E-source"> <pre class="c" data-language="c">static VALUE
d_lite_rshift(VALUE self, VALUE other)
{
    VALUE t, y, nth, rjd2;
    int m, d, rjd;
    double sg;

    get_d1(self);
    t = f_add3(f_mul(m_real_year(dat), INT2FIX(12)),
               INT2FIX(m_mon(dat) - 1),
               other);
    if (FIXNUM_P(t)) {
        long it = FIX2LONG(t);
        y = LONG2NUM(DIV(it, 12));
        it = MOD(it, 12);
        m = (int)it + 1;
    }
    else {
        y = f_idiv(t, INT2FIX(12));
        t = f_mod(t, INT2FIX(12));
        m = FIX2INT(t) + 1;
    }
    d = m_mday(dat);
    sg = m_sg(dat);

    while (1) {
        int ry, rm, rd, ns;

        if (valid_civil_p(y, m, d, sg,
                          &amp;nth, &amp;ry,
                          &amp;rm, &amp;rd, &amp;rjd, &amp;ns))
            break;
        if (--d &lt; 1)
            rb_raise(eDateError, "invalid date");
    }
    encode_jd(nth, rjd, &amp;rjd2);
    return d_lite_plus(self, f_sub(rjd2, m_real_local_jd(dat)));
}</pre> </div>  <p>Returns a new Date object representing the date <code>n</code> months later; <code>n</code> should be a numeric:</p> <pre class="ruby" data-language="ruby">(Date.new(2001, 2, 3) &gt;&gt; 1).to_s  # =&gt; "2001-03-03"
(Date.new(2001, 2, 3) &gt;&gt; -2).to_s # =&gt; "2000-12-03"
</pre> <p>When the same day does not exist for the new month, the last day of that month is used instead:</p> <pre class="ruby" data-language="ruby">(Date.new(2001, 1, 31) &gt;&gt; 1).to_s  # =&gt; "2001-02-28"
(Date.new(2001, 1, 31) &gt;&gt; -4).to_s # =&gt; "2000-09-30"
</pre> <p>This results in the following, possibly unexpected, behaviors:</p> <pre class="ruby" data-language="ruby">d0 = Date.new(2001, 1, 31)
d1 = d0 &gt;&gt; 1 # =&gt; #&lt;Date: 2001-02-28&gt;
d2 = d1 &gt;&gt; 1 # =&gt; #&lt;Date: 2001-03-28&gt;

d0 = Date.new(2001, 1, 31)
d1 = d0 &gt;&gt; 1  # =&gt; #&lt;Date: 2001-02-28&gt;
d2 = d1 &gt;&gt; -1 # =&gt; #&lt;Date: 2001-01-28&gt;
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-ajd"> <a href="#method-i-ajd" title="Link to this method"> <span class="method-callseq"> ajd → rational </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="ajd-source"> <pre class="c" data-language="c">static VALUE
d_lite_ajd(VALUE self)
{
    get_d1(self);
    return m_ajd(dat);
}</pre> </div>  <p>Returns the astronomical Julian day number. This is a fractional number, which is not adjusted by the offset.</p> <pre class="ruby" data-language="ruby">DateTime.new(2001,2,3,4,5,6,'+7').ajd     #=&gt; (11769328217/4800)
DateTime.new(2001,2,2,14,5,6,'-7').ajd    #=&gt; (11769328217/4800)
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-amjd"> <a href="#method-i-amjd" title="Link to this method"> <span class="method-callseq"> amjd → rational </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="amjd-source"> <pre class="c" data-language="c">static VALUE
d_lite_amjd(VALUE self)
{
    get_d1(self);
    return m_amjd(dat);
}</pre> </div>  <p>Returns the astronomical modified Julian day number. This is a fractional number, which is not adjusted by the offset.</p> <pre class="ruby" data-language="ruby">DateTime.new(2001,2,3,4,5,6,'+7').amjd    #=&gt; (249325817/4800)
DateTime.new(2001,2,2,14,5,6,'-7').amjd   #=&gt; (249325817/4800)
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-as_json"> <a href="#method-i-as_json" title="Link to this method"> <span class="method-name">as_json</span> <span class="method-args">(*)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="as_json-source"> <pre class="ruby" data-language="ruby"># File ext/json/lib/json/add/date.rb, line 32
def as_json(*)
  {
    JSON.create_id =&gt; self.class.name,
    'y' =&gt; year,
    'm' =&gt; month,
    'd' =&gt; day,
    'sg' =&gt; start,
  }
end</pre> </div>  <p>Methods <a href="date.html#method-i-as_json"><code>Date#as_json</code></a> and <a href="date.html#method-c-json_create"><code>Date.json_create</code></a> may be used to serialize and deserialize a Date object; see <a href="marshal.html"><code>Marshal</code></a>.</p> <p>Method <a href="date.html#method-i-as_json"><code>Date#as_json</code></a> serializes <code>self</code>, returning a 2-element hash representing <code>self</code>:</p> <pre class="ruby" data-language="ruby">require 'json/add/date'
x = Date.today.as_json
# =&gt; {"json_class"=&gt;"Date", "y"=&gt;2023, "m"=&gt;11, "d"=&gt;21, "sg"=&gt;2299161.0}
</pre> <p>Method <code>JSON.create</code> deserializes such a hash, returning a Date object:</p> <pre class="ruby" data-language="ruby">Date.json_create(x)
# =&gt; #&lt;Date: 2023-11-21 ((2460270j,0s,0n),+0s,2299161j)&gt;
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-asctime"> <a href="#method-i-asctime" title="Link to this method"> <span class="method-name">asctime</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="aliases"> Also aliased as: <a href="date.html#method-i-ctime">ctime</a> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-ctime"> <a href="#method-i-ctime" title="Link to this method"> <span class="method-name">ctime</span> </a> </div> </div> <div class="aliases"> Alias for: <a href="date.html#method-i-asctime">asctime</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-cwday"> <a href="#method-i-cwday" title="Link to this method"> <span class="method-callseq"> cwday → integer </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="cwday-source"> <pre class="c" data-language="c">static VALUE
d_lite_cwday(VALUE self)
{
    get_d1(self);
    return INT2FIX(m_cwday(dat));
}</pre> </div>  <p>Returns the commercial-date weekday index for <code>self</code> (see <a href="date.html#method-c-commercial"><code>Date.commercial</code></a>); 1 is Monday:</p> <pre class="ruby" data-language="ruby">Date.new(2001, 2, 3).cwday # =&gt; 6
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-cweek"> <a href="#method-i-cweek" title="Link to this method"> <span class="method-callseq"> cweek → integer </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="cweek-source"> <pre class="c" data-language="c">static VALUE
d_lite_cweek(VALUE self)
{
    get_d1(self);
    return INT2FIX(m_cweek(dat));
}</pre> </div>  <p>Returns commercial-date week index for <code>self</code> (see <a href="date.html#method-c-commercial"><code>Date.commercial</code></a>):</p> <pre class="ruby" data-language="ruby">Date.new(2001, 2, 3).cweek # =&gt; 5
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-cwyear"> <a href="#method-i-cwyear" title="Link to this method"> <span class="method-callseq"> cwyear → integer </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="cwyear-source"> <pre class="c" data-language="c">static VALUE
d_lite_cwyear(VALUE self)
{
    get_d1(self);
    return m_real_cwyear(dat);
}</pre> </div>  <p>Returns commercial-date year for <code>self</code> (see <a href="date.html#method-c-commercial"><code>Date.commercial</code></a>):</p> <pre class="ruby" data-language="ruby">Date.new(2001, 2, 3).cwyear # =&gt; 2001
Date.new(2000, 1, 1).cwyear # =&gt; 1999
</pre> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-day"> <a href="#method-i-day" title="Link to this method"> <span class="method-name">day</span> </a> </div> </div> <div class="aliases"> Alias for: <a href="date.html#method-i-mday">mday</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-day_fraction"> <a href="#method-i-day_fraction" title="Link to this method"> <span class="method-callseq"> day_fraction → rational </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="day_fraction-source"> <pre class="c" data-language="c">static VALUE
d_lite_day_fraction(VALUE self)
{
    get_d1(self);
    if (simple_dat_p(dat))
        return INT2FIX(0);
    return m_fr(dat);
}</pre> </div>  <p>Returns the fractional part of the day in range (Rational(0, 1)…Rational(1, 1)):</p> <pre class="ruby" data-language="ruby">DateTime.new(2001,2,3,12).day_fraction # =&gt; (1/2)
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-deconstruct_keys"> <a href="#method-i-deconstruct_keys" title="Link to this method"> <span class="method-callseq"> deconstruct_keys(array_of_names_or_nil) → hash </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="deconstruct_keys-source"> <pre class="c" data-language="c">static VALUE
d_lite_deconstruct_keys(VALUE self, VALUE keys)
{
    return deconstruct_keys(self, keys, /* is_datetime=false */ 0);
}</pre> </div>  <p>Returns a hash of the name/value pairs, to use in pattern matching. Possible keys are: <code>:year</code>, <code>:month</code>, <code>:day</code>, <code>:wday</code>, <code>:yday</code>.</p> <p>Possible usages:</p> <pre class="ruby" data-language="ruby">d = Date.new(2022, 10, 5)

if d in wday: 3, day: ..7  # uses deconstruct_keys underneath
  puts "first Wednesday of the month"
end
#=&gt; prints "first Wednesday of the month"

case d
in year: ...2022
  puts "too old"
in month: ..9
  puts "quarter 1-3"
in wday: 1..5, month:
  puts "working day in month #{month}"
end
#=&gt; prints "working day in month 10"
</pre> <p>Note that deconstruction by pattern can also be combined with class check:</p> <pre class="ruby" data-language="ruby">if d in Date(wday: 3, day: ..7)
  puts "first Wednesday of the month"
end
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-downto"> <a href="#method-i-downto" title="Link to this method"> <span class="method-callseq"> downto(min){|date| ... } → self </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="downto-source"> <pre class="c" data-language="c">static VALUE
d_lite_downto(VALUE self, VALUE min)
{
    VALUE date;

    RETURN_ENUMERATOR(self, 1, &amp;min);

    date = self;
    while (FIX2INT(d_lite_cmp(date, min)) &gt;= 0) {
        rb_yield(date);
        date = d_lite_plus(date, INT2FIX(-1));
    }
    return self;
}</pre> </div>  <p>Equivalent to <a href="date.html#method-i-step"><code>step</code></a> with arguments <code>min</code> and <code>-1</code>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-england"> <a href="#method-i-england" title="Link to this method"> <span class="method-callseq"> england → new_date </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="england-source"> <pre class="c" data-language="c">static VALUE
d_lite_england(VALUE self)
{
    return dup_obj_with_new_start(self, ENGLAND);
}</pre> </div>  <p>Equivalent to <a href="date.html#method-i-new_start"><code>Date#new_start</code></a> with argument <a href="date.html#ENGLAND"><code>Date::ENGLAND</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-friday-3F"> <a href="#method-i-friday-3F" title="Link to this method"> <span class="method-callseq"> friday? → true or false </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="friday-3F-source"> <pre class="c" data-language="c">static VALUE
d_lite_friday_p(VALUE self)
{
    get_d1(self);
    return f_boolcast(m_wday(dat) == 5);
}</pre> </div>  <p>Returns <code>true</code> if <code>self</code> is a Friday, <code>false</code> otherwise.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-gregorian"> <a href="#method-i-gregorian" title="Link to this method"> <span class="method-callseq"> gregorian → new_date </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="gregorian-source"> <pre class="c" data-language="c">static VALUE
d_lite_gregorian(VALUE self)
{
    return dup_obj_with_new_start(self, GREGORIAN);
}</pre> </div>  <p>Equivalent to <a href="date.html#method-i-new_start"><code>Date#new_start</code></a> with argument <a href="date.html#GREGORIAN"><code>Date::GREGORIAN</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-gregorian-3F"> <a href="#method-i-gregorian-3F" title="Link to this method"> <span class="method-callseq"> gregorian? → true or false </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="gregorian-3F-source"> <pre class="c" data-language="c">static VALUE
d_lite_gregorian_p(VALUE self)
{
    get_d1(self);
    return f_boolcast(m_gregorian_p(dat));
}</pre> </div>  <p>Returns <code>true</code> if the date is on or after the date of calendar reform, <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">Date.new(1582, 10, 15).gregorian?       # =&gt; true
(Date.new(1582, 10, 15) - 1).gregorian? # =&gt; false
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-httpdate"> <a href="#method-i-httpdate" title="Link to this method"> <span class="method-callseq"> httpdate → string </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="httpdate-source"> <pre class="c" data-language="c">static VALUE
d_lite_httpdate(VALUE self)
{
    volatile VALUE dup = dup_obj_with_new_offset(self, 0);
    return strftimev("%a, %d %b %Y %T GMT", dup, set_tmx);
}</pre> </div>  <p>Equivalent to <a href="date.html#method-i-strftime"><code>strftime</code></a> with argument <code>'%a, %d %b %Y %T GMT'</code>; see <a href="strftime_formatting_rdoc.html">Formats for Dates and Times</a>:</p> <pre class="ruby" data-language="ruby">Date.new(2001, 2, 3).httpdate # =&gt; "Sat, 03 Feb 2001 00:00:00 GMT"
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-infinite-3F"> <a href="#method-i-infinite-3F" title="Link to this method"> <span class="method-callseq"> infinite? → false </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="infinite-3F-source"> <pre class="ruby" data-language="ruby"># File ext/date/lib/date.rb, line 13
def infinite?
  false
end</pre> </div>  <p>Returns <code>false</code></p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-inspect"> <a href="#method-i-inspect" title="Link to this method"> <span class="method-callseq"> inspect → string </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="inspect-source"> <pre class="c" data-language="c">static VALUE
d_lite_inspect(VALUE self)
{
    get_d1(self);
    return mk_inspect(dat, rb_obj_class(self), self);
}</pre> </div>  <p>Returns a string representation of <code>self</code>:</p> <pre class="ruby" data-language="ruby">Date.new(2001, 2, 3).inspect
# =&gt; "#&lt;Date: 2001-02-03 ((2451944j,0s,0n),+0s,2299161j)&gt;"
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-iso8601"> <a href="#method-i-iso8601" title="Link to this method"> <span class="method-callseq"> iso8601 → string </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="iso8601-source"> <pre class="c" data-language="c">static VALUE
d_lite_iso8601(VALUE self)
{
    return strftimev("%Y-%m-%d", self, set_tmx);
}</pre> </div>  <p>Equivalent to <a href="date.html#method-i-strftime"><code>strftime</code></a> with argument <code>'%Y-%m-%d'</code> (or its <a href="strftime_formatting_rdoc.html#label-Shorthand+Conversion+Specifiers">shorthand form</a> <code>'%F'</code>);</p> <pre class="ruby" data-language="ruby">Date.new(2001, 2, 3).iso8601 # =&gt; "2001-02-03"
</pre> </div> <div class="aliases"> Also aliased as: <a href="date.html#method-i-xmlschema">xmlschema</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-italy"> <a href="#method-i-italy" title="Link to this method"> <span class="method-callseq"> italy → new_date </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="italy-source"> <pre class="c" data-language="c">static VALUE
d_lite_italy(VALUE self)
{
    return dup_obj_with_new_start(self, ITALY);
}</pre> </div>  <p>Equivalent to <a href="date.html#method-i-new_start"><code>Date#new_start</code></a> with argument <a href="date.html#ITALY"><code>Date::ITALY</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-jd"> <a href="#method-i-jd" title="Link to this method"> <span class="method-callseq"> jd → integer </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="jd-source"> <pre class="c" data-language="c">static VALUE
d_lite_jd(VALUE self)
{
    get_d1(self);
    return m_real_local_jd(dat);
}</pre> </div>  <p>Returns the Julian day number. This is a whole number, which is adjusted by the offset as the local time.</p> <pre class="ruby" data-language="ruby">DateTime.new(2001,2,3,4,5,6,'+7').jd      #=&gt; 2451944
DateTime.new(2001,2,3,4,5,6,'-7').jd      #=&gt; 2451944
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-jisx0301"> <a href="#method-i-jisx0301" title="Link to this method"> <span class="method-callseq"> jisx0301 → string </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="jisx0301-source"> <pre class="c" data-language="c">static VALUE
d_lite_jisx0301(VALUE self)
{
    char fmtbuf[JISX0301_DATE_SIZE];
    const char *fmt;

    get_d1(self);
    fmt = jisx0301_date_format(fmtbuf, sizeof(fmtbuf),
                               m_real_local_jd(dat),
                               m_real_year(dat));
    return strftimev(fmt, self, set_tmx);
}</pre> </div>  <p>Returns a string representation of the date in <code>self</code> in JIS X 0301 format.</p> <pre class="ruby" data-language="ruby">Date.new(2001, 2, 3).jisx0301 # =&gt; "H13.02.03"
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-julian"> <a href="#method-i-julian" title="Link to this method"> <span class="method-callseq"> julian → new_date </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="julian-source"> <pre class="c" data-language="c">static VALUE
d_lite_julian(VALUE self)
{
    return dup_obj_with_new_start(self, JULIAN);
}</pre> </div>  <p>Equivalent to <a href="date.html#method-i-new_start"><code>Date#new_start</code></a> with argument <a href="date.html#JULIAN"><code>Date::JULIAN</code></a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-julian-3F"> <a href="#method-i-julian-3F" title="Link to this method"> <span class="method-callseq"> julian? → true or false </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="julian-3F-source"> <pre class="c" data-language="c">static VALUE
d_lite_julian_p(VALUE self)
{
    get_d1(self);
    return f_boolcast(m_julian_p(dat));
}</pre> </div>  <p>Returns <code>true</code> if the date is before the date of calendar reform, <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">(Date.new(1582, 10, 15) - 1).julian? # =&gt; true
Date.new(1582, 10, 15).julian?       # =&gt; false
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-ld"> <a href="#method-i-ld" title="Link to this method"> <span class="method-callseq"> ld → integer </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="ld-source"> <pre class="c" data-language="c">static VALUE
d_lite_ld(VALUE self)
{
    get_d1(self);
    return f_sub(m_real_local_jd(dat), INT2FIX(2299160));
}</pre> </div>  <p>Returns the <a href="https://en.wikipedia.org/wiki/Lilian_date">Lilian day number</a>, which is the number of days since the beginning of the Gregorian calendar, October 15, 1582.</p> <pre class="ruby" data-language="ruby">Date.new(2001, 2, 3).ld # =&gt; 152784
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-leap-3F"> <a href="#method-i-leap-3F" title="Link to this method"> <span class="method-callseq"> leap? → true or false </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="leap-3F-source"> <pre class="c" data-language="c">static VALUE
d_lite_leap_p(VALUE self)
{
    int rjd, ns, ry, rm, rd;

    get_d1(self);
    if (m_gregorian_p(dat))
        return f_boolcast(c_gregorian_leap_p(m_year(dat)));

    c_civil_to_jd(m_year(dat), 3, 1, m_virtual_sg(dat),
                  &amp;rjd, &amp;ns);
    c_jd_to_civil(rjd - 1, m_virtual_sg(dat), &amp;ry, &amp;rm, &amp;rd);
    return f_boolcast(rd == 29);
}</pre> </div>  <p>Returns <code>true</code> if the year is a leap year, <code>false</code> otherwise:</p> <pre class="ruby" data-language="ruby">Date.new(2000).leap? # =&gt; true
Date.new(2001).leap? # =&gt; false
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-mday"> <a href="#method-i-mday" title="Link to this method"> <span class="method-name">mday</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="aliases"> Also aliased as: <a href="date.html#method-i-day">day</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-mjd"> <a href="#method-i-mjd" title="Link to this method"> <span class="method-callseq"> mjd → integer </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="mjd-source"> <pre class="c" data-language="c">static VALUE
d_lite_mjd(VALUE self)
{
    get_d1(self);
    return f_sub(m_real_local_jd(dat), INT2FIX(2400001));
}</pre> </div>  <p>Returns the modified Julian day number. This is a whole number, which is adjusted by the offset as the local time.</p> <pre class="ruby" data-language="ruby">DateTime.new(2001,2,3,4,5,6,'+7').mjd     #=&gt; 51943
DateTime.new(2001,2,3,4,5,6,'-7').mjd     #=&gt; 51943
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-mon"> <a href="#method-i-mon" title="Link to this method"> <span class="method-callseq"> mon → integer </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="mon-source"> <pre class="c" data-language="c">static VALUE
d_lite_mon(VALUE self)
{
    get_d1(self);
    return INT2FIX(m_mon(dat));
}</pre> </div>  <p>Returns the month in range (1..12):</p> <pre class="ruby" data-language="ruby">Date.new(2001, 2, 3).mon # =&gt; 2
</pre> </div> <div class="aliases"> Also aliased as: <a href="date.html#method-i-month">month</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-monday-3F"> <a href="#method-i-monday-3F" title="Link to this method"> <span class="method-callseq"> monday? → true or false </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="monday-3F-source"> <pre class="c" data-language="c">static VALUE
d_lite_monday_p(VALUE self)
{
    get_d1(self);
    return f_boolcast(m_wday(dat) == 1);
}</pre> </div>  <p>Returns <code>true</code> if <code>self</code> is a Monday, <code>false</code> otherwise.</p> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-month"> <a href="#method-i-month" title="Link to this method"> <span class="method-name">month</span> </a> </div> </div> <div class="aliases"> Alias for: <a href="date.html#method-i-mon">mon</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-new_start"> <a href="#method-i-new_start" title="Link to this method"> <span class="method-callseq"> new_start(start = Date::ITALY]) → new_date </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="new_start-source"> <pre class="c" data-language="c">static VALUE
d_lite_new_start(int argc, VALUE *argv, VALUE self)
{
    VALUE vsg;
    double sg;

    rb_scan_args(argc, argv, "01", &amp;vsg);

    sg = DEFAULT_SG;
    if (argc &gt;= 1)
        val2sg(vsg, sg);

    return dup_obj_with_new_start(self, sg);
}</pre> </div>  <p>Returns a copy of <code>self</code> with the given <code>start</code> value:</p> <pre class="ruby" data-language="ruby">d0 = Date.new(2000, 2, 3)
d0.julian? # =&gt; false
d1 = d0.new_start(Date::JULIAN)
d1.julian? # =&gt; true
</pre> <p>See argument <a href="date/calendars_rdoc.html#label-Argument+start">start</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-next"> <a href="#method-i-next" title="Link to this method"> <span class="method-callseq"> next → new_date </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="next-source"> <pre class="c" data-language="c">static VALUE
d_lite_next(VALUE self)
{
    return d_lite_next_day(0, (VALUE *)NULL, self);
}</pre> </div>  <p>Returns a new Date object representing the following day:</p> <pre class="ruby" data-language="ruby">d = Date.new(2001, 2, 3)
d.to_s      # =&gt; "2001-02-03"
d.next.to_s # =&gt; "2001-02-04"
</pre> </div> <div class="aliases"> Also aliased as: <a href="date.html#method-i-succ">succ</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-next_day"> <a href="#method-i-next_day" title="Link to this method"> <span class="method-callseq"> next_day(n = 1) → new_date </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="next_day-source"> <pre class="c" data-language="c">static VALUE
d_lite_next_day(int argc, VALUE *argv, VALUE self)
{
    VALUE n;

    rb_scan_args(argc, argv, "01", &amp;n);
    if (argc &lt; 1)
        n = INT2FIX(1);
    return d_lite_plus(self, n);
}</pre> </div>  <p>Equivalent to <a href="date.html#method-i-2B"><code>Date#+</code></a> with argument <code>n</code>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-next_month"> <a href="#method-i-next_month" title="Link to this method"> <span class="method-callseq"> next_month(n = 1) → new_date </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="next_month-source"> <pre class="c" data-language="c">static VALUE
d_lite_next_month(int argc, VALUE *argv, VALUE self)
{
    VALUE n;

    rb_scan_args(argc, argv, "01", &amp;n);
    if (argc &lt; 1)
        n = INT2FIX(1);
    return d_lite_rshift(self, n);
}</pre> </div>  <p>Equivalent to <a href="date.html#method-i-3E-3E"><code>&gt;&gt;</code></a> with argument <code>n</code>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-next_year"> <a href="#method-i-next_year" title="Link to this method"> <span class="method-callseq"> next_year(n = 1) → new_date </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="next_year-source"> <pre class="c" data-language="c">static VALUE
d_lite_next_year(int argc, VALUE *argv, VALUE self)
{
    VALUE n;

    rb_scan_args(argc, argv, "01", &amp;n);
    if (argc &lt; 1)
        n = INT2FIX(1);
    return d_lite_rshift(self, f_mul(n, INT2FIX(12)));
}</pre> </div>  <p>Equivalent to <a href="date.html#method-i-3E-3E"><code>&gt;&gt;</code></a> with argument <code>n * 12</code>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-prev_day"> <a href="#method-i-prev_day" title="Link to this method"> <span class="method-callseq"> prev_day(n = 1) → new_date </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="prev_day-source"> <pre class="c" data-language="c">static VALUE
d_lite_prev_day(int argc, VALUE *argv, VALUE self)
{
    VALUE n;

    rb_scan_args(argc, argv, "01", &amp;n);
    if (argc &lt; 1)
        n = INT2FIX(1);
    return d_lite_minus(self, n);
}</pre> </div>  <p>Equivalent to <a href="date.html#method-i-2D"><code>Date#-</code></a> with argument <code>n</code>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-prev_month"> <a href="#method-i-prev_month" title="Link to this method"> <span class="method-callseq"> prev_month(n = 1) → new_date </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="prev_month-source"> <pre class="c" data-language="c">static VALUE
d_lite_prev_month(int argc, VALUE *argv, VALUE self)
{
    VALUE n;

    rb_scan_args(argc, argv, "01", &amp;n);
    if (argc &lt; 1)
        n = INT2FIX(1);
    return d_lite_lshift(self, n);
}</pre> </div>  <p>Equivalent to <a href="date.html#method-i-3C-3C"><code>&lt;&lt;</code></a> with argument <code>n</code>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-prev_year"> <a href="#method-i-prev_year" title="Link to this method"> <span class="method-callseq"> prev_year(n = 1) → new_date </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="prev_year-source"> <pre class="c" data-language="c">static VALUE
d_lite_prev_year(int argc, VALUE *argv, VALUE self)
{
    VALUE n;

    rb_scan_args(argc, argv, "01", &amp;n);
    if (argc &lt; 1)
        n = INT2FIX(1);
    return d_lite_lshift(self, f_mul(n, INT2FIX(12)));
}</pre> </div>  <p>Equivalent to <a href="date.html#method-i-3C-3C"><code>&lt;&lt;</code></a> with argument <code>n * 12</code>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-rfc2822"> <a href="#method-i-rfc2822" title="Link to this method"> <span class="method-callseq"> rfc2822 → string </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="rfc2822-source"> <pre class="c" data-language="c">static VALUE
d_lite_rfc2822(VALUE self)
{
    return strftimev("%a, %-d %b %Y %T %z", self, set_tmx);
}</pre> </div>  <p>Equivalent to <a href="date.html#method-i-strftime"><code>strftime</code></a> with argument <code>'%a, %-d %b %Y %T %z'</code>; see <a href="strftime_formatting_rdoc.html">Formats for Dates and Times</a>:</p> <pre class="ruby" data-language="ruby">Date.new(2001, 2, 3).rfc2822 # =&gt; "Sat, 3 Feb 2001 00:00:00 +0000"
</pre> </div> <div class="aliases"> Also aliased as: <a href="date.html#method-i-rfc822">rfc822</a>, rfc822 </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-rfc3339"> <a href="#method-i-rfc3339" title="Link to this method"> <span class="method-callseq"> rfc3339 → string </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="rfc3339-source"> <pre class="c" data-language="c">static VALUE
d_lite_rfc3339(VALUE self)
{
    return strftimev("%Y-%m-%dT%H:%M:%S%:z", self, set_tmx);
}</pre> </div>  <p>Equivalent to <a href="date.html#method-i-strftime"><code>strftime</code></a> with argument <code>'%FT%T%:z'</code>; see <a href="strftime_formatting_rdoc.html">Formats for Dates and Times</a>:</p> <pre class="ruby" data-language="ruby">Date.new(2001, 2, 3).rfc3339 # =&gt; "2001-02-03T00:00:00+00:00"
</pre> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-rfc822"> <a href="#method-i-rfc822" title="Link to this method"> <span class="method-name">rfc822</span> </a> </div> </div> <div class="aliases"> Alias for: <a href="date.html#method-i-rfc2822">rfc2822</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-saturday-3F"> <a href="#method-i-saturday-3F" title="Link to this method"> <span class="method-callseq"> saturday? → true or false </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="saturday-3F-source"> <pre class="c" data-language="c">static VALUE
d_lite_saturday_p(VALUE self)
{
    get_d1(self);
    return f_boolcast(m_wday(dat) == 6);
}</pre> </div>  <p>Returns <code>true</code> if <code>self</code> is a Saturday, <code>false</code> otherwise.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-start"> <a href="#method-i-start" title="Link to this method"> <span class="method-callseq"> start → float </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="start-source"> <pre class="c" data-language="c">static VALUE
d_lite_start(VALUE self)
{
    get_d1(self);
    return DBL2NUM(m_sg(dat));
}</pre> </div>  <p>Returns the Julian start date for calendar reform; if not an infinity, the returned value is suitable for passing to <a href="date.html#method-i-jd"><code>Date#jd</code></a>:</p> <pre class="ruby" data-language="ruby">d = Date.new(2001, 2, 3, Date::ITALY)
s = d.start     # =&gt; 2299161.0
Date.jd(s).to_s # =&gt; "1582-10-15"

d = Date.new(2001, 2, 3, Date::ENGLAND)
s = d.start     # =&gt; 2361222.0
Date.jd(s).to_s # =&gt; "1752-09-14"

Date.new(2001, 2, 3, Date::GREGORIAN).start # =&gt; -Infinity
Date.new(2001, 2, 3, Date::JULIAN).start    # =&gt; Infinity
</pre> <p>See argument <a href="date/calendars_rdoc.html#label-Argument+start">start</a>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-step"> <a href="#method-i-step" title="Link to this method"> <span class="method-callseq"> step(limit, step = 1){|date| ... } → self </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="step-source"> <pre class="c" data-language="c">static VALUE
d_lite_step(int argc, VALUE *argv, VALUE self)
{
    VALUE limit, step, date;
    int c;

    rb_scan_args(argc, argv, "11", &amp;limit, &amp;step);

    if (argc &lt; 2)
        step = INT2FIX(1);

#if 0
    if (f_zero_p(step))
        rb_raise(rb_eArgError, "step can't be 0");
#endif

    RETURN_ENUMERATOR(self, argc, argv);

    date = self;
    c = f_cmp(step, INT2FIX(0));
    if (c &lt; 0) {
        while (FIX2INT(d_lite_cmp(date, limit)) &gt;= 0) {
            rb_yield(date);
            date = d_lite_plus(date, step);
        }
    }
    else if (c == 0) {
        while (1)
            rb_yield(date);
    }
    else /* if (c &gt; 0) */ {
        while (FIX2INT(d_lite_cmp(date, limit)) &lt;= 0) {
            rb_yield(date);
            date = d_lite_plus(date, step);
        }
    }
    return self;
}</pre> </div>  <p>Calls the block with specified dates; returns <code>self</code>.</p> <ul>
<li> <p>The first <code>date</code> is <code>self</code>.</p> </li>
<li> <p>Each successive <code>date</code> is <code>date + step</code>, where <code>step</code> is the numeric step size in days.</p> </li>
<li> <p>The last date is the last one that is before or equal to <code>limit</code>, which should be a Date object.</p> </li>
</ul> <p>Example:</p> <pre class="ruby" data-language="ruby">limit = Date.new(2001, 12, 31)
Date.new(2001).step(limit){|date| p date.to_s if date.mday == 31 }
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">"2001-01-31"
"2001-03-31"
"2001-05-31"
"2001-07-31"
"2001-08-31"
"2001-10-31"
"2001-12-31"
</pre> <p>Returns an <a href="enumerator.html"><code>Enumerator</code></a> if no block is given.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-strftime"> <a href="#method-i-strftime" title="Link to this method"> <span class="method-callseq"> strftime(format = '%F') → string </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="strftime-source"> <pre class="c" data-language="c">static VALUE
d_lite_strftime(int argc, VALUE *argv, VALUE self)
{
    return date_strftime_internal(argc, argv, self,
                                  "%Y-%m-%d", set_tmx);
}</pre> </div>  <p>Returns a string representation of the date in <code>self</code>, formatted according the given <code>format</code>:</p> <pre class="ruby" data-language="ruby">Date.new(2001, 2, 3).strftime # =&gt; "2001-02-03"
</pre> <p>For other formats, see <a href="strftime_formatting_rdoc.html">Formats for Dates and Times</a>.</p> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-succ"> <a href="#method-i-succ" title="Link to this method"> <span class="method-name">succ</span> </a> </div> </div> <div class="aliases"> Alias for: <a href="date.html#method-i-next">next</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-sunday-3F"> <a href="#method-i-sunday-3F" title="Link to this method"> <span class="method-callseq"> sunday? → true or false </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="sunday-3F-source"> <pre class="c" data-language="c">static VALUE
d_lite_sunday_p(VALUE self)
{
    get_d1(self);
    return f_boolcast(m_wday(dat) == 0);
}</pre> </div>  <p>Returns <code>true</code> if <code>self</code> is a Sunday, <code>false</code> otherwise.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-thursday-3F"> <a href="#method-i-thursday-3F" title="Link to this method"> <span class="method-callseq"> thursday? → true or false </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="thursday-3F-source"> <pre class="c" data-language="c">static VALUE
d_lite_thursday_p(VALUE self)
{
    get_d1(self);
    return f_boolcast(m_wday(dat) == 4);
}</pre> </div>  <p>Returns <code>true</code> if <code>self</code> is a Thursday, <code>false</code> otherwise.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-to_date"> <a href="#method-i-to_date" title="Link to this method"> <span class="method-callseq"> to_date → self </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="to_date-source"> <pre class="c" data-language="c">static VALUE
date_to_date(VALUE self)
{
    return self;
}</pre> </div>  <p>Returns <code>self</code>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-to_datetime"> <a href="#method-i-to_datetime" title="Link to this method"> <span class="method-callseq"> to_datetime → datetime </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="to_datetime-source"> <pre class="c" data-language="c">static VALUE
date_to_datetime(VALUE self)
{
    get_d1a(self);

    if (simple_dat_p(adat)) {
        VALUE new = d_lite_s_alloc_simple(cDateTime);
        {
            get_d1b(new);
            bdat-&gt;s = adat-&gt;s;
            return new;
        }
    }
    else {
        VALUE new = d_lite_s_alloc_complex(cDateTime);
        {
            get_d1b(new);
            bdat-&gt;c = adat-&gt;c;
            bdat-&gt;c.df = 0;
            RB_OBJ_WRITE(new, &amp;bdat-&gt;c.sf, INT2FIX(0));
#ifndef USE_PACK
            bdat-&gt;c.hour = 0;
            bdat-&gt;c.min = 0;
            bdat-&gt;c.sec = 0;
#else
            bdat-&gt;c.pc = PACK5(EX_MON(adat-&gt;c.pc), EX_MDAY(adat-&gt;c.pc),
                               0, 0, 0);
            bdat-&gt;c.flags |= HAVE_DF | HAVE_TIME;
#endif
            return new;
        }
    }
}</pre> </div>  <p>Returns a <a href="datetime.html"><code>DateTime</code></a> whose value is the same as <code>self</code>:</p> <pre class="ruby" data-language="ruby">Date.new(2001, 2, 3).to_datetime # =&gt; #&lt;DateTime: 2001-02-03T00:00:00+00:00&gt;
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-to_json"> <a href="#method-i-to_json" title="Link to this method"> <span class="method-name">to_json</span> <span class="method-args">(*args)</span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="to_json-source"> <pre class="ruby" data-language="ruby"># File ext/json/lib/json/add/date.rb, line 51
def to_json(*args)
  as_json.to_json(*args)
end</pre> </div>  <p>Returns a <a href="json.html"><code>JSON</code></a> string representing <code>self</code>:</p> <pre class="ruby" data-language="ruby">require 'json/add/date'
puts Date.today.to_json
</pre> <p>Output:</p> <pre class="ruby" data-language="ruby">{"json_class":"Date","y":2023,"m":11,"d":21,"sg":2299161.0}
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-to_s"> <a href="#method-i-to_s" title="Link to this method"> <span class="method-callseq"> to_s → string </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="to_s-source"> <pre class="c" data-language="c">static VALUE
d_lite_to_s(VALUE self)
{
    return strftimev("%Y-%m-%d", self, set_tmx);
}</pre> </div>  <p>Returns a string representation of the date in <code>self</code> in <a href="strftime_formatting_rdoc.html#label-ISO+8601+Format+Specifications">ISO 8601 extended date format</a> (<code>'%Y-%m-%d'</code>):</p> <pre class="ruby" data-language="ruby">Date.new(2001, 2, 3).to_s # =&gt; "2001-02-03"
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-to_time"> <a href="#method-i-to_time" title="Link to this method"> <span class="method-callseq"> to_time → time </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="to_time-source"> <pre class="c" data-language="c">static VALUE
date_to_time(VALUE self)
{
    VALUE t;

    get_d1a(self);

    if (m_julian_p(adat)) {
        VALUE g = d_lite_gregorian(self);
        get_d1b(g);
        adat = bdat;
        self = g;
    }

    t = f_local3(rb_cTime,
        m_real_year(adat),
        INT2FIX(m_mon(adat)),
        INT2FIX(m_mday(adat)));
    RB_GC_GUARD(self); /* may be the converted gregorian */
    return t;
}</pre> </div>  <p>Returns a new <a href="time.html"><code>Time</code></a> object with the same value as <code>self</code>; if <code>self</code> is a Julian date, derives its Gregorian date for conversion to the Time object:</p> <pre class="ruby" data-language="ruby">Date.new(2001, 2, 3).to_time               # =&gt; 2001-02-03 00:00:00 -0600
Date.new(2001, 2, 3, Date::JULIAN).to_time # =&gt; 2001-02-16 00:00:00 -0600
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-tuesday-3F"> <a href="#method-i-tuesday-3F" title="Link to this method"> <span class="method-callseq"> tuesday? → true or false </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="tuesday-3F-source"> <pre class="c" data-language="c">static VALUE
d_lite_tuesday_p(VALUE self)
{
    get_d1(self);
    return f_boolcast(m_wday(dat) == 2);
}</pre> </div>  <p>Returns <code>true</code> if <code>self</code> is a Tuesday, <code>false</code> otherwise.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-upto"> <a href="#method-i-upto" title="Link to this method"> <span class="method-callseq"> upto(max){|date| ... } → self </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="upto-source"> <pre class="c" data-language="c">static VALUE
d_lite_upto(VALUE self, VALUE max)
{
    VALUE date;

    RETURN_ENUMERATOR(self, 1, &amp;max);

    date = self;
    while (FIX2INT(d_lite_cmp(date, max)) &lt;= 0) {
        rb_yield(date);
        date = d_lite_plus(date, INT2FIX(1));
    }
    return self;
}</pre> </div>  <p>Equivalent to <a href="date.html#method-i-step"><code>step</code></a> with arguments <code>max</code> and <code>1</code>.</p> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-wday"> <a href="#method-i-wday" title="Link to this method"> <span class="method-callseq"> wday → integer </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="wday-source"> <pre class="c" data-language="c">static VALUE
d_lite_wday(VALUE self)
{
    get_d1(self);
    return INT2FIX(m_wday(dat));
}</pre> </div>  <p>Returns the day of week in range (0..6); Sunday is 0:</p> <pre class="ruby" data-language="ruby">Date.new(2001, 2, 3).wday # =&gt; 6
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-wednesday-3F"> <a href="#method-i-wednesday-3F" title="Link to this method"> <span class="method-callseq"> wednesday? → true or false </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="wednesday-3F-source"> <pre class="c" data-language="c">static VALUE
d_lite_wednesday_p(VALUE self)
{
    get_d1(self);
    return f_boolcast(m_wday(dat) == 3);
}</pre> </div>  <p>Returns <code>true</code> if <code>self</code> is a Wednesday, <code>false</code> otherwise.</p> </div> </div> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-xmlschema"> <a href="#method-i-xmlschema" title="Link to this method"> <span class="method-name">xmlschema</span> </a> </div> </div> <div class="aliases"> Alias for: <a href="date.html#method-i-iso8601">iso8601</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-yday"> <a href="#method-i-yday" title="Link to this method"> <span class="method-callseq"> yday → integer </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="yday-source"> <pre class="c" data-language="c">static VALUE
d_lite_yday(VALUE self)
{
    get_d1(self);
    return INT2FIX(m_yday(dat));
}</pre> </div>  <p>Returns the day of the year, in range (1..366):</p> <pre class="ruby" data-language="ruby">Date.new(2001, 2, 3).yday # =&gt; 34
</pre> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-year"> <a href="#method-i-year" title="Link to this method"> <span class="method-callseq"> year → integer </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="year-source"> <pre class="c" data-language="c">static VALUE
d_lite_year(VALUE self)
{
    get_d1(self);
    return m_real_year(dat);
}</pre> </div>  <p>Returns the year:</p> <pre class="ruby" data-language="ruby">Date.new(2001, 2, 3).year    # =&gt; 2001
(Date.new(1, 1, 1) - 1).year # =&gt; 0
</pre> </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core &copy; 1993&ndash;2024 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library &copy; contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>
