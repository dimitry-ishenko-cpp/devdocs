<h1 id="class-Continuation" class="anchor-link class"> class Continuation </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent"><a href="object.html">Object</a></dd>
</dl> <section class="description"> <p><a href="continuation.html"><code>Continuation</code></a> objects are generated by <a href="kernel.html#method-i-callcc"><code>Kernel#callcc</code></a>, after having +require+d <em>continuation</em>. They hold a return address and execution context, allowing a nonlocal return to the end of the <a href="kernel.html#method-i-callcc"><code>callcc</code></a> block from anywhere within a program. Continuations are somewhat analogous to a structured version of Câ€™s <code>setjmp/longjmp</code> (although they contain more state, so you might consider them closer to threads).</p> <p>For instance:</p> <pre class="ruby" data-language="ruby">require "continuation"
arr = [ "Freddie", "Herbie", "Ron", "Max", "Ringo" ]
callcc{|cc| $cc = cc}
puts(message = arr.shift)
$cc.call unless message =~ /Max/
</pre> <p><em>produces:</em></p> <pre class="ruby" data-language="ruby">Freddie
Herbie
Ron
Max
</pre> <p>Also you can call callcc in other methods:</p> <pre class="ruby" data-language="ruby">require "continuation"

def g
  arr = [ "Freddie", "Herbie", "Ron", "Max", "Ringo" ]
  cc = callcc { |cc| cc }
  puts arr.shift
  return cc, arr.size
end

def f
  c, size = g
  c.call(c) if size &gt; 1
end

f
</pre> <p>This (somewhat contrived) example allows the inner loop to abandon processing early:</p> <pre class="ruby" data-language="ruby">require "continuation"
callcc {|cont|
  for i in 0..4
    print "#{i}: "
    for j in i*5...(i+1)*5
      cont.call() if j == 17
      printf "%3d", j
    end
  end
}
puts
</pre> <p><em>produces:</em></p> <pre>0:   0  1  2  3  4
1:   5  6  7  8  9
2:  10 11 12 13 14
3:  15 16</pre> </section> <section id="5Buntitled-5D" class="documentation-section anchor-link"> <section id="public-instance-5Buntitled-5D-method-details" class="method-section anchor-link"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail anchor-link method-alias"> <div class="method-header"> <div class="method-heading" id="method-i-5B-5D"> <a href="#method-i-5B-5D" title="Link to this method"> <span class="method-callseq"> cont[args, ...] </span> </a> </div> </div> <div class="method-description"> <p>Invokes the continuation. The program continues from the end of the <a href="kernel.html#method-i-callcc"><code>callcc</code></a> block. If no arguments are given, the original <a href="kernel.html#method-i-callcc"><code>callcc</code></a> returns <code>nil</code>. If one argument is given, <a href="kernel.html#method-i-callcc"><code>callcc</code></a> returns it. Otherwise, an array containing <em>args</em> is returned.</p> <pre class="ruby" data-language="ruby">callcc {|cont|  cont.call }           #=&gt; nil
callcc {|cont|  cont.call 1 }         #=&gt; 1
callcc {|cont|  cont.call 1, 2, 3 }   #=&gt; [1, 2, 3]
</pre> </div> <div class="aliases"> Alias for: <a href="continuation.html#method-i-call">call</a> </div> </div> <div class="method-detail anchor-link "> <div class="method-header"> <div class="method-heading" id="method-i-call"> <a href="#method-i-call" title="Link to this method"> <span class="method-callseq"> call(args, ...) </span> </a> </div> <div class="method-heading"> <a href="#method-i-call" title="Link to this method"> <span class="method-callseq"> cont[args, ...] </span> </a> </div> </div> <div class="method-controls"> <details class="method-source-toggle"> <summary>Source</summary> </details> </div> <div class="method-description">
<div class="method-source-code" id="call-source"> <pre class="c" data-language="c">static VALUE
rb_cont_call(int argc, VALUE *argv, VALUE contval)
{
    rb_context_t *cont = cont_ptr(contval);
    rb_thread_t *th = GET_THREAD();

    if (cont_thread_value(cont) != th-&gt;self) {
        rb_raise(rb_eRuntimeError, "continuation called across threads");
    }
    if (cont-&gt;saved_ec.fiber_ptr) {
        if (th-&gt;ec-&gt;fiber_ptr != cont-&gt;saved_ec.fiber_ptr) {
            rb_raise(rb_eRuntimeError, "continuation called across fiber");
        }
    }

    cont-&gt;argc = argc;
    cont-&gt;value = make_passing_arg(argc, argv);

    cont_restore_0(cont, &amp;contval);
    UNREACHABLE_RETURN(Qnil);
}</pre> </div>  <p>Invokes the continuation. The program continues from the end of the <a href="kernel.html#method-i-callcc"><code>callcc</code></a> block. If no arguments are given, the original <a href="kernel.html#method-i-callcc"><code>callcc</code></a> returns <code>nil</code>. If one argument is given, <a href="kernel.html#method-i-callcc"><code>callcc</code></a> returns it. Otherwise, an array containing <em>args</em> is returned.</p> <pre class="ruby" data-language="ruby">callcc {|cont|  cont.call }           #=&gt; nil
callcc {|cont|  cont.call 1 }         #=&gt; 1
callcc {|cont|  cont.call 1, 2, 3 }   #=&gt; [1, 2, 3]
</pre> </div> <div class="aliases"> Also aliased as: <a href="continuation.html#method-i-5B-5D">[]</a> </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Ruby Core &copy; 1993&ndash;2024 Yukihiro Matsumoto<br>Licensed under the Ruby License.<br>Ruby Standard Library &copy; contributors<br>Licensed under their own licenses.<br>
    
  </p>
</div>
