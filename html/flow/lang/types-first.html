<h1>Types-First</h1> <p>Flow checks codebases by processing each file separately in dependency order. After a file has been checked, a signature is extracted and stored in main memory, to be used for files that depend on it. Currently, the default mode (we’ll also refer to it as <em>classic</em> mode) builds these signatures by using the types inferred for the file’s exports. In the new <em>types-first</em> architecture, Flow relies on annotations available at the boundaries of files to build these signatures.</p> <p>The benefit of this new architecture is dual:</p> <ol> <li> <p>It dramatically improves <em>performance</em>, in particular when it comes to rechecks. Suppose we want Flow to check a file <code>foo.js</code>, for which it hasn’t checked its dependencies yet. Classic mode would need to check all dependencies and generate signatures from them first, before it could check <code>foo.js</code>. In types-first, Flow extracts the dependency signatures just by looking at the annotations around the exports. This process is mostly syntactic, and therefore much faster than full type inference.</p> </li> <li> <p>It improves error <em>reliability</em>. Inferred types often become complicated, and may lead to errors being reported in downstream files, far away from their actual source. Type annotations at file boundaries of files can help localize such errors, and address them in the file that introduced them.</p> </li> </ol> <p>The caveat of this new version is that it requires exported parts of the code to be annotated with types, or to be expressions whose type can be trivially inferred (for example numbers and strings).</p> <h2 id="toc-how-to-upgrade-your-codebase-to-types-first">How to upgrade your codebase to Types-First </h2> <h3 id="toc-upgrade-flow-version">Upgrade Flow version </h3> <p>Types-first mode is officially released with version 0.125, but has been available in <em>experimental</em> status as of version 0.102. If you are currently on an older Flow version, you’d have to first upgrade Flow. Using the latest Flow version is the best way to benefit from the performance benefits outlined above.</p> <h3 id="toc-prepare-your-codebase-for-types-first">Prepare your codebase for Types-First </h3> <p>Types-first requires annotations at module boundaries in order to build type signature for files. If these annotations are missing, then a <code>signature-verification-failure</code> is raised, and the exported type for the respective part of the code will be <code>any</code>.</p> <p>To see what types are missing to make your codebase types-first ready, add the following line to the <code>[options]</code> section of the <code>.flowconfig</code> file:</p> <pre data-language="plaintext">well_formed_exports=true</pre> <p>Consider for example a file <code>foo.js</code> that exports a function call to <code>foo</code></p> <pre data-language="javascript">declare function foo&lt;T&gt;(x: T): T;
module.exports = foo(1);
</pre> <p>The return type of function calls is currently not trivially inferable (due to features like polymorphism, overloading etc.). Their result needs to be annotated and so you’d see the following error:</p> <pre data-language="plaintext">Cannot build a typed interface for this module. You should annotate the exports
of this module with types. Cannot determine the type of this call expression. Please
provide an annotation, e.g., by adding a type cast around this expression.
(`signature-verification-failure`)

   4│ module.exports = foo(1);
                       ^^^^^^</pre> <p>To resolve this, you can add an annotation like the following:</p> <pre data-language="javascript">declare function foo&lt;T&gt;(x: T): T;
module.exports = (foo(1): number);
</pre> <blockquote> <p>Note: As of version 0.134, types-first is the default mode. This mode automatically enables <code>well_formed_exports</code>, so you would see these errors without explicitly setting this flag. It is advisable to set <code>types_first=false</code> during this part of the upgrade.</p> </blockquote> <h4 id="toc-seal-your-intermediate-results">Seal your intermediate results </h4> <p>As you make progress adding types to your codebase, you can include directories so that they don’t regress as new code gets committed, and until the entire project has well-formed exports. You can do this by adding lines like the following to your .flowconfig:</p> <pre data-language="plaintext">well_formed_exports.includes=&lt;PROJECT_ROOT&gt;/path/to/directory</pre> <blockquote> <p>Warning: That this is a <em>substring</em> check, not a regular expression (for performance reasons).</p> </blockquote> <h4 id="toc-a-codemod-for-large-codebases">A codemod for large codebases </h4> <p>Adding the necessary annotations to large codebases can be quite tedious. To ease this burden, we are providing a codemod based on Flow’s inference, that can be used to annotate multiple files in bulk. See <a href="https://flow.org/en/cli/annotate-exports/">this tutorial</a> for more.</p> <h3 id="toc-enable-the-types-first-flag">Enable the types-first flag </h3> <p>Once you have eliminated signature verification errors, you can turn on the types-first mode, by adding the following line to the <code>[options]</code> section of the <code>.flowconfig</code> file:</p> <pre data-language="plaintext">types_first=true</pre> <p>You can also pass <code>--types-first</code> to the <code>flow check</code> or <code>flow start</code> commands.</p> <p>The <code>well_formed_exports</code> flag from before is implied by <code>types_first</code>. Once this process is completed and types-first has been enabled, you can remove <code>well_formed_exports</code>.</p> <p>Unfortunately, it is not possible to enable types-first mode for part of your repo; this switch affects all files managed by the current <code>.flowconfig</code>.</p> <blockquote> <p>Note: The above flags are available in versions of Flow <code>&gt;=0.102</code> with the <code>experimental.</code> prefix (and prior to v0.128, it used <code>whitelist</code> in place of <code>includes</code>):</p> <pre data-language="plaintext">experimental.well_formed_exports=true
experimental.well_formed_exports.whitelist=&lt;PROJECT_ROOT&gt;/path/to/directory
experimental.types_first=true</pre> </blockquote> <blockquote> <p>Note: If you are using a version where types-first is enabled by default (ie. <code>&gt;=0.134</code>), make sure you set <code>types_first=false</code> in your .flowconfig while running the codemods.</p> </blockquote> <h3 id="toc-deal-with-newly-introduced-errors">Deal with newly introduced errors </h3> <p>Switching between classic and types-first mode may cause some new Flow errors, besides signature-verification failures that we mentioned earlier. These errors are due differences in the way types based on annotations are interpreted, compared to their respective inferred types.</p> <p>Below are some common error patterns and how to overcome them.</p> <h4 id="toc-array-tuples-treated-as-regular-arrays-in-exports">Array tuples treated as regular arrays in exports </h4> <p>In types-first, an array literal in an <em>export position</em></p> <pre data-language="javascript">module.exports = [e1, e2];
</pre> <p>is treated as having type <code>Array&lt;t1 | t2&gt;</code>, where <code>e1</code> and <code>e2</code> have types <code>t1</code> and <code>t2</code>, instead of the tuple type <code>[t1, t2]</code>.</p> <p>In classic mode, the inferred type encompassed both types at the same time. This might cause errors in importing files that expect for example to find type <code>t1</code> in the first position of the import.</p> <p><strong>Fix:</strong> If a tuple type is expected, then the annotation <code>[t1, t2]</code> needs to be explicitly added on the export side.</p> <h4 id="toc-indirect-object-assignments-in-exports">Indirect object assignments in exports </h4> <p>Flow allows the code</p> <pre data-language="javascript">function foo(): void {}
foo.x = () =&gt; {};
foo.x.y = 2;
module.exports = foo;
</pre> <p>but in types-first the exported type will be</p> <pre data-language="plaintext">{
  (): void;
  x: () =&gt; void;
}</pre> <p>In other words it won’t take into account the update on <code>y</code>.</p> <p><strong>Fix:</strong> To include the update on <code>y</code> in the exported type, the export will need to be annotated with the type</p> <pre data-language="plaintext">{
  (): void;
  x: { (): void; y: number; };
};</pre> <p>The same holds for more complex assignment patterns like</p> <pre data-language="javascript">function foo(): void {}
Object.assign(foo, { x: 1});
module.exports = foo;
</pre> <p>where you’ll need to manually annotate the export with <code>{ (): void; x: number }</code>, or assignments preceding the function definition</p> <pre data-language="javascript">foo.x = 1;
function foo(): void {}
module.exports = foo;
</pre> <p>Note that in the last example, Flow types-first will pick up the static update if it was after the definition:</p> <pre data-language="javascript">function foo(): void {}
foo.x = 1;
module.exports = foo;
</pre> <h3 id="toc-exported-variables-with-updates">Exported variables with updates </h3> <p>The types-first signature extractor will not pick up subsequent update of an exported let-bound variables. Consider the example</p> <pre data-language="javascript">let foo: number | string = 1;
foo = "blah";
module.exports = foo;
</pre> <p>In classic mode the exported type would be <code>string</code>. In types-first it will be <code>number | string</code>, so if downstream typing depends on the more precise type, then you might get some errors.</p> <p><strong>Fix:</strong> Introduce a new variable on the update and export that one. For example</p> <pre data-language="javascript">const foo1: number | string = 1;
const foo2 = "blah";
module.exports = foo2;
</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2013&ndash;present Facebook Inc.<br>Licensed under the MIT License.<br>
    <a href="https://flow.org/en/docs/lang/types-first" class="_attribution-link">https://flow.org/en/docs/lang/types-first</a>
  </p>
</div>
