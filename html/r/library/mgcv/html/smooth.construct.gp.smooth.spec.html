<div class="container">
<main>  <h2>
<code>smooth.construct.gp.smooth.spec</code> Low rank Gaussian process smooths</h2> <h3>Description</h3> <p>Gaussian process/kriging models based on simple covariance functions can be written in a very similar form to thin plate and Duchon spline models (e.g. Handcock, Meier, Nychka, 1994), and low rank versions produced by the eigen approximation method of Wood (2003). Kammann and Wand (2003) suggest a particularly simple form of the Matern covariance function with only a single smoothing parameter to estimate, and this class implements this and other similar models. </p> <p>Usually invoked by an <code>s(...,bs="gp")</code> term in a <code>gam</code> formula. Argument <code>m</code> selects the covariance function, sets the range parameter and any power parameter. If <code>m</code> is not supplied then it defaults to <code>NA</code> and the covariance function suggested by Kammann and Wand (2003) along with their suggested range parameter is used. Otherwise <code>abs(m[1])</code> between 1 and 5 selects the correlation function from respectively, spherical, power exponential, and Matern with kappa = 1.5, 2.5 or 3.5. The sign of <code>m[1]</code> determines whether a linear trend in the covariates is added to the Guassian process (positive), or not (negative). The latter ensures stationarity. <code>m[2]</code>, if present, specifies the range parameter, with non-positive or absent indicating that the Kammann and Wand estimate should be used. <code>m[3]</code> can be used to specify the power for the power exponential which otherwise defaults to 1. </p> <h3>Usage</h3> <pre data-language="r"><code class="language-R">## S3 method for class 'gp.smooth.spec'
smooth.construct(object, data, knots)
## S3 method for class 'gp.smooth'
Predict.matrix(object, data)
</code></pre> <h3>Arguments</h3> <table> <tr>
<td><code id="object">object</code></td> <td> <p>a smooth specification object, usually generated by a term <code>s(...,bs="ms",...)</code>.</p> </td>
</tr> <tr>
<td><code id="data">data</code></td> <td> <p>a list containing just the data (including any <code>by</code> variable) required by this term, with names corresponding to <code>object$term</code> (and <code>object$by</code>). The <code>by</code> variable is the last element.</p> </td>
</tr> <tr>
<td><code id="knots">knots</code></td> <td> <p>a list containing any knots supplied for basis setup — in same order and with same names as <code>data</code>. Can be <code>NULL</code></p> </td>
</tr> </table> <h3>Details</h3> <p> Let <code class="reqn">\rho&gt;0</code> be the range parameter, <code class="reqn">0 &lt; \kappa\le 2 </code> and <code class="reqn">d</code> denote the distance between two points. Then the correlation functions indexed by <code>m[1]</code> are: </p> <ol> <li> <p><code class="reqn">1 - 1.5 d/\rho + 0.5 (d/\rho)^3</code> if <code class="reqn">d \le \rho</code> and 0 otherwise. </p> </li> <li> <p><code class="reqn">\exp(-(d/\rho)^\kappa)</code>. </p> </li> <li> <p><code class="reqn">\exp(-d/\rho)(1+d/\rho)</code>. </p> </li> <li> <p><code class="reqn">\exp(-d/\rho)(1+d/\rho + (d/\rho)^2/3)</code>. </p> </li> <li> <p><code class="reqn">\exp(-d/\rho)(1+d/\rho+2(d/\rho)^2/5 + (d/\rho)^3/15)</code>. </p> </li>
</ol> <p>See Fahrmeir et al. (2013) section 8.1.6, for example. Note that setting <code>r</code> to too small a value will lead to unpleasant results, as most points become all but independent (especially for the spherical model. Note: Wood 2017, Figure 5.20 right is based on a buggy implementation). </p> <p>The default basis dimension for this class is <code>k=M+k.def</code> where <code>M</code> is the null space dimension (dimension of unpenalized function space) and <code>k.def</code> is 10 for dimension 1, 30 for dimension 2 and 100 for higher dimensions. This is essentially arbitrary, and should be checked, but as with all penalized regression smoothers, results are statistically insensitive to the exact choise, provided it is not so small that it forces oversmoothing (the smoother's degrees of freedom are controlled primarily by its smoothing parameter). </p> <p>The constructor is not normally called directly, but is rather used internally by <code><a href="gam.html">gam</a></code>. To use for basis setup it is recommended to use <code><a href="smooth.construct.html">smooth.construct2</a></code>. </p> <p>For these classes the specification <code>object</code> will contain information on how to handle large datasets in their <code>xt</code> field. The default is to randomly subsample 2000 ‘knots’ from which to produce a reduced rank eigen approximation to the full basis, if the number of unique predictor variable combinations in excess of 2000. The default can be modified via the <code>xt</code> argument to <code><a href="s.html">s</a></code>. This is supplied as a list with elements <code>max.knots</code> and <code>seed</code> containing a number to use in place of 2000, and the random number seed to use (either can be missing). Note that the random sampling will not effect the state of R's RNG. </p> <p>For these bases <code>knots</code> has two uses. Firstly, as mentioned already, for large datasets the calculation of the <code>tp</code> basis can be time-consuming. The user can retain most of the advantages of the approach by supplying a reduced set of covariate values from which to obtain the basis - typically the number of covariate values used will be substantially smaller than the number of data, and substantially larger than the basis dimension, <code>k</code>. This approach is the one taken automatically if the number of unique covariate values (combinations) exceeds <code>max.knots</code>. The second possibility is to avoid the eigen-decomposition used to find the spline basis altogether and simply use the basis implied by the chosen knots: this will happen if the number of knots supplied matches the basis dimension, <code>k</code>. For a given basis dimension the second option is faster, but gives poorer results (and the user must be quite careful in choosing knot locations). </p> <h3>Value</h3> <p> An object of class <code>"gp.smooth"</code>. In addition to the usual elements of a smooth class documented under <code><a href="smooth.construct.html">smooth.construct</a></code>, this object will contain: </p> <table> <tr>
<td><code>shift</code></td> <td> <p>A record of the shift applied to each covariate in order to center it around zero and avoid any co-linearity problems that might otherwise occur in the penalty null space basis of the term. </p> </td>
</tr> <tr>
<td><code>Xu</code></td> <td> <p>A matrix of the unique covariate combinations for this smooth (the basis is constructed by first stripping out duplicate locations).</p> </td>
</tr> <tr>
<td><code>UZ</code></td> <td> <p>The matrix mapping the smoother parameters back to the parameters of a full GP smooth.</p> </td>
</tr> <tr>
<td><code>null.space.dimension</code></td> <td> <p>The dimension of the space of functions that have zero wiggliness according to the wiggliness penalty for this term.</p> </td>
</tr> <tr>
<td><code>gp.defn</code></td> <td> <p>the type, range parameter and power parameter defining the correlation function. </p> </td>
</tr> </table> <h3>Author(s)</h3> <p> Simon N. Wood <a href="mailto:simon.wood@r-project.org.html">simon.wood@r-project.org</a></p> <h3>References</h3> <p>Fahrmeir, L., T. Kneib, S. Lang and B. Marx (2013) Regression, Springer. </p> <p>Handcock, M. S., K. Meier and D. Nychka (1994) Journal of the American Statistical Association, 89: 401-403 </p> <p>Kammann, E. E. and M.P. Wand (2003) Geoadditive Models. Applied Statistics 52(1):1-18. </p> <p>Wood, S.N. (2003) Thin plate regression splines. J.R.Statist.Soc.B 65(1):95-114 </p> <p>Wood, S.N. (2017) Generalized Additive Models: an introduction with R (2nd ed). CRC/Taylor and Francis </p> <h3>See Also</h3> <p><code><a href="smooth.construct.tp.smooth.spec.html">tprs</a></code></p> <h3>Examples</h3> <pre data-language="r"><code class="language-R">require(mgcv)
eg &lt;- gamSim(2,n=200,scale=.05)
attach(eg)
op &lt;- par(mfrow=c(2,2),mar=c(4,4,1,1))
b0 &lt;- gam(y~s(x,z,k=50),data=data)  ## tps
b &lt;- gam(y~s(x,z,bs="gp",k=50),data=data)  ## Matern spline default range
b1 &lt;- gam(y~s(x,z,bs="gp",k=50,m=c(1,.5)),data=data)  ## spherical 

persp(truth$x,truth$z,truth$f,theta=30) ## truth
vis.gam(b0,theta=30)
vis.gam(b,theta=30)
vis.gam(b1,theta=30)

## compare non-stationary (b1) and stationary (b2)
b2 &lt;- gam(y~s(x,z,bs="gp",k=50,m=c(-1,.5)),data=data)  ## sph stationary 
vis.gam(b1,theta=30);vis.gam(b2,theta=30)
x &lt;- seq(-1,2,length=200); z &lt;- rep(.5,200)
pd &lt;- data.frame(x=x,z=z)
plot(x,predict(b1,pd),type="l");lines(x,predict(b2,pd),col=2)
abline(v=c(0,1))
plot(predict(b1),predict(b2))

detach(eg)

</code></pre> </main> </div><div class="_attribution">
  <p class="_attribution-p">
    Copyright (&copy;) 1999–2012 R Foundation for Statistical Computing.<br>Licensed under the <a href="https://www.gnu.org/copyleft/gpl.html">GNU General Public License</a>.<br>
    
  </p>
</div>
