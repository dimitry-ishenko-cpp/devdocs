<div class="container">
<main>  <h2>
<code>smooth.construct.sz.smooth.spec</code> Constrained factor smooth interactions in GAMs</h2> <h3>Description</h3> <p>Factor smooth interactions constructed to exclude main effects (and lower order factor smooth interactions). A smooth is constucted for each combination of the supplied factor levels. By appropriate application of sum to zero contrasts to equivalent smooth coefficients across factor levels, the required exclusion of lower order effects is achieved. </p> <p>See <a href="factor.smooth.html">factor.smooth</a> for alternative factor smooth interactions. </p> <h3>Usage</h3> <pre data-language="r"><code class="language-R">## S3 method for class 'sz.smooth.spec'
smooth.construct(object, data, knots)
## S3 method for class 'sz.interaction'
Predict.matrix(object, data)
</code></pre> <h3>Arguments</h3> <table> <tr>
<td><code id="object">object</code></td> <td> <p>For the <code>smooth.construct</code> method a smooth specification object, usually generated by a term <code>s(x,...,bs="sz",)</code>. For the <code>predict.Matrix</code> method an object of class <code>"sz.interaction"</code> produced by the <code>smooth.construct</code> method.</p> </td>
</tr> <tr>
<td><code id="data">data</code></td> <td> <p>a list containing just the data (including any <code>by</code> variable) required by this term, with names corresponding to <code>object$term</code>.</p> </td>
</tr> <tr>
<td><code id="knots">knots</code></td> <td> <p> a list containing any knots supplied for smooth basis setup.</p> </td>
</tr> </table> <h3>Details</h3> <p>This class produces a smooth for each combination of the levels of the supplied factor variables. <code>s(fac,x,bs="sz")</code> produces a smooth of <code>x</code> for each level of <code>fac</code>, for example. The smooths are constrained to represent deviations from the main effect smooth, so that models such as </p> <p style="text-align: center;"><code class="reqn">g(\mu_i) = f(x_i) + f_{k(i)}(x_i)</code> </p> <p>can be estimated in an identifiable manner, where <code class="reqn">k(i)</code> indicates the level of some factor that applies for the ith observation. Identifiability in this case is ensured by constraining the coefficients of the splines representing the <code class="reqn">f_{k}</code>. In particular if <code class="reqn">\beta_{ki}</code> is the ith coefficient of <code class="reqn">f_k</code> then the constraints are <code class="reqn">\sum_k \beta_{ki} = 0</code>. </p> <p>Such sum to zero constraints are implemented using sum to zero contrasts: identity matrices with an extra row of -1s appended. Consider the case of a single factor first. The model matrix corresponding to a smooth per factor level is the row tensor product (see <code><a href="tensor.prod.model.matrix.html">tensor.prod.model.matrix</a></code>) of the model matrix for the factor, and the model matrix for the smooth. The contrast matrix is then the Kronecker product of the sum to zero contrast for the factor, and an identity matrix of dimension determined by the number of coefficients of the smooth. </p> <p>If there are multiple factors then the overall model matrix is the row Kronecker product of all the factor model matrices and the smooth, while the contrast is the Kronecker product of all the sum-to-zero contrasts for the factors and a final identity matrix. Notice that this construction means that the main effects (and any interactions) of the factors are included in the factor level dependent smooths. In other words the individual smooths are not each centered. This means that adding main effects or interactions of the factors will lead to a rank deficient model. </p> <p>The terms can have a smoothing parameter per smooth, or a single smoothing parameter for all the smooths. The latter is specified by giving the smooth term an <code>id</code>. e.g. <code>s(fac,x,bs="sz",id=1)</code>. </p> <p>The basis for the smooths can be selected by supplying a list as the <code>xt</code> argument to <code><a href="s.html">s</a></code>, with a <code>bs</code> item. e.g. <code>s(fac,x,xt=list(bs="cr"))</code> selectes the <code>"cr"</code> basis. The default is <code>"tp"</code> </p> <p>The plot method for this class has two schemes. <code>scheme==0</code> is in colour, while <code>scheme==1</code> is black and white. Currently it only works for 1D smooths. </p> <h3>Value</h3> <p> An object of class <code>"sz.interaction"</code> or a matrix mapping the coefficients of the factor smooth interaction to the smooths themselves. </p> <h3>Author(s)</h3> <p> Simon N. Wood <a href="mailto:simon.wood@r-project.org.html">simon.wood@r-project.org</a> with input from Matteo Fasiolo.</p> <h3>See Also</h3> <p><code><a href="gam.models.html">gam.models</a></code>, <code><a href="gamm.html">gamm</a></code>, <a href="factor.smooth.html">factor.smooth</a></p> <h3>Examples</h3> <pre data-language="r"><code class="language-R">library(mgcv)
set.seed(0)
dat &lt;- gamSim(4)

b &lt;- gam(y ~ s(x2)+s(fac,x2,bs="sz")+s(x0),data=dat,method="REML")
plot(b,pages=1)
summary(b)

## Example involving 2 factors

f1 &lt;- function(x2) 2 * sin(pi * x2)
f2 &lt;- function(x2) exp(2 * x2) - 3.75887
f3 &lt;- function(x2) 0.2 * x2^11 * (10 * (1 - x2))^6 + 10 * (10 * x2)^3 * 
            (1 - x2)^10

n &lt;- 600
x &lt;- runif(n)
f1 &lt;- factor(sample(c("a","b","c"),n,replace=TRUE))
f2 &lt;- factor(sample(c("foo","bar"),n,replace=TRUE))

mu &lt;- f3(x)
for (i in 1:3) mu &lt;- mu + exp(2*(2-i)*x)*(f1==levels(f1)[i])
for (i in 1:2) mu &lt;- mu + 10*i*x*(1-x)*(f2==levels(f2)[i])
y &lt;- mu + rnorm(n)
dat &lt;- data.frame(y=y,x=x,f1=f1,f2=f2)
b &lt;- gam(y ~ s(x)+s(f1,x,bs="sz")+s(f2,x,bs="sz")+s(f1,f2,x,bs="sz",id=1),data=dat,method="REML")
plot(b,pages=1,scale=0)



</code></pre> </main> </div><div class="_attribution">
  <p class="_attribution-p">
    Copyright (&copy;) 1999â€“2012 R Foundation for Statistical Computing.<br>Licensed under the <a href="https://www.gnu.org/copyleft/gpl.html">GNU General Public License</a>.<br>
    
  </p>
</div>
