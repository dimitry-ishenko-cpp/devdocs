<div class="container">
<main>  <h2>
<code>c</code> Combine Values into a Vector or List</h2> <h3>Description</h3> <p>This is a generic function which combines its arguments. </p> <p>The default method combines its arguments to form a vector. All arguments are coerced to a common type which is the type of the returned value, and all attributes except names are removed. </p> <h3>Usage</h3> <pre data-language="r"><code class="language-R">## S3 Generic function
c(...)

## Default S3 method:
c(..., recursive = FALSE, use.names = TRUE)
</code></pre> <h3>Arguments</h3> <table> <tr>
<td><code id="...">...</code></td> <td> <p>objects to be concatenated. All <code><a href="null.html">NULL</a></code> entries are dropped before method dispatch unless at the very beginning of the argument list.</p> </td>
</tr> <tr>
<td><code id="recursive">recursive</code></td> <td> <p>logical. If <code>recursive = TRUE</code>, the function recursively descends through lists (and pairlists) combining all their elements into a vector.</p> </td>
</tr> <tr>
<td><code id="use.names">use.names</code></td> <td> <p>logical indicating if <code><a href="names.html">names</a></code> should be preserved.</p> </td>
</tr> </table> <h3>Details</h3> <p>The output type is determined from the highest type of the components in the hierarchy NULL &lt; raw &lt; logical &lt; integer &lt; double &lt; complex &lt; character &lt; list &lt; expression. Pairlists are treated as lists, whereas non-vector components (such as <code><a href="name.html">name</a></code>s / <code>symbol</code>s and <code><a href="call.html">call</a></code>s) are treated as one-element <code><a href="list.html">list</a></code>s which cannot be unlisted even if <code>recursive = TRUE</code>. </p> <p>If the output type is <code><a href="complex.html">complex</a></code>, logical, integer, and double <code>NA</code>s keep their imaginary parts zero when coerced, and hence will <em>not</em> become <code>NA_complex_</code> (with imaginary part <code>NA</code>). </p> <p>There is a <code><a href="factor.html">c.factor</a></code> method which combines factors into a factor. </p> <p><code>c</code> is sometimes used for its side effect of removing attributes except names, for example to turn an <code><a href="array.html">array</a></code> into a vector. <code>as.vector</code> is a more intuitive way to do this, but also drops names. Note that <code>c</code> methods other than the default are not required to remove attributes (and they will almost certainly preserve a class attribute). </p> <p>This is a <a href="primitive.html">primitive</a> function. </p> <h3>Value</h3> <p><code>NULL</code> or an expression or a vector of an appropriate mode. (With no arguments the value is <code>NULL</code>.) </p> <h3>S4 methods</h3> <p>This function is S4 generic, but with argument list <code>(x, ...)</code>. </p> <h3>References</h3> <p>Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) <em>The New S Language</em>. Wadsworth &amp; Brooks/Cole. </p> <h3>See Also</h3> <p><code><a href="unlist.html">unlist</a></code> and <code><a href="vector.html">as.vector</a></code> to produce attribute-free vectors. </p> <h3>Examples</h3> <pre data-language="r"><code class="language-R">c(1, 7:9)
c(1:5, 10.5, "next")

## uses with a single argument to drop attributes
x &lt;- 1:4
names(x) &lt;- letters[1:4]
x
c(x)          # has names
as.vector(x)  # no names
dim(x) &lt;- c(2,2)
x
c(x)
as.vector(x)

## append to a list:
ll &lt;- list(A = 1, c = "C")
## do *not* use
c(ll, d = 1:3) # which is == c(ll, as.list(c(d = 1:3)))
## but rather
c(ll, d = list(1:3))  # c() combining two lists

## descend through lists:
c(list(A = c(B = 1)), recursive = TRUE)
c(list(A = c(B = 1, C = 2), B = c(E = 7)), recursive = TRUE)
</code></pre> </main> </div><div class="_attribution">
  <p class="_attribution-p">
    Copyright (&copy;) 1999â€“2012 R Foundation for Statistical Computing.<br>Licensed under the <a href="https://www.gnu.org/copyleft/gpl.html">GNU General Public License</a>.<br>
    
  </p>
</div>
