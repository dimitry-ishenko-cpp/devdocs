  <h1 class="section">The let Function</h1>   <p>The <code>let</code> function provides a means to limit the scope of a variable. The assignment of the named variables in a <code>let</code> expression is in effect only within the text provided by the <code>let</code> expression, and this assignment doesn’t impact that named variable in any outer scope. </p> <p>Additionally, the <code>let</code> function enables list unpacking by assigning all unassigned values to the last named variable. </p> <p>The syntax of the <code>let</code> function is: </p> <div class="example"> <pre class="example">$(let <var>var</var> [<var>var</var> ...],[<var>list</var>],<var>text</var>)
</pre>
</div> <p>The first two arguments, <var>var</var> and <var>list</var>, are expanded before anything else is done; note that the last argument, <var>text</var>, is <strong>not</strong> expanded at the same time. Next, each word of the expanded value of <var>list</var> is bound to each of the variable names, <var>var</var>, in turn, with the final variable name being bound to the remainder of the expanded <var>list</var>. In other words, the first word of <var>list</var> is bound to the first variable <var>var</var>, the second word to the second variable <var>var</var>, and so on. </p> <p>If there are more variable names in <var>var</var> than there are words in <var>list</var>, the remaining <var>var</var> variable names are set to the empty string. If there are fewer <var>var</var>s than words in <var>list</var> then the last <var>var</var> is set to all remaining words in <var>list</var>. </p> <p>The variables in <var>var</var> are assigned as simply-expanded variables during the execution of <code>let</code>. See <a href="flavors.html">The Two Flavors of Variables</a>. </p> <p>After all variables are thus bound, <var>text</var> is expanded to provide the result of the <code>let</code> function. </p> <p>For example, this macro reverses the order of the words in the list that it is given as its first argument: </p> <div class="example"> <pre class="example">reverse = $(let first rest,$1,\
            $(if $(rest),$(call reverse,$(rest)) )$(first))

all: ; @echo $(call reverse,d c b a)
</pre>
</div> <p>will print <code>a b c d</code>. When first called, <code>let</code> will expand <var>$1</var> to <code>d c b a</code>. It will then assign <var>first</var> to <code>d</code> and assign <var>rest</var> to <code>c b a</code>. It will then expand the if-statement, where <code>$(rest)</code> is not empty so we recursively invoke the <var>reverse</var> function with the value of <var>rest</var> which is now <code>c b a</code>. The recursive invocation of <code>let</code> assigns <var>first</var> to <code>c</code> and <var>rest</var> to <code>b a</code>. The recursion continues until <code>let</code> is called with just a single value, <code>a</code>. Here <var>first</var> is <code>a</code> and <var>rest</var> is empty, so we do not recurse but simply expand <code>$(first)</code> to <code>a</code> and return, which adds <code> b</code>, etc. </p> <p>After the <var>reverse</var> call is complete, the <var>first</var> and <var>rest</var> variables are no longer set. If variables by those names existed beforehand, they are not affected by the expansion of the <code>reverse</code> macro. </p><div class="_attribution">
  <p class="_attribution-p">
    Copyright © 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022 Free Software Foundation, Inc. <br>Licensed under the GNU Free Documentation License.<br>
    <a href="https://www.gnu.org/software/make/manual/html_node/Let-Function.html" class="_attribution-link">https://www.gnu.org/software/make/manual/html_node/Let-Function.html</a>
  </p>
</div>
