<div id="col-content" data-swiftype-index="true"> <div id="about-search"><h1>About Search</h1></div>  <div class="prose"> <p data-swiftype-index="false"> <a href="https://github.com/chef/chef-web-docs/blob/main/content/chef_search.md" alt="Link to page on GitHub repository">[edit on GitHub]</a> </p> <p>Search indexes allow queries to be made for any type of data that is indexed by the Chef Infra Server, including data bags (and data bag items), environments, nodes, and roles. A defined query syntax is used to support search patterns like exact, wildcard, range, and fuzzy. A search is a full-text query that can be done from several locations, including from within a recipe, by using the <code>search</code> subcommand in knife, the <code>search</code> method in the Chef Infra Language, the search box in the Chef management console, and by using the <code>/search</code> or <code>/search/INDEX</code> endpoints in the Chef Infra Server API. The search engine is based on Elasticsearch and is run from the Chef Infra Server.</p> <p>Many of the examples in this section use knife, but the search indexes and search query syntax can be used in many locations, including from within recipes and when using the Chef Infra Server API.</p> <h2 id="search-indexes">Search Indexes</h2> <p>A search index is a full-text list of objects that are stored on the Chef Infra Server, against which search queries can be made. The following search indexes are built:</p> <table> <col style="width:40%"> <col style="width:60%"> <thead> <tr class="header"> <th>Search Index Name</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td><code>client</code></td> <td>API client</td> </tr> <tr> <td><code>DATA_BAG_NAME</code></td> <td>A data bag is a global variable that is stored as JSON data and is accessible from a Chef Infra Server. The name of the search index is the name of the data bag. For example, if the name of the data bag was "admins" then a corresponding search query might look something like <code>search(:admins, "*:*")</code>.</td> </tr> <tr> <td><code>environment</code></td> <td>An environment is a way to map an organization's real-life workflow to what can be configured and managed when using Chef Infra Server.</td> </tr> <tr> <td><code>node</code></td> <td>A node is any server or virtual server that is configured to be maintained by a Chef Infra Client.</td> </tr> <tr> <td><code>role</code></td> <td>A role is a way to define certain patterns and processes that exist across nodes in an organization as belonging to a single job function.</td> </tr> </tbody> </table> <h3 id="using-knife">Using Knife</h3> <p>Use the <code>knife search</code> subcommand to run a search query for information that is indexed on a Chef Infra Server.</p> <h4 id="search-by-platform-id">Search by platform ID</h4> <p>To search for the IDs of all nodes running on the Amazon EC2 platform, enter:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-bash" data-lang="bash">knife search node <span style="color:#4070a0">'ec2:*'</span> -i
</code></pre></div>
<p>to return something like:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-bash" data-lang="bash"><span style="color:#40a070">4</span> items found

ip-0A7CA19F.ec2.internal

ip-0A58CF8E.ec2.internal

ip-0A58E134.ec2.internal

ip-0A7CFFD5.ec2.internal
</code></pre></div>
<h4 id="search-by-instance-type">Search by instance type</h4> <p>To search for the instance type (flavor) of all nodes running on the Amazon EC2 platform, enter:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-bash" data-lang="bash">knife search node <span style="color:#4070a0">'ec2:*'</span> -a ec2.instance_type
</code></pre></div>
<p>to return something like:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-bash" data-lang="bash"><span style="color:#40a070">4</span> items found

ec2.instance_type:  m1.large
id:                 ip-0A7CA19F.ec2.internal

ec2.instance_type:  m1.large
id:                 ip-0A58CF8E.ec2.internal

ec2.instance_type:  m1.large
id:                 ip-0A58E134.ec2.internal

ec2.instance_type:  m1.large
id:                 ip-0A7CFFD5.ec2.internal
</code></pre></div>
<h4 id="search-by-recipe">Search by recipe</h4> <p>To search for recipes that are used by a node, use the <code>recipes</code> attribute to search for the recipe names, enter something like:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-bash" data-lang="bash">knife search node <span style="color:#4070a0">'recipes:recipe_name'</span>
</code></pre></div>
<p>or:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-bash" data-lang="bash">knife search node <span style="color:#4070a0">'*:*'</span> -a recipes | grep <span style="color:#4070a0">'recipe_name'</span>
</code></pre></div>
<h4 id="search-by-cookbook-then-recipe">Search by cookbook, then recipe</h4> <p>To search for cookbooks on a node, use the <code>recipes</code> attribute followed by the <code>cookbook::recipe</code> pattern, escaping both of the <code>:</code> characters. For example:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-bash" data-lang="bash">knife search node <span style="color:#4070a0">'recipes:cookbook_name\:\:recipe_name'</span>
</code></pre></div>
<h4 id="search-by-node">Search by node</h4> <p>To search for all nodes running Ubuntu, enter:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-bash" data-lang="bash">knife search node <span style="color:#4070a0">'platform:ubuntu'</span>
</code></pre></div>
<h4 id="search-by-node-and-environment">Search by node and environment</h4> <p>To search for all nodes running CentOS in the production environment, enter:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-bash" data-lang="bash">knife search node <span style="color:#4070a0">'chef_environment:production AND platform:centos'</span>
</code></pre></div>
<h4 id="search-for-nested-attributes">Search for nested attributes</h4> <p>To find a nested attribute, use a pattern similar to the following:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-bash" data-lang="bash">knife search node &lt;query_to_run&gt; -a &lt;main_attribute&gt;.&lt;nested_attribute&gt;
</code></pre></div>
<h4 id="search-for-multiple-attributes">Search for multiple attributes</h4> <p>To build a search query to use more than one attribute, use an underscore (<code>_</code>) to separate each attribute. For example, the following query will search for all nodes running a specific version of Ruby:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-bash" data-lang="bash">knife search node <span style="color:#4070a0">"languages_ruby_version:2.7.0"</span>
</code></pre></div>
<h4 id="search-for-nested-attributes-using-a-search-query">Search for nested attributes using a search query</h4> <p>To build a search query that can find a nested attribute:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-bash" data-lang="bash">knife search node name: &lt;node_name&gt; -a kernel.machine
</code></pre></div>
<h4 id="use-a-test-query">Use a test query</h4> <p>To test a search query that will be used in a <code>knife ssh</code> subcommand:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-bash" data-lang="bash">knife search node <span style="color:#4070a0">"role:web NOT name:web03"</span>
</code></pre></div>
<p>where the query in the previous example will search all servers that have the <code>web</code> role, but not on the server named <code>web03</code>.</p> <h2 id="query-syntax">Query Syntax</h2> <p>A search query is comprised of two parts: the key and the search pattern. A search query has the following syntax:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-ruby" data-lang="ruby"><span style="color:#517918">key</span>:search_pattern
</code></pre></div>
<p>where <code>key</code> is a field name that is found in the JSON description of an indexable object on the Chef Infra Server (a role, node, client, environment, or data bag) and <code>search_pattern</code> defines what will be searched for, using one of the following search patterns: exact, wildcard, range, or fuzzy matching. Both <code>key</code> and <code>search_pattern</code> are case-sensitive; <code>key</code> has limited support for multiple character wildcard matching using an asterisk ("*") (and as long as it is not the first character).</p> <div class="admonition-note"> <p class="admonition-note-title">Note</p> <div class="admonition-note-text"> Search queries may not contain newlines. </div> </div> <h2 id="filter-search-results">Filter Search Results</h2> <p>Use <code>:filter_result</code> as part of a search query to filter the search output based on the pattern specified by a Hash. Only attributes in the Hash will be returned.</p> <p>The syntax for the <code>search</code> method that uses <code>:filter_result</code> is as follows:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-ruby" data-lang="ruby">search(<span style="color:#517918">:index</span>, <span style="color:#4070a0">'query'</span>,
  <span style="color:#517918">filter_result</span>: { <span style="color:#4070a0">'foo'</span> <span style="color:#666">=&gt;</span> <span style="color:#666">[</span> <span style="color:#4070a0">'abc'</span> <span style="color:#666">]</span>,
                      <span style="color:#4070a0">'bar'</span> <span style="color:#666">=&gt;</span> <span style="color:#666">[</span> <span style="color:#4070a0">'123'</span> <span style="color:#666">]</span>,
                      <span style="color:#4070a0">'baz'</span> <span style="color:#666">=&gt;</span> <span style="color:#c65d09">%w(sea power)</span>,
                    }
)<span style="color:#666">.</span>each <span style="color:#007020;font-weight:700">do</span> <span style="color:#666">|</span>result<span style="color:#666">|</span>
  <span style="color:#007020">puts</span> result<span style="color:#666">[</span><span style="color:#4070a0">'foo'</span><span style="color:#666">]</span>
  <span style="color:#007020">puts</span> result<span style="color:#666">[</span><span style="color:#4070a0">'bar'</span><span style="color:#666">]</span>
  <span style="color:#007020">puts</span> result<span style="color:#666">[</span><span style="color:#4070a0">'baz'</span><span style="color:#666">]</span>
<span style="color:#007020;font-weight:700">end</span>
</code></pre></div>
<p>where:</p> <ul> <li>
<code>:index</code> is of name of the index on the Chef Infra Server against which the search query will run: <code>:client</code>, <code>:data_bag_name</code>, <code>:environment</code>, <code>:node</code>, and <code>:role</code>
</li> <li>
<code>'query'</code> is a valid search query against an object on the Chef server</li> <li>
<code>:filter_result</code> defines a Hash of values to be returned</li> </ul> <p>For example:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-ruby" data-lang="ruby">search(<span style="color:#517918">:node</span>, <span style="color:#4070a0">'role:web'</span>,
  <span style="color:#517918">filter_result</span>: { <span style="color:#4070a0">'name'</span> <span style="color:#666">=&gt;</span> <span style="color:#666">[</span> <span style="color:#4070a0">'name'</span> <span style="color:#666">]</span>,
                      <span style="color:#4070a0">'ip'</span> <span style="color:#666">=&gt;</span> <span style="color:#666">[</span> <span style="color:#4070a0">'ipaddress'</span> <span style="color:#666">]</span>,
                      <span style="color:#4070a0">'kernel_version'</span> <span style="color:#666">=&gt;</span> <span style="color:#c65d09">%w(kernel version)</span>,
                    }
)<span style="color:#666">.</span>each <span style="color:#007020;font-weight:700">do</span> <span style="color:#666">|</span>result<span style="color:#666">|</span>
  <span style="color:#007020">puts</span> result<span style="color:#666">[</span><span style="color:#4070a0">'name'</span><span style="color:#666">]</span>
  <span style="color:#007020">puts</span> result<span style="color:#666">[</span><span style="color:#4070a0">'ip'</span><span style="color:#666">]</span>
  <span style="color:#007020">puts</span> result<span style="color:#666">[</span><span style="color:#4070a0">'kernel_version'</span><span style="color:#666">]</span>
<span style="color:#007020;font-weight:700">end</span>
</code></pre></div>
<h2 id="keys">Keys</h2> <p>A field name/description pair is available in the JSON object. Use the field name when searching for this information in the JSON object. Any field that exists in any JSON description for any role, node, Chef Infra Client, environment, or data bag can be searched.</p> <h3 id="nested-fields">Nested Fields</h3> <p>A nested field appears deeper in the JSON data structure. For example, information about a network interface might be several layers deep: <code>node['network']['interfaces']['en1']</code>. When nested fields are present in a JSON structure, Chef Infra Client will extract those nested fields to the top-level, flattening them into compound fields that support wildcard search patterns.</p> <p>By combining wildcards with range-matching patterns and wildcard queries, it is possible to perform very powerful searches, such as using the vendor part of the MAC address to find every node that has a network card made by the specified vendor.</p> <p>Consider the following snippet of JSON data:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-javascript" data-lang="javascript">{<span style="color:#4070a0">"network"</span><span style="color:#666">:</span>
  [
  <span style="color:#60a0b0;font-style:italic">//snipped...
</span>    <span style="color:#4070a0">"interfaces"</span>,
      {<span style="color:#4070a0">"en1"</span><span style="color:#666">:</span> {
        <span style="color:#4070a0">"number"</span><span style="color:#666">:</span> <span style="color:#4070a0">"1"</span>,
        <span style="color:#4070a0">"flags"</span><span style="color:#666">:</span> [
          <span style="color:#4070a0">"UP"</span>,
          <span style="color:#4070a0">"BROADCAST"</span>,
          <span style="color:#4070a0">"SMART"</span>,
          <span style="color:#4070a0">"RUNNING"</span>,
          <span style="color:#4070a0">"SIMPLEX"</span>,
          <span style="color:#4070a0">"MULTICAST"</span>
        ],
        <span style="color:#4070a0">"addresses"</span><span style="color:#666">:</span> {
          <span style="color:#4070a0">"fe80::fa1e:dfff:fed8:63a2"</span><span style="color:#666">:</span> {
            <span style="color:#4070a0">"scope"</span><span style="color:#666">:</span> <span style="color:#4070a0">"Link"</span>,
            <span style="color:#4070a0">"prefixlen"</span><span style="color:#666">:</span> <span style="color:#4070a0">"64"</span>,
            <span style="color:#4070a0">"family"</span><span style="color:#666">:</span> <span style="color:#4070a0">"inet6"</span>
          },
          <span style="color:#4070a0">"f8:1e:df:d8:63:a2"</span><span style="color:#666">:</span> {
            <span style="color:#4070a0">"family"</span><span style="color:#666">:</span> <span style="color:#4070a0">"lladdr"</span>
          },
          <span style="color:#4070a0">"192.0.2.0"</span><span style="color:#666">:</span> {
            <span style="color:#4070a0">"netmask"</span><span style="color:#666">:</span> <span style="color:#4070a0">"255.255.255.0"</span>,
            <span style="color:#4070a0">"broadcast"</span><span style="color:#666">:</span> <span style="color:#4070a0">"192.168.0.255"</span>,
            <span style="color:#4070a0">"family"</span><span style="color:#666">:</span> <span style="color:#4070a0">"inet"</span>
          }
        },
        <span style="color:#4070a0">"mtu"</span><span style="color:#666">:</span> <span style="color:#4070a0">"1500"</span>,
        <span style="color:#4070a0">"media"</span><span style="color:#666">:</span> {
          <span style="color:#4070a0">"supported"</span><span style="color:#666">:</span> {
            <span style="color:#4070a0">"autoselect"</span><span style="color:#666">:</span> {
              <span style="color:#4070a0">"options"</span><span style="color:#666">:</span> [

              ]
            }
          },
          <span style="color:#4070a0">"selected"</span><span style="color:#666">:</span> {
            <span style="color:#4070a0">"autoselect"</span><span style="color:#666">:</span> {
              <span style="color:#4070a0">"options"</span><span style="color:#666">:</span> [

              ]
            }
          }
        },
        <span style="color:#4070a0">"type"</span><span style="color:#666">:</span> <span style="color:#4070a0">"en"</span>,
        <span style="color:#4070a0">"status"</span><span style="color:#666">:</span> <span style="color:#4070a0">"active"</span>,
        <span style="color:#4070a0">"encapsulation"</span><span style="color:#666">:</span> <span style="color:#4070a0">"Ethernet"</span>
      },
  <span style="color:#60a0b0;font-style:italic">//snipped...
</span></code></pre></div>
<p>Before this data is indexed on the Chef Infra Server, the nested fields are extracted into the top level, similar to:</p> <pre tabindex="0" class="highlight" data-language="ruby"><code class="language-none" data-lang="none">"broadcast" =&gt; "192.168.0.255",
"flags"     =&gt; ["UP", "BROADCAST", "SMART", "RUNNING", "SIMPLEX", "MULTICAST"]
"mtu"       =&gt; "1500"
</code></pre>
<p>which allows searches like the following to find data that is present in this node:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-ruby" data-lang="ruby">node <span style="color:#4070a0">"broadcast:192.168.0.*"</span>
</code></pre></div>
<p>or:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-ruby" data-lang="ruby">node <span style="color:#4070a0">"mtu:1500"</span>
</code></pre></div>
<p>or:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-ruby" data-lang="ruby">node <span style="color:#4070a0">"flags:UP"</span>
</code></pre></div>
<p>This data is also flattened into various compound fields, which follow the same pattern as the JSON hierarchy and use underscores (<code>_</code>) to separate the levels of data, similar to:</p> <pre tabindex="0" class="highlight" data-language="ruby"><code class="language-none" data-lang="none"># ...snip...
"network_interfaces_en1_addresses_192.0.2.0_broadcast" =&gt; "192.168.0.255",
"network_interfaces_en1_addresses_fe80::fa1e:tldr_family"  =&gt; "inet6",
"network_interfaces_en1_addresses"                         =&gt; ["fe80::fa1e:tldr","f8:1e:df:tldr","192.0.2.0"]
# ...snip...
</code></pre>
<p>which allows searches like the following to find data that is present in this node:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-ruby" data-lang="ruby">node <span style="color:#4070a0">"network_interfaces_en1_addresses:192.0.2.0"</span>
</code></pre></div>
<p>This flattened data structure also supports using wildcard compound fields, which allow searches to omit levels within the JSON data structure that are not important to the search query. In the following example, an asterisk (<code>*</code>) is used to show where the wildcard can exist when searching for a nested field:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-ruby" data-lang="ruby"><span style="color:#4070a0">"network_interfaces_*_flags"</span>     <span style="color:#666">=&gt;</span> <span style="color:#666">[</span><span style="color:#4070a0">"UP"</span>, <span style="color:#4070a0">"BROADCAST"</span>, <span style="color:#4070a0">"SMART"</span>, <span style="color:#4070a0">"RUNNING"</span>, <span style="color:#4070a0">"SIMPLEX"</span>, <span style="color:#4070a0">"MULTICAST"</span><span style="color:#666">]</span>
<span style="color:#4070a0">"network_interfaces_*_addresses"</span> <span style="color:#666">=&gt;</span> <span style="color:#666">[</span><span style="color:#4070a0">"fe80::fa1e:dfff:fed8:63a2"</span>, <span style="color:#4070a0">"192.0.2.0"</span>, <span style="color:#4070a0">"f8:1e:df:d8:63:a2"</span><span style="color:#666">]</span>
<span style="color:#4070a0">"network_interfaces_en0_media_*"</span> <span style="color:#666">=&gt;</span> <span style="color:#666">[</span><span style="color:#4070a0">"autoselect"</span>, <span style="color:#4070a0">"none"</span>, <span style="color:#4070a0">"1000baseT"</span>, <span style="color:#4070a0">"10baseT/UTP"</span>, <span style="color:#4070a0">"100baseTX"</span><span style="color:#666">]</span>
<span style="color:#4070a0">"network_interfaces_en1_*"</span>       <span style="color:#666">=&gt;</span> <span style="color:#666">[</span><span style="color:#4070a0">"1"</span>, <span style="color:#4070a0">"UP"</span>, <span style="color:#4070a0">"BROADCAST"</span>, <span style="color:#4070a0">"SMART"</span>, <span style="color:#4070a0">"RUNNING"</span>, <span style="color:#4070a0">"SIMPLEX"</span>, <span style="color:#4070a0">"MULTICAST"</span>,
                                     <span style="color:#4070a0">"fe80::fa1e:dfff:fed8:63a2"</span>, <span style="color:#4070a0">"f8:1e:df:d8:63:a2"</span>, <span style="color:#4070a0">"192.0.2.0"</span>,
                                     <span style="color:#4070a0">"1500"</span>, <span style="color:#4070a0">"supported"</span>, <span style="color:#4070a0">"selected"</span>, <span style="color:#4070a0">"en"</span>, <span style="color:#4070a0">"active"</span>, <span style="color:#4070a0">"Ethernet"</span><span style="color:#666">]</span>
</code></pre></div>
<p>For each of the wildcard examples above, the possible values are shown contained within the brackets. When running a search query, the query syntax for wildcards is to simply omit the name of the node (while preserving the underscores), similar to:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-ruby" data-lang="ruby">network_interfaces__flags
</code></pre></div>
<p>This query will search within the <code>flags</code> node, within the JSON structure, for each of <code>UP</code>, <code>BROADCAST</code>, <code>SMART</code>, <code>RUNNING</code>, <code>SIMPLEX</code>, and <code>MULTICAST</code>.</p> <h3 id="examples">Examples</h3> <p>To see the available keys for a node, enter the following (for a node named <code>staging</code>):</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-bash" data-lang="bash">knife node show staging -Fj | less
</code></pre></div>
<p>to return a full JSON description of the node and to view the available keys with which any search query can be based.</p> <p>To use a question mark (<code>?</code>) to replace a single character in a wildcard search, enter the following:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-bash" data-lang="bash">knife search node <span style="color:#4070a0">'platfor?:ubuntu'</span>
</code></pre></div>
<p>To use an asterisk (<code>*</code>) to replace zero (or more) characters in a wildcard search, enter the following:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-bash" data-lang="bash">knife search node <span style="color:#4070a0">'platfo*:ubuntu'</span>
</code></pre></div>
<p>To find all IP address that are on the same network, enter the following:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-bash" data-lang="bash">knife search node <span style="color:#4070a0">'ipaddress:192.168*'</span>
</code></pre></div>
<p>where <code>192.168*</code> is the network address for which the search will be run.</p> <p>To use a range search to find IP addresses within a subnet, enter the following:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-bash" data-lang="bash">knife search node <span style="color:#4070a0">'ipaddress:[192.168.0.* TO 192.0.2.*]'</span>
</code></pre></div>
<p>where <code>192.168.0.* TO 192.0.2.*</code> defines the subnet range.</p> <h2 id="patterns">Patterns</h2> <p>A search pattern is a way to fine-tune search results by returning anything that matches some type of incomplete search query. There are four types of search patterns that can be used when searching the search indexes on the Chef Infra Server: exact, wildcard, range, and fuzzy.</p> <h3 id="exact-matching">Exact Matching</h3> <p>An exact matching search pattern is used to search for a key with a name that exactly matches a search query. If the name of the key contains spaces, quotes must be used in the search pattern to ensure the search query finds the key. The entire query must also be contained within quotes, so as to prevent it from being interpreted by Ruby or a command shell. The best way to ensure that quotes are used consistently is to quote the entire query using single quotes (' ‘) and a search pattern with double quotes (" “).</p> <p>To search in a specific data bag for a specific data bag item, enter the following:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-bash" data-lang="bash">knife search admins <span style="color:#4070a0">'id:charlie'</span>
</code></pre></div>
<p>where <code>admins</code> is the name of the data bag and <code>charlie</code> is the name of the data bag item. Something similar to the following will be returned:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-bash" data-lang="bash"><span style="color:#40a070">1</span> items found
_rev:       1-39ff4099f2510f477b4c26bef81f75b9
chef_type:  data_bag_item
comment:    Charlie the Unicorn
data_bag:   admins
gid:        ops
id:         charlie
shell:      /bin/zsh
uid:        <span style="color:#40a070">1005</span>
</code></pre></div>
<p>To search in a specific data bag using a string to find any matching data bag item, enter the following:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-bash" data-lang="bash">knife search admins <span style="color:#4070a0">'comment:"Charlie the Unicorn"'</span>
</code></pre></div>
<p>where <code>admins</code> is the name of the data bag and <code>Charlie the Unicorn</code> is the string that will be used during the search. Something similar to the following will be returned:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-bash" data-lang="bash"><span style="color:#40a070">1</span> items found
_rev:       1-39ff4099f2510f477b4c26bef81f75b9
chef_type:  data_bag_item
comment:    Charlie the Unicorn
data_bag:   admins
gid:        ops
id:         charlie
shell:      /bin/zsh
uid:        <span style="color:#40a070">1005</span>
</code></pre></div>
<h3 id="wildcard-matching">Wildcard Matching</h3> <p>A wildcard matching search pattern is used to query for substring matches that replace zero (or more) characters in the search pattern with anything that could match the replaced character. There are two types of wildcard searches:</p> <ul> <li>A question mark (<code>?</code>) can be used to replace exactly one character (as long as that character is not the first character in the search pattern)</li> <li>An asterisk (<code>*</code>) can be used to replace any number of characters (including zero)</li> </ul> <p>To search for any node that contains the specified key, enter the following:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-bash" data-lang="bash">knife search node <span style="color:#4070a0">'foo:*'</span>
</code></pre></div>
<p>where <code>foo</code> is the name of the node.</p> <p>To search for a node using a partial name, enter one of the following:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-bash" data-lang="bash">knife search node <span style="color:#4070a0">'name:app*'</span>
</code></pre></div>
<p>or:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-bash" data-lang="bash">knife search node <span style="color:#4070a0">'name:app1*.example.com'</span>
</code></pre></div>
<p>or:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-bash" data-lang="bash">knife search node <span style="color:#4070a0">'name:app?.example.com'</span>
</code></pre></div>
<p>or:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-bash" data-lang="bash">knife search node <span style="color:#4070a0">'name:app1.example.???'</span>
</code></pre></div>
<p>to return <code>app1.example.com</code> (and any other node that matches any of the string searches above).</p> <h3 id="range-matching">Range Matching</h3> <p>A range matching search pattern is used to query for values that are within a range defined by upper and lower boundaries. A range matching search pattern can be inclusive or exclusive of the boundaries. Use square brackets ("[ ]") to denote inclusive boundaries and curly braces ("{ }") to denote exclusive boundaries and with the following syntax:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-ruby" data-lang="ruby">boundary <span style="color:#60add5">TO</span> boundary
</code></pre></div>
<p>where <code>TO</code> is required (and must be capitalized).</p> <p>A data bag named <code>sample</code> contains four data bag items: <code>abc</code>, <code>bar</code>, <code>baz</code>, and <code>quz</code>. All of the items in-between <code>bar</code> and <code>foo</code>, inclusive, can be searched for using an inclusive search pattern.</p> <p>To search using an inclusive range, enter the following:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-bash" data-lang="bash">knife search sample <span style="color:#4070a0">"id:[bar TO foo]"</span>
</code></pre></div>
<p>where square brackets (<code>[ ]</code>) are used to define the range.</p> <p>A data bag named <code>sample</code> contains four data bag items: <code>abc</code>, <code>bar</code>, <code>baz</code>, and <code>quz</code>. All of the items that are exclusive to <code>bar</code> and <code>foo</code> can be searched for using an exclusive search pattern.</p> <p>To search using an exclusive range, enter the following:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-bash" data-lang="bash">knife search sample <span style="color:#4070a0">"id:{bar TO foo}"</span>
</code></pre></div>
<p>where curly braces (<code>{ }</code>) are used to define the range.</p> <h3 id="fuzzy-matching">Fuzzy Matching</h3> <p>A fuzzy matching search pattern is used to search based on the proximity of two strings of characters. An (optional) integer may be used as part of the search query to more closely define the proximity. A fuzzy matching search pattern has the following syntax:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-ruby" data-lang="ruby"><span style="color:#4070a0">"search_query"</span><span style="color:#666">~</span>edit_distance
</code></pre></div>
<p>where <code>search_query</code> is the string that will be used during the search and <code>edit_distance</code> is the proximity. A tilde ("~") is used to separate the edit distance from the search query.</p> <p>To use a fuzzy search pattern enter something similar to:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-bash" data-lang="bash">knife search client <span style="color:#4070a0">"name:boo~"</span>
</code></pre></div>
<p>where <code>boo~</code> defines the fuzzy search pattern. This will return something similar to:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-javascript" data-lang="javascript">{
  <span style="color:#4070a0">"total"</span><span style="color:#666">:</span> <span style="color:#40a070">1</span>,
  <span style="color:#4070a0">"start"</span><span style="color:#666">:</span> <span style="color:#40a070">0</span>,
  <span style="color:#4070a0">"rows"</span><span style="color:#666">:</span> [
    {
      <span style="color:#4070a0">"public_key"</span><span style="color:#666">:</span> <span style="color:#4070a0">"too long didn't read"</span>,
      <span style="color:#4070a0">"name"</span><span style="color:#666">:</span> <span style="color:#4070a0">"foo"</span>,
      <span style="color:#4070a0">"_rev"</span><span style="color:#666">:</span> <span style="color:#4070a0">"1-f11a58043906e33d39a686e9b58cd92f"</span>,
      <span style="color:#4070a0">"json_class"</span><span style="color:#666">:</span> <span style="color:#4070a0">"Chef::ApiClient"</span>,
      <span style="color:#4070a0">"admin"</span><span style="color:#666">:</span> <span style="color:#007020;font-weight:700">false</span>,
      <span style="color:#4070a0">"chef_type"</span><span style="color:#666">:</span> <span style="color:#4070a0">"client"</span>
    }
  ]
}
</code></pre></div>
<h2 id="operators">Operators</h2> <p>An operator can be used to ensure that certain terms are included in the results, are excluded from the results, or are not included even when other aspects of the query match. Searches can use the following operators:</p> <table> <col style="width:40%"> <col style="width:60%"> <thead> <tr class="header"> <th>Operator</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td><code>AND</code></td> <td>Use to find a match when both terms exist.</td> </tr> <tr> <td><code>OR</code></td> <td>Use to find a match if either term exists.</td> </tr> <tr> <td><code>NOT</code></td> <td>Use to exclude the term after <code>NOT</code> from the search results.</td> </tr> </tbody> </table> <p>Operators must be in ALL CAPS. Parentheses can be used to group clauses and to form sub-queries.</p> <div class="admonition-warning"> <p class="admonition-warning-title">Warning</p> <div class="admonition-warning-text"> <p>Using <code>AND NOT</code> together may trigger an error. For example:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-bash" data-lang="bash">ERROR: knife search failed: invalid search query:
<span style="color:#4070a0">'datacenter%3A123%20AND%20NOT%20hostname%3Adev-%20AND%20NOT%20hostanem%3Asyslog-'</span>
Parse error at offset: <span style="color:#40a070">38</span> Reason: Expected one of <span style="color:#4070a0;font-weight:700">\ </span>at line 1, column <span style="color:#40a070">42</span> <span style="color:#666">(</span>byte 42<span style="color:#666">)</span> after AND
</code></pre></div>
<p>Use <code>-</code> instead of <code>NOT</code>. For example:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-bash" data-lang="bash">knife search sample <span style="color:#4070a0">"id:foo AND -id:bar"</span>
</code></pre></div>
</div> </div> <h3 id="and">AND</h3> <p>To join queries using the <code>AND</code> boolean operator, enter the following:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-bash" data-lang="bash">knife search sample <span style="color:#4070a0">"id:b* AND animal:dog"</span>
</code></pre></div>
<p>to return something like:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-bash" data-lang="bash"><span style="color:#666">{</span>
  <span style="color:#4070a0">"total"</span>: 1,
  <span style="color:#4070a0">"start"</span>: 0,
  <span style="color:#4070a0">"rows"</span>: <span style="color:#666">[</span>
    <span style="color:#666">{</span>
      <span style="color:#4070a0">"comment"</span>: <span style="color:#4070a0">"an item named baz"</span>,
      <span style="color:#4070a0">"id"</span>: <span style="color:#4070a0">"baz"</span>,
      <span style="color:#4070a0">"animal"</span>: <span style="color:#4070a0">"dog"</span>
    <span style="color:#666">}</span>
  <span style="color:#666">]</span>
<span style="color:#666">}</span>
</code></pre></div>
<p>Or, to find all of the computers running on the Microsoft Windows platform that are associated with a role named <code>jenkins</code>, enter:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-bash" data-lang="bash">knife search node <span style="color:#4070a0">'platform:windows AND roles:jenkins'</span>
</code></pre></div>
<p>to return something like:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-bash" data-lang="bash"><span style="color:#40a070">2</span> items found

Node Name:   windows-server-2012r2.domain.com
Environment: _default
FQDN:        windows-server-2012r2
IP:          0000::0000:0000:0000:0000
Run List:    role<span style="color:#666">[</span>jenkins-windows<span style="color:#666">]</span>
Roles:       jenkins-windows, jenkins
Recipes:     jenkins-client::windows, jenkins::node_windows
Platform:    windows 6.3.9600
Tags:

Node Name:   123-windows-2012r2-amd64-builder
Environment: _default
FQDN:        ABC-1234567890AB
IP:          123.45.6.78
Run List:    role<span style="color:#666">[</span>123-windows-2012r2-amd64-builder<span style="color:#666">]</span>
Roles:       123-windows-2012r2-amd64-builder, jenkins
Recipes:     jenkins::node_windows, git_windows
Platform:    windows 6.3.9600
Tags:
</code></pre></div>
<h3 id="not">NOT</h3> <p>To negate search results using the <code>NOT</code> boolean operator, enter the following:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-bash" data-lang="bash">knife search sample <span style="color:#4070a0">"(NOT id:foo)"</span>
</code></pre></div>
<p>to return something like:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-bash" data-lang="bash"><span style="color:#666">{</span>
  <span style="color:#4070a0">"total"</span>: 4,
  <span style="color:#4070a0">"start"</span>: 0,
  <span style="color:#4070a0">"rows"</span>: <span style="color:#666">[</span>
    <span style="color:#666">{</span>
      <span style="color:#4070a0">"comment"</span>: <span style="color:#4070a0">"an item named bar"</span>,
      <span style="color:#4070a0">"id"</span>: <span style="color:#4070a0">"bar"</span>,
      <span style="color:#4070a0">"animal"</span>: <span style="color:#4070a0">"cat"</span>
    <span style="color:#666">}</span>,
    <span style="color:#666">{</span>
      <span style="color:#4070a0">"comment"</span>: <span style="color:#4070a0">"an item named baz"</span>,
      <span style="color:#4070a0">"id"</span>: <span style="color:#4070a0">"baz"</span>
      <span style="color:#4070a0">"animal"</span>: <span style="color:#4070a0">"dog"</span>
    <span style="color:#666">}</span>,
    <span style="color:#666">{</span>
      <span style="color:#4070a0">"comment"</span>: <span style="color:#4070a0">"an item named abc"</span>,
      <span style="color:#4070a0">"id"</span>: <span style="color:#4070a0">"abc"</span>,
      <span style="color:#4070a0">"animal"</span>: <span style="color:#4070a0">"unicorn"</span>
    <span style="color:#666">}</span>,
    <span style="color:#666">{</span>
      <span style="color:#4070a0">"comment"</span>: <span style="color:#4070a0">"an item named qux"</span>,
      <span style="color:#4070a0">"id"</span>: <span style="color:#4070a0">"qux"</span>,
      <span style="color:#4070a0">"animal"</span>, <span style="color:#4070a0">"penguin"</span>
    <span style="color:#666">}</span>
  <span style="color:#666">]</span>
<span style="color:#666">}</span>
</code></pre></div>
<h3 id="or">OR</h3> <p>To join queries using the <code>OR</code> boolean operator, enter the following:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-bash" data-lang="bash">knife search sample <span style="color:#4070a0">"id:foo OR id:abc"</span>
</code></pre></div>
<p>to return something like:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-bash" data-lang="bash"><span style="color:#666">{</span>
  <span style="color:#4070a0">"total"</span>: 2,
  <span style="color:#4070a0">"start"</span>: 0,
  <span style="color:#4070a0">"rows"</span>: <span style="color:#666">[</span>
    <span style="color:#666">{</span>
      <span style="color:#4070a0">"comment"</span>: <span style="color:#4070a0">"an item named foo"</span>,
      <span style="color:#4070a0">"id"</span>: <span style="color:#4070a0">"foo"</span>,
      <span style="color:#4070a0">"animal"</span>: <span style="color:#4070a0">"pony"</span>
    <span style="color:#666">}</span>,
    <span style="color:#666">{</span>
      <span style="color:#4070a0">"comment"</span>: <span style="color:#4070a0">"an item named abc"</span>,
      <span style="color:#4070a0">"id"</span>: <span style="color:#4070a0">"abc"</span>,
      <span style="color:#4070a0">"animal"</span>: <span style="color:#4070a0">"unicorn"</span>
    <span style="color:#666">}</span>
  <span style="color:#666">]</span>
<span style="color:#666">}</span>
</code></pre></div>
<h2 id="special-characters">Special Characters</h2> <p>A special character can be used to fine-tune a search query and to increase the accuracy of the search results. The following characters can be included within the search query syntax, but each occurrence of a special character must be escaped with a backslash (<code>\</code>), also (<code>/</code>) must be escaped against the Elasticsearch:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-ruby" data-lang="ruby"><span style="color:#666">+</span>  <span style="color:#666">-</span>  <span style="color:#666">&amp;&amp;</span>  <span style="color:#666">|</span> <span style="color:#666">|</span>  <span style="color:#666">!</span>  ( )  { }  <span style="color:#666">[</span> <span style="color:#666">]</span>  <span style="color:#666">^</span>  <span style="color:#4070a0">"  ~  *  ?  :  \  /
</span></code></pre></div>
<p>For example:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-ruby" data-lang="ruby">\(<span style="color:#40a070">1</span>\<span style="color:#666">+</span><span style="color:#40a070">1</span>\)\:<span style="color:#40a070">2</span>
</code></pre></div>
<h2 id="targets">Targets</h2> <p>A search target is any object that has been indexed on the Chef Infra Server, including roles (and run-lists), nodes, environments, data bags, and any API client.</p> <h3 id="roles-in-run-lists">Roles in Run-lists</h3> <p>A search query can be made for roles that are at the top-level of a run-list and also for a role that is part of an expanded run-list.</p> <div class="admonition-note"> <p class="admonition-note-title">Note</p> <div class="admonition-note-text"> The <code>roles</code> field is updated with each Chef Infra Client run; changes to a run-list will not affect <code>roles</code> until the next Chef Infra Client run on the node. </div> </div> <table> <col style="width:40%"> <col style="width:60%"> <thead> <tr class="header"> <th>Role Location</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td><p>Top-level</p></td> <td>
<p>To find a node with a role in the top-level of its run-list, search within the <code>role</code> field (and escaping any special characters with the slash symbol) using the following syntax:</p> <pre class="highlight" data-language="ruby"><code>role:ROLE_NAME</code></pre> <p>where <code>role</code> (singular!) indicates the top-level run-list.</p>
</td> </tr> <tr> <td><p>Expanded</p></td> <td>
<p>To find a node with a role in an expanded run-list, search within the <code>roles</code> field (and escaping any special characters with the slash symbol) using the following syntax:</p> <pre class="highlight" data-language="ruby"><code>roles:ROLE_NAME</code></pre> <p>where <code>roles</code> (plural!) indicates the expanded run-list.</p>
</td> </tr> </tbody> </table> <p>To search a top-level run-list for a role named <code>load_balancer</code> use the <code>knife search</code> subcommand from the command line or the <code>search</code> method in a recipe. For example:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-bash" data-lang="bash">knife search node role:load_balancer
</code></pre></div>
<p>and from within a recipe:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-ruby" data-lang="ruby">search(<span style="color:#517918">:node</span>, <span style="color:#4070a0">'role:load_balancer'</span>)
</code></pre></div>
<p>To search an expanded run-list for all nodes with the role <code>load_balancer</code> use the <code>knife search</code> subcommand from the command line or the <code>search</code> method in a recipe. For example:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-bash" data-lang="bash">knife search node roles:load_balancer
</code></pre></div>
<p>and from within a recipe:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-ruby" data-lang="ruby">search(<span style="color:#517918">:node</span>, <span style="color:#4070a0">'roles:load_balancer'</span>)
</code></pre></div>
<h3 id="nodes">Nodes</h3> <p>A node can be searched from a recipe by using the following syntax:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-ruby" data-lang="ruby">search(<span style="color:#517918">:node</span>, <span style="color:#4070a0">"key:attribute"</span>)
</code></pre></div>
<p>A wildcard can be used to replace characters within the search query.</p> <p>Expanded lists of roles (all of the roles that apply to a node, including nested roles) and recipes to the role and recipe attributes on a node are saved on the Chef Infra Server. The expanded lists of roles allows for searching within nodes that run a given recipe, even if that recipe is included by a role.</p> <div class="admonition-note"> <p class="admonition-note-title">Note</p> <div class="admonition-note-text"> The <code>recipes</code> field is with each Chef Infra Client run; changes to a run-list will not affect <code>recipes</code> until the next Chef Infra Client run on the node. </div> </div> <table> <col style="width:40%"> <col style="width:60%"> <thead> <tr class="header"> <th>Node Location</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td><p>In a specified recipe</p></td> <td>
<p>To find a node with a specified recipe in the run-list, search within the <code>run_list</code> field (and escaping any special characters with the slash symbol) using the following syntax:</p> <div class="sourceCode" id="cb1"><pre class="sourceCode ruby highlight" data-language="ruby"><code class="sourceCode ruby"><span id="cb1-1">search(<span class="st">:node</span>, <span class="st">'run_list:recipe\[foo\:\:bar\]'</span>)</span></code></pre></div> <p>where <code>recipe</code> (singular!) indicates the top-level run-list. Variables can be interpolated into search strings using the Ruby alternate quoting syntax:</p> <div class="sourceCode" id="cb2"><pre class="sourceCode ruby highlight" data-language="ruby"><code class="sourceCode ruby"><span id="cb2-1">search(<span class="st">:node</span>,<span class="ot"> %Q{</span><span class="st">run_list:"recipe[</span><span class="ot">#{</span>the_recipe<span class="ot">}</span><span class="st">]"</span><span class="ot">}</span> )</span></code></pre></div>
</td> </tr> <tr> <td><p>In an expanded run-list</p></td> <td>
<p>To find a node with a recipe in an expanded run-list, search within the <code>recipes</code> field (and escaping any special characters with the slash symbol) using the following syntax:</p> <div class="sourceCode" id="cb3"><pre class="sourceCode ruby highlight" data-language="ruby"><code class="sourceCode ruby"><span id="cb3-1">recipes<span class="st">:RECIPE_NAME</span></span></code></pre></div> <p>where <code>recipes</code> (plural!) indicates to search within an expanded run-list.</p>
</td> </tr> </tbody> </table> <p>If you just want to use each result of the search and don’t care about the aggregate result you can provide a code block to the search method. Each result is then passed to the block:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-ruby" data-lang="ruby"><span style="color:#60a0b0;font-style:italic"># Print every node matching the search pattern</span>
search(<span style="color:#517918">:node</span>, <span style="color:#4070a0">"*:*"</span>)<span style="color:#666">.</span>each <span style="color:#007020;font-weight:700">do</span> <span style="color:#666">|</span>matching_node<span style="color:#666">|</span>
  <span style="color:#007020">puts</span> matching_node<span style="color:#666">.</span>to_s
<span style="color:#007020;font-weight:700">end</span>
</code></pre></div>
<h3 id="api-clients">API Clients</h3> <p>An API client is any machine that has permission to use the Chef Infra Server API to communicate with the Chef Infra Server. An API client is typically a node (that runs Chef Infra Client) or a workstation (that runs knife), but can also be any other machine configured to use the Chef Infra Server API.</p> <p>Sometimes when a role isn’t fully defined (or implemented), it may be necessary for a machine to connect to a database, search engine, or some other service within an environment by using the settings located on another machine, such as a host name, IP address, or private IP address. The following example shows a simplified settings file:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-ruby" data-lang="ruby"><span style="color:#517918">username</span>: <span style="color:#4070a0">"mysql"</span>
<span style="color:#517918">password</span>: <span style="color:#4070a0">"MoveAlong"</span>
<span style="color:#517918">host</span>:     <span style="color:#4070a0">"10.40.64.202"</span>
<span style="color:#517918">port</span>:     <span style="color:#4070a0">"3306"</span>
</code></pre></div>
<p>where <code>host</code> is the private IP address of the database server. Use the following knife query to view information about the node:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-bash" data-lang="bash">knife search node <span style="color:#4070a0">"name:name_of_database_server"</span> --long
</code></pre></div>
<p>To access these settings as part of a recipe that is run on the web server, use code similar to:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-ruby" data-lang="ruby">db_server <span style="color:#666">=</span> search(<span style="color:#517918">:node</span>, <span style="color:#4070a0">"name:name_of_database_server"</span>)
private_ip <span style="color:#666">=</span> <span style="color:#4070a0">"</span><span style="color:#70a0d0;font-style:italic">#{</span>db_server<span style="color:#666">[</span><span style="color:#40a070">0</span><span style="color:#666">][</span><span style="color:#517918">:rackspace</span><span style="color:#666">][</span><span style="color:#517918">:private_ip</span><span style="color:#666">]</span><span style="color:#70a0d0;font-style:italic">}</span><span style="color:#4070a0">"</span>
<span style="color:#007020">puts</span> private_ip
</code></pre></div>
<p>where the “[0]” is the 0 (zero) index for the <code>db_server</code> identifier. A single document is returned because the node is being searched on its unique name. The identifier <code>private_ip</code> will now have the value of the private IP address of the database server (<code>10.40.64.202</code>) and can then be used in templates as a variable, among other possible uses.</p> <h3 id="environments">Environments</h3> <p>An environment is a way to map an organization’s real-life workflow to what can be configured and managed when using Chef Infra. This mapping is accomplished by setting attributes and pinning cookbooks at the environment level. With environments, you can change cookbook configurations depending on the system’s designation. For example, by designating different staging and production environments, you can then define the correct URL of a database server for each environment. Environments also allow organizations to move new cookbook releases from staging to production with confidence by stepping releases through testing environments before entering production.</p> <p>When searching, an environment is an attribute. This allows search results to be limited to a specified environment by using Boolean operators and extra search terms. For example, to use knife to search for all of the servers running CentOS in an environment named “QA”, enter the following:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-bash" data-lang="bash">knife search node <span style="color:#4070a0">"chef_environment:QA AND platform:centos"</span>
</code></pre></div>
<p>Or, to include the same search in a recipe, use a code block similar to:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-ruby" data-lang="ruby">qa_nodes <span style="color:#666">=</span> search(<span style="color:#517918">:node</span>, <span style="color:#4070a0">'chef_environment:QA'</span>)
qa_nodes<span style="color:#666">.</span>each <span style="color:#007020;font-weight:700">do</span> <span style="color:#666">|</span>qa_node<span style="color:#666">|</span>
    <span style="color:#60a0b0;font-style:italic"># Do useful work specific to qa nodes only</span>
<span style="color:#007020;font-weight:700">end</span>
</code></pre></div>
<h3 id="data-bags">Data Bags</h3> <p>Data bags store global variables as JSON data. Data bags are indexed for searching and can be loaded by a cookbook or accessed during a search.</p> <p>Any search for a data bag (or a data bag item) must specify the name of the data bag and then provide the search query string that will be used during the search. For example, to use knife to search within a data bag named “admin_data” across all items, except for the “admin_users” item, enter the following:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-bash" data-lang="bash">knife search admin_data <span style="color:#4070a0">"(NOT id:admin_users)"</span>
</code></pre></div>
<p>Or, to include the same search query in a recipe, use a code block similar to:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-ruby" data-lang="ruby">search(<span style="color:#517918">:admin_data</span>, <span style="color:#4070a0">'NOT id:admin_users'</span>)
</code></pre></div>
<p>It may not be possible to know which data bag items will be needed. It may be necessary to load everything in a data bag (but not know what “everything” is). Using a search query is the ideal way to deal with that ambiguity, yet still ensure that all of the required data is returned. The following examples show how a recipe can use a series of search queries to search within a data bag named “admins”. For example, to find every administrator:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-ruby" data-lang="ruby">search(<span style="color:#517918">:admins</span>, <span style="color:#4070a0">'*:*'</span>)
</code></pre></div>
<p>Or to search for an administrator named “charlie”:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-ruby" data-lang="ruby">search(<span style="color:#517918">:admins</span>, <span style="color:#4070a0">'id:charlie'</span>)
</code></pre></div>
<p>Or to search for an administrator with a group identifier of “ops”:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-ruby" data-lang="ruby">search(<span style="color:#517918">:admins</span>, <span style="color:#4070a0">'gid:ops'</span>)
</code></pre></div>
<p>Or to search for an administrator whose name begins with the letter “c”:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-ruby" data-lang="ruby">search(<span style="color:#517918">:admins</span>, <span style="color:#4070a0">'id:c*'</span>)
</code></pre></div>
<p>Data bag items that are returned by a search query can be used as if they were a hash. For example:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-ruby" data-lang="ruby">charlie <span style="color:#666">=</span> search(<span style="color:#517918">:admins</span>, <span style="color:#4070a0">'id:charlie'</span>)<span style="color:#666">.</span>first
<span style="color:#60a0b0;font-style:italic"># =&gt; variable 'charlie' is set to the charlie data bag item</span>
charlie<span style="color:#666">[</span><span style="color:#4070a0">'gid'</span><span style="color:#666">]</span>
<span style="color:#60a0b0;font-style:italic"># =&gt; "ops"</span>
charlie<span style="color:#666">[</span><span style="color:#4070a0">'shell'</span><span style="color:#666">]</span>
<span style="color:#60a0b0;font-style:italic"># =&gt; "/bin/zsh"</span>
</code></pre></div>
<p>The following recipe can be used to create a user for each administrator by loading all of the items from the “admins” data bag, looping through each admin in the data bag, and then creating a user resource so that each of those admins exist:</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-ruby" data-lang="ruby">admins <span style="color:#666">=</span> data_bag(<span style="color:#4070a0">'admins'</span>)

admins<span style="color:#666">.</span>each <span style="color:#007020;font-weight:700">do</span> <span style="color:#666">|</span>login<span style="color:#666">|</span>
  admin <span style="color:#666">=</span> data_bag_item(<span style="color:#4070a0">'admins'</span>, login)
  home <span style="color:#666">=</span> <span style="color:#4070a0">"/home/</span><span style="color:#70a0d0;font-style:italic">#{</span>login<span style="color:#70a0d0;font-style:italic">}</span><span style="color:#4070a0">"</span>

  user(login) <span style="color:#007020;font-weight:700">do</span>
    uid       admin<span style="color:#666">[</span><span style="color:#4070a0">'uid'</span><span style="color:#666">]</span>
    gid       admin<span style="color:#666">[</span><span style="color:#4070a0">'gid'</span><span style="color:#666">]</span>
    shell     admin<span style="color:#666">[</span><span style="color:#4070a0">'shell'</span><span style="color:#666">]</span>
    comment   admin<span style="color:#666">[</span><span style="color:#4070a0">'comment'</span><span style="color:#666">]</span>
    home      home
    manage_home <span style="color:#007020">true</span>
  <span style="color:#007020;font-weight:700">end</span>
<span style="color:#007020;font-weight:700">end</span>
</code></pre></div>
<p>And then the same recipe, modified to load administrators using a search query (and using an array to store the results of the search query):</p> <div class="highlight"><pre tabindex="0" class="highlight" data-language="ruby"><code class="language-ruby" data-lang="ruby">admins <span style="color:#666">=</span> <span style="color:#666">[]</span>

search(<span style="color:#517918">:admins</span>, <span style="color:#4070a0">'*:*'</span>)<span style="color:#666">.</span>each <span style="color:#007020;font-weight:700">do</span> <span style="color:#666">|</span>admin<span style="color:#666">|</span>
  login <span style="color:#666">=</span> admin<span style="color:#666">[</span><span style="color:#4070a0">'id'</span><span style="color:#666">]</span>

  admins <span style="color:#666">&lt;&lt;</span> login

  home <span style="color:#666">=</span> <span style="color:#4070a0">"/home/</span><span style="color:#70a0d0;font-style:italic">#{</span>login<span style="color:#70a0d0;font-style:italic">}</span><span style="color:#4070a0">"</span>

  user(login) <span style="color:#007020;font-weight:700">do</span>
    uid       admin<span style="color:#666">[</span><span style="color:#4070a0">'uid'</span><span style="color:#666">]</span>
    gid       admin<span style="color:#666">[</span><span style="color:#4070a0">'gid'</span><span style="color:#666">]</span>
    shell     admin<span style="color:#666">[</span><span style="color:#4070a0">'shell'</span><span style="color:#666">]</span>
    comment   admin<span style="color:#666">[</span><span style="color:#4070a0">'comment'</span><span style="color:#666">]</span>

    home      home
    manage_home <span style="color:#007020">true</span>
  <span style="color:#007020;font-weight:700">end</span>
<span style="color:#007020;font-weight:700">end</span>
</code></pre></div> </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; Chef Software, Inc.<br>Licensed under the Creative Commons Attribution 3.0 Unported License.<br>The Chef&trade; Mark and Chef Logo are either registered trademarks/service marks or trademarks/servicemarks of Chef, in the United States and other countries and are used with Chef Inc's permission.<br>We are not affiliated with, endorsed or sponsored by Chef Inc.<br>
    <a href="https://docs.chef.io/chef_search/" class="_attribution-link">https://docs.chef.io/chef_search/</a>
  </p>
</div>
