<div id="col-content" data-swiftype-index="true"> <div id="leader-elections"><h1>Leader Elections</h1></div> <div class="prose"> <p data-swiftype-index="false"> <a href="https://github.com/habitat-sh/habitat/tree/main/components/docs-chef-io/content/habitat/sup_elections.md" alt="Link to page on GitHub repository">[edit on GitHub]</a> </p> <p>The Chef Habitat Supervisor performs leader election natively for service groups <a href="../service_group_topologies/index.html">topologies</a> that require one, such as <em>leader-follower</em>.</p> <p>Because Chef Habitat is an eventually-consistent distributed system, the role of the leader is different than in strongly-consistent systems. It only serves as the leader for <em>application level semantics</em>, e.g. a database write leader. The fact that a Supervisor is a leader has no bearing upon other operations in the Chef Habitat system, including rumor dissemination for configuration updates. It is <em>not</em> akin to a <a href="https://raft.github.io/">Raft</a> leader, through which writes must all be funneled. This allows for very high scalability of the Chef Habitat Supervisor ring.</p> <p>Services grouped using a leader need to have a minimum of three supervisors in order to break ties. It is also strongly recommended that you do not run the service group with an even number of members. Otherwise, in the event of a network partition with equal members on each side, both sides will elect a new leader, causing a full split-brain from which the algorithm cannot recover. Supervisors in a service group will warn you if you are using leader election and have an even number of supervisors.</p> <h3 id="protocol-for-electing-a-leader">Protocol for electing a leader</h3> <p>When a service group starts in a leader topology, it will wait until there are sufficient members to form a quorum (at least three). At this point, an election cycle can happen. Each Supervisor injects an election rumor into ring, targeted at the service group, with the <em>exact same</em> rumor, which demands an election and insists that the peer itself is the leader. This algorithm is known as <a href="https://en.wikipedia.org/wiki/Bully_algorithm">Bully</a>.</p> <p>Every peer that receives this rumor does a simple lexicographic comparison of its GUID with the GUID of the peer contained in that rumor. The winner is the peer whose GUID is higher. The peer then adds a vote for the GUID of the winner, and shares the rumor with others, including the total number of votes of anyone who previously voted for this winner.</p> <p>An election ends when a candidate peer X gets a rumor back from the ring saying that it (X) is the winner, with all members voting. At this point, it sends out a rumor saying it is the declared winner, and the election cycle ends.</p> <h3 id="related-reading">Related reading</h3> <ul> <li>For more information about the Bully algorithm, see <a href="http://dl.acm.org/citation.cfm?id=1309451">Elections in a Distributed Computing System</a> by Héctor García-Molina.</li> </ul> </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; Chef Software, Inc.<br>Licensed under the Creative Commons Attribution 3.0 Unported License.<br>The Chef&trade; Mark and Chef Logo are either registered trademarks/service marks or trademarks/servicemarks of Chef, in the United States and other countries and are used with Chef Inc's permission.<br>We are not affiliated with, endorsed or sponsored by Chef Inc.<br>
    <a href="https://docs.chef.io/habitat/sup_elections/" class="_attribution-link">https://docs.chef.io/habitat/sup_elections/</a>
  </p>
</div>
