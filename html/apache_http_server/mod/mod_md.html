<h1>Apache Module mod_md</h1>  <table class="module">
<tr>
<th>Description:</th>
<td>Managing domains across virtual hosts, certificate provisioning via the ACME protocol </td>
</tr> <tr>
<th>Status:</th>
<td>Experimental</td>
</tr> <tr>
<th>Module Identifier:</th>
<td>md_module</td>
</tr> <tr>
<th>Source File:</th>
<td>mod_md.c</td>
</tr> <tr>
<th>Compatibility:</th>
<td>Available in version 2.4.30 and later</td>
</tr>
</table> <h3>Summary</h3> <p> This module manages common properties of domains for one or more virtual hosts. Its serves two main purposes: for one, supervise/renew TLS certificates via the ACME protocol (<a href="https://tools.ietf.org/html/rfc8555">RFC 8555</a>). Certificates will be renewed by the module ahead of their expiration to account for disruption in internet services. There are ways to monitor the status of all certififcates managed this way and configurations that will run your own notification commands on renewal, expiration and errors. </p>
<p> Second, mod_md offers an alternate OCSP Stapling implementation. This works with managed certificates as well as with certificates you configure yourself. OCSP Stapling is a necessary component for any https: site, influencing page load times and, depending on other setups, page availability. More in the stapling section below. </p>
<p> The default ACME Authority for managing certificates is <a href="https://letsencrypt.org/">Let's Encrypt</a>, but it is possible to configure another CA that supports the protocol. </p> <p>Simple configuration example:</p> <div class="note">
<p><strong>TLS in a VirtualHost context</strong></p> <pre class="prettyprint lang-config">MDomain example.org

&lt;VirtualHost *:443&gt;
    ServerName example.org
    DocumentRoot htdocs/a

    SSLEngine on
    # no certificates specification
&lt;/VirtualHost&gt;</pre> <p> This setup will, on server start, contact <a href="https://letsencrypt.org/">Let's Encrypt</a> to request a certificate for the domain. If Let's Encrypt can verify the ownership of the domain, the module will retrieve the certificate and its chain, store it in the local file system (see <code class="directive"><a href="#mdstoredir">MDStoreDir</a></code>) and provide it, on next restart, to <code class="module"><a href="mod_ssl.html">mod_ssl</a></code>. </p>
<p> This happens while the server is already running. All other hosts will continue to work as before. While a certificate is not available, requests for the managed domain will be answered with a '503 Service Unavailable'. </p> </div> <div class="note">
<p><strong>Prerequisites</strong></p> <p> This module requires <code class="module"><a href="mod_watchdog.html">mod_watchdog</a></code> to be loaded as well. </p>
<p> Certificate sign-up and renewal with Let's Encrypt requires your server to be reachable on port 80 (http:) and/or port 443 (https:) from the public internet. (Unless your server is configured to use DNS for challenges - more on that under 'wildcard certificates') </p>
<p> The module will select from the methods offered by Let's Encrypt. Usually LE offers challenges on both ports and DNS and Apache chooses a method available. </p>
<p> To determine which one is available, the module looks at the ports Apache httpd listens on. If those include port 80, it assumes that the http: challenge (named http-01) is available. If the server listens on port 443, the https: challenge (named tls-alpn-01) is also added to the list. (And if <code class="directive"><a href="#mdchallengedns01">MDChallengeDns01</a></code> is configured, the challenge dns-01 is added as well.) </p>
<p> If your setup is not so straight forward, there are two methods available to influence this. First, look at <code class="directive"><a href="#mdportmap">MDPortMap</a></code> if the server is behind a portmapper, such as a firewall. Second, you may override the module's guesswork completely by configuring <code class="directive"><a href="#mdcachallenges">MDCAChallenges</a></code> directly. </p> </div> <div class="note">
<p><strong>https: Challenges</strong></p> <p> For domain verification via the TLS protocol `tls-alpn-01` is the name of the challenge type. It requires the Apache server to listen on port 443 (see <code class="directive"><a href="#mdportmap">MDPortMap</a></code> if you map that port to something else). </p>
<p> Let's Encrypt will open a TLS connection to Apache using the special indicator `acme-tls/1` (this indication part of TLS is called ALPN, therefore the name of the challenge. ALPN is also used by browsers to request a HTTP/2 connection). </p>
<p> As with the HTTP/2 protocol, to allow this, you configure: </p> <pre class="prettyprint lang-config">Protocols h2 http/1.1 acme-tls/1</pre> <p> And the `tls-alpn-01` challenge type is available. </p> </div> <div class="note">
<p><strong>Wildcard Certificates</strong></p> <p> Wildcard certificates are possible, but not straight-forward to use out of the box. Let's Encrypt requires the `dns-01` challenge verification for those. No other is considered good enough. </p>
<p> The difficulty here is that Apache cannot do that on its own. As the name implies, `dns-01` requires you to show some specific DNS records for your domain that contain some challenge data. So you need to _write_ your domain's DNS records. </p>
<p> If you know how to do that, you can integrated this with mod_md. Let's say you have a script for that in `/usr/bin/acme-setup-dns` you configure Apache with: </p> <pre class="prettyprint lang-config">MDChallengeDns01 /usr/bin/acme-setup-dns</pre> <p> and Apache will call this script when it needs to setup/teardown a DNS challenge record for a domain. </p>
<p> Assuming you want a certificate for `*.mydomain.com`, mod_md will call: </p> <pre class="prettyprint lang-config">/usr/bin/acme-setup-dns setup mydomain.com challenge-data
# this needs to remove all existing DNS TXT records for 
# _acme-challenge.mydomain.com and create a new one with 
# content "challenge-data"</pre> <p> and afterwards it will call </p> <pre class="prettyprint lang-config">/usr/bin/acme-setup-dns teardown mydomain.com
# this needs to remove all existing DNS TXT records for 
# _acme-challenge.mydomain.com</pre> </div> <div class="note">
<p><strong>Monitoring</strong></p> <p> Apache has a standard module for monitoring: <code class="module"><a href="mod_status.html">mod_status</a></code>. mod_md contributes a section and makes monitoring your domains easy. </p>
<p> You see all your MDs listed alphabetically, the domain names they contain, an overall status, expiration times and specific settings. The settings show your selection of renewal times (or the default), the CA that is used, etc. </p>
<p> The 'Renewal' column will show activity and error descriptions for certificate renewals. This should make life easier for people to find out if everything is all right or what went wrong. </p>
<p> If there is an error with an MD it will be shown here as well. This let's you assess problems without digging through your server logs. </p>
<p> There is also a new 'md-status' handler available to give you the MD information from 'server-status' in JSON format. You configure it as </p> <pre class="prettyprint lang-config">&lt;Location "/md-status"&gt;
  SetHandler md-status
&lt;/Location&gt;</pre> <p> on your server. As with 'server-status' you will want to add authorization for this. </p>
<p> If you just want to check the JSON status of a specific domain, simply append that to your status url: </p> <pre class="prettyprint lang-config">&gt; curl https://&lt;yourhost&gt;/md-status/another-domain.org
{
  "name": "another-domain.org",
  "domains": [
    "another-domain.org",
    "www.another-domain.org"
  ],
  ...</pre> <p> This JSON status also shows a log of activities when domains are renewed: </p> <pre class="prettyprint lang-config">{
"when": "Wed, 19 Jun 2019 14:45:58 GMT",
"type": "progress", "detail": "The certificate for the managed domain has been renewed successfully and can be used. A graceful server restart now is recommended."
},{
"when": "Wed, 19 Jun 2019 14:45:58 GMT",
"type": "progress", "detail": "Retrieving certificate chain for test-901-003-1560955549.org"
},{
"when": "Wed, 19 Jun 2019 14:45:58 GMT",
"type": "progress", "detail": "Waiting for finalized order to become valid"
},{
"when": "Wed, 19 Jun 2019 14:45:50 GMT",
"type": "progress", "detail": "Submitting CSR to CA for test-901-003-1560955549.org"
},
...</pre> <p> You will also find this information in the file `job.json` in your staging and, when activated, domains directory. This allows you to inspect these at any later point in time as well. </p>
<p> In addition, there is <code class="directive"><a href="#mdcertificatestatus">MDCertificateStatus</a></code> which gives access to relevant certificate information in JSON format. </p> </div> <div class="note">
<p><strong>Stapling</strong></p> <p> If you want to try the stapling in one Managed Domain alone at first, configure: </p> <pre class="prettyprint lang-config">&lt;MDomain mydomain.net&gt;
  MDStapling on
&lt;/MDomain&gt;</pre> <p> and use the 'server-status' and/or <code class="directive"><a href="#mdmessagecmd">MDMessageCmd</a></code> to see how it operates. You will see if Stapling information is there, how long it is valid, from where it came and when it will be refreshed. </p>
<p> If this all works to your satisfaction, you can switch it on for all your certificates or just your managed ones. </p>
<p> The existing stapling implementation by mod_ssl is used by many sites for years. There are two main differences between the mod_ssl and mod_md one: </p> <ol> <li>On demand vs. scheduled: mod_ssl retrieves the stapling information when it is requested, e.g. on a new connection. mod_md retrieves it right at server start and after 2/3rds of its lifetime.</li> <li>In memory vs. persisted: mod_ssl <em>can</em> persist this information, but most example configurations use a memory cache. mod_md always stores in the file system.</li> </ol> <p> If you are unlucky and restart your server during an outage of your CA's OCSP service, your users may no longer reach your sites. Without persistence your server cannot provide the client with the data and the client browser cannot get it as well, since the OCSP service is not responding. </p>
<p> The implementation in mod_md will have persisted it, load it again after restart and have it available for incoming connections. A day or two before this information expires, it will renew it, making it able to cope with a long OCSP service downtime. </p>
<p> Due to backward compatibility, the existing implementation in mod_ssl could not be changed drastically. For example, mod_ssl is unable to add a dependency to mod_watchdog without braking many existing installations (that do not load it). </p> </div>    <div class="directive-section">
<h2 id="mdactivationdelay">MDActivationDelay Directive</h2> <table class="directive"> <tr>
<th>Description:</th>
<td></td>
</tr> <tr>
<th>Syntax:</th>
<td><pre>MDActivationDelay duration</pre></td>
</tr> <tr>
<th>Context:</th>
<td>server config</td>
</tr> <tr>
<th>Status:</th>
<td>Experimental</td>
</tr> <tr>
<th>Module:</th>
<td>mod_md</td>
</tr> <tr>
<th>Compatibility:</th>
<td>Available in version 2.4.42 and later</td>
</tr> </table>  </div>  <div class="directive-section">
<h2 id="mdbaseserver">MDBaseServer Directive</h2> <table class="directive"> <tr>
<th>Description:</th>
<td>Control if base server may be managed or only virtual hosts.</td>
</tr> <tr>
<th>Syntax:</th>
<td><pre>MDBaseServer on|off</pre></td>
</tr> <tr>
<th>Default:</th>
<td><pre>MDBaseServer off</pre></td>
</tr> <tr>
<th>Context:</th>
<td>server config</td>
</tr> <tr>
<th>Status:</th>
<td>Experimental</td>
</tr> <tr>
<th>Module:</th>
<td>mod_md</td>
</tr> </table> <p> Controls if the base server, the one outside all VirtualHosts should be managed by mod_md or not. By default, it will not. For the very reason that it may have confusing side-effects. It is recommended that you have virtual hosts for all managed domains and do not rely on the global, fallback server configuration. </p> </div>  <div class="directive-section">
<h2 id="mdcachallenges">MDCAChallenges Directive</h2> <table class="directive"> <tr>
<th>Description:</th>
<td>Type of ACME challenge used to prove domain ownership.</td>
</tr> <tr>
<th>Syntax:</th>
<td><pre>MDCAChallenges name [ name ... ]</pre></td>
</tr> <tr>
<th>Default:</th>
<td><pre>MDCAChallenges tls-alpn-01 http-01 dns-01</pre></td>
</tr> <tr>
<th>Context:</th>
<td>server config</td>
</tr> <tr>
<th>Status:</th>
<td>Experimental</td>
</tr> <tr>
<th>Module:</th>
<td>mod_md</td>
</tr> </table> <p> Sets challenge types (in order of preference) when proving domain ownership. Supported by the module are the challenge methods 'tls-alpn-01', 'dns-01' and 'http-01'. The module will look at the overall configuration of the server to find out which methods can be used. </p>
<p> If the server listens on port 80, for example, the 'http-01' method is available. The prerequisite for 'dns-01' is a configured <code class="directive"><a href="#mdchallengedns01">MDChallengeDns01</a></code> command. 'tls-alpn-01' is described above in 'https: Challenges'. </p>
<p> This auto selection works for most setups. But since Apache is a very powerful server with many configuration options, the situation is not clear for all possible cases. For example: it may listen on multiple IP addresses where some are reachable on `https:` and some not. </p>
<p> If you configure <code class="directive">MDCAChallenges</code> directly, this auto selection is disabled. Instead, the module will use the configured challenge list when talking to the ACME server (a challenge type must be offered by the server as well). This challenges are examined in the order specified. </p> </div>  <div class="directive-section">
<h2 id="mdcertificateagreement">MDCertificateAgreement Directive</h2> <table class="directive"> <tr>
<th>Description:</th>
<td>You confirm that you accepted the Terms of Service of the Certificate Authority.</td>
</tr> <tr>
<th>Syntax:</th>
<td><pre>MDCertificateAgreement accepted</pre></td>
</tr> <tr>
<th>Context:</th>
<td>server config</td>
</tr> <tr>
<th>Status:</th>
<td>Experimental</td>
</tr> <tr>
<th>Module:</th>
<td>mod_md</td>
</tr> </table> <p>When you use mod_md to obtain a certificate, you become a customer of the CA (e.g. Let's Encrypt). That means you need to read and agree to their Terms of Service, so that you understand what they offer and what they might exclude or require from you. mod_md cannot, by itself, agree to such a thing. </p> </div>  <div class="directive-section">
<h2 id="mdcertificateauthority">MDCertificateAuthority Directive</h2> <table class="directive"> <tr>
<th>Description:</th>
<td>The URL of the ACME Certificate Authority service.</td>
</tr> <tr>
<th>Syntax:</th>
<td><pre>MDCertificateAuthority url</pre></td>
</tr> <tr>
<th>Default:</th>
<td><pre>MDCertificateAuthority https://acme-v02.api.letsencrypt.org/directory</pre></td>
</tr> <tr>
<th>Context:</th>
<td>server config</td>
</tr> <tr>
<th>Status:</th>
<td>Experimental</td>
</tr> <tr>
<th>Module:</th>
<td>mod_md</td>
</tr> </table> <p> The URL where the CA offers its service. </p>
<p> Let's Encrypt offers, right now, four such URLs. Two for the own legacy version of the ACME protocol, commonly named ACMEv1. And two for the RFC 8555 version, named ACMEv2. </p>
<p> Each version has 2 endpoints, as their is a production endpoint and a "staging" endpoint for testing. The testing endpoint works the same, but will not give you certificates recognized by browsers. However, it also has very relaxed rate limits. This allows testing of the service repeatedly without you blocking yourself. </p> <div class="example">
<h3>LE Staging Setup</h3>
<pre class="prettyprint lang-config">MDCertificateAuthority https://acme-staging-v02.api.letsencrypt.org/directory</pre> </div> </div>  <div class="directive-section">
<h2 id="mdcertificatecheck">MDCertificateCheck Directive</h2> <table class="directive"> <tr>
<th>Description:</th>
<td></td>
</tr> <tr>
<th>Syntax:</th>
<td><pre>MDCertificateCheck name url</pre></td>
</tr> <tr>
<th>Context:</th>
<td>server config</td>
</tr> <tr>
<th>Status:</th>
<td>Experimental</td>
</tr> <tr>
<th>Module:</th>
<td>mod_md</td>
</tr> <tr>
<th>Compatibility:</th>
<td>Available in version 2.4.42 and later</td>
</tr> </table>  </div>  <div class="directive-section">
<h2 id="mdcertificatefile">MDCertificateFile Directive</h2> <table class="directive"> <tr>
<th>Description:</th>
<td>Specify a static certificate file for the MD.</td>
</tr> <tr>
<th>Syntax:</th>
<td><pre>MDCertificateFile path-to-pem-file</pre></td>
</tr> <tr>
<th>Context:</th>
<td>server config</td>
</tr> <tr>
<th>Status:</th>
<td>Experimental</td>
</tr> <tr>
<th>Module:</th>
<td>mod_md</td>
</tr> </table> <p> This is used inside a <code class="directive"><a href="#mdomainset">MDomainSet</a></code> and specifies the file holding the certificate chain for the Managed Domain. The matching key is specified via <code class="directive"><a href="#mdcertificatekeyfile">MDCertificateKeyFile</a></code>. </p> <div class="example">
<h3>Example</h3>
<pre class="prettyprint lang-config">&lt;MDomain mydomain.com&gt;
  MDCertificateFile /etc/ssl/my.cert
  MDCertificateKeyFile /etc/ssl/my.key
&lt;/MDomain&gt;</pre> </div> <p> This is that equivalent of the mod_ssl <code class="directive"><a href="mod_ssl.html#sslcertificatefile">SSLCertificateFile</a></code> directive. It has several uses. </p>
<p> If you want to migrate an existing domain, using static files, to automated Let's Encrypt certificates, for one. You define the <code class="directive"><a href="#mdomainset">MDomainSet</a></code>, add the files here and remove the <code class="directive"><a href="mod_ssl.html#sslcertificatefile">SSLCertificateFile</a></code> from your VirtualHosts. </p>
<p> This will give you the same as before, with maybe less repeating lines in your configuration. Then you can add <code class="directive"><a href="#mdrenewmode">MDRenewMode</a></code> 'always' to it and the module will get a new certificate before the one from the file expires. When it has done so, you remove the <code class="directive">MDCertificateFile</code> and reload the server. </p>
<p> Another use case is that you renew your Let's Encrypt certificates with another ACME clients, for example the excellent <a href="https://certbot.eff.org">certbot</a>. Then let your MDs point to the files from certbot and have both working together. </p> </div>  <div class="directive-section">
<h2 id="mdcertificatekeyfile">MDCertificateKeyFile Directive</h2> <table class="directive"> <tr>
<th>Description:</th>
<td>Specify a static private key for for the static cerrtificate.</td>
</tr> <tr>
<th>Syntax:</th>
<td><pre>MDCertificateKeyFile path-to-file</pre></td>
</tr> <tr>
<th>Context:</th>
<td>server config</td>
</tr> <tr>
<th>Status:</th>
<td>Experimental</td>
</tr> <tr>
<th>Module:</th>
<td>mod_md</td>
</tr> </table> <p> This is used inside a <code class="directive"><a href="#mdomainset">MDomainSet</a></code> and specifies the file holding the private key for the Managed Domain. The matching certificate is specified via <code class="directive"><a href="#mdcertificatefile">MDCertificateFile</a></code>. </p>
<p> This is that equivalent of the mod_ssl <code class="directive"><a href="mod_ssl.html#sslcertificatekeyfile">SSLCertificateKeyFile</a></code> directive. </p> </div>  <div class="directive-section">
<h2 id="mdcertificatemonitor">MDCertificateMonitor Directive</h2> <table class="directive"> <tr>
<th>Description:</th>
<td>The URL of a certificate log monitor.</td>
</tr> <tr>
<th>Syntax:</th>
<td><pre>MDCertificateMonitor name url</pre></td>
</tr> <tr>
<th>Default:</th>
<td><pre>MDCertificateMonitor crt.sh https://crt.sh?q=</pre></td>
</tr> <tr>
<th>Context:</th>
<td>server config</td>
</tr> <tr>
<th>Status:</th>
<td>Experimental</td>
</tr> <tr>
<th>Module:</th>
<td>mod_md</td>
</tr> </table> <p> This is part of the 'server-status' HTML user interface and has nothing to do with the core functioning itself. It defines the link offered on that page for easy checking of a certificate monitor. The SHA256 fingerprint of the certificate is appended to the configured url. </p>
<p> Certificate Monitors offer supervision of Certificate Transparency (CT) Logs to track the use of certificates for domains. The least you may see is that Let's Encrypt (or whichever CA you have configured) has entered your certificates into the CTLogs. </p>
<p> Caveat: certificate logs update and monitor's intakes of those updates suffer some delay. This varies between logs and monitors. A brand new certificate will not be known immediately. </p> </div>  <div class="directive-section">
<h2 id="mdcertificateprotocol">MDCertificateProtocol Directive</h2> <table class="directive"> <tr>
<th>Description:</th>
<td>The protocol to use with the Certificate Authority.</td>
</tr> <tr>
<th>Syntax:</th>
<td><pre>MDCertificateProtocol protocol</pre></td>
</tr> <tr>
<th>Default:</th>
<td><pre>MDCertificateProtocol ACME</pre></td>
</tr> <tr>
<th>Context:</th>
<td>server config</td>
</tr> <tr>
<th>Status:</th>
<td>Experimental</td>
</tr> <tr>
<th>Module:</th>
<td>mod_md</td>
</tr> </table> <p> Specifies the protocol to use. Currently, only <code>ACME</code> is supported. </p> </div>  <div class="directive-section">
<h2 id="mdcertificatestatus">MDCertificateStatus Directive</h2> <table class="directive"> <tr>
<th>Description:</th>
<td>Exposes public certificate information in JSON.</td>
</tr> <tr>
<th>Syntax:</th>
<td><pre>MDCertificateStatus on|off</pre></td>
</tr> <tr>
<th>Default:</th>
<td><pre>MDCertificateStatus on</pre></td>
</tr> <tr>
<th>Context:</th>
<td>server config</td>
</tr> <tr>
<th>Status:</th>
<td>Experimental</td>
</tr> <tr>
<th>Module:</th>
<td>mod_md</td>
</tr> </table> <p> When enabled, a resources is available in Managed Domains at 'https://domain/.httpd/certificate-status' that returns a JSON document list key properties of the current and of a renewed certificate - when available. </p> <div class="example">
<h3>Example</h3>
<pre class="prettyprint lang-config">{
  "valid-until": "Thu, 29 Aug 2019 16:06:35 GMT",
  "valid-from": "Fri, 31 May 2019 16:06:35 GMT",
  "serial": "03039C464D454EDE79FCD2CAE859F668F269",
  "sha256-fingerprint": "1ff3bfd2c7c199489ed04df6e29a9b4ea6c015fe8a1b0ce3deb88afc751e352d"
  "renewal" : { ...renewed cert information... }
}</pre> </div> </div>  <div class="directive-section">
<h2 id="mdchallengedns01">MDChallengeDns01 Directive</h2> <table class="directive"> <tr>
<th>Description:</th>
<td></td>
</tr> <tr>
<th>Syntax:</th>
<td><pre>MDChallengeDns01 path-to-command</pre></td>
</tr> <tr>
<th>Context:</th>
<td>server config</td>
</tr> <tr>
<th>Status:</th>
<td>Experimental</td>
</tr> <tr>
<th>Module:</th>
<td>mod_md</td>
</tr> </table> <p> Define a program to be called when the `dns-01` challenge needs to be setup/torn down. The program is given the argument `setup` or `teardown` followed by the domain name. For `setup` the challenge content is additionally given. </p>
<p> You do not need to specify this, as long as a 'http:' or 'https:' challenge method is possible. However, Let's Encrypt makes 'dns-01' the only challenge available for wildcard certificates. If you require one of those, you need to configure this. </p>
<p> See the section about wildcard certificates above for more details. </p> </div>  <div class="directive-section">
<h2 id="mdcontactemail">MDContactEmail Directive</h2> <table class="directive"> <tr>
<th>Description:</th>
<td></td>
</tr> <tr>
<th>Syntax:</th>
<td><pre>MDContactEmail address</pre></td>
</tr> <tr>
<th>Context:</th>
<td>server config</td>
</tr> <tr>
<th>Status:</th>
<td>Experimental</td>
</tr> <tr>
<th>Module:</th>
<td>mod_md</td>
</tr> </table> <p> The ACME protocol requires you to give a contact url when you sign up. Currently, Let's Encrypt wants an email address (and it will use it to inform you about renewals or changed terms of service). <code class="module"><a href="mod_md.html">mod_md</a></code> uses the <code class="directive">MDContactEmail</code> directive email in your Apache configuration, so please specify the correct address there. If <code class="directive">MDContactEmail</code> is not present, <code class="module"><a href="mod_md.html">mod_md</a></code> will use the <code class="directive"><a href="core.html#serveradmin">ServerAdmin</a></code> directive. </p> </div>  <div class="directive-section">
<h2 id="mddrivemode">MDDriveMode Directive</h2> <table class="directive"> <tr>
<th>Description:</th>
<td>former name of MDRenewMode.</td>
</tr> <tr>
<th>Syntax:</th>
<td><pre>MDDriveMode always|auto|manual</pre></td>
</tr> <tr>
<th>Default:</th>
<td><pre>MDDriveMode auto</pre></td>
</tr> <tr>
<th>Context:</th>
<td>server config</td>
</tr> <tr>
<th>Status:</th>
<td>Experimental</td>
</tr> <tr>
<th>Module:</th>
<td>mod_md</td>
</tr> </table> <p>This directive exists for backward compatibility as the old name for <code class="directive"><a href="#mdrenewmode">MDRenewMode</a></code>. </p> </div>  <div class="directive-section">
<h2 id="mdexternalaccountbinding">MDExternalAccountBinding Directive</h2> <table class="directive"> <tr>
<th>Description:</th>
<td></td>
</tr> <tr>
<th>Syntax:</th>
<td><pre>MDExternalAccountBinding key-id hmac-64 | none | file</pre></td>
</tr> <tr>
<th>Default:</th>
<td><pre>MDExternalAccountBinding none</pre></td>
</tr> <tr>
<th>Context:</th>
<td>server config</td>
</tr> <tr>
<th>Status:</th>
<td>Experimental</td>
</tr> <tr>
<th>Module:</th>
<td>mod_md</td>
</tr> <tr>
<th>Compatibility:</th>
<td>Available in version 2.4.52 and later</td>
</tr> </table> <p> Configure values for ACME "External Account Binding", a feature of the ACME standard that allows clients to bind registrations to an existing customer account on ACME servers. </p> <p> Let's Encrypt does not require those, but other ACME CAs do. Check with your ACME CA if you need those and how to obtain the values. They are two strings, a key identifier and a base64 encoded 'hmac' value. </p> <p> You can configure those globally or for a specific MDomain. Since these values allow anyone to register under the same account, it is adivsable to give the configuration file restricted permissions, e.g. root only. </p> <p> The value can also be taken from a JSON file, to keep more open permissions on the server configuration and restrict the ones on that file. The JSON itself is: </p> <div class="example">
<h3>EAB JSON Example file</h3>
<pre class="prettyprint lang-config">{"kid": "kid-1", "hmac": "zWND..."}</pre> </div> <p> If you change EAB values, the new ones will be used when the next certificate renewal is due. </p> </div>  <div class="directive-section">
<h2 id="mdhttpproxy">MDHttpProxy Directive</h2> <table class="directive"> <tr>
<th>Description:</th>
<td>Define a proxy for outgoing connections.</td>
</tr> <tr>
<th>Syntax:</th>
<td><pre>MDHttpProxy url</pre></td>
</tr> <tr>
<th>Context:</th>
<td>server config</td>
</tr> <tr>
<th>Status:</th>
<td>Experimental</td>
</tr> <tr>
<th>Module:</th>
<td>mod_md</td>
</tr> </table> <p>Use a http proxy to connect to the <code class="directive"><a href="#mdcertificateauthority">MDCertificateAuthority</a></code>. Define this if your webserver can only reach the internet with a forward proxy. </p> </div>  <div class="directive-section">
<h2 id="mdmember">MDMember Directive</h2> <table class="directive"> <tr>
<th>Description:</th>
<td>Additional hostname for the managed domain.</td>
</tr> <tr>
<th>Syntax:</th>
<td><pre>MDMember hostname</pre></td>
</tr> <tr>
<th>Context:</th>
<td>server config</td>
</tr> <tr>
<th>Status:</th>
<td>Experimental</td>
</tr> <tr>
<th>Module:</th>
<td>mod_md</td>
</tr> </table> <p> Instead of listing all dns names on the same line, you may use <code class="directive">MDMember</code> to add such names to a managed domain. </p> <div class="example">
<h3>Example</h3>
<pre class="prettyprint lang-config">&lt;MDomain example.org&gt;
    MDMember www.example.org
    MDMember mail.example.org
&lt;/MDomain&gt;</pre> </div> <p> If you use it in the global context, outside a specific MD, you can only specify one value, 'auto' or 'manual' as the default for all other MDs. See <code class="directive"><a href="#mdomain">MDomain</a></code> for a description of these special values. </p> </div>  <div class="directive-section">
<h2 id="mdmembers">MDMembers Directive</h2> <table class="directive"> <tr>
<th>Description:</th>
<td>Control if the alias domain names are automatically added.</td>
</tr> <tr>
<th>Syntax:</th>
<td><pre>MDMembers auto|manual</pre></td>
</tr> <tr>
<th>Default:</th>
<td><pre>MDMembers auto</pre></td>
</tr> <tr>
<th>Context:</th>
<td>server config</td>
</tr> <tr>
<th>Status:</th>
<td>Experimental</td>
</tr> <tr>
<th>Module:</th>
<td>mod_md</td>
</tr> </table> <p>Defines if the <code class="directive"><a href="core.html#servername">ServerName</a></code> and <code class="directive"><a href="core.html#serveralias">ServerAlias</a></code> values of a VirtualHost are automatically added to the members of a Managed Domain or not. </p> </div>  <div class="directive-section">
<h2 id="mdmessagecmd">MDMessageCmd Directive</h2> <table class="directive"> <tr>
<th>Description:</th>
<td>Handle events for Manage Domains</td>
</tr> <tr>
<th>Syntax:</th>
<td><pre>MDMessageCmd path-to-cmd optional-args</pre></td>
</tr> <tr>
<th>Context:</th>
<td>server config</td>
</tr> <tr>
<th>Status:</th>
<td>Experimental</td>
</tr> <tr>
<th>Module:</th>
<td>mod_md</td>
</tr> </table> <p> This command gets called when one of the following events happen for a Managed Domain: "renewed", "installed", "expiring", "errored". The command may be invoked for more than these in the future and ignore events it is not prepared to handle. </p>
<p> This is the more flexible companion to <code class="directive"><a href="#mdnotifycmd">MDNotifyCmd</a></code>. </p> <div class="example">
<h3>Example</h3>
<pre class="prettyprint lang-config">MDMessageCmd /etc/apache/md-message</pre> <pre># will be invoked when a new certificate for mydomain.org is available as: /etc/apache/md-message renewed mydomain.com</pre>
</div> <p> The program should not block, as the module will wait for it to finish. A return code other than 0 is regarded as an error. </p>
<p> 'errored' is no immediate cause for concern since renewal is attempted early enough to allow the internet to come back. This is reported at most once per hour. </p>
<p> 'expiring' should be taken serious. It is issued when the <code class="directive"><a href="#mdwarnwindow">MDWarnWindow</a></code> is reached. By default this is 10% of the certificate lifetime, so for Let's Encrypt this currently means 9 days before it expires. The warning is repeated at most once a day. </p>
<p> 'renewed' means that a new certificate has been obtained and is stored in the 'staging' area in the MD store. It will be activated on the next server restart/reload. </p>
<p> 'installed' is triggered when a new certificate has been transferred from staging into the domains location in MD store. This happens at server startup/reload. Different to all other invocations, <code class="directive">MDMessageCmd</code> is run with root permissions (on *nix systems) and has access to the certificate files (and keys). Certificates needed for other applications or in different formats can be processed on this event. </p>
<p> 'renewing' event is triggered before starting renew process for the managed domain. Should the command return != 0 for this reason, renew will be aborted and repeated on next cycle. Some cluster setups use this to allow renewals to run only on a single node. </p>
<p> 'challenge-setup:type:domain' event is triggered when the challenge data for a domain has been created. This is invoked before the ACME server is told to check for it. The type is one of the ACME challenge types. This is invoked for every DNS name in a MDomain. Cluster setups may use this event to distribute challenge files to all nodes in a cluster. </p>
<p> ocsp-errored happens when MDStapling is enabled for a domain, this indicates that an error was encountered retrieving the OCSP response from the Certificate Authority. mod_md will continue trying. </p> </div>  <div class="directive-section">
<h2 id="mdmuststaple">MDMustStaple Directive</h2> <table class="directive"> <tr>
<th>Description:</th>
<td>Control if new certificates carry the OCSP Must Staple flag.</td>
</tr> <tr>
<th>Syntax:</th>
<td><pre>MDMustStaple on|off</pre></td>
</tr> <tr>
<th>Default:</th>
<td><pre>MDMustStaple off</pre></td>
</tr> <tr>
<th>Context:</th>
<td>server config</td>
</tr> <tr>
<th>Status:</th>
<td>Experimental</td>
</tr> <tr>
<th>Module:</th>
<td>mod_md</td>
</tr> </table> <p>Defines if newly requested certificate should have the OCSP Must Staple flag set or not. If a certificate has this flag, the server is required to send a OCSP stapling response to every client. This only works if you configure <code class="module"><a href="mod_ssl.html">mod_ssl</a></code> to generate this (see <code class="directive"><a href="mod_ssl.html#sslusestapling">SSLUseStapling</a></code> and friends). </p> </div>  <div class="directive-section">
<h2 id="mdnotifycmd">MDNotifyCmd Directive</h2> <table class="directive"> <tr>
<th>Description:</th>
<td>Run a program when a Managed Domain is ready.</td>
</tr> <tr>
<th>Syntax:</th>
<td><pre>MDNotifyCmd path [ args ]</pre></td>
</tr> <tr>
<th>Context:</th>
<td>server config</td>
</tr> <tr>
<th>Status:</th>
<td>Experimental</td>
</tr> <tr>
<th>Module:</th>
<td>mod_md</td>
</tr> </table> <p> The configured executable is run when a Managed Domain has signed up or renewed its certificate. It is given the name of the processed MD as additional arguments (after the parameters specified here). It should return status code 0 to indicate that it has run successfully. </p> </div>  <div class="directive-section">
<h2 id="mdomain">MDomain Directive</h2> <table class="directive"> <tr>
<th>Description:</th>
<td>Define list of domain names that belong to one group.</td>
</tr> <tr>
<th>Syntax:</th>
<td><pre>MDomain dns-name [ other-dns-name... ] [auto|manual]</pre></td>
</tr> <tr>
<th>Context:</th>
<td>server config</td>
</tr> <tr>
<th>Status:</th>
<td>Experimental</td>
</tr> <tr>
<th>Module:</th>
<td>mod_md</td>
</tr> </table> <p> All the names in the list are managed as one Managed Domain (MD). mod_md will request one single certificate that is valid for all these names. This directive uses the global settings (see other MD directives below). If you need specific settings for one MD, use the <code class="directive"><a href="#mdomainset">&lt;MDomainSet&gt;</a></code>. </p>
<p> There are 2 additional settings that are necessary for a Managed Domain: a contact Email address (via <code class="directive"><a href="#mdcontactemail">MDContactEmail</a></code> or <code class="directive"><a href="core.html#serveradmin">ServerAdmin</a></code>) and <code class="directive"><a href="#mdcertificateagreement">MDCertificateAgreement</a></code>. The mail address of <code class="directive"><a href="core.html#serveradmin">ServerAdmin</a></code> is used to register at the CA (Let's Encrypt by default). The CA may use it to notify you about changes in its service or status of your certificates. </p>
<p> The second setting, <code class="directive"><a href="#mdcertificateagreement">MDCertificateAgreement</a></code>, should have the value "accepted". By specifying this, you confirm that your accept the Terms of Service of the CA. </p> <div class="example">
<h3>Example</h3>
<pre class="prettyprint lang-config">MDContactEmail admin@example.org
MDCertificateAgreement accepted
MDomain example.org www.example.org

&lt;VirtualHost *:443&gt;
    ServerName example.org
    DocumentRoot htdocs/root

    SSLEngine on
&lt;/VirtualHost&gt;

&lt;VirtualHost *:443&gt;
    ServerName www.example.org
    DocumentRoot htdocs/www

    SSLEngine on
&lt;/VirtualHost&gt;</pre> </div> <p> There are two special names that you may use in this directive: 'manual' and 'auto'. This determines if a Managed Domain shall have exactly the name list as is configured ('manual') or offer more convenience. With 'auto' all names of a virtual host are added to a MD. Conveniently, 'auto' is also the default. </p> <div class="example">
<h3>Example</h3>
<pre class="prettyprint lang-config">MDomain example.org

&lt;VirtualHost *:443&gt;
    ServerName example.org
    ServerAlias www.example.org
    DocumentRoot htdocs/root

    SSLEngine on
&lt;/VirtualHost&gt;

MDomain example2.org auto

&lt;VirtualHost *:443&gt;
    ServerName example2.org
    ServerAlias www.example2.org
    ...
&lt;/VirtualHost&gt;</pre> </div> <p> In this example, the domain 'www.example.org' is automatically added to the MD 'example.org'. Similarly for 'example2.org' where 'auto' is configured explicitly. Whenever you add more ServerAlias names to this virtual host, they will be added as well to the Managed Domain. </p>
<p> If you prefer to explicitly declare all the domain names, use 'manual' mode. An error will be logged if the names do not match with the expected ones. </p> </div>  <div class="directive-section">
<h2 id="mdomainsetsection">&lt;MDomainSet&gt; Directive</h2> <table class="directive"> <tr>
<th>Description:</th>
<td>Container for directives applied to the same managed domains.</td>
</tr> <tr>
<th>Syntax:</th>
<td><pre>&lt;MDomainSet dns-name [ other-dns-name... ]&gt;...&lt;/MDomainSet&gt;</pre></td>
</tr> <tr>
<th>Context:</th>
<td>server config</td>
</tr> <tr>
<th>Status:</th>
<td>Experimental</td>
</tr> <tr>
<th>Module:</th>
<td>mod_md</td>
</tr> </table> <p> This is the directive <code class="directive"><a href="#mdomain">MDomain</a></code> with the added possibility to add setting just for this MD. In fact, you may also use "&lt;MDomain ..&gt;" as a shortcut. </p> <p> This allows you to configure an MD that uses another Certificate Authority, have other renewal requirements, etc. </p> <div class="example">
<h3>Example</h3>
<pre class="prettyprint lang-config">&lt;MDomain sandbox.example.org&gt;
    MDCertificateAuthority   https://someotherca.com/ACME
&lt;/MDomain&gt;</pre> </div> <p> A common use case is to configure https: requirements separately for your domains. </p> <div class="example">
<h3>Example</h3>
<pre class="prettyprint lang-config">&lt;MDomain example.org&gt;
    MDRequireHttps temporary
&lt;/MDomain&gt;</pre> </div> </div>  <div class="directive-section">
<h2 id="mdportmap">MDPortMap Directive</h2> <table class="directive"> <tr>
<th>Description:</th>
<td>Map external to internal ports for domain ownership verification.</td>
</tr> <tr>
<th>Syntax:</th>
<td><pre>MDPortMap map1 [ map2 ]</pre></td>
</tr> <tr>
<th>Default:</th>
<td><pre>MDPortMap http:80 https:443</pre></td>
</tr> <tr>
<th>Context:</th>
<td>server config</td>
</tr> <tr>
<th>Status:</th>
<td>Experimental</td>
</tr> <tr>
<th>Module:</th>
<td>mod_md</td>
</tr> </table> <p> The ACME protocol provides two methods to verify domain ownership via HTTP: one that uses 'http:' urls (port 80) and one for 'https:' urls (port 443). If your server is not reachable by at least one of the two, ACME may only work by configuring your DNS server, see <code class="directive"><a href="#mdchallengedns01">MDChallengeDns01</a></code>. </p>
<p> On most public facing servers, 'http:' arrives on port 80 and 'https:' on port 443. The module checks the ports your Apache server is listening on and assumes those are available. This means that when your server does not listen on port 80, it assumes that 'http:' requests from the internet will not work. </p>
<p> This is a good guess, but it may be wrong. For example, your Apache might listen to port 80, but your firewall might block it. 'http:' is only available in your intranet. So, the module will falsely assume that Let's Encrypt can use 'http:' challenges with your server. This will then fail, because your firewall will drop those. </p> <div class="example">
<h3>Example</h3>
<pre class="prettyprint lang-config">MDPortMap http:- https:8433</pre> </div> <p> The above example shows how you can specify that 'http:' requests from the internet will never arrive. In addition it says that 'https:' requests will arrive on local port 8433. </p>
<p> This is necessary if you have port forwarding in place, your server may be reachable from the Internet on port 443, but the local port that httpd uses is another one. Your server might only listen on ports 8443 and 8000, but be reached on ports 443 and 80 (from the internet). </p> </div>  <div class="directive-section">
<h2 id="mdprivatekeys">MDPrivateKeys Directive</h2> <table class="directive"> <tr>
<th>Description:</th>
<td>Set type and size of the private keys generated.</td>
</tr> <tr>
<th>Syntax:</th>
<td><pre>MDPrivateKeys type [ params... ]</pre></td>
</tr> <tr>
<th>Default:</th>
<td><pre>MDPrivateKeys RSA 2048</pre></td>
</tr> <tr>
<th>Context:</th>
<td>server config</td>
</tr> <tr>
<th>Status:</th>
<td>Experimental</td>
</tr> <tr>
<th>Module:</th>
<td>mod_md</td>
</tr> </table> <p> Defines what kind of private keys are generated for a managed domain and with what parameters. You can have more than one private key type configured and the module will obtain a certificate for each key. </p>
<p> For example, you may configure an RSA and an Elliptic Curve (EC) key, so that 2 certicates are created for a domain. On a client connection, the first one supported by the client will then be used. </p>
<p> Since EC keys and certificates are smaller, you might want to offer them first for all compatible (modern) clients. This can enable faster handshakes. Add an RSA key type to support older clients. </p> <div class="example">
<h3>Example</h3>
<pre class="prettyprint lang-config">MDPrivateKeys secp256r1 rsa3072</pre> </div> <p> The EC types supported depend on the CA you use. For Let's encrypt the supported curves include 'secp256r1' and 'secp384r1'. </p>
<p> Each key and certificate type is stored in its own file in the MD store. The key type is part of the file name with some backward compatible naming for RSA certificates. So you may continue sharing these files with other applications. </p>
<p> Please note that this setting only has an effect on new keys. Any existing private key you have remains unaffected. Also, this only affects private keys generated for certificates. ACME account keys are unaffected by this. </p> </div>  <div class="directive-section">
<h2 id="mdrenewmode">MDRenewMode Directive</h2> <table class="directive"> <tr>
<th>Description:</th>
<td>Controls if certificates shall be renewed.</td>
</tr> <tr>
<th>Syntax:</th>
<td><pre>MDRenewMode always|auto|manual</pre></td>
</tr> <tr>
<th>Default:</th>
<td><pre>MDRenewMode auto</pre></td>
</tr> <tr>
<th>Context:</th>
<td>server config</td>
</tr> <tr>
<th>Status:</th>
<td>Experimental</td>
</tr> <tr>
<th>Module:</th>
<td>mod_md</td>
</tr> </table> <p> In the default 'auto' mode, the module will do what makes most sense of each Managed Domain. For a domain without any certificates, it will obtain them from the Certificate Authority. </p> <p> However, if you have defined an MD that is not used by any of Apache's VirtualHosts, it will not bother. And for MDs with static certificate files (see <code class="directive"><a href="#mdcertificatefile">MDCertificateFile</a></code>), it assumes that you have your own source, and will not renew them either. </p> <p> You can override this default in either way. If you specify 'always', the module will renew certificates for an MD, regardless if the domains are in use or if there are static files. </p> <p> For the opposite effect, configure 'manual' and no renewal will be attempted. </p> </div>  <div class="directive-section">
<h2 id="mdrenewwindow">MDRenewWindow Directive</h2> <table class="directive"> <tr>
<th>Description:</th>
<td>Control when a certificate will be renewed.</td>
</tr> <tr>
<th>Syntax:</th>
<td><pre>MDRenewWindow duration</pre></td>
</tr> <tr>
<th>Default:</th>
<td><pre>MDRenewWindow 33%</pre></td>
</tr> <tr>
<th>Context:</th>
<td>server config</td>
</tr> <tr>
<th>Status:</th>
<td>Experimental</td>
</tr> <tr>
<th>Module:</th>
<td>mod_md</td>
</tr> </table> <p> If the validity of the certificate falls below duration, mod_md will get a new signed certificate. </p>
<p> Normally, certificates are valid for around 90 days and mod_md will renew them the earliest 33% of their complete lifetime before they expire (so for 90 days validity, 30 days before it expires). If you think this is not what you need, you can specify either the exact time, as in: </p> <div class="example">
<h3>Example</h3>
<pre class="prettyprint lang-config"># 21 days before expiry
MDRenewWindow 21d 
# 30 seconds (might be close)
MDRenewWindow 30s
# 10% of the cert lifetime
MDRenewWindow 10%</pre> </div> <p>When in auto drive mode, the module will check every 12 hours at least what the status of the managed domains is and if it needs to do something. On errors, for example when the CA is unreachable, it will initially retry after some seconds. Should that continue to fail, it will back off to a maximum interval of hourly checks. </p> </div>  <div class="directive-section">
<h2 id="mdrequirehttps">MDRequireHttps Directive</h2> <table class="directive"> <tr>
<th>Description:</th>
<td>Redirects http: traffic to https: for Managed Domains.</td>
</tr> <tr>
<th>Syntax:</th>
<td><pre>MDRequireHttps off|temporary|permanent</pre></td>
</tr> <tr>
<th>Default:</th>
<td><pre>MDRequireHttps off</pre></td>
</tr> <tr>
<th>Context:</th>
<td>server config</td>
</tr> <tr>
<th>Status:</th>
<td>Experimental</td>
</tr> <tr>
<th>Module:</th>
<td>mod_md</td>
</tr> </table> <p>This is a convenience directive to ease http: to https: migration of your Managed Domains. With: </p> <div class="example">
<h3>Example</h3>
<pre class="prettyprint lang-config">MDRequireHttps temporary</pre> </div> <p>you announce that you want all traffic via http: URLs to be redirected to the https: ones, for now. This is safe and you can remove this again at any time. </p>
<p> <strong>The following has consequences: </strong>if you want client to <strong>no longer</strong> use the http: URLs, configure: </p> <div class="example">
<h3>Permanent (for at least half a year!)</h3>
<pre class="prettyprint lang-config">MDRequireHttps permanent</pre> </div> <p>This does two things: </p> <ol> <li>All request to the <code>http:</code> resources are redirected to the same url with the <code>https:</code> scheme using the <code>301</code> status code. This tells clients that this is intended to be forever and the should update any links they have accordingly. </li> <li>All answers to <code>https:</code> requests will carry the header <code>Strict-Transport-Security</code> with a life time of half a year. This tells the browser that it <strong>never</strong> (for half a year) shall use <code>http:</code> when talking to this domain name. Browsers will, after having seen this, refuse to contact your unencrypted site. This prevents malicious middleware to downgrade connections and listen/manipulate the traffic. Which is good. But you cannot simply take it back again. </li> </ol> <p>You can achieve the same with <code class="module"><a href="mod_alias.html">mod_alias</a></code> and some <code class="directive"><a href="mod_alias.html#redirect">Redirect</a></code> configuration, basically. If you do it yourself, please make sure to exclude the paths /.well-known/* from your redirection, otherwise mod_md might have trouble signing on new certificates. </p> <p>If you set this globally, it applies to all managed domains. If you want it for a specific domain only, use: </p> <div class="example">
<h3>Example</h3>
<pre class="prettyprint lang-config">&lt;MDomain xxx.yyy&gt;
  MDRequireHttps temporary
&lt;/MDomain&gt;</pre> </div> </div>  <div class="directive-section">
<h2 id="mdserverstatus">MDServerStatus Directive</h2> <table class="directive"> <tr>
<th>Description:</th>
<td>Control if Managed Domain information is added to server-status.</td>
</tr> <tr>
<th>Syntax:</th>
<td><pre>MDServerStatus on|off</pre></td>
</tr> <tr>
<th>Default:</th>
<td><pre>MDServerStatus on</pre></td>
</tr> <tr>
<th>Context:</th>
<td>server config</td>
</tr> <tr>
<th>Status:</th>
<td>Experimental</td>
</tr> <tr>
<th>Module:</th>
<td>mod_md</td>
</tr> </table> <p> Apaches 'server-status' handler allows you configure a resource to monitor what is going on. This includes now a section listing all Managed Domains with the DNS names, renewal status, lifetimes and main properties. </p>
<p> You can switch that off using this directive. </p> </div>  <div class="directive-section">
<h2 id="mdstapleothers">MDStapleOthers Directive</h2> <table class="directive"> <tr>
<th>Description:</th>
<td>Enable stapling for certificates not managed by mod_md.</td>
</tr> <tr>
<th>Syntax:</th>
<td><pre>MDStapleOthers on|off</pre></td>
</tr> <tr>
<th>Default:</th>
<td><pre>MDStapleOthers on</pre></td>
</tr> <tr>
<th>Context:</th>
<td>server config</td>
</tr> <tr>
<th>Status:</th>
<td>Experimental</td>
</tr> <tr>
<th>Module:</th>
<td>mod_md</td>
</tr> <tr>
<th>Compatibility:</th>
<td>Available in version 2.4.42 and later</td>
</tr> </table> <p> This setting only takes effect when <code class="directive"><a href="#mdstapling">MDStapling</a></code> is enabled. It controls if <code class="module"><a href="mod_md.html">mod_md</a></code> should also provide stapling information for certificates that are not directly controlled by it, e.g. renewed via an ACME CA. </p> </div>  <div class="directive-section">
<h2 id="mdstapling">MDStapling Directive</h2> <table class="directive"> <tr>
<th>Description:</th>
<td>Enable stapling for all or a particular MDomain.</td>
</tr> <tr>
<th>Syntax:</th>
<td><pre>MDStapling on|off</pre></td>
</tr> <tr>
<th>Default:</th>
<td><pre>MDStapling off</pre></td>
</tr> <tr>
<th>Context:</th>
<td>server config</td>
</tr> <tr>
<th>Status:</th>
<td>Experimental</td>
</tr> <tr>
<th>Module:</th>
<td>mod_md</td>
</tr> <tr>
<th>Compatibility:</th>
<td>Available in version 2.4.42 and later</td>
</tr> </table> <p> <code class="module"><a href="mod_md.html">mod_md</a></code> offers an implementation for providing OCSP stapling information. This is an alternative to the one provided by <code class="module"><a href="mod_ssl.html">mod_ssl</a></code>. For backward compatibility, this is disabled by default. </p>
<p> The stapling can be switched on for all certificates on the server or for an individual <code class="directive"><a href="#mdomain">MDomain</a></code>. This will replace any stapling configuration in <code class="module"><a href="mod_ssl.html">mod_ssl</a></code> for these hosts. When disabled, the <code class="module"><a href="mod_ssl.html">mod_ssl</a></code> stapling will do the work (if it is itself enabled, of course). This allows for a gradual shift over from one implementation to the other. </p>
<p> The stapling of <code class="module"><a href="mod_md.html">mod_md</a></code> will also work for domains where the certificates are not managed by this module (see <code class="directive"><a href="#mdstapleothers">MDStapleOthers</a></code> for how to control this). This allows use of the new stapling without using any ACME certificate management. </p> </div>  <div class="directive-section">
<h2 id="mdstaplingkeepresponse">MDStaplingKeepResponse Directive</h2> <table class="directive"> <tr>
<th>Description:</th>
<td>Controls when old responses should be removed.</td>
</tr> <tr>
<th>Syntax:</th>
<td><pre>MDStaplingKeepResponse duration</pre></td>
</tr> <tr>
<th>Default:</th>
<td><pre>MDStaplingKeepResponse 7d</pre></td>
</tr> <tr>
<th>Context:</th>
<td>server config</td>
</tr> <tr>
<th>Status:</th>
<td>Experimental</td>
</tr> <tr>
<th>Module:</th>
<td>mod_md</td>
</tr> <tr>
<th>Compatibility:</th>
<td>Available in version 2.4.42 and later</td>
</tr> </table> <p> This time window specifies when OCSP response data used in stapling shall be removed from the store again. Response information older than 7 days (default) is deleted on server restart/reload. This keeps the store from growing when certificates are renewed/reconfigured frequently. </p>
 </div>  <div class="directive-section">
<h2 id="mdstaplingrenewwindow">MDStaplingRenewWindow Directive</h2> <table class="directive"> <tr>
<th>Description:</th>
<td>Control when the stapling responses will be renewed.</td>
</tr> <tr>
<th>Syntax:</th>
<td><pre>MDStaplingRenewWindow duration</pre></td>
</tr> <tr>
<th>Default:</th>
<td><pre>MDStaplingRenewWindow 33%</pre></td>
</tr> <tr>
<th>Context:</th>
<td>server config</td>
</tr> <tr>
<th>Status:</th>
<td>Experimental</td>
</tr> <tr>
<th>Module:</th>
<td>mod_md</td>
</tr> <tr>
<th>Compatibility:</th>
<td>Available in version 2.4.42 and later</td>
</tr> </table> <p> If the validity of the OCSP response used in stapling falls below <var>duration</var>, <code class="module"><a href="mod_md.html">mod_md</a></code> will obtain a new OCSP response. </p>
<p> The CA issuing a certificate commonly also operates the OCSP responder service and determines how long its signed response about the validity of a certificate are itself valid. The longer a response is valid, the longer it can be cached which mean better overall performance for everyone. The shorter the life time, the more rapidly certificate revocations spread to clients. Also, service reliability is a consideration. </p>
<p> By adjusting the stapling renew window you can control parts of this yourself. If you make the renew time short (e.g. a short time before the current information expires), you gain maximum cache time. But a service outage (down for maintenance, for example) will affect you. If you renew a long time before expiry, updates will be made more frequent, cause more load on the CA server infrastructure and also more coordination between the child processes of your server. </p>
<p> The default is chosen as 33%, which means renewal is started when only a third of the response lifetime is left. For a CA that issues OCSP responses with lifetime of 3 days, this means 2 days of caching and 1 day for renewal attempts. A service outage would have to last full 24 hours to affect your domains. </p>
<p> Setting an absolute renew window, like `2d` (2 days), is also possible. </p> </div>  <div class="directive-section">
<h2 id="mdstoredir">MDStoreDir Directive</h2> <table class="directive"> <tr>
<th>Description:</th>
<td>Path on the local file system to store the Managed Domains data.</td>
</tr> <tr>
<th>Syntax:</th>
<td><pre>MDStoreDir path</pre></td>
</tr> <tr>
<th>Default:</th>
<td><pre>MDStoreDir md</pre></td>
</tr> <tr>
<th>Context:</th>
<td>server config</td>
</tr> <tr>
<th>Status:</th>
<td>Experimental</td>
</tr> <tr>
<th>Module:</th>
<td>mod_md</td>
</tr> </table> <p> Defines where on the local file system the Managed Domain data is stored. This is an absolute path or interpreted relative to the server root. The default will create a directory 'md' in your server root. </p>
<p> If you move this and have already data, be sure to move/copy the data first to the new location, reconfigure and then restart the server. If you reconfigure and restart first, the server will try to get new certificates that it thinks are missing. </p> </div>  <div class="directive-section">
<h2 id="mdwarnwindow">MDWarnWindow Directive</h2> <table class="directive"> <tr>
<th>Description:</th>
<td>Define the time window when you want to be warned about an expiring certificate.</td>
</tr> <tr>
<th>Syntax:</th>
<td><pre>MDWarnWindow duration</pre></td>
</tr> <tr>
<th>Default:</th>
<td><pre>MDWarnWindow 10%</pre></td>
</tr> <tr>
<th>Context:</th>
<td>server config</td>
</tr> <tr>
<th>Status:</th>
<td>Experimental</td>
</tr> <tr>
<th>Module:</th>
<td>mod_md</td>
</tr> </table> <p> See <code class="directive"><a href="#mdrenewwindow">MDRenewWindow</a></code> for a description on how you can specify the time. </p>
<p> The modules checks the remaining lifetime of certificates and invokes <code class="directive"><a href="#mdmessagecmd">MDMessageCmd</a></code> when there is less than the warn window left. With the default, this mean 9 days for certificates from Let's Encrypt. </p>
<p> It also applies to Managed Domains with static certificate files ( see <code class="directive"><a href="#mdcertificatefile">MDCertificateFile</a></code>). </p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2018 The Apache Software Foundation<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://httpd.apache.org/docs/2.4/en/mod/mod_md.html" class="_attribution-link">https://httpd.apache.org/docs/2.4/en/mod/mod_md.html</a>
  </p>
</div>
