<h1 id="query-builder-class">Query Builder Class</h1> <p>CodeIgniter gives you access to a Query Builder class. This pattern allows information to be retrieved, inserted, and updated in your database with minimal scripting. In some cases, only one or two lines of code are necessary to perform a database action. CodeIgniter does not require that each database table be its own class file. It instead provides a more simplified interface.</p> <p>Beyond simplicity, a major benefit to using the Query Builder features is that it allows you to create database independent applications, since the query syntax is generated by each database adapter. It also allows for safer queries, since the values are escaped automatically by the system.</p>  <ul class="simple"> <li><a class="reference internal" href="#loading-the-query-builder" id="id1">Loading the Query Builder</a></li> <li><a class="reference internal" href="#selecting-data" id="id2">Selecting Data</a></li> <li><a class="reference internal" href="#looking-for-specific-data" id="id3">Looking for Specific Data</a></li> <li><a class="reference internal" href="#looking-for-similar-data" id="id4">Looking for Similar Data</a></li> <li><a class="reference internal" href="#ordering-results" id="id5">Ordering results</a></li> <li><a class="reference internal" href="#limiting-or-counting-results" id="id6">Limiting or Counting Results</a></li> <li><a class="reference internal" href="#query-grouping" id="id7">Query grouping</a></li> <li><a class="reference internal" href="#inserting-data" id="id8">Inserting Data</a></li> <li><a class="reference internal" href="#updating-data" id="id9">Updating Data</a></li> <li><a class="reference internal" href="#deleting-data" id="id10">Deleting Data</a></li> <li><a class="reference internal" href="#method-chaining" id="id11">Method Chaining</a></li> <li><a class="reference internal" href="#resetting-query-builder" id="id12">Resetting Query Builder</a></li> <li><a class="reference internal" href="#class-reference" id="id13">Class Reference</a></li> </ul>   <h2 id="loading-the-query-builder">Loading the Query Builder</h2> <p>The Query Builder is loaded through the <code>table()</code> method on the database connection. This sets the <code>FROM</code> portion of the query for you and returns a new instance of the Query Builder class:</p> <pre data-language="php">$db      = \Config\Database::connect();
$builder = $db-&gt;table('users');
</pre> <p>The Query Builder is only loaded into memory when you specifically request the class, so no resources are used by default.</p>   <h2 id="selecting-data">Selecting Data</h2> <p>The following functions allow you to build SQL <strong>SELECT</strong> statements.</p> <p><strong>$builder-&gt;get()</strong></p> <p>Runs the selection query and returns the result. Can be used by itself to retrieve all records from a table:</p> <pre data-language="php">$builder = $db-&gt;table('mytable');
$query   = $builder-&gt;get();  // Produces: SELECT * FROM mytable
</pre> <p>The first and second parameters enable you to set a limit and offset clause:</p> <pre data-language="php">$query = $builder-&gt;get(10, 20);

// Executes: SELECT * FROM mytable LIMIT 20, 10
// (in MySQL. Other databases have slightly different syntax)
</pre> <p>You’ll notice that the above function is assigned to a variable named $query, which can be used to show the results:</p> <pre data-language="php">$query = $builder-&gt;get();

foreach ($query-&gt;getResult() as $row) {
    echo $row-&gt;title;
}
</pre> <p>Please visit the <a class="reference internal" href="results.html"><span class="doc">result functions</span></a> page for a full discussion regarding result generation.</p> <p><strong>$builder-&gt;getCompiledSelect()</strong></p> <p>Compiles the selection query just like <code>$builder-&gt;get()</code> but does not <em>run</em> the query. This method simply returns the SQL query as a string.</p> <p>Example:</p> <pre data-language="php">$sql = $builder-&gt;getCompiledSelect();
echo $sql;

// Prints string: SELECT * FROM mytable
</pre> <p>The first parameter enables you to set whether or not the query builder query will be reset (by default it will be reset, just like when using <code>$builder-&gt;get()</code>):</p> <pre data-language="php">echo $builder-&gt;limit(10,20)-&gt;getCompiledSelect(false);

// Prints string: SELECT * FROM mytable LIMIT 20, 10
// (in MySQL. Other databases have slightly different syntax)

echo $builder-&gt;select('title, content, date')-&gt;getCompiledSelect();

// Prints string: SELECT title, content, date FROM mytable LIMIT 20, 10
</pre> <p>The key thing to notice in the above example is that the second query did not utilize <code>$builder-&gt;from()</code> and did not pass a table name into the first parameter. The reason for this outcome is because the query has not been executed using <code>$builder-&gt;get()</code> which resets values or reset directly using <code>$builder-&gt;resetQuery()</code>.</p> <p><strong>$builder-&gt;getWhere()</strong></p> <p>Identical to the <code>get()</code> function except that it permits you to add a “where” clause in the first parameter, instead of using the db-&gt;where() function:</p> <pre data-language="php">$query = $builder-&gt;getWhere(['id' =&gt; $id], $limit, $offset);
</pre> <p>Please read about the <code>where</code> function below for more information.</p> <p><strong>$builder-&gt;select()</strong></p> <p>Permits you to write the SELECT portion of your query:</p> <pre data-language="php">$builder-&gt;select('title, content, date');
$query = $builder-&gt;get();

// Executes: SELECT title, content, date FROM mytable
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">If you are selecting all (*) from a table you do not need to use this function. When omitted, CodeIgniter assumes that you wish to select all fields and automatically adds <code>SELECT \*</code>.</p> </div> <p><code>$builder-&gt;select()</code> accepts an optional second parameter. If you set it to <code>false</code>, CodeIgniter will not try to protect your field or table names. This is useful if you need a compound select statement where automatic escaping of fields may break them.</p> <pre data-language="php">$builder-&gt;select('(SELECT SUM(payments.amount) FROM payments WHERE payments.invoice_id=4) AS amount_paid', false);
$query = $builder-&gt;get();
</pre> <p><strong>$builder-&gt;selectMax()</strong></p> <p>Writes a <code>SELECT MAX(field)</code> portion for your query. You can optionally include a second parameter to rename the resulting field.</p> <pre data-language="php">$builder-&gt;selectMax('age');
$query = $builder-&gt;get();
// Produces: SELECT MAX(age) as age FROM mytable

$builder-&gt;selectMax('age', 'member_age');
$query = $builder-&gt;get();
// Produces: SELECT MAX(age) as member_age FROM mytable
</pre> <p><strong>$builder-&gt;selectMin()</strong></p> <p>Writes a “SELECT MIN(field)” portion for your query. As with selectMax(), You can optionally include a second parameter to rename the resulting field.</p> <pre data-language="php">$builder-&gt;selectMin('age');
$query = $builder-&gt;get();
// Produces: SELECT MIN(age) as age FROM mytable
</pre> <p><strong>$builder-&gt;selectAvg()</strong></p> <p>Writes a “SELECT AVG(field)” portion for your query. As with selectMax(), You can optionally include a second parameter to rename the resulting field.</p> <pre data-language="php">$builder-&gt;selectAvg('age');
$query = $builder-&gt;get();
// Produces: SELECT AVG(age) as age FROM mytable
</pre> <p><strong>$builder-&gt;selectSum()</strong></p> <p>Writes a “SELECT SUM(field)” portion for your query. As with <code>selectMax()</code>, You can optionally include a second parameter to rename the resulting field.</p> <pre data-language="php">$builder-&gt;selectSum('age');
$query = $builder-&gt;get();
// Produces: SELECT SUM(age) as age FROM mytable
</pre> <p><strong>$builder-&gt;selectCount()</strong></p> <p>Writes a <code>"SELECT COUNT(field)"</code> portion for your query. As with <code>selectMax()</code>, You can optionally include a second parameter to rename the resulting field.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">This method is particularly helpful when used with <code>groupBy()</code>. For counting results generally see <code>countAll()</code> or <code>countAllResults()</code>.</p> </div> <pre data-language="php">$builder-&gt;selectCount('age');
$query = $builder-&gt;get();
// Produces: SELECT COUNT(age) as age FROM mytable
</pre> <p><strong>$builder-&gt;from()</strong></p> <p>Permits you to write the FROM portion of your query:</p> <pre data-language="php">$builder = $db-&gt;table('users');
$builder-&gt;select('title, content, date');
$builder-&gt;from('mytable');
$query = $builder-&gt;get();
// Produces: SELECT title, content, date FROM users, mytable
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">As shown earlier, the FROM portion of your query can is specified in the <code>$db-&gt;table()</code> function. Additional calls to <code>from()</code> will add more tables to the FROM portion of your query.</p> </div> <p><strong>$builder-&gt;join()</strong></p> <p>Permits you to write the JOIN portion of your query:</p> <pre data-language="php">$builder = $db-&gt;table('blogs');
$builder-&gt;select('*');
$builder-&gt;join('comments', 'comments.id = blogs.id');
$query = $builder-&gt;get();

// Produces:
// SELECT * FROM blogs JOIN comments ON comments.id = blogs.id
</pre> <p>Multiple function calls can be made if you need several joins in one query.</p> <p>If you need a specific type of JOIN you can specify it via the third parameter of the function. Options are: left, right, outer, inner, left outer, and right outer.</p> <pre data-language="php">$builder-&gt;join('comments', 'comments.id = blogs.id', 'left');
// Produces: LEFT JOIN comments ON comments.id = blogs.id
</pre>   <h2 id="looking-for-specific-data">Looking for Specific Data</h2> <p><strong>$builder-&gt;where()</strong></p> <p>This function enables you to set <strong>WHERE</strong> clauses using one of four methods:</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">All values passed to this function are escaped automatically, producing safer queries, except when using a custom string.</p> </div> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last"><code>$builder-&gt;where()</code> accepts an optional third parameter. If you set it to <code>false</code>, CodeIgniter will not try to protect your field or table names.</p> </div> <ol class="arabic"> <li>
<p class="first"><strong>Simple key/value method:</strong></p>  <pre data-language="php">$builder-&gt;where('name', $name);
// Produces: WHERE name = 'Joe'
</pre> <p>Notice that the equal sign is added for you.</p> <p>If you use multiple function calls they will be chained together with AND between them:</p> <pre data-language="php">$builder-&gt;where('name', $name);
$builder-&gt;where('title', $title);
$builder-&gt;where('status', $status);
// WHERE name = 'Joe' AND title = 'boss' AND status = 'active'
</pre>  </li> <li>
<p class="first"><strong>Custom key/value method:</strong></p>  <p>You can include an operator in the first parameter in order to control the comparison:</p> <pre data-language="php">$builder-&gt;where('name !=', $name);
$builder-&gt;where('id &lt;', $id);
// Produces: WHERE name != 'Joe' AND id &lt; 45
</pre>  </li> <li>
<p class="first"><strong>Associative array method:</strong></p>  <pre data-language="php">$array = ['name' =&gt; $name, 'title' =&gt; $title, 'status' =&gt; $status];
$builder-&gt;where($array);
// Produces: WHERE name = 'Joe' AND title = 'boss' AND status = 'active'
</pre> <p>You can include your own operators using this method as well:</p> <pre data-language="php">$array = ['name !=' =&gt; $name, 'id &lt;' =&gt; $id, 'date &gt;' =&gt; $date];
$builder-&gt;where($array);
</pre>  </li> <li>
<p class="first"><strong>Custom string:</strong></p>  <p>You can write your own clauses manually:</p> <pre data-language="php">$where = "name='Joe' AND status='boss' OR status='active'";
$builder-&gt;where($where);
</pre> <p>If you are using user-supplied data within the string, you MUST escape the data manually. Failure to do so could result in SQL injections.</p> <pre data-language="php">$name = $builder-&gt;db-&gt;escape('Joe');
$where = "name={$name} AND status='boss' OR status='active'";
$builder-&gt;where($where);
</pre>  </li> <li>
<p class="first"><strong>Subqueries:</strong></p>  <p>You can use an anonymous function to create a subquery:</p> <pre data-language="php">$builder-&gt;where('advance_amount &lt;', function (BaseBuilder $builder) {
    return $builder-&gt;select('MAX(advance_amount)', false)-&gt;from('orders')-&gt;where('id &gt;', 2);
});
// Produces: WHERE "advance_amount" &lt; (SELECT MAX(advance_amount) FROM "orders" WHERE "id" &gt; 2)
</pre>  </li> </ol> <p><strong>$builder-&gt;orWhere()</strong></p> <p>This function is identical to the one above, except that multiple instances are joined by OR:</p> <pre data-language="php">$builder-&gt;where('name !=', $name);
$builder-&gt;orWhere('id &gt;', $id);
// Produces: WHERE name != 'Joe' OR id &gt; 50
</pre> <p><strong>$builder-&gt;whereIn()</strong></p> <p>Generates a WHERE field IN (‘item’, ‘item’) SQL query joined with AND if appropriate:</p> <pre data-language="php">$names = ['Frank', 'Todd', 'James'];
$builder-&gt;whereIn('username', $names);
// Produces: WHERE username IN ('Frank', 'Todd', 'James')
</pre> <p>You can use subqueries instead of an array of values:</p> <pre data-language="php">$builder-&gt;whereIn('id', function (BaseBuilder $builder) {
    return $builder-&gt;select('job_id')-&gt;from('users_jobs')-&gt;where('user_id', 3);
});
// Produces: WHERE "id" IN (SELECT "job_id" FROM "users_jobs" WHERE "user_id" = 3)
</pre> <p><strong>$builder-&gt;orWhereIn()</strong></p> <p>Generates a <code>WHERE field IN ('item', 'item')</code> SQL query joined with OR if appropriate:</p> <pre data-language="php">$names = ['Frank', 'Todd', 'James'];
$builder-&gt;orWhereIn('username', $names);
// Produces: OR username IN ('Frank', 'Todd', 'James')
</pre> <p>You can use subqueries instead of an array of values:</p> <pre data-language="php">$builder-&gt;orWhereIn('id', function (BaseBuilder $builder) {
    return $builder-&gt;select('job_id')-&gt;from('users_jobs')-&gt;where('user_id', 3);
});

// Produces: OR "id" IN (SELECT "job_id" FROM "users_jobs" WHERE "user_id" = 3)
</pre> <p><strong>$builder-&gt;whereNotIn()</strong></p> <p>Generates a WHERE field NOT IN (‘item’, ‘item’) SQL query joined with AND if appropriate:</p> <pre data-language="php">$names = ['Frank', 'Todd', 'James'];
$builder-&gt;whereNotIn('username', $names);
// Produces: WHERE username NOT IN ('Frank', 'Todd', 'James')
</pre> <p>You can use subqueries instead of an array of values:</p> <pre data-language="php">$builder-&gt;whereNotIn('id', function (BaseBuilder $builder) {
    return $builder-&gt;select('job_id')-&gt;from('users_jobs')-&gt;where('user_id', 3);
});

// Produces: WHERE "id" NOT IN (SELECT "job_id" FROM "users_jobs" WHERE "user_id" = 3)
</pre> <p><strong>$builder-&gt;orWhereNotIn()</strong></p> <p>Generates a <code>WHERE field NOT IN ('item', 'item')</code> SQL query joined with OR if appropriate:</p> <pre data-language="php">$names = ['Frank', 'Todd', 'James'];
$builder-&gt;orWhereNotIn('username', $names);
// Produces: OR username NOT IN ('Frank', 'Todd', 'James')
</pre> <p>You can use subqueries instead of an array of values:</p> <pre data-language="php">$builder-&gt;orWhereNotIn('id', function (BaseBuilder $builder) {
    return $builder-&gt;select('job_id')-&gt;from('users_jobs')-&gt;where('user_id', 3);
});

// Produces: OR "id" NOT IN (SELECT "job_id" FROM "users_jobs" WHERE "user_id" = 3)
</pre>   <h2 id="looking-for-similar-data">Looking for Similar Data</h2> <p><strong>$builder-&gt;like()</strong></p> <p>This method enables you to generate <strong>LIKE</strong> clauses, useful for doing searches.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">All values passed to this method are escaped automatically.</p> </div> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">All <code>like*</code> method variations can be forced to perform case-insensitive searches by passing a fifth parameter of <code>true</code> to the method. This will use platform-specific features where available otherwise, will force the values to be lowercase, i.e., <code>WHERE LOWER(column) LIKE '%search%'</code>. This may require indexes to be made for <code>LOWER(column)</code> instead of <code>column</code> to be effective.</p> </div> <ol class="arabic"> <li>
<p class="first"><strong>Simple key/value method:</strong></p>  <pre data-language="php">$builder-&gt;like('title', 'match');
// Produces: WHERE `title` LIKE '%match%' ESCAPE '!'
</pre> <p>If you use multiple method calls they will be chained together with AND between them:</p> <pre data-language="php">$builder-&gt;like('title', 'match');
$builder-&gt;like('body', 'match');
// WHERE `title` LIKE '%match%' ESCAPE '!' AND  `body` LIKE '%match%' ESCAPE '!'
</pre> <p>If you want to control where the wildcard (%) is placed, you can use an optional third argument. Your options are ‘before’, ‘after’ and ‘both’ (which is the default).</p> <pre data-language="php">$builder-&gt;like('title', 'match', 'before'); // Produces: WHERE `title` LIKE '%match' ESCAPE '!'
$builder-&gt;like('title', 'match', 'after');  // Produces: WHERE `title` LIKE 'match%' ESCAPE '!'
$builder-&gt;like('title', 'match', 'both');   // Produces: WHERE `title` LIKE '%match%' ESCAPE '!'
</pre>  </li> <li>
<p class="first"><strong>Associative array method:</strong></p>  <pre data-language="php">$array = ['title' =&gt; $match, 'page1' =&gt; $match, 'page2' =&gt; $match];
$builder-&gt;like($array);
// WHERE `title` LIKE '%match%' ESCAPE '!' AND  `page1` LIKE '%match%' ESCAPE '!' AND  `page2` LIKE '%match%' ESCAPE '!'
</pre>  </li> </ol> <p><strong>$builder-&gt;orLike()</strong></p> <p>This method is identical to the one above, except that multiple instances are joined by OR:</p> <pre data-language="php">$builder-&gt;like('title', 'match'); $builder-&gt;orLike('body', $match);
// WHERE `title` LIKE '%match%' ESCAPE '!' OR  `body` LIKE '%match%' ESCAPE '!'
</pre> <p><strong>$builder-&gt;notLike()</strong></p> <p>This method is identical to <code>like()</code>, except that it generates NOT LIKE statements:</p> <pre data-language="php">$builder-&gt;notLike('title', 'match'); // WHERE `title` NOT LIKE '%match% ESCAPE '!'
</pre> <p><strong>$builder-&gt;orNotLike()</strong></p> <p>This method is identical to <code>notLike()</code>, except that multiple instances are joined by OR:</p> <pre data-language="php">$builder-&gt;like('title', 'match');
$builder-&gt;orNotLike('body', 'match');
// WHERE `title` LIKE '%match% OR  `body` NOT LIKE '%match%' ESCAPE '!'
</pre> <p><strong>$builder-&gt;groupBy()</strong></p> <p>Permits you to write the GROUP BY portion of your query:</p> <pre data-language="php">$builder-&gt;groupBy("title");
// Produces: GROUP BY title
</pre> <p>You can also pass an array of multiple values as well:</p> <pre data-language="php">$builder-&gt;groupBy(["title", "date"]);
// Produces: GROUP BY title, date
</pre> <p><strong>$builder-&gt;distinct()</strong></p> <p>Adds the “DISTINCT” keyword to a query</p> <pre data-language="php">$builder-&gt;distinct();
$builder-&gt;get();
// Produces: SELECT DISTINCT * FROM mytable
</pre> <p><strong>$builder-&gt;having()</strong></p> <p>Permits you to write the HAVING portion of your query. There are 2 possible syntaxes, 1 argument or 2:</p> <pre data-language="php">$builder-&gt;having('user_id = 45'); // Produces: HAVING user_id = 45
$builder-&gt;having('user_id',  45); // Produces: HAVING user_id = 45
</pre> <p>You can also pass an array of multiple values as well:</p> <pre data-language="php">$builder-&gt;having(['title =' =&gt; 'My Title', 'id &lt;' =&gt; $id]);
// Produces: HAVING title = 'My Title', id &lt; 45
</pre> <p>If you are using a database that CodeIgniter escapes queries for, you can prevent escaping content by passing an optional third argument, and setting it to <code>false</code>.</p> <pre data-language="php">$builder-&gt;having('user_id',  45); // Produces: HAVING `user_id` = 45 in some databases such as MySQL
$builder-&gt;having('user_id',  45, false); // Produces: HAVING user_id = 45
</pre> <p><strong>$builder-&gt;orHaving()</strong></p> <p>Identical to <code>having()</code>, only separates multiple clauses with “OR”.</p> <p><strong>$builder-&gt;havingIn()</strong></p> <p>Generates a <code>HAVING field IN ('item', 'item')</code> SQL query joined with AND if appropriate</p> <pre data-language="php">$groups = [1, 2, 3];
$builder-&gt;havingIn('group_id', $groups);
// Produces: HAVING group_id IN (1, 2, 3)
</pre> <p>You can use subqueries instead of an array of values.</p> <pre data-language="php">$builder-&gt;havingIn('id', function (BaseBuilder $builder) {
    return $builder-&gt;select('user_id')-&gt;from('users_jobs')-&gt;where('group_id', 3);
});
// Produces: HAVING "id" IN (SELECT "user_id" FROM "users_jobs" WHERE "group_id" = 3)
</pre> <p><strong>$builder-&gt;orHavingIn()</strong></p> <p>Generates a <code>HAVING field IN ('item', 'item')</code> SQL query joined with OR if appropriate</p> <pre data-language="php">$groups = [1, 2, 3];
$builder-&gt;orHavingIn('group_id', $groups);
// Produces: OR group_id IN (1, 2, 3)
</pre> <p>You can use subqueries instead of an array of values.</p> <pre data-language="php">$builder-&gt;orHavingIn('id', function (BaseBuilder $builder) {
    return $builder-&gt;select('user_id')-&gt;from('users_jobs')-&gt;where('group_id', 3);
});

// Produces: OR "id" IN (SELECT "user_id" FROM "users_jobs" WHERE "group_id" = 3)
</pre> <p><strong>$builder-&gt;havingNotIn()</strong></p> <p>Generates a <code>HAVING field NOT IN ('item', 'item')</code> SQL query joined with AND if appropriate</p> <pre data-language="php">$groups = [1, 2, 3];
$builder-&gt;havingNotIn('group_id', $groups);
// Produces: HAVING group_id NOT IN (1, 2, 3)
</pre> <p>You can use subqueries instead of an array of values.</p> <pre data-language="php">$builder-&gt;havingNotIn('id', function (BaseBuilder $builder) {
    return $builder-&gt;select('user_id')-&gt;from('users_jobs')-&gt;where('group_id', 3);
});

// Produces: HAVING "id" NOT IN (SELECT "user_id" FROM "users_jobs" WHERE "group_id" = 3)
</pre> <p><strong>$builder-&gt;orHavingNotIn()</strong></p> <p>Generates a <code>HAVING field NOT IN ('item', 'item')</code> SQL query joined with OR if appropriate</p> <pre data-language="php">$groups = [1, 2, 3];
$builder-&gt;havingNotIn('group_id', $groups);
// Produces: OR group_id NOT IN (1, 2, 3)
</pre> <p>You can use subqueries instead of an array of values.</p> <pre data-language="php">$builder-&gt;orHavingNotIn('id', function (BaseBuilder $builder) {
    return $builder-&gt;select('user_id')-&gt;from('users_jobs')-&gt;where('group_id', 3);
});

// Produces: OR "id" NOT IN (SELECT "user_id" FROM "users_jobs" WHERE "group_id" = 3)
</pre> <p><strong>$builder-&gt;havingLike()</strong></p> <p>This method enables you to generate <strong>LIKE</strong> clauses for HAVING part or the query, useful for doing searches.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">All values passed to this method are escaped automatically.</p> </div> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">All <code>havingLike*</code> method variations can be forced to perform case-insensitive searches by passing a fifth parameter of <code>true</code> to the method. This will use platform-specific features where available otherwise, will force the values to be lowercase, i.e., <code>HAVING LOWER(column) LIKE '%search%'</code>. This may require indexes to be made for <code>LOWER(column)</code> instead of <code>column</code> to be effective.</p> </div> <ol class="arabic"> <li>
<p class="first"><strong>Simple key/value method:</strong></p>  <pre data-language="php">$builder-&gt;havingLike('title', 'match');
// Produces: HAVING `title` LIKE '%match%' ESCAPE '!'
</pre> <p>If you use multiple method calls they will be chained together with AND between them:</p> <pre data-language="php">$builder-&gt;havingLike('title', 'match');
$builder-&gt;havingLike('body', 'match');
// HAVING `title` LIKE '%match%' ESCAPE '!' AND  `body` LIKE '%match% ESCAPE '!'
</pre> <p>If you want to control where the wildcard (%) is placed, you can use an optional third argument. Your options are ‘before’, ‘after’ and ‘both’ (which is the default).</p> <pre data-language="php">$builder-&gt;havingLike('title', 'match', 'before'); // Produces: HAVING `title` LIKE '%match' ESCAPE '!'
$builder-&gt;havingLike('title', 'match', 'after');  // Produces: HAVING `title` LIKE 'match%' ESCAPE '!'
$builder-&gt;havingLike('title', 'match', 'both');   // Produces: HAVING `title` LIKE '%match%' ESCAPE '!'
</pre>  </li> <li>
<p class="first"><strong>Associative array method:</strong></p>  <pre data-language="php">$array = ['title' =&gt; $match, 'page1' =&gt; $match, 'page2' =&gt; $match];
$builder-&gt;havingLike($array);
// HAVING `title` LIKE '%match%' ESCAPE '!' AND  `page1` LIKE '%match%' ESCAPE '!' AND  `page2` LIKE '%match%' ESCAPE '!'
</pre>  </li> </ol> <p><strong>$builder-&gt;orHavingLike()</strong></p> <p>This method is identical to the one above, except that multiple instances are joined by OR:</p> <pre data-language="php">$builder-&gt;havingLike('title', 'match'); $builder-&gt;orHavingLike('body', $match);
// HAVING `title` LIKE '%match%' ESCAPE '!' OR  `body` LIKE '%match%' ESCAPE '!'
</pre> <p><strong>$builder-&gt;notHavingLike()</strong></p> <p>This method is identical to <code>havingLike()</code>, except that it generates NOT LIKE statements:</p> <pre data-language="php">$builder-&gt;notHavingLike('title', 'match');
// HAVING `title` NOT LIKE '%match% ESCAPE '!'
</pre> <p><strong>$builder-&gt;orNotHavingLike()</strong></p> <p>This method is identical to <code>notHavingLike()</code>, except that multiple instances are joined by OR:</p> <pre data-language="php">$builder-&gt;havingLike('title', 'match');
$builder-&gt;orNotHavingLike('body', 'match');
// HAVING `title` LIKE '%match% OR  `body` NOT LIKE '%match%' ESCAPE '!'
</pre>   <h2 id="ordering-results">Ordering results</h2> <p><strong>$builder-&gt;orderBy()</strong></p> <p>Lets you set an ORDER BY clause.</p> <p>The first parameter contains the name of the column you would like to order by.</p> <p>The second parameter lets you set the direction of the result. Options are <strong>ASC</strong>, <strong>DESC</strong> AND <strong>RANDOM</strong>.</p> <pre data-language="php">$builder-&gt;orderBy('title', 'DESC');
// Produces: ORDER BY `title` DESC
</pre> <p>You can also pass your own string in the first parameter:</p> <pre data-language="php">$builder-&gt;orderBy('title DESC, name ASC');
// Produces: ORDER BY `title` DESC, `name` ASC
</pre> <p>Or multiple function calls can be made if you need multiple fields.</p> <pre data-language="php">$builder-&gt;orderBy('title', 'DESC');
$builder-&gt;orderBy('name', 'ASC');
// Produces: ORDER BY `title` DESC, `name` ASC
</pre> <p>If you choose the <strong>RANDOM</strong> direction option, then the first parameters will be ignored, unless you specify a numeric seed value.</p> <pre data-language="php">$builder-&gt;orderBy('title', 'RANDOM');
// Produces: ORDER BY RAND()

$builder-&gt;orderBy(42, 'RANDOM');
// Produces: ORDER BY RAND(42)
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Random ordering is not currently supported in Oracle and will default to ASC instead.</p> </div>   <h2 id="limiting-or-counting-results">Limiting or Counting Results</h2> <p><strong>$builder-&gt;limit()</strong></p> <p>Lets you limit the number of rows you would like returned by the query:</p> <pre data-language="php">$builder-&gt;limit(10);
// Produces: LIMIT 10
</pre> <p>The second parameter lets you set a result offset.</p> <pre data-language="php">$builder-&gt;limit(10, 20);
// Produces: LIMIT 20, 10 (in MySQL. Other databases have slightly different syntax)
</pre> <p><strong>$builder-&gt;countAllResults()</strong></p> <p>Permits you to determine the number of rows in a particular Query Builder query. Queries will accept Query Builder restrictors such as <code>where()</code>, <code>orWhere()</code>, <code>like()</code>, <code>orLike()</code>, etc. Example:</p> <pre data-language="php">echo $builder-&gt;countAllResults(); // Produces an integer, like 25
$builder-&gt;like('title', 'match');
$builder-&gt;from('my_table');
echo $builder-&gt;countAllResults(); // Produces an integer, like 17
</pre> <p>However, this method also resets any field values that you may have passed to <code>select()</code>. If you need to keep them, you can pass <code>false</code> as the first parameter.</p> <pre data-language="php">echo $builder-&gt;countAllResults(false); // Produces an integer, like 17
</pre> <p><strong>$builder-&gt;countAll()</strong></p> <p>Permits you to determine the number of rows in a particular table. Example:</p> <pre data-language="php">echo $builder-&gt;countAll(); // Produces an integer, like 25
</pre> <p>As is in countAllResult method, this method resets any field values that you may have passed to <code>select()</code> as well. If you need to keep them, you can pass <code>false</code> as the first parameter.</p>   <h2 id="query-grouping">Query grouping</h2> <p>Query grouping allows you to create groups of WHERE clauses by enclosing them in parentheses. This will allow you to create queries with complex WHERE clauses. Nested groups are supported. Example:</p> <pre data-language="php">$builder-&gt;select('*')-&gt;from('my_table')
    -&gt;groupStart()
        -&gt;where('a', 'a')
        -&gt;orGroupStart()
            -&gt;where('b', 'b')
            -&gt;where('c', 'c')
        -&gt;groupEnd()
    -&gt;groupEnd()
    -&gt;where('d', 'd')
-&gt;get();

// Generates:
// SELECT * FROM (`my_table`) WHERE ( `a` = 'a' OR ( `b` = 'b' AND `c` = 'c' ) ) AND `d` = 'd'
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Groups need to be balanced, make sure every <code>groupStart()</code> is matched by a <code>groupEnd()</code>.</p> </div> <p><strong>$builder-&gt;groupStart()</strong></p> <p>Starts a new group by adding an opening parenthesis to the WHERE clause of the query.</p> <p><strong>$builder-&gt;orGroupStart()</strong></p> <p>Starts a new group by adding an opening parenthesis to the WHERE clause of the query, prefixing it with ‘OR’.</p> <p><strong>$builder-&gt;notGroupStart()</strong></p> <p>Starts a new group by adding an opening parenthesis to the WHERE clause of the query, prefixing it with ‘NOT’.</p> <p><strong>$builder-&gt;orNotGroupStart()</strong></p> <p>Starts a new group by adding an opening parenthesis to the WHERE clause of the query, prefixing it with ‘OR NOT’.</p> <p><strong>$builder-&gt;groupEnd()</strong></p> <p>Ends the current group by adding a closing parenthesis to the WHERE clause of the query.</p> <p><strong>$builder-&gt;havingGroupStart()</strong></p> <p>Starts a new group by adding an opening parenthesis to the HAVING clause of the query.</p> <p><strong>$builder-&gt;orHavingGroupStart()</strong></p> <p>Starts a new group by adding an opening parenthesis to the HAVING clause of the query, prefixing it with ‘OR’.</p> <p><strong>$builder-&gt;notHavingGroupStart()</strong></p> <p>Starts a new group by adding an opening parenthesis to the HAVING clause of the query, prefixing it with ‘NOT’.</p> <p><strong>$builder-&gt;orNotHavingGroupStart()</strong></p> <p>Starts a new group by adding an opening parenthesis to the HAVING clause of the query, prefixing it with ‘OR NOT’.</p> <p><strong>$builder-&gt;havingGroupEnd()</strong></p> <p>Ends the current group by adding a closing parenthesis to the HAVING clause of the query.</p>   <h2 id="inserting-data">Inserting Data</h2> <p><strong>$builder-&gt;insert()</strong></p> <p>Generates an insert string based on the data you supply, and runs the query. You can either pass an <strong>array</strong> or an <strong>object</strong> to the function. Here is an example using an array:</p> <pre data-language="php">$data = [
    'title' =&gt; 'My title',
    'name'  =&gt; 'My Name',
    'date'  =&gt; 'My date',
];

$builder-&gt;insert($data);
// Produces: INSERT INTO mytable (title, name, date) VALUES ('My title', 'My name', 'My date')
</pre> <p>The first parameter is an associative array of values.</p> <p>Here is an example using an object:</p> <pre data-language="php">class Myclass
{
    public $title   = 'My Title';
    public $content = 'My Content';
    public $date    = 'My Date';
}

$object = new Myclass;
$builder-&gt;insert($object);
// Produces: INSERT INTO mytable (title, content, date) VALUES ('My Title', 'My Content', 'My Date')
</pre> <p>The first parameter is an object.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">All values are escaped automatically producing safer queries.</p> </div> <p><strong>$builder-&gt;ignore()</strong></p> <p>Generates an insert ignore string based on the data you supply, and runs the query. So if an entry with the same primary key already exists, the query won’t be inserted. You can optionally pass an <strong>boolean</strong> to the function. Here is an example using the array of the above example:</p> <pre data-language="php">$data = [
    'title' =&gt; 'My title',
    'name'  =&gt; 'My Name',
    'date'  =&gt; 'My date',
];

$builder-&gt;ignore(true)-&gt;insert($data);
// Produces: INSERT OR IGNORE INTO mytable (title, name, date) VALUES ('My title', 'My name', 'My date')
</pre> <p><strong>$builder-&gt;getCompiledInsert()</strong></p> <p>Compiles the insertion query just like <code>$builder-&gt;insert()</code> but does not <em>run</em> the query. This method simply returns the SQL query as a string.</p> <p>Example:</p> <pre data-language="php">$data = [
    'title' =&gt; 'My title',
    'name'  =&gt; 'My Name',
    'date'  =&gt; 'My date',
];

$sql = $builder-&gt;set($data)-&gt;getCompiledInsert('mytable');
echo $sql;

// Produces string: INSERT INTO mytable (`title`, `name`, `date`) VALUES ('My title', 'My name', 'My date')
</pre> <p>The second parameter enables you to set whether or not the query builder query will be reset (by default it will be–just like <code>$builder-&gt;insert()</code>):</p> <pre data-language="php">echo $builder-&gt;set('title', 'My Title')-&gt;getCompiledInsert('mytable', false);

// Produces string: INSERT INTO mytable (`title`) VALUES ('My Title')

echo $builder-&gt;set('content', 'My Content')-&gt;getCompiledInsert();

// Produces string: INSERT INTO mytable (`title`, `content`) VALUES ('My Title', 'My Content')
</pre> <p>The key thing to notice in the above example is that the second query did not utilize <code>$builder-&gt;from()</code> nor did it pass a table name into the first parameter. The reason this worked is that the query has not been executed using <code>$builder-&gt;insert()</code> which resets values or reset directly using <code>$builder-&gt;resetQuery()</code>.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">This method doesn’t work for batch inserts.</p> </div> <p><strong>$builder-&gt;insertBatch()</strong></p> <p>Generates an insert string based on the data you supply, and runs the query. You can either pass an <strong>array</strong> or an <strong>object</strong> to the function. Here is an example using an array:</p> <pre data-language="php">$data = [
    [
        'title' =&gt; 'My title',
        'name'  =&gt; 'My Name',
        'date'  =&gt; 'My date',
    ],
    [
        'title' =&gt; 'Another title',
        'name'  =&gt; 'Another Name',
        'date'  =&gt; 'Another date',
    ],
];

$builder-&gt;insertBatch($data);
// Produces: INSERT INTO mytable (title, name, date) VALUES ('My title', 'My name', 'My date'),  ('Another title', 'Another name', 'Another date')
</pre> <p>The first parameter is an associative array of values.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">All values are escaped automatically producing safer queries.</p> </div>   <h2 id="updating-data">Updating Data</h2> <p><strong>$builder-&gt;replace()</strong></p> <p>This method executes a REPLACE statement, which is basically the SQL standard for (optional) DELETE + INSERT, using <em>PRIMARY</em> and <em>UNIQUE</em> keys as the determining factor. In our case, it will save you from the need to implement complex logics with different combinations of <code>select()</code>, <code>update()</code>, <code>delete()</code> and <code>insert()</code> calls.</p> <p>Example:</p> <pre data-language="php">$data = [
    'title' =&gt; 'My title',
    'name'  =&gt; 'My Name',
    'date'  =&gt; 'My date',
];

$builder-&gt;replace($data);

// Executes: REPLACE INTO mytable (title, name, date) VALUES ('My title', 'My name', 'My date')
</pre> <p>In the above example, if we assume that the <em>title</em> field is our primary key, then if a row containing ‘My title’ as the <em>title</em> value, that row will be deleted with our new row data replacing it.</p> <p>Usage of the <code>set()</code> method is also allowed and all fields are automatically escaped, just like with <code>insert()</code>.</p> <p><strong>$builder-&gt;set()</strong></p> <p>This function enables you to set values for inserts or updates.</p> <p><strong>It can be used instead of passing a data array directly to the insert or update functions:</strong></p> <pre data-language="php">$builder-&gt;set('name', $name);
$builder-&gt;insert();
// Produces: INSERT INTO mytable (`name`) VALUES ('{$name}')
</pre> <p>If you use multiple function called they will be assembled properly based on whether you are doing an insert or an update:</p> <pre data-language="php">$builder-&gt;set('name', $name);
$builder-&gt;set('title', $title);
$builder-&gt;set('status', $status);
$builder-&gt;insert();
</pre> <p><strong>set()</strong> will also accept an optional third parameter (<code>$escape</code>), that will prevent data from being escaped if set to <code>false</code>. To illustrate the difference, here is <code>set()</code> used both with and without the escape parameter.</p> <pre data-language="php">$builder-&gt;set('field', 'field+1', false);
$builder-&gt;where('id', 2);
$builder-&gt;update();
// gives UPDATE mytable SET field = field+1 WHERE `id` = 2

$builder-&gt;set('field', 'field+1');
$builder-&gt;where('id', 2);
$builder-&gt;update();
// gives UPDATE `mytable` SET `field` = 'field+1' WHERE `id` = 2
</pre> <p>You can also pass an associative array to this function:</p> <pre data-language="php">$array = [
    'name'   =&gt; $name,
    'title'  =&gt; $title,
    'status' =&gt; $status,
];

$builder-&gt;set($array);
$builder-&gt;insert();
</pre> <p>Or an object:</p> <pre data-language="php">class Myclass
{
    public $title   = 'My Title';
    public $content = 'My Content';
    public $date    = 'My Date';
}

$object = new Myclass;
$builder-&gt;set($object);
$builder-&gt;insert();
</pre> <p><strong>$builder-&gt;update()</strong></p> <p>Generates an update string and runs the query based on the data you supply. You can pass an <strong>array</strong> or an <strong>object</strong> to the function. Here is an example using an array:</p> <pre data-language="php">$data = [
    'title' =&gt; $title,
    'name'  =&gt; $name,
    'date'  =&gt; $date,
];

$builder-&gt;where('id', $id);
$builder-&gt;update($data);
// Produces:
//
// UPDATE mytable
// SET title = '{$title}', name = '{$name}', date = '{$date}'
// WHERE id = $id
</pre> <p>Or you can supply an object:</p> <pre data-language="php">class Myclass
{
    public $title   = 'My Title';
    public $content = 'My Content';
    public $date    = 'My Date';
}

$object = new Myclass;
$builder-&gt;where('id', $id);
$builder-&gt;update($object);
// Produces:
//
// UPDATE `mytable`
// SET `title` = '{$title}', `name` = '{$name}', `date` = '{$date}'
// WHERE id = `$id`
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">All values are escaped automatically producing safer queries.</p> </div> <p>You’ll notice the use of the <code>$builder-&gt;where()</code> function, enabling you to set the WHERE clause. You can optionally pass this information directly into the update function as a string:</p> <pre data-language="php">$builder-&gt;update($data, "id = 4");
</pre> <p>Or as an array:</p> <pre data-language="php">$builder-&gt;update($data, ['id' =&gt; $id]);
</pre> <p>You may also use the <code>$builder-&gt;set()</code> function described above when performing updates.</p> <p><strong>$builder-&gt;updateBatch()</strong></p> <p>Generates an update string based on the data you supply, and runs the query. You can either pass an <strong>array</strong> or an <strong>object</strong> to the function. Here is an example using an array:</p> <pre data-language="php">$data = [
   [
      'title' =&gt; 'My title' ,
      'name'  =&gt; 'My Name 2' ,
      'date'  =&gt; 'My date 2',
   ],
   [
      'title' =&gt; 'Another title' ,
      'name'  =&gt; 'Another Name 2' ,
      'date'  =&gt; 'Another date 2',
   ],
];

$builder-&gt;updateBatch($data, 'title');

// Produces:
// UPDATE `mytable` SET `name` = CASE
// WHEN `title` = 'My title' THEN 'My Name 2'
// WHEN `title` = 'Another title' THEN 'Another Name 2'
// ELSE `name` END,
// `date` = CASE
// WHEN `title` = 'My title' THEN 'My date 2'
// WHEN `title` = 'Another title' THEN 'Another date 2'
// ELSE `date` END
// WHERE `title` IN ('My title','Another title')
</pre> <p>The first parameter is an associative array of values, the second parameter is the where key.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">All values are escaped automatically producing safer queries.</p> </div> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last"><code>affectedRows()</code> won’t give you proper results with this method, due to the very nature of how it works. Instead, <code>updateBatch()</code> returns the number of rows affected.</p> </div> <p><strong>$builder-&gt;getCompiledUpdate()</strong></p> <p>This works exactly the same way as <code>$builder-&gt;getCompiledInsert()</code> except that it produces an UPDATE SQL string instead of an INSERT SQL string.</p> <p>For more information view documentation for <code>$builder-&gt;getCompiledInsert()</code>.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">This method doesn’t work for batched updates.</p> </div>   <h2 id="deleting-data">Deleting Data</h2> <p><strong>$builder-&gt;delete()</strong></p> <p>Generates a delete SQL string and runs the query.</p> <pre data-language="php">$builder-&gt;delete(['id' =&gt; $id]);
// Produces: // DELETE FROM mytable  // WHERE id = $id
</pre> <p>The first parameter is the where clause. You can also use the <code>where()</code> or <code>or_where()</code> functions instead of passing the data to the first parameter of the function:</p> <pre data-language="php">$builder-&gt;where('id', $id);
$builder-&gt;delete();

// Produces:
// DELETE FROM mytable
// WHERE id = $id
</pre> <p>If you want to delete all data from a table, you can use the <code>truncate()</code> function, or <code>emptyTable()</code>.</p> <p><strong>$builder-&gt;emptyTable()</strong></p> <p>Generates a delete SQL string and runs the query:</p> <pre data-language="php">$builder-&gt;emptyTable('mytable');
// Produces: DELETE FROM mytable
</pre> <p><strong>$builder-&gt;truncate()</strong></p> <p>Generates a truncate SQL string and runs the query.</p> <pre data-language="php">$builder-&gt;truncate();

// Produce:
// TRUNCATE mytable
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">If the TRUNCATE command isn’t available, <code>truncate()</code> will execute as “DELETE FROM table”.</p> </div> <p><strong>$builder-&gt;getCompiledDelete()</strong></p> <p>This works exactly the same way as <code>$builder-&gt;getCompiledInsert()</code> except that it produces a DELETE SQL string instead of an INSERT SQL string.</p> <p>For more information view documentation for <code>$builder-&gt;getCompiledInsert()</code>.</p>   <h2 id="method-chaining">Method Chaining</h2> <p>Method chaining allows you to simplify your syntax by connecting multiple functions. Consider this example:</p> <pre data-language="php">$query = $builder-&gt;select('title')
                 -&gt;where('id', $id)
                 -&gt;limit(10, 20)
                 -&gt;get();
</pre>   <h2 id="ar-caching">Resetting Query Builder</h2> <p id="resetting-query-builder"><strong>$builder-&gt;resetQuery()</strong></p> <p>Resetting Query Builder allows you to start fresh with your query without executing it first using a method like <code>$builder-&gt;get()</code> or <code>$builder-&gt;insert()</code>.</p> <p>This is useful in situations where you are using Query Builder to generate SQL (e.g., <code>$builder-&gt;getCompiledSelect()</code>) but then choose to, for instance, run the query:</p> <pre data-language="php">// Note that the second parameter of the ``get_compiled_select`` method is false
$sql = $builder-&gt;select(['field1','field2'])
               -&gt;where('field3',5)
               -&gt;getCompiledSelect(false);

// ...
// Do something crazy with the SQL code... like add it to a cron script for
// later execution or something...
// ...

$data = $builder-&gt;get()-&gt;getResultArray();

// Would execute and return an array of results of the following query:
// SELECT field1, field1 from mytable where field3 = 5;
</pre>   <h2 id="class-reference">Class Reference</h2> <dl class="class"> <dt>
<code>CodeIgniter\Database\BaseBuilder</code> </dt> <dd>
<dl class="method"> <dt id="db">
<code>db()</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Returns:</th>
<td class="field-body">The database connection in use</td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body"><code>ConnectionInterface</code></td> </tr>  </table> <p>Returns the current database connection from <code>$db</code>. Useful for accessing <code>ConnectionInterface</code> methods that are not directly available to the Query Builder, like <code>insertID()</code> or <code>errors()</code>.</p> </dd>
</dl> <dl class="method"> <dt id="resetQuery">
<code>resetQuery()</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<code>BaseBuilder</code> instance (method chaining)</td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body"><code>BaseBuilder</code></td> </tr>  </table> <p>Resets the current Query Builder state. Useful when you want to build a query that can be cancelled under certain conditions.</p> </dd>
</dl> <dl class="method"> <dt id="countAllResults">
<code>countAllResults([$reset = true])</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>$reset</strong> (<em>bool</em>) – Whether to reset values for SELECTs</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first">Number of rows in the query result</p> </td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body">
<p class="first last">int</p> </td> </tr>  </table> <p>Generates a platform-specific query string that counts all records returned by an Query Builder query.</p> </dd>
</dl> <dl class="method"> <dt id="countAll">
<code>countAll([$reset = true])</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>$reset</strong> (<em>bool</em>) – Whether to reset values for SELECTs</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first">Number of rows in the query result</p> </td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body">
<p class="first last">int</p> </td> </tr>  </table> <p>Generates a platform-specific query string that counts all records in the particular table.</p> </dd>
</dl> <dl class="method"> <dt id="get">
<code>get([$limit = null[, $offset = null[, $reset = true]]]])</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>$limit</strong> (<em>int</em>) – The LIMIT clause</li> <li>
<strong>$offset</strong> (<em>int</em>) – The OFFSET clause</li> <li>
<strong>$reset</strong> (<em>bool</em>) – Do we want to clear query builder values?</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><code>\CodeIgniter\Database\ResultInterface</code> instance (method chaining)</p> </td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body">
<p class="first last"><code>\CodeIgniter\Database\ResultInterface</code></p> </td> </tr>  </table> <p>Compiles and runs <code>SELECT</code> statement based on the already called Query Builder methods.</p> </dd>
</dl> <dl class="method"> <dt id="getWhere">
<code>getWhere([$where = null[, $limit = null[, $offset = null[, $reset = true]]]]])</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>$where</strong> (<em>string</em>) – The WHERE clause</li> <li>
<strong>$limit</strong> (<em>int</em>) – The LIMIT clause</li> <li>
<strong>$offset</strong> (<em>int</em>) – The OFFSET clause</li> <li>
<strong>$reset</strong> (<em>bool</em>) – Do we want to clear query builder values?</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><code>\CodeIgniter\Database\ResultInterface</code> instance (method chaining)</p> </td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body">
<p class="first last"><code>\CodeIgniter\Database\ResultInterface</code></p> </td> </tr>  </table> <p>Same as <code>get()</code>, but also allows the WHERE to be added directly.</p> </dd>
</dl> <dl class="method"> <dt id="select">
<code>select([$select = '*'[, $escape = null]])</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>$select</strong> (<em>string</em>) – The SELECT portion of a query</li> <li>
<strong>$escape</strong> (<em>bool</em>) – Whether to escape values and identifiers</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><code>BaseBuilder</code> instance (method chaining)</p> </td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body">
<p class="first last"><code>BaseBuilder</code></p> </td> </tr>  </table> <p>Adds a <code>SELECT</code> clause to a query.</p> </dd>
</dl> <dl class="method"> <dt id="selectAvg">
<code>selectAvg([$select = ''[, $alias = '']])</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>$select</strong> (<em>string</em>) – Field to compute the average of</li> <li>
<strong>$alias</strong> (<em>string</em>) – Alias for the resulting value name</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><code>BaseBuilder</code> instance (method chaining)</p> </td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body">
<p class="first last"><code>BaseBuilder</code></p> </td> </tr>  </table> <p>Adds a <code>SELECT AVG(field)</code> clause to a query.</p> </dd>
</dl> <dl class="method"> <dt id="selectMax">
<code>selectMax([$select = ''[, $alias = '']])</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>$select</strong> (<em>string</em>) – Field to compute the maximum of</li> <li>
<strong>$alias</strong> (<em>string</em>) – Alias for the resulting value name</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><code>BaseBuilder</code> instance (method chaining)</p> </td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body">
<p class="first last"><code>BaseBuilder</code></p> </td> </tr>  </table> <p>Adds a <code>SELECT MAX(field)</code> clause to a query.</p> </dd>
</dl> <dl class="method"> <dt id="selectMin">
<code>selectMin([$select = ''[, $alias = '']])</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>$select</strong> (<em>string</em>) – Field to compute the minimum of</li> <li>
<strong>$alias</strong> (<em>string</em>) – Alias for the resulting value name</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><code>BaseBuilder</code> instance (method chaining)</p> </td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body">
<p class="first last"><code>BaseBuilder</code></p> </td> </tr>  </table> <p>Adds a <code>SELECT MIN(field)</code> clause to a query.</p> </dd>
</dl> <dl class="method"> <dt id="selectSum">
<code>selectSum([$select = ''[, $alias = '']])</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>$select</strong> (<em>string</em>) – Field to compute the sum of</li> <li>
<strong>$alias</strong> (<em>string</em>) – Alias for the resulting value name</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><code>BaseBuilder</code> instance (method chaining)</p> </td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body">
<p class="first last"><code>BaseBuilder</code></p> </td> </tr>  </table> <p>Adds a <code>SELECT SUM(field)</code> clause to a query.</p> </dd>
</dl> <dl class="method"> <dt id="selectCount">
<code>selectCount([$select = ''[, $alias = '']])</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>$select</strong> (<em>string</em>) – Field to compute the average of</li> <li>
<strong>$alias</strong> (<em>string</em>) – Alias for the resulting value name</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><code>BaseBuilder</code> instance (method chaining)</p> </td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body">
<p class="first last"><code>BaseBuilder</code></p> </td> </tr>  </table> <p>Adds a <code>SELECT COUNT(field)</code> clause to a query.</p> </dd>
</dl> <dl class="method"> <dt id="distinct">
<code>distinct([$val = true])</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>$val</strong> (<em>bool</em>) – Desired value of the “distinct” flag</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><code>BaseBuilder</code> instance (method chaining)</p> </td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body">
<p class="first last"><code>BaseBuilder</code></p> </td> </tr>  </table> <p>Sets a flag which tells the query builder to add a <code>DISTINCT</code> clause to the <code>SELECT</code> portion of the query.</p> </dd>
</dl> <dl class="method"> <dt id="from">
<code>from($from[, $overwrite = false])</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>$from</strong> (<em>mixed</em>) – Table name(s); string or array</li> <li>
<strong>$overwrite</strong> (<em>bool</em>) – Should we remove the first table existing?</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><code>BaseBuilder</code> instance (method chaining)</p> </td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body">
<p class="first last"><code>BaseBuilder</code></p> </td> </tr>  </table> <p>Specifies the <code>FROM</code> clause of a query.</p> </dd>
</dl> <dl class="method"> <dt id="join">
<code>join($table, $cond[, $type = ''[, $escape = null]])</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>$table</strong> (<em>string</em>) – Table name to join</li> <li>
<strong>$cond</strong> (<em>string</em>) – The JOIN ON condition</li> <li>
<strong>$type</strong> (<em>string</em>) – The JOIN type</li> <li>
<strong>$escape</strong> (<em>bool</em>) – Whether to escape values and identifiers</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><code>BaseBuilder</code> instance (method chaining)</p> </td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body">
<p class="first last"><code>BaseBuilder</code></p> </td> </tr>  </table> <p>Adds a <code>JOIN</code> clause to a query.</p> </dd>
</dl> <dl class="method"> <dt id="where">
<code>where($key[, $value = null[, $escape = null]])</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>$key</strong> (<em>mixed</em>) – Name of field to compare, or associative array</li> <li>
<strong>$value</strong> (<em>mixed</em>) – If a single key, compared to this value</li> <li>
<strong>$escape</strong> (<em>bool</em>) – Whether to escape values and identifiers</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><code>BaseBuilder</code> instance (method chaining)</p> </td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body">
<p class="first last"><code>BaseBuilder</code></p> </td> </tr>  </table> <p>Generates the <code>WHERE</code> portion of the query. Separates multiple calls with <code>AND</code>.</p> </dd>
</dl> <dl class="method"> <dt id="orWhere">
<code>orWhere($key[, $value = null[, $escape = null]])</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>$key</strong> (<em>mixed</em>) – Name of field to compare, or associative array</li> <li>
<strong>$value</strong> (<em>mixed</em>) – If a single key, compared to this value</li> <li>
<strong>$escape</strong> (<em>bool</em>) – Whether to escape values and identifiers</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><code>BaseBuilder</code> instance (method chaining)</p> </td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body">
<p class="first last"><code>BaseBuilder</code></p> </td> </tr>  </table> <p>Generates the <code>WHERE</code> portion of the query. Separates multiple calls with <code>OR</code>.</p> </dd>
</dl> <dl class="method"> <dt id="orWhereIn">
<code>orWhereIn([$key = null[, $values = null[, $escape = null]]])</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>$key</strong> (<em>string</em>) – The field to search</li> <li>
<strong>$values</strong> (<em>array|Closure</em>) – Array of target values, or anonymous function for subquery</li> <li>
<strong>$escape</strong> (<em>bool</em>) – Whether to escape values and identifiers</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><code>BaseBuilder</code> instance (method chaining)</p> </td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body">
<p class="first last"><code>BaseBuilder</code></p> </td> </tr>  </table> <p>Generates a <code>WHERE</code> field <code>IN('item', 'item')</code> SQL query, joined with <code>OR</code> if appropriate.</p> </dd>
</dl> <dl class="method"> <dt id="orWhereNotIn">
<code>orWhereNotIn([$key = null[, $values = null[, $escape = null]]])</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>$key</strong> (<em>string</em>) – The field to search</li> <li>
<strong>$values</strong> (<em>array|Closure</em>) – Array of target values, or anonymous function for subquery</li> <li>
<strong>$escape</strong> (<em>bool</em>) – Whether to escape values and identifiers</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><code>BaseBuilder</code> instance (method chaining)</p> </td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body">
<p class="first last"><code>BaseBuilder</code></p> </td> </tr>  </table> <p>Generates a <code>WHERE</code> field <code>NOT IN('item', 'item')</code> SQL query, joined with <code>OR</code> if appropriate.</p> </dd>
</dl> <dl class="method"> <dt id="whereIn">
<code>whereIn([$key = null[, $values = null[, $escape = null]]])</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>$key</strong> (<em>string</em>) – Name of field to examine</li> <li>
<strong>$values</strong> (<em>array|Closure</em>) – Array of target values, or anonymous function for subquery</li> <li>
<strong>$escape</strong> (<em>bool</em>) – Whether to escape values and identifiers</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><code>BaseBuilder</code> instance (method chaining)</p> </td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body">
<p class="first last"><code>BaseBuilder</code></p> </td> </tr>  </table> <p>Generates a <code>WHERE</code> field <code>IN('item', 'item')</code> SQL query, joined with <code>AND</code> if appropriate.</p> </dd>
</dl> <dl class="method"> <dt id="whereNotIn">
<code>whereNotIn([$key = null[, $values = null[, $escape = null]]])</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>$key</strong> (<em>string</em>) – Name of field to examine</li> <li>
<strong>$values</strong> (<em>array|Closure</em>) – Array of target values, or anonymous function for subquery</li> <li>
<strong>$escape</strong> (<em>bool</em>) – Whether to escape values and identifiers</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><code>BaseBuilder</code> instance (method chaining)</p> </td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body">
<p class="first last"><code>BaseBuilder</code></p> </td> </tr>  </table> <p>Generates a <code>WHERE</code> field <code>NOT IN('item', 'item')</code> SQL query, joined with <code>AND</code> if appropriate.</p> </dd>
</dl> <dl class="method"> <dt id="groupStart">
<code>groupStart()</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<code>BaseBuilder</code> instance (method chaining)</td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body"><code>BaseBuilder</code></td> </tr>  </table> <p>Starts a group expression, using <code>AND</code> for the conditions inside it.</p> </dd>
</dl> <dl class="method"> <dt id="orGroupStart">
<code>orGroupStart()</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<code>BaseBuilder</code> instance (method chaining)</td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body"><code>BaseBuilder</code></td> </tr>  </table> <p>Starts a group expression, using <code>OR</code> for the conditions inside it.</p> </dd>
</dl> <dl class="method"> <dt id="notGroupStart">
<code>notGroupStart()</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<code>BaseBuilder</code> instance (method chaining)</td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body"><code>BaseBuilder</code></td> </tr>  </table> <p>Starts a group expression, using <code>AND NOT</code> for the conditions inside it.</p> </dd>
</dl> <dl class="method"> <dt id="orNotGroupStart">
<code>orNotGroupStart()</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<code>BaseBuilder</code> instance (method chaining)</td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body"><code>BaseBuilder</code></td> </tr>  </table> <p>Starts a group expression, using <code>OR NOT</code> for the conditions inside it.</p> </dd>
</dl> <dl class="method"> <dt id="groupEnd">
<code>groupEnd()</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<code>BaseBuilder</code> instance (method chaining)</td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body"><code>BaseBuilder</code></td> </tr>  </table> <p>Ends a group expression.</p> </dd>
</dl> <dl class="method"> <dt id="like">
<code>like($field[, $match = ''[, $side = 'both'[, $escape = null[, $insensitiveSearch = false]]]])</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>$field</strong> (<em>string</em>) – Field name</li> <li>
<strong>$match</strong> (<em>string</em>) – Text portion to match</li> <li>
<strong>$side</strong> (<em>string</em>) – Which side of the expression to put the ‘%’ wildcard on</li> <li>
<strong>$escape</strong> (<em>bool</em>) – Whether to escape values and identifiers</li> <li>
<strong>$insensitiveSearch</strong> (<em>bool</em>) – Whether to force a case-insensitive search</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><code>BaseBuilder</code> instance (method chaining)</p> </td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body">
<p class="first last"><code>BaseBuilder</code></p> </td> </tr>  </table> <p>Adds a <code>LIKE</code> clause to a query, separating multiple calls with <code>AND</code>.</p> </dd>
</dl> <dl class="method"> <dt id="orLike">
<code>orLike($field[, $match = ''[, $side = 'both'[, $escape = null[, $insensitiveSearch = false]]]])</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>$field</strong> (<em>string</em>) – Field name</li> <li>
<strong>$match</strong> (<em>string</em>) – Text portion to match</li> <li>
<strong>$side</strong> (<em>string</em>) – Which side of the expression to put the ‘%’ wildcard on</li> <li>
<strong>$escape</strong> (<em>bool</em>) – Whether to escape values and identifiers</li> <li>
<strong>$insensitiveSearch</strong> (<em>bool</em>) – Whether to force a case-insensitive search</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><code>BaseBuilder</code> instance (method chaining)</p> </td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body">
<p class="first last"><code>BaseBuilder</code></p> </td> </tr>  </table> <p>Adds a <code>LIKE</code> clause to a query, separating multiple class with <code>OR</code>.</p> </dd>
</dl> <dl class="method"> <dt id="notLike">
<code>notLike($field[, $match = ''[, $side = 'both'[, $escape = null[, $insensitiveSearch = false]]]])</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>$field</strong> (<em>string</em>) – Field name</li> <li>
<strong>$match</strong> (<em>string</em>) – Text portion to match</li> <li>
<strong>$side</strong> (<em>string</em>) – Which side of the expression to put the ‘%’ wildcard on</li> <li>
<strong>$escape</strong> (<em>bool</em>) – Whether to escape values and identifiers</li> <li>
<strong>$insensitiveSearch</strong> (<em>bool</em>) – Whether to force a case-insensitive search</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><code>BaseBuilder</code> instance (method chaining)</p> </td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body">
<p class="first last"><code>BaseBuilder</code></p> </td> </tr>  </table> <p>Adds a <code>NOT LIKE</code> clause to a query, separating multiple calls with <code>AND</code>.</p> </dd>
</dl> <dl class="method"> <dt id="orNotLike">
<code>orNotLike($field[, $match = ''[, $side = 'both'[, $escape = null[, $insensitiveSearch = false]]]])</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>$field</strong> (<em>string</em>) – Field name</li> <li>
<strong>$match</strong> (<em>string</em>) – Text portion to match</li> <li>
<strong>$side</strong> (<em>string</em>) – Which side of the expression to put the ‘%’ wildcard on</li> <li>
<strong>$escape</strong> (<em>bool</em>) – Whether to escape values and identifiers</li> <li>
<strong>$insensitiveSearch</strong> (<em>bool</em>) – Whether to force a case-insensitive search</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><code>BaseBuilder</code> instance (method chaining)</p> </td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body">
<p class="first last"><code>BaseBuilder</code></p> </td> </tr>  </table> <p>Adds a <code>NOT LIKE</code> clause to a query, separating multiple calls with <code>OR</code>.</p> </dd>
</dl> <dl class="method"> <dt id="having">
<code>having($key[, $value = null[, $escape = null]])</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>$key</strong> (<em>mixed</em>) – Identifier (string) or associative array of field/value pairs</li> <li>
<strong>$value</strong> (<em>string</em>) – Value sought if $key is an identifier</li> <li>
<strong>$escape</strong> (<em>string</em>) – Whether to escape values and identifiers</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><code>BaseBuilder</code> instance (method chaining)</p> </td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body">
<p class="first last"><code>BaseBuilder</code></p> </td> </tr>  </table> <p>Adds a <code>HAVING</code> clause to a query, separating multiple calls with <code>AND</code>.</p> </dd>
</dl> <dl class="method"> <dt id="orHaving">
<code>orHaving($key[, $value = null[, $escape = null]])</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>$key</strong> (<em>mixed</em>) – Identifier (string) or associative array of field/value pairs</li> <li>
<strong>$value</strong> (<em>string</em>) – Value sought if $key is an identifier</li> <li>
<strong>$escape</strong> (<em>string</em>) – Whether to escape values and identifiers</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><code>BaseBuilder</code> instance (method chaining)</p> </td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body">
<p class="first last"><code>BaseBuilder</code></p> </td> </tr>  </table> <p>Adds a <code>HAVING</code> clause to a query, separating multiple calls with <code>OR</code>.</p> </dd>
</dl> <dl class="method"> <dt id="orHavingIn">
<code>orHavingIn([$key = null[, $values = null[, $escape = null]]])</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>$key</strong> (<em>string</em>) – The field to search</li> <li>
<strong>$values</strong> (<em>array|Closure</em>) – Array of target values, or anonymous function for subquery</li> <li>
<strong>$escape</strong> (<em>bool</em>) – Whether to escape values and identifiers</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><code>BaseBuilder</code> instance (method chaining)</p> </td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body">
<p class="first last"><code>BaseBuilder</code></p> </td> </tr>  </table> <p>Generates a <code>HAVING</code> field IN(‘item’, ‘item’) SQL query, joined with <code>OR</code> if appropriate.</p> </dd>
</dl> <dl class="method"> <dt id="orHavingNotIn">
<code>orHavingNotIn([$key = null[, $values = null[, $escape = null]]])</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>$key</strong> (<em>string</em>) – The field to search</li> <li>
<strong>$values</strong> (<em>array|Closure</em>) – Array of target values, or anonymous function for subquery</li> <li>
<strong>$escape</strong> (<em>bool</em>) – Whether to escape values and identifiers</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><code>BaseBuilder</code> instance (method chaining)</p> </td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body">
<p class="first last"><code>BaseBuilder</code></p> </td> </tr>  </table> <p>Generates a <code>HAVING</code> field <code>NOT IN('item', 'item')</code> SQL query, joined with <code>OR</code> if appropriate.</p> </dd>
</dl> <dl class="method"> <dt id="havingIn">
<code>havingIn([$key = null[, $values = null[, $escape = null]]])</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>$key</strong> (<em>string</em>) – Name of field to examine</li> <li>
<strong>$values</strong> (<em>array|Closure</em>) – Array of target values, or anonymous function for subquery</li> <li>
<strong>$escape</strong> (<em>bool</em>) – Whether to escape values and identifiers</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><code>BaseBuilder</code> instance (method chaining)</p> </td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body">
<p class="first last"><code>BaseBuilder</code></p> </td> </tr>  </table> <p>Generates a <code>HAVING</code> field <code>IN('item', 'item')</code> SQL query, joined with <code>AND</code> if appropriate.</p> </dd>
</dl> <dl class="method"> <dt id="havingNotIn">
<code>havingNotIn([$key = null[, $values = null[, $escape = null]]])</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>$key</strong> (<em>string</em>) – Name of field to examine</li> <li>
<strong>$values</strong> (<em>array|Closure</em>) – Array of target values, or anonymous function for subquery</li> <li>
<strong>$escape</strong> (<em>bool</em>) – Whether to escape values and identifiers</li> <li>
<strong>$insensitiveSearch</strong> (<em>bool</em>) – Whether to force a case-insensitive search</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><code>BaseBuilder</code> instance (method chaining)</p> </td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body">
<p class="first last"><code>BaseBuilder</code></p> </td> </tr>  </table> <p>Generates a <code>HAVING</code> field <code>NOT IN('item', 'item')</code> SQL query, joined with <code>AND</code> if appropriate.</p> </dd>
</dl> <dl class="method"> <dt id="havingLike">
<code>havingLike($field[, $match = ''[, $side = 'both'[, $escape = null[, $insensitiveSearch = false]]]])</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>$field</strong> (<em>string</em>) – Field name</li> <li>
<strong>$match</strong> (<em>string</em>) – Text portion to match</li> <li>
<strong>$side</strong> (<em>string</em>) – Which side of the expression to put the ‘%’ wildcard on</li> <li>
<strong>$escape</strong> (<em>bool</em>) – Whether to escape values and identifiers</li> <li>
<strong>$insensitiveSearch</strong> (<em>bool</em>) – Whether to force a case-insensitive search</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><code>BaseBuilder</code> instance (method chaining)</p> </td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body">
<p class="first last"><code>BaseBuilder</code></p> </td> </tr>  </table> <p>Adds a <code>LIKE</code> clause to a <code>HAVING</code> part of the query, separating multiple calls with <code>AND</code>.</p> </dd>
</dl> <dl class="method"> <dt id="orHavingLike">
<code>orHavingLike($field[, $match = ''[, $side = 'both'[, $escape = null[, $insensitiveSearch = false]]]])</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>$field</strong> (<em>string</em>) – Field name</li> <li>
<strong>$match</strong> (<em>string</em>) – Text portion to match</li> <li>
<strong>$side</strong> (<em>string</em>) – Which side of the expression to put the ‘%’ wildcard on</li> <li>
<strong>$escape</strong> (<em>bool</em>) – Whether to escape values and identifiers</li> <li>
<strong>$insensitiveSearch</strong> (<em>bool</em>) – Whether to force a case-insensitive search</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><code>BaseBuilder</code> instance (method chaining)</p> </td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body">
<p class="first last"><code>BaseBuilder</code></p> </td> </tr>  </table> <p>Adds a <code>LIKE</code> clause to a <code>HAVING</code> part of the query, separating multiple class with <code>OR</code>.</p> </dd>
</dl> <dl class="method"> <dt id="notHavingLike">
<code>notHavingLike($field[, $match = ''[, $side = 'both'[, $escape = null[, $insensitiveSearch = false]]]])</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>$field</strong> (<em>string</em>) – Field name</li> <li>
<strong>$match</strong> (<em>string</em>) – Text portion to match</li> <li>
<strong>$side</strong> (<em>string</em>) – Which side of the expression to put the ‘%’ wildcard on</li> <li>
<strong>$escape</strong> (<em>bool</em>) – Whether to escape values and identifiers</li> <li>
<strong>$insensitiveSearch</strong> (<em>bool</em>) – Whether to force a case-insensitive search</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><code>BaseBuilder</code> instance (method chaining)</p> </td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body">
<p class="first last"><code>BaseBuilder</code></p> </td> </tr>  </table> <p>Adds a <code>NOT LIKE</code> clause to a <code>HAVING</code> part of the query, separating multiple calls with <code>AND</code>.</p> </dd>
</dl> <dl class="method"> <dt id="orNotHavingLike">
<code>orNotHavingLike($field[, $match = ''[, $side = 'both'[, $escape = null[, $insensitiveSearch = false]]]])</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>$field</strong> (<em>string</em>) – Field name</li> <li>
<strong>$match</strong> (<em>string</em>) – Text portion to match</li> <li>
<strong>$side</strong> (<em>string</em>) – Which side of the expression to put the ‘%’ wildcard on</li> <li>
<strong>$escape</strong> (<em>bool</em>) – Whether to escape values and identifiers</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><code>BaseBuilder</code> instance (method chaining)</p> </td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body">
<p class="first last"><code>BaseBuilder</code></p> </td> </tr>  </table> <p>Adds a <code>NOT LIKE</code> clause to a <code>HAVING</code> part of the query, separating multiple calls with <code>OR</code>.</p> </dd>
</dl> <dl class="method"> <dt id="havingGroupStart">
<code>havingGroupStart()</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<code>BaseBuilder</code> instance (method chaining)</td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body"><code>BaseBuilder</code></td> </tr>  </table> <p>Starts a group expression for <code>HAVING</code> clause, using <code>AND</code> for the conditions inside it.</p> </dd>
</dl> <dl class="method"> <dt id="orHavingGroupStart">
<code>orHavingGroupStart()</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<code>BaseBuilder</code> instance (method chaining)</td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body"><code>BaseBuilder</code></td> </tr>  </table> <p>Starts a group expression for <code>HAVING</code> clause, using <code>OR</code> for the conditions inside it.</p> </dd>
</dl> <dl class="method"> <dt id="notHavingGroupStart">
<code>notHavingGroupStart()</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<code>BaseBuilder</code> instance (method chaining)</td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body"><code>BaseBuilder</code></td> </tr>  </table> <p>Starts a group expression for <code>HAVING</code> clause, using <code>AND NOT</code> for the conditions inside it.</p> </dd>
</dl> <dl class="method"> <dt id="orNotHavingGroupStart">
<code>orNotHavingGroupStart()</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<code>BaseBuilder</code> instance (method chaining)</td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body"><code>BaseBuilder</code></td> </tr>  </table> <p>Starts a group expression for <code>HAVING</code> clause, using <code>OR NOT</code> for the conditions inside it.</p> </dd>
</dl> <dl class="method"> <dt id="havingGroupEnd">
<code>havingGroupEnd()</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<code>BaseBuilder</code> instance (method chaining)</td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body"><code>BaseBuilder</code></td> </tr>  </table> <p>Ends a group expression for <code>HAVING</code> clause.</p> </dd>
</dl> <dl class="method"> <dt id="groupBy">
<code>groupBy($by[, $escape = null])</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>$by</strong> (<em>mixed</em>) – Field(s) to group by; string or array</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><code>BaseBuilder</code> instance (method chaining)</p> </td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body">
<p class="first last"><code>BaseBuilder</code></p> </td> </tr>  </table> <p>Adds a <code>GROUP BY</code> clause to a query.</p> </dd>
</dl> <dl class="method"> <dt id="orderBy">
<code>orderBy($orderby[, $direction = ''[, $escape = null]])</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>$orderby</strong> (<em>string</em>) – Field to order by</li> <li>
<strong>$direction</strong> (<em>string</em>) – The order requested - ASC, DESC or random</li> <li>
<strong>$escape</strong> (<em>bool</em>) – Whether to escape values and identifiers</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><code>BaseBuilder</code> instance (method chaining)</p> </td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body">
<p class="first last"><code>BaseBuilder</code></p> </td> </tr>  </table> <p>Adds an <code>ORDER BY</code> clause to a query.</p> </dd>
</dl> <dl class="method"> <dt id="limit">
<code>limit($value[, $offset = 0])</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>$value</strong> (<em>int</em>) – Number of rows to limit the results to</li> <li>
<strong>$offset</strong> (<em>int</em>) – Number of rows to skip</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><code>BaseBuilder</code> instance (method chaining)</p> </td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body">
<p class="first last"><code>BaseBuilder</code></p> </td> </tr>  </table> <p>Adds <code>LIMIT</code> and <code>OFFSET</code> clauses to a query.</p> </dd>
</dl> <dl class="method"> <dt id="offset">
<code>offset($offset)</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>$offset</strong> (<em>int</em>) – Number of rows to skip</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><code>BaseBuilder</code> instance (method chaining)</p> </td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body">
<p class="first last"><code>BaseBuilder</code></p> </td> </tr>  </table> <p>Adds an <code>OFFSET</code> clause to a query.</p> </dd>
</dl> <dl class="method"> <dt id="set">
<code>set($key[, $value = ''[, $escape = null]])</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>$key</strong> (<em>mixed</em>) – Field name, or an array of field/value pairs</li> <li>
<strong>$value</strong> (<em>mixed</em>) – Field value, if $key is a single field</li> <li>
<strong>$escape</strong> (<em>bool</em>) – Whether to escape values</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><code>BaseBuilder</code> instance (method chaining)</p> </td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body">
<p class="first last"><code>BaseBuilder</code></p> </td> </tr>  </table> <p>Adds field/value pairs to be passed later to <code>insert()</code>, <code>update()</code> or <code>replace()</code>.</p> </dd>
</dl> <dl class="method"> <dt id="insert">
<code>insert([$set = null[, $escape = null]])</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>$set</strong> (<em>array</em>) – An associative array of field/value pairs</li> <li>
<strong>$escape</strong> (<em>bool</em>) – Whether to escape values</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><code>true</code> on success, <code>false</code> on failure</p> </td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body">
<p class="first last">bool</p> </td> </tr>  </table> <p>Compiles and executes an <code>INSERT</code> statement.</p> </dd>
</dl> <dl class="method"> <dt id="insertBatch">
<code>insertBatch([$set = null[, $escape = null[, $batch_size = 100]]])</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>$set</strong> (<em>array</em>) – Data to insert</li> <li>
<strong>$escape</strong> (<em>bool</em>) – Whether to escape values</li> <li>
<strong>$batch_size</strong> (<em>int</em>) – Count of rows to insert at once</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first">Number of rows inserted or <code>false</code> on failure</p> </td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body">
<p class="first last">int|false</p> </td> </tr>  </table> <p>Compiles and executes batch <code>INSERT</code> statements.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">When more than <code>$batch_size</code> rows are provided, multiple <code>INSERT</code> queries will be executed, each trying to insert up to <code>$batch_size</code> rows.</p> </div> </dd>
</dl> <dl class="method"> <dt id="setInsertBatch">
<code>setInsertBatch($key[, $value = ''[, $escape = null]])</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>$key</strong> (<em>mixed</em>) – Field name or an array of field/value pairs</li> <li>
<strong>$value</strong> (<em>string</em>) – Field value, if $key is a single field</li> <li>
<strong>$escape</strong> (<em>bool</em>) – Whether to escape values</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><code>BaseBuilder</code> instance (method chaining)</p> </td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body">
<p class="first last"><code>BaseBuilder</code></p> </td> </tr>  </table> <p>Adds field/value pairs to be inserted in a table later via <code>insertBatch()</code>.</p> </dd>
</dl> <dl class="method"> <dt id="update">
<code>update([$set = null[, $where = null[, $limit = null]]])</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>$set</strong> (<em>array</em>) – An associative array of field/value pairs</li> <li>
<strong>$where</strong> (<em>string</em>) – The WHERE clause</li> <li>
<strong>$limit</strong> (<em>int</em>) – The LIMIT clause</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><code>true</code> on success, <code>false</code> on failure</p> </td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body">
<p class="first last">bool</p> </td> </tr>  </table> <p>Compiles and executes an <code>UPDATE</code> statement.</p> </dd>
</dl> <dl class="method"> <dt id="updateBatch">
<code>updateBatch([$set = null[, $value = null[, $batch_size = 100]]])</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>$set</strong> (<em>array</em>) – Field name, or an associative array of field/value pairs</li> <li>
<strong>$value</strong> (<em>string</em>) – Field value, if $set is a single field</li> <li>
<strong>$batch_size</strong> (<em>int</em>) – Count of conditions to group in a single query</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first">Number of rows updated or <code>false</code> on failure</p> </td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body">
<p class="first last">int|false</p> </td> </tr>  </table> <p>Compiles and executes batch <code>UPDATE</code> statements.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">When more than <code>$batch_size</code> field/value pairs are provided, multiple queries will be executed, each handling up to <code>$batch_size</code> field/value pairs.</p> </div> </dd>
</dl> <dl class="method"> <dt id="setUpdateBatch">
<code>setUpdateBatch($key[, $value = ''[, $escape = null]])</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>$key</strong> (<em>mixed</em>) – Field name or an array of field/value pairs</li> <li>
<strong>$value</strong> (<em>string</em>) – Field value, if $key is a single field</li> <li>
<strong>$escape</strong> (<em>bool</em>) – Whether to escape values</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><code>BaseBuilder</code> instance (method chaining)</p> </td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body">
<p class="first last"><code>BaseBuilder</code></p> </td> </tr>  </table> <p>Adds field/value pairs to be updated in a table later via <code>updateBatch()</code>.</p> </dd>
</dl> <dl class="method"> <dt id="replace">
<code>replace([$set = null])</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>$set</strong> (<em>array</em>) – An associative array of field/value pairs</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><code>true</code> on success, <code>false</code> on failure</p> </td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body">
<p class="first last">bool</p> </td> </tr>  </table> <p>Compiles and executes a <code>REPLACE</code> statement.</p> </dd>
</dl> <dl class="method"> <dt id="delete">
<code>delete([$where = ''[, $limit = null[, $reset_data = true]]])</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>$where</strong> (<em>string</em>) – The WHERE clause</li> <li>
<strong>$limit</strong> (<em>int</em>) – The LIMIT clause</li> <li>
<strong>$reset_data</strong> (<em>bool</em>) – true to reset the query “write” clause</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><code>BaseBuilder</code> instance (method chaining) or <code>false</code> on failure</p> </td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body">
<p class="first last"><code>BaseBuilder|false</code></p> </td> </tr>  </table> <p>Compiles and executes a <code>DELETE</code> query.</p> </dd>
</dl> <dl class="method"> <dt id="increment">
<code>increment($column[, $value = 1])</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first last simple"> <li>
<strong>$column</strong> (<em>string</em>) – The name of the column to increment</li> <li>
<strong>$value</strong> (<em>int</em>) – The amount to increment in the column</li> </ul> </td> </tr>  </table> <p>Increments the value of a field by the specified amount. If the field is not a numeric field, like a <code>VARCHAR</code>, it will likely be replaced with <code>$value</code>.</p> </dd>
</dl> <dl class="method"> <dt id="decrement">
<code>decrement($column[, $value = 1])</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first last simple"> <li>
<strong>$column</strong> (<em>string</em>) – The name of the column to decrement</li> <li>
<strong>$value</strong> (<em>int</em>) – The amount to decrement in the column</li> </ul> </td> </tr>  </table> <p>Decrements the value of a field by the specified amount. If the field is not a numeric field, like a <code>VARCHAR</code>, it will likely be replaced with <code>$value</code>.</p> </dd>
</dl> <dl class="method"> <dt id="truncate">
<code>truncate()</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<code>true</code> on success, <code>false</code> on failure, string on test mode</td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body">bool|string</td> </tr>  </table> <p>Executes a <code>TRUNCATE</code> statement on a table.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">If the database platform in use doesn’t support <code>TRUNCATE</code>, a <code>DELETE</code> statement will be used instead.</p> </div> </dd>
</dl> <dl class="method"> <dt id="emptyTable">
<code>emptyTable()</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<code>true</code> on success, <code>false</code> on failure</td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body">bool</td> </tr>  </table> <p>Deletes all records from a table via a <code>DELETE</code> statement.</p> </dd>
</dl> <dl class="method"> <dt id="getCompiledSelect">
<code>getCompiledSelect([$reset = true])</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>$reset</strong> (<em>bool</em>) – Whether to reset the current QB values or not</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first">The compiled SQL statement as a string</p> </td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body">
<p class="first last">string</p> </td> </tr>  </table> <p>Compiles a <code>SELECT</code> statement and returns it as a string.</p> </dd>
</dl> <dl class="method"> <dt id="getCompiledInsert">
<code>getCompiledInsert([$reset = true])</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>$reset</strong> (<em>bool</em>) – Whether to reset the current QB values or not</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first">The compiled SQL statement as a string</p> </td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body">
<p class="first last">string</p> </td> </tr>  </table> <p>Compiles an <code>INSERT</code> statement and returns it as a string.</p> </dd>
</dl> <dl class="method"> <dt id="getCompiledUpdate">
<code>getCompiledUpdate([$reset = true])</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>$reset</strong> (<em>bool</em>) – Whether to reset the current QB values or not</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first">The compiled SQL statement as a string</p> </td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body">
<p class="first last">string</p> </td> </tr>  </table> <p>Compiles an <code>UPDATE</code> statement and returns it as a string.</p> </dd>
</dl> <dl class="method"> <dt id="getCompiledDelete">
<code>getCompiledDelete([$reset = true])</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<ul class="first simple"> <li>
<strong>$reset</strong> (<em>bool</em>) – Whether to reset the current QB values or not</li> </ul> </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first">The compiled SQL statement as a string</p> </td> </tr> <tr>
<th class="field-name">Return type:</th>
<td class="field-body">
<p class="first last">string</p> </td> </tr>  </table> <p>Compiles a <code>DELETE</code> statement and returns it as a string.</p> </dd>
</dl> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2014&ndash;2020 British Columbia Institute of Technology<br>Licensed under the MIT License.<br>
    <a href="https://codeigniter.com/user_guide/database/query_builder.html" class="_attribution-link">https://codeigniter.com/user_guide/database/query_builder.html</a>
  </p>
</div>
