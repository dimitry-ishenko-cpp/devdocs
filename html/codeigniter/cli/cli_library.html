<h1 id="cli-library">CLI Library</h1> <p>CodeIgniter’s CLI library makes creating interactive command-line scripts simple, including:</p> <ul class="simple"> <li>Prompting the user for more information</li> <li>Writing multi-colored text the terminal</li> <li>Beeping (be nice!)</li> <li>Showing progress bars during long tasks</li> <li>Wrapping long text lines to fit the window.</li> </ul>  <ul class="simple"> <li><a class="reference internal" href="#initializing-the-class" id="id1">Initializing the Class</a></li> <li><a class="reference internal" href="#getting-input-from-the-user" id="id2">Getting Input from the User</a></li> <li><a class="reference internal" href="#providing-feedback" id="id3">Providing Feedback</a></li> </ul>   <h2 id="initializing-the-class">Initializing the Class</h2> <p>You do not need to create an instance of the CLI library, since all of it’s methods are static. Instead, you simply need to ensure your controller can locate it via a <code>use</code> statement above your class:</p> <pre data-language="php">&lt;?php

namespace App\Controllers;

use CodeIgniter\CLI\CLI;

class MyController extends \CodeIgniter\Controller
{
    // ...
}
</pre> <p>The class is automatically initialized when the file is loaded the first time.</p>   <h2 id="getting-input-from-the-user">Getting Input from the User</h2> <p>Sometimes you need to ask the user for more information. They might not have provided optional command-line arguments, or the script may have encountered an existing file and needs confirmation before overwriting. This is handled with the <code>prompt()</code> or <code>promptByKey()</code> method.</p> <p>You can provide a question by passing it in as the first parameter:</p> <pre data-language="php">$color = CLI::prompt('What is your favorite color?');
</pre> <p>You can provide a default answer that will be used if the user just hits enter by passing the default in the second parameter:</p> <pre data-language="php">$color = CLI::prompt('What is your favorite color?', 'blue');
</pre> <p>You can restrict the acceptable answers by passing in an array of allowed answers as the second parameter:</p> <pre data-language="php">$overwrite = CLI::prompt('File exists. Overwrite?', ['y','n']);
</pre> <p>Finally, you can pass <a class="reference internal" href="../libraries/validation.html#validation"><span class="std std-ref">validation</span></a> rules to the answer input as the third parameter:</p> <pre data-language="php">$email = CLI::prompt('What is your email?', null, 'required|valid_email');
</pre> <p>Validation rules can also be written in the array syntax.:</p> <pre data-language="php">$email = CLI::prompt('What is your email?', null, ['required', 'valid_email']);
</pre> <p><strong>promptByKey()</strong></p> <p>Predefined answers (options) for prompt sometimes need to be described or are too complex to select via their value. <code>promptByKey()</code> allows the user to select an option by its key instead of its value:</p> <pre data-language="php">$fruit = CLI::promptByKey('These are your choices:', ['The red apple', 'The plump orange', 'The ripe banana']);

//These are your choices:
//  [0]  The red apple
//  [1]  The plump orange
//  [2]  The ripe banana
//
//[0, 1, 2]:
</pre> <p>Named keys are also possible:</p> <pre data-language="php">$fruit = CLI::promptByKey(['These are your choices:', 'Which would you like?'], [
    'apple' =&gt; 'The red apple',
    'orange' =&gt; 'The plump orange',
    'banana' =&gt; 'The ripe banana'
]);

//These are your choices:
//  [apple]   The red apple
//  [orange]  The plump orange
//  [banana]  The ripe banana
//
//Which would you like? [apple, orange, banana]:
</pre> <p>Finally, you can pass <a class="reference internal" href="../libraries/validation.html#validation"><span class="std std-ref">validation</span></a> rules to the answer input as the third parameter, the acceptable answers are automatically restricted to the passed options.</p>   <h2 id="providing-feedback">Providing Feedback</h2> <p><strong>write()</strong></p> <p>Several methods are provided for you to provide feedback to your users. This can be as simple as a single status update or a complex table of information that wraps to the user’s terminal window. At the core of this is the <code>write()</code> method which takes the string to output as the first parameter:</p> <pre data-language="php">CLI::write('The rain in Spain falls mainly on the plains.');
</pre> <p>You can change the color of the text by passing in a color name as the second parameter:</p> <pre data-language="php">CLI::write('File created.', 'green');
</pre> <p>This could be used to differentiate messages by status, or create ‘headers’ by using a different color. You can even set background colors by passing the color name in as the third parameter:</p> <pre data-language="php">CLI::write('File overwritten.', 'light_red', 'dark_gray');
</pre> <p>The following foreground colors are available:</p> <ul class="simple"> <li>black</li> <li>dark_gray</li> <li>blue</li> <li>dark_blue</li> <li>light_blue</li> <li>green</li> <li>light_green</li> <li>cyan</li> <li>light_cyan</li> <li>red</li> <li>light_red</li> <li>purple</li> <li>light_purple</li> <li>light_yellow</li> <li>yellow</li> <li>light_gray</li> <li>white</li> </ul> <p>And a smaller number are available as background colors:</p> <ul class="simple"> <li>black</li> <li>blue</li> <li>green</li> <li>cyan</li> <li>red</li> <li>yellow</li> <li>light_gray</li> <li>magenta</li> </ul> <p><strong>print()</strong></p> <p>Print functions identically to the <code>write()</code> method, except that it does not force a newline either before or after. Instead it prints it to the screen wherever the cursor is currently. This allows you to print multiple items all on the same line, from different calls. This is especially helpful when you want to show a status, do something, then print “Done” on the same line:</p> <pre data-language="php">for ($i = 0; $i &lt;= 10; $i++) {
    CLI::print($i);
}
</pre> <p><strong>color()</strong></p> <p>While the <code>write()</code> command will write a single line to the terminal, ending it with a EOL character, you can use the <code>color()</code> method to make a string fragment that can be used in the same way, except that it will not force an EOL after printing. This allows you to create multiple outputs on the same row. Or, more commonly, you can use it inside of a <code>write()</code> method to create a string of a different color inside:</p> <pre data-language="php">CLI::write("fileA \t". CLI::color('/path/to/file', 'white'), 'yellow');
</pre> <p>This example would write a single line to the window, with <code>fileA</code> in yellow, followed by a tab, and then <code>/path/to/file</code> in white text.</p> <p><strong>error()</strong></p> <p>If you need to output errors, you should use the appropriately named <code>error()</code> method. This writes light-red text to STDERR, instead of STDOUT, like <code>write()</code> and <code>color()</code> do. This can be useful if you have scripts watching for errors so they don’t have to sift through all of the information, only the actual error messages. You use it exactly as you would the <code>write()</code> method:</p> <pre data-language="php">CLI::error('Cannot write to file: ' . $file);
</pre> <p><strong>wrap()</strong></p> <p>This command will take a string, start printing it on the current line, and wrap it to a set length on new lines. This might be useful when displaying a list of options with descriptions that you want to wrap in the current window and not go off screen:</p> <pre data-language="php">CLI::color("task1\t", 'yellow');
CLI::wrap("Some long description goes here that might be longer than the current window.");
</pre> <p>By default, the string will wrap at the terminal width. Windows currently doesn’t provide a way to determine the window size, so we default to 80 characters. If you want to restrict the width to something shorter that you can be pretty sure fits within the window, pass the maximum line-length as the second parameter. This will break the string at the nearest word barrier so that words are not broken.</p> <pre data-language="php">// Wrap the text at max 20 characters wide
CLI::wrap($description, 20);
</pre> <p>You may find that you want a column on the left of titles, files, or tasks, while you want a column of text on the right with their descriptions. By default, this will wrap back to the left edge of the window, which doesn’t allow things to line up in columns. In cases like this, you can pass in a number of spaces to pad every line after the first line, so that you will have a crisp column edge on the left:</p> <pre data-language="php">$titles = [
    'task1a',
    'task1abc',
];
$descriptions = [
    'Lorem Ipsum is simply dummy text of the printing and typesetting industry.',
    "Lorem Ipsum has been the industry's standard dummy text ever since the",
];

// Determine the maximum length of all titles
// to determine the width of the left column
$maxlen = max(array_map('strlen', $titles));

for ($i = 0; $i &lt; count($titles); $i++) {
    CLI::write(
        // Display the title on the left of the row
        substr(
            $titles[$i] . str_repeat(' ', $maxlen + 3),
            0,
            $maxlen + 3
        ) .
        // Wrap the descriptions in a right-hand column
        // with its left side 3 characters wider than
        // the longest item on the left.
        CLI::wrap($descriptions[$i], 40, $maxlen + 3)
    );
}
</pre> <p>Would create something like this:</p> <pre data-language="none">task1a     Lorem Ipsum is simply dummy
           text of the printing and
           typesetting industry.
task1abc   Lorem Ipsum has been the
           industry's standard dummy
           text ever since the
</pre> <p><strong>newLine()</strong></p> <p>The <code>newLine()</code> method displays a blank line to the user. It does not take any parameters:</p> <pre data-language="php">CLI::newLine();
</pre> <p><strong>clearScreen()</strong></p> <p>You can clear the current terminal window with the <code>clearScreen()</code> method. In most versions of Windows, this will simply insert 40 blank lines since Windows doesn’t support this feature. Windows 10 bash integration should change this:</p> <pre data-language="php">CLI::clearScreen();
</pre> <p><strong>showProgress()</strong></p> <p>If you have a long-running task that you would like to keep the user updated with the progress, you can use the <code>showProgress()</code> method which displays something like the following:</p> <pre data-language="none">[####......] 40% Complete
</pre> <p>This block is animated in place for a very nice effect.</p> <p>To use it, pass in the current step as the first parameter, and the total number of steps as the second parameter. The percent complete and the length of the display will be determined based on that number. When you are done, pass <code>false</code> as the first parameter and the progress bar will be removed.</p> <pre data-language="php">$totalSteps = count($tasks);
$currStep   = 1;

foreach ($tasks as $task) {
    CLI::showProgress($currStep++, $totalSteps);
    $task-&gt;run();
}

// Done, so erase it...
CLI::showProgress(false);
</pre> <p><strong>table()</strong></p> <pre data-language="php">$thead = ['ID', 'Title', 'Updated At', 'Active'];
$tbody = [
    [7, 'A great item title', '2017-11-15 10:35:02', 1],
    [8, 'Another great item title', '2017-11-16 13:46:54', 0]
];

CLI::table($tbody, $thead);
</pre> <pre data-language="none">+----+--------------------------+---------------------+--------+
| ID | Title                    | Updated At          | Active |
+----+--------------------------+---------------------+--------+
| 7  | A great item title       | 2017-11-16 10:35:02 | 1      |
| 8  | Another great item title | 2017-11-16 13:46:54 | 0      |
+----+--------------------------+---------------------+--------+
</pre> <p><strong>wait()</strong></p> <p>Waits a certain number of seconds, optionally showing a wait message and waiting for a key press.</p> <pre data-language="php">// wait for specified interval, with countdown displayed
CLI::wait($seconds, true);

// show continuation message and wait for input
CLI::wait(0, false);

// wait for specified interval
CLI::wait($seconds, false);
</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2014&ndash;2020 British Columbia Institute of Technology<br>Licensed under the MIT License.<br>
    <a href="https://codeigniter.com/user_guide/cli/cli_library.html" class="_attribution-link">https://codeigniter.com/user_guide/cli/cli_library.html</a>
  </p>
</div>
