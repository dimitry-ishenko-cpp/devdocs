<h1 id="uri-routing">URI Routing</h1>  <ul class="simple"> <li><a class="reference internal" href="#setting-your-own-routing-rules" id="id2">Setting your own routing rules</a></li> <li><a class="reference internal" href="#placeholders" id="id3">Placeholders</a></li> <li><a class="reference internal" href="#examples" id="id4">Examples</a></li> <li><a class="reference internal" href="#custom-placeholders" id="id5">Custom Placeholders</a></li> <li><a class="reference internal" href="#regular-expressions" id="id6">Regular Expressions</a></li> <li><a class="reference internal" href="#closures" id="id7">Closures</a></li> <li><a class="reference internal" href="#mapping-multiple-routes" id="id8">Mapping multiple routes</a></li> <li><a class="reference internal" href="#redirecting-routes" id="id9">Redirecting Routes</a></li> <li><a class="reference internal" href="#grouping-routes" id="id10">Grouping Routes</a></li> <li><a class="reference internal" href="#environment-restrictions" id="id11">Environment Restrictions</a></li> <li><a class="reference internal" href="#reverse-routing" id="id12">Reverse Routing</a></li> <li><a class="reference internal" href="#using-named-routes" id="id13">Using Named Routes</a></li> <li><a class="reference internal" href="#using-http-verbs-in-routes" id="id14">Using HTTP verbs in routes</a></li> <li><a class="reference internal" href="#command-line-only-routes" id="id15">Command-Line only Routes</a></li> <li>
<a class="reference internal" href="#global-options" id="id16">Global Options</a><ul> <li><a class="reference internal" href="#applying-filters" id="id17">Applying Filters</a></li> <li><a class="reference internal" href="#assigning-namespace" id="id18">Assigning Namespace</a></li> <li><a class="reference internal" href="#limit-to-hostname" id="id19">Limit to Hostname</a></li> <li><a class="reference internal" href="#limit-to-subdomains" id="id20">Limit to Subdomains</a></li> <li><a class="reference internal" href="#offsetting-the-matched-parameters" id="id21">Offsetting the Matched Parameters</a></li> <li><a class="reference internal" href="#route-processing-queue" id="id22">Route processing queue</a></li> </ul> </li> <li>
<a class="reference internal" href="#routes-configuration-options" id="id23">Routes Configuration Options</a><ul> <li><a class="reference internal" href="#default-namespace" id="id24">Default Namespace</a></li> <li><a class="reference internal" href="#default-controller" id="id25">Default Controller</a></li> <li><a class="reference internal" href="#default-method" id="id26">Default Method</a></li> <li><a class="reference internal" href="#translate-uri-dashes" id="id27">Translate URI Dashes</a></li> <li><a class="reference internal" href="#use-defined-routes-only" id="id28">Use Defined Routes Only</a></li> <li><a class="reference internal" href="#override" id="id29">404 Override</a></li> <li><a class="reference internal" href="#route-processing-by-priority" id="id30">Route processing by priority</a></li> </ul> </li> </ul>  <p>Typically there is a one-to-one relationship between a URL string and its corresponding controller class/method. The segments in a URI normally follow this pattern:</p> <pre data-language="php">example.com/class/method/id/
</pre> <p>In some instances, however, you may want to remap this relationship so that a different class/method can be called instead of the one corresponding to the URL.</p> <p>For example, let’s say you want your URLs to have this prototype:</p> <pre data-language="php">example.com/product/1/
example.com/product/2/
example.com/product/3/
example.com/product/4/
</pre> <p>Normally the second segment of the URL is reserved for the method name, but in the example above it instead has a product ID. To overcome this, CodeIgniter allows you to remap the URI handler.</p>  <h2 id="setting-your-own-routing-rules">Setting your own routing rules</h2> <p>Routing rules are defined in the <strong>app/Config/Routes.php</strong> file. In it you’ll see that it creates an instance of the RouteCollection class that permits you to specify your own routing criteria. Routes can be specified using placeholders or Regular Expressions.</p> <p>A route simply takes the URI on the left, and maps it to the controller and method on the right, along with any parameters that should be passed to the controller. The controller and method should be listed in the same way that you would use a static method, by separating the fully-namespaced class and its method with a double-colon, like <code>Users::list</code>. If that method requires parameters to be passed to it, then they would be listed after the method name, separated by forward-slashes:</p> <pre data-language="php">// Calls the $Users-&gt;list()
Users::list
// Calls $Users-&gt;list(1, 23)
Users::list/1/23
</pre>   <h2 id="placeholders">Placeholders</h2> <p>A typical route might look something like this:</p> <pre data-language="php">$routes-&gt;add('product/(:num)', 'App\Catalog::productLookup');
</pre> <p>In a route, the first parameter contains the URI to be matched, while the second parameter contains the destination it should be re-routed to. In the above example, if the literal word “product” is found in the first segment of the URL, and a number is found in the second segment, the “AppCatalog” class and the “productLookup” method are used instead.</p> <p>Placeholders are simply strings that represent a Regular Expression pattern. During the routing process, these placeholders are replaced with the value of the Regular Expression. They are primarily used for readability.</p> <p>The following placeholders are available for you to use in your routes:</p> <table class="docutils">  <thead valign="bottom"> <tr>
<th class="head">Placeholders</th> <th class="head">Description</th> </tr> </thead>  <tr>
<td>(:any)</td> <td>will match all characters from that point to the end of the URI. This may include multiple URI segments.</td> </tr> <tr>
<td>(:segment)</td> <td>will match any character except for a forward slash (/) restricting the result to a single segment.</td> </tr> <tr>
<td>(:num)</td> <td>will match any integer.</td> </tr> <tr>
<td>(:alpha)</td> <td>will match any string of alphabetic characters</td> </tr> <tr>
<td>(:alphanum)</td> <td>will match any string of alphabetic characters or integers, or any combination of the two.</td> </tr> <tr>
<td>(:hash)</td> <td>is the same as <strong>(:segment)</strong>, but can be used to easily see which routes use hashed ids.</td> </tr>  </table> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last"><strong>{locale}</strong> cannot be used as a placeholder or other part of the route, as it is reserved for use in <a class="reference internal" href="../outgoing/localization.html"><span class="doc">localization</span></a>.</p> </div>   <h2 id="examples">Examples</h2> <p>Here are a few basic routing examples.</p> <p>A URL containing the word “journals” in the first segment will be remapped to the “AppBlogs” class, and the default method, which is usually <code>index()</code>:</p> <pre data-language="php">$routes-&gt;add('journals', 'App\Blogs');
</pre> <p>A URL containing the segments “blog/joe” will be remapped to the “Blogs” class and the “users” method. The ID will be set to “34”:</p> <pre data-language="php">$routes-&gt;add('blog/joe', 'Blogs::users/34');
</pre> <p>A URL with “product” as the first segment, and anything in the second will be remapped to the “Catalog” class and the “productLookup” method:</p> <pre data-language="php">$routes-&gt;add('product/(:any)', 'Catalog::productLookup');
</pre> <p>A URL with “product” as the first segment, and a number in the second will be remapped to the “Catalog” class and the “productLookupByID” method passing in the match as a variable to the method:</p> <pre data-language="php">$routes-&gt;add('product/(:num)', 'Catalog::productLookupByID/$1');
</pre> <p>Note that a single <code>(:any)</code> will match multiple segments in the URL if present. For example the route:</p> <pre data-language="php">$routes-&gt;add('product/(:any)', 'Catalog::productLookup/$1');
</pre> <p>will match product/123, product/123/456, product/123/456/789 and so on. The implementation in the Controller should take into account the maximum parameters:</p> <pre data-language="php">public function productLookup($seg1 = false, $seg2 = false, $seg3 = false) {
    echo $seg1; // Will be 123 in all examples
    echo $seg2; // false in first, 456 in second and third example
    echo $seg3; // false in first and second, 789 in third
}
</pre> <p>If matching multiple segments is not the intended behavior, <code>(:segment)</code> should be used when defining the routes. With the examples URLs from above:</p> <pre data-language="php">$routes-&gt;add('product/(:segment)', 'Catalog::productLookup/$1');
</pre> <p>will only match product/123 and generate 404 errors for other example.</p> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">While the <code>add()</code> method is convenient, it is recommended to always use the HTTP-verb-based routes, described below, as it is more secure. If you use the <a class="reference internal" href="../libraries/security.html"><span class="doc">CSRF protection</span></a>, it does not protect <strong>GET</strong> requests. If the URI specified in the <code>add()</code> method is accessible by the GET method, the CSRF protection will not work.</p> </div> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Using the HTTP-verb-based routes will also provide a slight performance increase, since only routes that match the current request method are stored, resulting in fewer routes to scan through when trying to find a match.</p> </div>   <h2 id="custom-placeholders">Custom Placeholders</h2> <p>You can create your own placeholders that can be used in your routes file to fully customize the experience and readability.</p> <p>You add new placeholders with the <code>addPlaceholder</code> method. The first parameter is the string to be used as the placeholder. The second parameter is the Regular Expression pattern it should be replaced with. This must be called before you add the route:</p> <pre data-language="php">$routes-&gt;addPlaceholder('uuid', '[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}');
$routes-&gt;add('users/(:uuid)', 'Users::show/$1');
</pre>   <h2 id="regular-expressions">Regular Expressions</h2> <p>If you prefer you can use regular expressions to define your routing rules. Any valid regular expression is allowed, as are back-references.</p> <div class="admonition important"> <p class="first admonition-title">Important</p> <p>Note: If you use back-references you must use the dollar syntax rather than the double backslash syntax. A typical RegEx route might look something like this:</p> <pre data-language="php">$routes-&gt;add('products/([a-z]+)/(\d+)', 'Products::show/$1/id_$2');
</pre> </div> <p>In the above example, a URI similar to products/shirts/123 would instead call the <code>show</code> method of the <code>Products</code> controller class, with the original first and second segment passed as arguments to it.</p> <p>With regular expressions, you can also catch a segment containing a forward slash (‘/’), which would usually represent the delimiter between multiple segments.</p> <p>For example, if a user accesses a password protected area of your web application and you wish to be able to redirect them back to the same page after they log in, you may find this example useful:</p> <pre data-language="php">$routes-&gt;add('login/(.+)', 'Auth::login/$1');
</pre> <p>For those of you who don’t know regular expressions and want to learn more about them, <a class="reference external" href="https://www.regular-expressions.info/">regular-expressions.info</a> might be a good starting point.</p> <div class="admonition important"> <p class="first admonition-title">Important</p> <p class="last">Note: You can also mix and match wildcards with regular expressions.</p> </div>   <h2 id="closures">Closures</h2> <p>You can use an anonymous function, or Closure, as the destination that a route maps to. This function will be executed when the user visits that URI. This is handy for quickly executing small tasks, or even just showing a simple view:</p> <pre data-language="php">$routes-&gt;add('feed', function () {
    $rss = new RSSFeeder();

    return $rss-&gt;feed('general');
});
</pre>   <h2 id="mapping-multiple-routes">Mapping multiple routes</h2> <p>While the add() method is simple to use, it is often handier to work with multiple routes at once, using the <code>map()</code> method. Instead of calling the <code>add()</code> method for each route that you need to add, you can define an array of routes and then pass it as the first parameter to the <code>map()</code> method:</p> <pre data-language="php">$routes = [];
$routes['product/(:num)'] = 'Catalog::productLookupById';
$routes['product/(:alphanum)'] = 'Catalog::productLookupByName';

$collection-&gt;map($routes);
</pre>   <h2 id="redirecting-routes">Redirecting Routes</h2> <p>Any site that lives long enough is bound to have pages that move. You can specify routes that should redirect to other routes with the <code>addRedirect()</code> method. The first parameter is the URI pattern for the old route. The second parameter is either the new URI to redirect to, or the name of a named route. The third parameter is the HTTP status code that should be sent along with the redirect. The default value is <code>302</code> which is a temporary redirect and is recommended in most cases:</p> <pre data-language="php">$routes-&gt;add('users/profile', 'Users::profile', ['as' =&gt; 'profile']);

// Redirect to a named route
$routes-&gt;addRedirect('users/about', 'profile');
// Redirect to a URI
$routes-&gt;addRedirect('users/about', 'users/profile');
</pre> <p>If a redirect route is matched during a page load, the user will be immediately redirected to the new page before a controller can be loaded.</p>   <h2 id="grouping-routes">Grouping Routes</h2> <p>You can group your routes under a common name with the <code>group()</code> method. The group name becomes a segment that appears prior to the routes defined inside of the group. This allows you to reduce the typing needed to build out an extensive set of routes that all share the opening string, like when building an admin area:</p> <pre data-language="php">$routes-&gt;group('admin', function ($routes) {
    $routes-&gt;add('users', 'Admin\Users::index');
    $routes-&gt;add('blog', 'Admin\Blog::index');
});
</pre> <p>This would prefix the ‘users’ and ‘blog” URIs with “admin”, handling URLs like <code>/admin/users</code> and <code>/admin/blog</code>.</p> <p>If you need to assign options to a group, like a <a class="reference external" href="#assigning-namespace">namespace</a>, do it before the callback:</p> <pre data-language="php">$routes-&gt;group('api', ['namespace' =&gt; 'App\API\v1'], function ($routes) {
    $routes-&gt;resource('users');
});
</pre> <p>This would handle a resource route to the <code>App\API\v1\Users</code> controller with the <code>/api/users</code> URI.</p> <p>You can also use a specific <a class="reference external" href="filters.html">filter</a> for a group of routes. This will always run the filter before or after the controller. This is especially handy during authentication or api logging:</p> <pre data-language="php">$routes-&gt;group('api', ['filter' =&gt; 'api-auth'], function ($routes) {
    $routes-&gt;resource('users');
});
</pre> <p>The value for the filter must match one of the aliases defined within <strong>app/Config/Filters.php</strong>.</p> <p>It is possible to nest groups within groups for finer organization if you need it:</p> <pre data-language="php">$routes-&gt;group('admin', function ($routes) {
    $routes-&gt;group('users', function ($routes) {
        $routes-&gt;add('list', 'Admin\Users::list');
    });
});
</pre> <p>This would handle the URL at <code>admin/users/list</code>. Note that options passed to the outer <code>group()</code> (for example <code>namespace</code> and <code>filter</code>) are not merged with the inner <code>group()</code> options.</p> <p>At some point, you may want to group routes for the purpose of applying filters or other route config options like namespace, subdomain, etc. Without necessarily needing to add a prefix to the group, you can pass an empty string in place of the prefix and the routes in the group will be routed as though the group never existed but with the given route config options.</p>   <h2 id="environment-restrictions">Environment Restrictions</h2> <p>You can create a set of routes that will only be viewable in a certain environment. This allows you to create tools that only the developer can use on their local machines that are not reachable on testing or production servers. This can be done with the <code>environment()</code> method. The first parameter is the name of the environment. Any routes defined within this closure are only accessible from the given environment:</p> <pre data-language="php">$routes-&gt;environment('development', function ($routes) {
    $routes-&gt;add('builder', 'Tools\Builder::index');
});
</pre>   <h2 id="reverse-routing">Reverse Routing</h2> <p>Reverse routing allows you to define the controller and method, as well as any parameters, that a link should go to, and have the router lookup the current route to it. This allows route definitions to change without you having to update your application code. This is typically used within views to create links.</p> <p>For example, if you have a route to a photo gallery that you want to link to, you can use the <code>route_to()</code> helper function to get the current route that should be used. The first parameter is the fully qualified Controller and method, separated by a double colon (::), much like you would use when writing the initial route itself. Any parameters that should be passed to the route are passed in next:</p> <pre data-language="php">// The route is defined as:
$routes-&gt;add('users/(:num)/gallery(:any)', 'App\Controllers\Galleries::showUserGallery/$1/$2');

// Generate the relative URL to link to user ID 15, gallery 12
// Generates: /users/15/gallery/12
&lt;a href="&lt;?= route_to('App\Controllers\Galleries::showUserGallery', 15, 12) ?&gt;.html"&gt;View Gallery&lt;/a&gt;
</pre>   <h2 id="using-named-routes">Using Named Routes</h2> <p>You can name routes to make your application less fragile. This applies a name to a route that can be called later, and even if the route definition changes, all of the links in your application built with <code>route_to</code> will still work without you having to make any changes. A route is named by passing in the <code>as</code> option with the name of the route:</p> <pre data-language="php">// The route is defined as:
$routes-&gt;add('users/(:num)/gallery(:any)', 'Galleries::showUserGallery/$1/$2', ['as' =&gt; 'user_gallery']);

// Generate the relative URL to link to user ID 15, gallery 12
// Generates: /users/15/gallery/12
&lt;a href="&lt;?= route_to('user_gallery', 15, 12) ?&gt;.html"&gt;View Gallery&lt;/a&gt;
</pre> <p>This has the added benefit of making the views more readable, too.</p>   <h2 id="using-http-verbs-in-routes">Using HTTP verbs in routes</h2> <p>It is possible to use HTTP verbs (request method) to define your routing rules. This is particularly useful when building RESTFUL applications. You can use any standard HTTP verb (GET, POST, PUT, DELETE, etc). Each verb has its own method you can use:</p> <pre data-language="php">$routes-&gt;get('products', 'Product::feature');
$routes-&gt;post('products', 'Product::feature');
$routes-&gt;put('products/(:num)', 'Product::feature');
$routes-&gt;delete('products/(:num)', 'Product::feature');
</pre> <p>You can supply multiple verbs that a route should match by passing them in as an array to the <code>match</code> method:</p> <pre data-language="php">$routes-&gt;match(['get', 'put'], 'products', 'Product::feature');
</pre>   <h2 id="command-line-only-routes">Command-Line only Routes</h2> <p>You can create routes that work only from the command-line, and are inaccessible from the web browser, with the <code>cli()</code> method. This is great for building cronjobs or CLI-only tools. Any route created by any of the HTTP-verb-based route methods will also be inaccessible from the CLI, but routes created by the <code>any()</code> method will still be available from the command line:</p> <pre data-language="php">$routes-&gt;cli('migrate', 'App\Database::migrate');
</pre>   <h2 id="global-options">Global Options</h2> <p>All of the methods for creating a route (add, get, post, <a class="reference external" href="restful.html">resource</a> etc) can take an array of options that can modify the generated routes, or further restrict them. The <code>$options</code> array is always the last parameter:</p> <pre data-language="php">$routes-&gt;add('from', 'to', $options);
$routes-&gt;get('from', 'to', $options);
$routes-&gt;post('from', 'to', $options);
$routes-&gt;put('from', 'to', $options);
$routes-&gt;head('from', 'to', $options);
$routes-&gt;options('from', 'to', $options);
$routes-&gt;delete('from', 'to', $options);
$routes-&gt;patch('from', 'to', $options);
$routes-&gt;match(['get', 'put'], 'from', 'to', $options);
$routes-&gt;resource('photos', $options);
$routes-&gt;map($array, $options);
$routes-&gt;group('name', $options, function ());
</pre>  <h3 id="applying-filters">Applying Filters</h3> <p>You can alter the behavior of specific routes by supplying filters to run before or after the controller. This is especially handy during authentication or api logging. The value for the filter can be a string or an array of strings:</p> <ul class="simple"> <li>matching the aliases defined in <strong>app/Config/Filters.php</strong>.</li> <li>filter classnames</li> </ul> <p>See <a class="reference external" href="filters.html">Controller filters</a> for more information on setting up filters.</p> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">If you set filters to routes in <strong>app/Config/Routes.php</strong> (not in <strong>app/Config/Filters.php</strong>), it is recommended to disable auto-routing. When auto-routing is enabled, it may be possible that a controller can be accessed via a different URL than the configured route, in which case the filter you specified to the route will not be applied. See <a class="reference internal" href="#use-defined-routes-only"><span class="std std-ref">Use Defined Routes Only</span></a> to disable auto-routing.</p> </div> <p><strong>Alias filter</strong></p> <p>You specify an alias defined in <strong>app/Config/Filters.php</strong> for the filter value:</p> <pre data-language="php">$routes-&gt;add('admin',' AdminController::index', ['filter' =&gt; 'admin-auth']);
</pre> <p>You may also supply arguments to be passed to the alias filter’s <code>before()</code> and <code>after()</code> methods:</p> <pre data-language="php">$routes-&gt;add('users/delete/(:segment)', 'AdminController::index', ['filter' =&gt; 'admin-auth:dual,noreturn']);
</pre> <p><strong>Classname filter</strong></p> <p>You specify a filter classname for the filter value:</p> <pre data-language="php">$routes-&gt;add('admin',' AdminController::index', ['filter' =&gt; \App\Filters\SomeFilter::class]);
</pre> <p><strong>Multiple filters</strong></p> <div class="admonition important"> <p class="first admonition-title">Important</p> <p class="last"><em>Multiple filters</em> is disabled by default. Because it breaks backward compatibility. If you want to use it, you need to configure. See <em>Multiple filters for a route</em> in <a class="reference internal" href="https://codeigniter.com/user_guide/installation/upgrade_415.html"><span class="doc">Upgrading from 4.1.4 to 4.1.5</span></a> for the details.</p> </div> <p>You specify an array for the filter value:</p> <pre data-language="php">$routes-&gt;add('admin',' AdminController::index', ['filter' =&gt; ['admin-auth', \App\Filters\SomeFilter::class]]);
</pre>   <h3 id="assigning-namespace">Assigning Namespace</h3> <p>While a default namespace will be prepended to the generated controllers (see below), you can also specify a different namespace to be used in any options array, with the <code>namespace</code> option. The value should be the namespace you want modified:</p> <pre data-language="php">// Routes to \Admin\Users::index()
$routes-&gt;add('admin/users', 'Users::index', ['namespace' =&gt; 'Admin']);
</pre> <p>The new namespace is only applied during that call for any methods that create a single route, like get, post, etc. For any methods that create multiple routes, the new namespace is attached to all routes generated by that function or, in the case of <code>group()</code>, all routes generated while in the closure.</p>   <h3 id="limit-to-hostname">Limit to Hostname</h3> <p>You can restrict groups of routes to function only in certain domain or sub-domains of your application by passing the “hostname” option along with the desired domain to allow it on as part of the options array:</p> <pre data-language="php">$collection-&gt;get('from', 'to', ['hostname' =&gt; 'accounts.example.com']);
</pre> <p>This example would only allow the specified hosts to work if the domain exactly matched “accounts.example.com”. It would not work under the main site at “example.com”.</p>   <h3 id="limit-to-subdomains">Limit to Subdomains</h3> <p>When the <code>subdomain</code> option is present, the system will restrict the routes to only be available on that sub-domain. The route will only be matched if the subdomain is the one the application is being viewed through:</p> <pre data-language="php">// Limit to media.example.com
$routes-&gt;add('from', 'to', ['subdomain' =&gt; 'media']);
</pre> <p>You can restrict it to any subdomain by setting the value to an asterisk, (*). If you are viewing from a URL that does not have any subdomain present, this will not be matched:</p> <pre data-language="php">// Limit to any sub-domain
$routes-&gt;add('from', 'to', ['subdomain' =&gt; '*']);
</pre> <div class="admonition important"> <p class="first admonition-title">Important</p> <p class="last">The system is not perfect and should be tested for your specific domain before being used in production. Most domains should work fine but some edge case ones, especially with a period in the domain itself (not used to separate suffixes or www) can potentially lead to false positives.</p> </div>   <h3 id="offsetting-the-matched-parameters">Offsetting the Matched Parameters</h3> <p>You can offset the matched parameters in your route by any numeric value with the <code>offset</code> option, with the value being the number of segments to offset.</p> <p>This can be beneficial when developing API’s with the first URI segment being the version number. It can also be used when the first parameter is a language string:</p> <pre data-language="php">$routes-&gt;get('users/(:num)', 'users/show/$1', ['offset' =&gt; 1]);

// Creates:
$routes['users/(:num)'] = 'users/show/$2';
</pre>   <h3 id="priority">Route processing queue</h3> <p id="route-processing-queue">When working with modules, it can be a problem if the routes in the application contain wildcards. Then the module routes will not be processed correctly. You can solve this problem by lowering the priority of route processing using the <code>priority</code> option. The parameter accepts positive integers and zero. The higher the number specified in the “priority”, the lower route priority in the processing queue:</p> <pre data-language="php">// First you need to enable sorting.
$routes-&gt;setPrioritize();

// App\Config\Routes
$routes-&gt;add('(.*)', 'Posts::index', ['priority' =&gt; 1]);

// Modules\Acme\Config\Routes
$routes-&gt;add('admin', 'Admin::index');

// The "admin" route will now be processed before the wildcard router.
</pre> <p>To disable this functionality, you must call the method with the parameter <code>false</code>:</p> <pre data-language="php">$routes-&gt;setPrioritize(false);
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">By default, all routes have a priority of 0. Negative integers will be cast to the absolute value.</p> </div>    <h2 id="routes-configuration-options">Routes Configuration Options</h2> <p>The RoutesCollection class provides several options that affect all routes, and can be modified to meet your application’s needs. These options are available at the top of <strong>app/Config/Routes.php</strong>.</p>  <h3 id="default-namespace">Default Namespace</h3> <p>When matching a controller to a route, the router will add the default namespace value to the front of the controller specified by the route. By default, this value is empty, which leaves each route to specify the fully namespaced controller:</p> <pre data-language="php">$routes-&gt;setDefaultNamespace('');

// Controller is \Users
$routes-&gt;add('users', 'Users::index');

// Controller is \Admin\Users
$routes-&gt;add('users', 'Admin\Users::index');
</pre> <p>If your controllers are not explicitly namespaced, there is no need to change this. If you namespace your controllers, then you can change this value to save typing:</p> <pre data-language="php">$routes-&gt;setDefaultNamespace('App');

// Controller is \App\Users
$routes-&gt;add('users', 'Users::index');

// Controller is \App\Admin\Users
$routes-&gt;add('users', 'Admin\Users::index');
</pre>   <h3 id="default-controller">Default Controller</h3> <p>When a user visits the root of your site (i.e., example.com) the controller to use is determined by the value set by the <code>setDefaultController()</code> method, unless a route exists for it explicitly. The default value for this is <code>Home</code> which matches the controller at <code>/app/Controllers/Home.php</code>:</p> <pre data-language="php">// example.com routes to app/Controllers/Welcome.php
$routes-&gt;setDefaultController('Welcome');
</pre> <p>The default controller is also used when no matching route has been found, and the URI would point to a directory in the controllers directory. For example, if the user visits <code>example.com/admin</code>, if a controller was found at <code>/app/Controllers/admin/Home.php</code> it would be used.</p>   <h3 id="default-method">Default Method</h3> <p>This works similar to the default controller setting, but is used to determine the default method that is used when a controller is found that matches the URI, but no segment exists for the method. The default value is <code>index</code>.</p> <p>In this example, if the user were to visit example.com/products, and a Products controller existed, the <code>Products::listAll()</code> method would be executed:</p> <pre data-language="php">$routes-&gt;setDefaultMethod('listAll');
</pre>   <h3 id="translate-uri-dashes">Translate URI Dashes</h3> <p>This option enables you to automatically replace dashes (‘-‘) with underscores in the controller and method URI segments, thus saving you additional route entries if you need to do that. This is required because the dash isn’t a valid class or method name character and would cause a fatal error if you try to use it:</p> <pre data-language="php">$routes-&gt;setTranslateURIDashes(true);
</pre>   <h3 id="id1">Use Defined Routes Only</h3> <p id="use-defined-routes-only">When no defined route is found that matches the URI, the system will attempt to match that URI against the controllers and methods as described above. You can disable this automatic matching, and restrict routes to only those defined by you, by setting the <code>setAutoRoute()</code> option to false:</p> <pre data-language="php">$routes-&gt;setAutoRoute(false);
</pre> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">If you use the <a class="reference internal" href="../libraries/security.html"><span class="doc">CSRF protection</span></a>, it does not protect <strong>GET</strong> requests. If the URI is accessible by the GET method, the CSRF protection will not work.</p> </div>   <h3 id="override">404 Override</h3> <p>When a page is not found that matches the current URI, the system will show a generic 404 view. You can change what happens by specifying an action to happen with the <code>set404Override()</code> option. The value can be either a valid class/method pair, just like you would show in any route, or a Closure:</p> <pre data-language="php">// Would execute the show404 method of the App\Errors class
$routes-&gt;set404Override('App\Errors::show404');

// Will display a custom view
$routes-&gt;set404Override(function ()
{
    echo view('my_errors/not_found.html');
});
</pre>   <h3 id="route-processing-by-priority">Route processing by priority</h3> <p>Enables or disables processing of the routes queue by priority. Lowering the priority is defined in the route option. Disabled by default. This functionality affects all routes. For an example of use lowering the priority see <a class="reference internal" href="#priority"><span class="std std-ref">Route processing queue</span></a>:</p> <pre data-language="php">// to enable
$routes-&gt;setPrioritize();

// to disable
$routes-&gt;setPrioritize(false);
</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2014&ndash;2020 British Columbia Institute of Technology<br>Licensed under the MIT License.<br>
    <a href="https://codeigniter.com/user_guide/incoming/routing.html" class="_attribution-link">https://codeigniter.com/user_guide/incoming/routing.html</a>
  </p>
</div>
