<h1 class="title">Versioning of Extensions</h1>  <h2 id="extension-versioning"> <a style="text-decoration: none;" href="#extension-versioning">Extension Versioning</a> </h2> <p>Most software has some sort of version number. Version numbers serve a few important goals:</p> <ul> <li>Tie a binary to a specific state of the source code</li> <li>Allow determining the expected feature set</li> <li>Allow determining the state of the APIs</li> <li>Allow efficient processing of bug reports (e.g., bug <code class="language-plaintext highlighter-rouge">#1337</code> was introduced in version <code class="language-plaintext highlighter-rouge">v3.4.5</code> )</li> <li>Allow determining chronological order of releases (e.g., version <code class="language-plaintext highlighter-rouge">v1.2.3</code> is older than <code class="language-plaintext highlighter-rouge">v1.2.4</code>)</li> <li>Give an indication of expected stability (e.g., <code class="language-plaintext highlighter-rouge">v0.0.1</code> is likely not very stable, whereas <code class="language-plaintext highlighter-rouge">v13.11.0</code> probably is stable)</li> </ul> <p>Just like <a href="../dev/release_calendar.html">DuckDB itself</a>, DuckDB extensions have their own version number. To ensure consistent semantics of these version numbers across the various extensions, DuckDB's <a href="core_extensions.html">Core Extensions</a> use a versioning scheme that prescribes how extensions should be versioned. The versioning scheme for Core Extensions is made up of 3 different stability levels: <strong>unstable</strong>, <strong>pre-release</strong>, and <strong>stable</strong>. Let's go over each of the 3 levels and describe their format:</p> <h3 id="unstable-extensions"> <a style="text-decoration: none;" href="#unstable-extensions">Unstable Extensions</a> </h3> <p>Unstable extensions are extensions that can't (or don't want to) give any guarantees regarding their current stability, or their goals of becoming stable. Unstable extensions are tagged with the <strong>short git hash</strong> of the extension.</p> <p>For example, at the time of writing this, the version of the <code class="language-plaintext highlighter-rouge">vss</code> extension is an unstable extension of version <code class="language-plaintext highlighter-rouge">690bfc5</code>.</p> <p>What to expect from an extension that has a version number in the <strong>unstable</strong> format?</p> <ul> <li>The state of the source code of the extension can be found by looking up the hash in the extension repository</li> <li>Functionality may change or be removed completely with every release</li> <li>This extension's API could change with every release</li> <li>This extension may not follow a structured release cycle, new (breaking) versions can be pushed at any time</li> </ul> <h3 id="pre-release-extensions"> <a style="text-decoration: none;" href="#pre-release-extensions">Pre-Release Extensions</a> </h3> <p>Pre-release extensions are the next step up from Unstable extensions. They are tagged with version in the <strong><a href="https://semver.org/">SemVer</a></strong> format, more specifically, those in the <code class="language-plaintext highlighter-rouge">v0.y.z</code> format. In semantic versioning, versions starting with <code class="language-plaintext highlighter-rouge">v0</code> have a special meaning: they indicate that the more strict semantics of regular (<code class="language-plaintext highlighter-rouge">&gt;v1.0.0</code>) versions do not yet apply. It basically means that an extensions is working towards becoming a stable extension, but is not quite there yet.</p> <p>For example, at the time of writing this, the version of the <code class="language-plaintext highlighter-rouge">delta</code> extension is a pre-release extension of version <code class="language-plaintext highlighter-rouge">v0.1.0</code>.</p> <p>What to expect from an extension that has a version number in the <strong>pre-release</strong> format?</p> <ul> <li>The extension is compiled from the source code corresponding to the tag.</li> <li>Semantic Versioning semantics apply. See the <a href="https://semver.org/">Semantic Versioning</a> specification for details.</li> <li>The extension follows a release cycle where new features are tested in nightly builds before being grouped into a release and pushed to the <code class="language-plaintext highlighter-rouge">core</code> repository.</li> <li>Release notes describing what has been added each release should be available to make it easy to understand the difference between versions.</li> </ul> <h3 id="stable-extensions"> <a style="text-decoration: none;" href="#stable-extensions">Stable Extensions</a> </h3> <p>Stable extensions are the final step of extension stability. This is denoted by using a <strong>stable SemVer</strong> of format <code class="language-plaintext highlighter-rouge">vx.y.z</code> where <code class="language-plaintext highlighter-rouge">x&gt;0</code>.</p> <p>For example, at the time of writing this, the version of the <code class="language-plaintext highlighter-rouge">parquet</code> extension is a stable extension of version <code class="language-plaintext highlighter-rouge">v1.0.0</code>.</p> <p>What to expect from an extension that has a version number in the <strong>stable</strong> format? Essentially the same as pre-release extensions, but now the more strict SemVer semantics apply: the API of the extension should now be stable and will only change in backwards incompatible ways when the major version is bumped. See the SemVer specification for details</p> <h2 id="release-cycle-of-pre-release-and-stable-core-extensions"> <a style="text-decoration: none;" href="#release-cycle-of-pre-release-and-stable-core-extensions">Release Cycle of Pre-Release and Stable Core Extensions</a> </h2> <p>In general for extensions the release cycle depends on their stability level. <strong>unstable</strong> extensions are often in sync with DuckDB's release cycle, but may also be quietly updated between DuckDB releases. <strong>pre-release</strong> and <strong>stable</strong> extensions follow their own release cycle. These may or may not coincide with DuckDB releases. To find out more about the release cycle of a specific extension, refer to the documentation or GitHub page of the respective extension. Generally, <strong>pre-release</strong> and <strong>stable</strong> extensions will document their releases as GitHub releases, an example of which you can see in the <a href="https://github.com/duckdb/duckdb_delta/releases">delta extension</a>.</p> <p>Finally, there is a small exception: All <a href="working_with_extensions.html#in-tree-vs-out-of-tree.html">in-tree</a> extensions simply follow DuckDB's release cycle.</p> <h2 id="nightly-builds"> <a style="text-decoration: none;" href="#nightly-builds">Nightly Builds</a> </h2> <p>Just like DuckDB itself, DuckDB's core extensions have nightly or dev builds that can be used to try out features before they are officially released. This can be useful when your workflow depends on a new feature, or when you need to confirm that your stack is compatible with the upcoming version.</p> <p>Nightly builds for extensions are slightly complicated due to the fact that currently DuckDB extensions binaries are tightly bound to a single DuckDB version. Because of this tight connection, there is a potential risk for a combinatory explosion. Therefore, not all combinations of nightly extension build and nightly DuckDB build are available.</p> <p>In general, there are 2 ways of using nightly builds: using a nightly DuckDB build and using a stable DuckDB build. Let's go over the differences between the two:</p> <h3 id="from-stable-duckdb"> <a style="text-decoration: none;" href="#from-stable-duckdb">From Stable DuckDB</a> </h3> <p>In most cases, user's will be interested in a nightly build of a specific extension, but don't necessarily want to switch to using the nightly build of DuckDB itself. This allows using a specific bleeding-edge feature while limiting the exposure to unstable code.</p> <p>To achieve this, Core Extensions tend to regularly push builds to the <a href="working_with_extensions.html#extension-repositories.html"><code class="language-plaintext highlighter-rouge">core_nightly</code> repository</a>. Let's look at an example:</p> <p>First we install a <a href="http://localhost:8000/docs/installation/"><strong>stable DuckDB build</strong></a>.</p> <p>Then we can install and load a <strong>nightly</strong> extension like this:</p> <pre class="language-sql highlighter-rouge" data-language="sql">INSTALL aws FROM core_nightly;
LOAD aws;</pre> <p>In this example we are using the latest <strong>nightly</strong> build of the aws extension with the latest <strong>stable</strong> version of DuckDB.</p> <h3 id="from-nightly-duckdb"> <a style="text-decoration: none;" href="#from-nightly-duckdb">From Nightly DuckDB</a> </h3> <p>When DuckDB CI produces a nightly binary of DuckDB itself, the binaries are distributed with a set of extensions that are pinned at a specific version. This extension version will be tested for that specific build of DuckDB, but might not be the latest dev build. Let's look at an example:</p> <p>First, we install a <a href="http://localhost:8000/docs/installation/"><strong>nightly DuckDB build</strong></a>. Then, we can install and load the <code class="language-plaintext highlighter-rouge">aws</code> extension as expected:</p> <pre class="language-sql highlighter-rouge" data-language="sql">INSTALL aws;
LOAD aws;</pre> <h2 id="updating-extensions"> <a style="text-decoration: none;" href="#updating-extensions">Updating Extensions</a> </h2> <p>DuckDB has a dedicated statement that will automatically update all extensions to their latest version. The output will give the user information on which extensions were updated to/from which version. For example:</p> <pre class="language-sql highlighter-rouge" data-language="sql">UPDATE EXTENSIONS;</pre>  <table> <thead> <tr> <th style="text-align: left">extension_name</th> <th style="text-align: left">repository</th> <th style="text-align: left">update_result</th> <th style="text-align: left">previous_version</th> <th style="text-align: left">current_version</th> </tr> </thead> <tbody> <tr> <td style="text-align: left">httpfs</td> <td style="text-align: left">core</td> <td style="text-align: left">NO_UPDATE_AVAILABLE</td> <td style="text-align: left">70fd6a8a24</td> <td style="text-align: left">70fd6a8a24</td> </tr> <tr> <td style="text-align: left">delta</td> <td style="text-align: left">core</td> <td style="text-align: left">UPDATED</td> <td style="text-align: left">d9e5cc1</td> <td style="text-align: left">04c61e4</td> </tr> <tr> <td style="text-align: left">azure</td> <td style="text-align: left">core</td> <td style="text-align: left">NO_UPDATE_AVAILABLE</td> <td style="text-align: left">49b63dc</td> <td style="text-align: left">49b63dc</td> </tr> <tr> <td style="text-align: left">aws</td> <td style="text-align: left">core_nightly</td> <td style="text-align: left">NO_UPDATE_AVAILABLE</td> <td style="text-align: left">42c78d3</td> <td style="text-align: left">42c78d3</td> </tr> </tbody> </table> <p>Note that DuckDB will look for updates in the source repository for each extension. So if an extension was installed from <code class="language-plaintext highlighter-rouge">core_nightly</code>, it will be updated with the latest nightly build.</p> <p>The update statement can also be provided with a list of specific extensions to update:</p> <pre class="language-sql highlighter-rouge" data-language="sql">UPDATE EXTENSIONS (httpfs, azure);</pre>  <table> <thead> <tr> <th style="text-align: left">extension_name</th> <th style="text-align: left">repository</th> <th style="text-align: left">update_result</th> <th style="text-align: left">previous_version</th> <th style="text-align: left">current_version</th> </tr> </thead> <tbody> <tr> <td style="text-align: left">httpfs</td> <td style="text-align: left">core</td> <td style="text-align: left">NO_UPDATE_AVAILABLE</td> <td style="text-align: left">70fd6a8a24</td> <td style="text-align: left">70fd6a8a24</td> </tr> <tr> <td style="text-align: left">azure</td> <td style="text-align: left">core</td> <td style="text-align: left">NO_UPDATE_AVAILABLE</td> <td style="text-align: left">49b63dc</td> <td style="text-align: left">49b63dc</td> </tr> </tbody> </table> <h2 id="target-duckdb-version"> <a style="text-decoration: none;" href="#target-duckdb-version">Target DuckDB Version</a> </h2> <p>Currently, when extensions are compiled, they are tied to a specific version of DuckDB. What this means is that, for example, an extension binary compiled for v0.10.3 does not work for v1.0.0. In most cases, this will not cause any issues and is fully transparent; DuckDB will automatically ensure it installs the correct binary for its version. For extension developers, this means that they must ensure that new binaries are created whenever a new version of DuckDB is released. However, note that DuckDB provides an <a href="https://github.com/duckdb/extension-template">extension template</a> that makes this fairly simple.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; Copyright 2018&ndash;2024 Stichting DuckDB Foundation<br>Licensed under the MIT License.<br>
    <a href="https://duckdb.org/docs/extensions/versioning_of_extensions.html" class="_attribution-link">https://duckdb.org/docs/extensions/versioning_of_extensions.html</a>
  </p>
</div>
