<h1 class="title">Directly Reading Files</h1>  <p>DuckDB allows directly reading files via the <a href="#read_text"><code class="language-plaintext highlighter-rouge">read_text</code></a> and <a href="#read_blob"><code class="language-plaintext highlighter-rouge">read_blob</code></a> functions. These functions accept a filename, a list of filenames or a glob pattern, and output the content of each file as a <code class="language-plaintext highlighter-rouge">VARCHAR</code> or <code class="language-plaintext highlighter-rouge">BLOB</code>, respectively, as well as additional metadata such as the file size and last modified time.</p> <h2 id="read_text"> <a style="text-decoration: none;" href="#read_text"><code class="language-plaintext highlighter-rouge">read_text</code></a> </h2> <p>The <code class="language-plaintext highlighter-rouge">read_text</code> table function reads from the selected source(s) to a <code class="language-plaintext highlighter-rouge">VARCHAR</code>. Each file results in a single row with the <code class="language-plaintext highlighter-rouge">content</code> field holding the entire content of the respective file.</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT size, parse_path(filename), content
FROM read_text('test/sql/table_function/files/*.txt');</pre> <table> <thead> <tr> <th style="text-align: right">size</th> <th>parse_path(filename)</th> <th>content</th> </tr> </thead> <tbody> <tr> <td style="text-align: right">12</td> <td>[test, sql, table_function, files, one.txt]</td> <td>Hello World!</td> </tr> <tr> <td style="text-align: right">2</td> <td>[test, sql, table_function, files, three.txt]</td> <td>42</td> </tr> <tr> <td style="text-align: right">10</td> <td>[test, sql, table_function, files, two.txt]</td> <td>Foo Bar\nFöö Bär</td> </tr> </tbody> </table> <p>The file content is first validated to be valid UTF-8. If <code class="language-plaintext highlighter-rouge">read_text</code> attempts to read a file with invalid UTF-8, an error is thrown suggesting to use <a href="#read_blob"><code class="language-plaintext highlighter-rouge">read_blob</code></a> instead.</p> <h2 id="read_blob"> <a style="text-decoration: none;" href="#read_blob"><code class="language-plaintext highlighter-rouge">read_blob</code></a> </h2> <p>The <code class="language-plaintext highlighter-rouge">read_blob</code> table function reads from the selected source(s) to a <code class="language-plaintext highlighter-rouge">BLOB</code>:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT size, content, filename
FROM read_blob('test/sql/table_function/files/*');</pre> <table> <thead> <tr> <th style="text-align: right">size</th> <th>content</th> <th>filename</th> </tr> </thead> <tbody> <tr> <td style="text-align: right">178</td> <td>PK\x03\x04\x0A\x00\x00\x00\x00\x00\xACi=X\x14t\xCE\xC7\x0A…</td> <td>test/sql/table_function/files/four.blob</td> </tr> <tr> <td style="text-align: right">12</td> <td>Hello World!</td> <td>test/sql/table_function/files/one.txt</td> </tr> <tr> <td style="text-align: right">2</td> <td>42</td> <td>test/sql/table_function/files/three.txt</td> </tr> <tr> <td style="text-align: right">10</td> <td>F\xC3\xB6\xC3\xB6 B\xC3\xA4r</td> <td>test/sql/table_function/files/two.txt</td> </tr> </tbody> </table> <h2 id="schema"> <a style="text-decoration: none;" href="#schema">Schema</a> </h2> <p>The schemas of the tables returned by <code class="language-plaintext highlighter-rouge">read_text</code> and <code class="language-plaintext highlighter-rouge">read_blob</code> are identical:</p> <pre class="language-sql highlighter-rouge" data-language="sql">DESCRIBE FROM read_text('README.md');</pre> <table> <thead> <tr> <th>column_name</th> <th>column_type</th> <th>null</th> <th>key</th> <th>default</th> <th>extra</th> </tr> </thead> <tbody> <tr> <td>filename</td> <td>VARCHAR</td> <td>YES</td> <td>NULL</td> <td>NULL</td> <td>NULL</td> </tr> <tr> <td>content</td> <td>VARCHAR</td> <td>YES</td> <td>NULL</td> <td>NULL</td> <td>NULL</td> </tr> <tr> <td>size</td> <td>BIGINT</td> <td>YES</td> <td>NULL</td> <td>NULL</td> <td>NULL</td> </tr> <tr> <td>last_modified</td> <td>TIMESTAMP</td> <td>YES</td> <td>NULL</td> <td>NULL</td> <td>NULL</td> </tr> </tbody> </table> <h2 id="handling-missing-metadata"> <a style="text-decoration: none;" href="#handling-missing-metadata">Handling Missing Metadata</a> </h2> <p>In cases where the underlying filesystem is unable to provide some of this data due (e.g., because HTTPFS can't always return a valid timestamp), the cell is set to <code class="language-plaintext highlighter-rouge">NULL</code> instead.</p> <h2 id="support-for-projection-pushdown"> <a style="text-decoration: none;" href="#support-for-projection-pushdown">Support for Projection Pushdown</a> </h2> <p>The table functions also utilize projection pushdown to avoid computing properties unnecessarily. So you could e.g., use this to glob a directory full of huge files to get the file size in the size column, as long as you omit the content column the data won't be read into DuckDB.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; Copyright 2018&ndash;2024 Stichting DuckDB Foundation<br>Licensed under the MIT License.<br>
    <a href="https://duckdb.org/docs/guides/file_formats/read_file.html" class="_attribution-link">https://duckdb.org/docs/guides/file_formats/read_file.html</a>
  </p>
</div>
