<h1 class="title">ODBC 101: A Duck Themed Guide to ODBC</h1>  <h2 id="what-is-odbc"> <a style="text-decoration: none;" href="#what-is-odbc">What is ODBC?</a> </h2> <p><a href="https://learn.microsoft.com/en-us/sql/odbc/microsoft-open-database-connectivity-odbc?view=sql-server-ver16">ODBC</a> which stands for Open Database Connectivity, is a standard that allows different programs to talk to different databases including, of course, <strong>DuckDB</strong> ü¶Ü. This makes it easier to build programs that work with many different databases, which saves time as developers don't have to write custom code to connect to each database. Instead, they can use the standardized ODBC interface, which reduces development time and costs, and programs are easier to maintain. However, ODBC can be slower than other methods of connecting to a database, such as using a native driver, as it adds an extra layer of abstraction between the application and the database. Furthermore, because DuckDB is column-based and ODBC is row-based, there can be some inefficiencies when using ODBC with DuckDB.</p> <blockquote> <p>There are links throughout this page to the official <a href="https://learn.microsoft.com/en-us/sql/odbc/reference/odbc-programmer-s-reference?view=sql-server-ver16">Microsoft ODBC documentation</a>, which is a great resource for learning more about ODBC.</p> </blockquote> <h2 id="general-concepts"> <a style="text-decoration: none;" href="#general-concepts">General Concepts</a> </h2> <ul> <li><a href="#handles">Handles</a></li> <li><a href="#connecting">Connecting</a></li> <li><a href="#error-handling-and-diagnostics">Error Handling and Diagnostics</a></li> <li><a href="#buffers-and-binding">Buffers and Binding</a></li> </ul> <h3 id="handles"> <a style="text-decoration: none;" href="#handles">Handles</a> </h3> <p>A <a href="https://learn.microsoft.com/en-us/sql/odbc/reference/develop-app/handles?view=sql-server-ver16">handle</a> is a pointer to a specific ODBC object which is used to interact with the database. There are several different types of handles, each with a different purpose, these are the environment handle, the connection handle, the statement handle, and the descriptor handle. Handles are allocated using the <a href="https://learn.microsoft.com/en-us/sql/odbc/reference/syntax/sqlallochandle-function?view=sql-server-ver16"><code class="language-plaintext highlighter-rouge">SQLAllocHandle</code></a> which takes as input the type of handle to allocate, and a pointer to the handle, the driver then creates a new handle of the specified type which it returns to the application.</p> <p>The DuckDB ODBC driver has the following handle types.</p> <h4 id="environment"> <a style="text-decoration: none;" href="#environment">Environment</a> </h4>  <table> <tbody> <tr> <td><strong>Handle name</strong></td> <td><a href="https://learn.microsoft.com/en-us/sql/odbc/reference/develop-app/environment-handles?view=sql-server-ver16">Environment</a></td> </tr> <tr> <td><strong>Type name</strong></td> <td><code class="language-plaintext highlighter-rouge">SQL_HANDLE_ENV</code></td> </tr> <tr> <td><strong>Description</strong></td> <td>Manages the environment settings for ODBC operations, and provides a global context in which to access data.</td> </tr> <tr> <td><strong>Use case</strong></td> <td>Initializing ODBC, managing driver behavior, resource allocation</td> </tr> <tr> <td><strong>Additional information</strong></td> <td>Must be <a href="https://learn.microsoft.com/en-us/sql/odbc/reference/develop-app/allocating-the-environment-handle?view=sql-server-ver16">allocated</a> once per application upon starting, and freed at the end.</td> </tr> </tbody> </table> <h4 id="connection"> <a style="text-decoration: none;" href="#connection">Connection</a> </h4>  <table> <tbody> <tr> <td><strong>Handle name</strong></td> <td><a href="https://learn.microsoft.com/en-us/sql/odbc/reference/develop-app/connection-handles?view=sql-server-ver16">Connection</a></td> </tr> <tr> <td><strong>Type name</strong></td> <td><code class="language-plaintext highlighter-rouge">SQL_HANDLE_DBC</code></td> </tr> <tr> <td><strong>Description</strong></td> <td>Represents a connection to a data source. Used to establish, manage, and terminate connections. Defines both the driver and the data source to use within the driver.</td> </tr> <tr> <td><strong>Use case</strong></td> <td>Establishing a connection to a database, managing the connection state</td> </tr> <tr> <td><strong>Additional information</strong></td> <td>Multiple connection handles can be <a href="https://learn.microsoft.com/en-us/sql/odbc/reference/develop-app/allocating-a-connection-handle-odbc?view=sql-server-ver16">created</a> as needed, allowing simultaneous connections to multiple data sources. <em>Note:</em> Allocating a connection handle does not establish a connection, but must be allocated first, and then used once the connection has been established.</td> </tr> </tbody> </table> <h4 id="statement"> <a style="text-decoration: none;" href="#statement">Statement</a> </h4>  <table> <tbody> <tr> <td><strong>Handle name</strong></td> <td><a href="https://learn.microsoft.com/en-us/sql/odbc/reference/develop-app/statement-handles?view=sql-server-ver16">Statement</a></td> </tr> <tr> <td><strong>Type name</strong></td> <td><code class="language-plaintext highlighter-rouge">SQL_HANDLE_STMT</code></td> </tr> <tr> <td><strong>Description</strong></td> <td>Handles the execution of SQL statements, as well as the returned result sets.</td> </tr> <tr> <td><strong>Use case</strong></td> <td>Executing SQL queries, fetching result sets, managing statement options.</td> </tr> <tr> <td><strong>Additional information</strong></td> <td>To facilitate the execution of concurrent queries, multiple handles can be <a href="https://learn.microsoft.com/en-us/sql/odbc/reference/develop-app/allocating-a-statement-handle-odbc?view=sql-server-ver16">allocated</a> per connection.</td> </tr> </tbody> </table> <h4 id="descriptor"> <a style="text-decoration: none;" href="#descriptor">Descriptor</a> </h4>  <table> <tbody> <tr> <td><strong>Handle name</strong></td> <td><a href="https://learn.microsoft.com/en-us/sql/odbc/reference/develop-app/descriptor-handles?view=sql-server-ver16">Descriptor</a></td> </tr> <tr> <td><strong>Type name</strong></td> <td><code class="language-plaintext highlighter-rouge">SQL_HANDLE_DESC</code></td> </tr> <tr> <td><strong>Description</strong></td> <td>Describes the attributes of a data structure or parameter, and allows the application to specify the structure of data to be bound/retrieved.</td> </tr> <tr> <td><strong>Use case</strong></td> <td>Describing table structures, result sets, binding columns to application buffers</td> </tr> <tr> <td><strong>Additional information</strong></td> <td>Used in situations where data structures need to be explicitly defined, for example during parameter binding or result set fetching. They are automatically allocated when a statement is allocated, but can also be allocated explicitly.</td> </tr> </tbody> </table> <h3 id="connecting"> <a style="text-decoration: none;" href="#connecting">Connecting</a> </h3> <p>The first step is to connect to the data source so that the application can perform database operations. First the application must allocate an environment handle, and then a connection handle. The connection handle is then used to connect to the data source. There are two functions which can be used to connect to a data source, <a href="https://learn.microsoft.com/en-us/sql/odbc/reference/syntax/sqldriverconnect-function?view=sql-server-ver16"><code class="language-plaintext highlighter-rouge">SQLDriverConnect</code></a> and <a href="https://learn.microsoft.com/en-us/sql/odbc/reference/syntax/sqlconnect-function?view=sql-server-ver16"><code class="language-plaintext highlighter-rouge">SQLConnect</code></a>. The former is used to connect to a data source using a connection string, while the latter is used to connect to a data source using a DSN.</p> <h4 id="connection-string"> <a style="text-decoration: none;" href="#connection-string">Connection String</a> </h4> <p>A <a href="https://learn.microsoft.com/en-us/sql/odbc/reference/develop-app/connection-strings?view=sql-server-ver16">connection string</a> is a string which contains the information needed to connect to a data source. It is formatted as a semicolon separated list of key-value pairs, however DuckDB currently only utilizes the DSN and ignores the rest of the parameters.</p> <h4 id="dsn"> <a style="text-decoration: none;" href="#dsn">DSN</a> </h4> <p>A DSN (<em>Data Source Name</em>) is a string that identifies a database. It can be a file path, URL, or a database name. For example: <code class="language-plaintext highlighter-rouge">C:\Users\me\duckdb.db</code> and <code class="language-plaintext highlighter-rouge">DuckDB</code> are both valid DSNs. More information on DSNs can be found on the <a href="https://learn.microsoft.com/en-us/sql/odbc/reference/develop-app/choosing-a-data-source-or-driver?view=sql-server-ver16">‚ÄúChoosing a Data Source or Driver‚Äù page of the SQL Server documentation</a>.</p> <h3 id="error-handling-and-diagnostics"> <a style="text-decoration: none;" href="#error-handling-and-diagnostics">Error Handling and Diagnostics</a> </h3> <p>All functions in ODBC return a code which represents the success or failure of the function. This allows for easy error handling, as the application can simply check the return code of each function call to determine if it was successful. When unsuccessful, the application can then use the <a href="https://learn.microsoft.com/en-us/sql/odbc/reference/syntax/sqlgetdiagrec-function?view=sql-server-ver16"><code class="language-plaintext highlighter-rouge">SQLGetDiagRec</code></a> function to retrieve the error information. The following table defines the <a href="https://learn.microsoft.com/en-us/sql/odbc/reference/develop-app/return-codes-odbc?view=sql-server-ver16">return codes</a>:</p> <table> <thead> <tr> <th>Return code</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">SQL_SUCCESS</code></td> <td>The function completed successfully.</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">SQL_SUCCESS_WITH_INFO</code></td> <td>The function completed successfully, but additional information is available, including a warning</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">SQL_ERROR</code></td> <td>The function failed.</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">SQL_INVALID_HANDLE</code></td> <td>The handle provided was invalid, indicating a programming error, i.e., when a handle is not allocated before it is used, or is the wrong type</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">SQL_NO_DATA</code></td> <td>The function completed successfully, but no more data is available</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">SQL_NEED_DATA</code></td> <td>More data is needed, such as when a parameter data is sent at execution time, or additional connection information is required.</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">SQL_STILL_EXECUTING</code></td> <td>A function that was asynchronously executed is still executing.</td> </tr> </tbody> </table> <h3 id="buffers-and-binding"> <a style="text-decoration: none;" href="#buffers-and-binding">Buffers and Binding</a> </h3> <p>A buffer is a block of memory used to store data. Buffers are used to store data retrieved from the database, or to send data to the database. Buffers are allocated by the application, and then bound to a column in a result set, or a parameter in a query, using the <a href="https://learn.microsoft.com/en-us/sql/odbc/reference/syntax/sqlbindcol-function?view=sql-server-ver16"><code class="language-plaintext highlighter-rouge">SQLBindCol</code></a> and <a href="https://learn.microsoft.com/en-us/sql/odbc/reference/syntax/sqlbindparameter-function?view=sql-server-ver16"><code class="language-plaintext highlighter-rouge">SQLBindParameter</code></a> functions. When the application fetches a row from the result set, or executes a query, the data is stored in the buffer. When the application sends a query to the database, the data in the buffer is sent to the database.</p> <h2 id="setting-up-an-application"> <a style="text-decoration: none;" href="#setting-up-an-application">Setting up an Application</a> </h2> <p>The following is a step-by-step guide to setting up an application that uses ODBC to connect to a database, execute a query, and fetch the results in <code class="language-plaintext highlighter-rouge">C++</code>.</p> <blockquote> <p>To install the driver as well as anything else you will need follow these <a href="../../api/odbc/overview.html">instructions</a>.</p> </blockquote> <h3 id="1-include-the-sql-header-files"> <a style="text-decoration: none;" href="#1-include-the-sql-header-files">1. Include the SQL Header Files</a> </h3> <p>The first step is to include the SQL header files:</p> <pre class="language-cpp highlighter-rouge" data-language="cpp">#include &lt;sql.h&gt;
#include &lt;sqlext.h&gt;</pre> <p>These files contain the definitions of the ODBC functions, as well as the data types used by ODBC. In order to be able to use these header files you have to have the <code class="language-plaintext highlighter-rouge">unixodbc</code> package installed:</p> <p>On macOS:</p> <pre class="language-bash highlighter-rouge" data-language="bash">brew install unixodbc</pre> <p>On Ubuntu and Debian:</p> <pre class="language-bash highlighter-rouge" data-language="bash">sudo apt-get install -y unixodbc-dev</pre> <p>On Fedora, CentOS, and Red Hat:</p> <pre class="language-bash highlighter-rouge" data-language="bash">sudo yum install -y unixODBC-devel</pre> <p>Remember to include the header file location in your <code class="language-plaintext highlighter-rouge">CFLAGS</code>.</p> <p>For <code class="language-plaintext highlighter-rouge">MAKEFILE</code>:</p> <pre class="language-make highlighter-rouge" data-language="make">CFLAGS=-I/usr/local/include
# or
CFLAGS=-/opt/homebrew/Cellar/unixodbc/2.3.11/include</pre> <p>For <code class="language-plaintext highlighter-rouge">CMAKE</code>:</p> <pre class="language-cmake highlighter-rouge" data-language="cmake">include_directories(/usr/local/include)
# or
include_directories(/opt/homebrew/Cellar/unixodbc/2.3.11/include)</pre> <p>You also have to link the library in your <code class="language-plaintext highlighter-rouge">CMAKE</code> or <code class="language-plaintext highlighter-rouge">MAKEFILE</code>. For <code class="language-plaintext highlighter-rouge">CMAKE</code>:</p> <pre class="language-cmake highlighter-rouge" data-language="cmake">target_link_libraries(ODBC_application /path/to/duckdb_odbc/libduckdb_odbc.dylib)</pre> <p>For <code class="language-plaintext highlighter-rouge">MAKEFILE</code>:</p> <pre class="language-make highlighter-rouge" data-language="make">LDLIBS=-L/path/to/duckdb_odbc/libduckdb_odbc.dylib</pre> <h3 id="2-define-the-odbc-handles-and-connect-to-the-database"> <a style="text-decoration: none;" href="#2-define-the-odbc-handles-and-connect-to-the-database">2. Define the ODBC Handles and Connect to the Database</a> </h3> <h4 id="2a-connecting-with-sqlconnect"> <a style="text-decoration: none;" href="#2a-connecting-with-sqlconnect">2.a. Connecting with SQLConnect</a> </h4> <p>Then set up the ODBC handles, allocate them, and connect to the database. First the environment handle is allocated, then the environment is set to ODBC version 3, then the connection handle is allocated, and finally the connection is made to the database. The following code snippet shows how to do this:</p> <pre class="language-cpp highlighter-rouge" data-language="cpp">SQLHANDLE env;
SQLHANDLE dbc;

SQLAllocHandle(SQL_HANDLE_ENV, SQL_NULL_HANDLE, &amp;env);

SQLSetEnvAttr(env, SQL_ATTR_ODBC_VERSION, (void*)SQL_OV_ODBC3, 0);

SQLAllocHandle(SQL_HANDLE_DBC, env, &amp;dbc);

std::string dsn = "DSN=duckdbmemory";
SQLConnect(dbc, (SQLCHAR*)dsn.c_str(), SQL_NTS, NULL, 0, NULL, 0);

std::cout &lt;&lt; "Connected!" &lt;&lt; std::endl;</pre> <h4 id="2b-connecting-with-sqldriverconnect"> <a style="text-decoration: none;" href="#2b-connecting-with-sqldriverconnect">2.b. Connecting with SQLDriverConnect</a> </h4> <p>Alternatively, you can connect to the ODBC driver using <a href="https://learn.microsoft.com/en-us/sql/odbc/reference/syntax/sqldriverconnect-function?view=sql-server-ver16"><code class="language-plaintext highlighter-rouge">SQLDriverConnect</code></a>. <code class="language-plaintext highlighter-rouge">SQLDriverConnect</code> accepts a connection string in which you can configure the database using any of the available <a href="../../configuration/overview.html">DuckDB configuration options</a>.</p> <pre class="language-cpp highlighter-rouge" data-language="cpp">SQLHANDLE env;
SQLHANDLE dbc;

SQLAllocHandle(SQL_HANDLE_ENV, SQL_NULL_HANDLE, &amp;env);

SQLSetEnvAttr(env, SQL_ATTR_ODBC_VERSION, (void*)SQL_OV_ODBC3, 0);

SQLAllocHandle(SQL_HANDLE_DBC, env, &amp;dbc);

SQLCHAR str[1024];
SQLSMALLINT strl;
std::string dsn = "DSN=DuckDB;allow_unsigned_extensions=true;access_mode=READ_ONLY"
SQLDriverConnect(dbc, nullptr, (SQLCHAR*)dsn.c_str(), SQL_NTS, str, sizeof(str), &amp;strl, SQL_DRIVER_COMPLETE)

std::cout &lt;&lt; "Connected!" &lt;&lt; std::endl;</pre> <h3 id="3-adding-a-query"> <a style="text-decoration: none;" href="#3-adding-a-query">3. Adding a Query</a> </h3> <p>Now that the application is set up, we can add a query to it. First, we need to allocate a statement handle:</p> <pre class="language-cpp highlighter-rouge" data-language="cpp">SQLHANDLE stmt;
SQLAllocHandle(SQL_HANDLE_STMT, dbc, &amp;stmt);</pre> <p>Then we can execute a query:</p> <pre class="language-cpp highlighter-rouge" data-language="cpp">SQLExecDirect(stmt, (SQLCHAR*)"SELECT * FROM integers", SQL_NTS);</pre> <h3 id="4-fetching-results"> <a style="text-decoration: none;" href="#4-fetching-results">4. Fetching Results</a> </h3> <p>Now that we have executed a query, we can fetch the results. First, we need to bind the columns in the result set to buffers:</p> <pre class="language-cpp highlighter-rouge" data-language="cpp">SQLLEN int_val;
SQLLEN null_val;
SQLBindCol(stmt, 1, SQL_C_SLONG, &amp;int_val, 0, &amp;null_val);</pre> <p>Then we can fetch the results:</p> <pre class="language-cpp highlighter-rouge" data-language="cpp">SQLFetch(stmt);</pre> <h3 id="5-go-wild"> <a style="text-decoration: none;" href="#5-go-wild">5. Go Wild</a> </h3> <p>Now that we have the results, we can do whatever we want with them. For example, we can print them:</p> <pre class="language-cpp highlighter-rouge" data-language="cpp">std::cout &lt;&lt; "Value: " &lt;&lt; int_val &lt;&lt; std::endl;</pre> <p>or do any other processing we want. As well as executing more queries and doing any thing else we want to do with the database such as inserting, updating, or deleting data.</p> <h3 id="6-free-the-handles-and-disconnecting"> <a style="text-decoration: none;" href="#6-free-the-handles-and-disconnecting">6. Free the Handles and Disconnecting</a> </h3> <p>Finally, we need to free the handles and disconnect from the database. First, we need to free the statement handle:</p> <pre class="language-cpp highlighter-rouge" data-language="cpp">SQLFreeHandle(SQL_HANDLE_STMT, stmt);</pre> <p>Then we need to disconnect from the database:</p> <pre class="language-cpp highlighter-rouge" data-language="cpp">SQLDisconnect(dbc);</pre> <p>And finally, we need to free the connection handle and the environment handle:</p> <pre class="language-cpp highlighter-rouge" data-language="cpp">SQLFreeHandle(SQL_HANDLE_DBC, dbc);
SQLFreeHandle(SQL_HANDLE_ENV, env);</pre> <p>Freeing the connection and environment handles can only be done after the connection to the database has been closed. Trying to free them before disconnecting from the database will result in an error.</p> <h2 id="sample-application"> <a style="text-decoration: none;" href="#sample-application">Sample Application</a> </h2> <p>The following is a sample application that includes a <code class="language-plaintext highlighter-rouge">cpp</code> file that connects to the database, executes a query, fetches the results, and prints them. It also disconnects from the database and frees the handles, and includes a function to check the return value of ODBC functions. It also includes a <code class="language-plaintext highlighter-rouge">CMakeLists.txt</code> file that can be used to build the application.</p> <h3 id="sample-cpp-file"> <a style="text-decoration: none;" href="#sample-cpp-file">Sample <code class="language-plaintext highlighter-rouge">.cpp</code> file</a> </h3> <pre class="language-cpp highlighter-rouge" data-language="cpp">#include &lt;iostream&gt;
#include &lt;sql.h&gt;
#include &lt;sqlext.h&gt;

void check_ret(SQLRETURN ret, std::string msg) {
    if (ret != SQL_SUCCESS &amp;&amp; ret != SQL_SUCCESS_WITH_INFO) {
        std::cout &lt;&lt; ret &lt;&lt; ": " &lt;&lt; msg &lt;&lt; " failed" &lt;&lt; std::endl;
        exit(1);
    }
    if (ret == SQL_SUCCESS_WITH_INFO) {
        std::cout &lt;&lt; ret &lt;&lt; ": " &lt;&lt; msg &lt;&lt; " succeeded with info" &lt;&lt; std::endl;
    }
}

int main() {
    SQLHANDLE env;
    SQLHANDLE dbc;
    SQLRETURN ret;

    ret = SQLAllocHandle(SQL_HANDLE_ENV, SQL_NULL_HANDLE, &amp;env);
    check_ret(ret, "SQLAllocHandle(env)");

    ret = SQLSetEnvAttr(env, SQL_ATTR_ODBC_VERSION, (void*)SQL_OV_ODBC3, 0);
    check_ret(ret, "SQLSetEnvAttr");

    ret = SQLAllocHandle(SQL_HANDLE_DBC, env, &amp;dbc);
    check_ret(ret, "SQLAllocHandle(dbc)");

    std::string dsn = "DSN=duckdbmemory";
    ret = SQLConnect(dbc, (SQLCHAR*)dsn.c_str(), SQL_NTS, NULL, 0, NULL, 0);
    check_ret(ret, "SQLConnect");

    std::cout &lt;&lt; "Connected!" &lt;&lt; std::endl;

    SQLHANDLE stmt;
    ret = SQLAllocHandle(SQL_HANDLE_STMT, dbc, &amp;stmt);
    check_ret(ret, "SQLAllocHandle(stmt)");

    ret = SQLExecDirect(stmt, (SQLCHAR*)"SELECT * FROM integers", SQL_NTS);
    check_ret(ret, "SQLExecDirect(SELECT * FROM integers)");

    SQLLEN int_val;
    SQLLEN null_val;
    ret = SQLBindCol(stmt, 1, SQL_C_SLONG, &amp;int_val, 0, &amp;null_val);
    check_ret(ret, "SQLBindCol");

    ret = SQLFetch(stmt);
    check_ret(ret, "SQLFetch");

    std::cout &lt;&lt; "Value: " &lt;&lt; int_val &lt;&lt; std::endl;

    ret = SQLFreeHandle(SQL_HANDLE_STMT, stmt);
    check_ret(ret, "SQLFreeHandle(stmt)");

    ret = SQLDisconnect(dbc);
    check_ret(ret, "SQLDisconnect");

    ret = SQLFreeHandle(SQL_HANDLE_DBC, dbc);
    check_ret(ret, "SQLFreeHandle(dbc)");

    ret = SQLFreeHandle(SQL_HANDLE_ENV, env);
    check_ret(ret, "SQLFreeHandle(env)");
}</pre> <h3 id="sample-cmakeliststxt-file"> <a style="text-decoration: none;" href="#sample-cmakeliststxt-file">Sample <code class="language-plaintext highlighter-rouge">CMakelists.txt</code> file</a> </h3> <pre class="language-cmake highlighter-rouge" data-language="cmake">cmake_minimum_required(VERSION 3.25)
project(ODBC_Tester_App)

set(CMAKE_CXX_STANDARD 17)
include_directories(/opt/homebrew/Cellar/unixodbc/2.3.11/include)

add_executable(ODBC_Tester_App main.cpp)
target_link_libraries(ODBC_Tester_App /duckdb_odbc/libduckdb_odbc.dylib)</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; Copyright 2018&ndash;2024 Stichting DuckDB Foundation<br>Licensed under the MIT License.<br>
    <a href="https://duckdb.org/docs/guides/odbc/general.html" class="_attribution-link">https://duckdb.org/docs/guides/odbc/general.html</a>
  </p>
</div>
