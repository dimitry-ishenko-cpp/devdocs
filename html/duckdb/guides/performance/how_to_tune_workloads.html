<h1 class="title">Tuning Workloads</h1>  <h2 id="parallelism-multi-core-processing"> <a style="text-decoration: none;" href="#parallelism-multi-core-processing">Parallelism (Multi-Core Processing)</a> </h2> <h3 id="the-effect-of-row-groups-on-parallelism"> <a style="text-decoration: none;" href="#the-effect-of-row-groups-on-parallelism">The Effect of Row Groups on Parallelism</a> </h3> <p>DuckDB parallelizes the workload based on <em><a href="../../internals/storage.html#row-groups.html">row groups</a>,</em> i.e., groups of rows that are stored together at the storage level. A row group in DuckDB's database format consists of max. 122,880 rows. Parallelism starts at the level of row groups, therefore, for a query to run on <em>k</em> threads, it needs to scan at least <em>k</em> * 122,880 rows.</p> <h3 id="too-many-threads"> <a style="text-decoration: none;" href="#too-many-threads">Too Many Threads</a> </h3> <p>Note that in certain cases DuckDB may launch <em>too many threads</em> (e.g., due to HyperThreading), which can lead to slowdowns. In these cases, it’s worth manually limiting the number of threads using <a href="../../configuration/pragmas.html#threads.html"><code class="language-plaintext highlighter-rouge">SET threads = X</code></a>.</p> <h2 id="larger-than-memory-workloads-out-of-core-processing"> <a style="text-decoration: none;" href="#larger-than-memory-workloads-out-of-core-processing">Larger-Than-Memory Workloads (Out-of-Core Processing)</a> </h2> <p>A key strength of DuckDB is support for larger-than-memory workloads, i.e., it is able to process data sets that are larger than the available system memory (also known as <em>out-of-core processing</em>). It can also run queries where the intermediate results cannot fit into memory. This section explains the prerequisites, scope, and known limitations of larger-than-memory processing in DuckDB.</p> <h3 id="spilling-to-disk"> <a style="text-decoration: none;" href="#spilling-to-disk">Spilling to Disk</a> </h3> <p>Larger-than-memory workloads are supported by spilling to disk. With the default configuration, DuckDB creates the <code class="language-plaintext highlighter-rouge">⟨database_file_name⟩.tmp</code> temporary directory (in persistent mode) or the <code class="language-plaintext highlighter-rouge">.tmp</code> directory (in in-memory mode). This directory can be changed using the <a href="../../configuration/pragmas.html#temp-directory-for-spilling-data-to-disk.html"><code class="language-plaintext highlighter-rouge">temp_directory</code> configuration option</a>, e.g.:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SET temp_directory = '/path/to/temp_dir.tmp/';</pre> <h3 id="blocking-operators"> <a style="text-decoration: none;" href="#blocking-operators">Blocking Operators</a> </h3> <p>Some operators cannot output a single row until the last row of their input has been seen. These are called <em>blocking operators</em> as they require their entire input to be buffered, and are the most memory-intensive operators in relational database systems. The main blocking operators are the following:</p> <ul> <li>
<em>sorting:</em> <a href="../../sql/query_syntax/orderby.html"><code class="language-plaintext highlighter-rouge">ORDER BY</code></a>
</li> <li>
<em>grouping:</em> <a href="../../sql/query_syntax/groupby.html"><code class="language-plaintext highlighter-rouge">GROUP BY</code></a>
</li> <li>
<em>windowing:</em> <a href="../../sql/functions/window_functions.html"><code class="language-plaintext highlighter-rouge">OVER ... (PARTITION BY ... ORDER BY ...)</code></a>
</li> <li>
<em>joining:</em> <a href="../../sql/query_syntax/from.html#joins.html"><code class="language-plaintext highlighter-rouge">JOIN</code></a>
</li> </ul> <p>DuckDB supports larger-than-memory processing for all of these operators.</p> <h3 id="limitations"> <a style="text-decoration: none;" href="#limitations">Limitations</a> </h3> <p>DuckDB strives to always complete workloads even if they are larger-than-memory. That said, there are some limitations at the moment:</p> <ul> <li>If multiple blocking operators appear in the same query, DuckDB may still throw an out-of-memory exception due to the complex interplay of these operators.</li> <li>Some <a href="../../sql/functions/aggregates.html">aggregate functions</a>, such as <code class="language-plaintext highlighter-rouge">list()</code> and <code class="language-plaintext highlighter-rouge">string_agg()</code>, do not support offloading to disk.</li> <li>
<a href="../../sql/functions/aggregates.html#order-by-clause-in-aggregate-functions.html">Aggregate functions that use sorting</a> are holistic, i.e., they need all inputs before the aggregation can start. As DuckDB cannot yet offload some complex intermediate aggregate states to disk, these functions can cause an out-of-memory exception when run on large data sets.</li> <li>The <code class="language-plaintext highlighter-rouge">PIVOT</code> operation <a href="../../sql/statements/pivot.html#internals.html">internally uses the <code class="language-plaintext highlighter-rouge">list()</code> function</a>, therefore it is subject to the same limitation.</li> </ul> <h2 id="profiling"> <a style="text-decoration: none;" href="#profiling">Profiling</a> </h2> <p>If your queries are not performing as well as expected, it’s worth studying their query plans:</p> <ul> <li>Use <a href="../meta/explain.html"><code class="language-plaintext highlighter-rouge">EXPLAIN</code></a> to print the physical query plan without running the query.</li> <li>Use <a href="../meta/explain_analyze.html"><code class="language-plaintext highlighter-rouge">EXPLAIN ANALYZE</code></a> to run and profile the query. This will show the CPU time that each step in the query takes. Note that due to multi-threading, adding up the individual times will be larger than the total query processing time.</li> </ul> <p>Query plans can point to the root of performance issues. A few general directions:</p> <ul> <li>Avoid nested loop joins in favor of hash joins.</li> <li>A scan that does not include a filter pushdown for a filter condition that is later applied performs unnecessary IO. Try rewriting the query to apply a pushdown.</li> <li>Bad join orders where the cardinality of an operator explodes to billions of tuples should be avoided at all costs.</li> </ul> <h2 id="prepared-statements"> <a style="text-decoration: none;" href="#prepared-statements">Prepared Statements</a> </h2> <p><a href="../../sql/query_syntax/prepared_statements.html">Prepared statements</a> can improve performance when running the same query many times, but with different parameters. When a statement is prepared, it completes several of the initial portions of the query execution process (parsing, planning, etc.) and caches their output. When it is executed, those steps can be skipped, improving performance. This is beneficial mostly for repeatedly running small queries (with a runtime of &lt; 100ms) with different sets of parameters.</p> <p>Note that it is not a primary design goal for DuckDB to quickly execute many small queries concurrently. Rather, it is optimized for running larger, less frequent queries.</p> <h2 id="querying-remote-files"> <a style="text-decoration: none;" href="#querying-remote-files">Querying Remote Files</a> </h2> <p>DuckDB uses synchronous IO when reading remote files. This means that each DuckDB thread can make at most one HTTP request at a time. If a query must make many small requests over the network, increasing DuckDB's <a href="../../configuration/pragmas.html#threads.html"><code class="language-plaintext highlighter-rouge">threads</code> setting</a> to larger than the total number of CPU cores (approx. 2-5 times CPU cores) can improve parallelism and performance.</p> <h3 id="avoid-reading-unnecessary-data"> <a style="text-decoration: none;" href="#avoid-reading-unnecessary-data">Avoid Reading Unnecessary Data</a> </h3> <p>The main bottleneck in workloads reading remote files is likely to be the IO. This means that minimizing the unnecessarily read data can be highly beneficial.</p> <p>Some basic SQL tricks can help with this:</p> <ul> <li>Avoid <code class="language-plaintext highlighter-rouge">SELECT *</code>. Instead, only select columns that are actually used. DuckDB will try to only download the data it actually needs.</li> <li>Apply filters on remote parquet files when possible. DuckDB can use these filters to reduce the amount of data that is scanned.</li> <li>Either <a href="../../sql/query_syntax/orderby.html">sort</a> or <a href="../../data/partitioning/partitioned_writes.html">partition</a> data by columns that are regularly used for filters: this increases the effectiveness of the filters in reducing IO.</li> </ul> <p>To inspect how much remote data is transferred for a query, <a href="../meta/explain_analyze.html"><code class="language-plaintext highlighter-rouge">EXPLAIN ANALYZE</code></a> can be used to print out the total number of requests and total data transferred for queries on remote files.</p> <h3 id="avoid-reading-data-more-than-once"> <a style="text-decoration: none;" href="#avoid-reading-data-more-than-once">Avoid Reading Data More Than Once</a> </h3> <p>DuckDB does not cache data from remote files automatically. This means that running a query on a remote file twice will download the required data twice. So if data needs to be accessed multiple times, storing it locally can make sense. To illustrate this, lets look at an example:</p> <p>Consider the following queries:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT col_a + col_b FROM 's3://bucket/file.parquet' WHERE col_a &gt; 10;
SELECT col_a * col_b FROM 's3://bucket/file.parquet' WHERE col_a &gt; 10;</pre> <p>These queries download the columns <code class="language-plaintext highlighter-rouge">col_a</code> and <code class="language-plaintext highlighter-rouge">col_b</code> from <code class="language-plaintext highlighter-rouge">s3://bucket/file.parquet</code> twice. Now consider the following queries:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE local_copy_of_file AS
    SELECT col_a, col_b FROM 's3://bucket/file.parquet' WHERE col_a &gt; 10;

SELECT col_a + col_b FROM local_copy_of_file;
SELECT col_a * col_b FROM local_copy_of_file;</pre> <p>Here DuckDB will first copy <code class="language-plaintext highlighter-rouge">col_a</code> and <code class="language-plaintext highlighter-rouge">col_b</code> from <code class="language-plaintext highlighter-rouge">s3://bucket/file.parquet</code> into a local table, and then query the local in-memory columns twice. Note also that the filter <code class="language-plaintext highlighter-rouge">WHERE col_a &gt; 10</code> is also now applied only once.</p> <p>An important side note needs to be made here though. The first two queries are fully streaming, with only a small memory footprint, whereas the second requires full materialization of columns <code class="language-plaintext highlighter-rouge">col_a</code> and <code class="language-plaintext highlighter-rouge">col_b</code>. This means that in some rare cases (e.g., with a high-speed network, but with very limited memory available) it could actually be beneficial to download the data twice.</p> <h2 id="best-practices-for-using-connections"> <a style="text-decoration: none;" href="#best-practices-for-using-connections">Best Practices for Using Connections</a> </h2> <p>DuckDB will perform best when reusing the same database connection many times. Disconnecting and reconnecting on every query will incur some overhead, which can reduce performance when running many small queries. DuckDB also caches some data and metadata in memory, and that cache is lost when the last open connection is closed. Frequently, a single connection will work best, but a connection pool may also be used.</p> <p>Using multiple connections can parallelize some operations, although it is typically not necessary. DuckDB does attempt to parallelize as much as possible within each individual query, but it is not possible to parallelize in all cases. Making multiple connections can process more operations concurrently. This can be more helpful if DuckDB is not CPU limited, but instead bottlenecked by another resource like network transfer speed.</p> <h2 id="the-preserve_insertion_order-option"> <a style="text-decoration: none;" href="#the-preserve_insertion_order-option">The <code class="language-plaintext highlighter-rouge">preserve_insertion_order</code> Option</a> </h2> <p>When importing or exporting data sets (from/to the Parquet or CSV formats), which are much larger than the available memory, an out of memory error may occur:</p> <pre class="language-console highlighter-rouge" data-language="console">Error: Out of Memory Error: failed to allocate data of size ... (.../... used)</pre> <p>In these cases, consider setting the <a href="../../configuration/overview.html"><code class="language-plaintext highlighter-rouge">preserve_insertion_order</code> configuration option</a> to <code class="language-plaintext highlighter-rouge">false</code>:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SET preserve_insertion_order = false;</pre> <p>This allows the systems to re-order any results that do not contain <code class="language-plaintext highlighter-rouge">ORDER BY</code> clauses, potentially reducing memory usage.</p> <h2 id="persistent-vs-in-memory-tables"> <a style="text-decoration: none;" href="#persistent-vs-in-memory-tables">Persistent vs. In-Memory Tables</a> </h2> <p>DuckDB supports <a href="http://localhost:8000/2022/10/28/lightweight-compression.html">lightweight compression techniques</a>. Currently, these are only applied on persistent (on-disk) databases.</p> <p>DuckDB does not compress its in-memory tables. The reason for this is that compression is performed during checkpointing, and in-memory tables are not checkpointed.</p> <p>In rare cases, this can result in unintuitive performance results where queries are faster on on-disk tables compared to in-memory ones. For example, Q1 of the <a href="../../extensions/tpch.html">TPC-H workload</a> is faster when running on-disk compared to the in-memory mode:</p> <pre class="language-sql highlighter-rouge" data-language="sql">INSTALL tpch;
LOAD tpch;
CALL dbgen(sf = 30);
.timer on
PRAGMA tpch(1);</pre> <table> <thead> <tr> <th>Database setup</th> <th style="text-align: right">Execution time</th> </tr> </thead> <tbody> <tr> <td>In-memory database</td> <td style="text-align: right">4.80 s</td> </tr> <tr> <td>Persistent database</td> <td style="text-align: right">0.57 s</td> </tr> </tbody> </table><div class="_attribution">
  <p class="_attribution-p">
    &copy; Copyright 2018&ndash;2024 Stichting DuckDB Foundation<br>Licensed under the MIT License.<br>
    <a href="https://duckdb.org/docs/guides/performance/how_to_tune_workloads.html" class="_attribution-link">https://duckdb.org/docs/guides/performance/how_to_tune_workloads.html</a>
  </p>
</div>
