<h1 class="title">Schema</h1>  <h2 id="types"> <a style="text-decoration: none;" href="#types">Types</a> </h2> <p>It is important to use the correct type for encoding columns (e.g., <code class="language-plaintext highlighter-rouge">BIGINT</code>, <code class="language-plaintext highlighter-rouge">DATE</code>, <code class="language-plaintext highlighter-rouge">DATETIME</code>). While it is always possible to use string types (<code class="language-plaintext highlighter-rouge">VARCHAR</code>, etc.) to encode more specific values, this is not recommended. Strings use more space and are slower to process in operations such as filtering, join, and aggregation.</p> <p>When loading CSV files, you may leverage the CSV reader's <a href="../../data/csv/auto_detection.html">auto-detection mechanism</a> to get the correct types for CSV inputs.</p> <p>If you run in a memory-constrained environment, using smaller data types (e.g., <code class="language-plaintext highlighter-rouge">TINYINT</code>) can reduce the amount of memory and disk space required to complete a query. DuckDB’s <a href="http://localhost:8000/2022/10/28/lightweight-compression.html#bit-packing">bitpacking compression</a> means small values stored in larger data types will not take up larger sizes on disk, but they will take up more memory during processing.</p> <blockquote> <p>Bestpractice Use the most restrictive types possible when creating columns. Avoid using strings for encoding more specific data items.</p> </blockquote> <h3 id="microbenchmark-using-timestamps"> <a style="text-decoration: none;" href="#microbenchmark-using-timestamps">Microbenchmark: Using Timestamps</a> </h3> <p>We illustrate the difference in aggregation speed using the <a href="https://blobs.duckdb.org/data/ldbc-sf300-comments-creationDate.parquet"><code class="language-plaintext highlighter-rouge">creationDate</code> column of the LDBC Comment table on scale factor 300</a>. This table has approx. 554 million unordered timestamp values. We run a simple aggregation query that returns the average day-of-the month from the timestamps in two configurations.</p> <p>First, we use a <code class="language-plaintext highlighter-rouge">DATETIME</code> to encode the values and run the query using the <a href="../../sql/functions/timestamp.html"><code class="language-plaintext highlighter-rouge">extract</code> datetime function</a>:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT avg(extract('day' FROM creationDate)) FROM Comment;</pre> <p>Second, we use the <code class="language-plaintext highlighter-rouge">VARCHAR</code> type and use string operations:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT avg(CAST(creationDate[9:10] AS INTEGER)) FROM Comment;</pre> <p>The results of the microbenchmark are as follows:</p>  <table> <thead> <tr> <th>Column type</th> <th style="text-align: right">Storage size</th> <th style="text-align: right">Query time</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">DATETIME</code></td> <td style="text-align: right">3.3 GB</td> <td style="text-align: right">0.9 s</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">VARCHAR</code></td> <td style="text-align: right">5.2 GB</td> <td style="text-align: right">3.9 s</td> </tr> </tbody> </table> <p>The results show that using the <code class="language-plaintext highlighter-rouge">DATETIME</code> value yields smaller storage sizes and faster processing.</p> <h3 id="microbenchmark-joining-on-strings"> <a style="text-decoration: none;" href="#microbenchmark-joining-on-strings">Microbenchmark: Joining on Strings</a> </h3> <p>We illustrate the difference caused by joining on different types by computing a self-join on the <a href="https://blobs.duckdb.org/data/ldbc-sf100-comments.tar.zst">LDBC Comment table at scale factor 100</a>. The table has 64-bit integer identifiers used as the <code class="language-plaintext highlighter-rouge">id</code> attribute of each row. We perform the following join operation:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT count(*) AS count
FROM Comment c1
JOIN Comment c2 ON c1.ParentCommentId = c2.id;</pre> <p>In the first experiment, we use the correct (most restrictive) types, i.e., both the <code class="language-plaintext highlighter-rouge">id</code> and the <code class="language-plaintext highlighter-rouge">ParentCommentId</code> columns are defined as <code class="language-plaintext highlighter-rouge">BIGINT</code>. In the second experiment, we define all columns with the <code class="language-plaintext highlighter-rouge">VARCHAR</code> type. While the results of the queries are the same for all both experiments, their runtime vary significantly. The results below show that joining on <code class="language-plaintext highlighter-rouge">BIGINT</code> columns is approx. 1.8× faster than performing the same join on <code class="language-plaintext highlighter-rouge">VARCHAR</code>-typed columns encoding the same value.</p>  <table> <thead> <tr> <th>Join column payload type</th> <th>Join column schema type</th> <th>Example value</th> <th style="text-align: right">Query time</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">BIGINT</code></td> <td><code class="language-plaintext highlighter-rouge">BIGINT</code></td> <td><code class="language-plaintext highlighter-rouge">70368755640078</code></td> <td style="text-align: right">1.2 s</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">BIGINT</code></td> <td><code class="language-plaintext highlighter-rouge">VARCHAR</code></td> <td><code class="language-plaintext highlighter-rouge">'70368755640078'</code></td> <td style="text-align: right">2.1 s</td> </tr> </tbody> </table> <blockquote> <p>Bestpractice Avoid representing numeric values as strings, especially if you intend to perform e.g., join operations on them.</p> </blockquote> <h2 id="constraints"> <a style="text-decoration: none;" href="#constraints">Constraints</a> </h2> <p>DuckDB allows defining <a href="../../sql/constraints.html">constraints</a> such as <code class="language-plaintext highlighter-rouge">UNIQUE</code>, <code class="language-plaintext highlighter-rouge">PRIMARY KEY</code>, and <code class="language-plaintext highlighter-rouge">FOREIGN KEY</code>. These constraints can be beneficial for ensuring data integrity but they have a negative effect on load performance as they necessitate building indexes and performing checks. Moreover, they <em>very rarely improve the performance of queries</em> as DuckDB does not rely on these indexes for join and aggregation operators (see <a href="indexing.html">indexing</a> for more details).</p> <blockquote> <p>Bestpractice Do not define constraints unless your goal is to ensure data integrity.</p> </blockquote> <h3 id="microbenchmark-the-effect-of-primary-keys"> <a style="text-decoration: none;" href="#microbenchmark-the-effect-of-primary-keys">Microbenchmark: The Effect of Primary Keys</a> </h3> <p>We illustrate the effect of using primary keys with the <a href="https://blobs.duckdb.org/data/ldbc-sf300-comments.tar.zst">LDBC Comment table at scale factor 300</a>. This table has approx. 554 million entries. We first create the schema without a primary key, then load the data. In the second experiment, we create the schema with a primary key, then load the data. In both cases, we take the data from <code class="language-plaintext highlighter-rouge">.csv.gz</code> files, and measure the time required to perform the loading.</p>  <table> <thead> <tr> <th>Operation</th> <th style="text-align: right">Execution time</th> </tr> </thead> <tbody> <tr> <td>Load without primary key</td> <td style="text-align: right">92.2 s</td> </tr> <tr> <td>Load with primary key</td> <td style="text-align: right">286.8 s</td> </tr> </tbody> </table> <p>In this case, primary keys will only have a (small) positive effect on highly selective queries such as when filtering on a single identifier. They do not have an effect on join and aggregation operators.</p> <blockquote> <p>Bestpractice For best bulk load performance, avoid defining primary key constraints if possible.</p> </blockquote><div class="_attribution">
  <p class="_attribution-p">
    &copy; Copyright 2018&ndash;2024 Stichting DuckDB Foundation<br>Licensed under the MIT License.<br>
    <a href="https://duckdb.org/docs/guides/performance/schema.html" class="_attribution-link">https://duckdb.org/docs/guides/performance/schema.html</a>
  </p>
</div>
