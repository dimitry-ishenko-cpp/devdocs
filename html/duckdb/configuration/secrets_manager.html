<h1 class="title">Secrets Manager</h1>  <p>The <strong>Secrets manager</strong> provides a unified user interface for secrets across all backends that use them. Secrets can be scoped, so different storage prefixes can have different secrets, allowing for example to join data across organizations in a single query. Secrets can also be persisted, so that they do not need to be specified every time DuckDB is launched.</p> <blockquote> <p>Warning Persistent secrets are stored in unencrypted binary format on the disk.</p> </blockquote> <h2 id="secrets"> <a style="text-decoration: none;" href="#secrets">Secrets</a> </h2> <h3 id="types-of-secrets"> <a style="text-decoration: none;" href="#types-of-secrets">Types of Secrets</a> </h3> <p>Secrets are typed, their type identifies which service they are for. Currently, the following cloud services are available:</p> <ul> <li>AWS S3 (<code class="language-plaintext highlighter-rouge">S3</code>), through the <a href="../extensions/httpfs/s3api.html"><code class="language-plaintext highlighter-rouge">httpfs</code> extension</a>
</li> <li>Azure Blob Storage (<code class="language-plaintext highlighter-rouge">AZURE</code>), through the <a href="../extensions/azure.html"><code class="language-plaintext highlighter-rouge">azure</code> extension</a>
</li> <li>Cloudflare R2 (<code class="language-plaintext highlighter-rouge">R2</code>), through the <a href="../extensions/httpfs/s3api.html"><code class="language-plaintext highlighter-rouge">httpfs</code> extension</a>
</li> <li>Google Cloud Storage (<code class="language-plaintext highlighter-rouge">GCS</code>), through the <a href="../extensions/httpfs/s3api.html"><code class="language-plaintext highlighter-rouge">httpfs</code> extension</a>
</li> <li>Hugging Face (<code class="language-plaintext highlighter-rouge">HUGGINGFACE</code>), through the <a href="../extensions/httpfs/hugging_face.html"><code class="language-plaintext highlighter-rouge">httpfs</code> extension</a>
</li> <li>MySQL (<code class="language-plaintext highlighter-rouge">MYSQL</code>), through the <a href="../extensions/mysql.html"><code class="language-plaintext highlighter-rouge">mysql</code> extension</a>
</li> <li>PostgreSQL (<code class="language-plaintext highlighter-rouge">POSTGRES</code>), through the <a href="../extensions/postgres.html"><code class="language-plaintext highlighter-rouge">postgres</code> extension</a>
</li> </ul> <p>For each type, there are one or more “secret providers” that specify how the secret is created. Secrets can also have an optional scope, which is a file path prefix that the secret applies to. When fetching a secret for a path, the secret scopes are compared to the path, returning the matching secret for the path. In the case of multiple matching secrets, the longest prefix is chosen.</p> <h3 id="creating-a-secret"> <a style="text-decoration: none;" href="#creating-a-secret">Creating a Secret</a> </h3> <p>Secrets can be created using the <a href="../sql/statements/create_secret.html"><code class="language-plaintext highlighter-rouge">CREATE SECRET</code> SQL statement</a>. Secrets can be <strong>temporary</strong> or <strong>persistent</strong>. Temporary secrets are used by default – and are stored in-memory for the life span of the DuckDB instance similar to how settings worked previously. Persistent secrets are stored in <strong>unencrypted binary format</strong> in the <code class="language-plaintext highlighter-rouge">~/.duckdb/stored_secrets</code> directory. On startup of DuckDB, persistent secrets are read from this directory and automatically loaded.</p> <h4 id="secret-providers"> <a style="text-decoration: none;" href="#secret-providers">Secret Providers</a> </h4> <p>To create a secret, a <strong>Secret Provider</strong> needs to be used. A Secret Provider is a mechanism through which a secret is generated. To illustrate this, for the <code class="language-plaintext highlighter-rouge">S3</code>, <code class="language-plaintext highlighter-rouge">GCS</code>, <code class="language-plaintext highlighter-rouge">R2</code>, and <code class="language-plaintext highlighter-rouge">AZURE</code> secret types, DuckDB currently supports two providers: <code class="language-plaintext highlighter-rouge">CONFIG</code> and <code class="language-plaintext highlighter-rouge">CREDENTIAL_CHAIN</code>. The <code class="language-plaintext highlighter-rouge">CONFIG</code> provider requires the user to pass all configuration information into the <code class="language-plaintext highlighter-rouge">CREATE SECRET</code>, whereas the <code class="language-plaintext highlighter-rouge">CREDENTIAL_CHAIN</code> provider will automatically try to fetch credentials. When no Secret Provider is specified, the <code class="language-plaintext highlighter-rouge">CONFIG</code> provider is used. For more details on how to create secrets using different providers check out the respective pages on <a href="../extensions/httpfs/overview.html#configuration-and-authentication-using-secrets.html">httpfs</a> and <a href="../extensions/azure.html#authentication-with-secret.html">azure</a>.</p> <h4 id="temporary-secrets"> <a style="text-decoration: none;" href="#temporary-secrets">Temporary Secrets</a> </h4> <p>To create a temporary unscoped secret to access S3, we can now use the following:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE SECRET my_secret (
    TYPE S3,
    KEY_ID 'my_secret_key',
    SECRET 'my_secret_value',
    REGION 'my_region'
);</pre> <p>Note that we implicitly use the default <code class="language-plaintext highlighter-rouge">CONFIG</code> secret provider here.</p> <h4 id="persistent-secrets"> <a style="text-decoration: none;" href="#persistent-secrets">Persistent Secrets</a> </h4> <p>In order to persist secrets between DuckDB database instances, we can now use the <code class="language-plaintext highlighter-rouge">CREATE PERSISTENT SECRET</code> command, e.g.:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE PERSISTENT SECRET my_persistent_secret (
    TYPE S3,
    KEY_ID 'my_secret_key',
    SECRET 'my_secret_value'
);</pre> <p>By default, this will write the secret (unencrypted) to the <code class="language-plaintext highlighter-rouge">~/.duckdb/stored_secrets</code> directory. To change the secrets directory, issue:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SET secret_directory = 'path/to/my_secrets_dir';</pre> <p>Note that setting the value of the <code class="language-plaintext highlighter-rouge">home_directory</code> configuration option has no effect on the location of the secrets.</p> <h3 id="deleting-secrets"> <a style="text-decoration: none;" href="#deleting-secrets">Deleting Secrets</a> </h3> <p>Secrets can be deleted using the <a href="../sql/statements/create_secret.html#syntax-for-drop-secret.html"><code class="language-plaintext highlighter-rouge">DROP SECRET</code> statement</a>, e.g.:</p> <pre class="language-sql highlighter-rouge" data-language="sql">DROP PERSISTENT SECRET my_persistent_secret;</pre> <h3 id="creating-multiple-secrets-for-the-same-service-type"> <a style="text-decoration: none;" href="#creating-multiple-secrets-for-the-same-service-type">Creating Multiple Secrets for the Same Service Type</a> </h3> <p>If two secrets exist for a service type, the scope can be used to decide which one should be used. For example:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE SECRET secret1 (
    TYPE S3,
    KEY_ID 'my_secret_key1',
    SECRET 'my_secret_value1',
    SCOPE 's3://my-bucket'
);</pre> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE SECRET secret2 (
    TYPE S3,
    KEY_ID 'my_secret_key2',
    SECRET 'my_secret_value2',
    SCOPE 's3://my-other-bucket'
);</pre> <p>Now, if the user queries something from <code class="language-plaintext highlighter-rouge">s3://my-other-bucket/something</code>, secret <code class="language-plaintext highlighter-rouge">secret2</code> will be chosen automatically for that request. To see which secret is being used, the <code class="language-plaintext highlighter-rouge">which_secret</code> scalar function can be used, which takes a path and a secret type as parameters:</p> <pre class="language-sql highlighter-rouge" data-language="sql">FROM which_secret('s3://my-other-bucket/file.parquet', 's3');</pre> <h3 id="listing-secrets"> <a style="text-decoration: none;" href="#listing-secrets">Listing Secrets</a> </h3> <p>Secrets can be listed using the built-in table-producing function, e.g., by using the <a href="../sql/meta/duckdb_table_functions.html#duckdb_secrets.html"><code class="language-plaintext highlighter-rouge">duckdb_secrets()</code> table function</a>:</p> <pre class="language-sql highlighter-rouge" data-language="sql">FROM duckdb_secrets();</pre> <p>Sensitive information will be redacted.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; Copyright 2018&ndash;2024 Stichting DuckDB Foundation<br>Licensed under the MIT License.<br>
    <a href="https://duckdb.org/docs/configuration/secrets_manager.html" class="_attribution-link">https://duckdb.org/docs/configuration/secrets_manager.html</a>
  </p>
</div>
