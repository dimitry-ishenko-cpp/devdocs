<h1 class="title">Pragmas</h1>   <p>The <code class="language-plaintext highlighter-rouge">PRAGMA</code> statement is a SQL extension adopted by DuckDB from SQLite. <code class="language-plaintext highlighter-rouge">PRAGMA</code> statements can be issued in a similar manner to regular SQL statements. <code class="language-plaintext highlighter-rouge">PRAGMA</code> commands may alter the internal state of the database engine, and can influence the subsequent execution or behavior of the engine.</p> <p><code class="language-plaintext highlighter-rouge">PRAGMA</code> statements that assign a value to an option can also be issued using the <a href="../sql/statements/set.html"><code class="language-plaintext highlighter-rouge">SET</code> statement</a> and the value of an option can be retrieved using <code class="language-plaintext highlighter-rouge">SELECT current_setting(option_name)</code>.</p> <p>For DuckDB's built in configuration options, see the <a href="overview.html#configuration-reference.html">Configuration Reference</a>. DuckDB <a href="../extensions/overview.html">extensions</a> may register additional configuration options. These are documented in the respective extensions' documentation pages.</p> <p>This page contains the supported <code class="language-plaintext highlighter-rouge">PRAGMA</code> settings.</p> <h2 id="metadata"> <a style="text-decoration: none;" href="#metadata">Metadata</a> </h2> <h4 id="schema-information"> <a style="text-decoration: none;" href="#schema-information">Schema Information</a> </h4> <p>List all databases:</p> <pre class="language-sql highlighter-rouge" data-language="sql">PRAGMA database_list;</pre> <p>List all tables:</p> <pre class="language-sql highlighter-rouge" data-language="sql">PRAGMA show_tables;</pre> <p>List all tables, with extra information, similarly to <a href="../guides/meta/describe.html"><code class="language-plaintext highlighter-rouge">DESCRIBE</code></a>:</p> <pre class="language-sql highlighter-rouge" data-language="sql">PRAGMA show_tables_expanded;</pre> <p>To list all functions:</p> <pre class="language-sql highlighter-rouge" data-language="sql">PRAGMA functions;</pre> <h4 id="table-information"> <a style="text-decoration: none;" href="#table-information">Table Information</a> </h4> <p>Get info for a specific table:</p> <pre class="language-sql highlighter-rouge" data-language="sql">PRAGMA table_info('table_name');
CALL pragma_table_info('table_name');</pre> <p><code class="language-plaintext highlighter-rouge">table_info</code> returns information about the columns of the table with name <code class="language-plaintext highlighter-rouge">table_name</code>. The exact format of the table returned is given below:</p> <pre class="language-sql highlighter-rouge" data-language="sql">cid INTEGER,        -- cid of the column
name VARCHAR,       -- name of the column
type VARCHAR,       -- type of the column
notnull BOOLEAN,    -- if the column is marked as NOT NULL
dflt_value VARCHAR, -- default value of the column, or NULL if not specified
pk BOOLEAN          -- part of the primary key or not</pre> <h4 id="database-size"> <a style="text-decoration: none;" href="#database-size">Database Size</a> </h4> <p>Get the file and memory size of each database:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SET database_size;
CALL pragma_database_size();</pre> <p><code class="language-plaintext highlighter-rouge">database_size</code> returns information about the file and memory size of each database. The column types of the returned results are given below:</p> <pre class="language-sql highlighter-rouge" data-language="sql">database_name VARCHAR, -- database name
database_size VARCHAR, -- total block count times the block size
block_size BIGINT,     -- database block size
total_blocks BIGINT,   -- total blocks in the database
used_blocks BIGINT,    -- used blocks in the database
free_blocks BIGINT,    -- free blocks in the database
wal_size VARCHAR,      -- write ahead log size
memory_usage VARCHAR,  -- memory used by the database buffer manager
memory_limit VARCHAR   -- maximum memory allowed for the database</pre> <h4 id="storage-information"> <a style="text-decoration: none;" href="#storage-information">Storage Information</a> </h4> <p>To get storage information:</p> <pre class="language-sql highlighter-rouge" data-language="sql">PRAGMA storage_info('table_name');
CALL pragma_storage_info('table_name');</pre> <p>This call returns the following information for the given table:</p>  <table> <thead> <tr> <th>Name</th> <th>Type</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">row_group_id</code></td> <td><code class="language-plaintext highlighter-rouge">BIGINT</code></td> <td> </td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">column_name</code></td> <td><code class="language-plaintext highlighter-rouge">VARCHAR</code></td> <td> </td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">column_id</code></td> <td><code class="language-plaintext highlighter-rouge">BIGINT</code></td> <td> </td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">column_path</code></td> <td><code class="language-plaintext highlighter-rouge">VARCHAR</code></td> <td> </td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">segment_id</code></td> <td><code class="language-plaintext highlighter-rouge">BIGINT</code></td> <td> </td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">segment_type</code></td> <td><code class="language-plaintext highlighter-rouge">VARCHAR</code></td> <td> </td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">start</code></td> <td><code class="language-plaintext highlighter-rouge">BIGINT</code></td> <td>The start row id of this chunk</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">count</code></td> <td><code class="language-plaintext highlighter-rouge">BIGINT</code></td> <td>The amount of entries in this storage chunk</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">compression</code></td> <td><code class="language-plaintext highlighter-rouge">VARCHAR</code></td> <td>Compression type used for this column – see the <a href="http://localhost:8000/2022/10/28/lightweight-compression.html">“Lightweight Compression in DuckDB” blog post</a>
</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">stats</code></td> <td><code class="language-plaintext highlighter-rouge">VARCHAR</code></td> <td> </td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">has_updates</code></td> <td><code class="language-plaintext highlighter-rouge">BOOLEAN</code></td> <td> </td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">persistent</code></td> <td><code class="language-plaintext highlighter-rouge">BOOLEAN</code></td> <td>
<code class="language-plaintext highlighter-rouge">false</code> if temporary table</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">block_id</code></td> <td><code class="language-plaintext highlighter-rouge">BIGINT</code></td> <td>empty unless persistent</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">block_offset</code></td> <td><code class="language-plaintext highlighter-rouge">BIGINT</code></td> <td>empty unless persistent</td> </tr> </tbody> </table> <p>See <a href="../internals/storage.html">Storage</a> for more information.</p> <h4 id="show-databases"> <a style="text-decoration: none;" href="#show-databases">Show Databases</a> </h4> <p>The following statement is equivalent to the <a href="../sql/statements/attach.html"><code class="language-plaintext highlighter-rouge">SHOW DATABASES</code> statement</a>:</p> <pre class="language-sql highlighter-rouge" data-language="sql">PRAGMA show_databases;</pre> <h2 id="resource-management"> <a style="text-decoration: none;" href="#resource-management">Resource Management</a> </h2> <h4 id="memory-limit"> <a style="text-decoration: none;" href="#memory-limit">Memory Limit</a> </h4> <p>Set the memory limit for the buffer manager:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SET memory_limit = '1GB';
SET max_memory = '1GB';</pre> <blockquote> <p>Warning The specified memory limit is only applied to the buffer manager. For most queries, the buffer manager handles the majority of the data processed. However, certain in-memory data structures such as <a href="../internals/vector.html">vectors</a> and query results are allocated outside of the buffer manager. Additionally, <a href="../sql/functions/aggregates.html">aggregate functions</a> with complex state (e.g., <code class="language-plaintext highlighter-rouge">list</code>, <code class="language-plaintext highlighter-rouge">mode</code>, <code class="language-plaintext highlighter-rouge">quantile</code>, <code class="language-plaintext highlighter-rouge">string_agg</code>, and <code class="language-plaintext highlighter-rouge">approx</code> functions) use memory outside of the buffer manager. Therefore, the actual memory consumption can be higher than the specified memory limit.</p> </blockquote> <h4 id="threads"> <a style="text-decoration: none;" href="#threads">Threads</a> </h4> <p>Set the amount of threads for parallel query execution:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SET threads = 4;</pre> <h2 id="collations"> <a style="text-decoration: none;" href="#collations">Collations</a> </h2> <p>List all available collations:</p> <pre class="language-sql highlighter-rouge" data-language="sql">PRAGMA collations;</pre> <p>Set the default collation to one of the available ones:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SET default_collation = 'nocase';</pre> <h2 id="default-ordering-for-nulls"> <a style="text-decoration: none;" href="#default-ordering-for-nulls">Default Ordering for NULLs</a> </h2> <p>Set the default ordering for NULLs to be either <code class="language-plaintext highlighter-rouge">NULLS_FIRST</code>, <code class="language-plaintext highlighter-rouge">NULLS_LAST</code>, <code class="language-plaintext highlighter-rouge">NULLS_FIRST_ON_ASC_LAST_ON_DESC</code> or <code class="language-plaintext highlighter-rouge">NULLS_LAST_ON_ASC_FIRST_ON_DESC</code>:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SET default_null_order = 'NULLS_FIRST';
SET default_null_order = 'NULLS_LAST_ON_ASC_FIRST_ON_DESC';</pre> <p>Set the default result set ordering direction to <code class="language-plaintext highlighter-rouge">ASCENDING</code> or <code class="language-plaintext highlighter-rouge">DESCENDING</code>:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SET default_order = 'ASCENDING';
SET default_order = 'DESCENDING';</pre> <h2 id="ordering-by-non-integer-literals"> <a style="text-decoration: none;" href="#ordering-by-non-integer-literals">Ordering by Non-Integer Literals</a> </h2> <p>By default, ordering by non-integer literals is not allowed:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT 42 ORDER BY 'hello world';</pre> <pre class="language-console highlighter-rouge" data-language="console">-- Binder Error: ORDER BY non-integer literal has no effect.</pre> <p>To allow this behavior, use the <code class="language-plaintext highlighter-rouge">order_by_non_integer_literal</code> option:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SET order_by_non_integer_literal = true;</pre> <h2 id="implicit-casting-to-varchar"> <a style="text-decoration: none;" href="#implicit-casting-to-varchar">Implicit Casting to <code class="language-plaintext highlighter-rouge">VARCHAR</code></a> </h2> <p>Prior to version 0.10.0, DuckDB would automatically allow any type to be implicitly cast to <code class="language-plaintext highlighter-rouge">VARCHAR</code> during function binding. As a result it was possible to e.g., compute the substring of an integer without using an explicit cast. For version v0.10.0 and later an explicit cast is needed instead. To revert to the old behavior that performs implicit casting, set the <code class="language-plaintext highlighter-rouge">old_implicit_casting</code> variable to <code class="language-plaintext highlighter-rouge">true</code>:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SET old_implicit_casting = true;</pre> <h2 id="python-scan-all-dataframes"> <a style="text-decoration: none;" href="#python-scan-all-dataframes">Python: Scan All Dataframes</a> </h2> <p>Prior to version 1.1.0, DuckDB's <a href="../api/c/replacement_scans.html">replacement scan mechanism</a> in Python scanned the global Python namespace. To revert to this old behavior, use the following setting:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SET python_scan_all_frames = true;</pre> <h2 id="information-on-duckdb"> <a style="text-decoration: none;" href="#information-on-duckdb">Information on DuckDB</a> </h2> <h4 id="version"> <a style="text-decoration: none;" href="#version">Version</a> </h4> <p>Show DuckDB version:</p> <pre class="language-sql highlighter-rouge" data-language="sql">PRAGMA version;
CALL pragma_version();</pre> <h4 id="platform"> <a style="text-decoration: none;" href="#platform">Platform</a> </h4> <p><code class="language-plaintext highlighter-rouge">platform</code> returns an identifier for the platform the current DuckDB executable has been compiled for, e.g., <code class="language-plaintext highlighter-rouge">osx_arm64</code>. The format of this identifier matches the platform name as described in the <a href="../extensions/working_with_extensions.html#platforms.html">extension loading explainer</a>:</p> <pre class="language-sql highlighter-rouge" data-language="sql">PRAGMA platform;
CALL pragma_platform();</pre> <h4 id="user-agent"> <a style="text-decoration: none;" href="#user-agent">User Agent</a> </h4> <p>The following statement returns the user agent information, e.g., <code class="language-plaintext highlighter-rouge">duckdb/v0.10.0(osx_arm64)</code>:</p> <pre class="language-sql highlighter-rouge" data-language="sql">PRAGMA user_agent;</pre> <h4 id="metadata-information"> <a style="text-decoration: none;" href="#metadata-information">Metadata Information</a> </h4> <p>The following statement returns information on the metadata store (<code class="language-plaintext highlighter-rouge">block_id</code>, <code class="language-plaintext highlighter-rouge">total_blocks</code>, <code class="language-plaintext highlighter-rouge">free_blocks</code>, and <code class="language-plaintext highlighter-rouge">free_list</code>):</p> <pre class="language-sql highlighter-rouge" data-language="sql">PRAGMA metadata_info;</pre> <h2 id="progress-bar"> <a style="text-decoration: none;" href="#progress-bar">Progress Bar</a> </h2> <p>Show progress bar when running queries:</p> <pre class="language-sql highlighter-rouge" data-language="sql">PRAGMA enable_progress_bar;</pre> <p>Or:</p> <pre class="language-sql highlighter-rouge" data-language="sql">PRAGMA enable_print_progress_bar;</pre> <p>Don't show a progress bar for running queries:</p> <pre class="language-sql highlighter-rouge" data-language="sql">PRAGMA disable_progress_bar;</pre> <p>Or:</p> <pre class="language-sql highlighter-rouge" data-language="sql">PRAGMA disable_print_progress_bar;</pre> <h2 id="explain-output"> <a style="text-decoration: none;" href="#explain-output">EXPLAIN Output</a> </h2> <p>The output of <a href="../sql/statements/profiling.html"><code class="language-plaintext highlighter-rouge">EXPLAIN</code></a> can be configured to show only the physical plan.</p> <p>The default configuration of <code class="language-plaintext highlighter-rouge">EXPLAIN</code>:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SET explain_output = 'physical_only';</pre> <p>To only show the optimized query plan:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SET explain_output = 'optimized_only';</pre> <p>To show all query plans:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SET explain_output = 'all';</pre> <h2 id="profiling"> <a style="text-decoration: none;" href="#profiling">Profiling</a> </h2> <h3 id="enable-profiling"> <a style="text-decoration: none;" href="#enable-profiling">Enable Profiling</a> </h3> <p>The following query enables profiling with the default format, <code class="language-plaintext highlighter-rouge">query_tree</code>. Independent of the format, <code class="language-plaintext highlighter-rouge">enable_profiling</code> is <strong>mandatory</strong> to enable profiling.</p> <pre class="language-sql highlighter-rouge" data-language="sql">PRAGMA enable_profiling;
PRAGMA enable_profile;</pre> <h5 id="profiling-format"> <a style="text-decoration: none;" href="#profiling-format">Profiling Format</a> </h5> <p>The format of <code class="language-plaintext highlighter-rouge">enable_profiling</code> can be specified as <code class="language-plaintext highlighter-rouge">query_tree</code>, <code class="language-plaintext highlighter-rouge">json</code>, <code class="language-plaintext highlighter-rouge">query_tree_optimizer</code>, or <code class="language-plaintext highlighter-rouge">no_output</code>. Each format prints its output to the configured output, except <code class="language-plaintext highlighter-rouge">no_output</code>.</p> <p>The default format is <code class="language-plaintext highlighter-rouge">query_tree</code>. It prints the physical query plan and the metrics of each operator in the tree.</p> <pre class="language-sql highlighter-rouge" data-language="sql">SET enable_profiling = 'query_tree';</pre> <p>Alternatively, <code class="language-plaintext highlighter-rouge">json</code> returns the physical query plan as JSON:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SET enable_profiling = 'json';</pre> <p>To return the physical query plan, including optimizer and planner metrics:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SET enable_profiling = 'query_tree_optimizer';</pre> <p>Database drivers and other applications can also access profiling information through API calls, in which case users can disable any other output. Even though the parameter reads <code class="language-plaintext highlighter-rouge">no_output</code>, it is essential to note that this <strong>only</strong> affects printing to the configurable output. When accessing profiling information through API calls, it is still crucial to enable profiling:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SET enable_profiling = 'no_output';</pre> <h3 id="profiling-output"> <a style="text-decoration: none;" href="#profiling-output">Profiling Output</a> </h3> <p>By default, DuckDB prints profiling information to the standard output. However, if you prefer to write the profiling information to a file, you can use <code class="language-plaintext highlighter-rouge">PRAGMA</code> <code class="language-plaintext highlighter-rouge">profiling_output</code> to specify a filepath.</p> <blockquote> <p>Warning The file contents will be overwritten for every newly issued query. Hence, the file will only contain the profiling information of the last run query:</p> </blockquote> <pre class="language-sql highlighter-rouge" data-language="sql">SET profiling_output = '/path/to/file.json';
SET profile_output = '/path/to/file.json';</pre> <h3 id="profiling-mode"> <a style="text-decoration: none;" href="#profiling-mode">Profiling Mode</a> </h3> <p>By default, a limited amount of profiling information is provided (<code class="language-plaintext highlighter-rouge">standard</code>).</p> <pre class="language-sql highlighter-rouge" data-language="sql">SET profiling_mode = 'standard';</pre> <p>For more details, use the detailed profiling mode by setting <code class="language-plaintext highlighter-rouge">profiling_mode</code> to <code class="language-plaintext highlighter-rouge">detailed</code>. The output of this mode includes profiling of the planner and optimizer stages.</p> <pre class="language-sql highlighter-rouge" data-language="sql">SET profiling_mode = 'detailed';</pre> <h3 id="custom-metrics"> <a style="text-decoration: none;" href="#custom-metrics">Custom Metrics</a> </h3> <p>By default, profiling enables all metrics except those activated by detailed profiling.</p> <p>Using the <code class="language-plaintext highlighter-rouge">custom_profiling_settings</code> <code class="language-plaintext highlighter-rouge">PRAGMA</code>, each metric, including those from detailed profiling, can be individually enabled or disabled. This <code class="language-plaintext highlighter-rouge">PRAGMA</code> accepts a JSON object with metric names as keys and Boolean values to toggle them on or off. Settings specified by this <code class="language-plaintext highlighter-rouge">PRAGMA</code> override the default behavior.</p> <blockquote> <p>Note This only affects the metrics when the <code class="language-plaintext highlighter-rouge">enable_profiling</code> is set to <code class="language-plaintext highlighter-rouge">json</code> or <code class="language-plaintext highlighter-rouge">no_output</code>. The <code class="language-plaintext highlighter-rouge">query_tree</code> and <code class="language-plaintext highlighter-rouge">query_tree_optimizer</code> always use a default set of metrics.</p> </blockquote> <p>In the following example, the <code class="language-plaintext highlighter-rouge">CPU_TIME</code> metric is disabled. The <code class="language-plaintext highlighter-rouge">EXTRA_INFO</code>, <code class="language-plaintext highlighter-rouge">OPERATOR_CARDINALITY</code>, and <code class="language-plaintext highlighter-rouge">OPERATOR_TIMING</code> metrics are enabled.</p> <pre class="language-sql highlighter-rouge" data-language="sql">SET custom_profiling_settings = '{"CPU_TIME": "false", "EXTRA_INFO": "true", "OPERATOR_CARDINALITY": "true", "OPERATOR_TIMING": "true"}';</pre> <p>The profiling documentation contains an overview of the available <a href="../dev/profiling.html#metrics.html">metrics</a>.</p> <h3 id="disable-profiling"> <a style="text-decoration: none;" href="#disable-profiling">Disable Profiling</a> </h3> <p>To disable profiling:</p> <pre class="language-sql highlighter-rouge" data-language="sql">PRAGMA disable_profiling;
PRAGMA disable_profile;</pre> <h2 id="query-optimization"> <a style="text-decoration: none;" href="#query-optimization">Query Optimization</a> </h2> <h4 id="optimizer"> <a style="text-decoration: none;" href="#optimizer">Optimizer</a> </h4> <p>To disable the query optimizer:</p> <pre class="language-sql highlighter-rouge" data-language="sql">PRAGMA disable_optimizer;</pre> <p>To enable the query optimizer:</p> <pre class="language-sql highlighter-rouge" data-language="sql">PRAGMA enable_optimizer;</pre> <h4 id="selectively-disabling-optimizers"> <a style="text-decoration: none;" href="#selectively-disabling-optimizers">Selectively Disabling Optimizers</a> </h4> <p>The <code class="language-plaintext highlighter-rouge">disabled_optimizers</code> option allows selectively disabling optimization steps. For example, to disable <code class="language-plaintext highlighter-rouge">filter_pushdown</code> and <code class="language-plaintext highlighter-rouge">statistics_propagation</code>, run:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SET disabled_optimizers = 'filter_pushdown,statistics_propagation';</pre> <p>The available optimizations can be queried using the <a href="../sql/meta/duckdb_table_functions.html#duckdb_optimizers.html"><code class="language-plaintext highlighter-rouge">duckdb_optimizers()</code> table function</a>.</p> <p>To re-enable the optimizers, run:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SET disabled_optimizers = '';</pre> <blockquote> <p>Warning The <code class="language-plaintext highlighter-rouge">disabled_optimizers</code> option should only be used for debugging performance issues and should be avoided in production.</p> </blockquote> <h2 id="logging"> <a style="text-decoration: none;" href="#logging">Logging</a> </h2> <p>Set a path for query logging:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SET log_query_path = '/tmp/duckdb_log/';</pre> <p>Disable query logging:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SET log_query_path = '';</pre> <h2 id="full-text-search-indexes"> <a style="text-decoration: none;" href="#full-text-search-indexes">Full-Text Search Indexes</a> </h2> <p>The <code class="language-plaintext highlighter-rouge">create_fts_index</code> and <code class="language-plaintext highlighter-rouge">drop_fts_index</code> options are only available when the <a href="../extensions/full_text_search.html"><code class="language-plaintext highlighter-rouge">fts</code> extension</a> is loaded. Their usage is documented on the <a href="../extensions/full_text_search.html">Full-Text Search extension page</a>.</p> <h2 id="verification"> <a style="text-decoration: none;" href="#verification">Verification</a> </h2> <h4 id="verification-of-external-operators"> <a style="text-decoration: none;" href="#verification-of-external-operators">Verification of External Operators</a> </h4> <p>Enable verification of external operators:</p> <pre class="language-sql highlighter-rouge" data-language="sql">PRAGMA verify_external;</pre> <p>Disable verification of external operators:</p> <pre class="language-sql highlighter-rouge" data-language="sql">PRAGMA disable_verify_external;</pre> <h4 id="verification-of-round-trip-capabilities"> <a style="text-decoration: none;" href="#verification-of-round-trip-capabilities">Verification of Round-Trip Capabilities</a> </h4> <p>Enable verification of round-trip capabilities for supported logical plans:</p> <pre class="language-sql highlighter-rouge" data-language="sql">PRAGMA verify_serializer;</pre> <p>Disable verification of round-trip capabilities:</p> <pre class="language-sql highlighter-rouge" data-language="sql">PRAGMA disable_verify_serializer;</pre> <h2 id="object-cache"> <a style="text-decoration: none;" href="#object-cache">Object Cache</a> </h2> <p>Enable caching of objects for e.g., Parquet metadata:</p> <pre class="language-sql highlighter-rouge" data-language="sql">PRAGMA enable_object_cache;</pre> <p>Disable caching of objects:</p> <pre class="language-sql highlighter-rouge" data-language="sql">PRAGMA disable_object_cache;</pre> <h2 id="checkpointing"> <a style="text-decoration: none;" href="#checkpointing">Checkpointing</a> </h2> <h4 id="force-checkpoint"> <a style="text-decoration: none;" href="#force-checkpoint">Force Checkpoint</a> </h4> <p>When <a href="../sql/statements/checkpoint.html"><code class="language-plaintext highlighter-rouge">CHECKPOINT</code></a> is called when no changes are made, force a checkpoint regardless:</p> <pre class="language-sql highlighter-rouge" data-language="sql">PRAGMA force_checkpoint;</pre> <h4 id="checkpoint-on-shutdown"> <a style="text-decoration: none;" href="#checkpoint-on-shutdown">Checkpoint on Shutdown</a> </h4> <p>Run a <code class="language-plaintext highlighter-rouge">CHECKPOINT</code> on successful shutdown and delete the WAL, to leave only a single database file behind:</p> <pre class="language-sql highlighter-rouge" data-language="sql">PRAGMA enable_checkpoint_on_shutdown;</pre> <p>Don't run a <code class="language-plaintext highlighter-rouge">CHECKPOINT</code> on shutdown:</p> <pre class="language-sql highlighter-rouge" data-language="sql">PRAGMA disable_checkpoint_on_shutdown;</pre> <h2 id="temp-directory-for-spilling-data-to-disk"> <a style="text-decoration: none;" href="#temp-directory-for-spilling-data-to-disk">Temp Directory for Spilling Data to Disk</a> </h2> <p>By default, DuckDB uses a temporary directory named <code class="language-plaintext highlighter-rouge">⟨database_file_name⟩.tmp</code> to spill to disk, located in the same directory as the database file. To change this, use:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SET temp_directory = '/path/to/temp_dir.tmp/';</pre> <h2 id="returning-errors-as-json"> <a style="text-decoration: none;" href="#returning-errors-as-json">Returning Errors as JSON</a> </h2> <p>The <code class="language-plaintext highlighter-rouge">errors_as_json</code> option can be set to obtain error information in raw JSON format. For certain errors, extra information or decomposed information is provided for easier machine processing. For example:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SET errors_as_json = true;</pre> <p>Then, running a query that results in an error produces a JSON output:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT * FROM nonexistent_tbl;</pre> <pre class="language-json highlighter-rouge" data-language="json">{
   "exception_type":"Catalog",
   "exception_message":"Table with name nonexistent_tbl does not exist!\nDid you mean \"temp.information_schema.tables\"?",
   "name":"nonexistent_tbl",
   "candidates":"temp.information_schema.tables",
   "position":"14",
   "type":"Table",
   "error_subtype":"MISSING_ENTRY"
}</pre> <h2 id="ieee-floating-point-operation-semantics"> <a style="text-decoration: none;" href="#ieee-floating-point-operation-semantics">IEEE Floating-Point Operation Semantics</a> </h2> <p>DuckDB follows IEEE floating-point operation semantics. If you would like to turn this off, run:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SET ieee_floating_point_ops = false;</pre> <p>In this case, floating point division by zero (e.g., <code class="language-plaintext highlighter-rouge">1.0 / 0.0</code>, <code class="language-plaintext highlighter-rouge">0.0 / 0.0</code> and <code class="language-plaintext highlighter-rouge">-1.0 / 0.0</code>) will all return <code class="language-plaintext highlighter-rouge">NULL</code>.</p> <h2 id="query-verification-for-development"> <a style="text-decoration: none;" href="#query-verification-for-development">Query Verification (for Development)</a> </h2> <p>The following <code class="language-plaintext highlighter-rouge">PRAGMA</code>s are mostly used for development and internal testing.</p> <p>Enable query verification:</p> <pre class="language-sql highlighter-rouge" data-language="sql">PRAGMA enable_verification;</pre> <p>Disable query verification:</p> <pre class="language-sql highlighter-rouge" data-language="sql">PRAGMA disable_verification;</pre> <p>Enable force parallel query processing:</p> <pre class="language-sql highlighter-rouge" data-language="sql">PRAGMA verify_parallelism;</pre> <p>Disable force parallel query processing:</p> <pre class="language-sql highlighter-rouge" data-language="sql">PRAGMA disable_verify_parallelism;</pre> <h2 id="block-sizes"> <a style="text-decoration: none;" href="#block-sizes">Block Sizes</a> </h2> <p>When persisting a database to disk, DuckDB writes to a dedicated file containing a list of blocks holding the data. In the case of a file that only holds very little data, e.g., a small table, the default block size of 256KB might not be ideal. Therefore, DuckDB's storage format supports different block sizes.</p> <p>There are a few constraints on possible block size values.</p> <ul> <li>Must be a power of two.</li> <li>Must be greater or equal to 16384 (16 KB).</li> <li>Must be lesser or equal to 262144 (256 KB).</li> </ul> <p>You can set the default block size for all new DuckDB files created by an instance like so:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SET default_block_size = '16384';</pre> <p>It is also possible to set the block size on a per-file basis, see <a href="../sql/statements/attach.html"><code class="language-plaintext highlighter-rouge">ATTACH</code></a> for details.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; Copyright 2018&ndash;2024 Stichting DuckDB Foundation<br>Licensed under the MIT License.<br>
    <a href="https://duckdb.org/docs/configuration/pragmas.html" class="_attribution-link">https://duckdb.org/docs/configuration/pragmas.html</a>
  </p>
</div>
