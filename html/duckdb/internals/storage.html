<h1 class="title">Storage Versions and Format</h1>  <h2 id="compatibility"> <a style="text-decoration: none;" href="#compatibility">Compatibility</a> </h2> <h3 id="backward-compatibility"> <a style="text-decoration: none;" href="#backward-compatibility">Backward Compatibility</a> </h3> <p><em>Backward compatibility</em> refers to the ability of a newer DuckDB version to read storage files created by an older DuckDB version. Version 0.10 is the first release of DuckDB that supports backward compatibility in the storage format. DuckDB v0.10 can read and operate on files created by the previous DuckDB version – DuckDB v0.9.</p> <p>For future DuckDB versions, our goal is to ensure that any DuckDB version released <strong>after</strong> can read files created by previous versions, starting from this release. We want to ensure that the file format is fully backward compatible. This allows you to keep data stored in DuckDB files around and guarantees that you will be able to read the files without having to worry about which version the file was written with or having to convert files between versions.</p> <h3 id="forward-compatibility"> <a style="text-decoration: none;" href="#forward-compatibility">Forward Compatibility</a> </h3> <p><em>Forward compatibility</em> refers to the ability of an older DuckDB version to read storage files produced by a newer DuckDB version. DuckDB v0.9 is <a href="http://localhost:8000/2024/02/13/announcing-duckdb-0100.html#forward-compatibility"><strong>partially</strong> forward compatible with DuckDB v0.10</a>. Certain files created by DuckDB v0.10 can be read by DuckDB v0.9.</p> <p>Forward compatibility is provided on a <strong>best effort</strong> basis. While stability of the storage format is important – there are still many improvements and innovations that we want to make to the storage format in the future. As such, forward compatibility may be (partially) broken on occasion.</p> <h2 id="how-to-move-between-storage-formats"> <a style="text-decoration: none;" href="#how-to-move-between-storage-formats">How to Move Between Storage Formats</a> </h2> <p>When you update DuckDB and open an old database file, you might encounter an error message about incompatible storage formats, pointing to this page. To move your database(s) to newer format you only need the older and the newer DuckDB executable.</p> <p>Open your database file with the older DuckDB and run the SQL statement <code class="language-plaintext highlighter-rouge">EXPORT DATABASE 'tmp'</code>. This allows you to save the whole state of the current database in use inside folder <code class="language-plaintext highlighter-rouge">tmp</code>. The content of the <code class="language-plaintext highlighter-rouge">tmp</code> folder will be overridden, so choose an empty/non yet existing location. Then, start the newer DuckDB and execute <code class="language-plaintext highlighter-rouge">IMPORT DATABASE 'tmp'</code> (pointing to the previously populated folder) to load the database, which can be then saved to the file you pointed DuckDB to.</p> <p>A bash one-liner (to be adapted with the file names and executable locations) is:</p> <pre class="language-bash highlighter-rouge" data-language="bash">/older/version/duckdb mydata.db -c "EXPORT DATABASE 'tmp'" &amp;&amp; /newer/duckdb mydata.new.db -c "IMPORT DATABASE 'tmp'"</pre> <p>After this, <code class="language-plaintext highlighter-rouge">mydata.db</code> will remain in the old format, <code class="language-plaintext highlighter-rouge">mydata.new.db</code> will contain the same data but in a format accessible by the more recent DuckDB version, and the folder <code class="language-plaintext highlighter-rouge">tmp</code> will hold the same data in a universal format as different files.</p> <p>Check <a href="../sql/statements/export.html"><code class="language-plaintext highlighter-rouge">EXPORT</code> documentation</a> for more details on the syntax.</p> <h2 id="storage-header"> <a style="text-decoration: none;" href="#storage-header">Storage Header</a> </h2> <p>DuckDB files start with a <code class="language-plaintext highlighter-rouge">uint64_t</code> which contains a checksum for the main header, followed by four magic bytes (<code class="language-plaintext highlighter-rouge">DUCK</code>), followed by the storage version number in a <code class="language-plaintext highlighter-rouge">uint64_t</code>.</p> <pre class="language-bash highlighter-rouge" data-language="bash">hexdump -n 20 -C mydata.db</pre> <pre class="language-text highlighter-rouge" data-language="text">00000000  01 d0 e2 63 9c 13 39 3e  44 55 43 4b 2b 00 00 00  |...c..9&gt;DUCK+...|
00000010  00 00 00 00                                       |....|
00000014</pre> <p>A simple example of reading the storage version using Python is below.</p> <pre class="language-python highlighter-rouge" data-language="python">import struct

pattern = struct.Struct('&lt;8x4sQ')

with open('test/sql/storage_version/storage_version.db', 'rb') as fh:
    print(pattern.unpack(fh.read(pattern.size)))</pre> <h2 id="storage-version-table"> <a style="text-decoration: none;" href="#storage-version-table">Storage Version Table</a> </h2> <p>For changes in each given release, check out the <a href="https://github.com/duckdb/duckdb/releases">change log</a> on GitHub. To see the commits that changed each storage version, see the <a href="https://github.com/duckdb/duckdb/commits/main/src/storage/storage_info.cpp">commit log</a>.</p>  <table> <thead> <tr> <th style="text-align: right">Storage version</th> <th>DuckDB version(s)</th> </tr> </thead> <tbody> <tr> <td style="text-align: right">64</td> <td>v0.9.x, v0.10.x, v1.0.0, v1.1.x</td> </tr> <tr> <td style="text-align: right">51</td> <td>v0.8.x</td> </tr> <tr> <td style="text-align: right">43</td> <td>v0.7.x</td> </tr> <tr> <td style="text-align: right">39</td> <td>v0.6.x</td> </tr> <tr> <td style="text-align: right">38</td> <td>v0.5.x</td> </tr> <tr> <td style="text-align: right">33</td> <td>v0.3.3, v0.3.4, v0.4.0</td> </tr> <tr> <td style="text-align: right">31</td> <td>v0.3.2</td> </tr> <tr> <td style="text-align: right">27</td> <td>v0.3.1</td> </tr> <tr> <td style="text-align: right">25</td> <td>v0.3.0</td> </tr> <tr> <td style="text-align: right">21</td> <td>v0.2.9</td> </tr> <tr> <td style="text-align: right">18</td> <td>v0.2.8</td> </tr> <tr> <td style="text-align: right">17</td> <td>v0.2.7</td> </tr> <tr> <td style="text-align: right">15</td> <td>v0.2.6</td> </tr> <tr> <td style="text-align: right">13</td> <td>v0.2.5</td> </tr> <tr> <td style="text-align: right">11</td> <td>v0.2.4</td> </tr> <tr> <td style="text-align: right">6</td> <td>v0.2.3</td> </tr> <tr> <td style="text-align: right">4</td> <td>v0.2.2</td> </tr> <tr> <td style="text-align: right">1</td> <td>v0.2.1 and prior</td> </tr> </tbody> </table> <h2 id="compression"> <a style="text-decoration: none;" href="#compression">Compression</a> </h2> <p>DuckDB uses <a href="http://localhost:8000/2022/10/28/lightweight-compression.html">lightweight compression</a>. Note that compression is only applied to persistent databases and is <strong>not applied to in-memory instances</strong>.</p> <h3 id="compression-algorithms"> <a style="text-decoration: none;" href="#compression-algorithms">Compression Algorithms</a> </h3> <p>The compression algorithms supported by DuckDB include the following:</p> <ul> <li><a href="http://localhost:8000/2022/10/28/lightweight-compression.html#constant-encoding">Constant Encoding</a></li> <li><a href="http://localhost:8000/2022/10/28/lightweight-compression.html#run-length-encoding-rle">Run-Length Encoding (RLE)</a></li> <li><a href="http://localhost:8000/2022/10/28/lightweight-compression.html#bit-packing">Bit Packing</a></li> <li><a href="http://localhost:8000/2022/10/28/lightweight-compression.html#frame-of-reference">Frame of Reference (FOR)</a></li> <li><a href="http://localhost:8000/2022/10/28/lightweight-compression.html#dictionary-encoding">Dictionary Encoding</a></li> <li>
<a href="http://localhost:8000/2022/10/28/lightweight-compression.html#fsst">Fast Static Symbol Table (FSST)</a> – <a href="https://www.vldb.org/pvldb/vol13/p2649-boncz.pdf">VLDB 2020 paper</a>
</li> <li>
<a href="http://localhost:8000/2024/02/13/announcing-duckdb-0100.html#adaptive-lossless-floating-point-compression-alp">Adaptive Lossless Floating-Point Compression (ALP)</a> – <a href="https://ir.cwi.nl/pub/33334/33334.pdf">SIGMOD 2024 paper</a>
</li> <li>
<a href="http://localhost:8000/2022/10/28/lightweight-compression.html#chimp--patas">Chimp</a> – <a href="https://www.vldb.org/pvldb/vol15/p3058-liakos.pdf">VLDB 2022 paper</a>
</li> <li><a href="http://localhost:8000/2022/11/14/announcing-duckdb-060.html#compression-improvements">Patas</a></li> </ul> <h2 id="disk-usage"> <a style="text-decoration: none;" href="#disk-usage">Disk Usage</a> </h2> <p>The disk usage of DuckDB's format depends on a number of factors, including the data type and the data distribution, the compression methods used, etc. As a rough approximation, loading 100 GB of uncompressed CSV files into a DuckDB database file will require 25 GB of disk space, while loading 100 GB of Parquet files will require 120 GB of disk space.</p> <h2 id="row-groups"> <a style="text-decoration: none;" href="#row-groups">Row Groups</a> </h2> <p>DuckDB's storage format stores the data in <em>row groups,</em> i.e., horizontal partitions of the data. This concept is equivalent to <a href="https://parquet.apache.org/docs/concepts/">Parquet's row groups</a>. Several features in DuckDB, including <a href="../guides/performance/how_to_tune_workloads.html">parallelism</a> and <a href="http://localhost:8000/2022/10/28/lightweight-compression.html">compression</a> are based on row groups.</p> <h2 id="troubleshooting"> <a style="text-decoration: none;" href="#troubleshooting">Troubleshooting</a> </h2> <h3 id="error-message-when-opening-an-incompatible-database-file"> <a style="text-decoration: none;" href="#error-message-when-opening-an-incompatible-database-file">Error Message When Opening an Incompatible Database File</a> </h3> <p>When opening a database file that has been written by a different DuckDB version from the one you are using, the following error message may occur:</p> <pre class="language-console highlighter-rouge" data-language="console">Error: unable to open database "...": Serialization Error: Failed to deserialize: ...</pre> <p>The message implies that the database file was created with a newer DuckDB version and uses features that are backward incompatible with the DuckDB version used to read the file.</p> <p>There are two potential workarounds:</p> <ol> <li>Update your DuckDB version to the latest stable version.</li> <li>Open the database with the latest version of DuckDB, export it to a standard format (e.g., Parquet), then import it using to any version of DuckDB. See the <a href="../sql/statements/export.html"><code class="language-plaintext highlighter-rouge">EXPORT/IMPORT DATABASE</code> statements</a> for details.</li> </ol><div class="_attribution">
  <p class="_attribution-p">
    &copy; Copyright 2018&ndash;2024 Stichting DuckDB Foundation<br>Licensed under the MIT License.<br>
    <a href="https://duckdb.org/docs/internals/storage.html" class="_attribution-link">https://duckdb.org/docs/internals/storage.html</a>
  </p>
</div>
