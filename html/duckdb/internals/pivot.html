<h1 class="title">Pivot Internals</h1>  <h2 id="pivot"> <a style="text-decoration: none;" href="#pivot"><code class="language-plaintext highlighter-rouge">PIVOT</code></a> </h2> <p><a href="../sql/statements/pivot.html">Pivoting</a> is implemented as a combination of SQL query re-writing and a dedicated <code class="language-plaintext highlighter-rouge">PhysicalPivot</code> operator for higher performance. Each <code class="language-plaintext highlighter-rouge">PIVOT</code> is implemented as set of aggregations into lists and then the dedicated <code class="language-plaintext highlighter-rouge">PhysicalPivot</code> operator converts those lists into column names and values. Additional pre-processing steps are required if the columns to be created when pivoting are detected dynamically (which occurs when the <code class="language-plaintext highlighter-rouge">IN</code> clause is not in use).</p> <p>DuckDB, like most SQL engines, requires that all column names and types be known at the start of a query. In order to automatically detect the columns that should be created as a result of a <code class="language-plaintext highlighter-rouge">PIVOT</code> statement, it must be translated into multiple queries. <a href="../sql/data_types/enum.html"><code class="language-plaintext highlighter-rouge">ENUM</code> types</a> are used to find the distinct values that should become columns. Each <code class="language-plaintext highlighter-rouge">ENUM</code> is then injected into one of the <code class="language-plaintext highlighter-rouge">PIVOT</code> statement's <code class="language-plaintext highlighter-rouge">IN</code> clauses.</p> <p>After the <code class="language-plaintext highlighter-rouge">IN</code> clauses have been populated with <code class="language-plaintext highlighter-rouge">ENUM</code>s, the query is re-written again into a set of aggregations into lists.</p> <p>For example:</p> <pre class="language-sql highlighter-rouge" data-language="sql">PIVOT cities
ON year
USING sum(population);</pre> <p>is initially translated into:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TEMPORARY TYPE __pivot_enum_0_0 AS ENUM (
    SELECT DISTINCT
        year::VARCHAR
    FROM cities
    ORDER BY
        year
    );
PIVOT cities
ON year IN __pivot_enum_0_0
USING sum(population);</pre> <p>and finally translated into:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT country, name, list(year), list(population_sum)
FROM (
    SELECT country, name, year, sum(population) AS population_sum
    FROM cities
    GROUP BY ALL
)
GROUP BY ALL;</pre> <p>This produces the result:</p>  <table> <thead> <tr> <th>country</th> <th>name</th> <th>list("year")</th> <th>list(population_sum)</th> </tr> </thead> <tbody> <tr> <td>NL</td> <td>Amsterdam</td> <td>[2000, 2010, 2020]</td> <td>[1005, 1065, 1158]</td> </tr> <tr> <td>US</td> <td>Seattle</td> <td>[2000, 2010, 2020]</td> <td>[564, 608, 738]</td> </tr> <tr> <td>US</td> <td>New York City</td> <td>[2000, 2010, 2020]</td> <td>[8015, 8175, 8772]</td> </tr> </tbody> </table> <p>The <code class="language-plaintext highlighter-rouge">PhysicalPivot</code> operator converts those lists into column names and values to return this result:</p>  <table> <thead> <tr> <th>country</th> <th>name</th> <th style="text-align: right">2000</th> <th style="text-align: right">2010</th> <th style="text-align: right">2020</th> </tr> </thead> <tbody> <tr> <td>NL</td> <td>Amsterdam</td> <td style="text-align: right">1005</td> <td style="text-align: right">1065</td> <td style="text-align: right">1158</td> </tr> <tr> <td>US</td> <td>Seattle</td> <td style="text-align: right">564</td> <td style="text-align: right">608</td> <td style="text-align: right">738</td> </tr> <tr> <td>US</td> <td>New York City</td> <td style="text-align: right">8015</td> <td style="text-align: right">8175</td> <td style="text-align: right">8772</td> </tr> </tbody> </table> <h2 id="unpivot"> <a style="text-decoration: none;" href="#unpivot"><code class="language-plaintext highlighter-rouge">UNPIVOT</code></a> </h2> <h3 id="internals"> <a style="text-decoration: none;" href="#internals">Internals</a> </h3> <p>Unpivoting is implemented entirely as rewrites into SQL queries. Each <code class="language-plaintext highlighter-rouge">UNPIVOT</code> is implemented as set of <code class="language-plaintext highlighter-rouge">unnest</code> functions, operating on a list of the column names and a list of the column values. If dynamically unpivoting, the <code class="language-plaintext highlighter-rouge">COLUMNS</code> expression is evaluated first to calculate the column list.</p> <p>For example:</p> <pre class="language-sql highlighter-rouge" data-language="sql">UNPIVOT monthly_sales
ON jan, feb, mar, apr, may, jun
INTO
    NAME month
    VALUE sales;</pre> <p>is translated into:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT
    empid,
    dept,
    unnest(['jan', 'feb', 'mar', 'apr', 'may', 'jun']) AS month,
    unnest(["jan", "feb", "mar", "apr", "may", "jun"]) AS sales
FROM monthly_sales;</pre> <p>Note the single quotes to build a list of text strings to populate <code class="language-plaintext highlighter-rouge">month</code>, and the double quotes to pull the column values for use in <code class="language-plaintext highlighter-rouge">sales</code>. This produces the same result as the initial example:</p>  <table> <thead> <tr> <th style="text-align: right">empid</th> <th>dept</th> <th>month</th> <th style="text-align: right">sales</th> </tr> </thead> <tbody> <tr> <td style="text-align: right">1</td> <td>electronics</td> <td>jan</td> <td style="text-align: right">1</td> </tr> <tr> <td style="text-align: right">1</td> <td>electronics</td> <td>feb</td> <td style="text-align: right">2</td> </tr> <tr> <td style="text-align: right">1</td> <td>electronics</td> <td>mar</td> <td style="text-align: right">3</td> </tr> <tr> <td style="text-align: right">1</td> <td>electronics</td> <td>apr</td> <td style="text-align: right">4</td> </tr> <tr> <td style="text-align: right">1</td> <td>electronics</td> <td>may</td> <td style="text-align: right">5</td> </tr> <tr> <td style="text-align: right">1</td> <td>electronics</td> <td>jun</td> <td style="text-align: right">6</td> </tr> <tr> <td style="text-align: right">2</td> <td>clothes</td> <td>jan</td> <td style="text-align: right">10</td> </tr> <tr> <td style="text-align: right">2</td> <td>clothes</td> <td>feb</td> <td style="text-align: right">20</td> </tr> <tr> <td style="text-align: right">2</td> <td>clothes</td> <td>mar</td> <td style="text-align: right">30</td> </tr> <tr> <td style="text-align: right">2</td> <td>clothes</td> <td>apr</td> <td style="text-align: right">40</td> </tr> <tr> <td style="text-align: right">2</td> <td>clothes</td> <td>may</td> <td style="text-align: right">50</td> </tr> <tr> <td style="text-align: right">2</td> <td>clothes</td> <td>jun</td> <td style="text-align: right">60</td> </tr> <tr> <td style="text-align: right">3</td> <td>cars</td> <td>jan</td> <td style="text-align: right">100</td> </tr> <tr> <td style="text-align: right">3</td> <td>cars</td> <td>feb</td> <td style="text-align: right">200</td> </tr> <tr> <td style="text-align: right">3</td> <td>cars</td> <td>mar</td> <td style="text-align: right">300</td> </tr> <tr> <td style="text-align: right">3</td> <td>cars</td> <td>apr</td> <td style="text-align: right">400</td> </tr> <tr> <td style="text-align: right">3</td> <td>cars</td> <td>may</td> <td style="text-align: right">500</td> </tr> <tr> <td style="text-align: right">3</td> <td>cars</td> <td>jun</td> <td style="text-align: right">600</td> </tr> </tbody> </table><div class="_attribution">
  <p class="_attribution-p">
    &copy; Copyright 2018&ndash;2024 Stichting DuckDB Foundation<br>Licensed under the MIT License.<br>
    <a href="https://duckdb.org/docs/internals/pivot.html" class="_attribution-link">https://duckdb.org/docs/internals/pivot.html</a>
  </p>
</div>
