<h1 class="title">Overview of DuckDB Internals</h1>  <p>On this page is a brief description of the internals of the DuckDB engine.</p> <h2 id="parser"> <a style="text-decoration: none;" href="#parser">Parser</a> </h2> <p>The parser converts a query string into the following tokens:</p> <ul> <li><a href="https://github.com/duckdb/duckdb/blob/main/src/include/duckdb/parser/sql_statement.hpp"><code class="language-plaintext highlighter-rouge">SQLStatement</code></a></li> <li><a href="https://github.com/duckdb/duckdb/blob/main/src/include/duckdb/parser/query_node.hpp"><code class="language-plaintext highlighter-rouge">QueryNode</code></a></li> <li><a href="https://github.com/duckdb/duckdb/blob/main/src/include/duckdb/parser/tableref.hpp"><code class="language-plaintext highlighter-rouge">TableRef</code></a></li> <li><a href="https://github.com/duckdb/duckdb/blob/main/src/include/duckdb/parser/parsed_expression.hpp"><code class="language-plaintext highlighter-rouge">ParsedExpression</code></a></li> </ul> <p>The parser is not aware of the catalog or any other aspect of the database. It will not throw errors if tables do not exist, and will not resolve <strong>any</strong> types of columns yet. It only transforms a query string into a set of tokens as specified.</p> <h3 id="parsedexpression"> <a style="text-decoration: none;" href="#parsedexpression">ParsedExpression</a> </h3> <p>The ParsedExpression represents an expression within a SQL statement. This can be e.g., a reference to a column, an addition operator or a constant value. The type of the ParsedExpression indicates what it represents, e.g., a comparison is represented as a <a href="https://github.com/duckdb/duckdb/blob/main/src/include/duckdb/parser/expression/comparison_expression.hpp"><code class="language-plaintext highlighter-rouge">ComparisonExpression</code></a>.</p> <p>ParsedExpressions do <strong>not</strong> have types, except for nodes with explicit types such as <code class="language-plaintext highlighter-rouge">CAST</code> statements. The types for expressions are resolved in the Binder, not in the Parser.</p> <h3 id="tableref"> <a style="text-decoration: none;" href="#tableref">TableRef</a> </h3> <p>The TableRef represents any table source. This can be a reference to a base table, but it can also be a join, a table-producing function or a subquery.</p> <h3 id="querynode"> <a style="text-decoration: none;" href="#querynode">QueryNode</a> </h3> <p>The QueryNode represents either (1) a <code class="language-plaintext highlighter-rouge">SELECT</code> statement, or (2) a set operation (i.e. <code class="language-plaintext highlighter-rouge">UNION</code>, <code class="language-plaintext highlighter-rouge">INTERSECT</code> or <code class="language-plaintext highlighter-rouge">DIFFERENCE</code>).</p> <h3 id="sql-statement"> <a style="text-decoration: none;" href="#sql-statement">SQL Statement</a> </h3> <p>The SQLStatement represents a complete SQL statement. The type of the SQL Statement represents what kind of statement it is (e.g., <code class="language-plaintext highlighter-rouge">StatementType::SELECT</code> represents a <code class="language-plaintext highlighter-rouge">SELECT</code> statement). A single SQL string can be transformed into multiple SQL statements in case the original query string contains multiple queries.</p> <h2 id="binder"> <a style="text-decoration: none;" href="#binder">Binder</a> </h2> <p>The binder converts all nodes into their <strong>bound</strong> equivalents. In the binder phase:</p> <ul> <li>The tables and columns are resolved using the catalog</li> <li>Types are resolved</li> <li>Aggregate/window functions are extracted</li> </ul> <p>The following conversions happen:</p> <ul> <li>SQLStatement → <a href="https://github.com/duckdb/duckdb/blob/main/src/include/duckdb/planner/bound_statement.hpp"><code class="language-plaintext highlighter-rouge">BoundStatement</code></a>
</li> <li>QueryNode → <a href="https://github.com/duckdb/duckdb/blob/main/src/include/duckdb/planner/bound_query_node.hpp"><code class="language-plaintext highlighter-rouge">BoundQueryNode</code></a>
</li> <li>TableRef → <a href="https://github.com/duckdb/duckdb/blob/main/src/include/duckdb/planner/bound_tableref.hpp"><code class="language-plaintext highlighter-rouge">BoundTableRef</code></a>
</li> <li>ParsedExpression → <a href="https://github.com/duckdb/duckdb/blob/main/src/include/duckdb/planner/expression.hpp"><code class="language-plaintext highlighter-rouge">Expression</code></a>
</li> </ul> <h2 id="logical-planner"> <a style="text-decoration: none;" href="#logical-planner">Logical Planner</a> </h2> <p>The logical planner creates <a href="https://github.com/duckdb/duckdb/blob/main/src/include/duckdb/planner/logical_operator.hpp"><code class="language-plaintext highlighter-rouge">LogicalOperator</code></a> nodes from the bound statements. In this phase, the actual logical query tree is created.</p> <h2 id="optimizer"> <a style="text-decoration: none;" href="#optimizer">Optimizer</a> </h2> <p>After the logical planner has created the logical query tree, the optimizers are run over that query tree to create an optimized query plan. The following query optimizers are run:</p> <ul> <li>
<strong>Expression Rewriter</strong>: Simplifies expressions, performs constant folding</li> <li>
<strong>Filter Pushdown</strong>: Pushes filters down into the query plan and duplicates filters over equivalency sets. Also prunes subtrees that are guaranteed to be empty (because of filters that statically evaluate to false).</li> <li>
<strong>Join Order Optimizer</strong>: Reorders joins using dynamic programming. Specifically, the <code class="language-plaintext highlighter-rouge">DPccp</code> algorithm from the paper <a href="https://15721.courses.cs.cmu.edu/spring2017/papers/14-optimizer1/p539-moerkotte.pdf">Dynamic Programming Strikes Back</a> is used.</li> <li>
<strong>Common Sub Expressions</strong>: Extracts common subexpressions from projection and filter nodes to prevent unnecessary duplicate execution.</li> <li>
<strong>In Clause Rewriter</strong>: Rewrites large static IN clauses to a MARK join or INNER join.</li> </ul> <h2 id="column-binding-resolver"> <a style="text-decoration: none;" href="#column-binding-resolver">Column Binding Resolver</a> </h2> <p>The column binding resolver converts logical <a href="https://github.com/duckdb/duckdb/blob/main/src/include/duckdb/planner/expression/bound_columnref_expression.hpp"><code class="language-plaintext highlighter-rouge">BoundColumnRefExpresion</code></a> nodes that refer to a column of a specific table into <a href="https://github.com/duckdb/duckdb/blob/main/src/include/duckdb/planner/expression/bound_reference_expression.hpp"><code class="language-plaintext highlighter-rouge">BoundReferenceExpression</code></a> nodes that refer to a specific index into the DataChunks that are passed around in the execution engine.</p> <h2 id="physical-plan-generator"> <a style="text-decoration: none;" href="#physical-plan-generator">Physical Plan Generator</a> </h2> <p>The physical plan generator converts the resulting logical operator tree into a <a href="https://github.com/duckdb/duckdb/blob/main/src/include/duckdb/execution/physical_operator.hpp"><code class="language-plaintext highlighter-rouge">PhysicalOperator</code></a> tree.</p> <h2 id="execution"> <a style="text-decoration: none;" href="#execution">Execution</a> </h2> <p>In the execution phase, the physical operators are executed to produce the query result. DuckDB uses a push-based vectorized model, where <a href="https://github.com/duckdb/duckdb/blob/main/src/include/duckdb/common/types/data_chunk.hpp"><code class="language-plaintext highlighter-rouge">DataChunks</code></a> are pushed through the operator tree. For more information, see the talk <a href="https://www.youtube.com/watch?v=1kDrPgRUuEI">Push-Based Execution in DuckDB</a>.</p> <div> <h2 id="pages-in-this-section">Pages in This Section</h2> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; Copyright 2018&ndash;2024 Stichting DuckDB Foundation<br>Licensed under the MIT License.<br>
    <a href="https://duckdb.org/docs/internals/overview.html" class="_attribution-link">https://duckdb.org/docs/internals/overview.html</a>
  </p>
</div>
