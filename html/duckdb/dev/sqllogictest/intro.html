<h1 class="title">sqllogictest Introduction</h1>  <p>For testing plain SQL, we use an extended version of the SQL logic test suite, adopted from <a href="https://www.sqlite.org/sqllogictest/doc/trunk/about.wiki">SQLite</a>. Every test is a single self-contained file located in the <code class="language-plaintext highlighter-rouge">test/sql</code> directory. To run tests located outside of the default <code class="language-plaintext highlighter-rouge">test</code> directory, specify <code class="language-plaintext highlighter-rouge">--test-dir &lt;root_directory&gt;</code> and make sure provided test file paths are relative to that root directory.</p> <p>The test describes a series of SQL statements, together with either the expected result, a <code class="language-plaintext highlighter-rouge">statement ok</code> indicator, or a <code class="language-plaintext highlighter-rouge">statement error</code> indicator. An example of a test file is shown below:</p> <pre class="language-sql highlighter-rouge" data-language="sql"># name: test/sql/projection/test_simple_projection.test
# group [projection]

# enable query verification
statement ok
PRAGMA enable_verification

# create table
statement ok
CREATE TABLE a (i INTEGER, j INTEGER);

# insertion: 1 affected row
statement ok
INSERT INTO a VALUES (42, 84);

query II
SELECT * FROM a;
----
42	84</pre> <p>In this example, three statements are executed. The first statements are expected to succeed (prefixed by <code class="language-plaintext highlighter-rouge">statement ok</code>). The third statement is expected to return a single row with two columns (indicated by <code class="language-plaintext highlighter-rouge">query II</code>). The values of the row are expected to be <code class="language-plaintext highlighter-rouge">42</code> and <code class="language-plaintext highlighter-rouge">84</code> (separated by a tab character). For more information on query result verification, see the <a href="result_verification.html">result verification section</a>.</p> <p>The top of every file should contain a comment describing the name and group of the test. The name of the test is always the relative file path of the file. The group is the folder that the file is in. The name and group of the test are relevant because they can be used to execute <em>only</em> that test in the unittest group. For example, if we wanted to execute <em>only</em> the above test, we would run the command <code class="language-plaintext highlighter-rouge">unittest test/sql/projection/test_simple_projection.test</code>. If we wanted to run all tests in a specific directory, we would run the command <code class="language-plaintext highlighter-rouge">unittest "[projection]"</code>.</p> <p>Any tests that are placed in the <code class="language-plaintext highlighter-rouge">test</code> directory are automatically added to the test suite. Note that the extension of the test is significant. The sqllogictests should either use the <code class="language-plaintext highlighter-rouge">.test</code> extension, or the <code class="language-plaintext highlighter-rouge">.test_slow</code> extension. The <code class="language-plaintext highlighter-rouge">.test_slow</code> extension indicates that the test takes a while to run, and will only be run when all tests are explicitly run using <code class="language-plaintext highlighter-rouge">unittest *</code>. Tests with the extension <code class="language-plaintext highlighter-rouge">.test</code> will be included in the fast set of tests.</p> <h2 id="query-verification"> <a style="text-decoration: none;" href="#query-verification">Query Verification</a> </h2> <p>Many simple tests start by enabling query verification. This can be done through the following <code class="language-plaintext highlighter-rouge">PRAGMA</code> statement:</p> <pre class="language-sql highlighter-rouge" data-language="sql">statement ok
PRAGMA enable_verification</pre> <p>Query verification performs extra validation to ensure that the underlying code runs correctly. The most important part of that is that it verifies that optimizers do not cause bugs in the query. It does this by running both an unoptimized and optimized version of the query, and verifying that the results of these queries are identical.</p> <p>Query verification is very useful because it not only discovers bugs in optimizers, but also finds bugs in e.g., join implementations. This is because the unoptimized version will typically run using cross products instead. Because of this, query verification can be very slow to do when working with larger data sets. It is therefore recommended to turn on query verification for all unit tests, except those involving larger data sets (more than ~10-100 rows).</p> <h2 id="editors--syntax-highlighting"> <a style="text-decoration: none;" href="#editors--syntax-highlighting">Editors &amp; Syntax Highlighting</a> </h2> <p>The sqllogictests are not exactly an industry standard, but several other systems have adopted them as well. Parsing sqllogictests is intentionally simple. All statements have to be separated by empty lines. For that reason, writing a syntax highlighter is not extremely difficult.</p> <p>A syntax highlighter exists for <a href="https://marketplace.visualstudio.com/items?itemName=benesch.sqllogictest">Visual Studio Code</a>. We have also <a href="https://github.com/Mytherin/vscode-sqllogictest">made a fork that supports the DuckDB dialect of the sqllogictests</a>. You can use the fork by installing the original, then copying the <code class="language-plaintext highlighter-rouge">syntaxes/sqllogictest.tmLanguage.json</code> into the installed extension (on macOS this is located in <code class="language-plaintext highlighter-rouge">~/.vscode/extensions/benesch.sqllogictest-0.1.1</code>).</p> <p>A syntax highlighter is also available for <a href="https://plugins.jetbrains.com/plugin/15295-sqltest">CLion</a>. It can be installed directly on the IDE by searching SQLTest on the marketplace. A <a href="https://github.com/pdet/SQLTest">GitHub repository</a> is also available, with extensions and bug reports being welcome.</p> <h3 id="temporary-files"> <a style="text-decoration: none;" href="#temporary-files">Temporary Files</a> </h3> <p>For some tests (e.g., CSV/Parquet file format tests) it is necessary to create temporary files. Any temporary files should be created in the temporary testing directory. This directory can be used by placing the string <code class="language-plaintext highlighter-rouge">__TEST_DIR__</code> in a query. This string will be replaced by the path of the temporary testing directory.</p> <pre class="language-sql highlighter-rouge" data-language="sql">statement ok
COPY csv_data TO '__TEST_DIR__/output_file.csv.gz' (COMPRESSION GZIP);</pre> <h3 id="require--extensions"> <a style="text-decoration: none;" href="#require--extensions">Require &amp; Extensions</a> </h3> <p>To avoid bloating the core system, certain functionality of DuckDB is available only as an extension. Tests can be build for those extensions by adding a <code class="language-plaintext highlighter-rouge">require</code> field in the test. If the extension is not loaded, any statements that occurs after the require field will be skipped. Examples of this are <code class="language-plaintext highlighter-rouge">require parquet</code> or <code class="language-plaintext highlighter-rouge">require icu</code>.</p> <p>Another usage is to limit a test to a specific vector size. For example, adding <code class="language-plaintext highlighter-rouge">require vector_size 512</code> to a test will prevent the test from being run unless the vector size greater than or equal to 512. This is useful because certain functionality is not supported for low vector sizes, but we run tests using a vector size of 2 in our CI.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; Copyright 2018&ndash;2024 Stichting DuckDB Foundation<br>Licensed under the MIT License.<br>
    <a href="https://duckdb.org/docs/dev/sqllogictest/intro.html" class="_attribution-link">https://duckdb.org/docs/dev/sqllogictest/intro.html</a>
  </p>
</div>
