<h1 class="title">Writing Tests</h1>  <h2 id="development-and-testing"> <a style="text-decoration: none;" href="#development-and-testing">Development and Testing</a> </h2> <p>It is crucial that any new features that get added have correct tests that not only test the “happy path”, but also test edge cases and incorrect usage of the feature. In this section, we describe how DuckDB tests are structured and how to make new tests for DuckDB.</p> <p>The tests can be run by running the <code class="language-plaintext highlighter-rouge">unittest</code> program located in the <code class="language-plaintext highlighter-rouge">test</code> folder. For the default compilations this is located in either <code class="language-plaintext highlighter-rouge">build/release/test/unittest</code> (release) or <code class="language-plaintext highlighter-rouge">build/debug/test/unittest</code> (debug).</p> <h2 id="philosophy"> <a style="text-decoration: none;" href="#philosophy">Philosophy</a> </h2> <p>When testing DuckDB, we aim to route all the tests through SQL. We try to avoid testing components individually because that makes those components more difficult to change later on. As such, almost all of our tests can (and should) be expressed in pure SQL. There are certain exceptions to this, which we will discuss in <a href="catch.html">Catch Tests</a>. However, in most cases you should write your tests in plain SQL.</p> <h2 id="frameworks"> <a style="text-decoration: none;" href="#frameworks">Frameworks</a> </h2> <p>SQL tests should be written using the <a href="intro.html">sqllogictest framework</a>.</p> <p>C++ tests can be written using the <a href="catch.html">Catch framework</a>.</p> <h2 id="client-connector-tests"> <a style="text-decoration: none;" href="#client-connector-tests">Client Connector Tests</a> </h2> <p>DuckDB also has tests for various client connectors. These are generally written in the relevant client language, and can be found in <code class="language-plaintext highlighter-rouge">tools/*/tests</code>. They also double as documentation of what should be doable from a given client.</p> <h2 id="functions-for-generating-test-data"> <a style="text-decoration: none;" href="#functions-for-generating-test-data">Functions for Generating Test Data</a> </h2> <p>DuckDB has built-in functions for generating test data.</p> <h3 id="test_all_types-function"> <a style="text-decoration: none;" href="#test_all_types-function"><code class="language-plaintext highlighter-rouge">test_all_types</code> Function</a> </h3> <p>The <code class="language-plaintext highlighter-rouge">test_all_types</code> table function generates a table whose columns correspond to types (<code class="language-plaintext highlighter-rouge">BOOL</code>, <code class="language-plaintext highlighter-rouge">TINYINT</code>, etc.). The table has three rows encoding the minimum value, the maximum value, and the null value for each type.</p> <pre class="language-sql highlighter-rouge" data-language="sql">FROM test_all_types();</pre> <pre class="language-text highlighter-rouge" data-language="text">┌─────────┬─────────┬──────────┬─────────────┬──────────────────────┬──────────────────────┬───┬──────────────────────┬──────────────────────┬──────────────────────┬──────────────────────┬──────────────────────┐
│  bool   │ tinyint │ smallint │     int     │        bigint        │       hugeint        │ … │        struct        │   struct_of_arrays   │   array_of_structs   │         map          │        union         │
│ boolean │  int8   │  int16   │    int32    │        int64         │        int128        │   │ struct(a integer, …  │ struct(a integer[]…  │ struct(a integer, …  │ map(varchar, varch…  │ union("name" varch…  │
├─────────┼─────────┼──────────┼─────────────┼──────────────────────┼──────────────────────┼───┼──────────────────────┼──────────────────────┼──────────────────────┼──────────────────────┼──────────────────────┤
│ false   │    -128 │   -32768 │ -2147483648 │ -9223372036854775808 │  -17014118346046923… │ … │ {'a': NULL, 'b': N…  │ {'a': NULL, 'b': N…  │ []                   │ {}                   │ Frank                │
│ true    │     127 │    32767 │  2147483647 │  9223372036854775807 │  170141183460469231… │ … │ {'a': 42, 'b': 🦆…   │ {'a': [42, 999, NU…  │ [{'a': NULL, 'b': …  │ {key1=🦆🦆🦆🦆🦆🦆…  │ 5                    │
│ NULL    │    NULL │     NULL │        NULL │                 NULL │                 NULL │ … │ NULL                 │ NULL                 │ NULL                 │ NULL                 │ NULL                 │
├─────────┴─────────┴──────────┴─────────────┴──────────────────────┴──────────────────────┴───┴──────────────────────┴──────────────────────┴──────────────────────┴──────────────────────┴──────────────────────┤
│ 3 rows                                                                                                                                                                                    44 columns (11 shown) │
└─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘</pre> <h3 id="test_vector_types-function"> <a style="text-decoration: none;" href="#test_vector_types-function"><code class="language-plaintext highlighter-rouge">test_vector_types</code> Function</a> </h3> <p>The <code class="language-plaintext highlighter-rouge">test_vector_types</code> table function takes <em>n</em> arguments <code class="language-plaintext highlighter-rouge">col1</code>, …, <code class="language-plaintext highlighter-rouge">coln</code> and an optional <code class="language-plaintext highlighter-rouge">BOOLEAN</code> argument <code class="language-plaintext highlighter-rouge">all_flat</code>. The function generates a table with <em>n</em> columns <code class="language-plaintext highlighter-rouge">test_vector</code>, <code class="language-plaintext highlighter-rouge">test_vector2</code>, …, <code class="language-plaintext highlighter-rouge">test_vectorn</code>. In each row, each field contains values conforming to the type of their respective column.</p> <pre class="language-sql highlighter-rouge" data-language="sql">FROM test_vector_types(NULL::BIGINT);</pre> <pre class="language-text highlighter-rouge" data-language="text">┌──────────────────────┐
│     test_vector      │
│        int64         │
├──────────────────────┤
│ -9223372036854775808 │
│  9223372036854775807 │
│                 NULL │
│         ...          │
└──────────────────────┘</pre> <pre class="language-sql highlighter-rouge" data-language="sql">FROM test_vector_types(NULL::ROW(i INTEGER, j VARCHAR, k DOUBLE), NULL::TIMESTAMP);</pre> <pre class="language-text highlighter-rouge" data-language="text">┌──────────────────────────────────────────────────────────────────────┬──────────────────────────────┐
│                             test_vector                              │         test_vector2         │
│                struct(i integer, j varchar, k double)                │          timestamp           │
├──────────────────────────────────────────────────────────────────────┼──────────────────────────────┤
│ {'i': -2147483648, 'j': 🦆🦆🦆🦆🦆🦆, 'k': -1.7976931348623157e+308}   │ 290309-12-22 (BC) 00:00:00   │
│ {'i': 2147483647, 'j': goo\0se, 'k': 1.7976931348623157e+308}        │ 294247-01-10 04:00:54.775806 │
│ {'i': NULL, 'j': NULL, 'k': NULL}                                    │ NULL                         │
│                                                  ...                                                │
└─────────────────────────────────────────────────────────────────────────────────────────────────────┘</pre> <p><code class="language-plaintext highlighter-rouge">test_vector_types</code> has an optional argument called <code class="language-plaintext highlighter-rouge">all_flat</code> of type <code class="language-plaintext highlighter-rouge">BOOL</code>. This only affects the internal representation of the vector.</p> <pre class="language-sql highlighter-rouge" data-language="sql">FROM test_vector_types(NULL::ROW(i INTEGER, j VARCHAR, k DOUBLE), NULL::TIMESTAMP, all_flat = true);
-- the output is the same as above but with a different internal representation</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; Copyright 2018&ndash;2024 Stichting DuckDB Foundation<br>Licensed under the MIT License.<br>
    <a href="https://duckdb.org/docs/dev/sqllogictest/writing_tests.html" class="_attribution-link">https://duckdb.org/docs/dev/sqllogictest/writing_tests.html</a>
  </p>
</div>
