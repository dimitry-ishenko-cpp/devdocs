<h1 class="title">Types</h1>  <p>DuckDB is a strongly typed database system. As such, every column has a single type specified. This type is constant over the entire column. That is to say, a column that is labeled as an <code class="language-plaintext highlighter-rouge">INTEGER</code> column will only contain <code class="language-plaintext highlighter-rouge">INTEGER</code> values.</p> <p>DuckDB also supports columns of composite types. For example, it is possible to define an array of integers (<code class="language-plaintext highlighter-rouge">INTEGER[]</code>). It is also possible to define types as arbitrary structs (<code class="language-plaintext highlighter-rouge">ROW(i INTEGER, j VARCHAR)</code>). For that reason, native DuckDB type objects are not mere enums, but a class that can potentially be nested.</p> <p>Types in the C API are modeled using an enum (<code class="language-plaintext highlighter-rouge">duckdb_type</code>) and a complex class (<code class="language-plaintext highlighter-rouge">duckdb_logical_type</code>). For most primitive types, e.g., integers or varchars, the enum is sufficient. For more complex types, such as lists, structs or decimals, the logical type must be used.</p> <pre class="language-c highlighter-rouge" data-language="c">typedef enum DUCKDB_TYPE {
  DUCKDB_TYPE_INVALID = 0,
  DUCKDB_TYPE_BOOLEAN = 1,
  DUCKDB_TYPE_TINYINT = 2,
  DUCKDB_TYPE_SMALLINT = 3,
  DUCKDB_TYPE_INTEGER = 4,
  DUCKDB_TYPE_BIGINT = 5,
  DUCKDB_TYPE_UTINYINT = 6,
  DUCKDB_TYPE_USMALLINT = 7,
  DUCKDB_TYPE_UINTEGER = 8,
  DUCKDB_TYPE_UBIGINT = 9,
  DUCKDB_TYPE_FLOAT = 10,
  DUCKDB_TYPE_DOUBLE = 11,
  DUCKDB_TYPE_TIMESTAMP = 12,
  DUCKDB_TYPE_DATE = 13,
  DUCKDB_TYPE_TIME = 14,
  DUCKDB_TYPE_INTERVAL = 15,
  DUCKDB_TYPE_HUGEINT = 16,
  DUCKDB_TYPE_UHUGEINT = 32,
  DUCKDB_TYPE_VARCHAR = 17,
  DUCKDB_TYPE_BLOB = 18,
  DUCKDB_TYPE_DECIMAL = 19,
  DUCKDB_TYPE_TIMESTAMP_S = 20,
  DUCKDB_TYPE_TIMESTAMP_MS = 21,
  DUCKDB_TYPE_TIMESTAMP_NS = 22,
  DUCKDB_TYPE_ENUM = 23,
  DUCKDB_TYPE_LIST = 24,
  DUCKDB_TYPE_STRUCT = 25,
  DUCKDB_TYPE_MAP = 26,
  DUCKDB_TYPE_ARRAY = 33,
  DUCKDB_TYPE_UUID = 27,
  DUCKDB_TYPE_UNION = 28,
  DUCKDB_TYPE_BIT = 29,
  DUCKDB_TYPE_TIME_TZ = 30,
  DUCKDB_TYPE_TIMESTAMP_TZ = 31,
} duckdb_type;</pre> <h2 id="functions"> <a style="text-decoration: none;" href="#functions">Functions</a> </h2> <p>The enum type of a column in the result can be obtained using the <code class="language-plaintext highlighter-rouge">duckdb_column_type</code> function. The logical type of a column can be obtained using the <code class="language-plaintext highlighter-rouge">duckdb_column_logical_type</code> function.</p> <h3 id="duckdb_value"> <a style="text-decoration: none;" href="#duckdb_value"><code class="language-plaintext highlighter-rouge">duckdb_value</code></a> </h3> <p>The <code class="language-plaintext highlighter-rouge">duckdb_value</code> functions will auto-cast values as required. For example, it is no problem to use <code class="language-plaintext highlighter-rouge">duckdb_value_double</code> on a column of type <code class="language-plaintext highlighter-rouge">duckdb_value_int32</code>. The value will be auto-cast and returned as a double. Note that in certain cases the cast may fail. For example, this can happen if we request a <code class="language-plaintext highlighter-rouge">duckdb_value_int8</code> and the value does not fit within an <code class="language-plaintext highlighter-rouge">int8</code> value. In this case, a default value will be returned (usually <code class="language-plaintext highlighter-rouge">0</code> or <code class="language-plaintext highlighter-rouge">nullptr</code>). The same default value will also be returned if the corresponding value is <code class="language-plaintext highlighter-rouge">NULL</code>.</p> <p>The <code class="language-plaintext highlighter-rouge">duckdb_value_is_null</code> function can be used to check if a specific value is <code class="language-plaintext highlighter-rouge">NULL</code> or not.</p> <p>The exception to the auto-cast rule is the <code class="language-plaintext highlighter-rouge">duckdb_value_varchar_internal</code> function. This function does not auto-cast and only works for <code class="language-plaintext highlighter-rouge">VARCHAR</code> columns. The reason this function exists is that the result does not need to be freed.</p> <blockquote> <p><code class="language-plaintext highlighter-rouge">duckdb_value_varchar</code> and <code class="language-plaintext highlighter-rouge">duckdb_value_blob</code> require the result to be de-allocated using <code class="language-plaintext highlighter-rouge">duckdb_free</code>.</p> </blockquote> <h3 id="duckdb_fetch_chunk"> <a style="text-decoration: none;" href="#duckdb_fetch_chunk"><code class="language-plaintext highlighter-rouge">duckdb_fetch_chunk</code></a> </h3> <p>The <code class="language-plaintext highlighter-rouge">duckdb_fetch_chunk</code> function can be used to read data chunks from a DuckDB result set, and is the most efficient way of reading data from a DuckDB result using the C API. It is also the only way of reading data of certain types from a DuckDB result. For example, the <code class="language-plaintext highlighter-rouge">duckdb_value</code> functions do not support structural reading of composite types (lists or structs) or more complex types like enums and decimals.</p> <p>For more information about data chunks, see the <a href="data_chunk.html">documentation on data chunks</a>.</p> <h2 id="api-reference-overview"> <a style="text-decoration: none;" href="#api-reference-overview">API Reference Overview</a> </h2>  <pre class="language-c highlighter-rouge" data-language="c">duckdb_data_chunk duckdb_result_get_chunk(duckdb_result result, idx_t chunk_index);
bool duckdb_result_is_streaming(duckdb_result result);
idx_t duckdb_result_chunk_count(duckdb_result result);
duckdb_result_type duckdb_result_return_type(duckdb_result result);</pre> <h3 id="date-time-timestamp-helpers"> <a style="text-decoration: none;" href="#date-time-timestamp-helpers">Date Time Timestamp Helpers</a> </h3> <pre class="language-c highlighter-rouge" data-language="c">duckdb_date_struct duckdb_from_date(duckdb_date date);
duckdb_date duckdb_to_date(duckdb_date_struct date);
bool duckdb_is_finite_date(duckdb_date date);
duckdb_time_struct duckdb_from_time(duckdb_time time);
duckdb_time_tz duckdb_create_time_tz(int64_t micros, int32_t offset);
duckdb_time_tz_struct duckdb_from_time_tz(duckdb_time_tz micros);
duckdb_time duckdb_to_time(duckdb_time_struct time);
duckdb_timestamp_struct duckdb_from_timestamp(duckdb_timestamp ts);
duckdb_timestamp duckdb_to_timestamp(duckdb_timestamp_struct ts);
bool duckdb_is_finite_timestamp(duckdb_timestamp ts);</pre> <h3 id="hugeint-helpers"> <a style="text-decoration: none;" href="#hugeint-helpers">Hugeint Helpers</a> </h3> <pre class="language-c highlighter-rouge" data-language="c">double duckdb_hugeint_to_double(duckdb_hugeint val);
duckdb_hugeint duckdb_double_to_hugeint(double val);</pre> <h3 id="decimal-helpers"> <a style="text-decoration: none;" href="#decimal-helpers">Decimal Helpers</a> </h3> <pre class="language-c highlighter-rouge" data-language="c">duckdb_decimal duckdb_double_to_decimal(double val, uint8_t width, uint8_t scale);
double duckdb_decimal_to_double(duckdb_decimal val);</pre> <h3 id="logical-type-interface"> <a style="text-decoration: none;" href="#logical-type-interface">Logical Type Interface</a> </h3> <pre class="language-c highlighter-rouge" data-language="c">duckdb_logical_type duckdb_create_logical_type(duckdb_type type);
char *duckdb_logical_type_get_alias(duckdb_logical_type type);
void duckdb_logical_type_set_alias(duckdb_logical_type type, const char *alias);
duckdb_logical_type duckdb_create_list_type(duckdb_logical_type type);
duckdb_logical_type duckdb_create_array_type(duckdb_logical_type type, idx_t array_size);
duckdb_logical_type duckdb_create_map_type(duckdb_logical_type key_type, duckdb_logical_type value_type);
duckdb_logical_type duckdb_create_union_type(duckdb_logical_type *member_types, const char **member_names, idx_t member_count);
duckdb_logical_type duckdb_create_struct_type(duckdb_logical_type *member_types, const char **member_names, idx_t member_count);
duckdb_logical_type duckdb_create_enum_type(const char **member_names, idx_t member_count);
duckdb_logical_type duckdb_create_decimal_type(uint8_t width, uint8_t scale);
duckdb_type duckdb_get_type_id(duckdb_logical_type type);
uint8_t duckdb_decimal_width(duckdb_logical_type type);
uint8_t duckdb_decimal_scale(duckdb_logical_type type);
duckdb_type duckdb_decimal_internal_type(duckdb_logical_type type);
duckdb_type duckdb_enum_internal_type(duckdb_logical_type type);
uint32_t duckdb_enum_dictionary_size(duckdb_logical_type type);
char *duckdb_enum_dictionary_value(duckdb_logical_type type, idx_t index);
duckdb_logical_type duckdb_list_type_child_type(duckdb_logical_type type);
duckdb_logical_type duckdb_array_type_child_type(duckdb_logical_type type);
idx_t duckdb_array_type_array_size(duckdb_logical_type type);
duckdb_logical_type duckdb_map_type_key_type(duckdb_logical_type type);
duckdb_logical_type duckdb_map_type_value_type(duckdb_logical_type type);
idx_t duckdb_struct_type_child_count(duckdb_logical_type type);
char *duckdb_struct_type_child_name(duckdb_logical_type type, idx_t index);
duckdb_logical_type duckdb_struct_type_child_type(duckdb_logical_type type, idx_t index);
idx_t duckdb_union_type_member_count(duckdb_logical_type type);
char *duckdb_union_type_member_name(duckdb_logical_type type, idx_t index);
duckdb_logical_type duckdb_union_type_member_type(duckdb_logical_type type, idx_t index);
void duckdb_destroy_logical_type(duckdb_logical_type *type);
duckdb_state duckdb_register_logical_type(duckdb_connection con, duckdb_logical_type type, duckdb_create_type_info info);</pre> <h4 id="duckdb_result_get_chunk"> <a style="text-decoration: none;" href="#duckdb_result_get_chunk"><code class="language-plaintext highlighter-rouge">duckdb_result_get_chunk</code></a> </h4> <blockquote> <p>Warning Deprecation notice. This method is scheduled for removal in a future release.</p> </blockquote> <p>Fetches a data chunk from the duckdb_result. This function should be called repeatedly until the result is exhausted.</p> <p>The result must be destroyed with <code class="language-plaintext highlighter-rouge">duckdb_destroy_data_chunk</code>.</p> <p>This function supersedes all <code class="language-plaintext highlighter-rouge">duckdb_value</code> functions, as well as the <code class="language-plaintext highlighter-rouge">duckdb_column_data</code> and <code class="language-plaintext highlighter-rouge">duckdb_nullmask_data</code> functions. It results in significantly better performance, and should be preferred in newer code-bases.</p> <p>If this function is used, none of the other result functions can be used and vice versa (i.e., this function cannot be mixed with the legacy result functions).</p> <p>Use <code class="language-plaintext highlighter-rouge">duckdb_result_chunk_count</code> to figure out how many chunks there are in the result.</p> <h5 id="syntax"> <a style="text-decoration: none;" href="#syntax">Syntax</a> </h5> <pre class="language-c highlighter-rouge" data-language="c">duckdb_data_chunk duckdb_result_get_chunk(
  duckdb_result result,
  idx_t chunk_index
);</pre> <h5 id="parameters"> <a style="text-decoration: none;" href="#parameters">Parameters</a> </h5> <ul> <li>
<code class="language-plaintext highlighter-rouge">result</code>: The result object to fetch the data chunk from.</li> <li>
<code class="language-plaintext highlighter-rouge">chunk_index</code>: The chunk index to fetch from.</li> </ul> <h5 id="return-value"> <a style="text-decoration: none;" href="#return-value">Return Value</a> </h5> <p>The resulting data chunk. Returns <code class="language-plaintext highlighter-rouge">NULL</code> if the chunk index is out of bounds.</p> <p><br></p> <h4 id="duckdb_result_is_streaming"> <a style="text-decoration: none;" href="#duckdb_result_is_streaming"><code class="language-plaintext highlighter-rouge">duckdb_result_is_streaming</code></a> </h4> <blockquote> <p>Warning Deprecation notice. This method is scheduled for removal in a future release.</p> </blockquote> <p>Checks if the type of the internal result is StreamQueryResult.</p> <h5 id="syntax-1"> <a style="text-decoration: none;" href="#syntax-1">Syntax</a> </h5> <pre class="language-c highlighter-rouge" data-language="c">bool duckdb_result_is_streaming(
  duckdb_result result
);</pre> <h5 id="parameters-1"> <a style="text-decoration: none;" href="#parameters-1">Parameters</a> </h5> <ul> <li>
<code class="language-plaintext highlighter-rouge">result</code>: The result object to check.</li> </ul> <h5 id="return-value-1"> <a style="text-decoration: none;" href="#return-value-1">Return Value</a> </h5> <p>Whether or not the result object is of the type StreamQueryResult</p> <p><br></p> <h4 id="duckdb_result_chunk_count"> <a style="text-decoration: none;" href="#duckdb_result_chunk_count"><code class="language-plaintext highlighter-rouge">duckdb_result_chunk_count</code></a> </h4> <blockquote> <p>Warning Deprecation notice. This method is scheduled for removal in a future release.</p> </blockquote> <p>Returns the number of data chunks present in the result.</p> <h5 id="syntax-2"> <a style="text-decoration: none;" href="#syntax-2">Syntax</a> </h5> <pre class="language-c highlighter-rouge" data-language="c">idx_t duckdb_result_chunk_count(
  duckdb_result result
);</pre> <h5 id="parameters-2"> <a style="text-decoration: none;" href="#parameters-2">Parameters</a> </h5> <ul> <li>
<code class="language-plaintext highlighter-rouge">result</code>: The result object</li> </ul> <h5 id="return-value-2"> <a style="text-decoration: none;" href="#return-value-2">Return Value</a> </h5> <p>Number of data chunks present in the result.</p> <p><br></p> <h4 id="duckdb_result_return_type"> <a style="text-decoration: none;" href="#duckdb_result_return_type"><code class="language-plaintext highlighter-rouge">duckdb_result_return_type</code></a> </h4> <p>Returns the return_type of the given result, or DUCKDB_RETURN_TYPE_INVALID on error</p> <h5 id="syntax-3"> <a style="text-decoration: none;" href="#syntax-3">Syntax</a> </h5> <pre class="language-c highlighter-rouge" data-language="c">duckdb_result_type duckdb_result_return_type(
  duckdb_result result
);</pre> <h5 id="parameters-3"> <a style="text-decoration: none;" href="#parameters-3">Parameters</a> </h5> <ul> <li>
<code class="language-plaintext highlighter-rouge">result</code>: The result object</li> </ul> <h5 id="return-value-3"> <a style="text-decoration: none;" href="#return-value-3">Return Value</a> </h5> <p>The return_type</p> <p><br></p> <h4 id="duckdb_from_date"> <a style="text-decoration: none;" href="#duckdb_from_date"><code class="language-plaintext highlighter-rouge">duckdb_from_date</code></a> </h4> <p>Decompose a <code class="language-plaintext highlighter-rouge">duckdb_date</code> object into year, month and date (stored as <code class="language-plaintext highlighter-rouge">duckdb_date_struct</code>).</p> <h5 id="syntax-4"> <a style="text-decoration: none;" href="#syntax-4">Syntax</a> </h5> <pre class="language-c highlighter-rouge" data-language="c">duckdb_date_struct duckdb_from_date(
  duckdb_date date
);</pre> <h5 id="parameters-4"> <a style="text-decoration: none;" href="#parameters-4">Parameters</a> </h5> <ul> <li>
<code class="language-plaintext highlighter-rouge">date</code>: The date object, as obtained from a <code class="language-plaintext highlighter-rouge">DUCKDB_TYPE_DATE</code> column.</li> </ul> <h5 id="return-value-4"> <a style="text-decoration: none;" href="#return-value-4">Return Value</a> </h5> <p>The <code class="language-plaintext highlighter-rouge">duckdb_date_struct</code> with the decomposed elements.</p> <p><br></p> <h4 id="duckdb_to_date"> <a style="text-decoration: none;" href="#duckdb_to_date"><code class="language-plaintext highlighter-rouge">duckdb_to_date</code></a> </h4> <p>Re-compose a <code class="language-plaintext highlighter-rouge">duckdb_date</code> from year, month and date (<code class="language-plaintext highlighter-rouge">duckdb_date_struct</code>).</p> <h5 id="syntax-5"> <a style="text-decoration: none;" href="#syntax-5">Syntax</a> </h5> <pre class="language-c highlighter-rouge" data-language="c">duckdb_date duckdb_to_date(
  duckdb_date_struct date
);</pre> <h5 id="parameters-5"> <a style="text-decoration: none;" href="#parameters-5">Parameters</a> </h5> <ul> <li>
<code class="language-plaintext highlighter-rouge">date</code>: The year, month and date stored in a <code class="language-plaintext highlighter-rouge">duckdb_date_struct</code>.</li> </ul> <h5 id="return-value-5"> <a style="text-decoration: none;" href="#return-value-5">Return Value</a> </h5> <p>The <code class="language-plaintext highlighter-rouge">duckdb_date</code> element.</p> <p><br></p> <h4 id="duckdb_is_finite_date"> <a style="text-decoration: none;" href="#duckdb_is_finite_date"><code class="language-plaintext highlighter-rouge">duckdb_is_finite_date</code></a> </h4> <p>Test a <code class="language-plaintext highlighter-rouge">duckdb_date</code> to see if it is a finite value.</p> <h5 id="syntax-6"> <a style="text-decoration: none;" href="#syntax-6">Syntax</a> </h5> <pre class="language-c highlighter-rouge" data-language="c">bool duckdb_is_finite_date(
  duckdb_date date
);</pre> <h5 id="parameters-6"> <a style="text-decoration: none;" href="#parameters-6">Parameters</a> </h5> <ul> <li>
<code class="language-plaintext highlighter-rouge">date</code>: The date object, as obtained from a <code class="language-plaintext highlighter-rouge">DUCKDB_TYPE_DATE</code> column.</li> </ul> <h5 id="return-value-6"> <a style="text-decoration: none;" href="#return-value-6">Return Value</a> </h5> <p>True if the date is finite, false if it is ±infinity.</p> <p><br></p> <h4 id="duckdb_from_time"> <a style="text-decoration: none;" href="#duckdb_from_time"><code class="language-plaintext highlighter-rouge">duckdb_from_time</code></a> </h4> <p>Decompose a <code class="language-plaintext highlighter-rouge">duckdb_time</code> object into hour, minute, second and microsecond (stored as <code class="language-plaintext highlighter-rouge">duckdb_time_struct</code>).</p> <h5 id="syntax-7"> <a style="text-decoration: none;" href="#syntax-7">Syntax</a> </h5> <pre class="language-c highlighter-rouge" data-language="c">duckdb_time_struct duckdb_from_time(
  duckdb_time time
);</pre> <h5 id="parameters-7"> <a style="text-decoration: none;" href="#parameters-7">Parameters</a> </h5> <ul> <li>
<code class="language-plaintext highlighter-rouge">time</code>: The time object, as obtained from a <code class="language-plaintext highlighter-rouge">DUCKDB_TYPE_TIME</code> column.</li> </ul> <h5 id="return-value-7"> <a style="text-decoration: none;" href="#return-value-7">Return Value</a> </h5> <p>The <code class="language-plaintext highlighter-rouge">duckdb_time_struct</code> with the decomposed elements.</p> <p><br></p> <h4 id="duckdb_create_time_tz"> <a style="text-decoration: none;" href="#duckdb_create_time_tz"><code class="language-plaintext highlighter-rouge">duckdb_create_time_tz</code></a> </h4> <p>Create a <code class="language-plaintext highlighter-rouge">duckdb_time_tz</code> object from micros and a timezone offset.</p> <h5 id="syntax-8"> <a style="text-decoration: none;" href="#syntax-8">Syntax</a> </h5> <pre class="language-c highlighter-rouge" data-language="c">duckdb_time_tz duckdb_create_time_tz(
  int64_t micros,
  int32_t offset
);</pre> <h5 id="parameters-8"> <a style="text-decoration: none;" href="#parameters-8">Parameters</a> </h5> <ul> <li>
<code class="language-plaintext highlighter-rouge">micros</code>: The microsecond component of the time.</li> <li>
<code class="language-plaintext highlighter-rouge">offset</code>: The timezone offset component of the time.</li> </ul> <h5 id="return-value-8"> <a style="text-decoration: none;" href="#return-value-8">Return Value</a> </h5> <p>The <code class="language-plaintext highlighter-rouge">duckdb_time_tz</code> element.</p> <p><br></p> <h4 id="duckdb_from_time_tz"> <a style="text-decoration: none;" href="#duckdb_from_time_tz"><code class="language-plaintext highlighter-rouge">duckdb_from_time_tz</code></a> </h4> <p>Decompose a TIME_TZ objects into micros and a timezone offset.</p> <p>Use <code class="language-plaintext highlighter-rouge">duckdb_from_time</code> to further decompose the micros into hour, minute, second and microsecond.</p> <h5 id="syntax-9"> <a style="text-decoration: none;" href="#syntax-9">Syntax</a> </h5> <pre class="language-c highlighter-rouge" data-language="c">duckdb_time_tz_struct duckdb_from_time_tz(
  duckdb_time_tz micros
);</pre> <h5 id="parameters-9"> <a style="text-decoration: none;" href="#parameters-9">Parameters</a> </h5> <ul> <li>
<code class="language-plaintext highlighter-rouge">micros</code>: The time object, as obtained from a <code class="language-plaintext highlighter-rouge">DUCKDB_TYPE_TIME_TZ</code> column.</li> </ul> <p><br></p> <h4 id="duckdb_to_time"> <a style="text-decoration: none;" href="#duckdb_to_time"><code class="language-plaintext highlighter-rouge">duckdb_to_time</code></a> </h4> <p>Re-compose a <code class="language-plaintext highlighter-rouge">duckdb_time</code> from hour, minute, second and microsecond (<code class="language-plaintext highlighter-rouge">duckdb_time_struct</code>).</p> <h5 id="syntax-10"> <a style="text-decoration: none;" href="#syntax-10">Syntax</a> </h5> <pre class="language-c highlighter-rouge" data-language="c">duckdb_time duckdb_to_time(
  duckdb_time_struct time
);</pre> <h5 id="parameters-10"> <a style="text-decoration: none;" href="#parameters-10">Parameters</a> </h5> <ul> <li>
<code class="language-plaintext highlighter-rouge">time</code>: The hour, minute, second and microsecond in a <code class="language-plaintext highlighter-rouge">duckdb_time_struct</code>.</li> </ul> <h5 id="return-value-9"> <a style="text-decoration: none;" href="#return-value-9">Return Value</a> </h5> <p>The <code class="language-plaintext highlighter-rouge">duckdb_time</code> element.</p> <p><br></p> <h4 id="duckdb_from_timestamp"> <a style="text-decoration: none;" href="#duckdb_from_timestamp"><code class="language-plaintext highlighter-rouge">duckdb_from_timestamp</code></a> </h4> <p>Decompose a <code class="language-plaintext highlighter-rouge">duckdb_timestamp</code> object into a <code class="language-plaintext highlighter-rouge">duckdb_timestamp_struct</code>.</p> <h5 id="syntax-11"> <a style="text-decoration: none;" href="#syntax-11">Syntax</a> </h5> <pre class="language-c highlighter-rouge" data-language="c">duckdb_timestamp_struct duckdb_from_timestamp(
  duckdb_timestamp ts
);</pre> <h5 id="parameters-11"> <a style="text-decoration: none;" href="#parameters-11">Parameters</a> </h5> <ul> <li>
<code class="language-plaintext highlighter-rouge">ts</code>: The ts object, as obtained from a <code class="language-plaintext highlighter-rouge">DUCKDB_TYPE_TIMESTAMP</code> column.</li> </ul> <h5 id="return-value-10"> <a style="text-decoration: none;" href="#return-value-10">Return Value</a> </h5> <p>The <code class="language-plaintext highlighter-rouge">duckdb_timestamp_struct</code> with the decomposed elements.</p> <p><br></p> <h4 id="duckdb_to_timestamp"> <a style="text-decoration: none;" href="#duckdb_to_timestamp"><code class="language-plaintext highlighter-rouge">duckdb_to_timestamp</code></a> </h4> <p>Re-compose a <code class="language-plaintext highlighter-rouge">duckdb_timestamp</code> from a duckdb_timestamp_struct.</p> <h5 id="syntax-12"> <a style="text-decoration: none;" href="#syntax-12">Syntax</a> </h5> <pre class="language-c highlighter-rouge" data-language="c">duckdb_timestamp duckdb_to_timestamp(
  duckdb_timestamp_struct ts
);</pre> <h5 id="parameters-12"> <a style="text-decoration: none;" href="#parameters-12">Parameters</a> </h5> <ul> <li>
<code class="language-plaintext highlighter-rouge">ts</code>: The de-composed elements in a <code class="language-plaintext highlighter-rouge">duckdb_timestamp_struct</code>.</li> </ul> <h5 id="return-value-11"> <a style="text-decoration: none;" href="#return-value-11">Return Value</a> </h5> <p>The <code class="language-plaintext highlighter-rouge">duckdb_timestamp</code> element.</p> <p><br></p> <h4 id="duckdb_is_finite_timestamp"> <a style="text-decoration: none;" href="#duckdb_is_finite_timestamp"><code class="language-plaintext highlighter-rouge">duckdb_is_finite_timestamp</code></a> </h4> <p>Test a <code class="language-plaintext highlighter-rouge">duckdb_timestamp</code> to see if it is a finite value.</p> <h5 id="syntax-13"> <a style="text-decoration: none;" href="#syntax-13">Syntax</a> </h5> <pre class="language-c highlighter-rouge" data-language="c">bool duckdb_is_finite_timestamp(
  duckdb_timestamp ts
);</pre> <h5 id="parameters-13"> <a style="text-decoration: none;" href="#parameters-13">Parameters</a> </h5> <ul> <li>
<code class="language-plaintext highlighter-rouge">ts</code>: The timestamp object, as obtained from a <code class="language-plaintext highlighter-rouge">DUCKDB_TYPE_TIMESTAMP</code> column.</li> </ul> <h5 id="return-value-12"> <a style="text-decoration: none;" href="#return-value-12">Return Value</a> </h5> <p>True if the timestamp is finite, false if it is ±infinity.</p> <p><br></p> <h4 id="duckdb_hugeint_to_double"> <a style="text-decoration: none;" href="#duckdb_hugeint_to_double"><code class="language-plaintext highlighter-rouge">duckdb_hugeint_to_double</code></a> </h4> <p>Converts a duckdb_hugeint object (as obtained from a <code class="language-plaintext highlighter-rouge">DUCKDB_TYPE_HUGEINT</code> column) into a double.</p> <h5 id="syntax-14"> <a style="text-decoration: none;" href="#syntax-14">Syntax</a> </h5> <pre class="language-c highlighter-rouge" data-language="c">double duckdb_hugeint_to_double(
  duckdb_hugeint val
);</pre> <h5 id="parameters-14"> <a style="text-decoration: none;" href="#parameters-14">Parameters</a> </h5> <ul> <li>
<code class="language-plaintext highlighter-rouge">val</code>: The hugeint value.</li> </ul> <h5 id="return-value-13"> <a style="text-decoration: none;" href="#return-value-13">Return Value</a> </h5> <p>The converted <code class="language-plaintext highlighter-rouge">double</code> element.</p> <p><br></p> <h4 id="duckdb_double_to_hugeint"> <a style="text-decoration: none;" href="#duckdb_double_to_hugeint"><code class="language-plaintext highlighter-rouge">duckdb_double_to_hugeint</code></a> </h4> <p>Converts a double value to a duckdb_hugeint object.</p> <p>If the conversion fails because the double value is too big the result will be 0.</p> <h5 id="syntax-15"> <a style="text-decoration: none;" href="#syntax-15">Syntax</a> </h5> <pre class="language-c highlighter-rouge" data-language="c">duckdb_hugeint duckdb_double_to_hugeint(
  double val
);</pre> <h5 id="parameters-15"> <a style="text-decoration: none;" href="#parameters-15">Parameters</a> </h5> <ul> <li>
<code class="language-plaintext highlighter-rouge">val</code>: The double value.</li> </ul> <h5 id="return-value-14"> <a style="text-decoration: none;" href="#return-value-14">Return Value</a> </h5> <p>The converted <code class="language-plaintext highlighter-rouge">duckdb_hugeint</code> element.</p> <p><br></p> <h4 id="duckdb_double_to_decimal"> <a style="text-decoration: none;" href="#duckdb_double_to_decimal"><code class="language-plaintext highlighter-rouge">duckdb_double_to_decimal</code></a> </h4> <p>Converts a double value to a duckdb_decimal object.</p> <p>If the conversion fails because the double value is too big, or the width/scale are invalid the result will be 0.</p> <h5 id="syntax-16"> <a style="text-decoration: none;" href="#syntax-16">Syntax</a> </h5> <pre class="language-c highlighter-rouge" data-language="c">duckdb_decimal duckdb_double_to_decimal(
  double val,
  uint8_t width,
  uint8_t scale
);</pre> <h5 id="parameters-16"> <a style="text-decoration: none;" href="#parameters-16">Parameters</a> </h5> <ul> <li>
<code class="language-plaintext highlighter-rouge">val</code>: The double value.</li> </ul> <h5 id="return-value-15"> <a style="text-decoration: none;" href="#return-value-15">Return Value</a> </h5> <p>The converted <code class="language-plaintext highlighter-rouge">duckdb_decimal</code> element.</p> <p><br></p> <h4 id="duckdb_decimal_to_double"> <a style="text-decoration: none;" href="#duckdb_decimal_to_double"><code class="language-plaintext highlighter-rouge">duckdb_decimal_to_double</code></a> </h4> <p>Converts a duckdb_decimal object (as obtained from a <code class="language-plaintext highlighter-rouge">DUCKDB_TYPE_DECIMAL</code> column) into a double.</p> <h5 id="syntax-17"> <a style="text-decoration: none;" href="#syntax-17">Syntax</a> </h5> <pre class="language-c highlighter-rouge" data-language="c">double duckdb_decimal_to_double(
  duckdb_decimal val
);</pre> <h5 id="parameters-17"> <a style="text-decoration: none;" href="#parameters-17">Parameters</a> </h5> <ul> <li>
<code class="language-plaintext highlighter-rouge">val</code>: The decimal value.</li> </ul> <h5 id="return-value-16"> <a style="text-decoration: none;" href="#return-value-16">Return Value</a> </h5> <p>The converted <code class="language-plaintext highlighter-rouge">double</code> element.</p> <p><br></p> <h4 id="duckdb_create_logical_type"> <a style="text-decoration: none;" href="#duckdb_create_logical_type"><code class="language-plaintext highlighter-rouge">duckdb_create_logical_type</code></a> </h4> <p>Creates a <code class="language-plaintext highlighter-rouge">duckdb_logical_type</code> from a primitive type. The resulting logical type must be destroyed with <code class="language-plaintext highlighter-rouge">duckdb_destroy_logical_type</code>.</p> <p>Returns an invalid logical type, if type is: <code class="language-plaintext highlighter-rouge">DUCKDB_TYPE_INVALID</code>, <code class="language-plaintext highlighter-rouge">DUCKDB_TYPE_DECIMAL</code>, <code class="language-plaintext highlighter-rouge">DUCKDB_TYPE_ENUM</code>, <code class="language-plaintext highlighter-rouge">DUCKDB_TYPE_LIST</code>, <code class="language-plaintext highlighter-rouge">DUCKDB_TYPE_STRUCT</code>, <code class="language-plaintext highlighter-rouge">DUCKDB_TYPE_MAP</code>, <code class="language-plaintext highlighter-rouge">DUCKDB_TYPE_ARRAY</code>, or <code class="language-plaintext highlighter-rouge">DUCKDB_TYPE_UNION</code>.</p> <h5 id="syntax-18"> <a style="text-decoration: none;" href="#syntax-18">Syntax</a> </h5> <pre class="language-c highlighter-rouge" data-language="c">duckdb_logical_type duckdb_create_logical_type(
  duckdb_type type
);</pre> <h5 id="parameters-18"> <a style="text-decoration: none;" href="#parameters-18">Parameters</a> </h5> <ul> <li>
<code class="language-plaintext highlighter-rouge">type</code>: The primitive type to create.</li> </ul> <h5 id="return-value-17"> <a style="text-decoration: none;" href="#return-value-17">Return Value</a> </h5> <p>The logical type.</p> <p><br></p> <h4 id="duckdb_logical_type_get_alias"> <a style="text-decoration: none;" href="#duckdb_logical_type_get_alias"><code class="language-plaintext highlighter-rouge">duckdb_logical_type_get_alias</code></a> </h4> <p>Returns the alias of a duckdb_logical_type, if set, else <code class="language-plaintext highlighter-rouge">nullptr</code>. The result must be destroyed with <code class="language-plaintext highlighter-rouge">duckdb_free</code>.</p> <h5 id="syntax-19"> <a style="text-decoration: none;" href="#syntax-19">Syntax</a> </h5> <pre class="language-c highlighter-rouge" data-language="c">char *duckdb_logical_type_get_alias(
  duckdb_logical_type type
);</pre> <h5 id="parameters-19"> <a style="text-decoration: none;" href="#parameters-19">Parameters</a> </h5> <ul> <li>
<code class="language-plaintext highlighter-rouge">type</code>: The logical type</li> </ul> <h5 id="return-value-18"> <a style="text-decoration: none;" href="#return-value-18">Return Value</a> </h5> <p>The alias or <code class="language-plaintext highlighter-rouge">nullptr</code></p> <p><br></p> <h4 id="duckdb_logical_type_set_alias"> <a style="text-decoration: none;" href="#duckdb_logical_type_set_alias"><code class="language-plaintext highlighter-rouge">duckdb_logical_type_set_alias</code></a> </h4> <p>Sets the alias of a duckdb_logical_type.</p> <h5 id="syntax-20"> <a style="text-decoration: none;" href="#syntax-20">Syntax</a> </h5> <pre class="language-c highlighter-rouge" data-language="c">void duckdb_logical_type_set_alias(
  duckdb_logical_type type,
  const char *alias
);</pre> <h5 id="parameters-20"> <a style="text-decoration: none;" href="#parameters-20">Parameters</a> </h5> <ul> <li>
<code class="language-plaintext highlighter-rouge">type</code>: The logical type</li> <li>
<code class="language-plaintext highlighter-rouge">alias</code>: The alias to set</li> </ul> <p><br></p> <h4 id="duckdb_create_list_type"> <a style="text-decoration: none;" href="#duckdb_create_list_type"><code class="language-plaintext highlighter-rouge">duckdb_create_list_type</code></a> </h4> <p>Creates a LIST type from its child type. The return type must be destroyed with <code class="language-plaintext highlighter-rouge">duckdb_destroy_logical_type</code>.</p> <h5 id="syntax-21"> <a style="text-decoration: none;" href="#syntax-21">Syntax</a> </h5> <pre class="language-c highlighter-rouge" data-language="c">duckdb_logical_type duckdb_create_list_type(
  duckdb_logical_type type
);</pre> <h5 id="parameters-21"> <a style="text-decoration: none;" href="#parameters-21">Parameters</a> </h5> <ul> <li>
<code class="language-plaintext highlighter-rouge">type</code>: The child type of the list</li> </ul> <h5 id="return-value-19"> <a style="text-decoration: none;" href="#return-value-19">Return Value</a> </h5> <p>The logical type.</p> <p><br></p> <h4 id="duckdb_create_array_type"> <a style="text-decoration: none;" href="#duckdb_create_array_type"><code class="language-plaintext highlighter-rouge">duckdb_create_array_type</code></a> </h4> <p>Creates an ARRAY type from its child type. The return type must be destroyed with <code class="language-plaintext highlighter-rouge">duckdb_destroy_logical_type</code>.</p> <h5 id="syntax-22"> <a style="text-decoration: none;" href="#syntax-22">Syntax</a> </h5> <pre class="language-c highlighter-rouge" data-language="c">duckdb_logical_type duckdb_create_array_type(
  duckdb_logical_type type,
  idx_t array_size
);</pre> <h5 id="parameters-22"> <a style="text-decoration: none;" href="#parameters-22">Parameters</a> </h5> <ul> <li>
<code class="language-plaintext highlighter-rouge">type</code>: The child type of the array.</li> <li>
<code class="language-plaintext highlighter-rouge">array_size</code>: The number of elements in the array.</li> </ul> <h5 id="return-value-20"> <a style="text-decoration: none;" href="#return-value-20">Return Value</a> </h5> <p>The logical type.</p> <p><br></p> <h4 id="duckdb_create_map_type"> <a style="text-decoration: none;" href="#duckdb_create_map_type"><code class="language-plaintext highlighter-rouge">duckdb_create_map_type</code></a> </h4> <p>Creates a MAP type from its key type and value type. The return type must be destroyed with <code class="language-plaintext highlighter-rouge">duckdb_destroy_logical_type</code>.</p> <h5 id="syntax-23"> <a style="text-decoration: none;" href="#syntax-23">Syntax</a> </h5> <pre class="language-c highlighter-rouge" data-language="c">duckdb_logical_type duckdb_create_map_type(
  duckdb_logical_type key_type,
  duckdb_logical_type value_type
);</pre> <h5 id="parameters-23"> <a style="text-decoration: none;" href="#parameters-23">Parameters</a> </h5> <ul> <li>
<code class="language-plaintext highlighter-rouge">key_type</code>: The map's key type.</li> <li>
<code class="language-plaintext highlighter-rouge">value_type</code>: The map's value type.</li> </ul> <h5 id="return-value-21"> <a style="text-decoration: none;" href="#return-value-21">Return Value</a> </h5> <p>The logical type.</p> <p><br></p> <h4 id="duckdb_create_union_type"> <a style="text-decoration: none;" href="#duckdb_create_union_type"><code class="language-plaintext highlighter-rouge">duckdb_create_union_type</code></a> </h4> <p>Creates a UNION type from the passed arrays. The return type must be destroyed with <code class="language-plaintext highlighter-rouge">duckdb_destroy_logical_type</code>.</p> <h5 id="syntax-24"> <a style="text-decoration: none;" href="#syntax-24">Syntax</a> </h5> <pre class="language-c highlighter-rouge" data-language="c">duckdb_logical_type duckdb_create_union_type(
  duckdb_logical_type *member_types,
  const char **member_names,
  idx_t member_count
);</pre> <h5 id="parameters-24"> <a style="text-decoration: none;" href="#parameters-24">Parameters</a> </h5> <ul> <li>
<code class="language-plaintext highlighter-rouge">member_types</code>: The array of union member types.</li> <li>
<code class="language-plaintext highlighter-rouge">member_names</code>: The union member names.</li> <li>
<code class="language-plaintext highlighter-rouge">member_count</code>: The number of union members.</li> </ul> <h5 id="return-value-22"> <a style="text-decoration: none;" href="#return-value-22">Return Value</a> </h5> <p>The logical type.</p> <p><br></p> <h4 id="duckdb_create_struct_type"> <a style="text-decoration: none;" href="#duckdb_create_struct_type"><code class="language-plaintext highlighter-rouge">duckdb_create_struct_type</code></a> </h4> <p>Creates a STRUCT type based on the member types and names. The resulting type must be destroyed with <code class="language-plaintext highlighter-rouge">duckdb_destroy_logical_type</code>.</p> <h5 id="syntax-25"> <a style="text-decoration: none;" href="#syntax-25">Syntax</a> </h5> <pre class="language-c highlighter-rouge" data-language="c">duckdb_logical_type duckdb_create_struct_type(
  duckdb_logical_type *member_types,
  const char **member_names,
  idx_t member_count
);</pre> <h5 id="parameters-25"> <a style="text-decoration: none;" href="#parameters-25">Parameters</a> </h5> <ul> <li>
<code class="language-plaintext highlighter-rouge">member_types</code>: The array of types of the struct members.</li> <li>
<code class="language-plaintext highlighter-rouge">member_names</code>: The array of names of the struct members.</li> <li>
<code class="language-plaintext highlighter-rouge">member_count</code>: The number of members of the struct.</li> </ul> <h5 id="return-value-23"> <a style="text-decoration: none;" href="#return-value-23">Return Value</a> </h5> <p>The logical type.</p> <p><br></p> <h4 id="duckdb_create_enum_type"> <a style="text-decoration: none;" href="#duckdb_create_enum_type"><code class="language-plaintext highlighter-rouge">duckdb_create_enum_type</code></a> </h4> <p>Creates an ENUM type from the passed member name array. The resulting type should be destroyed with <code class="language-plaintext highlighter-rouge">duckdb_destroy_logical_type</code>.</p> <h5 id="syntax-26"> <a style="text-decoration: none;" href="#syntax-26">Syntax</a> </h5> <pre class="language-c highlighter-rouge" data-language="c">duckdb_logical_type duckdb_create_enum_type(
  const char **member_names,
  idx_t member_count
);</pre> <h5 id="parameters-26"> <a style="text-decoration: none;" href="#parameters-26">Parameters</a> </h5> <ul> <li>
<code class="language-plaintext highlighter-rouge">member_names</code>: The array of names that the enum should consist of.</li> <li>
<code class="language-plaintext highlighter-rouge">member_count</code>: The number of elements that were specified in the array.</li> </ul> <h5 id="return-value-24"> <a style="text-decoration: none;" href="#return-value-24">Return Value</a> </h5> <p>The logical type.</p> <p><br></p> <h4 id="duckdb_create_decimal_type"> <a style="text-decoration: none;" href="#duckdb_create_decimal_type"><code class="language-plaintext highlighter-rouge">duckdb_create_decimal_type</code></a> </h4> <p>Creates a DECIMAL type with the specified width and scale. The resulting type should be destroyed with <code class="language-plaintext highlighter-rouge">duckdb_destroy_logical_type</code>.</p> <h5 id="syntax-27"> <a style="text-decoration: none;" href="#syntax-27">Syntax</a> </h5> <pre class="language-c highlighter-rouge" data-language="c">duckdb_logical_type duckdb_create_decimal_type(
  uint8_t width,
  uint8_t scale
);</pre> <h5 id="parameters-27"> <a style="text-decoration: none;" href="#parameters-27">Parameters</a> </h5> <ul> <li>
<code class="language-plaintext highlighter-rouge">width</code>: The width of the decimal type</li> <li>
<code class="language-plaintext highlighter-rouge">scale</code>: The scale of the decimal type</li> </ul> <h5 id="return-value-25"> <a style="text-decoration: none;" href="#return-value-25">Return Value</a> </h5> <p>The logical type.</p> <p><br></p> <h4 id="duckdb_get_type_id"> <a style="text-decoration: none;" href="#duckdb_get_type_id"><code class="language-plaintext highlighter-rouge">duckdb_get_type_id</code></a> </h4> <p>Retrieves the enum <code class="language-plaintext highlighter-rouge">duckdb_type</code> of a <code class="language-plaintext highlighter-rouge">duckdb_logical_type</code>.</p> <h5 id="syntax-28"> <a style="text-decoration: none;" href="#syntax-28">Syntax</a> </h5> <pre class="language-c highlighter-rouge" data-language="c">duckdb_type duckdb_get_type_id(
  duckdb_logical_type type
);</pre> <h5 id="parameters-28"> <a style="text-decoration: none;" href="#parameters-28">Parameters</a> </h5> <ul> <li>
<code class="language-plaintext highlighter-rouge">type</code>: The logical type.</li> </ul> <h5 id="return-value-26"> <a style="text-decoration: none;" href="#return-value-26">Return Value</a> </h5> <p>The <code class="language-plaintext highlighter-rouge">duckdb_type</code> id.</p> <p><br></p> <h4 id="duckdb_decimal_width"> <a style="text-decoration: none;" href="#duckdb_decimal_width"><code class="language-plaintext highlighter-rouge">duckdb_decimal_width</code></a> </h4> <p>Retrieves the width of a decimal type.</p> <h5 id="syntax-29"> <a style="text-decoration: none;" href="#syntax-29">Syntax</a> </h5> <pre class="language-c highlighter-rouge" data-language="c">uint8_t duckdb_decimal_width(
  duckdb_logical_type type
);</pre> <h5 id="parameters-29"> <a style="text-decoration: none;" href="#parameters-29">Parameters</a> </h5> <ul> <li>
<code class="language-plaintext highlighter-rouge">type</code>: The logical type object</li> </ul> <h5 id="return-value-27"> <a style="text-decoration: none;" href="#return-value-27">Return Value</a> </h5> <p>The width of the decimal type</p> <p><br></p> <h4 id="duckdb_decimal_scale"> <a style="text-decoration: none;" href="#duckdb_decimal_scale"><code class="language-plaintext highlighter-rouge">duckdb_decimal_scale</code></a> </h4> <p>Retrieves the scale of a decimal type.</p> <h5 id="syntax-30"> <a style="text-decoration: none;" href="#syntax-30">Syntax</a> </h5> <pre class="language-c highlighter-rouge" data-language="c">uint8_t duckdb_decimal_scale(
  duckdb_logical_type type
);</pre> <h5 id="parameters-30"> <a style="text-decoration: none;" href="#parameters-30">Parameters</a> </h5> <ul> <li>
<code class="language-plaintext highlighter-rouge">type</code>: The logical type object</li> </ul> <h5 id="return-value-28"> <a style="text-decoration: none;" href="#return-value-28">Return Value</a> </h5> <p>The scale of the decimal type</p> <p><br></p> <h4 id="duckdb_decimal_internal_type"> <a style="text-decoration: none;" href="#duckdb_decimal_internal_type"><code class="language-plaintext highlighter-rouge">duckdb_decimal_internal_type</code></a> </h4> <p>Retrieves the internal storage type of a decimal type.</p> <h5 id="syntax-31"> <a style="text-decoration: none;" href="#syntax-31">Syntax</a> </h5> <pre class="language-c highlighter-rouge" data-language="c">duckdb_type duckdb_decimal_internal_type(
  duckdb_logical_type type
);</pre> <h5 id="parameters-31"> <a style="text-decoration: none;" href="#parameters-31">Parameters</a> </h5> <ul> <li>
<code class="language-plaintext highlighter-rouge">type</code>: The logical type object</li> </ul> <h5 id="return-value-29"> <a style="text-decoration: none;" href="#return-value-29">Return Value</a> </h5> <p>The internal type of the decimal type</p> <p><br></p> <h4 id="duckdb_enum_internal_type"> <a style="text-decoration: none;" href="#duckdb_enum_internal_type"><code class="language-plaintext highlighter-rouge">duckdb_enum_internal_type</code></a> </h4> <p>Retrieves the internal storage type of an enum type.</p> <h5 id="syntax-32"> <a style="text-decoration: none;" href="#syntax-32">Syntax</a> </h5> <pre class="language-c highlighter-rouge" data-language="c">duckdb_type duckdb_enum_internal_type(
  duckdb_logical_type type
);</pre> <h5 id="parameters-32"> <a style="text-decoration: none;" href="#parameters-32">Parameters</a> </h5> <ul> <li>
<code class="language-plaintext highlighter-rouge">type</code>: The logical type object</li> </ul> <h5 id="return-value-30"> <a style="text-decoration: none;" href="#return-value-30">Return Value</a> </h5> <p>The internal type of the enum type</p> <p><br></p> <h4 id="duckdb_enum_dictionary_size"> <a style="text-decoration: none;" href="#duckdb_enum_dictionary_size"><code class="language-plaintext highlighter-rouge">duckdb_enum_dictionary_size</code></a> </h4> <p>Retrieves the dictionary size of the enum type.</p> <h5 id="syntax-33"> <a style="text-decoration: none;" href="#syntax-33">Syntax</a> </h5> <pre class="language-c highlighter-rouge" data-language="c">uint32_t duckdb_enum_dictionary_size(
  duckdb_logical_type type
);</pre> <h5 id="parameters-33"> <a style="text-decoration: none;" href="#parameters-33">Parameters</a> </h5> <ul> <li>
<code class="language-plaintext highlighter-rouge">type</code>: The logical type object</li> </ul> <h5 id="return-value-31"> <a style="text-decoration: none;" href="#return-value-31">Return Value</a> </h5> <p>The dictionary size of the enum type</p> <p><br></p> <h4 id="duckdb_enum_dictionary_value"> <a style="text-decoration: none;" href="#duckdb_enum_dictionary_value"><code class="language-plaintext highlighter-rouge">duckdb_enum_dictionary_value</code></a> </h4> <p>Retrieves the dictionary value at the specified position from the enum.</p> <p>The result must be freed with <code class="language-plaintext highlighter-rouge">duckdb_free</code>.</p> <h5 id="syntax-34"> <a style="text-decoration: none;" href="#syntax-34">Syntax</a> </h5> <pre class="language-c highlighter-rouge" data-language="c">char *duckdb_enum_dictionary_value(
  duckdb_logical_type type,
  idx_t index
);</pre> <h5 id="parameters-34"> <a style="text-decoration: none;" href="#parameters-34">Parameters</a> </h5> <ul> <li>
<code class="language-plaintext highlighter-rouge">type</code>: The logical type object</li> <li>
<code class="language-plaintext highlighter-rouge">index</code>: The index in the dictionary</li> </ul> <h5 id="return-value-32"> <a style="text-decoration: none;" href="#return-value-32">Return Value</a> </h5> <p>The string value of the enum type. Must be freed with <code class="language-plaintext highlighter-rouge">duckdb_free</code>.</p> <p><br></p> <h4 id="duckdb_list_type_child_type"> <a style="text-decoration: none;" href="#duckdb_list_type_child_type"><code class="language-plaintext highlighter-rouge">duckdb_list_type_child_type</code></a> </h4> <p>Retrieves the child type of the given LIST type. Also accepts MAP types. The result must be freed with <code class="language-plaintext highlighter-rouge">duckdb_destroy_logical_type</code>.</p> <h5 id="syntax-35"> <a style="text-decoration: none;" href="#syntax-35">Syntax</a> </h5> <pre class="language-c highlighter-rouge" data-language="c">duckdb_logical_type duckdb_list_type_child_type(
  duckdb_logical_type type
);</pre> <h5 id="parameters-35"> <a style="text-decoration: none;" href="#parameters-35">Parameters</a> </h5> <ul> <li>
<code class="language-plaintext highlighter-rouge">type</code>: The logical type, either LIST or MAP.</li> </ul> <h5 id="return-value-33"> <a style="text-decoration: none;" href="#return-value-33">Return Value</a> </h5> <p>The child type of the LIST or MAP type.</p> <p><br></p> <h4 id="duckdb_array_type_child_type"> <a style="text-decoration: none;" href="#duckdb_array_type_child_type"><code class="language-plaintext highlighter-rouge">duckdb_array_type_child_type</code></a> </h4> <p>Retrieves the child type of the given ARRAY type.</p> <p>The result must be freed with <code class="language-plaintext highlighter-rouge">duckdb_destroy_logical_type</code>.</p> <h5 id="syntax-36"> <a style="text-decoration: none;" href="#syntax-36">Syntax</a> </h5> <pre class="language-c highlighter-rouge" data-language="c">duckdb_logical_type duckdb_array_type_child_type(
  duckdb_logical_type type
);</pre> <h5 id="parameters-36"> <a style="text-decoration: none;" href="#parameters-36">Parameters</a> </h5> <ul> <li>
<code class="language-plaintext highlighter-rouge">type</code>: The logical type. Must be ARRAY.</li> </ul> <h5 id="return-value-34"> <a style="text-decoration: none;" href="#return-value-34">Return Value</a> </h5> <p>The child type of the ARRAY type.</p> <p><br></p> <h4 id="duckdb_array_type_array_size"> <a style="text-decoration: none;" href="#duckdb_array_type_array_size"><code class="language-plaintext highlighter-rouge">duckdb_array_type_array_size</code></a> </h4> <p>Retrieves the array size of the given array type.</p> <h5 id="syntax-37"> <a style="text-decoration: none;" href="#syntax-37">Syntax</a> </h5> <pre class="language-c highlighter-rouge" data-language="c">idx_t duckdb_array_type_array_size(
  duckdb_logical_type type
);</pre> <h5 id="parameters-37"> <a style="text-decoration: none;" href="#parameters-37">Parameters</a> </h5> <ul> <li>
<code class="language-plaintext highlighter-rouge">type</code>: The logical type object</li> </ul> <h5 id="return-value-35"> <a style="text-decoration: none;" href="#return-value-35">Return Value</a> </h5> <p>The fixed number of elements the values of this array type can store.</p> <p><br></p> <h4 id="duckdb_map_type_key_type"> <a style="text-decoration: none;" href="#duckdb_map_type_key_type"><code class="language-plaintext highlighter-rouge">duckdb_map_type_key_type</code></a> </h4> <p>Retrieves the key type of the given map type.</p> <p>The result must be freed with <code class="language-plaintext highlighter-rouge">duckdb_destroy_logical_type</code>.</p> <h5 id="syntax-38"> <a style="text-decoration: none;" href="#syntax-38">Syntax</a> </h5> <pre class="language-c highlighter-rouge" data-language="c">duckdb_logical_type duckdb_map_type_key_type(
  duckdb_logical_type type
);</pre> <h5 id="parameters-38"> <a style="text-decoration: none;" href="#parameters-38">Parameters</a> </h5> <ul> <li>
<code class="language-plaintext highlighter-rouge">type</code>: The logical type object</li> </ul> <h5 id="return-value-36"> <a style="text-decoration: none;" href="#return-value-36">Return Value</a> </h5> <p>The key type of the map type. Must be destroyed with <code class="language-plaintext highlighter-rouge">duckdb_destroy_logical_type</code>.</p> <p><br></p> <h4 id="duckdb_map_type_value_type"> <a style="text-decoration: none;" href="#duckdb_map_type_value_type"><code class="language-plaintext highlighter-rouge">duckdb_map_type_value_type</code></a> </h4> <p>Retrieves the value type of the given map type.</p> <p>The result must be freed with <code class="language-plaintext highlighter-rouge">duckdb_destroy_logical_type</code>.</p> <h5 id="syntax-39"> <a style="text-decoration: none;" href="#syntax-39">Syntax</a> </h5> <pre class="language-c highlighter-rouge" data-language="c">duckdb_logical_type duckdb_map_type_value_type(
  duckdb_logical_type type
);</pre> <h5 id="parameters-39"> <a style="text-decoration: none;" href="#parameters-39">Parameters</a> </h5> <ul> <li>
<code class="language-plaintext highlighter-rouge">type</code>: The logical type object</li> </ul> <h5 id="return-value-37"> <a style="text-decoration: none;" href="#return-value-37">Return Value</a> </h5> <p>The value type of the map type. Must be destroyed with <code class="language-plaintext highlighter-rouge">duckdb_destroy_logical_type</code>.</p> <p><br></p> <h4 id="duckdb_struct_type_child_count"> <a style="text-decoration: none;" href="#duckdb_struct_type_child_count"><code class="language-plaintext highlighter-rouge">duckdb_struct_type_child_count</code></a> </h4> <p>Returns the number of children of a struct type.</p> <h5 id="syntax-40"> <a style="text-decoration: none;" href="#syntax-40">Syntax</a> </h5> <pre class="language-c highlighter-rouge" data-language="c">idx_t duckdb_struct_type_child_count(
  duckdb_logical_type type
);</pre> <h5 id="parameters-40"> <a style="text-decoration: none;" href="#parameters-40">Parameters</a> </h5> <ul> <li>
<code class="language-plaintext highlighter-rouge">type</code>: The logical type object</li> </ul> <h5 id="return-value-38"> <a style="text-decoration: none;" href="#return-value-38">Return Value</a> </h5> <p>The number of children of a struct type.</p> <p><br></p> <h4 id="duckdb_struct_type_child_name"> <a style="text-decoration: none;" href="#duckdb_struct_type_child_name"><code class="language-plaintext highlighter-rouge">duckdb_struct_type_child_name</code></a> </h4> <p>Retrieves the name of the struct child.</p> <p>The result must be freed with <code class="language-plaintext highlighter-rouge">duckdb_free</code>.</p> <h5 id="syntax-41"> <a style="text-decoration: none;" href="#syntax-41">Syntax</a> </h5> <pre class="language-c highlighter-rouge" data-language="c">char *duckdb_struct_type_child_name(
  duckdb_logical_type type,
  idx_t index
);</pre> <h5 id="parameters-41"> <a style="text-decoration: none;" href="#parameters-41">Parameters</a> </h5> <ul> <li>
<code class="language-plaintext highlighter-rouge">type</code>: The logical type object</li> <li>
<code class="language-plaintext highlighter-rouge">index</code>: The child index</li> </ul> <h5 id="return-value-39"> <a style="text-decoration: none;" href="#return-value-39">Return Value</a> </h5> <p>The name of the struct type. Must be freed with <code class="language-plaintext highlighter-rouge">duckdb_free</code>.</p> <p><br></p> <h4 id="duckdb_struct_type_child_type"> <a style="text-decoration: none;" href="#duckdb_struct_type_child_type"><code class="language-plaintext highlighter-rouge">duckdb_struct_type_child_type</code></a> </h4> <p>Retrieves the child type of the given struct type at the specified index.</p> <p>The result must be freed with <code class="language-plaintext highlighter-rouge">duckdb_destroy_logical_type</code>.</p> <h5 id="syntax-42"> <a style="text-decoration: none;" href="#syntax-42">Syntax</a> </h5> <pre class="language-c highlighter-rouge" data-language="c">duckdb_logical_type duckdb_struct_type_child_type(
  duckdb_logical_type type,
  idx_t index
);</pre> <h5 id="parameters-42"> <a style="text-decoration: none;" href="#parameters-42">Parameters</a> </h5> <ul> <li>
<code class="language-plaintext highlighter-rouge">type</code>: The logical type object</li> <li>
<code class="language-plaintext highlighter-rouge">index</code>: The child index</li> </ul> <h5 id="return-value-40"> <a style="text-decoration: none;" href="#return-value-40">Return Value</a> </h5> <p>The child type of the struct type. Must be destroyed with <code class="language-plaintext highlighter-rouge">duckdb_destroy_logical_type</code>.</p> <p><br></p> <h4 id="duckdb_union_type_member_count"> <a style="text-decoration: none;" href="#duckdb_union_type_member_count"><code class="language-plaintext highlighter-rouge">duckdb_union_type_member_count</code></a> </h4> <p>Returns the number of members that the union type has.</p> <h5 id="syntax-43"> <a style="text-decoration: none;" href="#syntax-43">Syntax</a> </h5> <pre class="language-c highlighter-rouge" data-language="c">idx_t duckdb_union_type_member_count(
  duckdb_logical_type type
);</pre> <h5 id="parameters-43"> <a style="text-decoration: none;" href="#parameters-43">Parameters</a> </h5> <ul> <li>
<code class="language-plaintext highlighter-rouge">type</code>: The logical type (union) object</li> </ul> <h5 id="return-value-41"> <a style="text-decoration: none;" href="#return-value-41">Return Value</a> </h5> <p>The number of members of a union type.</p> <p><br></p> <h4 id="duckdb_union_type_member_name"> <a style="text-decoration: none;" href="#duckdb_union_type_member_name"><code class="language-plaintext highlighter-rouge">duckdb_union_type_member_name</code></a> </h4> <p>Retrieves the name of the union member.</p> <p>The result must be freed with <code class="language-plaintext highlighter-rouge">duckdb_free</code>.</p> <h5 id="syntax-44"> <a style="text-decoration: none;" href="#syntax-44">Syntax</a> </h5> <pre class="language-c highlighter-rouge" data-language="c">char *duckdb_union_type_member_name(
  duckdb_logical_type type,
  idx_t index
);</pre> <h5 id="parameters-44"> <a style="text-decoration: none;" href="#parameters-44">Parameters</a> </h5> <ul> <li>
<code class="language-plaintext highlighter-rouge">type</code>: The logical type object</li> <li>
<code class="language-plaintext highlighter-rouge">index</code>: The child index</li> </ul> <h5 id="return-value-42"> <a style="text-decoration: none;" href="#return-value-42">Return Value</a> </h5> <p>The name of the union member. Must be freed with <code class="language-plaintext highlighter-rouge">duckdb_free</code>.</p> <p><br></p> <h4 id="duckdb_union_type_member_type"> <a style="text-decoration: none;" href="#duckdb_union_type_member_type"><code class="language-plaintext highlighter-rouge">duckdb_union_type_member_type</code></a> </h4> <p>Retrieves the child type of the given union member at the specified index.</p> <p>The result must be freed with <code class="language-plaintext highlighter-rouge">duckdb_destroy_logical_type</code>.</p> <h5 id="syntax-45"> <a style="text-decoration: none;" href="#syntax-45">Syntax</a> </h5> <pre class="language-c highlighter-rouge" data-language="c">duckdb_logical_type duckdb_union_type_member_type(
  duckdb_logical_type type,
  idx_t index
);</pre> <h5 id="parameters-45"> <a style="text-decoration: none;" href="#parameters-45">Parameters</a> </h5> <ul> <li>
<code class="language-plaintext highlighter-rouge">type</code>: The logical type object</li> <li>
<code class="language-plaintext highlighter-rouge">index</code>: The child index</li> </ul> <h5 id="return-value-43"> <a style="text-decoration: none;" href="#return-value-43">Return Value</a> </h5> <p>The child type of the union member. Must be destroyed with <code class="language-plaintext highlighter-rouge">duckdb_destroy_logical_type</code>.</p> <p><br></p> <h4 id="duckdb_destroy_logical_type"> <a style="text-decoration: none;" href="#duckdb_destroy_logical_type"><code class="language-plaintext highlighter-rouge">duckdb_destroy_logical_type</code></a> </h4> <p>Destroys the logical type and de-allocates all memory allocated for that type.</p> <h5 id="syntax-46"> <a style="text-decoration: none;" href="#syntax-46">Syntax</a> </h5> <pre class="language-c highlighter-rouge" data-language="c">void duckdb_destroy_logical_type(
  duckdb_logical_type *type
);</pre> <h5 id="parameters-46"> <a style="text-decoration: none;" href="#parameters-46">Parameters</a> </h5> <ul> <li>
<code class="language-plaintext highlighter-rouge">type</code>: The logical type to destroy.</li> </ul> <p><br></p> <h4 id="duckdb_register_logical_type"> <a style="text-decoration: none;" href="#duckdb_register_logical_type"><code class="language-plaintext highlighter-rouge">duckdb_register_logical_type</code></a> </h4> <p>Registers a custom type within the given connection. The type must have an alias</p> <h5 id="syntax-47"> <a style="text-decoration: none;" href="#syntax-47">Syntax</a> </h5> <pre class="language-c highlighter-rouge" data-language="c">duckdb_state duckdb_register_logical_type(
  duckdb_connection con,
  duckdb_logical_type type,
  duckdb_create_type_info info
);</pre> <h5 id="parameters-47"> <a style="text-decoration: none;" href="#parameters-47">Parameters</a> </h5> <ul> <li>
<code class="language-plaintext highlighter-rouge">con</code>: The connection to use</li> <li>
<code class="language-plaintext highlighter-rouge">type</code>: The custom type to register</li> </ul> <h5 id="return-value-44"> <a style="text-decoration: none;" href="#return-value-44">Return Value</a> </h5> <p>Whether or not the registration was successful.</p> <p><br></p><div class="_attribution">
  <p class="_attribution-p">
    &copy; Copyright 2018&ndash;2024 Stichting DuckDB Foundation<br>Licensed under the MIT License.<br>
    <a href="https://duckdb.org/docs/api/c/types.html" class="_attribution-link">https://duckdb.org/docs/api/c/types.html</a>
  </p>
</div>
