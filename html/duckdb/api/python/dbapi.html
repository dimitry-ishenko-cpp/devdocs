<h1 class="title">Python DB API</h1>  <p>The standard DuckDB Python API provides a SQL interface compliant with the <a href="https://www.python.org/dev/peps/pep-0249/">DB-API 2.0 specification described by PEP 249</a> similar to the <a href="https://docs.python.org/3.7/library/sqlite3.html">SQLite Python API</a>.</p> <h2 id="connection"> <a style="text-decoration: none;" href="#connection">Connection</a> </h2> <p>To use the module, you must first create a <code class="language-plaintext highlighter-rouge">DuckDBPyConnection</code> object that represents a connection to a database. This is done through the <a href="http://localhost:8000/docs/api/python/reference/#duckdb.connect.html"><code class="language-plaintext highlighter-rouge">duckdb.connect</code></a> method.</p> <p>The 'config' keyword argument can be used to provide a <code class="language-plaintext highlighter-rouge">dict</code> that contains key-&gt;value pairs referencing <a href="../../configuration/overview.html#configuration-reference.html">settings</a> understood by DuckDB.</p> <h3 id="in-memory-connection"> <a style="text-decoration: none;" href="#in-memory-connection">In-Memory Connection</a> </h3> <p>The special value <code class="language-plaintext highlighter-rouge">:memory:</code> can be used to create an <strong>in-memory database</strong>. Note that for an in-memory database no data is persisted to disk (i.e., all data is lost when you exit the Python process).</p> <h4 id="named-in-memory-connections"> <a style="text-decoration: none;" href="#named-in-memory-connections">Named in-memory Connections</a> </h4> <p>The special value <code class="language-plaintext highlighter-rouge">:memory:</code> can also be postfixed with a name, for example: <code class="language-plaintext highlighter-rouge">:memory:conn3</code>. When a name is provided, subsequent <code class="language-plaintext highlighter-rouge">duckdb.connect</code> calls will create a new connection to the same database, sharing the catalogs (views, tables, macros etc..).</p> <p>Using <code class="language-plaintext highlighter-rouge">:memory:</code> without a name will always create a new and separate database instance.</p> <h3 id="default-connection"> <a style="text-decoration: none;" href="#default-connection">Default Connection</a> </h3> <p>By default we create an (unnamed) <strong>in-memory-database</strong> that lives inside the <code class="language-plaintext highlighter-rouge">duckdb</code> module. Every method of <code class="language-plaintext highlighter-rouge">DuckDBPyConnection</code> is also available on the <code class="language-plaintext highlighter-rouge">duckdb</code> module, this connection is what's used by these methods.</p> <p>The special value <code class="language-plaintext highlighter-rouge">:default:</code> can be used to get this default connection.</p> <h3 id="file-based-connection"> <a style="text-decoration: none;" href="#file-based-connection">File-Based Connection</a> </h3> <p>If the <code class="language-plaintext highlighter-rouge">database</code> is a file path, a connection to a persistent database is established. If the file does not exist the file will be created (the extension of the file is irrelevant and can be <code class="language-plaintext highlighter-rouge">.db</code>, <code class="language-plaintext highlighter-rouge">.duckdb</code> or anything else).</p> <h4 id="read_only-connections"> <a style="text-decoration: none;" href="#read_only-connections"><code class="language-plaintext highlighter-rouge">read_only</code> Connections</a> </h4> <p>If you would like to connect in read-only mode, you can set the <code class="language-plaintext highlighter-rouge">read_only</code> flag to <code class="language-plaintext highlighter-rouge">True</code>. If the file does not exist, it is <strong>not</strong> created when connecting in read-only mode. Read-only mode is required if multiple Python processes want to access the same database file at the same time.</p> <pre class="language-python highlighter-rouge" data-language="python">import duckdb

duckdb.execute("CREATE TABLE tbl AS SELECT 42 a")
con = duckdb.connect(":default:")
con.sql("SELECT * FROM tbl")
# or
duckdb.default_connection.sql("SELECT * FROM tbl")</pre> <pre class="language-text highlighter-rouge" data-language="text">┌───────┐
│   a   │
│ int32 │
├───────┤
│    42 │
└───────┘</pre> <pre class="language-python highlighter-rouge" data-language="python">import duckdb

# to start an in-memory database
con = duckdb.connect(database = ":memory:")
# to use a database file (not shared between processes)
con = duckdb.connect(database = "my-db.duckdb", read_only = False)
# to use a database file (shared between processes)
con = duckdb.connect(database = "my-db.duckdb", read_only = True)
# to explicitly get the default connection
con = duckdb.connect(database = ":default:")</pre> <p>If you want to create a second connection to an existing database, you can use the <code class="language-plaintext highlighter-rouge">cursor()</code> method. This might be useful for example to allow parallel threads running queries independently. A single connection is thread-safe but is locked for the duration of the queries, effectively serializing database access in this case.</p> <p>Connections are closed implicitly when they go out of scope or if they are explicitly closed using <code class="language-plaintext highlighter-rouge">close()</code>. Once the last connection to a database instance is closed, the database instance is closed as well.</p> <h2 id="querying"> <a style="text-decoration: none;" href="#querying">Querying</a> </h2> <p>SQL queries can be sent to DuckDB using the <code class="language-plaintext highlighter-rouge">execute()</code> method of connections. Once a query has been executed, results can be retrieved using the <code class="language-plaintext highlighter-rouge">fetchone</code> and <code class="language-plaintext highlighter-rouge">fetchall</code> methods on the connection. <code class="language-plaintext highlighter-rouge">fetchall</code> will retrieve all results and complete the transaction. <code class="language-plaintext highlighter-rouge">fetchone</code> will retrieve a single row of results each time that it is invoked until no more results are available. The transaction will only close once <code class="language-plaintext highlighter-rouge">fetchone</code> is called and there are no more results remaining (the return value will be <code class="language-plaintext highlighter-rouge">None</code>). As an example, in the case of a query only returning a single row, <code class="language-plaintext highlighter-rouge">fetchone</code> should be called once to retrieve the results and a second time to close the transaction. Below are some short examples:</p> <pre class="language-python highlighter-rouge" data-language="python"># create a table
con.execute("CREATE TABLE items (item VARCHAR, value DECIMAL(10, 2), count INTEGER)")
# insert two items into the table
con.execute("INSERT INTO items VALUES ('jeans', 20.0, 1), ('hammer', 42.2, 2)")

# retrieve the items again
con.execute("SELECT * FROM items")
print(con.fetchall())
# [('jeans', Decimal('20.00'), 1), ('hammer', Decimal('42.20'), 2)]

# retrieve the items one at a time
con.execute("SELECT * FROM items")
print(con.fetchone())
# ('jeans', Decimal('20.00'), 1)
print(con.fetchone())
# ('hammer', Decimal('42.20'), 2)
print(con.fetchone()) # This closes the transaction. Any subsequent calls to .fetchone will return None
# None</pre> <p>The <code class="language-plaintext highlighter-rouge">description</code> property of the connection object contains the column names as per the standard.</p> <h3 id="prepared-statements"> <a style="text-decoration: none;" href="#prepared-statements">Prepared Statements</a> </h3> <p>DuckDB also supports <a href="../../sql/query_syntax/prepared_statements.html">prepared statements</a> in the API with the <code class="language-plaintext highlighter-rouge">execute</code> and <code class="language-plaintext highlighter-rouge">executemany</code> methods. The values may be passed as an additional parameter after a query that contains <code class="language-plaintext highlighter-rouge">?</code> or <code class="language-plaintext highlighter-rouge">$1</code> (dollar symbol and a number) placeholders. Using the <code class="language-plaintext highlighter-rouge">?</code> notation adds the values in the same sequence as passed within the Python parameter. Using the <code class="language-plaintext highlighter-rouge">$</code> notation allows for values to be reused within the SQL statement based on the number and index of the value found within the Python parameter. Values are converted according to the <a href="conversion.html#object-conversion-python-object-to-duckdb.html">conversion rules</a>.</p> <p>Here are some examples. First, insert a row using a <a href="../../sql/query_syntax/prepared_statements.html">prepared statement</a>:</p> <pre class="language-python highlighter-rouge" data-language="python">con.execute("INSERT INTO items VALUES (?, ?, ?)", ["laptop", 2000, 1])</pre> <p>Second, insert several rows using a <a href="../../sql/query_syntax/prepared_statements.html">prepared statement</a>:</p> <pre class="language-python highlighter-rouge" data-language="python">con.executemany("INSERT INTO items VALUES (?, ?, ?)", [["chainsaw", 500, 10], ["iphone", 300, 2]] )</pre> <p>Query the database using a <a href="../../sql/query_syntax/prepared_statements.html">prepared statement</a>:</p> <pre class="language-python highlighter-rouge" data-language="python">con.execute("SELECT item FROM items WHERE value &gt; ?", [400])
print(con.fetchall())</pre> <pre class="language-text highlighter-rouge" data-language="text">[('laptop',), ('chainsaw',)]</pre> <p>Query using the <code class="language-plaintext highlighter-rouge">$</code> notation for a <a href="../../sql/query_syntax/prepared_statements.html">prepared statement</a> and reused values:</p> <pre class="language-python highlighter-rouge" data-language="python">con.execute("SELECT $1, $1, $2", ["duck", "goose"])
print(con.fetchall())</pre> <pre class="language-text highlighter-rouge" data-language="text">[('duck', 'duck', 'goose')]</pre> <blockquote> <p>Warning Do <em>not</em> use <code class="language-plaintext highlighter-rouge">executemany</code> to insert large amounts of data into DuckDB. See the <a href="data_ingestion.html">data ingestion page</a> for better options.</p> </blockquote> <h2 id="named-parameters"> <a style="text-decoration: none;" href="#named-parameters">Named Parameters</a> </h2> <p>Besides the standard unnamed parameters, like <code class="language-plaintext highlighter-rouge">$1</code>, <code class="language-plaintext highlighter-rouge">$2</code> etc., it's also possible to supply named parameters, like <code class="language-plaintext highlighter-rouge">$my_parameter</code>. When using named parameters, you have to provide a dictionary mapping of <code class="language-plaintext highlighter-rouge">str</code> to value in the <code class="language-plaintext highlighter-rouge">parameters</code> argument. An example use is the following:</p> <pre class="language-python highlighter-rouge" data-language="python">import duckdb

res = duckdb.execute("""
    SELECT
        $my_param,
        $other_param,
        $also_param
    """,
    {
        "my_param": 5,
        "other_param": "DuckDB",
        "also_param": [42]
    }
).fetchall()
print(res)</pre> <pre class="language-text highlighter-rouge" data-language="text">[(5, 'DuckDB', [42])]</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; Copyright 2018&ndash;2024 Stichting DuckDB Foundation<br>Licensed under the MIT License.<br>
    <a href="https://duckdb.org/docs/api/python/dbapi.html" class="_attribution-link">https://duckdb.org/docs/api/python/dbapi.html</a>
  </p>
</div>
