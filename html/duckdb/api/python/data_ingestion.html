<h1 class="title">Data Ingestion</h1>  <p>This page contains examples for data ingestion to Python using DuckDB. First, import the DuckDB page:</p> <pre class="language-python highlighter-rouge" data-language="python">import duckdb</pre> <p>Then, proceed with any of the following sections.</p> <h2 id="csv-files"> <a style="text-decoration: none;" href="#csv-files">CSV Files</a> </h2> <p>CSV files can be read using the <code class="language-plaintext highlighter-rouge">read_csv</code> function, called either from within Python or directly from within SQL. By default, the <code class="language-plaintext highlighter-rouge">read_csv</code> function attempts to auto-detect the CSV settings by sampling from the provided file.</p> <p>Read from a file using fully auto-detected settings:</p> <pre class="language-python highlighter-rouge" data-language="python">duckdb.read_csv("example.csv")</pre> <p>Read multiple CSV files from a folder:</p> <pre class="language-python highlighter-rouge" data-language="python">duckdb.read_csv("folder/*.csv")</pre> <p>Specify options on how the CSV is formatted internally:</p> <pre class="language-python highlighter-rouge" data-language="python">duckdb.read_csv("example.csv", header = False, sep = ",")</pre> <p>Override types of the first two columns:</p> <pre class="language-python highlighter-rouge" data-language="python">duckdb.read_csv("example.csv", dtype = ["int", "varchar"])</pre> <p>Directly read a CSV file from within SQL:</p> <pre class="language-python highlighter-rouge" data-language="python">duckdb.sql("SELECT * FROM 'example.csv'")</pre> <p>Call <code class="language-plaintext highlighter-rouge">read_csv</code> from within SQL:</p> <pre class="language-python highlighter-rouge" data-language="python">duckdb.sql("SELECT * FROM read_csv('example.csv')")</pre> <p>See the <a href="../../data/csv/overview.html">CSV Import</a> page for more information.</p> <h2 id="parquet-files"> <a style="text-decoration: none;" href="#parquet-files">Parquet Files</a> </h2> <p>Parquet files can be read using the <code class="language-plaintext highlighter-rouge">read_parquet</code> function, called either from within Python or directly from within SQL.</p> <p>Read from a single Parquet file:</p> <pre class="language-python highlighter-rouge" data-language="python">duckdb.read_parquet("example.parquet")</pre> <p>Read multiple Parquet files from a folder:</p> <pre class="language-python highlighter-rouge" data-language="python">duckdb.read_parquet("folder/*.parquet")</pre> <p>Read a Parquet file over <a href="../../extensions/httpfs/overview.html">https</a>:</p> <pre class="language-python highlighter-rouge" data-language="python">duckdb.read_parquet("https://some.url/some_file.parquet")</pre> <p>Read a list of Parquet files:</p> <pre class="language-python highlighter-rouge" data-language="python">duckdb.read_parquet(["file1.parquet", "file2.parquet", "file3.parquet"])</pre> <p>Directly read a Parquet file from within SQL:</p> <pre class="language-python highlighter-rouge" data-language="python">duckdb.sql("SELECT * FROM 'example.parquet'")</pre> <p>Call <code class="language-plaintext highlighter-rouge">read_parquet</code> from within SQL:</p> <pre class="language-python highlighter-rouge" data-language="python">duckdb.sql("SELECT * FROM read_parquet('example.parquet')")</pre> <p>See the <a href="../../data/parquet/overview.html">Parquet Loading</a> page for more information.</p> <h2 id="json-files"> <a style="text-decoration: none;" href="#json-files">JSON Files</a> </h2> <p>JSON files can be read using the <code class="language-plaintext highlighter-rouge">read_json</code> function, called either from within Python or directly from within SQL. By default, the <code class="language-plaintext highlighter-rouge">read_json</code> function will automatically detect if a file contains newline-delimited JSON or regular JSON, and will detect the schema of the objects stored within the JSON file.</p> <p>Read from a single JSON file:</p> <pre class="language-python highlighter-rouge" data-language="python">duckdb.read_json("example.json")</pre> <p>Read multiple JSON files from a folder:</p> <pre class="language-python highlighter-rouge" data-language="python">duckdb.read_json("folder/*.json")</pre> <p>Directly read a JSON file from within SQL:</p> <pre class="language-python highlighter-rouge" data-language="python">duckdb.sql("SELECT * FROM 'example.json'")</pre> <p>Call <code class="language-plaintext highlighter-rouge">read_json</code> from within SQL:</p> <pre class="language-python highlighter-rouge" data-language="python">duckdb.sql("SELECT * FROM read_json_auto('example.json')")</pre> <h2 id="directly-accessing-dataframes-and-arrow-objects"> <a style="text-decoration: none;" href="#directly-accessing-dataframes-and-arrow-objects">Directly Accessing DataFrames and Arrow Objects</a> </h2> <p>DuckDB is automatically able to query certain Python variables by referring to their variable name (as if it was a table). These types include the following: Pandas DataFrame, Polars DataFrame, Polars LazyFrame, NumPy arrays, <a href="relational_api.html">relations</a>, and Arrow objects. Accessing these is made possible by <a href="../c/replacement_scans.html">replacement scans</a>.</p> <p>DuckDB supports querying multiple types of Apache Arrow objects including <a href="https://arrow.apache.org/docs/python/generated/pyarrow.Table.html">tables</a>, <a href="https://arrow.apache.org/docs/python/generated/pyarrow.dataset.Dataset.html">datasets</a>, <a href="https://arrow.apache.org/docs/python/generated/pyarrow.ipc.RecordBatchStreamReader.html">RecordBatchReaders</a>, and <a href="https://arrow.apache.org/docs/python/generated/pyarrow.dataset.Scanner.html">scanners</a>. See the Python <a href="../../guides/overview.html#python-client.html">guides</a> for more examples.</p> <pre class="language-python highlighter-rouge" data-language="python">import duckdb
import pandas as pd

test_df = pd.DataFrame.from_dict({"i": [1, 2, 3, 4], "j": ["one", "two", "three", "four"]})
print(duckdb.sql("SELECT * FROM test_df").fetchall())</pre> <pre class="language-text highlighter-rouge" data-language="text">[(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]</pre> <p>DuckDB also supports “registering” a DataFrame or Arrow object as a virtual table, comparable to a SQL <code class="language-plaintext highlighter-rouge">VIEW</code>. This is useful when querying a DataFrame/Arrow object that is stored in another way (as a class variable, or a value in a dictionary). Below is a Pandas example:</p> <p>If your Pandas DataFrame is stored in another location, here is an example of manually registering it:</p> <pre class="language-python highlighter-rouge" data-language="python">import duckdb
import pandas as pd

my_dictionary = {}
my_dictionary["test_df"] = pd.DataFrame.from_dict({"i": [1, 2, 3, 4], "j": ["one", "two", "three", "four"]})
duckdb.register("test_df_view", my_dictionary["test_df"])
print(duckdb.sql("SELECT * FROM test_df_view").fetchall())</pre> <pre class="language-text highlighter-rouge" data-language="text">[(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]</pre> <p>You can also create a persistent table in DuckDB from the contents of the DataFrame (or the view):</p> <pre class="language-python highlighter-rouge" data-language="python"># create a new table from the contents of a DataFrame
con.execute("CREATE TABLE test_df_table AS SELECT * FROM test_df")
# insert into an existing table from the contents of a DataFrame
con.execute("INSERT INTO test_df_table SELECT * FROM test_df")</pre> <h3 id="pandas-dataframes--object-columns"> <a style="text-decoration: none;" href="#pandas-dataframes--object-columns">Pandas DataFrames – <code class="language-plaintext highlighter-rouge">object</code> Columns</a> </h3> <p><code class="language-plaintext highlighter-rouge">pandas.DataFrame</code> columns of an <code class="language-plaintext highlighter-rouge">object</code> dtype require some special care, since this stores values of arbitrary type. To convert these columns to DuckDB, we first go through an analyze phase before converting the values. In this analyze phase a sample of all the rows of the column are analyzed to determine the target type. This sample size is by default set to 1000. If the type picked during the analyze step is incorrect, this will result in a "Failed to cast value:" error, in which case you will need to increase the sample size. The sample size can be changed by setting the <code class="language-plaintext highlighter-rouge">pandas_analyze_sample</code> config option.</p> <pre class="language-python highlighter-rouge" data-language="python"># example setting the sample size to 100k
duckdb.execute("SET GLOBAL pandas_analyze_sample = 100_000")</pre> <h3 id="registering-objects"> <a style="text-decoration: none;" href="#registering-objects">Registering Objects</a> </h3> <p>You can register Python objects as DuckDB tables using the <a href="http://localhost:8000/docs/api/python/reference/#duckdb.DuckDBPyConnection.register.html"><code class="language-plaintext highlighter-rouge">DuckDBPyConnection.register()</code> function</a>.</p> <p>The precedence of objects with the same name is as follows:</p> <ul> <li>Objects explicitly registered via <code class="language-plaintext highlighter-rouge">DuckDBPyConnection.register()</code>
</li> <li>Native DuckDB tables and views</li> <li><a href="../c/replacement_scans.html">Replacement scans</a></li> </ul><div class="_attribution">
  <p class="_attribution-p">
    &copy; Copyright 2018&ndash;2024 Stichting DuckDB Foundation<br>Licensed under the MIT License.<br>
    <a href="https://duckdb.org/docs/api/python/data_ingestion.html" class="_attribution-link">https://duckdb.org/docs/api/python/data_ingestion.html</a>
  </p>
</div>
