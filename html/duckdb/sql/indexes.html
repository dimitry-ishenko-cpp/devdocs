<h1 class="title">Indexes</h1>  <h2 id="index-types"> <a style="text-decoration: none;" href="#index-types">Index Types</a> </h2> <p>DuckDB has two built-in index types. Indexes can also be defined via <a href="../extensions/overview.html">extensions</a>.</p> <h3 id="min-max-index-zonemap"> <a style="text-decoration: none;" href="#min-max-index-zonemap">Min-Max Index (Zonemap)</a> </h3> <p>A <a href="https://en.wikipedia.org/wiki/Block_Range_Index">min-max index</a> (also known as zonemap and block range index) is automatically created for columns of all <a href="data_types/overview.html">general-purpose data types</a>.</p> <h3 id="adaptive-radix-tree-art"> <a style="text-decoration: none;" href="#adaptive-radix-tree-art">Adaptive Radix Tree (ART)</a> </h3> <p>An <a href="https://db.in.tum.de/~leis/papers/ART.pdf">Adaptive Radix Tree (ART)</a> is mainly used to ensure primary key constraints and to speed up point and very highly selective (i.e., &lt; 0.1%) queries. ART indexes are automatically created for columns with a <code class="language-plaintext highlighter-rouge">UNIQUE</code> or <code class="language-plaintext highlighter-rouge">PRIMARY KEY</code> constraint and can be defined using <code class="language-plaintext highlighter-rouge">CREATE INDEX</code>.</p> <blockquote> <p>Warning ART indexes must currently be able to fit in-memory. Avoid creating ART indexes if the index does not fit in memory.</p> </blockquote> <h3 id="indexes-defined-by-extensions"> <a style="text-decoration: none;" href="#indexes-defined-by-extensions">Indexes Defined by Extensions</a> </h3> <p><a href="http://localhost:8000/2024/09/09/announcing-duckdb-110.html#r-tree">Starting with version 1.1.0</a>, DuckDB supports <a href="../extensions/spatial/r-tree_indexes.html">R-trees for spatial indexing</a> via the <code class="language-plaintext highlighter-rouge">spatial</code> extension.</p> <h2 id="persistence"> <a style="text-decoration: none;" href="#persistence">Persistence</a> </h2> <p>Both min-max indexes and ART indexes are persisted on disk.</p> <h2 id="create-index-and-drop-index"> <a style="text-decoration: none;" href="#create-index-and-drop-index"><code class="language-plaintext highlighter-rouge">CREATE INDEX</code> and <code class="language-plaintext highlighter-rouge">DROP INDEX</code></a> </h2> <p>To create an index, use the <a href="statements/create_index.html#create-index.html"><code class="language-plaintext highlighter-rouge">CREATE INDEX</code> statement</a>. To drop an index, use the <a href="statements/create_index.html#drop-index.html"><code class="language-plaintext highlighter-rouge">DROP INDEX</code> statement</a>.</p> <h2 id="limitations-of-art-indexes"> <a style="text-decoration: none;" href="#limitations-of-art-indexes">Limitations of ART Indexes</a> </h2> <p>ART indexes create a secondary copy of the data in a second location – this complicates processing, particularly when combined with transactions. Certain limitations apply when it comes to modifying data that is also stored in secondary indexes.</p> <blockquote> <p>As expected, indexes have a strong effect on performance, slowing down loading and updates, but speeding up certain queries. Please consult the <a href="../guides/performance/indexing.html">Performance Guide</a> for details.</p> </blockquote> <h3 id="updates-become-deletes-and-inserts"> <a style="text-decoration: none;" href="#updates-become-deletes-and-inserts">Updates Become Deletes and Inserts</a> </h3> <p>When an update statement is executed on a column that is present in an index, the statement is transformed into a <em>delete</em> of the original row followed by an <em>insert</em>. This has certain performance implications, particularly for wide tables, as entire rows are rewritten instead of only the affected columns.</p> <h3 id="over-eager-unique-constraint-checking"> <a style="text-decoration: none;" href="#over-eager-unique-constraint-checking">Over-Eager Unique Constraint Checking</a> </h3> <p>Due to the presence of transactions, data can only be removed from the index after (1) the transaction that performed the delete is committed, and (2) no further transactions exist that refer to the old entry still present in the index. As a result of this – transactions that perform <em>deletions followed by insertions</em> may trigger unexpected unique constraint violations, as the deleted tuple has not actually been removed from the index yet. For example:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE students (id INTEGER, name VARCHAR);
INSERT INTO students VALUES (1, 'John Doe');
CREATE UNIQUE INDEX students_id ON students (id);

BEGIN; -- start transaction
DELETE FROM students WHERE id = 1;
INSERT INTO students VALUES (1, 'Jane Doe');</pre> <p>The last statement fails with the following error:</p> <pre class="language-console highlighter-rouge" data-language="console">Constraint Error: Duplicate key "id: 1" violates unique constraint. If this is an unexpected constraint violation please double check with the known index limitations section in our documentation (https://duckdb.org/docs/sql/indexes).</pre> <p>This, combined with the fact that updates are turned into deletions and insertions within the same transaction, means that updating rows in the presence of unique or primary key constraints can often lead to unexpected unique constraint violations. For example, in the following query, <code class="language-plaintext highlighter-rouge">SET id = 1</code> causes a <code class="language-plaintext highlighter-rouge">Constraint Error</code> to occur.</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE students (id INTEGER PRIMARY KEY, name VARCHAR);
INSERT INTO students VALUES (1, 'John Doe');

UPDATE students SET id = 1 WHERE id = 1;</pre> <pre class="language-console highlighter-rouge" data-language="console">Constraint Error: Duplicate key "id: 1" violates primary key constraint.
If this is an unexpected constraint violation please double check with the known index limitations section in our documentation (https://duckdb.org/docs/sql/indexes).</pre> <p>Currently, this is an expected limitation of DuckDB – although we aim to resolve this in the future.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; Copyright 2018&ndash;2024 Stichting DuckDB Foundation<br>Licensed under the MIT License.<br>
    <a href="https://duckdb.org/docs/sql/indexes.html" class="_attribution-link">https://duckdb.org/docs/sql/indexes.html</a>
  </p>
</div>
