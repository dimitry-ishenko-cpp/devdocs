<h1 class="title">Union Type</h1>  <p>A <code class="language-plaintext highlighter-rouge">UNION</code> <em>type</em> (not to be confused with the SQL <a href="../query_syntax/setops.html#union-all-by-name.html"><code class="language-plaintext highlighter-rouge">UNION</code> operator</a>) is a nested type capable of holding one of multiple “alternative” values, much like the <code class="language-plaintext highlighter-rouge">union</code> in C. The main difference being that these <code class="language-plaintext highlighter-rouge">UNION</code> types are <em>tagged unions</em> and thus always carry a discriminator “tag” which signals which alternative it is currently holding, even if the inner value itself is null. <code class="language-plaintext highlighter-rouge">UNION</code> types are thus more similar to C++17's <code class="language-plaintext highlighter-rouge">std::variant</code>, Rust's <code class="language-plaintext highlighter-rouge">Enum</code> or the “sum type” present in most functional languages.</p> <p><code class="language-plaintext highlighter-rouge">UNION</code> types must always have at least one member, and while they can contain multiple members of the same type, the tag names must be unique. <code class="language-plaintext highlighter-rouge">UNION</code> types can have at most 256 members.</p> <p>Under the hood, <code class="language-plaintext highlighter-rouge">UNION</code> types are implemented on top of <code class="language-plaintext highlighter-rouge">STRUCT</code> types, and simply keep the “tag” as the first entry.</p> <p><code class="language-plaintext highlighter-rouge">UNION</code> values can be created with the <a href="../functions/union.html"><code class="language-plaintext highlighter-rouge">union_value(tag := expr)</code></a> function or by <a href="#casting-to-unions">casting from a member type</a>.</p> <h2 id="example"> <a style="text-decoration: none;" href="#example">Example</a> </h2> <p>Create a table with a <code class="language-plaintext highlighter-rouge">UNION</code> column:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE tbl1 (u UNION(num INTEGER, str VARCHAR));
INSERT INTO tbl1 values (1), ('two'), (union_value(str := 'three'));</pre> <p>Any type can be implicitly cast to a <code class="language-plaintext highlighter-rouge">UNION</code> containing the type. Any <code class="language-plaintext highlighter-rouge">UNION</code> can also be implicitly cast to another <code class="language-plaintext highlighter-rouge">UNION</code> if the source <code class="language-plaintext highlighter-rouge">UNION</code> members are a subset of the target's (if the cast is unambiguous).</p> <p><code class="language-plaintext highlighter-rouge">UNION</code> uses the member types' <code class="language-plaintext highlighter-rouge">VARCHAR</code> cast functions when casting to <code class="language-plaintext highlighter-rouge">VARCHAR</code>:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT u FROM tbl1;</pre> <table> <thead> <tr> <th>u</th> </tr> </thead> <tbody> <tr> <td>1</td> </tr> <tr> <td>two</td> </tr> <tr> <td>three</td> </tr> </tbody> </table> <p>Select all the <code class="language-plaintext highlighter-rouge">str</code> members:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT union_extract(u, 'str') AS str
FROM tbl1;</pre> <table> <thead> <tr> <th>str</th> </tr> </thead> <tbody> <tr> <td>NULL</td> </tr> <tr> <td>two</td> </tr> <tr> <td>three</td> </tr> </tbody> </table> <p>Alternatively, you can use 'dot syntax' similarly to <a href="struct.html"><code class="language-plaintext highlighter-rouge">STRUCT</code>s</a>.</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT u.str
FROM tbl1;</pre> <table> <thead> <tr> <th>str</th> </tr> </thead> <tbody> <tr> <td>NULL</td> </tr> <tr> <td>two</td> </tr> <tr> <td>three</td> </tr> </tbody> </table> <p>Select the currently active tag from the <code class="language-plaintext highlighter-rouge">UNION</code> as an <code class="language-plaintext highlighter-rouge">ENUM</code>.</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT union_tag(u) AS t
FROM tbl1;</pre> <table> <thead> <tr> <th>t</th> </tr> </thead> <tbody> <tr> <td>num</td> </tr> <tr> <td>str</td> </tr> <tr> <td>str</td> </tr> </tbody> </table> <h2 id="union-casts"> <a style="text-decoration: none;" href="#union-casts">Union Casts</a> </h2> <p>Compared to other nested types, <code class="language-plaintext highlighter-rouge">UNION</code>s allow a set of implicit casts to facilitate unintrusive and natural usage when working with their members as “subtypes”. However, these casts have been designed with two principles in mind, to avoid ambiguity and to avoid casts that could lead to loss of information. This prevents <code class="language-plaintext highlighter-rouge">UNION</code>s from being completely “transparent”, while still allowing <code class="language-plaintext highlighter-rouge">UNION</code> types to have a “supertype” relationship with their members.</p> <p>Thus <code class="language-plaintext highlighter-rouge">UNION</code> types can't be implicitly cast to any of their member types in general, since the information in the other members not matching the target type would be “lost”. If you want to coerce a <code class="language-plaintext highlighter-rouge">UNION</code> into one of its members, you should use the <code class="language-plaintext highlighter-rouge">union_extract</code> function explicitly instead.</p> <p>The only exception to this is when casting a <code class="language-plaintext highlighter-rouge">UNION</code> to <code class="language-plaintext highlighter-rouge">VARCHAR</code>, in which case the members will all use their corresponding <code class="language-plaintext highlighter-rouge">VARCHAR</code> casts. Since everything can be cast to <code class="language-plaintext highlighter-rouge">VARCHAR</code>, this is “safe” in a sense.</p> <h3 id="casting-to-unions"> <a style="text-decoration: none;" href="#casting-to-unions">Casting to Unions</a> </h3> <p>A type can always be implicitly cast to a <code class="language-plaintext highlighter-rouge">UNION</code> if it can be implicitly cast to one of the <code class="language-plaintext highlighter-rouge">UNION</code> member types.</p> <ul> <li>If there are multiple candidates, the built in implicit casting priority rules determine the target type. For example, a <code class="language-plaintext highlighter-rouge">FLOAT</code> → <code class="language-plaintext highlighter-rouge">UNION(i INTEGER, v VARCHAR)</code> cast will always cast the <code class="language-plaintext highlighter-rouge">FLOAT</code> to the <code class="language-plaintext highlighter-rouge">INTEGER</code> member before <code class="language-plaintext highlighter-rouge">VARCHAR</code>.</li> <li>If the cast still is ambiguous, i.e., there are multiple candidates with the same implicit casting priority, an error is raised. This usually happens when the <code class="language-plaintext highlighter-rouge">UNION</code> contains multiple members of the same type, e.g., a <code class="language-plaintext highlighter-rouge">FLOAT</code> → <code class="language-plaintext highlighter-rouge">UNION(i INTEGER, num INTEGER)</code> is always ambiguous.</li> </ul> <p>So how do we disambiguate if we want to create a <code class="language-plaintext highlighter-rouge">UNION</code> with multiple members of the same type? By using the <code class="language-plaintext highlighter-rouge">union_value</code> function, which takes a keyword argument specifying the tag. For example, <code class="language-plaintext highlighter-rouge">union_value(num := 2::INTEGER)</code> will create a <code class="language-plaintext highlighter-rouge">UNION</code> with a single member of type <code class="language-plaintext highlighter-rouge">INTEGER</code> with the tag <code class="language-plaintext highlighter-rouge">num</code>. This can then be used to disambiguate in an explicit (or implicit, read on below!) <code class="language-plaintext highlighter-rouge">UNION</code> to <code class="language-plaintext highlighter-rouge">UNION</code> cast, like <code class="language-plaintext highlighter-rouge">CAST(union_value(b := 2) AS UNION(a INTEGER, b INTEGER))</code>.</p> <h3 id="casting-between-unions"> <a style="text-decoration: none;" href="#casting-between-unions">Casting between Unions</a> </h3> <p><code class="language-plaintext highlighter-rouge">UNION</code> types can be cast between each other if the source type is a “subset” of the target type. In other words, all the tags in the source <code class="language-plaintext highlighter-rouge">UNION</code> must be present in the target <code class="language-plaintext highlighter-rouge">UNION</code>, and all the types of the matching tags must be implicitly castable between source and target. In essence, this means that <code class="language-plaintext highlighter-rouge">UNION</code> types are covariant with respect to their members.</p>  <table> <thead> <tr> <th>Ok</th> <th>Source</th> <th>Target</th> <th>Comments</th> </tr> </thead> <tbody> <tr> <td>✅</td> <td><code class="language-plaintext highlighter-rouge">UNION(a A, b B)</code></td> <td><code class="language-plaintext highlighter-rouge">UNION(a A, b B, c C)</code></td> <td> </td> </tr> <tr> <td>✅</td> <td><code class="language-plaintext highlighter-rouge">UNION(a A, b B)</code></td> <td><code class="language-plaintext highlighter-rouge">UNION(a A, b C)</code></td> <td>if <code class="language-plaintext highlighter-rouge">B</code> can be implicitly cast to <code class="language-plaintext highlighter-rouge">C</code>
</td> </tr> <tr> <td>❌</td> <td><code class="language-plaintext highlighter-rouge">UNION(a A, b B, c C)</code></td> <td><code class="language-plaintext highlighter-rouge">UNION(a A, b B)</code></td> <td> </td> </tr> <tr> <td>❌</td> <td><code class="language-plaintext highlighter-rouge">UNION(a A, b B)</code></td> <td><code class="language-plaintext highlighter-rouge">UNION(a A, b C)</code></td> <td>if <code class="language-plaintext highlighter-rouge">B</code> can't be implicitly cast to <code class="language-plaintext highlighter-rouge">C</code>
</td> </tr> <tr> <td>❌</td> <td><code class="language-plaintext highlighter-rouge">UNION(A, B, D)</code></td> <td><code class="language-plaintext highlighter-rouge">UNION(A, B, C)</code></td> <td> </td> </tr> </tbody> </table> <h2 id="comparison-and-sorting"> <a style="text-decoration: none;" href="#comparison-and-sorting">Comparison and Sorting</a> </h2> <p>Since <code class="language-plaintext highlighter-rouge">UNION</code> types are implemented on top of <code class="language-plaintext highlighter-rouge">STRUCT</code> types internally, they can be used with all the comparison operators as well as in both <code class="language-plaintext highlighter-rouge">WHERE</code> and <code class="language-plaintext highlighter-rouge">HAVING</code> clauses with <a href="struct.html#comparison-operators.html">the same semantics as <code class="language-plaintext highlighter-rouge">STRUCT</code>s</a>. The “tag” is always stored as the first struct entry, which ensures that the <code class="language-plaintext highlighter-rouge">UNION</code> types are compared and ordered by “tag” first.</p> <h2 id="functions"> <a style="text-decoration: none;" href="#functions">Functions</a> </h2> <p>See <a href="../functions/union.html">Union Functions</a>.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; Copyright 2018&ndash;2024 Stichting DuckDB Foundation<br>Licensed under the MIT License.<br>
    <a href="https://duckdb.org/docs/sql/data_types/union.html" class="_attribution-link">https://duckdb.org/docs/sql/data_types/union.html</a>
  </p>
</div>
