<h1 class="title">Struct Data Type</h1>  <p>Conceptually, a <code class="language-plaintext highlighter-rouge">STRUCT</code> column contains an ordered list of columns called “entries”. The entries are referenced by name using strings. This document refers to those entry names as keys. Each row in the <code class="language-plaintext highlighter-rouge">STRUCT</code> column must have the same keys. The names of the struct entries are part of the <em>schema</em>. Each row in a <code class="language-plaintext highlighter-rouge">STRUCT</code> column must have the same layout. The names of the struct entries are case-insensitive.</p> <p><code class="language-plaintext highlighter-rouge">STRUCT</code>s are typically used to nest multiple columns into a single column, and the nested column can be of any type, including other <code class="language-plaintext highlighter-rouge">STRUCT</code>s and <code class="language-plaintext highlighter-rouge">LIST</code>s.</p> <p><code class="language-plaintext highlighter-rouge">STRUCT</code>s are similar to PostgreSQL's <code class="language-plaintext highlighter-rouge">ROW</code> type. The key difference is that DuckDB <code class="language-plaintext highlighter-rouge">STRUCT</code>s require the same keys in each row of a <code class="language-plaintext highlighter-rouge">STRUCT</code> column. This allows DuckDB to provide significantly improved performance by fully utilizing its vectorized execution engine, and also enforces type consistency for improved correctness. DuckDB includes a <code class="language-plaintext highlighter-rouge">row</code> function as a special way to produce a <code class="language-plaintext highlighter-rouge">STRUCT</code>, but does not have a <code class="language-plaintext highlighter-rouge">ROW</code> data type. See an example below and the <a href="../functions/struct.html"><code class="language-plaintext highlighter-rouge">STRUCT</code> functions documentation</a> for details.</p> <p><code class="language-plaintext highlighter-rouge">STRUCT</code>s have a fixed schema. It is not possible to change the schema of a <code class="language-plaintext highlighter-rouge">STRUCT</code> using <code class="language-plaintext highlighter-rouge">UPDATE</code> operations.</p> <p>See the <a href="overview.html">data types overview</a> for a comparison between nested data types.</p> <h3 id="creating-structs"> <a style="text-decoration: none;" href="#creating-structs">Creating Structs</a> </h3> <p>Structs can be created using the <a href="../functions/struct.html"><code class="language-plaintext highlighter-rouge">struct_pack(name := expr, ...)</code></a> function, the equivalent array notation <code class="language-plaintext highlighter-rouge">{'name': expr, ...}</code>, using a row variable, or using the <code class="language-plaintext highlighter-rouge">row</code> function.</p> <p>Create a struct using the <code class="language-plaintext highlighter-rouge">struct_pack</code> function. Note the lack of single quotes around the keys and the use of the <code class="language-plaintext highlighter-rouge">:=</code> operator:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT struct_pack(key1 := 'value1', key2 := 42) AS s;</pre> <p>Create a struct using the array notation:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT {'key1': 'value1', 'key2': 42} AS s;</pre> <p>Create a struct using a row variable:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT d AS s FROM (SELECT 'value1' AS key1, 42 AS key2) d;</pre> <p>Create a struct of integers:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT {'x': 1, 'y': 2, 'z': 3} AS s;</pre> <p>Create a struct of strings with a <code class="language-plaintext highlighter-rouge">NULL</code> value:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT {'yes': 'duck', 'maybe': 'goose', 'huh': NULL, 'no': 'heron'} AS s;</pre> <p>Create a struct with a different type for each key:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT {'key1': 'string', 'key2': 1, 'key3': 12.345} AS s;</pre> <p>Create a struct of structs with <code class="language-plaintext highlighter-rouge">NULL</code> values:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT {
        'birds': {'yes': 'duck', 'maybe': 'goose', 'huh': NULL, 'no': 'heron'},
        'aliens': NULL,
        'amphibians': {'yes': 'frog', 'maybe': 'salamander', 'huh': 'dragon', 'no': 'toad'}
    } AS s;</pre> <h3 id="adding-fieldsvalues-to-structs"> <a style="text-decoration: none;" href="#adding-fieldsvalues-to-structs">Adding Field(s)/Value(s) to Structs</a> </h3> <p>Add to a struct of integers:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT struct_insert({'a': 1, 'b': 2, 'c': 3}, d := 4) AS s;</pre> <h3 id="retrieving-from-structs"> <a style="text-decoration: none;" href="#retrieving-from-structs">Retrieving from Structs</a> </h3> <p>Retrieving a value from a struct can be accomplished using dot notation, bracket notation, or through <a href="../functions/struct.html">struct functions</a> like <code class="language-plaintext highlighter-rouge">struct_extract</code>.</p> <p>Use dot notation to retrieve the value at a key's location. In the following query, the subquery generates a struct column <code class="language-plaintext highlighter-rouge">a</code>, which we then query with <code class="language-plaintext highlighter-rouge">a.x</code>.</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT a.x FROM (SELECT {'x': 1, 'y': 2, 'z': 3} AS a);</pre> <p>If a key contains a space, simply wrap it in double quotes (<code class="language-plaintext highlighter-rouge">"</code>).</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT a."x space" FROM (SELECT {'x space': 1, 'y': 2, 'z': 3} AS a);</pre> <p>Bracket notation may also be used. Note that this uses single quotes (<code class="language-plaintext highlighter-rouge">'</code>) since the goal is to specify a certain string key and only constant expressions may be used inside the brackets (no expressions):</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT a['x space'] FROM (SELECT {'x space': 1, 'y': 2, 'z': 3} AS a);</pre> <p>The struct_extract function is also equivalent. This returns 1:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT struct_extract({'x space': 1, 'y': 2, 'z': 3}, 'x space');</pre> <h4 id="struct"> <a style="text-decoration: none;" href="#struct"><code class="language-plaintext highlighter-rouge">STRUCT.*</code></a> </h4> <p>Rather than retrieving a single key from a struct, star notation (<code class="language-plaintext highlighter-rouge">*</code>) can be used to retrieve all keys from a struct as separate columns. This is particularly useful when a prior operation creates a struct of unknown shape, or if a query must handle any potential struct keys.</p> <p>All keys within a struct can be returned as separate columns using <code class="language-plaintext highlighter-rouge">*</code>:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT a.*
FROM (SELECT {'x': 1, 'y': 2, 'z': 3} AS a);</pre>  <table> <thead> <tr> <th style="text-align: left">x</th> <th style="text-align: left">y</th> <th style="text-align: left">z</th> </tr> </thead> <tbody> <tr> <td style="text-align: left">1</td> <td style="text-align: left">2</td> <td style="text-align: left">3</td> </tr> </tbody> </table> <h3 id="dot-notation-order-of-operations"> <a style="text-decoration: none;" href="#dot-notation-order-of-operations">Dot Notation Order of Operations</a> </h3> <p>Referring to structs with dot notation can be ambiguous with referring to schemas and tables. In general, DuckDB looks for columns first, then for struct keys within columns. DuckDB resolves references in these orders, using the first match to occur:</p> <h4 id="no-dots"> <a style="text-decoration: none;" href="#no-dots">No Dots</a> </h4> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT part1
FROM tbl;</pre> <ol> <li>
<code class="language-plaintext highlighter-rouge">part1</code> is a column</li> </ol> <h4 id="one-dot"> <a style="text-decoration: none;" href="#one-dot">One Dot</a> </h4> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT part1.part2
FROM tbl;</pre> <ol> <li>
<code class="language-plaintext highlighter-rouge">part1</code> is a table, <code class="language-plaintext highlighter-rouge">part2</code> is a column</li> <li>
<code class="language-plaintext highlighter-rouge">part1</code> is a column, <code class="language-plaintext highlighter-rouge">part2</code> is a property of that column</li> </ol> <h4 id="two-or-more-dots"> <a style="text-decoration: none;" href="#two-or-more-dots">Two (or More) Dots</a> </h4> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT part1.part2.part3
FROM tbl;</pre> <ol> <li>
<code class="language-plaintext highlighter-rouge">part1</code> is a schema, <code class="language-plaintext highlighter-rouge">part2</code> is a table, <code class="language-plaintext highlighter-rouge">part3</code> is a column</li> <li>
<code class="language-plaintext highlighter-rouge">part1</code> is a table, <code class="language-plaintext highlighter-rouge">part2</code> is a column, <code class="language-plaintext highlighter-rouge">part3</code> is a property of that column</li> <li>
<code class="language-plaintext highlighter-rouge">part1</code> is a column, <code class="language-plaintext highlighter-rouge">part2</code> is a property of that column, <code class="language-plaintext highlighter-rouge">part3</code> is a property of that column</li> </ol> <p>Any extra parts (e.g., <code class="language-plaintext highlighter-rouge">.part4.part5</code>, etc.) are always treated as properties</p> <h3 id="creating-structs-with-the-row-function"> <a style="text-decoration: none;" href="#creating-structs-with-the-row-function">Creating Structs with the <code class="language-plaintext highlighter-rouge">row</code> Function</a> </h3> <p>The <code class="language-plaintext highlighter-rouge">row</code> function can be used to automatically convert multiple columns to a single struct column. When using <code class="language-plaintext highlighter-rouge">row</code> the keys will be empty strings allowing for easy insertion into a table with a struct column. Columns, however, cannot be initialized with the <code class="language-plaintext highlighter-rouge">row</code> function, and must be explicitly named. For example, inserting values into a struct column using the <code class="language-plaintext highlighter-rouge">row</code> function:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE t1 (s STRUCT(v VARCHAR, i INTEGER));
INSERT INTO t1 VALUES (row('a', 42));
SELECT * FROM t1;</pre> <p>The table will contain a single entry:</p> <pre class="language-sql highlighter-rouge" data-language="sql">{'v': a, 'i': 42}</pre> <p>The following produces the same result as above:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE t1 AS (
    SELECT row('a', 42)::STRUCT(v VARCHAR, i INTEGER)
);</pre> <p>Initializing a struct column with the <code class="language-plaintext highlighter-rouge">row</code> function will fail:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE t2 AS SELECT row('a');</pre> <pre class="language-console highlighter-rouge" data-language="console">Invalid Input Error: A table cannot be created from an unnamed struct</pre> <p>When casting structs, the names of fields have to match. Therefore, the following query will fail:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT a::STRUCT(y INTEGER) AS b
FROM
    (SELECT {'x': 42} AS a);</pre> <pre class="language-console highlighter-rouge" data-language="console">Mismatch Type Error: Type STRUCT(x INTEGER) does not match with STRUCT(y INTEGER). Cannot cast STRUCTs - element "x" in source struct was not found in target struct</pre> <p>A workaround for this is to use <a href="#creating-structs"><code class="language-plaintext highlighter-rouge">struct_pack</code></a> instead:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT struct_pack(y := a.x) AS b
FROM
    (SELECT {'x': 42} AS a);</pre> <p>The <code class="language-plaintext highlighter-rouge">row</code> function can be used to return unnamed structs. For example:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT row(x, x + 1, y) FROM (SELECT 1 AS x, 'a' AS y) AS s;</pre> <p>This produces <code class="language-plaintext highlighter-rouge">(1, 2, a)</code>.</p> <p>If using multiple expressions when creating a struct, the <code class="language-plaintext highlighter-rouge">row</code> function is optional. The following query returns the same result as the previous one:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT (x, x + 1, y) AS s FROM (SELECT 1 AS x, 'a' AS y);</pre> <h2 id="comparison-and-ordering"> <a style="text-decoration: none;" href="#comparison-and-ordering">Comparison and Ordering</a> </h2> <p>The <code class="language-plaintext highlighter-rouge">STRUCT</code> type can be compared using all the <a href="../expressions/comparison_operators.html">comparison operators</a>. These comparisons can be used in <a href="../expressions/logical_operators.html">logical expressions</a> such as <code class="language-plaintext highlighter-rouge">WHERE</code> and <code class="language-plaintext highlighter-rouge">HAVING</code> clauses, and return <a href="boolean.html"><code class="language-plaintext highlighter-rouge">BOOLEAN</code> values</a>.</p> <p>For comparisons, the keys of a <code class="language-plaintext highlighter-rouge">STRUCT</code> have a fixed positional order, from left to right. Comparisons behave the same as row comparisons, therefore, matching keys must be at identical positions.</p> <p>Specifically, for any <code class="language-plaintext highlighter-rouge">STRUCT</code> comparison, the following rules apply:</p> <ul> <li>
<strong>Equality.</strong> <code class="language-plaintext highlighter-rouge">s1</code> and <code class="language-plaintext highlighter-rouge">s2</code> are equal, if all respective values are equal.</li> <li>
<strong>Less Than</strong>. For the first index <code class="language-plaintext highlighter-rouge">i</code> where <code class="language-plaintext highlighter-rouge">s1.value[i] != s2.value[i]</code>: If <code class="language-plaintext highlighter-rouge">s1.value[i] &lt; s2.value[i]</code>, <code class="language-plaintext highlighter-rouge">s1</code> is less than <code class="language-plaintext highlighter-rouge">s2</code>.</li> </ul> <p><code class="language-plaintext highlighter-rouge">NULL</code> values are compared following PostgreSQL's semantics. Lower nesting levels are used for tie-breaking.</p> <p>Here are some queries returning <code class="language-plaintext highlighter-rouge">true</code> for the comparison.</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT {'k1': 2, 'k2': 3} &lt; {'k1': 2, 'k2': 4} AS result;</pre> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT {'k1': 'hello'} &lt; {'k1': 'world'} AS result;</pre> <p>These queries return <code class="language-plaintext highlighter-rouge">false</code>.</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT {'k2': 4, 'k1': 3} &lt; {'k2': 2, 'k1': 4} AS result;</pre> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT {'k1': [4, 3]} &lt; {'k1': [3, 6, 7]} AS result;</pre> <p>These queries return <code class="language-plaintext highlighter-rouge">NULL</code>.</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT {'k1': 2, 'k2': 3} &lt; {'k1': 2, 'k2': NULL} AS result;</pre> <p>This query returns a <code class="language-plaintext highlighter-rouge">Binder Error</code> because the keys do not match positionally.</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT {'k1': 2, 'k2': 3} &lt; {'k2': 2, 'k1': 4} AS result;</pre> <pre class="language-console highlighter-rouge" data-language="console">Binder Error: Cannot compare values of type STRUCT(k1 INTEGER, k2 INTEGER)
and type STRUCT(k2 INTEGER, k1 INTEGER) - an explicit cast is required</pre> <h2 id="functions"> <a style="text-decoration: none;" href="#functions">Functions</a> </h2> <p>See <a href="../functions/struct.html">Struct Functions</a>.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; Copyright 2018&ndash;2024 Stichting DuckDB Foundation<br>Licensed under the MIT License.<br>
    <a href="https://duckdb.org/docs/sql/data_types/struct.html" class="_attribution-link">https://duckdb.org/docs/sql/data_types/struct.html</a>
  </p>
</div>
