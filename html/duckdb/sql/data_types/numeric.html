<h1 class="title">Numeric Types</h1>  <h2 id="integer-types"> <a style="text-decoration: none;" href="#integer-types">Integer Types</a> </h2> <p>The types <code class="language-plaintext highlighter-rouge">TINYINT</code>, <code class="language-plaintext highlighter-rouge">SMALLINT</code>, <code class="language-plaintext highlighter-rouge">INTEGER</code>, <code class="language-plaintext highlighter-rouge">BIGINT</code> and <code class="language-plaintext highlighter-rouge">HUGEINT</code> store whole numbers, that is, numbers without fractional components, of various ranges. Attempts to store values outside of the allowed range will result in an error. The types <code class="language-plaintext highlighter-rouge">UTINYINT</code>, <code class="language-plaintext highlighter-rouge">USMALLINT</code>, <code class="language-plaintext highlighter-rouge">UINTEGER</code>, <code class="language-plaintext highlighter-rouge">UBIGINT</code> and <code class="language-plaintext highlighter-rouge">UHUGEINT</code> store whole unsigned numbers. Attempts to store negative numbers or values outside of the allowed range will result in an error.</p> <table> <thead> <tr> <th style="text-align: left">Name</th> <th style="text-align: left">Aliases</th> <th style="text-align: right">Min</th> <th style="text-align: right">Max</th> </tr> </thead> <tbody> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">TINYINT</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">INT1</code></td> <td style="text-align: right">-128</td> <td style="text-align: right">127</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">SMALLINT</code></td> <td style="text-align: left">
<code class="language-plaintext highlighter-rouge">INT2</code>, <code class="language-plaintext highlighter-rouge">INT16</code> <code class="language-plaintext highlighter-rouge">SHORT</code>
</td> <td style="text-align: right">-32768</td> <td style="text-align: right">32767</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">INTEGER</code></td> <td style="text-align: left">
<code class="language-plaintext highlighter-rouge">INT4</code>, <code class="language-plaintext highlighter-rouge">INT32</code>, <code class="language-plaintext highlighter-rouge">INT</code>, <code class="language-plaintext highlighter-rouge">SIGNED</code>
</td> <td style="text-align: right">-2147483648</td> <td style="text-align: right">2147483647</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">BIGINT</code></td> <td style="text-align: left">
<code class="language-plaintext highlighter-rouge">INT8</code>, <code class="language-plaintext highlighter-rouge">INT64</code> <code class="language-plaintext highlighter-rouge">LONG</code>
</td> <td style="text-align: right">-9223372036854775808</td> <td style="text-align: right">9223372036854775807</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">HUGEINT</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">INT128</code></td> <td style="text-align: right">-170141183460469231731687303715884105728</td> <td style="text-align: right">170141183460469231731687303715884105727</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">UTINYINT</code></td> <td style="text-align: left">-</td> <td style="text-align: right">0</td> <td style="text-align: right">255</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">USMALLINT</code></td> <td style="text-align: left">-</td> <td style="text-align: right">0</td> <td style="text-align: right">65535</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">UINTEGER</code></td> <td style="text-align: left">-</td> <td style="text-align: right">0</td> <td style="text-align: right">4294967295</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">UBIGINT</code></td> <td style="text-align: left">-</td> <td style="text-align: right">0</td> <td style="text-align: right">18446744073709551615</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">UHUGEINT</code></td> <td style="text-align: left">-</td> <td style="text-align: right">0</td> <td style="text-align: right">340282366920938463463374607431768211455</td> </tr> </tbody> </table> <p>The type integer is the common choice, as it offers the best balance between range, storage size, and performance. The <code class="language-plaintext highlighter-rouge">SMALLINT</code> type is generally only used if disk space is at a premium. The <code class="language-plaintext highlighter-rouge">BIGINT</code> and <code class="language-plaintext highlighter-rouge">HUGEINT</code> types are designed to be used when the range of the integer type is insufficient.</p> <h2 id="fixed-point-decimals"> <a style="text-decoration: none;" href="#fixed-point-decimals">Fixed-Point Decimals</a> </h2> <p>The data type <code class="language-plaintext highlighter-rouge">DECIMAL(WIDTH, SCALE)</code> (also available under the alias <code class="language-plaintext highlighter-rouge">NUMERIC(WIDTH, SCALE)</code>) represents an exact fixed-point decimal value. When creating a value of type <code class="language-plaintext highlighter-rouge">DECIMAL</code>, the <code class="language-plaintext highlighter-rouge">WIDTH</code> and <code class="language-plaintext highlighter-rouge">SCALE</code> can be specified to define which size of decimal values can be held in the field. The <code class="language-plaintext highlighter-rouge">WIDTH</code> field determines how many digits can be held, and the <code class="language-plaintext highlighter-rouge">scale</code> determines the amount of digits after the decimal point. For example, the type <code class="language-plaintext highlighter-rouge">DECIMAL(3, 2)</code> can fit the value <code class="language-plaintext highlighter-rouge">1.23</code>, but cannot fit the value <code class="language-plaintext highlighter-rouge">12.3</code> or the value <code class="language-plaintext highlighter-rouge">1.234</code>. The default <code class="language-plaintext highlighter-rouge">WIDTH</code> and <code class="language-plaintext highlighter-rouge">SCALE</code> is <code class="language-plaintext highlighter-rouge">DECIMAL(18, 3)</code>, if none are specified.</p> <p>Internally, decimals are represented as integers depending on their specified <code class="language-plaintext highlighter-rouge">WIDTH</code>.</p>  <table> <thead> <tr> <th style="text-align: left">Width</th> <th style="text-align: left">Internal</th> <th style="text-align: right">Size (bytes)</th> </tr> </thead> <tbody> <tr> <td style="text-align: left">1-4</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">INT16</code></td> <td style="text-align: right">2</td> </tr> <tr> <td style="text-align: left">5-9</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">INT32</code></td> <td style="text-align: right">4</td> </tr> <tr> <td style="text-align: left">10-18</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">INT64</code></td> <td style="text-align: right">8</td> </tr> <tr> <td style="text-align: left">19-38</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">INT128</code></td> <td style="text-align: right">16</td> </tr> </tbody> </table> <p>Performance can be impacted by using too large decimals when not required. In particular decimal values with a width above 19 are slow, as arithmetic involving the <code class="language-plaintext highlighter-rouge">INT128</code> type is much more expensive than operations involving the <code class="language-plaintext highlighter-rouge">INT32</code> or <code class="language-plaintext highlighter-rouge">INT64</code> types. It is therefore recommended to stick with a <code class="language-plaintext highlighter-rouge">WIDTH</code> of <code class="language-plaintext highlighter-rouge">18</code> or below, unless there is a good reason for why this is insufficient.</p> <h2 id="floating-point-types"> <a style="text-decoration: none;" href="#floating-point-types">Floating-Point Types</a> </h2> <p>The data types <code class="language-plaintext highlighter-rouge">FLOAT</code> and <code class="language-plaintext highlighter-rouge">DOUBLE</code> precision are variable-precision numeric types. In practice, these types are usually implementations of IEEE Standard 754 for Binary Floating-Point Arithmetic (single and double precision, respectively), to the extent that the underlying processor, operating system, and compiler support it.</p>  <table> <thead> <tr> <th style="text-align: left">Name</th> <th style="text-align: left">Aliases</th> <th style="text-align: left">Description</th> </tr> </thead> <tbody> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">FLOAT</code></td> <td style="text-align: left">
<code class="language-plaintext highlighter-rouge">FLOAT4</code>, <code class="language-plaintext highlighter-rouge">REAL</code>
</td> <td style="text-align: left">single precision floating-point number (4 bytes)</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">DOUBLE</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">FLOAT8</code></td> <td style="text-align: left">double precision floating-point number (8 bytes)</td> </tr> </tbody> </table> <p>Like for fixed-point data types, conversion from literals or casts from other datatypes to floating-point types stores inputs that cannot be represented exactly as approximations. However, it can be harder to predict what inputs are affected by this. For example, it is not surprising that <code class="language-plaintext highlighter-rouge">1.3::DECIMAL(1, 0) - 0.7::DECIMAL(1, 0) != 0.6::DECIMAL(1, 0)</code> but it may he surprising that <code class="language-plaintext highlighter-rouge">1.3::FLOAT - 0.7::FLOAT != 0.6::FLOAT</code>.</p> <p>Additionally, whereas multiplication, addition, and subtraction of fixed-point decimal data types is exact, these operations are only approximate on floating-point binary data types.</p> <p>For more complex mathematical operations, however, floating-point arithmetic is used internally and more precise results can be obtained if intermediate steps are <em>not</em> cast to fixed point formats of the same width as in- and outputs. For example, <code class="language-plaintext highlighter-rouge">(10::FLOAT / 3::FLOAT)::FLOAT * 3 = 10</code> whereas <code class="language-plaintext highlighter-rouge">(10::DECIMAL(18, 3) / 3::DECIMAL(18, 3))::DECIMAL(18, 3) * 3 = 9.999</code>.</p> <p>In general, we advise that:</p> <ul> <li>If you require exact storage of numbers with a known number of decimal digits and require exact additions, subtractions, and multiplications (such as for monetary amounts), use the <a href="#fixed-point-decimals"><code class="language-plaintext highlighter-rouge">DECIMAL</code> data type</a> or its <code class="language-plaintext highlighter-rouge">NUMERIC</code> alias instead.</li> <li>If you want to do fast or complicated calculations, the floating-point data types may be more appropriate. However, if you use the results for anything important, you should evaluate your implementation carefully for corner cases (ranges, infinities, underflows, invalid operations) that may be handled differently from what you expect and you should familiarize yourself with common floating-point pitfalls. The article <a href="https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html">“What Every Computer Scientist Should Know About Floating-Point Arithmetic” by David Goldberg</a> and <a href="https://randomascii.wordpress.com/2017/06/19/sometimes-floating-point-math-is-perfect/">the floating point series on Bruce Dawson's blog</a> provide excellent starting points.</li> </ul> <p>On most platforms, the <code class="language-plaintext highlighter-rouge">FLOAT</code> type has a range of at least 1E-37 to 1E+37 with a precision of at least 6 decimal digits. The <code class="language-plaintext highlighter-rouge">DOUBLE</code> type typically has a range of around 1E-307 to 1E+308 with a precision of at least 15 digits. Positive numbers outside of these ranges (and negative numbers ourside the mirrored ranges) may cause errors on some platforms but will usually be converted to zero or infinity, respectively.</p> <p>In addition to ordinary numeric values, the floating-point types have several special values representing IEEE 754 special values:</p> <ul> <li>
<code class="language-plaintext highlighter-rouge">Infinity</code>: infinity</li> <li>
<code class="language-plaintext highlighter-rouge">-Infinity</code>: negative infinity</li> <li>
<code class="language-plaintext highlighter-rouge">NaN</code>: not a number</li> </ul> <blockquote> <p>On a machine whose floating-point arithmetic does not follow IEEE 754, these values will probably not work as expected.</p> </blockquote> <p>When writing these values as constants in a SQL command, you must put quotes around them, for example:</p> <pre class="language-sql highlighter-rouge" data-language="sql">UPDATE table
SET x = '-Infinity';</pre> <p>On input, these strings are recognized in a case-insensitive manner.</p> <h2 id="universally-unique-identifiers-uuids"> <a style="text-decoration: none;" href="#universally-unique-identifiers-uuids">Universally Unique Identifiers (<code class="language-plaintext highlighter-rouge">UUID</code>s)</a> </h2> <p>DuckDB supports universally unique identifiers (UUIDs) through the <code class="language-plaintext highlighter-rouge">UUID</code> type. These use 128 bits and are represented internally as <code class="language-plaintext highlighter-rouge">HUGEINT</code> values. When printed, they are shown with lowercase hexadecimal characters, separated by dashes as follows: <code class="language-plaintext highlighter-rouge">⟨8 characters⟩-⟨4 characters⟩-⟨4 characters⟩-⟨4 characters⟩-⟨12 characters⟩</code> (using 36 characters in total including the dashes). For example, <code class="language-plaintext highlighter-rouge">4ac7a9e9-607c-4c8a-84f3-843f0191e3fd</code> is a valid UUID.</p> <p>To generate a new UUID, use the <a href="../functions/utility.html#utility-functions.html"><code class="language-plaintext highlighter-rouge">uuid()</code> utility function</a>.</p> <h2 id="functions"> <a style="text-decoration: none;" href="#functions">Functions</a> </h2> <p>See <a href="../functions/numeric.html">Numeric Functions and Operators</a>.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; Copyright 2018&ndash;2024 Stichting DuckDB Foundation<br>Licensed under the MIT License.<br>
    <a href="https://duckdb.org/docs/sql/data_types/numeric.html" class="_attribution-link">https://duckdb.org/docs/sql/data_types/numeric.html</a>
  </p>
</div>
