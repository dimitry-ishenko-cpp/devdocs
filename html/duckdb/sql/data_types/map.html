<h1 class="title">Map Type</h1>  <p><code class="language-plaintext highlighter-rouge">MAP</code>s are similar to <code class="language-plaintext highlighter-rouge">STRUCT</code>s in that they are an ordered list of “entries” where a key maps to a value. However, <code class="language-plaintext highlighter-rouge">MAP</code>s do not need to have the same keys present for each row, and thus are suitable for other use cases. <code class="language-plaintext highlighter-rouge">MAP</code>s are useful when the schema is unknown beforehand or when the schema varies per row; their flexibility is a key differentiator.</p> <p><code class="language-plaintext highlighter-rouge">MAP</code>s must have a single type for all keys, and a single type for all values. Keys and values can be any type, and the type of the keys does not need to match the type of the values (e.g., a <code class="language-plaintext highlighter-rouge">MAP</code> of <code class="language-plaintext highlighter-rouge">VARCHAR</code> to <code class="language-plaintext highlighter-rouge">INT</code> is valid). <code class="language-plaintext highlighter-rouge">MAP</code>s may not have duplicate keys. <code class="language-plaintext highlighter-rouge">MAP</code>s return an empty list if a key is not found rather than throwing an error as structs do.</p> <p>In contrast, <code class="language-plaintext highlighter-rouge">STRUCT</code>s must have string keys, but each key may have a value of a different type. See the <a href="overview.html">data types overview</a> for a comparison between nested data types.</p> <p>To construct a <code class="language-plaintext highlighter-rouge">MAP</code>, use the bracket syntax preceded by the <code class="language-plaintext highlighter-rouge">MAP</code> keyword.</p> <h2 id="creating-maps"> <a style="text-decoration: none;" href="#creating-maps">Creating Maps</a> </h2> <p>A map with <code class="language-plaintext highlighter-rouge">VARCHAR</code> keys and <code class="language-plaintext highlighter-rouge">INTEGER</code> values. This returns <code class="language-plaintext highlighter-rouge">{key1=10, key2=20, key3=30}</code>:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT MAP {'key1': 10, 'key2': 20, 'key3': 30};</pre> <p>Alternatively use the map_from_entries function. This returns <code class="language-plaintext highlighter-rouge">{key1=10, key2=20, key3=30}</code>:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT map_from_entries([('key1', 10), ('key2', 20), ('key3', 30)]);</pre> <p>A map can be also created using two lists: keys and values. This returns <code class="language-plaintext highlighter-rouge">{key1=10, key2=20, key3=30}</code>:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT MAP(['key1', 'key2', 'key3'], [10, 20, 30]);</pre> <p>A map can also use INTEGER keys and NUMERIC values. This returns <code class="language-plaintext highlighter-rouge">{1=42.001, 5=-32.100}</code>:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT MAP {1: 42.001, 5: -32.1};</pre> <p>Keys and/or values can also be nested types. This returns <code class="language-plaintext highlighter-rouge">{[a, b]=[1.1, 2.2], [c, d]=[3.3, 4.4]}</code>:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT MAP {['a', 'b']: [1.1, 2.2], ['c', 'd']: [3.3, 4.4]};</pre> <p>Create a table with a map column that has INTEGER keys and DOUBLE values:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE tbl (col MAP(INTEGER, DOUBLE));</pre> <h2 id="retrieving-from-maps"> <a style="text-decoration: none;" href="#retrieving-from-maps">Retrieving from Maps</a> </h2> <p><code class="language-plaintext highlighter-rouge">MAP</code>s use bracket notation for retrieving values. Selecting from a <code class="language-plaintext highlighter-rouge">MAP</code> returns a <code class="language-plaintext highlighter-rouge">LIST</code> rather than an individual value, with an empty <code class="language-plaintext highlighter-rouge">LIST</code> meaning that the key was not found.</p> <p>Use bracket notation to retrieve a list containing the value at a key's location. This returns <code class="language-plaintext highlighter-rouge">[5]</code>. Note that the expression in bracket notation must match the type of the map's key:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT MAP {'key1': 5, 'key2': 43}['key1'];</pre> <p>To retrieve the underlying value, use list selection syntax to grab the first element. This returns <code class="language-plaintext highlighter-rouge">5</code>:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT MAP {'key1': 5, 'key2': 43}['key1'][1];</pre> <p>If the element is not in the map, an empty list will be returned. This returns <code class="language-plaintext highlighter-rouge">[]</code>. Note that the expression in bracket notation must match the type of the map's key else an error is returned:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT MAP {'key1': 5, 'key2': 43}['key3'];</pre> <p>The element_at function can also be used to retrieve a map value. This returns <code class="language-plaintext highlighter-rouge">[5]</code>:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT element_at(MAP {'key1': 5, 'key2': 43}, 'key1');</pre> <h2 id="comparison-operators"> <a style="text-decoration: none;" href="#comparison-operators">Comparison Operators</a> </h2> <p>Nested types can be compared using all the <a href="../expressions/comparison_operators.html">comparison operators</a>. These comparisons can be used in <a href="../expressions/logical_operators.html">logical expressions</a> for both <code class="language-plaintext highlighter-rouge">WHERE</code> and <code class="language-plaintext highlighter-rouge">HAVING</code> clauses, as well as for creating <a href="boolean.html">Boolean values</a>.</p> <p>The ordering is defined positionally in the same way that words can be ordered in a dictionary. <code class="language-plaintext highlighter-rouge">NULL</code> values compare greater than all other values and are considered equal to each other.</p> <p>At the top level, <code class="language-plaintext highlighter-rouge">NULL</code> nested values obey standard SQL <code class="language-plaintext highlighter-rouge">NULL</code> comparison rules: comparing a <code class="language-plaintext highlighter-rouge">NULL</code> nested value to a non-<code class="language-plaintext highlighter-rouge">NULL</code> nested value produces a <code class="language-plaintext highlighter-rouge">NULL</code> result. Comparing nested value <em>members</em>, however, uses the internal nested value rules for <code class="language-plaintext highlighter-rouge">NULL</code>s, and a <code class="language-plaintext highlighter-rouge">NULL</code> nested value member will compare above a non-<code class="language-plaintext highlighter-rouge">NULL</code> nested value member.</p> <h2 id="functions"> <a style="text-decoration: none;" href="#functions">Functions</a> </h2> <p>See <a href="../functions/map.html">Map Functions</a>.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; Copyright 2018&ndash;2024 Stichting DuckDB Foundation<br>Licensed under the MIT License.<br>
    <a href="https://duckdb.org/docs/sql/data_types/map.html" class="_attribution-link">https://duckdb.org/docs/sql/data_types/map.html</a>
  </p>
</div>
