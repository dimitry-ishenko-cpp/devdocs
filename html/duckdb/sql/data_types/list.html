<h1 class="title">List Type</h1>  <p>A <code class="language-plaintext highlighter-rouge">LIST</code> column encodes lists of values. Fields in the column can have values with different lengths, but they must all have the same underlying type. <code class="language-plaintext highlighter-rouge">LIST</code>s are typically used to store arrays of numbers, but can contain any uniform data type, including other <code class="language-plaintext highlighter-rouge">LIST</code>s and <code class="language-plaintext highlighter-rouge">STRUCT</code>s.</p> <p><code class="language-plaintext highlighter-rouge">LIST</code>s are similar to PostgreSQL's <code class="language-plaintext highlighter-rouge">ARRAY</code> type. DuckDB uses the <code class="language-plaintext highlighter-rouge">LIST</code> terminology, but some <a href="../functions/list.html"><code class="language-plaintext highlighter-rouge">array_</code> functions</a> are provided for PostgreSQL compatibility.</p> <p>See the <a href="overview.html">data types overview</a> for a comparison between nested data types.</p> <blockquote> <p>For storing fixed-length lists, DuckDB uses the <a href="array.html"><code class="language-plaintext highlighter-rouge">ARRAY</code> type</a>.</p> </blockquote> <h2 id="creating-lists"> <a style="text-decoration: none;" href="#creating-lists">Creating Lists</a> </h2> <p>Lists can be created using the <a href="../functions/list.html#list_valueany-.html"><code class="language-plaintext highlighter-rouge">list_value(expr, ...)</code></a> function or the equivalent bracket notation <code class="language-plaintext highlighter-rouge">[expr, ...]</code>. The expressions can be constants or arbitrary expressions. To create a list from a table column, use the <a href="../functions/aggregates.html#general-aggregate-functions.html"><code class="language-plaintext highlighter-rouge">list</code></a> aggregate function.</p> <p>List of integers:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT [1, 2, 3];</pre> <p>List of strings with a <code class="language-plaintext highlighter-rouge">NULL</code> value:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT ['duck', 'goose', NULL, 'heron'];</pre> <p>List of lists with <code class="language-plaintext highlighter-rouge">NULL</code> values:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT [['duck', 'goose', 'heron'], NULL, ['frog', 'toad'], []];</pre> <p>Create a list with the list_value function:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT list_value(1, 2, 3);</pre> <p>Create a table with an <code class="language-plaintext highlighter-rouge">INTEGER</code> list column and a <code class="language-plaintext highlighter-rouge">VARCHAR</code> list column:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE list_table (int_list INTEGER[], varchar_list VARCHAR[]);</pre> <h2 id="retrieving-from-lists"> <a style="text-decoration: none;" href="#retrieving-from-lists">Retrieving from Lists</a> </h2> <p>Retrieving one or more values from a list can be accomplished using brackets and slicing notation, or through <a href="../functions/list.html">list functions</a> like <code class="language-plaintext highlighter-rouge">list_extract</code>. Multiple equivalent functions are provided as aliases for compatibility with systems that refer to lists as arrays. For example, the function <code class="language-plaintext highlighter-rouge">array_slice</code>.</p> <blockquote> <p>We wrap the list creation in parenthesis so that it happens first. This is only needed in our basic examples here, not when working with a list column. For example, this can't be parsed: <code class="language-plaintext highlighter-rouge">SELECT ['a', 'b', 'c'][1]</code>.</p> </blockquote>  <table> <thead> <tr> <th style="text-align: left">Example</th> <th style="text-align: left">Result</th> </tr> </thead> <tbody> <tr> <td style="text-align: left">SELECT (['a', 'b', 'c'])[3]</td> <td style="text-align: left">'c'</td> </tr> <tr> <td style="text-align: left">SELECT (['a', 'b', 'c'])[-1]</td> <td style="text-align: left">'c'</td> </tr> <tr> <td style="text-align: left">SELECT (['a', 'b', 'c'])[2 + 1]</td> <td style="text-align: left">'c'</td> </tr> <tr> <td style="text-align: left">SELECT list_extract(['a', 'b', 'c'], 3)</td> <td style="text-align: left">'c'</td> </tr> <tr> <td style="text-align: left">SELECT (['a', 'b', 'c'])[1:2]</td> <td style="text-align: left">['a', 'b']</td> </tr> <tr> <td style="text-align: left">SELECT (['a', 'b', 'c'])[:2]</td> <td style="text-align: left">['a', 'b']</td> </tr> <tr> <td style="text-align: left">SELECT (['a', 'b', 'c'])[-2:]</td> <td style="text-align: left">['b', 'c']</td> </tr> <tr> <td style="text-align: left">SELECT list_slice(['a', 'b', 'c'], 2, 3)</td> <td style="text-align: left">['b', 'c']</td> </tr> </tbody> </table> <h2 id="comparison-and-ordering"> <a style="text-decoration: none;" href="#comparison-and-ordering">Comparison and Ordering</a> </h2> <p>The <code class="language-plaintext highlighter-rouge">LIST</code> type can be compared using all the <a href="../expressions/comparison_operators.html">comparison operators</a>. These comparisons can be used in <a href="../expressions/logical_operators.html">logical expressions</a> such as <code class="language-plaintext highlighter-rouge">WHERE</code> and <code class="language-plaintext highlighter-rouge">HAVING</code> clauses, and return <a href="boolean.html"><code class="language-plaintext highlighter-rouge">BOOLEAN</code> values</a>.</p> <p>The <code class="language-plaintext highlighter-rouge">LIST</code> ordering is defined positionally using the following rules, where <code class="language-plaintext highlighter-rouge">min_len = min(len(l1), len(l2))</code>.</p> <ul> <li>
<strong>Equality.</strong> <code class="language-plaintext highlighter-rouge">l1</code> and <code class="language-plaintext highlighter-rouge">l2</code> are equal, if for each <code class="language-plaintext highlighter-rouge">i</code> in <code class="language-plaintext highlighter-rouge">[1, min_len]</code>: <code class="language-plaintext highlighter-rouge">l1[i] = l2[i]</code>.</li> <li>
<strong>Less Than</strong>. For the first index <code class="language-plaintext highlighter-rouge">i</code> in <code class="language-plaintext highlighter-rouge">[1, min_len]</code> where <code class="language-plaintext highlighter-rouge">l1[i] != l2[i]</code>: If <code class="language-plaintext highlighter-rouge">l1[i] &lt; l2[i]</code>, <code class="language-plaintext highlighter-rouge">l1</code> is less than <code class="language-plaintext highlighter-rouge">l2</code>.</li> </ul> <p><code class="language-plaintext highlighter-rouge">NULL</code> values are compared following PostgreSQL's semantics. Lower nesting levels are used for tie-breaking.</p> <p>Here are some queries returning <code class="language-plaintext highlighter-rouge">true</code> for the comparison.</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT [1, 2] &lt; [1, 3] AS result;</pre> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT [[1], [2, 4, 5]] &lt; [[2]] AS result;</pre> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT [ ] &lt; [1] AS result;</pre> <p>These queries return <code class="language-plaintext highlighter-rouge">false</code>.</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT [ ] &lt; [ ] AS result;</pre> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT [1, 2] &lt; [1] AS result;</pre> <p>These queries return <code class="language-plaintext highlighter-rouge">NULL</code>.</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT [1, 2] &lt; [1, NULL, 4] AS result;</pre> <h2 id="updating-lists"> <a style="text-decoration: none;" href="#updating-lists">Updating Lists</a> </h2> <p>Updates on lists are internally represented as an insert and a delete operation. Therefore, updating list values may lead to a duplicate key error on primary/unique keys. See the following example:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE tbl (id INTEGER PRIMARY KEY, lst INTEGER[], comment VARCHAR);
INSERT INTO tbl VALUES (1, [12, 34], 'asd');
UPDATE tbl SET lst = [56, 78] WHERE id = 1;</pre> <pre class="language-console highlighter-rouge" data-language="console">Constraint Error: Duplicate key "id: 1" violates primary key constraint.
If this is an unexpected constraint violation please double check with the known index limitations section in our documentation (https://duckdb.org/docs/sql/indexes).</pre> <h2 id="functions"> <a style="text-decoration: none;" href="#functions">Functions</a> </h2> <p>See <a href="../functions/list.html">List Functions</a>.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; Copyright 2018&ndash;2024 Stichting DuckDB Foundation<br>Licensed under the MIT License.<br>
    <a href="https://duckdb.org/docs/sql/data_types/list.html" class="_attribution-link">https://duckdb.org/docs/sql/data_types/list.html</a>
  </p>
</div>
