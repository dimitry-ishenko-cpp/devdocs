<h1 class="title">Literal Types</h1>  <p>DuckDB has special literal types for representing <code class="language-plaintext highlighter-rouge">NULL</code>, integer and string literals in queries. These have their own binding and conversion rules.</p> <blockquote> <p>Prior to DuckDB version 0.10.0, integer and string literals behaved identically to the <code class="language-plaintext highlighter-rouge">INTEGER</code> and <code class="language-plaintext highlighter-rouge">VARCHAR</code> types.</p> </blockquote> <h2 id="null-literals"> <a style="text-decoration: none;" href="#null-literals">Null Literals</a> </h2> <p>The <code class="language-plaintext highlighter-rouge">NULL</code> literal is denoted with the keyword <code class="language-plaintext highlighter-rouge">NULL</code>. The <code class="language-plaintext highlighter-rouge">NULL</code> literal can be implicitly converted to any other type.</p> <h2 id="integer-literals"> <a style="text-decoration: none;" href="#integer-literals">Integer Literals</a> </h2> <p>Integer literals are denoted as a sequence of one or more digits. At runtime, these result in values of the <code class="language-plaintext highlighter-rouge">INTEGER_LITERAL</code> type. <code class="language-plaintext highlighter-rouge">INTEGER_LITERAL</code> types can be implicitly converted to any <a href="numeric.html#integer-types.html">integer type</a> in which the value fits. For example, the integer literal <code class="language-plaintext highlighter-rouge">42</code> can be implicitly converted to a <code class="language-plaintext highlighter-rouge">TINYINT</code>, but the integer literal <code class="language-plaintext highlighter-rouge">1000</code> cannot be.</p> <h2 id="other-numeric-literals"> <a style="text-decoration: none;" href="#other-numeric-literals">Other Numeric Literals</a> </h2> <p>Non-integer numeric literals can be denoted with decimal notation, using the period character (<code class="language-plaintext highlighter-rouge">.</code>) to separate the integer part and the decimal part of the number. Either the integer part or the decimal part may be omitted:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT 1.5;          -- 1.5
SELECT .50;          -- 0.5
SELECT 2.;           -- 2.0</pre> <p>Non-integer numeric literals can also be denoted using <a href="https://en.wikipedia.org/wiki/Scientific_notation#E_notation"><em>E notation</em></a>. In E notation, an integer or decimal literal is followed by and exponential part, which is denoted by <code class="language-plaintext highlighter-rouge">e</code> or <code class="language-plaintext highlighter-rouge">E</code>, followed by a literal integer indicating the exponent. The exponential part indicates that the preceding value should be multiplied by 10 raised to the power of the exponent:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT 1e2;           -- 100
SELECT 6.02214e23;    -- Avogadro's constant
SELECT 1e-10;         -- 1 ångström</pre> <h2 id="underscores-in-numeric-literals"> <a style="text-decoration: none;" href="#underscores-in-numeric-literals">Underscores in Numeric Literals</a> </h2> <p>DuckDB's SQL dialect allows using the underscore character <code class="language-plaintext highlighter-rouge">_</code> in numeric literals as an optional separator. The rules for using underscores are as follows:</p> <ul> <li>Underscores are allowed in integer, decimal, hexadecimal and binary notation.</li> <li>Underscores can not be the first or last character in a literal.</li> <li>Underscores have to have an integer/numeric part on either side of them, i.e., there can not be multiple underscores in a row and not immediately before/after a decimal or exponent.</li> </ul> <p>Examples:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT 100_000_000;          -- 100000000
SELECT '0xFF_FF'::INTEGER;   -- 65535
SELECT 1_2.1_2E0_1;          -- 121.2
SELECT '0b0_1_0_1'::INTEGER; -- 5</pre> <h2 id="string-literals"> <a style="text-decoration: none;" href="#string-literals">String Literals</a> </h2> <p>String literals are delimited using single quotes (<code class="language-plaintext highlighter-rouge">'</code>, apostrophe) and result in <code class="language-plaintext highlighter-rouge">STRING_LITERAL</code> values. Note that double quotes (<code class="language-plaintext highlighter-rouge">"</code>) cannot be used as string delimiter character: instead, double quotes are used to delimit <a href="../dialect/keywords_and_identifiers.html#identifiers.html">quoted identifiers</a>.</p> <h3 id="implicit-string-literal-concatenation"> <a style="text-decoration: none;" href="#implicit-string-literal-concatenation">Implicit String Literal Concatenation</a> </h3> <p>Consecutive single-quoted string literals separated only by whitespace that contains at least one newline are implicitly concatenated:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT 'Hello'
    ' '
    'World' AS greeting;</pre> <p>is equivalent to:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT 'Hello'
    || ' '
    || 'World' AS greeting;</pre> <p>They both return the following result:</p> <table> <thead> <tr> <th>greeting</th> </tr> </thead> <tbody> <tr> <td>Hello World</td> </tr> </tbody> </table> <p>Note that implicit concatenation only works if there is at least one newline between the literals. Using adjacent string literals separated by whitespace without a newline results in a syntax error:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT 'Hello' ' ' 'World' AS greeting;</pre> <pre class="language-console highlighter-rouge" data-language="console">Parser Error: syntax error at or near "' '"
LINE 1: SELECT 'Hello' ' ' 'World' AS greeting;
                       ^</pre> <p>Also note that implicit concatenation only works with single-quoted string literals, and does not work with other kinds of string values.</p> <h3 id="implicit-string-conversion"> <a style="text-decoration: none;" href="#implicit-string-conversion">Implicit String Conversion</a> </h3> <p><code class="language-plaintext highlighter-rouge">STRING_LITERAL</code> instances can be implicitly converted to <em>any</em> other type.</p> <p>For example, we can compare string literals with dates:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT d &gt; '1992-01-01' AS result FROM (VALUES (DATE '1992-01-01')) t(d);</pre> <table> <thead> <tr> <th style="text-align: left">result</th> </tr> </thead> <tbody> <tr> <td style="text-align: left">false</td> </tr> </tbody> </table> <p>However, we cannot compare <code class="language-plaintext highlighter-rouge">VARCHAR</code> values with dates.</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT d &gt; '1992-01-01'::VARCHAR FROM (VALUES (DATE '1992-01-01')) t(d);</pre> <pre class="language-console highlighter-rouge" data-language="console">Binder Error: Cannot compare values of type DATE and type VARCHAR - an explicit cast is required</pre> <h3 id="escape-string-literals"> <a style="text-decoration: none;" href="#escape-string-literals">Escape String Literals</a> </h3> <p>To escape a single quote (apostrophe) character in a string literal, use <code class="language-plaintext highlighter-rouge">''</code>. For example, <code class="language-plaintext highlighter-rouge">SELECT '''' AS s</code> returns <code class="language-plaintext highlighter-rouge">'</code>.</p> <p>To include special characters such as newline, use <code class="language-plaintext highlighter-rouge">E</code> escape the string. Both the uppercase (<code class="language-plaintext highlighter-rouge">E'...'</code>) and lowercase variants (<code class="language-plaintext highlighter-rouge">e'...'</code>) work.</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT E'Hello\nworld' AS msg;</pre> <p>Or:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT e'Hello\nworld' AS msg;</pre>  <pre class="language-text highlighter-rouge" data-language="text">┌──────────────┐
│     msg      │
│   varchar    │
├──────────────┤
│ Hello\nworld │
└──────────────┘</pre> <p>The following backslash escape sequences are supported:</p> <table> <thead> <tr> <th style="text-align: left">Escape sequence</th> <th style="text-align: left">Name</th> <th style="text-align: right">ASCII code</th> </tr> </thead> <tbody> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">\b</code></td> <td style="text-align: left">backspace</td> <td style="text-align: right">8</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">\f</code></td> <td style="text-align: left">form feed</td> <td style="text-align: right">12</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">\n</code></td> <td style="text-align: left">newline</td> <td style="text-align: right">10</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">\r</code></td> <td style="text-align: left">carriage return</td> <td style="text-align: right">13</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">\t</code></td> <td style="text-align: left">tab</td> <td style="text-align: right">9</td> </tr> </tbody> </table> <h3 id="dollar-quoted-string-literals"> <a style="text-decoration: none;" href="#dollar-quoted-string-literals">Dollar-Quoted String Literals</a> </h3> <p>DuckDB supports dollar-quoted string literals, which are surrounded by double-dollar symbols (<code class="language-plaintext highlighter-rouge">$$</code>):</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT $$Hello
world$$ AS msg;</pre>  <pre class="language-text highlighter-rouge" data-language="text">┌──────────────┐
│     msg      │
│   varchar    │
├──────────────┤
│ Hello\nworld │
└──────────────┘</pre> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT $$The price is $9.95$$ AS msg;</pre> <table> <thead> <tr> <th>msg</th> </tr> </thead> <tbody> <tr> <td>The price is $9.95</td> </tr> </tbody> </table> <p><a href="#implicit-string-literal-concatenation">Implicit concatenation</a> only works for single-quoted string literals, not with dollar-quoted ones.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; Copyright 2018&ndash;2024 Stichting DuckDB Foundation<br>Licensed under the MIT License.<br>
    <a href="https://duckdb.org/docs/sql/data_types/literal_types.html" class="_attribution-link">https://duckdb.org/docs/sql/data_types/literal_types.html</a>
  </p>
</div>
