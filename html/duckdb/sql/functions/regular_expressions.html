<h1 class="title">Regular Expressions</h1>   <p>DuckDB offers <a href="pattern_matching.html">pattern matching operators</a> (<a href="pattern_matching.html#like.html"><code class="language-plaintext highlighter-rouge">LIKE</code></a>, <a href="pattern_matching.html#similar-to.html"><code class="language-plaintext highlighter-rouge">SIMILAR TO</code></a>, <a href="pattern_matching.html#glob.html"><code class="language-plaintext highlighter-rouge">GLOB</code></a>), as well as support for regular expressions via functions.</p> <h2 id="regular-expression-syntax"> <a style="text-decoration: none;" href="#regular-expression-syntax">Regular Expression Syntax</a> </h2> <p>DuckDB uses the <a href="https://github.com/google/re2">RE2 library</a> as its regular expression engine. For the regular expression syntax, see the <a href="https://github.com/google/re2/wiki/Syntax">RE2 docs</a>.</p> <h2 id="functions"> <a style="text-decoration: none;" href="#functions">Functions</a> </h2> <p>All functions accept an optional set of <a href="#options-for-regular-expression-functions">options</a>.</p> <table> <thead> <tr> <th style="text-align: left">Name</th> <th style="text-align: left">Description</th> </tr> </thead> <tbody> <tr> <td style="text-align: left"><a href="#regexp_extractstring-pattern-group--0-options"><code class="language-plaintext highlighter-rouge">regexp_extract(string, pattern[, group = 0][, options])</code></a></td> <td style="text-align: left">If <code class="language-plaintext highlighter-rouge">string</code> contains the regexp <code class="language-plaintext highlighter-rouge">pattern</code>, returns the capturing group specified by optional parameter <code class="language-plaintext highlighter-rouge">group</code>. The <code class="language-plaintext highlighter-rouge">group</code> must be a constant value. If no <code class="language-plaintext highlighter-rouge">group</code> is given, it defaults to 0. A set of optional <a href="#options-for-regular-expression-functions"><code class="language-plaintext highlighter-rouge">options</code></a> can be set.</td> </tr> <tr> <td style="text-align: left"><a href="#regexp_extractstring-pattern-name_list-options"><code class="language-plaintext highlighter-rouge">regexp_extract(string, pattern, name_list[, options])</code></a></td> <td style="text-align: left">If <code class="language-plaintext highlighter-rouge">string</code> contains the regexp <code class="language-plaintext highlighter-rouge">pattern</code>, returns the capturing groups as a struct with corresponding names from <code class="language-plaintext highlighter-rouge">name_list</code>.</td> </tr> <tr> <td style="text-align: left"><a href="#regexp_extract_allstring-regex-group--0-options"><code class="language-plaintext highlighter-rouge">regexp_extract_all(string, regex[, group = 0][, options])</code></a></td> <td style="text-align: left">Split the <code class="language-plaintext highlighter-rouge">string</code> along the <code class="language-plaintext highlighter-rouge">regex</code> and extract all occurrences of <code class="language-plaintext highlighter-rouge">group</code>.</td> </tr> <tr> <td style="text-align: left"><a href="#regexp_full_matchstring-regex-options"><code class="language-plaintext highlighter-rouge">regexp_full_match(string, regex[, options])</code></a></td> <td style="text-align: left">Returns <code class="language-plaintext highlighter-rouge">true</code> if the entire <code class="language-plaintext highlighter-rouge">string</code> matches the <code class="language-plaintext highlighter-rouge">regex</code>.</td> </tr> <tr> <td style="text-align: left"><a href="#regexp_matchesstring-pattern-options"><code class="language-plaintext highlighter-rouge">regexp_matches(string, pattern[, options])</code></a></td> <td style="text-align: left">Returns <code class="language-plaintext highlighter-rouge">true</code> if <code class="language-plaintext highlighter-rouge">string</code> contains the regexp <code class="language-plaintext highlighter-rouge">pattern</code>, <code class="language-plaintext highlighter-rouge">false</code> otherwise.</td> </tr> <tr> <td style="text-align: left"><a href="#regexp_replacestring-pattern-replacement-options"><code class="language-plaintext highlighter-rouge">regexp_replace(string, pattern, replacement[, options])</code></a></td> <td style="text-align: left">If <code class="language-plaintext highlighter-rouge">string</code> contains the regexp <code class="language-plaintext highlighter-rouge">pattern</code>, replaces the matching part with <code class="language-plaintext highlighter-rouge">replacement</code>.</td> </tr> <tr> <td style="text-align: left"><a href="#regexp_split_to_arraystring-regex-options"><code class="language-plaintext highlighter-rouge">regexp_split_to_array(string, regex[, options])</code></a></td> <td style="text-align: left">Alias of <code class="language-plaintext highlighter-rouge">string_split_regex</code>. Splits the <code class="language-plaintext highlighter-rouge">string</code> along the <code class="language-plaintext highlighter-rouge">regex</code>.</td> </tr> <tr> <td style="text-align: left"><a href="#regexp_split_to_tablestring-regex-options"><code class="language-plaintext highlighter-rouge">regexp_split_to_table(string, regex[, options])</code></a></td> <td style="text-align: left">Splits the <code class="language-plaintext highlighter-rouge">string</code> along the <code class="language-plaintext highlighter-rouge">regex</code> and returns a row for each part.</td> </tr> </tbody> </table> <h4 id="regexp_extractstring-pattern-group--0-options"> <a style="text-decoration: none;" href="#regexp_extractstring-pattern-group--0-options"><code class="language-plaintext highlighter-rouge">regexp_extract(string, pattern[, group = 0][, options])</code></a> </h4>  <table> <tbody> <tr> <td><strong>Description</strong></td> <td>If <code class="language-plaintext highlighter-rouge">string</code> contains the regexp <code class="language-plaintext highlighter-rouge">pattern</code>, returns the capturing group specified by optional parameter <code class="language-plaintext highlighter-rouge">group</code>. The <code class="language-plaintext highlighter-rouge">group</code> must be a constant value. If no <code class="language-plaintext highlighter-rouge">group</code> is given, it defaults to 0. A set of optional <a href="#options-for-regular-expression-functions"><code class="language-plaintext highlighter-rouge">options</code></a> can be set.</td> </tr> <tr> <td><strong>Example</strong></td> <td><code class="language-plaintext highlighter-rouge">regexp_extract('abc', '([a-z])(b)', 1)</code></td> </tr> <tr> <td><strong>Result</strong></td> <td><code class="language-plaintext highlighter-rouge">a</code></td> </tr> </tbody> </table> <h4 id="regexp_extractstring-pattern-name_list-options"> <a style="text-decoration: none;" href="#regexp_extractstring-pattern-name_list-options"><code class="language-plaintext highlighter-rouge">regexp_extract(string, pattern, name_list[, options])</code></a> </h4>  <table> <tbody> <tr> <td><strong>Description</strong></td> <td>If <code class="language-plaintext highlighter-rouge">string</code> contains the regexp <code class="language-plaintext highlighter-rouge">pattern</code>, returns the capturing groups as a struct with corresponding names from <code class="language-plaintext highlighter-rouge">name_list</code>. A set of optional <a href="#options-for-regular-expression-functions"><code class="language-plaintext highlighter-rouge">options</code></a> can be set.</td> </tr> <tr> <td><strong>Example</strong></td> <td><code class="language-plaintext highlighter-rouge">regexp_extract('2023-04-15', '(\d+)-(\d+)-(\d+)', ['y', 'm', 'd'])</code></td> </tr> <tr> <td><strong>Result</strong></td> <td><code class="language-plaintext highlighter-rouge">{'y':'2023', 'm':'04', 'd':'15'}</code></td> </tr> </tbody> </table> <h4 id="regexp_extract_allstring-regex-group--0-options"> <a style="text-decoration: none;" href="#regexp_extract_allstring-regex-group--0-options"><code class="language-plaintext highlighter-rouge">regexp_extract_all(string, regex[, group = 0][, options])</code></a> </h4>  <table> <tbody> <tr> <td><strong>Description</strong></td> <td>Split the <code class="language-plaintext highlighter-rouge">string</code> along the <code class="language-plaintext highlighter-rouge">regex</code> and extract all occurrences of <code class="language-plaintext highlighter-rouge">group</code>. A set of optional <a href="#options-for-regular-expression-functions"><code class="language-plaintext highlighter-rouge">options</code></a> can be set.</td> </tr> <tr> <td><strong>Example</strong></td> <td><code class="language-plaintext highlighter-rouge">regexp_extract_all('hello_world', '([a-z ]+)_?', 1)</code></td> </tr> <tr> <td><strong>Result</strong></td> <td><code class="language-plaintext highlighter-rouge">[hello, world]</code></td> </tr> </tbody> </table> <h4 id="regexp_full_matchstring-regex-options"> <a style="text-decoration: none;" href="#regexp_full_matchstring-regex-options"><code class="language-plaintext highlighter-rouge">regexp_full_match(string, regex[, options])</code></a> </h4>  <table> <tbody> <tr> <td><strong>Description</strong></td> <td>Returns <code class="language-plaintext highlighter-rouge">true</code> if the entire <code class="language-plaintext highlighter-rouge">string</code> matches the <code class="language-plaintext highlighter-rouge">regex</code>. A set of optional <a href="#options-for-regular-expression-functions"><code class="language-plaintext highlighter-rouge">options</code></a> can be set.</td> </tr> <tr> <td><strong>Example</strong></td> <td><code class="language-plaintext highlighter-rouge">regexp_full_match('anabanana', '(an)*')</code></td> </tr> <tr> <td><strong>Result</strong></td> <td><code class="language-plaintext highlighter-rouge">false</code></td> </tr> </tbody> </table> <h4 id="regexp_matchesstring-pattern-options"> <a style="text-decoration: none;" href="#regexp_matchesstring-pattern-options"><code class="language-plaintext highlighter-rouge">regexp_matches(string, pattern[, options])</code></a> </h4>  <table> <tbody> <tr> <td><strong>Description</strong></td> <td>Returns <code class="language-plaintext highlighter-rouge">true</code> if <code class="language-plaintext highlighter-rouge">string</code> contains the regexp <code class="language-plaintext highlighter-rouge">pattern</code>, <code class="language-plaintext highlighter-rouge">false</code> otherwise. A set of optional <a href="#options-for-regular-expression-functions"><code class="language-plaintext highlighter-rouge">options</code></a> can be set.</td> </tr> <tr> <td><strong>Example</strong></td> <td><code class="language-plaintext highlighter-rouge">regexp_matches('anabanana', '(an)*')</code></td> </tr> <tr> <td><strong>Result</strong></td> <td><code class="language-plaintext highlighter-rouge">true</code></td> </tr> </tbody> </table> <h4 id="regexp_replacestring-pattern-replacement-options"> <a style="text-decoration: none;" href="#regexp_replacestring-pattern-replacement-options"><code class="language-plaintext highlighter-rouge">regexp_replace(string, pattern, replacement[, options])</code></a> </h4>  <table> <tbody> <tr> <td><strong>Description</strong></td> <td>If <code class="language-plaintext highlighter-rouge">string</code> contains the regexp <code class="language-plaintext highlighter-rouge">pattern</code>, replaces the matching part with <code class="language-plaintext highlighter-rouge">replacement</code>. A set of optional <a href="#options-for-regular-expression-functions"><code class="language-plaintext highlighter-rouge">options</code></a> can be set.</td> </tr> <tr> <td><strong>Example</strong></td> <td><code class="language-plaintext highlighter-rouge">regexp_replace('hello', '[lo]', '-')</code></td> </tr> <tr> <td><strong>Result</strong></td> <td><code class="language-plaintext highlighter-rouge">he-lo</code></td> </tr> </tbody> </table> <h4 id="regexp_split_to_arraystring-regex-options"> <a style="text-decoration: none;" href="#regexp_split_to_arraystring-regex-options"><code class="language-plaintext highlighter-rouge">regexp_split_to_array(string, regex[, options])</code></a> </h4>  <table> <tbody> <tr> <td><strong>Description</strong></td> <td>Alias of <code class="language-plaintext highlighter-rouge">string_split_regex</code>. Splits the <code class="language-plaintext highlighter-rouge">string</code> along the <code class="language-plaintext highlighter-rouge">regex</code>. A set of optional <a href="#options-for-regular-expression-functions"><code class="language-plaintext highlighter-rouge">options</code></a> can be set.</td> </tr> <tr> <td><strong>Example</strong></td> <td><code class="language-plaintext highlighter-rouge">regexp_split_to_array('hello world; 42', ';? ')</code></td> </tr> <tr> <td><strong>Result</strong></td> <td><code class="language-plaintext highlighter-rouge">['hello', 'world', '42']</code></td> </tr> </tbody> </table> <h4 id="regexp_split_to_tablestring-regex-options"> <a style="text-decoration: none;" href="#regexp_split_to_tablestring-regex-options"><code class="language-plaintext highlighter-rouge">regexp_split_to_table(string, regex[, options])</code></a> </h4>  <table> <tbody> <tr> <td><strong>Description</strong></td> <td>Splits the <code class="language-plaintext highlighter-rouge">string</code> along the <code class="language-plaintext highlighter-rouge">regex</code> and returns a row for each part. A set of optional <a href="#options-for-regular-expression-functions"><code class="language-plaintext highlighter-rouge">options</code></a> can be set.</td> </tr> <tr> <td><strong>Example</strong></td> <td><code class="language-plaintext highlighter-rouge">regexp_split_to_table('hello world; 42', ';? ')</code></td> </tr> <tr> <td><strong>Result</strong></td> <td>Three rows: <code class="language-plaintext highlighter-rouge">'hello'</code>, <code class="language-plaintext highlighter-rouge">'world', '42'</code>
</td> </tr> </tbody> </table> <p>The <code class="language-plaintext highlighter-rouge">regexp_matches</code> function is similar to the <code class="language-plaintext highlighter-rouge">SIMILAR TO</code> operator, however, it does not require the entire string to match. Instead, <code class="language-plaintext highlighter-rouge">regexp_matches</code> returns <code class="language-plaintext highlighter-rouge">true</code> if the string merely contains the pattern (unless the special tokens <code class="language-plaintext highlighter-rouge">^</code> and <code class="language-plaintext highlighter-rouge">$</code> are used to anchor the regular expression to the start and end of the string). Below are some examples:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT regexp_matches('abc', 'abc');       -- true
SELECT regexp_matches('abc', '^abc$');     -- true
SELECT regexp_matches('abc', 'a');         -- true
SELECT regexp_matches('abc', '^a$');       -- false
SELECT regexp_matches('abc', '.*(b|d).*'); -- true
SELECT regexp_matches('abc', '(b|c).*');   -- true
SELECT regexp_matches('abc', '^(b|c).*');  -- false
SELECT regexp_matches('abc', '(?i)A');     -- true
SELECT regexp_matches('abc', 'A', 'i');    -- true</pre> <h2 id="options-for-regular-expression-functions"> <a style="text-decoration: none;" href="#options-for-regular-expression-functions">Options for Regular Expression Functions</a> </h2> <p>The regex functions support the following <code class="language-plaintext highlighter-rouge">options</code>.</p>  <table> <thead> <tr> <th style="text-align: left">Option</th> <th style="text-align: left">Description</th> </tr> </thead> <tbody> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">'c'</code></td> <td style="text-align: left">case-sensitive matching</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">'i'</code></td> <td style="text-align: left">case-insensitive matching</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">'l'</code></td> <td style="text-align: left">match literals instead of regular expression tokens</td> </tr> <tr> <td style="text-align: left">
<code class="language-plaintext highlighter-rouge">'m'</code>, <code class="language-plaintext highlighter-rouge">'n'</code>, <code class="language-plaintext highlighter-rouge">'p'</code>
</td> <td style="text-align: left">newline sensitive matching</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">'g'</code></td> <td style="text-align: left">global replace, only available for <code class="language-plaintext highlighter-rouge">regexp_replace</code>
</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">'s'</code></td> <td style="text-align: left">non-newline sensitive matching</td> </tr> </tbody> </table> <p>For example:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT regexp_matches('abcd', 'ABC', 'c'); -- false
SELECT regexp_matches('abcd', 'ABC', 'i'); -- true
SELECT regexp_matches('ab^/$cd', '^/$', 'l'); -- true
SELECT regexp_matches(E'hello\nworld', 'hello.world', 'p'); -- false
SELECT regexp_matches(E'hello\nworld', 'hello.world', 's'); -- true</pre> <h3 id="using-regexp_matches"> <a style="text-decoration: none;" href="#using-regexp_matches">Using <code class="language-plaintext highlighter-rouge">regexp_matches</code></a> </h3> <p>The <code class="language-plaintext highlighter-rouge">regexp_matches</code> operator will be optimized to the <code class="language-plaintext highlighter-rouge">LIKE</code> operator when possible. To achieve best performance, the <code class="language-plaintext highlighter-rouge">'c'</code> option (case-sensitive matching) should be passed if applicable. Note that by default the <a href="#regular-expression-syntax"><code class="language-plaintext highlighter-rouge">RE2</code> library</a> doesn't match the <code class="language-plaintext highlighter-rouge">.</code> character to newline.</p>  <table> <thead> <tr> <th style="text-align: left">Original</th> <th style="text-align: left">Optimized equivalent</th> </tr> </thead> <tbody> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">regexp_matches('hello world', '^hello', 'c')</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">prefix('hello world', 'hello')</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">regexp_matches('hello world', 'world$', 'c')</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">suffix('hello world', 'world')</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">regexp_matches('hello world', 'hello.world', 'c')</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">LIKE 'hello_world'</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">regexp_matches('hello world', 'he.*rld', 'c')</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">LIKE '%he%rld'</code></td> </tr> </tbody> </table> <h3 id="using-regexp_replace"> <a style="text-decoration: none;" href="#using-regexp_replace">Using <code class="language-plaintext highlighter-rouge">regexp_replace</code></a> </h3> <p>The <code class="language-plaintext highlighter-rouge">regexp_replace</code> function can be used to replace the part of a string that matches the regexp pattern with a replacement string. The notation <code class="language-plaintext highlighter-rouge">\d</code> (where <code class="language-plaintext highlighter-rouge">d</code> is a number indicating the group) can be used to refer to groups captured in the regular expression in the replacement string. Note that by default, <code class="language-plaintext highlighter-rouge">regexp_replace</code> only replaces the first occurrence of the regular expression. To replace all occurrences, use the global replace (<code class="language-plaintext highlighter-rouge">g</code>) flag.</p> <p>Some examples for using <code class="language-plaintext highlighter-rouge">regexp_replace</code>:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT regexp_replace('abc', '(b|c)', 'X');        -- aXc
SELECT regexp_replace('abc', '(b|c)', 'X', 'g');   -- aXX
SELECT regexp_replace('abc', '(b|c)', '\1\1\1\1'); -- abbbbc
SELECT regexp_replace('abc', '(.*)c', '\1e');      -- abe
SELECT regexp_replace('abc', '(a)(b)', '\2\1');    -- bac</pre> <h3 id="using-regexp_extract"> <a style="text-decoration: none;" href="#using-regexp_extract">Using <code class="language-plaintext highlighter-rouge">regexp_extract</code></a> </h3> <p>The <code class="language-plaintext highlighter-rouge">regexp_extract</code> function is used to extract a part of a string that matches the regexp pattern. A specific capturing group within the pattern can be extracted using the <code class="language-plaintext highlighter-rouge">group</code> parameter. If <code class="language-plaintext highlighter-rouge">group</code> is not specified, it defaults to 0, extracting the first match with the whole pattern.</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT regexp_extract('abc', '.b.');           -- abc
SELECT regexp_extract('abc', '.b.', 0);        -- abc
SELECT regexp_extract('abc', '.b.', 1);        -- (empty)
SELECT regexp_extract('abc', '([a-z])(b)', 1); -- a
SELECT regexp_extract('abc', '([a-z])(b)', 2); -- b</pre> <p>The <code class="language-plaintext highlighter-rouge">regexp_extract</code> function also supports a <code class="language-plaintext highlighter-rouge">name_list</code> argument, which is a <code class="language-plaintext highlighter-rouge">LIST</code> of strings. Using <code class="language-plaintext highlighter-rouge">name_list</code>, the <code class="language-plaintext highlighter-rouge">regexp_extract</code> will return the corresponding capture groups as fields of a <code class="language-plaintext highlighter-rouge">STRUCT</code>:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT regexp_extract('2023-04-15', '(\d+)-(\d+)-(\d+)', ['y', 'm', 'd']);</pre> <pre class="language-text highlighter-rouge" data-language="text">{'y': 2023, 'm': 04, 'd': 15}</pre> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT regexp_extract('2023-04-15 07:59:56', '^(\d+)-(\d+)-(\d+) (\d+):(\d+):(\d+)', ['y', 'm', 'd']);</pre> <pre class="language-text highlighter-rouge" data-language="text">{'y': 2023, 'm': 04, 'd': 15}</pre> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT regexp_extract('duckdb_0_7_1', '^(\w+)_(\d+)_(\d+)', ['tool', 'major', 'minor', 'fix']);</pre> <pre class="language-console highlighter-rouge" data-language="console">Binder Error: Not enough group names in regexp_extract</pre> <p>If the number of column names is less than the number of capture groups, then only the first groups are returned. If the number of column names is greater, then an error is generated.</p> <h2 id="limitations"> <a style="text-decoration: none;" href="#limitations">Limitations</a> </h2> <p>Regular expressions only support 9 capture groups: <code class="language-plaintext highlighter-rouge">\1</code>, <code class="language-plaintext highlighter-rouge">\2</code>, <code class="language-plaintext highlighter-rouge">\3</code>, …, <code class="language-plaintext highlighter-rouge">\9</code>. Capture groups with two or more digits are not supported.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; Copyright 2018&ndash;2024 Stichting DuckDB Foundation<br>Licensed under the MIT License.<br>
    <a href="https://duckdb.org/docs/sql/functions/regular_expressions.html" class="_attribution-link">https://duckdb.org/docs/sql/functions/regular_expressions.html</a>
  </p>
</div>
