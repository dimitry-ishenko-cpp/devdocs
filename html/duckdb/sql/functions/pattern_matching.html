<h1 class="title">Pattern Matching</h1>  <p>There are four separate approaches to pattern matching provided by DuckDB: the traditional SQL <a href="#like"><code class="language-plaintext highlighter-rouge">LIKE</code> operator</a>, the more recent <a href="#similar-to"><code class="language-plaintext highlighter-rouge">SIMILAR TO</code> operator</a> (added in SQL:1999), a <a href="#glob"><code class="language-plaintext highlighter-rouge">GLOB</code> operator</a>, and POSIX-style <a href="#regular-expressions">regular expressions</a>.</p> <h2 id="like"> <a style="text-decoration: none;" href="#like"><code class="language-plaintext highlighter-rouge">LIKE</code></a> </h2>  <p>The <code class="language-plaintext highlighter-rouge">LIKE</code> expression returns <code class="language-plaintext highlighter-rouge">true</code> if the string matches the supplied pattern. (As expected, the <code class="language-plaintext highlighter-rouge">NOT LIKE</code> expression returns <code class="language-plaintext highlighter-rouge">false</code> if <code class="language-plaintext highlighter-rouge">LIKE</code> returns <code class="language-plaintext highlighter-rouge">true</code>, and vice versa. An equivalent expression is <code class="language-plaintext highlighter-rouge">NOT (string LIKE pattern)</code>.)</p> <p>If pattern does not contain percent signs or underscores, then the pattern only represents the string itself; in that case <code class="language-plaintext highlighter-rouge">LIKE</code> acts like the equals operator. An underscore (<code class="language-plaintext highlighter-rouge">_</code>) in pattern stands for (matches) any single character; a percent sign (<code class="language-plaintext highlighter-rouge">%</code>) matches any sequence of zero or more characters.</p> <p><code class="language-plaintext highlighter-rouge">LIKE</code> pattern matching always covers the entire string. Therefore, if it's desired to match a sequence anywhere within a string, the pattern must start and end with a percent sign.</p> <p>Some examples:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT 'abc' LIKE 'abc'; -- true
SELECT 'abc' LIKE 'a%' ; -- true
SELECT 'abc' LIKE '_b_'; -- true
SELECT 'abc' LIKE 'c';   -- false
SELECT 'abc' LIKE 'c%' ; -- false
SELECT 'abc' LIKE '%c';  -- true
SELECT 'abc' NOT LIKE '%c'; -- false</pre> <p>The keyword <code class="language-plaintext highlighter-rouge">ILIKE</code> can be used instead of <code class="language-plaintext highlighter-rouge">LIKE</code> to make the match case-insensitive according to the active locale:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT 'abc' ILIKE '%C'; -- true</pre> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT 'abc' NOT ILIKE '%C'; -- false</pre> <p>To search within a string for a character that is a wildcard (<code class="language-plaintext highlighter-rouge">%</code> or <code class="language-plaintext highlighter-rouge">_</code>), the pattern must use an <code class="language-plaintext highlighter-rouge">ESCAPE</code> clause and an escape character to indicate the wildcard should be treated as a literal character instead of a wildcard. See an example below.</p> <p>Additionally, the function <code class="language-plaintext highlighter-rouge">like_escape</code> has the same functionality as a <code class="language-plaintext highlighter-rouge">LIKE</code> expression with an <code class="language-plaintext highlighter-rouge">ESCAPE</code> clause, but using function syntax. See the <a href="char.html">Text Functions Docs</a> for details.</p> <p>Search for strings with 'a' then a literal percent sign then 'c':</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT 'a%c' LIKE 'a$%c' ESCAPE '$'; -- true
SELECT 'azc' LIKE 'a$%c' ESCAPE '$'; -- false</pre> <p>Case-insensitive ILIKE with ESCAPE:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT 'A%c' ILIKE 'a$%c' ESCAPE '$'; -- true</pre> <p>There are also alternative characters that can be used as keywords in place of <code class="language-plaintext highlighter-rouge">LIKE</code> expressions. These enhance PostgreSQL compatibility.</p>  <table> <thead> <tr> <th style="text-align: left">LIKE-style</th> <th style="text-align: left">PostgreSQL-style</th> </tr> </thead> <tbody> <tr> <td style="text-align: left">LIKE</td> <td style="text-align: left">~~</td> </tr> <tr> <td style="text-align: left">NOT LIKE</td> <td style="text-align: left">!~~</td> </tr> <tr> <td style="text-align: left">ILIKE</td> <td style="text-align: left">~~*</td> </tr> <tr> <td style="text-align: left">NOT ILIKE</td> <td style="text-align: left">!~~*</td> </tr> </tbody> </table> <h2 id="similar-to"> <a style="text-decoration: none;" href="#similar-to"><code class="language-plaintext highlighter-rouge">SIMILAR TO</code></a> </h2>  <p>The <code class="language-plaintext highlighter-rouge">SIMILAR TO</code> operator returns true or false depending on whether its pattern matches the given string. It is similar to <code class="language-plaintext highlighter-rouge">LIKE</code>, except that it interprets the pattern using a <a href="regular_expressions.html">regular expression</a>. Like <code class="language-plaintext highlighter-rouge">LIKE</code>, the <code class="language-plaintext highlighter-rouge">SIMILAR TO</code> operator succeeds only if its pattern matches the entire string; this is unlike common regular expression behavior where the pattern can match any part of the string.</p> <p>A regular expression is a character sequence that is an abbreviated definition of a set of strings (a regular set). A string is said to match a regular expression if it is a member of the regular set described by the regular expression. As with <code class="language-plaintext highlighter-rouge">LIKE</code>, pattern characters match string characters exactly unless they are special characters in the regular expression language — but regular expressions use different special characters than <code class="language-plaintext highlighter-rouge">LIKE</code> does.</p> <p>Some examples:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT 'abc' SIMILAR TO 'abc';       -- true
SELECT 'abc' SIMILAR TO 'a';         -- false
SELECT 'abc' SIMILAR TO '.*(b|d).*'; -- true
SELECT 'abc' SIMILAR TO '(b|c).*';   -- false
SELECT 'abc' NOT SIMILAR TO 'abc';   -- false</pre> <p>There are also alternative characters that can be used as keywords in place of <code class="language-plaintext highlighter-rouge">SIMILAR TO</code> expressions. These follow POSIX syntax.</p>  <table> <thead> <tr> <th style="text-align: left">
<code class="language-plaintext highlighter-rouge">SIMILAR TO</code>-style</th> <th style="text-align: left">POSIX-style</th> </tr> </thead> <tbody> <tr> <td style="text-align: left">SIMILAR TO</td> <td style="text-align: left">~</td> </tr> <tr> <td style="text-align: left">NOT SIMILAR TO</td> <td style="text-align: left">!~</td> </tr> </tbody> </table> <h2 id="globbing"> <a style="text-decoration: none;" href="#globbing">Globbing</a> </h2> <p>DuckDB supports file name expansion, also known as globbing, for discovering files. DuckDB's glob syntax uses the question mark (<code class="language-plaintext highlighter-rouge">?</code>) wildcard to match any single character and the asterisk (<code class="language-plaintext highlighter-rouge">*</code>) to match zero or more characters. In addition, you can use the bracket syntax (<code class="language-plaintext highlighter-rouge">[...]</code>) to match any single character contained within the brackets, or within the character range specified by the brackets. An exclamation mark (<code class="language-plaintext highlighter-rouge">!</code>) may be used inside the first bracket to search for a character that is not contained within the brackets. To learn more, visit the <a href="https://en.wikipedia.org/wiki/Glob_(programming)">“glob (programming)” Wikipedia page</a>.</p> <h3 id="glob"> <a style="text-decoration: none;" href="#glob"><code class="language-plaintext highlighter-rouge">GLOB</code></a> </h3>  <p>The <code class="language-plaintext highlighter-rouge">GLOB</code> operator returns <code class="language-plaintext highlighter-rouge">true</code> or <code class="language-plaintext highlighter-rouge">false</code> if the string matches the <code class="language-plaintext highlighter-rouge">GLOB</code> pattern. The <code class="language-plaintext highlighter-rouge">GLOB</code> operator is most commonly used when searching for filenames that follow a specific pattern (for example a specific file extension).</p> <p>Some examples:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT 'best.txt' GLOB '*.txt';            -- true
SELECT 'best.txt' GLOB '????.txt';         -- true
SELECT 'best.txt' GLOB '?.txt';            -- false
SELECT 'best.txt' GLOB '[abc]est.txt';     -- true
SELECT 'best.txt' GLOB '[a-z]est.txt';     -- true</pre> <p>The bracket syntax is case-sensitive:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT 'Best.txt' GLOB '[a-z]est.txt';     -- false
SELECT 'Best.txt' GLOB '[a-zA-Z]est.txt';  -- true</pre> <p>The <code class="language-plaintext highlighter-rouge">!</code> applies to all characters within the brackets:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT 'Best.txt' GLOB '[!a-zA-Z]est.txt'; -- false</pre> <p>To negate a GLOB operator, negate the entire expression:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT NOT 'best.txt' GLOB '*.txt';        -- false</pre> <p>Three tildes (<code class="language-plaintext highlighter-rouge">~~~</code>) may also be used in place of the <code class="language-plaintext highlighter-rouge">GLOB</code> keyword.</p>  <table> <thead> <tr> <th style="text-align: left">GLOB-style</th> <th style="text-align: left">Symbolic-style</th> </tr> </thead> <tbody> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">GLOB</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">~~~</code></td> </tr> </tbody> </table> <h3 id="glob-function-to-find-filenames"> <a style="text-decoration: none;" href="#glob-function-to-find-filenames">Glob Function to Find Filenames</a> </h3> <p>The glob pattern matching syntax can also be used to search for filenames using the <code class="language-plaintext highlighter-rouge">glob</code> table function. It accepts one parameter: the path to search (which may include glob patterns).</p> <p>Search the current directory for all files:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT * FROM glob('*');</pre>  <table> <thead> <tr> <th>file</th> </tr> </thead> <tbody> <tr> <td>duckdb.exe</td> </tr> <tr> <td>test.csv</td> </tr> <tr> <td>test.json</td> </tr> <tr> <td>test.parquet</td> </tr> <tr> <td>test2.csv</td> </tr> <tr> <td>test2.parquet</td> </tr> <tr> <td>todos.json</td> </tr> </tbody> </table> <h3 id="globbing-semantics"> <a style="text-decoration: none;" href="#globbing-semantics">Globbing Semantics</a> </h3> <p>DuckDB's globbing implementation follows the semantics of <a href="https://docs.python.org/3/library/glob.html">Python's <code class="language-plaintext highlighter-rouge">glob</code></a> and not the <code class="language-plaintext highlighter-rouge">glob</code> used in the shell. A notable difference is the behavior of the <code class="language-plaintext highlighter-rouge">**/</code> construct: <code class="language-plaintext highlighter-rouge">**/⟨filename⟩</code> will not return a file with <code class="language-plaintext highlighter-rouge">⟨filename⟩</code> in top-level directory. For example, with a <code class="language-plaintext highlighter-rouge">README.md</code> file present in the directory, the following query finds it:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT * FROM glob('README.md');</pre>  <table> <thead> <tr> <th>file</th> </tr> </thead> <tbody> <tr> <td>README.md</td> </tr> </tbody> </table> <p>However, the following query returns an empty result:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT * FROM glob('**/README.md');</pre> <p>Meanwhile, the globbing of Bash, Zsh, etc. finds the file using the same syntax:</p> <pre class="language-bash highlighter-rouge" data-language="bash">ls **/README.md</pre> <pre class="language-text highlighter-rouge" data-language="text">README.md</pre> <h2 id="regular-expressions"> <a style="text-decoration: none;" href="#regular-expressions">Regular Expressions</a> </h2> <p>DuckDB's regex support is documented on the <a href="regular_expressions.html">Regular Expressions page</a>.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; Copyright 2018&ndash;2024 Stichting DuckDB Foundation<br>Licensed under the MIT License.<br>
    <a href="https://duckdb.org/docs/sql/functions/pattern_matching.html" class="_attribution-link">https://duckdb.org/docs/sql/functions/pattern_matching.html</a>
  </p>
</div>
