<h1 class="title">Set Operations</h1>  <p>Set operations allow queries to be combined according to <a href="https://en.wikipedia.org/wiki/Set_(mathematics)#Basic_operations">set operation semantics</a>. Set operations refer to the <a href="#union"><code class="language-plaintext highlighter-rouge">UNION [ALL]</code></a>, <a href="#intersect"><code class="language-plaintext highlighter-rouge">INTERSECT [ALL]</code></a> and <a href="#except"><code class="language-plaintext highlighter-rouge">EXCEPT [ALL]</code></a> clauses. The vanilla variants use set semantics, i.e., they eliminate duplicates, while the variants with <code class="language-plaintext highlighter-rouge">ALL</code> use bag semantics.</p> <p>Traditional set operations unify queries <strong>by column position</strong>, and require the to-be-combined queries to have the same number of input columns. If the columns are not of the same type, casts may be added. The result will use the column names from the first query.</p> <p>DuckDB also supports <a href="#union-all-by-name"><code class="language-plaintext highlighter-rouge">UNION [ALL] BY NAME</code></a>, which joins columns by name instead of by position. <code class="language-plaintext highlighter-rouge">UNION BY NAME</code> does not require the inputs to have the same number of columns. <code class="language-plaintext highlighter-rouge">NULL</code> values will be added in case of missing columns.</p> <h2 id="union"> <a style="text-decoration: none;" href="#union"><code class="language-plaintext highlighter-rouge">UNION</code></a> </h2> <p>The <code class="language-plaintext highlighter-rouge">UNION</code> clause can be used to combine rows from multiple queries. The queries are required to return the same number of columns. <a href="../data_types/typecasting.html#implicit-casting.html">Implicit casting</a> to one of the returned types is performed to combine columns of different types where necessary. If this is not possible, the <code class="language-plaintext highlighter-rouge">UNION</code> clause throws an error.</p> <h3 id="vanilla-union-set-semantics"> <a style="text-decoration: none;" href="#vanilla-union-set-semantics">Vanilla <code class="language-plaintext highlighter-rouge">UNION</code> (Set Semantics)</a> </h3> <p>The vanilla <code class="language-plaintext highlighter-rouge">UNION</code> clause follows set semantics, therefore it performs duplicate elimination, i.e., only unique rows will be included in the result.</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT * FROM range(2) t1(x)
UNION
SELECT * FROM range(3) t2(x);</pre> <table> <thead> <tr> <th style="text-align: right">x</th> </tr> </thead> <tbody> <tr> <td style="text-align: right">2</td> </tr> <tr> <td style="text-align: right">1</td> </tr> <tr> <td style="text-align: right">0</td> </tr> </tbody> </table> <h3 id="union-all-bag-semantics"> <a style="text-decoration: none;" href="#union-all-bag-semantics"><code class="language-plaintext highlighter-rouge">UNION ALL</code> (Bag Semantics)</a> </h3> <p><code class="language-plaintext highlighter-rouge">UNION ALL</code> returns all rows of both queries following bag semantics, i.e., <em>without</em> duplicate elimination.</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT * FROM range(2) t1(x)
UNION ALL
SELECT * FROM range(3) t2(x);</pre> <table> <thead> <tr> <th style="text-align: right">x</th> </tr> </thead> <tbody> <tr> <td style="text-align: right">0</td> </tr> <tr> <td style="text-align: right">1</td> </tr> <tr> <td style="text-align: right">0</td> </tr> <tr> <td style="text-align: right">1</td> </tr> <tr> <td style="text-align: right">2</td> </tr> </tbody> </table> <h3 id="union-all-by-name"> <a style="text-decoration: none;" href="#union-all-by-name"><code class="language-plaintext highlighter-rouge">UNION [ALL] BY NAME</code></a> </h3> <p>The <code class="language-plaintext highlighter-rouge">UNION [ALL] BY NAME</code> clause can be used to combine rows from different tables by name, instead of by position. <code class="language-plaintext highlighter-rouge">UNION BY NAME</code> does not require both queries to have the same number of columns. Any columns that are only found in one of the queries are filled with <code class="language-plaintext highlighter-rouge">NULL</code> values for the other query.</p> <p>Take the following tables for example:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE capitals (city VARCHAR, country VARCHAR);
INSERT INTO capitals VALUES
    ('Amsterdam', 'NL'),
    ('Berlin', 'Germany');
CREATE TABLE weather (city VARCHAR, degrees INTEGER, date DATE);
INSERT INTO weather VALUES
    ('Amsterdam', 10, '2022-10-14'),
    ('Seattle', 8, '2022-10-12');</pre> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT * FROM capitals
UNION BY NAME
SELECT * FROM weather;</pre> <table> <thead> <tr> <th>city</th> <th>country</th> <th style="text-align: right">degrees</th> <th>date</th> </tr> </thead> <tbody> <tr> <td>Seattle</td> <td>NULL</td> <td style="text-align: right">8</td> <td>2022-10-12</td> </tr> <tr> <td>Amsterdam</td> <td>NL</td> <td style="text-align: right">NULL</td> <td>NULL</td> </tr> <tr> <td>Berlin</td> <td>Germany</td> <td style="text-align: right">NULL</td> <td>NULL</td> </tr> <tr> <td>Amsterdam</td> <td>NULL</td> <td style="text-align: right">10</td> <td>2022-10-14</td> </tr> </tbody> </table> <p><code class="language-plaintext highlighter-rouge">UNION BY NAME</code> follows set semantics (therefore it performs duplicate elimination), whereas <code class="language-plaintext highlighter-rouge">UNION ALL BY NAME</code> follows bag semantics.</p> <h2 id="intersect"> <a style="text-decoration: none;" href="#intersect"><code class="language-plaintext highlighter-rouge">INTERSECT</code></a> </h2> <p>The <code class="language-plaintext highlighter-rouge">INTERSECT</code> clause can be used to select all rows that occur in the result of <strong>both</strong> queries.</p> <h3 id="vanilla-intersect-set-semantics"> <a style="text-decoration: none;" href="#vanilla-intersect-set-semantics">Vanilla <code class="language-plaintext highlighter-rouge">INTERSECT</code> (Set Semantics)</a> </h3> <p>Vanilla <code class="language-plaintext highlighter-rouge">INTERSECT</code> performs duplicate elimination, so only unique rows are returned.</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT * FROM range(2) t1(x)
INTERSECT
SELECT * FROM range(6) t2(x);</pre> <table> <thead> <tr> <th style="text-align: right">x</th> </tr> </thead> <tbody> <tr> <td style="text-align: right">0</td> </tr> <tr> <td style="text-align: right">1</td> </tr> </tbody> </table> <h3 id="intersect-all-bag-semantics"> <a style="text-decoration: none;" href="#intersect-all-bag-semantics"><code class="language-plaintext highlighter-rouge">INTERSECT ALL</code> (Bag Semantics)</a> </h3> <p><code class="language-plaintext highlighter-rouge">INTERSECT ALL</code> follows bag semantics, so duplicates are returned.</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT unnest([5, 5, 6, 6, 6, 6, 7, 8]) AS x
INTERSECT ALL
SELECT unnest([5, 6, 6, 7, 7, 9]);</pre> <table> <thead> <tr> <th style="text-align: right">x</th> </tr> </thead> <tbody> <tr> <td style="text-align: right">5</td> </tr> <tr> <td style="text-align: right">6</td> </tr> <tr> <td style="text-align: right">6</td> </tr> <tr> <td style="text-align: right">7</td> </tr> </tbody> </table> <h2 id="except"> <a style="text-decoration: none;" href="#except"><code class="language-plaintext highlighter-rouge">EXCEPT</code></a> </h2> <p>The <code class="language-plaintext highlighter-rouge">EXCEPT</code> clause can be used to select all rows that <strong>only</strong> occur in the left query.</p> <h3 id="vanilla-except-set-semantics"> <a style="text-decoration: none;" href="#vanilla-except-set-semantics">Vanilla <code class="language-plaintext highlighter-rouge">EXCEPT</code> (Set Semantics)</a> </h3> <p>Vanilla <code class="language-plaintext highlighter-rouge">EXCEPT</code> follows set semantics, therefore, it performs duplicate elimination, so only unique rows are returned.</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT * FROM range(5) t1(x)
EXCEPT
SELECT * FROM range(2) t2(x);</pre> <table> <thead> <tr> <th style="text-align: right">x</th> </tr> </thead> <tbody> <tr> <td style="text-align: right">2</td> </tr> <tr> <td style="text-align: right">3</td> </tr> <tr> <td style="text-align: right">4</td> </tr> </tbody> </table> <h3 id="except-all-bag-semantics"> <a style="text-decoration: none;" href="#except-all-bag-semantics"><code class="language-plaintext highlighter-rouge">EXCEPT ALL</code> (Bag Semantics)</a> </h3> <p><code class="language-plaintext highlighter-rouge">EXCEPT ALL</code> uses bag semantics:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT unnest([5, 5, 6, 6, 6, 6, 7, 8]) AS x
EXCEPT ALL
SELECT unnest([5, 6, 6, 7, 7, 9]);</pre> <table> <thead> <tr> <th style="text-align: right">x</th> </tr> </thead> <tbody> <tr> <td style="text-align: right">5</td> </tr> <tr> <td style="text-align: right">8</td> </tr> <tr> <td style="text-align: right">6</td> </tr> <tr> <td style="text-align: right">6</td> </tr> </tbody> </table> <h2 id="syntax"> <a style="text-decoration: none;" href="#syntax">Syntax</a> </h2><div class="_attribution">
  <p class="_attribution-p">
    &copy; Copyright 2018&ndash;2024 Stichting DuckDB Foundation<br>Licensed under the MIT License.<br>
    <a href="https://duckdb.org/docs/sql/query_syntax/setops.html" class="_attribution-link">https://duckdb.org/docs/sql/query_syntax/setops.html</a>
  </p>
</div>
