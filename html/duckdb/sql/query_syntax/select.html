<h1 class="title">SELECT Clause</h1>  <p>The <code class="language-plaintext highlighter-rouge">SELECT</code> clause specifies the list of columns that will be returned by the query. While it appears first in the clause, <em>logically</em> the expressions here are executed only at the end. The <code class="language-plaintext highlighter-rouge">SELECT</code> clause can contain arbitrary expressions that transform the output, as well as aggregates and window functions.</p> <h2 id="examples"> <a style="text-decoration: none;" href="#examples">Examples</a> </h2> <p>Select all columns from the table called <code class="language-plaintext highlighter-rouge">table_name</code>:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT * FROM table_name;</pre> <p>Perform arithmetic on the columns in a table, and provide an alias:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT col1 + col2 AS res, sqrt(col1) AS root FROM table_name;</pre> <p>Select all unique cities from the <code class="language-plaintext highlighter-rouge">addresses</code> table:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT DISTINCT city FROM addresses;</pre> <p>Return the total number of rows in the <code class="language-plaintext highlighter-rouge">addresses</code> table:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT count(*) FROM addresses;</pre> <p>Select all columns except the city column from the <code class="language-plaintext highlighter-rouge">addresses</code> table:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT * EXCLUDE (city) FROM addresses;</pre> <p>Select all columns from the <code class="language-plaintext highlighter-rouge">addresses</code> table, but replace <code class="language-plaintext highlighter-rouge">city</code> with <code class="language-plaintext highlighter-rouge">lower(city)</code>:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT * REPLACE (lower(city) AS city) FROM addresses;</pre> <p>Select all columns matching the given regular expression from the table:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT COLUMNS('number\d+') FROM addresses;</pre> <p>Compute a function on all given columns of a table:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT min(COLUMNS(*)) FROM addresses;</pre> <p>To select columns with spaces or special characters, use double quotes (<code class="language-plaintext highlighter-rouge">"</code>):</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT "Some Column Name" FROM tbl;</pre> <h2 id="syntax"> <a style="text-decoration: none;" href="#syntax">Syntax</a> </h2>  <h2 id="select-list"> <a style="text-decoration: none;" href="#select-list"><code class="language-plaintext highlighter-rouge">SELECT</code> List</a> </h2> <p>The <code class="language-plaintext highlighter-rouge">SELECT</code> clause contains a list of expressions that specify the result of a query. The select list can refer to any columns in the <code class="language-plaintext highlighter-rouge">FROM</code> clause, and combine them using expressions. As the output of a SQL query is a table – every expression in the <code class="language-plaintext highlighter-rouge">SELECT</code> clause also has a name. The expressions can be explicitly named using the <code class="language-plaintext highlighter-rouge">AS</code> clause (e.g., <code class="language-plaintext highlighter-rouge">expr AS name</code>). If a name is not provided by the user the expressions are named automatically by the system.</p> <blockquote> <p>Column names are case-insensitive. See the <a href="../dialect/keywords_and_identifiers.html#rules-for-case-sensitivity.html">Rules for Case Sensitivity</a> for more details.</p> </blockquote> <h3 id="star-expressions"> <a style="text-decoration: none;" href="#star-expressions">Star Expressions</a> </h3> <p>Select all columns from the table called <code class="language-plaintext highlighter-rouge">table_name</code>:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT *
FROM table_name;</pre> <p>Select all columns matching the given regular expression from the table:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT COLUMNS('number\d+')
FROM addresses;</pre> <p>The <a href="../expressions/star.html">star expression</a> is a special expression that expands to <em>multiple expressions</em> based on the contents of the <code class="language-plaintext highlighter-rouge">FROM</code> clause. In the simplest case, <code class="language-plaintext highlighter-rouge">*</code> expands to <strong>all</strong> expressions in the <code class="language-plaintext highlighter-rouge">FROM</code> clause. Columns can also be selected using regular expressions or lambda functions. See the <a href="../expressions/star.html">star expression page</a> for more details.</p> <h3 id="distinct-clause"> <a style="text-decoration: none;" href="#distinct-clause"><code class="language-plaintext highlighter-rouge">DISTINCT</code> Clause</a> </h3> <p>Select all unique cities from the addresses table:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT DISTINCT city
FROM addresses;</pre> <p>The <code class="language-plaintext highlighter-rouge">DISTINCT</code> clause can be used to return <strong>only</strong> the unique rows in the result – so that any duplicate rows are filtered out.</p> <blockquote> <p>Queries starting with <code class="language-plaintext highlighter-rouge">SELECT DISTINCT</code> run deduplication, which is an expensive operation. Therefore, only use <code class="language-plaintext highlighter-rouge">DISTINCT</code> if necessary.</p> </blockquote> <h3 id="distinct-on-clause"> <a style="text-decoration: none;" href="#distinct-on-clause"><code class="language-plaintext highlighter-rouge">DISTINCT ON</code> Clause</a> </h3> <p>Select only the highest population city for each country:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT DISTINCT ON(country) city, population
FROM cities
ORDER BY population DESC;</pre> <p>The <code class="language-plaintext highlighter-rouge">DISTINCT ON</code> clause returns only one row per unique value in the set of expressions as defined in the <code class="language-plaintext highlighter-rouge">ON</code> clause. If an <code class="language-plaintext highlighter-rouge">ORDER BY</code> clause is present, the row that is returned is the first row that is encountered as per the <code class="language-plaintext highlighter-rouge">ORDER BY</code> criteria. If an <code class="language-plaintext highlighter-rouge">ORDER BY</code> clause is not present, the first row that is encountered is not defined and can be any row in the table.</p> <blockquote> <p>When querying large data sets, using <code class="language-plaintext highlighter-rouge">DISTINCT</code> on all columns can be expensive. Therefore, consider using <code class="language-plaintext highlighter-rouge">DISTINCT ON</code> on a column (or a set of columns) which guaranetees a sufficient degree of uniqueness for your results. For example, using <code class="language-plaintext highlighter-rouge">DISTINCT ON</code> on the key column(s) of a table guarantees full uniqueness.</p> </blockquote> <h3 id="aggregates"> <a style="text-decoration: none;" href="#aggregates">Aggregates</a> </h3> <p>Return the total number of rows in the addresses table:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT count(*)
FROM addresses;</pre> <p>Return the total number of rows in the addresses table grouped by city:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT city, count(*)
FROM addresses
GROUP BY city;</pre> <p><a href="../functions/aggregates.html">Aggregate functions</a> are special functions that <em>combine</em> multiple rows into a single value. When aggregate functions are present in the <code class="language-plaintext highlighter-rouge">SELECT</code> clause, the query is turned into an aggregate query. In an aggregate query, <strong>all</strong> expressions must either be part of an aggregate function, or part of a group (as specified by the <a href="groupby.html"><code class="language-plaintext highlighter-rouge">GROUP BY clause</code></a>).</p> <h3 id="window-functions"> <a style="text-decoration: none;" href="#window-functions">Window Functions</a> </h3> <p>Generate a <code class="language-plaintext highlighter-rouge">row_number</code> column containing incremental identifiers for each row:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT row_number() OVER ()
FROM sales;</pre> <p>Compute the difference between the current amount, and the previous amount, by order of time:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT amount - lag(amount) OVER (ORDER BY time)
FROM sales;</pre> <p><a href="../functions/window_functions.html">Window functions</a> are special functions that allow the computation of values relative to <em>other rows</em> in a result. Window functions are marked by the <code class="language-plaintext highlighter-rouge">OVER</code> clause which contains the <em>window specification</em>. The window specification defines the frame or context in which the window function is computed. See the <a href="../functions/window_functions.html">window functions page</a> for more information.</p> <h3 id="unnest-function"> <a style="text-decoration: none;" href="#unnest-function"><code class="language-plaintext highlighter-rouge">unnest</code> Function</a> </h3> <p>Unnest an array by one level:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT unnest([1, 2, 3]);</pre> <p>Unnest a struct by one level:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT unnest({'a': 42, 'b': 84});</pre> <p>The <a href="unnest.html"><code class="language-plaintext highlighter-rouge">unnest</code></a> function is a special function that can be used together with <a href="../data_types/array.html">arrays</a>, <a href="../data_types/list.html">lists</a>, or <a href="../data_types/struct.html">structs</a>. The unnest function strips one level of nesting from the type. For example, <code class="language-plaintext highlighter-rouge">INTEGER[]</code> is transformed into <code class="language-plaintext highlighter-rouge">INTEGER</code>. <code class="language-plaintext highlighter-rouge">STRUCT(a INTEGER, b INTEGER)</code> is transformed into <code class="language-plaintext highlighter-rouge">a INTEGER, b INTEGER</code>. The unnest function can be used to transform nested types into regular scalar types, which makes them easier to operate on.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; Copyright 2018&ndash;2024 Stichting DuckDB Foundation<br>Licensed under the MIT License.<br>
    <a href="https://duckdb.org/docs/sql/query_syntax/select.html" class="_attribution-link">https://duckdb.org/docs/sql/query_syntax/select.html</a>
  </p>
</div>
