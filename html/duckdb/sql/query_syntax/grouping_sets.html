<h1 class="title">GROUPING SETS</h1>  <p><code class="language-plaintext highlighter-rouge">GROUPING SETS</code>, <code class="language-plaintext highlighter-rouge">ROLLUP</code> and <code class="language-plaintext highlighter-rouge">CUBE</code> can be used in the <code class="language-plaintext highlighter-rouge">GROUP BY</code> clause to perform a grouping over multiple dimensions within the same query. Note that this syntax is not compatible with <a href="groupby.html#group-by-all.html"><code class="language-plaintext highlighter-rouge">GROUP BY ALL</code></a>.</p> <h2 id="examples"> <a style="text-decoration: none;" href="#examples">Examples</a> </h2> <p>Compute the average income along the provided four different dimensions:</p> <pre class="language-sql highlighter-rouge" data-language="sql">-- the syntax () denotes the empty set (i.e., computing an ungrouped aggregate)
SELECT city, street_name, avg(income)
FROM addresses
GROUP BY GROUPING SETS ((city, street_name), (city), (street_name), ());</pre> <p>Compute the average income along the same dimensions:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT city, street_name, avg(income)
FROM addresses
GROUP BY CUBE (city, street_name);</pre> <p>Compute the average income along the dimensions <code class="language-plaintext highlighter-rouge">(city, street_name)</code>, <code class="language-plaintext highlighter-rouge">(city)</code> and <code class="language-plaintext highlighter-rouge">()</code>:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT city, street_name, avg(income)
FROM addresses
GROUP BY ROLLUP (city, street_name);</pre> <h2 id="description"> <a style="text-decoration: none;" href="#description">Description</a> </h2> <p><code class="language-plaintext highlighter-rouge">GROUPING SETS</code> perform the same aggregate across different <code class="language-plaintext highlighter-rouge">GROUP BY clauses</code> in a single query.</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE students (course VARCHAR, type VARCHAR);
INSERT INTO students (course, type)
VALUES
    ('CS', 'Bachelor'), ('CS', 'Bachelor'), ('CS', 'PhD'), ('Math', 'Masters'),
    ('CS', NULL), ('CS', NULL), ('Math', NULL);</pre> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT course, type, count(*)
FROM students
GROUP BY GROUPING SETS ((course, type), course, type, ());</pre> <table> <thead> <tr> <th>course</th> <th>type</th> <th style="text-align: right">count_star()</th> </tr> </thead> <tbody> <tr> <td>Math</td> <td>NULL</td> <td style="text-align: right">1</td> </tr> <tr> <td>NULL</td> <td>NULL</td> <td style="text-align: right">7</td> </tr> <tr> <td>CS</td> <td>PhD</td> <td style="text-align: right">1</td> </tr> <tr> <td>CS</td> <td>Bachelor</td> <td style="text-align: right">2</td> </tr> <tr> <td>Math</td> <td>Masters</td> <td style="text-align: right">1</td> </tr> <tr> <td>CS</td> <td>NULL</td> <td style="text-align: right">2</td> </tr> <tr> <td>Math</td> <td>NULL</td> <td style="text-align: right">2</td> </tr> <tr> <td>CS</td> <td>NULL</td> <td style="text-align: right">5</td> </tr> <tr> <td>NULL</td> <td>NULL</td> <td style="text-align: right">3</td> </tr> <tr> <td>NULL</td> <td>Masters</td> <td style="text-align: right">1</td> </tr> <tr> <td>NULL</td> <td>Bachelor</td> <td style="text-align: right">2</td> </tr> <tr> <td>NULL</td> <td>PhD</td> <td style="text-align: right">1</td> </tr> </tbody> </table> <p>In the above query, we group across four different sets: <code class="language-plaintext highlighter-rouge">course, type</code>, <code class="language-plaintext highlighter-rouge">course</code>, <code class="language-plaintext highlighter-rouge">type</code> and <code class="language-plaintext highlighter-rouge">()</code> (the empty group). The result contains <code class="language-plaintext highlighter-rouge">NULL</code> for a group which is not in the grouping set for the result, i.e., the above query is equivalent to the following UNION statement:</p> <p>Group by course, type:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT course, type, count(*)
FROM students
GROUP BY course, type
UNION ALL</pre> <p>Group by type:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT NULL AS course, type, count(*)
FROM students
GROUP BY type
UNION ALL</pre> <p>Group by course:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT course, NULL AS type, count(*)
FROM students
GROUP BY course
UNION ALL</pre> <p>Group by nothing:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT NULL AS course, NULL AS type, count(*)
FROM students;</pre> <p><code class="language-plaintext highlighter-rouge">CUBE</code> and <code class="language-plaintext highlighter-rouge">ROLLUP</code> are syntactic sugar to easily produce commonly used grouping sets.</p> <p>The <code class="language-plaintext highlighter-rouge">ROLLUP</code> clause will produce all “sub-groups” of a grouping set, e.g., <code class="language-plaintext highlighter-rouge">ROLLUP (country, city, zip)</code> produces the grouping sets <code class="language-plaintext highlighter-rouge">(country, city, zip), (country, city), (country), ()</code>. This can be useful for producing different levels of detail of a group by clause. This produces <code class="language-plaintext highlighter-rouge">n+1</code> grouping sets where n is the amount of terms in the <code class="language-plaintext highlighter-rouge">ROLLUP</code> clause.</p> <p><code class="language-plaintext highlighter-rouge">CUBE</code> produces grouping sets for all combinations of the inputs, e.g., <code class="language-plaintext highlighter-rouge">CUBE (country, city, zip)</code> will produce <code class="language-plaintext highlighter-rouge">(country, city, zip), (country, city), (country, zip), (city, zip), (country), (city), (zip), ()</code>. This produces <code class="language-plaintext highlighter-rouge">2^n</code> grouping sets.</p> <h2 id="identifying-grouping-sets-with-grouping_id"> <a style="text-decoration: none;" href="#identifying-grouping-sets-with-grouping_id">Identifying Grouping Sets with <code class="language-plaintext highlighter-rouge">GROUPING_ID()</code></a> </h2> <p>The super-aggregate rows generated by <code class="language-plaintext highlighter-rouge">GROUPING SETS</code>, <code class="language-plaintext highlighter-rouge">ROLLUP</code> and <code class="language-plaintext highlighter-rouge">CUBE</code> can often be identified by <code class="language-plaintext highlighter-rouge">NULL</code>-values returned for the respective column in the grouping. But if the columns used in the grouping can themselves contain actual <code class="language-plaintext highlighter-rouge">NULL</code>-values, then it can be challenging to distinguish whether the value in the resultset is a “real” <code class="language-plaintext highlighter-rouge">NULL</code>-value coming out of the data itself, or a <code class="language-plaintext highlighter-rouge">NULL</code>-value generated by the grouping construct. The <code class="language-plaintext highlighter-rouge">GROUPING_ID()</code> or <code class="language-plaintext highlighter-rouge">GROUPING()</code> function is designed to identify which groups generated the super-aggregate rows in the result.</p> <p><code class="language-plaintext highlighter-rouge">GROUPING_ID()</code> is an aggregate function that takes the column expressions that make up the grouping(s). It returns a <code class="language-plaintext highlighter-rouge">BIGINT</code> value. The return value is <code class="language-plaintext highlighter-rouge">0</code> for the rows that are not super-aggregate rows. But for the super-aggregate rows, it returns an integer value that identifies the combination of expressions that make up the group for which the super-aggregate is generated. At this point, an example might help. Consider the following query:</p> <pre class="language-sql highlighter-rouge" data-language="sql">WITH days AS (
    SELECT
        year("generate_series")    AS y,
        quarter("generate_series") AS q,
        month("generate_series")   AS m
    FROM generate_series(DATE '2023-01-01', DATE '2023-12-31', INTERVAL 1 DAY)
)
SELECT y, q, m, GROUPING_ID(y, q, m) AS "grouping_id()"
FROM days
GROUP BY GROUPING SETS (
    (y, q, m),
    (y, q),
    (y),
    ()
)
ORDER BY y, q, m;</pre> <p>These are the results:</p> <table> <thead> <tr> <th style="text-align: right">y</th> <th style="text-align: right">q</th> <th style="text-align: right">m</th> <th style="text-align: right">grouping_id()</th> </tr> </thead> <tbody> <tr> <td style="text-align: right">2023</td> <td style="text-align: right">1</td> <td style="text-align: right">1</td> <td style="text-align: right">0</td> </tr> <tr> <td style="text-align: right">2023</td> <td style="text-align: right">1</td> <td style="text-align: right">2</td> <td style="text-align: right">0</td> </tr> <tr> <td style="text-align: right">2023</td> <td style="text-align: right">1</td> <td style="text-align: right">3</td> <td style="text-align: right">0</td> </tr> <tr> <td style="text-align: right">2023</td> <td style="text-align: right">1</td> <td style="text-align: right">NULL</td> <td style="text-align: right">1</td> </tr> <tr> <td style="text-align: right">2023</td> <td style="text-align: right">2</td> <td style="text-align: right">4</td> <td style="text-align: right">0</td> </tr> <tr> <td style="text-align: right">2023</td> <td style="text-align: right">2</td> <td style="text-align: right">5</td> <td style="text-align: right">0</td> </tr> <tr> <td style="text-align: right">2023</td> <td style="text-align: right">2</td> <td style="text-align: right">6</td> <td style="text-align: right">0</td> </tr> <tr> <td style="text-align: right">2023</td> <td style="text-align: right">2</td> <td style="text-align: right">NULL</td> <td style="text-align: right">1</td> </tr> <tr> <td style="text-align: right">2023</td> <td style="text-align: right">3</td> <td style="text-align: right">7</td> <td style="text-align: right">0</td> </tr> <tr> <td style="text-align: right">2023</td> <td style="text-align: right">3</td> <td style="text-align: right">8</td> <td style="text-align: right">0</td> </tr> <tr> <td style="text-align: right">2023</td> <td style="text-align: right">3</td> <td style="text-align: right">9</td> <td style="text-align: right">0</td> </tr> <tr> <td style="text-align: right">2023</td> <td style="text-align: right">3</td> <td style="text-align: right">NULL</td> <td style="text-align: right">1</td> </tr> <tr> <td style="text-align: right">2023</td> <td style="text-align: right">4</td> <td style="text-align: right">10</td> <td style="text-align: right">0</td> </tr> <tr> <td style="text-align: right">2023</td> <td style="text-align: right">4</td> <td style="text-align: right">11</td> <td style="text-align: right">0</td> </tr> <tr> <td style="text-align: right">2023</td> <td style="text-align: right">4</td> <td style="text-align: right">12</td> <td style="text-align: right">0</td> </tr> <tr> <td style="text-align: right">2023</td> <td style="text-align: right">4</td> <td style="text-align: right">NULL</td> <td style="text-align: right">1</td> </tr> <tr> <td style="text-align: right">2023</td> <td style="text-align: right">NULL</td> <td style="text-align: right">NULL</td> <td style="text-align: right">3</td> </tr> <tr> <td style="text-align: right">NULL</td> <td style="text-align: right">NULL</td> <td style="text-align: right">NULL</td> <td style="text-align: right">7</td> </tr> </tbody> </table> <p>In this example, the lowest level of grouping is at the month level, defined by the grouping set <code class="language-plaintext highlighter-rouge">(y, q, m)</code>. Result rows corresponding to that level are simply aggregate rows and the <code class="language-plaintext highlighter-rouge">GROUPING_ID(y, q, m)</code> function returns <code class="language-plaintext highlighter-rouge">0</code> for those. The grouping set <code class="language-plaintext highlighter-rouge">(y, q)</code> results in super-aggregate rows over the month level, leaving a <code class="language-plaintext highlighter-rouge">NULL</code>-value for the <code class="language-plaintext highlighter-rouge">m</code> column, and for which <code class="language-plaintext highlighter-rouge">GROUPING_ID(y, q, m)</code> returns <code class="language-plaintext highlighter-rouge">1</code>. The grouping set <code class="language-plaintext highlighter-rouge">(y)</code> results in super-aggregate rows over the quarter level, leaving <code class="language-plaintext highlighter-rouge">NULL</code>-values for the <code class="language-plaintext highlighter-rouge">m</code> and <code class="language-plaintext highlighter-rouge">q</code> column, for which <code class="language-plaintext highlighter-rouge">GROUPING_ID(y, q, m)</code> returns <code class="language-plaintext highlighter-rouge">3</code>. Finally, the <code class="language-plaintext highlighter-rouge">()</code> grouping set results in one super-aggregate row for the entire resultset, leaving <code class="language-plaintext highlighter-rouge">NULL</code>-values for <code class="language-plaintext highlighter-rouge">y</code>, <code class="language-plaintext highlighter-rouge">q</code> and <code class="language-plaintext highlighter-rouge">m</code> and for which <code class="language-plaintext highlighter-rouge">GROUPING_ID(y, q, m)</code> returns <code class="language-plaintext highlighter-rouge">7</code>.</p> <p>To understand the relationship between the return value and the grouping set, you can think of <code class="language-plaintext highlighter-rouge">GROUPING_ID(y, q, m)</code> writing to a bitfield, where the first bit corresponds to the last expression passed to <code class="language-plaintext highlighter-rouge">GROUPING_ID()</code>, the second bit to the one-but-last expression passed to <code class="language-plaintext highlighter-rouge">GROUPING_ID()</code>, and so on. This may become clearer by casting <code class="language-plaintext highlighter-rouge">GROUPING_ID()</code> to <code class="language-plaintext highlighter-rouge">BIT</code>:</p> <pre class="language-sql highlighter-rouge" data-language="sql">WITH days AS (
    SELECT
        year("generate_series")    AS y,
        quarter("generate_series") AS q,
        month("generate_series")   AS m
    FROM generate_series(DATE '2023-01-01', DATE '2023-12-31', INTERVAL 1 DAY)
)
SELECT
    y, q, m,
    GROUPING_ID(y, q, m) AS "grouping_id(y, q, m)",
    right(GROUPING_ID(y, q, m)::BIT::VARCHAR, 3) AS "y_q_m_bits"
FROM days
GROUP BY GROUPING SETS (
    (y, q, m),
    (y, q),
    (y),
    ()
)
ORDER BY y, q, m;</pre> <p>Which returns these results:</p> <table> <thead> <tr> <th style="text-align: right">y</th> <th style="text-align: right">q</th> <th style="text-align: right">m</th> <th style="text-align: right">grouping_id(y, q, m)</th> <th>y_q_m_bits</th> </tr> </thead> <tbody> <tr> <td style="text-align: right">2023</td> <td style="text-align: right">1</td> <td style="text-align: right">1</td> <td style="text-align: right">0</td> <td>000</td> </tr> <tr> <td style="text-align: right">2023</td> <td style="text-align: right">1</td> <td style="text-align: right">2</td> <td style="text-align: right">0</td> <td>000</td> </tr> <tr> <td style="text-align: right">2023</td> <td style="text-align: right">1</td> <td style="text-align: right">3</td> <td style="text-align: right">0</td> <td>000</td> </tr> <tr> <td style="text-align: right">2023</td> <td style="text-align: right">1</td> <td style="text-align: right">NULL</td> <td style="text-align: right">1</td> <td>001</td> </tr> <tr> <td style="text-align: right">2023</td> <td style="text-align: right">2</td> <td style="text-align: right">4</td> <td style="text-align: right">0</td> <td>000</td> </tr> <tr> <td style="text-align: right">2023</td> <td style="text-align: right">2</td> <td style="text-align: right">5</td> <td style="text-align: right">0</td> <td>000</td> </tr> <tr> <td style="text-align: right">2023</td> <td style="text-align: right">2</td> <td style="text-align: right">6</td> <td style="text-align: right">0</td> <td>000</td> </tr> <tr> <td style="text-align: right">2023</td> <td style="text-align: right">2</td> <td style="text-align: right">NULL</td> <td style="text-align: right">1</td> <td>001</td> </tr> <tr> <td style="text-align: right">2023</td> <td style="text-align: right">3</td> <td style="text-align: right">7</td> <td style="text-align: right">0</td> <td>000</td> </tr> <tr> <td style="text-align: right">2023</td> <td style="text-align: right">3</td> <td style="text-align: right">8</td> <td style="text-align: right">0</td> <td>000</td> </tr> <tr> <td style="text-align: right">2023</td> <td style="text-align: right">3</td> <td style="text-align: right">9</td> <td style="text-align: right">0</td> <td>000</td> </tr> <tr> <td style="text-align: right">2023</td> <td style="text-align: right">3</td> <td style="text-align: right">NULL</td> <td style="text-align: right">1</td> <td>001</td> </tr> <tr> <td style="text-align: right">2023</td> <td style="text-align: right">4</td> <td style="text-align: right">10</td> <td style="text-align: right">0</td> <td>000</td> </tr> <tr> <td style="text-align: right">2023</td> <td style="text-align: right">4</td> <td style="text-align: right">11</td> <td style="text-align: right">0</td> <td>000</td> </tr> <tr> <td style="text-align: right">2023</td> <td style="text-align: right">4</td> <td style="text-align: right">12</td> <td style="text-align: right">0</td> <td>000</td> </tr> <tr> <td style="text-align: right">2023</td> <td style="text-align: right">4</td> <td style="text-align: right">NULL</td> <td style="text-align: right">1</td> <td>001</td> </tr> <tr> <td style="text-align: right">2023</td> <td style="text-align: right">NULL</td> <td style="text-align: right">NULL</td> <td style="text-align: right">3</td> <td>011</td> </tr> <tr> <td style="text-align: right">NULL</td> <td style="text-align: right">NULL</td> <td style="text-align: right">NULL</td> <td style="text-align: right">7</td> <td>111</td> </tr> </tbody> </table> <p>Note that the number of expressions passed to <code class="language-plaintext highlighter-rouge">GROUPING_ID()</code>, or the order in which they are passed is independent from the actual group definitions appearing in the <code class="language-plaintext highlighter-rouge">GROUPING SETS</code>-clause (or the groups implied by <code class="language-plaintext highlighter-rouge">ROLLUP</code> and <code class="language-plaintext highlighter-rouge">CUBE</code>). As long as the expressions passed to <code class="language-plaintext highlighter-rouge">GROUPING_ID()</code> are expressions that appear some where in the <code class="language-plaintext highlighter-rouge">GROUPING SETS</code>-clause, <code class="language-plaintext highlighter-rouge">GROUPING_ID()</code> will set a bit corresponding to the position of the expression whenever that expression is rolled up to a super-aggregate.</p> <h2 id="syntax"> <a style="text-decoration: none;" href="#syntax">Syntax</a> </h2><div class="_attribution">
  <p class="_attribution-p">
    &copy; Copyright 2018&ndash;2024 Stichting DuckDB Foundation<br>Licensed under the MIT License.<br>
    <a href="https://duckdb.org/docs/sql/query_syntax/grouping_sets.html" class="_attribution-link">https://duckdb.org/docs/sql/query_syntax/grouping_sets.html</a>
  </p>
</div>
