<h1 class="title">Unnesting</h1>  <h2 id="examples"> <a style="text-decoration: none;" href="#examples">Examples</a> </h2> <p>Unnest a list, generating 3 rows (1, 2, 3):</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT unnest([1, 2, 3]);</pre> <p>Unnesting a struct, generating two columns (a, b):</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT unnest({'a': 42, 'b': 84});</pre> <p>Recursive unnest of a list of structs:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT unnest([{'a': 42, 'b': 84}, {'a': 100, 'b': NULL}], recursive := true);</pre> <p>Limit depth of recursive unnest using <code class="language-plaintext highlighter-rouge">max_depth</code>:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT unnest([[[1, 2], [3, 4]], [[5, 6], [7, 8, 9], []], [[10, 11]]], max_depth := 2);</pre> <p>The <code class="language-plaintext highlighter-rouge">unnest</code> special function is used to unnest lists or structs by one level. The function can be used as a regular scalar function, but only in the <code class="language-plaintext highlighter-rouge">SELECT</code> clause. Invoking <code class="language-plaintext highlighter-rouge">unnest</code> with the <code class="language-plaintext highlighter-rouge">recursive</code> parameter will unnest lists and structs of multiple levels. The depth of unnesting can be limited using the <code class="language-plaintext highlighter-rouge">max_depth</code> parameter (which assumes <code class="language-plaintext highlighter-rouge">recursive</code> unnesting by default).</p> <h3 id="unnesting-lists"> <a style="text-decoration: none;" href="#unnesting-lists">Unnesting Lists</a> </h3> <p>Unnest a list, generating 3 rows (1, 2, 3):</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT unnest([1, 2, 3]);</pre> <p>Unnest a scalar list, generating 3 rows ((1, 10), (2, 11), (3, NULL)):</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT unnest([1, 2, 3]), unnest([10, 11]);</pre> <p>Unnest a scalar list, generating 3 rows ((1, 10), (2, 10), (3, 10)):</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT unnest([1, 2, 3]), 10;</pre> <p>Unnest a list column generated from a subquery:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT unnest(l) + 10 FROM (VALUES ([1, 2, 3]), ([4, 5])) tbl(l);</pre> <p>Empty result:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT unnest([]);</pre> <p>Empty result:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT unnest(NULL);</pre> <p>Using <code class="language-plaintext highlighter-rouge">unnest</code> on a list will emit one tuple per entry in the list. When <code class="language-plaintext highlighter-rouge">unnest</code> is combined with regular scalar expressions, those expressions are repeated for every entry in the list. When multiple lists are unnested in the same <code class="language-plaintext highlighter-rouge">SELECT</code> clause, the lists are unnested side-by-side. If one list is longer than the other, the shorter list will be padded with <code class="language-plaintext highlighter-rouge">NULL</code> values.</p> <p>An empty list and a <code class="language-plaintext highlighter-rouge">NULL</code> list will both unnest to zero elements.</p> <h3 id="unnesting-structs"> <a style="text-decoration: none;" href="#unnesting-structs">Unnesting Structs</a> </h3> <p>Unnesting a struct, generating two columns (a, b):</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT unnest({'a': 42, 'b': 84});</pre> <p>Unnesting a struct, generating two columns (a, b):</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT unnest({'a': 42, 'b': {'x': 84}});</pre> <p><code class="language-plaintext highlighter-rouge">unnest</code> on a struct will emit one column per entry in the struct.</p> <h3 id="recursive-unnest"> <a style="text-decoration: none;" href="#recursive-unnest">Recursive Unnest</a> </h3> <p>Unnesting a list of lists recursively, generating 5 rows (1, 2, 3, 4, 5):</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT unnest([[1, 2, 3], [4, 5]], recursive := true);</pre> <p>Unnesting a list of structs recursively, generating two rows of two columns (a, b):</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT unnest([{'a': 42, 'b': 84}, {'a': 100, 'b': NULL}], recursive := true);</pre> <p>Unnesting a struct, generating two columns (a, b):</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT unnest({'a': [1, 2, 3], 'b': 88}, recursive := true);</pre> <p>Calling <code class="language-plaintext highlighter-rouge">unnest</code> with the <code class="language-plaintext highlighter-rouge">recursive</code> setting will fully unnest lists, followed by fully unnesting structs. This can be useful to fully flatten columns that contain lists within lists, or lists of structs. Note that lists <em>within</em> structs are not unnested.</p> <h3 id="setting-the-maximum-depth-of-unnesting"> <a style="text-decoration: none;" href="#setting-the-maximum-depth-of-unnesting">Setting the Maximum Depth of Unnesting</a> </h3> <p>The <code class="language-plaintext highlighter-rouge">max_depth</code> parameter allows limiting the maximum depth of recursive unnesting (which is assumed by default and does not have to be specified separately). For example, unnestig to <code class="language-plaintext highlighter-rouge">max_depth</code> of 2 yields the following:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT unnest([[[1, 2], [3, 4]], [[5, 6], [7, 8, 9], []], [[10, 11]]], max_depth := 2) AS x;</pre> <table> <thead> <tr> <th>x</th> </tr> </thead> <tbody> <tr> <td>[1, 2]</td> </tr> <tr> <td>[3, 4]</td> </tr> <tr> <td>[5, 6]</td> </tr> <tr> <td>[7, 8, 9]</td> </tr> <tr> <td>[]</td> </tr> <tr> <td>[10, 11]</td> </tr> </tbody> </table> <p>Meanwhile, unnesting to <code class="language-plaintext highlighter-rouge">max_depth</code> of 3 results in:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT unnest([[[1, 2], [3, 4]], [[5, 6], [7, 8, 9], []], [[10, 11]]], max_depth := 3) AS x;</pre> <table> <thead> <tr> <th style="text-align: right">x</th> </tr> </thead> <tbody> <tr> <td style="text-align: right">1</td> </tr> <tr> <td style="text-align: right">2</td> </tr> <tr> <td style="text-align: right">3</td> </tr> <tr> <td style="text-align: right">4</td> </tr> <tr> <td style="text-align: right">5</td> </tr> <tr> <td style="text-align: right">6</td> </tr> <tr> <td style="text-align: right">7</td> </tr> <tr> <td style="text-align: right">8</td> </tr> <tr> <td style="text-align: right">9</td> </tr> <tr> <td style="text-align: right">10</td> </tr> <tr> <td style="text-align: right">11</td> </tr> </tbody> </table> <h3 id="keeping-track-of-list-entry-positions"> <a style="text-decoration: none;" href="#keeping-track-of-list-entry-positions">Keeping Track of List Entry Positions</a> </h3> <p>To keep track of each entry's position within the original list, <code class="language-plaintext highlighter-rouge">unnest</code> may be combined with <a href="../functions/list.html#generate_subscripts.html"><code class="language-plaintext highlighter-rouge">generate_subscripts</code></a>:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT unnest(l) AS x, generate_subscripts(l, 1) AS index
FROM (VALUES ([1, 2, 3]), ([4, 5])) tbl(l);</pre> <table> <thead> <tr> <th style="text-align: right">x</th> <th style="text-align: right">index</th> </tr> </thead> <tbody> <tr> <td style="text-align: right">1</td> <td style="text-align: right">1</td> </tr> <tr> <td style="text-align: right">2</td> <td style="text-align: right">2</td> </tr> <tr> <td style="text-align: right">3</td> <td style="text-align: right">3</td> </tr> <tr> <td style="text-align: right">4</td> <td style="text-align: right">1</td> </tr> <tr> <td style="text-align: right">5</td> <td style="text-align: right">2</td> </tr> </tbody> </table><div class="_attribution">
  <p class="_attribution-p">
    &copy; Copyright 2018&ndash;2024 Stichting DuckDB Foundation<br>Licensed under the MIT License.<br>
    <a href="https://duckdb.org/docs/sql/query_syntax/unnest.html" class="_attribution-link">https://duckdb.org/docs/sql/query_syntax/unnest.html</a>
  </p>
</div>
