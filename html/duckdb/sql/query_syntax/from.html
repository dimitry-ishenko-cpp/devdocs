<h1 class="title">FROM and JOIN Clauses</h1>  <p>The <code class="language-plaintext highlighter-rouge">FROM</code> clause specifies the <em>source</em> of the data on which the remainder of the query should operate. Logically, the <code class="language-plaintext highlighter-rouge">FROM</code> clause is where the query starts execution. The <code class="language-plaintext highlighter-rouge">FROM</code> clause can contain a single table, a combination of multiple tables that are joined together using <code class="language-plaintext highlighter-rouge">JOIN</code> clauses, or another <code class="language-plaintext highlighter-rouge">SELECT</code> query inside a subquery node. DuckDB also has an optional <code class="language-plaintext highlighter-rouge">FROM</code>-first syntax which enables you to also query without a <code class="language-plaintext highlighter-rouge">SELECT</code> statement.</p> <h2 id="examples"> <a style="text-decoration: none;" href="#examples">Examples</a> </h2> <p>Select all columns from the table called <code class="language-plaintext highlighter-rouge">table_name</code>:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT *
FROM table_name;</pre> <p>Select all columns from the table using the <code class="language-plaintext highlighter-rouge">FROM</code>-first syntax:</p> <pre class="language-sql highlighter-rouge" data-language="sql">FROM table_name
SELECT *;</pre> <p>Select all columns using the <code class="language-plaintext highlighter-rouge">FROM</code>-first syntax and omitting the <code class="language-plaintext highlighter-rouge">SELECT</code> clause:</p> <pre class="language-sql highlighter-rouge" data-language="sql">FROM table_name;</pre> <p>Select all columns from the table called <code class="language-plaintext highlighter-rouge">table_name</code> through an alias <code class="language-plaintext highlighter-rouge">tn</code>:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT tn.*
FROM table_name tn;</pre> <p>Select all columns from the table <code class="language-plaintext highlighter-rouge">table_name</code> in the schema <code class="language-plaintext highlighter-rouge">schema_name</code>:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT *
FROM schema_name.table_name;</pre> <p>Select the column <code class="language-plaintext highlighter-rouge">i</code> from the table function <code class="language-plaintext highlighter-rouge">range</code>, where the first column of the range function is renamed to <code class="language-plaintext highlighter-rouge">i</code>:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT t.i
FROM range(100) AS t(i);</pre> <p>Select all columns from the CSV file called <code class="language-plaintext highlighter-rouge">test.csv</code>:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT *
FROM 'test.csv';</pre> <p>Select all columns from a subquery:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT *
FROM (SELECT * FROM table_name);</pre> <p>Select the entire row of the table as a struct:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT t
FROM t;</pre> <p>Select the entire row of the subquery as a struct (i.e., a single column):</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT t
FROM (SELECT unnest(generate_series(41, 43)) AS x, 'hello' AS y) t;</pre> <p>Join two tables together:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT *
FROM table_name
JOIN other_table
  ON table_name.key = other_table.key;</pre> <p>Select a 10% sample from a table:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT *
FROM table_name
TABLESAMPLE 10%;</pre> <p>Select a sample of 10 rows from a table:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT *
FROM table_name
TABLESAMPLE 10 ROWS;</pre> <p>Use the <code class="language-plaintext highlighter-rouge">FROM</code>-first syntax with <code class="language-plaintext highlighter-rouge">WHERE</code> clause and aggregation:</p> <pre class="language-sql highlighter-rouge" data-language="sql">FROM range(100) AS t(i)
SELECT sum(t.i)
WHERE i % 2 = 0;</pre> <h2 id="joins"> <a style="text-decoration: none;" href="#joins">Joins</a> </h2> <p>Joins are a fundamental relational operation used to connect two tables or relations horizontally. The relations are referred to as the <em>left</em> and <em>right</em> sides of the join based on how they are written in the join clause. Each result row has the columns from both relations.</p> <p>A join uses a rule to match pairs of rows from each relation. Often this is a predicate, but there are other implied rules that may be specified.</p> <h3 id="outer-joins"> <a style="text-decoration: none;" href="#outer-joins">Outer Joins</a> </h3> <p>Rows that do not have any matches can still be returned if an <code class="language-plaintext highlighter-rouge">OUTER</code> join is specified. Outer joins can be one of:</p> <ul> <li>
<code class="language-plaintext highlighter-rouge">LEFT</code> (All rows from the left relation appear at least once)</li> <li>
<code class="language-plaintext highlighter-rouge">RIGHT</code> (All rows from the right relation appear at least once)</li> <li>
<code class="language-plaintext highlighter-rouge">FULL</code> (All rows from both relations appear at least once)</li> </ul> <p>A join that is not <code class="language-plaintext highlighter-rouge">OUTER</code> is <code class="language-plaintext highlighter-rouge">INNER</code> (only rows that get paired are returned).</p> <p>When an unpaired row is returned, the attributes from the other table are set to <code class="language-plaintext highlighter-rouge">NULL</code>.</p> <h3 id="cross-product-joins-cartesian-product"> <a style="text-decoration: none;" href="#cross-product-joins-cartesian-product">Cross Product Joins (Cartesian Product)</a> </h3> <p>The simplest type of join is a <code class="language-plaintext highlighter-rouge">CROSS JOIN</code>. There are no conditions for this type of join, and it just returns all the possible pairs.</p> <p>Return all pairs of rows:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT a.*, b.*
FROM a
CROSS JOIN b;</pre> <p>This is equivalent to omitting the <code class="language-plaintext highlighter-rouge">JOIN</code> clause:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT a.*, b.*
FROM a, b;</pre> <h3 id="conditional-joins"> <a style="text-decoration: none;" href="#conditional-joins">Conditional Joins</a> </h3> <p>Most joins are specified by a predicate that connects attributes from one side to attributes from the other side. The conditions can be explicitly specified using an <code class="language-plaintext highlighter-rouge">ON</code> clause with the join (clearer) or implied by the <code class="language-plaintext highlighter-rouge">WHERE</code> clause (old-fashioned).</p> <p>We use the <code class="language-plaintext highlighter-rouge">l_regions</code> and the <code class="language-plaintext highlighter-rouge">l_nations</code> tables from the TPC-H schema:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE l_regions (
    r_regionkey INTEGER NOT NULL PRIMARY KEY,
    r_name      CHAR(25) NOT NULL,
    r_comment   VARCHAR(152)
);

CREATE TABLE l_nations (
    n_nationkey INTEGER NOT NULL PRIMARY KEY,
    n_name      CHAR(25) NOT NULL,
    n_regionkey INTEGER NOT NULL,
    n_comment   VARCHAR(152),
    FOREIGN KEY (n_regionkey) REFERENCES l_regions(r_regionkey)
);</pre> <p>Return the regions for the nations:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT n.*, r.*
FROM l_nations n
JOIN l_regions r ON (n_regionkey = r_regionkey);</pre> <p>If the column names are the same and are required to be equal, then the simpler <code class="language-plaintext highlighter-rouge">USING</code> syntax can be used:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE l_regions (regionkey INTEGER NOT NULL PRIMARY KEY,
                        name      CHAR(25) NOT NULL,
                        comment   VARCHAR(152));

CREATE TABLE l_nations (nationkey INTEGER NOT NULL PRIMARY KEY,
                        name      CHAR(25) NOT NULL,
                        regionkey INTEGER NOT NULL,
                        comment   VARCHAR(152),
                        FOREIGN KEY (regionkey) REFERENCES l_regions(regionkey));</pre> <p>Return the regions for the nations:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT n.*, r.*
FROM l_nations n
JOIN l_regions r USING (regionkey);</pre> <p>The expressions do not have to be equalities – any predicate can be used:</p> <p>Return the pairs of jobs where one ran longer but cost less:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT s1.t_id, s2.t_id
FROM west s1, west s2
WHERE s1.time &gt; s2.time
  AND s1.cost &lt; s2.cost;</pre> <h3 id="natural-joins"> <a style="text-decoration: none;" href="#natural-joins">Natural Joins</a> </h3> <p>Natural joins join two tables based on attributes that share the same name.</p> <p>For example, take the following example with cities, airport codes and airport names. Note that both tables are intentionally incomplete, i.e., they do not have a matching pair in the other table.</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE city_airport (city_name VARCHAR, iata VARCHAR);
CREATE TABLE airport_names (iata VARCHAR, airport_name VARCHAR);
INSERT INTO city_airport VALUES
    ('Amsterdam', 'AMS'),
    ('Rotterdam', 'RTM'),
    ('Eindhoven', 'EIN'),
    ('Groningen', 'GRQ');
INSERT INTO airport_names VALUES
    ('AMS', 'Amsterdam Airport Schiphol'),
    ('RTM', 'Rotterdam The Hague Airport'),
    ('MST', 'Maastricht Aachen Airport');</pre> <p>To join the tables on their shared <a href="https://en.wikipedia.org/wiki/IATA_airport_code"><code class="language-plaintext highlighter-rouge">IATA</code></a> attributes, run:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT *
FROM city_airport
NATURAL JOIN airport_names;</pre> <p>This produces the following result:</p> <table> <thead> <tr> <th>city_name</th> <th>iata</th> <th>airport_name</th> </tr> </thead> <tbody> <tr> <td>Amsterdam</td> <td>AMS</td> <td>Amsterdam Airport Schiphol</td> </tr> <tr> <td>Rotterdam</td> <td>RTM</td> <td>Rotterdam The Hague Airport</td> </tr> </tbody> </table> <p>Note that only rows where the same <code class="language-plaintext highlighter-rouge">iata</code> attribute was present in both tables were included in the result.</p> <p>We can also express query using the vanilla <code class="language-plaintext highlighter-rouge">JOIN</code> clause with the <code class="language-plaintext highlighter-rouge">USING</code> keyword:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT *
FROM city_airport
JOIN airport_names
USING (iata);</pre> <h3 id="semi-and-anti-joins"> <a style="text-decoration: none;" href="#semi-and-anti-joins">Semi and Anti Joins</a> </h3> <p>Semi joins return rows from the left table that have at least one match in the right table. Anti joins return rows from the left table that have <em>no</em> matches in the right table. When using a semi or anti join the result will never have more rows than the left hand side table. Semi joins provide the same logic as the <a href="../expressions/in.html"><code class="language-plaintext highlighter-rouge">IN</code> operator</a> statement. Anti joins provide the same logic as the <code class="language-plaintext highlighter-rouge">NOT IN</code> operator, except anti joins ignore <code class="language-plaintext highlighter-rouge">NULL</code> values from the right table.</p> <h4 id="semi-join-example"> <a style="text-decoration: none;" href="#semi-join-example">Semi Join Example</a> </h4> <p>Return a list of city–airport code pairs from the <code class="language-plaintext highlighter-rouge">city_airport</code> table where the airport name <strong>is available</strong> in the <code class="language-plaintext highlighter-rouge">airport_names</code> table:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT *
FROM city_airport
SEMI JOIN airport_names
    USING (iata);</pre> <table> <thead> <tr> <th>city_name</th> <th>iata</th> </tr> </thead> <tbody> <tr> <td>Amsterdam</td> <td>AMS</td> </tr> <tr> <td>Rotterdam</td> <td>RTM</td> </tr> </tbody> </table> <p>This query is equivalent with:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT *
FROM city_airport
WHERE iata IN (SELECT iata FROM airport_names);</pre> <h4 id="anti-join-example"> <a style="text-decoration: none;" href="#anti-join-example">Anti Join Example</a> </h4> <p>Return a list of city–airport code pairs from the <code class="language-plaintext highlighter-rouge">city_airport</code> table where the airport name <strong>is not available</strong> in the <code class="language-plaintext highlighter-rouge">airport_names</code> table:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT *
FROM city_airport
ANTI JOIN airport_names
    USING (iata);</pre> <table> <thead> <tr> <th>city_name</th> <th>iata</th> </tr> </thead> <tbody> <tr> <td>Eindhoven</td> <td>EIN</td> </tr> <tr> <td>Groningen</td> <td>GRQ</td> </tr> </tbody> </table> <p>This query is equivalent with:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT *
FROM city_airport
WHERE iata NOT IN (SELECT iata FROM airport_names WHERE iata IS NOT NULL);</pre> <h3 id="lateral-joins"> <a style="text-decoration: none;" href="#lateral-joins">Lateral Joins</a> </h3> <p>The <code class="language-plaintext highlighter-rouge">LATERAL</code> keyword allows subqueries in the <code class="language-plaintext highlighter-rouge">FROM</code> clause to refer to previous subqueries. This feature is also known as a <em>lateral join</em>.</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT *
FROM range(3) t(i), LATERAL (SELECT i + 1) t2(j);</pre>  <table> <thead> <tr> <th style="text-align: right">i</th> <th style="text-align: right">j</th> </tr> </thead> <tbody> <tr> <td style="text-align: right">0</td> <td style="text-align: right">1</td> </tr> <tr> <td style="text-align: right">2</td> <td style="text-align: right">3</td> </tr> <tr> <td style="text-align: right">1</td> <td style="text-align: right">2</td> </tr> </tbody> </table> <p>Lateral joins are a generalization of correlated subqueries, as they can return multiple values per input value rather than only a single value.</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT *
FROM
    generate_series(0, 1) t(i),
    LATERAL (SELECT i + 10 UNION ALL SELECT i + 100) t2(j);</pre>  <table> <thead> <tr> <th style="text-align: right">i</th> <th style="text-align: right">j</th> </tr> </thead> <tbody> <tr> <td style="text-align: right">0</td> <td style="text-align: right">10</td> </tr> <tr> <td style="text-align: right">1</td> <td style="text-align: right">11</td> </tr> <tr> <td style="text-align: right">0</td> <td style="text-align: right">100</td> </tr> <tr> <td style="text-align: right">1</td> <td style="text-align: right">101</td> </tr> </tbody> </table> <p>It may be helpful to think about <code class="language-plaintext highlighter-rouge">LATERAL</code> as a loop where we iterate through the rows of the first subquery and use it as input to the second (<code class="language-plaintext highlighter-rouge">LATERAL</code>) subquery. In the examples above, we iterate through table <code class="language-plaintext highlighter-rouge">t</code> and refer to its column <code class="language-plaintext highlighter-rouge">i</code> from the definition of table <code class="language-plaintext highlighter-rouge">t2</code>. The rows of <code class="language-plaintext highlighter-rouge">t2</code> form column <code class="language-plaintext highlighter-rouge">j</code> in the result.</p> <p>It is possible to refer to multiple attributes from the <code class="language-plaintext highlighter-rouge">LATERAL</code> subquery. Using the table from the first example:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE t1 AS
    SELECT *
    FROM range(3) t(i), LATERAL (SELECT i + 1) t2(j);

SELECT *
    FROM t1, LATERAL (SELECT i + j) t2(k)
    ORDER BY ALL;</pre>  <table> <thead> <tr> <th style="text-align: right">i</th> <th style="text-align: right">j</th> <th style="text-align: right">k</th> </tr> </thead> <tbody> <tr> <td style="text-align: right">0</td> <td style="text-align: right">1</td> <td style="text-align: right">1</td> </tr> <tr> <td style="text-align: right">1</td> <td style="text-align: right">2</td> <td style="text-align: right">3</td> </tr> <tr> <td style="text-align: right">2</td> <td style="text-align: right">3</td> <td style="text-align: right">5</td> </tr> </tbody> </table> <blockquote> <p>DuckDB detects when <code class="language-plaintext highlighter-rouge">LATERAL</code> joins should be used, making the use of the <code class="language-plaintext highlighter-rouge">LATERAL</code> keyword optional.</p> </blockquote> <h3 id="positional-joins"> <a style="text-decoration: none;" href="#positional-joins">Positional Joins</a> </h3> <p>When working with data frames or other embedded tables of the same size, the rows may have a natural correspondence based on their physical order. In scripting languages, this is easily expressed using a loop:</p> <pre class="language-cpp highlighter-rouge" data-language="cpp">for (i = 0; i &lt; n; i++) {
    f(t1.a[i], t2.b[i]);
}</pre> <p>It is difficult to express this in standard SQL because relational tables are not ordered, but imported tables such as <a href="#">data frames</a> or disk files (like <a href="../../data/csv/overview.html">CSVs</a> or <a href="../../data/parquet/overview.html">Parquet files</a>) do have a natural ordering.</p> <p>Connecting them using this ordering is called a <em>positional join:</em></p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE t1 (x INTEGER);
CREATE TABLE t2 (s VARCHAR);

INSERT INTO t1 VALUES (1), (2), (3);
INSERT INTO t2 VALUES ('a'), ('b');

SELECT *
FROM t1
POSITIONAL JOIN t2;</pre>  <table> <thead> <tr> <th style="text-align: right">x</th> <th>s</th> </tr> </thead> <tbody> <tr> <td style="text-align: right">1</td> <td>a</td> </tr> <tr> <td style="text-align: right">2</td> <td>b</td> </tr> <tr> <td style="text-align: right">3</td> <td>NULL</td> </tr> </tbody> </table> <p>Positional joins are always <code class="language-plaintext highlighter-rouge">FULL OUTER</code> joins, i.e., missing values (the last values in the shorter column) are set to <code class="language-plaintext highlighter-rouge">NULL</code>.</p> <h3 id="as-of-joins"> <a style="text-decoration: none;" href="#as-of-joins">As-Of Joins</a> </h3> <p>A common operation when working with temporal or similarly-ordered data is to find the nearest (first) event in a reference table (such as prices). This is called an <em>as-of join:</em></p> <p>Attach prices to stock trades:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT t.*, p.price
FROM trades t
ASOF JOIN prices p
       ON t.symbol = p.symbol AND t.when &gt;= p.when;</pre> <p>The <code class="language-plaintext highlighter-rouge">ASOF</code> join requires at least one inequality condition on the ordering field. The inequality can be any inequality condition (<code class="language-plaintext highlighter-rouge">&gt;=</code>, <code class="language-plaintext highlighter-rouge">&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;=</code>, <code class="language-plaintext highlighter-rouge">&lt;</code>) on any data type, but the most common form is <code class="language-plaintext highlighter-rouge">&gt;=</code> on a temporal type. Any other conditions must be equalities (or <code class="language-plaintext highlighter-rouge">NOT DISTINCT</code>). This means that the left/right order of the tables is significant.</p> <p><code class="language-plaintext highlighter-rouge">ASOF</code> joins each left side row with at most one right side row. It can be specified as an <code class="language-plaintext highlighter-rouge">OUTER</code> join to find unpaired rows (e.g., trades without prices or prices which have no trades.)</p> <p>Attach prices or NULLs to stock trades:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT *
FROM trades t
ASOF LEFT JOIN prices p
            ON t.symbol = p.symbol
           AND t.when &gt;= p.when;</pre> <p><code class="language-plaintext highlighter-rouge">ASOF</code> joins can also specify join conditions on matching column names with the <code class="language-plaintext highlighter-rouge">USING</code> syntax, but the <em>last</em> attribute in the list must be the inequality, which will be greater than or equal to (<code class="language-plaintext highlighter-rouge">&gt;=</code>):</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT *
FROM trades t
ASOF JOIN prices p USING (symbol, "when");</pre> <p>Returns symbol, trades.when, price (but NOT prices.when):</p> <p>If you combine <code class="language-plaintext highlighter-rouge">USING</code> with a <code class="language-plaintext highlighter-rouge">SELECT *</code> like this, the query will return the left side (probe) column values for the matches, not the right side (build) column values. To get the <code class="language-plaintext highlighter-rouge">prices</code> times in the example, you will need to list the columns explicitly:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT t.symbol, t.when AS trade_when, p.when AS price_when, price
FROM trades t
ASOF LEFT JOIN prices p USING (symbol, "when");</pre> <h3 id="self-joins"> <a style="text-decoration: none;" href="#self-joins">Self-Joins</a> </h3> <p>DuckDB allows self-joins for all types of joins. Note that tables need to be aliased, using the same table name without aliases will result in an error:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE t(x int);
SELECT * FROM t JOIN t USING(x);</pre> <pre class="language-console highlighter-rouge" data-language="console">Binder Error: Duplicate alias "t" in query!</pre> <p>Adding the aliases allows the query to parse successfully:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT * FROM t AS t t1 JOIN t t2 USING(x);</pre> <h2 id="from-first-syntax"> <a style="text-decoration: none;" href="#from-first-syntax"><code class="language-plaintext highlighter-rouge">FROM</code>-First Syntax</a> </h2> <p>DuckDB's SQL supports the <code class="language-plaintext highlighter-rouge">FROM</code>-first syntax, i.e., it allows putting the <code class="language-plaintext highlighter-rouge">FROM</code> clause before the <code class="language-plaintext highlighter-rouge">SELECT</code> clause or completely omitting the <code class="language-plaintext highlighter-rouge">SELECT</code> clause. We use the following example to demonstrate it:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE tbl AS
    SELECT *
    FROM (VALUES ('a'), ('b')) t1(s), range(1, 3) t2(i);</pre> <h3 id="from-first-syntax-with-a-select-clause"> <a style="text-decoration: none;" href="#from-first-syntax-with-a-select-clause"><code class="language-plaintext highlighter-rouge">FROM</code>-First Syntax with a <code class="language-plaintext highlighter-rouge">SELECT</code> Clause</a> </h3> <p>The following statement demonstrates the use of the <code class="language-plaintext highlighter-rouge">FROM</code>-first syntax:</p> <pre class="language-sql highlighter-rouge" data-language="sql">FROM tbl
SELECT i, s;</pre> <p>This is equivalent to:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT i, s
FROM tbl;</pre>  <table> <thead> <tr> <th style="text-align: right">i</th> <th>s</th> </tr> </thead> <tbody> <tr> <td style="text-align: right">1</td> <td>a</td> </tr> <tr> <td style="text-align: right">2</td> <td>a</td> </tr> <tr> <td style="text-align: right">1</td> <td>b</td> </tr> <tr> <td style="text-align: right">2</td> <td>b</td> </tr> </tbody> </table> <h3 id="from-first-syntax-without-a-select-clause"> <a style="text-decoration: none;" href="#from-first-syntax-without-a-select-clause"><code class="language-plaintext highlighter-rouge">FROM</code>-First Syntax without a <code class="language-plaintext highlighter-rouge">SELECT</code> Clause</a> </h3> <p>The following statement demonstrates the use of the optional <code class="language-plaintext highlighter-rouge">SELECT</code> clause:</p> <pre class="language-sql highlighter-rouge" data-language="sql">FROM tbl;</pre> <p>This is equivalent to:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT *
FROM tbl;</pre>  <table> <thead> <tr> <th>s</th> <th style="text-align: right">i</th> </tr> </thead> <tbody> <tr> <td>a</td> <td style="text-align: right">1</td> </tr> <tr> <td>a</td> <td style="text-align: right">2</td> </tr> <tr> <td>b</td> <td style="text-align: right">1</td> </tr> <tr> <td>b</td> <td style="text-align: right">2</td> </tr> </tbody> </table> <h2 id="syntax"> <a style="text-decoration: none;" href="#syntax">Syntax</a> </h2><div class="_attribution">
  <p class="_attribution-p">
    &copy; Copyright 2018&ndash;2024 Stichting DuckDB Foundation<br>Licensed under the MIT License.<br>
    <a href="https://duckdb.org/docs/sql/query_syntax/from.html" class="_attribution-link">https://duckdb.org/docs/sql/query_syntax/from.html</a>
  </p>
</div>
