<h1 class="title">Friendly SQL</h1>  <p>DuckDB offers several advanced SQL features and syntactic sugar to make SQL queries more concise. We refer to these colloquially as “friendly SQL”.</p> <blockquote> <p>Several of these features are also supported in other systems while some are (currently) exclusive to DuckDB.</p> </blockquote> <h2 id="clauses"> <a style="text-decoration: none;" href="#clauses">Clauses</a> </h2> <ul> <li>Creating tables and inserting data: <ul> <li>
<a href="../statements/create_table.html#create-or-replace.html"><code class="language-plaintext highlighter-rouge">CREATE OR REPLACE TABLE</code></a>: avoid <code class="language-plaintext highlighter-rouge">DROP TABLE IF EXISTS</code> statements in scripts.</li> <li>
<a href="../statements/create_table.html#create-table--as-select-ctas.html"><code class="language-plaintext highlighter-rouge">CREATE TABLE ... AS SELECT</code> (CTAS)</a>: create a new table from the output of a table without manually defining a schema.</li> <li>
<a href="../statements/insert.html#insert-into--by-name.html"><code class="language-plaintext highlighter-rouge">INSERT INTO ... BY NAME</code></a>: this variant of the <code class="language-plaintext highlighter-rouge">INSERT</code> statement allows using column names instead of positions.</li> <li>
<a href="../statements/insert.html#insert-or-ignore-into.html"><code class="language-plaintext highlighter-rouge">INSERT OR IGNORE INTO ...</code></a>: insert the rows that do not result in a conflict due to <code class="language-plaintext highlighter-rouge">UNIQUE</code> or <code class="language-plaintext highlighter-rouge">PRIMARY KEY</code> constraints.</li> <li>
<a href="../statements/insert.html#insert-or-replace-into.html"><code class="language-plaintext highlighter-rouge">INSERT OR REPLACE INTO ...</code></a>: insert the rows that do not result in a conflict due to <code class="language-plaintext highlighter-rouge">UNIQUE</code> or <code class="language-plaintext highlighter-rouge">PRIMARY KEY</code> constraints. For those that result in a conflict, replace the columns of the existing row to the new values of the to-be-inserted row.</li> </ul> </li> <li>Describing tables and computing statistics: <ul> <li>
<a href="../../guides/meta/describe.html"><code class="language-plaintext highlighter-rouge">DESCRIBE</code></a>: provides a succinct summary of the schema of a table or query.</li> <li>
<a href="../../guides/meta/summarize.html"><code class="language-plaintext highlighter-rouge">SUMMARIZE</code></a>: returns summary statistics for a table or query.</li> </ul> </li> <li>Making SQL clauses more compact: <ul> <li>
<a href="../query_syntax/from.html#from-first-syntax.html"><code class="language-plaintext highlighter-rouge">FROM</code>-first syntax with an optional <code class="language-plaintext highlighter-rouge">SELECT</code> clause</a>: DuckDB allows queries in the form of <code class="language-plaintext highlighter-rouge">FROM tbl</code> which selects all columns (performing a <code class="language-plaintext highlighter-rouge">SELECT *</code> statement).</li> <li>
<a href="../query_syntax/groupby.html#group-by-all.html"><code class="language-plaintext highlighter-rouge">GROUP BY ALL</code></a>: omit the group-by columns by inferring them from the list of attributes in the <code class="language-plaintext highlighter-rouge">SELECT</code> clause.</li> <li>
<a href="../query_syntax/orderby.html#order-by-all.html"><code class="language-plaintext highlighter-rouge">ORDER BY ALL</code></a>: shorthand to order on all columns (e.g., to ensure deterministic results).</li> <li>
<a href="../expressions/star.html#exclude-clause.html"><code class="language-plaintext highlighter-rouge">SELECT * EXCLUDE</code></a>: the <code class="language-plaintext highlighter-rouge">EXCLUDE</code> option allows excluding specific columns from the <code class="language-plaintext highlighter-rouge">*</code> expression.</li> <li>
<a href="../expressions/star.html#replace-clause.html"><code class="language-plaintext highlighter-rouge">SELECT * REPLACE</code></a>: the <code class="language-plaintext highlighter-rouge">REPLACE</code> option allows replacing specific columns with different expressions in a <code class="language-plaintext highlighter-rouge">*</code> expression.</li> <li>
<a href="../query_syntax/setops.html#union-all-by-name.html"><code class="language-plaintext highlighter-rouge">UNION BY NAME</code></a>: perform the <code class="language-plaintext highlighter-rouge">UNION</code> operation along the names of columns (instead of relying on positions).</li> </ul> </li> <li>Transforming tables: <ul> <li>
<a href="../statements/pivot.html"><code class="language-plaintext highlighter-rouge">PIVOT</code></a> to turn long tables to wide tables.</li> <li>
<a href="../statements/unpivot.html"><code class="language-plaintext highlighter-rouge">UNPIVOT</code></a> to turn wide tables to long tables.</li> </ul> </li> <li>Defining SQL-level variables: <ul> <li><a href="../statements/set.html#set-variable.html"><code class="language-plaintext highlighter-rouge">SET VARIABLE</code></a></li> <li><a href="../statements/set.html#reset-variable.html"><code class="language-plaintext highlighter-rouge">RESET VARIABLE</code></a></li> </ul> </li> </ul> <h2 id="query-features"> <a style="text-decoration: none;" href="#query-features">Query Features</a> </h2> <ul> <li><a href="http://localhost:8000/2022/05/04/friendlier-sql.html#column-aliases-in-where--group-by--having">Column aliases in <code class="language-plaintext highlighter-rouge">WHERE</code>, <code class="language-plaintext highlighter-rouge">GROUP BY</code>, and <code class="language-plaintext highlighter-rouge">HAVING</code></a></li> <li>
<a href="../expressions/star.html#columns-expression.html"><code class="language-plaintext highlighter-rouge">COLUMNS()</code> expression</a> can be used to execute the same expression on multiple columns: <ul> <li><a href="http://localhost:8000/2023/08/23/even-friendlier-sql.html#columns-with-regular-expressions">with regular expressions</a></li> <li><a href="http://localhost:8000/2023/08/23/even-friendlier-sql.html#columns-with-exclude-and-replace">with <code class="language-plaintext highlighter-rouge">EXCLUDE</code> and <code class="language-plaintext highlighter-rouge">REPLACE</code></a></li> <li><a href="http://localhost:8000/2023/08/23/even-friendlier-sql.html#columns-with-lambda-functions">with lambda functions</a></li> </ul> </li> <li>Reusable column aliases, e.g.: <code class="language-plaintext highlighter-rouge">SELECT i + 1 AS j, j + 2 AS k FROM range(0, 3) t(i)</code>
</li> <li>Advanced aggregation features for analytical (OLAP) queries: <ul> <li><a href="../query_syntax/filter.html"><code class="language-plaintext highlighter-rouge">FILTER</code> clause</a></li> <li><a href="../query_syntax/grouping_sets.html"><code class="language-plaintext highlighter-rouge">GROUPING SETS</code>, <code class="language-plaintext highlighter-rouge">GROUP BY CUBE</code>, <code class="language-plaintext highlighter-rouge">GROUP BY ROLLUP</code> clauses</a></li> </ul> </li> <li>
<a href="../functions/aggregates.html"><code class="language-plaintext highlighter-rouge">count()</code> shorthand</a> for <code class="language-plaintext highlighter-rouge">count(*)</code>
</li> </ul> <h2 id="literals-and-identifiers"> <a style="text-decoration: none;" href="#literals-and-identifiers">Literals and Identifiers</a> </h2> <ul> <li><a href="keywords_and_identifiers.html#case-sensitivity-of-identifiers.html">Case-insensitivity while maintaining case of entities in the catalog</a></li> <li><a href="keywords_and_identifiers.html#deduplicating-identifiers.html">Deduplicating identifiers</a></li> <li><a href="keywords_and_identifiers.html#numeric-literals.html">Underscores as digit separators in numeric literals</a></li> </ul> <h2 id="data-types"> <a style="text-decoration: none;" href="#data-types">Data Types</a> </h2> <ul> <li><a href="../data_types/map.html"><code class="language-plaintext highlighter-rouge">MAP</code> data type</a></li> <li><a href="../data_types/union.html"><code class="language-plaintext highlighter-rouge">UNION</code> data type</a></li> </ul> <h2 id="data-import"> <a style="text-decoration: none;" href="#data-import">Data Import</a> </h2> <ul> <li><a href="../../data/csv/auto_detection.html">Auto-detecting the headers and schema of CSV files</a></li> <li>Directly querying <a href="../../data/csv/overview.html">CSV files</a> and <a href="../../data/parquet/overview.html">Parquet files</a>
</li> <li>Loading from files using the syntax <code class="language-plaintext highlighter-rouge">FROM 'my.csv'</code>, <code class="language-plaintext highlighter-rouge">FROM 'my.csv.gz'</code>, <code class="language-plaintext highlighter-rouge">FROM 'my.parquet'</code>, etc.</li> <li>
<a href="../functions/pattern_matching.html#globbing.html">Filename expansion (globbing)</a>, e.g.: <code class="language-plaintext highlighter-rouge">FROM 'my-data/part-*.parquet'</code>
</li> </ul> <h2 id="functions-and-expressions"> <a style="text-decoration: none;" href="#functions-and-expressions">Functions and Expressions</a> </h2> <ul> <li>
<a href="../functions/overview.html#function-chaining-via-the-dot-operator.html">Dot operator for function chaining</a>: <code class="language-plaintext highlighter-rouge">SELECT ('hello').upper()</code>
</li> <li>String formatters: the <a href="../functions/char.html#fmt-syntax.html"><code class="language-plaintext highlighter-rouge">format()</code> function with the <code class="language-plaintext highlighter-rouge">fmt</code> syntax</a> and the <a href="../functions/char.html#printf-syntax.html"><code class="language-plaintext highlighter-rouge">printf() function</code></a>
</li> <li><a href="http://localhost:8000/2023/08/23/even-friendlier-sql.html#list-comprehensions">List comprehensions</a></li> <li><a href="http://localhost:8000/2022/05/04/friendlier-sql.html#string-slicing">List slicing</a></li> <li><a href="http://localhost:8000/2022/05/04/friendlier-sql.html#string-slicing">String slicing</a></li> <li><a href="http://localhost:8000/2022/05/04/friendlier-sql.html#struct-dot-notation"><code class="language-plaintext highlighter-rouge">STRUCT.*</code> notation</a></li> <li><a href="http://localhost:8000/2022/05/04/friendlier-sql.html#simple-list-and-struct-creation">Simple <code class="language-plaintext highlighter-rouge">LIST</code> and <code class="language-plaintext highlighter-rouge">STRUCT</code> creation</a></li> </ul> <h2 id="join-types"> <a style="text-decoration: none;" href="#join-types">Join Types</a> </h2> <ul> <li><a href="../query_syntax/from.html#as-of-joins.html"><code class="language-plaintext highlighter-rouge">ASOF</code> joins</a></li> <li><a href="../query_syntax/from.html#lateral-joins.html"><code class="language-plaintext highlighter-rouge">LATERAL</code> joins</a></li> <li><a href="../query_syntax/from.html#positional-joins.html"><code class="language-plaintext highlighter-rouge">POSITIONAL</code> joins</a></li> </ul> <h2 id="trailing-commas"> <a style="text-decoration: none;" href="#trailing-commas">Trailing Commas</a> </h2> <p>DuckDB allows <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Trailing_commas">trailing commas</a>, both when listing entities (e.g., column and table names) and when constructing <a href="../data_types/list.html#creating-lists.html"><code class="language-plaintext highlighter-rouge">LIST</code> items</a>. For example, the following query works:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT
    42 AS x,
    ['a', 'b', 'c',] AS y,
    'hello world' AS z,
;</pre> <h2 id="top-n-in-group-queries"> <a style="text-decoration: none;" href="#top-n-in-group-queries">"Top-N in Group" Queries</a> </h2> <p>Computing the "top-N rows in a group" ordered by some criteria is a common task in SQL that unfortunately often requires a complex query involving window functions and/or subqueries.</p> <p>To aid in this, DuckDB provides the aggregate functions <a href="../functions/aggregates.html#maxarg-n.html"><code class="language-plaintext highlighter-rouge">max(arg, n)</code></a>, <a href="../functions/aggregates.html#minarg-n.html"><code class="language-plaintext highlighter-rouge">min(arg, n)</code></a>, <a href="../functions/aggregates.html#arg_maxarg-val-n.html"><code class="language-plaintext highlighter-rouge">arg_max(arg, val, n)</code></a>, <a href="../functions/aggregates.html#arg_minarg-val-n.html"><code class="language-plaintext highlighter-rouge">arg_min(arg, val, n)</code></a>, <a href="../functions/aggregates.html#max_byarg-val-n.html"><code class="language-plaintext highlighter-rouge">max_by(arg, val, n)</code></a> and <a href="../functions/aggregates.html#min_byarg-val-n.html"><code class="language-plaintext highlighter-rouge">min_by(arg, val, n)</code></a> to efficiently return the "top" <code class="language-plaintext highlighter-rouge">n</code> rows in a group based on a specific column in either ascending or descending order.</p> <p>For example, let's use the following table:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT * FROM t1;</pre> <pre class="language-text highlighter-rouge" data-language="text">┌─────────┬───────┐
│   grp   │  val  │
│ varchar │ int32 │
├─────────┼───────┤
│ a       │     2 │
│ a       │     1 │
│ b       │     5 │
│ b       │     4 │
│ a       │     3 │
│ b       │     6 │
└─────────┴───────┘</pre> <p>We want to get a list of the top-3 <code class="language-plaintext highlighter-rouge">val</code> values in each group <code class="language-plaintext highlighter-rouge">grp</code>. The conventional way to do this is to use a window function in a subquery:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT array_agg(rs.val), rs.grp
FROM
    (SELECT val, grp, row_number() OVER (PARTITION BY grp ORDER BY val DESC) AS rid
    FROM t1 ORDER BY val DESC) AS rs
WHERE rid &lt; 4
GROUP BY rs.grp;</pre> <pre class="language-text highlighter-rouge" data-language="text">┌───────────────────┬─────────┐
│ array_agg(rs.val) │   grp   │
│      int32[]      │ varchar │
├───────────────────┼─────────┤
│ [3, 2, 1]         │ a       │
│ [6, 5, 4]         │ b       │
└───────────────────┴─────────┘</pre> <p>But in DuckDB, we can do this much more concisely (and efficiently!):</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT max(val, 3) FROM t1 GROUP BY grp;</pre> <pre class="language-text highlighter-rouge" data-language="text">┌─────────────┐
│ max(val, 3) │
│   int32[]   │
├─────────────┤
│ [3, 2, 1]   │
│ [6, 5, 4]   │
└─────────────┘</pre> <h2 id="related-blog-posts"> <a style="text-decoration: none;" href="#related-blog-posts">Related Blog Posts</a> </h2> <ul> <li>
<a href="http://localhost:8000/2022/05/04/friendlier-sql.html">“Friendlier SQL with DuckDB”</a> blog post</li> <li>
<a href="http://localhost:8000/2023/08/23/even-friendlier-sql.html">“Even Friendlier SQL with DuckDB”</a> blog post</li> <li>
<a href="http://localhost:8000/2024/03/01/sql-gymnastics.html">“SQL Gymnastics: Bending SQL into Flexible New Shapes”</a> blog post</li> </ul><div class="_attribution">
  <p class="_attribution-p">
    &copy; Copyright 2018&ndash;2024 Stichting DuckDB Foundation<br>Licensed under the MIT License.<br>
    <a href="https://duckdb.org/docs/sql/dialect/friendly_sql.html" class="_attribution-link">https://duckdb.org/docs/sql/dialect/friendly_sql.html</a>
  </p>
</div>
