<h1 class="title">PostgreSQL Compatibility</h1>  <p>DuckDB's SQL dialect closely follows the conventions of the PostgreSQL dialect. The few exceptions to this are listed on this page.</p> <h2 id="floating-point-arithmetic"> <a style="text-decoration: none;" href="#floating-point-arithmetic">Floating-Point Arithmetic</a> </h2> <p>DuckDB and PostgreSQL handle floating-point arithmetic differently for division by zero. DuckDB conforms to the <a href="https://en.wikipedia.org/wiki/IEEE_754">IEEE Standard for Floating-Point Arithmetic (IEEE 754)</a> for both division by zero and operations involving infinity values. PostgreSQL returns an error for division by zero but aligns with IEEE 754 for handling infinity values. To show the differences, run the following SQL queries:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT 1.0 / 0.0 AS x;
SELECT 0.0 / 0.0 AS x;
SELECT -1.0 / 0.0 AS x;
SELECT 'Infinity'::FLOAT / 'Infinity'::FLOAT AS x;
SELECT 1.0 / 'Infinity'::FLOAT AS x;
SELECT 'Infinity'::FLOAT - 'Infinity'::FLOAT AS x;
SELECT 'Infinity'::FLOAT - 1.0 AS x;</pre>  <table> <thead> <tr> <th style="text-align: left">Expression</th> <th style="text-align: right">PostgreSQL</th> <th style="text-align: right">DuckDB</th> <th style="text-align: right">IEEE 754</th> </tr> </thead> <tbody> <tr> <td style="text-align: left">1.0 / 0.0</td> <td style="text-align: right">error</td> <td style="text-align: right">Infinity</td> <td style="text-align: right">Infinity</td> </tr> <tr> <td style="text-align: left">0.0 / 0.0</td> <td style="text-align: right">error</td> <td style="text-align: right">NaN</td> <td style="text-align: right">NaN</td> </tr> <tr> <td style="text-align: left">-1.0 / 0.0</td> <td style="text-align: right">error</td> <td style="text-align: right">-Infinity</td> <td style="text-align: right">-Infinity</td> </tr> <tr> <td style="text-align: left">'Infinity' / 'Infinity'</td> <td style="text-align: right">NaN</td> <td style="text-align: right">NaN</td> <td style="text-align: right">NaN</td> </tr> <tr> <td style="text-align: left">1.0 / 'Infinity'</td> <td style="text-align: right">0.0</td> <td style="text-align: right">0.0</td> <td style="text-align: right">0.0</td> </tr> <tr> <td style="text-align: left">'Infinity' - 'Infinity'</td> <td style="text-align: right">NaN</td> <td style="text-align: right">NaN</td> <td style="text-align: right">NaN</td> </tr> <tr> <td style="text-align: left">'Infinity' - 1.0</td> <td style="text-align: right">Infinity</td> <td style="text-align: right">Infinity</td> <td style="text-align: right">Infinity</td> </tr> </tbody> </table> <h2 id="division-on-integers"> <a style="text-decoration: none;" href="#division-on-integers">Division on Integers</a> </h2> <p>When computing division on integers, PostgreSQL performs integer division, while DuckDB performs float division:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT 1 / 2 AS x;</pre> <p>PostgreSQL returns:</p> <pre class="language-text highlighter-rouge" data-language="text">x
---
 0
(1 row)</pre> <p>DuckDB returns:</p> <table> <thead> <tr> <th style="text-align: right">x</th> </tr> </thead> <tbody> <tr> <td style="text-align: right">0.5</td> </tr> </tbody> </table> <p>To perform integer division in DuckDB, use the <code class="language-plaintext highlighter-rouge">//</code> operator:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT 1 // 2 AS x;</pre> <table> <thead> <tr> <th style="text-align: right">x</th> </tr> </thead> <tbody> <tr> <td style="text-align: right">0</td> </tr> </tbody> </table> <h2 id="union-of-boolean-and-integer-values"> <a style="text-decoration: none;" href="#union-of-boolean-and-integer-values"><code class="language-plaintext highlighter-rouge">UNION</code> of Boolean and Integer Values</a> </h2> <p>The following query fails in PostgreSQL but successfully completes in DuckDB:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT true AS x
UNION
SELECT 2;</pre> <p>PostgreSQL returns an error:</p> <pre class="language-console highlighter-rouge" data-language="console">ERROR:  UNION types boolean and integer cannot be matched</pre> <p>DuckDB performs an enforced cast, therefore, it completes the query and returns the following:</p> <table> <thead> <tr> <th style="text-align: right">x</th> </tr> </thead> <tbody> <tr> <td style="text-align: right">1</td> </tr> <tr> <td style="text-align: right">2</td> </tr> </tbody> </table> <h2 id="case-sensitivity-for-quoted-identifiers"> <a style="text-decoration: none;" href="#case-sensitivity-for-quoted-identifiers">Case Sensitivity for Quoted Identifiers</a> </h2> <p>PostgreSQL is case-insensitive. The way PostgreSQL achieves case insensitivity is by lowercasing unquoted identifiers within SQL, whereas quoting preserves case, e.g., the following command creates a table named <code class="language-plaintext highlighter-rouge">mytable</code> but tries to query for <code class="language-plaintext highlighter-rouge">MyTaBLe</code> because quotes preserve the case.</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE MyTaBLe(x INT);
SELECT * FROM "MyTaBLe";</pre> <pre class="language-console highlighter-rouge" data-language="console">ERROR:  relation "MyTaBLe" does not exist</pre> <p>PostgreSQL does not only treat quoted identifiers as case-sensitive, PostgreSQL treats all identifiers as case-sensitive, e.g., this also does not work:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE "PreservedCase"(x INT);
SELECT * FROM PreservedCase;</pre> <pre class="language-console highlighter-rouge" data-language="console">ERROR:  relation "preservedcase" does not exist</pre> <p>Therefore, case-insensitivity in PostgreSQL only works if you never use quoted identifiers with different cases.</p> <p>For DuckDB, this behavior was problematic when interfacing with other tools (e.g., Parquet, Pandas) that are case-sensitive by default - since all identifiers would be lowercased all the time. Therefore, DuckDB achieves case insensitivity by making identifiers fully case insensitive throughout the system but <a href="keywords_and_identifiers.html#rules-for-case-sensitivity.html"><em>preserving their case</em></a>.</p> <p>In DuckDB, the scripts above complete successfully:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE MyTaBLe(x INT);
SELECT * FROM "MyTaBLe";
CREATE TABLE "PreservedCase"(x INT);
SELECT * FROM PreservedCase;
SELECT table_name FROM duckdb_tables();</pre>  <table> <thead> <tr> <th>table_name</th> </tr> </thead> <tbody> <tr> <td>MyTaBLe</td> </tr> <tr> <td>PreservedCase</td> </tr> </tbody> </table> <p>PostgreSQL's behavior of lowercasing identifiers is accessible using the <a href="../../configuration/overview.html#local-configuration-options.html"><code class="language-plaintext highlighter-rouge">preserve_identifier_case</code> option</a>:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SET preserve_identifier_case = false;
CREATE TABLE MyTaBLe(x INT);
SELECT table_name FROM duckdb_tables();</pre>  <table> <thead> <tr> <th>table_name</th> </tr> </thead> <tbody> <tr> <td>mytable</td> </tr> </tbody> </table> <p>However, the case insensitive matching in the system for identifiers cannot be turned off.</p> <h2 id="using-double-equality-sign-for-comparison"> <a style="text-decoration: none;" href="#using-double-equality-sign-for-comparison">Using Double Equality Sign for Comparison</a> </h2> <p>DuckDB supports both <code class="language-plaintext highlighter-rouge">=</code> and <code class="language-plaintext highlighter-rouge">==</code> for quality comparison, while Postgres only supports <code class="language-plaintext highlighter-rouge">=</code>.</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT 1 == 1 AS t;</pre> <p>DuckDB returns:</p> <pre class="language-text highlighter-rouge" data-language="text">┌─────────┐
│    t    │
│ boolean │
├─────────┤
│ true    │
└─────────┘</pre> <p>Postgres returns:</p> <pre class="language-console highlighter-rouge" data-language="console">postgres=# SELECT 1 == 1 AS t;
ERROR:  operator does not exist: integer == integer
LINE 1: SELECT 1 == 1 AS t;</pre> <p>Note that the use of <code class="language-plaintext highlighter-rouge">==</code> is not encouraged due to its limited portability.</p> <h2 id="vacuuming-tables"> <a style="text-decoration: none;" href="#vacuuming-tables">Vacuuming tables</a> </h2> <p>In PostgreSQL, the <code class="language-plaintext highlighter-rouge">VACUUM</code> statement garbage collects tables and analyzes tables. In DuckDB, the <a href="../statements/vacuum.html"><code class="language-plaintext highlighter-rouge">VACUUM</code> statement</a> is only used to rebuild statistics. For instruction on reclaiming space, refer to the <a href="../../operations_manual/footprint_of_duckdb/reclaiming_space.html">“Reclaiming space” page</a>.</p> <h2 id="functions"> <a style="text-decoration: none;" href="#functions">Functions</a> </h2> <h3 id="to_date-function"> <a style="text-decoration: none;" href="#to_date-function"><code class="language-plaintext highlighter-rouge">to_date</code> Function</a> </h3> <p>DuckDB does not support the <a href="https://www.postgresql.org/docs/17/functions-formatting.html"><code class="language-plaintext highlighter-rouge">to_date</code> PostgreSQL date formatting function</a>. Instead, please use the <a href="../functions/dateformat.html#strptime-examples.html"><code class="language-plaintext highlighter-rouge">strptime</code> function</a>.</p> <h2 id="resolution-of-type-names-in-the-schema"> <a style="text-decoration: none;" href="#resolution-of-type-names-in-the-schema">Resolution of Type Names in the Schema</a> </h2> <p>For <a href="../statements/create_table.html"><code class="language-plaintext highlighter-rouge">CREATE TABLE</code> statements</a>, DuckDB attempts to resolve type names in the schema where a table is created. For example:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE SCHEMA myschema;
CREATE TYPE myschema.mytype AS ENUM ('as', 'df');
CREATE TABLE myschema.mytable (v mytype);</pre> <p>PostgreSQL returns an error on the last statement:</p> <pre class="language-console highlighter-rouge" data-language="console">ERROR:  type "mytype" does not exist
LINE 1: CREATE TABLE myschema.mytable (v mytype);
                                         ^</pre> <p>DuckDB runs the statement and creates the table successfully, confirmed by the following query:</p> <pre class="language-sql highlighter-rouge" data-language="sql">DESCRIBE myschema.mytable;</pre> <pre class="language-text highlighter-rouge" data-language="text">┌─────────────┬──────────────────┬─────────┬─────────┬─────────┬─────────┐
│ column_name │   column_type    │  null   │   key   │ default │  extra  │
│   varchar   │     varchar      │ varchar │ varchar │ varchar │ varchar │
├─────────────┼──────────────────┼─────────┼─────────┼─────────┼─────────┤
│ v           │ ENUM('as', 'df') │ YES     │ NULL    │ NULL    │ NULL    │
└─────────────┴──────────────────┴─────────┴─────────┴─────────┴─────────┘</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; Copyright 2018&ndash;2024 Stichting DuckDB Foundation<br>Licensed under the MIT License.<br>
    <a href="https://duckdb.org/docs/sql/dialect/postgresql_compatibility.html" class="_attribution-link">https://duckdb.org/docs/sql/dialect/postgresql_compatibility.html</a>
  </p>
</div>
