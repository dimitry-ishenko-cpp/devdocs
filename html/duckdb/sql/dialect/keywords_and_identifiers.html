<h1 class="title">Keywords and Identifiers</h1>  <h2 id="identifiers"> <a style="text-decoration: none;" href="#identifiers">Identifiers</a> </h2> <p>Similarly to other SQL dialects and programming languages, identifiers in DuckDB's SQL are subject to several rules.</p> <ul> <li>Unquoted identifiers need to conform to a number of rules: <ul> <li>They must not be a reserved keyword (see <a href="../meta/duckdb_table_functions.html#duckdb_keywords.html"><code class="language-plaintext highlighter-rouge">duckdb_keywords()</code></a>), e.g., <code class="language-plaintext highlighter-rouge">SELECT 123 AS SELECT</code> will fail.</li> <li>They must not start with a number or special character, e.g., <code class="language-plaintext highlighter-rouge">SELECT 123 AS 1col</code> is invalid.</li> <li>They cannot contain whitespaces (including tabs and newline characters).</li> </ul> </li> <li>Identifiers can be quoted using double-quote characters (<code class="language-plaintext highlighter-rouge">"</code>). Quoted identifiers can use any keyword, whitespace or special character, e.g., <code class="language-plaintext highlighter-rouge">"SELECT"</code> and <code class="language-plaintext highlighter-rouge">" ¬ß ü¶Ü ¬∂ "</code> are valid identifiers.</li> <li>Double quotes can be escaped by repeating the quote character, e.g., to create an identifier named <code class="language-plaintext highlighter-rouge">IDENTIFIER "X"</code>, use <code class="language-plaintext highlighter-rouge">"IDENTIFIER ""X"""</code>.</li> </ul> <h3 id="deduplicating-identifiers"> <a style="text-decoration: none;" href="#deduplicating-identifiers">Deduplicating Identifiers</a> </h3> <p>In some cases, duplicate identifiers can occur, e.g., column names may conflict when unnesting a nested data structure. In these cases, DuckDB automatically deduplicates column names by renaming them according to the following rules:</p> <ul> <li>For a column named <code class="language-plaintext highlighter-rouge">‚ü®name‚ü©</code>, the first instance is not renamed.</li> <li>Subsequent instances are renamed to <code class="language-plaintext highlighter-rouge">‚ü®name‚ü©_‚ü®count‚ü©</code>, where <code class="language-plaintext highlighter-rouge">‚ü®count‚ü©</code> starts at 1.</li> </ul> <p>For example:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT *
FROM (SELECT UNNEST({'a': 42, 'b': {'a': 88, 'b': 99}}, recursive := true));</pre> <table> <thead> <tr> <th style="text-align: right">a</th> <th style="text-align: right">a_1</th> <th style="text-align: right">b</th> </tr> </thead> <tbody> <tr> <td style="text-align: right">42</td> <td style="text-align: right">88</td> <td style="text-align: right">99</td> </tr> </tbody> </table> <h2 id="database-names"> <a style="text-decoration: none;" href="#database-names">Database Names</a> </h2> <p>Database names are subject to the rules for <a href="#identifiers">identifiers</a>.</p> <p>Additionally, it is best practice to avoid DuckDB's two internal <a href="../meta/duckdb_table_functions.html#duckdb_databases.html">database schema names</a>, <code class="language-plaintext highlighter-rouge">system</code> and <code class="language-plaintext highlighter-rouge">temp</code>. By default, persistent databases are named after their filename without the extension. Therefore, the filenames <code class="language-plaintext highlighter-rouge">system.db</code> and <code class="language-plaintext highlighter-rouge">temp.db</code> (as well as <code class="language-plaintext highlighter-rouge">system.duckdb</code> and <code class="language-plaintext highlighter-rouge">temp.duckdb</code>) result in the database names <code class="language-plaintext highlighter-rouge">system</code> and <code class="language-plaintext highlighter-rouge">temp</code>, respectively. If you need to attach to a database that has one of these names, use an alias, e.g.:</p> <pre class="language-sql highlighter-rouge" data-language="sql">ATTACH 'temp.db' AS temp2;
USE temp2;</pre> <h2 id="rules-for-case-sensitivity"> <a style="text-decoration: none;" href="#rules-for-case-sensitivity">Rules for Case-Sensitivity</a> </h2> <h3 id="keywords-and-function-names"> <a style="text-decoration: none;" href="#keywords-and-function-names">Keywords and Function Names</a> </h3> <p>SQL keywords and function names are case-insensitive in DuckDB.</p> <p>For example, the following two queries are equivalent:</p> <pre class="language-matlab highlighter-rouge" data-language="matlab">select COS(Pi()) as CosineOfPi;
SELECT cos(pi()) AS CosineOfPi;</pre> <table> <thead> <tr> <th style="text-align: right">CosineOfPi</th> </tr> </thead> <tbody> <tr> <td style="text-align: right">-1.0</td> </tr> </tbody> </table> <h3 id="case-sensitivity-of-identifiers"> <a style="text-decoration: none;" href="#case-sensitivity-of-identifiers">Case-Sensitivity of Identifiers</a> </h3> <p>Identifiers in DuckDB are always case-insensitive, similarly to PostgreSQL. However, unlike PostgreSQL (and some other major SQL implementations), DuckDB also treats quoted identifiers as case-insensitive.</p> <p>Despite treating identifiers in a case-insensitive manner, each character's case (uppercase/lowercase) is maintained as originally specified by the user even if a query uses different cases when referring to the identifier. For example:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE tbl AS SELECT cos(pi()) AS CosineOfPi;
SELECT cosineofpi FROM tbl;</pre> <table> <thead> <tr> <th style="text-align: right">CosineOfPi</th> </tr> </thead> <tbody> <tr> <td style="text-align: right">-1.0</td> </tr> </tbody> </table> <p>To change this behavior, set the <code class="language-plaintext highlighter-rouge">preserve_identifier_case</code> <a href="../../configuration/overview.html#configuration-reference.html">configuration option</a> to <code class="language-plaintext highlighter-rouge">false</code>.</p> <h4 id="handling-conflicts"> <a style="text-decoration: none;" href="#handling-conflicts">Handling Conflicts</a> </h4> <p>In case of a conflict, when the same identifier is spelt with different cases, one will be selected randomly. For example:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE t1 (idfield INTEGER, x INTEGER);
CREATE TABLE t2 (IdField INTEGER, y INTEGER);
INSERT INTO t1 VALUES (1, 123);
INSERT INTO t2 VALUES (1, 456);
SELECT * FROM t1 NATURAL JOIN t2;</pre> <table> <thead> <tr> <th style="text-align: right">idfield</th> <th style="text-align: right">x</th> <th style="text-align: right">y</th> </tr> </thead> <tbody> <tr> <td style="text-align: right">1</td> <td style="text-align: right">123</td> <td style="text-align: right">456</td> </tr> </tbody> </table> <h4 id="disabling-preserving-cases"> <a style="text-decoration: none;" href="#disabling-preserving-cases">Disabling Preserving Cases</a> </h4> <p>With the <code class="language-plaintext highlighter-rouge">preserve_identifier_case</code> <a href="../../configuration/overview.html#configuration-reference.html">configuration option</a> set to <code class="language-plaintext highlighter-rouge">false</code>, all identifiers are turned into lowercase:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SET preserve_identifier_case = false;
CREATE TABLE tbl AS SELECT cos(pi()) AS CosineOfPi;
SELECT CosineOfPi FROM tbl;</pre> <table> <thead> <tr> <th style="text-align: right">cosineofpi</th> </tr> </thead> <tbody> <tr> <td style="text-align: right">-1.0</td> </tr> </tbody> </table><div class="_attribution">
  <p class="_attribution-p">
    &copy; Copyright 2018&ndash;2024 Stichting DuckDB Foundation<br>Licensed under the MIT License.<br>
    <a href="https://duckdb.org/docs/sql/dialect/keywords_and_identifiers.html" class="_attribution-link">https://duckdb.org/docs/sql/dialect/keywords_and_identifiers.html</a>
  </p>
</div>
