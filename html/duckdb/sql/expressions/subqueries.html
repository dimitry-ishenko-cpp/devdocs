<h1 class="title">Subqueries</h1>  <p>Subqueries are parenthesized query expressions that appear as part of a larger, outer query. Subqueries are usually based on <code class="language-plaintext highlighter-rouge">SELECT ... FROM</code>, but in DuckDB other query constructs such as <a href="../statements/pivot.html"><code class="language-plaintext highlighter-rouge">PIVOT</code></a> can also appear as a subquery.</p> <h2 id="scalar-subquery"> <a style="text-decoration: none;" href="#scalar-subquery">Scalar Subquery</a> </h2>  <p>Scalar subqueries are subqueries that return a single value. They can be used anywhere where an expression can be used. If a scalar subquery returns more than a single value, an error is raised (unless <code class="language-plaintext highlighter-rouge">scalar_subquery_error_on_multiple_rows</code> is set to <code class="language-plaintext highlighter-rouge">false</code>, in which case a row is selected randomly).</p> <p>Consider the following table:</p> <h3 id="grades"> <a style="text-decoration: none;" href="#grades">Grades</a> </h3>  <table> <thead> <tr> <th style="text-align: right">grade</th> <th style="text-align: left">course</th> </tr> </thead> <tbody> <tr> <td style="text-align: right">7</td> <td style="text-align: left">Math</td> </tr> <tr> <td style="text-align: right">9</td> <td style="text-align: left">Math</td> </tr> <tr> <td style="text-align: right">8</td> <td style="text-align: left">CS</td> </tr> </tbody> </table> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE grades (grade INTEGER, course VARCHAR);
INSERT INTO grades VALUES (7, 'Math'), (9, 'Math'), (8, 'CS');</pre> <p>We can run the following query to obtain the minimum grade:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT min(grade) FROM grades;</pre> <table> <thead> <tr> <th style="text-align: right">min(grade)</th> </tr> </thead> <tbody> <tr> <td style="text-align: right">7</td> </tr> </tbody> </table> <p>By using a scalar subquery in the <code class="language-plaintext highlighter-rouge">WHERE</code> clause, we can figure out for which course this grade was obtained:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT course FROM grades WHERE grade = (SELECT min(grade) FROM grades);</pre> <table> <thead> <tr> <th>course</th> </tr> </thead> <tbody> <tr> <td>Math</td> </tr> </tbody> </table> <h2 id="subquery-comparisons-all-any-and-some"> <a style="text-decoration: none;" href="#subquery-comparisons-all-any-and-some">Subquery Comparisons: <code class="language-plaintext highlighter-rouge">ALL</code>, <code class="language-plaintext highlighter-rouge">ANY</code> and <code class="language-plaintext highlighter-rouge">SOME</code></a> </h2> <p>In the section on <a href="#scalar-subquery">scalar subqueries</a>, a scalar expression was compared directly to a subquery using the equality <a href="comparison_operators.html#comparison-operators.html">comparison operator</a> (<code class="language-plaintext highlighter-rouge">=</code>). Such direct comparisons only make sense with scalar subqueries.</p> <p>Scalar expressions can still be compared to single-column subqueries returning multiple rows by specifying a quantifier. Available quantifiers are <code class="language-plaintext highlighter-rouge">ALL</code>, <code class="language-plaintext highlighter-rouge">ANY</code> and <code class="language-plaintext highlighter-rouge">SOME</code>. The quantifiers <code class="language-plaintext highlighter-rouge">ANY</code> and <code class="language-plaintext highlighter-rouge">SOME</code> are equivalent.</p> <h3 id="all"> <a style="text-decoration: none;" href="#all"><code class="language-plaintext highlighter-rouge">ALL</code></a> </h3> <p>The <code class="language-plaintext highlighter-rouge">ALL</code> quantifier specifies that the comparison as a whole evaluates to <code class="language-plaintext highlighter-rouge">true</code> when the individual comparison results of <em>the expression at the left hand side of the comparison operator</em> with each of the values from <em>the subquery at the right hand side of the comparison operator</em> <strong>all</strong> evaluate to <code class="language-plaintext highlighter-rouge">true</code>:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT 6 &lt;= ALL (SELECT grade FROM grades) AS adequate;</pre> <p>returns:</p> <table> <thead> <tr> <th>adequate</th> </tr> </thead> <tbody> <tr> <td>true</td> </tr> </tbody> </table> <p>because 6 is less than or equal to each of the subquery results 7, 8 and 9.</p> <p>However, the following query</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT 8 &gt;= ALL (SELECT grade FROM grades) AS excellent;</pre> <p>returns</p> <table> <thead> <tr> <th>excellent</th> </tr> </thead> <tbody> <tr> <td>false</td> </tr> </tbody> </table> <p>because 8 is not greater than or equal to the subquery result 7. And thus, because not all comparisons evaluate <code class="language-plaintext highlighter-rouge">true</code>, <code class="language-plaintext highlighter-rouge">&gt;= ALL</code> as a whole evaluates to <code class="language-plaintext highlighter-rouge">false</code>.</p> <h3 id="any"> <a style="text-decoration: none;" href="#any"><code class="language-plaintext highlighter-rouge">ANY</code></a> </h3> <p>The <code class="language-plaintext highlighter-rouge">ANY</code> quantifier specifies that the comparison as a whole evaluates to <code class="language-plaintext highlighter-rouge">true</code> when at least one of the individual comparison results evaluates to <code class="language-plaintext highlighter-rouge">true</code>. For example:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT 5 &gt;= ANY (SELECT grade FROM grades) AS fail;</pre> <p>returns</p> <table> <thead> <tr> <th>fail</th> </tr> </thead> <tbody> <tr> <td>false</td> </tr> </tbody> </table> <p>because no result of the subquery is less than or equal to 5.</p> <p>The quantifier <code class="language-plaintext highlighter-rouge">SOME</code> maybe used instead of <code class="language-plaintext highlighter-rouge">ANY</code>: <code class="language-plaintext highlighter-rouge">ANY</code> and <code class="language-plaintext highlighter-rouge">SOME</code> are interchangeable.</p> <h2 id="exists"> <a style="text-decoration: none;" href="#exists"><code class="language-plaintext highlighter-rouge">EXISTS</code></a> </h2>  <p>The <code class="language-plaintext highlighter-rouge">EXISTS</code> operator tests for the existence of any row inside the subquery. It returns either true when the subquery returns one or more records, and false otherwise. The <code class="language-plaintext highlighter-rouge">EXISTS</code> operator is generally the most useful as a <em>correlated</em> subquery to express semijoin operations. However, it can be used as an uncorrelated subquery as well.</p> <p>For example, we can use it to figure out if there are any grades present for a given course:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT EXISTS (FROM grades WHERE course = 'Math') AS math_grades_present;</pre> <table> <thead> <tr> <th style="text-align: right">math_grades_present</th> </tr> </thead> <tbody> <tr> <td style="text-align: right">true</td> </tr> </tbody> </table> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT EXISTS (FROM grades WHERE course = 'History') AS history_grades_present;</pre> <table> <thead> <tr> <th style="text-align: right">history_grades_present</th> </tr> </thead> <tbody> <tr> <td style="text-align: right">false</td> </tr> </tbody> </table> <blockquote> <p>The subqueries in the examples above make use of the fact that you can omit the <code class="language-plaintext highlighter-rouge">SELECT *</code> in DuckDB thanks to the <a href="../query_syntax/from.html"><code class="language-plaintext highlighter-rouge">FROM</code>-first syntax</a>. The <code class="language-plaintext highlighter-rouge">SELECT</code> clause is required in subqueries by other SQL systems but cannot fulfil any purpose in <code class="language-plaintext highlighter-rouge">EXISTS</code> and <code class="language-plaintext highlighter-rouge">NOT EXISTS</code> subqueries.</p> </blockquote> <h3 id="not-exists"> <a style="text-decoration: none;" href="#not-exists"><code class="language-plaintext highlighter-rouge">NOT EXISTS</code></a> </h3> <p>The <code class="language-plaintext highlighter-rouge">NOT EXISTS</code> operator tests for the absence of any row inside the subquery. It returns either true when the subquery returns an empty result, and false otherwise. The <code class="language-plaintext highlighter-rouge">NOT EXISTS</code> operator is generally the most useful as a <em>correlated</em> subquery to express antijoin operations. For example, to find Person nodes without an interest:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE Person (id BIGINT, name VARCHAR);
CREATE TABLE interest (PersonId BIGINT, topic VARCHAR);

INSERT INTO Person VALUES (1, 'Jane'), (2, 'Joe');
INSERT INTO interest VALUES (2, 'Music');

SELECT *
FROM Person
WHERE NOT EXISTS (FROM interest WHERE interest.PersonId = Person.id);</pre> <table> <thead> <tr> <th style="text-align: right">id</th> <th>name</th> </tr> </thead> <tbody> <tr> <td style="text-align: right">1</td> <td>Jane</td> </tr> </tbody> </table> <blockquote> <p>DuckDB automatically detects when a <code class="language-plaintext highlighter-rouge">NOT EXISTS</code> query expresses an antijoin operation. There is no need to manually rewrite such queries to use <code class="language-plaintext highlighter-rouge">LEFT OUTER JOIN ... WHERE ... IS NULL</code>.</p> </blockquote> <h2 id="in-operator"> <a style="text-decoration: none;" href="#in-operator"><code class="language-plaintext highlighter-rouge">IN</code> Operator</a> </h2>  <p>The <code class="language-plaintext highlighter-rouge">IN</code> operator checks containment of the left expression inside the result defined by the subquery or the set of expressions on the right hand side (RHS). The <code class="language-plaintext highlighter-rouge">IN</code> operator returns true if the expression is present in the RHS, false if the expression is not in the RHS and the RHS has no <code class="language-plaintext highlighter-rouge">NULL</code> values, or <code class="language-plaintext highlighter-rouge">NULL</code> if the expression is not in the RHS and the RHS has <code class="language-plaintext highlighter-rouge">NULL</code> values.</p> <p>We can use the <code class="language-plaintext highlighter-rouge">IN</code> operator in a similar manner as we used the <code class="language-plaintext highlighter-rouge">EXISTS</code> operator:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT 'Math' IN (SELECT course FROM grades) AS math_grades_present;</pre> <table> <thead> <tr> <th style="text-align: right">math_grades_present</th> </tr> </thead> <tbody> <tr> <td style="text-align: right">true</td> </tr> </tbody> </table> <h2 id="correlated-subqueries"> <a style="text-decoration: none;" href="#correlated-subqueries">Correlated Subqueries</a> </h2> <p>All the subqueries presented here so far have been <strong>uncorrelated</strong> subqueries, where the subqueries themselves are entirely self-contained and can be run without the parent query. There exists a second type of subqueries called <strong>correlated</strong> subqueries. For correlated subqueries, the subquery uses values from the parent subquery.</p> <p>Conceptually, the subqueries are run once for every single row in the parent query. Perhaps a simple way of envisioning this is that the correlated subquery is a <strong>function</strong> that is applied to every row in the source data set.</p> <p>For example, suppose that we want to find the minimum grade for every course. We could do that as follows:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT *
FROM grades grades_parent
WHERE grade =
    (SELECT min(grade)
     FROM grades
     WHERE grades.course = grades_parent.course);</pre> <table> <thead> <tr> <th style="text-align: right">grade</th> <th>course</th> </tr> </thead> <tbody> <tr> <td style="text-align: right">7</td> <td>Math</td> </tr> <tr> <td style="text-align: right">8</td> <td>CS</td> </tr> </tbody> </table> <p>The subquery uses a column from the parent query (<code class="language-plaintext highlighter-rouge">grades_parent.course</code>). Conceptually, we can see the subquery as a function where the correlated column is a parameter to that function:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT min(grade)
FROM grades
WHERE course = ?;</pre> <p>Now when we execute this function for each of the rows, we can see that for <code class="language-plaintext highlighter-rouge">Math</code> this will return <code class="language-plaintext highlighter-rouge">7</code>, and for <code class="language-plaintext highlighter-rouge">CS</code> it will return <code class="language-plaintext highlighter-rouge">8</code>. We then compare it against the grade for that actual row. As a result, the row <code class="language-plaintext highlighter-rouge">(Math, 9)</code> will be filtered out, as <code class="language-plaintext highlighter-rouge">9 &lt;&gt; 7</code>.</p> <h2 id="returning-each-row-of-the-subquery-as-a-struct"> <a style="text-decoration: none;" href="#returning-each-row-of-the-subquery-as-a-struct">Returning Each Row of the Subquery as a Struct</a> </h2> <p>Using the name of a subquery in the <code class="language-plaintext highlighter-rouge">SELECT</code> clause (without referring to a specific column) turns each row of the subquery into a struct whose fields correspond to the columns of the subquery. For example:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT t
FROM (SELECT unnest(generate_series(41, 43)) AS x, 'hello' AS y) t;</pre>  <table> <thead> <tr> <th>t</th> </tr> </thead> <tbody> <tr> <td>{'x': 41, 'y': hello}</td> </tr> <tr> <td>{'x': 42, 'y': hello}</td> </tr> <tr> <td>{'x': 43, 'y': hello}</td> </tr> </tbody> </table><div class="_attribution">
  <p class="_attribution-p">
    &copy; Copyright 2018&ndash;2024 Stichting DuckDB Foundation<br>Licensed under the MIT License.<br>
    <a href="https://duckdb.org/docs/sql/expressions/subqueries.html" class="_attribution-link">https://duckdb.org/docs/sql/expressions/subqueries.html</a>
  </p>
</div>
