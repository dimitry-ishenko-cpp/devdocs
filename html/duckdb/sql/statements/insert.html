<h1 class="title">INSERT Statement</h1>  <p>The <code class="language-plaintext highlighter-rouge">INSERT</code> statement inserts new data into a table.</p> <h3 id="examples"> <a style="text-decoration: none;" href="#examples">Examples</a> </h3> <p>Insert the values 1, 2, 3 into <code class="language-plaintext highlighter-rouge">tbl</code>:</p> <pre class="language-sql highlighter-rouge" data-language="sql">INSERT INTO tbl
    VALUES (1), (2), (3);</pre> <p>Insert the result of a query into a table:</p> <pre class="language-sql highlighter-rouge" data-language="sql">INSERT INTO tbl
    SELECT * FROM other_tbl;</pre> <p>Insert values into the <code class="language-plaintext highlighter-rouge">i</code> column, inserting the default value into other columns:</p> <pre class="language-sql highlighter-rouge" data-language="sql">INSERT INTO tbl (i)
    VALUES (1), (2), (3);</pre> <p>Explicitly insert the default value into a column:</p> <pre class="language-sql highlighter-rouge" data-language="sql">INSERT INTO tbl (i)
    VALUES (1), (DEFAULT), (3);</pre> <p>Assuming <code class="language-plaintext highlighter-rouge">tbl</code> has a primary key/unique constraint, do nothing on conflict:</p> <pre class="language-sql highlighter-rouge" data-language="sql">INSERT OR IGNORE INTO tbl (i)
    VALUES (1);</pre> <p>Or update the table with the new values instead:</p> <pre class="language-sql highlighter-rouge" data-language="sql">INSERT OR REPLACE INTO tbl (i)
    VALUES (1);</pre> <h3 id="syntax"> <a style="text-decoration: none;" href="#syntax">Syntax</a> </h3>  <p><code class="language-plaintext highlighter-rouge">INSERT INTO</code> inserts new rows into a table. One can insert one or more rows specified by value expressions, or zero or more rows resulting from a query.</p> <h2 id="insert-column-order"> <a style="text-decoration: none;" href="#insert-column-order">Insert Column Order</a> </h2> <p>It's possible to provide an optional insert column order, this can either be <code class="language-plaintext highlighter-rouge">BY POSITION</code> (the default) or <code class="language-plaintext highlighter-rouge">BY NAME</code>. Each column not present in the explicit or implicit column list will be filled with a default value, either its declared default value or <code class="language-plaintext highlighter-rouge">NULL</code> if there is none.</p> <p>If the expression for any column is not of the correct data type, automatic type conversion will be attempted.</p> <h3 id="insert-into--by-position"> <a style="text-decoration: none;" href="#insert-into--by-position"><code class="language-plaintext highlighter-rouge">INSERT INTO ... [BY POSITION]</code></a> </h3> <p>The order that values are inserted into the columns of the table is determined by the order that the columns were declared in. That is, the values supplied by the <code class="language-plaintext highlighter-rouge">VALUES</code> clause or query are associated with the column list left-to-right. This is the default option, that can be explicitly specified using the <code class="language-plaintext highlighter-rouge">BY POSITION</code> option. For example:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE tbl (a INTEGER, b INTEGER);
INSERT INTO tbl
    VALUES (5, 42);</pre> <p>Specifying <code class="language-plaintext highlighter-rouge">BY POSITION</code> is optional and is equivalent to the default behavior:</p> <pre class="language-sql highlighter-rouge" data-language="sql">INSERT INTO tbl
    BY POSITION
    VALUES (5, 42);</pre> <p>To use a different order, column names can be provided as part of the target, for example:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE tbl (a INTEGER, b INTEGER);
INSERT INTO tbl (b, a)
    VALUES (5, 42);</pre> <p>Adding <code class="language-plaintext highlighter-rouge">BY POSITION</code> results in the same behavior:</p> <pre class="language-sql highlighter-rouge" data-language="sql">INSERT INTO tbl
    BY POSITION (b, a)
    VALUES (5, 42);</pre> <p>This will insert <code class="language-plaintext highlighter-rouge">5</code> into <code class="language-plaintext highlighter-rouge">b</code> and <code class="language-plaintext highlighter-rouge">42</code> into <code class="language-plaintext highlighter-rouge">a</code>.</p> <h3 id="insert-into--by-name"> <a style="text-decoration: none;" href="#insert-into--by-name"><code class="language-plaintext highlighter-rouge">INSERT INTO ... BY NAME</code></a> </h3> <p>Using the <code class="language-plaintext highlighter-rouge">BY NAME</code> modifier, the names of the column list of the <code class="language-plaintext highlighter-rouge">SELECT</code> statement are matched against the column names of the table to determine the order that values should be inserted into the table. This allows inserting even in cases when the order of the columns in the table differs from the order of the values in the <code class="language-plaintext highlighter-rouge">SELECT</code> statement or certain columns are missing.</p> <p>For example:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE tbl (a INTEGER, b INTEGER);
INSERT INTO tbl BY NAME (SELECT 42 AS b, 32 AS a);
INSERT INTO tbl BY NAME (SELECT 22 AS b);
SELECT * FROM tbl;</pre> <table> <thead> <tr> <th style="text-align: right">a</th> <th style="text-align: right">b</th> </tr> </thead> <tbody> <tr> <td style="text-align: right">32</td> <td style="text-align: right">42</td> </tr> <tr> <td style="text-align: right">NULL</td> <td style="text-align: right">22</td> </tr> </tbody> </table> <p>It's important to note that when using <code class="language-plaintext highlighter-rouge">INSERT INTO ... BY NAME</code>, the column names specified in the <code class="language-plaintext highlighter-rouge">SELECT</code> statement must match the column names in the table. If a column name is misspelled or does not exist in the table, an error will occur. Columns that are missing from the <code class="language-plaintext highlighter-rouge">SELECT</code> statement will be filled with the default value.</p> <h2 id="on-conflict-clause"> <a style="text-decoration: none;" href="#on-conflict-clause"><code class="language-plaintext highlighter-rouge">ON CONFLICT</code> Clause</a> </h2> <p>An <code class="language-plaintext highlighter-rouge">ON CONFLICT</code> clause can be used to perform a certain action on conflicts that arise from <code class="language-plaintext highlighter-rouge">UNIQUE</code> or <code class="language-plaintext highlighter-rouge">PRIMARY KEY</code> constraints. An example for such a conflict is shown in the following example:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE tbl (i INTEGER PRIMARY KEY, j INTEGER);
INSERT INTO tbl
    VALUES (1, 42);
INSERT INTO tbl
    VALUES (1, 84);</pre> <p>This raises as an error:</p> <pre class="language-console highlighter-rouge" data-language="console">Constraint Error: Duplicate key "i: 1" violates primary key constraint.</pre> <p>The table will contain the row that was first inserted:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT * FROM tbl;</pre> <table> <thead> <tr> <th style="text-align: right">i</th> <th style="text-align: right">j</th> </tr> </thead> <tbody> <tr> <td style="text-align: right">1</td> <td style="text-align: right">42</td> </tr> </tbody> </table> <p>These error messages can be avoided by explicitly handling conflicts. DuckDB supports two such clauses: <a href="#do-nothing-clause"><code class="language-plaintext highlighter-rouge">ON CONFLICT DO NOTHING</code></a> and <a href="#do-update-clause-upsert"><code class="language-plaintext highlighter-rouge">ON CONFLICT DO UPDATE SET ...</code></a>.</p> <h3 id="do-nothing-clause"> <a style="text-decoration: none;" href="#do-nothing-clause"><code class="language-plaintext highlighter-rouge">DO NOTHING</code> Clause</a> </h3> <p>The <code class="language-plaintext highlighter-rouge">DO NOTHING</code> clause causes the error(s) to be ignored, and the values are not inserted or updated. For example:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE tbl (i INTEGER PRIMARY KEY, j INTEGER);
INSERT INTO tbl
    VALUES (1, 42);
INSERT INTO tbl
    VALUES (1, 84)
    ON CONFLICT DO NOTHING;</pre> <p>These statements finish successfully and leaves the table with the row <code class="language-plaintext highlighter-rouge">&lt;i: 1, j: 42&gt;</code>.</p> <h4 id="insert-or-ignore-into"> <a style="text-decoration: none;" href="#insert-or-ignore-into"><code class="language-plaintext highlighter-rouge">INSERT OR IGNORE INTO</code></a> </h4> <p>The <code class="language-plaintext highlighter-rouge">INSERT OR IGNORE INTO ...</code> statement is a shorter syntax alternative to <code class="language-plaintext highlighter-rouge">INSERT INTO ... ON CONFLICT DO NOTHING</code>. For example, the following statements are equivalent:</p> <pre class="language-sql highlighter-rouge" data-language="sql">INSERT OR IGNORE INTO tbl
    VALUES (1, 84);
INSERT INTO tbl
    VALUES (1, 84) ON CONFLICT DO NOTHING;</pre> <h3 id="do-update-clause-upsert"> <a style="text-decoration: none;" href="#do-update-clause-upsert"><code class="language-plaintext highlighter-rouge">DO UPDATE</code> Clause (Upsert)</a> </h3> <p>The <code class="language-plaintext highlighter-rouge">DO UPDATE</code> clause causes the <code class="language-plaintext highlighter-rouge">INSERT</code> to turn into an <code class="language-plaintext highlighter-rouge">UPDATE</code> on the conflicting row(s) instead. The <code class="language-plaintext highlighter-rouge">SET</code> expressions that follow determine how these rows are updated. The expressions can use the special virtual table <code class="language-plaintext highlighter-rouge">EXCLUDED</code>, which contains the conflicting values for the row. Optionally you can provide an additional <code class="language-plaintext highlighter-rouge">WHERE</code> clause that can exclude certain rows from the update. The conflicts that don't meet this condition are ignored instead.</p> <p>Because we need a way to refer to both the <strong>to-be-inserted</strong> tuple and the <strong>existing</strong> tuple, we introduce the special <code class="language-plaintext highlighter-rouge">EXCLUDED</code> qualifier. When the <code class="language-plaintext highlighter-rouge">EXCLUDED</code> qualifier is provided, the reference refers to the <strong>to-be-inserted</strong> tuple, otherwise, it refers to the <strong>existing</strong> tuple. This special qualifier can be used within the <code class="language-plaintext highlighter-rouge">WHERE</code> clauses and <code class="language-plaintext highlighter-rouge">SET</code> expressions of the <code class="language-plaintext highlighter-rouge">ON CONFLICT</code> clause.</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE tbl (i INTEGER PRIMARY KEY, j INTEGER);
INSERT INTO tbl VALUES (1, 42);
INSERT INTO tbl VALUES (1, 52), (1, 62) ON CONFLICT DO UPDATE SET j = EXCLUDED.j;</pre> <h4 id="examples-1"> <a style="text-decoration: none;" href="#examples-1">Examples</a> </h4> <p>An example using <code class="language-plaintext highlighter-rouge">DO UPDATE</code> is the following:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE tbl (i INTEGER PRIMARY KEY, j INTEGER);
INSERT INTO tbl
    VALUES (1, 42);
INSERT INTO tbl
    VALUES (1, 84)
    ON CONFLICT DO UPDATE SET j = EXCLUDED.j;
SELECT * FROM tbl;</pre> <table> <thead> <tr> <th style="text-align: right">i</th> <th style="text-align: right">j</th> </tr> </thead> <tbody> <tr> <td style="text-align: right">1</td> <td style="text-align: right">84</td> </tr> </tbody> </table> <p>Rearranging columns and using <code class="language-plaintext highlighter-rouge">BY NAME</code> is also possible:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE tbl (i INTEGER PRIMARY KEY, j INTEGER);
INSERT INTO tbl
    VALUES (1, 42);
INSERT INTO tbl (j, i)
    VALUES (168, 1)
    ON CONFLICT DO UPDATE SET j = EXCLUDED.j;
INSERT INTO tbl
    BY NAME (SELECT 1 AS i, 336 AS j)
    ON CONFLICT DO UPDATE SET j = EXCLUDED.j;
SELECT * FROM tbl;</pre> <table> <thead> <tr> <th style="text-align: right">i</th> <th style="text-align: right">j</th> </tr> </thead> <tbody> <tr> <td style="text-align: right">1</td> <td style="text-align: right">336</td> </tr> </tbody> </table> <h4 id="insert-or-replace-into"> <a style="text-decoration: none;" href="#insert-or-replace-into"><code class="language-plaintext highlighter-rouge">INSERT OR REPLACE INTO</code></a> </h4> <p>The <code class="language-plaintext highlighter-rouge">INSERT OR REPLACE INTO ...</code> statement is a shorter syntax alternative to <code class="language-plaintext highlighter-rouge">INSERT INTO ... DO UPDATE SET c1 = EXCLUDED.c1, c2 = EXCLUDED.c2, ...</code>. That is, it updates every column of the <strong>existing</strong> row to the new values of the <strong>to-be-inserted</strong> row. For example, given the following input table:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE tbl (i INTEGER PRIMARY KEY, j INTEGER);
INSERT INTO tbl
    VALUES (1, 42);</pre> <p>These statements are equivalent:</p> <pre class="language-sql highlighter-rouge" data-language="sql">INSERT OR REPLACE INTO tbl
    VALUES (1, 84);
INSERT INTO tbl
    VALUES (1, 84)
    ON CONFLICT DO UPDATE SET j = EXCLUDED.j;
INSERT INTO tbl (j, i)
    VALUES (84, 1)
    ON CONFLICT DO UPDATE SET j = EXCLUDED.j;
INSERT INTO tbl BY NAME
    (SELECT 84 AS j, 1 AS i)
    ON CONFLICT DO UPDATE SET j = EXCLUDED.j;</pre> <h4 id="limitations"> <a style="text-decoration: none;" href="#limitations">Limitations</a> </h4> <p>When the <code class="language-plaintext highlighter-rouge">ON CONFLICT ... DO UPDATE</code> clause is used and a conflict occurs, DuckDB internally assigns <code class="language-plaintext highlighter-rouge">NULL</code> values to the row's columns that are unaffected by the conflict, then re-assigns their values. If the affected columns use a <code class="language-plaintext highlighter-rouge">NOT NULL</code> constraint, this will trigger a <code class="language-plaintext highlighter-rouge">NOT NULL constraint failed</code> error. For example:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE t1 (id INTEGER PRIMARY KEY, val1 DOUBLE, val2 DOUBLE NOT NULL);
CREATE TABLE t2 (id INTEGER PRIMARY KEY, val1 DOUBLE);
INSERT INTO t1
    VALUES (1, 2, 3);
INSERT INTO t2
    VALUES (1, 5);

INSERT INTO t1 BY NAME (SELECT id, val1 FROM t2)
    ON CONFLICT DO UPDATE
    SET val1 = EXCLUDED.val1;</pre> <p>This fails with the following error:</p> <pre class="language-console highlighter-rouge" data-language="console">Constraint Error: NOT NULL constraint failed: t1.val2</pre> <h3 id="defining-a-conflict-target"> <a style="text-decoration: none;" href="#defining-a-conflict-target">Defining a Conflict Target</a> </h3> <p>A conflict target may be provided as <code class="language-plaintext highlighter-rouge">ON CONFLICT (conflict_target)</code>. This is a group of columns that an index or uniqueness/key constraint is defined on. If the conflict target is omitted, or <code class="language-plaintext highlighter-rouge">PRIMARY KEY</code> constraint(s) on the table are targeted.</p> <p>Specifying a conflict target is optional unless using a <a href="#do-update-clause-upsert"><code class="language-plaintext highlighter-rouge">DO UPDATE</code></a> and there are multiple unique/primary key constraints on the table.</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE tbl (i INTEGER PRIMARY KEY, j INTEGER UNIQUE, k INTEGER);
INSERT INTO tbl
    VALUES (1, 20, 300);
SELECT * FROM tbl;</pre> <table> <thead> <tr> <th style="text-align: right">i</th> <th style="text-align: right">j</th> <th style="text-align: right">k</th> </tr> </thead> <tbody> <tr> <td style="text-align: right">1</td> <td style="text-align: right">20</td> <td style="text-align: right">300</td> </tr> </tbody> </table> <pre class="language-sql highlighter-rouge" data-language="sql">INSERT INTO tbl
    VALUES (1, 40, 700)
    ON CONFLICT (i) DO UPDATE SET k = 2 * EXCLUDED.k;</pre> <table> <thead> <tr> <th style="text-align: right">i</th> <th style="text-align: right">j</th> <th style="text-align: right">k</th> </tr> </thead> <tbody> <tr> <td style="text-align: right">1</td> <td style="text-align: right">20</td> <td style="text-align: right">1400</td> </tr> </tbody> </table> <pre class="language-sql highlighter-rouge" data-language="sql">INSERT INTO tbl
    VALUES (1, 20, 900)
    ON CONFLICT (j) DO UPDATE SET k = 5 * EXCLUDED.k;</pre> <table> <thead> <tr> <th style="text-align: right">i</th> <th style="text-align: right">j</th> <th style="text-align: right">k</th> </tr> </thead> <tbody> <tr> <td style="text-align: right">1</td> <td style="text-align: right">20</td> <td style="text-align: right">4500</td> </tr> </tbody> </table> <p>When a conflict target is provided, you can further filter this with a <code class="language-plaintext highlighter-rouge">WHERE</code> clause, that should be met by all conflicts.</p> <pre class="language-sql highlighter-rouge" data-language="sql">INSERT INTO tbl
    VALUES (1, 40, 700)
    ON CONFLICT (i) DO UPDATE SET k = 2 * EXCLUDED.k WHERE k &lt; 100;</pre> <h3 id="multiple-tuples-conflicting-on-the-same-key"> <a style="text-decoration: none;" href="#multiple-tuples-conflicting-on-the-same-key">Multiple Tuples Conflicting on the Same Key</a> </h3> <h4 id="limitations-1"> <a style="text-decoration: none;" href="#limitations-1">Limitations</a> </h4> <p>Currently, DuckDBâ€™s <code class="language-plaintext highlighter-rouge">ON CONFLICT DO UPDATE</code> feature is limited to enforce constraints between committed and newly inserted (transaction-local) data. In other words, having multiple tuples conflicting on the same key is not supported. If the newly inserted data has duplicate rows, an error message will be thrown, or unexpected behavior can occur. This also includes conflicts <strong>only</strong> within the newly inserted data.</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE tbl (i INTEGER PRIMARY KEY, j INTEGER);
INSERT INTO tbl
    VALUES (1, 42);
INSERT INTO tbl
    VALUES (1, 84), (1, 168)
    ON CONFLICT DO UPDATE SET j = j + EXCLUDED.j;</pre> <p>This returns the following message.</p> <pre class="language-console highlighter-rouge" data-language="console">Error: Invalid Input Error: ON CONFLICT DO UPDATE can not update the same row twice in the same command.
Ensure that no rows proposed for insertion within the same command have duplicate constrained values</pre> <p>To work around this, enforce uniqueness using <a href="../query_syntax/select.html#distinct-on-clause.html"><code class="language-plaintext highlighter-rouge">DISTINCT ON</code></a>. For example:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE tbl (i INTEGER PRIMARY KEY, j INTEGER);
INSERT INTO tbl
    VALUES (1, 42);
INSERT INTO tbl
    SELECT DISTINCT ON(i) i, j FROM VALUES (1, 84), (1, 168) AS t (i, j)
    ON CONFLICT DO UPDATE SET j = j + EXCLUDED.j;
SELECT * FROM tbl;</pre> <table> <thead> <tr> <th style="text-align: right">i</th> <th style="text-align: right">j</th> </tr> </thead> <tbody> <tr> <td style="text-align: right">1</td> <td style="text-align: right">126</td> </tr> </tbody> </table> <h2 id="returning-clause"> <a style="text-decoration: none;" href="#returning-clause"><code class="language-plaintext highlighter-rouge">RETURNING</code> Clause</a> </h2> <p>The <code class="language-plaintext highlighter-rouge">RETURNING</code> clause may be used to return the contents of the rows that were inserted. This can be useful if some columns are calculated upon insert. For example, if the table contains an automatically incrementing primary key, then the <code class="language-plaintext highlighter-rouge">RETURNING</code> clause will include the automatically created primary key. This is also useful in the case of generated columns.</p> <p>Some or all columns can be explicitly chosen to be returned and they may optionally be renamed using aliases. Arbitrary non-aggregating expressions may also be returned instead of simply returning a column. All columns can be returned using the <code class="language-plaintext highlighter-rouge">*</code> expression, and columns or expressions can be returned in addition to all columns returned by the <code class="language-plaintext highlighter-rouge">*</code>.</p> <p>For example:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE t1 (i INTEGER);
INSERT INTO t1
    SELECT 42
    RETURNING *;</pre>  <table> <thead> <tr> <th style="text-align: right">i</th> </tr> </thead> <tbody> <tr> <td style="text-align: right">42</td> </tr> </tbody> </table> <p>A more complex example that includes an expression in the <code class="language-plaintext highlighter-rouge">RETURNING</code> clause:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE t2 (i INTEGER, j INTEGER);
INSERT INTO t2
    SELECT 2 AS i, 3 AS j
    RETURNING *, i * j AS i_times_j;</pre>  <table> <thead> <tr> <th style="text-align: right">i</th> <th style="text-align: right">j</th> <th style="text-align: right">i_times_j</th> </tr> </thead> <tbody> <tr> <td style="text-align: right">2</td> <td style="text-align: right">3</td> <td style="text-align: right">6</td> </tr> </tbody> </table> <p>The next example shows a situation where the <code class="language-plaintext highlighter-rouge">RETURNING</code> clause is more helpful. First, a table is created with a primary key column. Then a sequence is created to allow for that primary key to be incremented as new rows are inserted. When we insert into the table, we do not already know the values generated by the sequence, so it is valuable to return them. For additional information, see the <a href="create_sequence.html"><code class="language-plaintext highlighter-rouge">CREATE SEQUENCE</code> page</a>.</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE t3 (i INTEGER PRIMARY KEY, j INTEGER);
CREATE SEQUENCE 't3_key';
INSERT INTO t3
    SELECT nextval('t3_key') AS i, 42 AS j
    UNION ALL
    SELECT nextval('t3_key') AS i, 43 AS j
    RETURNING *;</pre>  <table> <thead> <tr> <th style="text-align: right">i</th> <th style="text-align: right">j</th> </tr> </thead> <tbody> <tr> <td style="text-align: right">1</td> <td style="text-align: right">42</td> </tr> <tr> <td style="text-align: right">2</td> <td style="text-align: right">43</td> </tr> </tbody> </table><div class="_attribution">
  <p class="_attribution-p">
    &copy; Copyright 2018&ndash;2024 Stichting DuckDB Foundation<br>Licensed under the MIT License.<br>
    <a href="https://duckdb.org/docs/sql/statements/insert.html" class="_attribution-link">https://duckdb.org/docs/sql/statements/insert.html</a>
  </p>
</div>
