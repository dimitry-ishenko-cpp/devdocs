<h1 class="title">CREATE TABLE Statement</h1>  <p>The <code class="language-plaintext highlighter-rouge">CREATE TABLE</code> statement creates a table in the catalog.</p> <h2 id="examples"> <a style="text-decoration: none;" href="#examples">Examples</a> </h2> <p>Create a table with two integer columns (<code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">j</code>):</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE t1 (i INTEGER, j INTEGER);</pre> <p>Create a table with a primary key:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE t1 (id INTEGER PRIMARY KEY, j VARCHAR);</pre> <p>Create a table with a composite primary key:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE t1 (id INTEGER, j VARCHAR, PRIMARY KEY (id, j));</pre> <p>Create a table with various different types and constraints:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE t1 (
    i INTEGER NOT NULL,
    decimalnr DOUBLE CHECK (decimalnr &lt; 10),
    date DATE UNIQUE,
    time TIMESTAMP
);</pre> <p>Create table with <code class="language-plaintext highlighter-rouge">CREATE TABLE ... AS SELECT</code> (CTAS):</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE t1 AS
    SELECT 42 AS i, 84 AS j;</pre> <p>Create a table from a CSV file (automatically detecting column names and types):</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE t1 AS
    SELECT *
    FROM read_csv('path/file.csv');</pre> <p>We can use the <code class="language-plaintext highlighter-rouge">FROM</code>-first syntax to omit <code class="language-plaintext highlighter-rouge">SELECT *</code>:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE t1 AS
    FROM read_csv('path/file.csv');</pre> <p>Copy the schema of <code class="language-plaintext highlighter-rouge">t2</code> to <code class="language-plaintext highlighter-rouge">t1</code>:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE t1 AS
    FROM t2
    LIMIT 0;</pre> <h2 id="temporary-tables"> <a style="text-decoration: none;" href="#temporary-tables">Temporary Tables</a> </h2> <p>Temporary tables can be created using the <code class="language-plaintext highlighter-rouge">CREATE TEMP TABLE</code> or the <code class="language-plaintext highlighter-rouge">CREATE TEMPORARY TABLE</code> statement (see diagram below). Temporary tables are session scoped (similar to PostgreSQL for example), meaning that only the specific connection that created them can access them, and once the connection to DuckDB is closed they will be automatically dropped. Temporary tables reside in memory rather than on disk (even when connecting to a persistent DuckDB), but if the <code class="language-plaintext highlighter-rouge">temp_directory</code> <a href="../../configuration/overview.html">configuration</a> is set when connecting or with a <code class="language-plaintext highlighter-rouge">SET</code> command, data will be spilled to disk if memory becomes constrained.</p> <p>Create a temporary table from a CSV file (automatically detecting column names and types):</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TEMP TABLE t1 AS
    SELECT *
    FROM read_csv('path/file.csv');</pre> <p>Allow temporary tables to off-load excess memory to disk:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SET temp_directory = '/path/to/directory/';</pre> <p>Temporary tables are part of the <code class="language-plaintext highlighter-rouge">temp.main</code> schema. While discouraged, their names can overlap with the names of the regular database tables. In these cases, use their fully qualified name, e.g., <code class="language-plaintext highlighter-rouge">temp.main.t1</code>, for disambiguation.</p> <h2 id="create-or-replace"> <a style="text-decoration: none;" href="#create-or-replace"><code class="language-plaintext highlighter-rouge">CREATE OR REPLACE</code></a> </h2> <p>The <code class="language-plaintext highlighter-rouge">CREATE OR REPLACE</code> syntax allows a new table to be created or for an existing table to be overwritten by the new table. This is shorthand for dropping the existing table and then creating the new one.</p> <p>Create a table with two integer columns (i and j) even if t1 already exists:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE OR REPLACE TABLE t1 (i INTEGER, j INTEGER);</pre> <h2 id="if-not-exists"> <a style="text-decoration: none;" href="#if-not-exists"><code class="language-plaintext highlighter-rouge">IF NOT EXISTS</code></a> </h2> <p>The <code class="language-plaintext highlighter-rouge">IF NOT EXISTS</code> syntax will only proceed with the creation of the table if it does not already exist. If the table already exists, no action will be taken and the existing table will remain in the database.</p> <p>Create a table with two integer columns (<code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">j</code>) only if <code class="language-plaintext highlighter-rouge">t1</code> does not exist yet:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE IF NOT EXISTS t1 (i INTEGER, j INTEGER);</pre> <h2 id="create-table--as-select-ctas"> <a style="text-decoration: none;" href="#create-table--as-select-ctas"><code class="language-plaintext highlighter-rouge">CREATE TABLE ... AS SELECT</code> (CTAS)</a> </h2> <p>DuckDB supports the <code class="language-plaintext highlighter-rouge">CREATE TABLE ... AS SELECT</code> syntax, also known as “CTAS”:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE nums AS
    SELECT i
    FROM range(0, 3) t(i);</pre> <p>This syntax can be used in combination with the <a href="../../data/csv/overview.html">CSV reader</a>, the shorthand to read directly from CSV files without specifying a function, the <a href="../query_syntax/from.html"><code class="language-plaintext highlighter-rouge">FROM</code>-first syntax</a>, and the <a href="../../extensions/httpfs/https.html">HTTP(S) support</a>, yielding concise SQL commands such as the following:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE flights AS
    FROM 'https://duckdb.org/data/flights.csv';</pre> <p>The CTAS construct also works with the <code class="language-plaintext highlighter-rouge">OR REPLACE</code> modifier, yielding <code class="language-plaintext highlighter-rouge">CREATE OR REPLACE TABLE ... AS</code> statements:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE OR REPLACE TABLE flights AS
    FROM 'https://duckdb.org/data/flights.csv';</pre> <p>Note that it is not possible to create tables using CTAS statements with constraints (primary keys, check constraints, etc.).</p> <h2 id="check-constraints"> <a style="text-decoration: none;" href="#check-constraints">Check Constraints</a> </h2> <p>A <code class="language-plaintext highlighter-rouge">CHECK</code> constraint is an expression that must be satisfied by the values of every row in the table.</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE t1 (
    id INTEGER PRIMARY KEY,
    percentage INTEGER CHECK (0 &lt;= percentage AND percentage &lt;= 100)
);
INSERT INTO t1 VALUES (1, 5);
INSERT INTO t1 VALUES (2, -1);</pre> <pre class="language-console highlighter-rouge" data-language="console">Error: Constraint Error: CHECK constraint failed: t1</pre> <pre class="language-sql highlighter-rouge" data-language="sql">INSERT INTO t1 VALUES (3, 101);</pre> <pre class="language-console highlighter-rouge" data-language="console">Error: Constraint Error: CHECK constraint failed: t1</pre> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE t2 (id INTEGER PRIMARY KEY, x INTEGER, y INTEGER CHECK (x &lt; y));
INSERT INTO t2 VALUES (1, 5, 10);
INSERT INTO t2 VALUES (2, 5, 3);</pre> <pre class="language-console highlighter-rouge" data-language="console">Error: Constraint Error: CHECK constraint failed: t2</pre> <p><code class="language-plaintext highlighter-rouge">CHECK</code> constraints can also be added as part of the <code class="language-plaintext highlighter-rouge">CONSTRAINTS</code> clause:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE t3 (
    id INTEGER PRIMARY KEY,
    x INTEGER,
    y INTEGER,
    CONSTRAINT x_smaller_than_y CHECK (x &lt; y)
);
INSERT INTO t3 VALUES (1, 5, 10);
INSERT INTO t3 VALUES (2, 5, 3);</pre> <pre class="language-console highlighter-rouge" data-language="console">Error: Constraint Error: CHECK constraint failed: t3</pre> <h2 id="foreign-key-constraints"> <a style="text-decoration: none;" href="#foreign-key-constraints">Foreign Key Constraints</a> </h2> <p>A <code class="language-plaintext highlighter-rouge">FOREIGN KEY</code> is a column (or set of columns) that references another table's primary key. Foreign keys check referential integrity, i.e., the referred primary key must exist in the other table upon insertion.</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE t1 (id INTEGER PRIMARY KEY, j VARCHAR);
CREATE TABLE t2 (
    id INTEGER PRIMARY KEY,
    t1_id INTEGER,
    FOREIGN KEY (t1_id) REFERENCES t1 (id)
);</pre> <p>Example:</p> <pre class="language-sql highlighter-rouge" data-language="sql">INSERT INTO t1 VALUES (1, 'a');
INSERT INTO t2 VALUES (1, 1);
INSERT INTO t2 VALUES (2, 2);</pre> <pre class="language-console highlighter-rouge" data-language="console">Error: Constraint Error: Violates foreign key constraint because key "id: 2" does not exist in the referenced table</pre> <p>Foreign keys can be defined on composite primary keys:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE t3 (id INTEGER, j VARCHAR, PRIMARY KEY (id, j));
CREATE TABLE t4 (
    id INTEGER PRIMARY KEY, t3_id INTEGER, t3_j VARCHAR,
    FOREIGN KEY (t3_id, t3_j) REFERENCES t3(id, j)
);</pre> <p>Example:</p> <pre class="language-sql highlighter-rouge" data-language="sql">INSERT INTO t3 VALUES (1, 'a');
INSERT INTO t4 VALUES (1, 1, 'a');
INSERT INTO t4 VALUES (2, 1, 'b');</pre> <pre class="language-console highlighter-rouge" data-language="console">Error: Constraint Error: Violates foreign key constraint because key "id: 1, j: b" does not exist in the referenced table</pre> <p>Foreign keys can also be defined on unique columns:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE t5 (id INTEGER UNIQUE, j VARCHAR);
CREATE TABLE t6 (
    id INTEGER PRIMARY KEY,
    t5_id INTEGER,
    FOREIGN KEY (t5_id) REFERENCES t5(id)
);</pre> <h3 id="limitations"> <a style="text-decoration: none;" href="#limitations">Limitations</a> </h3> <p>Foreign keys have the following limitations.</p> <p>Foreign keys with cascading deletes (<code class="language-plaintext highlighter-rouge">FOREIGN KEY ... REFERENCES ... ON DELETE CASCADE</code>) are not supported.</p> <p>Inserting into tables with self-referencing foreign keys is currently not supported and will result in the following error:</p> <pre class="language-console highlighter-rouge" data-language="console">Constraint Error: Violates foreign key constraint because key "..." does not exist in the referenced table.</pre> <h2 id="generated-columns"> <a style="text-decoration: none;" href="#generated-columns">Generated Columns</a> </h2> <p>The <code class="language-plaintext highlighter-rouge">[type] [GENERATED ALWAYS] AS (expr) [VIRTUAL|STORED]</code> syntax will create a generated column. The data in this kind of column is generated from its expression, which can reference other (regular or generated) columns of the table. Since they are produced by calculations, these columns can not be inserted into directly.</p> <p>DuckDB can infer the type of the generated column based on the expression's return type. This allows you to leave out the type when declaring a generated column. It is possible to explicitly set a type, but insertions into the referenced columns might fail if the type can not be cast to the type of the generated column.</p> <p>Generated columns come in two varieties: <code class="language-plaintext highlighter-rouge">VIRTUAL</code> and <code class="language-plaintext highlighter-rouge">STORED</code>. The data of virtual generated columns is not stored on disk, instead it is computed from the expression every time the column is referenced (through a select statement).</p> <p>The data of stored generated columns is stored on disk and is computed every time the data of their dependencies change (through an <code class="language-plaintext highlighter-rouge">INSERT</code> / <code class="language-plaintext highlighter-rouge">UPDATE</code> / <code class="language-plaintext highlighter-rouge">DROP</code> statement).</p> <p>Currently, only the <code class="language-plaintext highlighter-rouge">VIRTUAL</code> kind is supported, and it is also the default option if the last field is left blank.</p> <p>The simplest syntax for a generated column:</p> <p>The type is derived from the expression, and the variant defaults to <code class="language-plaintext highlighter-rouge">VIRTUAL</code>:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE t1 (x FLOAT, two_x AS (2 * x));</pre> <p>Fully specifying the same generated column for completeness:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE t1 (x FLOAT, two_x FLOAT GENERATED ALWAYS AS (2 * x) VIRTUAL);</pre> <h2 id="syntax"> <a style="text-decoration: none;" href="#syntax">Syntax</a> </h2><div class="_attribution">
  <p class="_attribution-p">
    &copy; Copyright 2018&ndash;2024 Stichting DuckDB Foundation<br>Licensed under the MIT License.<br>
    <a href="https://duckdb.org/docs/sql/statements/create_table.html" class="_attribution-link">https://duckdb.org/docs/sql/statements/create_table.html</a>
  </p>
</div>
