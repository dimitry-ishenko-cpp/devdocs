<h1 class="title">PIVOT Statement</h1>  <p>The <code class="language-plaintext highlighter-rouge">PIVOT</code> statement allows distinct values within a column to be separated into their own columns. The values within those new columns are calculated using an aggregate function on the subset of rows that match each distinct value.</p> <p>DuckDB implements both the SQL Standard <code class="language-plaintext highlighter-rouge">PIVOT</code> syntax and a simplified <code class="language-plaintext highlighter-rouge">PIVOT</code> syntax that automatically detects the columns to create while pivoting. <code class="language-plaintext highlighter-rouge">PIVOT_WIDER</code> may also be used in place of the <code class="language-plaintext highlighter-rouge">PIVOT</code> keyword.</p> <p>For details on how the <code class="language-plaintext highlighter-rouge">PIVOT</code> statement is implemented, see the <a href="../../internals/pivot.html#pivot.html">Pivot Internals site</a>.</p> <blockquote> <p>The <a href="unpivot.html"><code class="language-plaintext highlighter-rouge">UNPIVOT</code> statement</a> is the inverse of the <code class="language-plaintext highlighter-rouge">PIVOT</code> statement.</p> </blockquote> <h2 id="simplified-pivot-syntax"> <a style="text-decoration: none;" href="#simplified-pivot-syntax">Simplified <code class="language-plaintext highlighter-rouge">PIVOT</code> Syntax</a> </h2> <p>The full syntax diagram is below, but the simplified <code class="language-plaintext highlighter-rouge">PIVOT</code> syntax can be summarized using spreadsheet pivot table naming conventions as:</p> <pre class="language-sql highlighter-rouge" data-language="sql">PIVOT ⟨dataset⟩
ON ⟨columns⟩
USING ⟨values⟩
GROUP BY ⟨rows⟩
ORDER BY ⟨columns_with_order_directions⟩
LIMIT ⟨number_of_rows⟩;</pre> <p>The <code class="language-plaintext highlighter-rouge">ON</code>, <code class="language-plaintext highlighter-rouge">USING</code>, and <code class="language-plaintext highlighter-rouge">GROUP BY</code> clauses are each optional, but they may not all be omitted.</p> <h3 id="example-data"> <a style="text-decoration: none;" href="#example-data">Example Data</a> </h3> <p>All examples use the dataset produced by the queries below:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE cities (
    country VARCHAR, name VARCHAR, year INTEGER, population INTEGER
);
INSERT INTO cities VALUES
    ('NL', 'Amsterdam', 2000, 1005),
    ('NL', 'Amsterdam', 2010, 1065),
    ('NL', 'Amsterdam', 2020, 1158),
    ('US', 'Seattle', 2000, 564),
    ('US', 'Seattle', 2010, 608),
    ('US', 'Seattle', 2020, 738),
    ('US', 'New York City', 2000, 8015),
    ('US', 'New York City', 2010, 8175),
    ('US', 'New York City', 2020, 8772);</pre> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT *
FROM cities;</pre>  <table> <thead> <tr> <th>country</th> <th>name</th> <th style="text-align: right">year</th> <th style="text-align: right">population</th> </tr> </thead> <tbody> <tr> <td>NL</td> <td>Amsterdam</td> <td style="text-align: right">2000</td> <td style="text-align: right">1005</td> </tr> <tr> <td>NL</td> <td>Amsterdam</td> <td style="text-align: right">2010</td> <td style="text-align: right">1065</td> </tr> <tr> <td>NL</td> <td>Amsterdam</td> <td style="text-align: right">2020</td> <td style="text-align: right">1158</td> </tr> <tr> <td>US</td> <td>Seattle</td> <td style="text-align: right">2000</td> <td style="text-align: right">564</td> </tr> <tr> <td>US</td> <td>Seattle</td> <td style="text-align: right">2010</td> <td style="text-align: right">608</td> </tr> <tr> <td>US</td> <td>Seattle</td> <td style="text-align: right">2020</td> <td style="text-align: right">738</td> </tr> <tr> <td>US</td> <td>New York City</td> <td style="text-align: right">2000</td> <td style="text-align: right">8015</td> </tr> <tr> <td>US</td> <td>New York City</td> <td style="text-align: right">2010</td> <td style="text-align: right">8175</td> </tr> <tr> <td>US</td> <td>New York City</td> <td style="text-align: right">2020</td> <td style="text-align: right">8772</td> </tr> </tbody> </table> <h3 id="pivot-on-and-using"> <a style="text-decoration: none;" href="#pivot-on-and-using"><code class="language-plaintext highlighter-rouge">PIVOT ON</code> and <code class="language-plaintext highlighter-rouge">USING</code></a> </h3> <p>Use the <code class="language-plaintext highlighter-rouge">PIVOT</code> statement below to create a separate column for each year and calculate the total population in each. The <code class="language-plaintext highlighter-rouge">ON</code> clause specifies which column(s) to split into separate columns. It is equivalent to the columns parameter in a spreadsheet pivot table.</p> <p>The <code class="language-plaintext highlighter-rouge">USING</code> clause determines how to aggregate the values that are split into separate columns. This is equivalent to the values parameter in a spreadsheet pivot table. If the <code class="language-plaintext highlighter-rouge">USING</code> clause is not included, it defaults to <code class="language-plaintext highlighter-rouge">count(*)</code>.</p> <pre class="language-sql highlighter-rouge" data-language="sql">PIVOT cities
ON year
USING sum(population);</pre>  <table> <thead> <tr> <th>country</th> <th>name</th> <th style="text-align: right">2000</th> <th style="text-align: right">2010</th> <th style="text-align: right">2020</th> </tr> </thead> <tbody> <tr> <td>NL</td> <td>Amsterdam</td> <td style="text-align: right">1005</td> <td style="text-align: right">1065</td> <td style="text-align: right">1158</td> </tr> <tr> <td>US</td> <td>Seattle</td> <td style="text-align: right">564</td> <td style="text-align: right">608</td> <td style="text-align: right">738</td> </tr> <tr> <td>US</td> <td>New York City</td> <td style="text-align: right">8015</td> <td style="text-align: right">8175</td> <td style="text-align: right">8772</td> </tr> </tbody> </table> <p>In the above example, the <code class="language-plaintext highlighter-rouge">sum</code> aggregate is always operating on a single value. If we only want to change the orientation of how the data is displayed without aggregating, use the <code class="language-plaintext highlighter-rouge">first</code> aggregate function. In this example, we are pivoting numeric values, but the <code class="language-plaintext highlighter-rouge">first</code> function works very well for pivoting out a text column. (This is something that is difficult to do in a spreadsheet pivot table, but easy in DuckDB!)</p> <p>This query produces a result that is identical to the one above:</p> <pre class="language-sql highlighter-rouge" data-language="sql">PIVOT cities
ON year
USING first(population);</pre> <blockquote> <p>Note The SQL syntax permits <a href="../query_syntax/filter.html"><code class="language-plaintext highlighter-rouge">FILTER</code> clauses</a> with aggregate functions in the <code class="language-plaintext highlighter-rouge">USING</code> clause. In DuckDB, the <code class="language-plaintext highlighter-rouge">PIVOT</code> statement currently does not support these and they are silently ignored.</p> </blockquote> <h3 id="pivot-on-using-and-group-by"> <a style="text-decoration: none;" href="#pivot-on-using-and-group-by"><code class="language-plaintext highlighter-rouge">PIVOT ON</code>, <code class="language-plaintext highlighter-rouge">USING</code>, and <code class="language-plaintext highlighter-rouge">GROUP BY</code></a> </h3> <p>By default, the <code class="language-plaintext highlighter-rouge">PIVOT</code> statement retains all columns not specified in the <code class="language-plaintext highlighter-rouge">ON</code> or <code class="language-plaintext highlighter-rouge">USING</code> clauses. To include only certain columns and further aggregate, specify columns in the <code class="language-plaintext highlighter-rouge">GROUP BY</code> clause. This is equivalent to the rows parameter of a spreadsheet pivot table.</p> <p>In the below example, the <code class="language-plaintext highlighter-rouge">name</code> column is no longer included in the output, and the data is aggregated up to the <code class="language-plaintext highlighter-rouge">country</code> level.</p> <pre class="language-sql highlighter-rouge" data-language="sql">PIVOT cities
ON year
USING sum(population)
GROUP BY country;</pre>  <table> <thead> <tr> <th>country</th> <th style="text-align: right">2000</th> <th style="text-align: right">2010</th> <th style="text-align: right">2020</th> </tr> </thead> <tbody> <tr> <td>NL</td> <td style="text-align: right">1005</td> <td style="text-align: right">1065</td> <td style="text-align: right">1158</td> </tr> <tr> <td>US</td> <td style="text-align: right">8579</td> <td style="text-align: right">8783</td> <td style="text-align: right">9510</td> </tr> </tbody> </table> <h3 id="in-filter-for-on-clause"> <a style="text-decoration: none;" href="#in-filter-for-on-clause"><code class="language-plaintext highlighter-rouge">IN</code> Filter for <code class="language-plaintext highlighter-rouge">ON</code> Clause</a> </h3> <p>To only create a separate column for specific values within a column in the <code class="language-plaintext highlighter-rouge">ON</code> clause, use an optional <code class="language-plaintext highlighter-rouge">IN</code> expression. Let's say for example that we wanted to forget about the year 2020 for no particular reason…</p> <pre class="language-sql highlighter-rouge" data-language="sql">PIVOT cities
ON year IN (2000, 2010)
USING sum(population)
GROUP BY country;</pre>  <table> <thead> <tr> <th>country</th> <th style="text-align: right">2000</th> <th style="text-align: right">2010</th> </tr> </thead> <tbody> <tr> <td>NL</td> <td style="text-align: right">1005</td> <td style="text-align: right">1065</td> </tr> <tr> <td>US</td> <td style="text-align: right">8579</td> <td style="text-align: right">8783</td> </tr> </tbody> </table> <h3 id="multiple-expressions-per-clause"> <a style="text-decoration: none;" href="#multiple-expressions-per-clause">Multiple Expressions per Clause</a> </h3> <p>Multiple columns can be specified in the <code class="language-plaintext highlighter-rouge">ON</code> and <code class="language-plaintext highlighter-rouge">GROUP BY</code> clauses, and multiple aggregate expressions can be included in the <code class="language-plaintext highlighter-rouge">USING</code> clause.</p> <h4 id="multiple-on-columns-and-on-expressions"> <a style="text-decoration: none;" href="#multiple-on-columns-and-on-expressions">Multiple <code class="language-plaintext highlighter-rouge">ON</code> Columns and <code class="language-plaintext highlighter-rouge">ON</code> Expressions</a> </h4> <p>Multiple columns can be pivoted out into their own columns. DuckDB will find the distinct values in each <code class="language-plaintext highlighter-rouge">ON</code> clause column and create one new column for all combinations of those values (a Cartesian product).</p> <p>In the below example, all combinations of unique countries and unique cities receive their own column. Some combinations may not be present in the underlying data, so those columns are populated with <code class="language-plaintext highlighter-rouge">NULL</code> values.</p> <pre class="language-sql highlighter-rouge" data-language="sql">PIVOT cities
ON country, name
USING sum(population);</pre>  <table> <thead> <tr> <th style="text-align: right">year</th> <th style="text-align: right">NL_Amsterdam</th> <th>NL_New York City</th> <th>NL_Seattle</th> <th>US_Amsterdam</th> <th style="text-align: right">US_New York City</th> <th style="text-align: right">US_Seattle</th> </tr> </thead> <tbody> <tr> <td style="text-align: right">2000</td> <td style="text-align: right">1005</td> <td>NULL</td> <td>NULL</td> <td>NULL</td> <td style="text-align: right">8015</td> <td style="text-align: right">564</td> </tr> <tr> <td style="text-align: right">2010</td> <td style="text-align: right">1065</td> <td>NULL</td> <td>NULL</td> <td>NULL</td> <td style="text-align: right">8175</td> <td style="text-align: right">608</td> </tr> <tr> <td style="text-align: right">2020</td> <td style="text-align: right">1158</td> <td>NULL</td> <td>NULL</td> <td>NULL</td> <td style="text-align: right">8772</td> <td style="text-align: right">738</td> </tr> </tbody> </table> <p>To pivot only the combinations of values that are present in the underlying data, use an expression in the <code class="language-plaintext highlighter-rouge">ON</code> clause. Multiple expressions and/or columns may be provided.</p> <p>Here, <code class="language-plaintext highlighter-rouge">country</code> and <code class="language-plaintext highlighter-rouge">name</code> are concatenated together and the resulting concatenations each receive their own column. Any arbitrary non-aggregating expression may be used. In this case, concatenating with an underscore is used to imitate the naming convention the <code class="language-plaintext highlighter-rouge">PIVOT</code> clause uses when multiple <code class="language-plaintext highlighter-rouge">ON</code> columns are provided (like in the prior example).</p> <pre class="language-sql highlighter-rouge" data-language="sql">PIVOT cities
ON country || '_' || name
USING sum(population);</pre>  <table> <thead> <tr> <th style="text-align: right">year</th> <th style="text-align: right">NL_Amsterdam</th> <th style="text-align: right">US_New York City</th> <th style="text-align: right">US_Seattle</th> </tr> </thead> <tbody> <tr> <td style="text-align: right">2000</td> <td style="text-align: right">1005</td> <td style="text-align: right">8015</td> <td style="text-align: right">564</td> </tr> <tr> <td style="text-align: right">2010</td> <td style="text-align: right">1065</td> <td style="text-align: right">8175</td> <td style="text-align: right">608</td> </tr> <tr> <td style="text-align: right">2020</td> <td style="text-align: right">1158</td> <td style="text-align: right">8772</td> <td style="text-align: right">738</td> </tr> </tbody> </table> <h4 id="multiple-using-expressions"> <a style="text-decoration: none;" href="#multiple-using-expressions">Multiple <code class="language-plaintext highlighter-rouge">USING</code> Expressions</a> </h4> <p>An alias may also be included for each expression in the <code class="language-plaintext highlighter-rouge">USING</code> clause. It will be appended to the generated column names after an underscore (<code class="language-plaintext highlighter-rouge">_</code>). This makes the column naming convention much cleaner when multiple expressions are included in the <code class="language-plaintext highlighter-rouge">USING</code> clause.</p> <p>In this example, both the <code class="language-plaintext highlighter-rouge">sum</code> and <code class="language-plaintext highlighter-rouge">max</code> of the population column are calculated for each year and are split into separate columns.</p> <pre class="language-sql highlighter-rouge" data-language="sql">PIVOT cities
ON year
USING sum(population) AS total, max(population) AS max
GROUP BY country;</pre>  <table> <thead> <tr> <th>country</th> <th style="text-align: right">2000_total</th> <th style="text-align: right">2000_max</th> <th style="text-align: right">2010_total</th> <th style="text-align: right">2010_max</th> <th style="text-align: right">2020_total</th> <th style="text-align: right">2020_max</th> </tr> </thead> <tbody> <tr> <td>US</td> <td style="text-align: right">8579</td> <td style="text-align: right">8015</td> <td style="text-align: right">8783</td> <td style="text-align: right">8175</td> <td style="text-align: right">9510</td> <td style="text-align: right">8772</td> </tr> <tr> <td>NL</td> <td style="text-align: right">1005</td> <td style="text-align: right">1005</td> <td style="text-align: right">1065</td> <td style="text-align: right">1065</td> <td style="text-align: right">1158</td> <td style="text-align: right">1158</td> </tr> </tbody> </table> <h4 id="multiple-group-by-columns"> <a style="text-decoration: none;" href="#multiple-group-by-columns">Multiple <code class="language-plaintext highlighter-rouge">GROUP BY</code> Columns</a> </h4> <p>Multiple <code class="language-plaintext highlighter-rouge">GROUP BY</code> columns may also be provided. Note that column names must be used rather than column positions (1, 2, etc.), and that expressions are not supported in the <code class="language-plaintext highlighter-rouge">GROUP BY</code> clause.</p> <pre class="language-sql highlighter-rouge" data-language="sql">PIVOT cities
ON year
USING sum(population)
GROUP BY country, name;</pre>  <table> <thead> <tr> <th>country</th> <th>name</th> <th style="text-align: right">2000</th> <th style="text-align: right">2010</th> <th style="text-align: right">2020</th> </tr> </thead> <tbody> <tr> <td>NL</td> <td>Amsterdam</td> <td style="text-align: right">1005</td> <td style="text-align: right">1065</td> <td style="text-align: right">1158</td> </tr> <tr> <td>US</td> <td>Seattle</td> <td style="text-align: right">564</td> <td style="text-align: right">608</td> <td style="text-align: right">738</td> </tr> <tr> <td>US</td> <td>New York City</td> <td style="text-align: right">8015</td> <td style="text-align: right">8175</td> <td style="text-align: right">8772</td> </tr> </tbody> </table> <h3 id="using-pivot-within-a-select-statement"> <a style="text-decoration: none;" href="#using-pivot-within-a-select-statement">Using <code class="language-plaintext highlighter-rouge">PIVOT</code> within a <code class="language-plaintext highlighter-rouge">SELECT</code> Statement</a> </h3> <p>The <code class="language-plaintext highlighter-rouge">PIVOT</code> statement may be included within a <code class="language-plaintext highlighter-rouge">SELECT</code> statement as a CTE (<a href="../query_syntax/with.html">a Common Table Expression, or <code class="language-plaintext highlighter-rouge">WITH</code> clause</a>), or a subquery. This allows for a <code class="language-plaintext highlighter-rouge">PIVOT</code> to be used alongside other SQL logic, as well as for multiple <code class="language-plaintext highlighter-rouge">PIVOT</code>s to be used in one query.</p> <p>No <code class="language-plaintext highlighter-rouge">SELECT</code> is needed within the CTE, the <code class="language-plaintext highlighter-rouge">PIVOT</code> keyword can be thought of as taking its place.</p> <pre class="language-sql highlighter-rouge" data-language="sql">WITH pivot_alias AS (
    PIVOT cities
    ON year
    USING sum(population)
    GROUP BY country
)
SELECT * FROM pivot_alias;</pre> <p>A <code class="language-plaintext highlighter-rouge">PIVOT</code> may be used in a subquery and must be wrapped in parentheses. Note that this behavior is different than the SQL Standard Pivot, as illustrated in subsequent examples.</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT *
FROM (
    PIVOT cities
    ON year
    USING sum(population)
    GROUP BY country
) pivot_alias;</pre> <h3 id="multiple-pivot-statements"> <a style="text-decoration: none;" href="#multiple-pivot-statements">Multiple <code class="language-plaintext highlighter-rouge">PIVOT</code> Statements</a> </h3> <p>Each <code class="language-plaintext highlighter-rouge">PIVOT</code> can be treated as if it were a <code class="language-plaintext highlighter-rouge">SELECT</code> node, so they can be joined together or manipulated in other ways.</p> <p>For example, if two <code class="language-plaintext highlighter-rouge">PIVOT</code> statements share the same <code class="language-plaintext highlighter-rouge">GROUP BY</code> expression, they can be joined together using the columns in the <code class="language-plaintext highlighter-rouge">GROUP BY</code> clause into a wider pivot.</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT *
FROM (PIVOT cities ON year USING sum(population) GROUP BY country) year_pivot
JOIN (PIVOT cities ON name USING sum(population) GROUP BY country) name_pivot
USING (country);</pre>  <table> <thead> <tr> <th>country</th> <th style="text-align: right">2000</th> <th style="text-align: right">2010</th> <th style="text-align: right">2020</th> <th style="text-align: right">Amsterdam</th> <th style="text-align: right">New York City</th> <th style="text-align: right">Seattle</th> </tr> </thead> <tbody> <tr> <td>NL</td> <td style="text-align: right">1005</td> <td style="text-align: right">1065</td> <td style="text-align: right">1158</td> <td style="text-align: right">3228</td> <td style="text-align: right">NULL</td> <td style="text-align: right">NULL</td> </tr> <tr> <td>US</td> <td style="text-align: right">8579</td> <td style="text-align: right">8783</td> <td style="text-align: right">9510</td> <td style="text-align: right">NULL</td> <td style="text-align: right">24962</td> <td style="text-align: right">1910</td> </tr> </tbody> </table> <h2 id="simplified-pivot-full-syntax-diagram"> <a style="text-decoration: none;" href="#simplified-pivot-full-syntax-diagram">Simplified <code class="language-plaintext highlighter-rouge">PIVOT</code> Full Syntax Diagram</a> </h2> <p>Below is the full syntax diagram of the <code class="language-plaintext highlighter-rouge">PIVOT</code> statement.</p>  <h2 id="sql-standard-pivot-syntax"> <a style="text-decoration: none;" href="#sql-standard-pivot-syntax">SQL Standard <code class="language-plaintext highlighter-rouge">PIVOT</code> Syntax</a> </h2> <p>The full syntax diagram is below, but the SQL Standard <code class="language-plaintext highlighter-rouge">PIVOT</code> syntax can be summarized as:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT *
FROM ⟨dataset⟩
PIVOT (
    ⟨values⟩
    FOR
        ⟨column_1⟩ IN (⟨in_list⟩)
        ⟨column_2⟩ IN (⟨in_list⟩)
        ...
    GROUP BY ⟨rows⟩
);</pre> <p>Unlike the simplified syntax, the <code class="language-plaintext highlighter-rouge">IN</code> clause must be specified for each column to be pivoted. If you are interested in dynamic pivoting, the simplified syntax is recommended.</p> <p>Note that no commas separate the expressions in the <code class="language-plaintext highlighter-rouge">FOR</code> clause, but that <code class="language-plaintext highlighter-rouge">value</code> and <code class="language-plaintext highlighter-rouge">GROUP BY</code> expressions must be comma-separated!</p> <h2 id="examples"> <a style="text-decoration: none;" href="#examples">Examples</a> </h2> <p>This example uses a single value expression, a single column expression, and a single row expression:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT *
FROM cities
PIVOT (
    sum(population)
    FOR
        year IN (2000, 2010, 2020)
    GROUP BY country
);</pre>  <table> <thead> <tr> <th>country</th> <th style="text-align: right">2000</th> <th style="text-align: right">2010</th> <th style="text-align: right">2020</th> </tr> </thead> <tbody> <tr> <td>NL</td> <td style="text-align: right">1005</td> <td style="text-align: right">1065</td> <td style="text-align: right">1158</td> </tr> <tr> <td>US</td> <td style="text-align: right">8579</td> <td style="text-align: right">8783</td> <td style="text-align: right">9510</td> </tr> </tbody> </table> <p>This example is somewhat contrived, but serves as an example of using multiple value expressions and multiple columns in the <code class="language-plaintext highlighter-rouge">FOR</code> clause.</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT *
FROM cities
PIVOT (
    sum(population) AS total,
    count(population) AS count
    FOR
        year IN (2000, 2010)
        country IN ('NL', 'US')
);</pre> <table> <thead> <tr> <th>name</th> <th style="text-align: right">2000_NL_total</th> <th style="text-align: right">2000_NL_count</th> <th style="text-align: right">2000_US_total</th> <th style="text-align: right">2000_US_count</th> <th style="text-align: right">2010_NL_total</th> <th style="text-align: right">2010_NL_count</th> <th style="text-align: right">2010_US_total</th> <th style="text-align: right">2010_US_count</th> </tr> </thead> <tbody> <tr> <td>Amsterdam</td> <td style="text-align: right">1005</td> <td style="text-align: right">1</td> <td style="text-align: right">NULL</td> <td style="text-align: right">0</td> <td style="text-align: right">1065</td> <td style="text-align: right">1</td> <td style="text-align: right">NULL</td> <td style="text-align: right">0</td> </tr> <tr> <td>Seattle</td> <td style="text-align: right">NULL</td> <td style="text-align: right">0</td> <td style="text-align: right">564</td> <td style="text-align: right">1</td> <td style="text-align: right">NULL</td> <td style="text-align: right">0</td> <td style="text-align: right">608</td> <td style="text-align: right">1</td> </tr> <tr> <td>New York City</td> <td style="text-align: right">NULL</td> <td style="text-align: right">0</td> <td style="text-align: right">8015</td> <td style="text-align: right">1</td> <td style="text-align: right">NULL</td> <td style="text-align: right">0</td> <td style="text-align: right">8175</td> <td style="text-align: right">1</td> </tr> </tbody> </table> <h3 id="sql-standard-pivot-full-syntax-diagram"> <a style="text-decoration: none;" href="#sql-standard-pivot-full-syntax-diagram">SQL Standard <code class="language-plaintext highlighter-rouge">PIVOT</code> Full Syntax Diagram</a> </h3> <p>Below is the full syntax diagram of the SQL Standard version of the <code class="language-plaintext highlighter-rouge">PIVOT</code> statement.</p>  <h2 id="limitations"> <a style="text-decoration: none;" href="#limitations">Limitations</a> </h2> <p><code class="language-plaintext highlighter-rouge">PIVOT</code> currently only accepts an aggregate function, expressions are not allowed. For example, the following query attempts to get the population as the number of people instead of thousands of people (i.e., instead of 564, get 564000):</p> <pre class="language-sql highlighter-rouge" data-language="sql">PIVOT cities
ON year
USING sum(population) * 1000;</pre> <p>However, it fails with the following error:</p> <pre class="language-console highlighter-rouge" data-language="console">Catalog Error: * is not an aggregate function</pre> <p>To work around this limitation, perform the <code class="language-plaintext highlighter-rouge">PIVOT</code> with the aggregation only, then use the <a href="../expressions/star.html#columns-expression.html"><code class="language-plaintext highlighter-rouge">COLUMNS</code> expression</a>:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT country, name, 1000 * COLUMNS(* EXCLUDE (country, name))
FROM (
    PIVOT cities
    ON year
    USING sum(population)
);</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; Copyright 2018&ndash;2024 Stichting DuckDB Foundation<br>Licensed under the MIT License.<br>
    <a href="https://duckdb.org/docs/sql/statements/pivot.html" class="_attribution-link">https://duckdb.org/docs/sql/statements/pivot.html</a>
  </p>
</div>
