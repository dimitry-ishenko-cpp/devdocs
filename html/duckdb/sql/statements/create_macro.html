<h1 class="title">CREATE MACRO Statement</h1>  <p>The <code class="language-plaintext highlighter-rouge">CREATE MACRO</code> statement can create a scalar or table macro (function) in the catalog. A macro may only be a single <code class="language-plaintext highlighter-rouge">SELECT</code> statement (similar to a <code class="language-plaintext highlighter-rouge">VIEW</code>), but it has the benefit of accepting parameters.</p> <p>For a scalar macro, <code class="language-plaintext highlighter-rouge">CREATE MACRO</code> is followed by the name of the macro, and optionally parameters within a set of parentheses. The keyword <code class="language-plaintext highlighter-rouge">AS</code> is next, followed by the text of the macro. By design, a scalar macro may only return a single value. For a table macro, the syntax is similar to a scalar macro except <code class="language-plaintext highlighter-rouge">AS</code> is replaced with <code class="language-plaintext highlighter-rouge">AS TABLE</code>. A table macro may return a table of arbitrary size and shape.</p> <blockquote> <p>If a <code class="language-plaintext highlighter-rouge">MACRO</code> is temporary, it is only usable within the same database connection and is deleted when the connection is closed.</p> </blockquote> <h2 id="examples"> <a style="text-decoration: none;" href="#examples">Examples</a> </h2> <h3 id="scalar-macros"> <a style="text-decoration: none;" href="#scalar-macros">Scalar Macros</a> </h3> <p>Create a macro that adds two expressions (<code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code>):</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE MACRO add(a, b) AS a + b;</pre> <p>Create a macro for a case expression:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE MACRO ifelse(a, b, c) AS CASE WHEN a THEN b ELSE c END;</pre> <p>Create a macro that does a subquery:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE MACRO one() AS (SELECT 1);</pre> <p>Create a macro with a common table expression. Note that parameter names get priority over column names. To work around this, disambiguate using the table name.</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE MACRO plus_one(a) AS (WITH cte AS (SELECT 1 AS a) SELECT cte.a + a FROM cte);</pre> <p>Macros are schema-dependent, and have an alias, <code class="language-plaintext highlighter-rouge">FUNCTION</code>:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE FUNCTION main.my_avg(x) AS sum(x) / count(x);</pre> <p>Create a macro with default constant parameters:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE MACRO add_default(a, b := 5) AS a + b;</pre> <p>Create a macro <code class="language-plaintext highlighter-rouge">arr_append</code> (with a functionality equivalent to <code class="language-plaintext highlighter-rouge">array_append</code>):</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE MACRO arr_append(l, e) AS list_concat(l, list_value(e));</pre> <h3 id="table-macros"> <a style="text-decoration: none;" href="#table-macros">Table Macros</a> </h3> <p>Create a table macro without parameters:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE MACRO static_table() AS TABLE
    SELECT 'Hello' AS column1, 'World' AS column2;</pre> <p>Create a table macro with parameters (that can be of any type):</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE MACRO dynamic_table(col1_value, col2_value) AS TABLE
    SELECT col1_value AS column1, col2_value AS column2;</pre> <p>Create a table macro that returns multiple rows. It will be replaced if it already exists, and it is temporary (will be automatically deleted when the connection ends):</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE OR REPLACE TEMP MACRO dynamic_table(col1_value, col2_value) AS TABLE
    SELECT col1_value AS column1, col2_value AS column2
    UNION ALL
    SELECT 'Hello' AS col1_value, 456 AS col2_value;</pre> <p>Pass an argument as a list:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE MACRO get_users(i) AS TABLE
    SELECT * FROM users WHERE uid IN (SELECT unnest(i));</pre> <p>An example for how to use the <code class="language-plaintext highlighter-rouge">get_users</code> table macro is the following:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE users AS
    SELECT *
    FROM (VALUES (1, 'Ada'), (2, 'Bob'), (3, 'Carl'), (4, 'Dan'), (5, 'Eve')) t(uid, name);
SELECT * FROM get_users([1, 5]);</pre> <p>To define macros on arbitrary tables, use the <a href="../../guides/sql_features/query_and_query_table_functions.html"><code class="language-plaintext highlighter-rouge">query_table</code> function</a>. For example, the following macro computes a column-wise checksum on a table:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE MACRO checksum(table_name) AS TABLE
    SELECT bit_xor(md5_number(COLUMNS(*)::VARCHAR))
    FROM query_table(table_name);

CREATE TABLE tbl AS SELECT unnest([42, 43]) AS x, 100 AS y;
SELECT * FROM checksum('tbl');</pre> <h2 id="overloading"> <a style="text-decoration: none;" href="#overloading">Overloading</a> </h2> <p>It is possible to overload a macro based on the amount of parameters it takes, this works for both scalar and table macros.</p> <p>By providing overloads we can have both <code class="language-plaintext highlighter-rouge">add_x(a, b)</code> and <code class="language-plaintext highlighter-rouge">add_x(a, b, c)</code> with different function bodies.</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE MACRO add_x
    (a, b) AS a + b,
    (a, b, c) AS a + b + c;</pre> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT
    add_x(21, 42) AS two_args,
    add_x(21, 42, 21) AS three_args;</pre> <table> <thead> <tr> <th>two_args</th> <th>three_args</th> </tr> </thead> <tbody> <tr> <td>63</td> <td>84</td> </tr> </tbody> </table> <h2 id="syntax"> <a style="text-decoration: none;" href="#syntax">Syntax</a> </h2>  <p>Macros allow you to create shortcuts for combinations of expressions.</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE MACRO add(a) AS a + b;</pre> <pre class="language-console highlighter-rouge" data-language="console">Binder Error: Referenced column "b" not found in FROM clause!</pre> <p>This works:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE MACRO add(a, b) AS a + b;</pre> <p>Usage example:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT add(1, 2) AS x;</pre> <table> <thead> <tr> <th style="text-align: right">x</th> </tr> </thead> <tbody> <tr> <td style="text-align: right">3</td> </tr> </tbody> </table> <p>However, this fails:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT add('hello', 3);</pre> <pre class="language-console highlighter-rouge" data-language="console">Binder Error: Could not choose a best candidate function for the function call "+(STRING_LITERAL, INTEGER_LITERAL)". In order to select one, please add explicit type casts.
    Candidate functions:
    +(DATE, INTEGER) -&gt; DATE
    +(INTEGER, INTEGER) -&gt; INTEGER</pre> <p>Macros can have default parameters. Unlike some languages, default parameters must be named when the macro is invoked.</p> <p><code class="language-plaintext highlighter-rouge">b</code> is a default parameter:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE MACRO add_default(a, b := 5) AS a + b;</pre> <p>The following will result in 42:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT add_default(37);</pre> <p>The following will throw an error:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT add_default(40, 2);</pre> <pre class="language-console highlighter-rouge" data-language="console">Binder Error: Macro function 'add_default(a)' requires a single positional argument, but 2 positional arguments were provided.</pre> <p>Default parameters must used by assigning them like the following:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT add_default(40, b := 2) AS x;</pre> <table> <thead> <tr> <th style="text-align: right">x</th> </tr> </thead> <tbody> <tr> <td style="text-align: right">42</td> </tr> </tbody> </table> <p>However, the following fails:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT add_default(b := 2, 40);</pre> <pre class="language-console highlighter-rouge" data-language="console">Binder Error: Positional parameters cannot come after parameters with a default value!</pre> <p>The order of default parameters does not matter:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE MACRO triple_add(a, b := 5, c := 10) AS a + b + c;</pre> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT triple_add(40, c := 1, b := 1) AS x;</pre> <table> <thead> <tr> <th style="text-align: right">x</th> </tr> </thead> <tbody> <tr> <td style="text-align: right">42</td> </tr> </tbody> </table> <p>When macros are used, they are expanded (i.e., replaced with the original expression), and the parameters within the expanded expression are replaced with the supplied arguments. Step by step:</p> <p>The <code class="language-plaintext highlighter-rouge">add</code> macro we defined above is used in a query:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT add(40, 2) AS x;</pre> <p>Internally, add is replaced with its definition of <code class="language-plaintext highlighter-rouge">a + b</code>:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT a + b; AS x</pre> <p>Then, the parameters are replaced by the supplied arguments:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT 40 + 2 AS x;</pre> <h2 id="limitations"> <a style="text-decoration: none;" href="#limitations">Limitations</a> </h2> <h3 id="using-named-parameters"> <a style="text-decoration: none;" href="#using-named-parameters">Using Named Parameters</a> </h3> <p>Currently, positional macro parameters can only be used positionally, and named parameters can only be used by supplying their name. Therefore, the following will not work:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE MACRO my_macro(a, b := 42) AS (a + b);
SELECT my_macro(32, 52);</pre> <pre class="language-console highlighter-rouge" data-language="console">Error: Binder Error: Macro function 'my_macro(a)' requires a single positional argument, but 2 positional arguments were provided.</pre> <h3 id="using-subquery-macros"> <a style="text-decoration: none;" href="#using-subquery-macros">Using Subquery Macros</a> </h3> <p>If a <code class="language-plaintext highlighter-rouge">MACRO</code> is defined as a subquery, it cannot be invoked in a table function. DuckDB will return the following error:</p> <pre class="language-console highlighter-rouge" data-language="console">Binder Error: Table function cannot contain subqueries</pre> <h3 id="overloads"> <a style="text-decoration: none;" href="#overloads">Overloads</a> </h3> <p>Overloads for macro functions have to be set at creation, it is not possible to define a macro by the same name twice without first removing the first definition.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; Copyright 2018&ndash;2024 Stichting DuckDB Foundation<br>Licensed under the MIT License.<br>
    <a href="https://duckdb.org/docs/sql/statements/create_macro.html" class="_attribution-link">https://duckdb.org/docs/sql/statements/create_macro.html</a>
  </p>
</div>
