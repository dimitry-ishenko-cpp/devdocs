<h1 class="title">JSON Processing Functions</h1>  <h2 id="json-extraction-functions"> <a style="text-decoration: none;" href="#json-extraction-functions">JSON Extraction Functions</a> </h2> <p>There are two extraction functions, which have their respective operators. The operators can only be used if the string is stored as the <code class="language-plaintext highlighter-rouge">JSON</code> logical type. These functions supports the same two location notations as <a href="#json-scalar-functions">JSON Scalar functions</a>.</p> <table> <thead> <tr> <th style="text-align: left">Function</th> <th style="text-align: left">Alias</th> <th style="text-align: left">Operator</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">json_exists(json, path)</code></td> <td style="text-align: left"> </td> <td style="text-align: left"> </td> <td>Returns <code class="language-plaintext highlighter-rouge">true</code> if the supplied path exists in the <code class="language-plaintext highlighter-rouge">json</code>, and <code class="language-plaintext highlighter-rouge">false</code> otherwise.</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">json_extract(json, path)</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">json_extract_path</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">-&gt;</code></td> <td>Extracts <code class="language-plaintext highlighter-rouge">JSON</code> from <code class="language-plaintext highlighter-rouge">json</code> at the given <code class="language-plaintext highlighter-rouge">path</code>. If <code class="language-plaintext highlighter-rouge">path</code> is a <code class="language-plaintext highlighter-rouge">LIST</code>, the result will be a <code class="language-plaintext highlighter-rouge">LIST</code> of <code class="language-plaintext highlighter-rouge">JSON</code>.</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">json_extract_string(json, path)</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">json_extract_path_text</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">-&gt;&gt;</code></td> <td>Extracts <code class="language-plaintext highlighter-rouge">VARCHAR</code> from <code class="language-plaintext highlighter-rouge">json</code> at the given <code class="language-plaintext highlighter-rouge">path</code>. If <code class="language-plaintext highlighter-rouge">path</code> is a <code class="language-plaintext highlighter-rouge">LIST</code>, the result will be a <code class="language-plaintext highlighter-rouge">LIST</code> of <code class="language-plaintext highlighter-rouge">VARCHAR</code>.</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">json_value(json, path)</code></td> <td style="text-align: left"> </td> <td style="text-align: left"> </td> <td>Extracts <code class="language-plaintext highlighter-rouge">JSON</code> from <code class="language-plaintext highlighter-rouge">json</code> at the given <code class="language-plaintext highlighter-rouge">path</code>. If the <code class="language-plaintext highlighter-rouge">json</code> at the supplied path is not a scalar value, it will return <code class="language-plaintext highlighter-rouge">NULL</code>.</td> </tr> </tbody> </table> <p>Note that the equality comparison operator (<code class="language-plaintext highlighter-rouge">=</code>) has a higher precedence than the <code class="language-plaintext highlighter-rouge">-&gt;</code> JSON extract operator. Therefore, surround the uses of the <code class="language-plaintext highlighter-rouge">-&gt;</code> operator with parentheses when making equality comparisons. For example:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT ((JSON '{"field": 42}')-&gt;'field') = 42;</pre> <blockquote> <p>Warning DuckDB's JSON data type uses <a href="#indexing">0-based indexing</a>.</p> </blockquote> <p>Examples:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE example (j JSON);
INSERT INTO example VALUES
    ('{ "family": "anatidae", "species": [ "duck", "goose", "swan", null ] }');</pre> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT json_extract(j, '$.family') FROM example;</pre> <pre class="language-text highlighter-rouge" data-language="text">"anatidae"</pre> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT j-&gt;'$.family' FROM example;</pre> <pre class="language-text highlighter-rouge" data-language="text">"anatidae"</pre> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT j-&gt;'$.species[0]' FROM example;</pre> <pre class="language-text highlighter-rouge" data-language="text">"duck"</pre> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT j-&gt;'$.species[*]' FROM example;</pre> <pre class="language-text highlighter-rouge" data-language="text">["duck", "goose", "swan", null]</pre> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT j-&gt;&gt;'$.species[*]' FROM example;</pre> <pre class="language-text highlighter-rouge" data-language="text">[duck, goose, swan, null]</pre> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT j-&gt;'$.species'-&gt;0 FROM example;</pre> <pre class="language-text highlighter-rouge" data-language="text">"duck"</pre> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT j-&gt;'species'-&gt;['0','1'] FROM example;</pre> <pre class="language-text highlighter-rouge" data-language="text">["duck", "goose"]</pre> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT json_extract_string(j, '$.family') FROM example;</pre> <pre class="language-text highlighter-rouge" data-language="text">anatidae</pre> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT j-&gt;&gt;'$.family' FROM example;</pre> <pre class="language-text highlighter-rouge" data-language="text">anatidae</pre> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT j-&gt;&gt;'$.species[0]' FROM example;</pre> <pre class="language-text highlighter-rouge" data-language="text">duck</pre> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT j-&gt;'species'-&gt;&gt;0 FROM example;</pre> <pre class="language-text highlighter-rouge" data-language="text">duck</pre> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT j-&gt;'species'-&gt;&gt;['0','1'] FROM example;</pre> <pre class="language-text highlighter-rouge" data-language="text">[duck, goose]</pre> <p>Note that DuckDB's JSON data type uses <a href="#indexing">0-based indexing</a>.</p> <p>If multiple values need to be extracted from the same JSON, it is more efficient to extract a list of paths:</p> <p>The following will cause the JSON to be parsed twice,:</p> <p>Resulting in a slower query that uses more memory:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT
    json_extract(j, 'family') AS family,
    json_extract(j, 'species') AS species
FROM example;</pre>  <table> <thead> <tr> <th>family</th> <th>species</th> </tr> </thead> <tbody> <tr> <td>"anatidae"</td> <td>["duck","goose","swan",null]</td> </tr> </tbody> </table> <p>The following produces the same result but is faster and more memory-efficient:</p> <pre class="language-sql highlighter-rouge" data-language="sql">WITH extracted AS (
    SELECT json_extract(j, ['family', 'species']) AS extracted_list
    FROM example
)
SELECT
    extracted_list[1] AS family,
    extracted_list[2] AS species
FROM extracted;</pre> <h2 id="json-scalar-functions"> <a style="text-decoration: none;" href="#json-scalar-functions">JSON Scalar Functions</a> </h2> <p>The following scalar JSON functions can be used to gain information about the stored JSON values. With the exception of <code class="language-plaintext highlighter-rouge">json_valid(json)</code>, all JSON functions produce an error when invalid JSON is supplied.</p> <p>We support two kinds of notations to describe locations within JSON: <a href="https://datatracker.ietf.org/doc/html/rfc6901">JSON Pointer</a> and JSONPath.</p> <table> <thead> <tr> <th style="text-align: left">Function</th> <th style="text-align: left">Description</th> </tr> </thead> <tbody> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">json_array_length(json[, path])</code></td> <td style="text-align: left">Return the number of elements in the JSON array <code class="language-plaintext highlighter-rouge">json</code>, or <code class="language-plaintext highlighter-rouge">0</code> if it is not a JSON array. If <code class="language-plaintext highlighter-rouge">path</code> is specified, return the number of elements in the JSON array at the given <code class="language-plaintext highlighter-rouge">path</code>. If <code class="language-plaintext highlighter-rouge">path</code> is a <code class="language-plaintext highlighter-rouge">LIST</code>, the result will be <code class="language-plaintext highlighter-rouge">LIST</code> of array lengths.</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">json_contains(json_haystack, json_needle)</code></td> <td style="text-align: left">Returns <code class="language-plaintext highlighter-rouge">true</code> if <code class="language-plaintext highlighter-rouge">json_needle</code> is contained in <code class="language-plaintext highlighter-rouge">json_haystack</code>. Both parameters are of JSON type, but <code class="language-plaintext highlighter-rouge">json_needle</code> can also be a numeric value or a string, however the string must be wrapped in double quotes.</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">json_keys(json[, path])</code></td> <td style="text-align: left">Returns the keys of <code class="language-plaintext highlighter-rouge">json</code> as a <code class="language-plaintext highlighter-rouge">LIST</code> of <code class="language-plaintext highlighter-rouge">VARCHAR</code>, if <code class="language-plaintext highlighter-rouge">json</code> is a JSON object. If <code class="language-plaintext highlighter-rouge">path</code> is specified, return the keys of the JSON object at the given <code class="language-plaintext highlighter-rouge">path</code>. If <code class="language-plaintext highlighter-rouge">path</code> is a <code class="language-plaintext highlighter-rouge">LIST</code>, the result will be <code class="language-plaintext highlighter-rouge">LIST</code> of <code class="language-plaintext highlighter-rouge">LIST</code> of <code class="language-plaintext highlighter-rouge">VARCHAR</code>.</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">json_structure(json)</code></td> <td style="text-align: left">Return the structure of <code class="language-plaintext highlighter-rouge">json</code>. Defaults to <code class="language-plaintext highlighter-rouge">JSON</code> if the structure is inconsistent (e.g., incompatible types in an array).</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">json_type(json[, path])</code></td> <td style="text-align: left">Return the type of the supplied <code class="language-plaintext highlighter-rouge">json</code>, which is one of <code class="language-plaintext highlighter-rouge">ARRAY</code>, <code class="language-plaintext highlighter-rouge">BIGINT</code>, <code class="language-plaintext highlighter-rouge">BOOLEAN</code>, <code class="language-plaintext highlighter-rouge">DOUBLE</code>, <code class="language-plaintext highlighter-rouge">OBJECT</code>, <code class="language-plaintext highlighter-rouge">UBIGINT</code>, <code class="language-plaintext highlighter-rouge">VARCHAR</code>, and <code class="language-plaintext highlighter-rouge">NULL</code>. If <code class="language-plaintext highlighter-rouge">path</code> is specified, return the type of the element at the given <code class="language-plaintext highlighter-rouge">path</code>. If <code class="language-plaintext highlighter-rouge">path</code> is a <code class="language-plaintext highlighter-rouge">LIST</code>, the result will be <code class="language-plaintext highlighter-rouge">LIST</code> of types.</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">json_valid(json)</code></td> <td style="text-align: left">Return whether <code class="language-plaintext highlighter-rouge">json</code> is valid JSON.</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">json(json)</code></td> <td style="text-align: left">Parse and minify <code class="language-plaintext highlighter-rouge">json</code>.</td> </tr> </tbody> </table> <p>The JSONPointer syntax separates each field with a <code class="language-plaintext highlighter-rouge">/</code>. For example, to extract the first element of the array with key <code class="language-plaintext highlighter-rouge">duck</code>, you can do:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT json_extract('{"duck": [1, 2, 3]}', '/duck/0');</pre> <pre class="language-text highlighter-rouge" data-language="text">1</pre> <p>The JSONPath syntax separates fields with a <code class="language-plaintext highlighter-rouge">.</code>, and accesses array elements with <code class="language-plaintext highlighter-rouge">[i]</code>, and always starts with <code class="language-plaintext highlighter-rouge">$</code>. Using the same example, we can do the following:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT json_extract('{"duck": [1, 2, 3]}', '$.duck[0]');</pre> <pre class="language-text highlighter-rouge" data-language="text">1</pre> <p>Note that DuckDB's JSON data type uses <a href="#indexing">0-based indexing</a>.</p> <p>JSONPath is more expressive, and can also access from the back of lists:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT json_extract('{"duck": [1, 2, 3]}', '$.duck[#-1]');</pre> <pre class="language-text highlighter-rouge" data-language="text">3</pre> <p>JSONPath also allows escaping syntax tokens, using double quotes:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT json_extract('{"duck.goose": [1, 2, 3]}', '$."duck.goose"[1]');</pre> <pre class="language-text highlighter-rouge" data-language="text">2</pre> <p>Examples using the <a href="https://en.wikipedia.org/wiki/Anatidae">anatidae biological family</a>:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE example (j JSON);
INSERT INTO example VALUES
    ('{ "family": "anatidae", "species": [ "duck", "goose", "swan", null ] }');</pre> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT json(j) FROM example;</pre> <pre class="language-text highlighter-rouge" data-language="text">{"family":"anatidae","species":["duck","goose","swan",null]}</pre> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT j.family FROM example;</pre> <pre class="language-text highlighter-rouge" data-language="text">"anatidae"</pre> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT j.species[0] FROM example;</pre> <pre class="language-text highlighter-rouge" data-language="text">"duck"</pre> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT json_valid(j) FROM example;</pre> <pre class="language-text highlighter-rouge" data-language="text">true</pre> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT json_valid('{');</pre> <pre class="language-text highlighter-rouge" data-language="text">false</pre> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT json_array_length('["duck", "goose", "swan", null]');</pre> <pre class="language-text highlighter-rouge" data-language="text">4</pre> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT json_array_length(j, 'species') FROM example;</pre> <pre class="language-text highlighter-rouge" data-language="text">4</pre> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT json_array_length(j, '/species') FROM example;</pre> <pre class="language-text highlighter-rouge" data-language="text">4</pre> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT json_array_length(j, '$.species') FROM example;</pre> <pre class="language-text highlighter-rouge" data-language="text">4</pre> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT json_array_length(j, ['$.species']) FROM example;</pre> <pre class="language-text highlighter-rouge" data-language="text">[4]</pre> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT json_type(j) FROM example;</pre> <pre class="language-text highlighter-rouge" data-language="text">OBJECT</pre> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT json_keys(j) FROM example;</pre> <pre class="language-text highlighter-rouge" data-language="text">[family, species]</pre> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT json_structure(j) FROM example;</pre> <pre class="language-text highlighter-rouge" data-language="text">{"family":"VARCHAR","species":["VARCHAR"]}</pre> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT json_structure('["duck", {"family": "anatidae"}]');</pre> <pre class="language-text highlighter-rouge" data-language="text">["JSON"]</pre> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT json_contains('{"key": "value"}', '"value"');</pre> <pre class="language-text highlighter-rouge" data-language="text">true</pre> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT json_contains('{"key": 1}', '1');</pre> <pre class="language-text highlighter-rouge" data-language="text">true</pre> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT json_contains('{"top_key": {"key": "value"}}', '{"key": "value"}');</pre> <pre class="language-text highlighter-rouge" data-language="text">true</pre> <h2 id="json-aggregate-functions"> <a style="text-decoration: none;" href="#json-aggregate-functions">JSON Aggregate Functions</a> </h2> <p>There are three JSON aggregate functions.</p>  <table> <thead> <tr> <th style="text-align: left">Function</th> <th style="text-align: left">Description</th> </tr> </thead> <tbody> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">json_group_array(any)</code></td> <td style="text-align: left">Return a JSON array with all values of <code class="language-plaintext highlighter-rouge">any</code> in the aggregation.</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">json_group_object(key, value)</code></td> <td style="text-align: left">Return a JSON object with all <code class="language-plaintext highlighter-rouge">key</code>, <code class="language-plaintext highlighter-rouge">value</code> pairs in the aggregation.</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">json_group_structure(json)</code></td> <td style="text-align: left">Return the combined <code class="language-plaintext highlighter-rouge">json_structure</code> of all <code class="language-plaintext highlighter-rouge">json</code> in the aggregation.</td> </tr> </tbody> </table> <p>Examples:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE example1 (k VARCHAR, v INTEGER);
INSERT INTO example1 VALUES ('duck', 42), ('goose', 7);</pre> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT json_group_array(v) FROM example1;</pre> <pre class="language-text highlighter-rouge" data-language="text">[42, 7]</pre> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT json_group_object(k, v) FROM example1;</pre> <pre class="language-text highlighter-rouge" data-language="text">{"duck":42,"goose":7}</pre> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE example2 (j JSON);
INSERT INTO example2 VALUES
    ('{"family": "anatidae", "species": ["duck", "goose"], "coolness": 42.42}'),
    ('{"family": "canidae", "species": ["labrador", "bulldog"], "hair": true}');</pre> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT json_group_structure(j) FROM example2;</pre> <pre class="language-text highlighter-rouge" data-language="text">{"family":"VARCHAR","species":["VARCHAR"],"coolness":"DOUBLE","hair":"BOOLEAN"}</pre> <h2 id="transforming-json-to-nested-types"> <a style="text-decoration: none;" href="#transforming-json-to-nested-types">Transforming JSON to Nested Types</a> </h2> <p>In many cases, it is inefficient to extract values from JSON one-by-one. Instead, we can “extract” all values at once, transforming JSON to the nested types <code class="language-plaintext highlighter-rouge">LIST</code> and <code class="language-plaintext highlighter-rouge">STRUCT</code>.</p>  <table> <thead> <tr> <th style="text-align: left">Function</th> <th style="text-align: left">Description</th> </tr> </thead> <tbody> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">json_transform(json, structure)</code></td> <td style="text-align: left">Transform <code class="language-plaintext highlighter-rouge">json</code> according to the specified <code class="language-plaintext highlighter-rouge">structure</code>.</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">from_json(json, structure)</code></td> <td style="text-align: left">Alias for <code class="language-plaintext highlighter-rouge">json_transform</code>.</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">json_transform_strict(json, structure)</code></td> <td style="text-align: left">Same as <code class="language-plaintext highlighter-rouge">json_transform</code>, but throws an error when type casting fails.</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">from_json_strict(json, structure)</code></td> <td style="text-align: left">Alias for <code class="language-plaintext highlighter-rouge">json_transform_strict</code>.</td> </tr> </tbody> </table> <p>The <code class="language-plaintext highlighter-rouge">structure</code> argument is JSON of the same form as returned by <code class="language-plaintext highlighter-rouge">json_structure</code>. The <code class="language-plaintext highlighter-rouge">structure</code> argument can be modified to transform the JSON into the desired structure and types. It is possible to extract fewer key/value pairs than are present in the JSON, and it is also possible to extract more: missing keys become <code class="language-plaintext highlighter-rouge">NULL</code>.</p> <p>Examples:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE example (j JSON);
INSERT INTO example VALUES
    ('{"family": "anatidae", "species": ["duck", "goose"], "coolness": 42.42}'),
    ('{"family": "canidae", "species": ["labrador", "bulldog"], "hair": true}');</pre> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT json_transform(j, '{"family": "VARCHAR", "coolness": "DOUBLE"}') FROM example;</pre> <pre class="language-text highlighter-rouge" data-language="text">{'family': anatidae, 'coolness': 42.420000}
{'family': canidae, 'coolness': NULL}</pre> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT json_transform(j, '{"family": "TINYINT", "coolness": "DECIMAL(4, 2)"}') FROM example;</pre> <pre class="language-text highlighter-rouge" data-language="text">{'family': NULL, 'coolness': 42.42}
{'family': NULL, 'coolness': NULL}</pre> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT json_transform_strict(j, '{"family": "TINYINT", "coolness": "DOUBLE"}') FROM example;</pre> <pre class="language-console highlighter-rouge" data-language="console">Invalid Input Error: Failed to cast value: "anatidae"</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; Copyright 2018&ndash;2024 Stichting DuckDB Foundation<br>Licensed under the MIT License.<br>
    <a href="https://duckdb.org/docs/data/json/json_functions.html" class="_attribution-link">https://duckdb.org/docs/data/json/json_functions.html</a>
  </p>
</div>
