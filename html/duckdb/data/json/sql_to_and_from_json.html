<h1 class="title">SQL to/from JSON</h1>  <p>The <code class="language-plaintext highlighter-rouge">json</code> extension also provides functions to serialize and deserialize <code class="language-plaintext highlighter-rouge">SELECT</code> statements between SQL and JSON, as well as executing JSON serialized statements.</p> <table> <thead> <tr> <th style="text-align: left">Function</th> <th style="text-align: left">Type</th> <th style="text-align: left">Description</th> </tr> </thead> <tbody> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">json_deserialize_sql(json)</code></td> <td style="text-align: left">Scalar</td> <td style="text-align: left">Deserialize one or many <code class="language-plaintext highlighter-rouge">json</code> serialized statements back to an equivalent SQL string.</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">json_execute_serialized_sql(varchar)</code></td> <td style="text-align: left">Table</td> <td style="text-align: left">Execute <code class="language-plaintext highlighter-rouge">json</code> serialized statements and return the resulting rows. Only one statement at a time is supported for now.</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">json_serialize_sql(varchar, skip_empty := boolean, skip_null := boolean, format := boolean)</code></td> <td style="text-align: left">Scalar</td> <td style="text-align: left">Serialize a set of semicolon-separated (<code class="language-plaintext highlighter-rouge">;</code>) select statements to an equivalent list of <code class="language-plaintext highlighter-rouge">json</code> serialized statements.</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">PRAGMA json_execute_serialized_sql(varchar)</code></td> <td style="text-align: left">Pragma</td> <td style="text-align: left">Pragma version of the <code class="language-plaintext highlighter-rouge">json_execute_serialized_sql</code> function.</td> </tr> </tbody> </table> <p>The <code class="language-plaintext highlighter-rouge">json_serialize_sql(varchar)</code> function takes three optional parameters, <code class="language-plaintext highlighter-rouge">skip_empty</code>, <code class="language-plaintext highlighter-rouge">skip_null</code>, and <code class="language-plaintext highlighter-rouge">format</code> that can be used to control the output of the serialized statements.</p> <p>If you run the <code class="language-plaintext highlighter-rouge">json_execute_serialize_sql(varchar)</code> table function inside of a transaction the serialized statements will not be able to see any transaction local changes. This is because the statements are executed in a separate query context. You can use the <code class="language-plaintext highlighter-rouge">PRAGMA json_execute_serialize_sql(varchar)</code> pragma version to execute the statements in the same query context as the pragma, although with the limitation that the serialized JSON must be provided as a constant string, i.e., you cannot do <code class="language-plaintext highlighter-rouge">PRAGMA json_execute_serialize_sql(json_serialize_sql(...))</code>.</p> <p>Note that these functions do not preserve syntactic sugar such as <code class="language-plaintext highlighter-rouge">FROM * SELECT ...</code>, so a statement round-tripped through <code class="language-plaintext highlighter-rouge">json_deserialize_sql(json_serialize_sql(...))</code> may not be identical to the original statement, but should always be semantically equivalent and produce the same output.</p> <h3 id="examples"> <a style="text-decoration: none;" href="#examples">Examples</a> </h3> <p>Simple example:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT json_serialize_sql('SELECT 2');</pre> <pre class="language-text highlighter-rouge" data-language="text">'{"error":false,"statements":[{"node":{"type":"SELECT_NODE","modifiers":[],"cte_map":{"map":[]},"select_list":[{"class":"CONSTANT","type":"VALUE_CONSTANT","alias":"","value":{"type":{"id":"INTEGER","type_info":null},"is_null":false,"value":2}}],"from_table":{"type":"EMPTY","alias":"","sample":null},"where_clause":null,"group_expressions":[],"group_sets":[],"aggregate_handling":"STANDARD_HANDLING","having":null,"sample":null,"qualify":null}}]}'</pre> <p>Example with multiple statements and skip options:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT json_serialize_sql('SELECT 1 + 2; SELECT a + b FROM tbl1', skip_empty := true, skip_null := true);</pre> <pre class="language-text highlighter-rouge" data-language="text">'{"error":false,"statements":[{"node":{"type":"SELECT_NODE","select_list":[{"class":"FUNCTION","type":"FUNCTION","function_name":"+","children":[{"class":"CONSTANT","type":"VALUE_CONSTANT","value":{"type":{"id":"INTEGER"},"is_null":false,"value":1}},{"class":"CONSTANT","type":"VALUE_CONSTANT","value":{"type":{"id":"INTEGER"},"is_null":false,"value":2}}],"order_bys":{"type":"ORDER_MODIFIER"},"distinct":false,"is_operator":true,"export_state":false}],"from_table":{"type":"EMPTY"},"aggregate_handling":"STANDARD_HANDLING"}},{"node":{"type":"SELECT_NODE","select_list":[{"class":"FUNCTION","type":"FUNCTION","function_name":"+","children":[{"class":"COLUMN_REF","type":"COLUMN_REF","column_names":["a"]},{"class":"COLUMN_REF","type":"COLUMN_REF","column_names":["b"]}],"order_bys":{"type":"ORDER_MODIFIER"},"distinct":false,"is_operator":true,"export_state":false}],"from_table":{"type":"BASE_TABLE","table_name":"tbl1"},"aggregate_handling":"STANDARD_HANDLING"}}]}'</pre> <p>Example with a syntax error:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT json_serialize_sql('TOTALLY NOT VALID SQL');</pre> <pre class="language-text highlighter-rouge" data-language="text">'{"error":true,"error_type":"parser","error_message":"syntax error at or near \"TOTALLY\"\nLINE 1: TOTALLY NOT VALID SQL\n        ^"}'</pre> <p>Example with deserialize:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT json_deserialize_sql(json_serialize_sql('SELECT 1 + 2'));</pre> <pre class="language-text highlighter-rouge" data-language="text">'SELECT (1 + 2)'</pre> <p>Example with deserialize and syntax sugar:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT json_deserialize_sql(json_serialize_sql('FROM x SELECT 1 + 2'));</pre> <pre class="language-text highlighter-rouge" data-language="text">'SELECT (1 + 2) FROM x'</pre> <p>Example with execute:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT * FROM json_execute_serialized_sql(json_serialize_sql('SELECT 1 + 2'));</pre> <pre class="language-text highlighter-rouge" data-language="text">3</pre> <p>Example with error:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT * FROM json_execute_serialized_sql(json_serialize_sql('TOTALLY NOT VALID SQL'));</pre> <pre class="language-console highlighter-rouge" data-language="console">Error: Parser Error: Error parsing json: parser: syntax error at or near "TOTALLY"</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; Copyright 2018&ndash;2024 Stichting DuckDB Foundation<br>Licensed under the MIT License.<br>
    <a href="https://duckdb.org/docs/data/json/sql_to_and_from_json.html" class="_attribution-link">https://duckdb.org/docs/data/json/sql_to_and_from_json.html</a>
  </p>
</div>
