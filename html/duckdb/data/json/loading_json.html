<h1 class="title">Loading JSON</h1>  <p>The DuckDB JSON reader can automatically infer which configuration flags to use by analyzing the JSON file. This will work correctly in most situations, and should be the first option attempted. In rare situations where the JSON reader cannot figure out the correct configuration, it is possible to manually configure the JSON reader to correctly parse the JSON file.</p> <h2 id="json-read-functions"> <a style="text-decoration: none;" href="#json-read-functions">JSON Read Functions</a> </h2> <p>The following table functions are used to read JSON:</p> <table> <thead> <tr> <th style="text-align: left">Function</th> <th style="text-align: left">Description</th> </tr> </thead> <tbody> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">read_json_objects(filename)</code></td> <td style="text-align: left">Read a JSON object from <code class="language-plaintext highlighter-rouge">filename</code>, where <code class="language-plaintext highlighter-rouge">filename</code> can also be a list of files or a glob pattern.</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">read_ndjson_objects(filename)</code></td> <td style="text-align: left">Alias for <code class="language-plaintext highlighter-rouge">read_json_objects</code> with parameter <code class="language-plaintext highlighter-rouge">format</code> set to <code class="language-plaintext highlighter-rouge">'newline_delimited'</code>.</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">read_json_objects_auto(filename)</code></td> <td style="text-align: left">Alias for <code class="language-plaintext highlighter-rouge">read_json_objects</code> with parameter <code class="language-plaintext highlighter-rouge">format</code> set to <code class="language-plaintext highlighter-rouge">'auto'</code>.</td> </tr> </tbody> </table> <p>These functions have the following parameters:</p> <table> <thead> <tr> <th style="text-align: left">Name</th> <th style="text-align: left">Description</th> <th style="text-align: left">Type</th> <th style="text-align: left">Default</th> </tr> </thead> <tbody> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">compression</code></td> <td style="text-align: left">The compression type for the file. By default this will be detected automatically from the file extension (e.g., <code class="language-plaintext highlighter-rouge">t.json.gz</code> will use gzip, <code class="language-plaintext highlighter-rouge">t.json</code> will use none). Options are <code class="language-plaintext highlighter-rouge">'none'</code>, <code class="language-plaintext highlighter-rouge">'gzip'</code>, <code class="language-plaintext highlighter-rouge">'zstd'</code>, and <code class="language-plaintext highlighter-rouge">'auto'</code>.</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">VARCHAR</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">'auto'</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">filename</code></td> <td style="text-align: left">Whether or not an extra <code class="language-plaintext highlighter-rouge">filename</code> column should be included in the result.</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">BOOL</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">false</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">format</code></td> <td style="text-align: left">Can be one of <code class="language-plaintext highlighter-rouge">['auto', 'unstructured', 'newline_delimited', 'array']</code>.</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">VARCHAR</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">'array'</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">hive_partitioning</code></td> <td style="text-align: left">Whether or not to interpret the path as a <a href="../partitioning/hive_partitioning.html">Hive partitioned path</a>.</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">BOOL</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">false</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">ignore_errors</code></td> <td style="text-align: left">Whether to ignore parse errors (only possible when <code class="language-plaintext highlighter-rouge">format</code> is <code class="language-plaintext highlighter-rouge">'newline_delimited'</code>).</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">BOOL</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">false</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">maximum_sample_files</code></td> <td style="text-align: left">The maximum number of JSON files sampled for auto-detection.</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">BIGINT</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">32</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">maximum_object_size</code></td> <td style="text-align: left">The maximum size of a JSON object (in bytes).</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">UINTEGER</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">16777216</code></td> </tr> </tbody> </table> <p>The <code class="language-plaintext highlighter-rouge">format</code> parameter specifies how to read the JSON from a file. With <code class="language-plaintext highlighter-rouge">'unstructured'</code>, the top-level JSON is read, e.g.:</p> <pre class="language-json highlighter-rouge" data-language="json">{
  "duck": 42
}
{
  "goose": [1, 2, 3]
}</pre> <p>will result in two objects being read.</p> <p>With <code class="language-plaintext highlighter-rouge">'newline_delimited'</code>, <a href="http://ndjson.org">NDJSON</a> is read, where each JSON is separated by a newline (<code class="language-plaintext highlighter-rouge">\n</code>), e.g.:</p> <pre class="language-json highlighter-rouge" data-language="json">{"duck": 42}
{"goose": [1, 2, 3]}</pre> <p>will also result in two objects being read.</p> <p>With <code class="language-plaintext highlighter-rouge">'array'</code>, each array element is read, e.g.:</p> <pre class="language-json highlighter-rouge" data-language="json">[
    {
        "duck": 42
    },
    {
        "goose": [1, 2, 3]
    }
]</pre> <p>Again, will result in two objects being read.</p> <p>Example usage:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT * FROM read_json_objects('my_file1.json');</pre> <pre class="language-text highlighter-rouge" data-language="text">{"duck":42,"goose":[1,2,3]}</pre> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT * FROM read_json_objects(['my_file1.json', 'my_file2.json']);</pre> <pre class="language-text highlighter-rouge" data-language="text">{"duck":42,"goose":[1,2,3]}
{"duck":43,"goose":[4,5,6],"swan":3.3}</pre> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT * FROM read_ndjson_objects('*.json.gz');</pre> <pre class="language-text highlighter-rouge" data-language="text">{"duck":42,"goose":[1,2,3]}
{"duck":43,"goose":[4,5,6],"swan":3.3}</pre> <p>DuckDB also supports reading JSON as a table, using the following functions:</p> <table> <thead> <tr> <th style="text-align: left">Function</th> <th style="text-align: left">Description</th> </tr> </thead> <tbody> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">read_json(filename)</code></td> <td style="text-align: left">Read JSON from <code class="language-plaintext highlighter-rouge">filename</code>, where <code class="language-plaintext highlighter-rouge">filename</code> can also be a list of files, or a glob pattern.</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">read_json_auto(filename)</code></td> <td style="text-align: left">Alias for <code class="language-plaintext highlighter-rouge">read_json</code> with all auto-detection enabled.</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">read_ndjson(filename)</code></td> <td style="text-align: left">Alias for <code class="language-plaintext highlighter-rouge">read_json</code> with parameter <code class="language-plaintext highlighter-rouge">format</code> set to <code class="language-plaintext highlighter-rouge">'newline_delimited'</code>.</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">read_ndjson_auto(filename)</code></td> <td style="text-align: left">Alias for <code class="language-plaintext highlighter-rouge">read_json_auto</code> with parameter <code class="language-plaintext highlighter-rouge">format</code> set to <code class="language-plaintext highlighter-rouge">'newline_delimited'</code>.</td> </tr> </tbody> </table> <p>Besides the <code class="language-plaintext highlighter-rouge">maximum_object_size</code>, <code class="language-plaintext highlighter-rouge">format</code>, <code class="language-plaintext highlighter-rouge">ignore_errors</code> and <code class="language-plaintext highlighter-rouge">compression</code>, these functions have additional parameters:</p> <table> <thead> <tr> <th style="text-align: left">Name</th> <th style="text-align: left">Description</th> <th style="text-align: left">Type</th> <th style="text-align: left">Default</th> </tr> </thead> <tbody> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">auto_detect</code></td> <td style="text-align: left">Whether to auto-detect the names of the keys and data types of the values automatically</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">BOOL</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">false</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">columns</code></td> <td style="text-align: left">A struct that specifies the key names and value types contained within the JSON file (e.g., <code class="language-plaintext highlighter-rouge">{key1: 'INTEGER', key2: 'VARCHAR'}</code>). If <code class="language-plaintext highlighter-rouge">auto_detect</code> is enabled these will be inferred</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">STRUCT</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">(empty)</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">dateformat</code></td> <td style="text-align: left">Specifies the date format to use when parsing dates. See <a href="../../sql/functions/dateformat.html">Date Format</a>
</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">VARCHAR</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">'iso'</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">maximum_depth</code></td> <td style="text-align: left">Maximum nesting depth to which the automatic schema detection detects types. Set to -1 to fully detect nested JSON types</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">BIGINT</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">-1</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">records</code></td> <td style="text-align: left">Can be one of <code class="language-plaintext highlighter-rouge">['auto', 'true', 'false']</code>
</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">VARCHAR</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">'records'</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">sample_size</code></td> <td style="text-align: left">Option to define number of sample objects for automatic JSON type detection. Set to -1 to scan the entire input file</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">UBIGINT</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">20480</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">timestampformat</code></td> <td style="text-align: left">Specifies the date format to use when parsing timestamps. See <a href="../../sql/functions/dateformat.html">Date Format</a>
</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">VARCHAR</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">'iso'</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">union_by_name</code></td> <td style="text-align: left">Whether the schema's of multiple JSON files should be <a href="../multiple_files/combining_schemas.html">unified</a>
</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">BOOL</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">false</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">map_inference_threshold</code></td> <td style="text-align: left">Controls the threshold for number of columns whose schema will be auto-detected; if JSON schema auto-detection would infer a <code class="language-plaintext highlighter-rouge">STRUCT</code> type for a field that has <em>more</em> than this threshold number of subfields, it infers a <code class="language-plaintext highlighter-rouge">MAP</code> type instead. Set to -1 to disable <code class="language-plaintext highlighter-rouge">MAP</code> inference.</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">BIGINT</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">24</code></td> </tr> </tbody> </table> <p>Example usage:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT * FROM read_json('my_file1.json', columns = {duck: 'INTEGER'});</pre>  <table> <thead> <tr> <th style="text-align: left">duck</th> </tr> </thead> <tbody> <tr> <td style="text-align: left">42</td> </tr> </tbody> </table> <p>DuckDB can convert JSON arrays directly to its internal <code class="language-plaintext highlighter-rouge">LIST</code> type, and missing keys become <code class="language-plaintext highlighter-rouge">NULL</code>:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT *
FROM read_json(
        ['my_file1.json', 'my_file2.json'],
        columns = {duck: 'INTEGER', goose: 'INTEGER[]', swan: 'DOUBLE'}
    );</pre>  <table> <thead> <tr> <th style="text-align: left">duck</th> <th style="text-align: left">goose</th> <th style="text-align: left">swan</th> </tr> </thead> <tbody> <tr> <td style="text-align: left">42</td> <td style="text-align: left">[1, 2, 3]</td> <td style="text-align: left">NULL</td> </tr> <tr> <td style="text-align: left">43</td> <td style="text-align: left">[4, 5, 6]</td> <td style="text-align: left">3.3</td> </tr> </tbody> </table> <p>DuckDB can automatically detect the types like so:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT goose, duck FROM read_json('*.json.gz');
SELECT goose, duck FROM '*.json.gz'; -- equivalent</pre>  <table> <thead> <tr> <th style="text-align: left">goose</th> <th style="text-align: left">duck</th> </tr> </thead> <tbody> <tr> <td style="text-align: left">[1, 2, 3]</td> <td style="text-align: left">42</td> </tr> <tr> <td style="text-align: left">[4, 5, 6]</td> <td style="text-align: left">43</td> </tr> </tbody> </table> <p>DuckDB can read (and auto-detect) a variety of formats, specified with the <code class="language-plaintext highlighter-rouge">format</code> parameter. Querying a JSON file that contains an <code class="language-plaintext highlighter-rouge">'array'</code>, e.g.:</p> <pre class="language-json highlighter-rouge" data-language="json">[
  {
    "duck": 42,
    "goose": 4.2
  },
  {
    "duck": 43,
    "goose": 4.3
  }
]</pre> <p>Can be queried exactly the same as a JSON file that contains <code class="language-plaintext highlighter-rouge">'unstructured'</code> JSON, e.g.:</p> <pre class="language-json highlighter-rouge" data-language="json">{
    "duck": 42,
    "goose": 4.2
}
{
    "duck": 43,
    "goose": 4.3
}</pre> <p>Both can be read as the table:</p>  <table> <thead> <tr> <th style="text-align: left">duck</th> <th style="text-align: left">goose</th> </tr> </thead> <tbody> <tr> <td style="text-align: left">42</td> <td style="text-align: left">4.2</td> </tr> <tr> <td style="text-align: left">43</td> <td style="text-align: left">4.3</td> </tr> </tbody> </table> <p>If your JSON file does not contain 'records', i.e., any other type of JSON than objects, DuckDB can still read it. This is specified with the <code class="language-plaintext highlighter-rouge">records</code> parameter. The <code class="language-plaintext highlighter-rouge">records</code> parameter specifies whether the JSON contains records that should be unpacked into individual columns, i.e., reading the following file with <code class="language-plaintext highlighter-rouge">records</code>:</p> <pre class="language-json highlighter-rouge" data-language="json">{"duck": 42, "goose": [1, 2, 3]}
{"duck": 43, "goose": [4, 5, 6]}</pre> <p>Results in two columns:</p>  <table> <thead> <tr> <th style="text-align: left">duck</th> <th style="text-align: left">goose</th> </tr> </thead> <tbody> <tr> <td style="text-align: left">42</td> <td style="text-align: left">[1,2,3]</td> </tr> <tr> <td style="text-align: left">42</td> <td style="text-align: left">[4,5,6]</td> </tr> </tbody> </table> <p>You can read the same file with <code class="language-plaintext highlighter-rouge">records</code> set to <code class="language-plaintext highlighter-rouge">'false'</code>, to get a single column, which is a <code class="language-plaintext highlighter-rouge">STRUCT</code> containing the data:</p>  <table> <thead> <tr> <th style="text-align: left">json</th> </tr> </thead> <tbody> <tr> <td style="text-align: left">{'duck': 42, 'goose': [1,2,3]}</td> </tr> <tr> <td style="text-align: left">{'duck': 43, 'goose': [4,5,6]}</td> </tr> </tbody> </table> <p>For additional examples reading more complex data, please see the <a href="http://localhost:8000/2023/03/03/json.html">“Shredding Deeply Nested JSON, One Vector at a Time” blog post</a>.</p> <h2 id="format-json"> <a style="text-decoration: none;" href="#format-json"><code class="language-plaintext highlighter-rouge">FORMAT JSON</code></a> </h2> <p>When the <code class="language-plaintext highlighter-rouge">json</code> extension is installed, <code class="language-plaintext highlighter-rouge">FORMAT JSON</code> is supported for <code class="language-plaintext highlighter-rouge">COPY FROM</code>, <code class="language-plaintext highlighter-rouge">COPY TO</code>, <code class="language-plaintext highlighter-rouge">EXPORT DATABASE</code> and <code class="language-plaintext highlighter-rouge">IMPORT DATABASE</code>. See the <a href="../../sql/statements/copy.html"><code class="language-plaintext highlighter-rouge">COPY</code> statement</a> and the <a href="../../sql/statements/export.html"><code class="language-plaintext highlighter-rouge">IMPORT</code> / <code class="language-plaintext highlighter-rouge">EXPORT</code> clauses</a>.</p> <p>By default, <code class="language-plaintext highlighter-rouge">COPY</code> expects newline-delimited JSON. If you prefer copying data to/from a JSON array, you can specify <code class="language-plaintext highlighter-rouge">ARRAY true</code>, e.g.,</p> <pre class="language-sql highlighter-rouge" data-language="sql">COPY (SELECT * FROM range(5)) TO 'my.json' (ARRAY true);</pre> <p>will create the following file:</p> <pre class="language-json highlighter-rouge" data-language="json">[
    {"range":0},
    {"range":1},
    {"range":2},
    {"range":3},
    {"range":4}
]</pre> <p>This can be read like so:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE test (range BIGINT);
COPY test FROM 'my.json' (ARRAY true);</pre> <p>The format can be detected automatically the format like so:</p> <pre class="language-sql highlighter-rouge" data-language="sql">COPY test FROM 'my.json' (AUTO_DETECT true);</pre> <h2 id="copy-statement"> <a style="text-decoration: none;" href="#copy-statement"><code class="language-plaintext highlighter-rouge">COPY</code> Statement</a> </h2> <p>The <code class="language-plaintext highlighter-rouge">COPY</code> statement can be used to load data from a JSON file into a table. For the <code class="language-plaintext highlighter-rouge">COPY</code> statement, we must first create a table with the correct schema to load the data into. We then specify the JSON file to load from plus any configuration options separately.</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE todos (userId UBIGINT, id UBIGINT, title VARCHAR, completed BOOLEAN);
COPY todos FROM 'todos.json';
SELECT * FROM todos LIMIT 5;</pre> <table> <thead> <tr> <th>userId</th> <th>id</th> <th>title</th> <th>completed</th> </tr> </thead> <tbody> <tr> <td>1</td> <td>1</td> <td>delectus aut autem</td> <td>false</td> </tr> <tr> <td>1</td> <td>2</td> <td>quis ut nam facilis et officia qui</td> <td>false</td> </tr> <tr> <td>1</td> <td>3</td> <td>fugiat veniam minus</td> <td>false</td> </tr> <tr> <td>1</td> <td>4</td> <td>et porro tempora</td> <td>true</td> </tr> <tr> <td>1</td> <td>5</td> <td>laboriosam mollitia et enim quasi adipisci quia provident illum</td> <td>false</td> </tr> </tbody> </table> <p>For more details, see the <a href="../../sql/statements/copy.html">page on the <code class="language-plaintext highlighter-rouge">COPY</code> statement</a>.</p> <h2 id="parameters"> <a style="text-decoration: none;" href="#parameters">Parameters</a> </h2> <table> <thead> <tr> <th style="text-align: left">Name</th> <th style="text-align: left">Description</th> <th style="text-align: left">Type</th> <th style="text-align: left">Default</th> </tr> </thead> <tbody> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">auto_detect</code></td> <td style="text-align: left">Whether to auto-detect detect the names of the keys and data types of the values automatically</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">BOOL</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">false</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">columns</code></td> <td style="text-align: left">A struct that specifies the key names and value types contained within the JSON file (e.g., <code class="language-plaintext highlighter-rouge">{key1: 'INTEGER', key2: 'VARCHAR'}</code>). If <code class="language-plaintext highlighter-rouge">auto_detect</code> is enabled these will be inferred</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">STRUCT</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">(empty)</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">compression</code></td> <td style="text-align: left">The compression type for the file. By default this will be detected automatically from the file extension (e.g., <code class="language-plaintext highlighter-rouge">t.json.gz</code> will use gzip, <code class="language-plaintext highlighter-rouge">t.json</code> will use none). Options are <code class="language-plaintext highlighter-rouge">'uncompressed'</code>, <code class="language-plaintext highlighter-rouge">'gzip'</code>, <code class="language-plaintext highlighter-rouge">'zstd'</code>, and <code class="language-plaintext highlighter-rouge">'auto_detect'</code>.</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">VARCHAR</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">'auto_detect'</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">convert_strings_to_integers</code></td> <td style="text-align: left">Whether strings representing integer values should be converted to a numerical type.</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">BOOL</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">false</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">dateformat</code></td> <td style="text-align: left">Specifies the date format to use when parsing dates. See <a href="../../sql/functions/dateformat.html">Date Format</a>
</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">VARCHAR</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">'iso'</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">filename</code></td> <td style="text-align: left">Whether or not an extra <code class="language-plaintext highlighter-rouge">filename</code> column should be included in the result.</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">BOOL</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">false</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">format</code></td> <td style="text-align: left">Can be one of <code class="language-plaintext highlighter-rouge">['auto', 'unstructured', 'newline_delimited', 'array']</code>
</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">VARCHAR</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">'array'</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">hive_partitioning</code></td> <td style="text-align: left">Whether or not to interpret the path as a <a href="../partitioning/hive_partitioning.html">Hive partitioned path</a>.</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">BOOL</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">false</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">ignore_errors</code></td> <td style="text-align: left">Whether to ignore parse errors (only possible when <code class="language-plaintext highlighter-rouge">format</code> is <code class="language-plaintext highlighter-rouge">'newline_delimited'</code>)</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">BOOL</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">false</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">maximum_depth</code></td> <td style="text-align: left">Maximum nesting depth to which the automatic schema detection detects types. Set to -1 to fully detect nested JSON types</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">BIGINT</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">-1</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">maximum_object_size</code></td> <td style="text-align: left">The maximum size of a JSON object (in bytes)</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">UINTEGER</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">16777216</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">records</code></td> <td style="text-align: left">Can be one of <code class="language-plaintext highlighter-rouge">['auto', 'true', 'false']</code>
</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">VARCHAR</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">'records'</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">sample_size</code></td> <td style="text-align: left">Option to define number of sample objects for automatic JSON type detection. Set to -1 to scan the entire input file</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">UBIGINT</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">20480</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">timestampformat</code></td> <td style="text-align: left">Specifies the date format to use when parsing timestamps. See <a href="../../sql/functions/dateformat.html">Date Format</a>
</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">VARCHAR</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">'iso'</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">union_by_name</code></td> <td style="text-align: left">Whether the schema's of multiple JSON files should be <a href="../multiple_files/combining_schemas.html">unified</a>.</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">BOOL</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">false</code></td> </tr> </tbody> </table> <h2 id="the-read_json-function"> <a style="text-decoration: none;" href="#the-read_json-function">The <code class="language-plaintext highlighter-rouge">read_json</code> Function</a> </h2> <p>The <code class="language-plaintext highlighter-rouge">read_json</code> is the simplest method of loading JSON files: it automatically attempts to figure out the correct configuration of the JSON reader. It also automatically deduces types of columns.</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT *
FROM read_json('todos.json')
LIMIT 5;</pre> <table> <thead> <tr> <th style="text-align: right">userId</th> <th style="text-align: right">id</th> <th>title</th> <th>completed</th> </tr> </thead> <tbody> <tr> <td style="text-align: right">1</td> <td style="text-align: right">1</td> <td>delectus aut autem</td> <td>false</td> </tr> <tr> <td style="text-align: right">1</td> <td style="text-align: right">2</td> <td>quis ut nam facilis et officia qui</td> <td>false</td> </tr> <tr> <td style="text-align: right">1</td> <td style="text-align: right">3</td> <td>fugiat veniam minus</td> <td>false</td> </tr> <tr> <td style="text-align: right">1</td> <td style="text-align: right">4</td> <td>et porro tempora</td> <td>true</td> </tr> <tr> <td style="text-align: right">1</td> <td style="text-align: right">5</td> <td>laboriosam mollitia et enim quasi adipisci quia provident illum</td> <td>false</td> </tr> </tbody> </table> <p>The path can either be a relative path (relative to the current working directory) or an absolute path.</p> <p>We can use <code class="language-plaintext highlighter-rouge">read_json</code> to create a persistent table as well:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE todos AS
    SELECT *
    FROM read_json('todos.json');
DESCRIBE todos;</pre>  <table> <thead> <tr> <th>column_name</th> <th>column_type</th> <th>null</th> <th>key</th> <th>default</th> <th>extra</th> </tr> </thead> <tbody> <tr> <td>userId</td> <td>UBIGINT</td> <td>YES</td> <td> </td> <td> </td> <td> </td> </tr> <tr> <td>id</td> <td>UBIGINT</td> <td>YES</td> <td> </td> <td> </td> <td> </td> </tr> <tr> <td>title</td> <td>VARCHAR</td> <td>YES</td> <td> </td> <td> </td> <td> </td> </tr> <tr> <td>completed</td> <td>BOOLEAN</td> <td>YES</td> <td> </td> <td> </td> <td> </td> </tr> </tbody> </table> <p>If we specify the columns, we can bypass the automatic detection. Note that not all columns need to be specified:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT *
FROM read_json('todos.json',
               columns = {userId: 'UBIGINT',
                          completed: 'BOOLEAN'});</pre> <p>Multiple files can be read at once by providing a glob or a list of files. Refer to the <a href="../multiple_files/overview.html">multiple files section</a> for more information.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; Copyright 2018&ndash;2024 Stichting DuckDB Foundation<br>Licensed under the MIT License.<br>
    <a href="https://duckdb.org/docs/data/json/loading_json.html" class="_attribution-link">https://duckdb.org/docs/data/json/loading_json.html</a>
  </p>
</div>
