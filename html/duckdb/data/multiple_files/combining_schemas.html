<h1 class="title">Combining Schemas</h1>   <h2 id="examples"> <a style="text-decoration: none;" href="#examples">Examples</a> </h2> <p>Read a set of CSV files combining columns by position:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT * FROM read_csv('flights*.csv');</pre> <p>Read a set of CSV files combining columns by name:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT * FROM read_csv('flights*.csv', union_by_name = true);</pre> <h2 id="combining-schemas"> <a style="text-decoration: none;" href="#combining-schemas">Combining Schemas</a> </h2> <p>When reading from multiple files, we have to <strong>combine schemas</strong> from those files. That is because each file has its own schema that can differ from the other files. DuckDB offers two ways of unifying schemas of multiple files: <strong>by column position</strong> and <strong>by column name</strong>.</p> <p>By default, DuckDB reads the schema of the first file provided, and then unifies columns in subsequent files by column position. This works correctly as long as all files have the same schema. If the schema of the files differs, you might want to use the <code class="language-plaintext highlighter-rouge">union_by_name</code> option to allow DuckDB to construct the schema by reading all of the names instead.</p> <p>Below is an example of how both methods work.</p> <h2 id="union-by-position"> <a style="text-decoration: none;" href="#union-by-position">Union by Position</a> </h2> <p>By default, DuckDB unifies the columns of these different files <strong>by position</strong>. This means that the first column in each file is combined together, as well as the second column in each file, etc. For example, consider the following two files.</p> <p><a href="http://localhost:8000/data/flights1.csv"><code class="language-plaintext highlighter-rouge">flights1.csv</code></a>:</p> <pre><code class="language-csv">FlightDate|UniqueCarrier|OriginCityName|DestCityName
1988-01-01|AA|New York, NY|Los Angeles, CA
1988-01-02|AA|New York, NY|Los Angeles, CA
</code></pre> <p><a href="http://localhost:8000/data/flights2.csv"><code class="language-plaintext highlighter-rouge">flights2.csv</code></a>:</p> <pre><code class="language-csv">FlightDate|UniqueCarrier|OriginCityName|DestCityName
1988-01-03|AA|New York, NY|Los Angeles, CA
</code></pre> <p>Reading the two files at the same time will produce the following result set:</p>  <table> <thead> <tr> <th>FlightDate</th> <th>UniqueCarrier</th> <th>OriginCityName</th> <th>DestCityName</th> </tr> </thead> <tbody> <tr> <td>1988-01-01</td> <td>AA</td> <td>New York, NY</td> <td>Los Angeles, CA</td> </tr> <tr> <td>1988-01-02</td> <td>AA</td> <td>New York, NY</td> <td>Los Angeles, CA</td> </tr> <tr> <td>1988-01-03</td> <td>AA</td> <td>New York, NY</td> <td>Los Angeles, CA</td> </tr> </tbody> </table> <p>This is equivalent to the SQL construct <a href="../../sql/query_syntax/setops.html#union-all.html"><code class="language-plaintext highlighter-rouge">UNION ALL</code></a>.</p> <h2 id="union-by-name"> <a style="text-decoration: none;" href="#union-by-name">Union by Name</a> </h2> <p>If you are processing multiple files that have different schemas, perhaps because columns have been added or renamed, it might be desirable to unify the columns of different files <strong>by name</strong> instead. This can be done by providing the <code class="language-plaintext highlighter-rouge">union_by_name</code> option. For example, consider the following two files, where <code class="language-plaintext highlighter-rouge">flights4.csv</code> has an extra column (<code class="language-plaintext highlighter-rouge">UniqueCarrier</code>).</p> <p><a href="http://localhost:8000/data/flights3.csv"><code class="language-plaintext highlighter-rouge">flights3.csv</code></a>:</p> <pre><code class="language-csv">FlightDate|OriginCityName|DestCityName
1988-01-01|New York, NY|Los Angeles, CA
1988-01-02|New York, NY|Los Angeles, CA
</code></pre> <p><a href="http://localhost:8000/data/flights4.csv"><code class="language-plaintext highlighter-rouge">flights4.csv</code></a>:</p> <pre><code class="language-csv">FlightDate|UniqueCarrier|OriginCityName|DestCityName
1988-01-03|AA|New York, NY|Los Angeles, CA
</code></pre> <p>Reading these when unifying column names <strong>by position</strong> results in an error â€“ as the two files have a different number of columns. When specifying the <code class="language-plaintext highlighter-rouge">union_by_name</code> option, the columns are correctly unified, and any missing values are set to <code class="language-plaintext highlighter-rouge">NULL</code>.</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT * FROM read_csv(['flights3.csv', 'flights4.csv'], union_by_name = true);</pre>  <table> <thead> <tr> <th>FlightDate</th> <th>OriginCityName</th> <th>DestCityName</th> <th>UniqueCarrier</th> </tr> </thead> <tbody> <tr> <td>1988-01-01</td> <td>New York, NY</td> <td>Los Angeles, CA</td> <td>NULL</td> </tr> <tr> <td>1988-01-02</td> <td>New York, NY</td> <td>Los Angeles, CA</td> <td>NULL</td> </tr> <tr> <td>1988-01-03</td> <td>New York, NY</td> <td>Los Angeles, CA</td> <td>AA</td> </tr> </tbody> </table> <p>This is equivalent to the SQL construct <a href="../../sql/query_syntax/setops.html#union-all-by-name.html"><code class="language-plaintext highlighter-rouge">UNION ALL BY NAME</code></a>.</p> <blockquote> <p>Using the <code class="language-plaintext highlighter-rouge">union_by_name</code> option increases memory consumption.</p> </blockquote><div class="_attribution">
  <p class="_attribution-p">
    &copy; Copyright 2018&ndash;2024 Stichting DuckDB Foundation<br>Licensed under the MIT License.<br>
    <a href="https://duckdb.org/docs/data/multiple_files/combining_schemas.html" class="_attribution-link">https://duckdb.org/docs/data/multiple_files/combining_schemas.html</a>
  </p>
</div>
