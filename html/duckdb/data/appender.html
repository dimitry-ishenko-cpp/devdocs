<h1 class="title">Appender</h1>  <p>The Appender can be used to load bulk data into a DuckDB database. It is currently available in the <a href="#appender-support-in-other-clients">C, C++, Go, Java, and Rust APIs</a>. The Appender is tied to a connection, and will use the transaction context of that connection when appending. An Appender always appends to a single table in the database file.</p> <p>In the <a href="../api/cpp.html">C++ API</a>, the Appender works as follows:</p> <pre class="language-cpp highlighter-rouge" data-language="cpp">DuckDB db;
Connection con(db);
// create the table
con.Query("CREATE TABLE people (id INTEGER, name VARCHAR)");
// initialize the appender
Appender appender(con, "people");</pre> <p>The <code class="language-plaintext highlighter-rouge">AppendRow</code> function is the easiest way of appending data. It uses recursive templates to allow you to put all the values of a single row within one function call, as follows:</p> <pre class="language-cpp highlighter-rouge" data-language="cpp">appender.AppendRow(1, "Mark");</pre> <p>Rows can also be individually constructed using the <code class="language-plaintext highlighter-rouge">BeginRow</code>, <code class="language-plaintext highlighter-rouge">EndRow</code> and <code class="language-plaintext highlighter-rouge">Append</code> methods. This is done internally by <code class="language-plaintext highlighter-rouge">AppendRow</code>, and hence has the same performance characteristics.</p> <pre class="language-cpp highlighter-rouge" data-language="cpp">appender.BeginRow();
appender.Append&lt;int32_t&gt;(2);
appender.Append&lt;string&gt;("Hannes");
appender.EndRow();</pre> <p>Any values added to the Appender are cached prior to being inserted into the database system for performance reasons. That means that, while appending, the rows might not be immediately visible in the system. The cache is automatically flushed when the Appender goes out of scope or when <code class="language-plaintext highlighter-rouge">appender.Close()</code> is called. The cache can also be manually flushed using the <code class="language-plaintext highlighter-rouge">appender.Flush()</code> method. After either <code class="language-plaintext highlighter-rouge">Flush</code> or <code class="language-plaintext highlighter-rouge">Close</code> is called, all the data has been written to the database system.</p> <h2 id="date-time-and-timestamps"> <a style="text-decoration: none;" href="#date-time-and-timestamps">Date, Time and Timestamps</a> </h2> <p>While numbers and strings are rather self-explanatory, dates, times and timestamps require some explanation. They can be directly appended using the methods provided by <code class="language-plaintext highlighter-rouge">duckdb::Date</code>, <code class="language-plaintext highlighter-rouge">duckdb::Time</code> or <code class="language-plaintext highlighter-rouge">duckdb::Timestamp</code>. They can also be appended using the internal <code class="language-plaintext highlighter-rouge">duckdb::Value</code> type, however, this adds some additional overheads and should be avoided if possible.</p> <p>Below is a short example:</p> <pre class="language-cpp highlighter-rouge" data-language="cpp">con.Query("CREATE TABLE dates (d DATE, t TIME, ts TIMESTAMP)");
Appender appender(con, "dates");

// construct the values using the Date/Time/Timestamp types
// (this is the most efficient approach)
appender.AppendRow(
    Date::FromDate(1992, 1, 1),
    Time::FromTime(1, 1, 1, 0),
    Timestamp::FromDatetime(Date::FromDate(1992, 1, 1), Time::FromTime(1, 1, 1, 0))
);
// construct duckdb::Value objects
appender.AppendRow(
    Value::DATE(1992, 1, 1),
    Value::TIME(1, 1, 1, 0),
    Value::TIMESTAMP(1992, 1, 1, 1, 1, 1, 0)
);</pre> <h2 id="commit-frequency"> <a style="text-decoration: none;" href="#commit-frequency">Commit Frequency</a> </h2> <p>By default, the appender performs a commits every 204,800 rows. You can change this by explicitly using <a href="../sql/statements/transactions.html">transactions</a> and surrounding your batches of <code class="language-plaintext highlighter-rouge">AppendRow</code> calls by <code class="language-plaintext highlighter-rouge">BEGIN TRANSACTION</code> and <code class="language-plaintext highlighter-rouge">COMMIT</code> statements.</p> <h2 id="handling-constraint-violations"> <a style="text-decoration: none;" href="#handling-constraint-violations">Handling Constraint Violations</a> </h2> <p>If the Appender encounters a <code class="language-plaintext highlighter-rouge">PRIMARY KEY</code> conflict or a <code class="language-plaintext highlighter-rouge">UNIQUE</code> constraint violation, it fails and returns the following error:</p> <pre class="language-console highlighter-rouge" data-language="console">Constraint Error: PRIMARY KEY or UNIQUE constraint violated: duplicate key "..."</pre> <p>In this case, the entire append operation fails and no rows are inserted.</p> <h2 id="appender-support-in-other-clients"> <a style="text-decoration: none;" href="#appender-support-in-other-clients">Appender Support in Other Clients</a> </h2> <p>The Appender is also available in the following client APIs:</p> <ul> <li><a href="../api/c/appender.html">C</a></li> <li><a href="../api/go.html#appender.html">Go</a></li> <li><a href="../api/julia.html#appender-api.html">Julia</a></li> <li><a href="../api/java.html#appender.html">JDBC (Java)</a></li> <li><a href="../api/rust.html#appender.html">Rust</a></li> </ul><div class="_attribution">
  <p class="_attribution-p">
    &copy; Copyright 2018&ndash;2024 Stichting DuckDB Foundation<br>Licensed under the MIT License.<br>
    <a href="https://duckdb.org/docs/data/appender.html" class="_attribution-link">https://duckdb.org/docs/data/appender.html</a>
  </p>
</div>
