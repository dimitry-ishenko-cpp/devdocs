<h1 class="title">CSV Import</h1>  <h2 id="examples"> <a style="text-decoration: none;" href="#examples">Examples</a> </h2> <p>The following examples use the <a href="http://localhost:8000/data/flights.csv"><code class="language-plaintext highlighter-rouge">flights.csv</code></a> file.</p> <p>Read a CSV file from disk, auto-infer options:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT * FROM 'flights.csv';</pre> <p>Use the <code class="language-plaintext highlighter-rouge">read_csv</code> function with custom options:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT *
FROM read_csv('flights.csv',
    delim = '|',
    header = true,
    columns = {
        'FlightDate': 'DATE',
        'UniqueCarrier': 'VARCHAR',
        'OriginCityName': 'VARCHAR',
        'DestCityName': 'VARCHAR'
    });</pre> <p>Read a CSV from stdin, auto-infer options:</p> <pre class="language-bash highlighter-rouge" data-language="bash">cat flights.csv | duckdb -c "SELECT * FROM read_csv('/dev/stdin')"</pre> <p>Read a CSV file into a table:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE ontime (
    FlightDate DATE,
    UniqueCarrier VARCHAR,
    OriginCityName VARCHAR,
    DestCityName VARCHAR
);
COPY ontime FROM 'flights.csv';</pre> <p>Alternatively, create a table without specifying the schema manually using a <a href="../../sql/statements/create_table.html#create-table--as-select-ctas.html"><code class="language-plaintext highlighter-rouge">CREATE TABLE .. AS SELECT</code> statement</a>:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE ontime AS
    SELECT * FROM 'flights.csv';</pre> <p>We can use the <a href="../../sql/query_syntax/from.html#from-first-syntax.html"><code class="language-plaintext highlighter-rouge">FROM</code>-first syntax</a> to omit <code class="language-plaintext highlighter-rouge">SELECT *</code>.</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE ontime AS
    FROM 'flights.csv';</pre> <p>Write the result of a query to a CSV file.</p> <pre class="language-sql highlighter-rouge" data-language="sql">COPY (SELECT * FROM ontime) TO 'flights.csv' WITH (HEADER, DELIMITER '|');</pre> <p>If we serialize the entire table, we can simply refer to it with its name.</p> <pre class="language-sql highlighter-rouge" data-language="sql">COPY ontime TO 'flights.csv' WITH (HEADER, DELIMITER '|');</pre> <h2 id="csv-loading"> <a style="text-decoration: none;" href="#csv-loading">CSV Loading</a> </h2> <p>CSV loading, i.e., importing CSV files to the database, is a very common, and yet surprisingly tricky, task. While CSVs seem simple on the surface, there are a lot of inconsistencies found within CSV files that can make loading them a challenge. CSV files come in many different varieties, are often corrupt, and do not have a schema. The CSV reader needs to cope with all of these different situations.</p> <p>The DuckDB CSV reader can automatically infer which configuration flags to use by analyzing the CSV file using the <a href="http://localhost:8000/2023/10/27/csv-sniffer.html">CSV sniffer</a>. This will work correctly in most situations, and should be the first option attempted. In rare situations where the CSV reader cannot figure out the correct configuration it is possible to manually configure the CSV reader to correctly parse the CSV file. See the <a href="auto_detection.html">auto detection page</a> for more information.</p> <h2 id="parameters"> <a style="text-decoration: none;" href="#parameters">Parameters</a> </h2> <p>Below are parameters that can be passed to the CSV reader. These parameters are accepted by the <a href="#csv-functions"><code class="language-plaintext highlighter-rouge">read_csv</code> function</a>. But not all parameters are accepted by the <a href="../../sql/statements/copy.html#copy-to.html"><code class="language-plaintext highlighter-rouge">COPY</code> statement</a>.</p> <table> <thead> <tr> <th style="text-align: left">Name</th> <th style="text-align: left">Description</th> <th style="text-align: left">Type</th> <th style="text-align: left">Default</th> </tr> </thead> <tbody> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">all_varchar</code></td> <td style="text-align: left">Option to skip type detection for CSV parsing and assume all columns to be of type <code class="language-plaintext highlighter-rouge">VARCHAR</code>. This option is only supported by the <code class="language-plaintext highlighter-rouge">read_csv</code> function.</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">BOOL</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">false</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">allow_quoted_nulls</code></td> <td style="text-align: left">Option to allow the conversion of quoted values to <code class="language-plaintext highlighter-rouge">NULL</code> values</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">BOOL</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">true</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">auto_detect</code></td> <td style="text-align: left">Enables <a href="auto_detection.html">auto detection of CSV parameters</a>.</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">BOOL</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">true</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">auto_type_candidates</code></td> <td style="text-align: left">This option allows you to specify the types that the sniffer will use when detecting CSV column types. The <code class="language-plaintext highlighter-rouge">VARCHAR</code> type is always included in the detected types (as a fallback option). See <a href="#auto_type_candidates-details">example</a>.</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">TYPE[]</code></td> <td style="text-align: left"><a href="#auto_type_candidates-details">default types</a></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">columns</code></td> <td style="text-align: left">A struct that specifies the column names and column types contained within the CSV file (e.g., <code class="language-plaintext highlighter-rouge">{'col1': 'INTEGER', 'col2': 'VARCHAR'}</code>). Using this option implies that auto detection is not used.</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">STRUCT</code></td> <td style="text-align: left">(empty)</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">compression</code></td> <td style="text-align: left">The compression type for the file. By default this will be detected automatically from the file extension (e.g., <code class="language-plaintext highlighter-rouge">t.csv.gz</code> will use gzip, <code class="language-plaintext highlighter-rouge">t.csv</code> will use <code class="language-plaintext highlighter-rouge">none</code>). Options are <code class="language-plaintext highlighter-rouge">none</code>, <code class="language-plaintext highlighter-rouge">gzip</code>, <code class="language-plaintext highlighter-rouge">zstd</code>.</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">VARCHAR</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">auto</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">dateformat</code></td> <td style="text-align: left">Specifies the date format to use when parsing dates. See <a href="../../sql/functions/dateformat.html">Date Format</a>.</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">VARCHAR</code></td> <td style="text-align: left">(empty)</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">decimal_separator</code></td> <td style="text-align: left">The decimal separator of numbers.</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">VARCHAR</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">.</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">delimiter</code></td> <td style="text-align: left">Specifies the delimiter character that separates columns within each row (line) of the file. Alias for <code class="language-plaintext highlighter-rouge">sep</code>. This option is only available in the <code class="language-plaintext highlighter-rouge">COPY</code> statement.</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">VARCHAR</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">,</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">delim</code></td> <td style="text-align: left">Specifies the delimiter character that separates columns within each row (line) of the file. Alias for <code class="language-plaintext highlighter-rouge">sep</code>.</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">VARCHAR</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">,</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">escape</code></td> <td style="text-align: left">Specifies the string that should appear before a data character sequence that matches the <code class="language-plaintext highlighter-rouge">quote</code> value.</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">VARCHAR</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">"</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">filename</code></td> <td style="text-align: left">Whether or not an extra <code class="language-plaintext highlighter-rouge">filename</code> column should be included in the result.</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">BOOL</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">false</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">force_not_null</code></td> <td style="text-align: left">Do not match the specified columns' values against the NULL string. In the default case where the <code class="language-plaintext highlighter-rouge">NULL</code> string is empty, this means that empty values will be read as zero-length strings rather than <code class="language-plaintext highlighter-rouge">NULL</code>s.</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">VARCHAR[]</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">[]</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">header</code></td> <td style="text-align: left">Specifies that the file contains a header line with the names of each column in the file.</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">BOOL</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">false</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">hive_partitioning</code></td> <td style="text-align: left">Whether or not to interpret the path as a <a href="../partitioning/hive_partitioning.html">Hive partitioned path</a>.</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">BOOL</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">false</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">ignore_errors</code></td> <td style="text-align: left">Option to ignore any parsing errors encountered â€“ and instead ignore rows with errors.</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">BOOL</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">false</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">max_line_size</code></td> <td style="text-align: left">The maximum line size in bytes.</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">BIGINT</code></td> <td style="text-align: left">2097152</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">names</code></td> <td style="text-align: left">The column names as a list, see <a href="tips.html#provide-names-if-the-file-does-not-contain-a-header.html">example</a>.</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">VARCHAR[]</code></td> <td style="text-align: left">(empty)</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">new_line</code></td> <td style="text-align: left">Set the new line character(s) in the file. Options are <code class="language-plaintext highlighter-rouge">'\r'</code>,<code class="language-plaintext highlighter-rouge">'\n'</code>, or <code class="language-plaintext highlighter-rouge">'\r\n'</code>. Note that the CSV parser only distinguishes between single-character and double-character line delimiters. Therefore, it does not differentiate between <code class="language-plaintext highlighter-rouge">'\r'</code> and <code class="language-plaintext highlighter-rouge">'\n'</code>.</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">VARCHAR</code></td> <td style="text-align: left">(empty)</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">normalize_names</code></td> <td style="text-align: left">Boolean value that specifies whether or not column names should be normalized, removing any non-alphanumeric characters from them.</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">BOOL</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">false</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">null_padding</code></td> <td style="text-align: left">If this option is enabled, when a row lacks columns, it will pad the remaining columns on the right with null values.</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">BOOL</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">false</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">nullstr</code></td> <td style="text-align: left">Specifies the string that represents a <code class="language-plaintext highlighter-rouge">NULL</code> value or (since v0.10.2) a list of strings that represent a <code class="language-plaintext highlighter-rouge">NULL</code> value.</td> <td style="text-align: left">
<code class="language-plaintext highlighter-rouge">VARCHAR</code> or <code class="language-plaintext highlighter-rouge">VARCHAR[]</code>
</td> <td style="text-align: left">(empty)</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">parallel</code></td> <td style="text-align: left">Whether or not the parallel CSV reader is used.</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">BOOL</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">true</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">quote</code></td> <td style="text-align: left">Specifies the quoting string to be used when a data value is quoted.</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">VARCHAR</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">"</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">sample_size</code></td> <td style="text-align: left">The number of sample rows for <a href="auto_detection.html">auto detection of parameters</a>.</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">BIGINT</code></td> <td style="text-align: left">20480</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">sep</code></td> <td style="text-align: left">Specifies the delimiter character that separates columns within each row (line) of the file. Alias for <code class="language-plaintext highlighter-rouge">delim</code>.</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">VARCHAR</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">,</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">skip</code></td> <td style="text-align: left">The number of lines at the top of the file to skip.</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">BIGINT</code></td> <td style="text-align: left">0</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">timestampformat</code></td> <td style="text-align: left">Specifies the date format to use when parsing timestamps. See <a href="../../sql/functions/dateformat.html">Date Format</a>.</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">VARCHAR</code></td> <td style="text-align: left">(empty)</td> </tr> <tr> <td style="text-align: left">
<code class="language-plaintext highlighter-rouge">types</code> or <code class="language-plaintext highlighter-rouge">dtypes</code>
</td> <td style="text-align: left">The column types as either a list (by position) or a struct (by name). <a href="tips.html#override-the-types-of-specific-columns.html">Example here</a>.</td> <td style="text-align: left">
<code class="language-plaintext highlighter-rouge">VARCHAR[]</code> or <code class="language-plaintext highlighter-rouge">STRUCT</code>
</td> <td style="text-align: left">(empty)</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">union_by_name</code></td> <td style="text-align: left">Whether the columns of multiple schemas should be <a href="../multiple_files/combining_schemas.html#union-by-name.html">unified by name</a>, rather than by position. Note that using this option increases memory consumption.</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">BOOL</code></td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">false</code></td> </tr> </tbody> </table> <h3 id="auto_type_candidates-details"> <a style="text-decoration: none;" href="#auto_type_candidates-details"><code class="language-plaintext highlighter-rouge">auto_type_candidates</code> Details</a> </h3> <p>The <code class="language-plaintext highlighter-rouge">auto_type_candidates</code> option lets you specify the data types that should be considered by the CSV reader for <a href="auto_detection.html#type-detection.html">column data type detection</a>. Usage example:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT * FROM read_csv('csv_file.csv', auto_type_candidates = ['BIGINT', 'DATE']);</pre> <p>The default value for the <code class="language-plaintext highlighter-rouge">auto_type_candidates</code> option is <code class="language-plaintext highlighter-rouge">['SQLNULL', 'BOOLEAN', 'BIGINT', 'DOUBLE', 'TIME', 'DATE', 'TIMESTAMP', 'VARCHAR']</code>.</p> <h2 id="csv-functions"> <a style="text-decoration: none;" href="#csv-functions">CSV Functions</a> </h2> <p>The <code class="language-plaintext highlighter-rouge">read_csv</code> automatically attempts to figure out the correct configuration of the CSV reader using the <a href="http://localhost:8000/2023/10/27/csv-sniffer.html">CSV sniffer</a>. It also automatically deduces types of columns. If the CSV file has a header, it will use the names found in that header to name the columns. Otherwise, the columns will be named <code class="language-plaintext highlighter-rouge">column0, column1, column2, ...</code>. An example with the <a href="http://localhost:8000/data/flights.csv"><code class="language-plaintext highlighter-rouge">flights.csv</code></a> file:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT * FROM read_csv('flights.csv');</pre>  <table> <thead> <tr> <th>FlightDate</th> <th>UniqueCarrier</th> <th>OriginCityName</th> <th>DestCityName</th> </tr> </thead> <tbody> <tr> <td>1988-01-01</td> <td>AA</td> <td>New York, NY</td> <td>Los Angeles, CA</td> </tr> <tr> <td>1988-01-02</td> <td>AA</td> <td>New York, NY</td> <td>Los Angeles, CA</td> </tr> <tr> <td>1988-01-03</td> <td>AA</td> <td>New York, NY</td> <td>Los Angeles, CA</td> </tr> </tbody> </table> <p>The path can either be a relative path (relative to the current working directory) or an absolute path.</p> <p>We can use <code class="language-plaintext highlighter-rouge">read_csv</code> to create a persistent table as well:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE ontime AS
    SELECT * FROM read_csv('flights.csv');
DESCRIBE ontime;</pre>  <table> <thead> <tr> <th>column_name</th> <th>column_type</th> <th>null</th> <th>key</th> <th>default</th> <th>extra</th> </tr> </thead> <tbody> <tr> <td>FlightDate</td> <td>DATE</td> <td>YES</td> <td>NULL</td> <td>NULL</td> <td>NULL</td> </tr> <tr> <td>UniqueCarrier</td> <td>VARCHAR</td> <td>YES</td> <td>NULL</td> <td>NULL</td> <td>NULL</td> </tr> <tr> <td>OriginCityName</td> <td>VARCHAR</td> <td>YES</td> <td>NULL</td> <td>NULL</td> <td>NULL</td> </tr> <tr> <td>DestCityName</td> <td>VARCHAR</td> <td>YES</td> <td>NULL</td> <td>NULL</td> <td>NULL</td> </tr> </tbody> </table> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT * FROM read_csv('flights.csv', sample_size = 20_000);</pre> <p>If we set <code class="language-plaintext highlighter-rouge">delim</code>/<code class="language-plaintext highlighter-rouge">sep</code>, <code class="language-plaintext highlighter-rouge">quote</code>, <code class="language-plaintext highlighter-rouge">escape</code>, or <code class="language-plaintext highlighter-rouge">header</code> explicitly, we can bypass the automatic detection of this particular parameter:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT * FROM read_csv('flights.csv', header = true);</pre> <p>Multiple files can be read at once by providing a glob or a list of files. Refer to the <a href="../multiple_files/overview.html">multiple files section</a> for more information.</p> <h2 id="writing-using-the-copy-statement"> <a style="text-decoration: none;" href="#writing-using-the-copy-statement">Writing Using the <code class="language-plaintext highlighter-rouge">COPY</code> Statement</a> </h2> <p>The <a href="../../sql/statements/copy.html#copy-to.html"><code class="language-plaintext highlighter-rouge">COPY</code> statement</a> can be used to load data from a CSV file into a table. This statement has the same syntax as the one used in PostgreSQL. To load the data using the <code class="language-plaintext highlighter-rouge">COPY</code> statement, we must first create a table with the correct schema (which matches the order of the columns in the CSV file and uses types that fit the values in the CSV file). <code class="language-plaintext highlighter-rouge">COPY</code> detects the CSV's configuration options automatically.</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE ontime (
    flightdate DATE,
    uniquecarrier VARCHAR,
    origincityname VARCHAR,
    destcityname VARCHAR
);
COPY ontime FROM 'flights.csv';
SELECT * FROM ontime;</pre>  <table> <thead> <tr> <th>flightdate</th> <th>uniquecarrier</th> <th>origincityname</th> <th>destcityname</th> </tr> </thead> <tbody> <tr> <td>1988-01-01</td> <td>AA</td> <td>New York, NY</td> <td>Los Angeles, CA</td> </tr> <tr> <td>1988-01-02</td> <td>AA</td> <td>New York, NY</td> <td>Los Angeles, CA</td> </tr> <tr> <td>1988-01-03</td> <td>AA</td> <td>New York, NY</td> <td>Los Angeles, CA</td> </tr> </tbody> </table> <p>If we want to manually specify the CSV format, we can do so using the configuration options of <code class="language-plaintext highlighter-rouge">COPY</code>.</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE ontime (flightdate DATE, uniquecarrier VARCHAR, origincityname VARCHAR, destcityname VARCHAR);
COPY ontime FROM 'flights.csv' (DELIMITER '|', HEADER);
SELECT * FROM ontime;</pre> <h2 id="reading-faulty-csv-files"> <a style="text-decoration: none;" href="#reading-faulty-csv-files">Reading Faulty CSV Files</a> </h2> <p>DuckDB supports reading erroneous CSV files. For details, see the <a href="reading_faulty_csv_files.html">Reading Faulty CSV Files page</a>.</p> <h2 id="limitations"> <a style="text-decoration: none;" href="#limitations">Limitations</a> </h2> <p>The CSV reader only supports input files using UTF-8 character encoding. For CSV files using different encodings, use e.g., the <a href="https://linux.die.net/man/1/iconv"><code class="language-plaintext highlighter-rouge">iconv</code> command-line tool</a> to convert them to UTF-8. For example:</p> <pre class="language-bash highlighter-rouge" data-language="bash">iconv -f ISO-8859-2 -t UTF-8 input.csv &gt; input-utf-8.csv</pre> <h2 id="order-preservation"> <a style="text-decoration: none;" href="#order-preservation">Order Preservation</a> </h2> <p>The CSV reader respects the <code class="language-plaintext highlighter-rouge">preserve_insertion_order</code> <a href="../../configuration/overview.html">configuration option</a>. When <code class="language-plaintext highlighter-rouge">true</code> (the default), the order of the rows in the resultset returned by the CSV reader is the same as the order of the corresponding lines read from the file(s). When <code class="language-plaintext highlighter-rouge">false</code>, there is no guarantee that the order is preserved.</p> <div> <h2 id="pages-in-this-section">Pages in This Section</h2> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; Copyright 2018&ndash;2024 Stichting DuckDB Foundation<br>Licensed under the MIT License.<br>
    <a href="https://duckdb.org/docs/data/csv/overview.html" class="_attribution-link">https://duckdb.org/docs/data/csv/overview.html</a>
  </p>
</div>
