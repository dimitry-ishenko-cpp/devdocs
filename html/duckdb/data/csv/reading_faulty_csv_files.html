<h1 class="title">Reading Faulty CSV Files</h1>  <p>CSV files can come in all shapes and forms, with some presenting many errors that make the process of cleanly reading them inherently difficult. To help users read these files, DuckDB supports detailed error messages, the ability to skip faulty lines, and the possibility of storing faulty lines in a temporary table to assist users with a data cleaning step.</p> <h2 id="structural-errors"> <a style="text-decoration: none;" href="#structural-errors">Structural Errors</a> </h2> <p>DuckDB supports the detection and skipping of several different structural errors. In this section, we will go over each error with an example. For the examples, consider the following table:</p> <pre class="language-sql highlighter-rouge" data-language="sql">CREATE TABLE people (name VARCHAR, birth_date DATE);</pre> <p>DuckDB detects the following error types:</p> <ul> <li>
<code class="language-plaintext highlighter-rouge">CAST</code>: Casting errors occur when a column in the CSV file cannot be cast to the expected schema value. For example, the line <code class="language-plaintext highlighter-rouge">Pedro,The 90s</code> would cause an error since the string <code class="language-plaintext highlighter-rouge">The 90s</code> cannot be cast to a date.</li> <li>
<code class="language-plaintext highlighter-rouge">MISSING COLUMNS</code>: This error occurs if a line in the CSV file has fewer columns than expected. In our example, we expect two columns; therefore, a row with just one value, e.g., <code class="language-plaintext highlighter-rouge">Pedro</code>, would cause this error.</li> <li>
<code class="language-plaintext highlighter-rouge">TOO MANY COLUMNS</code>: This error occurs if a line in the CSV has more columns than expected. In our example, any line with more than two columns would cause this error, e.g., <code class="language-plaintext highlighter-rouge">Pedro,01-01-1992,pdet</code>.</li> <li>
<code class="language-plaintext highlighter-rouge">UNQUOTED VALUE</code>: Quoted values in CSV lines must always be unquoted at the end; if a quoted value remains quoted throughout, it will cause an error. For example, assuming our scanner uses <code class="language-plaintext highlighter-rouge">quote='"'</code>, the line <code class="language-plaintext highlighter-rouge">"pedro"holanda, 01-01-1992</code> would present an unquoted value error.</li> <li>
<code class="language-plaintext highlighter-rouge">LINE SIZE OVER MAXIMUM</code>: DuckDB has a parameter that sets the maximum line size a CSV file can have, which by default is set to <code class="language-plaintext highlighter-rouge">2,097,152</code> bytes. Assuming our scanner is set to <code class="language-plaintext highlighter-rouge">max_line_size = 25</code>, the line <code class="language-plaintext highlighter-rouge">Pedro Holanda, 01-01-1992</code> would produce an error, as it exceeds 25 bytes.</li> <li>
<code class="language-plaintext highlighter-rouge">INVALID UNICODE</code>: DuckDB only supports UTF-8 strings; thus, lines containing non-UTF-8 characters will produce an error. For example, the line <code class="language-plaintext highlighter-rouge">pedro\xff\xff, 01-01-1992</code> would be problematic.</li> </ul> <h3 id="anatomy-of-a-csv-error"> <a style="text-decoration: none;" href="#anatomy-of-a-csv-error">Anatomy of a CSV Error</a> </h3> <p>By default, when performing a CSV read, if any structural errors are encountered, the scanner will immediately stop the scanning process and throw the error to the user. These errors are designed to provide as much information as possible to allow users to evaluate them directly in their CSV file.</p> <p>This is an example for a full error message:</p> <pre class="language-console highlighter-rouge" data-language="console">Conversion Error: CSV Error on Line: 5648
Original Line: Pedro,The 90s
Error when converting column "birth_date". date field value out of range: "The 90s", expected format is (DD-MM-YYYY)

Column date is being converted as type DATE
This type was auto-detected from the CSV file.
Possible solutions:
* Override the type for this column manually by setting the type explicitly, e.g. types={'birth_date': 'VARCHAR'}
* Set the sample size to a larger value to enable the auto-detection to scan more values, e.g. sample_size=-1
* Use a COPY statement to automatically derive types from an existing table.

  file= people.csv
  delimiter = , (Auto-Detected)
  quote = " (Auto-Detected)
  escape = " (Auto-Detected)
  new_line = \r\n (Auto-Detected)
  header = true (Auto-Detected)
  skip_rows = 0 (Auto-Detected)
  date_format = (DD-MM-YYYY) (Auto-Detected)
  timestamp_format =  (Auto-Detected)
  null_padding=0
  sample_size=20480
  ignore_errors=false
  all_varchar=0</pre> <p>The first block provides us with information regarding where the error occurred, including the line number, the original CSV line, and which field was problematic:</p> <pre class="language-console highlighter-rouge" data-language="console">Conversion Error: CSV Error on Line: 5648
Original Line: Pedro,The 90s
Error when converting column "birth_date". date field value out of range: "The 90s", expected format is (DD-MM-YYYY)</pre> <p>The second block provides us with potential solutions:</p> <pre class="language-console highlighter-rouge" data-language="console">Column date is being converted as type DATE
This type was auto-detected from the CSV file.
Possible solutions:
* Override the type for this column manually by setting the type explicitly, e.g. types={'birth_date': 'VARCHAR'}
* Set the sample size to a larger value to enable the auto-detection to scan more values, e.g. sample_size=-1
* Use a COPY statement to automatically derive types from an existing table.</pre> <p>Since the type of this field was auto-detected, it suggests defining the field as a <code class="language-plaintext highlighter-rouge">VARCHAR</code> or fully utilizing the dataset for type detection.</p> <p>Finally, the last block presents some of the options used in the scanner that can cause errors, indicating whether they were auto-detected or manually set by the user.</p> <h2 id="using-the-ignore_errors-option"> <a style="text-decoration: none;" href="#using-the-ignore_errors-option">Using the <code class="language-plaintext highlighter-rouge">ignore_errors</code> Option</a> </h2> <p>There are cases where CSV files may have multiple structural errors, and users simply wish to skip these and read the correct data. Reading erroneous CSV files is possible by utilizing the <code class="language-plaintext highlighter-rouge">ignore_errors</code> option. With this option set, rows containing data that would otherwise cause the CSV parser to generate an error will be ignored. In our example, we will demonstrate a CAST error, but note that any of the errors described in our Structural Error section would cause the faulty line to be skipped.</p> <p>For example, consider the following CSV file, <a href="http://localhost:8000/data/faulty.csv"><code class="language-plaintext highlighter-rouge">faulty.csv</code></a>:</p> <pre><code class="language-csv">Pedro,31
Oogie Boogie, three
</code></pre> <p>If you read the CSV file, specifying that the first column is a <code class="language-plaintext highlighter-rouge">VARCHAR</code> and the second column is an <code class="language-plaintext highlighter-rouge">INTEGER</code>, loading the file would fail, as the string <code class="language-plaintext highlighter-rouge">three</code> cannot be converted to an <code class="language-plaintext highlighter-rouge">INTEGER</code>.</p> <p>For example, the following query will throw a casting error.</p> <pre class="language-sql highlighter-rouge" data-language="sql">FROM read_csv('faulty.csv', columns = {'name': 'VARCHAR', 'age': 'INTEGER'});</pre> <p>However, with <code class="language-plaintext highlighter-rouge">ignore_errors</code> set, the second row of the file is skipped, outputting only the complete first row. For example:</p> <pre class="language-sql highlighter-rouge" data-language="sql">FROM read_csv(
    'faulty.csv',
    columns = {'name': 'VARCHAR', 'age': 'INTEGER'},
    ignore_errors = true
);</pre> <p>Outputs:</p>  <table> <thead> <tr> <th>name</th> <th>age</th> </tr> </thead> <tbody> <tr> <td>Pedro</td> <td>31</td> </tr> </tbody> </table> <p>One should note that the CSV Parser is affected by the projection pushdown optimization. Hence, if we were to select only the name column, both rows would be considered valid, as the casting error on the age would never occur. For example:</p> <pre class="language-sql highlighter-rouge" data-language="sql">SELECT name
FROM read_csv('faulty.csv', columns = {'name': 'VARCHAR', 'age': 'INTEGER'});</pre> <p>Outputs:</p>  <table> <thead> <tr> <th>name</th> </tr> </thead> <tbody> <tr> <td>Pedro</td> </tr> <tr> <td>Oogie Boogie</td> </tr> </tbody> </table> <h2 id="retrieving-faulty-csv-lines"> <a style="text-decoration: none;" href="#retrieving-faulty-csv-lines">Retrieving Faulty CSV Lines</a> </h2> <p>Being able to read faulty CSV files is important, but for many data cleaning operations, it is also necessary to know exactly which lines are corrupted and what errors the parser discovered on them. For scenarios like these, it is possible to use DuckDB's CSV Rejects Table feature. By default, this feature creates two temporary tables.</p> <ol> <li>
<code class="language-plaintext highlighter-rouge">reject_scans</code>: Stores information regarding the parameters of the CSV Scanner</li> <li>
<code class="language-plaintext highlighter-rouge">reject_errors</code>: Stores information regarding each CSV faulty line and in which CSV Scanner they happened.</li> </ol> <p>Note that any of the errors described in our Structural Error section will be stored in the rejects tables. Also, if a line has multiple errors, multiple entries will be stored for the same line, one for each error.</p> <h3 id="reject-scans"> <a style="text-decoration: none;" href="#reject-scans">Reject Scans</a> </h3> <p>The CSV Reject Scans Table returns the following information:</p>  <table> <thead> <tr> <th style="text-align: left">Column name</th> <th style="text-align: left">Description</th> <th style="text-align: left">Type</th> </tr> </thead> <tbody> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">scan_id</code></td> <td style="text-align: left">The internal ID used in DuckDB to represent that scanner</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">UBIGINT</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">file_id</code></td> <td style="text-align: left">A scanner might happen over multiple files, so the file_id represents a unique file in a scanner</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">UBIGINT</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">file_path</code></td> <td style="text-align: left">The file path</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">VARCHAR</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">delimiter</code></td> <td style="text-align: left">The delimiter used e.g., ;</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">VARCHAR</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">quote</code></td> <td style="text-align: left">The quote used e.g., "</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">VARCHAR</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">escape</code></td> <td style="text-align: left">The quote used e.g., "</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">VARCHAR</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">newline_delimiter</code></td> <td style="text-align: left">The newline delimiter used e.g., \r\n</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">VARCHAR</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">skip_rows</code></td> <td style="text-align: left">If any rows were skipped from the top of the file</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">UINTEGER</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">has_header</code></td> <td style="text-align: left">If the file has a header</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">BOOLEAN</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">columns</code></td> <td style="text-align: left">The schema of the file (i.e., all column names and types)</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">VARCHAR</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">date_format</code></td> <td style="text-align: left">The format used for date types</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">VARCHAR</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">timestamp_format</code></td> <td style="text-align: left">The format used for timestamp types</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">VARCHAR</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">user_arguments</code></td> <td style="text-align: left">Any extra scanner parameters manually set by the user</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">VARCHAR</code></td> </tr> </tbody> </table> <h3 id="reject-errors"> <a style="text-decoration: none;" href="#reject-errors">Reject Errors</a> </h3> <p>The CSV Reject Errors Table returns the following information:</p>  <table> <thead> <tr> <th style="text-align: left">Column name</th> <th style="text-align: left">Description</th> <th style="text-align: left">Type</th> </tr> </thead> <tbody> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">scan_id</code></td> <td style="text-align: left">The internal ID used in DuckDB to represent that scanner, used to join with reject scans tables</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">UBIGINT</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">file_id</code></td> <td style="text-align: left">The file_id represents a unique file in a scanner, used to join with reject scans tables</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">UBIGINT</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">line</code></td> <td style="text-align: left">Line number, from the CSV File, where the error occurred.</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">UBIGINT</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">line_byte_position</code></td> <td style="text-align: left">Byte Position of the start of the line, where the error occurred.</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">UBIGINT</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">byte_position</code></td> <td style="text-align: left">Byte Position where the error occurred.</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">UBIGINT</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">column_idx</code></td> <td style="text-align: left">If the error happens in a specific column, the index of the column.</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">UBIGINT</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">column_name</code></td> <td style="text-align: left">If the error happens in a specific column, the name of the column.</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">VARCHAR</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">error_type</code></td> <td style="text-align: left">The type of the error that happened.</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">ENUM</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">csv_line</code></td> <td style="text-align: left">The original CSV line.</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">VARCHAR</code></td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">error_message</code></td> <td style="text-align: left">The error message produced by DuckDB.</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">VARCHAR</code></td> </tr> </tbody> </table> <h2 id="parameters"> <a style="text-decoration: none;" href="#parameters">Parameters</a> </h2>  <p>The parameters listed below are used in the <code class="language-plaintext highlighter-rouge">read_csv</code> function to configure the CSV Rejects Table.</p> <table> <thead> <tr> <th style="text-align: left">Name</th> <th style="text-align: left">Description</th> <th style="text-align: left">Type</th> <th style="text-align: left">Default</th> </tr> </thead> <tbody> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">store_rejects</code></td> <td style="text-align: left">If set to true, any errors in the file will be skipped and stored in the default rejects temporary tables.</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">BOOLEAN</code></td> <td style="text-align: left">False</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">rejects_scan</code></td> <td style="text-align: left">Name of a temporary table where the information of the scan information of faulty CSV file are stored.</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">VARCHAR</code></td> <td style="text-align: left">reject_scans</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">rejects_table</code></td> <td style="text-align: left">Name of a temporary table where the information of the faulty lines of a CSV file are stored.</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">VARCHAR</code></td> <td style="text-align: left">reject_errors</td> </tr> <tr> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">rejects_limit</code></td> <td style="text-align: left">Upper limit on the number of faulty records from a CSV file that will be recorded in the rejects table. 0 is used when no limit should be applied.</td> <td style="text-align: left"><code class="language-plaintext highlighter-rouge">BIGINT</code></td> <td style="text-align: left">0</td> </tr> </tbody> </table> <p>To store the information of the faulty CSV lines in a rejects table, the user must simply set the <code class="language-plaintext highlighter-rouge">store_rejects</code> option to true. For example:</p> <pre class="language-sql highlighter-rouge" data-language="sql">FROM read_csv(
    'faulty.csv',
    columns = {'name': 'VARCHAR', 'age': 'INTEGER'},
    store_rejects = true
);</pre> <p>You can then query both the <code class="language-plaintext highlighter-rouge">reject_scans</code> and <code class="language-plaintext highlighter-rouge">reject_errors</code> tables, to retrieve information about the rejected tuples. For example:</p> <pre class="language-sql highlighter-rouge" data-language="sql">FROM reject_scans;</pre> <p>Outputs:</p>  <table> <thead> <tr> <th>scan_id</th> <th>file_id</th> <th>file_path</th> <th>delimiter</th> <th>quote</th> <th>escape</th> <th>newline_delimiter</th> <th>skip_rows</th> <th style="text-align: right">has_header</th> <th>columns</th> <th>date_format</th> <th>timestamp_format</th> <th>user_arguments</th> </tr> </thead> <tbody> <tr> <td>5</td> <td>0</td> <td>faulty.csv</td> <td>,</td> <td>"</td> <td>"</td> <td>\n</td> <td>0</td> <td style="text-align: right">false</td> <td>{'name': 'VARCHAR','age': 'INTEGER'}</td> <td> </td> <td> </td> <td>store_rejects=true</td> </tr> </tbody> </table> <pre class="language-sql highlighter-rouge" data-language="sql">FROM reject_errors;</pre> <p>Outputs:</p>  <table> <thead> <tr> <th>scan_id</th> <th>file_id</th> <th>line</th> <th>line_byte_position</th> <th>byte_position</th> <th>column_idx</th> <th>column_name</th> <th>error_type</th> <th>csv_line</th> <th>error_message</th> </tr> </thead> <tbody> <tr> <td>5</td> <td>0</td> <td>2</td> <td>10</td> <td>23</td> <td>2</td> <td>age</td> <td>CAST</td> <td>Oogie Boogie, three</td> <td>Error when converting column "age". Could not convert string " three" to 'INTEGER'</td> </tr> </tbody> </table><div class="_attribution">
  <p class="_attribution-p">
    &copy; Copyright 2018&ndash;2024 Stichting DuckDB Foundation<br>Licensed under the MIT License.<br>
    <a href="https://duckdb.org/docs/data/csv/reading_faulty_csv_files.html" class="_attribution-link">https://duckdb.org/docs/data/csv/reading_faulty_csv_files.html</a>
  </p>
</div>
