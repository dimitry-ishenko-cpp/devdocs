<h1 class="title">CSV Auto Detection</h1>  <p>When using <code class="language-plaintext highlighter-rouge">read_csv</code>, the system tries to automatically infer how to read the CSV file using the <a href="http://localhost:8000/2023/10/27/csv-sniffer.html">CSV sniffer</a>. This step is necessary because CSV files are not self-describing and come in many different dialects. The auto-detection works roughly as follows:</p> <ul> <li>Detect the dialect of the CSV file (delimiter, quoting rule, escape)</li> <li>Detect the types of each of the columns</li> <li>Detect whether or not the file has a header row</li> </ul> <p>By default the system will try to auto-detect all options. However, options can be individually overridden by the user. This can be useful in case the system makes a mistake. For example, if the delimiter is chosen incorrectly, we can override it by calling the <code class="language-plaintext highlighter-rouge">read_csv</code> with an explicit delimiter (e.g., <code class="language-plaintext highlighter-rouge">read_csv('file.csv', delim = '|')</code>).</p> <p>The detection works by operating on a sample of the file. The size of the sample can be modified by setting the <code class="language-plaintext highlighter-rouge">sample_size</code> parameter. The default sample size is <code class="language-plaintext highlighter-rouge">20480</code> rows. Setting the <code class="language-plaintext highlighter-rouge">sample_size</code> parameter to <code class="language-plaintext highlighter-rouge">-1</code> means the entire file is read for sampling. The way sampling is performed depends on the type of file. If we are reading from a regular file on disk, we will jump into the file and try to sample from different locations in the file. If we are reading from a file in which we cannot jump – such as a <code class="language-plaintext highlighter-rouge">.gz</code> compressed CSV file or <code class="language-plaintext highlighter-rouge">stdin</code> – samples are taken only from the beginning of the file.</p> <h2 id="sniff_csv-function"> <a style="text-decoration: none;" href="#sniff_csv-function"><code class="language-plaintext highlighter-rouge">sniff_csv</code> Function</a> </h2> <p>It is possible to run the CSV sniffer as a separate step using the <code class="language-plaintext highlighter-rouge">sniff_csv(filename)</code> function, which returns the detected CSV properties as a table with a single row. The <code class="language-plaintext highlighter-rouge">sniff_csv</code> function accepts an optional <code class="language-plaintext highlighter-rouge">sample_size</code> parameter to configure the number of rows sampled.</p> <pre class="language-sql highlighter-rouge" data-language="sql">FROM sniff_csv('my_file.csv');
FROM sniff_csv('my_file.csv', sample_size = 1000);</pre> <table> <thead> <tr> <th>Column name</th> <th>Description</th> <th>Example</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">Delimiter</code></td> <td>delimiter</td> <td><code class="language-plaintext highlighter-rouge">,</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">Quote</code></td> <td>quote character</td> <td><code class="language-plaintext highlighter-rouge">"</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">Escape</code></td> <td>escape</td> <td><code class="language-plaintext highlighter-rouge">\</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">NewLineDelimiter</code></td> <td>new-line delimiter</td> <td><code class="language-plaintext highlighter-rouge">\r\n</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">SkipRow</code></td> <td>number of rows skipped</td> <td>1</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">HasHeader</code></td> <td>whether the CSV has a header</td> <td><code class="language-plaintext highlighter-rouge">true</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">Columns</code></td> <td>column types encoded as a <code class="language-plaintext highlighter-rouge">LIST</code> of <code class="language-plaintext highlighter-rouge">STRUCT</code>s</td> <td><code class="language-plaintext highlighter-rouge">({'name': 'VARCHAR', 'age': 'BIGINT'})</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">DateFormat</code></td> <td>date Format</td> <td><code class="language-plaintext highlighter-rouge">%d/%m/%Y</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">TimestampFormat</code></td> <td>timestamp Format</td> <td><code class="language-plaintext highlighter-rouge">%Y-%m-%dT%H:%M:%S.%f</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">UserArguments</code></td> <td>arguments used to invoke <code class="language-plaintext highlighter-rouge">sniff_csv</code>
</td> <td><code class="language-plaintext highlighter-rouge">sample_size = 1000</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">Prompt</code></td> <td>prompt ready to be used to read the CSV</td> <td><code class="language-plaintext highlighter-rouge">FROM read_csv('my_file.csv', auto_detect=false, delim=',', ...)</code></td> </tr> </tbody> </table> <h3 id="prompt"> <a style="text-decoration: none;" href="#prompt">Prompt</a> </h3> <p>The <code class="language-plaintext highlighter-rouge">Prompt</code> column contains a SQL command with the configurations detected by the sniffer.</p> <pre class="language-sql highlighter-rouge" data-language="sql">-- use line mode in CLI to get the full command
.mode line
SELECT Prompt FROM sniff_csv('my_file.csv');</pre> <pre class="language-text highlighter-rouge" data-language="text">Prompt = FROM read_csv('my_file.csv', auto_detect=false, delim=',', quote='"', escape='"', new_line='\n', skip=0, header=true, columns={...});</pre> <h2 id="detection-steps"> <a style="text-decoration: none;" href="#detection-steps">Detection Steps</a> </h2> <h3 id="dialect-detection"> <a style="text-decoration: none;" href="#dialect-detection">Dialect Detection</a> </h3> <p>Dialect detection works by attempting to parse the samples using the set of considered values. The detected dialect is the dialect that has (1) a consistent number of columns for each row, and (2) the highest number of columns for each row.</p> <p>The following dialects are considered for automatic dialect detection.</p>   <table> <thead> <tr> <th>Parameters</th> <th>Considered values</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">delim</code></td> <td>
<code class="language-plaintext highlighter-rouge">,</code> <code class="language-plaintext highlighter-rouge">|</code> <code class="language-plaintext highlighter-rouge">;</code> <code class="language-plaintext highlighter-rouge">\t</code>
</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">quote</code></td> <td>
<code class="language-plaintext highlighter-rouge">"</code> <code class="language-plaintext highlighter-rouge">'</code> (empty)</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">escape</code></td> <td>
<code class="language-plaintext highlighter-rouge">"</code> <code class="language-plaintext highlighter-rouge">'</code> <code class="language-plaintext highlighter-rouge">\</code> (empty)</td> </tr> </tbody> </table>  <p>Consider the example file <a href="http://localhost:8000/data/flights.csv"><code class="language-plaintext highlighter-rouge">flights.csv</code></a>:</p> <pre><code class="language-csv">FlightDate|UniqueCarrier|OriginCityName|DestCityName
1988-01-01|AA|New York, NY|Los Angeles, CA
1988-01-02|AA|New York, NY|Los Angeles, CA
1988-01-03|AA|New York, NY|Los Angeles, CA
</code></pre> <p>In this file, the dialect detection works as follows:</p> <ul> <li>If we split by a <code class="language-plaintext highlighter-rouge">|</code> every row is split into <code class="language-plaintext highlighter-rouge">4</code> columns</li> <li>If we split by a <code class="language-plaintext highlighter-rouge">,</code> rows 2-4 are split into <code class="language-plaintext highlighter-rouge">3</code> columns, while the first row is split into <code class="language-plaintext highlighter-rouge">1</code> column</li> <li>If we split by <code class="language-plaintext highlighter-rouge">;</code>, every row is split into <code class="language-plaintext highlighter-rouge">1</code> column</li> <li>If we split by <code class="language-plaintext highlighter-rouge">\t</code>, every row is split into <code class="language-plaintext highlighter-rouge">1</code> column</li> </ul> <p>In this example – the system selects the <code class="language-plaintext highlighter-rouge">|</code> as the delimiter. All rows are split into the same amount of columns, and there is more than one column per row meaning the delimiter was actually found in the CSV file.</p> <h3 id="type-detection"> <a style="text-decoration: none;" href="#type-detection">Type Detection</a> </h3> <p>After detecting the dialect, the system will attempt to figure out the types of each of the columns. Note that this step is only performed if we are calling <code class="language-plaintext highlighter-rouge">read_csv</code>. In case of the <code class="language-plaintext highlighter-rouge">COPY</code> statement the types of the table that we are copying into will be used instead.</p> <p>The type detection works by attempting to convert the values in each column to the candidate types. If the conversion is unsuccessful, the candidate type is removed from the set of candidate types for that column. After all samples have been handled – the remaining candidate type with the highest priority is chosen. The default set of candidate types is given below, in order of priority:</p>  <table> <thead> <tr> <th>Types</th> </tr> </thead> <tbody> <tr> <td>BOOLEAN</td> </tr> <tr> <td>BIGINT</td> </tr> <tr> <td>DOUBLE</td> </tr> <tr> <td>TIME</td> </tr> <tr> <td>DATE</td> </tr> <tr> <td>TIMESTAMP</td> </tr> <tr> <td>VARCHAR</td> </tr> </tbody> </table> <p>Note everything can be cast to <code class="language-plaintext highlighter-rouge">VARCHAR</code>. This type has the lowest priority, i.e., columns are converted to <code class="language-plaintext highlighter-rouge">VARCHAR</code> if they cannot be cast to anything else. In <a href="http://localhost:8000/data/flights.csv"><code class="language-plaintext highlighter-rouge">flights.csv</code></a> the <code class="language-plaintext highlighter-rouge">FlightDate</code> column will be cast to a <code class="language-plaintext highlighter-rouge">DATE</code>, while the other columns will be cast to <code class="language-plaintext highlighter-rouge">VARCHAR</code>.</p> <p>The set of candidate types that should be considered by the CSV reader can be explicitly specified using the <a href="overview.html#auto_type_candidates-details.html"><code class="language-plaintext highlighter-rouge">auto_type_candidates</code></a> option.</p> <p>In addition to the default set of candidate types, other types that may be specified using the <code class="language-plaintext highlighter-rouge">auto_type_candidates</code> options are:</p>  <table> <thead> <tr> <th>Types</th> </tr> </thead> <tbody> <tr> <td>DECIMAL</td> </tr> <tr> <td>FLOAT</td> </tr> <tr> <td>INTEGER</td> </tr> <tr> <td>SMALLINT</td> </tr> <tr> <td>TINYINT</td> </tr> </tbody> </table> <p>Even though the set of data types that can be automatically detected may appear quite limited, the CSV reader can configured to read arbitrarily complex types by using the <code class="language-plaintext highlighter-rouge">types</code>-option described in the next section.</p> <p>Type detection can be entirely disabled by using the <code class="language-plaintext highlighter-rouge">all_varchar</code> option. If this is set all columns will remain as <code class="language-plaintext highlighter-rouge">VARCHAR</code> (as they originally occur in the CSV file).</p> <h4 id="overriding-type-detection"> <a style="text-decoration: none;" href="#overriding-type-detection">Overriding Type Detection</a> </h4> <p>The detected types can be individually overridden using the <code class="language-plaintext highlighter-rouge">types</code> option. This option takes either of two options:</p> <ul> <li>A list of type definitions (e.g., <code class="language-plaintext highlighter-rouge">types = ['INTEGER', 'VARCHAR', 'DATE']</code>). This overrides the types of the columns in-order of occurrence in the CSV file.</li> <li>Alternatively, <code class="language-plaintext highlighter-rouge">types</code> takes a <code class="language-plaintext highlighter-rouge">name</code> → <code class="language-plaintext highlighter-rouge">type</code> map which overrides options of individual columns (e.g., <code class="language-plaintext highlighter-rouge">types = {'quarter': 'INTEGER'}</code>).</li> </ul> <p>The set of column types that may be specified using the <code class="language-plaintext highlighter-rouge">types</code> option is not as limited as the types available for the <code class="language-plaintext highlighter-rouge">auto_type_candidates</code> option: any valid type definition is acceptable to the <code class="language-plaintext highlighter-rouge">types</code>-option. (To get a valid type definition, use the <a href="../../sql/functions/utility.html#typeofexpression.html"><code class="language-plaintext highlighter-rouge">typeof()</code></a> function, or use the <code class="language-plaintext highlighter-rouge">column_type</code> column of the <a href="../../guides/meta/describe.html"><code class="language-plaintext highlighter-rouge">DESCRIBE</code></a> result.)</p> <p>The <code class="language-plaintext highlighter-rouge">sniff_csv()</code> function's <code class="language-plaintext highlighter-rouge">Column</code> field returns a struct with column names and types that can be used as a basis for overriding types.</p> <h2 id="header-detection"> <a style="text-decoration: none;" href="#header-detection">Header Detection</a> </h2> <p>Header detection works by checking if the candidate header row deviates from the other rows in the file in terms of types. For example, in <a href="http://localhost:8000/data/flights.csv"><code class="language-plaintext highlighter-rouge">flights.csv</code></a>, we can see that the header row consists of only <code class="language-plaintext highlighter-rouge">VARCHAR</code> columns – whereas the values contain a <code class="language-plaintext highlighter-rouge">DATE</code> value for the <code class="language-plaintext highlighter-rouge">FlightDate</code> column. As such – the system defines the first row as the header row and extracts the column names from the header row.</p> <p>In files that do not have a header row, the column names are generated as <code class="language-plaintext highlighter-rouge">column0</code>, <code class="language-plaintext highlighter-rouge">column1</code>, etc.</p> <p>Note that headers cannot be detected correctly if all columns are of type <code class="language-plaintext highlighter-rouge">VARCHAR</code> – as in this case the system cannot distinguish the header row from the other rows in the file. In this case, the system assumes the file has a header. This can be overridden by setting the <code class="language-plaintext highlighter-rouge">header</code> option to <code class="language-plaintext highlighter-rouge">false</code>.</p> <h3 id="dates-and-timestamps"> <a style="text-decoration: none;" href="#dates-and-timestamps">Dates and Timestamps</a> </h3> <p>DuckDB supports the <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601 format</a> format by default for timestamps, dates and times. Unfortunately, not all dates and times are formatted using this standard. For that reason, the CSV reader also supports the <code class="language-plaintext highlighter-rouge">dateformat</code> and <code class="language-plaintext highlighter-rouge">timestampformat</code> options. Using this format the user can specify a <a href="../../sql/functions/dateformat.html">format string</a> that specifies how the date or timestamp should be read.</p> <p>As part of the auto-detection, the system tries to figure out if dates and times are stored in a different representation. This is not always possible – as there are ambiguities in the representation. For example, the date <code class="language-plaintext highlighter-rouge">01-02-2000</code> can be parsed as either January 2nd or February 1st. Often these ambiguities can be resolved. For example, if we later encounter the date <code class="language-plaintext highlighter-rouge">21-02-2000</code> then we know that the format must have been <code class="language-plaintext highlighter-rouge">DD-MM-YYYY</code>. <code class="language-plaintext highlighter-rouge">MM-DD-YYYY</code> is no longer possible as there is no 21nd month.</p> <p>If the ambiguities cannot be resolved by looking at the data the system has a list of preferences for which date format to use. If the system choses incorrectly, the user can specify the <code class="language-plaintext highlighter-rouge">dateformat</code> and <code class="language-plaintext highlighter-rouge">timestampformat</code> options manually.</p> <p>The system considers the following formats for dates (<code class="language-plaintext highlighter-rouge">dateformat</code>). Higher entries are chosen over lower entries in case of ambiguities (i.e., ISO 8601 is preferred over <code class="language-plaintext highlighter-rouge">MM-DD-YYYY</code>).</p>  <table> <thead> <tr> <th>dateformat</th> </tr> </thead> <tbody> <tr> <td>ISO 8601</td> </tr> <tr> <td>%y-%m-%d</td> </tr> <tr> <td>%Y-%m-%d</td> </tr> <tr> <td>%d-%m-%y</td> </tr> <tr> <td>%d-%m-%Y</td> </tr> <tr> <td>%m-%d-%y</td> </tr> <tr> <td>%m-%d-%Y</td> </tr> </tbody> </table> <p>The system considers the following formats for timestamps (<code class="language-plaintext highlighter-rouge">timestampformat</code>). Higher entries are chosen over lower entries in case of ambiguities.</p>  <table> <thead> <tr> <th>timestampformat</th> </tr> </thead> <tbody> <tr> <td>ISO 8601</td> </tr> <tr> <td>%y-%m-%d %H:%M:%S</td> </tr> <tr> <td>%Y-%m-%d %H:%M:%S</td> </tr> <tr> <td>%d-%m-%y %H:%M:%S</td> </tr> <tr> <td>%d-%m-%Y %H:%M:%S</td> </tr> <tr> <td>%m-%d-%y %I:%M:%S %p</td> </tr> <tr> <td>%m-%d-%Y %I:%M:%S %p</td> </tr> <tr> <td>%Y-%m-%d %H:%M:%S.%f</td> </tr> </tbody> </table><div class="_attribution">
  <p class="_attribution-p">
    &copy; Copyright 2018&ndash;2024 Stichting DuckDB Foundation<br>Licensed under the MIT License.<br>
    <a href="https://duckdb.org/docs/data/csv/auto_detection.html" class="_attribution-link">https://duckdb.org/docs/data/csv/auto_detection.html</a>
  </p>
</div>
