<h1 id="test-api-reference" tabindex="-1">Test API Reference </h1>
<p>The following types are used in the type signatures below</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">type Awaitable&lt;T&gt; = T | PromiseLike&lt;T&gt;
type TestFunction = () =&gt; Awaitable&lt;void&gt;

interface TestOptions {
  /**
   * Will fail the test if it takes too long to execute
   */
  timeout?: number
  /**
   * Will retry the test specific number of times if it fails
   *
   * @default 0
   */
  retry?: number
  /**
   * Will repeat the same test several times even if it fails each time
   * If you have "retry" option and it fails, it will use every retry in each cycle
   * Useful for debugging random failings
   *
   * @default 0
   */
  repeats?: number
}</pre>
</div>
<p>Vitest 1.3.0 deprecates the use of options as the last parameter. You will see a deprecation message until 2.0.0 when this syntax will be removed. If you need to pass down options, use <code>test</code> function's second argument:</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark has-diff vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">import { test } from 'vitest'

test('flaky test', () =&gt; {}, { retry: 3 }) 
test('flaky test', { retry: 3 }, () =&gt; {})</pre>
</div>
<p>When a test function returns a promise, the runner will wait until it is resolved to collect async expectations. If the promise is rejected, the test will fail.</p>
<div class="tip custom-block">
<strong class="custom-block-title">TIP</strong><p>In Jest, <code>TestFunction</code> can also be of type <code>(done: DoneCallback) =&gt; void</code>. If this form is used, the test will not be concluded until <code>done</code> is called. You can achieve the same using an <code>async</code> function, see the <a href="../guide/migration.html#done-callback">Migration guide Done Callback section</a>.</p>
</div>
<p>Most options support both dot-syntax and object-syntax allowing you to use whatever style you prefer.</p>
<div class="vp-code-group vp-adaptive-theme">
<div class="tabs">
<input type="radio" name="group-4vidW" id="tab-7HHBtLv" checked><label for="tab-7HHBtLv">dot-syntax</label><input type="radio" name="group-4vidW" id="tab-00Hbxml"><label for="tab-00Hbxml">object-syntax</label>
</div>
<div class="blocks">
<div class="language-ts vp-adaptive-theme active">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code twoslash lsp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">import { test } from 'vitest'

test.skip('skipped test', () =&gt; {
  // some logic that fails right now
})</pre>
</div>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code twoslash lsp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">import { test } from 'vitest'

test('skipped test', { skip: true }, () =&gt; {
  // some logic that fails right now
})</pre>
</div>
</div>
</div>
<h2 id="test" tabindex="-1">test </h2>
<ul><li>
<strong>Alias:</strong> <code>it</code>
</li></ul>
<p><code>test</code> defines a set of related expectations. It receives the test name and a function that holds the expectations to test.</p>
<p>Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before terminating. The default is 5 seconds, and can be configured globally with <a href="../config/index.html#testtimeout">testTimeout</a></p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code twoslash lsp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">import { expect, test } from 'vitest'

test('should work as expected', () =&gt; {
  expect(Math.sqrt(4)).toBe(2)
})</pre>
</div>
<h3 id="test-extended" tabindex="-1">test.extend </h3>
<ul><li>
<strong>Alias:</strong> <code>it.extend</code>
</li></ul>
<p>Use <code>test.extend</code> to extend the test context with custom fixtures. This will return a new <code>test</code> and it's also extendable, so you can compose more fixtures or override existing ones by extending it as you need. See <a href="../guide/test-context.html#test-extend">Extend Test Context</a> for more information.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">import { expect, test } from 'vitest'

const todos = []
const archive = []

const myTest = test.extend({
  todos: async ({ task }, use) =&gt; {
    todos.push(1, 2, 3)
    await use(todos)
    todos.length = 0
  },
  archive
})

myTest('add item', ({ todos }) =&gt; {
  expect(todos.length).toBe(3)

  todos.push(4)
  expect(todos.length).toBe(4)
})</pre>
</div>
<h3 id="test-skip" tabindex="-1">test.skip </h3>
<ul><li>
<strong>Alias:</strong> <code>it.skip</code>
</li></ul>
<p>If you want to skip running certain tests, but you don't want to delete the code due to any reason, you can use <code>test.skip</code> to avoid running them.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code twoslash lsp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">import { assert, test } from 'vitest'

test.skip('skipped test', () =&gt; {
  // Test skipped, no error
  assert.equal(Math.sqrt(4), 3)
})</pre>
</div>
<p>You can also skip test by calling <code>skip</code> on its <a href="../guide/test-context.html">context</a> dynamically:</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code twoslash lsp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">import { assert, test } from 'vitest'

test('skipped test', (context) =&gt; {
  context.skip()
  // Test skipped, no error
  assert.equal(Math.sqrt(4), 3)
})</pre>
</div>
<h3 id="test-skipif" tabindex="-1">test.skipIf </h3>
<ul><li>
<strong>Alias:</strong> <code>it.skipIf</code>
</li></ul>
<p>In some cases you might run tests multiple times with different environments, and some of the tests might be environment-specific. Instead of wrapping the test code with <code>if</code>, you can use <code>test.skipIf</code> to skip the test whenever the condition is truthy.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code twoslash lsp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">import { assert, test } from 'vitest'

const isDev = process.env.NODE_ENV === 'development'

test.skipIf(isDev)('prod only test', () =&gt; {
  // this test only runs in production
})</pre>
</div>
<div class="warning custom-block">
<strong class="custom-block-title">WARNING</strong><p>You cannot use this syntax, when using Vitest as <a href="../guide/testing-types.html">type checker</a>.</p>
</div>
<h3 id="test-runif" tabindex="-1">test.runIf </h3>
<ul><li>
<strong>Alias:</strong> <code>it.runIf</code>
</li></ul>
<p>Opposite of <a href="#test-skipif">test.skipIf</a>.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code twoslash lsp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">import { assert, test } from 'vitest'

const isDev = process.env.NODE_ENV === 'development'

test.runIf(isDev)('dev only test', () =&gt; {
  // this test only runs in development
})</pre>
</div>
<div class="warning custom-block">
<strong class="custom-block-title">WARNING</strong><p>You cannot use this syntax, when using Vitest as <a href="../guide/testing-types.html">type checker</a>.</p>
</div>
<h3 id="test-only" tabindex="-1">test.only </h3>
<ul><li>
<strong>Alias:</strong> <code>it.only</code>
</li></ul>
<p>Use <code>test.only</code> to only run certain tests in a given suite. This is useful when debugging.</p>
<p>Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before terminating. The default is 5 seconds, and can be configured globally with <a href="../config/index.html#testtimeout">testTimeout</a>.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code twoslash lsp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">import { assert, test } from 'vitest'

test.only('test', () =&gt; {
  // Only this test (and others marked with only) are run
  assert.equal(Math.sqrt(4), 2)
})</pre>
</div>
<p>Sometimes it is very useful to run <code>only</code> tests in a certain file, ignoring all other tests from the whole test suite, which pollute the output.</p>
<p>In order to do that run <code>vitest</code> with specific file containing the tests in question.</p>
<div class="language- vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript"># vitest interesting.test.ts</pre>
</div>
<h3 id="test-concurrent" tabindex="-1">test.concurrent </h3>
<ul><li>
<strong>Alias:</strong> <code>it.concurrent</code>
</li></ul>
<p><code>test.concurrent</code> marks consecutive tests to be run in parallel. It receives the test name, an async function with the tests to collect, and an optional timeout (in milliseconds).</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code twoslash lsp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">import { describe, test } from 'vitest'

// The two tests marked with concurrent will be run in parallel
describe('suite', () =&gt; {
  test('serial test', async () =&gt; { /* ... */ })
  test.concurrent('concurrent test 1', async () =&gt; { /* ... */ })
  test.concurrent('concurrent test 2', async () =&gt; { /* ... */ })
})</pre>
</div>
<p><code>test.skip</code>, <code>test.only</code>, and <code>test.todo</code> works with concurrent tests. All the following combinations are valid:</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">test.concurrent(/* ... */)
test.skip.concurrent(/* ... */) // or test.concurrent.skip(/* ... */)
test.only.concurrent(/* ... */) // or test.concurrent.only(/* ... */)
test.todo.concurrent(/* ... */) // or test.concurrent.todo(/* ... */)</pre>
</div>
<p>When running concurrent tests, Snapshots and Assertions must use <code>expect</code> from the local <a href="../guide/test-context.html">Test Context</a> to ensure the right test is detected.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">test.concurrent('test 1', async ({ expect }) =&gt; {
  expect(foo).toMatchSnapshot()
})
test.concurrent('test 2', async ({ expect }) =&gt; {
  expect(foo).toMatchSnapshot()
})</pre>
</div>
<div class="warning custom-block">
<strong class="custom-block-title">WARNING</strong><p>You cannot use this syntax, when using Vitest as <a href="../guide/testing-types.html">type checker</a>.</p>
</div>
<h3 id="test-sequential" tabindex="-1">test.sequential </h3>
<ul><li>
<strong>Alias:</strong> <code>it.sequential</code>
</li></ul>
<p><code>test.sequential</code> marks a test as sequential. This is useful if you want to run tests in sequence within <code>describe.concurrent</code> or with the <code>--sequence.concurrent</code> command option.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code twoslash lsp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">// with config option { sequence: { concurrent: true } }
test('concurrent test 1', async () =&gt; { /* ... */ })
test('concurrent test 2', async () =&gt; { /* ... */ })

test.sequential('sequential test 1', async () =&gt; { /* ... */ })
test.sequential('sequential test 2', async () =&gt; { /* ... */ })

// within concurrent suite
describe.concurrent('suite', () =&gt; {
  test('concurrent test 1', async () =&gt; { /* ... */ })
  test('concurrent test 2', async () =&gt; { /* ... */ })

  test.sequential('sequential test 1', async () =&gt; { /* ... */ })
  test.sequential('sequential test 2', async () =&gt; { /* ... */ })
})</pre>
</div>
<h3 id="test-todo" tabindex="-1">test.todo </h3>
<ul><li>
<strong>Alias:</strong> <code>it.todo</code>
</li></ul>
<p>Use <code>test.todo</code> to stub tests to be implemented later. An entry will be shown in the report for the tests so you know how many tests you still need to implement.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">// An entry will be shown in the report for this test
test.todo('unimplemented test')</pre>
</div>
<h3 id="test-fails" tabindex="-1">test.fails </h3>
<ul><li>
<strong>Alias:</strong> <code>it.fails</code>
</li></ul>
<p>Use <code>test.fails</code> to indicate that an assertion will fail explicitly.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code twoslash lsp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">import { expect, test } from 'vitest'

function myAsyncFunc() {
  return new Promise(resolve =&gt; resolve(1))
}
test.fails('fail test', async () =&gt; {
  await expect(myAsyncFunc()).rejects.toBe(1)
})</pre>
</div>
<div class="warning custom-block">
<strong class="custom-block-title">WARNING</strong><p>You cannot use this syntax, when using Vitest as <a href="../guide/testing-types.html">type checker</a>.</p>
</div>
<h3 id="test-each" tabindex="-1">test.each </h3>
<ul><li>
<strong>Alias:</strong> <code>it.each</code>
</li></ul>
<div class="tip custom-block">
<strong class="custom-block-title">TIP</strong><p>While <code>test.each</code> is provided for Jest compatibility, Vitest also has <a href="#test-for"><code>test.for</code></a> with an additional feature to integrate <a href="../guide/test-context.html"><code>TestContext</code></a>.</p>
</div>
<p>Use <code>test.each</code> when you need to run the same test with different variables. You can inject parameters with <a href="https://nodejs.org/api/util.html#util_util_format_format_args" target="_blank" rel="noreferrer">printf formatting</a> in the test name in the order of the test function parameters.</p>
<ul>
<li>
<code>%s</code>: string</li>
<li>
<code>%d</code>: number</li>
<li>
<code>%i</code>: integer</li>
<li>
<code>%f</code>: floating point value</li>
<li>
<code>%j</code>: json</li>
<li>
<code>%o</code>: object</li>
<li>
<code>%#</code>: index of the test case</li>
<li>
<code>%%</code>: single percent sign ('%')</li>
</ul>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code twoslash lsp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">test.each([
  [1, 1, 2],
  [1, 2, 3],
  [2, 1, 3],
])('add(%i, %i) -&gt; %i', (a, b, expected) =&gt; {
  expect(a + b).toBe(expected)
})

// this will return
// ✓ add(1, 1) -&gt; 2
// ✓ add(1, 2) -&gt; 3
// ✓ add(2, 1) -&gt; 3</pre>
</div>
<p>You can also access object properties with <code>$</code> prefix, if you are using objects as arguments:</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">test.each([
  { a: 1, b: 1, expected: 2 },
  { a: 1, b: 2, expected: 3 },
  { a: 2, b: 1, expected: 3 },
])('add($a, $b) -&gt; $expected', ({ a, b, expected }) =&gt; {
  expect(a + b).toBe(expected)
})

// this will return
// ✓ add(1, 1) -&gt; 2
// ✓ add(1, 2) -&gt; 3
// ✓ add(2, 1) -&gt; 3</pre>
</div>
<p>You can also access Object attributes with <code>.</code>, if you are using objects as arguments:</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">test.each`
a               | b      | expected
${{ val: 1 }}   | ${'b'} | ${'1b'}
${{ val: 2 }}   | ${'b'} | ${'2b'}
${{ val: 3 }}   | ${'b'} | ${'3b'}
`('add($a.val, $b) -&gt; $expected', ({ a, b, expected }) =&gt; {
  expect(a.val + b).toBe(expected)
})

// this will return
// ✓ add(1, b) -&gt; 1b
// ✓ add(2, b) -&gt; 2b
// ✓ add(3, b) -&gt; 3b</pre>
</div>
<p>Starting from Vitest 0.25.3, you can also use template string table.</p>
<ul>
<li>First row should be column names, separated by <code>|</code>;</li>
<li>One or more subsequent rows of data supplied as template literal expressions using <code>${value}</code> syntax.</li>
</ul>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code twoslash lsp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">test.each`
  a               | b      | expected
  ${1}            | ${1}   | ${2}
  ${'a'}          | ${'b'} | ${'ab'}
  ${[]}           | ${'b'} | ${'b'}
  ${{}}           | ${'b'} | ${'[object Object]b'}
  ${{ asd: 1 }}   | ${'b'} | ${'[object Object]b'}
`('returns $expected when $a is added $b', ({ a, b, expected }) =&gt; {
  expect(a + b).toBe(expected)
})</pre>
</div>
<div class="tip custom-block">
<strong class="custom-block-title">TIP</strong><p>Vitest processes <code>$values</code> with Chai <code>format</code> method. If the value is too truncated, you can increase <a href="../config/index.html#chaiconfig-truncatethreshold">chaiConfig.truncateThreshold</a> in your config file.</p>
</div>
<div class="warning custom-block">
<strong class="custom-block-title">WARNING</strong><p>You cannot use this syntax, when using Vitest as <a href="../guide/testing-types.html">type checker</a>.</p>
</div>
<h3 id="test-for" tabindex="-1">test.for </h3>
<ul><li>
<strong>Alias:</strong> <code>it.for</code>
</li></ul>
<p>Alternative of <code>test.each</code> to provide <a href="../guide/test-context.html"><code>TestContext</code></a>.</p>
<p>The difference from <code>test.each</code> is how array case is provided in the arguments. Other non array case (including template string usage) works exactly same.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark has-diff vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">// `each` spreads array case
test.each([
  [1, 1, 2],
  [1, 2, 3],
  [2, 1, 3],
])('add(%i, %i) -&gt; %i', (a, b, expected) =&gt; { 
  expect(a + b).toBe(expected)
})

// `for` doesn't spread array case
test.for([
  [1, 1, 2],
  [1, 2, 3],
  [2, 1, 3],
])('add(%i, %i) -&gt; %i', ([a, b, expected]) =&gt; { 
  expect(a + b).toBe(expected)
})</pre>
</div>
<p>2nd argument is <a href="../guide/test-context.html"><code>TestContext</code></a> and it can be used for concurrent snapshot, for example,</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">test.concurrent.for([
  [1, 1],
  [1, 2],
  [2, 1],
])('add(%i, %i)', ([a, b], { expect }) =&gt; {
  expect(a + b).matchSnapshot()
})</pre>
</div>
<h2 id="bench" tabindex="-1">bench </h2>
<ul><li>
<strong>Type:</strong> <code>(name: string | Function, fn: BenchFunction, options?: BenchOptions) =&gt; void</code>
</li></ul>
<p><code>bench</code> defines a benchmark. In Vitest terms benchmark is a function that defines a series of operations. Vitest runs this function multiple times to display different performance results.</p>
<p>Vitest uses <a href="https://github.com/tinylibs/tinybench" target="_blank" rel="noreferrer"><code>tinybench</code></a> library under the hood, inheriting all its options that can be used as a third argument.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code twoslash lsp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">import { bench } from 'vitest'

bench('normal sorting', () =&gt; {
  const x = [1, 5, 4, 2, 3]
  x.sort((a, b) =&gt; {
    return a - b
  })
}, { time: 1000 })</pre>
</div>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">export interface Options {
  /**
   * time needed for running a benchmark task (milliseconds)
   * @default 500
   */
  time?: number

  /**
   * number of times that a task should run if even the time option is finished
   * @default 10
   */
  iterations?: number

  /**
   * function to get the current timestamp in milliseconds
   */
  now?: () =&gt; number

  /**
   * An AbortSignal for aborting the benchmark
   */
  signal?: AbortSignal

  /**
   * warmup time (milliseconds)
   * @default 100ms
   */
  warmupTime?: number

  /**
   * warmup iterations
   * @default 5
   */
  warmupIterations?: number

  /**
   * setup function to run before each benchmark task (cycle)
   */
  setup?: Hook

  /**
   * teardown function to run after each benchmark task (cycle)
   */
  teardown?: Hook
}</pre>
</div>
<h3 id="bench-skip" tabindex="-1">bench.skip </h3>
<ul><li>
<strong>Type:</strong> <code>(name: string | Function, fn: BenchFunction, options?: BenchOptions) =&gt; void</code>
</li></ul>
<p>You can use <code>bench.skip</code> syntax to skip running certain benchmarks.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code twoslash lsp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">import { bench } from 'vitest'

bench.skip('normal sorting', () =&gt; {
  const x = [1, 5, 4, 2, 3]
  x.sort((a, b) =&gt; {
    return a - b
  })
})</pre>
</div>
<h3 id="bench-only" tabindex="-1">bench.only </h3>
<ul><li>
<strong>Type:</strong> <code>(name: string | Function, fn: BenchFunction, options?: BenchOptions) =&gt; void</code>
</li></ul>
<p>Use <code>bench.only</code> to only run certain benchmarks in a given suite. This is useful when debugging.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code twoslash lsp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">import { bench } from 'vitest'

bench.only('normal sorting', () =&gt; {
  const x = [1, 5, 4, 2, 3]
  x.sort((a, b) =&gt; {
    return a - b
  })
})</pre>
</div>
<h3 id="bench-todo" tabindex="-1">bench.todo </h3>
<ul><li>
<strong>Type:</strong> <code>(name: string | Function) =&gt; void</code>
</li></ul>
<p>Use <code>bench.todo</code> to stub benchmarks to be implemented later.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code twoslash lsp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">import { bench } from 'vitest'

bench.todo('unimplemented test')</pre>
</div>
<h2 id="describe" tabindex="-1">describe </h2>
<p>When you use <code>test</code> or <code>bench</code> in the top level of file, they are collected as part of the implicit suite for it. Using <code>describe</code> you can define a new suite in the current context, as a set of related tests or benchmarks and other nested suites. A suite lets you organize your tests and benchmarks so reports are more clear.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code twoslash lsp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">// basic.spec.ts
// organizing tests

import { describe, expect, test } from 'vitest'

const person = {
  isActive: true,
  age: 32,
}

describe('person', () =&gt; {
  test('person is defined', () =&gt; {
    expect(person).toBeDefined()
  })

  test('is active', () =&gt; {
    expect(person.isActive).toBeTruthy()
  })

  test('age limit', () =&gt; {
    expect(person.age).toBeLessThanOrEqual(32)
  })
})</pre>
</div>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code twoslash lsp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">// basic.bench.ts
// organizing benchmarks

import { bench, describe } from 'vitest'

describe('sort', () =&gt; {
  bench('normal', () =&gt; {
    const x = [1, 5, 4, 2, 3]
    x.sort((a, b) =&gt; {
      return a - b
    })
  })

  bench('reverse', () =&gt; {
    const x = [1, 5, 4, 2, 3]
    x.reverse().sort((a, b) =&gt; {
      return a - b
    })
  })
})</pre>
</div>
<p>You can also nest describe blocks if you have a hierarchy of tests or benchmarks:</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code twoslash lsp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">import { describe, expect, test } from 'vitest'

function numberToCurrency(value: number | string) {
  if (typeof value !== 'number') {
    throw new TypeError('Value must be a number')
  }

  return value.toFixed(2).toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',')
}

describe('numberToCurrency', () =&gt; {
  describe('given an invalid number', () =&gt; {
    test('composed of non-numbers to throw error', () =&gt; {
      expect(() =&gt; numberToCurrency('abc')).toThrowError()
    })
  })

  describe('given a valid number', () =&gt; {
    test('returns the correct currency format', () =&gt; {
      expect(numberToCurrency(10000)).toBe('10,000.00')
    })
  })
})</pre>
</div>
<h3 id="describe-skip" tabindex="-1">describe.skip </h3>
<ul><li>
<strong>Alias:</strong> <code>suite.skip</code>
</li></ul>
<p>Use <code>describe.skip</code> in a suite to avoid running a particular describe block.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code twoslash lsp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">import { assert, describe, test } from 'vitest'

describe.skip('skipped suite', () =&gt; {
  test('sqrt', () =&gt; {
    // Suite skipped, no error
    assert.equal(Math.sqrt(4), 3)
  })
})</pre>
</div>
<h3 id="describe-skipif" tabindex="-1">describe.skipIf </h3>
<ul><li>
<strong>Alias:</strong> <code>suite.skipIf</code>
</li></ul>
<p>In some cases, you might run suites multiple times with different environments, and some of the suites might be environment-specific. Instead of wrapping the suite with <code>if</code>, you can use <code>describe.skipIf</code> to skip the suite whenever the condition is truthy.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code twoslash lsp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">import { describe, test } from 'vitest'

const isDev = process.env.NODE_ENV === 'development'

describe.skipIf(isDev)('prod only test suite', () =&gt; {
  // this test suite only runs in production
})</pre>
</div>
<div class="warning custom-block">
<strong class="custom-block-title">WARNING</strong><p>You cannot use this syntax when using Vitest as <a href="../guide/testing-types.html">type checker</a>.</p>
</div>
<h3 id="describe-runif" tabindex="-1">describe.runIf </h3>
<ul><li>
<strong>Alias:</strong> <code>suite.runIf</code>
</li></ul>
<p>Opposite of <a href="#describe-skipif">describe.skipIf</a>.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code twoslash lsp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">import { assert, describe, test } from 'vitest'

const isDev = process.env.NODE_ENV === 'development'

describe.runIf(isDev)('dev only test suite', () =&gt; {
  // this test suite only runs in development
})</pre>
</div>
<div class="warning custom-block">
<strong class="custom-block-title">WARNING</strong><p>You cannot use this syntax, when using Vitest as <a href="../guide/testing-types.html">type checker</a>.</p>
</div>
<h3 id="describe-only" tabindex="-1">describe.only </h3>
<ul><li>
<strong>Type:</strong> <code>(name: string | Function, fn: TestFunction, options?: number | TestOptions) =&gt; void</code>
</li></ul>
<p>Use <code>describe.only</code> to only run certain suites</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code twoslash lsp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">// Only this suite (and others marked with only) are run
describe.only('suite', () =&gt; {
  test('sqrt', () =&gt; {
    assert.equal(Math.sqrt(4), 3)
  })
})

describe('other suite', () =&gt; {
  // ... will be skipped
})</pre>
</div>
<p>Sometimes it is very useful to run <code>only</code> tests in a certain file, ignoring all other tests from the whole test suite, which pollute the output.</p>
<p>In order to do that run <code>vitest</code> with specific file containing the tests in question.</p>
<div class="language- vp-adaptive-theme">
<pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript"># vitest interesting.test.ts</pre>
</div>
<h3 id="describe-concurrent" tabindex="-1">describe.concurrent </h3>
<ul><li>
<strong>Alias:</strong> <code>suite.concurrent</code>
</li></ul>
<p><code>describe.concurrent</code> runs all inner suites and tests in parallel</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code twoslash lsp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">// All suites and tests within this suite will be run in parallel
describe.concurrent('suite', () =&gt; {
  test('concurrent test 1', async () =&gt; { /* ... */ })
  describe('concurrent suite 2', async () =&gt; {
    test('concurrent test inner 1', async () =&gt; { /* ... */ })
    test('concurrent test inner 2', async () =&gt; { /* ... */ })
  })
  test.concurrent('concurrent test 3', async () =&gt; { /* ... */ })
})</pre>
</div>
<p><code>.skip</code>, <code>.only</code>, and <code>.todo</code> works with concurrent suites. All the following combinations are valid:</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">describe.concurrent(/* ... */)
describe.skip.concurrent(/* ... */) // or describe.concurrent.skip(/* ... */)
describe.only.concurrent(/* ... */) // or describe.concurrent.only(/* ... */)
describe.todo.concurrent(/* ... */) // or describe.concurrent.todo(/* ... */)</pre>
</div>
<p>When running concurrent tests, Snapshots and Assertions must use <code>expect</code> from the local <a href="../guide/test-context.html">Test Context</a> to ensure the right test is detected.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">describe.concurrent('suite', () =&gt; {
  test('concurrent test 1', async ({ expect }) =&gt; {
    expect(foo).toMatchSnapshot()
  })
  test('concurrent test 2', async ({ expect }) =&gt; {
    expect(foo).toMatchSnapshot()
  })
})</pre>
</div>
<div class="warning custom-block">
<strong class="custom-block-title">WARNING</strong><p>You cannot use this syntax, when using Vitest as <a href="../guide/testing-types.html">type checker</a>.</p>
</div>
<h3 id="describe-sequential" tabindex="-1">describe.sequential </h3>
<ul><li>
<strong>Alias:</strong> <code>suite.sequential</code>
</li></ul>
<p><code>describe.sequential</code> in a suite marks every test as sequential. This is useful if you want to run tests in sequence within <code>describe.concurrent</code> or with the <code>--sequence.concurrent</code> command option.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code twoslash lsp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">describe.concurrent('suite', () =&gt; {
  test('concurrent test 1', async () =&gt; { /* ... */ })
  test('concurrent test 2', async () =&gt; { /* ... */ })

  describe.sequential('', () =&gt; {
    test('sequential test 1', async () =&gt; { /* ... */ })
    test('sequential test 2', async () =&gt; { /* ... */ })
  })
})</pre>
</div>
<h3 id="describe-shuffle" tabindex="-1">describe.shuffle </h3>
<ul><li>
<strong>Alias:</strong> <code>suite.shuffle</code>
</li></ul>
<p>Vitest provides a way to run all tests in random order via CLI flag <a href="../guide/cli.html"><code>--sequence.shuffle</code></a> or config option <a href="../config/index.html#sequence-shuffle"><code>sequence.shuffle</code></a>, but if you want to have only part of your test suite to run tests in random order, you can mark it with this flag.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code twoslash lsp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">describe.shuffle('suite', () =&gt; {
  test('random test 1', async () =&gt; { /* ... */ })
  test('random test 2', async () =&gt; { /* ... */ })
  test('random test 3', async () =&gt; { /* ... */ })
})
// order depends on sequence.seed option in config (Date.now() by default)</pre>
</div>
<p><code>.skip</code>, <code>.only</code>, and <code>.todo</code> works with random suites.</p>
<div class="warning custom-block">
<strong class="custom-block-title">WARNING</strong><p>You cannot use this syntax, when using Vitest as <a href="../guide/testing-types.html">type checker</a>.</p>
</div>
<h3 id="describe-todo" tabindex="-1">describe.todo </h3>
<ul><li>
<strong>Alias:</strong> <code>suite.todo</code>
</li></ul>
<p>Use <code>describe.todo</code> to stub suites to be implemented later. An entry will be shown in the report for the tests so you know how many tests you still need to implement.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">// An entry will be shown in the report for this suite
describe.todo('unimplemented suite')</pre>
</div>
<h3 id="describe-each" tabindex="-1">describe.each </h3>
<ul><li>
<strong>Alias:</strong> <code>suite.each</code>
</li></ul>
<p>Use <code>describe.each</code> if you have more than one test that depends on the same data.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code twoslash lsp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">describe.each([
  { a: 1, b: 1, expected: 2 },
  { a: 1, b: 2, expected: 3 },
  { a: 2, b: 1, expected: 3 },
])('describe object add($a, $b)', ({ a, b, expected }) =&gt; {
  test(`returns ${expected}`, () =&gt; {
    expect(a + b).toBe(expected)
  })

  test(`returned value not be greater than ${expected}`, () =&gt; {
    expect(a + b).not.toBeGreaterThan(expected)
  })

  test(`returned value not be less than ${expected}`, () =&gt; {
    expect(a + b).not.toBeLessThan(expected)
  })
})</pre>
</div>
<p>Starting from Vitest 0.25.3, you can also use template string table.</p>
<ul>
<li>First row should be column names, separated by <code>|</code>;</li>
<li>One or more subsequent rows of data supplied as template literal expressions using <code>${value}</code> syntax.</li>
</ul>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code twoslash lsp" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">describe.each`
  a               | b      | expected
  ${1}            | ${1}   | ${2}
  ${'a'}          | ${'b'} | ${'ab'}
  ${[]}           | ${'b'} | ${'b'}
  ${{}}           | ${'b'} | ${'[object Object]b'}
  ${{ asd: 1 }}   | ${'b'} | ${'[object Object]b'}
`('describe template string add($a, $b)', ({ a, b, expected }) =&gt; {
  test(`returns ${expected}`, () =&gt; {
    expect(a + b).toBe(expected)
  })
})</pre>
</div>
<div class="warning custom-block">
<strong class="custom-block-title">WARNING</strong><p>You cannot use this syntax, when using Vitest as <a href="../guide/testing-types.html">type checker</a>.</p>
</div>
<h2 id="setup-and-teardown" tabindex="-1">Setup and Teardown </h2>
<p>These functions allow you to hook into the life cycle of tests to avoid repeating setup and teardown code. They apply to the current context: the file if they are used at the top-level or the current suite if they are inside a <code>describe</code> block. These hooks are not called, when you are running Vitest as a type checker.</p>
<h3 id="beforeeach" tabindex="-1">beforeEach </h3>
<ul><li>
<strong>Type:</strong> <code>beforeEach(fn: () =&gt; Awaitable&lt;void&gt;, timeout?: number)</code>
</li></ul>
<p>Register a callback to be called before each of the tests in the current context runs. If the function returns a promise, Vitest waits until the promise resolve before running the test.</p>
<p>Optionally, you can pass a timeout (in milliseconds) defining how long to wait before terminating. The default is 5 seconds.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">import { beforeEach } from 'vitest'

beforeEach(async () =&gt; {
  // Clear mocks and add some testing data after before each test run
  await stopMocking()
  await addUser({ name: 'John' })
})</pre>
</div>
<p>Here, the <code>beforeEach</code> ensures that user is added for each test.</p>
<p><code>beforeEach</code> also accepts an optional cleanup function (equivalent to <code>afterEach</code>).</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">import { beforeEach } from 'vitest'

beforeEach(async () =&gt; {
  // called once before each test run
  await prepareSomething()

  // clean up function, called once after each test run
  return async () =&gt; {
    await resetSomething()
  }
})</pre>
</div>
<h3 id="aftereach" tabindex="-1">afterEach </h3>
<ul><li>
<strong>Type:</strong> <code>afterEach(fn: () =&gt; Awaitable&lt;void&gt;, timeout?: number)</code>
</li></ul>
<p>Register a callback to be called after each one of the tests in the current context completes. If the function returns a promise, Vitest waits until the promise resolve before continuing.</p>
<p>Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before terminating. The default is 5 seconds.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">import { afterEach } from 'vitest'

afterEach(async () =&gt; {
  await clearTestingData() // clear testing data after each test run
})</pre>
</div>
<p>Here, the <code>afterEach</code> ensures that testing data is cleared after each test runs.</p>
<div class="tip custom-block">
<strong class="custom-block-title">TIP</strong><p>Vitest 1.3.0 added <a href="#ontestfinished"><code>onTestFinished</code></a> hook. You can call it during the test execution to cleanup any state after the test has finished running.</p>
</div>
<h3 id="beforeall" tabindex="-1">beforeAll </h3>
<ul><li>
<strong>Type:</strong> <code>beforeAll(fn: () =&gt; Awaitable&lt;void&gt;, timeout?: number)</code>
</li></ul>
<p>Register a callback to be called once before starting to run all tests in the current context. If the function returns a promise, Vitest waits until the promise resolve before running tests.</p>
<p>Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before terminating. The default is 5 seconds.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">import { beforeAll } from 'vitest'

beforeAll(async () =&gt; {
  await startMocking() // called once before all tests run
})</pre>
</div>
<p>Here the <code>beforeAll</code> ensures that the mock data is set up before tests run.</p>
<p><code>beforeAll</code> also accepts an optional cleanup function (equivalent to <code>afterAll</code>).</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">import { beforeAll } from 'vitest'

beforeAll(async () =&gt; {
  // called once before all tests run
  await startMocking()

  // clean up function, called once after all tests run
  return async () =&gt; {
    await stopMocking()
  }
})</pre>
</div>
<h3 id="afterall" tabindex="-1">afterAll </h3>
<ul><li>
<strong>Type:</strong> <code>afterAll(fn: () =&gt; Awaitable&lt;void&gt;, timeout?: number)</code>
</li></ul>
<p>Register a callback to be called once after all tests have run in the current context. If the function returns a promise, Vitest waits until the promise resolve before continuing.</p>
<p>Optionally, you can provide a timeout (in milliseconds) for specifying how long to wait before terminating. The default is 5 seconds.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">import { afterAll } from 'vitest'

afterAll(async () =&gt; {
  await stopMocking() // this method is called after all tests run
})</pre>
</div>
<p>Here the <code>afterAll</code> ensures that <code>stopMocking</code> method is called after all tests run.</p>
<h2 id="test-hooks" tabindex="-1">Test Hooks </h2>
<p>Vitest provides a few hooks that you can call <em>during</em> the test execution to cleanup the state when the test has finished runnning.</p>
<div class="warning custom-block">
<strong class="custom-block-title">WARNING</strong><p>These hooks will throw an error if they are called outside of the test body.</p>
</div>
<h3 id="ontestfinished" tabindex="-1">onTestFinished </h3>
<p>This hook is always called after the test has finished running. It is called after <code>afterEach</code> hooks since they can influence the test result. It receives a <code>TaskResult</code> object with the current test result.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">import { onTestFinished, test } from 'vitest'

test('performs a query', () =&gt; {
  const db = connectDb()
  onTestFinished(() =&gt; db.close())
  db.query('SELECT * FROM users')
})</pre>
</div>
<div class="warning custom-block">
<strong class="custom-block-title">WARNING</strong><p>If you are running tests concurrently, you should always use <code>onTestFinished</code> hook from the test context since Vitest doesn't track concurrent tests in global hooks:</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">import { test } from 'vitest'

test.concurrent('performs a query', ({ onTestFinished }) =&gt; {
  const db = connectDb()
  onTestFinished(() =&gt; db.close())
  db.query('SELECT * FROM users')
})</pre>
</div>
</div>
<p>This hook is particularly useful when creating reusable logic:</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">// this can be in a separate file
function getTestDb() {
  const db = connectMockedDb()
  onTestFinished(() =&gt; db.close())
  return db
}

test('performs a user query', async () =&gt; {
  const db = getTestDb()
  expect(
    await db.query('SELECT * from users').perform()
  ).toEqual([])
})

test('performs an organization query', async () =&gt; {
  const db = getTestDb()
  expect(
    await db.query('SELECT * from organizations').perform()
  ).toEqual([])
})</pre>
</div>
<div class="tip custom-block">
<strong class="custom-block-title">TIP</strong><p>This hook is always called in reverse order and is not affected by <a href="../config/index.html#sequence-hooks"><code>sequence.hooks</code></a> option.</p>
</div>
<h3 id="ontestfailed" tabindex="-1">onTestFailed </h3>
<p>This hook is called only after the test has failed. It is called after <code>afterEach</code> hooks since they can influence the test result. It receives a <code>TaskResult</code> object with the current test result. This hook is useful for debugging.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">import { onTestFailed, test } from 'vitest'

test('performs a query', () =&gt; {
  const db = connectDb()
  onTestFailed((e) =&gt; {
    console.log(e.result.errors)
  })
  db.query('SELECT * FROM users')
})</pre>
</div>
<div class="warning custom-block">
<strong class="custom-block-title">WARNING</strong><p>If you are running tests concurrently, you should always use <code>onTestFailed</code> hook from the test context since Vitest doesn't track concurrent tests in global hooks:</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" data-language="javascript">import { test } from 'vitest'

test.concurrent('performs a query', ({ onTestFailed }) =&gt; {
  const db = connectDb()
  onTestFailed((result) =&gt; {
    console.log(result.errors)
  })
  db.query('SELECT * FROM users')
})</pre>
</div>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2021-Present Anthony Fu<br>&copy; 2021-Present Matias Capeletto<br>Licensed under the MIT License.<br>
    <a href="https://vitest.dev/api/" class="_attribution-link">https://vitest.dev/api/</a>
  </p>
</div>
