<h1 id="expect" tabindex="-1">expect </h1>
<p>The following types are used in the type signatures below</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">type Awaitable&lt;T&gt; = T | PromiseLike&lt;T&gt;</pre>
</div>
<p><code>expect</code> is used to create assertions. In this context <code>assertions</code> are functions that can be called to assert a statement. Vitest provides <code>chai</code> assertions by default and also <code>Jest</code> compatible assertions build on top of <code>chai</code>.</p>
<p>For example, this code asserts that an <code>input</code> value is equal to <code>2</code>. If it's not, the assertion will throw an error, and the test will fail.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">import { expect } from 'vitest'

const input = Math.sqrt(4)

expect(input).to.equal(2) // chai API
expect(input).toBe(2) // jest API</pre>
</div>
<p>Technically this example doesn't use <a href="index.html#test"><code>test</code></a> function, so in the console you will see Node.js error instead of Vitest output. To learn more about <code>test</code>, please read <a href="index.html">Test API Reference</a>.</p>
<p>Also, <code>expect</code> can be used statically to access matcher functions, described later, and more.</p>
<div class="warning custom-block">
<strong class="custom-block-title">WARNING</strong><p><code>expect</code> has no effect on testing types, if the expression doesn't have a type error. If you want to use Vitest as <a href="../guide/testing-types.html">type checker</a>, use <a href="expect-typeof.html"><code>expectTypeOf</code></a> or <a href="assert-type.html"><code>assertType</code></a>.</p>
</div>
<h2 id="soft" tabindex="-1">soft </h2>
<ul><li>
<strong>Type:</strong> <code>ExpectStatic &amp; (actual: any) =&gt; Assertions</code>
</li></ul>
<p><code>expect.soft</code> functions similarly to <code>expect</code>, but instead of terminating the test execution upon a failed assertion, it continues running and marks the failure as a test failure. All errors encountered during the test will be displayed until the test is completed.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">import { expect, test } from 'vitest'

test('expect.soft test', () =&gt; {
  expect.soft(1 + 1).toBe(3) // mark the test as fail and continue
  expect.soft(1 + 2).toBe(4) // mark the test as fail and continue
})
// At the end of the test, the above errors will be output.</pre>
</div>
<p>It can also be used with <code>expect</code>. if <code>expect</code> assertion fails, the test will be terminated and all errors will be displayed.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">import { expect, test } from 'vitest'

test('expect.soft test', () =&gt; {
  expect.soft(1 + 1).toBe(3) // mark the test as fail and continue
  expect(1 + 2).toBe(4) // failed and terminate the test, all previous errors will be output
  expect.soft(1 + 3).toBe(5) // do not run
})</pre>
</div>
<div class="warning custom-block">
<strong class="custom-block-title">WARNING</strong><p><code>expect.soft</code> can only be used inside the <a href="index.html#test"><code>test</code></a> function.</p>
</div>
<h2 id="not" tabindex="-1">not </h2>
<p>Using <code>not</code> will negate the assertion. For example, this code asserts that an <code>input</code> value is not equal to <code>2</code>. If it's equal, the assertion will throw an error, and the test will fail.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">import { expect, test } from 'vitest'

const input = Math.sqrt(16)

expect(input).not.to.equal(2) // chai API
expect(input).not.toBe(2) // jest API</pre>
</div>
<h2 id="tobe" tabindex="-1">toBe </h2>
<ul><li>
<strong>Type:</strong> <code>(value: any) =&gt; Awaitable&lt;void&gt;</code>
</li></ul>
<p><code>toBe</code> can be used to assert if primitives are equal or that objects share the same reference. It is equivalent of calling <code>expect(Object.is(3, 3)).toBe(true)</code>. If the objects are not the same, but you want to check if their structures are identical, you can use <a href="#toequal"><code>toEqual</code></a>.</p>
<p>For example, the code below checks if the trader has 13 apples.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">import { expect, test } from 'vitest'

const stock = {
  type: 'apples',
  count: 13,
}

test('stock has 13 apples', () =&gt; {
  expect(stock.type).toBe('apples')
  expect(stock.count).toBe(13)
})

test('stocks are the same', () =&gt; {
  const refStock = stock // same reference

  expect(stock).toBe(refStock)
})</pre>
</div>
<p>Try not to use <code>toBe</code> with floating-point numbers. Since JavaScript rounds them, <code>0.1 + 0.2</code> is not strictly <code>0.3</code>. To reliably assert floating-point numbers, use <a href="#tobecloseto"><code>toBeCloseTo</code></a> assertion.</p>
<h2 id="tobecloseto" tabindex="-1">toBeCloseTo </h2>
<ul><li>
<strong>Type:</strong> <code>(value: number, numDigits?: number) =&gt; Awaitable&lt;void&gt;</code>
</li></ul>
<p>Use <code>toBeCloseTo</code> to compare floating-point numbers. The optional <code>numDigits</code> argument limits the number of digits to check <em>after</em> the decimal point. For example:</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">import { expect, test } from 'vitest'

test.fails('decimals are not equal in javascript', () =&gt; {
  expect(0.2 + 0.1).toBe(0.3) // 0.2 + 0.1 is 0.30000000000000004
})

test('decimals are rounded to 5 after the point', () =&gt; {
  // 0.2 + 0.1 is 0.30000 | "000000000004" removed
  expect(0.2 + 0.1).toBeCloseTo(0.3, 5)
  // nothing from 0.30000000000000004 is removed
  expect(0.2 + 0.1).not.toBeCloseTo(0.3, 50)
})</pre>
</div>
<h2 id="tobedefined" tabindex="-1">toBeDefined </h2>
<ul><li>
<strong>Type:</strong> <code>() =&gt; Awaitable&lt;void&gt;</code>
</li></ul>
<p><code>toBeDefined</code> asserts that the value is not equal to <code>undefined</code>. Useful use case would be to check if function <em>returned</em> anything.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">import { expect, test } from 'vitest'

function getApples() {
  return 3
}

test('function returned something', () =&gt; {
  expect(getApples()).toBeDefined()
})</pre>
</div>
<h2 id="tobeundefined" tabindex="-1">toBeUndefined </h2>
<ul><li>
<strong>Type:</strong> <code>() =&gt; Awaitable&lt;void&gt;</code>
</li></ul>
<p>Opposite of <code>toBeDefined</code>, <code>toBeUndefined</code> asserts that the value <em>is</em> equal to <code>undefined</code>. Useful use case would be to check if function hasn't <em>returned</em> anything.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">import { expect, test } from 'vitest'

function getApplesFromStock(stock) {
  if (stock === 'Bill')
    return 13
}

test('mary doesn\'t have a stock', () =&gt; {
  expect(getApplesFromStock('Mary')).toBeUndefined()
})</pre>
</div>
<h2 id="tobetruthy" tabindex="-1">toBeTruthy </h2>
<ul><li>
<strong>Type:</strong> <code>() =&gt; Awaitable&lt;void&gt;</code>
</li></ul>
<p><code>toBeTruthy</code> asserts that the value is true when converted to boolean. Useful if you don't care for the value, but just want to know it can be converted to <code>true</code>.</p>
<p>For example, having this code you don't care for the return value of <code>stocks.getInfo</code> - it maybe a complex object, a string, or anything else. The code will still work.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">import { Stocks } from './stocks.js'

const stocks = new Stocks()
stocks.sync('Bill')
if (stocks.getInfo('Bill'))
  stocks.sell('apples', 'Bill')</pre>
</div>
<p>So if you want to test that <code>stocks.getInfo</code> will be truthy, you could write:</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">import { expect, test } from 'vitest'
import { Stocks } from './stocks.js'

const stocks = new Stocks()

test('if we know Bill stock, sell apples to him', () =&gt; {
  stocks.sync('Bill')
  expect(stocks.getInfo('Bill')).toBeTruthy()
})</pre>
</div>
<p>Everything in JavaScript is truthy, except <code>false</code>, <code>null</code>, <code>undefined</code>, <code>NaN</code>, <code>0</code>, <code>-0</code>, <code>0n</code>, <code>""</code> and <code>document.all</code>.</p>
<h2 id="tobefalsy" tabindex="-1">toBeFalsy </h2>
<ul><li>
<strong>Type:</strong> <code>() =&gt; Awaitable&lt;void&gt;</code>
</li></ul>
<p><code>toBeFalsy</code> asserts that the value is false when converted to boolean. Useful if you don't care for the value, but just want to know if it can be converted to <code>false</code>.</p>
<p>For example, having this code you don't care for the return value of <code>stocks.stockFailed</code> - it may return any falsy value, but the code will still work.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">import { Stocks } from './stocks.js'

const stocks = new Stocks()
stocks.sync('Bill')
if (!stocks.stockFailed('Bill'))
  stocks.sell('apples', 'Bill')</pre>
</div>
<p>So if you want to test that <code>stocks.stockFailed</code> will be falsy, you could write:</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">import { expect, test } from 'vitest'
import { Stocks } from './stocks.js'

const stocks = new Stocks()

test('if Bill stock hasn\'t failed, sell apples to him', () =&gt; {
  stocks.syncStocks('Bill')
  expect(stocks.stockFailed('Bill')).toBeFalsy()
})</pre>
</div>
<p>Everything in JavaScript is truthy, except <code>false</code>, <code>null</code>, <code>undefined</code>, <code>NaN</code>, <code>0</code>, <code>-0</code>, <code>0n</code>, <code>""</code> and <code>document.all</code>.</p>
<h2 id="tobenull" tabindex="-1">toBeNull </h2>
<ul><li>
<strong>Type:</strong> <code>() =&gt; Awaitable&lt;void&gt;</code>
</li></ul>
<p><code>toBeNull</code> simply asserts if something is <code>null</code>. Alias for <code>.toBe(null)</code>.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">import { expect, test } from 'vitest'

function apples() {
  return null
}

test('we don\'t have apples', () =&gt; {
  expect(apples()).toBeNull()
})</pre>
</div>
<h2 id="tobenan" tabindex="-1">toBeNaN </h2>
<ul><li>
<strong>Type:</strong> <code>() =&gt; Awaitable&lt;void&gt;</code>
</li></ul>
<p><code>toBeNaN</code> simply asserts if something is <code>NaN</code>. Alias for <code>.toBe(NaN)</code>.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">import { expect, test } from 'vitest'

let i = 0

function getApplesCount() {
  i++
  return i &gt; 1 ? Number.NaN : i
}

test('getApplesCount has some unusual side effects...', () =&gt; {
  expect(getApplesCount()).not.toBeNaN()
  expect(getApplesCount()).toBeNaN()
})</pre>
</div>
<h2 id="tobetypeof" tabindex="-1">toBeTypeOf </h2>
<ul><li>
<strong>Type:</strong> <code>(c: 'bigint' | 'boolean' | 'function' | 'number' | 'object' | 'string' | 'symbol' | 'undefined') =&gt; Awaitable&lt;void&gt;</code>
</li></ul>
<p><code>toBeTypeOf</code> asserts if an actual value is of type of received type.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">import { expect, test } from 'vitest'

const actual = 'stock'

test('stock is type of string', () =&gt; {
  expect(actual).toBeTypeOf('string')
})</pre>
</div>
<h2 id="tobeinstanceof" tabindex="-1">toBeInstanceOf </h2>
<ul><li>
<strong>Type:</strong> <code>(c: any) =&gt; Awaitable&lt;void&gt;</code>
</li></ul>
<p><code>toBeInstanceOf</code> asserts if an actual value is instance of received class.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">import { expect, test } from 'vitest'
import { Stocks } from './stocks.js'

const stocks = new Stocks()

test('stocks are instance of Stocks', () =&gt; {
  expect(stocks).toBeInstanceOf(Stocks)
})</pre>
</div>
<h2 id="tobegreaterthan" tabindex="-1">toBeGreaterThan </h2>
<ul><li>
<strong>Type:</strong> <code>(n: number | bigint) =&gt; Awaitable&lt;void&gt;</code>
</li></ul>
<p><code>toBeGreaterThan</code> asserts if actual value is greater than received one. Equal values will fail the test.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">import { expect, test } from 'vitest'
import { getApples } from './stocks.js'

test('have more then 10 apples', () =&gt; {
  expect(getApples()).toBeGreaterThan(10)
})</pre>
</div>
<h2 id="tobegreaterthanorequal" tabindex="-1">toBeGreaterThanOrEqual </h2>
<ul><li>
<strong>Type:</strong> <code>(n: number | bigint) =&gt; Awaitable&lt;void&gt;</code>
</li></ul>
<p><code>toBeGreaterThanOrEqual</code> asserts if actual value is greater than received one or equal to it.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">import { expect, test } from 'vitest'
import { getApples } from './stocks.js'

test('have 11 apples or more', () =&gt; {
  expect(getApples()).toBeGreaterThanOrEqual(11)
})</pre>
</div>
<h2 id="tobelessthan" tabindex="-1">toBeLessThan </h2>
<ul><li>
<strong>Type:</strong> <code>(n: number | bigint) =&gt; Awaitable&lt;void&gt;</code>
</li></ul>
<p><code>toBeLessThan</code> asserts if actual value is less than received one. Equal values will fail the test.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">import { expect, test } from 'vitest'
import { getApples } from './stocks.js'

test('have less then 20 apples', () =&gt; {
  expect(getApples()).toBeLessThan(20)
})</pre>
</div>
<h2 id="tobelessthanorequal" tabindex="-1">toBeLessThanOrEqual </h2>
<ul><li>
<strong>Type:</strong> <code>(n: number | bigint) =&gt; Awaitable&lt;void&gt;</code>
</li></ul>
<p><code>toBeLessThanOrEqual</code> asserts if actual value is less than received one or equal to it.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">import { expect, test } from 'vitest'
import { getApples } from './stocks.js'

test('have 11 apples or less', () =&gt; {
  expect(getApples()).toBeLessThanOrEqual(11)
})</pre>
</div>
<h2 id="toequal" tabindex="-1">toEqual </h2>
<ul><li>
<strong>Type:</strong> <code>(received: any) =&gt; Awaitable&lt;void&gt;</code>
</li></ul>
<p><code>toEqual</code> asserts if actual value is equal to received one or has the same structure, if it is an object (compares them recursively). You can see the difference between <code>toEqual</code> and <a href="#tobe"><code>toBe</code></a> in this example:</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">import { expect, test } from 'vitest'

const stockBill = {
  type: 'apples',
  count: 13,
}

const stockMary = {
  type: 'apples',
  count: 13,
}

test('stocks have the same properties', () =&gt; {
  expect(stockBill).toEqual(stockMary)
})

test('stocks are not the same', () =&gt; {
  expect(stockBill).not.toBe(stockMary)
})</pre>
</div>
<div class="warning custom-block">
<strong class="custom-block-title">WARNING</strong><p>A <em>deep equality</em> will not be performed for <code>Error</code> objects. To test if something was thrown, use <a href="#tothrowerror"><code>toThrowError</code></a> assertion.</p>
</div>
<h2 id="tostrictequal" tabindex="-1">toStrictEqual </h2>
<ul><li>
<strong>Type:</strong> <code>(received: any) =&gt; Awaitable&lt;void&gt;</code>
</li></ul>
<p><code>toStrictEqual</code> asserts if the actual value is equal to the received one or has the same structure if it is an object (compares them recursively), and of the same type.</p>
<p>Differences from <a href="#toequal"><code>.toEqual</code></a>:</p>
<ul>
<li>Keys with <code>undefined</code> properties are checked. e.g. <code>{a: undefined, b: 2}</code> does not match <code>{b: 2}</code> when using <code>.toStrictEqual</code>.</li>
<li>Array sparseness is checked. e.g. <code>[, 1]</code> does not match <code>[undefined, 1]</code> when using <code>.toStrictEqual</code>.</li>
<li>Object types are checked to be equal. e.g. A class instance with fields <code>a</code> and<code> b</code> will not equal a literal object with fields <code>a</code> and <code>b</code>.</li>
</ul>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">import { expect, test } from 'vitest'

class Stock {
  constructor(type) {
    this.type = type
  }
}

test('structurally the same, but semantically different', () =&gt; {
  expect(new Stock('apples')).toEqual({ type: 'apples' })
  expect(new Stock('apples')).not.toStrictEqual({ type: 'apples' })
})</pre>
</div>
<h2 id="tocontain" tabindex="-1">toContain </h2>
<ul><li>
<strong>Type:</strong> <code>(received: string) =&gt; Awaitable&lt;void&gt;</code>
</li></ul>
<p><code>toContain</code> asserts if the actual value is in an array. <code>toContain</code> can also check whether a string is a substring of another string. Since Vitest 1.0, if you are running tests in a browser-like environment, this assertion can also check if class is contained in a <code>classList</code>, or an element is inside another one.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">import { expect, test } from 'vitest'
import { getAllFruits } from './stocks.js'

test('the fruit list contains orange', () =&gt; {
  expect(getAllFruits()).toContain('orange')

  const element = document.querySelector('#el')
  // element has a class
  expect(element.classList).toContain('flex')
  // element is inside another one
  expect(document.querySelector('#wrapper')).toContain(element)
})</pre>
</div>
<h2 id="tocontainequal" tabindex="-1">toContainEqual </h2>
<ul><li>
<strong>Type:</strong> <code>(received: any) =&gt; Awaitable&lt;void&gt;</code>
</li></ul>
<p><code>toContainEqual</code> asserts if an item with a specific structure and values is contained in an array. It works like <a href="#toequal"><code>toEqual</code></a> inside for each element.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">import { expect, test } from 'vitest'
import { getFruitStock } from './stocks.js'

test('apple available', () =&gt; {
  expect(getFruitStock()).toContainEqual({ fruit: 'apple', count: 5 })
})</pre>
</div>
<h2 id="tohavelength" tabindex="-1">toHaveLength </h2>
<ul><li>
<strong>Type:</strong> <code>(received: number) =&gt; Awaitable&lt;void&gt;</code>
</li></ul>
<p><code>toHaveLength</code> asserts if an object has a <code>.length</code> property and it is set to a certain numeric value.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">import { expect, test } from 'vitest'

test('toHaveLength', () =&gt; {
  expect('abc').toHaveLength(3)
  expect([1, 2, 3]).toHaveLength(3)

  expect('').not.toHaveLength(3) // doesn't have .length of 3
  expect({ length: 3 }).toHaveLength(3)
})</pre>
</div>
<h2 id="tohaveproperty" tabindex="-1">toHaveProperty </h2>
<ul><li>
<strong>Type:</strong> <code>(key: any, received?: any) =&gt; Awaitable&lt;void&gt;</code>
</li></ul>
<p><code>toHaveProperty</code> asserts if a property at provided reference <code>key</code> exists for an object.</p>
<p>You can provide an optional value argument also known as deep equality, like the <code>toEqual</code> matcher to compare the received property value.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">import { expect, test } from 'vitest'

const invoice = {
  'isActive': true,
  'P.O': '12345',
  'customer': {
    first_name: 'John',
    last_name: 'Doe',
    location: 'China',
  },
  'total_amount': 5000,
  'items': [
    {
      type: 'apples',
      quantity: 10,
    },
    {
      type: 'oranges',
      quantity: 5,
    },
  ],
}

test('John Doe Invoice', () =&gt; {
  expect(invoice).toHaveProperty('isActive') // assert that the key exists
  expect(invoice).toHaveProperty('total_amount', 5000) // assert that the key exists and the value is equal

  expect(invoice).not.toHaveProperty('account') // assert that this key does not exist

  // Deep referencing using dot notation
  expect(invoice).toHaveProperty('customer.first_name')
  expect(invoice).toHaveProperty('customer.last_name', 'Doe')
  expect(invoice).not.toHaveProperty('customer.location', 'India')

  // Deep referencing using an array containing the key
  expect(invoice).toHaveProperty('items[0].type', 'apples')
  expect(invoice).toHaveProperty('items.0.type', 'apples') // dot notation also works

  // Deep referencing using an array containing the keyPath
  expect(invoice).toHaveProperty(['items', 0, 'type'], 'apples')
  expect(invoice).toHaveProperty(['items', '0', 'type'], 'apples') // string notation also works

  // Wrap your key in an array to avoid the key from being parsed as a deep reference
  expect(invoice).toHaveProperty(['P.O'], '12345')
})</pre>
</div>
<h2 id="tomatch" tabindex="-1">toMatch </h2>
<ul><li>
<strong>Type:</strong> <code>(received: string | regexp) =&gt; Awaitable&lt;void&gt;</code>
</li></ul>
<p><code>toMatch</code> asserts if a string matches a regular expression or a string.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">import { expect, test } from 'vitest'

test('top fruits', () =&gt; {
  expect('top fruits include apple, orange and grape').toMatch(/apple/)
  expect('applefruits').toMatch('fruit') // toMatch also accepts a string
})</pre>
</div>
<div class="tip custom-block">
<strong class="custom-block-title">TIP</strong><p>If the value in the error message is too truncated, you can increase <a href="../config/index.html#chaiconfig-truncatethreshold">chaiConfig.truncateThreshold</a> in your config file.</p>
</div>
<h2 id="tomatchobject" tabindex="-1">toMatchObject </h2>
<ul><li>
<strong>Type:</strong> <code>(received: object | array) =&gt; Awaitable&lt;void&gt;</code>
</li></ul>
<p><code>toMatchObject</code> asserts if an object matches a subset of the properties of an object.</p>
<p>You can also pass an array of objects. This is useful if you want to check that two arrays match in their number of elements, as opposed to <code>arrayContaining</code>, which allows for extra elements in the received array.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">import { expect, test } from 'vitest'

const johnInvoice = {
  isActive: true,
  customer: {
    first_name: 'John',
    last_name: 'Doe',
    location: 'China',
  },
  total_amount: 5000,
  items: [
    {
      type: 'apples',
      quantity: 10,
    },
    {
      type: 'oranges',
      quantity: 5,
    },
  ],
}

const johnDetails = {
  customer: {
    first_name: 'John',
    last_name: 'Doe',
    location: 'China',
  },
}

test('invoice has john personal details', () =&gt; {
  expect(johnInvoice).toMatchObject(johnDetails)
})

test('the number of elements must match exactly', () =&gt; {
  // Assert that an array of object matches
  expect([{ foo: 'bar' }, { baz: 1 }]).toMatchObject([
    { foo: 'bar' },
    { baz: 1 },
  ])
})</pre>
</div>
<h2 id="tothrowerror" tabindex="-1">toThrowError </h2>
<ul>
<li><p><strong>Type:</strong> <code>(received: any) =&gt; Awaitable&lt;void&gt;</code></p></li>
<li><p><strong>Alias:</strong> <code>toThrow</code></p></li>
</ul>
<p><code>toThrowError</code> asserts if a function throws an error when it is called.</p>
<p>You can provide an optional argument to test that a specific error is thrown:</p>
<ul>
<li>regular expression: error message matches the pattern</li>
<li>string: error message includes the substring</li>
</ul>
<div class="tip custom-block">
<strong class="custom-block-title">TIP</strong><p>You must wrap the code in a function, otherwise the error will not be caught, and test will fail.</p>
</div>
<p>For example, if we want to test that <code>getFruitStock('pineapples')</code> throws, we could write:</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">import { expect, test } from 'vitest'

function getFruitStock(type) {
  if (type === 'pineapples')
    throw new Error('Pineapples are not in stock')

  // Do some other stuff
}

test('throws on pineapples', () =&gt; {
  // Test that the error message says "stock" somewhere: these are equivalent
  expect(() =&gt; getFruitStock('pineapples')).toThrowError(/stock/)
  expect(() =&gt; getFruitStock('pineapples')).toThrowError('stock')

  // Test the exact error message
  expect(() =&gt; getFruitStock('pineapples')).toThrowError(
    /^Pineapples are not in stock$/,
  )
})</pre>
</div>
<div class="tip custom-block">
<strong class="custom-block-title">TIP</strong><p>To test async functions, use in combination with <a href="#rejects">rejects</a>.</p>
<div class="language-js vp-adaptive-theme">
<span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">function getAsyncFruitStock() {
  return Promise.reject(new Error('empty'))
}

test('throws on pineapples', async () =&gt; {
  await expect(() =&gt; getAsyncFruitStock()).rejects.toThrowError('empty')
})</pre>
</div>
</div>
<h2 id="tomatchsnapshot" tabindex="-1">toMatchSnapshot </h2>
<ul><li>
<strong>Type:</strong> <code>&lt;T&gt;(shape?: Partial&lt;T&gt; | string, message?: string) =&gt; void</code>
</li></ul>
<p>This ensures that a value matches the most recent snapshot.</p>
<p>You can provide an optional <code>hint</code> string argument that is appended to the test name. Although Vitest always appends a number at the end of a snapshot name, short descriptive hints might be more useful than numbers to differentiate multiple snapshots in a single it or test block. Vitest sorts snapshots by name in the corresponding <code>.snap</code> file.</p>
<div class="tip custom-block">
<strong class="custom-block-title">TIP</strong><p>When snapshot mismatch and causing the test failing, if the mismatch is expected, you can press <code>u</code> key to update the snapshot for once. Or you can pass <code>-u</code> or <code>--update</code> CLI options to make Vitest always update the tests.</p>
</div>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">import { expect, test } from 'vitest'

test('matches snapshot', () =&gt; {
  const data = { foo: new Set(['bar', 'snapshot']) }
  expect(data).toMatchSnapshot()
})</pre>
</div>
<p>You can also provide a shape of an object, if you are testing just a shape of an object, and don't need it to be 100% compatible:</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">import { expect, test } from 'vitest'

test('matches snapshot', () =&gt; {
  const data = { foo: new Set(['bar', 'snapshot']) }
  expect(data).toMatchSnapshot({ foo: expect.any(Set) })
})</pre>
</div>
<h2 id="tomatchinlinesnapshot" tabindex="-1">toMatchInlineSnapshot </h2>
<ul><li>
<strong>Type:</strong> <code>&lt;T&gt;(shape?: Partial&lt;T&gt; | string, snapshot?: string, message?: string) =&gt; void</code>
</li></ul>
<p>This ensures that a value matches the most recent snapshot.</p>
<p>Vitest adds and updates the inlineSnapshot string argument to the matcher in the test file (instead of an external <code>.snap</code> file).</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">import { expect, test } from 'vitest'

test('matches inline snapshot', () =&gt; {
  const data = { foo: new Set(['bar', 'snapshot']) }
  // Vitest will update following content when updating the snapshot
  expect(data).toMatchInlineSnapshot(`
    {
      "foo": Set {
        "bar",
        "snapshot",
      },
    }
  `)
})</pre>
</div>
<p>You can also provide a shape of an object, if you are testing just a shape of an object, and don't need it to be 100% compatible:</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">import { expect, test } from 'vitest'

test('matches snapshot', () =&gt; {
  const data = { foo: new Set(['bar', 'snapshot']) }
  expect(data).toMatchInlineSnapshot(
    { foo: expect.any(Set) },
    `
    {
      "foo": Any&lt;Set&gt;,
    }
  `
  )
})</pre>
</div>
<h2 id="tomatchfilesnapshot-0-30-0" tabindex="-1">toMatchFileSnapshot <span class="VPBadge info">0.30.0+</span> </h2>
<ul><li>
<strong>Type:</strong> <code>&lt;T&gt;(filepath: string, message?: string) =&gt; Promise&lt;void&gt;</code>
</li></ul>
<p>Compare or update the snapshot with the content of a file explicitly specified (instead of the <code>.snap</code> file).</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">import { expect, it } from 'vitest'

it('render basic', async () =&gt; {
  const result = renderHTML(h('div', { class: 'foo' }))
  await expect(result).toMatchFileSnapshot('./test/basic.output.html')
})</pre>
</div>
<p>Note that since file system operation is async, you need to use <code>await</code> with <code>toMatchFileSnapshot()</code>.</p>
<h2 id="tothrowerrormatchingsnapshot" tabindex="-1">toThrowErrorMatchingSnapshot </h2>
<ul><li>
<strong>Type:</strong> <code>(message?: string) =&gt; void</code>
</li></ul>
<p>The same as <a href="#tomatchsnapshot"><code>toMatchSnapshot</code></a>, but expects the same value as <a href="#tothrowerror"><code>toThrowError</code></a>.</p>
<h2 id="tothrowerrormatchinginlinesnapshot" tabindex="-1">toThrowErrorMatchingInlineSnapshot </h2>
<ul><li>
<strong>Type:</strong> <code>(snapshot?: string, message?: string) =&gt; void</code>
</li></ul>
<p>The same as <a href="#tomatchinlinesnapshot"><code>toMatchInlineSnapshot</code></a>, but expects the same value as <a href="#tothrowerror"><code>toThrowError</code></a>.</p>
<h2 id="tohavebeencalled" tabindex="-1">toHaveBeenCalled </h2>
<ul><li>
<strong>Type:</strong> <code>() =&gt; Awaitable&lt;void&gt;</code>
</li></ul>
<p>This assertion is useful for testing that a function has been called. Requires a spy function to be passed to <code>expect</code>.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">import { expect, test, vi } from 'vitest'

const market = {
  buy(subject: string, amount: number) {
    // ...
  },
}

test('spy function', () =&gt; {
  const buySpy = vi.spyOn(market, 'buy')

  expect(buySpy).not.toHaveBeenCalled()

  market.buy('apples', 10)

  expect(buySpy).toHaveBeenCalled()
})</pre>
</div>
<h2 id="tohavebeencalledtimes" tabindex="-1">toHaveBeenCalledTimes </h2>
<ul><li>
<strong>Type</strong>: <code>(amount: number) =&gt; Awaitable&lt;void&gt;</code>
</li></ul>
<p>This assertion checks if a function was called a certain amount of times. Requires a spy function to be passed to <code>expect</code>.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">import { expect, test, vi } from 'vitest'

const market = {
  buy(subject: string, amount: number) {
    // ...
  },
}

test('spy function called two times', () =&gt; {
  const buySpy = vi.spyOn(market, 'buy')

  market.buy('apples', 10)
  market.buy('apples', 20)

  expect(buySpy).toHaveBeenCalledTimes(2)
})</pre>
</div>
<h2 id="tohavebeencalledwith" tabindex="-1">toHaveBeenCalledWith </h2>
<ul><li>
<strong>Type</strong>: <code>(...args: any[]) =&gt; Awaitable&lt;void&gt;</code>
</li></ul>
<p>This assertion checks if a function was called at least once with certain parameters. Requires a spy function to be passed to <code>expect</code>.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">import { expect, test, vi } from 'vitest'

const market = {
  buy(subject: string, amount: number) {
    // ...
  },
}

test('spy function', () =&gt; {
  const buySpy = vi.spyOn(market, 'buy')

  market.buy('apples', 10)
  market.buy('apples', 20)

  expect(buySpy).toHaveBeenCalledWith('apples', 10)
  expect(buySpy).toHaveBeenCalledWith('apples', 20)
})</pre>
</div>
<h2 id="tohavebeenlastcalledwith" tabindex="-1">toHaveBeenLastCalledWith </h2>
<ul><li>
<strong>Type</strong>: <code>(...args: any[]) =&gt; Awaitable&lt;void&gt;</code>
</li></ul>
<p>This assertion checks if a function was called with certain parameters at it's last invocation. Requires a spy function to be passed to <code>expect</code>.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">import { expect, test, vi } from 'vitest'

const market = {
  buy(subject: string, amount: number) {
    // ...
  },
}

test('spy function', () =&gt; {
  const buySpy = vi.spyOn(market, 'buy')

  market.buy('apples', 10)
  market.buy('apples', 20)

  expect(buySpy).not.toHaveBeenLastCalledWith('apples', 10)
  expect(buySpy).toHaveBeenLastCalledWith('apples', 20)
})</pre>
</div>
<h2 id="tohavebeennthcalledwith" tabindex="-1">toHaveBeenNthCalledWith </h2>
<ul><li>
<strong>Type</strong>: <code>(time: number, ...args: any[]) =&gt; Awaitable&lt;void&gt;</code>
</li></ul>
<p>This assertion checks if a function was called with certain parameters at the certain time. The count starts at 1. So, to check the second entry, you would write <code>.toHaveBeenNthCalledWith(2, ...)</code>.</p>
<p>Requires a spy function to be passed to <code>expect</code>.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">import { expect, test, vi } from 'vitest'

const market = {
  buy(subject: string, amount: number) {
    // ...
  },
}

test('first call of spy function called with right params', () =&gt; {
  const buySpy = vi.spyOn(market, 'buy')

  market.buy('apples', 10)
  market.buy('apples', 20)

  expect(buySpy).toHaveBeenNthCalledWith(1, 'apples', 10)
})</pre>
</div>
<h2 id="tohavereturned" tabindex="-1">toHaveReturned </h2>
<ul><li>
<strong>Type</strong>: <code>() =&gt; Awaitable&lt;void&gt;</code>
</li></ul>
<p>This assertion checks if a function has successfully returned a value at least once (i.e., did not throw an error). Requires a spy function to be passed to <code>expect</code>.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">import { expect, test, vi } from 'vitest'

function getApplesPrice(amount: number) {
  const PRICE = 10
  return amount * PRICE
}

test('spy function returned a value', () =&gt; {
  const getPriceSpy = vi.fn(getApplesPrice)

  const price = getPriceSpy(10)

  expect(price).toBe(100)
  expect(getPriceSpy).toHaveReturned()
})</pre>
</div>
<h2 id="tohavereturnedtimes" tabindex="-1">toHaveReturnedTimes </h2>
<ul><li>
<strong>Type</strong>: <code>(amount: number) =&gt; Awaitable&lt;void&gt;</code>
</li></ul>
<p>This assertion checks if a function has successfully returned a value exact amount of times (i.e., did not throw an error). Requires a spy function to be passed to <code>expect</code>.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">import { expect, test, vi } from 'vitest'

test('spy function returns a value two times', () =&gt; {
  const sell = vi.fn((product: string) =&gt; ({ product }))

  sell('apples')
  sell('bananas')

  expect(sell).toHaveReturnedTimes(2)
})</pre>
</div>
<h2 id="tohavereturnedwith" tabindex="-1">toHaveReturnedWith </h2>
<ul><li>
<strong>Type</strong>: <code>(returnValue: any) =&gt; Awaitable&lt;void&gt;</code>
</li></ul>
<p>You can call this assertion to check if a function has successfully returned a value with certain parameters at least once. Requires a spy function to be passed to <code>expect</code>.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">import { expect, test, vi } from 'vitest'

test('spy function returns a product', () =&gt; {
  const sell = vi.fn((product: string) =&gt; ({ product }))

  sell('apples')

  expect(sell).toHaveReturnedWith({ product: 'apples' })
})</pre>
</div>
<h2 id="tohavelastreturnedwith" tabindex="-1">toHaveLastReturnedWith </h2>
<ul><li>
<strong>Type</strong>: <code>(returnValue: any) =&gt; Awaitable&lt;void&gt;</code>
</li></ul>
<p>You can call this assertion to check if a function has successfully returned a value with certain parameters on it's last invoking. Requires a spy function to be passed to <code>expect</code>.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">import { expect, test, vi } from 'vitest'

test('spy function returns bananas on a last call', () =&gt; {
  const sell = vi.fn((product: string) =&gt; ({ product }))

  sell('apples')
  sell('bananas')

  expect(sell).toHaveLastReturnedWith({ product: 'bananas' })
})</pre>
</div>
<h2 id="tohaventhreturnedwith" tabindex="-1">toHaveNthReturnedWith </h2>
<ul><li>
<strong>Type</strong>: <code>(time: number, returnValue: any) =&gt; Awaitable&lt;void&gt;</code>
</li></ul>
<p>You can call this assertion to check if a function has successfully returned a value with certain parameters on a certain call. Requires a spy function to be passed to <code>expect</code>.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">import { expect, test, vi } from 'vitest'

test('spy function returns bananas on second call', () =&gt; {
  const sell = vi.fn((product: string) =&gt; ({ product }))

  sell('apples')
  sell('bananas')

  expect(sell).toHaveNthReturnedWith(2, { product: 'bananas' })
})</pre>
</div>
<h2 id="tosatisfy" tabindex="-1">toSatisfy </h2>
<ul><li>
<strong>Type:</strong> <code>(predicate: (value: any) =&gt; boolean) =&gt; Awaitable&lt;void&gt;</code>
</li></ul>
<p>This assertion checks if a value satisfies a certain predicate.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">describe('toSatisfy()', () =&gt; {
  const isOdd = (value: number) =&gt; value % 2 !== 0

  it('pass with 0', () =&gt; {
    expect(1).toSatisfy(isOdd)
  })

  it('pass with negotiation', () =&gt; {
    expect(2).not.toSatisfy(isOdd)
  })
})</pre>
</div>
<h2 id="resolves" tabindex="-1">resolves </h2>
<ul><li>
<strong>Type:</strong> <code>Promisify&lt;Assertions&gt;</code>
</li></ul>
<p><code>resolves</code> is intended to remove boilerplate when asserting asynchronous code. Use it to unwrap value from the pending promise and assert its value with usual assertions. If the promise rejects, the assertion will fail.</p>
<p>It returns the same <code>Assertions</code> object, but all matchers now return <code>Promise</code>, so you would need to <code>await</code> it. Also works with <code>chai</code> assertions.</p>
<p>For example, if you have a function, that makes an API call and returns some data, you may use this code to assert its return value:</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">import { expect, test } from 'vitest'

async function buyApples() {
  return fetch('/buy/apples').then(r =&gt; r.json())
}

test('buyApples returns new stock id', async () =&gt; {
  // toEqual returns a promise now, so you HAVE to await it
  await expect(buyApples()).resolves.toEqual({ id: 1 }) // jest API
  await expect(buyApples()).resolves.to.equal({ id: 1 }) // chai API
})</pre>
</div>
<div class="warning custom-block">
<strong class="custom-block-title">WARNING</strong><p>If the assertion is not awaited, then you will have a false-positive test that will pass every time. To make sure that assertions are actually called, you may use <a href="#expect-assertions"><code>expect.assertions(number)</code></a>.</p>
</div>
<h2 id="rejects" tabindex="-1">rejects </h2>
<ul><li>
<strong>Type:</strong> <code>Promisify&lt;Assertions&gt;</code>
</li></ul>
<p><code>rejects</code> is intended to remove boilerplate when asserting asynchronous code. Use it to unwrap reason why the promise was rejected, and assert its value with usual assertions. If the promise successfully resolves, the assertion will fail.</p>
<p>It returns the same <code>Assertions</code> object, but all matchers now return <code>Promise</code>, so you would need to <code>await</code> it. Also works with <code>chai</code> assertions.</p>
<p>For example, if you have a function that fails when you call it, you may use this code to assert the reason:</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">import { expect, test } from 'vitest'

async function buyApples(id) {
  if (!id)
    throw new Error('no id')
}

test('buyApples throws an error when no id provided', async () =&gt; {
  // toThrow returns a promise now, so you HAVE to await it
  await expect(buyApples()).rejects.toThrow('no id')
})</pre>
</div>
<div class="warning custom-block">
<strong class="custom-block-title">WARNING</strong><p>If the assertion is not awaited, then you will have a false-positive test that will pass every time. To make sure that assertions were actually called, you can use <a href="#expect-assertions"><code>expect.assertions(number)</code></a>.</p>
</div>
<h2 id="expect-assertions" tabindex="-1">expect.assertions </h2>
<ul><li>
<strong>Type:</strong> <code>(count: number) =&gt; void</code>
</li></ul>
<p>After the test has passed or failed verify that a certain number of assertions was called during a test. A useful case would be to check if an asynchronous code was called.</p>
<p>For example, if we have a function that asynchronously calls two matchers, we can assert that they were actually called.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">import { expect, test } from 'vitest'

async function doAsync(...cbs) {
  await Promise.all(
    cbs.map((cb, index) =&gt; cb({ index })),
  )
}

test('all assertions are called', async () =&gt; {
  expect.assertions(2)
  function callback1(data) {
    expect(data).toBeTruthy()
  }
  function callback2(data) {
    expect(data).toBeTruthy()
  }

  await doAsync(callback1, callback2)
})</pre>
</div>
<div class="warning custom-block">
<strong class="custom-block-title">WARNING</strong><p>When using <code>assertions</code> with async concurrent tests, <code>expect</code> from the local <a href="../guide/test-context.html">Test Context</a> must be used to ensure the right test is detected.</p>
</div>
<h2 id="expect-hasassertions" tabindex="-1">expect.hasAssertions </h2>
<ul><li>
<strong>Type:</strong> <code>() =&gt; void</code>
</li></ul>
<p>After the test has passed or failed verify that at least one assertion was called during a test. A useful case would be to check if an asynchronous code was called.</p>
<p>For example, if you have a code that calls a callback, we can make an assertion inside a callback, but the test will always pass if we don't check if an assertion was called.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">import { expect, test } from 'vitest'
import { db } from './db.js'

const cbs = []

function onSelect(cb) {
  cbs.push(cb)
}

// after selecting from db, we call all callbacks
function select(id) {
  return db.select({ id }).then((data) =&gt; {
    return Promise.all(
      cbs.map(cb =&gt; cb(data)),
    )
  })
}

test('callback was called', async () =&gt; {
  expect.hasAssertions()
  onSelect((data) =&gt; {
    // should be called on select
    expect(data).toBeTruthy()
  })
  // if not awaited, test will fail
  // if you don't have expect.hasAssertions(), test will pass
  await select(3)
})</pre>
</div>
<h2 id="expect-unreachable" tabindex="-1">expect.unreachable </h2>
<ul><li>
<strong>Type:</strong> <code>(message?: string) =&gt; never</code>
</li></ul>
<p>This method is used to asserting that a line should never be reached.</p>
<p>For example, if we want to test that <code>build()</code> throws due to receiving directories having no <code>src</code> folder, and also handle each error separately, we could do this:</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">import { expect, test } from 'vitest'

async function build(dir) {
  if (dir.includes('no-src'))
    throw new Error(`${dir}/src does not exist`)
}

const errorDirs = [
  'no-src-folder',
  // ...
]

test.each(errorDirs)('build fails with "%s"', async (dir) =&gt; {
  try {
    await build(dir)
    expect.unreachable('Should not pass build')
  }
  catch (err: any) {
    expect(err).toBeInstanceOf(Error)
    expect(err.stack).toContain('build')

    switch (dir) {
      case 'no-src-folder':
        expect(err.message).toBe(`${dir}/src does not exist`)
        break
      default:
        // to exhaust all error tests
        expect.unreachable('All error test must be handled')
        break
    }
  }
})</pre>
</div>
<h2 id="expect-anything" tabindex="-1">expect.anything </h2>
<ul><li>
<strong>Type:</strong> <code>() =&gt; any</code>
</li></ul>
<p>This asymmetric matcher, when used with equality check, will always return <code>true</code>. Useful, if you just want to be sure that the property exist.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">import { expect, test } from 'vitest'

test('object has "apples" key', () =&gt; {
  expect({ apples: 22 }).toEqual({ apples: expect.anything() })
})</pre>
</div>
<h2 id="expect-any" tabindex="-1">expect.any </h2>
<ul><li>
<strong>Type:</strong> <code>(constructor: unknown) =&gt; any</code>
</li></ul>
<p>This asymmetric matcher, when used with an equality check, will return <code>true</code> only if the value is an instance of a specified constructor. Useful, if you have a value that is generated each time, and you only want to know that it exists with a proper type.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">import { expect, test } from 'vitest'
import { generateId } from './generators.js'

test('"id" is a number', () =&gt; {
  expect({ id: generateId() }).toEqual({ id: expect.any(Number) })
})</pre>
</div>
<h2 id="expect-closeto-1-0-0" tabindex="-1">expect.closeTo <span class="VPBadge info">1.0.0+</span> </h2>
<ul><li>
<strong>Type:</strong> <code>(expected: any, precision?: number) =&gt; any</code>
</li></ul>
<p><code>expect.closeTo</code> is useful when comparing floating point numbers in object properties or array item. If you need to compare a number, please use <code>.toBeCloseTo</code> instead.</p>
<p>The optional <code>numDigits</code> argument limits the number of digits to check <strong>after</strong> the decimal point. For the default value <code>2</code>, the test criterion is <code>Math.abs(expected - received) &lt; 0.005 (that is, 10 ** -2 / 2)</code>.</p>
<p>For example, this test passes with a precision of 5 digits:</p>
<div class="language-js vp-adaptive-theme">
<span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">test('compare float in object properties', () =&gt; {
  expect({
    title: '0.1 + 0.2',
    sum: 0.1 + 0.2,
  }).toEqual({
    title: '0.1 + 0.2',
    sum: expect.closeTo(0.3, 5),
  })
})</pre>
</div>
<h2 id="expect-arraycontaining" tabindex="-1">expect.arrayContaining </h2>
<ul><li>
<strong>Type:</strong> <code>&lt;T&gt;(expected: T[]) =&gt; any</code>
</li></ul>
<p>When used with an equality check, this asymmetric matcher will return <code>true</code> if the value is an array and contains specified items.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">import { expect, test } from 'vitest'

test('basket includes fuji', () =&gt; {
  const basket = {
    varieties: [
      'Empire',
      'Fuji',
      'Gala',
    ],
    count: 3
  }
  expect(basket).toEqual({
    count: 3,
    varieties: expect.arrayContaining(['Fuji'])
  })
})</pre>
</div>
<div class="tip custom-block">
<strong class="custom-block-title">TIP</strong><p>You can use <code>expect.not</code> with this matcher to negate the expected value.</p>
</div>
<h2 id="expect-objectcontaining" tabindex="-1">expect.objectContaining </h2>
<ul><li>
<strong>Type:</strong> <code>(expected: any) =&gt; any</code>
</li></ul>
<p>When used with an equality check, this asymmetric matcher will return <code>true</code> if the value has a similar shape.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">import { expect, test } from 'vitest'

test('basket has empire apples', () =&gt; {
  const basket = {
    varieties: [
      {
        name: 'Empire',
        count: 1,
      }
    ],
  }
  expect(basket).toEqual({
    varieties: [
      expect.objectContaining({ name: 'Empire' }),
    ]
  })
})</pre>
</div>
<div class="tip custom-block">
<strong class="custom-block-title">TIP</strong><p>You can use <code>expect.not</code> with this matcher to negate the expected value.</p>
</div>
<h2 id="expect-stringcontaining" tabindex="-1">expect.stringContaining </h2>
<ul><li>
<strong>Type:</strong> <code>(expected: any) =&gt; any</code>
</li></ul>
<p>When used with an equality check, this asymmetric matcher will return <code>true</code> if the value is a string and contains a specified substring.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">import { expect, test } from 'vitest'

test('variety has "Emp" in its name', () =&gt; {
  const variety = {
    name: 'Empire',
    count: 1,
  }
  expect(variety).toEqual({
    name: expect.stringContaining('Emp'),
    count: 1,
  })
})</pre>
</div>
<div class="tip custom-block">
<strong class="custom-block-title">TIP</strong><p>You can use <code>expect.not</code> with this matcher to negate the expected value.</p>
</div>
<h2 id="expect-stringmatching" tabindex="-1">expect.stringMatching </h2>
<ul><li>
<strong>Type:</strong> <code>(expected: any) =&gt; any</code>
</li></ul>
<p>When used with an equality check, this asymmetric matcher will return <code>true</code> if the value is a string and contains a specified substring or if the string matches a regular expression.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">import { expect, test } from 'vitest'

test('variety ends with "re"', () =&gt; {
  const variety = {
    name: 'Empire',
    count: 1,
  }
  expect(variety).toEqual({
    name: expect.stringMatching(/re$/),
    count: 1,
  })
})</pre>
</div>
<div class="tip custom-block">
<strong class="custom-block-title">TIP</strong><p>You can use <code>expect.not</code> with this matcher to negate the expected value.</p>
</div>
<h2 id="expect-addsnapshotserializer" tabindex="-1">expect.addSnapshotSerializer </h2>
<ul><li>
<strong>Type:</strong> <code>(plugin: PrettyFormatPlugin) =&gt; void</code>
</li></ul>
<p>This method adds custom serializers that are called when creating a snapshot. This is an advanced feature - if you want to know more, please read a <a href="../guide/snapshot.html#custom-serializer">guide on custom serializers</a>.</p>
<p>If you are adding custom serializers, you should call this method inside <a href="../config/index.html#setupfiles"><code>setupFiles</code></a>. This will affect every snapshot.</p>
<div class="tip custom-block">
<strong class="custom-block-title">TIP</strong><p>If you previously used Vue CLI with Jest, you might want to install <a href="https://www.npmjs.com/package/jest-serializer-vue" target="_blank" rel="noreferrer">jest-serializer-vue</a>. Otherwise, your snapshots will be wrapped in a string, which cases <code>"</code> to be escaped.</p>
</div>
<h2 id="expect-extend" tabindex="-1">expect.extend </h2>
<ul><li>
<strong>Type:</strong> <code>(matchers: MatchersObject) =&gt; void</code>
</li></ul>
<p>You can extend default matchers with your own. This function is used to extend the matchers object with custom matchers.</p>
<p>When you define matchers that way, you also create asymmetric matchers that can be used like <code>expect.stringContaining</code>.</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">import { expect, test } from 'vitest'

test('custom matchers', () =&gt; {
  expect.extend({
    toBeFoo: (received, expected) =&gt; {
      if (received !== 'foo') {
        return {
          message: () =&gt; `expected ${received} to be foo`,
          pass: false,
        }
      }
    },
  })

  expect('foo').toBeFoo()
  expect({ foo: 'foo' }).toEqual({ foo: expect.toBeFoo() })
})</pre>
</div>
<div class="tip custom-block">
<strong class="custom-block-title">TIP</strong><p>If you want your matchers to appear in every test, you should call this method inside <a href="../config/index.html#setupFiles"><code>setupFiles</code></a>.</p>
</div>
<p>This function is compatible with Jest's <code>expect.extend</code>, so any library that uses it to create custom matchers will work with Vitest.</p>
<p>If you are using TypeScript, since Vitest 0.31.0 you can extend default <code>Assertion</code> interface in an ambient declaration file (e.g: <code>vitest.d.ts</code>) with the code below:</p>
<div class="language-ts vp-adaptive-theme">
<span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" data-language="javascript">interface CustomMatchers&lt;R = unknown&gt; {
  toBeFoo(): R
}

declare module 'vitest' {
  interface Assertion&lt;T = any&gt; extends CustomMatchers&lt;T&gt; {}
  interface AsymmetricMatchersContaining extends CustomMatchers {}
}</pre>
</div>
<div class="warning custom-block">
<strong class="custom-block-title">WARNING</strong><p>Don't forget to include the ambient declaration file in your <code>tsconfig.json</code>.</p>
</div>
<div class="tip custom-block">
<strong class="custom-block-title">TIP</strong><p>If you want to know more, checkout <a href="../guide/extending-matchers.html">guide on extending matchers</a>.</p>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2021-Present Anthony Fu<br>&copy; 2021-Present Matias Capeletto<br>Licensed under the MIT License.<br>
    <a href="https://vitest.dev/api/expect" class="_attribution-link">https://vitest.dev/api/expect</a>
  </p>
</div>
