<h1> Context</h1>
<p>package <a href="index.html">eval.vm</a></p> <p class="availability"><em>Available on macro</em></p>

<h2 class="section">Static methods</h2>
<h3 class="anchor" id="addBreakpoint"><code><span class="label label-static">static</span><a href="#addBreakpoint">addBreakpoint</a>(<span style="white-space:nowrap">file:<a class="type" title="String - The basic String class." href="https://api.haxe.org/String.html">String</a>,</span> <span style="white-space:nowrap">line:<a class="type" title="Int - The standard Int type." href="https://api.haxe.org/Int.html">Int</a></span>):<a class="type" title="Void - The standard Void type." href="https://api.haxe.org/Void.html">Void</a></code></h3>

<h3 class="anchor" id="breakHere"><code><span class="label label-static">static</span><a href="#breakHere">breakHere</a>():<a class="type" title="Void - The standard Void type." href="https://api.haxe.org/Void.html">Void</a></code></h3>

<h3 class="anchor" id="callMacroApi"><code><span class="label label-static">static</span><a href="#callMacroApi">callMacroApi</a>(<span style="white-space:nowrap">s:<a class="type" title="String - The basic String class." href="https://api.haxe.org/String.html">String</a></span>):<a class="type" title="Dynamic - Dynamic is a special type which is compatible with all other types." href="https://api.haxe.org/Dynamic.html">Dynamic</a></code></h3>

<h3 class="anchor" id="loadPlugin"><code><span class="label label-static">static</span><a href="#loadPlugin">loadPlugin</a>&lt;<span class="type">T</span>&gt;(<span style="white-space:nowrap">filePath:<a class="type" title="String - The basic String class." href="https://api.haxe.org/String.html">String</a></span>):<span class="type">T</span></code></h3>
<p>Loads and returns a plugin from file <code>filePath</code>.</p> <p>If Haxe is built natively, the extension automatically defaults to <code>.cmxs</code>, even if a different extension is provided in <code>filePath</code>. In bytecode mode, the default extension is <code>.cmo</code>.</p> <p>Sample plugin:</p> <pre><code class="prettyprint ocaml">open EvalValue
open EvalContext
open EvalEncode

let add_int = vfun2 (fun v1 v2 -&gt; match v1,v2 with
	| VInt32 i1,VInt32 i2 -&gt; vint32 (Int32.add i1 i2)
	| _ -&gt; exc_string "Expected int + int"
)
;;
EvalStdLib.StdContext.register ["add_int",add_int]</code></pre> <p>Usage from Haxe:</p> <pre><code class="prettyprint haxe">var module:TestPlugin = eval.vm.Context.loadPlugin("testPlugin.cmo");
trace(module.add_int(4, 3));</code></pre> <p>Plugins have to be compiled with the same OCaml version as the Haxe compiler and using the same Haxe version. If a plugin cannot be loaded, an exception of type <code><a href="https://api.haxe.org/String.html">String</a></code> is thrown.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2020 Haxe Foundation<br>Licensed under a MIT license.<br>
    <a href="https://api.haxe.org/eval/vm/Context.html" class="_attribution-link">https://api.haxe.org/eval/vm/Context.html</a>
  </p>
</div>
