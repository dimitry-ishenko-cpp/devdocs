<h1> Gc</h1>
<p>package <a href="index.html">eval.vm</a></p> <p class="availability"><em>Available on macro</em></p>
<p>Memory management control and statistics; finalised values.</p>
<h2 class="section">Static methods</h2>
<h3 class="anchor" id="allocated_bytes"><code><span class="label label-static">static</span><a href="#allocated_bytes">allocated_bytes</a>():<a class="type" title="Float - The standard Float type, this is a double-precision IEEE 64bit float." href="https://api.haxe.org/Float.html">Float</a></code></h3>
<p>Return the total number of bytes allocated since the program was started. It is returned as a float to avoid overflow problems with int on 32-bit machines.</p>
<h3 class="anchor" id="compact"><code><span class="label label-static">static</span><a href="#compact">compact</a>():<a class="type" title="Void - The standard Void type." href="https://api.haxe.org/Void.html">Void</a></code></h3>
<p>Perform a full major collection and compact the heap. Note that heap compaction is a lengthy operation.</p>
<h3 class="anchor" id="counters"><code><span class="label label-static">static</span><a href="#counters">counters</a>():{promoted_words:<a class="type" title="Float - The standard Float type, this is a double-precision IEEE 64bit float." href="https://api.haxe.org/Float.html">Float</a>, minor_words:<a class="type" title="Float - The standard Float type, this is a double-precision IEEE 64bit float." href="https://api.haxe.org/Float.html">Float</a>, major_words:<a class="type" title="Float - The standard Float type, this is a double-precision IEEE 64bit float." href="https://api.haxe.org/Float.html">Float</a>}</code></h3>
<p>Return (minor_words, promoted_words, major_words). This function is as fast as quick_stat.</p>
<h3 class="anchor" id="finalise"><code><span class="label label-static">static</span><a href="#finalise">finalise</a>&lt;<span class="type">T</span>&gt;(<span style="white-space:nowrap">f:<span class="type">T</span> ‑&gt; <a class="type" title="Void - The standard Void type." href="https://api.haxe.org/Void.html">Void</a>,</span> <span style="white-space:nowrap">v:<span class="type">T</span></span>):<a class="type" title="Void - The standard Void type." href="https://api.haxe.org/Void.html">Void</a></code></h3>
<p>Registers f as a finalisation function for v. v must be heap-allocated. f will be called with v as argument at some point between the first time v becomes unreachable (including through weak pointers) and the time v is collected by the GC. Several functions can be registered for the same value, or even several instances of the same function. Each instance will be called once (or never, if the program terminates before v becomes unreachable). The GC will call the finalisation functions in the order of deallocation. When several values become unreachable at the same time (i.e. during the same GC cycle), the finalisation functions will be called in the reverse order of the corresponding calls to finalise. If finalise is called in the same order as the values are allocated, that means each value is finalised before the values it depends upon. Of course, this becomes false if additional dependencies are introduced by assignments.</p> <p>In the presence of multiple OCaml threads it should be assumed that any particular finaliser may be executed in any of the threads.</p>
<h3 class="anchor" id="full_major"><code><span class="label label-static">static</span><a href="#full_major">full_major</a>():<a class="type" title="Void - The standard Void type." href="https://api.haxe.org/Void.html">Void</a></code></h3>
<p>Do a minor collection, finish the current major collection cycle, and perform a complete new cycle. This will collect all currently unreachable blocks.</p>
<h3 class="anchor" id="get"><code><span class="label label-static">static</span><a href="#get">get</a>():<a class="type" title="eval.vm.Control - The GC parameters are given as a control record." href="control.html">Control</a></code></h3>
<p>Return the current values of the GC parameters in a control record.</p>
<h3 class="anchor" id="major"><code><span class="label label-static">static</span><a href="#major">major</a>():<a class="type" title="Void - The standard Void type." href="https://api.haxe.org/Void.html">Void</a></code></h3>
<p>Do a minor collection and finish the current major collection cycle.</p>
<h3 class="anchor" id="major_slice"><code><span class="label label-static">static</span><a href="#major_slice">major_slice</a>():<a class="type" title="Void - The standard Void type." href="https://api.haxe.org/Void.html">Void</a></code></h3>
<p>Do a minor collection and a slice of major collection. n is the size of the slice: the GC will do enough work to free (on average) n words of memory. If n = 0, the GC will try to do enough work to ensure that the next automatic slice has no work to do. This function returns an unspecified integer (currently: 0).</p>
<h3 class="anchor" id="minor"><code><span class="label label-static">static</span><a href="#minor">minor</a>():<a class="type" title="Void - The standard Void type." href="https://api.haxe.org/Void.html">Void</a></code></h3>
<p>Trigger a minor collection.</p>
<h3 class="anchor" id="print_stat"><code><span class="label label-static">static</span><a href="#print_stat">print_stat</a>(<span style="white-space:nowrap">out_channel:<a class="type" title="haxe.io.Output - An Output is an abstract write." href="https://api.haxe.org/haxe/io/Output.html">Output</a></span>):<a class="type" title="Void - The standard Void type." href="https://api.haxe.org/Void.html">Void</a></code></h3>
<p>Print the current values of the memory management counters (in human-readable form) into the channel argument.</p>
<h3 class="anchor" id="quick_stat"><code><span class="label label-static">static</span><a href="#quick_stat">quick_stat</a>():<a class="type" title="eval.vm.Stat - The memory management counters are returned in a stat record." href="stat.html">Stat</a></code></h3>
<p>Same as stat except that live_words, live_blocks, free_words, free_blocks, largest_free, and fragments are set to 0. This function is much faster than stat because it does not need to go through the heap.</p>
<h3 class="anchor" id="set"><code><span class="label label-static">static</span><a href="#set">set</a>(<span style="white-space:nowrap">r:<a class="type" title="eval.vm.Control - The GC parameters are given as a control record." href="control.html">Control</a></span>):<a class="type" title="Void - The standard Void type." href="https://api.haxe.org/Void.html">Void</a></code></h3>
<p>Changes the GC parameters according to the control record r.</p>
<h3 class="anchor" id="stat"><code><span class="label label-static">static</span><a href="#stat">stat</a>():<a class="type" title="eval.vm.Stat - The memory management counters are returned in a stat record." href="stat.html">Stat</a></code></h3>
<p>Return the current values of the memory management counters in a stat record. This function examines every heap block to get the statistics.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2020 Haxe Foundation<br>Licensed under a MIT license.<br>
    <a href="https://api.haxe.org/eval/vm/Gc.html" class="_attribution-link">https://api.haxe.org/eval/vm/Gc.html</a>
  </p>
</div>
