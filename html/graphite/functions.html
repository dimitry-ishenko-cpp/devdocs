<h1>Functions</h1> <p>Functions are used to transform, combine, and perform computations on <a class="reference internal" href="terminology.html#term-series"><span class="xref std std-term">series</span></a> data. Functions are applied using the Composer interface or by manipulating the <code class="docutils literal notranslate"><span class="pre">target</span></code> parameters in the <a class="reference internal" href="render_api.html"><span class="doc">Render API</span></a>.</p>  <h2 id="usage">Usage</h2> <p>Most functions are applied to one <a class="reference internal" href="terminology.html#term-series-list"><span class="xref std std-term">series list</span></a>. Functions with the parameter <code class="docutils literal notranslate"><span class="pre">*seriesLists</span></code> can take an arbitrary number of series lists. To pass multiple series lists to a function which only takes one, use the <code class="xref py py-func docutils literal notranslate"><span class="pre">group()</span></code> function.</p>   <h2 id="module-graphite.render.functions">List of functions</h2> <dl class="function"> <dt id="graphite.render.functions.absolute"> absolute(seriesList)</dt> <dd>
<p>Takes one metric or a wildcard seriesList and applies the mathematical abs function to each datapoint transforming it to its absolute value.</p> <p>Example:</p> <pre data-language="none">&amp;target=absolute(Server.instance01.threads.busy)
&amp;target=absolute(Server.instance*.threads.busy)</pre> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.aggregate"> aggregate(seriesList, func, xFilesFactor=None)</dt> <dd>
<p>Aggregate series using the specified function.</p> <p>Example:</p> <pre data-language="none">&amp;target=aggregate(host.cpu-[0-7].cpu-{user,system}.value, "sum")</pre> <p>This would be the equivalent of</p> <pre data-language="none">&amp;target=sumSeries(host.cpu-[0-7].cpu-{user,system}.value)</pre> <p>This function can be used with aggregation functions <code class="docutils literal notranslate"><span class="pre">average</span></code>, <code class="docutils literal notranslate"><span class="pre">median</span></code>, <code class="docutils literal notranslate"><span class="pre">sum</span></code>, <code class="docutils literal notranslate"><span class="pre">min</span></code>, <code class="docutils literal notranslate"><span class="pre">max</span></code>, <code class="docutils literal notranslate"><span class="pre">diff</span></code>, <code class="docutils literal notranslate"><span class="pre">stddev</span></code>, <code class="docutils literal notranslate"><span class="pre">count</span></code>, <code class="docutils literal notranslate"><span class="pre">range</span></code>, <code class="docutils literal notranslate"><span class="pre">multiply</span></code> &amp; <code class="docutils literal notranslate"><span class="pre">last</span></code>.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.aggregateLine"> aggregateLine(seriesList, func='average', keepStep=False)</dt> <dd>
<p>Takes a metric or wildcard seriesList and draws a horizontal line based on the function applied to each series.</p> <p>If the optional keepStep parameter is set to True, the result will have the same time period and step as the source series.</p> <p>Note: By default, the graphite renderer consolidates data points by averaging data points over time. If you are using the ‘min’ or ‘max’ function for aggregateLine, this can cause an unusual gap in the line drawn by this function and the data itself. To fix this, you should use the consolidateBy() function with the same function argument you are using for aggregateLine. This will ensure that the proper data points are retained and the graph should line up correctly.</p> <p>Example:</p> <pre data-language="none">&amp;target=aggregateLine(server01.connections.total, 'avg')
&amp;target=aggregateLine(server*.connections.total, 'avg')</pre> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.aggregateWithWildcards"> aggregateWithWildcards(seriesList, func, *positions)</dt> <dd>
<p>Call aggregator after inserting wildcards at the given position(s).</p> <p>Example:</p> <pre data-language="none">&amp;target=aggregateWithWildcards(host.cpu-[0-7].cpu-{user,system}.value, "sum", 1)</pre> <p>This would be the equivalent of</p> <pre data-language="none">&amp;target=sumSeries(host.cpu-[0-7].cpu-user.value)&amp;target=sumSeries(host.cpu-[0-7].cpu-system.value)
# or
&amp;target=aggregate(host.cpu-[0-7].cpu-user.value,"sum")&amp;target=aggregate(host.cpu-[0-7].cpu-system.value,"sum")</pre> <p>This function can be used with all aggregation functions supported by <a class="reference internal" href="#graphite.render.functions.aggregate" title="graphite.render.functions.aggregate"><code class="xref py py-func docutils literal notranslate"><span class="pre">aggregate</span></code></a>: <code class="docutils literal notranslate"><span class="pre">average</span></code>, <code class="docutils literal notranslate"><span class="pre">median</span></code>, <code class="docutils literal notranslate"><span class="pre">sum</span></code>, <code class="docutils literal notranslate"><span class="pre">min</span></code>, <code class="docutils literal notranslate"><span class="pre">max</span></code>, <code class="docutils literal notranslate"><span class="pre">diff</span></code>, <code class="docutils literal notranslate"><span class="pre">stddev</span></code>, <code class="docutils literal notranslate"><span class="pre">range</span></code> &amp; <code class="docutils literal notranslate"><span class="pre">multiply</span></code>.</p> <p>This complements <a class="reference internal" href="#graphite.render.functions.groupByNodes" title="graphite.render.functions.groupByNodes"><code class="xref py py-func docutils literal notranslate"><span class="pre">groupByNodes</span></code></a> which takes a list of nodes that must match in each group.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.alias"> alias(seriesList, newName)</dt> <dd>
<p>Takes one metric or a wildcard seriesList and a string in quotes. Prints the string instead of the metric name in the legend.</p> <pre data-language="none">&amp;target=alias(Sales.widgets.largeBlue,"Large Blue Widgets")</pre> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.aliasByMetric"> aliasByMetric(seriesList)</dt> <dd>
<p>Takes a seriesList and applies an alias derived from the base metric name.</p> <pre data-language="none">&amp;target=aliasByMetric(carbon.agents.graphite.creates)</pre> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.aliasByNode"> aliasByNode(seriesList, *nodes)</dt> <dd>
<p>Takes a seriesList and applies an alias derived from one or more “node” portion/s of the target name or tags. Node indices are 0 indexed.</p> <pre data-language="none">&amp;target=aliasByNode(ganglia.*.cpu.load5,1)</pre> <p>Each node may be an integer referencing a node in the series name or a string identifying a tag.</p> <pre data-language="none">&amp;target=seriesByTag("name=~cpu.load.*", "server=~server[1-9]+", "datacenter=dc1")|aliasByNode("datacenter", "server", 1)

# will produce output series like
# dc1.server1.load5, dc1.server2.load5, dc1.server1.load10, dc1.server2.load10</pre> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.aliasByTags"> aliasByTags(seriesList, *tags)</dt> <dd>
<p>Takes a seriesList and applies an alias derived from one or more tags and/or nodes</p> <pre data-language="none">&amp;target=seriesByTag("name=cpu")|aliasByTags("server","name")</pre> <p>This is an alias for <a class="reference internal" href="#graphite.render.functions.aliasByNode" title="graphite.render.functions.aliasByNode"><code class="xref py py-func docutils literal notranslate"><span class="pre">aliasByNode</span></code></a>.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.aliasQuery"> aliasQuery(seriesList, search, replace, newName)</dt> <dd>
<p>Performs a query to alias the metrics in seriesList.</p> <pre data-language="none">&amp;target=aliasQuery(channel.power.*,"channel\.power\.([0-9]+)","channel.frequency.\1", "Channel %d MHz")</pre> <p>The series in seriesList will be aliased by first translating the series names using the search &amp; replace parameters, then using the last value of the resulting series to construct the alias using sprintf-style syntax.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.aliasSub"> aliasSub(seriesList, search, replace)</dt> <dd>
<p>Runs series names through a regex search/replace.</p> <pre data-language="none">&amp;target=aliasSub(ip.*TCP*,"^.*TCP(\d+)","\1")</pre> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.alpha"> alpha(seriesList, alpha)</dt> <dd>
<p>Assigns the given alpha transparency setting to the series. Takes a float value between 0 and 1.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.applyByNode"> applyByNode(seriesList, nodeNum, templateFunction, newName=None)</dt> <dd>
<p>Takes a seriesList and applies some complicated function (described by a string), replacing templates with unique prefixes of keys from the seriesList (the key is all nodes up to the index given as <cite>nodeNum</cite>).</p> <p>If the <cite>newName</cite> parameter is provided, the name of the resulting series will be given by that parameter, with any “%” characters replaced by the unique prefix.</p> <p>Example:</p> <pre data-language="none">&amp;target=applyByNode(servers.*.disk.bytes_free,1,"divideSeries(%.disk.bytes_free,sumSeries(%.disk.bytes_*))")</pre> <p>Would find all series which match <cite>servers.*.disk.bytes_free</cite>, then trim them down to unique series up to the node given by nodeNum, then fill them into the template function provided (replacing % by the prefixes).</p> <p>Additional Examples:</p> <p>Given keys of</p> <ul class="simple"> <li><cite>stats.counts.haproxy.web.2XX</cite></li> <li><cite>stats.counts.haproxy.web.3XX</cite></li> <li><cite>stats.counts.haproxy.web.5XX</cite></li> <li><cite>stats.counts.haproxy.microservice.2XX</cite></li> <li><cite>stats.counts.haproxy.microservice.3XX</cite></li> <li><cite>stats.counts.haproxy.microservice.5XX</cite></li> </ul> <p>The following will return the rate of 5XX’s per service:</p> <pre data-language="none">applyByNode(stats.counts.haproxy.*.*XX, 3, "asPercent(%.5XX, sumSeries(%.*XX))", "%.pct_5XX")</pre> <p>The output series would have keys <cite>stats.counts.haproxy.web.pct_5XX</cite> and <cite>stats.counts.haproxy.microservice.pct_5XX</cite>.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.areaBetween"> areaBetween(seriesList)</dt> <dd>
<p>Draws the vertical area in between the two series in seriesList. Useful for visualizing a range such as the minimum and maximum latency for a service.</p> <p>areaBetween expects <strong>exactly one argument</strong> that results in exactly two series (see example below). The order of the lower and higher values series does not matter. The visualization only works when used in conjunction with <code class="docutils literal notranslate"><span class="pre">areaMode=stacked</span></code>.</p> <p>Most likely use case is to provide a band within which another metric should move. In such case applying an <code class="docutils literal notranslate"><span class="pre">alpha()</span></code>, as in the second example, gives best visual results.</p> <p>Example:</p> <pre data-language="none">&amp;target=areaBetween(service.latency.{min,max})&amp;areaMode=stacked

&amp;target=alpha(areaBetween(service.latency.{min,max}),0.3)&amp;areaMode=stacked</pre> <p>If for instance, you need to build a seriesList, you should use the <code class="docutils literal notranslate"><span class="pre">group</span></code> function, like so:</p> <pre data-language="none">&amp;target=areaBetween(group(minSeries(a.*.min),maxSeries(a.*.max)))</pre> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.asPercent"> asPercent(seriesList, total=None, *nodes)</dt> <dd>
<p>Calculates a percentage of the total of a wildcard series. If <cite>total</cite> is specified, each series will be calculated as a percentage of that total. If <cite>total</cite> is not specified, the sum of all points in the wildcard series will be used instead.</p> <p>A list of nodes can optionally be provided, if so they will be used to match series with their corresponding totals following the same logic as <a class="reference internal" href="#graphite.render.functions.groupByNodes" title="graphite.render.functions.groupByNodes"><code class="xref py py-func docutils literal notranslate"><span class="pre">groupByNodes</span></code></a>.</p> <p>When passing <cite>nodes</cite> the <cite>total</cite> parameter may be a series list or <cite>None</cite>. If it is <cite>None</cite> then for each series in <cite>seriesList</cite> the percentage of the sum of series in that group will be returned.</p> <p>When not passing <cite>nodes</cite>, the <cite>total</cite> parameter may be a single series, reference the same number of series as <cite>seriesList</cite> or be a numeric value.</p> <p>Example:</p> <pre data-language="none"># Server01 connections failed and succeeded as a percentage of Server01 connections attempted
&amp;target=asPercent(Server01.connections.{failed,succeeded}, Server01.connections.attempted)

# For each server, its connections failed as a percentage of its connections attempted
&amp;target=asPercent(Server*.connections.failed, Server*.connections.attempted)

# For each server, its connections failed and succeeded as a percentage of its connections attemped
&amp;target=asPercent(Server*.connections.{failed,succeeded}, Server*.connections.attempted, 0)

# apache01.threads.busy as a percentage of 1500
&amp;target=asPercent(apache01.threads.busy,1500)

# Server01 cpu stats as a percentage of its total
&amp;target=asPercent(Server01.cpu.*.jiffies)

# cpu stats for each server as a percentage of its total
&amp;target=asPercent(Server*.cpu.*.jiffies, None, 0)</pre> <p>When using <cite>nodes</cite>, any series or totals that can’t be matched will create output series with names like <code class="docutils literal notranslate"><span class="pre">asPercent(someSeries,MISSING)</span></code> or <code class="docutils literal notranslate"><span class="pre">asPercent(MISSING,someTotalSeries)</span></code> and all values set to None. If desired these series can be filtered out by piping the result through <code class="docutils literal notranslate"><span class="pre">|exclude("MISSING")</span></code> as shown below:</p> <pre data-language="none">&amp;target=asPercent(Server{1,2}.memory.used,Server{1,3}.memory.total,0)

# will produce 3 output series:
# asPercent(Server1.memory.used,Server1.memory.total) [values will be as expected]
# asPercent(Server2.memory.used,MISSING) [all values will be None]
# asPercent(MISSING,Server3.memory.total) [all values will be None]

&amp;target=asPercent(Server{1,2}.memory.used,Server{1,3}.memory.total,0)|exclude("MISSING")

# will produce 1 output series:
# asPercent(Server1.memory.used,Server1.memory.total) [values will be as expected]</pre> <p>Each node may be an integer referencing a node in the series name or a string identifying a tag.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">When <cite>total</cite> is a seriesList, specifying <cite>nodes</cite> to match series with the corresponding total series will increase reliability.</p> </div> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.averageAbove"> averageAbove(seriesList, n)</dt> <dd>
<p>Takes one metric or a wildcard seriesList followed by an integer N. Out of all metrics passed, draws only the metrics with an average value above N for the time period specified.</p> <p>Example:</p> <pre data-language="none">&amp;target=averageAbove(server*.instance*.threads.busy,25)</pre> <p>Draws the servers with average values above 25.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.averageBelow"> averageBelow(seriesList, n)</dt> <dd>
<p>Takes one metric or a wildcard seriesList followed by an integer N. Out of all metrics passed, draws only the metrics with an average value below N for the time period specified.</p> <p>Example:</p> <pre data-language="none">&amp;target=averageBelow(server*.instance*.threads.busy,25)</pre> <p>Draws the servers with average values below 25.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.averageOutsidePercentile"> averageOutsidePercentile(seriesList, n)</dt> <dd>
<p>Removes series lying inside an average percentile interval</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.averageSeries"> averageSeries(*seriesLists)</dt> <dd>
<p>Short Alias: avg()</p> <p>Takes one metric or a wildcard seriesList. Draws the average value of all metrics passed at each time.</p> <p>Example:</p> <pre data-language="none">&amp;target=averageSeries(company.server.*.threads.busy)</pre> <p>This is an alias for <a class="reference internal" href="#graphite.render.functions.aggregate" title="graphite.render.functions.aggregate"><code class="xref py py-func docutils literal notranslate"><span class="pre">aggregate</span></code></a> with aggregation <code class="docutils literal notranslate"><span class="pre">average</span></code>.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.averageSeriesWithWildcards"> averageSeriesWithWildcards(seriesList, *position)</dt> <dd>
<p>Call averageSeries after inserting wildcards at the given position(s).</p> <p>Example:</p> <pre data-language="none">&amp;target=averageSeriesWithWildcards(host.cpu-[0-7].cpu-{user,system}.value, 1)</pre> <p>This would be the equivalent of</p> <pre data-language="none">&amp;target=averageSeries(host.*.cpu-user.value)&amp;target=averageSeries(host.*.cpu-system.value)</pre> <p>This is an alias for <a class="reference internal" href="#graphite.render.functions.aggregateWithWildcards" title="graphite.render.functions.aggregateWithWildcards"><code class="xref py py-func docutils literal notranslate"><span class="pre">aggregateWithWildcards</span></code></a> with aggregation <code class="docutils literal notranslate"><span class="pre">average</span></code>.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.cactiStyle"> cactiStyle(seriesList, system=None, units=None)</dt> <dd>
<p>Takes a series list and modifies the aliases to provide column aligned output with Current, Max, and Min values in the style of cacti. Optionally takes a “system” value to apply unit formatting in the same style as the Y-axis, or a “unit” string to append an arbitrary unit suffix.</p> <pre data-language="none">&amp;target=cactiStyle(ganglia.*.net.bytes_out,"si")
&amp;target=cactiStyle(ganglia.*.net.bytes_out,"si","b")</pre> <p>A possible value for <code class="docutils literal notranslate"><span class="pre">system</span></code> is <code class="docutils literal notranslate"><span class="pre">si</span></code>, which would express your values in multiples of a thousand. A second option is to use <code class="docutils literal notranslate"><span class="pre">binary</span></code> which will instead express your values in multiples of 1024 (useful for network devices).</p> <p>Column alignment of the Current, Max, Min values works under two conditions: you use a monospace font such as terminus and use a single cactiStyle call, as separate cactiStyle calls are not aware of each other. In case you have different targets for which you would like to have cactiStyle to line up, you can use <code class="docutils literal notranslate"><span class="pre">group()</span></code> to combine them before applying cactiStyle, such as:</p> <pre data-language="none">&amp;target=cactiStyle(group(metricA,metricB))</pre> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.changed"> changed(seriesList)</dt> <dd>
<p>Takes one metric or a wildcard seriesList. Output 1 when the value changed, 0 when null or the same</p> <p>Example:</p> <pre data-language="none">&amp;target=changed(Server01.connections.handled)</pre> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.color"> color(seriesList, theColor)</dt> <dd>
<p>Assigns the given color to the seriesList</p> <p>Example:</p> <pre data-language="none">&amp;target=color(collectd.hostname.cpu.0.user, 'green')
&amp;target=color(collectd.hostname.cpu.0.system, 'ff0000')
&amp;target=color(collectd.hostname.cpu.0.idle, 'gray')
&amp;target=color(collectd.hostname.cpu.0.idle, '6464ffaa')</pre> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.consolidateBy"> consolidateBy(seriesList, consolidationFunc)</dt> <dd>
<p>Takes one metric or a wildcard seriesList and a consolidation function name.</p> <p>Valid function names are ‘sum’, ‘average’, ‘min’, ‘max’, ‘first’ &amp; ‘last’.</p> <p>When a graph is drawn where width of the graph size in pixels is smaller than the number of datapoints to be graphed, Graphite consolidates the values to to prevent line overlap. The consolidateBy() function changes the consolidation function from the default of ‘average’ to one of ‘sum’, ‘max’, ‘min’, ‘first’, or ‘last’. This is especially useful in sales graphs, where fractional values make no sense and a ‘sum’ of consolidated values is appropriate.</p> <pre data-language="none">&amp;target=consolidateBy(Sales.widgets.largeBlue, 'sum')
&amp;target=consolidateBy(Servers.web01.sda1.free_space, 'max')</pre> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.constantLine"> constantLine(value)</dt> <dd>
<p>Takes a float F.</p> <p>Draws a horizontal line at value F across the graph.</p> <p>Example:</p> <pre data-language="none">&amp;target=constantLine(123.456)</pre> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.countSeries"> countSeries(*seriesLists)</dt> <dd>
<p>Draws a horizontal line representing the number of nodes found in the seriesList.</p> <pre data-language="none">&amp;target=countSeries(carbon.agents.*.*)</pre> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.cumulative"> cumulative(seriesList)</dt> <dd>
<p>Takes one metric or a wildcard seriesList.</p> <p>When a graph is drawn where width of the graph size in pixels is smaller than the number of datapoints to be graphed, Graphite consolidates the values to to prevent line overlap. The cumulative() function changes the consolidation function from the default of ‘average’ to ‘sum’. This is especially useful in sales graphs, where fractional values make no sense and a ‘sum’ of consolidated values is appropriate.</p> <p>Alias for <a class="reference internal" href="#graphite.render.functions.consolidateBy" title="graphite.render.functions.consolidateBy"><code class="xref py py-func docutils literal notranslate"><span class="pre">consolidateBy(series,</span> <span class="pre">'sum')</span></code></a></p> <pre data-language="none">&amp;target=cumulative(Sales.widgets.largeBlue)</pre> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.currentAbove"> currentAbove(seriesList, n)</dt> <dd>
<p>Takes one metric or a wildcard seriesList followed by an integer N. Out of all metrics passed, draws only the metrics whose value is above N at the end of the time period specified.</p> <p>Example:</p> <pre data-language="none">&amp;target=currentAbove(server*.instance*.threads.busy,50)</pre> <p>Draws the servers with more than 50 busy threads.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.currentBelow"> currentBelow(seriesList, n)</dt> <dd>
<p>Takes one metric or a wildcard seriesList followed by an integer N. Out of all metrics passed, draws only the metrics whose value is below N at the end of the time period specified.</p> <p>Example:</p> <pre data-language="none">&amp;target=currentBelow(server*.instance*.threads.busy,3)</pre> <p>Draws the servers with less than 3 busy threads.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.dashed"> dashed(seriesList, dashLength=5)</dt> <dd>
<p>Takes one metric or a wildcard seriesList, followed by a float F.</p> <p>Draw the selected metrics with a dotted line with segments of length F If omitted, the default length of the segments is 5.0</p> <p>Example:</p> <pre data-language="none">&amp;target=dashed(server01.instance01.memory.free,2.5)</pre> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.delay"> delay(seriesList, steps)</dt> <dd>
<p>This shifts all samples later by an integer number of steps. This can be used for custom derivative calculations, among other things. Note: this will pad the early end of the data with None for every step shifted.</p> <p>This complements other time-displacement functions such as timeShift and timeSlice, in that this function is indifferent about the step intervals being shifted.</p> <p>Example:</p> <pre data-language="none">&amp;target=divideSeries(server.FreeSpace,delay(server.FreeSpace,1))</pre> <p>This computes the change in server free space as a percentage of the previous free space.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.derivative"> derivative(seriesList)</dt> <dd>
<p>This is the opposite of the integral function. This is useful for taking a running total metric and calculating the delta between subsequent data points.</p> <p>This function does not normalize for periods of time, as a true derivative would. Instead see the perSecond() function to calculate a rate of change over time.</p> <p>Example:</p> <pre data-language="none">&amp;target=derivative(company.server.application01.ifconfig.TXPackets)</pre> <p>Each time you run ifconfig, the RX and TXPackets are higher (assuming there is network traffic.) By applying the derivative function, you can get an idea of the packets per minute sent or received, even though you’re only recording the total.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.diffSeries"> diffSeries(*seriesLists)</dt> <dd>
<p>Subtracts series 2 through n from series 1.</p> <p>Example:</p> <pre data-language="none">&amp;target=diffSeries(service.connections.total,service.connections.failed)</pre> <p>To diff a series and a constant, one should use offset instead of (or in addition to) diffSeries</p> <p>Example:</p> <pre data-language="none">&amp;target=offset(service.connections.total,-5)

&amp;target=offset(diffSeries(service.connections.total,service.connections.failed),-4)</pre> <p>This is an alias for <a class="reference internal" href="#graphite.render.functions.aggregate" title="graphite.render.functions.aggregate"><code class="xref py py-func docutils literal notranslate"><span class="pre">aggregate</span></code></a> with aggregation <code class="docutils literal notranslate"><span class="pre">diff</span></code>.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.divideSeries"> divideSeries(dividendSeriesList, divisorSeries)</dt> <dd>
<p>Takes a dividend metric and a divisor metric and draws the division result. A constant may <em>not</em> be passed. To divide by a constant, use the scale() function (which is essentially a multiplication operation) and use the inverse of the dividend. (Division by 8 = multiplication by 1/8 or 0.125)</p> <p>Example:</p> <pre data-language="none">&amp;target=divideSeries(Series.dividends,Series.divisors)</pre> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.divideSeriesLists"> divideSeriesLists(dividendSeriesList, divisorSeriesList)</dt> <dd>
<p>Iterates over a two lists and divides list1[0] by list2[0], list1[1] by list2[1] and so on. The lists need to be the same length</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.drawAsInfinite"> drawAsInfinite(seriesList)</dt> <dd>
<p>Takes one metric or a wildcard seriesList. If the value is zero, draw the line at 0. If the value is above zero, draw the line at infinity. If the value is null or less than zero, do not draw the line.</p> <p>Useful for displaying on/off metrics, such as exit codes. (0 = success, anything else = failure.)</p> <p>Example:</p> <pre data-language="none">drawAsInfinite(Testing.script.exitCode)</pre> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.events"> events(*tags)</dt> <dd>
<p>Returns the number of events at this point in time. Usable with drawAsInfinite.</p> <p>Example:</p> <pre data-language="none">&amp;target=events("tag-one", "tag-two")
&amp;target=events("*")</pre> <p>Returns all events tagged as “tag-one” and “tag-two” and the second one returns all events.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.exclude"> exclude(seriesList, pattern)</dt> <dd>
<p>Takes a metric or a wildcard seriesList, followed by a regular expression in double quotes. Excludes metrics that match the regular expression.</p> <p>Example:</p> <pre data-language="none">&amp;target=exclude(servers*.instance*.threads.busy,"server02")</pre> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.exponentialMovingAverage"> exponentialMovingAverage(seriesList, windowSize)</dt> <dd>
<p>Takes a series of values and a window size and produces an exponential moving average utilizing the following formula:</p> <pre data-language="none">ema(current) = constant * (Current Value) + (1 - constant) * ema(previous)</pre> <p>The Constant is calculated as:</p> <pre data-language="none">constant = 2 / (windowSize + 1)</pre> <p>The first period EMA uses a simple moving average for its value.</p> <p>Example:</p> <pre data-language="none">&amp;target=exponentialMovingAverage(*.transactions.count, 10)
&amp;target=exponentialMovingAverage(*.transactions.count, '-10s')</pre> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.fallbackSeries"> fallbackSeries(seriesList, fallback)</dt> <dd>
<p>Takes a wildcard seriesList, and a second fallback metric. If the wildcard does not match any series, draws the fallback metric.</p> <p>Example:</p> <pre data-language="none">&amp;target=fallbackSeries(server*.requests_per_second, constantLine(0))</pre> <p>Draws a 0 line when server metric does not exist.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.filterSeries"> filterSeries(seriesList, func, operator, threshold)</dt> <dd>
<p>Takes one metric or a wildcard seriesList followed by a consolidation function, an operator and a threshold. Draws only the metrics which match the filter expression.</p> <p>Example:</p> <pre data-language="none">&amp;target=filterSeries(system.interface.eth*.packetsSent, 'max', '&gt;', 1000)</pre> <p>This would only display interfaces which has a peak throughput higher than 1000 packets/min.</p> <p>Supported aggregation functions: <code class="docutils literal notranslate"><span class="pre">average</span></code>, <code class="docutils literal notranslate"><span class="pre">median</span></code>, <code class="docutils literal notranslate"><span class="pre">sum</span></code>, <code class="docutils literal notranslate"><span class="pre">min</span></code>, <code class="docutils literal notranslate"><span class="pre">max</span></code>, <code class="docutils literal notranslate"><span class="pre">diff</span></code>, <code class="docutils literal notranslate"><span class="pre">stddev</span></code>, <code class="docutils literal notranslate"><span class="pre">range</span></code>, <code class="docutils literal notranslate"><span class="pre">multiply</span></code> &amp; <code class="docutils literal notranslate"><span class="pre">last</span></code>.</p> <p>Supported operators: <code class="docutils literal notranslate"><span class="pre">=</span></code>, <code class="docutils literal notranslate"><span class="pre">!=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> &amp; <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.grep"> grep(seriesList, pattern)</dt> <dd>
<p>Takes a metric or a wildcard seriesList, followed by a regular expression in double quotes. Excludes metrics that don’t match the regular expression.</p> <p>Example:</p> <pre data-language="none">&amp;target=grep(servers*.instance*.threads.busy,"server02")</pre> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.group"> group(*seriesLists)</dt> <dd>
<p>Takes an arbitrary number of seriesLists and adds them to a single seriesList. This is used to pass multiple seriesLists to a function which only takes one</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.groupByNode"> groupByNode(seriesList, nodeNum, callback='average')</dt> <dd>
<p>Takes a serieslist and maps a callback to subgroups within as defined by a common node</p> <pre data-language="none">&amp;target=groupByNode(ganglia.by-function.*.*.cpu.load5,2,"sumSeries")</pre> <p>Would return multiple series which are each the result of applying the “sumSeries” function to groups joined on the second node (0 indexed) resulting in a list of targets like</p> <pre data-language="none">sumSeries(ganglia.by-function.server1.*.cpu.load5),sumSeries(ganglia.by-function.server2.*.cpu.load5),...</pre> <p>Node may be an integer referencing a node in the series name or a string identifying a tag.</p> <p>This is an alias for using <a class="reference internal" href="#graphite.render.functions.groupByNodes" title="graphite.render.functions.groupByNodes"><code class="xref py py-func docutils literal notranslate"><span class="pre">groupByNodes</span></code></a> with a single node.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.groupByNodes"> groupByNodes(seriesList, callback, *nodes)</dt> <dd>
<p>Takes a serieslist and maps a callback to subgroups within as defined by multiple nodes</p> <pre data-language="none">&amp;target=groupByNodes(ganglia.server*.*.cpu.load*,"sum",1,4)</pre> <p>Would return multiple series which are each the result of applying the “sum” aggregation to groups joined on the nodes’ list (0 indexed) resulting in a list of targets like</p> <pre data-language="none">sumSeries(ganglia.server1.*.cpu.load5),sumSeries(ganglia.server1.*.cpu.load10),sumSeries(ganglia.server1.*.cpu.load15),sumSeries(ganglia.server2.*.cpu.load5),sumSeries(ganglia.server2.*.cpu.load10),sumSeries(ganglia.server2.*.cpu.load15),...</pre> <p>This function can be used with all aggregation functions supported by <a class="reference internal" href="#graphite.render.functions.aggregate" title="graphite.render.functions.aggregate"><code class="xref py py-func docutils literal notranslate"><span class="pre">aggregate</span></code></a>: <code class="docutils literal notranslate"><span class="pre">average</span></code>, <code class="docutils literal notranslate"><span class="pre">median</span></code>, <code class="docutils literal notranslate"><span class="pre">sum</span></code>, <code class="docutils literal notranslate"><span class="pre">min</span></code>, <code class="docutils literal notranslate"><span class="pre">max</span></code>, <code class="docutils literal notranslate"><span class="pre">diff</span></code>, <code class="docutils literal notranslate"><span class="pre">stddev</span></code>, <code class="docutils literal notranslate"><span class="pre">range</span></code> &amp; <code class="docutils literal notranslate"><span class="pre">multiply</span></code>.</p> <p>Each node may be an integer referencing a node in the series name or a string identifying a tag.</p> <pre data-language="none">&amp;target=seriesByTag("name=~cpu.load.*", "server=~server[1-9]+", "datacenter=~dc[1-9]+")|groupByNodes("average", "datacenter", 1)

# will produce output series like
# dc1.load5, dc2.load5, dc1.load10, dc2.load10</pre> <p>This complements <a class="reference internal" href="#graphite.render.functions.aggregateWithWildcards" title="graphite.render.functions.aggregateWithWildcards"><code class="xref py py-func docutils literal notranslate"><span class="pre">aggregateWithWildcards</span></code></a> which takes a list of wildcard nodes.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.groupByTags"> groupByTags(seriesList, callback, *tags)</dt> <dd>
<p>Takes a serieslist and maps a callback to subgroups within as defined by multiple tags</p> <pre data-language="none">&amp;target=seriesByTag("name=cpu")|groupByTags("average","dc")</pre> <p>Would return multiple series which are each the result of applying the “averageSeries” function to groups joined on the specified tags resulting in a list of targets like</p> <pre data-language="none">averageSeries(seriesByTag("name=cpu","dc=dc1")),averageSeries(seriesByTag("name=cpu","dc=dc2")),...</pre> <p>This function can be used with all aggregation functions supported by <a class="reference internal" href="#graphite.render.functions.aggregate" title="graphite.render.functions.aggregate"><code class="xref py py-func docutils literal notranslate"><span class="pre">aggregate</span></code></a>: <code class="docutils literal notranslate"><span class="pre">average</span></code>, <code class="docutils literal notranslate"><span class="pre">median</span></code>, <code class="docutils literal notranslate"><span class="pre">sum</span></code>, <code class="docutils literal notranslate"><span class="pre">min</span></code>, <code class="docutils literal notranslate"><span class="pre">max</span></code>, <code class="docutils literal notranslate"><span class="pre">diff</span></code>, <code class="docutils literal notranslate"><span class="pre">stddev</span></code>, <code class="docutils literal notranslate"><span class="pre">range</span></code> &amp; <code class="docutils literal notranslate"><span class="pre">multiply</span></code>.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.highest"> highest(seriesList, n=1, func='average')</dt> <dd>
<p>Takes one metric or a wildcard seriesList followed by an integer N and an aggregation function. Out of all metrics passed, draws only the N metrics with the highest aggregated value over the time period specified.</p> <p>Example:</p> <pre data-language="none">&amp;target=highest(server*.instance*.threads.busy,5,'max')</pre> <p>Draws the 5 servers with the highest number of busy threads.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.highestAverage"> highestAverage(seriesList, n)</dt> <dd>
<p>Takes one metric or a wildcard seriesList followed by an integer N. Out of all metrics passed, draws only the top N metrics with the highest average value for the time period specified.</p> <p>Example:</p> <pre data-language="none">&amp;target=highestAverage(server*.instance*.threads.busy,5)</pre> <p>Draws the top 5 servers with the highest average value.</p> <p>This is an alias for <a class="reference internal" href="#graphite.render.functions.highest" title="graphite.render.functions.highest"><code class="xref py py-func docutils literal notranslate"><span class="pre">highest</span></code></a> with aggregation <code class="docutils literal notranslate"><span class="pre">average</span></code>.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.highestCurrent"> highestCurrent(seriesList, n)</dt> <dd>
<p>Takes one metric or a wildcard seriesList followed by an integer N. Out of all metrics passed, draws only the N metrics with the highest value at the end of the time period specified.</p> <p>Example:</p> <pre data-language="none">&amp;target=highestCurrent(server*.instance*.threads.busy,5)</pre> <p>Draws the 5 servers with the highest busy threads.</p> <p>This is an alias for <a class="reference internal" href="#graphite.render.functions.highest" title="graphite.render.functions.highest"><code class="xref py py-func docutils literal notranslate"><span class="pre">highest</span></code></a> with aggregation <code class="docutils literal notranslate"><span class="pre">current</span></code>.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.highestMax"> highestMax(seriesList, n)</dt> <dd>
<p>Takes one metric or a wildcard seriesList followed by an integer N.</p> <p>Out of all metrics passed, draws only the N metrics with the highest maximum value in the time period specified.</p> <p>Example:</p> <pre data-language="none">&amp;target=highestMax(server*.instance*.threads.busy,5)</pre> <p>Draws the top 5 servers who have had the most busy threads during the time period specified.</p> <p>This is an alias for <a class="reference internal" href="#graphite.render.functions.highest" title="graphite.render.functions.highest"><code class="xref py py-func docutils literal notranslate"><span class="pre">highest</span></code></a> with aggregation <code class="docutils literal notranslate"><span class="pre">max</span></code>.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.hitcount"> hitcount(seriesList, intervalString, alignToInterval=False)</dt> <dd>
<p>Estimate hit counts from a list of time series.</p> <p>This function assumes the values in each time series represent hits per second. It calculates hits per some larger interval such as per day or per hour. This function is like summarize(), except that it compensates automatically for different time scales (so that a similar graph results from using either fine-grained or coarse-grained records) and handles rarely-occurring events gracefully.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.holtWintersAberration"> holtWintersAberration(seriesList, delta=3, bootstrapInterval='7d', seasonality='1d')</dt> <dd>
<p>Performs a Holt-Winters forecast using the series as input data and plots the positive or negative deviation of the series data from the forecast.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.holtWintersConfidenceArea"> holtWintersConfidenceArea(seriesList, delta=3, bootstrapInterval='7d', seasonality='1d')</dt> <dd>
<p>Performs a Holt-Winters forecast using the series as input data and plots the area between the upper and lower bands of the predicted forecast deviations.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.holtWintersConfidenceBands"> holtWintersConfidenceBands(seriesList, delta=3, bootstrapInterval='7d', seasonality='1d')</dt> <dd>
<p>Performs a Holt-Winters forecast using the series as input data and plots upper and lower bands with the predicted forecast deviations.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.holtWintersForecast"> holtWintersForecast(seriesList, bootstrapInterval='7d', seasonality='1d')</dt> <dd>
<p>Performs a Holt-Winters forecast using the series as input data. Data from <cite>bootstrapInterval</cite> (one week by default) previous to the series is used to bootstrap the initial forecast.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.identity"> identity(name)</dt> <dd>
<p>Identity function: Returns datapoints where the value equals the timestamp of the datapoint. Useful when you have another series where the value is a timestamp, and you want to compare it to the time of the datapoint, to render an age</p> <p>Example:</p> <pre data-language="none">&amp;target=identity("The.time.series")</pre> <p>This would create a series named “The.time.series” that contains points where x(t) == t.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.integral"> integral(seriesList)</dt> <dd>
<p>This will show the sum over time, sort of like a continuous addition function. Useful for finding totals or trends in metrics that are collected per minute.</p> <p>Example:</p> <pre data-language="none">&amp;target=integral(company.sales.perMinute)</pre> <p>This would start at zero on the left side of the graph, adding the sales each minute, and show the total sales for the time period selected at the right side, (time now, or the time specified by ‘&amp;until=’).</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.integralByInterval"> integralByInterval(seriesList, intervalUnit)</dt> <dd>
<p>This will do the same as integral() funcion, except resetting the total to 0 at the given time in the parameter “from” Useful for finding totals per hour/day/week/..</p> <p>Example:</p> <pre data-language="none">&amp;target=integralByInterval(company.sales.perMinute, "1d")&amp;from=midnight-10days</pre> <p>This would start at zero on the left side of the graph, adding the sales each minute, and show the evolution of sales per day during the last 10 days.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.interpolate"> interpolate(seriesList, limit=inf)</dt> <dd>
<p>Takes one metric or a wildcard seriesList, and optionally a limit to the number of ‘None’ values to skip over. Continues the line with the last received value when gaps (‘None’ values) appear in your data, rather than breaking your line.</p> <p>Example:</p> <pre data-language="none">&amp;target=interpolate(Server01.connections.handled)
&amp;target=interpolate(Server01.connections.handled, 10)</pre> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.invert"> invert(seriesList)</dt> <dd>
<p>Takes one metric or a wildcard seriesList, and inverts each datapoint (i.e. 1/x).</p> <p>Example:</p> <pre data-language="none">&amp;target=invert(Server.instance01.threads.busy)</pre> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.isNonNull"> isNonNull(seriesList)</dt> <dd>
<p>Takes a metric or wildcard seriesList and counts up the number of non-null values. This is useful for understanding the number of metrics that have data at a given point in time (i.e. to count which servers are alive).</p> <p>Example:</p> <pre data-language="none">&amp;target=isNonNull(webapp.pages.*.views)</pre> <p>Returns a seriesList where 1 is specified for non-null values, and 0 is specified for null values.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.keepLastValue"> keepLastValue(seriesList, limit=inf)</dt> <dd>
<p>Takes one metric or a wildcard seriesList, and optionally a limit to the number of ‘None’ values to skip over. Continues the line with the last received value when gaps (‘None’ values) appear in your data, rather than breaking your line.</p> <p>Example:</p> <pre data-language="none">&amp;target=keepLastValue(Server01.connections.handled)
&amp;target=keepLastValue(Server01.connections.handled, 10)</pre> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.legendValue"> legendValue(seriesList, *valueTypes)</dt> <dd>
<p>Takes one metric or a wildcard seriesList and a string in quotes. Appends a value to the metric name in the legend. Currently one or several of: <cite>last</cite>, <cite>avg</cite>, <cite>total</cite>, <cite>min</cite>, <cite>max</cite>. The last argument can be <cite>si</cite> (default) or <cite>binary</cite>, in that case values will be formatted in the corresponding system.</p> <pre data-language="none">&amp;target=legendValue(Sales.widgets.largeBlue, 'avg', 'max', 'si')</pre> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.limit"> limit(seriesList, n)</dt> <dd>
<p>Takes one metric or a wildcard seriesList followed by an integer N.</p> <p>Only draw the first N metrics. Useful when testing a wildcard in a metric.</p> <p>Example:</p> <pre data-language="none">&amp;target=limit(server*.instance*.memory.free,5)</pre> <p>Draws only the first 5 instance’s memory free.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.lineWidth"> lineWidth(seriesList, width)</dt> <dd>
<p>Takes one metric or a wildcard seriesList, followed by a float F.</p> <p>Draw the selected metrics with a line width of F, overriding the default value of 1, or the &amp;lineWidth=X.X parameter.</p> <p>Useful for highlighting a single metric out of many, or having multiple line widths in one graph.</p> <p>Example:</p> <pre data-language="none">&amp;target=lineWidth(server01.instance01.memory.free,5)</pre> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.linearRegression"> linearRegression(seriesList, startSourceAt=None, endSourceAt=None)</dt> <dd>
<p>Graphs the linear regression function by least squares method.</p> <p>Takes one metric or a wildcard seriesList, followed by a quoted string with the time to start the line and another quoted string with the time to end the line. The start and end times are inclusive (default range is from to until). See <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">/</span> <span class="pre">until</span></code> in the <a class="reference internal" href="render_api.html"><span class="doc">Render API</span></a> for examples of time formats. Datapoints in the range is used to regression.</p> <p>Example:</p> <pre data-language="none">&amp;target=linearRegression(Server.instance01.threads.busy, '-1d')
&amp;target=linearRegression(Server.instance*.threads.busy, "00:00 20140101","11:59 20140630")</pre> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.linearRegressionAnalysis"> linearRegressionAnalysis(series)</dt> <dd>
<p>Returns factor and offset of linear regression function by least squares method.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.logarithm"> logarithm(seriesList, base=10)</dt> <dd>
<p>Takes one metric or a wildcard seriesList, a base, and draws the y-axis in logarithmic format. If base is omitted, the function defaults to base 10.</p> <p>Example:</p> <pre data-language="none">&amp;target=log(carbon.agents.hostname.avgUpdateTime,2)</pre> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.lowest"> lowest(seriesList, n=1, func='average')</dt> <dd>
<p>Takes one metric or a wildcard seriesList followed by an integer N and an aggregation function. Out of all metrics passed, draws only the N metrics with the lowest aggregated value over the time period specified.</p> <p>Example:</p> <pre data-language="none">&amp;target=lowest(server*.instance*.threads.busy,5,'min')</pre> <p>Draws the 5 servers with the lowest number of busy threads.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.lowestAverage"> lowestAverage(seriesList, n)</dt> <dd>
<p>Takes one metric or a wildcard seriesList followed by an integer N. Out of all metrics passed, draws only the bottom N metrics with the lowest average value for the time period specified.</p> <p>Example:</p> <pre data-language="none">&amp;target=lowestAverage(server*.instance*.threads.busy,5)</pre> <p>Draws the bottom 5 servers with the lowest average value.</p> <p>This is an alias for <a class="reference internal" href="#graphite.render.functions.lowest" title="graphite.render.functions.lowest"><code class="xref py py-func docutils literal notranslate"><span class="pre">lowest</span></code></a> with aggregation <code class="docutils literal notranslate"><span class="pre">average</span></code>.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.lowestCurrent"> lowestCurrent(seriesList, n)</dt> <dd>
<p>Takes one metric or a wildcard seriesList followed by an integer N. Out of all metrics passed, draws only the N metrics with the lowest value at the end of the time period specified.</p> <p>Example:</p> <pre data-language="none">&amp;target=lowestCurrent(server*.instance*.threads.busy,5)</pre> <p>Draws the 5 servers with the least busy threads right now.</p> <p>This is an alias for <a class="reference internal" href="#graphite.render.functions.lowest" title="graphite.render.functions.lowest"><code class="xref py py-func docutils literal notranslate"><span class="pre">lowest</span></code></a> with aggregation <code class="docutils literal notranslate"><span class="pre">current</span></code>.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.mapSeries"> mapSeries(seriesList, *mapNodes)</dt> <dd>
<p>Short form: <code class="docutils literal notranslate"><span class="pre">map()</span></code></p> <p>Takes a seriesList and maps it to a list of seriesList. Each seriesList has the given mapNodes in common.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">This function is not very useful alone. It should be used with <a class="reference internal" href="#graphite.render.functions.reduceSeries" title="graphite.render.functions.reduceSeries"><code class="xref py py-func docutils literal notranslate"><span class="pre">reduceSeries()</span></code></a></p> </div> <pre data-language="none">mapSeries(servers.*.cpu.*,1) =&gt;

  [
    servers.server1.cpu.*,
    servers.server2.cpu.*,
    ...
    servers.serverN.cpu.*
  ]</pre> <p>Each node may be an integer referencing a node in the series name or a string identifying a tag.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.maxSeries"> maxSeries(*seriesLists)</dt> <dd>
<p>Takes one metric or a wildcard seriesList. For each datapoint from each metric passed in, pick the maximum value and graph it.</p> <p>Example:</p> <pre data-language="none">&amp;target=maxSeries(Server*.connections.total)</pre> <p>This is an alias for <a class="reference internal" href="#graphite.render.functions.aggregate" title="graphite.render.functions.aggregate"><code class="xref py py-func docutils literal notranslate"><span class="pre">aggregate</span></code></a> with aggregation <code class="docutils literal notranslate"><span class="pre">max</span></code>.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.maximumAbove"> maximumAbove(seriesList, n)</dt> <dd>
<p>Takes one metric or a wildcard seriesList followed by a constant n. Draws only the metrics with a maximum value above n.</p> <p>Example:</p> <pre data-language="none">&amp;target=maximumAbove(system.interface.eth*.packetsSent,1000)</pre> <p>This would only display interfaces which sent more than 1000 packets/min.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.maximumBelow"> maximumBelow(seriesList, n)</dt> <dd>
<p>Takes one metric or a wildcard seriesList followed by a constant n. Draws only the metrics with a maximum value below n.</p> <p>Example:</p> <pre data-language="none">&amp;target=maximumBelow(system.interface.eth*.packetsSent,1000)</pre> <p>This would only display interfaces which sent less than 1000 packets/min.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.minMax"> minMax(seriesList)</dt> <dd>
<p>Applies the popular min max normalization technique, which takes each point and applies the following normalization transformation to it: normalized = (point - min) / (max - min).</p> <p>Example:</p> <pre data-language="none">&amp;target=minMax(Server.instance01.threads.busy)</pre> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.minSeries"> minSeries(*seriesLists)</dt> <dd>
<p>Takes one metric or a wildcard seriesList. For each datapoint from each metric passed in, pick the minimum value and graph it.</p> <p>Example:</p> <pre data-language="none">&amp;target=minSeries(Server*.connections.total)</pre> <p>This is an alias for <a class="reference internal" href="#graphite.render.functions.aggregate" title="graphite.render.functions.aggregate"><code class="xref py py-func docutils literal notranslate"><span class="pre">aggregate</span></code></a> with aggregation <code class="docutils literal notranslate"><span class="pre">min</span></code>.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.minimumAbove"> minimumAbove(seriesList, n)</dt> <dd>
<p>Takes one metric or a wildcard seriesList followed by a constant n. Draws only the metrics with a minimum value above n.</p> <p>Example:</p> <pre data-language="none">&amp;target=minimumAbove(system.interface.eth*.packetsSent,1000)</pre> <p>This would only display interfaces which sent more than 1000 packets/min.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.minimumBelow"> minimumBelow(seriesList, n)</dt> <dd>
<p>Takes one metric or a wildcard seriesList followed by a constant n. Draws only the metrics with a minimum value below n.</p> <p>Example:</p> <pre data-language="none">&amp;target=minimumBelow(system.interface.eth*.packetsSent,1000)</pre> <p>This would only display interfaces which at one point sent less than 1000 packets/min.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.mostDeviant"> mostDeviant(seriesList, n)</dt> <dd>
<p>Takes one metric or a wildcard seriesList followed by an integer N. Draws the N most deviant metrics. To find the deviants, the standard deviation (sigma) of each series is taken and ranked. The top N standard deviations are returned.</p> <blockquote> <div>Example:</div>
</blockquote> <pre data-language="none">&amp;target=mostDeviant(server*.instance*.memory.free, 5)</pre> <p>Draws the 5 instances furthest from the average memory free.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.movingAverage"> movingAverage(seriesList, windowSize, xFilesFactor=None)</dt> <dd>
<p>Graphs the moving average of a metric (or metrics) over a fixed number of past points, or a time interval.</p> <p>Takes one metric or a wildcard seriesList followed by a number N of datapoints or a quoted string with a length of time like ‘1hour’ or ‘5min’ (See <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">/</span>
<span class="pre">until</span></code> in the <a class="reference internal" href="render_api.html"><span class="doc">Render API</span></a> for examples of time formats), and an xFilesFactor value to specify how many points in the window must be non-null for the output to be considered valid. Graphs the average of the preceeding datapoints for each point on the graph.</p> <p>Example:</p> <pre data-language="none">&amp;target=movingAverage(Server.instance01.threads.busy,10)
&amp;target=movingAverage(Server.instance*.threads.idle,'5min')</pre> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.movingMax"> movingMax(seriesList, windowSize, xFilesFactor=None)</dt> <dd>
<p>Graphs the moving maximum of a metric (or metrics) over a fixed number of past points, or a time interval.</p> <p>Takes one metric or a wildcard seriesList followed by a number N of datapoints or a quoted string with a length of time like ‘1hour’ or ‘5min’ (See <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">/</span>
<span class="pre">until</span></code> in the <a class="reference internal" href="render_api.html"><span class="doc">Render API</span></a> for examples of time formats), and an xFilesFactor value to specify how many points in the window must be non-null for the output to be considered valid. Graphs the maximum of the preceeding datapoints for each point on the graph.</p> <p>Example:</p> <pre data-language="none">&amp;target=movingMax(Server.instance01.requests,10)
&amp;target=movingMax(Server.instance*.errors,'5min')</pre> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.movingMedian"> movingMedian(seriesList, windowSize, xFilesFactor=None)</dt> <dd>
<p>Graphs the moving median of a metric (or metrics) over a fixed number of past points, or a time interval.</p> <p>Takes one metric or a wildcard seriesList followed by a number N of datapoints or a quoted string with a length of time like ‘1hour’ or ‘5min’ (See <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">/</span>
<span class="pre">until</span></code> in the <a class="reference internal" href="render_api.html"><span class="doc">Render API</span></a> for examples of time formats), and an xFilesFactor value to specify how many points in the window must be non-null for the output to be considered valid. Graphs the median of the preceeding datapoints for each point on the graph.</p> <p>Example:</p> <pre data-language="none">&amp;target=movingMedian(Server.instance01.threads.busy,10)
&amp;target=movingMedian(Server.instance*.threads.idle,'5min')</pre> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.movingMin"> movingMin(seriesList, windowSize, xFilesFactor=None)</dt> <dd>
<p>Graphs the moving minimum of a metric (or metrics) over a fixed number of past points, or a time interval.</p> <p>Takes one metric or a wildcard seriesList followed by a number N of datapoints or a quoted string with a length of time like ‘1hour’ or ‘5min’ (See <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">/</span>
<span class="pre">until</span></code> in the <a class="reference internal" href="render_api.html"><span class="doc">Render API</span></a> for examples of time formats), and an xFilesFactor value to specify how many points in the window must be non-null for the output to be considered valid. Graphs the minimum of the preceeding datapoints for each point on the graph.</p> <p>Example:</p> <pre data-language="none">&amp;target=movingMin(Server.instance01.requests,10)
&amp;target=movingMin(Server.instance*.errors,'5min')</pre> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.movingSum"> movingSum(seriesList, windowSize, xFilesFactor=None)</dt> <dd>
<p>Graphs the moving sum of a metric (or metrics) over a fixed number of past points, or a time interval.</p> <p>Takes one metric or a wildcard seriesList followed by a number N of datapoints or a quoted string with a length of time like ‘1hour’ or ‘5min’ (See <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">/</span>
<span class="pre">until</span></code> in the <a class="reference internal" href="render_api.html"><span class="doc">Render API</span></a> for examples of time formats), and an xFilesFactor value to specify how many points in the window must be non-null for the output to be considered valid. Graphs the sum of the preceeding datapoints for each point on the graph.</p> <p>Example:</p> <pre data-language="none">&amp;target=movingSum(Server.instance01.requests,10)
&amp;target=movingSum(Server.instance*.errors,'5min')</pre> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.movingWindow"> movingWindow(seriesList, windowSize, func='average', xFilesFactor=None)</dt> <dd>
<p>Graphs a moving window function of a metric (or metrics) over a fixed number of past points, or a time interval.</p> <p>Takes one metric or a wildcard seriesList, a number N of datapoints or a quoted string with a length of time like ‘1hour’ or ‘5min’ (See <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">/</span>
<span class="pre">until</span></code> in the <a class="reference internal" href="render_api.html"><span class="doc">Render API</span></a> for examples of time formats), a function to apply to the points in the window to produce the output, and an xFilesFactor value to specify how many points in the window must be non-null for the output to be considered valid. Graphs the output of the function for the preceeding datapoints for each point on the graph.</p> <p>Example:</p> <pre data-language="none">&amp;target=movingWindow(Server.instance01.threads.busy,10)
&amp;target=movingWindow(Server.instance*.threads.idle,'5min','median',0.5)</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last"><cite>xFilesFactor</cite> follows the same semantics as in Whisper storage schemas. Setting it to 0 (the default) means that only a single value in a given interval needs to be non-null, setting it to 1 means that all values in the interval must be non-null. A setting of 0.5 means that at least half the values in the interval must be non-null.</p> </div> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.multiplySeries"> multiplySeries(*seriesLists)</dt> <dd>
<p>Takes two or more series and multiplies their points. A constant may not be used. To multiply by a constant, use the scale() function.</p> <p>Example:</p> <pre data-language="none">&amp;target=multiplySeries(Series.dividends,Series.divisors)</pre> <p>This is an alias for <a class="reference internal" href="#graphite.render.functions.aggregate" title="graphite.render.functions.aggregate"><code class="xref py py-func docutils literal notranslate"><span class="pre">aggregate</span></code></a> with aggregation <code class="docutils literal notranslate"><span class="pre">multiply</span></code>.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.multiplySeriesWithWildcards"> multiplySeriesWithWildcards(seriesList, *position)</dt> <dd>
<p>Call multiplySeries after inserting wildcards at the given position(s).</p> <p>Example:</p> <pre data-language="none">&amp;target=multiplySeriesWithWildcards(web.host-[0-7].{avg-response,total-request}.value, 2)</pre> <p>This would be the equivalent of</p> <pre data-language="none">&amp;target=multiplySeries(web.host-0.{avg-response,total-request}.value)&amp;target=multiplySeries(web.host-1.{avg-response,total-request}.value)...</pre> <p>This is an alias for <a class="reference internal" href="#graphite.render.functions.aggregateWithWildcards" title="graphite.render.functions.aggregateWithWildcards"><code class="xref py py-func docutils literal notranslate"><span class="pre">aggregateWithWildcards</span></code></a> with aggregation <code class="docutils literal notranslate"><span class="pre">multiply</span></code>.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.nPercentile"> nPercentile(seriesList, n)</dt> <dd>
<p>Returns n-percent of each series in the seriesList.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.nonNegativeDerivative"> nonNegativeDerivative(seriesList, maxValue=None)</dt> <dd>
<p>Same as the derivative function above, but ignores datapoints that trend down. Useful for counters that increase for a long time, then wrap or reset. (Such as if a network interface is destroyed and recreated by unloading and re-loading a kernel module, common with USB / WiFi cards.</p> <p>Example:</p> <pre data-language="none">&amp;target=nonNegativederivative(company.server.application01.ifconfig.TXPackets)</pre> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.offset"> offset(seriesList, factor)</dt> <dd>
<p>Takes one metric or a wildcard seriesList followed by a constant, and adds the constant to each datapoint.</p> <p>Example:</p> <pre data-language="none">&amp;target=offset(Server.instance01.threads.busy,10)</pre> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.offsetToZero"> offsetToZero(seriesList)</dt> <dd>
<p>Offsets a metric or wildcard seriesList by subtracting the minimum value in the series from each datapoint.</p> <p>Useful to compare different series where the values in each series may be higher or lower on average but you’re only interested in the relative difference.</p> <p>An example use case is for comparing different round trip time results. When measuring RTT (like pinging a server), different devices may come back with consistently different results due to network latency which will be different depending on how many network hops between the probe and the device. To compare different devices in the same graph, the network latency to each has to be factored out of the results. This is a shortcut that takes the fastest response (lowest number in the series) and sets that to zero and then offsets all of the other datapoints in that series by that amount. This makes the assumption that the lowest response is the fastest the device can respond, of course the more datapoints that are in the series the more accurate this assumption is.</p> <p>Example:</p> <pre data-language="none">&amp;target=offsetToZero(Server.instance01.responseTime)
&amp;target=offsetToZero(Server.instance*.responseTime)</pre> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.perSecond"> perSecond(seriesList, maxValue=None)</dt> <dd>
<p>NonNegativeDerivative adjusted for the series time interval This is useful for taking a running total metric and showing how many requests per second were handled.</p> <p>Example:</p> <pre data-language="none">&amp;target=perSecond(company.server.application01.ifconfig.TXPackets)</pre> <p>Each time you run ifconfig, the RX and TXPackets are higher (assuming there is network traffic.) By applying the perSecond function, you can get an idea of the packets per second sent or received, even though you’re only recording the total.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.percentileOfSeries"> percentileOfSeries(seriesList, n, interpolate=False)</dt> <dd>
<p>percentileOfSeries returns a single series which is composed of the n-percentile values taken across a wildcard series at each point. Unless <cite>interpolate</cite> is set to True, percentile values are actual values contained in one of the supplied series.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.pieAverage"> pieAverage(series)</dt> <dd>
<p>Return the average</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.pieMaximum"> pieMaximum(series)</dt> <dd>
<p>Return the maximum</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.pieMinimum"> pieMinimum(series)</dt> <dd>
<p>Return the minimum</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.pow"> pow(seriesList, factor)</dt> <dd>
<p>Takes one metric or a wildcard seriesList followed by a constant, and raises the datapoint by the power of the constant provided at each point.</p> <p>Example:</p> <pre data-language="none">&amp;target=pow(Server.instance01.threads.busy,10)
&amp;target=pow(Server.instance*.threads.busy,10)</pre> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.powSeries"> powSeries(*seriesLists)</dt> <dd>
<p>Takes two or more series and pows their points. A constant line may be used.</p> <p>Example:</p> <pre data-language="none">&amp;target=powSeries(Server.instance01.app.requests, Server.instance01.app.replies)</pre> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.randomWalkFunction"> randomWalkFunction(name, step=60)</dt> <dd>
<p>Short Alias: randomWalk()</p> <p>Returns a random walk starting at 0. This is great for testing when there is no real data in whisper.</p> <p>Example:</p> <pre data-language="none">&amp;target=randomWalk("The.time.series")</pre> <p>This would create a series named “The.time.series” that contains points where x(t) == x(t-1)+random()-0.5, and x(0) == 0. Accepts optional second argument as ‘step’ parameter (default step is 60 sec)</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.rangeOfSeries"> rangeOfSeries(*seriesLists)</dt> <dd>
<p>Takes a wildcard seriesList. Distills down a set of inputs into the range of the series</p> <p>Example:</p> <pre data-language="none">&amp;target=rangeOfSeries(Server*.connections.total)</pre> <p>This is an alias for <a class="reference internal" href="#graphite.render.functions.aggregate" title="graphite.render.functions.aggregate"><code class="xref py py-func docutils literal notranslate"><span class="pre">aggregate</span></code></a> with aggregation <code class="docutils literal notranslate"><span class="pre">rangeOf</span></code>.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.reduceSeries"> reduceSeries(seriesLists, reduceFunction, reduceNode, *reduceMatchers)</dt> <dd>
<p>Short form: <code class="docutils literal notranslate"><span class="pre">reduce()</span></code></p> <p>Takes a list of seriesLists and reduces it to a list of series by means of the reduceFunction.</p> <p>Reduction is performed by matching the reduceNode in each series against the list of reduceMatchers. Then each series is passed to the reduceFunction as arguments in the order given by reduceMatchers. The reduceFunction should yield a single series.</p> <p>The resulting list of series are aliased so that they can easily be nested in other functions.</p> <p><strong>Example</strong>: Map/Reduce asPercent(bytes_used,total_bytes) for each server</p> <p>Assume that metrics in the form below exist:</p> <pre data-language="none">servers.server1.disk.bytes_used
servers.server1.disk.total_bytes
servers.server2.disk.bytes_used
servers.server2.disk.total_bytes
servers.server3.disk.bytes_used
servers.server3.disk.total_bytes
...
servers.serverN.disk.bytes_used
servers.serverN.disk.total_bytes</pre> <p>To get the percentage of disk used for each server:</p> <pre data-language="none">reduceSeries(mapSeries(servers.*.disk.*,1),"asPercent",3,"bytes_used","total_bytes") =&gt;

  alias(asPercent(servers.server1.disk.bytes_used,servers.server1.disk.total_bytes),"servers.server1.disk.reduce.asPercent"),
  alias(asPercent(servers.server2.disk.bytes_used,servers.server2.disk.total_bytes),"servers.server2.disk.reduce.asPercent"),
  alias(asPercent(servers.server3.disk.bytes_used,servers.server3.disk.total_bytes),"servers.server3.disk.reduce.asPercent"),
  ...
  alias(asPercent(servers.serverN.disk.bytes_used,servers.serverN.disk.total_bytes),"servers.serverN.disk.reduce.asPercent")</pre> <p>In other words, we will get back the following metrics:</p> <pre data-language="default">servers.server1.disk.reduce.asPercent
servers.server2.disk.reduce.asPercent
servers.server3.disk.reduce.asPercent
...
servers.serverN.disk.reduce.asPercent</pre> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <p class="last"><a class="reference internal" href="#graphite.render.functions.mapSeries" title="graphite.render.functions.mapSeries"><code class="xref py py-func docutils literal notranslate"><span class="pre">mapSeries()</span></code></a></p> </div> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.removeAbovePercentile"> removeAbovePercentile(seriesList, n)</dt> <dd>
<p>Removes data above the nth percentile from the series or list of series provided. Values above this percentile are assigned a value of None.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.removeAboveValue"> removeAboveValue(seriesList, n)</dt> <dd>
<p>Removes data above the given threshold from the series or list of series provided. Values above this threshold are assigned a value of None.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.removeBelowPercentile"> removeBelowPercentile(seriesList, n)</dt> <dd>
<p>Removes data below the nth percentile from the series or list of series provided. Values below this percentile are assigned a value of None.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.removeBelowValue"> removeBelowValue(seriesList, n)</dt> <dd>
<p>Removes data below the given threshold from the series or list of series provided. Values below this threshold are assigned a value of None.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.removeBetweenPercentile"> removeBetweenPercentile(seriesList, n)</dt> <dd>
<p>Removes series that do not have an value lying in the x-percentile of all the values at a moment</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.removeEmptySeries"> removeEmptySeries(seriesList, xFilesFactor=None)</dt> <dd>
<p>Takes one metric or a wildcard seriesList. Out of all metrics passed, draws only the metrics with not empty data</p> <p>Example:</p> <pre data-language="none">&amp;target=removeEmptySeries(server*.instance*.threads.busy)</pre> <p>Draws only live servers with not empty data.</p> <p><cite>xFilesFactor</cite> follows the same semantics as in Whisper storage schemas. Setting it to 0 (the default) means that only a single value in the series needs to be non-null for it to be considered non-empty, setting it to 1 means that all values in the series must be non-null. A setting of 0.5 means that at least half the values in the series must be non-null.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.roundFunction"> roundFunction(seriesList, precision=None)</dt> <dd>
<p>Takes one metric or a wildcard seriesList optionally followed by a precision, and rounds each datapoint to the specified precision.</p> <p>Example:</p> <pre data-language="none">&amp;target=round(Server.instance01.threads.busy)
&amp;target=round(Server.instance01.threads.busy,2)</pre> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.scale"> scale(seriesList, factor)</dt> <dd>
<p>Takes one metric or a wildcard seriesList followed by a constant, and multiplies the datapoint by the constant provided at each point.</p> <p>Example:</p> <pre data-language="none">&amp;target=scale(Server.instance01.threads.busy,10)
&amp;target=scale(Server.instance*.threads.busy,10)</pre> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.scaleToSeconds"> scaleToSeconds(seriesList, seconds)</dt> <dd>
<p>Takes one metric or a wildcard seriesList and returns “value per seconds” where seconds is a last argument to this functions.</p> <p>Useful in conjunction with derivative or integral function if you want to normalize its result to a known resolution for arbitrary retentions</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.secondYAxis"> secondYAxis(seriesList)</dt> <dd>
<p>Graph the series on the secondary Y axis.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.seriesByTag"> seriesByTag(*tagExpressions)</dt> <dd>
<p>Returns a SeriesList of series matching all the specified tag expressions.</p> <p>Example:</p> <pre data-language="none">&amp;target=seriesByTag("tag1=value1","tag2!=value2")</pre> <p>Returns a seriesList of all series that have tag1 set to value1, AND do not have tag2 set to value2.</p> <p>Tags specifiers are strings, and may have the following formats:</p> <pre data-language="none">tag=spec    tag value exactly matches spec
tag!=spec   tag value does not exactly match spec
tag=~value  tag value matches the regular expression spec
tag!=~spec  tag value does not match the regular expression spec</pre> <p>Any tag spec that matches an empty value is considered to match series that don’t have that tag.</p> <p>At least one tag spec must require a non-empty value.</p> <p>Regular expression conditions are treated as being anchored at the start of the value.</p> <p>See <a class="reference internal" href="tags.html#querying-tagged-series"><span class="std std-ref">querying tagged series</span></a> for more detail.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.setXFilesFactor"> setXFilesFactor(seriesList, xFilesFactor)</dt> <dd>
<p>Short form: xFilesFactor()</p> <p>Takes one metric or a wildcard seriesList and an xFilesFactor value between 0 and 1</p> <p>When a series needs to be consolidated, this sets the fraction of values in an interval that must not be null for the consolidation to be considered valid. If there are not enough values then None will be returned for that interval.</p> <pre data-language="none">&amp;target=xFilesFactor(Sales.widgets.largeBlue, 0.5)
&amp;target=Servers.web01.sda1.free_space|consolidateBy('max')|xFilesFactor(0.5)</pre> <p>The <cite>xFilesFactor</cite> set via this function is used as the default for all functions that accept an <cite>xFilesFactor</cite> parameter, all functions that aggregate data across multiple series and/or intervals, and <a class="reference external" href="render_api.html#maxdatapoints">maxDataPoints</a> consolidation.</p> <p>A default for the entire render request can also be set using the <a class="reference external" href="render_api.html#xfilesfactor">xFilesFactor</a> query parameter.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last"><cite>xFilesFactor</cite> follows the same semantics as in Whisper storage schemas. Setting it to 0 (the default) means that only a single value in a given interval needs to be non-null, setting it to 1 means that all values in the interval must be non-null. A setting of 0.5 means that at least half the values in the interval must be non-null.</p> </div> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.sinFunction"> sinFunction(name, amplitude=1, step=60)</dt> <dd>
<p>Short Alias: sin()</p> <p>Just returns the sine of the current time. The optional amplitude parameter changes the amplitude of the wave.</p> <p>Example:</p> <pre data-language="none">&amp;target=sin("The.time.series", 2)</pre> <p>This would create a series named “The.time.series” that contains sin(x)*2. Accepts optional second argument as ‘amplitude’ parameter (default amplitude is 1) Accepts optional third argument as ‘step’ parameter (default step is 60 sec)</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.smartSummarize"> smartSummarize(seriesList, intervalString, func='sum', alignTo=None)</dt> <dd>
<p>Smarter version of summarize.</p> <p>The alignToFrom boolean parameter has been replaced by alignTo and no longer has any effect. Alignment can be to years, months, weeks, days, hours, and minutes.</p> <p>This function can be used with aggregation functions <code class="docutils literal notranslate"><span class="pre">average</span></code>, <code class="docutils literal notranslate"><span class="pre">median</span></code>, <code class="docutils literal notranslate"><span class="pre">sum</span></code>, <code class="docutils literal notranslate"><span class="pre">min</span></code>, <code class="docutils literal notranslate"><span class="pre">max</span></code>, <code class="docutils literal notranslate"><span class="pre">diff</span></code>, <code class="docutils literal notranslate"><span class="pre">stddev</span></code>, <code class="docutils literal notranslate"><span class="pre">count</span></code>, <code class="docutils literal notranslate"><span class="pre">range</span></code>, <code class="docutils literal notranslate"><span class="pre">multiply</span></code> &amp; <code class="docutils literal notranslate"><span class="pre">last</span></code>.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.sortBy"> sortBy(seriesList, func='average', reverse=False)</dt> <dd>
<p>Takes one metric or a wildcard seriesList followed by an aggregation function and an optional <code class="docutils literal notranslate"><span class="pre">reverse</span></code> parameter.</p> <p>Returns the metrics sorted according to the specified function.</p> <p>Example:</p> <pre data-language="none">&amp;target=sortBy(server*.instance*.threads.busy,'max')</pre> <p>Draws the servers in ascending order by maximum.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.sortByMaxima"> sortByMaxima(seriesList)</dt> <dd>
<p>Takes one metric or a wildcard seriesList.</p> <p>Sorts the list of metrics in descending order by the maximum value across the time period specified. Useful with the &amp;areaMode=all parameter, to keep the lowest value lines visible.</p> <p>Example:</p> <pre data-language="none">&amp;target=sortByMaxima(server*.instance*.memory.free)</pre> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.sortByMinima"> sortByMinima(seriesList)</dt> <dd>
<p>Takes one metric or a wildcard seriesList.</p> <p>Sorts the list of metrics by the lowest value across the time period specified, including only series that have a maximum value greater than 0.</p> <p>Example:</p> <pre data-language="none">&amp;target=sortByMinima(server*.instance*.memory.free)</pre> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.sortByName"> sortByName(seriesList, natural=False, reverse=False)</dt> <dd>
<p>Takes one metric or a wildcard seriesList. Sorts the list of metrics by the metric name using either alphabetical order or natural sorting. Natural sorting allows names containing numbers to be sorted more naturally, e.g: - Alphabetical sorting: server1, server11, server12, server2 - Natural sorting: server1, server2, server11, server12</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.sortByTotal"> sortByTotal(seriesList)</dt> <dd>
<p>Takes one metric or a wildcard seriesList.</p> <p>Sorts the list of metrics in descending order by the sum of values across the time period specified.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.squareRoot"> squareRoot(seriesList)</dt> <dd>
<p>Takes one metric or a wildcard seriesList, and computes the square root of each datapoint.</p> <p>Example:</p> <pre data-language="none">&amp;target=squareRoot(Server.instance01.threads.busy)</pre> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.stacked"> stacked(seriesLists, stackName='__DEFAULT__')</dt> <dd>
<p>Takes one metric or a wildcard seriesList and change them so they are stacked. This is a way of stacking just a couple of metrics without having to use the stacked area mode (that stacks everything). By means of this a mixed stacked and non stacked graph can be made</p> <p>It can also take an optional argument with a name of the stack, in case there is more than one, e.g. for input and output metrics.</p> <p>Example:</p> <pre data-language="none">&amp;target=stacked(company.server.application01.ifconfig.TXPackets, 'tx')</pre> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.stddevSeries"> stddevSeries(*seriesLists)</dt> <dd>
<p>Takes one metric or a wildcard seriesList. Draws the standard deviation of all metrics passed at each time.</p> <p>Example:</p> <pre data-language="none">&amp;target=stddevSeries(company.server.*.threads.busy)</pre> <p>This is an alias for <a class="reference internal" href="#graphite.render.functions.aggregate" title="graphite.render.functions.aggregate"><code class="xref py py-func docutils literal notranslate"><span class="pre">aggregate</span></code></a> with aggregation <code class="docutils literal notranslate"><span class="pre">stddev</span></code>.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.stdev"> stdev(seriesList, points, windowTolerance=0.1)</dt> <dd>
<p>Takes one metric or a wildcard seriesList followed by an integer N. Draw the Standard Deviation of all metrics passed for the past N datapoints. If the ratio of null points in the window is greater than windowTolerance, skip the calculation. The default for windowTolerance is 0.1 (up to 10% of points in the window can be missing). Note that if this is set to 0.0, it will cause large gaps in the output anywhere a single point is missing.</p> <p>Example:</p> <pre data-language="none">&amp;target=stdev(server*.instance*.threads.busy,30)
&amp;target=stdev(server*.instance*.cpu.system,30,0.0)</pre> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.substr"> substr(seriesList, start=0, stop=0)</dt> <dd>
<p>Takes one metric or a wildcard seriesList followed by 1 or 2 integers. Assume that the metric name is a list or array, with each element separated by dots. Prints n - length elements of the array (if only one integer n is passed) or n - m elements of the array (if two integers n and m are passed). The list starts with element 0 and ends with element (length - 1).</p> <p>Example:</p> <pre data-language="none">&amp;target=substr(carbon.agents.hostname.avgUpdateTime,2,4)</pre> <p>The label would be printed as “hostname.avgUpdateTime”.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.sumSeries"> sumSeries(*seriesLists)</dt> <dd>
<p>Short form: sum()</p> <p>This will add metrics together and return the sum at each datapoint. (See integral for a sum over time)</p> <p>Example:</p> <pre data-language="none">&amp;target=sum(company.server.application*.requestsHandled)</pre> <p>This would show the sum of all requests handled per minute (provided requestsHandled are collected once a minute). If metrics with different retention rates are combined, the coarsest metric is graphed, and the sum of the other metrics is averaged for the metrics with finer retention rates.</p> <p>This is an alias for <a class="reference internal" href="#graphite.render.functions.aggregate" title="graphite.render.functions.aggregate"><code class="xref py py-func docutils literal notranslate"><span class="pre">aggregate</span></code></a> with aggregation <code class="docutils literal notranslate"><span class="pre">sum</span></code>.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.sumSeriesWithWildcards"> sumSeriesWithWildcards(seriesList, *position)</dt> <dd>
<p>Call sumSeries after inserting wildcards at the given position(s).</p> <p>Example:</p> <pre data-language="none">&amp;target=sumSeriesWithWildcards(host.cpu-[0-7].cpu-{user,system}.value, 1)</pre> <p>This would be the equivalent of</p> <pre data-language="none">&amp;target=sumSeries(host.cpu-[0-7].cpu-user.value)&amp;target=sumSeries(host.cpu-[0-7].cpu-system.value)</pre> <p>This is an alias for <a class="reference internal" href="#graphite.render.functions.aggregateWithWildcards" title="graphite.render.functions.aggregateWithWildcards"><code class="xref py py-func docutils literal notranslate"><span class="pre">aggregateWithWildcards</span></code></a> with aggregation <code class="docutils literal notranslate"><span class="pre">sum</span></code>.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.summarize"> summarize(seriesList, intervalString, func='sum', alignToFrom=False)</dt> <dd>
<p>Summarize the data into interval buckets of a certain size.</p> <p>By default, the contents of each interval bucket are summed together. This is useful for counters where each increment represents a discrete event and retrieving a “per X” value requires summing all the events in that interval.</p> <p>Specifying ‘average’ instead will return the mean for each bucket, which can be more useful when the value is a gauge that represents a certain value in time.</p> <p>This function can be used with aggregation functions <code class="docutils literal notranslate"><span class="pre">average</span></code>, <code class="docutils literal notranslate"><span class="pre">median</span></code>, <code class="docutils literal notranslate"><span class="pre">sum</span></code>, <code class="docutils literal notranslate"><span class="pre">min</span></code>, <code class="docutils literal notranslate"><span class="pre">max</span></code>, <code class="docutils literal notranslate"><span class="pre">diff</span></code>, <code class="docutils literal notranslate"><span class="pre">stddev</span></code>, <code class="docutils literal notranslate"><span class="pre">count</span></code>, <code class="docutils literal notranslate"><span class="pre">range</span></code>, <code class="docutils literal notranslate"><span class="pre">multiply</span></code> &amp; <code class="docutils literal notranslate"><span class="pre">last</span></code>.</p> <p>By default, buckets are calculated by rounding to the nearest interval. This works well for intervals smaller than a day. For example, 22:32 will end up in the bucket 22:00-23:00 when the interval=1hour.</p> <p>Passing alignToFrom=true will instead create buckets starting at the from time. In this case, the bucket for 22:32 depends on the from time. If from=6:30 then the 1hour bucket for 22:32 is 22:30-23:30.</p> <p>Example:</p> <pre data-language="none">&amp;target=summarize(counter.errors, "1hour") # total errors per hour
&amp;target=summarize(nonNegativeDerivative(gauge.num_users), "1week") # new users per week
&amp;target=summarize(queue.size, "1hour", "avg") # average queue size per hour
&amp;target=summarize(queue.size, "1hour", "max") # maximum queue size during each hour
&amp;target=summarize(metric, "13week", "avg", true)&amp;from=midnight+20100101 # 2010 Q1-4</pre> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.threshold"> threshold(value, label=None, color=None)</dt> <dd>
<p>Takes a float F, followed by a label (in double quotes) and a color. (See <code class="docutils literal notranslate"><span class="pre">bgcolor</span></code> in the <a class="reference internal" href="render_api.html"><span class="doc">Render API</span></a> for valid color names &amp; formats.)</p> <p>Draws a horizontal line at value F across the graph.</p> <p>Example:</p> <pre data-language="none">&amp;target=threshold(123.456, "omgwtfbbq", "red")</pre> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.timeFunction"> timeFunction(name, step=60)</dt> <dd>
<p>Short Alias: time()</p> <p>Just returns the timestamp for each X value. T</p> <p>Example:</p> <pre data-language="none">&amp;target=time("The.time.series")</pre> <p>This would create a series named “The.time.series” that contains in Y the same value (in seconds) as X. Accepts optional second argument as ‘step’ parameter (default step is 60 sec)</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.timeShift"> timeShift(seriesList, timeShift, resetEnd=True, alignDST=False)</dt> <dd>
<p>Takes one metric or a wildcard seriesList, followed by a quoted string with the length of time (See <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">/</span> <span class="pre">until</span></code> in the <a class="reference internal" href="render_api.html"><span class="doc">Render API</span></a> for examples of time formats).</p> <p>Draws the selected metrics shifted in time. If no sign is given, a minus sign ( - ) is implied which will shift the metric back in time. If a plus sign ( + ) is given, the metric will be shifted forward in time.</p> <p>Will reset the end date range automatically to the end of the base stat unless resetEnd is False. Example case is when you timeshift to last week and have the graph date range set to include a time in the future, will limit this timeshift to pretend ending at the current time. If resetEnd is False, will instead draw full range including future time.</p> <p>Because time is shifted by a fixed number of seconds, comparing a time period with DST to a time period without DST, and vice-versa, will result in an apparent misalignment. For example, 8am might be overlaid with 7am. To compensate for this, use the alignDST option.</p> <p>Useful for comparing a metric against itself at a past periods or correcting data stored at an offset.</p> <p>Example:</p> <pre data-language="none">&amp;target=timeShift(Sales.widgets.largeBlue,"7d")
&amp;target=timeShift(Sales.widgets.largeBlue,"-7d")
&amp;target=timeShift(Sales.widgets.largeBlue,"+1h")</pre> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.timeSlice"> timeSlice(seriesList, startSliceAt, endSliceAt='now')</dt> <dd>
<p>Takes one metric or a wildcard metric, followed by a quoted string with the time to start the line and another quoted string with the time to end the line. The start and end times are inclusive. See <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">/</span> <span class="pre">until</span></code> in the <a class="reference internal" href="render_api.html"><span class="doc">Render API</span></a> for examples of time formats.</p> <p>Useful for filtering out a part of a series of data from a wider range of data.</p> <p>Example:</p> <pre data-language="none">&amp;target=timeSlice(network.core.port1,"00:00 20140101","11:59 20140630")
&amp;target=timeSlice(network.core.port1,"12:00 20140630","now")</pre> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.timeStack"> timeStack(seriesList, timeShiftUnit='1d', timeShiftStart=0, timeShiftEnd=7)</dt> <dd>
<p>Takes one metric or a wildcard seriesList, followed by a quoted string with the length of time (See <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">/</span> <span class="pre">until</span></code> in the <a class="reference internal" href="render_api.html"><span class="doc">Render API</span></a> for examples of time formats). Also takes a start multiplier and end multiplier for the length of time</p> <p>create a seriesList which is composed the original metric series stacked with time shifts starting time shifts from the start multiplier through the end multiplier</p> <p>Useful for looking at history, or feeding into averageSeries or stddevSeries.</p> <p>Example:</p> <pre data-language="none">&amp;target=timeStack(Sales.widgets.largeBlue,"1d",0,7)    # create a series for today and each of the previous 7 days</pre> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.transformNull"> transformNull(seriesList, default=0, referenceSeries=None)</dt> <dd>
<p>Takes a metric or wildcard seriesList and replaces null values with the value specified by <cite>default</cite>. The value 0 used if not specified. The optional referenceSeries, if specified, is a metric or wildcard series list that governs which time intervals nulls should be replaced. If specified, nulls are replaced only in intervals where a non-null is found for the same interval in any of referenceSeries. This method compliments the drawNullAsZero function in graphical mode, but also works in text-only mode.</p> <p>Example:</p> <pre data-language="none">&amp;target=transformNull(webapp.pages.*.views,-1)</pre> <p>This would take any page that didn’t have values and supply negative 1 as a default. Any other numeric value may be used as well.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.unique"> unique(*seriesLists)</dt> <dd>
<p>Takes an arbitrary number of seriesLists and returns unique series, filtered by name.</p> <p>Example:</p> <pre data-language="none">&amp;target=unique(mostDeviant(server.*.disk_free,5),lowestCurrent(server.*.disk_free,5))</pre> <p>Draws servers with low disk space, and servers with highly deviant disk space, but never the same series twice.</p> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.useSeriesAbove"> useSeriesAbove(seriesList, value, search, replace)</dt> <dd>
<p>Compares the maximum of each series against the given <cite>value</cite>. If the series maximum is greater than <cite>value</cite>, the regular expression search and replace is applied against the series name to plot a related metric</p> <p>e.g. given useSeriesAbove(ganglia.metric1.reqs,10,’reqs’,’time’), the response time metric will be plotted only when the maximum value of the corresponding request/s metric is &gt; 10</p> <pre data-language="none">&amp;target=useSeriesAbove(ganglia.metric1.reqs,10,"reqs","time")</pre> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.verticalLine"> verticalLine(ts, label=None, color=None)</dt> <dd>
<p>Takes a timestamp string ts.</p> <p>Draws a vertical line at the designated timestamp with optional ‘label’ and ‘color’. Supported timestamp formats include both relative (e.g. -3h) and absolute (e.g. 16:00_20110501) strings, such as those used with <code class="docutils literal notranslate"><span class="pre">from</span></code> and <code class="docutils literal notranslate"><span class="pre">until</span></code> parameters. When set, the ‘label’ will appear in the graph legend.</p> <p>Note: Any timestamps defined outside the requested range will raise a ‘ValueError’ exception.</p> <p>Example:</p> <pre data-language="none">&amp;target=verticalLine("12:3420131108","event","blue")
&amp;target=verticalLine("16:00_20110501","event")
&amp;target=verticalLine("-5mins")</pre> </dd>
</dl> <dl class="function"> <dt id="graphite.render.functions.weightedAverage"> weightedAverage(seriesListAvg, seriesListWeight, *nodes)</dt> <dd>
<p>Takes a series of average values and a series of weights and produces a weighted average for all values. The corresponding values should share one or more zero-indexed nodes and/or tags.</p> <p>Example:</p> <pre data-language="none">&amp;target=weightedAverage(*.transactions.mean,*.transactions.count,0)</pre> <p>Each node may be an integer referencing a node in the series name or a string identifying a tag.</p> </dd>
</dl>   <h2 id="function-plugins">Function Plugins</h2> <p>Function plugins can define additional functions for use in render calls.</p> <p>A function plugin is simply a file defining one or more functions and exporting dictionaries of <code class="docutils literal notranslate"><span class="pre">SeriesFunctions</span></code> and/or <code class="docutils literal notranslate"><span class="pre">PieFunctions</span></code>. When Graphite loads the plugin it will add functions in <code class="docutils literal notranslate"><span class="pre">SeriesFunctions</span></code> and/or <code class="docutils literal notranslate"><span class="pre">PieFunctions</span></code> to the list of available functions.</p> <p>Each exposed function must accept at least a <code class="docutils literal notranslate"><span class="pre">requestContext</span></code> and <code class="docutils literal notranslate"><span class="pre">seriesList</span></code> parameter, and may accept additional parameters as needed.</p> <p><code class="docutils literal notranslate"><span class="pre">requestContext</span></code> will be a dictionary as defined in <code class="docutils literal notranslate"><span class="pre">graphite.render.views.renderView()</span></code>, <code class="docutils literal notranslate"><span class="pre">seriesList</span></code> will be a list of <code class="docutils literal notranslate"><span class="pre">TimeSeries</span></code> objects.</p> <pre data-language="python">from graphite.functions.params import Param, ParamTypes

def toUpperCase(requestContext, seriesList):
  """Custom function that changes series names to UPPERCASE"""
  for series in seriesList:
    series.name = series.name.upper()
  return seriesList

# optionally set the group attribute
toUpperCase.group = 'Custom'
toUpperCase.params = [
  Param('seriesList', ParamTypes.seriesList, required=True),
]

SeriesFunctions = {
  'upper': toUpperCase,
}</pre> <p>Each function can have a docstring, <code class="docutils literal notranslate"><span class="pre">.group</span></code>, and <code class="docutils literal notranslate"><span class="pre">.params</span></code> attributes defined, these are used in the function API output as hints for query builders.</p> <p>The <code class="docutils literal notranslate"><span class="pre">.group</span></code> attribute is the group name as a string, the <code class="docutils literal notranslate"><span class="pre">.params</span></code> attribute is a list of parameter definitions.</p> <p>Each parameter definition is <code class="docutils literal notranslate"><span class="pre">Param</span></code> object, the <code class="docutils literal notranslate"><span class="pre">Param</span></code> constructor accepts the following arguments (note that <cite>requestContext</cite> is not included in the list of parameters):</p> <ul class="simple"> <li>
<strong>name</strong>: The name of the parameter</li> <li>
<strong>paramtype</strong>: The parameter type, one of:<ul> <li>
<strong>ParamTypes.aggFunc</strong>: An aggregation function name</li> <li>
<strong>ParamTypes.boolean</strong>: True/False</li> <li>
<strong>ParamTypes.date</strong>: A date specification</li> <li>
<strong>ParamTypes.float</strong>: A float value</li> <li>
<strong>ParamTypes.integer</strong>: An integer value</li> <li>
<strong>ParamTypes.interval</strong>: An interval specifier like <code class="docutils literal notranslate"><span class="pre">1h</span></code>, <code class="docutils literal notranslate"><span class="pre">1d</span></code>, etc</li> <li>
<strong>ParamTypes.intOrInterval</strong>: An integer or interval specifier</li> <li>
<strong>ParamTypes.node</strong>: A node number</li> <li>
<strong>ParamTypes.nodeOrTag</strong>: A node number or tag name</li> <li>
<strong>ParamTypes.series</strong>: A single series</li> <li>
<strong>ParamTypes.seriesList</strong>: A list of series</li> <li>
<strong>ParamTypes.seriesLists</strong>: A list of seriesLists</li> <li>
<strong>ParamTypes.string</strong>: A string value</li> <li>
<strong>ParamTypes.tag</strong>: A tag name</li> </ul> </li> <li>
<strong>required</strong>: Set to <code class="docutils literal notranslate"><span class="pre">True</span></code> for required parameters</li> <li>
<strong>default</strong>: Default value for optional parameters</li> <li>
<strong>multiple</strong>: Set to <code class="docutils literal notranslate"><span class="pre">True</span></code> for parameters that accept multiple instances (defined with <code class="docutils literal notranslate"><span class="pre">*</span></code> in Python)</li> <li>
<strong>options</strong>: A list of available values for parameters that accept only a defined list</li> <li>
<strong>suggestions</strong>: A list of suggested values for parameters that accept free-form values</li> </ul> <p>Custom plugin files may be placed in the <code class="docutils literal notranslate"><span class="pre">/opt/graphite/webapp/graphite/functions/custom</span></code> folder and will be loaded automatically when graphite starts.</p> <p>To load a packaged function plugin module, add it to the <code class="docutils literal notranslate"><span class="pre">FUNCTION_PLUGINS</span></code> setting:</p> <pre data-language="python">FUNCTION_PLUGINS = [
  'some.function_plugin',
]</pre>   <h2 id="function-api">Function API</h2> <p>You can use the HTTP api to get a list of available functions, or the details of a specific function.</p> <p>To get a list of available functions:</p> <pre data-language="none">$ curl -s "http://graphite/functions?pretty=1"

{
  "absolute": {
    "description": "&lt;function description&gt;",
    "function": "absolute(seriesList)",
    "group": "Transform",
    "module": "graphite.render.functions",
    "name": "absolute",
    "params": [
      {
        "name": "seriesList",
        "required": true,
        "type": "seriesList"
      }
    ]
  },
  &lt;more functions...&gt;
}</pre> <p>If the parameter <code class="docutils literal notranslate"><span class="pre">grouped=1</span></code> is passed, the returned list will be organized by group:</p> <pre data-language="none">$ curl -s "http://graphite/functions?pretty=1&amp;grouped=1"

{
  "Alias": {
    &lt;alias functions...&gt;
  },
  &lt;more groups...&gt;
}</pre> <p>To get the definition of a specific function:</p> <pre data-language="none">$ curl -s "http://graphite/functions/absolute?pretty=1"

{
  "description": "&lt;function description&gt;",
  "function": "absolute(seriesList)",
  "group": "Transform",
  "module": "graphite.render.functions",
  "name": "absolute",
  "params": [
    {
      "name": "seriesList",
      "required": true,
      "type": "seriesList"
    }
  ]
}</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2008&ndash;2012 Chris Davis<br>&copy; 2011&ndash;2016 The Graphite Project<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://graphite.readthedocs.io/en/latest/functions.html" class="_attribution-link">https://graphite.readthedocs.io/en/latest/functions.html</a>
  </p>
</div>
