<h1>6. Questions &amp; Answers</h1>

<div class="css-elchao exirf770">
<div class="toc"><ul>
<li><a href="#why-should-you-upgrade-to-yarn-modern">Why should you upgrade to Yarn Modern?</a></li>
<li><a href="#how-easy-should-you-expect-the-migration-from-classic-to-modern-to-be">How easy should you expect the migration from Classic to Modern to be?</a></li>
<li><a href="#which-files-should-be-gitignored">Which files should be gitignored?</a></li>
<li><a href="#should-lockfiles-be-committed-to-the-repository">Should lockfiles be committed to the repository?</a></li>
<li><a href="#how-to-share-scripts-between-workspaces">How to share scripts between workspaces?</a></li>
<li><a href="#is-yarn-operated-by-facebook">Is Yarn operated by Facebook?</a></li>
<li><a href="#why-registryyarnpkgcom-does-facebook-track-us">Why <code class="language-text">registry.yarnpkg.com</code>? Does Facebook track us?</a></li>
<li><a href="#queries-to-registryyarnpkgcom-return-a-404500-is-it-down">Queries to <code class="language-text">registry.yarnpkg.com</code> return a 404/500/...; is it down?</a></li>
<li><a href="#is-yarn-faster-than-other-package-managers">Is Yarn faster than other package managers?</a></li>
<li><a href="#why-is-typescript-patched-even-if-i-dont-use-plugnplay">Why is TypeScript patched even if I don't use Plug'n'Play?</a></li>
</ul></div>
<h2 id="why-should-you-upgrade-to-yarn-modern">
Why should you upgrade to Yarn Modern?</h2>
<p>While the Yarn Classic line (1.x) remains a pillar of the JavaScript ecosystem, we recommend upgrading if possible. Why's that?</p>
<ol>
<li><p>New features: On top of the classic features you're already used to, on top of the new ones you'll discover (<a href="../cli/dlx.html"><code class="language-text">yarn dlx</code></a>, <a href="https://github.com/yarnpkg/berry/tree/master/packages/plugin-patch">builtin <code class="language-text">patch:</code> protocol</a>, ...), Modern offers plugins extending Yarn's featureset with <a href="../features/release-workflow.html">changesets</a>, <a href="../features/constraints.html">constraints</a>, <a href="../cli/workspaces/foreach.html">workspaces</a>, ...</p></li>
<li><p>Efficiency: Modern features new install strategies, leading projects to only be a fraction of their past self; as an example, under the default configuration the stock CRA artifacts now only take 45MB instead of 237MB. <a href="https://p.datadoghq.eu/sb/d2wdprp9uki7gfks-c562c42f4dfd0ade4885690fa719c818">Performances</a> were improved as well, with most installs now only taking a few seconds even on extremely large projects. We even made it possible to reach <a href="../features/zero-installs.html">zero seconds</a>!</p></li>
<li><p>Extensibility: Modern's architecture allows you to build your own features as you need it. No more of you being blocked waiting for us to implement this feature you dream of - you can now do it yourself, according to your own specs! Focused workspaces, custom installs, project validation, ...</p></li>
<li><p>Stability: Modern comes after years of experience with maintaining Classic; it allowed us to finally fix longstanding design issues with how some features were implemented. Workspaces are now core components, the resolution pipeline has been streamlined, data structures are more efficient... as a result, Modern is much less likely to suffer from incorrect assumptions and other design flaws.</p></li>
<li><p>Future proof: A big reason why we invested in Modern was that we noticed how building new features on Classic was becoming difficult - each change being too likely to have unforeseen consequences. The Modern architecture learned from our mistakes, and was designed to allow us to build features at a much higher pace - as evidenced by our new gained velocity.</p></li>
</ol>
<h2 id="how-easy-should-you-expect-the-migration-from-classic-to-modern-to-be">
How easy should you expect the migration from Classic to Modern to be?</h2>
<p>Generally, a few main things will need to be taken care of:</p>
<ol>
<li><p>The settings format changed. We don't read the <code class="language-text">.npmrc</code> or <code class="language-text">.yarnrc</code> files anymore, instead of consuming the settings from the <a href="../configuration/yarnrc.html"><code class="language-text">.yarnrc.yml</code> file</a>.</p></li>
<li><p>Some third-party packages don't list their dependencies properly and will need to be helped through the <a href="../configuration/yarnrc.html#packageExtensions"><code class="language-text">packageExtensions</code></a> settings.</p></li>
<li><p>Support for text editors is pretty good, but you'll need to run the one-time-setup listed in our <a href="editor-sdks.html">SDK documentation</a>.</p></li>
<li><p>Some tools (mostly React Native and Flow) will require downgrading to the <code class="language-text">node_modules</code> install strategy by setting the <a href="../configuration/yarnrc.html#nodeLinker"><code class="language-text">nodeLinker</code></a> setting to <code class="language-text">node-modules</code>. TypeScript doesn't have this problem.</p></li>
</ol>
<p>Most projects will only face those four problems, which can all be fixed in a good afternoon of work. For more detailed instructions, please see the detailed <a href="migration.html">migration guide</a>.</p>
<h2 id="which-files-should-be-gitignored">
Which files should be gitignored?</h2>
<p>If you're using Zero-Installs:</p>
<div class="gatsby-highlight" data-language="gitignore"><pre class="language-gitignore"><code class="language-gitignore"><span class="token entry string">.yarn<span class="token punctuation">/</span><span class="token operator">*</span></span>
<span class="token entry string"><span class="token operator">!</span>.yarn<span class="token punctuation">/</span>cache</span>
<span class="token entry string"><span class="token operator">!</span>.yarn<span class="token punctuation">/</span>patches</span>
<span class="token entry string"><span class="token operator">!</span>.yarn<span class="token punctuation">/</span>plugins</span>
<span class="token entry string"><span class="token operator">!</span>.yarn<span class="token punctuation">/</span>releases</span>
<span class="token entry string"><span class="token operator">!</span>.yarn<span class="token punctuation">/</span>sdks</span>
<span class="token entry string"><span class="token operator">!</span>.yarn<span class="token punctuation">/</span>versions</span></code></pre></div>
<p>If you're not using Zero-Installs:</p>
<div class="gatsby-highlight" data-language="gitignore"><pre class="language-gitignore"><code class="language-gitignore"><span class="token entry string">.pnp.<span class="token operator">*</span></span>
<span class="token entry string">.yarn<span class="token punctuation">/</span><span class="token operator">*</span></span>
<span class="token entry string"><span class="token operator">!</span>.yarn<span class="token punctuation">/</span>patches</span>
<span class="token entry string"><span class="token operator">!</span>.yarn<span class="token punctuation">/</span>plugins</span>
<span class="token entry string"><span class="token operator">!</span>.yarn<span class="token punctuation">/</span>releases</span>
<span class="token entry string"><span class="token operator">!</span>.yarn<span class="token punctuation">/</span>sdks</span>
<span class="token entry string"><span class="token operator">!</span>.yarn<span class="token punctuation">/</span>versions</span></code></pre></div>
<p>If you're interested to know more about each of these files:</p>
<ul>
<li><p><code class="language-text">.yarn/cache</code> and <code class="language-text">.pnp.*</code> may be safely ignored, but you'll need to run <code class="language-text">yarn install</code> to regenerate them between each branch switch - which would be optional otherwise, cf <a href="../features/zero-installs.html">Zero-Installs</a>.</p></li>
<li><p><code class="language-text">.yarn/install-state.gz</code> is an optimization file that you shouldn't ever have to commit. It simply stores the exact state of your project so that the next commands can boot without having to resolve your workspaces all over again.</p></li>
<li><p><code class="language-text">.yarn/patches</code> contain the patchfiles you've been generating with the <a href="../cli/patch-commit.html"><code class="language-text">yarn patch-commit</code></a> command. You always want them in your repository, since they are necessary to install your dependencies.</p></li>
<li><p><code class="language-text">.yarn/plugins</code> and <code class="language-text">.yarn/releases</code> contain the Yarn releases used in the current repository (as defined by <a href="../cli/set/version.html"><code class="language-text">yarn set version</code></a>). You will want to keep them versioned (this prevents potential issues if, say, two engineers use different Yarn versions with different features).</p></li>
<li><p><code class="language-text">.yarn/sdks</code> contains the editor SDKs generated by <code class="language-text">@yarnpkg/sdks</code>. Whether to keep it in your repository or not is up to you; if you don't, you'll need to follow the editor procedure again on new clones. See <a href="editor-sdks.html">Editor SDKs</a> for more details.</p></li>
<li><p><code class="language-text">.yarn/unplugged</code> should likely always be ignored since they typically hold machine-specific build artifacts. Ignoring it might however prevent <a href="../features/zero-installs.html">Zero-Installs</a> from working (to prevent this, set <a href="../configuration/yarnrc.html#enableScripts"><code class="language-text">enableScripts</code></a> to <code class="language-text">false</code>).</p></li>
<li><p><code class="language-text">.yarn/versions</code> is used by the <a href="../features/release-workflow.html">version plugin</a> to store the package release definitions. You will want to keep it within your repository.</p></li>
<li><p><code class="language-text">yarn.lock</code> should always be stored within your repository (<a href="#should-lockfiles-be-committed-to-the-repository">even if you develop a library</a>).</p></li>
<li><p><code class="language-text">.yarnrc.yml</code> (and its older counterpart, <code class="language-text">.yarnrc</code>) are configuration files. They should always be stored in your project.</p></li>
</ul>
<blockquote>
<p><strong>Tip:</strong> You can also add a <code class="language-text">.gitattributes</code> file to identify the release and plugin bundles as binary content. This way Git won't bother showing massive diffs when each time you subsequently add or update them:</p>
<div class="gatsby-highlight" data-language="gitattributes"><pre class="language-gitattributes"><code class="language-gitattributes">/.yarn/releases/** binary
/.yarn/plugins/** binary</code></pre></div>
</blockquote>
<h2 id="should-lockfiles-be-committed-to-the-repository">
Should lockfiles be committed to the repository?</h2>
<p><strong>Yes.</strong></p>
<p>Lockfiles are meant to always be stored along with your project sources - and this regardless of whether you're writing a standalone application or a distributed library.</p>
<p>One persisting argument against checking-in the lockfile in the repository is about being made aware of potential problems against the latest versions of the library. People saying this argue that the lockfile being present prevents contributors from seeing such issues, as all dependencies are locked and appear fine until a consumer installs the library and uses more recent (and incompatible) dependencies.</p>
<p>Although tempting, this reasoning has a fatal flaw: removing the lockfile from the repository doesn't prevent this problem from happening. In particular:</p>
<ul>
<li><p>Active contributors won't get new versions unless they explicitly remove their install artifacts (<code class="language-text">node_modules</code>), which may not happen often. Problematic dependency upgrades will thus be mainly discovered by new contributors, which doesn't make for a good first experience and may deter contributions.</p></li>
<li><p>Even assuming you run fresh installs every week, your upgrades won't be easily reversible - once you test the most recent packages, you won't test against the less recent ones. The compatibility issues will still exist, they just will be against packages that used to work but that you don't test anymore. in other words, by always testing the most recent semver release, you won't see if you accidentally start relying on a feature that wasn't available before.</p></li>
</ul>
<p>Of course these points are only part of the problem - the lack of lockfile also means that key state information are missing from the repository. When months later you or your contributors want to make a fix on one of your old projects you might not even be able to <em>build</em> it anymore, let alone improve it.</p>
<p>Lockfiles should <strong>always</strong> be kept within the repository. Continuous integration testing <strong>is a good idea</strong>, but should be left to continuous integration systems. For example, Yarn itself runs <a href="https://github.com/yarnpkg/berry#current-status">daily tests</a> against the latest versions of major open-source frameworks and tools, which allows us to quickly spot any compatibility issue with the newest release, while still being guarateed that every contributor will have a consistent experience working with the project. <a href="https://dependabot.com/#how-it-works">Dependabot</a> and <a href="https://www.whitesourcesoftware.com/free-developer-tools/renovate">Renovate</a> are also good tools that track your dependencies updates for you.</p>
<h2 id="how-to-share-scripts-between-workspaces">
How to share scripts between workspaces?</h2>
<p>Little-known Yarn feature: any script with a colon in its name (<code class="language-text">build:foo</code>) can be called from any workspace. Another little-known feature: <code class="language-text">$INIT_CWD</code> will always point to the directory running the script. Put together, you can write scripts that can be reused this way:</p>
<div class="gatsby-highlight" data-language="json"><pre class="language-json"><code class="language-json"><span class="token punctuation">{</span>
  <span class="token property">"dependencies"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">"typescript"</span><span class="token operator">:</span> <span class="token string">"^3.8.0"</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token property">"scripts"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">"g:tsc"</span><span class="token operator">:</span> <span class="token string">"cd $INIT_CWD &amp;&amp; tsc"</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></div>
<p>Then, from any workspace that contains its own <code class="language-text">tsconfig.json</code>, you'll be able to call TypeScript:</p>
<div class="gatsby-highlight" data-language="json"><pre class="language-json"><code class="language-json"><span class="token punctuation">{</span>
  <span class="token property">"scripts"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">"build"</span><span class="token operator">:</span> <span class="token string">"yarn g:tsc"</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></div>
<p>or if you only want to use <code class="language-text">tsc</code> from the root workspace:</p>
<div class="gatsby-highlight" data-language="json"><pre class="language-json"><code class="language-json"><span class="token punctuation">{</span>
  <span class="token property">"scripts"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">"build"</span><span class="token operator">:</span> <span class="token string">"run -T tsc"</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></div>
<p>Should you want to run a script in the base of your project:</p>
<div class="gatsby-highlight" data-language="json"><pre class="language-json"><code class="language-json"><span class="token punctuation">{</span>
  <span class="token property">"scripts"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">"build"</span><span class="token operator">:</span> <span class="token string">"node ${PROJECT_CWD}/scripts/update-contributors.js"</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></div>
<h2 id="is-yarn-operated-by-facebook">
Is Yarn operated by Facebook?</h2>
<p><strong>No.</strong></p>
<p>Despite the first version of Yarn having been implemented by <a href="https://twitter.com/sebmck">Sebastian McKenzie</a> while working at Facebook, the initial design received feedbacks from various other companies (such as <a href="https://www.tilde.io">Tilde</a> via <a href="https://yehudakatz.com/2016/10/11/im-excited-to-work-on-yarn-the-new-js-package-manager-2/">Yehuda Katz</a>) and the project was put into its own <a href="https://github.com/yarnpkg">GitHub organization</a>. Facebook kept investing in it during the following years (mostly because it proved to be a critical part of the RN ecosystem) but major contributions came from the open-source too.</p>
<p>Nowadays, the active development team is composed exclusively of people employed by non-founders companies. Facebook employees are of course still welcome to offer contributions to the project, but they would go through the same review process as everyone else.</p>
<h2 id="why-registryyarnpkgcom-does-facebook-track-us">
Why <code class="language-text">registry.yarnpkg.com</code>? Does Facebook track us?</h2>
<p><strong>No.</strong></p>
<p>When Yarn got created, the npm registry used to be served through Fastly. This was apparently affecting the install performances, so the initial team decided to partner with Cloudflare and setup a <a href="https://en.wikipedia.org/wiki/Reverse_proxy">reverse proxy</a> that would simply better cache the requests before returning them. This setup didn't even have a backend on our side.</p>
<p>At some point npm switched to Cloudflare as well, and we turned off the proxy to replace it by a <a href="https://en.wikipedia.org/wiki/CNAME_record">CNAME</a> (<a href="https://toolbox.googleapps.com/apps/dig/#CNAME/registry.yarnpkg.com">proof</a>). We still keep the hostname for reliability reasons - while it stands to reason that the Yarn domain name will keep being maintained for as long as Yarn is being used, the same isn't necessarily true of the npm domain name. That gives us the ability to redirect to a read-only copy of the registry should the primary source become unavailable.</p>
<p>While we do gather some basic <a href="../advanced/telemetry.html">client-side telemetry</a>, no http logs can ever even reach the Yarn project infrastructure - and even less Facebook, which has no control over the project (see also, <a href="qa.html#is-yarn-operated-by-facebook">Is Yarn operated by Facebook?</a>).</p>
<h2 id="queries-to-registryyarnpkgcom-return-a-404500-is-it-down">
Queries to <code class="language-text">registry.yarnpkg.com</code> return a 404/500/...; is it down?</h2>
<p><strong>No.</strong></p>
<p>As mentioned in the <a href="#why-registryyarnpkgcom-does-facebook-track-us">previous section</a>, the Yarn registry is just a CNAME to the npm registry. Since we don't even have a backend, any server error can only come from the npm registry and thus should be reported to them and monitored on their <a href="https://status.npmjs.org/">status page</a>.</p>
<h2 id="is-yarn-faster-than-other-package-managers">
Is Yarn faster than other package managers?</h2>
<p><strong>Shrug 🤷‍♀️</strong></p>
<p>At the time Yarn got released Yarn was effectively much faster than some of its competitors. Unfortunately, we failed to highlight that performance wasn't the main reason why we kept working on Yarn. Performances come and go, so while we were super fast it wasn't so much because we were doing something incredibly well, but rather that the competing implementations had a serious bug. When that bug got fixed, our miscommunication became more apparent as some people thought that Yarn was all about performances.</p>
<p>Put simply, our differences lie in our priorities. Different projects make different tradeoffs, and it's exactly what happens here. We prioritized workspaces because we felt like monorepos were providing significant value. We've spent significant resources pushing for Plug'n'Play (including through <a href="https://github.com/pulls?utf8=%E2%9C%93&amp;q=is%3Apr+author%3Aarcanis+archived%3Afalse+is%3Aclosed+pnp+-user%3Ayarnpkg+">dozens of contributions to third-party projects</a>) because we felt like this was important for the ecosystem. This is the main difference: we make our own informed decisions regarding the project roadmap.</p>
<p>Speed is relative and a temporary state. Processes, roadmaps and core values are what stick.</p>
<h2 id="why-is-typescript-patched-even-if-i-dont-use-plugnplay">
Why is TypeScript patched even if I don't use Plug'n'Play?</h2>
<p>Given that PnP is a resolver standard different from Node, tools that reimplement the <code class="language-text">require.resolve</code> API need to add some logic to account for the PnP resolution. While various projects did so (for example Webpack 5 now supports PnP out of the box), a few are still on the fence about it. In the case of TypeScript we started and keep maintaining a <a href="https://github.com/microsoft/TypeScript/pull/35206">pull request</a>, but the TypeScript team still has to accept it. In order to unblock our users, we made the decision to automatically apply this exact pull request to the downloaded TypeScript versions, using our new <a href="../features/protocols.html#patch"><code class="language-text">patch:</code> protocol</a>.</p>
<p>Which now begs the question: why do we still apply this patch even when Plug'n'Play is disabled? The main reason is that Yarn intends to provide consistent behaviour. Some setups involve using the <code class="language-text">node_modules</code> linker during development (to avoid having to setup editor <a href="editor-sdks.html">SDKS</a>) and PnP in production (for install speed). If we were to only apply the patches when PnP is enabled, then the package cache would turn different, which would for example break immutable installs.</p>
<p>We <em>could</em> potentially make it configurable through a switch, but in the end we decided it wasn't worth the extra configuration:</p>
<ul>
<li>The TypeScript patch is a noop if PnP isn't enabled, so this shouldn't affect your work (if it does, please open an issue)</li>
<li>We hope to eventually land this PR in TypeScript one day, so the more eyes we can get on it the higher our confidence will be</li>
<li>Since Yarn 3+, failing builtin patches are simply ignored and fallback to the original sources</li>
</ul>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2016&ndash;present Yarn Contributors<br>Licensed under the BSD License.<br>
    <a href="https://yarnpkg.com/getting-started/qa" class="_attribution-link">https://yarnpkg.com/getting-started/qa</a>
  </p>
</div>
