<h1>Release Workflow</h1>

<div class="css-elchao exirf770">
<blockquote>
<p><strong>Experimental</strong></p>
<p>This feature is still incubating, and we'll likely be improving it based on your feedback.</p>
</blockquote>
<blockquote>
<p><strong>Plugin</strong></p>
<p>To access this feature, first install the <code class="language-text">version</code> plugin: <code class="language-text">yarn plugin import version</code></p>
</blockquote>
<p>When working with monorepos, a hard task often is to figure out which packages should receive a new version when starting a new release. Yarn offers a few tools that aim to make this workflow easier without the need for third-party tools (although it's possible you may prefer the workflow offered by different implementations, of course!).</p>
<div class="toc"><ul>
<li><p><a href="#auto-updated-dependencies">Auto-updated dependencies</a></p></li>
<li><p><a href="#deferred-versioning">Deferred versioning</a></p></li>
<li><p><a href="#checked-in-deferred-records">Checked-in deferred records</a></p></li>
<li>
<p><a href="#ensuring-that-versions-are-bumped-ci">Ensuring that versions are bumped (CI)</a></p>
<ul><li>
<p><a href="#caveat">Caveat</a></p>
<ul><li><a href="#commit-history">Commit history</a></li></ul>
</li></ul>
</li>
</ul></div>
<h2 id="auto-updated-dependencies">
Auto-updated dependencies</h2>
<p>When running the <code class="language-text">yarn version</code> command to upgrade the version of a workspace, every other workspace that depend on the first one through a basic semver ranges (<code class="language-text">^x.y.z</code>, <code class="language-text">~x.y.z</code>, ...) will get auto-updated to reference the new version. For example, let's say we have the following workspaces:</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">/packages/common (1.0.0)
/packages/server (depends on common@^1.0.0)
/packages/client (depends on common@^1.0.0)</code></pre></div>
<p>In pre-2.0, upgrading <code class="language-text">common</code> would have required you to run the command there, then go into each of <code class="language-text">server</code> and <code class="language-text">client</code> to manually upgrade their dependencies to reference the new version. But not anymore! If we run <code class="language-text">yarn version 1.1.1</code> into <code class="language-text">common</code>, the following changes will be applied:</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">/packages/common (1.1.1)
/packages/server (depends on common@^1.1.1)
/packages/client (depends on common@^1.1.1)</code></pre></div>
<p>Of course it's not that important when the packages from the monorepo are always meant to be used as part of the monorepo, but it becomes much more interesting when you work with multiple packages meant to be published. Have you forgotten to update the range of either of your dependent packages, your users would have potentially downloaded an old version of <code class="language-text">common</code> which wouldn't have been compatible with the newer one.</p>
<h2 id="deferred-versioning">
Deferred versioning</h2>
<p>Starting from the 2.0, the <code class="language-text">yarn version</code> command now accepts a new flag: <code class="language-text">--deferred</code>. When set, this flag will cause the command to not immediately change the <code class="language-text">version</code> field of the local manifest, but to instead internally record an entry stating that the current package will need to receive an upgrade during the next release cycle. For example, the following:</p>
<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash"><span class="token function">yarn</span> version minor --deferred</code></pre></div>
<p>Will not cause the <code class="language-text">package.json</code> file to change! Instead, Yarn will create (or reuse, if you're inside a branch) a file within the <code class="language-text">.yarn/versions</code> directory. This file will record the requested upgrade:</p>
<div class="gatsby-highlight" data-language="yaml"><pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">releases</span><span class="token punctuation">:</span>
  <span class="token key atrule">my-package@1.0.0</span><span class="token punctuation">:</span> minor</code></pre></div>
<p>Then later on, once you're ready, just run <code class="language-text">yarn version apply</code>. Yarn will then locate all the upgrade records it previously saved, and apply them all at once (including by taking care of upgrading inter-dependencies as we saw).</p>
<h2 id="checked-in-deferred-records">
Checked-in deferred records</h2>
<p>We've seen in the previous section that <code class="language-text">yarn version patch</code> could store the future versions in an internal folder, <code class="language-text">.yarn/versions</code>. But why is that? What good is it? To answer this question, consider a popular open-source project developed through a monorepo. This project receives many external pull requests, but they aren't released right away - they're often released as part of a batch. Every once in a while, the lead maintainer will take all the changes, convert them into new versions, and start the deployment.</p>
<p>Let's focus on the part where changes have to be converted into versions. How does that work? This isn't easy. Taking Lerna, for example (the most popular version management tool for monorepos), you have two solutions:</p>
<ul>
<li><p>With the fixed mode, all your packages have a single version. As such, they get upgraded all at once.</p></li>
<li><p>With the independent mode, you get to chose a version for each package whose sources changed.</p></li>
</ul>
<p>One critical problem remains, though: even if you use the independent mode, how will you know which packages are meant to be upgraded? And, just as critical, should they be patch releases? Minor releases? Hard to know - large projects can receive dozens of PRs a week, and keeping track of which units need to be released and to which version is a pretty difficult task.</p>
<p>With Yarn's workflow, however, this all becomes very easy! Since the upgrades are kept in a file, and since this file is magically bound to a Git branch, it simply becomes a matter of committing the release folder - all expected releases will then become part of the project history until comes the time of <code class="language-text">yarn version apply</code> - then Yarn will consume all the individual records, merge then (so that a PR requiring a minor will have higher precedence than the PR requiring a patch), and apply them simultaneously.</p>
<p>As an added bonus, you'll even be able to review the package upgrades as part of the typical PR review! This will have the effect of delegating more power to your community while being able to ensure that everyone follows rules.</p>
<h2 id="ensuring-that-versions-are-bumped-ci">
Ensuring that versions are bumped (CI)</h2>
<p>One problem with committing the deferred releases, however, is that it becomes important to make sure that the PRs you receive include the correct package release definitions. For example, you should be able to trust that the definition contains release strategies (patch, minor, major, ...) for each modified workspace.</p>
<p>To solve this problem in an automated way, the <code class="language-text">yarn version check</code> command appeared. When run, this command will figure out which packages changed and whether they are listed in the release definition file. If they aren't, an error will be thrown and - assuming you integrate this into a CI system such as the GitHub Actions - the PR author will be asked to fill out the release definition file.</p>
<p>Writing this file can be tedious; fortunately <code class="language-text">yarn version check</code> implements a very handy flag named <code class="language-text">--interactive</code>. When set (<code class="language-text">yarn version check --interactive</code>), Yarn will print a terminal interface that will summarize all the changed files, all the changed workspaces, all relevant dependent workspaces, and checkboxes for each entry allowing you to pick the release strategies you want to set for each workspace.</p>
<p>The <a href="../configuration/yarnrc.html#changesetIgnorePatterns"><code class="language-text">changesetIgnorePatterns</code></a> configuration option can be used to ignore files when checking which files have changed. It is useful for excluding files that don't affect the release process (e.g. test files).</p>
<h3 id="caveat">
Caveat</h3>
<h4 id="commit-history">
Commit history</h4>
<p>The <code class="language-text">version</code> plugin requires access to the commit history in order to be able to correctly infer which packages require release specifications. In particular, when using GitHub Actions with <code class="language-text">actions/checkout@v2</code> or greater the default behavior is for Git to fetch just the version being checked, which would cause problems. To correct this, you will need to override the <code class="language-text">fetch-depth</code> configuration value to fetch the whole commit history:</p>
<div class="gatsby-highlight" data-language="yaml"><pre class="language-yaml"><code class="language-yaml"><span class="token punctuation">-</span> <span class="token key atrule">uses</span><span class="token punctuation">:</span> actions/checkout@v2
  <span class="token key atrule">with</span><span class="token punctuation">:</span>
    <span class="token key atrule">fetch-depth</span><span class="token punctuation">:</span> <span class="token number">0</span></code></pre></div>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2016&ndash;present Yarn Contributors<br>Licensed under the BSD License.<br>
    <a href="https://yarnpkg.com/features/release-workflow" class="_attribution-link">https://yarnpkg.com/features/release-workflow</a>
  </p>
</div>
