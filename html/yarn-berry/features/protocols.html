<h1>Protocols</h1>

<div class="css-elchao exirf770">
<div class="toc"><ul>
<li><p><a href="#table">Table</a></p></li>
<li>
<p><a href="#details">Details</a></p>
<ul>
<li><a href="#exec">Exec</a></li>
<li><a href="#git">Git</a></li>
<li><a href="#patch">Patch</a></li>
<li><a href="#workspace">Workspace</a></li>
</ul>
</li>
<li>
<p><a href="#frequently-asked-questions">Frequently Asked Questions</a></p>
<ul>
<li><a href="#can-i-install-a-workspace-of-a-project-when-using-the-git-protocol">Can I install a workspace of a project when using the <code class="language-text">git:</code> protocol?</a></li>
<li><a href="#why-cant-i-add-dependencies-through-the-patch-protocol">Why can't I add dependencies through the <code class="language-text">patch:</code> protocol?</a></li>
<li><a href="#why-is-the-link-protocol-recommended-over-aliases-for-path-mapping">Why is the <code class="language-text">link:</code> protocol recommended over aliases for path mapping?</a></li>
<li><a href="#whats-the-difference-between-link-and-portal">What's the difference between <code class="language-text">link:</code> and <code class="language-text">portal:</code>?</a></li>
</ul>
</li>
</ul></div>
<h2 id="table">
Table</h2>
<p>The following protocols can be used by any dependency entry listed in the <code class="language-text">dependencies</code> or <code class="language-text">devDependencies</code> fields. While they work regardless of the context we strongly recommend you to only use semver ranges on published packages as they are the one common protocol whose semantic is clearly defined across all package managers.</p>
<table>
<thead><tr>
<th>Name</th>
<th>Example</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr>
<td>Semver</td>
<td><code class="language-text">^1.2.3</code></td>
<td>Resolves from the default registry</td>
</tr>
<tr>
<td>Tag</td>
<td><code class="language-text">latest</code></td>
<td>Resolves from the default registry</td>
</tr>
<tr>
<td>Npm alias</td>
<td><code class="language-text">npm:name@...</code></td>
<td>Resolves from the npm registry</td>
</tr>
<tr>
<td>Git</td>
<td><code class="language-text">git@github.com:foo/bar.git</code></td>
<td>Downloads a public package from a Git repository</td>
</tr>
<tr>
<td>GitHub</td>
<td><code class="language-text">github:foo/bar</code></td>
<td>Downloads a <strong>public</strong> package from GitHub</td>
</tr>
<tr>
<td>GitHub</td>
<td><code class="language-text">foo/bar</code></td>
<td>Alias for the <code class="language-text">github:</code> protocol</td>
</tr>
<tr>
<td>File</td>
<td><code class="language-text">file:./my-package</code></td>
<td>Copies the target location into the cache</td>
</tr>
<tr>
<td>Link</td>
<td><code class="language-text">link:./my-folder</code></td>
<td>Creates a link to the <code class="language-text">./my-folder</code> folder (ignore dependencies)</td>
</tr>
<tr>
<td>Patch</td>
<td><code class="language-text">patch:left-pad@1.0.0#./my-patch.patch</code></td>
<td>Creates a patched copy of the original package</td>
</tr>
<tr>
<td>Portal</td>
<td><code class="language-text">portal:./my-folder</code></td>
<td>Creates a link to the <code class="language-text">./my-folder</code> folder (follow dependencies)</td>
</tr>
<tr>
<td>Workspace</td>
<td><code class="language-text">workspace:*</code></td>
<td>Creates a link to a package in another workspace</td>
</tr>
<tr>
<td><a href="#exec">Exec</a></td>
<td><code class="language-text">exec:./my-generator-package</code></td>
<td>
<sup><em>Experimental &amp; Plugin</em></sup><br>Instructs Yarn to execute the specified Node script and use its output as package content</td>
</tr>
</tbody>
</table>
<h2 id="details">
Details</h2>
<h3 id="exec">
Exec</h3>
<p>This protocol is experimental, and only available after installing an optional plugin.</p>
<p>Its documentation and usage can be found on GitHub: <a href="https://github.com/yarnpkg/berry/blob/master/packages/plugin-exec/README.md">yarnpkg/berry/blob/master/packages/plugin-exec/README.md</a>.</p>
<h3 id="git">
Git</h3>
<p>The Git protocol, while fairly old, has been significantly improved starting from Yarn 2. In particular, some things to know:</p>
<ul>
<li><p>The target repository won't be used as-is - it will first be packed using <a href="../cli/pack.html"><code class="language-text">pack</code></a></p></li>
<li><p>You can explicitly request a tag, commit, branch, or semver tag, by using one of those keywords (if you're missing the keyword, Yarn will look for the first thing that seems to match, as in prior versions):</p></li>
</ul>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">git@github.com:yarnpkg/berry.git#tag=@yarnpkg/cli/2.2.0
git@github.com:yarnpkg/berry.git#commit=a806c88
git@github.com:yarnpkg/berry.git#head=master</code></pre></div>
<ul>
<li><p>Yarn will use either of Yarn, npm, or pnpm to pack the repository, based on the repository style (ie we'll use Yarn if there's a <code class="language-text">yarn.lock</code>, npm if there's a <code class="language-text">package-lock.json</code>, or pnpm if there's a <code class="language-text">pnpm-lock.yaml</code>)</p></li>
<li><p>Workspaces can be cloned as long as the remote repository uses Yarn or npm (npm@&gt;=7.x has to be installed on the system); we can't support pnpm because it doesn't have equivalent for the <a href="../cli/workspace.html"><code class="language-text">workspace</code> command</a>. Just reference the workspace by name in your range (you can optionally enforce the tag as well):</p></li>
</ul>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">git@github.com:yarnpkg/berry.git#workspace=@yarnpkg/shell&amp;tag=@yarnpkg/shell/2.1.0</code></pre></div>
<h3 id="patch">
Patch</h3>
<p>The <code class="language-text">patch:</code> protocol is meant to be used with <a href="../cli/patch.html"><code class="language-text">yarn patch</code></a> and <a href="../cli/patch-commit.html"><code class="language-text">yarn patch-commit</code></a>. It allows you to change the sources for a package without having to completely fork the dependency. The intended workflow is:</p>
<ol>
<li>Find a package you want to patch (let's say <code class="language-text">lodash@^1.0.0</code>)</li>
<li>Run <code class="language-text">yarn patch lodash</code>
</li>
<li>Edit the folder the command generated</li>
<li>Once you're done, run <code class="language-text">yarn patch-commit -s &lt;path&gt;</code>
</li>
<li>In your manifest, change the dependency from <code class="language-text">^1.0.0</code> to:</li>
</ol>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">patch:lodash@^1.0.0#path/to/generated/file.patch</code></pre></div>
<p>Note that if you wish to update a transitive dependency (ie not directly yours), it's perfectly possible to use the <a href="../configuration/manifest.html#resolutions"><code class="language-text">resolutions</code> field</a>.</p>
<h3 id="workspace">
Workspace</h3>
<p>The <code class="language-text">workspace:</code> protocol is meant to be used with <a href="workspaces.html#workspace-ranges-workspace">workspaces</a>. While Yarn automatically picks workspace resolutions when they match, there are times where you absolutely don't want to risk using a package from the remote registry even if the versions don't match (for example if your project isn't actually meant to be published and you just want to use the workspaces to better compartmentalize your code).</p>
<p>Our current recommendation is to use <code class="language-text">workspace:*</code>, which will almost always do what you expect. See <a href="workspaces.html#workspace-ranges-workspace">the documentation of workspaces</a> for full details about this protocol.</p>
<h2 id="frequently-asked-questions">
Frequently Asked Questions</h2>
<h3 id="can-i-install-a-workspace-of-a-project-when-using-the-git-protocol">
Can I install a workspace of a project when using the <code class="language-text">git:</code> protocol?</h3>
<p>Yes! Yarn supports workspaces even through git dependencies, using the following syntax:</p>
<div class="gatsby-highlight" data-language="json"><pre class="language-json"><code class="language-json"><span class="token punctuation">{</span>
  <span class="token property">"dependencies"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">"my-pkg"</span><span class="token operator">:</span> <span class="token string">"org/app#workspace=my-pkg"</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></div>
<p>You can even combine it with the branch selectors:</p>
<div class="gatsby-highlight" data-language="json"><pre class="language-json"><code class="language-json"><span class="token punctuation">{</span>
  <span class="token property">"dependencies"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">"my-pkg"</span><span class="token operator">:</span> <span class="token string">"org/app#head=next&amp;workspace=my-pkg"</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></div>
<blockquote><p><strong>Note:</strong> For this workflow to work, make sure that each individual workspaces can be built just by running <code class="language-text">yarn install &amp;&amp; yarn pack</code> into each individual workspace. In particular, avoid third-party release scripts unless they use <code class="language-text">yarn pack</code> under the hood.</p></blockquote>
<h3 id="why-cant-i-add-dependencies-through-the-patch-protocol">
Why can't I add dependencies through the <code class="language-text">patch:</code> protocol?</h3>
<p>A Yarn install is split across multiple steps (described <a href="../advanced/architecture.html#install-architecture">here</a>). Most importantly, we first fully resolve the dependency tree, and only then do we download the packages from their remote sources. Since patches occur during this second step, by the time we inject the new dependencies it's already too late as the dependency tree has already been frozen.</p>
<p>In order to add dependencies to a package, either fork it (and reference it through the Git protocol, for example), or use the <a href="../configuration/yarnrc.html#packageExtensions"><code class="language-text">packageExtensions</code></a> mechanism which is specifically made to add new runtime dependencies to packages.</p>
<h3 id="why-is-the-link-protocol-recommended-over-aliases-for-path-mapping">
Why is the <code class="language-text">link:</code> protocol recommended over aliases for path mapping?</h3>
<p>Many tools support a feature generally known as "aliases", which allows you to map a specific directory to a package name. This pattern allows you to use regular package imports (<code class="language-text">my-app/Toolbar</code>) instead of potentially complex relative paths (<code class="language-text">../../../Toolbar</code>). It sounds awesome! So why do we recommend against this practice?</p>
<p>As we said, many tools support this feature. But the trick is that their implementations and configurations are all subtly different. Depending on the tool, it will be called <code class="language-text">moduleNameMapper</code>, <code class="language-text">resolve.alias</code>, <code class="language-text">paths</code>, or even <code class="language-text">module.name_mapper</code>. Depending on the tool it'll be a regex, a domain-specific language, or just a package name. All those differences make it difficult to keep the configurations synchronized, and likely that a mistake will creep in. Even worse, it'll lock you out of tools that don't support aliases, since they won't know how to deal with these paths they know nothing about.</p>
<p>Enter the <code class="language-text">link:</code> protocol! Through it, you directly instruct the package manager to install a resolution from the given name to the given path. Since the package manager's knowledge base is used by every package in your project, adding a link dependency is enough to make all your tooling aware of this new connection. No need for further configuration ðŸ’«</p>
<div class="gatsby-highlight" data-language="json"><pre class="language-json"><code class="language-json"><span class="token punctuation">{</span>
  <span class="token property">"dependencies"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">"src"</span><span class="token operator">:</span> <span class="token string">"link:./src"</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre></div>
<blockquote><p><strong>Tip:</strong> Yarn 2 implements support for self-references, making the <code class="language-text">link:</code> protocol unneeded in most cases. Any file that's part of a package will always be able to import any file from its own package using the package name - even the top-level project! Just add a <code class="language-text">"name": "app"</code> field into your top-level package.json, and you'll be able to use <code class="language-text">import 'app/Toolbar'</code> without further ado.</p></blockquote>
<blockquote><p><strong>Note:</strong> You may be tempted to alias a scope without giving an explicit name (ie <code class="language-text">"@app": "link:./src"</code>). Don't. This pattern is invalid and won't work. The reason for this is that package identifiers have a required package name, and an optional scope name. As a result, a scope without package name is a syntax error. Prefer doing <code class="language-text">"app": "link:./src"</code>, which will still allow you to use subdirectories if needed (ie <code class="language-text">import 'app/toolbar/Icon'</code>).</p></blockquote>
<blockquote><p><strong>Note:</strong> By reading this FAQ entry, you might think that we recommend against using aliases altogether. This isn't entirely correct. While using aliases <em>for directory mapping</em> is a practice we advise against, they have their usefulness in other contexts. For example, using an alias to map the <code class="language-text">fs</code> module into a local mock is perfectly fine.</p></blockquote>
<h3 id="whats-the-difference-between-link-and-portal">
What's the difference between <code class="language-text">link:</code> and <code class="language-text">portal:</code>?</h3>
<p>The <code class="language-text">link:</code> protocol is meant to link a package name to a folder on the disk - any folder. For example, one perfect use case for the <code class="language-text">link:</code> protocol is to map your <code class="language-text">src</code> folder to a clearer name that you can then use from your Node applications without having to use relative paths (for example you could link <code class="language-text">my-app</code> to <code class="language-text">link:./src</code> so that you can call <code class="language-text">require('my-app')</code> from any file within your application).</p>
<p>Because such destination folders typically don't contain <code class="language-text">package.json</code>, the <code class="language-text">link:</code> protocol doesn't even try to read them. It can cause problems when you want to link an identifier to a different <em>package</em> on the disk (similar to what <code class="language-text">yarn link</code> does) because then the transitive dependencies aren't resolved.</p>
<p>In order to solve this use case, the new <code class="language-text">portal:</code> protocol available in the v2 opens a portal to any package located on your disk. Because portals are meant to only target packages they can leverage the information from the <code class="language-text">package.json</code> files listed within their targets to properly resolve transitive dependencies.</p>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2016&ndash;present Yarn Contributors<br>Licensed under the BSD License.<br>
    <a href="https://yarnpkg.com/features/protocols" class="_attribution-link">https://yarnpkg.com/features/protocols</a>
  </p>
</div>
