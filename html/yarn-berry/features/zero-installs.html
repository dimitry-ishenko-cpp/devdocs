<h1>Zero-Installs</h1>

<div class="css-elchao exirf770">
<p>While not a feature in itself, the term "Zero Install" encompasses a lot of Yarn features tailored around one specific goal - to make your projects as stable and fast as possible by removing the main source of entropy from the equation: Yarn itself.</p>
<blockquote><p><strong>Important:</strong> Zero-install is an <em>optional</em> philosophy. It has some drawbacks, and while we believe this workflow to be a defining feature for professional-grade projects we don't have any plans to ignore or deprecate the typical <code class="language-text">yarn install</code> workflow in any way, now or in the future.</p></blockquote>
<div class="toc"><ul>
<li><p><a href="#how-does-yarn-impact-a-projects-stability">How does Yarn impact a project's stability?</a></p></li>
<li><p><a href="#how-do-you-reach-this-zero-install-state-youre-advocating-for">How do you reach this "zero-install" state you're advocating for?</a></p></li>
<li>
<p><a href="#concerns">Concerns</a></p>
<ul>
<li><a href="#is-it-different-from-just-checking-in-the-node_modules-folder">Is it different from just checking-in the <code class="language-text">node_modules</code> folder?</a></li>
<li><a href="#does-it-have-security-implications">Does it have security implications?</a></li>
</ul>
</li>
</ul></div>
<h2 id="how-does-yarn-impact-a-projects-stability">
How does Yarn impact a project's stability?</h2>
<p>Yarn does its best to guarantee that running <code class="language-text">yarn install</code> twice will give you the same result in both cases. The main way it does this is through a lockfile, which contains all the information needed for a project to be installed in a reproducible way across systems. But is it good enough?</p>
<p>While Yarn does its best to guarantee that what works now will keep working, there's always the off chance that a future Yarn release will introduce a bug that will prevent you from installing your project. Or maybe your production environments will change and <code class="language-text">yarn install</code> won't be able to write in the temporary directories anymore. Or maybe the network will fail and your packages won't be available anymore. Or maybe your credentials will rotate and you will start getting authentication issues. Or ... so many things can go wrong, and not all of them are things we can control.</p>
<p>Note that these challenges are not unique to Yarn â€” you may remember a time when npm used to erase production servers due to a bug that reached one of their releases. This is exactly what we mean: any code that runs is code that can fail. And thanks to Murphy's law, we know that something that can fail <em>will</em> eventually fail. From there, it becomes clear that the only sure way to prevent such issues is to run as little code as possible.</p>
<h2 id="how-do-you-reach-this-zero-install-state-youre-advocating-for">
How do you reach this "zero-install" state you're advocating for?</h2>
<p>In order to make a project zero-install, you must be able to use it as soon as you clone it. This is very easy starting from Yarn 2!</p>
<ul>
<li>
<p>First, ensure that your project is using <a href="pnp.html">Plug'n'Play</a> to resolve dependencies via the cache folder and <strong>not</strong> from <code class="language-text">node_modules</code>.</p>
<ul><li>While in theory you could check-in your <code class="language-text">node_modules</code> folder rather than the cache, in practice the <code class="language-text">node_modules</code> contains a gigantic amount of files that frequently change location and mess with Git's optimizations. By contrast, the Yarn cache contains exactly one file per package, that only change when the packages themselves change.</li></ul>
</li>
<li>
<p>The cache folder is by default stored within your project folder (in <code class="language-text">.yarn/cache</code>). Just make sure you add it to your repository (see also, <a href="offline-cache.html">Offline Cache</a>).</p>
<ul><li>Again, this whole workflow is optional. If at some point you decide that in the end you prefer to keep using a global cache, just toggle on <code class="language-text">enableGlobalCache</code> in the <a href="../configuration/yarnrc.html#enableGlobalCache">yarnrc settings</a> and it'll be back to normal.</li></ul>
</li>
<li><p>When running <code class="language-text">yarn install</code>, Yarn will generate a <code class="language-text">.pnp.cjs</code> file. Add it to your repository as well - it contains the dependency tree that Node will use to load your packages.</p></li>
<li><p>Depending on whether your dependencies have install scripts or not (we advise you to avoid it if you can, and prefer wasm-powered alternatives) you may also want to add the <code class="language-text">.yarn/unplugged</code> entries.</p></li>
</ul>
<p>And that's it! Push your changes to your repository, checkout a new one somewhere, and check whether running <code class="language-text">yarn start</code> (or whatever other script you'd normally use) works.</p>
<h2 id="concerns">
Concerns</h2>
<h3 id="is-it-different-from-just-checking-in-the-node_modules-folder">
Is it different from just checking-in the <code class="language-text">node_modules</code> folder?</h3>
<p>Yes, very much. To give you an idea, a <code class="language-text">node_modules</code> folder of 135k uncompressed files (for a total of 1.2GB) gives a Yarn cache of 2k binary archives (for a total of 139MB). Git simply cannot support the former, while the latter is perfectly fine.</p>
<p>Another huge difference is the number of changes. Back in Yarn 1, when updating a package, a huge amount of files had to be recreated, or even simply moved. When the same happens in a Yarn 2 install, you get a very predictable result: exactly one changed file for each added/removed package. This in turn has beneficial side effects in terms of performance and security, since you can easily spot the invalid checksums on a per-package basis.</p>
<h3 id="does-it-have-security-implications">
Does it have security implications?</h3>
<p>Note that, by design, this setup requires that you trust people modifying your repository. In particular, projects accepting PRs from external users will have to be careful that the PRs affecting the package archives are legit (since it would otherwise be possible to a malicious user to send a PR for a new dependency after having altered its archive content). The best way to do this is to add a CI step (for untrusted PRs only) that uses the <code class="language-text">--check-cache</code> flag:</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">$&gt; yarn install --check-cache</code></pre></div>
<p>This way Yarn will re-download the package files from whatever their remote location would be and will report any mismatching checksum.</p>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2016&ndash;present Yarn Contributors<br>Licensed under the BSD License.<br>
    <a href="https://yarnpkg.com/features/zero-installs" class="_attribution-link">https://yarnpkg.com/features/zero-installs</a>
  </p>
</div>
