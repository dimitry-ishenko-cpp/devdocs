<h1>pnpify run</h1>

<div class="css-elchao exirf770">
<p>Run a command with a virtual node_modules folder.</p>
<h2 id="usage">
Usage</h2>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">$&gt; pnpify run &lt;commandName&gt; ...</code></pre></div>
<h2 id="examples">
Examples</h2>
<p>Run Angular using PnPify :</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">pnpify ng build</code></pre></div>
<h2 id="options">
Options</h2>
<table>
<thead><tr>
<th><div>Definition</div></th>
<th>Description</th>
</tr></thead>
<tbody><tr>
<td><h3 id="options-cwd%20%230" class="header-code"><code class="language-text">--cwd #0</code></h3></td>
<td>The directory to run the command in</td>
</tr></tbody>
</table>
<h2 id="details">
Details</h2>
<p>When a non-PnP-compliant project tries to access the <code class="language-text">node_modules</code> directories (for example through <code class="language-text">readdir</code> or <code class="language-text">readFile</code>), PnPify intercepts those calls and converts them into calls to the PnP API. Then, based on the result, it simulates the existence of a virtual <code class="language-text">node_modules</code> folder that the underlying tool will then consume - still unaware that the files are extracted from a virtual filesystem.</p>
<p>The <code class="language-text">run</code> keyword can be omitted if the executed command doesn't conflict with built-in commands.</p>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2016&ndash;present Yarn Contributors<br>Licensed under the BSD License.<br>
    <a href="https://yarnpkg.com/pnpify/cli/run" class="_attribution-link">https://yarnpkg.com/pnpify/cli/run</a>
  </p>
</div>
