<h1>Architecture</h1>

<div class="css-elchao exirf770">
<div class="toc"><ul>
<li><a href="#general-architecture">General architecture</a></li>
<li><a href="#install-architecture">Install architecture</a></li>
</ul></div>
<h2 id="general-architecture">
General architecture</h2>
<p>Yarn works through a core package (published as <code class="language-text">@yarnpkg/core</code>) that exposes the various base components that make up a project. Some of the components are classes that you might recognize from the API: <code class="language-text">Configuration</code>, <code class="language-text">Project</code>, <code class="language-text">Workspace</code>, <code class="language-text">Cache</code>, <code class="language-text">Manifest</code>, and others. All those are provided by the core package.</p>
<p>The core itself doesn't do much - it merely contains the logic required to manage a project. In order to use this logic from the command-line Yarn provides an indirection called <code class="language-text">@yarnpkg/cli</code> which, interestingly, doesn't do much either. It however has two very important responsibilities: it hydrates a project instance based on the current directory (<code class="language-text">cwd</code>), and inject the prebuilt Yarn plugins into the environment.</p>
<p>See, Yarn is built in modular way that allow most of the business logic related to third-party interactions to be externalized inside their own package - for example the <a href="https://github.com/yarnpkg/berry/tree/master/packages/plugin-npm">npm resolver</a> is but one plugin amongst many others. This design gives us a much simpler codebase to work with (hence an increased development speed and stabler product), and offers plugin authors the ability to write their own external logic without having to modify the Yarn codebase itself.</p>
<h2 id="install-architecture">
Install architecture</h2>
<p>What happens when running <code class="language-text">yarn install</code> can be summarized in a few different steps:</p>
<ol>
<li>
<p>First we enter the "resolution step":</p>
<ul>
<li><p>First we load the entries stored within the lockfile, then based on those data and the current state of the project (that it figures out by reading the manifest files, aka <code class="language-text">package.json</code>) the core runs an internal algorithm to find out which entries are missing.</p></li>
<li><p>For each of those missing entries, it queries the plugins using the <a href="https://github.com/yarnpkg/berry/blob/master/packages/yarnpkg-core/sources/Resolver.ts"><code class="language-text">Resolver</code></a> interface, and asks them whether they would know about a package that would match the given descriptor (<a href="https://github.com/yarnpkg/berry/blob/master/packages/yarnpkg-core/sources/Resolver.ts#L54"><code class="language-text">supportsDescriptor</code></a>) and its exact identity (<a href="https://github.com/yarnpkg/berry/blob/master/packages/yarnpkg-core/sources/Resolver.ts#L114"><code class="language-text">getCandidates</code></a>) and transitive dependency list (<a href="https://github.com/yarnpkg/berry/blob/master/packages/yarnpkg-core/sources/Resolver.ts#L123"><code class="language-text">resolve</code></a>).</p></li>
<li><p>Once it has obtained a new list of package metadata, the core starts a new resolution pass on the transitive dependencies of the newly added packages. This will be repeated until it figures out that all packages from the dependency tree now have their metadata stored within the lockfile.</p></li>
<li><p>Finally, once every package range from the dependency tree has been resolved into metadata, the core builds the tree in memory one last time in order to generate what we call "virtual packages". In short, those virtual packages are split instances of the same base package - we use them to disambiguate all packages that list peer dependencies, whose dependency set would change depending on their location in the dependency tree (consult <a href="lexicon.html#virtualpackages">this lexicon entry</a> for more information).</p></li>
</ul>
</li>
<li>
<p>Once the resolution is done, we enter the "fetch step":</p>
<ul>
<li><p>Now that we have the exact set of packages that make up our dependency tree, we iterate over it and for each of them we start a new request to the cache to know whether the package is anywhere to be found. If it isn't we do just like we did in the previous step and we ask our plugins (through the <a href="https://github.com/yarnpkg/berry/blob/master/packages/yarnpkg-core/sources/Fetcher.ts"><code class="language-text">Fetcher</code></a> interface) whether they know about the package (<a href="https://github.com/yarnpkg/berry/blob/master/packages/yarnpkg-core/sources/Fetcher.ts#L43"><code class="language-text">supports</code></a>) and if so to retrieve it from whatever its remote location is (<a href="https://github.com/yarnpkg/berry/blob/master/packages/yarnpkg-core/sources/Fetcher.ts#L67"><code class="language-text">fetch</code></a>).</p></li>
<li><p>Interesting tidbit regarding the fetchers: they communicate with the core through an abstraction layer over <code class="language-text">fs</code>. We do this so that our packages can come from many different sources - it can be from a zip archive for packages downloaded from a registry, or from an actual directory on the disk for <a href="architecture.html"><code class="language-text">portal:</code></a> dependencies.</p></li>
</ul>
</li>
<li>
<p>And finally, once all the packages are ready for consumption, comes the "link step":</p>
<ul>
<li><p>In order to work properly, the packages you use must be installed on the disk in some way. For example, in the case of a native Node application, your packages would have to be installed into a set of <code class="language-text">node_modules</code> directories so that they could be located by the interpreter. That's what the linker is about. Through the <a href="https://github.com/yarnpkg/berry/blob/master/packages/yarnpkg-core/sources/Linker.ts"><code class="language-text">Linker</code></a> and <a href="https://github.com/yarnpkg/berry/blob/master/packages/yarnpkg-core/sources/Installer.ts"><code class="language-text">Installer</code></a> interfaces the Yarn core will communicate with the registered plugins to let them know about the packages listed in the dependency tree, and describe their relationships (for example it would tell them that <code class="language-text">tapable</code> is a dependency of <code class="language-text">webpack</code>). The plugins can then decide what to do of this information in whatever way they see fit.</p></li>
<li><p>Doing this means that new linkers can be created for other programming languages pretty easily - you just need to write your own logic regarding what should happen from the packages provided by Yarn. Want to generate an <code class="language-text">__autoload.php</code>? Do it! Want to setup a Python virtual env? No problemo!</p></li>
<li><p>Something else that's pretty cool is that the packages from within the dependency tree don't have to all be of the same type. Our plugin design allows instantiating multiple linkers simultaneously. Even better - the packages can depend on one another across linkers! You could have a JavaScript package depending on a Python package (which is technically the case of <code class="language-text">node-gyp</code>, for example).</p></li>
</ul>
</li>
</ol>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2016&ndash;present Yarn Contributors<br>Licensed under the BSD License.<br>
    <a href="https://yarnpkg.com/advanced/architecture" class="_attribution-link">https://yarnpkg.com/advanced/architecture</a>
  </p>
</div>
