<h1>PnP API</h1>

<div class="css-elchao exirf770">
<div class="toc"><ul>
<li><p><a href="#overview">Overview</a></p></li>
<li>
<p><a href="#data-structures">Data Structures</a></p>
<ul>
<li><a href="#packagelocator"><code class="language-text">PackageLocator</code></a></li>
<li><a href="#packageinformation"><code class="language-text">PackageInformation</code></a></li>
</ul>
</li>
<li>
<p><a href="#runtime-constants">Runtime Constants</a></p>
<ul>
<li><a href="#processversionspnp"><code class="language-text">process.versions.pnp</code></a></li>
<li><a href="#requiremodule"><code class="language-text">require('module')</code></a></li>
<li><a href="#requirepnpapi"><code class="language-text">require('pnpapi')</code></a></li>
</ul>
</li>
<li>
<p><a href="#api-interface">API Interface</a></p>
<ul>
<li><a href="#versions"><code class="language-text">VERSIONS</code></a></li>
<li><a href="#toplevel"><code class="language-text">topLevel</code></a></li>
<li><a href="#getlocator"><code class="language-text">getLocator(...)</code></a></li>
<li><a href="#getdependencytreeroots"><code class="language-text">getDependencyTreeRoots(...)</code></a></li>
<li><a href="#getalllocators"><code class="language-text">getAllLocators(...)</code></a></li>
<li><a href="#getpackageinformation"><code class="language-text">getPackageInformation(...)</code></a></li>
<li><a href="#findpackagelocator"><code class="language-text">findPackageLocator(...)</code></a></li>
<li><a href="#resolvetounqualified"><code class="language-text">resolveToUnqualified(...)</code></a></li>
<li><a href="#resolveunqualified"><code class="language-text">resolveUnqualified(...)</code></a></li>
<li><a href="#resolverequest"><code class="language-text">resolveRequest(...)</code></a></li>
<li><a href="#resolvevirtual"><code class="language-text">resolveVirtual(...)</code></a></li>
</ul>
</li>
<li><p><a href="#qualified-vs-unqualified-resolutions">Qualified vs Unqualified Resolutions</a></p></li>
<li><p><a href="#accessing-the-files">Accessing the files</a></p></li>
<li><p><a href="#traversing-the-dependency-tree">Traversing the dependency tree</a></p></li>
</ul></div>
<h2 id="overview">
Overview</h2>
<p>On top of being a simple install strategy, Plug'n'Play also provides a API that allows you to introspect the dependency tree at runtime.</p>
<h2 id="data-structures">
Data Structures</h2>
<h3 id="packagelocator">
<code class="language-text">PackageLocator</code>
</h3>
<div class="gatsby-highlight" data-language="ts"><pre class="language-ts"><code class="language-ts"><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">PackageLocator</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span>
  reference<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></div>
<p>A package locator is an object describing one unique instance of a package in the dependency tree. The <code class="language-text">name</code> field is guaranteed to be the name of the package itself, but the <code class="language-text">reference</code> field should be considered an opaque string whose value may be whatever the PnP implementation decides to put there.</p>
<p>Note that one package locator is different from the others: the top-level locator (available through <code class="language-text">pnp.topLevel</code>, cf below) sets <em>both</em> <code class="language-text">name</code> and <code class="language-text">reference</code> to <code class="language-text">null</code>. This special locator will always mirror the top-level package (which is generally the root of the repository, even when working with workspaces).</p>
<h3 id="packageinformation">
<code class="language-text">PackageInformation</code>
</h3>
<div class="gatsby-highlight" data-language="ts"><pre class="language-ts"><code class="language-ts"><span class="token keyword">export</span> <span class="token keyword">type</span> <span class="token class-name">PackageInformation</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  packageLocation<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span>
  packageDependencies<span class="token operator">:</span> Map<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token keyword">null</span> <span class="token operator">|</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
  packagePeers<span class="token operator">:</span> Set<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
  linkType<span class="token operator">:</span> <span class="token string">'HARD'</span> <span class="token operator">|</span> <span class="token string">'SOFT'</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></div>
<p>The package information set describes the location where the package can be found on the disk, and the exact set of dependencies it is allowed to require. The <code class="language-text">packageDependencies</code> values are meant to be interpreted as such:</p>
<ul>
<li><p>If a string, the value is meant to be used as a reference in a locator whose name is the dependency name.</p></li>
<li><p>If a <code class="language-text">[string, string]</code> tuple, the value is meant to be used as a locator whose name is the first element of the tuple and reference is the second one. This typically occurs with package aliases (such as <code class="language-text">"foo": "npm:bar@1.2.3"</code>).</p></li>
<li><p>If <code class="language-text">null</code>, the specified dependency isn't available at all. This typically occurs when a package's peer dependency didn't get provided by its direct parent in the dependency tree.</p></li>
</ul>
<p>The <code class="language-text">packagePeers</code> field, if present, indicates which dependencies have an enforced contract on using the exact same instance as the package that depends on them. This field is rarely useful in pure PnP context (because our instantiation guarantees are stricter and more predictable than this), but is required to properly generate a <code class="language-text">node_modules</code> directory from a PnP map.</p>
<p>The <code class="language-text">linkType</code> field is only useful in specific cases - it describes whether the producer of the PnP API was asked to make the package available through a hard linkage (in which case all the <code class="language-text">packageLocation</code> field is reputed being owned by the linker) or a soft linkage (in which case the <code class="language-text">packageLocation</code> field represents a location outside of the sphere of influence of the linker).</p>
<h2 id="runtime-constants">
Runtime Constants</h2>
<h3 id="processversionspnp">
<code class="language-text">process.versions.pnp</code>
</h3>
<p>When operating under PnP environments, this value will be set to a number indicating the version of the PnP standard in use (which is strictly identical to <code class="language-text">require('pnpapi').VERSIONS.std</code>).</p>
<p>This value is a convenient way to check whether you're operating under a Plug'n'Play environment (where you can <code class="language-text">require('pnpapi')</code>) or not:</p>
<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>versions<span class="token punctuation">.</span>pnp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// do something with the PnP API ...</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token comment">// fallback</span>
<span class="token punctuation">}</span></code></pre></div>
<h3 id="requiremodule">
<code class="language-text">require('module')</code>
</h3>
<p>The <code class="language-text">module</code> builtin module is extended when operating within the PnP API with one extra function:</p>
<div class="gatsby-highlight" data-language="ts"><pre class="language-ts"><code class="language-ts"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">findPnpApi</span><span class="token punctuation">(</span>lookupSource<span class="token operator">:</span> <span class="token constant">URL</span> <span class="token operator">|</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> PnpApi <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">;</span></code></pre></div>
<p>When called, this function will traverse the filesystem hierarchy starting from the given <code class="language-text">lookupSource</code> in order to locate the closest <code class="language-text">.pnp.cjs</code> file. It'll then load this file, register it inside the PnP loader internal store, and return the resulting API to you.</p>
<p>Note that while you'll be able to resolve the dependencies by using the API returned to you, you'll need to make sure they are properly <em>loaded</em> on behalf of the project too, by using <code class="language-text">createRequire</code>:</p>
<div class="gatsby-highlight" data-language="ts"><pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> <span class="token punctuation">{</span>createRequire<span class="token punctuation">,</span> findPnpApi<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">require</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">module</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// We'll be able to inspect the dependencies of the module passed as first argument</span>
<span class="token keyword">const</span> targetModule <span class="token operator">=</span> process<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> targetPnp <span class="token operator">=</span> <span class="token function">findPnpApi</span><span class="token punctuation">(</span>targetModule<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> targetRequire <span class="token operator">=</span> <span class="token function">createRequire</span><span class="token punctuation">(</span>targetModule<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> resolved <span class="token operator">=</span> targetPnp<span class="token punctuation">.</span><span class="token function">resolveRequest</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">eslint</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> targetModule<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token function">targetRequire</span><span class="token punctuation">(</span>resolved<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &lt;-- important! don't use `require`!</span></code></pre></div>
<p>Finally, it can be noted that <code class="language-text">findPnpApi</code> isn't actually needed in most cases and we can do the same with just <code class="language-text">createRequire</code> thanks to its <code class="language-text">resolve</code> function:</p>
<div class="gatsby-highlight" data-language="ts"><pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> <span class="token punctuation">{</span>createRequire<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">require</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">module</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// We'll be able to inspect the dependencies of the module passed as first argument</span>
<span class="token keyword">const</span> targetModule <span class="token operator">=</span> process<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> targetRequire <span class="token operator">=</span> <span class="token function">createRequire</span><span class="token punctuation">(</span>targetModule<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> resolved <span class="token operator">=</span> targetRequire<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">eslint</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token function">targetRequire</span><span class="token punctuation">(</span>resolved<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &lt;-- still important</span></code></pre></div>
<h3 id="requirepnpapi">
<code class="language-text">require('pnpapi')</code>
</h3>
<p>When operating under a Plug'n'Play environment, a new builtin module will appear in your tree and will be made available to all your packages (regardless of whether they define it in their dependencies or not): <code class="language-text">pnpapi</code>. It exposes the constants a function described in the rest of this document.</p>
<p>Note that we've reserved the <code class="language-text">pnpapi</code> package name on the npm registry, so there's no risk that anyone will be able to snatch the name for nefarious purposes. We might use it later to provide a polyfill for non-PnP environments (so that you'd be able to use the PnP API regardless of whether the project got installed via PnP or not), but as of now it's still an empty package.</p>
<p>Note that the <code class="language-text">pnpapi</code> builtin is <em>contextual</em>: while two packages from the same dependency tree are guaranteed to read the same one, two packages from different dependency trees will get different instances - each reflecting the dependency tree they belong to. This distinction doesn't often matter except sometimes for project generator (which typically run within their own dependency tree while also manipulating the project they're generating).</p>
<h2 id="api-interface">
API Interface</h2>
<h3 id="versions">
<code class="language-text">VERSIONS</code>
</h3>
<div class="gatsby-highlight" data-language="ts"><pre class="language-ts"><code class="language-ts"><span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token constant">VERSIONS</span><span class="token operator">:</span> <span class="token punctuation">{</span>std<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></div>
<p>The <code class="language-text">VERSIONS</code> object contains a set of numbers that detail which version of the API is currently exposed. The only version that is guaranteed to be there is <code class="language-text">std</code>, which will refer to the version of this document. Other keys are meant to be used to describe extensions provided by third-party implementors. Versions will only be bumped when the signatures of the public API change.</p>
<p><strong>Note:</strong> The current version is 3. We bump it responsibly and strive to make each version backward-compatible with the previous ones, but as you can probably guess some features are only available with the latest versions.</p>
<h3 id="toplevel">
<code class="language-text">topLevel</code>
</h3>
<div class="gatsby-highlight" data-language="ts"><pre class="language-ts"><code class="language-ts"><span class="token keyword">export</span> <span class="token keyword">const</span> topLevel<span class="token operator">:</span> <span class="token punctuation">{</span>name<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span> reference<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></div>
<p>The <code class="language-text">topLevel</code> object is a simple package locator pointing to the top-level package of the dependency tree. Note that even when using workspaces you'll still only have one single top-level for the entire project.</p>
<p>This object is provided for convenience and doesn't necessarily needs to be used; you may create your own top-level locator by using your own locator literal with both fields set to <code class="language-text">null</code>.</p>
<p><strong>Note:</strong> These special top-level locators are merely aliases to physical locators, which can be accessed by calling <code class="language-text">findPackageLocator</code>.</p>
<h3 id="getlocator">
<code class="language-text">getLocator(...)</code>
</h3>
<div class="gatsby-highlight" data-language="ts"><pre class="language-ts"><code class="language-ts"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">getLocator</span><span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> referencish<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> PackageLocator<span class="token punctuation">;</span></code></pre></div>
<p>This function is a small helper that makes it easier to work with "referencish" ranges. As you may have seen in the <code class="language-text">PackageInformation</code> interface, the <code class="language-text">packageDependencies</code> map values may be either a string or a tuple - and the way to compute the resolved locator changes depending on that. To avoid having to manually make a <code class="language-text">Array.isArray</code> check, we provide the <code class="language-text">getLocator</code> function that does it for you.</p>
<p>Just like for <code class="language-text">topLevel</code>, you're under no obligation to actually use it - you're free to roll your own version if for some reason our implementation wasn't what you're looking for.</p>
<h3 id="getdependencytreeroots">
<code class="language-text">getDependencyTreeRoots(...)</code>
</h3>
<div class="gatsby-highlight" data-language="ts"><pre class="language-ts"><code class="language-ts"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">getDependencyTreeRoots</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> PackageLocator<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre></div>
<p>The <code class="language-text">getDependencyTreeRoots</code> function will return the set of locators that constitute the roots of individual dependency trees. In Yarn, there is exactly one such locator for each workspace in the project.</p>
<p><strong>Note:</strong> This function will always return the physical locators, so it'll never return the special top-level locator described in the <code class="language-text">topLevel</code> section.</p>
<h3 id="getalllocators">
<code class="language-text">getAllLocators(...)</code>
</h3>
<div class="gatsby-highlight" data-language="ts"><pre class="language-ts"><code class="language-ts"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">getAllLocators</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> PackageLocator<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre></div>
<p><strong>Important:</strong> This function is not part of the Plug'n'Play specification and only available as a Yarn extension. In order to use it, you first must check that the <a href="pnpapi.html#versions"><code class="language-text">VERSIONS</code></a> dictionary contains a valid <code class="language-text">getAllLocators</code> property.</p>
<p>The <code class="language-text">getAllLocators</code> function will return all locators from the dependency tree, in no particular order (although it'll always be a consistent order between calls for the same API). It can be used when you wish to know more about the packages themselves, but not about the exact tree layout.</p>
<h3 id="getpackageinformation">
<code class="language-text">getPackageInformation(...)</code>
</h3>
<div class="gatsby-highlight" data-language="ts"><pre class="language-ts"><code class="language-ts"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">getPackageInformation</span><span class="token punctuation">(</span>locator<span class="token operator">:</span> PackageLocator<span class="token punctuation">)</span><span class="token operator">:</span> PackageInformation<span class="token punctuation">;</span></code></pre></div>
<p>The <code class="language-text">getPackageInformation</code> function returns all the information stored inside the PnP API for a given package.</p>
<h3 id="findpackagelocator">
<code class="language-text">findPackageLocator(...)</code>
</h3>
<div class="gatsby-highlight" data-language="ts"><pre class="language-ts"><code class="language-ts"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">findPackageLocator</span><span class="token punctuation">(</span>location<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> PackageLocator <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">;</span></code></pre></div>
<p>Given a location on the disk, the <code class="language-text">findPackageLocator</code> function will return the package locator for the package that "owns" the path. For example, running this function on something conceptually similar to <code class="language-text">/path/to/node_modules/foo/index.js</code> would return a package locator pointing to the <code class="language-text">foo</code> package (and its exact version).</p>
<p><strong>Note:</strong> This function will always return the physical locators, so it'll never return the special top-level locator described in the <code class="language-text">topLevel</code> section. You can leverage this property to extract the physical locator for the top-level package:</p>
<div class="gatsby-highlight" data-language="ts"><pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> virtualLocator <span class="token operator">=</span> pnpApi<span class="token punctuation">.</span>topLevel<span class="token punctuation">;</span>
<span class="token keyword">const</span> physicalLocator <span class="token operator">=</span> pnpApi<span class="token punctuation">.</span><span class="token function">findPackageLocator</span><span class="token punctuation">(</span>pnpApi<span class="token punctuation">.</span><span class="token function">getPackageInformation</span><span class="token punctuation">(</span>virtualLocator<span class="token punctuation">)</span><span class="token punctuation">.</span>packageLocation<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<h3 id="resolvetounqualified">
<code class="language-text">resolveToUnqualified(...)</code>
</h3>
<div class="gatsby-highlight" data-language="ts"><pre class="language-ts"><code class="language-ts"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">resolveToUnqualified</span><span class="token punctuation">(</span>request<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> issuer<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span> opts<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">{</span>considerBuiltins<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">;</span></code></pre></div>
<p>The <code class="language-text">resolveToUnqualified</code> function is maybe the most important function exposed by the PnP API. Given a request (which may be a bare specifier like <code class="language-text">lodash</code>, or an relative/absolute path like <code class="language-text">./foo.js</code>) and the path of the file that issued the request, the PnP API will return an unqualified resolution.</p>
<p>For example, the following:</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">lodash/uniq</code></pre></div>
<p>Might very well be resolved into:</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">/my/cache/lodash/1.0.0/node_modules/lodash/uniq</code></pre></div>
<p>As you can see, the <code class="language-text">.js</code> extension didn't get added. This is due to the difference between <a href="#qualified-vs-unqualified-resolutions">qualified and unqualified resolutions</a>. In case you must obtain a path ready to be used with the filesystem API, prefer using <code class="language-text">resolveRequest</code> instead.</p>
<p>Note that in some cases you may just have a folder to work with as <code class="language-text">issuer</code> parameter. When this happens, just suffix the issuer with an extra slash (<code class="language-text">/</code>) to indicate to the PnP API that the issuer is a folder.</p>
<p>This function will return <code class="language-text">null</code> if the request is a builtin module, unless <code class="language-text">considerBuiltins</code> is set to <code class="language-text">false</code>.</p>
<h3 id="resolveunqualified">
<code class="language-text">resolveUnqualified(...)</code>
</h3>
<div class="gatsby-highlight" data-language="ts"><pre class="language-ts"><code class="language-ts"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">resolveUnqualified</span><span class="token punctuation">(</span>unqualified<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> opts<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">{</span>extensions<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span></code></pre></div>
<p>The <code class="language-text">resolveUnqualified</code> function is mostly provided as an helper; it reimplements the Node resolution for file extensions and folder indexes, but not the regular <code class="language-text">node_modules</code> traversal. It makes it slightly easier to integrate PnP into some projects, although it isn't required in any way if you already have something that fits the bill.</p>
<p>To give you an example <code class="language-text">resolveUnqualified</code> isn't needed with <code class="language-text">enhanced-resolved</code>, used by Webpack, because it already implements its own way the logic contained in <code class="language-text">resolveUnqualified</code> (and more). Instead, we only have to leverage the lower-level <code class="language-text">resolveToUnqualified</code> function and feed it to the regular resolver.</p>
<p>For example, the following:</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">/my/cache/lodash/1.0.0/node_modules/lodash/uniq</code></pre></div>
<p>Might very well be resolved into:</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">/my/cache/lodash/1.0.0/node_modules/lodash/uniq/index.js</code></pre></div>
<h3 id="resolverequest">
<code class="language-text">resolveRequest(...)</code>
</h3>
<div class="gatsby-highlight" data-language="ts"><pre class="language-ts"><code class="language-ts"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">resolveRequest</span><span class="token punctuation">(</span>request<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> issuer<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span> opts<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">{</span>considerBuiltins<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">,</span> extensions<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">;</span></code></pre></div>
<p>The <code class="language-text">resolveRequest</code> function is a wrapper around both <code class="language-text">resolveToUnqualified</code> and <code class="language-text">resolveUnqualified</code>. In essence, it's a bit like calling <code class="language-text">resolveUnqualified(resolveToUnqualified(...))</code>, but shorter.</p>
<p>Just like <code class="language-text">resolveUnqualified</code>, <code class="language-text">resolveRequest</code> is entirely optional and you might want to skip it to directly use the lower-level <code class="language-text">resolveToUnqualified</code> if you already have a resolution pipeline that just needs to add support for Plug'n'Play.</p>
<p>For example, the following:</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">lodash</code></pre></div>
<p>Might very well be resolved into:</p>
<div class="gatsby-highlight" data-language="text"><pre class="language-text"><code class="language-text">/my/cache/lodash/1.0.0/node_modules/lodash/uniq/index.js</code></pre></div>
<p>This function will return <code class="language-text">null</code> if the request is a builtin module, unless <code class="language-text">considerBuiltins</code> is set to <code class="language-text">false</code>.</p>
<h3 id="resolvevirtual">
<code class="language-text">resolveVirtual(...)</code>
</h3>
<div class="gatsby-highlight" data-language="ts"><pre class="language-ts"><code class="language-ts"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">resolveVirtual</span><span class="token punctuation">(</span>path<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">;</span></code></pre></div>
<p><strong>Important:</strong> This function is not part of the Plug'n'Play specification and only available as a Yarn extension. In order to use it, you first must check that the <a href="pnp-api.html#versions"><code class="language-text">VERSIONS</code></a> dictionary contains a valid <code class="language-text">resolveVirtual</code> property.</p>
<p>The <code class="language-text">resolveVirtual</code> function will accept any path as parameter and return the same path minus any <a href="lexicon.html#virtual-package">virtual component</a>. This makes it easier to store the location to the files in a portable way as long as you don't care about losing the dependency tree information in the process (requiring files through those paths will prevent them from accessing their peer dependencies).</p>
<h2 id="qualified-vs-unqualified-resolutions">
Qualified vs Unqualified Resolutions</h2>
<p>This document detailed two types of resolutions: qualified and unqualified. Although similar, they present different characteristics that make them suitable in different settings.</p>
<p>The difference between qualified and unqualified resolutions lies in the quirks of the Node resolution itself. Unqualified resolutions can be statically computed without ever accessing the filesystem, but only can only resolve relative paths and bare specifiers (like <code class="language-text">lodash</code>); they won't ever resolve the file extensions or folder indexes. By contrast, qualified resolutions are ready to be used to access the filesystem.</p>
<p>Unqualified resolutions are the core of the Plug'n'Play API; they represent data that cannot be obtained any other way. If you're looking to integrate Plug'n'Play inside your resolver, they're likely what you're looking for. On the other hand, fully qualified resolutions are handy if you're working with the PnP API as a one-off and just want to obtain some information on a given file or package.</p>
<p>Two great options for two different use cases 🙂</p>
<h2 id="accessing-the-files">
Accessing the files</h2>
<p>The paths returned in the <code class="language-text">PackageInformation</code> structures are in the native format (so Posix on Linux/OSX and Win32 on Windows), but they may reference files outside of the typical filesystem. This is particularly true for Yarn, which references packages directly from within their zip archives.</p>
<p>To access such files, you can use the <code class="language-text">@yarnpkg/fslib</code> project which abstracts the filesystem under a multi-layer architecture. For example, the following code would make it possible to access any path, regardless of whether they're stored within a zip archive or not:</p>
<div class="gatsby-highlight" data-language="ts"><pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> <span class="token punctuation">{</span>PosixFS<span class="token punctuation">,</span> ZipOpenFS<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">require</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">@yarnpkg/fslib</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> libzip <span class="token operator">=</span> <span class="token keyword">require</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">@yarnpkg/libzip</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getLibzipSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// This will transparently open zip archives</span>
<span class="token keyword">const</span> zipOpenFs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ZipOpenFS</span><span class="token punctuation">(</span><span class="token punctuation">{</span>libzip<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// This will convert all paths into a Posix variant, required for cross-platform compatibility</span>
<span class="token keyword">const</span> crossFs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PosixFS</span><span class="token punctuation">(</span>zipOpenFs<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>crossFs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">C:\\path\\to\\archive.zip\\package.json</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<h2 id="traversing-the-dependency-tree">
Traversing the dependency tree</h2>
<p>The following function implements a tree traversal in order to print the list of locators from the tree.</p>
<p><strong>Important note:</strong> This implementation iterates over <strong>all</strong> the nodes in the tree, even if they are found multiple times (which is very often the case). As a result the execution time is way higher than it could be. Optimize as needed 🙂</p>
<div class="gatsby-highlight" data-language="ts"><pre class="language-ts"><code class="language-ts"><span class="token keyword">const</span> pnp <span class="token operator">=</span> <span class="token keyword">require</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">pnpapi</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> seen <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token function-variable function">getKey</span> <span class="token operator">=</span> locator <span class="token operator">=&gt;</span>
  <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>locator<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token function-variable function">isPeerDependency</span> <span class="token operator">=</span> <span class="token punctuation">(</span>pkg<span class="token punctuation">,</span> parentPkg<span class="token punctuation">,</span> name<span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
  <span class="token function">getKey</span><span class="token punctuation">(</span>pkg<span class="token punctuation">.</span>packageDependencies<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token function">getKey</span><span class="token punctuation">(</span>parentPkg<span class="token punctuation">.</span>packageDependencies<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token function-variable function">traverseDependencyTree</span> <span class="token operator">=</span> <span class="token punctuation">(</span>locator<span class="token punctuation">,</span> parentPkg <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// Prevent infinite recursion when A depends on B which depends on A</span>
  <span class="token keyword">const</span> key <span class="token operator">=</span> <span class="token function">getKey</span><span class="token punctuation">(</span>locator<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>seen<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>

  <span class="token keyword">const</span> pkg <span class="token operator">=</span> pnp<span class="token punctuation">.</span><span class="token function">getPackageInformation</span><span class="token punctuation">(</span>locator<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">assert</span><span class="token punctuation">(</span>pkg<span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">The package information should be available</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  seen<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span>locator<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token punctuation">[</span>name<span class="token punctuation">,</span> referencish<span class="token punctuation">]</span> <span class="token keyword">of</span> pkg<span class="token punctuation">.</span>packageDependencies<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Unmet peer dependencies</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>referencish <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
      <span class="token keyword">continue</span><span class="token punctuation">;</span>

    <span class="token comment">// Avoid iterating on peer dependencies - very expensive</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>parentPkg <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isPeerDependency</span><span class="token punctuation">(</span>pkg<span class="token punctuation">,</span> parentPkg<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token keyword">continue</span><span class="token punctuation">;</span>

    <span class="token keyword">const</span> childLocator <span class="token operator">=</span> pnp<span class="token punctuation">.</span><span class="token function">getLocator</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> referencish<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">traverseDependencyTree</span><span class="token punctuation">(</span>childLocator<span class="token punctuation">,</span> pkg<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">groupEnd</span><span class="token punctuation">(</span>locator<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// Important: This `delete` here causes the traversal to go over nodes even</span>
  <span class="token comment">// if they have already been traversed in another branch. If you don't need</span>
  <span class="token comment">// that, remove this line for a hefty speed increase.</span>
  seen<span class="token punctuation">.</span><span class="token keyword">delete</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// Iterate on each workspace</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> locator <span class="token keyword">of</span> pnp<span class="token punctuation">.</span><span class="token function">getDependencyTreeRoots</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">traverseDependencyTree</span><span class="token punctuation">(</span>locator<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2016&ndash;present Yarn Contributors<br>Licensed under the BSD License.<br>
    <a href="https://yarnpkg.com/advanced/pnpapi" class="_attribution-link">https://yarnpkg.com/advanced/pnpapi</a>
  </p>
</div>
