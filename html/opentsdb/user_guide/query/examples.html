<h1>Query Examples</h1> <p>The following is a list of example queries using an example data set. We'll illustrate a number of common query types that may be encountered so you can get an understanding of how the query system works. Each time series in the example set has only a single data point stored and the UIDs have been truncated to a single byte to make it easier to read. The example queries are all <em>Metric</em> queries from the HTTP API and only show the <code class="docutils literal"><span class="pre">m=</span></code> component. See <a class="reference internal" href="../../api_http/query/index.html"><em>/api/query</em></a> for details. If you are using a CLI tool, the query format will differ slightly so read the documentation for the particular command.</p>  <h2>Sample Data</h2> <p><strong>Time Series</strong></p> <table class="docutils"> <colgroup> <col width="10%"> <col width="20%"> <col width="50%"> <col width="20%"> </colgroup> <thead valign="bottom"> <tr class="row-odd">
<th class="head">TS#</th> <th class="head">Metric</th> <th class="head">Tags</th> <th class="head">TSUID</th> </tr> </thead> <tbody valign="top"> <tr class="row-even">
<td>1</td> <td>sys.cpu.system</td> <td>dc=dal host=web01</td> <td>0102040101</td> </tr> <tr class="row-odd">
<td>2</td> <td>sys.cpu.system</td> <td>dc=dal host=web02</td> <td>0102040102</td> </tr> <tr class="row-even">
<td>3</td> <td>sys.cpu.system</td> <td>dc=dal host=web03</td> <td>0102040103</td> </tr> <tr class="row-odd">
<td>4</td> <td>sys.cpu.system</td> <td>host=web01</td> <td>010101</td> </tr> <tr class="row-even">
<td>5</td> <td>sys.cpu.system</td> <td>host=web01 owner=jdoe</td> <td>0101010306</td> </tr> <tr class="row-odd">
<td>6</td> <td>sys.cpu.system</td> <td>dc=lax host=web01</td> <td>0102050101</td> </tr> <tr class="row-even">
<td>7</td> <td>sys.cpu.system</td> <td>dc=lax host=web02</td> <td>0102050102</td> </tr> <tr class="row-odd">
<td>8</td> <td>sys.cpu.user</td> <td>dc=dal host=web01</td> <td>0202040101</td> </tr> <tr class="row-even">
<td>9</td> <td>sys.cpu.user</td> <td>dc=dal host=web02</td> <td>0202040102</td> </tr> </tbody> </table> <p><strong>UIDs</strong></p> <table class="docutils"> <colgroup> <col width="50%"> <col width="50%"> </colgroup> <thead valign="bottom"> <tr class="row-odd">
<th class="head">Name</th> <th class="head">UID</th> </tr> </thead> <tbody valign="top"> <tr class="row-even">
<td><strong>Metrics</strong></td> <td> </td> </tr> <tr class="row-odd">
<td>cpu.system</td> <td>01</td> </tr> <tr class="row-even">
<td>cpu.user</td> <td>02</td> </tr> <tr class="row-odd">
<td><strong>Tagks</strong></td> <td> </td> </tr> <tr class="row-even">
<td>host</td> <td>01</td> </tr> <tr class="row-odd">
<td>dc</td> <td>02</td> </tr> <tr class="row-even">
<td>owner</td> <td>03</td> </tr> <tr class="row-odd">
<td><strong>Tagvs</strong></td> <td> </td> </tr> <tr class="row-even">
<td>web01</td> <td>01</td> </tr> <tr class="row-odd">
<td>web02</td> <td>02</td> </tr> <tr class="row-even">
<td>web03</td> <td>03</td> </tr> <tr class="row-odd">
<td>dal</td> <td>04</td> </tr> <tr class="row-even">
<td>lax</td> <td>05</td> </tr> <tr class="row-odd">
<td>doe</td> <td>06</td> </tr> </tbody> </table> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">This isn't necesarily the best way to setup your metrics and tags, rather it's meant to be illustrative of how the query system works. In particular, TS #4 and 5, while legitimate timeseries, may screw up your queries unless you know how they work. In general, try to maintain the same number and type of tags for each timeseries.</p> </div>   <h2>Under the Hood</h2> <p>You may want to read up on how OpenTSDB stores timeseries data here: <a class="reference internal" href="../backends/index.html"><em>Storage</em></a>. Otherwise, remember that each row in storage has a unique key formatted:</p> <pre data-language="python">&lt;metricID&gt;&lt;normalized_timestamp&gt;&lt;tagkID1&gt;&lt;tagvID1&gt;[...&lt;tagkIDN&gt;&lt;tagvIDN&gt;]
</pre>
 <p>The data table above would be stored as:</p> <pre data-language="python">01&lt;ts&gt;0101
01&lt;ts&gt;01010306
01&lt;ts&gt;02040101
01&lt;ts&gt;02040102
01&lt;ts&gt;02040103
01&lt;ts&gt;02050101
01&lt;ts&gt;02050102
02&lt;ts&gt;02040101
02&lt;ts&gt;02040102
</pre>
 <p>When you query OpenTSDB, here's what happens under the hood.</p> <ul class="simple"> <li>The query is parsed and verified to make sure that the format is correct and that the metrics, tag names and tag values exist. If a single metric, tag name or value doesn't exist in the system, it will kick back an error.</li> <li>Then it sets up a scanner for the underlying storage system.<ul> <li>If the query doesn't have any tags or tag values, then it will grab any rows of data that match <code class="docutils literal"><span class="pre">&lt;metricID&gt;&lt;timestamp&gt;</span></code>, so if you have a ton of time series for a particular metric, this could be many, many rows.</li> <li>If the query does have one or more tags defined, then it will still scan all of the rows matching <code class="docutils literal"><span class="pre">&lt;metricID&gt;&lt;timestamp&gt;</span></code>, but also perform a regex to return only the rows that contain the requested tag.</li> </ul> </li> <li>Once all of the data has been returned, OpenTSDB organizes it into groups, if required</li> <li>If downsampling was requested, each individual time series is down sampled into smaller time spans using the proper aggregator</li> <li>Then each group of data is aggregated using the specific aggregation function</li> <li>If the <code class="docutils literal"><span class="pre">rate</span></code> flag was detected, each aggregate will then be adjusted to get the rate.</li> <li>Results are returned to the caller</li> </ul>   <h2>Query 1 - All Time Series for a Metric</h2> <pre data-language="python">m=sum:cpu.system
</pre>
 <p>This is the simplest query to make. TSDB will setup a scanner to fetch all data points for the metric UID <code class="docutils literal"><span class="pre">01</span></code> between <em>&lt;start&gt;</em> and <em>&lt;end&gt;</em>. The result will be the a single dataset with time series #1 through #7 summed together. If you have thousands of unique tag combinations for a given metric, they will all be added together into one series.</p> <pre data-language="javascript">[
  {
    "metric": "cpu.system",
    "tags": {},
    "aggregated_tags": [
      "host"
    ],
    "tsuids": [
      "010101",
      "0101010306",
      "0102050101",
      "0102040101",
      "0102040102",
      "0102040103",
      "0102050102"
    ],
    "dps": {
      "1346846400": 130.29999923706055
    }
  }
]
</pre>
   <h2>Query 2 - Filter on a Tag</h2> <p>Usually aggregating all of the time series for a metric isn't particularly useful. Instead we can drill down a little by filtering for time series that contain a specific tagk/tagv pair combination. Simply put the pair in curly braces:</p> <pre data-language="python">m=sum:cpu.system{host=web01}
</pre>
 <p>This will return an aggregate of time series #1, #4, #5 and #6 since they're the only series that include <code class="docutils literal"><span class="pre">host=web01</span></code>.</p> <pre data-language="javascript">[
  {
    "metric": "cpu.system",
    "tags": {
      "host": "web01"
    },
    "aggregated_tags": [],
    "tsuids": [
      "010101",
      "0101010306",
      "0102040101",
      "0102050101"
    ],
    "dps": {
      "1346846400": 63.59999942779541
    }
  }
]
</pre>
   <h2>Query 3 - Specific Time Series</h2> <p>What if you want a specific timeseries? You have to include every tag and coresponding value.</p> <pre data-language="python">m=sum:cpu.system{host=web01,dc=lax}
</pre>
 <p>This will return the data from timeseries #6 only.</p> <pre data-language="javascript">[
  {
    "metric": "cpu.system",
    "tags": {
      "dc": "lax",
      "host": "web01"
    },
    "aggregated_tags": [],
    "tsuids": [
      "0102050101"
    ],
    "dps": {
      "1346846400": 15.199999809265137
    }
  }
]
</pre>
 <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">This is where a tagging scheme will stand or fall. Let's say you want to get just the data from timeseries #4. With the current system, you are unable to. You would send in query #2 <code class="docutils literal"><span class="pre">m=sum:cpu.system{host=web01}</span></code> thinking that it will return just the data from #4, but as we saw, you'll get the aggregate results for #1, #4, #5 and #6. To prevent such an occurance, you would need to add another tag to #4 that differentiates it from other timeseries in the group. Or if you've already commited, you can use TSUID queries.</p> </div>   <h2>Query 4 - TSUID Query</h2> <p>If you know the exact TSUID of the timeseries that you want to retrieve, you can simply pass it in like so:</p> <pre data-language="python">tsuids=sum:0102040102
</pre>
 <p>The results will be the data points that you requested.</p> <pre data-language="javascript">[
  {
    "metric": "cpu.system",
    "tags": {
      "dc": "lax",
      "host": "web01"
    },
    "aggregated_tags": [],
    "tsuids": [
      "0102050101"
    ],
    "dps": {
      "1346846400": 15.199999809265137
    }
  }
]
</pre>
   <h2>Query 5 - Multi-TSUID Query</h2> <p>You can also aggregate multiple TSUIDs in the same query, provided they share the same metric. If you attempt to aggregate multiple metrics, the API will issue an error.</p> <pre data-language="python">tsuids=sum:0102040101,0102050101
</pre>
 <pre data-language="javascript">[
  {
    "metric": "cpu.system",
    "tags": {
      "host": "web01"
    },
    "aggregated_tags": [
      "dc"
    ],
    "tsuids": [
      "0102040101",
      "0102050101"
    ],
    "dps": {
      "1346846400": 33.19999980926514
    }
  }
]
</pre>
   <h2>Query 6 - Grouping</h2> <pre data-language="python">m=sum:cpu.system{host=*}
</pre>
 <p>The <code class="docutils literal"><span class="pre">*</span></code> (asterisk) is a grouping operator that will return a data set for each unique value of the tag name given. Every timeseries that includes the given metric and the given tag name, regardless of other tags or values, will be included in the results. After the individual timeseries results are grouped, they'll be aggregated and returned.</p> <p>In this example, we will have 3 groups returned:</p> <table class="docutils"> <colgroup> <col width="50%"> <col width="50%"> </colgroup> <thead valign="bottom"> <tr class="row-odd">
<th class="head">Group</th> <th class="head">Time Series Included</th> </tr> </thead> <tbody valign="top"> <tr class="row-even">
<td>web01</td> <td>#1, #4, #5, #6</td> </tr> <tr class="row-odd">
<td>web02</td> <td>#2, #7</td> </tr> <tr class="row-even">
<td>web03</td> <td>#3</td> </tr> </tbody> </table> <p>TSDB found 7 total timeseries that included the "host" tag. There were 3 unique values for that tag (web01, web02, and web03).</p> <pre data-language="javascript">[
  {
    "metric": "cpu.system",
    "tags": {
      "host": "web01"
    },
    "aggregated_tags": [],
    "tsuids": [
      "010101",
      "0101010306",
      "0102040101",
      "0102050101"
    ],
    "dps": {
      "1346846400": 63.59999942779541
    }
  },
  {
    "metric": "cpu.system",
    "tags": {
      "host": "web02"
    },
    "aggregated_tags": [
      "dc"
    ],
    "tsuids": [
      "0102040102",
      "0102050102"
    ],
    "dps": {
      "1346846400": 24.199999809265137
    }
  },
  {
    "metric": "cpu.system",
    "tags": {
      "dc": "dal",
      "host": "web03"
    },
    "aggregated_tags": [],
    "tsuids": [
      "0102040103"
    ],
    "dps": {
      "1346846400": 42.5
    }
  }
]
</pre>
   <h2>Query 7 - Group and Filter</h2> <p>Note that the in example #2, the <code class="docutils literal"><span class="pre">web01</span></code> group included the odd-ball timeseries #4 and #5. We can filter those out by specifying a second tag ala:</p> <pre data-language="python">m=sum:cpu.nice{host=*,dc=dal}
</pre>
 <p>Now we'll only get results for #1 - #3, but we lose the <code class="docutils literal"><span class="pre">dc=lax</span></code> values.</p> <pre data-language="javascript">[
  {
    "metric": "cpu.system",
    "tags": {
      "dc": "dal",
      "host": "web01"
    },
    "aggregated_tags": [],
    "tsuids": [
      "0102040101"
    ],
    "dps": {
      "1346846400": 18
    }
  },
  {
    "metric": "cpu.system",
    "tags": {
      "dc": "dal",
      "host": "web02"
    },
    "aggregated_tags": [],
    "tsuids": [
      "0102040102"
    ],
    "dps": {
      "1346846400": 9
    }
  },
  {
    "metric": "cpu.system",
    "tags": {
      "dc": "dal",
      "host": "web03"
    },
    "aggregated_tags": [],
    "tsuids": [
      "0102040103"
    ],
    "dps": {
      "1346846400": 42.5
    }
  }
]
</pre>
   <h2>Query 8 - Grouping With OR</h2> <p>The <code class="docutils literal"><span class="pre">*</span></code> operator is greedy and will return <em>all</em> values that are assigned to a tag name. If you only want a few tag values, you can use the <code class="docutils literal"><span class="pre">|</span></code> (pipe) operator instead.</p> <pre data-language="python">m=sum:cpu.nice{host=web01|web02}
</pre>
 <p>This will find all of the timeseries that include "host" values for "web01" OR "web02", then group them by value, similar to the <code class="docutils literal"><span class="pre">*</span></code> operator. Our groups, this time, will look like this:</p> <table class="docutils"> <colgroup> <col width="50%"> <col width="50%"> </colgroup> <thead valign="bottom"> <tr class="row-odd">
<th class="head">Group</th> <th class="head">Time Series Included</th> </tr> </thead> <tbody valign="top"> <tr class="row-even">
<td>web01</td> <td>#1, #4, #5, #6</td> </tr> <tr class="row-odd">
<td>web02</td> <td>#2, #7</td> </tr> </tbody> </table> <pre data-language="javascript">[
  {
    "metric": "cpu.system",
    "tags": {
      "host": "web01"
    },
    "aggregated_tags": [],
    "tsuids": [
      "010101",
      "0101010306",
      "0102040101",
      "0102050101"
    ],
    "dps": {
      "1346846400": 63.59999942779541
    }
  },
  {
    "metric": "cpu.system",
    "tags": {
      "host": "web02"
    },
    "aggregated_tags": [
      "dc"
    ],
    "tsuids": [
      "0102040102",
      "0102050102"
    ],
    "dps": {
      "1346846400": 24.199999809265137
    }
  }
]
</pre>
<div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2016 The OpenTSDB Authors<br>Licensed under the GNU LGPLv2.1+ and GPLv3+ licenses.<br>
    <a href="http://opentsdb.net/docs/build/html/user_guide/query/examples.html" class="_attribution-link">http://opentsdb.net/docs/build/html/user_guide/query/examples.html</a>
  </p>
</div>
