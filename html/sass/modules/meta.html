<h1 class="sl-l-container">sass:meta</h1> <div class="sl-l-container sl-color--white-background sl-l-section"> <div class="sl-l-medium-holy-grail"> <div class="sl-l-medium-holy-grail__body">  <div class="sl-l-medium-holy-grail__main"> <div class="sl-l-large-holy-grail"> <div class="sl-l-large-holy-grail__body"> <div class="sl-l-large-holy-grail__main docSearch-content"> <div class="sl-l-container sl-l-container--small"> <dl class="impl-status sl-c-description-list sl-c-description-list--horizontal"> <div class="compatibility"> Compatibility: </div>
<div> <dt>Dart Sass</dt> <dd>since 1.23.0</dd> </div>
<div> <dt>LibSass</dt> <dd>✗</dd> </div>
<div> <dt>Ruby Sass</dt> <dd>✗</dd> </div>
<div><a href="javascript:;.html">➤</a></div>
</dl>
<div class="sl-c-callout sl-c-callout--impl-status"> <p>Only Dart Sass currently supports loading built-in modules with <code>@use</code>. Users of other implementations must call functions using their global names instead.</p> </div> <h2 id="mixins" tabindex="-1">Mixins
</h2> <div class="sl-c-callout sl-c-callout--function">
<pre class="signature language-scss" id="meta.apply" data-language="scss">meta.apply($mixin, $args...)</pre> <dl class="impl-status sl-c-description-list sl-c-description-list--horizontal"> <div class="compatibility"> Compatibility: </div>
<div> <dt>Dart Sass</dt> <dd>since 1.69.0</dd> </div>
<div> <dt>LibSass</dt> <dd>✗</dd> </div>
<div> <dt>Ruby Sass</dt> <dd>✗</dd> </div>
</dl> <p>Includes <code>$mixin</code> with <code>$args</code>. If this is passed a <a href="../at-rules/mixin.html#content-blocks"><code>@content</code> block</a>, it’s forwarded to <code>$mixin</code>.</p> <p>The <code>$mixin</code> must be a <a href="../values/mixins.html">mixin value</a>, such as one returned by <a href="#get-mixin"><code>meta.get-mixin()</code></a>.</p> <div class="code-example ui-tabs can-split" style="--split-location: 72.72727272727273%"> <div id="example-first-class-mixin-scss" class="ui-tabs-panel scss sl-c-code-panel"><pre class="language-scss" data-language="scss">@use "sass:meta";
@use "sass:string";

/// Passes each element of $list to a separate invocation of $mixin.
@mixin apply-to-all($mixin, $list) {
  @each $element in $list {
    @include meta.apply($mixin, $element);
  }
}

@mixin font-class($size) {
  .font-#{$size} {
    font-size: $size;
  }
}

$sizes: [8px, 12px, 2rem];

@include apply-to-all(meta.get-mixin("font-class"), $sizes);</pre></div> <div id="example-first-class-mixin-sass" class="ui-tabs-panel sass ui-tabs-panel-inactive sl-c-code-panel"><pre class="language-sass" data-language="sass">// SASS
@use "sass:meta"
@use "sass:string"

/// Passes each element of $list to a separate invocation of $mixin.
@mixin apply-to-all($mixin, $list)
  @each $element in $list
    @include meta.apply($mixin, $element)



@mixin font-class($size)
  .font-#{$size}
    font-size: $size



$sizes: 8px, 12px 2rem

@include apply-to-all(meta.get-mixin("font-class"), $sizes)</pre></div> <div id="example-first-class-mixin-css" class="ui-tabs-panel css ui-tabs-panel-inactive sl-c-code-panel"><pre class="language-css" data-language="css">/* CSS */
.font-8px {
  font-size: 8px;
}

.font-12px {
  font-size: 12px;
}

.font-2rem {
  font-size: 2rem;
}</pre></div> </div> </div> <div class="sl-c-callout sl-c-callout--function">
<pre class="signature language-scss" id="meta.load-css" data-language="scss">meta.load-css($url, $with: null)</pre> <dl class="impl-status sl-c-description-list sl-c-description-list--horizontal"> <div class="compatibility"> Compatibility: </div>
<div> <dt>Dart Sass</dt> <dd>since 1.23.0</dd> </div>
<div> <dt>LibSass</dt> <dd>✗</dd> </div>
<div> <dt>Ruby Sass</dt> <dd>✗</dd> </div>
<div><a href="javascript:;.html">➤</a></div>
</dl>
<div class="sl-c-callout sl-c-callout--impl-status"> <p>Only Dart Sass currently supports this mixin.</p> </div> <p>Loads the <a href="../at-rules/use.html">module</a> at <code>$url</code> and includes its <span class="caps">CSS</span> as though it were written as the contents of this mixin. The <code>$with</code> parameter provides <a href="../at-rules/use.html#configuration">configuration</a> for the modules; if it’s passed, it must be a map from variable names (without <code>$</code>) to the values of those variables to use in the loaded module.</p> <p>If <code>$url</code> is relative, it’s interpreted as relative to the file in which <code>meta.load-css()</code> is included.</p> <p><strong>Like the <a href="../at-rules/use.html"><code>@use</code> rule</a></strong>:</p> <ul> <li> <p>This will only evaluate the given module once, even if it’s loaded multiple times in different ways.</p> </li> <li> <p>This cannot provide configuration to a module that’s already been loaded, whether or not it was already loaded with configuration.</p> </li> </ul> <p><strong>Unlike the <a href="../at-rules/use.html"><code>@use</code> rule</a></strong>:</p> <ul> <li> <p>This doesn’t make any members from the loaded module available in the current module.</p> </li> <li> <p>This can be used anywhere in a stylesheet. It can even be nested within style rules to create nested styles!</p> </li> <li> <p>The module <span class="caps">URL</span> being loaded can come from a variable and include <a href="../interpolation.html">interpolation</a>.</p> </li> </ul> <div class="sl-c-callout sl-c-callout--warning">  <p>The <code>$url</code> parameter should be a string containing a <span class="caps">URL</span> like you’d pass to the <code>@use</code> rule. It shouldn’t be a <span class="caps">CSS</span> <code>url()</code>!</p> </div> <div class="code-example ui-tabs can-split" style="--split-location: 67.27272727272727%"> <div id="example-load-css-scss" class="ui-tabs-panel scss sl-c-code-panel">
<pre class="language-scss" data-language="scss">// dark-theme/_code.scss
$border-contrast: false !default;

code {
  background-color: #6b717f;
  color: #d2e1dd;
  @if $border-contrast {
    border-color: #dadbdf;
  }
}</pre>
<pre class="language-scss" data-language="scss">// style.scss
@use "sass:meta";

body.dark {
  @include meta.load-css("dark-theme/code",
      $with: ("border-contrast": true));
}</pre>
</div> <div id="example-load-css-sass" class="ui-tabs-panel sass ui-tabs-panel-inactive sl-c-code-panel">
<pre class="language-sass" data-language="sass">// SASS
// dark-theme/_code.sass
$border-contrast: false !default

code
  background-color: #6b717f
  color: #d2e1dd
  @if $border-contrast
    border-color: #dadbdf</pre>
<pre class="language-sass" data-language="sass">// SASS
// style.sass
@use "sass:meta"

body.dark
  $configuration: ("border-contrast": true)
  @include meta.load-css("dark-theme/code", $with: $configuration)</pre>
</div> <div id="example-load-css-css" class="ui-tabs-panel css ui-tabs-panel-inactive sl-c-code-panel"><pre class="language-css" data-language="css">/* CSS */
body.dark code {
  background-color: #6b717f;
  color: #d2e1dd;
  border-color: #dadbdf;
}</pre></div> </div> </div> <h2 id="functions" tabindex="-1">Functions
</h2> <div class="sl-c-callout sl-c-callout--function">
<pre class="signature language-scss" id="meta.accepts-content" data-language="scss">meta.accepts-content($mixin) //=&gt; boolean</pre> <dl class="impl-status sl-c-description-list sl-c-description-list--horizontal"> <div class="compatibility"> Compatibility: </div>
<div> <dt>Dart Sass</dt> <dd>since 1.69.0</dd> </div>
<div> <dt>LibSass</dt> <dd>✗</dd> </div>
<div> <dt>Ruby Sass</dt> <dd>✗</dd> </div>
</dl> <p>Returns whether the given <a href="../values/mixins.html">mixin value</a> can accept a <a href="../at-rules/mixin.html#content-blocks"><code>@content</code> block</a>.</p> <p>This returns true if it’s <em>possible</em> for the mixin to accept a <code>@content</code> block, even if it doesn’t always do so.</p> </div> <div class="sl-c-callout sl-c-callout--function">
<pre class="signature language-scss" id="meta.calc-args" data-language="scss">meta.calc-args($calc) //=&gt; list</pre> <dl class="impl-status sl-c-description-list sl-c-description-list--horizontal"> <div class="compatibility"> Compatibility: </div>
<div> <dt>Dart Sass</dt> <dd>since 1.40.0</dd> </div>
<div> <dt>LibSass</dt> <dd>✗</dd> </div>
<div> <dt>Ruby Sass</dt> <dd>✗</dd> </div>
</dl> <p>Returns the arguments for the given <a href="../values/calculations.html">calculation</a>.</p> <p>If an argument is a number or a nested calculation, it’s returned as that type. Otherwise, it’s returned as an unquoted string.</p> <div class="code-example ui-tabs"> <div id="example-calc-args-scss" class="ui-tabs-panel scss sl-c-code-panel"><pre class="language-scss" data-language="scss">@use 'sass:meta';

@debug meta.calc-args(calc(100px + 10%)); // unquote("100px + 10%")
@debug meta.calc-args(clamp(50px, var(--width), 1000px)); // 50px, unquote("var(--width)"), 1000px</pre></div> <div id="example-calc-args-sass" class="ui-tabs-panel sass ui-tabs-panel-inactive sl-c-code-panel"><pre class="language-sass" data-language="sass">// SASS
@use 'sass:meta'

@debug meta.calc-args(calc(100px + 10%))  // unquote("100px + 10%")
@debug meta.calc-args(clamp(50px, var(--width), 1000px))  // 50px, unquote("var(--width)"), 1000px</pre></div> </div> </div> <div class="sl-c-callout sl-c-callout--function">
<pre class="signature language-scss" id="meta.calc-name" data-language="scss">meta.calc-name($calc) //=&gt; quoted string</pre> <dl class="impl-status sl-c-description-list sl-c-description-list--horizontal"> <div class="compatibility"> Compatibility: </div>
<div> <dt>Dart Sass</dt> <dd>since 1.40.0</dd> </div>
<div> <dt>LibSass</dt> <dd>✗</dd> </div>
<div> <dt>Ruby Sass</dt> <dd>✗</dd> </div>
</dl> <p>Returns the name of the given <a href="../values/calculations.html">calculation</a>.</p> <div class="code-example ui-tabs"> <div id="example-calc-name-scss" class="ui-tabs-panel scss sl-c-code-panel"><pre class="language-scss" data-language="scss">@use 'sass:meta';

@debug meta.calc-name(calc(100px + 10%)); // "calc"
@debug meta.calc-name(clamp(50px, var(--width), 1000px)); // "clamp"</pre></div> <div id="example-calc-name-sass" class="ui-tabs-panel sass ui-tabs-panel-inactive sl-c-code-panel"><pre class="language-sass" data-language="sass">// SASS
@use 'sass:meta'

@debug meta.calc-name(calc(100px + 10%))  // "calc"
@debug meta.calc-name(clamp(50px, var(--width), 1000px))  // "clamp"</pre></div> </div> </div> <div class="sl-c-callout sl-c-callout--function">
<pre class="signature language-scss" id="meta.call" data-language="scss">meta.call($function, $args...)
call($function, $args...)</pre> <dl class="impl-status sl-c-description-list sl-c-description-list--horizontal"> <div class="compatibility"> Compatibility (Argument Type): </div>
<div> <dt>Dart Sass</dt> <dd>✓</dd> </div>
<div> <dt>LibSass</dt> <dd>since 3.5.0</dd> </div>
<div> <dt>Ruby Sass</dt> <dd>since 3.5.0</dd> </div>
<div><a href="javascript:;.html">➤</a></div>
</dl>
<div class="sl-c-callout sl-c-callout--impl-status"> <p>In older versions of LibSass and Ruby Sass, the <a href="meta.html#call"><code>call()</code> function</a> took a string representing a function’s name. This was changed to take a function value instead in preparation for a new module system where functions are no longer global and so a given name may not always refer to the same function.</p> <p>Passing a string to <code>call()</code> still works in all implementations, but it’s deprecated and will be disallowed in future versions.</p> </div> <p>Invokes <code>$function</code> with <code>$args</code> and returns the result.</p> <p>The <code>$function</code> must be a <a href="../values/functions.html">function value</a>, such as one returned by <a href="#get-function"><code>meta.get-function()</code></a>.</p> <div class="code-example ui-tabs"> <div id="example-first-class-function-scss" class="ui-tabs-panel scss sl-c-code-panel"><pre class="language-scss" data-language="scss">@use "sass:list";
@use "sass:meta";
@use "sass:string";

/// Return a copy of $list with all elements for which $condition returns `true`
/// removed.
@function remove-where($list, $condition) {
  $new-list: ();
  $separator: list.separator($list);
  @each $element in $list {
    @if not meta.call($condition, $element) {
      $new-list: list.append($new-list, $element, $separator: $separator);
    }
  }
  @return $new-list;
}

$fonts: Tahoma, Geneva, "Helvetica Neue", Helvetica, Arial, sans-serif;

.content {
  @function contains-helvetica($string) {
    @return string.index($string, "Helvetica");
  }
  font-family: remove-where($fonts, meta.get-function("contains-helvetica"));
}</pre></div> <div id="example-first-class-function-sass" class="ui-tabs-panel sass ui-tabs-panel-inactive sl-c-code-panel"><pre class="language-sass" data-language="sass">// SASS
@use "sass:list"
@use "sass:meta"
@use "sass:string"

/// Return a copy of $list with all elements for which $condition returns `true`
/// removed.
@function remove-where($list, $condition)
  $new-list: ()
  $separator: list.separator($list)
  @each $element in $list
    @if not meta.call($condition, $element)
      $new-list: list.append($new-list, $element, $separator: $separator)


  @return $new-list


$fonts: Tahoma, Geneva, "Helvetica Neue", Helvetica, Arial, sans-serif

.content
  @function contains-helvetica($string)
    @return string.index($string, "Helvetica")

  font-family: remove-where($fonts, meta.get-function("contains-helvetica"))</pre></div> <div id="example-first-class-function-css" class="ui-tabs-panel css ui-tabs-panel-inactive sl-c-code-panel"><pre class="language-css" data-language="css">/* CSS */
.content {
  font-family: Tahoma, Geneva, Arial, sans-serif;
}</pre></div> </div> </div> <div class="sl-c-callout sl-c-callout--function">
<pre class="signature language-scss" id="meta.content-exists" data-language="scss">meta.content-exists()
content-exists() //=&gt; boolean</pre> <p>Returns whether the current mixin was passed a <a href="../at-rules/mixin.html#content-blocks"><code>@content</code> block</a>.</p> <p>Throws an error if called outside of a mixin.</p> <div class="code-example ui-tabs"> <div id="example-content-exists-scss" class="ui-tabs-panel scss sl-c-code-panel"><pre class="language-scss" data-language="scss">@use 'sass:meta';

@mixin debug-content-exists {
  @debug meta.content-exists();
  @content;
}

@include debug-content-exists; // false
@include debug-content-exists { // true
  // Content!
}</pre></div> <div id="example-content-exists-sass" class="ui-tabs-panel sass ui-tabs-panel-inactive sl-c-code-panel"><pre class="language-sass" data-language="sass">// SASS
@use 'sass:meta'

@mixin debug-content-exists
  @debug meta.content-exists()
  @content


@include debug-content-exists  // false
@include debug-content-exists   // true
  // Content!</pre></div> </div> </div> <div class="sl-c-callout sl-c-callout--function">
<pre class="signature language-scss" id="meta.feature-exists" data-language="scss">meta.feature-exists($feature)
feature-exists($feature) //=&gt; boolean</pre> <p>Returns whether the current Sass implementation supports <code>$feature</code>.</p> <p>The <code>$feature</code> must be a string. The currently recognized features are:</p> <ul> <li>
<code>global-variable-shadowing</code>, which means that a local variable will <a href="../variables.html#shadowing">shadow</a> a global variable unless it has the <code>!global</code> flag.</li> <li>
<code>extend-selector-pseudoclass</code>, which means that the <a href="../at-rules/extend.html"><code>@extend</code> rule</a> will affect selectors nested in pseudo-classes like <code>:not()</code>.</li> <li>
<code>units-level3</code>, which means that <a href="../values/numbers.html#units">unit arithmetic</a> supports units defined in <a href="http://www.w3.org/TR/css3-values"><span class="caps">CSS</span> Values and Units Level 3</a>.</li> <li>
<code>at-error</code>, which means that the <a href="../at-rules/error.html"><code>@error</code> rule</a> is supported.</li> <li>
<code>custom-property</code>, which means that <a href="../style-rules/declarations.html#custom-properties">custom property declaration</a> values don’t support any <a href="../syntax/structure.html#expressions">expressions</a> other than <a href="../interpolation.html">interpolation</a>.</li> </ul> <p>Returns <code>false</code> for any unrecognized <code>$feature</code>.</p> <div class="sl-c-callout sl-c-callout--warning">  <p>This function is deprecated and should be avoided. See <a href="https://sass-lang.com/documentation/breaking-changes/feature-exists">the breaking change page</a> for details.</p> </div> <div class="code-example ui-tabs"> <div id="example-feature-exists-scss" class="ui-tabs-panel scss sl-c-code-panel"><pre class="language-scss" data-language="scss">@use "sass:meta";

@debug meta.feature-exists("at-error"); // true
@debug meta.feature-exists("unrecognized"); // false</pre></div> <div id="example-feature-exists-sass" class="ui-tabs-panel sass ui-tabs-panel-inactive sl-c-code-panel"><pre class="language-sass" data-language="sass">// SASS
@use "sass:meta"

@debug meta.feature-exists("at-error")  // true
@debug meta.feature-exists("unrecognized")  // false</pre></div> </div> </div> <div class="sl-c-callout sl-c-callout--function">
<pre class="signature language-scss" id="meta.function-exists" data-language="scss">meta.function-exists($name, $module: null)
function-exists($name) //=&gt; boolean</pre> <p>Returns whether a function named <code>$name</code> is defined, either as a built-in function or a user-defined function.</p> <p>If <code>$module</code> is passed, this also checks the module named <code>$module</code> for the function definition. <code>$module</code> must be a string matching the namespace of a <a href="../at-rules/use.html"><code>@use</code> rule</a> in the current file.</p> <div class="code-example ui-tabs"> <div id="example-function-exists-scss" class="ui-tabs-panel scss sl-c-code-panel"><pre class="language-scss" data-language="scss">@use "sass:meta";
@use "sass:math";

@debug meta.function-exists("div", "math"); // true
@debug meta.function-exists("scale-color"); // true
@debug meta.function-exists("add"); // false

@function add($num1, $num2) {
  @return $num1 + $num2;
}
@debug meta.function-exists("add"); // true</pre></div> <div id="example-function-exists-sass" class="ui-tabs-panel sass ui-tabs-panel-inactive sl-c-code-panel"><pre class="language-sass" data-language="sass">// SASS
@use "sass:meta"
@use "sass:math"

@debug meta.function-exists("div", "math")  // true
@debug meta.function-exists("scale-color")  // true
@debug meta.function-exists("add")  // false

@function add($num1, $num2)
  @return $num1 + $num2

@debug meta.function-exists("add")  // true</pre></div> </div> </div> <div class="sl-c-callout sl-c-callout--function">
<pre class="signature language-scss" id="meta.get-function" data-language="scss">meta.get-function($name, $css: false, $module: null)
get-function($name, $css: false, $module: null) //=&gt; function</pre> <p>Returns the <a href="../values/functions.html">function value</a> named <code>$name</code>.</p> <p>If <code>$module</code> is <code>null</code>, this returns the function named <code>$name</code> without a namespace (including <a href="../modules.html#global-functions">global built-in functions</a>). Otherwise, <code>$module</code> must be a string matching the namespace of a <a href="../at-rules/use.html"><code>@use</code> rule</a> in the current file, in which case this returns the function in that module named <code>$name</code>.</p> <p>By default, this throws an error if <code>$name</code> doesn’t refer to Sass function. However, if <code>$css</code> is <code>true</code>, it instead returns a <a href="../at-rules/function.html#plain-css-functions">plain <span class="caps">CSS</span> function</a>.</p> <p>The returned function can be called using <a href="#call"><code>meta.call()</code></a>.</p> <div class="code-example ui-tabs"> <div id="example-first-class-function-scss" class="ui-tabs-panel scss sl-c-code-panel"><pre class="language-scss" data-language="scss">@use "sass:list";
@use "sass:meta";
@use "sass:string";

/// Return a copy of $list with all elements for which $condition returns `true`
/// removed.
@function remove-where($list, $condition) {
  $new-list: ();
  $separator: list.separator($list);
  @each $element in $list {
    @if not meta.call($condition, $element) {
      $new-list: list.append($new-list, $element, $separator: $separator);
    }
  }
  @return $new-list;
}

$fonts: Tahoma, Geneva, "Helvetica Neue", Helvetica, Arial, sans-serif;

.content {
  @function contains-helvetica($string) {
    @return string.index($string, "Helvetica");
  }
  font-family: remove-where($fonts, meta.get-function("contains-helvetica"));
}</pre></div> <div id="example-first-class-function-sass" class="ui-tabs-panel sass ui-tabs-panel-inactive sl-c-code-panel"><pre class="language-sass" data-language="sass">// SASS
@use "sass:list"
@use "sass:meta"
@use "sass:string"

/// Return a copy of $list with all elements for which $condition returns `true`
/// removed.
@function remove-where($list, $condition)
  $new-list: ()
  $separator: list.separator($list)
  @each $element in $list
    @if not meta.call($condition, $element)
      $new-list: list.append($new-list, $element, $separator: $separator)


  @return $new-list


$fonts: Tahoma, Geneva, "Helvetica Neue", Helvetica, Arial, sans-serif

.content
  @function contains-helvetica($string)
    @return string.index($string, "Helvetica")

  font-family: remove-where($fonts, meta.get-function("contains-helvetica"))</pre></div> <div id="example-first-class-function-css" class="ui-tabs-panel css ui-tabs-panel-inactive sl-c-code-panel"><pre class="language-css" data-language="css">/* CSS */
.content {
  font-family: Tahoma, Geneva, Arial, sans-serif;
}</pre></div> </div> </div> <div class="sl-c-callout sl-c-callout--function">
<pre class="signature language-scss" id="meta.get-mixin" data-language="scss">meta.get-mixin($name, $module: null) //=&gt; function</pre> <dl class="impl-status sl-c-description-list sl-c-description-list--horizontal"> <div class="compatibility"> Compatibility: </div>
<div> <dt>Dart Sass</dt> <dd>since 1.69.0</dd> </div>
<div> <dt>LibSass</dt> <dd>✗</dd> </div>
<div> <dt>Ruby Sass</dt> <dd>✗</dd> </div>
</dl> <p>Returns the <a href="../values/mixins.html">mixin value</a> named <code>$name</code>.</p> <p>If <code>$module</code> is <code>null</code>, this returns the mixin named <code>$name</code> defined in the current module. Otherwise, <code>$module</code> must be a string matching the namespace of a <a href="../at-rules/use.html"><code>@use</code> rule</a> in the current file, in which case this returns the mixin in that module named <code>$name</code>.</p> <p>By default, this throws an error if <code>$name</code> doesn’t refer to a mixin.</p> <p>The returned mixin can be included using <a href="#apply"><code>meta.apply()</code></a>.</p> <div class="code-example ui-tabs can-split" style="--split-location: 72.72727272727273%"> <div id="example-first-class-mixin-scss" class="ui-tabs-panel scss sl-c-code-panel"><pre class="language-scss" data-language="scss">@use "sass:meta";
@use "sass:string";

/// Passes each element of $list to a separate invocation of $mixin.
@mixin apply-to-all($mixin, $list) {
  @each $element in $list {
    @include meta.apply($mixin, $element);
  }
}

@mixin font-class($size) {
  .font-#{$size} {
    font-size: $size;
  }
}

$sizes: [8px, 12px, 2rem];

@include apply-to-all(meta.get-mixin("font-class"), $sizes);</pre></div> <div id="example-first-class-mixin-sass" class="ui-tabs-panel sass ui-tabs-panel-inactive sl-c-code-panel"><pre class="language-sass" data-language="sass">// SASS
@use "sass:meta"
@use "sass:string"

/// Passes each element of $list to a separate invocation of $mixin.
@mixin apply-to-all($mixin, $list)
  @each $element in $list
    @include meta.apply($mixin, $element)



@mixin font-class($size)
  .font-#{$size}
    font-size: $size



$sizes: 8px, 12px 2rem

@include apply-to-all(meta.get-mixin("font-class"), $sizes)</pre></div> <div id="example-first-class-mixin-css" class="ui-tabs-panel css ui-tabs-panel-inactive sl-c-code-panel"><pre class="language-css" data-language="css">/* CSS */
.font-8px {
  font-size: 8px;
}

.font-12px {
  font-size: 12px;
}

.font-2rem {
  font-size: 2rem;
}</pre></div> </div> </div> <div class="sl-c-callout sl-c-callout--function">
<pre class="signature language-scss" id="meta.global-variable-exists" data-language="scss">meta.global-variable-exists($name, $module: null)
global-variable-exists($name, $module: null) //=&gt; boolean</pre> <p>Returns whether a <a href="../variables.html#scope">global variable</a> named <code>$name</code> (without the <code>$</code>) exists.</p> <p>If <code>$module</code> is <code>null</code>, this returns whether a variable named <code>$name</code> without a namespace exists. Otherwise, <code>$module</code> must be a string matching the namespace of a <a href="../at-rules/use.html"><code>@use</code> rule</a> in the current file, in which case this returns whether that module has a variable named <code>$name</code>.</p> <p>See also <a href="#variable-exists"><code>meta.variable-exists()</code></a>.</p> <div class="code-example ui-tabs"> <div id="example-global-variable-exists-scss" class="ui-tabs-panel scss sl-c-code-panel"><pre class="language-scss" data-language="scss">@use "sass:meta";

@debug meta.global-variable-exists("var1"); // false

$var1: value;
@debug meta.global-variable-exists("var1"); // true

h1 {
  // $var2 is local.
  $var2: value;
  @debug meta.global-variable-exists("var2"); // false
}</pre></div> <div id="example-global-variable-exists-sass" class="ui-tabs-panel sass ui-tabs-panel-inactive sl-c-code-panel"><pre class="language-sass" data-language="sass">// SASS
@use "sass:meta"

@debug meta.global-variable-exists("var1")  // false

$var1: value
@debug meta.global-variable-exists("var1")  // true

h1
  // $var2 is local.
  $var2: value
  @debug meta.global-variable-exists("var2")  // false</pre></div> </div> </div> <div class="sl-c-callout sl-c-callout--function">
<pre class="signature language-scss" id="meta.inspect" data-language="scss">meta.inspect($value)
inspect($value) //=&gt; unquoted string</pre> <p>Returns a string representation of <code>$value</code>.</p> <p>Returns a representation of <em>any</em> Sass value, not just those that can be represented in <span class="caps">CSS</span>. As such, its return value is not guaranteed to be valid <span class="caps">CSS</span>.</p> <div class="sl-c-callout sl-c-callout--warning">  <p>This function is intended for debugging; its output format is not guaranteed to be consistent across Sass versions or implementations.</p> </div> <div class="code-example ui-tabs"> <div id="example-inspect-scss" class="ui-tabs-panel scss sl-c-code-panel"><pre class="language-scss" data-language="scss">@use "sass:meta";

@debug meta.inspect(10px 20px 30px); // unquote("10px 20px 30px")
@debug meta.inspect(("width": 200px)); // unquote('("width": 200px)')
@debug meta.inspect(null); // unquote("null")
@debug meta.inspect("Helvetica"); // unquote('"Helvetica"')</pre></div> <div id="example-inspect-sass" class="ui-tabs-panel sass ui-tabs-panel-inactive sl-c-code-panel"><pre class="language-sass" data-language="sass">// SASS
@use "sass:meta"

@debug meta.inspect(10px 20px 30px)  // unquote("10px 20px 30px")
@debug meta.inspect(("width": 200px))  // unquote('("width": 200px)')
@debug meta.inspect(null)  // unquote("null")
@debug meta.inspect("Helvetica")  // unquote('"Helvetica"')</pre></div> </div> </div> <div class="sl-c-callout sl-c-callout--function">
<pre class="signature language-scss" id="meta.keywords" data-language="scss">meta.keywords($args)
keywords($args) //=&gt; map</pre> <p>Returns the keywords passed to a mixin or function that takes <a href="../at-rules/mixin.html#taking-arbitrary-arguments">arbitrary arguments</a>. The <code>$args</code> argument must be an <a href="../values/lists.html#argument-lists">argument list</a>.</p> <p>The keywords are returned as a map from argument names as unquoted strings (not including <code>$</code>) to the values of those arguments.</p> <div class="code-example ui-tabs can-split" style="--split-location: 71.36363636363636%"> <div id="example-mixin-arbitrary-kwargs-scss" class="ui-tabs-panel scss sl-c-code-panel"><pre class="language-scss" data-language="scss">@use "sass:meta";

@mixin syntax-colors($args...) {
  @debug meta.keywords($args);
  // (string: #080, comment: #800, variable: #60b)

  @each $name, $color in meta.keywords($args) {
    pre span.stx-#{$name} {
      color: $color;
    }
  }
}

@include syntax-colors(
  $string: #080,
  $comment: #800,
  $variable: #60b,
)</pre></div> <div id="example-mixin-arbitrary-kwargs-sass" class="ui-tabs-panel sass ui-tabs-panel-inactive sl-c-code-panel"><pre class="language-sass" data-language="sass">// SASS
@use "sass:meta"

@mixin syntax-colors($args...)
  @debug meta.keywords($args)
  // (string: #080, comment: #800, variable: #60b)

  @each $name, $color in meta.keywords($args)
    pre span.stx-#{$name}
      color: $color




@include syntax-colors($string: #080, $comment: #800, $variable: #60b)</pre></div> <div id="example-mixin-arbitrary-kwargs-css" class="ui-tabs-panel css ui-tabs-panel-inactive sl-c-code-panel"><pre class="language-css" data-language="css">/* CSS */
pre span.stx-string {
  color: #080;
}

pre span.stx-comment {
  color: #800;
}

pre span.stx-variable {
  color: #60b;
}</pre></div> </div> </div> <div class="sl-c-callout sl-c-callout--function">
<pre class="signature language-scss" id="meta.mixin-exists" data-language="scss">meta.mixin-exists($name, $module: null)
mixin-exists($name, $module: null) //=&gt; boolean</pre> <p>Returns whether a <a href="../at-rules/mixin.html">mixin</a> named <code>$name</code> exists.</p> <p>If <code>$module</code> is <code>null</code>, this returns whether a mixin named <code>$name</code> without a namespace exists. Otherwise, <code>$module</code> must be a string matching the namespace of a <a href="../at-rules/use.html"><code>@use</code> rule</a> in the current file, in which case this returns whether that module has a mixin named <code>$name</code>.</p> <div class="code-example ui-tabs"> <div id="example-mixin-exists-scss" class="ui-tabs-panel scss sl-c-code-panel"><pre class="language-scss" data-language="scss">@use "sass:meta";

@debug meta.mixin-exists("shadow-none"); // false

@mixin shadow-none {
  box-shadow: none;
}

@debug meta.mixin-exists("shadow-none"); // true</pre></div> <div id="example-mixin-exists-sass" class="ui-tabs-panel sass ui-tabs-panel-inactive sl-c-code-panel"><pre class="language-sass" data-language="sass">// SASS
@use "sass:meta"

@debug meta.mixin-exists("shadow-none")  // false

@mixin shadow-none
  box-shadow: none


@debug meta.mixin-exists("shadow-none")  // true</pre></div> </div> </div> <div class="sl-c-callout sl-c-callout--function">
<pre class="signature language-scss" id="meta.module-functions" data-language="scss">meta.module-functions($module) //=&gt; map</pre> <dl class="impl-status sl-c-description-list sl-c-description-list--horizontal"> <div class="compatibility"> Compatibility: </div>
<div> <dt>Dart Sass</dt> <dd>since 1.23.0</dd> </div>
<div> <dt>LibSass</dt> <dd>✗</dd> </div>
<div> <dt>Ruby Sass</dt> <dd>✗</dd> </div>
<div><a href="javascript:;.html">➤</a></div>
</dl>
<div class="sl-c-callout sl-c-callout--impl-status"> <p>Only Dart Sass currently supports this function.</p> </div> <p>Returns all the functions defined in a module, as a map from function names to <a href="../values/functions.html">function values</a>.</p> <p>The <code>$module</code> parameter must be a string matching the namespace of a <a href="../at-rules/use.html"><code>@use</code> rule</a> in the current file.</p> <div class="code-example ui-tabs"> <div id="example-module-functions-scss" class="ui-tabs-panel scss sl-c-code-panel">
<pre class="language-scss" data-language="scss">// _functions.scss
@function pow($base, $exponent) {
  $result: 1;
  @for $_ from 1 through $exponent {
    $result: $result * $base;
  }
  @return $result;
}</pre>
<pre class="language-scss" data-language="scss">@use "sass:map";
@use "sass:meta";

@use "functions";

@debug meta.module-functions("functions"); // ("pow": get-function("pow"))

@debug meta.call(map.get(meta.module-functions("functions"), "pow"), 3, 4); // 81</pre>
</div> <div id="example-module-functions-sass" class="ui-tabs-panel sass ui-tabs-panel-inactive sl-c-code-panel">
<pre class="language-sass" data-language="sass">// SASS
// _functions.sass
@function pow($base, $exponent)
  $result: 1
  @for $_ from 1 through $exponent
    $result: $result * $base

  @return $result</pre>
<pre class="language-sass" data-language="sass">// SASS
@use "sass:map"
@use "sass:meta"

@use "functions"

@debug meta.module-functions("functions") // ("pow": get-function("pow"))

@debug meta.call(map.get(meta.module-functions("functions"), "pow"), 3, 4) // 81</pre>
</div> </div> </div> <div class="sl-c-callout sl-c-callout--function">
<pre class="signature language-scss" id="meta.module-mixins" data-language="scss">meta.module-mixins($module) //=&gt; map</pre> <dl class="impl-status sl-c-description-list sl-c-description-list--horizontal"> <div class="compatibility"> Compatibility: </div>
<div> <dt>Dart Sass</dt> <dd>since 1.69.0</dd> </div>
<div> <dt>LibSass</dt> <dd>✗</dd> </div>
<div> <dt>Ruby Sass</dt> <dd>✗</dd> </div>
</dl> <p>Returns all the mixins defined in a module, as a map from mixin names to <a href="../values/mixins.html">mixin values</a>.</p> <p>The <code>$module</code> parameter must be a string matching the namespace of a <a href="../at-rules/use.html"><code>@use</code> rule</a> in the current file.</p> <div class="code-example ui-tabs can-split" style="--split-location: 74.0909090909091%"> <div id="example-module-mixins-scss" class="ui-tabs-panel scss sl-c-code-panel">
<pre class="language-scss" data-language="scss">// _mixins.scss
@mixin stretch() {
  align-items: stretch;
  display: flex;
  flex-direction: row;
}</pre>
<pre class="language-scss" data-language="scss">@use "sass:map";
@use "sass:meta";

@use "mixins";

@debug meta.module-mixins("mixins"); // =&gt; ("stretch": get-mixin("stretch"))

.header {
  @include meta.apply(map.get(meta.module-mixins("mixins"), "stretch"));
}</pre>
</div> <div id="example-module-mixins-sass" class="ui-tabs-panel sass ui-tabs-panel-inactive sl-c-code-panel">
<pre class="language-sass" data-language="sass">// SASS
// _mixins.scss
@mixin stretch()
  align-items: stretch
  display: flex
  flex-direction: row</pre>
<pre class="language-sass" data-language="sass">// SASS
@use "sass:map"
@use "sass:meta"

@use "mixins"

@debug meta.module-mixins("mixins") // =&gt; ("stretch": get-mixin("stretch"))

.header
  @include meta.apply(map.get(meta.module-mixins("mixins"), "stretch"))</pre>
</div> <div id="example-module-mixins-css" class="ui-tabs-panel css ui-tabs-panel-inactive sl-c-code-panel"><pre class="language-css" data-language="css">/* CSS */
.header {
  align-items: stretch;
  display: flex;
  flex-direction: row;
}</pre></div> </div> </div> <div class="sl-c-callout sl-c-callout--function">
<pre class="signature language-scss" id="meta.module-variables" data-language="scss">meta.module-variables($module) //=&gt; map</pre> <dl class="impl-status sl-c-description-list sl-c-description-list--horizontal"> <div class="compatibility"> Compatibility: </div>
<div> <dt>Dart Sass</dt> <dd>since 1.23.0</dd> </div>
<div> <dt>LibSass</dt> <dd>✗</dd> </div>
<div> <dt>Ruby Sass</dt> <dd>✗</dd> </div>
<div><a href="javascript:;.html">➤</a></div>
</dl>
<div class="sl-c-callout sl-c-callout--impl-status"> <p>Only Dart Sass currently supports this function.</p> </div> <p>Returns all the variables defined in a module, as a map from variable names (without <code>$</code>) to the values of those variables.</p> <p>The <code>$module</code> parameter must be a string matching the namespace of a <a href="../at-rules/use.html"><code>@use</code> rule</a> in the current file.</p> <div class="code-example ui-tabs"> <div id="example-module-variables-scss" class="ui-tabs-panel scss sl-c-code-panel">
<pre class="language-scss" data-language="scss">// _variables.scss
$hopbush: #c69;
$midnight-blue: #036;
$wafer: #e1d7d2;</pre>
<pre class="language-scss" data-language="scss">@use "sass:meta";

@use "variables";

@debug meta.module-variables("variables");
// (
//   "hopbush": #c69,
//   "midnight-blue": #036,
//   "wafer": #e1d7d2
// )</pre>
</div> <div id="example-module-variables-sass" class="ui-tabs-panel sass ui-tabs-panel-inactive sl-c-code-panel">
<pre class="language-sass" data-language="sass">// SASS
// _variables.sass
$hopbush: #c69
$midnight-blue: #036
$wafer: #e1d7d2</pre>
<pre class="language-sass" data-language="sass">// SASS
@use "sass:meta"

@use "variables"

@debug meta.module-variables("variables")
// (
//   "hopbush": #c69,
//   "midnight-blue": #036,
//   "wafer": #e1d7d2
// )</pre>
</div> </div> </div> <div class="sl-c-callout sl-c-callout--function">
<pre class="signature language-scss" id="meta.type-of" data-language="scss">meta.type-of($value)
type-of($value) //=&gt; unquoted string</pre> <p>Returns the type of <code>$value</code>.</p> <p>This can return the following values:</p> <ul> <li><a href="../values/numbers.html"><code>number</code></a></li> <li><a href="../values/strings.html"><code>string</code></a></li> <li><a href="../values/colors.html"><code>color</code></a></li> <li><a href="../values/lists.html"><code>list</code></a></li> <li><a href="../values/maps.html"><code>map</code></a></li> <li><a href="../values/calculations.html"><code>calculation</code></a></li> <li><a href="../values/booleans.html"><code>bool</code></a></li> <li><a href="../values/null.html"><code>null</code></a></li> <li><a href="../values/functions.html"><code>function</code></a></li> <li><a href="../values/lists.html#argument-lists"><code>arglist</code></a></li> </ul> <p>New possible values may be added in the future. It may return either <code>list</code> or <code>map</code> for <code>()</code>, depending on whether or not it was returned by a <a href="map.html">map function</a>.</p> <div class="code-example ui-tabs"> <div id="example-type-of-scss" class="ui-tabs-panel scss sl-c-code-panel"><pre class="language-scss" data-language="scss">@use 'sass:meta';

@debug meta.type-of(10px); // number
@debug meta.type-of(10px 20px 30px); // list
@debug meta.type-of(()); // list</pre></div> <div id="example-type-of-sass" class="ui-tabs-panel sass ui-tabs-panel-inactive sl-c-code-panel"><pre class="language-sass" data-language="sass">// SASS
@use 'sass:meta'

@debug meta.type-of(10px)  // number
@debug meta.type-of(10px 20px 30px)  // list
@debug meta.type-of(())  // list</pre></div> </div> </div> <div class="sl-c-callout sl-c-callout--function">
<pre class="signature language-scss" id="meta.variable-exists" data-language="scss">meta.variable-exists($name)
variable-exists($name) //=&gt; boolean</pre> <p>Returns whether a variable named <code>$name</code> (without the <code>$</code>) exists in the current <a href="../variables.html#scope">scope</a>.</p> <p>See also <a href="#global-variable-exists"><code>meta.global-variable-exists()</code></a>.</p> <div class="code-example ui-tabs"> <div id="example-variable-exists-scss" class="ui-tabs-panel scss sl-c-code-panel"><pre class="language-scss" data-language="scss">@use "sass:meta";

@debug meta.variable-exists("var1"); // false

$var1: value;
@debug meta.variable-exists("var1"); // true

h1 {
  // $var2 is local.
  $var2: value;
  @debug meta.variable-exists("var2"); // true
}</pre></div> <div id="example-variable-exists-sass" class="ui-tabs-panel sass ui-tabs-panel-inactive sl-c-code-panel"><pre class="language-sass" data-language="sass">// SASS
@use "sass:meta"

@debug meta.variable-exists("var1")  // false

$var1: value
@debug meta.variable-exists("var1")  // true

h1
  // $var2 is local.
  $var2: value
  @debug meta.variable-exists("var2")  // true</pre></div> </div> </div> </div> </div> </div> </div> </div> </div> </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2006&ndash;2025 the Sass team, and numerous contributors<br>Licensed under the MIT License.<br>
    <a href="https://sass-lang.com/documentation/modules/meta" class="_attribution-link">https://sass-lang.com/documentation/modules/meta</a>
  </p>
</div>
