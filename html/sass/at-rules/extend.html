<h1 class="sl-l-container">@extend</h1> <div class="sl-l-container sl-color--white-background sl-l-section"> <div class="sl-l-medium-holy-grail"> <div class="sl-l-medium-holy-grail__body">  <div class="sl-l-medium-holy-grail__main"> <div class="sl-l-large-holy-grail"> <div class="sl-l-large-holy-grail__body"> <div class="sl-l-large-holy-grail__complementary sl-l-large-holy-grail__complementary--contents"> <nav aria-labelledby="page-sections" class="page-sections sl-c-list-navigation-wrapper sl-c-list-navigation-wrapper--collapsible"> <h3 id="page-sections">Page Sections</h3> <ul>
<li> <a href="#how-it-works" class="open">How It Works</a>
</li>
<li> <a href="#placeholder-selectors" class="section open">Placeholder Selectors</a><ul>
<li class="overview"> <a href="#placeholder-selectors">Overview</a> </li>
<li> <a href="#private-placeholders" class="open">Private Placeholders</a>
</li>
</ul> </li>
<li> <a href="#extension-scope" class="open">Extension Scope</a>
</li>
<li> <a href="#mandatory-and-optional-extends" class="open">Mandatory and Optional Extends</a>
</li>
<li> <a href="#extends-or-mixins" class="open">Extends or Mixins?</a>
</li>
<li> <a href="#limitations" class="section open">Limitations</a><ul>
<li class="overview"> <a href="#limitations">Overview</a> </li>
<li> <a href="#disallowed-selectors" class="open">Disallowed Selectors</a>
</li>
<li> <a href="#html-heuristics" class="open"><span class="caps">HTML</span> Heuristics</a>
</li>
<li> <a href="#extend-in-media" class="open">Extend in <code>@media</code></a>
</li>
</ul> </li>
</ul> </nav> </div> <div class="sl-l-large-holy-grail__main docSearch-content"> <div class="sl-l-container sl-l-container--small"> <div class="sl-c-introduction"> <p>There are often cases when designing a page when one class should have all the styles of another class, as well as its own specific styles. For example, the <a href="http://getbem.com/naming/"><span class="caps">BEM</span> methodology</a> encourages modifier classes that go on the same elements as block or element classes. But this can create cluttered <span class="caps">HTML</span>, itâ€™s prone to errors from forgetting to include both classes, and it can bring non-semantic style concerns into your markup.</p> </div>  <pre class="language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>error error--serious<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
  Oh no! You've been hacked!
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span></code></pre> <pre class="language-css" data-language="css">/* CSS */
.error {
  border: 1px #f00;
  background-color: #fdd;
}

.error--serious {
  border-width: 3px;
}</pre> <p>Sassâ€™s <code>@extend</code> rule solves this. Itâ€™s written <code>@extend &lt;selector&gt;</code>, and it tells Sass that one selector should inherit the styles of another.</p> <div class="code-example ui-tabs can-split" style="--split-location: 50%"> <div id="example-extend-scss" class="ui-tabs-panel scss sl-c-code-panel"><pre class="language-scss" data-language="scss">.error {
  border: 1px #f00;
  background-color: #fdd;

  &amp;--serious {
    @extend .error;
    border-width: 3px;
  }
}</pre></div> <div id="example-extend-sass" class="ui-tabs-panel sass ui-tabs-panel-inactive sl-c-code-panel"><pre class="language-sass" data-language="sass">// SASS
.error
  border: 1px #f00
  background-color: #fdd

  &amp;--serious
    @extend .error
    border-width: 3px</pre></div> <div id="example-extend-css" class="ui-tabs-panel css ui-tabs-panel-inactive sl-c-code-panel"><pre class="language-css" data-language="css">/* CSS */
.error, .error--serious {
  border: 1px #f00;
  background-color: #fdd;
}
.error--serious {
  border-width: 3px;
}</pre></div> </div> <p>When one class extends another, Sass styles all elements that match the extender as though they also match the class being extended. When one class selector extends another, it works exactly as though you added the extended class to every element in your <span class="caps">HTML</span> that already had the extending class. You can just write <code>class="error--serious"</code>, and Sass will make sure itâ€™s styled as though it had <code>class="error"</code> as well.</p> <p>Of course, selectors arenâ€™t just used on their own in style rules. Sass knows to extend <em>everywhere</em> the selector is used. This ensures that your elements are styled exactly as if they matched the extended selector.</p> <div class="code-example ui-tabs can-split" style="--split-location: 50%"> <div id="example-extended-selector-scss" class="ui-tabs-panel scss sl-c-code-panel"><pre class="language-scss" data-language="scss">.error:hover {
  background-color: #fee;
}

.error--serious {
  @extend .error;
  border-width: 3px;
}</pre></div> <div id="example-extended-selector-sass" class="ui-tabs-panel sass ui-tabs-panel-inactive sl-c-code-panel"><pre class="language-sass" data-language="sass">// SASS
.error:hover
  background-color: #fee


.error--serious
  @extend .error
  border-width: 3px</pre></div> <div id="example-extended-selector-css" class="ui-tabs-panel css ui-tabs-panel-inactive sl-c-code-panel"><pre class="language-css" data-language="css">/* CSS */
.error:hover, .error--serious:hover {
  background-color: #fee;
}

.error--serious {
  border-width: 3px;
}</pre></div> </div> <div class="sl-c-callout sl-c-callout--warning">  <p>Extends are resolved after the rest of your stylesheet is compiled. In particular, it happens after <a href="../style-rules/parent-selector.html">parent selectors</a> are resolved. This means that if you <code>@extend .error</code>, it wonâ€™t affect the inner selector in <code>.error { &amp;__icon { ... } }</code>. It also means that <a href="../style-rules/parent-selector.html#in-sassscript">parent selectors in SassScript</a> canâ€™t see the results of extend.</p> </div> <h2 id="how-it-works" tabindex="-1">How It Works
</h2> <p>Unlike <a href="mixin.html">mixins</a>, which copy styles into the current style rule, <code>@extend</code> updates style rules that contain the extended selector so that they contain the extending selector as well. When extending selectors, Sass does <em>intelligent unification</em>:</p> <ul> <li> <p>It never generates selectors like <code>#main#footer</code> that canâ€™t possibly match any elements.</p> </li> <li> <p>It ensures that complex selectors are interleaved so that they work no matter which order the <span class="caps">HTML</span> elements are nested.</p> </li> <li> <p>It trims redundant selectors as much as possible, while still ensuring that the specificity is greater than or equal to that of the extender.</p> </li> <li> <p>It knows when one selector matches everything another does, and can combine them together.</p> </li> <li> <p>It intelligently handles <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors#Combinators">combinators</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Universal_selectors">universal selectors</a>, and <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:not">pseudo-classes that contain selectors</a>.</p> </li> </ul> <div class="code-example ui-tabs"> <div id="example-how-it-works-scss" class="ui-tabs-panel scss sl-c-code-panel"><pre class="language-scss" data-language="scss">.content nav.sidebar {
  @extend .info;
}

// This won't be extended, because `p` is incompatible with `nav`.
p.info {
  background-color: #dee9fc;
}

// There's no way to know whether `&lt;div class="guide"&gt;` will be inside or
// outside `&lt;div class="content"&gt;`, so Sass generates both to be safe.
.guide .info {
  border: 1px solid rgba(#000, 0.8);
  border-radius: 2px;
}

// Sass knows that every element matching "main.content" also matches ".content"
// and avoids generating unnecessary interleaved selectors.
main.content .info {
  font-size: 0.8em;
}</pre></div> <div id="example-how-it-works-sass" class="ui-tabs-panel sass ui-tabs-panel-inactive sl-c-code-panel"><pre class="language-sass" data-language="sass">// SASS
.content nav.sidebar
  @extend .info


// This won't be extended, because `p` is incompatible with `nav`.
p.info
  background-color: #dee9fc


// There's no way to know whether `&lt;div class="guide"&gt;` will be inside or
// outside `&lt;div class="content"&gt;`, so Sass generates both to be safe.
.guide .info
  border: 1px solid rgba(#000, 0.8)
  border-radius: 2px


// Sass knows that every element matching "main.content" also matches ".content"
// and avoids generating unnecessary interleaved selectors.
main.content .info
  font-size: 0.8em</pre></div> <div id="example-how-it-works-css" class="ui-tabs-panel css ui-tabs-panel-inactive sl-c-code-panel"><pre class="language-css" data-language="css">/* CSS */
p.info {
  background-color: #dee9fc;
}

.guide .info, .guide .content nav.sidebar, .content .guide nav.sidebar {
  border: 1px solid rgba(0, 0, 0, 0.8);
  border-radius: 2px;
}

main.content .info, main.content nav.sidebar {
  font-size: 0.8em;
}</pre></div> </div> <div class="sl-c-callout sl-c-callout--fun-fact"> <h3>ðŸ’¡ Fun fact:</h3> <p>You can directly access Sassâ€™s intelligent unification using <a href="../modules/selector.html">selector functions</a>! The <a href="../modules/selector.html#unify"><code>selector.unify()</code> function</a> returns a selector that matches the intersection of two selectors, while the <a href="../modules/selector.html#extend"><code>selector.extend()</code> function</a> works just like <code>@extend</code>, but on a single selector.</p> </div> <div class="sl-c-callout sl-c-callout--warning">  <p>Because <code>@extend</code> updates style rules that contain the extended selector, their styles have precedence in <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Cascade">the cascade</a> based on where the extended selectorâ€™s style rules appear, <em>not</em> based on where the <code>@extend</code> appears. This can be confusing, but just remember: this is the same precedence those rules would have if you added the extended class to your <span class="caps">HTML</span>!</p> </div> <h2 id="placeholder-selectors" tabindex="-1">Placeholder Selectors
</h2> <p>Sometimes you want to write a style rule thatâ€™s <em>only</em> intended to be extended. In that case, you can use <a href="../style-rules/placeholder-selectors.html">placeholder selectors</a>, which look like class selectors that start with <code>%</code> instead of <code>.</code>. Any selectors that include placeholders arenâ€™t included in the <span class="caps">CSS</span> output, but selectors that extend them are.</p> <div class="code-example ui-tabs can-split" style="--split-location: 50%"> <div id="example-placeholder-scss" class="ui-tabs-panel scss sl-c-code-panel"><pre class="language-scss" data-language="scss">.alert:hover, %strong-alert {
  font-weight: bold;
}

%strong-alert:hover {
  color: red;
}</pre></div> <div id="example-placeholder-sass" class="ui-tabs-panel sass ui-tabs-panel-inactive sl-c-code-panel"><pre class="language-sass" data-language="sass">// SASS
.alert:hover, %strong-alert
  font-weight: bold


%strong-alert:hover
  color: red</pre></div> <div id="example-placeholder-css" class="ui-tabs-panel css ui-tabs-panel-inactive sl-c-code-panel"><pre class="language-css" data-language="css">/* CSS */
.alert:hover {
  font-weight: bold;
}</pre></div> </div> <h3 id="private-placeholders" tabindex="-1">Private Placeholders
</h3> <p>Like <a href="use.html#private-members">module members</a>, a placeholder selector can be marked private by starting its name with either <code>-</code> or <code>_</code>. A private placeholder selector can only be extended within the stylesheet that defines it. To any other stylesheets, it will look as though that selector doesnâ€™t exist.</p> <h2 id="extension-scope" tabindex="-1">Extension Scope
</h2> <p>When one stylesheet extends a selector, that extension will only affect style rules written in <em>upstream</em> modulesâ€”that is, modules that are loaded by that stylesheet using the <a href="use.html"><code>@use</code> rule</a> or the <a href="forward.html"><code>@forward</code> rule</a>, modules loaded by <em>those</em> modules, and so on. This helps make your <code>@extend</code> rules more predictable, ensuring that they affect only the styles you were aware of when you wrote them.</p> <div class="sl-c-callout sl-c-callout--warning">  <p>Extensions arenâ€™t scoped at all if youâ€™re using the <a href="import.html"><code>@import</code> rule</a>. Not only will they affect every stylesheet you import, theyâ€™ll affect every stylesheet that imports your stylesheet, everything else those stylesheets import, and so on. Without <code>@use</code>, extensions are <em>global</em>.</p> </div> <h2 id="mandatory-and-optional-extends" tabindex="-1">Mandatory and Optional Extends
</h2> <p>Normally, if an <code>@extend</code> doesnâ€™t match any selectors in the stylesheet, Sass will produce an error. This helps protect from typos or from renaming a selector without renaming the selectors that inherit from it. Extends that require that the extended selector exists are <em>mandatory</em>.</p> <p>This may not always be what you want, though. If you want the <code>@extend</code> to do nothing if the extended selector doesnâ€™t exist, just add <code>!optional</code> to the end.</p> <h2 id="extends-or-mixins" tabindex="-1">Extends or Mixins?
</h2> <p>Extends and <a href="mixin.html">mixins</a> are both ways of encapsulating and re-using styles in Sass, which naturally raises the question of when to use which one. Mixins are obviously necessary when you need to configure the styles using <a href="mixin.html#arguments">arguments</a>, but what if theyâ€™re just a chunk of styles?</p> <p>As a rule of thumb, extends are the best option when youâ€™re expressing a relationship between semantic classes (or other semantic selectors). Because an element with class <code>.error--serious</code> <em>is an</em> error, it makes sense for it to extend <code>.error</code>. But for non-semantic collections of styles, writing a mixin can avoid cascade headaches and make it easier to configure down the line.</p> <div class="sl-c-callout sl-c-callout--fun-fact"> <h3>ðŸ’¡ Fun fact:</h3> <p>Most web servers compress the <span class="caps">CSS</span> they serve using an algorithm thatâ€™s very good at handling repeated chunks of identical text. This means that, although mixins may produce more <span class="caps">CSS</span> than extends, they probably wonâ€™t substantially increase the amount your users need to download. So choose the feature that makes the most sense for your use-case, not the one that generates the least <span class="caps">CSS</span>!</p> </div> <h2 id="limitations" tabindex="-1">Limitations
</h2> <h3 id="disallowed-selectors" tabindex="-1">Disallowed Selectors
</h3> <dl class="impl-status sl-c-description-list sl-c-description-list--horizontal"> <div class="compatibility"> Compatibility (No Compound Extensions): </div>
<div> <dt>Dart Sass</dt> <dd>âœ“</dd> </div>
<div> <dt>LibSass</dt> <dd>âœ—</dd> </div>
<div> <dt>Ruby Sass</dt> <dd>âœ—</dd> </div>
<div><a href="javascript:;.html">âž¤</a></div>
</dl>
<div class="sl-c-callout sl-c-callout--impl-status"> <p>LibSass and Ruby Sass currently allow compound selectors like <code>.message.info</code> to be extended. However, this behavior doesnâ€™t match the definition of <code>@extend</code>: instead of styling elements that match the extending selector as though it had <code>class="message info"</code>, which would be affected by style rules that included either <code>.message</code> <em>or</em> <code>.info</code>, it only styled them with rules that included both <code>.message</code> <em>and</em> <code>info</code>.</p> <p>In order to keep the definition of <code>@extend</code> straightforward and understandable, and to keep the implementation clean and efficient, that behavior is now deprecated and will be removed from future versions.</p> <p>See <a href="https://sass-lang.com/documentation/breaking-changes/extend-compound">the breaking change page</a> for more details.</p> </div> <p>Only <em>simple selectors</em>â€”individual selectors like <code>.info</code> or <code>a</code>â€”can be extended. If <code>.message.info</code> could be extended, the definition of <code>@extend</code> says that elements matching the extender would be styled as though they matched <code>.message.info</code>. Thatâ€™s just the same as matching both <code>.message</code> and <code>.info</code>, so there wouldnâ€™t be any benefit in writing that instead of <code>@extend .message, .info</code>.</p> <p>Similarly, if <code>.main .info</code> could be extended, it would do (almost) the same thing as extending <code>.info</code> on its own. The subtle differences arenâ€™t worth the confusion of looking like itâ€™s doing something substantially different, so this isnâ€™t allowed either.</p> <div class="code-example ui-tabs"> <div id="example-disallowed-selectors-scss" class="ui-tabs-panel scss sl-c-code-panel"><pre class="language-scss" data-language="scss">.alert {
  @extend .message.info;
  //      ^^^^^^^^^^^^^
  // Error: Write @extend .message, .info instead.

  @extend .main .info;
  //      ^^^^^^^^^^^
  // Error: write @extend .info instead.
}</pre></div> <div id="example-disallowed-selectors-sass" class="ui-tabs-panel sass ui-tabs-panel-inactive sl-c-code-panel"><pre class="language-sass" data-language="sass">// SASS
.alert
  @extend .message.info
  //      ^^^^^^^^^^^^^
  // Error: Write @extend .message, .info instead.

  @extend .main .info
  //      ^^^^^^^^^^^
  // Error: write @extend .info instead.</pre></div> </div> <h3 id="html-heuristics" tabindex="-1">
<span class="caps">HTML</span> Heuristics
</h3> <p>When <code>@extend</code> <a href="#how-it-works">interleaves complex selectors</a>, it doesnâ€™t generate all possible combinations of ancestor selectors. Many of the selectors it could generate are unlikely to actually match real <span class="caps">HTML</span>, and generating them all would make stylesheets way too big for very little real value. Instead, it uses a <a href="https://en.wikipedia.org/wiki/Heuristic">heuristic</a>: it assumes that each selectorâ€™s ancestors will be self-contained, without being interleaved with any other selectorâ€™s ancestors.</p> <div class="code-example ui-tabs"> <div id="example-html-heuristics-scss" class="ui-tabs-panel scss sl-c-code-panel"><pre class="language-scss" data-language="scss">header .warning li {
  font-weight: bold;
}

aside .notice dd {
  // Sass doesn't generate CSS to match the &lt;dd&gt; in
  //
  // &lt;header&gt;
  //   &lt;aside&gt;
  //     &lt;div class="warning"&gt;
  //       &lt;div class="notice"&gt;
  //         &lt;dd&gt;...&lt;/dd&gt;
  //       &lt;/div&gt;
  //     &lt;/div&gt;
  //   &lt;/aside&gt;
  // &lt;/header&gt;
  //
  // because matching all elements like that would require us to generate nine
  // new selectors instead of just two.
  @extend li;
}</pre></div> <div id="example-html-heuristics-sass" class="ui-tabs-panel sass ui-tabs-panel-inactive sl-c-code-panel"><pre class="language-sass" data-language="sass">// SASS
header .warning li
  font-weight: bold


aside .notice dd
  // Sass doesn't generate CSS to match the &lt;dd&gt; in
  //
  // &lt;header&gt;
  //   &lt;aside&gt;
  //     &lt;div class="warning"&gt;
  //       &lt;div class="notice"&gt;
  //         &lt;dd&gt;...&lt;/dd&gt;
  //       &lt;/div&gt;
  //     &lt;/div&gt;
  //   &lt;/aside&gt;
  // &lt;/header&gt;
  //
  // because matching all elements like that would require us to generate nine
  // new selectors instead of just two.
  @extend li</pre></div> <div id="example-html-heuristics-css" class="ui-tabs-panel css ui-tabs-panel-inactive sl-c-code-panel"><pre class="language-css" data-language="css">/* CSS */
header .warning li, header .warning aside .notice dd, aside .notice header .warning dd {
  font-weight: bold;
}</pre></div> </div> <h3 id="extend-in-media" tabindex="-1">Extend in <code>@media</code>
</h3> <p>While <code>@extend</code> is allowed within <a href="css.html"><code>@media</code> and other <span class="caps">CSS</span> at-rules</a>, itâ€™s not allowed to extend selectors that appear outside its at-rule. This is because the extending selector only applies within the given media context, and thereâ€™s no way to make sure that restriction is preserved in the generated selector without duplicating the entire style rule.</p> <div class="code-example ui-tabs"> <div id="example-extend-media-scss" class="ui-tabs-panel scss sl-c-code-panel"><pre class="language-scss" data-language="scss">@media screen and (max-width: 600px) {
  .error--serious {
    @extend .error;
    //      ^^^^^^
    // Error: ".error" was extended in @media, but used outside it.
  }
}

.error {
  border: 1px #f00;
  background-color: #fdd;
}</pre></div> <div id="example-extend-media-sass" class="ui-tabs-panel sass ui-tabs-panel-inactive sl-c-code-panel"><pre class="language-sass" data-language="sass">// SASS
@media screen and (max-width: 600px)
  .error--serious
    @extend .error
    //      ^^^^^^
    // Error: ".error" was extended in @media, but used outside it.



.error
  border: 1px #f00
  background-color: #fdd</pre></div> </div> </div> </div> </div> </div> </div> </div> </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2006&ndash;2025 the Sass team, and numerous contributors<br>Licensed under the MIT License.<br>
    <a href="https://sass-lang.com/documentation/at-rules/extend" class="_attribution-link">https://sass-lang.com/documentation/at-rules/extend</a>
  </p>
</div>
