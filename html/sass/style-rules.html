<h1 class="sl-l-container">Style Rules</h1> <div class="sl-l-container sl-color--white-background sl-l-section"> <div class="sl-l-medium-holy-grail"> <div class="sl-l-medium-holy-grail__body">  <div class="sl-l-medium-holy-grail__main"> <div class="sl-l-large-holy-grail"> <div class="sl-l-large-holy-grail__body"> <div class="sl-l-large-holy-grail__complementary sl-l-large-holy-grail__complementary--contents"> <nav aria-labelledby="page-sections" class="page-sections sl-c-list-navigation-wrapper sl-c-list-navigation-wrapper--collapsible"> <h3 id="page-sections">Page Sections</h3> <ul>
<li> <a href="#nesting" class="section open">Nesting</a><ul>
<li class="overview"> <a href="#nesting">Overview</a> </li>
<li> <a href="#selector-lists" class="open">Selector Lists</a>
</li>
<li> <a href="#selector-combinators" class="open">Selector Combinators</a>
</li>
<li> <a href="#advanced-nesting" class="open">Advanced Nesting</a>
</li>
</ul> </li>
<li> <a href="#interpolation" class="open">Interpolation</a>
</li>
</ul> </nav> </div> <div class="sl-l-large-holy-grail__main docSearch-content"> <div class="sl-l-container sl-l-container--small"> <div class="sl-c-introduction"> <p>Style rules are the foundation of Sass, just like they are for <span class="caps">CSS</span>. And they work the same way: you choose which elements to style with a selector, and <a href="style-rules/declarations.html">declare properties</a> that affect how those elements look.</p> </div> <div class="code-example ui-tabs can-split" style="--split-location: 50%"> <div id="example-style-rules-scss" class="ui-tabs-panel scss sl-c-code-panel"><pre class="language-scss" data-language="scss">.button {
  padding: 3px 10px;
  font-size: 12px;
  border-radius: 3px;
  border: 1px solid #e1e4e8;
}</pre></div> <div id="example-style-rules-sass" class="ui-tabs-panel sass ui-tabs-panel-inactive sl-c-code-panel"><pre class="language-sass" data-language="sass">// SASS
.button
  padding: 3px 10px
  font-size: 12px
  border-radius: 3px
  border: 1px solid #e1e4e8</pre></div> <div id="example-style-rules-css" class="ui-tabs-panel css ui-tabs-panel-inactive sl-c-code-panel"><pre class="language-css" data-language="css">/* CSS */
.button {
  padding: 3px 10px;
  font-size: 12px;
  border-radius: 3px;
  border: 1px solid #e1e4e8;
}</pre></div> </div> <h2 id="nesting" tabindex="-1">Nesting
</h2> <p>But Sass wants to make your life easier. Rather than repeating the same selectors over and over again, you can write one style rules inside another. Sass will automatically combine the outer ruleâ€™s selector with the inner ruleâ€™s.</p> <div class="code-example ui-tabs can-split" style="--split-location: 50%"> <div id="example-nesting-scss" class="ui-tabs-panel scss sl-c-code-panel"><pre class="language-scss" data-language="scss">nav {
  ul {
    margin: 0;
    padding: 0;
    list-style: none;
  }

  li { display: inline-block; }

  a {
    display: block;
    padding: 6px 12px;
    text-decoration: none;
  }
}</pre></div> <div id="example-nesting-sass" class="ui-tabs-panel sass ui-tabs-panel-inactive sl-c-code-panel"><pre class="language-sass" data-language="sass">// SASS
nav
  ul
    margin: 0
    padding: 0
    list-style: none

  li
    display: inline-block

  a
    display: block
    padding: 6px 12px
    text-decoration: none</pre></div> <div id="example-nesting-css" class="ui-tabs-panel css ui-tabs-panel-inactive sl-c-code-panel"><pre class="language-css" data-language="css">/* CSS */
nav ul {
  margin: 0;
  padding: 0;
  list-style: none;
}
nav li {
  display: inline-block;
}
nav a {
  display: block;
  padding: 6px 12px;
  text-decoration: none;
}</pre></div> </div> <div class="sl-c-callout sl-c-callout--warning">  <p>Nested rules are super helpful, but they can also make it hard to visualize how much <span class="caps">CSS</span> youâ€™re actually generating. The deeper you nest, the more bandwidth it takes to serve your <span class="caps">CSS</span> and the more work it takes the browser to render it. Keep those selectors shallow!</p> </div> <h3 id="selector-lists" tabindex="-1">Selector Lists
</h3> <p>Nested rules are clever about handling selector lists (that is, comma-separated selectors). Each complex selector (the ones between the commas) is nested separately, and then theyâ€™re combined back into a selector list.</p> <div class="code-example ui-tabs can-split" style="--split-location: 50%"> <div id="example-selector-lists-scss" class="ui-tabs-panel scss sl-c-code-panel"><pre class="language-scss" data-language="scss">.alert, .warning {
  ul, p {
    margin-right: 0;
    margin-left: 0;
    padding-bottom: 0;
  }
}</pre></div> <div id="example-selector-lists-sass" class="ui-tabs-panel sass ui-tabs-panel-inactive sl-c-code-panel"><pre class="language-sass" data-language="sass">// SASS
.alert, .warning
  ul, p
    margin-right: 0
    margin-left: 0
    padding-bottom: 0</pre></div> <div id="example-selector-lists-css" class="ui-tabs-panel css ui-tabs-panel-inactive sl-c-code-panel"><pre class="language-css" data-language="css">/* CSS */
.alert ul, .alert p, .warning ul, .warning p {
  margin-right: 0;
  margin-left: 0;
  padding-bottom: 0;
}</pre></div> </div> <h3 id="selector-combinators" tabindex="-1">Selector Combinators
</h3> <p>You can nest selectors that use <a href="#">combinators</a> as well. You can put the combinator at the end of the outer selector, at the beginning of the inner selector, or even all on its own in between the two.</p> <div class="code-example ui-tabs can-split" style="--split-location: 50%"> <div id="example-selector-combinators-scss" class="ui-tabs-panel scss sl-c-code-panel"><pre class="language-scss" data-language="scss">ul &gt; {
  li {
    list-style-type: none;
  }
}

h2 {
  + p {
    border-top: 1px solid gray;
  }
}

p {
  ~ {
    span {
      opacity: 0.8;
    }
  }
}</pre></div> <div id="example-selector-combinators-sass" class="ui-tabs-panel sass ui-tabs-panel-inactive sl-c-code-panel"><pre class="language-sass" data-language="sass">// SASS
ul &gt;
  li
    list-style-type: none



h2
  + p
    border-top: 1px solid gray



p
  ~
    span
      opacity: 0.8</pre></div> <div id="example-selector-combinators-css" class="ui-tabs-panel css ui-tabs-panel-inactive sl-c-code-panel"><pre class="language-css" data-language="css">/* CSS */
ul &gt; li {
  list-style-type: none;
}

h2 + p {
  border-top: 1px solid gray;
}

p ~ span {
  opacity: 0.8;
}</pre></div> </div> <h3 id="advanced-nesting" tabindex="-1">Advanced Nesting
</h3> <p>If you want to do more with your nested style rules than just combine them in order with the descendant combinator (that is, a plain space) separating them, Sass has your back. See the <a href="style-rules/parent-selector.html">parent selector documentation</a> for more details.</p> <h2 id="interpolation" tabindex="-1">Interpolation
</h2> <p>You can use <a href="interpolation.html">interpolation</a> to inject values from <a href="syntax/structure.html#expressions">expressions</a> like variables and function calls into your selectors. This is particularly useful when youâ€™re writing <a href="at-rules/mixin.html">mixins</a>, since it allows you to create selectors from parameters your users pass in.</p> <div class="code-example ui-tabs can-split" style="--split-location: 50%"> <div id="example-interpolation-scss" class="ui-tabs-panel scss sl-c-code-panel"><pre class="language-scss" data-language="scss">@mixin define-emoji($name, $glyph) {
  span.emoji-#{$name} {
    font-family: IconFont;
    font-variant: normal;
    font-weight: normal;
    content: $glyph;
  }
}

@include define-emoji("women-holding-hands", "ðŸ‘­");</pre></div> <div id="example-interpolation-sass" class="ui-tabs-panel sass ui-tabs-panel-inactive sl-c-code-panel"><pre class="language-sass" data-language="sass">// SASS
@mixin define-emoji($name, $glyph)
  span.emoji-#{$name}
    font-family: IconFont
    font-variant: normal
    font-weight: normal
    content: $glyph



@include define-emoji("women-holding-hands", "ðŸ‘­")</pre></div> <div id="example-interpolation-css" class="ui-tabs-panel css ui-tabs-panel-inactive sl-c-code-panel"><pre class="language-css" data-language="css">/* CSS */
@charset "UTF-8";
span.emoji-women-holding-hands {
  font-family: IconFont;
  font-variant: normal;
  font-weight: normal;
  content: "ðŸ‘­";
}</pre></div> </div> <div class="sl-c-callout sl-c-callout--fun-fact"> <h3>ðŸ’¡ Fun fact:</h3> <p>Sass only parses selectors <em>after</em> interpolation is resolved. This means you can safely use interpolation to generate any part of the selector without worrying that it wonâ€™t parse.</p> </div> <p>You can combine interpolation with the parent selector <code>&amp;</code>, the <a href="at-rules/at-root.html"><code>@at-root</code> rule</a>, and <a href="modules/selector.html">selector functions</a> to wield some serious power when dynamically generating selectors. For more information, see the <a href="style-rules/parent-selector.html">parent selector documentation</a>.</p> </div> </div> </div> </div> </div> </div> </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2006&ndash;2025 the Sass team, and numerous contributors<br>Licensed under the MIT License.<br>
    <a href="https://sass-lang.com/documentation/style-rules" class="_attribution-link">https://sass-lang.com/documentation/style-rules</a>
  </p>
</div>
