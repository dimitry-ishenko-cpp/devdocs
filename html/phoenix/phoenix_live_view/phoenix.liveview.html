<h1>   <span translate="no">Phoenix.LiveView</span> <small>behaviour</small>  </h1> <section id="moduledoc"> <p>LiveView provides rich, real-time user experiences with server-rendered HTML.</p>
<p>The LiveView programming model is declarative: instead of saying "once event X happens, change Y on the page", events in LiveView are regular messages which may cause changes to its state. Once the state changes, LiveView will re-render the relevant parts of its HTML template and push it to the browser, which updates itself in the most efficient manner. This means developers write LiveView templates as any other server-rendered HTML and LiveView does the hard work of tracking changes and sending the relevant diffs to the browser.</p>
<p>At the end of the day, a LiveView is nothing more than a process that receives events as messages and updates its state. The state itself is nothing more than functional and immutable Elixir data structures. The events are either internal application messages (usually emitted by <a href="https://hexdocs.pm/phoenix_pubsub/2.0.0/Phoenix.PubSub.html"><code class="inline">Phoenix.PubSub</code></a>) or sent by the client/browser.</p>
<p>LiveView is first rendered statically as part of regular HTTP requests, which provides quick times for "First Meaningful Paint", in addition to helping search and indexing engines. Then a persistent connection is established between client and server. This allows LiveView applications to react faster to user events as there is less work to be done and less data to be sent compared to stateless requests that have to authenticate, decode, load, and encode data on every request. The flipside is that LiveView uses more memory on the server compared to stateless requests.</p>
<h2 id="module-life-cycle" class="section-heading">  Life-cycle </h2> <p>A LiveView begins as a regular HTTP request and HTML response, and then upgrades to a stateful view on client connect, guaranteeing a regular HTML page even if JavaScript is disabled. Any time a stateful view changes or updates its socket assigns, it is automatically re-rendered and the updates are pushed to the client.</p>
<p>You begin by rendering a LiveView typically from your router. When LiveView is first rendered, the <a href="#c:mount/3"><code class="inline">mount/3</code></a> callback is invoked with the current params, the current session and the LiveView socket. As in a regular request, <code class="inline">params</code> contains public data that can be modified by the user. The <code class="inline">session</code> always contains private data set by the application itself. The <a href="#c:mount/3"><code class="inline">mount/3</code></a> callback wires up socket assigns necessary for rendering the view. After mounting, <a href="#c:handle_params/3"><code class="inline">handle_params/3</code></a> is invoked so uri and query params are handled. Finally, <a href="#c:render/1"><code class="inline">render/1</code></a> is invoked and the HTML is sent as a regular HTML response to the client.</p>
<p>After rendering the static page, LiveView connects from the client to the server where stateful views are spawned to push rendered updates to the browser, and receive client events via <code class="inline">phx-</code> bindings. Just like the first rendering, <a href="#c:mount/3"><code class="inline">mount/3</code></a>, is invoked with params, session, and socket state, However in the connected client case, a LiveView process is spawned on the server, runs <a href="#c:handle_params/3"><code class="inline">handle_params/3</code></a> again and then pushes the result of <a href="#c:render/1"><code class="inline">render/1</code></a> to the client and continues on for the duration of the connection. If at any point during the stateful life-cycle a crash is encountered, or the client connection drops, the client gracefully reconnects to the server, calling <a href="#c:mount/3"><code class="inline">mount/3</code></a> and <a href="#c:handle_params/3"><code class="inline">handle_params/3</code></a> again.</p>
<p>LiveView also allows attaching hooks to specific life-cycle stages with <a href="#attach_hook/4"><code class="inline">attach_hook/4</code></a>.</p>
<h2 id="module-example" class="section-heading">  Example </h2> <p>Before writing your first example, make sure that Phoenix LiveView is properly installed. If you are just getting started, this can be easily done by running <code class="inline">mix phx.new my_app --live</code>. The <code class="inline">phx.new</code> command with the <code class="inline">--live</code> flag will create a new project with LiveView installed and configured. Otherwise, please follow the steps in the <a href="installation.html">installation guide</a> before continuing.</p>
<p>A LiveView is a simple module that requires two callbacks: <a href="#c:mount/3"><code class="inline">mount/3</code></a> and <a href="#c:render/1"><code class="inline">render/1</code></a>:</p>
<pre data-language="elixir">defmodule MyAppWeb.ThermostatLive do
  # In Phoenix v1.6+ apps, the line below should be: use MyAppWeb, :live_view
  use Phoenix.LiveView

  def render(assigns) do
    ~H"""
    Current temperature: &lt;%= @temperature %&gt;
    """
  end

  def mount(_params, %{"current_user_id" =&gt; user_id}, socket) do
    temperature = Thermostat.get_user_reading(user_id)
    {:ok, assign(socket, :temperature, temperature)}
  end
end</pre>
<p>The <a href="#c:render/1"><code class="inline">render/1</code></a> callback receives the <code class="inline">socket.assigns</code> and is responsible for returning rendered content. We use the <code class="inline">~H</code> sigil to define a HEEx template, which stands for HTML+EEx. They are an extension of Elixir's builtin EEx templates, with support for HTML validation, syntax-based components, smart change tracking, and more. You can learn more about the template syntax in <a href="phoenix.liveview.helpers.html#sigil_H/2"><code class="inline">Phoenix.LiveView.Helpers.sigil_H/2</code></a>.</p>
<p>Next, decide where you want to use your LiveView.</p>
<p>You can serve the LiveView directly from your router (recommended):</p>
<pre data-language="elixir">defmodule MyAppWeb.Router do
  use Phoenix.Router
  import Phoenix.LiveView.Router

  scope "/", MyAppWeb do
    live "/thermostat", ThermostatLive
  end
end</pre>
<p><em>Note:</em> the above assumes there is <code class="inline">plug :put_root_layout</code> call in your router that configures the LiveView layout. This call is automatically included in Phoenix v1.6 apps and described in the installation guide.</p>
<p>Alternatively, you can <code class="inline">live_render</code> from any template. In your view:</p>
<pre data-language="elixir">import Phoenix.LiveView.Helpers</pre>
<p>Then in your template:</p>
<pre data-language="elixir">&lt;h1&gt;Temperature Control&lt;/h1&gt;
&lt;%= live_render(@conn, MyAppWeb.ThermostatLive) %&gt;</pre>
<p>Once the LiveView is rendered, a regular HTML response is sent. In your app.js file, you should find the following:</p>
<pre data-language="elixir">import {Socket} from "phoenix"
import {LiveSocket} from "phoenix_live_view"

let csrfToken = document.querySelector("meta[name='csrf-token']").getAttribute("content")
let liveSocket = new LiveSocket("/live", Socket, {params: {_csrf_token: csrfToken}})
liveSocket.connect()</pre>
<p>After the client connects, <a href="#c:mount/3"><code class="inline">mount/3</code></a> will be invoked inside a spawned LiveView process. At this point, you can use <a href="#connected?/1"><code class="inline">connected?/1</code></a> to conditionally perform stateful work, such as subscribing to pubsub topics, sending messages, etc. For example, you can periodically update a LiveView with a timer:</p>
<pre data-language="elixir">defmodule DemoWeb.ThermostatLive do
  use Phoenix.LiveView
  ...

  def mount(_params, %{"current_user_id" =&gt; user_id}, socket) do
    if connected?(socket), do: Process.send_after(self(), :update, 30000)

    case Thermostat.get_user_reading(user_id) do
      {:ok, temperature} -&gt;
        {:ok, assign(socket, temperature: temperature, user_id: user_id)}

      {:error, _reason} -&gt;
        {:ok, redirect(socket, to: "/error")}
    end
  end

  def handle_info(:update, socket) do
    Process.send_after(self(), :update, 30000)
    {:ok, temperature} = Thermostat.get_reading(socket.assigns.user_id)
    {:noreply, assign(socket, :temperature, temperature)}
  end
end</pre>
<p>We used <code class="inline">connected?(socket)</code> on mount to send our view a message every 30s if the socket is in a connected state. We receive the <code class="inline">:update</code> message in the <a href="#c:handle_info/2"><code class="inline">handle_info/2</code></a> callback, just like in an Elixir <a href="https://hexdocs.pm/elixir/GenServer.html"><code class="inline">GenServer</code></a>, and update our socket assigns. Whenever a socket's assigns change, <a href="#c:render/1"><code class="inline">render/1</code></a> is automatically invoked, and the updates are sent to the client.</p>
<h2 id="module-colocating-templates" class="section-heading">  Colocating templates </h2> <p>In the examples above, we have placed the template directly inside the LiveView:</p>
<pre data-language="elixir">defmodule MyAppWeb.ThermostatLive do
  use Phoenix.LiveView

  def render(assigns) do
    ~H"""
    Current temperature: &lt;%= @temperature %&gt;
    """
  end</pre>
<p>For larger templates, you can place them in a file in the same directory and same name as the LiveView. For example, if the file above is placed at <code class="inline">lib/my_app_web/live/thermostat_live.ex</code>, you can also remove the <a href="#c:render/1"><code class="inline">render/1</code></a> definition above and instead put the template code at <code class="inline">lib/my_app_web/live/thermostat_live.html.heex</code>.</p>
<p>Alternatively, you can keep the <a href="#c:render/1"><code class="inline">render/1</code></a> callback but delegate to an existing <a href="https://hexdocs.pm/phoenix_view/1.1.2/Phoenix.View.html"><code class="inline">Phoenix.View</code></a> module in your application. For example:</p>
<pre data-language="elixir">defmodule MyAppWeb.ThermostatLive do
  use Phoenix.LiveView

  def render(assigns) do
    Phoenix.View.render(MyAppWeb.PageView, "page.html", assigns)
  end
end</pre>
<p>In all cases, each assign in the template will be accessible as <code class="inline">@assign</code>. You can learn more about <a href="assigns-eex.html">assigns and HEEx templates in their own guide</a>.</p>
<h2 id="module-bindings" class="section-heading">  Bindings </h2> <p>Phoenix supports DOM element bindings for client-server interaction. For example, to react to a click on a button, you would render the element:</p>
<pre data-language="elixir">&lt;button phx-click="inc_temperature"&gt;+&lt;/button&gt;</pre>
<p>Then on the server, all LiveView bindings are handled with the <a href="#c:handle_event/3"><code class="inline">handle_event/3</code></a> callback, for example:</p>
<pre data-language="elixir">def handle_event("inc_temperature", _value, socket) do
  {:ok, new_temp} = Thermostat.inc_temperature(socket.assigns.id)
  {:noreply, assign(socket, :temperature, new_temp)}
end</pre>
<p>To update UI state, for example, to open and close dropdowns, switch tabs, etc, LiveView also supports JS commands (<a href="phoenix.liveview.js.html"><code class="inline">Phoenix.LiveView.JS</code></a>), which execute directly on the client without reaching the server. To learn more, see <a href="bindings.html">our bindings page</a> for a complete list of all LiveView bindings as well as our <a href="https://hexdocs.pm/phoenix_live_view/js-interop.html">JavaScript interoperability guide</a>.</p>
<h2 id="module-compartmentalize-state-markup-and-events-in-liveview" class="section-heading">  Compartmentalize state, markup, and events in LiveView </h2> <p>LiveView supports two extension mechanisms: function components, provided by <code class="inline">HEEx</code> templates, and stateful components.</p>
<p>Function components are any function that receives an assigns map, similar to <code class="inline">render(assigns)</code> in our LiveView, and returns a <code class="inline">~H</code> template. For example:</p>
<pre data-language="elixir">def weather_greeting(assigns) do
  ~H"""
  &lt;div title="My div" class={@class}&gt;
    &lt;p&gt;Hello &lt;%= @name %&gt;&lt;/p&gt;
    &lt;MyApp.Weather.city name="Kraków"/&gt;
  &lt;/div&gt;
  """
end</pre>
<p>You can learn more about function components in the <a href="phoenix.component.html"><code class="inline">Phoenix.Component</code></a> module. At the end of the day, they are useful mechanism to reuse markup in your LiveViews.</p>
<p>However, sometimes you need to compartmentalize or reuse more than markup. Perhaps you want to move part of the state or part of the events in your LiveView to a separate module. For these cases, LiveView provides <a href="phoenix.livecomponent.html"><code class="inline">Phoenix.LiveComponent</code></a>, which are rendered using <a href="phoenix.liveview.helpers.html#live_component/1"><code class="inline">live_component/1</code></a>:</p>
<pre data-language="elixir">&lt;.live_component module={UserComponent} id={user.id} user={user} /&gt;</pre>
<p>Components have their own <a href="#c:mount/3"><code class="inline">mount/3</code></a> and <a href="#c:handle_event/3"><code class="inline">handle_event/3</code></a> callbacks, as well as their own state with change tracking support. Components are also lightweight as they "run" in the same process as the parent <code class="inline">LiveView</code>. However, this means an error in a component would cause the whole view to fail to render. See <a href="phoenix.livecomponent.html"><code class="inline">Phoenix.LiveComponent</code></a> for a complete rundown on components.</p>
<p>Finally, if you want complete isolation between parts of a LiveView, you can always render a LiveView inside another LiveView by calling <a href="phoenix.liveview.helpers.html#live_render/3"><code class="inline">live_render/3</code></a>. This child LiveView runs in a separate process than the parent, with its own callbacks. If a child LiveView crashes, it won't affect the parent. If the parent crashes, all children are terminated.</p>
<p>When rendering a child LiveView, the <code class="inline">:id</code> option is required to uniquely identify the child. A child LiveView will only ever be rendered and mounted a single time, provided its ID remains unchanged.</p>
<p>Given that a LiveView runs on its own process, it is an excellent tool for creating completely isolated UI elements, but it is a slightly expensive abstraction if all you want is to compartmentalize markup or events (or both).</p>
<p>To sum it up:</p>
<ul>
<li>use <a href="phoenix.component.html"><code class="inline">Phoenix.Component</code></a> to compartmentalize/reuse markup</li>
<li>use <a href="phoenix.livecomponent.html"><code class="inline">Phoenix.LiveComponent</code></a> to compartmentalize state, markup, and events</li>
<li>use nested <a href="phoenix.liveview.html#content"><code class="inline">Phoenix.LiveView</code></a> to compartmentalize state, markup, events, and error isolation</li>
</ul>
<h2 id="module-endpoint-configuration" class="section-heading">  Endpoint configuration </h2> <p>LiveView accepts the following configuration in your endpoint under the <code class="inline">:live_view</code> key:</p>
<ul>
<li><p><code class="inline">:signing_salt</code> (required) - the salt used to sign data sent to the client</p></li>
<li><p><code class="inline">:hibernate_after</code> (optional) - the idle time in milliseconds allowed in the LiveView before compressing its own memory and state. Defaults to 15000ms (15 seconds)</p></li>
</ul>
<h2 id="module-guides" class="section-heading">  Guides </h2> <p>LiveView has many guides to help you on your journey.</p>
<h3 id="module-server-side" class="section-heading">  Server-side </h3> <p>These guides focus on server-side functionality:</p>
<ul>
<li><a href="assigns-eex.html">Assigns and HEEx templates</a></li>
<li><a href="error-handling.html">Error and exception handling</a></li>
<li><a href="live-layouts.html">Live Layouts</a></li>
<li><a href="live-navigation.html">Live Navigation</a></li>
<li><a href="security-model.html">Security considerations of the LiveView model</a></li>
<li><a href="telemetry.html">Telemetry</a></li>
<li><a href="uploads.html">Uploads</a></li>
<li><a href="using-gettext.html">Using Gettext for internationalization</a></li>
</ul>
<h3 id="module-client-side" class="section-heading">  Client-side </h3> <p>These guides focus on LiveView bindings and client-side integration:</p>
<ul>
<li><a href="bindings.html">Bindings</a></li>
<li><a href="form-bindings.html">Form bindings</a></li>
<li><a href="dom-patching.html">DOM patching and temporary assigns</a></li>
<li><a href="https://hexdocs.pm/phoenix_live_view/js-interop.html">JavaScript interoperability</a></li>
<li><a href="uploads-external.html">Uploads (External)</a></li>
</ul> </section> <section id="summary" class="details-list"> <h1 class="section-heading">  Summary </h1> <h2> Types </h2>
<dl class="summary-types summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#t:unsigned_params/0" translate="no">unsigned_params()</a> </dt> </div> </dl> <h2> Callbacks </h2>
<dl class="summary-callbacks summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#c:handle_call/3" translate="no">handle_call(msg, {}, socket)</a> </dt> <dd class="summary-synopsis"><p>Invoked to handle calls from other Elixir processes.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:handle_cast/2" translate="no">handle_cast(msg, socket)</a> </dt> <dd class="summary-synopsis"><p>Invoked to handle casts from other Elixir processes.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:handle_event/3" translate="no">handle_event(event, unsigned_params, socket)</a> </dt> <dd class="summary-synopsis"><p>Invoked to handle events sent by the client.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:handle_info/2" translate="no">handle_info(msg, socket)</a> </dt> <dd class="summary-synopsis"><p>Invoked to handle messages from other Elixir processes.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:handle_params/3" translate="no">handle_params(unsigned_params, uri, socket)</a> </dt> <dd class="summary-synopsis"><p>Invoked after mount and whenever there is a live patch event.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:mount/3" translate="no">mount( params, session, socket )</a> </dt> <dd class="summary-synopsis"><p>The LiveView entry-point.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:render/1" translate="no">render(assigns)</a> </dt> <dd class="summary-synopsis"><p>Renders a template.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:terminate/2" translate="no">terminate(reason, socket)</a> </dt> <dd class="summary-synopsis"><p>Invoked when the LiveView is terminating.</p></dd> </div> </dl> <h2> Functions </h2>
<dl class="summary-functions summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#__using__/1" translate="no">__using__(opts)</a> </dt> <dd class="summary-synopsis"><p>Uses LiveView in the current module to mark it a LiveView.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#allow_upload/3" translate="no">allow_upload(socket, name, options)</a> </dt> <dd class="summary-synopsis"><p>Allows an upload for the provided name.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#assign/2" translate="no">assign(socket_or_assigns, keyword_or_map)</a> </dt> <dd class="summary-synopsis"><p>Adds key-value pairs to assigns.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#assign/3" translate="no">assign(socket_or_assigns, key, value)</a> </dt> <dd class="summary-synopsis"><p>Adds a <code class="inline">key</code>-<code class="inline">value</code> pair to <code class="inline">socket_or_assigns</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#assign_new/3" translate="no">assign_new(socket_or_assigns, key, fun)</a> </dt> <dd class="summary-synopsis"><p>Assigns the given <code class="inline">key</code> with value from <code class="inline">fun</code> into <code class="inline">socket_or_assigns</code> if one does not yet exist.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#attach_hook/4" translate="no">attach_hook(socket, name, stage, fun)</a> </dt> <dd class="summary-synopsis"><p>Attaches the given <code class="inline">fun</code> by <code class="inline">name</code> for the lifecycle <code class="inline">stage</code> into <code class="inline">socket</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#cancel_upload/3" translate="no">cancel_upload(socket, name, entry_ref)</a> </dt> <dd class="summary-synopsis"><p>Cancels an upload for the given entry.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#changed?/2" translate="no">changed?(socket_or_assigns, key)</a> </dt> <dd class="summary-synopsis"><p>Checks if the given key changed in <code class="inline">socket_or_assigns</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#clear_flash/1" translate="no">clear_flash(socket)</a> </dt> <dd class="summary-synopsis"><p>Clears the flash.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#clear_flash/2" translate="no">clear_flash(socket, key)</a> </dt> <dd class="summary-synopsis"><p>Clears a key from the flash.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#connected?/1" translate="no">connected?(socket)</a> </dt> <dd class="summary-synopsis"><p>Returns true if the socket is connected.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#consume_uploaded_entries/3" translate="no">consume_uploaded_entries(socket, name, func)</a> </dt> <dd class="summary-synopsis"><p>Consumes the uploaded entries.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#consume_uploaded_entry/3" translate="no">consume_uploaded_entry(socket, entry, func)</a> </dt> <dd class="summary-synopsis"><p>Consumes an individual uploaded entry.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#detach_hook/3" translate="no">detach_hook(socket, name, stage)</a> </dt> <dd class="summary-synopsis"><p>Detaches a hook with the given <code class="inline">name</code> from the lifecycle <code class="inline">stage</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#disallow_upload/2" translate="no">disallow_upload(socket, name)</a> </dt> <dd class="summary-synopsis"><p>Revokes a previously allowed upload from <a href="#allow_upload/3"><code class="inline">allow_upload/3</code></a>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#get_connect_info/1" translate="no">get_connect_info(socket)</a> <span class="deprecated" title="use get_connect_info/2 instead">deprecated</span> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#get_connect_info/2" translate="no">get_connect_info(socket, key)</a> </dt> <dd class="summary-synopsis"><p>Accesses a given connect info key from the socket.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#get_connect_params/1" translate="no">get_connect_params(socket)</a> </dt> <dd class="summary-synopsis"><p>Accesses the connect params sent by the client for use on connected mount.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#on_mount/1" translate="no">on_mount(mod_or_mod_arg)</a> </dt> <dd class="summary-synopsis"><p>Declares a module callback to be invoked on the LiveView's mount.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#push_event/3" translate="no">push_event(socket, event, payload)</a> </dt> <dd class="summary-synopsis"><p>Pushes an event to the client.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#push_patch/2" translate="no">push_patch(socket, opts)</a> </dt> <dd class="summary-synopsis"><p>Annotates the socket for navigation within the current LiveView.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#push_redirect/2" translate="no">push_redirect(socket, opts)</a> </dt> <dd class="summary-synopsis"><p>Annotates the socket for navigation to another LiveView.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#put_flash/3" translate="no">put_flash(socket, kind, msg)</a> </dt> <dd class="summary-synopsis"><p>Adds a flash message to the socket to be displayed.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#redirect/2" translate="no">redirect(socket, arg2)</a> </dt> <dd class="summary-synopsis"><p>Annotates the socket for redirect to a destination path.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#send_update/3" translate="no">send_update(pid \\ self(), module, assigns)</a> </dt> <dd class="summary-synopsis"><p>Asynchronously updates a <a href="phoenix.livecomponent.html"><code class="inline">Phoenix.LiveComponent</code></a> with new assigns.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#send_update_after/4" translate="no">send_update_after(pid \\ self(), module, assigns, time_in_milliseconds)</a> </dt> <dd class="summary-synopsis"><p>Similar to <a href="#send_update/3"><code class="inline">send_update/3</code></a> but the update will be delayed according to the given <code class="inline">time_in_milliseconds</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#static_changed?/1" translate="no">static_changed?(socket)</a> </dt> <dd class="summary-synopsis"><p>Returns true if the socket is connected and the tracked static assets have changed.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#transport_pid/1" translate="no">transport_pid(socket)</a> </dt> <dd class="summary-synopsis"><p>Returns the transport pid of the socket.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#update/3" translate="no">update(socket_or_assigns, key, fun)</a> </dt> <dd class="summary-synopsis"><p>Updates an existing <code class="inline">key</code> with <code class="inline">fun</code> in the given <code class="inline">socket_or_assigns</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#uploaded_entries/2" translate="no">uploaded_entries(socket, name)</a> </dt> <dd class="summary-synopsis"><p>Returns the completed and in progress entries for the upload.</p></dd> </div> </dl> </section> <section id="types" class="details-list"> <h1 class="section-heading">  Types </h1> <div class="types-list"> <section class="detail"> <h3 class="detail-header" id="t:unsigned_params/0">unsigned_params()<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view.ex#L327" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type unsigned_params() :: map()</pre> </div> </section> </section> </div> </section> <section id="callbacks" class="details-list"> <h1 class="section-heading">  Callbacks </h1> <div class="callbacks-list"> <section class="detail"> <h3 class="detail-header" id="c:handle_call/3">handle_call(msg, {}, socket)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view.ex#L422" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback handle_call(
  msg :: term(),
  {pid(), reference()},
  socket :: Phoenix.LiveView.Socket.t()
) ::
  {:noreply, Phoenix.LiveView.Socket.t()}
  | {:reply, term(), Phoenix.LiveView.Socket.t()}</pre> </div> <p>Invoked to handle calls from other Elixir processes.</p>
<p>See <a href="https://hexdocs.pm/elixir/GenServer.html#call/3"><code class="inline">GenServer.call/3</code></a> and <a href="https://hexdocs.pm/elixir/GenServer.html#c:handle_call/3"><code class="inline">GenServer.handle_call/3</code></a> for more information.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:handle_cast/2">handle_cast(msg, socket)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view.ex#L433" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback handle_cast(msg :: term(), socket :: Phoenix.LiveView.Socket.t()) ::
  {:noreply, Phoenix.LiveView.Socket.t()}</pre> </div> <p>Invoked to handle casts from other Elixir processes.</p>
<p>See <a href="https://hexdocs.pm/elixir/GenServer.html#cast/2"><code class="inline">GenServer.cast/2</code></a> and <a href="https://hexdocs.pm/elixir/GenServer.html#c:handle_cast/2"><code class="inline">GenServer.handle_cast/2</code></a> for more information. It must always return <code class="inline">{:noreply, socket}</code>, where <code class="inline">:noreply</code> means no additional information is sent to the process which cast the message.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:handle_event/3">handle_event(event, unsigned_params, socket)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view.ex#L413" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback handle_event(
  event :: binary(),
  unsigned_params(),
  socket :: Phoenix.LiveView.Socket.t()
) ::
  {:noreply, Phoenix.LiveView.Socket.t()}
  | {:reply, map(), Phoenix.LiveView.Socket.t()}</pre> </div> <p>Invoked to handle events sent by the client.</p>
<p>It receives the <code class="inline">event</code> name, the event payload as a map, and the socket.</p>
<p>It must return <code class="inline">{:noreply, socket}</code>, where <code class="inline">:noreply</code> means no additional information is sent to the client, or <code class="inline">{:reply, map(), socket}</code>, where the given <code class="inline">map()</code> is encoded and sent as a reply to the client.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:handle_info/2">handle_info(msg, socket)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view.ex#L444" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback handle_info(msg :: term(), socket :: Phoenix.LiveView.Socket.t()) ::
  {:noreply, Phoenix.LiveView.Socket.t()}</pre> </div> <p>Invoked to handle messages from other Elixir processes.</p>
<p>See <a href="https://hexdocs.pm/elixir/Kernel.html#send/2"><code class="inline">Kernel.send/2</code></a> and <a href="https://hexdocs.pm/elixir/GenServer.html#c:handle_info/2"><code class="inline">GenServer.handle_info/2</code></a> for more information. It must always return <code class="inline">{:noreply, socket}</code>, where <code class="inline">:noreply</code> means no additional information is sent to the process which sent the message.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:handle_params/3">handle_params(unsigned_params, uri, socket)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view.ex#L399" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback handle_params(
  unsigned_params(),
  uri :: String.t(),
  socket :: Phoenix.LiveView.Socket.t()
) ::
  {:noreply, Phoenix.LiveView.Socket.t()}</pre> </div> <p>Invoked after mount and whenever there is a live patch event.</p>
<p>It receives the current <code class="inline">params</code>, including parameters from the router, the current <code class="inline">uri</code> from the client and the <code class="inline">socket</code>. It is invoked after mount or whenever there is a live navigation event caused by <a href="#push_patch/2"><code class="inline">push_patch/2</code></a> or <a href="phoenix.liveview.helpers.html#live_patch/2"><code class="inline">Phoenix.LiveView.Helpers.live_patch/2</code></a>.</p>
<p>It must always return <code class="inline">{:noreply, socket}</code>, where <code class="inline">:noreply</code> means no additional information is sent to the client.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:mount/3">mount( params, session, socket )<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view.ex#L359" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback mount(
  params :: unsigned_params() | :not_mounted_at_router,
  session :: map(),
  socket :: Phoenix.LiveView.Socket.t()
) ::
  {:ok, Phoenix.LiveView.Socket.t()}
  | {:ok, Phoenix.LiveView.Socket.t(), keyword()}</pre> </div> <p>The LiveView entry-point.</p>
<p>For each LiveView in the root of a template, <a href="#c:mount/3"><code class="inline">mount/3</code></a> is invoked twice: once to do the initial page load and again to establish the live socket.</p>
<p>It expects three arguments:</p>
<ul>
<li>
<code class="inline">params</code> - a map of string keys which contain public information that can be set by the user. The map contains the query params as well as any router path parameter. If the LiveView was not mounted at the router, this argument is the atom <code class="inline">:not_mounted_at_router</code>
</li>
<li>
<code class="inline">session</code> - the connection session</li>
<li>
<code class="inline">socket</code> - the LiveView socket</li>
</ul>
<p>It must return either <code class="inline">{:ok, socket}</code> or <code class="inline">{:ok, socket, options}</code>, where <code class="inline">options</code> is one of:</p>
<ul>
<li><p><code class="inline">:temporary_assigns</code> - a keyword list of assigns that are temporary and must be reset to their value after every render. Note that once the value is reset, it won't be re-rendered again until it is explicitly assigned</p></li>
<li><p><code class="inline">:layout</code> - the optional layout to be used by the LiveView</p></li>
</ul> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:render/1">render(assigns)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view.ex#L377" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback render(assigns :: Phoenix.LiveView.Socket.assigns()) ::
  Phoenix.LiveView.Rendered.t()</pre> </div> <p>Renders a template.</p>
<p>This callback is invoked whenever LiveView detects new content must be rendered and sent to the client.</p>
<p>If you define this function, it must return a template defined via the <a href="phoenix.liveview.helpers.html#sigil_H/2"><code class="inline">Phoenix.LiveView.Helpers.sigil_H/2</code></a>.</p>
<p>If you don't define this function, LiveView will attempt to render a template in the same directory as your LiveView. For example, if you have a LiveView named <code class="inline">MyApp.MyCustomView</code> inside <code class="inline">lib/my_app/live_views/my_custom_view.ex</code>, Phoenix will look for a template at <code class="inline">lib/my_app/live_views/my_custom_view.html.heex</code>.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:terminate/2">terminate(reason, socket)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view.ex#L385" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback terminate(reason, socket :: Phoenix.LiveView.Socket.t()) :: term()
when reason: :normal | :shutdown | {:shutdown, :left | :closed | term()}</pre> </div> <p>Invoked when the LiveView is terminating.</p>
<p>In case of errors, this callback is only invoked if the LiveView is trapping exits. See <a href="https://hexdocs.pm/elixir/GenServer.html#c:terminate/2"><code class="inline">GenServer.terminate/2</code></a> for more info.</p> </section> </section> </div> </section> <section id="functions" class="details-list"> <h1 class="section-heading">  Functions </h1> <div class="functions-list"> <section class="detail"> <h3 class="detail-header" id="__using__/1">__using__(opts)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view.ex#L470" class="source">Source</a>
</h3> <section class="docstring"> <p>Uses LiveView in the current module to mark it a LiveView.</p>
<pre data-language="elixir">use Phoenix.LiveView,
  namespace: MyAppWeb,
  container: {:tr, class: "colorized"},
  layout: {MyAppWeb.LayoutView, "live.html"}</pre>
<h4 id="__using__/1-options" class="section-heading">  Options </h4> <ul>
<li>
<code class="inline">:namespace</code> - configures the namespace the <code class="inline">LiveView</code> is in</li>
<li>
<code class="inline">:container</code> - configures the container the <code class="inline">LiveView</code> will be wrapped in</li>
<li>
<code class="inline">:layout</code> - configures the layout the <code class="inline">LiveView</code> will be rendered in</li>
</ul> </section> </section> <section class="detail"> <h3 class="detail-header" id="allow_upload/3">allow_upload(socket, name, options)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view.ex#L1120" class="source">Source</a>
</h3> <section class="docstring"> <p>Allows an upload for the provided name.</p>
<h4 id="allow_upload/3-options" class="section-heading">  Options </h4> <ul>
<li><p><code class="inline">:accept</code> - Required. A list of unique file type specifiers or the atom :any to allow any kind of file. For example, <code class="inline">[".jpeg"]</code>, <code class="inline">:any</code>, etc.</p></li>
<li><p><code class="inline">:max_entries</code> - The maximum number of selected files to allow per file input. Defaults to 1.</p></li>
<li><p><code class="inline">:max_file_size</code> - The maximum file size in bytes to allow to be uploaded. Defaults 8MB. For example, <code class="inline">12_000_000</code>.</p></li>
<li><p><code class="inline">:chunk_size</code> - The chunk size in bytes to send when uploading. Defaults <code class="inline">64_000</code>.</p></li>
<li><p><code class="inline">:chunk_timeout</code> - The time in milliseconds to wait before closing the upload channel when a new chunk has not been received. Defaults <code class="inline">10_000</code>.</p></li>
<li><p><code class="inline">:external</code> - The 2-arity function for generating metadata for external client uploaders. See the Uploads section for example usage.</p></li>
<li><p><code class="inline">:progress</code> - The optional 3-arity function for receiving progress events</p></li>
<li><p><code class="inline">:auto_upload</code> - Instructs the client to upload the file automatically on file selection instead of waiting for form submits. Default false.</p></li>
</ul>
<p>Raises when a previously allowed upload under the same name is still active.</p>
<h4 id="allow_upload/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">allow_upload(socket, :avatar, accept: ~w(.jpg .jpeg), max_entries: 2)
allow_upload(socket, :avatar, accept: :any)</pre>
<p>For consuming files automatically as they are uploaded, you can pair <code class="inline">auto_upload: true</code> with a custom progress function to consume the entries as they are completed. For example:</p>
<pre data-language="elixir">allow_upload(socket, :avatar, accept: :any, progress: &amp;handle_progress/3, auto_upload: true)

defp handle_progress(:avatar, entry, socket) do
  if entry.done? do
    uploaded_file =
      consume_uploaded_entry(socket, entry, fn %{} = meta -&gt;
        {:ok, ...}
      end)

    {:noreply, put_flash(socket, :info, "file #{uploaded_file.name} uploaded")}
  else
    {:noreply, socket}
  end
end</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="assign/2">assign(socket_or_assigns, keyword_or_map)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view.ex#L894" class="source">Source</a>
</h3> <section class="docstring"> <p>Adds key-value pairs to assigns.</p>
<p>The first argument is either a LiveView <code class="inline">socket</code> or an <code class="inline">assigns</code> map from function components.</p>
<p>A keyword list or a map of assigns must be given as argument to be merged into existing assigns.</p>
<h4 id="assign/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; assign(socket, name: "Elixir", logo: "💧")
iex&gt; assign(socket, %{name: "Elixir"})</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="assign/3">assign(socket_or_assigns, key, value)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view.ex#L858" class="source">Source</a>
</h3> <section class="docstring"> <p>Adds a <code class="inline">key</code>-<code class="inline">value</code> pair to <code class="inline">socket_or_assigns</code>.</p>
<p>The first argument is either a LiveView <code class="inline">socket</code> or an <code class="inline">assigns</code> map from function components.</p>
<h4 id="assign/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; assign(socket, :name, "Elixir")</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="assign_new/3">assign_new(socket_or_assigns, key, fun)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view.ex#L751" class="source">Source</a>
</h3> <section class="docstring"> <p>Assigns the given <code class="inline">key</code> with value from <code class="inline">fun</code> into <code class="inline">socket_or_assigns</code> if one does not yet exist.</p>
<p>The first argument is either a LiveView <code class="inline">socket</code> or an <code class="inline">assigns</code> map from function components.</p>
<p>This function is useful for lazily assigning values and referencing parent assigns. We will cover both use cases next.</p>
<h4 id="assign_new/3-lazy-assigns" class="section-heading">  Lazy assigns </h4> <p>Imagine you have a function component that accepts a color:</p>
<pre data-language="elixir">&lt;.my_component color="red" /&gt;</pre>
<p>The color is also optional, so you can skip it:</p>
<pre data-language="elixir">&lt;.my_component /&gt;</pre>
<p>In such cases, the implementation can use <code class="inline">assign_new</code> to lazily assign a color if none is given. Let's make it so it picks a random one when none is given:</p>
<pre data-language="elixir">def my_component(assigns) do
  assigns = assign_new(assigns, :color, fn -&gt; Enum.random(~w(red green blue)) end)

  ~H"""
  &lt;div class={"bg-#{@color}"}&gt;
    Example
  &lt;/div&gt;
  """
end</pre>
<h4 id="assign_new/3-referencing-parent-assigns" class="section-heading">  Referencing parent assigns </h4> <p>When a user first accesses an application using LiveView, the LiveView is first rendered in its disconnected state, as part of a regular HTML response. In some cases, there may be data that is shared by your Plug pipelines and your LiveView, such as the <code class="inline">:current_user</code> assign.</p>
<p>By using <code class="inline">assign_new</code> in the mount callback of your LiveView, you can instruct LiveView to re-use any assigns set in your Plug pipelines as part of <a href="https://hexdocs.pm/plug/1.13.3/Plug.Conn.html"><code class="inline">Plug.Conn</code></a>, avoiding sending additional queries to the database. Imagine you have a Plug that does:</p>
<pre data-language="elixir"># A plug
def authenticate(conn, _opts) do
  if user_id = get_session(conn, :user_id) do
    assign(conn, :current_user, Accounts.get_user!(user_id))
  else
    send_resp(conn, :forbidden)
  end
end</pre>
<p>You can re-use the <code class="inline">:current_user</code> assign in your LiveView during the initial render:</p>
<pre data-language="elixir">def mount(_params, %{"user_id" =&gt; user_id}, socket) do
  {:ok, assign_new(socket, :current_user, fn -&gt; Accounts.get_user!(user_id) end)}
end</pre>
<p>In such case <code class="inline">conn.assigns.current_user</code> will be used if present. If there is no such <code class="inline">:current_user</code> assign or the LiveView was mounted as part of the live navigation, where no Plug pipelines are invoked, then the anonymous function is invoked to execute the query instead.</p>
<p>LiveView is also able to share assigns via <code class="inline">assign_new</code> within nested LiveView. If the parent LiveView defines a <code class="inline">:current_user</code> assign and the child LiveView also uses <a href="#assign_new/3"><code class="inline">assign_new/3</code></a> to fetch the <code class="inline">:current_user</code> in its <code class="inline">mount/3</code> callback, as above, the assign will be fetched from the parent LiveView, once again avoiding additional database queries.</p>
<p>Note that <code class="inline">fun</code> also provides access to the previously assigned values:</p>
<pre data-language="elixir">assigns =
    assigns
    |&gt; assign_new(:foo, fn -&gt; "foo" end)
    |&gt; assign_new(:bar, fn %{foo: foo} -&gt; foo &lt;&gt; "bar" end)</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="attach_hook/4">attach_hook(socket, name, stage, fun)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view.ex#L1715" class="source">Source</a>
</h3> <section class="docstring"> <p>Attaches the given <code class="inline">fun</code> by <code class="inline">name</code> for the lifecycle <code class="inline">stage</code> into <code class="inline">socket</code>.</p>
<blockquote><p>Note: This function is for server-side lifecycle callbacks. For client-side hooks, see the <a href="https://hexdocs.pm/phoenix_live_view/js-interop.html#client-hooks">JS Interop guide</a>.</p></blockquote>
<p>Hooks provide a mechanism to tap into key stages of the LiveView lifecycle in order to bind/update assigns, intercept events, patches, and regular messages when necessary, and to inject common functionality. Hooks may be attached to any of the following lifecycle stages: <code class="inline">:mount</code> (via <a href="#on_mount/1"><code class="inline">on_mount/1</code></a>), <code class="inline">:handle_params</code>, <code class="inline">:handle_event</code>, and <code class="inline">:handle_info</code>.</p>
<h4 id="attach_hook/4-return-values" class="section-heading">  Return Values </h4> <p>Lifecycle hooks take place immediately before a given lifecycle callback is invoked on the LiveView. A hook may return <code class="inline">{:halt, socket}</code> to halt the reduction, otherwise it must return <code class="inline">{:cont, socket}</code> so the operation may continue until all hooks have been invoked for the current stage.</p>
<h4 id="attach_hook/4-halting-the-lifecycle" class="section-heading">  Halting the lifecycle </h4> <p>Note that halting from a hook <em>will halt the entire lifecycle stage</em>. This means that when a hook returns <code class="inline">{:halt, socket}</code> then the LiveView callback will <strong>not</strong> be invoked. This has some implications.</p>
<h3 id="attach_hook/4-implications-for-plugin-authors" class="section-heading">  Implications for plugin authors </h3> <p>When defining a plugin that matches on specific callbacks, you <strong>must</strong> define a catch-all clause, as your hook will be invoked even for events you may not be interested on.</p>
<h3 id="attach_hook/4-implications-for-end-users" class="section-heading">  Implications for end-users </h3> <p>Allowing a hook to halt the invocation of the callback means that you can attach hooks to intercept specific events before detaching themselves, while allowing other events to continue normally.</p>
<h4 id="attach_hook/4-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">def mount(_params, _session, socket) do
  socket =
    attach_hook(socket, :my_hook, :handle_event, fn
      "very-special-event", _params, socket -&gt;
        # Handle the very special event and then detach the hook
        {:halt, detach_hook(socket, :my_hook, :handle_event)}

      _event, _params, socket -&gt;
        {:cont, socket}
    end)

  {:ok, socket}
end</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="cancel_upload/3">cancel_upload(socket, name, entry_ref)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view.ex#L1145" class="source">Source</a>
</h3> <section class="docstring"> <p>Cancels an upload for the given entry.</p>
<h4 id="cancel_upload/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">&lt;%= for entry &lt;- @uploads.avatar.entries do %&gt;
  ...
  &lt;button phx-click="cancel-upload" phx-value-ref="&lt;%= entry.ref %&gt;"&gt;cancel&lt;/button&gt;
&lt;% end %&gt;

def handle_event("cancel-upload", %{"ref" =&gt; ref}, socket) do
  {:noreply, cancel_upload(socket, :avatar, ref)}
end</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="changed?/2">changed?(socket_or_assigns, key)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view.ex#L967" class="source">Source</a>
</h3> <section class="docstring"> <p>Checks if the given key changed in <code class="inline">socket_or_assigns</code>.</p>
<p>The first argument is either a LiveView <code class="inline">socket</code> or an <code class="inline">assigns</code> map from function components.</p>
<h4 id="changed?/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; changed?(socket, :count)</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="clear_flash/1">clear_flash(socket)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view.ex#L1014" class="source">Source</a>
</h3> <section class="docstring"> <p>Clears the flash.</p>
<h4 id="clear_flash/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; clear_flash(socket)</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="clear_flash/2">clear_flash(socket, key)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view.ex#L1023" class="source">Source</a>
</h3> <section class="docstring"> <p>Clears a key from the flash.</p>
<h4 id="clear_flash/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; clear_flash(socket, :info)</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="connected?/1">connected?(socket)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view.ex#L669" class="source">Source</a>
</h3> <section class="docstring"> <p>Returns true if the socket is connected.</p>
<p>Useful for checking the connectivity status when mounting the view. For example, on initial page render, the view is mounted statically, rendered, and the HTML is sent to the client. Once the client connects to the server, a LiveView is then spawned and mounted statefully within a process. Use <a href="#connected?/1"><code class="inline">connected?/1</code></a> to conditionally perform stateful work, such as subscribing to pubsub topics, sending messages, etc.</p>
<h4 id="connected?/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">defmodule DemoWeb.ClockLive do
  use Phoenix.LiveView
  ...
  def mount(_params, _session, socket) do
    if connected?(socket), do: :timer.send_interval(1000, self(), :tick)

    {:ok, assign(socket, date: :calendar.local_time())}
  end

  def handle_info(:tick, socket) do
    {:noreply, assign(socket, date: :calendar.local_time())}
  end
end</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="consume_uploaded_entries/3">consume_uploaded_entries(socket, name, func)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view.ex#L1188" class="source">Source</a>
</h3> <section class="docstring"> <p>Consumes the uploaded entries.</p>
<p>Raises when there are still entries in progress. Typically called when submitting a form to handle the uploaded entries alongside the form data. For form submissions, it is guaranteed that all entries have completed before the submit event is invoked. Once entries are consumed, they are removed from the upload.</p>
<p>The function passed to consume may return a tagged tuple of the form <code class="inline">{:ok, my_result}</code> to collect results about the consumed entries, or <code class="inline">{:postpone, my_result}</code> to collect results, but postpone the file consumption to be performed later.</p>
<h4 id="consume_uploaded_entries/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">def handle_event("save", _params, socket) do
  uploaded_files =
    consume_uploaded_entries(socket, :avatar, fn %{path: path}, _entry -&gt;
      dest = Path.join("priv/static/uploads", Path.basename(path))
      File.cp!(path, dest)
      {:ok, Routes.static_path(socket, "/uploads/#{Path.basename(dest)}")}
    end)
  {:noreply, update(socket, :uploaded_files, &amp;(&amp;1 ++ uploaded_files))}
end</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="consume_uploaded_entry/3">consume_uploaded_entry(socket, entry, func)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view.ex#L1225" class="source">Source</a>
</h3> <section class="docstring"> <p>Consumes an individual uploaded entry.</p>
<p>Raises when the entry is still in progress. Typically called when submitting a form to handle the uploaded entries alongside the form data. Once entries are consumed, they are removed from the upload.</p>
<p>This is a lower-level feature than <a href="#consume_uploaded_entries/3"><code class="inline">consume_uploaded_entries/3</code></a> and useful for scenarios where you want to consume entries as they are individually completed.</p>
<p>Like <a href="#consume_uploaded_entries/3"><code class="inline">consume_uploaded_entries/3</code></a>, the function passed to consume may return a tagged tuple of the form <code class="inline">{:ok, my_result}</code> to collect results about the consumed entries, or <code class="inline">{:postpone, my_result}</code> to collect results, but postpone the file consumption to be performed later.</p>
<h4 id="consume_uploaded_entry/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">def handle_event("save", _params, socket) do
  case uploaded_entries(socket, :avatar) do
    {[_|_] = entries, []} -&gt;
      uploaded_files = for entry &lt;- entries do
        consume_uploaded_entry(socket, entry, fn %{path: path} -&gt;
          dest = Path.join("priv/static/uploads", Path.basename(path))
          File.cp!(path, dest)
          {:ok, Routes.static_path(socket, "/uploads/#{Path.basename(dest)}")}
        end)
      end
      {:noreply, update(socket, :uploaded_files, &amp;(&amp;1 ++ uploaded_files))}

    _ -&gt;
      {:noreply, socket}
  end
end</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="detach_hook/3">detach_hook(socket, name, stage)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view.ex#L1732" class="source">Source</a>
</h3> <section class="docstring"> <p>Detaches a hook with the given <code class="inline">name</code> from the lifecycle <code class="inline">stage</code>.</p>
<blockquote><p>Note: This function is for server-side lifecycle callbacks. For client-side hooks, see the <a href="https://hexdocs.pm/phoenix_live_view/js-interop.html#client-hooks">JS Interop guide</a>.</p></blockquote>
<p>If no hook is found, this function is a no-op.</p>
<h4 id="detach_hook/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">def handle_event(_, socket) do
  {:noreply, detach_hook(socket, :hook_that_was_attached, :handle_event)}
end</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="disallow_upload/2">disallow_upload(socket, name)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view.ex#L1129" class="source">Source</a>
</h3> <section class="docstring"> <p>Revokes a previously allowed upload from <a href="#allow_upload/3"><code class="inline">allow_upload/3</code></a>.</p>
<h4 id="disallow_upload/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">disallow_upload(socket, :avatar)</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="get_connect_info/1">get_connect_info(socket)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view.ex#L1377" class="source">Source</a>
</h3> <div class="deprecated"> This function is deprecated. use get_connect_info/2 instead. </div>  </section> <section class="detail"> <h3 class="detail-header" id="get_connect_info/2">get_connect_info(socket, key)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view.ex#L1416" class="source">Source</a>
</h3> <section class="docstring"> <p>Accesses a given connect info key from the socket.</p>
<p>The following keys are supported: <code class="inline">:peer_data</code>, <code class="inline">:trace_context_headers</code>, <code class="inline">:x_headers</code>, <code class="inline">:uri</code>, and <code class="inline">:user_agent</code>.</p>
<p>The connect information is available only during mount. During disconnected render, all keys are available. On connected render, only the keys explicitly declared in your socket are available. See <a href="https://hexdocs.pm/phoenix/1.6.6/Phoenix.Endpoint.html#socket/3"><code class="inline">Phoenix.Endpoint.socket/3</code></a> for a complete description of the keys.</p>
<h4 id="get_connect_info/2-examples" class="section-heading">  Examples </h4> <p>The first step is to declare the <code class="inline">connect_info</code> you want to receive. Typically, it includes at least the session, but you must include all other keys you want to access on connected mount, such as <code class="inline">:peer_data</code>:</p>
<pre data-language="elixir">socket "/live", Phoenix.LiveView.Socket,
  websocket: [connect_info: [:peer_data, session: @session_options]]</pre>
<p>Those values can now be accessed on the connected mount as <a href="#get_connect_info/2"><code class="inline">get_connect_info/2</code></a>:</p>
<pre data-language="elixir">def mount(_params, _session, socket) do
  peer_data = get_connect_info(socket, :peer_data)
  {:ok, assign(socket, ip: peer_data.address)}
end</pre>
<p>If the key is not available, usually because it was not specified in <code class="inline">connect_info</code>, it returns nil.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="get_connect_params/1">get_connect_params(socket)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view.ex#L1368" class="source">Source</a>
</h3> <section class="docstring"> <p>Accesses the connect params sent by the client for use on connected mount.</p>
<p>Connect params are only sent when the client connects to the server and only remain available during mount. <code class="inline">nil</code> is returned when called in a disconnected state and a <a href="https://hexdocs.pm/elixir/RuntimeError.html"><code class="inline">RuntimeError</code></a> is raised if called after mount.</p>
<h4 id="get_connect_params/1-reserved-params" class="section-heading">  Reserved params </h4> <p>The following params have special meaning in LiveView:</p>
<ul>
<li>
<code class="inline">"_csrf_token"</code> - the CSRF Token which must be explicitly set by the user when connecting</li>
<li>
<code class="inline">"_mounts"</code> - the number of times the current LiveView is mounted. It is 0 on first mount, then increases on each reconnect. It resets when navigating away from the current LiveView or on errors</li>
<li>
<code class="inline">"_track_static"</code> - set automatically with a list of all href/src from tags with the <code class="inline">phx-track-static</code> annotation in them. If there are no such tags, nothing is sent</li>
</ul>
<h4 id="get_connect_params/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">def mount(_params, _session, socket) do
  {:ok, assign(socket, width: get_connect_params(socket)["width"] || @width)}
end</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="on_mount/1">on_mount(mod_or_mod_arg)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view.ex#L620" class="source">Source</a>
</h3> <section class="docstring"> <p>Declares a module callback to be invoked on the LiveView's mount.</p>
<p>The function within the given module, which must be named <code class="inline">on_mount</code>, will be invoked before both disconnected and connected mounts. The hook has the option to either halt or continue the mounting process as usual. If you wish to redirect the LiveView, you <strong>must</strong> halt, otherwise an error will be raised.</p>
<p>Tip: if you need to define multiple <code class="inline">on_mount</code> callbacks, avoid defining multiple modules. Instead, pass a tuple and use pattern matching to handle different cases:</p>
<pre data-language="elixir">def on_mount(:admin, _params, _session, socket) do
  {:cont, socket}
end

def on_mount(:user, _params, _session, socket) do
  {:cont, socket}
end</pre>
<p>And then invoke it as:</p>
<pre data-language="elixir">on_mount {MyAppWeb.SomeHook, :admin}
on_mount {MyAppWeb.SomeHook, :user}</pre>
<p>Registering <code class="inline">on_mount</code> hooks can be useful to perform authentication as well as add custom behaviour to other callbacks via <a href="#attach_hook/4"><code class="inline">attach_hook/4</code></a>.</p>
<h4 id="on_mount/1-examples" class="section-heading">  Examples </h4> <p>The following is an example of attaching a hook via <a href="phoenix.liveview.router.html#live_session/3"><code class="inline">Phoenix.LiveView.Router.live_session/3</code></a>:</p>
<pre data-language="elixir"># lib/my_app_web/live/init_assigns.ex
defmodule MyAppWeb.InitAssigns do
  @moduledoc """
  Ensures common `assigns` are applied to all LiveViews attaching this hook.
  """
  import Phoenix.LiveView

  def on_mount(:default, _params, _session, socket) do
    {:cont, assign(socket, :page_title, "DemoWeb")}
  end

  def on_mount(:user, params, session, socket) do
    # code
  end

  def on_mount(:admin, params, session, socket) do
    # code
  end
end

# lib/my_app_web/router.ex
defmodule MyAppWeb.Router do
  use MyAppWeb, :router

  # pipelines, plugs, etc.

  live_session :default, on_mount: MyAppWeb.InitAssigns do
    scope "/", MyAppWeb do
      pipe_through :browser
      live "/", PageLive, :index
    end
  end

  live_session :authenticated, on_mount: {MyAppWeb.InitAssigns, :user} do
    scope "/", MyAppWeb do
      pipe_through [:browser, :require_user]
      live "/profile", UserLive.Profile, :index
    end
  end

  live_session :admins, on_mount: {MyAppWeb.InitAssigns, :admin} do
    scope "/admin", MyAppWeb.Admin do
      pipe_through [:browser, :require_user, :require_admin]
      live "/", AdminLive.Index, :index
    end
  end
end</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="push_event/3">push_event(socket, event, payload)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view.ex#L1065" class="source">Source</a>
</h3> <section class="docstring"> <p>Pushes an event to the client.</p>
<p>Events can be handled in two ways:</p>
<ol>
<li><p>They can be handled on <code class="inline">window</code> via <code class="inline">addEventListener</code>. A "phx:" prefix will be added to the event name.</p></li>
<li><p>They can be handled inside a hook via <code class="inline">handleEvent</code>.</p></li>
</ol>
<p>Note that events are dispatched to all active hooks on the client who are handling the given <code class="inline">event</code>. If you need to scope events, then this must be done by namespacing them.</p>
<h4 id="push_event/3-hook-example" class="section-heading">  Hook example </h4> <p>If you push a "scores" event from your LiveView:</p>
<pre data-language="elixir">{:noreply, push_event(socket, "scores", %{points: 100, user: "josé"})}</pre>
<p>A hook declared via <code class="inline">phx-hook</code> can handle it via <code class="inline">handleEvent</code>:</p>
<pre data-language="elixir">this.handleEvent("scores", data =&gt; ...)</pre>
<h4 id="push_event/3-window-example" class="section-heading">  <code class="inline">window</code> example </h4> <p>All events are also dispatched on the <code class="inline">window</code>. This means you can handle them by adding listeners. For example, if you want to remove an element from the page, you can do this:</p>
<pre data-language="elixir">{:noreply, push_event(socket, "remove-el", %{id: "foo-bar"})}</pre>
<p>And now in your app.js you can register and handle it:</p>
<pre data-language="elixir">window.addEventListener(
  "phx:remove-el",
  e =&gt; document.getElementById(e.detail.id).remove()
)</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="push_patch/2">push_patch(socket, opts)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view.ex#L1274" class="source">Source</a>
</h3> <section class="docstring"> <p>Annotates the socket for navigation within the current LiveView.</p>
<p>When navigating to the current LiveView, <a href="#c:handle_params/3"><code class="inline">handle_params/3</code></a> is immediately invoked to handle the change of params and URL state. Then the new state is pushed to the client, without reloading the whole page while also maintaining the current scroll position. For live redirects to another LiveView, use <a href="#push_redirect/2"><code class="inline">push_redirect/2</code></a>.</p>
<h4 id="push_patch/2-options" class="section-heading">  Options </h4> <ul>
<li>
<code class="inline">:to</code> - the required path to link to. It must always be a local path</li>
<li>
<code class="inline">:replace</code> - the flag to replace the current history or push a new state. Defaults <code class="inline">false</code>.</li>
</ul>
<h4 id="push_patch/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:noreply, push_patch(socket, to: "/")}
{:noreply, push_patch(socket, to: "/", replace: true)}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="push_redirect/2">push_redirect(socket, opts)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view.ex#L1300" class="source">Source</a>
</h3> <section class="docstring"> <p>Annotates the socket for navigation to another LiveView.</p>
<p>The current LiveView will be shutdown and a new one will be mounted in its place, without reloading the whole page. This can also be used to remount the same LiveView, in case you want to start fresh. If you want to navigate to the same LiveView without remounting it, use <a href="#push_patch/2"><code class="inline">push_patch/2</code></a> instead.</p>
<h4 id="push_redirect/2-options" class="section-heading">  Options </h4> <ul>
<li>
<code class="inline">:to</code> - the required path to link to. It must always be a local path</li>
<li>
<code class="inline">:replace</code> - the flag to replace the current history or push a new state. Defaults <code class="inline">false</code>.</li>
</ul>
<h4 id="push_redirect/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:noreply, push_redirect(socket, to: "/")}
{:noreply, push_redirect(socket, to: "/", replace: true)}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="put_flash/3">put_flash(socket, kind, msg)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view.ex#L1005" class="source">Source</a>
</h3> <section class="docstring"> <p>Adds a flash message to the socket to be displayed.</p>
<p><em>Note</em>: While you can use <a href="#put_flash/3"><code class="inline">put_flash/3</code></a> inside a <a href="phoenix.livecomponent.html"><code class="inline">Phoenix.LiveComponent</code></a>, components have their own <code class="inline">@flash</code> assigns. The <code class="inline">@flash</code> assign in a component is only copied to its parent LiveView if the component calls <a href="#push_redirect/2"><code class="inline">push_redirect/2</code></a> or <a href="#push_patch/2"><code class="inline">push_patch/2</code></a>.</p>
<p><em>Note</em>: You must also place the <a href="phoenix.liveview.router.html#fetch_live_flash/2"><code class="inline">Phoenix.LiveView.Router.fetch_live_flash/2</code></a> plug in your browser's pipeline in place of <code class="inline">fetch_flash</code> for LiveView flash messages be supported, for example:</p>
<pre data-language="elixir">import Phoenix.LiveView.Router

pipeline :browser do
  ...
  plug :fetch_live_flash
end</pre>
<h4 id="put_flash/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; put_flash(socket, :info, "It worked!")
iex&gt; put_flash(socket, :error, "You can't access that page")</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="redirect/2">redirect(socket, arg2)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view.ex#L1240" class="source">Source</a>
</h3> <section class="docstring"> <p>Annotates the socket for redirect to a destination path.</p>
<p><em>Note</em>: LiveView redirects rely on instructing client to perform a <code class="inline">window.location</code> update on the provided redirect location. The whole page will be reloaded and all state will be discarded.</p>
<h4 id="redirect/2-options" class="section-heading">  Options </h4> <ul>
<li>
<code class="inline">:to</code> - the path to redirect to. It must always be a local path</li>
<li>
<code class="inline">:external</code> - an external path to redirect to</li>
</ul> </section> </section> <section class="detail">  <h3 class="detail-header" id="send_update/3">send_update(pid \\ self(), module, assigns)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view.ex#L1595" class="source">Source</a>
</h3> <section class="docstring"> <p>Asynchronously updates a <a href="phoenix.livecomponent.html"><code class="inline">Phoenix.LiveComponent</code></a> with new assigns.</p>
<p>The <code class="inline">:id</code> that identifies the component must be passed as part of the assigns and it will be used to identify the live components to be updated.</p>
<p>The <code class="inline">pid</code> argument is optional and it defaults to the current process, which means the update instruction will be sent to a component running on the same LiveView. If the current process is not a LiveView or you want to send updates to a live component running on another LiveView, you should explicitly pass the LiveView's pid instead.</p>
<p>When the component receives the update, first the optional <a href="phoenix.livecomponent.html#c:preload/1"><code class="inline">preload/1</code></a> then <a href="phoenix.livecomponent.html#c:update/2"><code class="inline">update/2</code></a> is invoked with the new assigns. If <a href="phoenix.livecomponent.html#c:update/2"><code class="inline">update/2</code></a> is not defined all assigns are simply merged into the socket.</p>
<p>While a component may always be updated from the parent by updating some parent assigns which will re-render the child, thus invoking <a href="phoenix.livecomponent.html#c:update/2"><code class="inline">update/2</code></a> on the child component, <a href="#send_update/3"><code class="inline">send_update/3</code></a> is useful for updating a component that entirely manages its own state, as well as messaging between components mounted in the same LiveView.</p>
<h4 id="send_update/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">def handle_event("cancel-order", _, socket) do
  ...
  send_update(Cart, id: "cart", status: "cancelled")
  {:noreply, socket}
end

def handle_event("cancel-order-asynchronously", _, socket) do
  ...
  pid = self()

  Task.async(fn -&gt;
    # Do something asynchronously
    send_update(pid, Cart, id: "cart", status: "cancelled")
  end)

  {:noreply, socket}
end</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="send_update_after/4">send_update_after(pid \\ self(), module, assigns, time_in_milliseconds)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view.ex#L1628" class="source">Source</a>
</h3> <section class="docstring"> <p>Similar to <a href="#send_update/3"><code class="inline">send_update/3</code></a> but the update will be delayed according to the given <code class="inline">time_in_milliseconds</code>.</p>
<h4 id="send_update_after/4-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">def handle_event("cancel-order", _, socket) do
  ...
  send_update_after(Cart, [id: "cart", status: "cancelled"], 3000)
  {:noreply, socket}
end

def handle_event("cancel-order-asynchronously", _, socket) do
  ...
  pid = self()

  Task.async(fn -&gt;
    # Do something asynchronously
    send_update_after(pid, Cart, [id: "cart", status: "cancelled"], 3000)
  end)

  {:noreply, socket}
end</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="static_changed?/1">static_changed?(socket)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view.ex#L1507" class="source">Source</a>
</h3> <section class="docstring"> <p>Returns true if the socket is connected and the tracked static assets have changed.</p>
<p>This function is useful to detect if the client is running on an outdated version of the marked static files. It works by comparing the static paths sent by the client with the one on the server.</p>
<p><strong>Note:</strong> this functionality requires Phoenix v1.5.2 or later.</p>
<p>To use this functionality, the first step is to annotate which static files you want to be tracked by LiveView, with the <code class="inline">phx-track-static</code>. For example:</p>
<pre data-language="elixir">&lt;link phx-track-static rel="stylesheet" href="&lt;%= Routes.static_path(@conn, .html"/css/app.css") %&gt;"/&gt;
&lt;script defer phx-track-static type="text/javascript" src="&lt;%= Routes.static_path(@conn, "/js/app.js") %&gt;"&gt;&lt;/script&gt;</pre>
<p>Now, whenever LiveView connects to the server, it will send a copy <code class="inline">src</code> or <code class="inline">href</code> attributes of all tracked statics and compare those values with the latest entries computed by <a href="https://hexdocs.pm/phoenix/1.6.6/Mix.Tasks.Phx.Digest.html"><code class="inline">mix phx.digest</code></a> in the server.</p>
<p>The tracked statics on the client will match the ones on the server the huge majority of times. However, if there is a new deployment, those values may differ. You can use this function to detect those cases and show a banner to the user, asking them to reload the page. To do so, first set the assign on mount:</p>
<pre data-language="elixir">def mount(params, session, socket) do
  {:ok, assign(socket, static_changed?: static_changed?(socket))}
end</pre>
<p>And then in your views:</p>
<pre data-language="elixir">&lt;%= if @static_changed? do %&gt;
  &lt;div id="reload-static"&gt;
    The app has been updated. Click here to &lt;a href="#" onclick="window.location.reload()"&gt;reload&lt;/a&gt;.
  &lt;/div&gt;
&lt;% end %&gt;</pre>
<p>If you prefer, you can also send a JavaScript script that immediately reloads the page.</p>
<p><strong>Note:</strong> only set <code class="inline">phx-track-static</code> on your own assets. For example, do not set it in external JavaScript files:</p>
<pre data-language="elixir">&lt;script defer phx-track-static type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"&gt;&lt;/script&gt;</pre>
<p>Because you don't actually serve the file above, LiveView will interpret the static above as missing, and this function will return true.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="transport_pid/1">transport_pid(socket)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view.ex#L1649" class="source">Source</a>
</h3> <section class="docstring"> <p>Returns the transport pid of the socket.</p>
<p>Raises <a href="https://hexdocs.pm/elixir/ArgumentError.html"><code class="inline">ArgumentError</code></a> if the socket is not connected.</p>
<h4 id="transport_pid/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; transport_pid(socket)
#PID&lt;0.107.0&gt;</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="update/3">update(socket_or_assigns, key, fun)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view.ex#L928" class="source">Source</a>
</h3> <section class="docstring"> <p>Updates an existing <code class="inline">key</code> with <code class="inline">fun</code> in the given <code class="inline">socket_or_assigns</code>.</p>
<p>The first argument is either a LiveView <code class="inline">socket</code> or an <code class="inline">assigns</code> map from function components.</p>
<p>The update function receives the current key's value and returns the updated value. Raises if the key does not exist.</p>
<p>The update function may also be of arity 2, in which case it receives the current key's value as the first argument and the current assigns as the second argument. Raises if the key does not exist.</p>
<h4 id="update/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; update(socket, :count, fn count -&gt; count + 1 end)
iex&gt; update(socket, :count, &amp;(&amp;1 + 1))
iex&gt; update(socket, :max_users_this_session, fn current_max, %{users: users} -&gt; max(current_max, length(users)) end)</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="uploaded_entries/2">uploaded_entries(socket, name)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view.ex#L1160" class="source">Source</a>
</h3> <section class="docstring"> <p>Returns the completed and in progress entries for the upload.</p>
<h4 id="uploaded_entries/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">case uploaded_entries(socket, :photos) do
  {[_ | _] = completed, []} -&gt;
    # all entries are completed

  {[], [_ | _] = in_progress} -&gt;
    # all entries are still in progress
end</pre> </section> </section> </div> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2018 Chris McCord<br>Licensed under the MIT License.<br>
    <a href="https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html" class="_attribution-link">https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html</a>
  </p>
</div>
