<h1>   <span translate="no">Phoenix.LiveView.Helpers</span>  </h1> <section id="moduledoc"> <p>A collection of helpers to be imported into your views.</p> </section> <section id="summary" class="details-list"> <h1 class="section-heading">  Summary </h1> <h2> Functions </h2>
<dl class="summary-functions summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#assigns_to_attributes/2" translate="no">assigns_to_attributes(assigns, exclude \\ [])</a> </dt> <dd class="summary-synopsis"><p>Filters the assigns as a list of keywords for use in dynamic tag attributes.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#component/2" translate="no">component(func, assigns \\ [])</a> </dt> <dd class="summary-synopsis"><p>Renders a component defined by the given function.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#form/1" translate="no">form(assigns)</a> </dt> <dd class="summary-synopsis"><p>Renders a form function component.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#inner_block/2" translate="no">inner_block(name, list)</a> </dt> <dd class="summary-synopsis"><p>Define a inner block, generally used by slots.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#live_component/1" translate="no">live_component(assigns)</a> </dt> <dd class="summary-synopsis"><p>A function component for rendering <a href="phoenix.livecomponent.html"><code class="inline">Phoenix.LiveComponent</code></a> within a parent LiveView.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#live_component/3" translate="no">live_component(component, assigns, do_block \\ [])</a> <span class="deprecated" title="Use .live_component (live_component/1) instead">deprecated</span> </dt> <dd class="summary-synopsis"><p>Deprecated API for rendering <code class="inline">LiveComponent</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#live_file_input/2" translate="no">live_file_input(conf, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Builds a file input tag for a LiveView upload.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#live_flash/2" translate="no">live_flash(other, key)</a> </dt> <dd class="summary-synopsis"><p>Returns the flash message from the LiveView flash assign.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#live_img_preview/2" translate="no">live_img_preview(entry, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Generates an image preview on the client for a selected file.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#live_patch/2" translate="no">live_patch(text, opts)</a> </dt> <dd class="summary-synopsis"><p>Generates a link that will patch the current LiveView.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#live_redirect/2" translate="no">live_redirect(text, opts)</a> </dt> <dd class="summary-synopsis"><p>Generates a link that will redirect to a new LiveView of the same live session.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#live_render/3" translate="no">live_render(conn_or_socket, view, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Renders a LiveView within a template.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#live_title_tag/2" translate="no">live_title_tag(title, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Renders a title tag with automatic prefix/suffix on <code class="inline">@page_title</code> updates.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render_block/2" translate="no">render_block(inner_block, argument \\ [])</a> <span class="deprecated" title="Use render_slot/2 instead">deprecated</span> </dt> <dd class="summary-synopsis"><p>Renders the <code class="inline">@inner_block</code> assign of a component with the given <code class="inline">argument</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render_slot/2" translate="no">render_slot(slot, argument \\ nil)</a> </dt> <dd class="summary-synopsis"><p>Renders a slot entry with the given optional <code class="inline">argument</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#sigil_H/2" translate="no">sigil_H(arg, list)</a> </dt> <dd class="summary-synopsis"><p>The <code class="inline">~H</code> sigil for writing HEEx templates inside source files.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#sigil_L/2" translate="no">sigil_L(arg, list)</a> <span class="deprecated" title="Use ~H instead">deprecated</span> </dt> <dd class="summary-synopsis"><p>Provides <code class="inline">~L</code> sigil with HTML safe Live EEx syntax inside source files.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#upload_errors/1" translate="no">upload_errors(conf)</a> </dt> <dd class="summary-synopsis"><p>Returns the entry errors for an upload.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#upload_errors/2" translate="no">upload_errors(conf, entry)</a> </dt> <dd class="summary-synopsis"><p>Returns the entry errors for an upload.</p></dd> </div> </dl> </section> <section id="functions" class="details-list"> <h1 class="section-heading">  Functions </h1> <div class="functions-list"> <section class="detail">  <h3 class="detail-header" id="assigns_to_attributes/2">assigns_to_attributes(assigns, exclude \\ [])<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/helpers.ex#L236" class="source">Source</a>
</h3> <section class="docstring"> <p>Filters the assigns as a list of keywords for use in dynamic tag attributes.</p>
<p>Useful for transforming caller assigns into dynamic attributes while stripping reserved keys from the result.</p>
<h4 id="assigns_to_attributes/2-examples" class="section-heading">  Examples </h4> <p>Imagine the following <code class="inline">my_link</code> component which allows a caller to pass a <code class="inline">new_window</code> assign, along with any other attributes they would like to add to the element, such as class, data attributes, etc:</p>
<pre data-language="elixir">&lt;.my_link href="/.html" id={@id} new_window={true} class="my-class"&gt;Home&lt;/.my_link&gt;</pre>
<p>We could support the dynamic attributes with the following component:</p>
<pre data-language="elixir">def my_link(assigns) do
  target = if assigns[:new_window], do: "_blank", else: false
  extra = assigns_to_attributes(assigns, [:new_window])

  assigns =
    assigns
    |&gt; Phoenix.LiveView.assign(:target, target)
    |&gt; Phoenix.LiveView.assign(:extra, extra)

  ~H"""
  &lt;a href={@href} target={@target} {@extra}&gt;
    &lt;%= render_slot(@inner_block) %&gt;
  &lt;/a&gt;
  """
end</pre>
<p>The above would result in the following rendered HTML:</p>
<pre data-language="elixir">&lt;a href="/.html" target="_blank" id="1" class="my-class"&gt;Home&lt;/a&gt;</pre>
<p>The second argument (optional) to <code class="inline">assigns_to_attributes</code> is a list of keys to exclude. It typically includes reserved keys by the component itself, which either do not belong in the markup, or are already handled explicitly by the component.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="component/2">component(func, assigns \\ [])<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/helpers.ex#L629" class="source">Source</a>
</h3> <section class="docstring"> <p>Renders a component defined by the given function.</p>
<p>This function is rarely invoked directly by users. Instead, it is used by <code class="inline">~H</code> to render <a href="phoenix.component.html"><code class="inline">Phoenix.Component</code></a>s. For example, the following:</p>
<pre data-language="elixir">&lt;MyApp.Weather.city name="Kraków" /&gt;</pre>
<p>Is the same as:</p>
<pre data-language="elixir">&lt;%= component(&amp;MyApp.Weather.city/1, name: "Kraków") %&gt;</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="form/1">form(assigns)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/helpers.ex#L1098" class="source">Source</a>
</h3> <section class="docstring"> <p>Renders a form function component.</p>
<p>This function is built on top of <a href="https://hexdocs.pm/phoenix_html/3.2.0/Phoenix.HTML.Form.html#form_for/4"><code class="inline">Phoenix.HTML.Form.form_for/4</code></a>. For more information about options and how to build inputs, see <a href="https://hexdocs.pm/phoenix_html/3.2.0/Phoenix.HTML.Form.html"><code class="inline">Phoenix.HTML.Form</code></a>.</p>
<h4 id="form/1-options" class="section-heading">  Options </h4> <p>The following attribute is required:</p>
<ul><li>
<code class="inline">:for</code> - the form source data</li></ul>
<p>The following attributes are optional:</p>
<ul>
<li><p><code class="inline">:action</code> - the action to submit the form on. This attribute must be given if you intend to submit the form to a URL without LiveView.</p></li>
<li><p><code class="inline">:as</code> - the server side parameter in which all params for this form will be collected (i.e. <code class="inline">as: :user_params</code> would mean all fields for this form will be accessed as <code class="inline">conn.params.user_params</code> server side). Automatically inflected when a changeset is given.</p></li>
<li><p><code class="inline">:multipart</code> - when true, sets enctype to "multipart/form-data". Required when uploading files</p></li>
<li><p><code class="inline">:method</code> - the HTTP method. It is only used if an <code class="inline">:action</code> is given. If the method is not "get" nor "post", an input tag with name <code class="inline">_method</code> is generated along-side the form tag. Defaults to "post".</p></li>
<li><p><code class="inline">:csrf_token</code> - a token to authenticate the validity of requests. One is automatically generated when an action is given and the method is not "get". When set to false, no token is generated.</p></li>
<li><p><code class="inline">:errors</code> - use this to manually pass a keyword list of errors to the form (for example from <code class="inline">conn.assigns[:errors]</code>). This option is only used when a connection is used as the form source and it will make the errors available under <code class="inline">f.errors</code></p></li>
<li><p><code class="inline">:id</code> - the ID of the form attribute. If an ID is given, all form inputs will also be prefixed by the given ID</p></li>
</ul>
<p>All further assigns will be passed to the form tag.</p>
<h4 id="form/1-examples" class="section-heading">  Examples </h4> <h3 id="form/1-inside-liveview" class="section-heading">  Inside LiveView </h3> <p>The <code class="inline">:for</code> attribute is typically an <a href="../ecto/ecto.changeset.html"><code class="inline">Ecto.Changeset</code></a>:</p>
<pre data-language="elixir">&lt;.form let={f} for={@changeset} phx-change="change_name"&gt;
  &lt;%= text_input f, :name %&gt;
&lt;/.form&gt;

&lt;.form let={user_form} for={@changeset} multipart phx-change="change_user" phx-submit="save_user"&gt;
  &lt;%= text_input user_form, :name %&gt;
  &lt;%= submit "Save" %&gt;
&lt;/.form&gt;</pre>
<p>Notice how both examples use <code class="inline">phx-change</code>. The LiveView must implement the <code class="inline">phx-change</code> event and store the input values as they arrive on change. This is important because, if an unrelated change happens on the page, LiveView should re-render the inputs with their updated values. Without <code class="inline">phx-change</code>, the inputs would otherwise be cleared. Alternatively, you can use <code class="inline">phx-update="ignore"</code> on the form to discard any updates.</p>
<p>The <code class="inline">:for</code> attribute can also be an atom, in case you don't have an existing data layer but you want to use the existing form helpers. In this case, you need to pass the input values explicitly as they change (or use <code class="inline">phx-update="ignore"</code> as per the previous paragraph):</p>
<pre data-language="elixir">&lt;.form let={user_form} for={:user} multipart phx-change="change_user" phx-submit="save_user"&gt;
  &lt;%= text_input user_form, :name, value: @user_name %&gt;
  &lt;%= submit "Save" %&gt;
&lt;/.form&gt;</pre>
<p>However, if you don't have a data layer, it may be more straight-forward to drop the <code class="inline">form</code> component altogether and simply rely on HTML:</p>
<pre data-language="elixir">&lt;form multipart phx-change="change_user" phx-submit="save_user"&gt;
  &lt;input type="text" name="user[name]" value={@user_name}&gt;
  &lt;input type="submit" name="Save"&gt;
&lt;/form&gt;</pre>
<h3 id="form/1-outside-liveview" class="section-heading">  Outside LiveView </h3> <p>The <code class="inline">form</code> component can still be used to submit forms outside of LiveView. In such cases, the <code class="inline">action</code> attribute MUST be given. Without said attribute, the <code class="inline">form</code> method and csrf token are discarded.</p>
<pre data-language="elixir">&lt;.form let={f} for={@changeset} action={Routes.comment_path(:create, @comment)}&gt;
  &lt;%= text_input f, :body %&gt;
&lt;/.form&gt;</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="inner_block/2">inner_block(name, list)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/helpers.ex#L781" class="source">Source</a>
</h3> <section class="docstring"> <p>Define a inner block, generally used by slots.</p>
<p>This macro is mostly used by HTML engines that provides a <code class="inline">slot</code> implementation and rarely called directly. The <code class="inline">name</code> must be the assign name the slot/block will be stored under.</p>
<p>If you're using HEEx templates, you should use its higher level <code class="inline">&lt;:slot&gt;</code> notation instead. See <a href="phoenix.component.html"><code class="inline">Phoenix.Component</code></a> for more information.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="live_component/1">live_component(assigns)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/helpers.ex#L469" class="source">Source</a>
</h3> <section class="docstring"> <p>A function component for rendering <a href="phoenix.livecomponent.html"><code class="inline">Phoenix.LiveComponent</code></a> within a parent LiveView.</p>
<p>While <code class="inline">LiveView</code>s can be nested, each LiveView starts its own process. A <code class="inline">LiveComponent</code> provides similar functionality to <code class="inline">LiveView</code>, except they run in the same process as the <code class="inline">LiveView</code>, with its own encapsulated state. That's why they are called stateful components.</p>
<p>See <a href="phoenix.livecomponent.html"><code class="inline">Phoenix.LiveComponent</code></a> for more information.</p>
<h4 id="live_component/1-examples" class="section-heading">  Examples </h4> <p><code class="inline">.live_component</code> requires the component <code class="inline">:module</code> and its <code class="inline">:id</code> to be given:</p>
<pre data-language="elixir">&lt;.live_component module={MyApp.WeatherComponent} id="thermostat" city="Kraków" /&gt;</pre>
<p>The <code class="inline">:id</code> is used to identify this <code class="inline">LiveComponent</code> throughout the LiveView lifecycle. Note the <code class="inline">:id</code> won't necessarily be used as the DOM ID. That's up to the component.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="live_component/3">live_component(component, assigns, do_block \\ [])<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/helpers.ex#L537" class="source">Source</a>
</h3> <div class="deprecated"> This macro is deprecated. Use .live_component (live_component/1) instead. </div> <section class="docstring"> <p>Deprecated API for rendering <code class="inline">LiveComponent</code>.</p>
<h4 id="live_component/3-upgrading" class="section-heading">  Upgrading </h4> <p>In order to migrate from <code class="inline">&lt;%= live_component ... %&gt;</code> to <code class="inline">&lt;.live_component&gt;</code>, you must first:</p>
<ol>
<li><p>Migrate from <code class="inline">~L</code> sigil and <code class="inline">.leex</code> templates to <code class="inline">~H</code> sigil and <code class="inline">.heex</code> templates</p></li>
<li>
<p>Then instead of:</p>
<pre data-language="elixir">&lt;%= live_component MyModule, id: "hello" do %&gt;
...
&lt;% end %&gt;</pre>
<p>You should do:</p>
<pre data-language="elixir">&lt;.live_component module={MyModule} id="hello"&gt;
...
&lt;/.live_component&gt;</pre>
</li>
<li><p>If your component is using <a href="#render_block/2"><code class="inline">render_block/2</code></a>, replace it by <a href="#render_slot/2"><code class="inline">render_slot/2</code></a></p></li>
</ol> </section> </section> <section class="detail">  <h3 class="detail-header" id="live_file_input/2">live_file_input(conf, opts \\ [])<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/helpers.ex#L936" class="source">Source</a>
</h3> <section class="docstring"> <p>Builds a file input tag for a LiveView upload.</p>
<p>Options may be passed through to the tag builder for custom attributes.</p>
<h4 id="live_file_input/2-drag-and-drop" class="section-heading">  Drag and Drop </h4> <p>Drag and drop is supported by annotating the droppable container with a <code class="inline">phx-drop-target</code> attribute pointing to the DOM ID of the file input. By default, the file input ID is the upload <code class="inline">ref</code>, so the following markup is all that is required for drag and drop support:</p>
<pre data-language="elixir">&lt;div class="container" phx-drop-target={@uploads.avatar.ref}&gt;
    ...
    &lt;%= live_file_input @uploads.avatar %&gt;
&lt;/div&gt;</pre>
<h4 id="live_file_input/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">&lt;%= live_file_input @uploads.avatar %&gt;</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="live_flash/2">live_flash(other, key)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/helpers.ex#L837" class="source">Source</a>
</h3> <section class="docstring"> <p>Returns the flash message from the LiveView flash assign.</p>
<h4 id="live_flash/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">&lt;p class="alert alert-info"&gt;&lt;%= live_flash(@flash, :info) %&gt;&lt;/p&gt;
&lt;p class="alert alert-danger"&gt;&lt;%= live_flash(@flash, :error) %&gt;&lt;/p&gt;</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="live_img_preview/2">live_img_preview(entry, opts \\ [])<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/helpers.ex#L901" class="source">Source</a>
</h3> <section class="docstring"> <p>Generates an image preview on the client for a selected file.</p>
<h4 id="live_img_preview/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">&lt;%= for entry &lt;- @uploads.avatar.entries do %&gt;
  &lt;%= live_img_preview entry, width: 75 %&gt;
&lt;% end %&gt;</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="live_patch/2">live_patch(text, opts)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/helpers.ex#L273" class="source">Source</a>
</h3> <section class="docstring"> <p>Generates a link that will patch the current LiveView.</p>
<p>When navigating to the current LiveView, <a href="phoenix.liveview.html#c:handle_params/3"><code class="inline">Phoenix.LiveView.handle_params/3</code></a> is immediately invoked to handle the change of params and URL state. Then the new state is pushed to the client, without reloading the whole page while also maintaining the current scroll position. For live redirects to another LiveView, use <a href="#live_redirect/2"><code class="inline">live_redirect/2</code></a>.</p>
<h4 id="live_patch/2-options" class="section-heading">  Options </h4> <ul>
<li>
<code class="inline">:to</code> - the required path to link to.</li>
<li>
<code class="inline">:replace</code> - the flag to replace the current history or push a new state. Defaults <code class="inline">false</code>.</li>
</ul>
<p>All other options are forwarded to the anchor tag.</p>
<h4 id="live_patch/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">&lt;%= live_patch "home", to: Routes.page_path(@socket, :index) %&gt;
&lt;%= live_patch "next", to: Routes.live_path(@socket, MyLive, @page + 1) %&gt;
&lt;%= live_patch to: Routes.live_path(@socket, MyLive, dir: :asc), replace: false do %&gt;
  Sort By Price
&lt;% end %&gt;</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="live_redirect/2">live_redirect(text, opts)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/helpers.ex#L327" class="source">Source</a>
</h3> <section class="docstring"> <p>Generates a link that will redirect to a new LiveView of the same live session.</p>
<p>The current LiveView will be shut down and a new one will be mounted in its place, without reloading the whole page. This can also be used to remount the same LiveView, in case you want to start fresh. If you want to navigate to the same LiveView without remounting it, use <a href="#live_patch/2"><code class="inline">live_patch/2</code></a> instead.</p>
<p><em>Note</em>: The live redirects are only supported between two LiveViews defined under the same live session. See <a href="phoenix.liveview.router.html#live_session/3"><code class="inline">Phoenix.LiveView.Router.live_session/3</code></a> for more details.</p>
<h4 id="live_redirect/2-options" class="section-heading">  Options </h4> <ul>
<li>
<code class="inline">:to</code> - the required path to link to.</li>
<li>
<code class="inline">:replace</code> - the flag to replace the current history or push a new state. Defaults <code class="inline">false</code>.</li>
</ul>
<p>All other options are forwarded to the anchor tag.</p>
<h4 id="live_redirect/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">&lt;%= live_redirect "home", to: Routes.page_path(@socket, :index) %&gt;
&lt;%= live_redirect "next", to: Routes.live_path(@socket, MyLive, @page + 1) %&gt;
&lt;%= live_redirect to: Routes.live_path(@socket, MyLive, dir: :asc), replace: false do %&gt;
  Sort By Price
&lt;% end %&gt;</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="live_render/3">live_render(conn_or_socket, view, opts \\ [])<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/helpers.ex#L430" class="source">Source</a>
</h3> <section class="docstring"> <p>Renders a LiveView within a template.</p>
<p>This is useful in two situations:</p>
<ul>
<li><p>When rendering a child LiveView inside a LiveView</p></li>
<li><p>When rendering a LiveView inside a regular (non-live) controller/view</p></li>
</ul>
<h4 id="live_render/3-options" class="section-heading">  Options </h4> <ul>
<li><p><code class="inline">:session</code> - a map of binary keys with extra session data to be serialized and sent to the client. All session data currently in the connection is automatically available in LiveViews. You can use this option to provide extra data. Remember all session data is serialized and sent to the client, so you should always keep the data in the session to a minimum. For example, instead of storing a User struct, you should store the "user_id" and load the User when the LiveView mounts.</p></li>
<li><p><code class="inline">:container</code> - an optional tuple for the HTML tag and DOM attributes to be used for the LiveView container. For example: <code class="inline">{:li, style: "color: blue;"}</code>. By default it uses the module definition container. See the "Containers" section below for more information.</p></li>
<li><p><code class="inline">:id</code> - both the DOM ID and the ID to uniquely identify a LiveView. An <code class="inline">:id</code> is automatically generated when rendering root LiveViews but it is a required option when rendering a child LiveView.</p></li>
<li><p><code class="inline">:sticky</code> - an optional flag to maintain the LiveView across live redirects, even if it is nested within another LiveView. If you are rendering the sticky view within your live layout, make sure that the sticky view itself does not use the same layout. You can do so by returning <code class="inline">{:ok, socket, layout: false}</code> from mount.</p></li>
</ul>
<h4 id="live_render/3-examples" class="section-heading">  Examples </h4> <p>When rendering from a controller/view, you can call:</p>
<pre data-language="elixir">&lt;%= live_render(@conn, MyApp.ThermostatLive) %&gt;</pre>
<p>Or:</p>
<pre data-language="elixir">&lt;%= live_render(@conn, MyApp.ThermostatLive, session: %{"home_id" =&gt; @home.id}) %&gt;</pre>
<p>Within another LiveView, you must pass the <code class="inline">:id</code> option:</p>
<pre data-language="elixir">&lt;%= live_render(@socket, MyApp.ThermostatLive, id: "thermostat") %&gt;</pre>
<h4 id="live_render/3-containers" class="section-heading">  Containers </h4> <p>When a <code class="inline">LiveView</code> is rendered, its contents are wrapped in a container. By default, the container is a <code class="inline">div</code> tag with a handful of <code class="inline">LiveView</code> specific attributes.</p>
<p>The container can be customized in different ways:</p>
<ul>
<li>
<p>You can change the default <code class="inline">container</code> on <code class="inline">use Phoenix.LiveView</code>:</p>
<pre data-language="elixir">use Phoenix.LiveView, container: {:tr, id: "foo-bar"}</pre>
</li>
<li>
<p>You can override the container tag and pass extra attributes when calling <code class="inline">live_render</code> (as well as on your <code class="inline">live</code> call in your router):</p>
<pre data-language="elixir">live_render socket, MyLiveView, container: {:tr, class: "highlight"}</pre>
</li>
</ul> </section> </section> <section class="detail">  <h3 class="detail-header" id="live_title_tag/2">live_title_tag(title, opts \\ [])<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/helpers.ex#L978" class="source">Source</a>
</h3> <section class="docstring"> <p>Renders a title tag with automatic prefix/suffix on <code class="inline">@page_title</code> updates.</p>
<h4 id="live_title_tag/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">&lt;%= live_title_tag assigns[:page_title] || "Welcome", prefix: "MyApp – " %&gt;

&lt;%= live_title_tag assigns[:page_title] || "Welcome", suffix: " – MyApp" %&gt;</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="render_block/2">render_block(inner_block, argument \\ [])<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/helpers.ex#L667" class="source">Source</a>
</h3> <div class="deprecated"> This macro is deprecated. Use render_slot/2 instead. </div> <section class="docstring"> <p>Renders the <code class="inline">@inner_block</code> assign of a component with the given <code class="inline">argument</code>.</p>
<pre data-language="elixir">&lt;%= render_block(@inner_block, value: @value)</pre>
<p>This function is deprecated for function components. Use <a href="#render_slot/2"><code class="inline">render_slot/2</code></a> instead.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="render_slot/2">render_slot(slot, argument \\ nil)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/helpers.ex#L731" class="source">Source</a>
</h3> <section class="docstring"> <p>Renders a slot entry with the given optional <code class="inline">argument</code>.</p>
<pre data-language="elixir">&lt;%= render_slot(@inner_block, @form) %&gt;</pre>
<p>If multiple slot entries are defined for the same slot, <a href="#render_slot/2"><code class="inline">render_slot/2</code></a> will automatically render all entries, merging their contents. In case you want to use the entries' attributes, you need to iterate over the list to access each slot individually.</p>
<p>For example, imagine a table component:</p>
<pre data-language="elixir">&lt;.table rows={@users}&gt;
  &lt;:col let={user} label="Name"&gt;
    &lt;%= user.name %&gt;
  &lt;/:col&gt;

  &lt;:col let={user} label="Address"&gt;
    &lt;%= user.address %&gt;
  &lt;/:col&gt;
&lt;/.table&gt;</pre>
<p>At the top level, we pass the rows as an assign and we define a <code class="inline">:col</code> slot for each column we want in the table. Each column also has a <code class="inline">label</code>, which we are going to use in the table header.</p>
<p>Inside the component, you can render the table with headers, rows, and columns:</p>
<pre data-language="elixir">def table(assigns) do
  ~H"""
  &lt;table&gt;
    &lt;tr&gt;
      &lt;%= for col &lt;- @col do %&gt;
        &lt;th&gt;&lt;%= col.label %&gt;&lt;/th&gt;
      &lt;% end %&gt;
    &lt;/tr&gt;
    &lt;%= for row &lt;- @rows do %&gt;
      &lt;tr&gt;
        &lt;%= for col &lt;- @col do %&gt;
          &lt;td&gt;&lt;%= render_slot(col, row) %&gt;&lt;/td&gt;
        &lt;% end %&gt;
      &lt;/tr&gt;
    &lt;% end %&gt;
  &lt;/table&gt;
  """
end</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="sigil_H/2">sigil_H(arg, list)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/helpers.ex#L180" class="source">Source</a>
</h3> <section class="docstring"> <p>The <code class="inline">~H</code> sigil for writing HEEx templates inside source files.</p>
<blockquote><p>Note: <code class="inline">HEEx</code> requires Elixir &gt;= <code class="inline">1.12.0</code> in order to provide accurate file:line:column information in error messages. Earlier Elixir versions will work but will show inaccurate error messages.</p></blockquote>
<blockquote><p>Note: The HEEx HTML formatter requires Elixir &gt;= 1.13.0. See the <a href="phoenix.liveview.htmlformatter.html"><code class="inline">Phoenix.LiveView.HTMLFormatter</code></a> for more information on template formatting.</p></blockquote>
<p><code class="inline">HEEx</code> is a HTML-aware and component-friendly extension of Elixir Embedded language (<a href="https://hexdocs.pm/eex/EEx.html"><code class="inline">EEx</code></a>) that provides:</p>
<ul>
<li>Built-in handling of HTML attributes</li>
<li>An HTML-like notation for injecting function components</li>
<li>Compile-time validation of the structure of the template</li>
<li>The ability to minimize the amount of data sent over the wire</li>
</ul>
<h4 id="sigil_H/2-example" class="section-heading">  Example </h4> <pre data-language="elixir">~H"""
&lt;div title="My div" class={@class}&gt;
  &lt;p&gt;Hello &lt;%= @name %&gt;&lt;/p&gt;
  &lt;MyApp.Weather.city name="Kraków"/&gt;
&lt;/div&gt;
"""</pre>
<h4 id="sigil_H/2-syntax" class="section-heading">  Syntax </h4> <p><code class="inline">HEEx</code> is built on top of Embedded Elixir (<a href="https://hexdocs.pm/eex/EEx.html"><code class="inline">EEx</code></a>). In this section, we are going to cover the basic constructs in <code class="inline">HEEx</code> templates as well as its syntax extensions.</p>
<h3 id="sigil_H/2-interpolation" class="section-heading">  Interpolation </h3> <p>Both <code class="inline">HEEx</code> and <a href="https://hexdocs.pm/eex/EEx.html"><code class="inline">EEx</code></a> templates use <code class="inline">&lt;%= ... %&gt;</code> for interpolating code inside the body of HTML tags:</p>
<pre data-language="elixir">&lt;p&gt;Hello, &lt;%= @name %&gt;&lt;/p&gt;</pre>
<p>Similarly, conditionals and other block Elixir constructs are supported:</p>
<pre data-language="elixir">&lt;%= if @show_greeting? do %&gt;
  &lt;p&gt;Hello, &lt;%= @name %&gt;&lt;/p&gt;
&lt;% end %&gt;</pre>
<p>Note we don't include the equal sign <code class="inline">=</code> in the closing <code class="inline">&lt;% end %&gt;</code> tag (because the closing tag does not output anything).</p>
<p>There is one important difference between <code class="inline">HEEx</code> and Elixir's builtin <a href="https://hexdocs.pm/eex/EEx.html"><code class="inline">EEx</code></a>. <code class="inline">HEEx</code> uses a specific annotation for interpolating HTML tags and attributes. Let's check it out.</p>
<h3 id="sigil_H/2-heex-extension-defining-attributes" class="section-heading">  HEEx extension: Defining attributes </h3> <p>Since <code class="inline">HEEx</code> must parse and validate the HTML structure, code interpolation using <code class="inline">&lt;%= ... %&gt;</code> and <code class="inline">&lt;% ... %&gt;</code> are restricted to the body (inner content) of the HTML/component nodes and it cannot be applied within tags.</p>
<p>For instance, the following syntax is invalid:</p>
<pre data-language="elixir">&lt;div class="&lt;%= @class %&gt;"&gt;
  ...
&lt;/div&gt;</pre>
<p>Instead do:</p>
<pre data-language="elixir">&lt;div class={@class}&gt;
  ...
&lt;/div&gt;</pre>
<p>You can put any Elixir expression between <code class="inline">{ ... }</code>. For example, if you want to set classes, where some are static and others are dynamic, you can using string interpolation:</p>
<pre data-language="elixir">&lt;div class={"btn btn-#{@type}"}&gt;
  ...
&lt;/div&gt;</pre>
<p>The following attribute values have special meaning:</p>
<ul>
<li><p><code class="inline">true</code> - if a value is <code class="inline">true</code>, the attribute is rendered with no value at all. For example, <code class="inline">&lt;input required={true}&gt;</code> is the same as <code class="inline">&lt;input required&gt;</code>;</p></li>
<li><p><code class="inline">false</code> or <code class="inline">nil</code> - if a value is <code class="inline">false</code> or <code class="inline">nil</code>, the attribute is not rendered;</p></li>
<li><p><code class="inline">list</code> (only for the <code class="inline">class</code> attribute) - each element of the list is processed as a different class. <code class="inline">nil</code> and <code class="inline">false</code> elements are discarded.</p></li>
</ul>
<p>For multiple dynamic attributes, you can use the same notation but without assigning the expression to any specific attribute.</p>
<pre data-language="elixir">&lt;div {@dynamic_attrs}&gt;
  ...
&lt;/div&gt;</pre>
<p>The expression inside <code class="inline">{...}</code> must be either a keyword list or a map containing the key-value pairs representing the dynamic attributes.</p>
<p>You can pair this notation <a href="#assigns_to_attributes/2"><code class="inline">assigns_to_attributes/2</code></a> to strip out any internal LiveView attributes and user-defined assigns from being expanded into the HTML tag:</p>
<pre data-language="elixir">&lt;div {assigns_to_attributes(assigns, [:visible])}&gt;
  ...
&lt;/div&gt;</pre>
<p>The above would add all caller attributes into the HTML, but strip out LiveView assigns like slots, as well as user-defined assigns like <code class="inline">:visible</code> that are not meant to be added to the HTML itself. This approach is useful to allow a component to accept arbitrary HTML attributes like class, ARIA attributes, etc.</p>
<h3 id="sigil_H/2-heex-extension-defining-function-components" class="section-heading">  HEEx extension: Defining function components </h3> <p>Function components are stateless components implemented as pure functions with the help of the <a href="phoenix.component.html"><code class="inline">Phoenix.Component</code></a> module. They can be either local (same module) or remote (external module).</p>
<p><code class="inline">HEEx</code> allows invoking these function components directly in the template using an HTML-like notation. For example, a remote function:</p>
<pre data-language="elixir">&lt;MyApp.Weather.city name="Kraków"/&gt;</pre>
<p>A local function can be invoked with a leading dot:</p>
<pre data-language="elixir">&lt;.city name="Kraków"/&gt;</pre>
<p>where the component could be defined as follows:</p>
<pre data-language="elixir">defmodule MyApp.Weather do
  use Phoenix.Component

  def city(assigns) do
    ~H"""
    The chosen city is: &lt;%= @name %&gt;.
    """
  end

  def country(assigns) do
    ~H"""
    The chosen country is: &lt;%= @name %&gt;.
    """
  end
end</pre>
<p>It is typically best to group related functions into a single module, as opposed to having many modules with a single <code class="inline">render/1</code> function. Function components support other important features, such as slots. You can learn more about components in <a href="phoenix.component.html"><code class="inline">Phoenix.Component</code></a>.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="sigil_L/2">sigil_L(arg, list)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/helpers.ex#L21" class="source">Source</a>
</h3> <div class="deprecated"> This macro is deprecated. Use ~H instead. </div> <section class="docstring"> <p>Provides <code class="inline">~L</code> sigil with HTML safe Live EEx syntax inside source files.</p>
<pre data-language="elixir">iex&gt; ~L"""
...&gt; Hello &lt;%= "world" %&gt;
...&gt; """
{:safe, ["Hello ", "world", "\n"]}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="upload_errors/1">upload_errors(conf)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/helpers.ex#L860" class="source">Source</a>
</h3> <section class="docstring"> <p>Returns the entry errors for an upload.</p>
<p>The following error may be returned:</p>
<ul><li>
<code class="inline">:too_many_files</code> - The number of selected files exceeds the <code class="inline">:max_entries</code> constraint</li></ul>
<h4 id="upload_errors/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">def error_to_string(:too_many_files), do: "You have selected too many files"

&lt;%= for err &lt;- upload_errors(@uploads.avatar) do %&gt;
  &lt;div class="alert alert-danger"&gt;
    &lt;%= error_to_string(err) %&gt;
  &lt;/div&gt;
&lt;% end %&gt;</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="upload_errors/2">upload_errors(conf, entry)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/helpers.ex#L885" class="source">Source</a>
</h3> <section class="docstring"> <p>Returns the entry errors for an upload.</p>
<p>The following errors may be returned:</p>
<ul>
<li>
<code class="inline">:too_large</code> - The entry exceeds the <code class="inline">:max_file_size</code> constraint</li>
<li>
<code class="inline">:not_accepted</code> - The entry does not match the <code class="inline">:accept</code> MIME types</li>
</ul>
<h4 id="upload_errors/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">def error_to_string(:too_large), do: "Too large"
def error_to_string(:not_accepted), do: "You have selected an unacceptable file type"

&lt;%= for entry &lt;- @uploads.avatar.entries do %&gt;
  &lt;%= for err &lt;- upload_errors(@uploads.avatar, entry) do %&gt;
    &lt;div class="alert alert-danger"&gt;
      &lt;%= error_to_string(err) %&gt;
    &lt;/div&gt;
  &lt;% end %&gt;
&lt;% end %&gt;</pre> </section> </section> </div> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2018 Chris McCord<br>Licensed under the MIT License.<br>
    <a href="https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.Helpers.html" class="_attribution-link">https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.Helpers.html</a>
  </p>
</div>
