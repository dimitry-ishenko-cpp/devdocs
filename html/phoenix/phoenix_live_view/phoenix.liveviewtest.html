<h1>   <span translate="no">Phoenix.LiveViewTest</span>  </h1> <section id="moduledoc"> <p>Conveniences for testing Phoenix LiveViews.</p>
<p>In LiveView tests, we interact with views via process communication in substitution of a browser. Like a browser, our test process receives messages about the rendered updates from the view which can be asserted against to test the life-cycle and behavior of LiveViews and their children.</p>
<h2 id="module-liveview-testing" class="section-heading">  LiveView Testing </h2> <p>The life-cycle of a LiveView as outlined in the <a href="phoenix.liveview.html"><code class="inline">Phoenix.LiveView</code></a> docs details how a view starts as a stateless HTML render in a disconnected socket state. Once the browser receives the HTML, it connects to the server and a new LiveView process is started, remounted in a connected socket state, and the view continues statefully. The LiveView test functions support testing both disconnected and connected mounts separately, for example:</p>
<pre data-language="elixir">import Plug.Conn
import Phoenix.ConnTest
import Phoenix.LiveViewTest
@endpoint MyEndpoint

test "disconnected and connected mount", %{conn: conn} do
  conn = get(conn, "/my-path")
  assert html_response(conn, 200) =~ "&lt;h1&gt;My Disconnected View&lt;/h1&gt;"

  {:ok, view, html} = live(conn)
end

test "redirected mount", %{conn: conn} do
  assert {:error, {:redirect, %{to: "/somewhere"}}} = live(conn, "my-path")
end</pre>
<p>Here, we start by using the familiar <a href="https://hexdocs.pm/phoenix/1.6.6/Phoenix.ConnTest.html"><code class="inline">Phoenix.ConnTest</code></a> function, <code class="inline">get/2</code> to test the regular HTTP GET request which invokes mount with a disconnected socket. Next, <a href="#live/1"><code class="inline">live/1</code></a> is called with our sent connection to mount the view in a connected state, which starts our stateful LiveView process.</p>
<p>In general, it's often more convenient to test the mounting of a view in a single step, provided you don't need the result of the stateless HTTP render. This is done with a single call to <a href="#live/2"><code class="inline">live/2</code></a>, which performs the <code class="inline">get</code> step for us:</p>
<pre data-language="elixir">test "connected mount", %{conn: conn} do
  {:ok, _view, html} = live(conn, "/my-path")
  assert html =~ "&lt;h1&gt;My Connected View&lt;/h1&gt;"
end</pre>
<h3 id="module-testing-events" class="section-heading">  Testing Events </h3> <p>The browser can send a variety of events to a LiveView via <code class="inline">phx-</code> bindings, which are sent to the <code class="inline">handle_event/3</code> callback. To test events sent by the browser and assert on the rendered side effect of the event, use the <code class="inline">render_*</code> functions:</p>
<ul>
<li><p><a href="#render_click/1"><code class="inline">render_click/1</code></a> - sends a phx-click event and value, returning the rendered result of the <code class="inline">handle_event/3</code> callback.</p></li>
<li><p><a href="#render_focus/2"><code class="inline">render_focus/2</code></a> - sends a phx-focus event and value, returning the rendered result of the <code class="inline">handle_event/3</code> callback.</p></li>
<li><p><a href="#render_blur/1"><code class="inline">render_blur/1</code></a> - sends a phx-blur event and value, returning the rendered result of the <code class="inline">handle_event/3</code> callback.</p></li>
<li><p><a href="#render_submit/1"><code class="inline">render_submit/1</code></a> - sends a form phx-submit event and value, returning the rendered result of the <code class="inline">handle_event/3</code> callback.</p></li>
<li><p><a href="#render_change/1"><code class="inline">render_change/1</code></a> - sends a form phx-change event and value, returning the rendered result of the <code class="inline">handle_event/3</code> callback.</p></li>
<li><p><a href="#render_keydown/1"><code class="inline">render_keydown/1</code></a> - sends a form phx-keydown event and value, returning the rendered result of the <code class="inline">handle_event/3</code> callback.</p></li>
<li><p><a href="#render_keyup/1"><code class="inline">render_keyup/1</code></a> - sends a form phx-keyup event and value, returning the rendered result of the <code class="inline">handle_event/3</code> callback.</p></li>
<li><p><a href="#render_hook/3"><code class="inline">render_hook/3</code></a> - sends a hook event and value, returning the rendered result of the <code class="inline">handle_event/3</code> callback.</p></li>
</ul>
<p>For example:</p>
<pre data-language="elixir">{:ok, view, _html} = live(conn, "/thermo")

assert view
       |&gt; element("button#inc")
       |&gt; render_click() =~ "The temperature is: 31℉"</pre>
<p>In the example above, we are looking for a particular element on the page and triggering its phx-click event. LiveView takes care of making sure the element has a phx-click and automatically sends its values to the server.</p>
<p>You can also bypass the element lookup and directly trigger the LiveView event in most functions:</p>
<pre data-language="elixir">assert render_click(view, :inc, %{}) =~ "The temperature is: 31℉"</pre>
<p>The <code class="inline">element</code> style is preferred as much as possible, as it helps LiveView perform validations and ensure the events in the HTML actually matches the event names on the server.</p>
<h3 id="module-testing-regular-messages" class="section-heading">  Testing regular messages </h3> <p>LiveViews are <a href="https://hexdocs.pm/elixir/GenServer.html"><code class="inline">GenServer</code></a>'s under the hood, and can send and receive messages just like any other server. To test the side effects of sending or receiving messages, simply message the view and use the <code class="inline">render</code> function to test the result:</p>
<pre data-language="elixir">send(view.pid, {:set_temp, 50})
assert render(view) =~ "The temperature is: 50℉"</pre>
<h2 id="module-testing-function-components" class="section-heading">  Testing function components </h2> <p>There are two mechanisms for testing function components. Imagine the following component:</p>
<pre data-language="elixir">def greet(assigns) do
  ~H"""
  &lt;div&gt;Hello, &lt;%= @name %&gt;!&lt;/div&gt;
  """
end</pre>
<p>You can test it by using <a href="#render_component/3"><code class="inline">render_component/3</code></a>, passing the function reference to the component as first argument:</p>
<pre data-language="elixir">import Phoenix.LiveViewTest

test "greets" do
  assert render_component(&amp;MyComponents.greet/1, name: "Mary") ==
           "&lt;div&gt;Hello, Mary!&lt;/div&gt;"
end</pre>
<p>However, for complex components, often the simplest way to test them is by using the <code class="inline">~H</code> sigil itself:</p>
<pre data-language="elixir">import Phoenix.LiveView.Helpers
import Phoenix.LiveViewTest

test "greets" do
  assigns = []
  assert rendered_to_string(~H"""
         &lt;MyComponents.greet name="Mary" /&gt;
         """) ==
           "&lt;div&gt;Hello, Mary!&lt;/div&gt;"
end</pre>
<p>The difference is that we use <code class="inline">rendered_to_string</code> to convert the rendered template to a string for testing.</p>
<h2 id="module-testing-stateful-components" class="section-heading">  Testing stateful components </h2> <p>There are two main mechanisms for testing stateful components. You can use <a href="#render_component/2"><code class="inline">render_component/2</code></a> to test how a component is mounted and rendered once:</p>
<pre data-language="elixir">assert render_component(MyComponent, id: 123, user: %User{}) =~
         "some markup in component"</pre>
<p>However, if you want to test how components are mounted by a LiveView and interact with DOM events, you must use the regular <a href="#live/2"><code class="inline">live/2</code></a> macro to build the LiveView with the component and then scope events by passing the view and a <strong>DOM selector</strong> in a list:</p>
<pre data-language="elixir">{:ok, view, html} = live(conn, "/users")
html = view |&gt; element("#user-13 a", "Delete") |&gt; render_click()
refute html =~ "user-13"
refute view |&gt; element("#user-13") |&gt; has_element?()</pre>
<p>In the example above, LiveView will lookup for an element with ID=user-13 and retrieve its <code class="inline">phx-target</code>. If <code class="inline">phx-target</code> points to a component, that will be the component used, otherwise it will fallback to the view.</p> </section> <section id="summary" class="details-list"> <h1 class="section-heading">  Summary </h1> <h2> Functions </h2>
<dl class="summary-functions summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#assert_patch/2" translate="no">assert_patch(view, timeout \\ 100)</a> </dt> <dd class="summary-synopsis"><p>Asserts a live patch will happen within <code class="inline">timeout</code> milliseconds. The default <code class="inline">timeout</code> is 100.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#assert_patch/3" translate="no">assert_patch(view, to, timeout)</a> </dt> <dd class="summary-synopsis"><p>Asserts a live patch will happen to a given path within <code class="inline">timeout</code> milliseconds. The default <code class="inline">timeout</code> is 100.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#assert_patched/2" translate="no">assert_patched(view, to)</a> </dt> <dd class="summary-synopsis"><p>Asserts a live patch was performed, and returns the new path.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#assert_push_event/4" translate="no">assert_push_event(view, event, payload, timeout \\ 100)</a> </dt> <dd class="summary-synopsis"><p>Asserts an event will be pushed within <code class="inline">timeout</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#assert_redirect/2" translate="no">assert_redirect(view, timeout \\ 100)</a> </dt> <dd class="summary-synopsis"><p>Asserts a redirect will happen within <code class="inline">timeout</code> milliseconds. The default <code class="inline">timeout</code> is 100.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#assert_redirect/3" translate="no">assert_redirect(view, to, timeout)</a> </dt> <dd class="summary-synopsis"><p>Asserts a redirect will happen to a given path within <code class="inline">timeout</code> milliseconds. The default <code class="inline">timeout</code> is 100.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#assert_redirected/2" translate="no">assert_redirected(view, to)</a> </dt> <dd class="summary-synopsis"><p>Asserts a redirect was performed.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#assert_reply/3" translate="no">assert_reply(view, payload, timeout \\ 100)</a> </dt> <dd class="summary-synopsis"><p>Asserts a hook reply was returned from a <code class="inline">handle_event</code> callback.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#element/3" translate="no">element(view, selector, text_filter \\ nil)</a> </dt> <dd class="summary-synopsis"><p>Returns an element to scope a function to.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#file_input/4" translate="no">file_input(view, form_selector, name, entries)</a> </dt> <dd class="summary-synopsis"><p>Builds a file input for testing uploads within a form.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#find_live_child/2" translate="no">find_live_child(parent, child_id)</a> </dt> <dd class="summary-synopsis"><p>Gets the nested LiveView child by <code class="inline">child_id</code> from the <code class="inline">parent</code> LiveView.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#follow_redirect/3" translate="no">follow_redirect(reason, conn, to \\ nil)</a> </dt> <dd class="summary-synopsis"><p>Follows the redirect from a <code class="inline">render_*</code> action or an <code class="inline">{:error, redirect}</code> tuple.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#follow_trigger_action/2" translate="no">follow_trigger_action(form, conn)</a> </dt> <dd class="summary-synopsis"><p>Receives a <code class="inline">form_element</code> and asserts that <code class="inline">phx-trigger-action</code> has been set to true, following up on that request.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#form/3" translate="no">form(view, selector, form_data \\ %{})</a> </dt> <dd class="summary-synopsis"><p>Returns a form element to scope a function to.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#has_element?/1" translate="no">has_element?(element)</a> </dt> <dd class="summary-synopsis"><p>Checks if the given element exists on the page.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#has_element?/3" translate="no">has_element?(view, selector, text_filter \\ nil)</a> </dt> <dd class="summary-synopsis"><p>Checks if the given <code class="inline">selector</code> with <code class="inline">text_filter</code> is on <code class="inline">view</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#live/2" translate="no">live(conn, path \\ nil)</a> </dt> <dd class="summary-synopsis"><p>Spawns a connected LiveView process.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#live_children/1" translate="no">live_children(parent)</a> </dt> <dd class="summary-synopsis"><p>Returns the current list of LiveView children for the <code class="inline">parent</code> LiveView.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#live_isolated/3" translate="no">live_isolated(conn, live_view, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Spawns a connected LiveView process mounted in isolation as the sole rendered element.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#live_redirect/2" translate="no">live_redirect(view, opts)</a> </dt> <dd class="summary-synopsis"><p>Performs a live redirect from one LiveView to another.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#open_browser/2" translate="no">open_browser(view_or_element, open_fun \\ &amp;open_with_system_cmd/1)</a> </dt> <dd class="summary-synopsis"><p>Open the default browser to display current HTML of <code class="inline">view_or_element</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#page_title/1" translate="no">page_title(view)</a> </dt> <dd class="summary-synopsis"><p>Returns the most recent title that was updated via a <code class="inline">page_title</code> assign.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#preflight_upload/1" translate="no">preflight_upload(upload)</a> </dt> <dd class="summary-synopsis"><p>Performs a preflight upload request.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#put_connect_info/2" translate="no">put_connect_info(conn, params)</a> <span class="deprecated" title="set the relevant connect_info fields in the connection instead">deprecated</span> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#put_connect_params/2" translate="no">put_connect_params(conn, params)</a> </dt> <dd class="summary-synopsis"><p>Puts connect params to be used on LiveView connections.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#refute_redirected/2" translate="no">refute_redirected(view, to)</a> </dt> <dd class="summary-synopsis"><p>Refutes a redirect to a given path was performed.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render/1" translate="no">render(view_or_element)</a> </dt> <dd class="summary-synopsis"><p>Returns the HTML string of the rendered view or element.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render_blur/2" translate="no">render_blur(element, value \\ %{})</a> </dt> <dd class="summary-synopsis"><p>Sends a blur event given by <code class="inline">element</code> and returns the rendered result.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render_blur/3" translate="no">render_blur(view, event, value)</a> </dt> <dd class="summary-synopsis"><p>Sends a blur event to the view and returns the rendered result.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render_change/2" translate="no">render_change(element, value \\ %{})</a> </dt> <dd class="summary-synopsis"><p>Sends a form change event given by <code class="inline">element</code> and returns the rendered result.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render_change/3" translate="no">render_change(view, event, value)</a> </dt> <dd class="summary-synopsis"><p>Sends a form change event to the view and returns the rendered result.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render_click/2" translate="no">render_click(element, value \\ %{})</a> </dt> <dd class="summary-synopsis"><p>Sends a click event given by <code class="inline">element</code> and returns the rendered result.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render_click/3" translate="no">render_click(view, event, value)</a> </dt> <dd class="summary-synopsis"><p>Sends a click <code class="inline">event</code> to the <code class="inline">view</code> with <code class="inline">value</code> and returns the rendered result.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render_component/3" translate="no">render_component(component, assigns \\ Macro.escape(%{}), opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Renders a component.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render_focus/2" translate="no">render_focus(element, value \\ %{})</a> </dt> <dd class="summary-synopsis"><p>Sends a focus event given by <code class="inline">element</code> and returns the rendered result.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render_focus/3" translate="no">render_focus(view, event, value)</a> </dt> <dd class="summary-synopsis"><p>Sends a focus event to the view and returns the rendered result.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render_hook/3" translate="no">render_hook(view_or_element, event, value \\ %{})</a> </dt> <dd class="summary-synopsis"><p>Sends a hook event to the view or an element and returns the rendered result.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render_keydown/2" translate="no">render_keydown(element, value \\ %{})</a> </dt> <dd class="summary-synopsis"><p>Sends a keydown event given by <code class="inline">element</code> and returns the rendered result.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render_keydown/3" translate="no">render_keydown(view, event, value)</a> </dt> <dd class="summary-synopsis"><p>Sends a keydown event to the view and returns the rendered result.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render_keyup/2" translate="no">render_keyup(element, value \\ %{})</a> </dt> <dd class="summary-synopsis"><p>Sends a keyup event given by <code class="inline">element</code> and returns the rendered result.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render_keyup/3" translate="no">render_keyup(view, event, value)</a> </dt> <dd class="summary-synopsis"><p>Sends a keyup event to the view and returns the rendered result.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render_patch/2" translate="no">render_patch(view, path)</a> </dt> <dd class="summary-synopsis"><p>Simulates a <code class="inline">live_patch</code> to the given <code class="inline">path</code> and returns the rendered result.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render_submit/2" translate="no">render_submit(element, value \\ %{})</a> </dt> <dd class="summary-synopsis"><p>Sends a form submit event given by <code class="inline">element</code> and returns the rendered result.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render_submit/3" translate="no">render_submit(view, event, value)</a> </dt> <dd class="summary-synopsis"><p>Sends a form submit event to the view and returns the rendered result.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#render_upload/3" translate="no">render_upload(upload, entry_name, percent \\ 100)</a> </dt> <dd class="summary-synopsis"><p>Performs an upload of a file input and renders the result.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#rendered_to_string/1" translate="no">rendered_to_string(rendered)</a> </dt> <dd class="summary-synopsis"><p>Converts a rendered template to a string.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#with_target/2" translate="no">with_target(view, target)</a> </dt> <dd class="summary-synopsis"><p>Sets the target of the view for events.</p></dd> </div> </dl> </section> <section id="functions" class="details-list"> <h1 class="section-heading">  Functions </h1> <div class="functions-list"> <section class="detail">  <h3 class="detail-header" id="assert_patch/2">assert_patch(view, timeout \\ 100)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/test/live_view_test.ex#L1190" class="source">Source</a>
</h3> <section class="docstring"> <p>Asserts a live patch will happen within <code class="inline">timeout</code> milliseconds. The default <code class="inline">timeout</code> is 100.</p>
<p>It returns the new path.</p>
<p>To assert on the flash message, you can assert on the result of the rendered LiveView.</p>
<h4 id="assert_patch/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">render_click(view, :event_that_triggers_patch)
assert_patch view

render_click(view, :event_that_triggers_patch)
assert_patch view, 30

render_click(view, :event_that_triggers_patch)
path = assert_patch view
assert path =~ ~r/path/+/</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="assert_patch/3">assert_patch(view, to, timeout)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/test/live_view_test.ex#L1216" class="source">Source</a>
</h3> <section class="docstring"> <p>Asserts a live patch will happen to a given path within <code class="inline">timeout</code> milliseconds. The default <code class="inline">timeout</code> is 100.</p>
<p>It always returns <code class="inline">:ok</code>.</p>
<p>To assert on the flash message, you can assert on the result of the rendered LiveView.</p>
<h4 id="assert_patch/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">render_click(view, :event_that_triggers_patch)
assert_patch view, "/path"

render_click(view, :event_that_triggers_patch)
assert_patch view, "/path", 30</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="assert_patched/2">assert_patched(view, to)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/test/live_view_test.ex#L1234" class="source">Source</a>
</h3> <section class="docstring"> <p>Asserts a live patch was performed, and returns the new path.</p>
<p>To assert on the flash message, you can assert on the result of the rendered LiveView.</p>
<h4 id="assert_patched/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">render_click(view, :event_that_triggers_redirect)
assert_patched view, "/path"</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="assert_push_event/4">assert_push_event(view, event, payload, timeout \\ 100)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/test/live_view_test.ex#L1470" class="source">Source</a>
</h3> <section class="docstring"> <p>Asserts an event will be pushed within <code class="inline">timeout</code>.</p>
<h4 id="assert_push_event/4-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">assert_push_event view, "scores", %{points: 100, user: "josé"}</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="assert_redirect/2">assert_redirect(view, timeout \\ 100)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/test/live_view_test.ex#L1255" class="source">Source</a>
</h3> <section class="docstring"> <p>Asserts a redirect will happen within <code class="inline">timeout</code> milliseconds. The default <code class="inline">timeout</code> is 100.</p>
<p>It returns a tuple containing the new path and the flash messages from said redirect, if any. Note the flash will contain string keys.</p>
<h4 id="assert_redirect/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">render_click(view, :event_that_triggers_redirect)
{path, flash} = assert_redirect view
assert flash["info"] == "Welcome"
assert path =~ ~r/path\/\d+/

render_click(view, :event_that_triggers_redirect)
assert_redirect view, 30</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="assert_redirect/3">assert_redirect(view, to, timeout)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/test/live_view_test.ex#L1279" class="source">Source</a>
</h3> <section class="docstring"> <p>Asserts a redirect will happen to a given path within <code class="inline">timeout</code> milliseconds. The default <code class="inline">timeout</code> is 100.</p>
<p>It returns the flash messages from said redirect, if any. Note the flash will contain string keys.</p>
<h4 id="assert_redirect/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">render_click(view, :event_that_triggers_redirect)
flash = assert_redirect view, "/path"
assert flash["info"] == "Welcome"

render_click(view, :event_that_triggers_redirect)
assert_redirect view, "/path", 30</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="assert_redirected/2">assert_redirected(view, to)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/test/live_view_test.ex#L1298" class="source">Source</a>
</h3> <section class="docstring"> <p>Asserts a redirect was performed.</p>
<p>It returns the flash messages from said redirect, if any. Note the flash will contain string keys.</p>
<h4 id="assert_redirected/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">render_click(view, :event_that_triggers_redirect)
flash = assert_redirected view, "/path"
assert flash["info"] == "Welcome"</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="assert_reply/3">assert_reply(view, payload, timeout \\ 100)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/test/live_view_test.ex#L1485" class="source">Source</a>
</h3> <section class="docstring"> <p>Asserts a hook reply was returned from a <code class="inline">handle_event</code> callback.</p>
<h4 id="assert_reply/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">assert_reply view, %{result: "ok", transaction_id: _}</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="element/3">element(view, selector, text_filter \\ nil)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/test/live_view_test.ex#L1054" class="source">Source</a>
</h3> <section class="docstring"> <p>Returns an element to scope a function to.</p>
<p>It expects the current LiveView, a query selector, and a text filter.</p>
<p>An optional text filter may be given to filter the results by the query selector. If the text filter is a string or a regex, it will match any element that contains the string (including as a substring) or matches the regex.</p>
<p>So a link containing the text "unopened" will match <code class="inline">element("a", "opened")</code>. To prevent this, a regex could specify that "opened" appear without the prefix "un". For example, <code class="inline">element("a", ~r{(?&lt;!un)opened})</code>. But it may be clearer to add an HTML attribute to make the element easier to select.</p>
<p>After the text filter is applied, only one element must remain, otherwise an error is raised.</p>
<p>If no text filter is given, then the query selector itself must return a single element.</p>
<pre data-language="elixir">assert view
      |&gt; element("#term a:first-child", "Increment")
      |&gt; render() =~ "Increment&lt;/a&gt;"</pre>
<p>Attribute selectors are also supported, and may be used on special cases like ids which contain periods:</p>
<pre data-language="elixir">assert view
       |&gt; element(~s{[href="/foo.html"][id="foo.bar.baz"]})
       |&gt; render() =~ "Increment&lt;/a&gt;"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="file_input/4">file_input(view, form_selector, name, entries)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/test/live_view_test.ex#L1108" class="source">Source</a>
</h3> <section class="docstring"> <p>Builds a file input for testing uploads within a form.</p>
<p>Given the form DOM selector, the upload name, and a list of maps of client metadata for the upload, the returned file input can be passed to <a href="#render_upload/2"><code class="inline">render_upload/2</code></a>.</p>
<p>Client metadata takes the following form:</p>
<ul>
<li>
<code class="inline">:last_modified</code> - the last modified timestamp</li>
<li>
<code class="inline">:name</code> - the name of the file</li>
<li>
<code class="inline">:content</code> - the binary content of the file</li>
<li>
<code class="inline">:size</code> - the byte size of the content</li>
<li>
<code class="inline">:type</code> - the MIME type of the file</li>
</ul>
<h4 id="file_input/4-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">avatar = file_input(lv, "#my-form-id", :avatar, [%{
  last_modified: 1_594_171_879_000,
  name: "myfile.jpeg",
  content: File.read!("myfile.jpg"),
  size: 1_396_009,
  type: "image/jpeg"
}])

assert render_upload(avatar, "myfile.jpeg") =~ "100%"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="find_live_child/2">find_live_child(parent, child_id)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/test/live_view_test.ex#L922" class="source">Source</a>
</h3> <section class="docstring"> <p>Gets the nested LiveView child by <code class="inline">child_id</code> from the <code class="inline">parent</code> LiveView.</p>
<h4 id="find_live_child/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, _html} = live(conn, "/thermo")
assert clock_view = find_live_child(view, "clock")
assert render_click(clock_view, :snooze) =~ "snoozing"</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="follow_redirect/3">follow_redirect(reason, conn, to \\ nil)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/test/live_view_test.ex#L1528" class="source">Source</a>
</h3> <section class="docstring"> <p>Follows the redirect from a <code class="inline">render_*</code> action or an <code class="inline">{:error, redirect}</code> tuple.</p>
<p>Imagine you have a LiveView that redirects on a <code class="inline">render_click</code> event. You can make sure it immediately redirects after the <code class="inline">render_click</code> action by calling <a href="#follow_redirect/3"><code class="inline">follow_redirect/3</code></a>:</p>
<pre data-language="elixir">live_view
|&gt; render_click("redirect")
|&gt; follow_redirect(conn)</pre>
<p>Or in the case of an error tuple:</p>
<pre data-language="elixir">assert {:error, {:redirect, %{to: "/somewhere"}}} = result = live(conn, "my-path")
{:ok, view, html} = follow_redirect(result, conn)</pre>
<p><a href="#follow_redirect/3"><code class="inline">follow_redirect/3</code></a> expects a connection as second argument. This is the connection that will be used to perform the underlying request.</p>
<p>If the LiveView redirects with a live redirect, this macro returns <code class="inline">{:ok, live_view, disconnected_html}</code> with the content of the new LiveView, the same as the <code class="inline">live/3</code> macro. If the LiveView redirects with a regular redirect, this macro returns <code class="inline">{:ok, conn}</code> with the rendered redirected page. In any other case, this macro raises.</p>
<p>Finally, note that you can optionally assert on the path you are being redirected to by passing a third argument:</p>
<pre data-language="elixir">live_view
|&gt; render_click("redirect")
|&gt; follow_redirect(conn, "/redirected/page")</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="follow_trigger_action/2">follow_trigger_action(form, conn)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/test/live_view_test.ex#L1649" class="source">Source</a>
</h3> <section class="docstring"> <p>Receives a <code class="inline">form_element</code> and asserts that <code class="inline">phx-trigger-action</code> has been set to true, following up on that request.</p>
<p>Imagine you have a LiveView that sends an HTTP form submission. Say that it sets the <code class="inline">phx-trigger-action</code> to true, as a response to a submit event. You can follow the trigger action like this:</p>
<pre data-language="elixir">form = form(live_view, selector, %{"form" =&gt; "data"})

# First we submit the form. Optionally verify that phx-trigger-action
# is now part of the form.
assert render_submit(form) =~ ~r/phx-trigger-action/

# Now follow the request made by the form
conn = follow_trigger_action(form, conn)
assert conn.method == "POST"
assert conn.params == %{"form" =&gt; "data"}</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="form/3">form(view, selector, form_data \\ %{})<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/test/live_view_test.ex#L1078" class="source">Source</a>
</h3> <section class="docstring"> <p>Returns a form element to scope a function to.</p>
<p>It expects the current LiveView, a query selector, and the form data. The query selector must return a single element.</p>
<p>The form data will be validated directly against the form markup and make sure the data you are changing/submitting actually exists, failing otherwise.</p>
<h4 id="form/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">assert view
      |&gt; form("#term", user: %{name: "hello"})
      |&gt; render_submit() =~ "Name updated"</pre>
<p>This function is meant to mimic what the user can actually do, so you cannot set hidden input values. However, hidden values can be given when calling <a href="#render_submit/2"><code class="inline">render_submit/2</code></a> or <a href="#render_change/2"><code class="inline">render_change/2</code></a>, see their docs for examples.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="has_element?/1">has_element?(element)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/test/live_view_test.ex#L936" class="source">Source</a>
</h3> <section class="docstring"> <p>Checks if the given element exists on the page.</p>
<h4 id="has_element?/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">assert view |&gt; element("#some-element") |&gt; has_element?()</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="has_element?/3">has_element?(view, selector, text_filter \\ nil)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/test/live_view_test.ex#L950" class="source">Source</a>
</h3> <section class="docstring"> <p>Checks if the given <code class="inline">selector</code> with <code class="inline">text_filter</code> is on <code class="inline">view</code>.</p>
<p>See <a href="#element/3"><code class="inline">element/3</code></a> for more information.</p>
<h4 id="has_element?/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">assert has_element?(view, "#some-element")</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="live/2">live(conn, path \\ nil)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/test/live_view_test.ex#L216" class="source">Source</a>
</h3> <section class="docstring"> <p>Spawns a connected LiveView process.</p>
<p>If a <code class="inline">path</code> is given, then a regular <code class="inline">get(conn, path)</code> is done and the page is upgraded to a <code class="inline">LiveView</code>. If no path is given, it assumes a previously rendered <code class="inline">%Plug.Conn{}</code> is given, which will be converted to a <code class="inline">LiveView</code> immediately.</p>
<h4 id="live/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, html} = live(conn, "/path")
assert view.module == MyLive
assert html =~ "the count is 3"

assert {:error, {:redirect, %{to: "/somewhere"}}} = live(conn, "/path")</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="live_children/1">live_children(parent)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/test/live_view_test.ex#L909" class="source">Source</a>
</h3> <section class="docstring"> <p>Returns the current list of LiveView children for the <code class="inline">parent</code> LiveView.</p>
<p>Children are returned in the order they appear in the rendered HTML.</p>
<h4 id="live_children/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, _html} = live(conn, "/thermo")
assert [clock_view] = live_children(view)
assert render_click(clock_view, :snooze) =~ "snoozing"</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="live_isolated/3">live_isolated(conn, live_view, opts \\ [])<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/test/live_view_test.ex#L262" class="source">Source</a>
</h3> <section class="docstring"> <p>Spawns a connected LiveView process mounted in isolation as the sole rendered element.</p>
<p>Useful for testing LiveViews that are not directly routable, such as those built as small components to be re-used in multiple parents. Testing routable LiveViews is still recommended whenever possible since features such as live navigation require routable LiveViews.</p>
<h4 id="live_isolated/3-options" class="section-heading">  Options </h4> <ul><li>
<code class="inline">:session</code> - the session to be given to the LiveView</li></ul>
<p>All other options are forwarded to the LiveView for rendering. Refer to <a href="phoenix.liveview.helpers.html#live_render/3"><code class="inline">Phoenix.LiveView.Helpers.live_render/3</code></a> for a list of supported render options.</p>
<h4 id="live_isolated/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, html} =
  live_isolated(conn, MyAppWeb.ClockLive, session: %{"tz" =&gt; "EST"})</pre>
<p>Use <a href="#put_connect_params/2"><code class="inline">put_connect_params/2</code></a> to put connect params for a call to <a href="phoenix.liveview.html#get_connect_params/1"><code class="inline">Phoenix.LiveView.get_connect_params/1</code></a> in <a href="phoenix.liveview.html#c:mount/3"><code class="inline">Phoenix.LiveView.mount/3</code></a>:</p>
<pre data-language="elixir">{:ok, view, html} =
  conn
  |&gt; put_connect_params(%{"param" =&gt; "value"})
  |&gt; live_isolated(AppWeb.ClockLive, session: %{"tz" =&gt; "EST"})</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="live_redirect/2">live_redirect(view, opts)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/test/live_view_test.ex#L1586" class="source">Source</a>
</h3> <section class="docstring"> <p>Performs a live redirect from one LiveView to another.</p>
<p>When redirecting between two LiveViews of the same <code class="inline">live_session</code>, mounts the new LiveView and shutsdown the previous one, which mimics general browser live navigation behaviour.</p>
<p>When attempting to navigate from a LiveView of a different <code class="inline">live_session</code>, an error redirect condition is returned indicating a failed <code class="inline">live_redirect</code> from the client.</p>
<h4 id="live_redirect/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">assert {:ok, page_live, _html} = live(conn, "/page/1")
assert {:ok, page2_live, _html} = live(conn, "/page/2")

assert {:error, {:redirect, _}} = live_redirect(page2_live, to: "/admin")</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="open_browser/2">open_browser(view_or_element, open_fun \\ &amp;open_with_system_cmd/1)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/test/live_view_test.ex#L1378" class="source">Source</a>
</h3> <section class="docstring"> <p>Open the default browser to display current HTML of <code class="inline">view_or_element</code>.</p>
<h4 id="open_browser/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">view
|&gt; element("#term a:first-child", "Increment")
|&gt; open_browser()

assert view
       |&gt; form("#term", user: %{name: "hello"})
       |&gt; open_browser()
       |&gt; render_submit() =~ "Name updated"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="page_title/1">page_title(view)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/test/live_view_test.ex#L1165" class="source">Source</a>
</h3> <section class="docstring"> <p>Returns the most recent title that was updated via a <code class="inline">page_title</code> assign.</p>
<h4 id="page_title/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">render_click(view, :event_that_triggers_page_title_update)
assert page_title(view) =~ "my title"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="preflight_upload/1">preflight_upload(upload)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/test/live_view_test.ex#L1740" class="source">Source</a>
</h3> <section class="docstring"> <p>Performs a preflight upload request.</p>
<p>Useful for testing external uploaders to retrieve the <code class="inline">:external</code> entry metadata.</p>
<h4 id="preflight_upload/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">avatar = file_input(lv, "#my-form-id", :avatar, [%{name: ..., ...}, ...])
assert {:ok, %{ref: _ref, config: %{chunk_size: _}}} = preflight_upload(avatar)</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="put_connect_info/2">put_connect_info(conn, params)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/test/live_view_test.ex#L194" class="source">Source</a>
</h3> <div class="deprecated"> This function is deprecated. set the relevant connect_info fields in the connection instead. </div>  </section> <section class="detail"> <h3 class="detail-header" id="put_connect_params/2">put_connect_params(conn, params)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/test/live_view_test.ex#L189" class="source">Source</a>
</h3> <section class="docstring"> <p>Puts connect params to be used on LiveView connections.</p>
<p>See <a href="phoenix.liveview.html#get_connect_params/1"><code class="inline">Phoenix.LiveView.get_connect_params/1</code></a>.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="refute_redirected/2">refute_redirected(view, to)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/test/live_view_test.ex#L1334" class="source">Source</a>
</h3> <section class="docstring"> <p>Refutes a redirect to a given path was performed.</p>
<p>It returns :ok if the specified redirect isn't already in the mailbox.</p>
<h4 id="refute_redirected/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">render_click(view, :event_that_triggers_redirect_to_path)
:ok = refute_redirected view, "/wrong_path"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="render/1">render(view_or_element)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/test/live_view_test.ex#L970" class="source">Source</a>
</h3> <section class="docstring"> <p>Returns the HTML string of the rendered view or element.</p>
<p>If a view is provided, the entire LiveView is rendered. If a view after calling <a href="#with_target/2"><code class="inline">with_target/2</code></a> or an element are given, only that particular context is returned.</p>
<h4 id="render/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, _html} = live(conn, "/thermo")
assert render(view) =~ ~s|&lt;button id="alarm"&gt;Snooze&lt;/div&gt;|

assert view
       |&gt; element("#alarm")
       |&gt; render() == "Snooze"</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="render_blur/2">render_blur(element, value \\ %{})<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/test/live_view_test.ex#L788" class="source">Source</a>
</h3> <section class="docstring"> <p>Sends a blur event given by <code class="inline">element</code> and returns the rendered result.</p>
<p>The <code class="inline">element</code> is created with <a href="#element/3"><code class="inline">element/3</code></a> and must point to a single element on the page with a <code class="inline">phx-blur</code> attribute in it. The event name given set on <code class="inline">phx-blur</code> is then sent to the appropriate LiveView (or component if <code class="inline">phx-target</code> is set accordingly). All <code class="inline">phx-value-*</code> entries in the element are sent as values. Extra values can be given with the <code class="inline">value</code> argument.</p>
<p>It returns the contents of the whole LiveView or an <code class="inline">{:error, redirect}</code> tuple.</p>
<h4 id="render_blur/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, html} = live(conn, "/thermo")

assert view
       |&gt; element("#inactive")
       |&gt; render_blur() =~ "Tap to wake"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="render_blur/3">render_blur(view, event, value)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/test/live_view_test.ex#L805" class="source">Source</a>
</h3> <section class="docstring"> <p>Sends a blur event to the view and returns the rendered result.</p>
<p>It returns the contents of the whole LiveView or an <code class="inline">{:error, redirect}</code> tuple.</p>
<h4 id="render_blur/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, html} = live(conn, "/thermo")
assert html =~ "The temp is: 30℉"
assert render_blur(view, :inactive) =~ "Tap to wake"</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="render_change/2">render_change(element, value \\ %{})<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/test/live_view_test.ex#L662" class="source">Source</a>
</h3> <section class="docstring"> <p>Sends a form change event given by <code class="inline">element</code> and returns the rendered result.</p>
<p>The <code class="inline">element</code> is created with <a href="#element/3"><code class="inline">element/3</code></a> and must point to a single element on the page with a <code class="inline">phx-change</code> attribute in it. The event name given set on <code class="inline">phx-change</code> is then sent to the appropriate LiveView (or component if <code class="inline">phx-target</code> is set accordingly). All <code class="inline">phx-value-*</code> entries in the element are sent as values.</p>
<p>If you need to pass any extra values or metadata, such as the "_target" parameter, you can do so by giving a map under the <code class="inline">value</code> argument.</p>
<p>It returns the contents of the whole LiveView or an <code class="inline">{:error, redirect}</code> tuple.</p>
<h4 id="render_change/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, html} = live(conn, "/thermo")

assert view
       |&gt; element("form")
       |&gt; render_change(%{deg: 123}) =~ "123 exceeds limits"

# Passing metadata
{:ok, view, html} = live(conn, "/thermo")

assert view
       |&gt; element("form")
       |&gt; render_change(%{_target: ["deg"], deg: 123}) =~ "123 exceeds limits"</pre>
<p>As with <a href="#render_submit/2"><code class="inline">render_submit/2</code></a>, hidden input field values can be provided like so:</p>
<pre data-language="elixir">refute view
      |&gt; form("#term", user: %{name: "hello"})
      |&gt; render_change(%{user: %{"hidden_field" =&gt; "example"}}) =~ "can't be blank"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="render_change/3">render_change(view, event, value)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/test/live_view_test.ex#L678" class="source">Source</a>
</h3> <section class="docstring"> <p>Sends a form change event to the view and returns the rendered result.</p>
<p>It returns the contents of the whole LiveView or an <code class="inline">{:error, redirect}</code> tuple.</p>
<h4 id="render_change/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, html} = live(conn, "/thermo")
assert html =~ "The temp is: 30℉"
assert render_change(view, :validate, %{deg: 123}) =~ "123 exceeds limits"</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="render_click/2">render_click(element, value \\ %{})<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/test/live_view_test.ex#L556" class="source">Source</a>
</h3> <section class="docstring"> <p>Sends a click event given by <code class="inline">element</code> and returns the rendered result.</p>
<p>The <code class="inline">element</code> is created with <a href="#element/3"><code class="inline">element/3</code></a> and must point to a single element on the page with a <code class="inline">phx-click</code> attribute in it. The event name given set on <code class="inline">phx-click</code> is then sent to the appropriate LiveView (or component if <code class="inline">phx-target</code> is set accordingly). All <code class="inline">phx-value-*</code> entries in the element are sent as values. Extra values can be given with the <code class="inline">value</code> argument.</p>
<p>If the element is does not have a <code class="inline">phx-click</code> attribute but it is a link (the <code class="inline">&lt;a&gt;</code> tag), the link will be followed accordingly:</p>
<ul>
<li>if the link is a <code class="inline">live_patch</code>, the current view will be patched</li>
<li>if the link is a <code class="inline">live_redirect</code>, this function will return <code class="inline">{:error, {:live_redirect, %{to: url}}}</code>, which can be followed with <a href="#follow_redirect/2"><code class="inline">follow_redirect/2</code></a>
</li>
<li>if the link is a regular link, this function will return <code class="inline">{:error, {:redirect, %{to: url}}}</code>, which can be followed with <a href="#follow_redirect/2"><code class="inline">follow_redirect/2</code></a>
</li>
</ul>
<p>It returns the contents of the whole LiveView or an <code class="inline">{:error, redirect}</code> tuple.</p>
<h4 id="render_click/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, html} = live(conn, "/thermo")

assert view
       |&gt; element("button", "Increment")
       |&gt; render_click() =~ "The temperature is: 30℉"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="render_click/3">render_click(view, event, value)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/test/live_view_test.ex#L573" class="source">Source</a>
</h3> <section class="docstring"> <p>Sends a click <code class="inline">event</code> to the <code class="inline">view</code> with <code class="inline">value</code> and returns the rendered result.</p>
<p>It returns the contents of the whole LiveView or an <code class="inline">{:error, redirect}</code> tuple.</p>
<h4 id="render_click/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, html} = live(conn, "/thermo")
assert html =~ "The temperature is: 30℉"
assert render_click(view, :inc) =~ "The temperature is: 31℉"</pre> </section> </section> <section class="detail">   <h3 class="detail-header" id="render_component/3">render_component(component, assigns \\ Macro.escape(%{}), opts \\ [])<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/test/live_view_test.ex#L458" class="source">Source</a>
</h3> <section class="docstring"> <p>Renders a component.</p>
<p>The first argument may either be a function component, as an anonymous function:</p>
<pre data-language="elixir">assert render_component(&amp;Weather.city/1, name: "Kraków") =~
         "some markup in component"</pre>
<p>Or a stateful component as a module. In this case, this function will mount, update, and render the component. The <code class="inline">:id</code> option is a required argument:</p>
<pre data-language="elixir">assert render_component(MyComponent, id: 123, user: %User{}) =~
         "some markup in component"</pre>
<p>If your component is using the router, you can pass it as argument:</p>
<pre data-language="elixir">assert render_component(MyComponent, %{id: 123, user: %User{}}, router: SomeRouter) =~
         "some markup in component"</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="render_focus/2">render_focus(element, value \\ %{})<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/test/live_view_test.ex#L830" class="source">Source</a>
</h3> <section class="docstring"> <p>Sends a focus event given by <code class="inline">element</code> and returns the rendered result.</p>
<p>The <code class="inline">element</code> is created with <a href="#element/3"><code class="inline">element/3</code></a> and must point to a single element on the page with a <code class="inline">phx-focus</code> attribute in it. The event name given set on <code class="inline">phx-focus</code> is then sent to the appropriate LiveView (or component if <code class="inline">phx-target</code> is set accordingly). All <code class="inline">phx-value-*</code> entries in the element are sent as values. Extra values can be given with the <code class="inline">value</code> argument.</p>
<p>It returns the contents of the whole LiveView or an <code class="inline">{:error, redirect}</code> tuple.</p>
<h4 id="render_focus/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, html} = live(conn, "/thermo")

assert view
       |&gt; element("#inactive")
       |&gt; render_focus() =~ "Tap to wake"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="render_focus/3">render_focus(view, event, value)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/test/live_view_test.ex#L847" class="source">Source</a>
</h3> <section class="docstring"> <p>Sends a focus event to the view and returns the rendered result.</p>
<p>It returns the contents of the whole LiveView or an <code class="inline">{:error, redirect}</code> tuple.</p>
<h4 id="render_focus/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, html} = live(conn, "/thermo")
assert html =~ "The temp is: 30℉"
assert render_focus(view, :inactive) =~ "Tap to wake"</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="render_hook/3">render_hook(view_or_element, event, value \\ %{})<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/test/live_view_test.ex#L873" class="source">Source</a>
</h3> <section class="docstring"> <p>Sends a hook event to the view or an element and returns the rendered result.</p>
<p>It returns the contents of the whole LiveView or an <code class="inline">{:error, redirect}</code> tuple.</p>
<h4 id="render_hook/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, html} = live(conn, "/thermo")
assert html =~ "The temp is: 30℉"
assert render_hook(view, :refresh, %{deg: 32}) =~ "The temp is: 32℉"</pre>
<p>If you are pushing events from a hook to a component, then you must pass an <code class="inline">element</code>, created with <a href="#element/3"><code class="inline">element/3</code></a>, as first argument and it must point to a single element on the page with a <code class="inline">phx-target</code> attribute in it:</p>
<pre data-language="elixir">{:ok, view, _html} = live(conn, "/thermo")
assert view
       |&gt; element("#thermo-component")
       |&gt; render_hook(:refresh, %{deg: 32}) =~ "The temp is: 32℉"</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="render_keydown/2">render_keydown(element, value \\ %{})<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/test/live_view_test.ex#L702" class="source">Source</a>
</h3> <section class="docstring"> <p>Sends a keydown event given by <code class="inline">element</code> and returns the rendered result.</p>
<p>The <code class="inline">element</code> is created with <a href="#element/3"><code class="inline">element/3</code></a> and must point to a single element on the page with a <code class="inline">phx-keydown</code> or <code class="inline">phx-window-keydown</code> attribute in it. The event name given set on <code class="inline">phx-keydown</code> is then sent to the appropriate LiveView (or component if <code class="inline">phx-target</code> is set accordingly). All <code class="inline">phx-value-*</code> entries in the element are sent as values. Extra values can be given with the <code class="inline">value</code> argument.</p>
<p>It returns the contents of the whole LiveView or an <code class="inline">{:error, redirect}</code> tuple.</p>
<h4 id="render_keydown/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, html} = live(conn, "/thermo")
assert html =~ "The temp is: 30℉"
assert view |&gt; element("#inc") |&gt; render_keydown() =~ "The temp is: 31℉"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="render_keydown/3">render_keydown(view, event, value)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/test/live_view_test.ex#L722" class="source">Source</a>
</h3> <section class="docstring"> <p>Sends a keydown event to the view and returns the rendered result.</p>
<p>It returns the contents of the whole LiveView or an <code class="inline">{:error, redirect}</code> tuple.</p>
<h4 id="render_keydown/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, html} = live(conn, "/thermo")
assert html =~ "The temp is: 30℉"
assert render_keydown(view, :inc) =~ "The temp is: 31℉"</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="render_keyup/2">render_keyup(element, value \\ %{})<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/test/live_view_test.ex#L746" class="source">Source</a>
</h3> <section class="docstring"> <p>Sends a keyup event given by <code class="inline">element</code> and returns the rendered result.</p>
<p>The <code class="inline">element</code> is created with <a href="#element/3"><code class="inline">element/3</code></a> and must point to a single element on the page with a <code class="inline">phx-keyup</code> or <code class="inline">phx-window-keyup</code> attribute in it. The event name given set on <code class="inline">phx-keyup</code> is then sent to the appropriate LiveView (or component if <code class="inline">phx-target</code> is set accordingly). All <code class="inline">phx-value-*</code> entries in the element are sent as values. Extra values can be given with the <code class="inline">value</code> argument.</p>
<p>It returns the contents of the whole LiveView or an <code class="inline">{:error, redirect}</code> tuple.</p>
<h4 id="render_keyup/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, html} = live(conn, "/thermo")
assert html =~ "The temp is: 30℉"
assert view |&gt; element("#inc") |&gt; render_keyup() =~ "The temp is: 31℉"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="render_keyup/3">render_keyup(view, event, value)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/test/live_view_test.ex#L763" class="source">Source</a>
</h3> <section class="docstring"> <p>Sends a keyup event to the view and returns the rendered result.</p>
<p>It returns the contents of the whole LiveView or an <code class="inline">{:error, redirect}</code> tuple.</p>
<h4 id="render_keyup/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, html} = live(conn, "/thermo")
assert html =~ "The temp is: 30℉"
assert render_keyup(view, :inc) =~ "The temp is: 31℉"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="render_patch/2">render_patch(view, path)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/test/live_view_test.ex#L894" class="source">Source</a>
</h3> <section class="docstring"> <p>Simulates a <code class="inline">live_patch</code> to the given <code class="inline">path</code> and returns the rendered result.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="render_submit/2">render_submit(element, value \\ %{})<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/test/live_view_test.ex#L605" class="source">Source</a>
</h3> <section class="docstring"> <p>Sends a form submit event given by <code class="inline">element</code> and returns the rendered result.</p>
<p>The <code class="inline">element</code> is created with <a href="#element/3"><code class="inline">element/3</code></a> and must point to a single element on the page with a <code class="inline">phx-submit</code> attribute in it. The event name given set on <code class="inline">phx-submit</code> is then sent to the appropriate LiveView (or component if <code class="inline">phx-target</code> is set accordingly). All <code class="inline">phx-value-*</code> entries in the element are sent as values. Extra values, including hidden input fields, can be given with the <code class="inline">value</code> argument.</p>
<p>It returns the contents of the whole LiveView or an <code class="inline">{:error, redirect}</code> tuple.</p>
<h4 id="render_submit/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, html} = live(conn, "/thermo")

assert view
       |&gt; element("form")
       |&gt; render_submit(%{deg: 123, avatar: upload}) =~ "123 exceeds limits"</pre>
<p>To submit a form along with some with hidden input values:</p>
<pre data-language="elixir">assert view
      |&gt; form("#term", user: %{name: "hello"})
      |&gt; render_submit(%{user: %{"hidden_field" =&gt; "example"}}) =~ "Name updated"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="render_submit/3">render_submit(view, event, value)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/test/live_view_test.ex#L621" class="source">Source</a>
</h3> <section class="docstring"> <p>Sends a form submit event to the view and returns the rendered result.</p>
<p>It returns the contents of the whole LiveView or an <code class="inline">{:error, redirect}</code> tuple.</p>
<h4 id="render_submit/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, view, html} = live(conn, "/thermo")
assert html =~ "The temp is: 30℉"
assert render_submit(view, :refresh, %{deg: 32}) =~ "The temp is: 32℉"</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="render_upload/3">render_upload(upload, entry_name, percent \\ 100)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/test/live_view_test.ex#L1713" class="source">Source</a>
</h3> <section class="docstring"> <p>Performs an upload of a file input and renders the result.</p>
<p>See <a href="#file_input/4"><code class="inline">file_input/4</code></a> for details on building a file input.</p>
<h4 id="render_upload/3-examples" class="section-heading">  Examples </h4> <p>Given the following LiveView template:</p>
<pre data-language="elixir">&lt;%= for entry &lt;- @uploads.avatar.entries do %&gt;
    &lt;%= entry.name %&gt;: &lt;%= entry.progress %&gt;%
&lt;% end %&gt;</pre>
<p>Your test case can assert the uploaded content:</p>
<pre data-language="elixir">avatar = file_input(lv, "#my-form-id", :avatar, [
  %{
    last_modified: 1_594_171_879_000,
    name: "myfile.jpeg",
    content: File.read!("myfile.jpg"),
    size: 1_396_009,
    type: "image/jpeg"
  }
])

assert render_upload(avatar, "myfile.jpeg") =~ "100%"</pre>
<p>By default, the entire file is chunked to the server, but an optional percentage to chunk can be passed to test chunk-by-chunk uploads:</p>
<pre data-language="elixir">assert render_upload(avatar, "myfile.jpeg", 49) =~ "49%"
assert render_upload(avatar, "myfile.jpeg", 51) =~ "100%"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="rendered_to_string/1">rendered_to_string(rendered)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/test/live_view_test.ex#L518" class="source">Source</a>
</h3> <section class="docstring"> <p>Converts a rendered template to a string.</p>
<h4 id="rendered_to_string/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; import Phoenix.LiveView.Helpers
iex&gt; assigns = []
iex&gt; ~H"""
...&gt; &lt;div&gt;example&lt;/div&gt;
...&gt; """
...&gt; |&gt; rendered_to_string()
"&lt;div&gt;example&lt;/div&gt;"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="with_target/2">with_target(view, target)<a href="https://github.com/phoenixframework/phoenix_live_view/blob/v0.17.11/lib/phoenix_live_view/test/live_view_test.ex#L989" class="source">Source</a>
</h3> <section class="docstring"> <p>Sets the target of the view for events.</p>
<p>This emulates <code class="inline">phx-target</code> directly in tests, without having to dispatch the event to a specific element. This can be useful for invoking events to one or multiple components at the same time:</p>
<pre data-language="elixir">view
|&gt; with_target("#user-1,#user-2")
|&gt; render_click("Hide", %{})</pre> </section> </section> </div> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2018 Chris McCord<br>Licensed under the MIT License.<br>
    <a href="https://hexdocs.pm/phoenix_live_view/Phoenix.LiveViewTest.html" class="_attribution-link">https://hexdocs.pm/phoenix_live_view/Phoenix.LiveViewTest.html</a>
  </p>
</div>
