<h1>   <span translate="no">Phoenix.Endpoint</span> <small>behaviour</small>  </h1> <section id="moduledoc"> <p>Defines a Phoenix endpoint.</p>
<p>The endpoint is the boundary where all requests to your web application start. It is also the interface your application provides to the underlying web servers.</p>
<p>Overall, an endpoint has three responsibilities:</p>
<ul>
<li><p>to provide a wrapper for starting and stopping the endpoint as part of a supervision tree</p></li>
<li><p>to define an initial plug pipeline for requests to pass through</p></li>
<li><p>to host web specific configuration for your application</p></li>
</ul>
<h2 id="module-endpoints" class="section-heading">  Endpoints </h2> <p>An endpoint is simply a module defined with the help of <a href="phoenix.endpoint.html#content"><code class="inline">Phoenix.Endpoint</code></a>. If you have used the <a href="mix.tasks.phx.new.html"><code class="inline">mix phx.new</code></a> generator, an endpoint was automatically generated as part of your application:</p>
<pre data-language="elixir">defmodule YourAppWeb.Endpoint do
  use Phoenix.Endpoint, otp_app: :your_app

  # plug ...
  # plug ...

  plug YourApp.Router
end</pre>
<p>Endpoints must be explicitly started as part of your application supervision tree. Endpoints are added by default to the supervision tree in generated applications. Endpoints can be added to the supervision tree as follows:</p>
<pre data-language="elixir">children = [
  YourAppWeb.Endpoint
]</pre>
<h2 id="module-endpoint-configuration" class="section-heading">  Endpoint configuration </h2> <p>All endpoints are configured in your application environment. For example:</p>
<pre data-language="elixir">config :your_app, YourAppWeb.Endpoint,
  secret_key_base: "kjoy3o1zeidquwy1398juxzldjlksahdk3"</pre>
<p>Endpoint configuration is split into two categories. Compile-time configuration means the configuration is read during compilation and changing it at runtime has no effect. The compile-time configuration is mostly related to error handling.</p>
<p>Runtime configuration, instead, is accessed during or after your application is started and can be read through the <a href="#c:config/2"><code class="inline">config/2</code></a> function:</p>
<pre data-language="elixir">YourAppWeb.Endpoint.config(:port)
YourAppWeb.Endpoint.config(:some_config, :default_value)</pre>
<h3 id="module-dynamic-configuration" class="section-heading">  Dynamic configuration </h3> <p>For dynamically configuring the endpoint, such as loading data from environment variables or configuration files, Phoenix invokes the <a href="#c:init/2"><code class="inline">init/2</code></a> callback on the endpoint, passing the atom <code class="inline">:supervisor</code> as the first argument and the endpoint configuration as second.</p>
<p>All of Phoenix configuration, except the Compile-time configuration below can be set dynamically from the <a href="#c:init/2"><code class="inline">init/2</code></a> callback.</p>
<h3 id="module-compile-time-configuration" class="section-heading">  Compile-time configuration </h3> <ul>
<li><p><code class="inline">:code_reloader</code> - when <code class="inline">true</code>, enables code reloading functionality. For the list of code reloader configuration options see <a href="phoenix.codereloader.html#reload/1"><code class="inline">Phoenix.CodeReloader.reload/1</code></a>. Keep in mind code reloading is based on the file-system, therefore it is not possible to run two instances of the same app at the same time with code reloading in development, as they will race each other and only one will effectively recompile the files. In such cases, tweak your config files so code reloading is enabled in only one of the apps or set the MIX_BUILD environment variable to give them distinct build directories</p></li>
<li><p><code class="inline">:debug_errors</code> - when <code class="inline">true</code>, uses <a href="https://hexdocs.pm/plug/1.13.6/Plug.Debugger.html"><code class="inline">Plug.Debugger</code></a> functionality for debugging failures in the application. Recommended to be set to <code class="inline">true</code> only in development as it allows listing of the application source code during debugging. Defaults to <code class="inline">false</code></p></li>
<li><p><code class="inline">:force_ssl</code> - ensures no data is ever sent via HTTP, always redirecting to HTTPS. It expects a list of options which are forwarded to <a href="https://hexdocs.pm/plug/1.13.6/Plug.SSL.html"><code class="inline">Plug.SSL</code></a>. By default it sets the "strict-transport-security" header in HTTPS requests, forcing browsers to always use HTTPS. If an unsafe request (HTTP) is sent, it redirects to the HTTPS version using the <code class="inline">:host</code> specified in the <code class="inline">:url</code> configuration. To dynamically redirect to the <code class="inline">host</code> of the current request, set <code class="inline">:host</code> in the <code class="inline">:force_ssl</code> configuration to <code class="inline">nil</code></p></li>
</ul>
<h3 id="module-runtime-configuration" class="section-heading">  Runtime configuration </h3> <ul>
<li><p><code class="inline">:adapter</code> - which webserver adapter to use for serving web requests. See the "Adapter configuration" section below</p></li>
<li><p><code class="inline">:cache_static_manifest</code> - a path to a json manifest file that contains static files and their digested version. This is typically set to "priv/static/cache_manifest.json" which is the file automatically generated by <a href="mix.tasks.phx.digest.html"><code class="inline">mix phx.digest</code></a>. It can be either: a string containing a file system path or a tuple containing the application name and the path within that application.</p></li>
<li><p><code class="inline">:cache_static_manifest_latest</code> - a map of the static files pointing to their digest version. This is automatically loaded from <code class="inline">cache_static_manifest</code> on boot. However, if you have your own static handling mechanism, you may want to set this value explicitly. This is used by projects such as <code class="inline">LiveView</code> to detect if the client is running on the latest version of all assets.</p></li>
<li><p><code class="inline">:cache_manifest_skip_vsn</code> - when true, skips the appended query string "?vsn=d" when generatic paths to static assets. This query string is used by <a href="https://hexdocs.pm/plug/1.13.6/Plug.Static.html"><code class="inline">Plug.Static</code></a> to set long expiry dates, therefore, you should set this option to true only if you are not using <a href="https://hexdocs.pm/plug/1.13.6/Plug.Static.html"><code class="inline">Plug.Static</code></a> to serve assets, for example, if you are using a CDN. If you are setting this option, you should also consider passing <code class="inline">--no-vsn</code> to <a href="mix.tasks.phx.digest.html"><code class="inline">mix phx.digest</code></a>. Defaults to <code class="inline">false</code>.</p></li>
<li><p><code class="inline">:check_origin</code> - configure the default <code class="inline">:check_origin</code> setting for transports. See <a href="#socket/3"><code class="inline">socket/3</code></a> for options. Defaults to <code class="inline">true</code>.</p></li>
<li><p><code class="inline">:secret_key_base</code> - a secret key used as a base to generate secrets for encrypting and signing data. For example, cookies and tokens are signed by default, but they may also be encrypted if desired. Defaults to <code class="inline">nil</code> as it must be set per application</p></li>
<li><p><code class="inline">:server</code> - when <code class="inline">true</code>, starts the web server when the endpoint supervision tree starts. Defaults to <code class="inline">false</code>. The <a href="mix.tasks.phx.server.html"><code class="inline">mix phx.server</code></a> task automatically sets this to <code class="inline">true</code></p></li>
<li>
<p><code class="inline">:url</code> - configuration for generating URLs throughout the app. Accepts the <code class="inline">:host</code>, <code class="inline">:scheme</code>, <code class="inline">:path</code> and <code class="inline">:port</code> options. All keys except <code class="inline">:path</code> can be changed at runtime. Defaults to:</p>
<pre data-language="elixir">[host: "localhost", path: "/"]</pre>
<p>The <code class="inline">:port</code> option requires either an integer or string. The <code class="inline">:host</code> option requires a string.</p>
<p>The <code class="inline">:scheme</code> option accepts <code class="inline">"http"</code> and <code class="inline">"https"</code> values. Default value is inferred from top level <code class="inline">:http</code> or <code class="inline">:https</code> option. It is useful when hosting Phoenix behind a load balancer or reverse proxy and terminating SSL there.</p>
<p>The <code class="inline">:path</code> option can be used to override root path. Useful when hosting Phoenix behind a reverse proxy with URL rewrite rules</p>
</li>
<li><p><code class="inline">:static_url</code> - configuration for generating URLs for static files. It will fallback to <code class="inline">url</code> if no option is provided. Accepts the same options as <code class="inline">url</code></p></li>
<li>
<p><code class="inline">:watchers</code> - a set of watchers to run alongside your server. It expects a list of tuples containing the executable and its arguments. Watchers are guaranteed to run in the application directory, but only when the server is enabled (unless <code class="inline">:force_watchers</code> configuration is set to <code class="inline">true</code>). For example, the watcher below will run the "watch" mode of the webpack build tool when the server starts. You can configure it to whatever build tool or command you want:</p>
<pre data-language="elixir">[
  node: [
    "node_modules/webpack/bin/webpack.js",
    "--mode",
    "development",
    "--watch",
    "--watch-options-stdin"
  ]
]</pre>
<p>The <code class="inline">:cd</code> and <code class="inline">:env</code> options can be given at the end of the list to customize the watcher:</p>
<pre data-language="elixir">[node: [..., cd: "assets", env: [{"TAILWIND_MODE", "watch"}]]]</pre>
<p>A watcher can also be a module-function-args tuple that will be invoked accordingly:</p>
<pre data-language="elixir">[another: {Mod, :fun, [arg1, arg2]}]</pre>
</li>
<li><p><code class="inline">:force_watchers</code> - when <code class="inline">true</code>, forces your watchers to start even when the <code class="inline">:server</code> option is set to <code class="inline">false</code>.</p></li>
<li>
<p><code class="inline">:live_reload</code> - configuration for the live reload option. Configuration requires a <code class="inline">:patterns</code> option which should be a list of file patterns to watch. When these files change, it will trigger a reload. If you are using a tool like <a href="http://pow.cx">pow</a> in development, you may need to set the <code class="inline">:url</code> option appropriately.</p>
<pre data-language="elixir">live_reload: [
  url: "ws://localhost:4000",
  patterns: [
    ~r{priv/static/.*(js|css|png|jpeg|jpg|gif)$},
    ~r{web/views/.*(ex)$},
    ~r{web/templates/.*(eex)$}
  ]
]</pre>
</li>
<li><p><code class="inline">:pubsub_server</code> - the name of the pubsub server to use in channels and via the Endpoint broadcast functions. The PubSub server is typically started in your supervision tree.</p></li>
<li>
<p><code class="inline">:render_errors</code> - responsible for rendering templates whenever there is a failure in the application. For example, if the application crashes with a 500 error during a HTML request, <code class="inline">render("500.html", assigns)</code> will be called in the view given to <code class="inline">:render_errors</code>. Defaults to:</p>
<pre data-language="elixir">[view: MyApp.ErrorView, accepts: ~w(html), layout: false, log: :debug]</pre>
<p>The default format is used when none is set in the connection</p>
</li>
</ul>
<h3 id="module-adapter-configuration" class="section-heading">  Adapter configuration </h3> <p>Phoenix allows you to choose which webserver adapter to use. The default is <a href="phoenix.endpoint.cowboy2adapter.html"><code class="inline">Phoenix.Endpoint.Cowboy2Adapter</code></a> which can be configured via the following top-level options.</p>
<ul>
<li><p><code class="inline">:http</code> - the configuration for the HTTP server. It accepts all options as defined by <a href="https://hexdocs.pm/plug_cowboy/"><code class="inline">Plug.Cowboy</code></a>. Defaults to <code class="inline">false</code></p></li>
<li><p><code class="inline">:https</code> - the configuration for the HTTPS server. It accepts all options as defined by <a href="https://hexdocs.pm/plug_cowboy/"><code class="inline">Plug.Cowboy</code></a>. Defaults to <code class="inline">false</code></p></li>
<li><p><code class="inline">:drainer</code> - a drainer process that triggers when your application is shutting down to wait for any on-going request to finish. It accepts all options as defined by <a href="https://hexdocs.pm/plug_cowboy/Plug.Cowboy.Drainer.html"><code class="inline">Plug.Cowboy.Drainer</code></a>. Defaults to <code class="inline">[]</code>, which will start a drainer process for each configured endpoint, but can be disabled by setting it to <code class="inline">false</code>.</p></li>
</ul>
<h2 id="module-endpoint-api" class="section-heading">  Endpoint API </h2> <p>In the previous section, we have used the <a href="#c:config/2"><code class="inline">config/2</code></a> function that is automatically generated in your endpoint. Here's a list of all the functions that are automatically defined in your endpoint:</p>
<ul>
<li><p>for handling paths and URLs: <a href="#c:struct_url/0"><code class="inline">struct_url/0</code></a>, <a href="#c:url/0"><code class="inline">url/0</code></a>, <a href="#c:path/1"><code class="inline">path/1</code></a>, <a href="#c:static_url/0"><code class="inline">static_url/0</code></a>,<a href="#c:static_path/1"><code class="inline">static_path/1</code></a>, and <a href="#c:static_integrity/1"><code class="inline">static_integrity/1</code></a></p></li>
<li><p>for broadcasting to channels: <a href="#c:broadcast/3"><code class="inline">broadcast/3</code></a>, <a href="#c:broadcast!/3"><code class="inline">broadcast!/3</code></a>, <a href="#c:broadcast_from/4"><code class="inline">broadcast_from/4</code></a>, <a href="#c:broadcast_from!/4"><code class="inline">broadcast_from!/4</code></a>, <a href="#c:local_broadcast/3"><code class="inline">local_broadcast/3</code></a>, and <a href="#c:local_broadcast_from/4"><code class="inline">local_broadcast_from/4</code></a></p></li>
<li><p>for configuration: <a href="#c:start_link/1"><code class="inline">start_link/1</code></a>, <a href="#c:config/2"><code class="inline">config/2</code></a>, and <a href="#c:config_change/2"><code class="inline">config_change/2</code></a></p></li>
<li><p>as required by the <a href="https://hexdocs.pm/plug/1.13.6/Plug.html"><code class="inline">Plug</code></a> behaviour: <a href="https://hexdocs.pm/plug/1.13.6/Plug.html#c:init/1"><code class="inline">Plug.init/1</code></a> and <a href="https://hexdocs.pm/plug/1.13.6/Plug.html#c:call/2"><code class="inline">Plug.call/2</code></a></p></li>
</ul> </section> <section id="summary" class="details-list"> <h1 class="section-heading">  Summary </h1> <h2> Types </h2>
<dl class="summary-types summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#t:event/0" translate="no">event()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:msg/0" translate="no">msg()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:topic/0" translate="no">topic()</a> </dt> </div> </dl> <h2> Callbacks </h2>
<dl class="summary-callbacks summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#c:broadcast!/3" translate="no">broadcast!(topic, event, msg)</a> </dt> <dd class="summary-synopsis"><p>Broadcasts a <code class="inline">msg</code> as <code class="inline">event</code> in the given <code class="inline">topic</code> to all nodes.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:broadcast/3" translate="no">broadcast(topic, event, msg)</a> </dt> <dd class="summary-synopsis"><p>Broadcasts a <code class="inline">msg</code> as <code class="inline">event</code> in the given <code class="inline">topic</code> to all nodes.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:broadcast_from!/4" translate="no">broadcast_from!(from, topic, event, msg)</a> </dt> <dd class="summary-synopsis"><p>Broadcasts a <code class="inline">msg</code> from the given <code class="inline">from</code> as <code class="inline">event</code> in the given <code class="inline">topic</code> to all nodes.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:broadcast_from/4" translate="no">broadcast_from(from, topic, event, msg)</a> </dt> <dd class="summary-synopsis"><p>Broadcasts a <code class="inline">msg</code> from the given <code class="inline">from</code> as <code class="inline">event</code> in the given <code class="inline">topic</code> to all nodes.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:config/2" translate="no">config key, default</a> </dt> <dd class="summary-synopsis"><p>Access the endpoint configuration given by key.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:config_change/2" translate="no">config_change(changed, removed)</a> </dt> <dd class="summary-synopsis"><p>Reload the endpoint configuration on application upgrades.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:host/0" translate="no">host()</a> </dt> <dd class="summary-synopsis"><p>Returns the host from the :url configuration.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:init/2" translate="no">init(atom, config)</a> </dt> <dd class="summary-synopsis"><p>Initialize the endpoint configuration.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:local_broadcast/3" translate="no">local_broadcast(topic, event, msg)</a> </dt> <dd class="summary-synopsis"><p>Broadcasts a <code class="inline">msg</code> as <code class="inline">event</code> in the given <code class="inline">topic</code> within the current node.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:local_broadcast_from/4" translate="no">local_broadcast_from(from, topic, event, msg)</a> </dt> <dd class="summary-synopsis"><p>Broadcasts a <code class="inline">msg</code> from the given <code class="inline">from</code> as <code class="inline">event</code> in the given <code class="inline">topic</code> within the current node.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:path/1" translate="no">path(path)</a> </dt> <dd class="summary-synopsis"><p>Generates the path information when routing to this endpoint.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:script_name/0" translate="no">script_name()</a> </dt> <dd class="summary-synopsis"><p>Returns the script name from the :url configuration.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:start_link/1" translate="no">start_link(keyword)</a> </dt> <dd class="summary-synopsis"><p>Starts the endpoint supervision tree.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:static_integrity/1" translate="no">static_integrity(path)</a> </dt> <dd class="summary-synopsis"><p>Generates an integrity hash to a static file in <code class="inline">priv/static</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:static_lookup/1" translate="no">static_lookup(path)</a> </dt> <dd class="summary-synopsis"><p>Generates a two item tuple containing the <code class="inline">static_path</code> and <code class="inline">static_integrity</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:static_path/1" translate="no">static_path(path)</a> </dt> <dd class="summary-synopsis"><p>Generates a route to a static file in <code class="inline">priv/static</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:static_url/0" translate="no">static_url()</a> </dt> <dd class="summary-synopsis"><p>Generates the static URL without any path information.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:struct_url/0" translate="no">struct_url()</a> </dt> <dd class="summary-synopsis"><p>Generates the endpoint base URL, but as a <a href="https://hexdocs.pm/elixir/URI.html"><code class="inline">URI</code></a> struct.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:subscribe/2" translate="no">subscribe(topic, opts)</a> </dt> <dd class="summary-synopsis"><p>Subscribes the caller to the given topic.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:unsubscribe/1" translate="no">unsubscribe(topic)</a> </dt> <dd class="summary-synopsis"><p>Unsubscribes the caller from the given topic.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:url/0" translate="no">url()</a> </dt> <dd class="summary-synopsis"><p>Generates the endpoint base URL without any path information.</p></dd> </div> </dl> <h2> Functions </h2>
<dl class="summary-functions summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#server?/2" translate="no">server?(otp_app, endpoint)</a> </dt> <dd class="summary-synopsis"><p>Checks if Endpoint's web server has been configured to start.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#socket/3" translate="no">socket(path, module, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Defines a websocket/longpoll mount-point for a socket.</p></dd> </div> </dl> </section> <section id="types" class="details-list"> <h1 class="section-heading">  Types </h1> <div class="types-list"> <section class="detail"> <h3 class="detail-header" id="t:event/0">event()<a href="https://github.com/phoenixframework/phoenix/blob/v1.6.11/lib/phoenix/endpoint.ex#L256" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type event() :: String.t()</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:msg/0">msg()<a href="https://github.com/phoenixframework/phoenix/blob/v1.6.11/lib/phoenix/endpoint.ex#L257" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type msg() :: map() | {:binary, binary()}</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:topic/0">topic()<a href="https://github.com/phoenixframework/phoenix/blob/v1.6.11/lib/phoenix/endpoint.ex#L255" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type topic() :: String.t()</pre> </div> </section> </section> </div> </section> <section id="callbacks" class="details-list"> <h1 class="section-heading">  Callbacks </h1> <div class="callbacks-list"> <section class="detail"> <h3 class="detail-header" id="c:broadcast!/3">broadcast!(topic, event, msg)<a href="https://github.com/phoenixframework/phoenix/blob/v1.6.11/lib/phoenix/endpoint.ex#L360" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback broadcast!(topic(), event(), msg()) :: :ok | no_return()</pre> </div> <p>Broadcasts a <code class="inline">msg</code> as <code class="inline">event</code> in the given <code class="inline">topic</code> to all nodes.</p>
<p>Raises in case of failures.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:broadcast/3">broadcast(topic, event, msg)<a href="https://github.com/phoenixframework/phoenix/blob/v1.6.11/lib/phoenix/endpoint.ex#L353" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback broadcast(topic(), event(), msg()) :: :ok | {:error, term()}</pre> </div> <p>Broadcasts a <code class="inline">msg</code> as <code class="inline">event</code> in the given <code class="inline">topic</code> to all nodes.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:broadcast_from!/4">broadcast_from!(from, topic, event, msg)<a href="https://github.com/phoenixframework/phoenix/blob/v1.6.11/lib/phoenix/endpoint.ex#L372" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback broadcast_from!(from :: pid(), topic(), event(), msg()) :: :ok | no_return()</pre> </div> <p>Broadcasts a <code class="inline">msg</code> from the given <code class="inline">from</code> as <code class="inline">event</code> in the given <code class="inline">topic</code> to all nodes.</p>
<p>Raises in case of failures.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:broadcast_from/4">broadcast_from(from, topic, event, msg)<a href="https://github.com/phoenixframework/phoenix/blob/v1.6.11/lib/phoenix/endpoint.ex#L365" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback broadcast_from(from :: pid(), topic(), event(), msg()) :: :ok | {:error, term()}</pre> </div> <p>Broadcasts a <code class="inline">msg</code> from the given <code class="inline">from</code> as <code class="inline">event</code> in the given <code class="inline">topic</code> to all nodes.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:config/2">config key, default<a href="https://github.com/phoenixframework/phoenix/blob/v1.6.11/lib/phoenix/endpoint.ex#L274" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback config(key :: atom(), default :: term()) :: term()</pre> </div> <p>Access the endpoint configuration given by key.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:config_change/2">config_change(changed, removed)<a href="https://github.com/phoenixframework/phoenix/blob/v1.6.11/lib/phoenix/endpoint.ex#L279" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback config_change(changed :: term(), removed :: term()) :: term()</pre> </div> <p>Reload the endpoint configuration on application upgrades.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:host/0">host()<a href="https://github.com/phoenixframework/phoenix/blob/v1.6.11/lib/phoenix/endpoint.ex#L334" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback host() :: String.t()</pre> </div> <p>Returns the host from the :url configuration.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:init/2">init(atom, config)<a href="https://github.com/phoenixframework/phoenix/blob/v1.6.11/lib/phoenix/endpoint.ex#L287" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback init(:supervisor, config :: Keyword.t()) :: {:ok, Keyword.t()}</pre> </div> <p>Initialize the endpoint configuration.</p>
<p>Invoked when the endpoint supervisor starts, allows dynamically configuring the endpoint from system environment or other runtime sources.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:local_broadcast/3">local_broadcast(topic, event, msg)<a href="https://github.com/phoenixframework/phoenix/blob/v1.6.11/lib/phoenix/endpoint.ex#L377" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback local_broadcast(topic(), event(), msg()) :: :ok</pre> </div> <p>Broadcasts a <code class="inline">msg</code> as <code class="inline">event</code> in the given <code class="inline">topic</code> within the current node.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:local_broadcast_from/4">local_broadcast_from(from, topic, event, msg)<a href="https://github.com/phoenixframework/phoenix/blob/v1.6.11/lib/phoenix/endpoint.ex#L382" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback local_broadcast_from(from :: pid(), topic(), event(), msg()) :: :ok</pre> </div> <p>Broadcasts a <code class="inline">msg</code> from the given <code class="inline">from</code> as <code class="inline">event</code> in the given <code class="inline">topic</code> within the current node.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:path/1">path(path)<a href="https://github.com/phoenixframework/phoenix/blob/v1.6.11/lib/phoenix/endpoint.ex#L304" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback path(path :: String.t()) :: String.t()</pre> </div> <p>Generates the path information when routing to this endpoint.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:script_name/0">script_name()<a href="https://github.com/phoenixframework/phoenix/blob/v1.6.11/lib/phoenix/endpoint.ex#L329" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback script_name() :: [String.t()]</pre> </div> <p>Returns the script name from the :url configuration.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:start_link/1">start_link(keyword)<a href="https://github.com/phoenixframework/phoenix/blob/v1.6.11/lib/phoenix/endpoint.ex#L269" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback start_link(keyword()) :: Supervisor.on_start()</pre> </div> <p>Starts the endpoint supervision tree.</p>
<p>Starts endpoint's configuration cache and possibly the servers for handling requests.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:static_integrity/1">static_integrity(path)<a href="https://github.com/phoenixframework/phoenix/blob/v1.6.11/lib/phoenix/endpoint.ex#L319" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback static_integrity(path :: String.t()) :: String.t() | nil</pre> </div> <p>Generates an integrity hash to a static file in <code class="inline">priv/static</code>.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:static_lookup/1">static_lookup(path)<a href="https://github.com/phoenixframework/phoenix/blob/v1.6.11/lib/phoenix/endpoint.ex#L324" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback static_lookup(path :: String.t()) ::
  {String.t(), String.t()} | {String.t(), nil}</pre> </div> <p>Generates a two item tuple containing the <code class="inline">static_path</code> and <code class="inline">static_integrity</code>.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:static_path/1">static_path(path)<a href="https://github.com/phoenixframework/phoenix/blob/v1.6.11/lib/phoenix/endpoint.ex#L314" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback static_path(path :: String.t()) :: String.t()</pre> </div> <p>Generates a route to a static file in <code class="inline">priv/static</code>.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:static_url/0">static_url()<a href="https://github.com/phoenixframework/phoenix/blob/v1.6.11/lib/phoenix/endpoint.ex#L309" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback static_url() :: String.t()</pre> </div> <p>Generates the static URL without any path information.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:struct_url/0">struct_url()<a href="https://github.com/phoenixframework/phoenix/blob/v1.6.11/lib/phoenix/endpoint.ex#L294" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback struct_url() :: URI.t()</pre> </div> <p>Generates the endpoint base URL, but as a <a href="https://hexdocs.pm/elixir/URI.html"><code class="inline">URI</code></a> struct.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:subscribe/2">subscribe(topic, opts)<a href="https://github.com/phoenixframework/phoenix/blob/v1.6.11/lib/phoenix/endpoint.ex#L343" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback subscribe(topic(), opts :: Keyword.t()) :: :ok | {:error, term()}</pre> </div> <p>Subscribes the caller to the given topic.</p>
<p>See <a href="https://hexdocs.pm/phoenix_pubsub/2.1.1/Phoenix.PubSub.html#subscribe/3"><code class="inline">Phoenix.PubSub.subscribe/3</code></a> for options.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:unsubscribe/1">unsubscribe(topic)<a href="https://github.com/phoenixframework/phoenix/blob/v1.6.11/lib/phoenix/endpoint.ex#L348" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback unsubscribe(topic()) :: :ok | {:error, term()}</pre> </div> <p>Unsubscribes the caller from the given topic.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:url/0">url()<a href="https://github.com/phoenixframework/phoenix/blob/v1.6.11/lib/phoenix/endpoint.ex#L299" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback url() :: String.t()</pre> </div> <p>Generates the endpoint base URL without any path information.</p> </section> </section> </div> </section> <section id="functions" class="details-list"> <h1 class="section-heading">  Functions </h1> <div class="functions-list"> <section class="detail"> <h3 class="detail-header" id="server?/2">server?(otp_app, endpoint)<a href="https://github.com/phoenixframework/phoenix/blob/v1.6.11/lib/phoenix/endpoint.ex#L933" class="source">Source</a>
</h3> <section class="docstring"> <p>Checks if Endpoint's web server has been configured to start.</p>
<ul>
<li>
<code class="inline">otp_app</code> - The OTP app running the endpoint, for example <code class="inline">:my_app</code>
</li>
<li>
<code class="inline">endpoint</code> - The endpoint module, for example <code class="inline">MyAppWeb.Endpoint</code>
</li>
</ul>
<h4 id="server?/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; Phoenix.Endpoint.server?(:my_app, MyAppWeb.Endpoint)
true</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="socket/3">socket(path, module, opts \\ [])<a href="https://github.com/phoenixframework/phoenix/blob/v1.6.11/lib/phoenix/endpoint.ex#L907" class="source">Source</a>
</h3> <section class="docstring"> <p>Defines a websocket/longpoll mount-point for a socket.</p>
<h4 id="socket/3-options" class="section-heading">  Options </h4> <ul>
<li><p><code class="inline">:websocket</code> - controls the websocket configuration. Defaults to <code class="inline">true</code>. May be false or a keyword list of options. See "Common configuration" and "WebSocket configuration" for the whole list</p></li>
<li><p><code class="inline">:longpoll</code> - controls the longpoll configuration. Defaults to <code class="inline">false</code>. May be true or a keyword list of options. See "Common configuration" and "Longpoll configuration" for the whole list</p></li>
</ul>
<p>If your socket is implemented using <a href="phoenix.socket.html"><code class="inline">Phoenix.Socket</code></a>, you can also pass to each transport above all options accepted on <code class="inline">use Phoenix.Socket</code>. An option given here will override the value in <code class="inline">use Phoenix.Socket</code>.</p>
<h4 id="socket/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">socket "/ws", MyApp.UserSocket

socket "/ws/admin", MyApp.AdminUserSocket,
  longpoll: true,
  websocket: [compress: true]</pre>
<h4 id="socket/3-path-params" class="section-heading">  Path params </h4> <p>It is possible to include variables in the path, these will be available in the <code class="inline">params</code> that are passed to the socket.</p>
<pre data-language="elixir">socket "/ws/:user_id", MyApp.UserSocket,
  websocket: [path: "/project/:project_id"]</pre>
<h4 id="socket/3-common-configuration" class="section-heading">  Common configuration </h4> <p>The configuration below can be given to both <code class="inline">:websocket</code> and <code class="inline">:longpoll</code> keys:</p>
<ul>
<li><p><code class="inline">:path</code> - the path to use for the transport. Will default to the transport name ("/websocket" or "/longpoll")</p></li>
<li><p><code class="inline">:serializer</code> - a list of serializers for messages. See <a href="phoenix.socket.html"><code class="inline">Phoenix.Socket</code></a> for more information</p></li>
<li><p><code class="inline">:transport_log</code> - if the transport layer itself should log and, if so, the level</p></li>
<li>
<p><code class="inline">:check_origin</code> - if the transport should check the origin of requests when the <code class="inline">origin</code> header is present. May be <code class="inline">true</code>, <code class="inline">false</code>, a list of hosts that are allowed, or a function provided as MFA tuple. Defaults to <code class="inline">:check_origin</code> setting at endpoint configuration.</p>
<p>If <code class="inline">true</code>, the header is checked against <code class="inline">:host</code> in <code class="inline">YourAppWeb.Endpoint.config(:url)[:host]</code>.</p>
<p>If <code class="inline">false</code>, your app is vulnerable to Cross-Site WebSocket Hijacking (CSWSH) attacks. Only use in development, when the host is truly unknown or when serving clients that do not send the <code class="inline">origin</code> header, such as mobile apps.</p>
<p>You can also specify a list of explicitly allowed origins. Wildcards are supported.</p>
<pre data-language="elixir">check_origin: [
  "https://example.com",
  "//another.com:888",
  "//*.other.com"
]</pre>
<p>Or to accept any origin matching the request connection's host, port, and scheme:</p>
<pre data-language="elixir">check_origin: :conn</pre>
<p>Or a custom MFA function:</p>
<pre data-language="elixir">check_origin: {MyAppWeb.Auth, :my_check_origin?, []}</pre>
<p>The MFA is invoked with the request <code class="inline">%URI{}</code> as the first argument, followed by arguments in the MFA list, and must return a boolean.</p>
</li>
<li><p><code class="inline">:code_reloader</code> - enable or disable the code reloader. Defaults to your endpoint configuration</p></li>
<li>
<p><code class="inline">:connect_info</code> - a list of keys that represent data to be copied from the transport to be made available in the user socket <code class="inline">connect/3</code> callback</p>
<p>The valid keys are:</p>
<ul>
<li><p><code class="inline">:peer_data</code> - the result of <a href="https://hexdocs.pm/plug/1.13.6/Plug.Conn.html#get_peer_data/1"><code class="inline">Plug.Conn.get_peer_data/1</code></a></p></li>
<li><p><code class="inline">:trace_context_headers</code> - a list of all trace context headers. Supported headers are defined by the <a href="https://www.w3.org/TR/trace-context-1/">W3C Trace Context Specification</a>. These headers are necessary for libraries such as <a href="https://opentelemetry.io/">OpenTelemetry</a> to extract trace propagation information to know this request is part of a larger trace in progress.</p></li>
<li><p><code class="inline">:x_headers</code> - all request headers that have an "x-" prefix</p></li>
<li><p><code class="inline">:uri</code> - a <code class="inline">%URI{}</code> with information from the conn</p></li>
<li><p><code class="inline">:user_agent</code> - the value of the "user-agent" request header</p></li>
<li><p><code class="inline">{:session, session_config}</code> - the session information from <a href="https://hexdocs.pm/plug/1.13.6/Plug.Conn.html"><code class="inline">Plug.Conn</code></a>. The <code class="inline">session_config</code> is an exact copy of the arguments given to <a href="https://hexdocs.pm/plug/1.13.6/Plug.Session.html"><code class="inline">Plug.Session</code></a>. This requires the "_csrf_token" to be given as request parameter with the value of <code class="inline">URI.encode_www_form(Plug.CSRFProtection.get_csrf_token())</code> when connecting to the socket. It can also be a MFA to allow loading config in runtime <code class="inline">{MyAppWeb.Auth, :get_session_config, []}</code>. Otherwise the session will be <code class="inline">nil</code>.</p></li>
</ul>
<p>Arbitrary keywords may also appear following the above valid keys, which is useful for passing custom connection information to the socket.</p>
<p>For example:</p>
<pre data-language="elixir">  socket "/socket", AppWeb.UserSocket,
      websocket: [
        connect_info: [:peer_data, :trace_context_headers, :x_headers, :uri, session: [store: :cookie]]
      ]</pre>
<p>With arbitrary keywords:</p>
<pre data-language="elixir">  socket "/socket", AppWeb.UserSocket,
      websocket: [
        connect_info: [:uri, custom_value: "abcdef"]
      ]</pre>
</li>
</ul>
<h4 id="socket/3-websocket-configuration" class="section-heading">  Websocket configuration </h4> <p>The following configuration applies only to <code class="inline">:websocket</code>.</p>
<ul>
<li><p><code class="inline">:timeout</code> - the timeout for keeping websocket connections open after it last received data, defaults to 60_000ms</p></li>
<li><p><code class="inline">:max_frame_size</code> - the maximum allowed frame size in bytes, defaults to "infinity"</p></li>
<li><p><code class="inline">:fullsweep_after</code> - the maximum number of garbage collections before forcing a fullsweep for the socket process. You can set it to <code class="inline">0</code> to force more frequent cleanups of your websocket transport processes. Setting this option requires Erlang/OTP 24</p></li>
<li><p><code class="inline">:compress</code> - whether to enable per message compression on all data frames, defaults to false</p></li>
<li>
<p><code class="inline">:subprotocols</code> - a list of supported websocket subprotocols. Used for handshake <code class="inline">Sec-WebSocket-Protocol</code> response header, defaults to nil.</p>
<p>For example:</p>
<pre data-language="elixir">subprotocols: ["sip", "mqtt"]</pre>
</li>
<li>
<p><code class="inline">:error_handler</code> - custom error handler for connection errors. If <a href="phoenix.socket.html#c:connect/3"><code class="inline">Phoenix.Socket.connect/3</code></a> returns an <code class="inline">{:error, reason}</code> tuple, the error handler will be called with the error reason. For WebSockets, the error handler must be a MFA tuple that receives a <a href="https://hexdocs.pm/plug/1.13.6/Plug.Conn.html"><code class="inline">Plug.Conn</code></a>, the error reason, and returns a <a href="https://hexdocs.pm/plug/1.13.6/Plug.Conn.html"><code class="inline">Plug.Conn</code></a> with a response. For example:</p>
<pre data-language="elixir">error_handler: {MySocket, :handle_error, []}</pre>
<p>and a <code class="inline">{:error, :rate_limit}</code> return may be handled on <code class="inline">MySocket</code> as:</p>
<pre data-language="elixir">def handle_error(conn, :rate_limit), do: Plug.Conn.send_resp(conn, 429, "Too many requests")</pre>
</li>
</ul>
<h4 id="socket/3-longpoll-configuration" class="section-heading">  Longpoll configuration </h4> <p>The following configuration applies only to <code class="inline">:longpoll</code>:</p>
<ul>
<li><p><code class="inline">:window_ms</code> - how long the client can wait for new messages in its poll request, defaults to 10_000ms.</p></li>
<li><p><code class="inline">:pubsub_timeout_ms</code> - how long a request can wait for the pubsub layer to respond, defaults to 2000ms.</p></li>
<li><p><code class="inline">:crypto</code> - options for verifying and signing the token, accepted by <a href="phoenix.token.html"><code class="inline">Phoenix.Token</code></a>. By default tokens are valid for 2 weeks</p></li>
</ul> </section> </section> </div> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2014 Chris McCord<br>Licensed under the MIT License.<br>
    <a href="https://hexdocs.pm/phoenix/Phoenix.Endpoint.html" class="_attribution-link">https://hexdocs.pm/phoenix/Phoenix.Endpoint.html</a>
  </p>
</div>
