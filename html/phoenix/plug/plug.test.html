<h1>   <span translate="no">Plug.Test</span>  </h1> <section id="moduledoc"> <p>Conveniences for testing plugs.</p>
<p>This module can be used in your test cases, like this:</p>
<pre data-language="elixir">use ExUnit.Case, async: true
use Plug.Test</pre>
<p>Using this module will:</p>
<ul>
<li>import all the functions from this module</li>
<li>import all the functions from the <a href="plug.conn.html"><code class="inline">Plug.Conn</code></a> module</li>
</ul>
<p>By default, Plug tests checks for invalid header keys, e.g. header keys which include uppercase letters, and raises a <a href="plug.conn.invalidheadererror.html"><code class="inline">Plug.Conn.InvalidHeaderError</code></a> when it finds one. To disable it, set <code class="inline">:validate_header_keys_during_test</code> to false on the app config.</p>
<pre data-language="elixir">config :plug, :validate_header_keys_during_test, false</pre> </section> <section id="summary" class="details-list"> <h1 class="section-heading">  Summary </h1> <h2> Functions </h2>
<dl class="summary-functions summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#conn/3" translate="no">conn(method, path, params_or_body \\ nil)</a> </dt> <dd class="summary-synopsis"><p>Creates a test connection.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#delete_req_cookie/2" translate="no">delete_req_cookie(conn, key)</a> </dt> <dd class="summary-synopsis"><p>Deletes a request cookie.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#init_test_session/2" translate="no">init_test_session(conn, session)</a> </dt> <dd class="summary-synopsis"><p>Initializes the session with the given contents.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#put_http_protocol/2" translate="no">put_http_protocol(conn, http_protocol)</a> </dt> <dd class="summary-synopsis"><p>Puts the HTTP protocol.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#put_peer_data/2" translate="no">put_peer_data(conn, peer_data)</a> </dt> <dd class="summary-synopsis"><p>Puts the peer data.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#put_req_cookie/3" translate="no">put_req_cookie(conn, key, value)</a> </dt> <dd class="summary-synopsis"><p>Puts a request cookie.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#recycle_cookies/2" translate="no">recycle_cookies(new_conn, old_conn)</a> </dt> <dd class="summary-synopsis"><p>Moves cookies from a connection into a new connection for subsequent requests.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#sent_informs/1" translate="no">sent_informs(conn)</a> </dt> <dd class="summary-synopsis"><p>Returns the informational requests that have been sent.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#sent_pushes/1" translate="no">sent_pushes(conn)</a> </dt> <dd class="summary-synopsis"><p>Returns the assets that have been pushed.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#sent_resp/1" translate="no">sent_resp(conn)</a> </dt> <dd class="summary-synopsis"><p>Returns the sent response.</p></dd> </div> </dl> </section> <section id="functions" class="details-list"> <h1 class="section-heading">  Functions </h1> <div class="functions-list"> <section class="detail">  <h3 class="detail-header" id="conn/3">conn(method, path, params_or_body \\ nil)<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/test.ex#L65" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec conn(String.Chars.t(), binary(), params()) :: Plug.Conn.t()</pre> </div> <p>Creates a test connection.</p>
<p>The request <code class="inline">method</code> and <code class="inline">path</code> are required arguments. <code class="inline">method</code> may be any value that implements <a href="https://hexdocs.pm/elixir/Kernel.html#to_string/1"><code class="inline">to_string/1</code></a> and it will be properly converted and normalized (e.g., <code class="inline">:get</code> or <code class="inline">"post"</code>).</p>
<p>The <code class="inline">path</code> is commonly the request path with optional query string but it may also be a complete URI. When a URI is given, the host and schema will be used as part of the request too.</p>
<p>The <code class="inline">params_or_body</code> field must be one of:</p>
<ul>
<li>
<code class="inline">nil</code> - meaning there is no body;</li>
<li>a binary - containing a request body. For such cases, <code class="inline">:headers</code> must be given as option with a content-type;</li>
<li>a map or list - containing the parameters which will automatically set the content-type to multipart. The map or list may contain other lists or maps and all entries will be normalized to string keys;</li>
</ul>
<h4 id="conn/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">conn(:get, "/foo?bar=10")
conn(:get, "/foo", %{bar: 10})
conn(:post, "/")
conn("patch", "/", "") |&gt; put_req_header("content-type", "application/json")</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="delete_req_cookie/2">delete_req_cookie(conn, key)<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/test.ex#L192" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec delete_req_cookie(Plug.Conn.t(), binary()) :: Plug.Conn.t()</pre> </div> <p>Deletes a request cookie.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="init_test_session/2">init_test_session(conn, session)<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/test.ex#L236" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec init_test_session(Plug.Conn.t(), %{optional(String.t() | atom()) =&gt; any()}) ::
  Plug.Conn.t()</pre> </div> <p>Initializes the session with the given contents.</p>
<p>If the session has already been initialized, the new contents will be merged with the previous ones.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="put_http_protocol/2">put_http_protocol(conn, http_protocol)<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/test.ex#L164" class="source">Source</a>
</h3> <section class="docstring"> <p>Puts the HTTP protocol.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="put_peer_data/2">put_peer_data(conn, peer_data)<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/test.ex#L173" class="source">Source</a>
</h3> <section class="docstring"> <p>Puts the peer data.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="put_req_cookie/3">put_req_cookie(conn, key, value)<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/test.ex#L183" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec put_req_cookie(Plug.Conn.t(), binary(), binary()) :: Plug.Conn.t()</pre> </div> <p>Puts a request cookie.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="recycle_cookies/2">recycle_cookies(new_conn, old_conn)<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/test.ex#L212" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec recycle_cookies(Plug.Conn.t(), Plug.Conn.t()) :: Plug.Conn.t()</pre> </div> <p>Moves cookies from a connection into a new connection for subsequent requests.</p>
<p>This function copies the cookie information in <code class="inline">old_conn</code> into <code class="inline">new_conn</code>, emulating multiple requests done by clients where cookies are always passed forward, and returns the new version of <code class="inline">new_conn</code>.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="sent_informs/1">sent_informs(conn)<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/test.ex#L119" class="source">Source</a>
</h3> <section class="docstring"> <p>Returns the informational requests that have been sent.</p>
<p>This function depends on gathering the messages sent by the test adapter when informational messages, such as an early hint, are sent. Calling this function will clear the informational request messages from the inbox for the process. To assert on multiple informs, the result of the function should be stored in a variable.</p>
<h4 id="sent_informs/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">conn = conn(:get, "/foo", "bar=10")
informs = Plug.Test.sent_informs(conn)
assert {"/static/application.css", [{"accept", "text/css"}]} in informs
assert {"/static/application.js", [{"accept", "application/javascript"}]} in informs</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="sent_pushes/1">sent_pushes(conn)<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/test.ex#L148" class="source">Source</a>
</h3> <section class="docstring"> <p>Returns the assets that have been pushed.</p>
<p>This function depends on gathering the messages sent by the test adapter when assets are pushed. Calling this function will clear the pushed message from the inbox for the process. To assert on multiple pushes, the result of the function should be stored in a variable.</p>
<h4 id="sent_pushes/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">conn = conn(:get, "/foo?bar=10")
pushes = Plug.Test.sent_pushes(conn)
assert {"/static/application.css", [{"accept", "text/css"}]} in pushes
assert {"/static/application.js", [{"accept", "application/javascript"}]} in pushes</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="sent_resp/1">sent_resp(conn)<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/test.ex#L76" class="source">Source</a>
</h3> <section class="docstring"> <p>Returns the sent response.</p>
<p>This function is useful when the code being invoked crashes and there is a need to verify a particular response was sent, even with the crash. It returns a tuple with <code class="inline">{status, headers, body}</code>.</p> </section> </section> </div> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2013 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/plug/Plug.Test.html" class="_attribution-link">https://hexdocs.pm/plug/Plug.Test.html</a>
  </p>
</div>
