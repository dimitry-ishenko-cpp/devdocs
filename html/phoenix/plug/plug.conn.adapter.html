<h1>   <span translate="no">Plug.Conn.Adapter</span> <small>behaviour</small>  </h1> <section id="moduledoc"> <p>Specification of the connection adapter API implemented by webservers.</p> </section> <section id="summary" class="details-list"> <h1 class="section-heading">  Summary </h1> <h2> Types </h2>
<dl class="summary-types summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#t:http_protocol/0" translate="no">http_protocol()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:payload/0" translate="no">payload()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:peer_data/0" translate="no">peer_data()</a> </dt> </div> </dl> <h2> Callbacks </h2>
<dl class="summary-callbacks summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#c:chunk/2" translate="no">chunk(payload, body)</a> </dt> <dd class="summary-synopsis"><p>Sends a chunk in the chunked response.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:get_http_protocol/1" translate="no">get_http_protocol(payload)</a> </dt> <dd class="summary-synopsis"><p>Returns the HTTP protocol and its version.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:get_peer_data/1" translate="no">get_peer_data(payload)</a> </dt> <dd class="summary-synopsis"><p>Returns peer information such as the address, port and ssl cert.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:inform/3" translate="no">inform(payload, status, headers)</a> </dt> <dd class="summary-synopsis"><p>Send an informational response to the client.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:push/3" translate="no">push(payload, path, headers)</a> </dt> <dd class="summary-synopsis"><p>Push a resource to the client.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:read_req_body/2" translate="no">read_req_body(payload, options)</a> </dt> <dd class="summary-synopsis"><p>Reads the request body.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:send_chunked/3" translate="no">send_chunked(payload, status, headers)</a> </dt> <dd class="summary-synopsis"><p>Sends the given status, headers as the beginning of a chunked response to the client.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:send_file/6" translate="no">send_file( payload, status, headers, file, offset, length )</a> </dt> <dd class="summary-synopsis"><p>Sends the given status, headers and file as a response back to the client.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:send_resp/4" translate="no">send_resp( payload, status, headers, body )</a> </dt> <dd class="summary-synopsis"><p>Sends the given status, headers and body as a response back to the client.</p></dd> </div> </dl> <h2> Functions </h2>
<dl class="summary-functions summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#conn/5" translate="no">conn(adapter, method, uri, remote_ip, req_headers)</a> </dt> <dd class="summary-synopsis"><p>Function used by adapters to create a new connection.</p></dd> </div> </dl> </section> <section id="types" class="details-list"> <h1 class="section-heading">  Types </h1> <div class="types-list"> <section class="detail"> <h3 class="detail-header" id="t:http_protocol/0">http_protocol()<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn/adapter.ex#L7" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type http_protocol() :: :"HTTP/1" | :"HTTP/1.1" | :"HTTP/2" | atom()</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:payload/0">payload()<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn/adapter.ex#L8" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type payload() :: term()</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:peer_data/0">peer_data()<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn/adapter.ex#L9" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type peer_data() :: %{
  address: :inet.ip_address(),
  port: :inet.port_number(),
  ssl_cert: binary() | nil
}</pre> </div> </section> </section> </div> </section> <section id="callbacks" class="details-list"> <h1 class="section-heading">  Callbacks </h1> <div class="callbacks-list"> <section class="detail"> <h3 class="detail-header" id="c:chunk/2">chunk(payload, body)<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn/adapter.ex#L105" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback chunk(payload(), body :: Plug.Conn.body()) ::
  :ok | {:ok, sent_body :: binary(), payload()} | {:error, term()}</pre> </div> <p>Sends a chunk in the chunked response.</p>
<p>If the request has method <code class="inline">"HEAD"</code>, the adapter should not send the response to the client.</p>
<p>Webservers are advised to return <code class="inline">:ok</code> and not modify any further state for each chunk. However, the test implementation returns the actual body and payload so it can be used during testing.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:get_http_protocol/1">get_http_protocol(payload)<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn/adapter.ex#L144" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback get_http_protocol(payload()) :: http_protocol()</pre> </div> <p>Returns the HTTP protocol and its version.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:get_peer_data/1">get_peer_data(payload)<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn/adapter.ex#L139" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback get_peer_data(payload()) :: peer_data()</pre> </div> <p>Returns peer information such as the address, port and ssl cert.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:inform/3">inform(payload, status, headers)<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn/adapter.ex#L133" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback inform(payload(), status :: Plug.Conn.status(), headers :: Keyword.t()) ::
  :ok | {:error, term()}</pre> </div> <p>Send an informational response to the client.</p>
<p>If the adapter does not support inform, then <code class="inline">{:error, :not_supported}</code> should be returned.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:push/3">push(payload, path, headers)<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn/adapter.ex#L125" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback push(payload(), path :: String.t(), headers :: Keyword.t()) ::
  :ok | {:error, term()}</pre> </div> <p>Push a resource to the client.</p>
<p>If the adapter does not support server push then <code class="inline">{:error, :not_supported}</code> should be returned.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:read_req_body/2">read_req_body(payload, options)<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn/adapter.ex#L114" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback read_req_body(payload(), options :: Keyword.t()) ::
  {:ok, data :: binary(), payload()}
  | {:more, data :: binary(), payload()}
  | {:error, term()}</pre> </div> <p>Reads the request body.</p>
<p>Read the docs in <a href="plug.conn.html#read_body/2"><code class="inline">Plug.Conn.read_body/2</code></a> for the supported options and expected behaviour.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:send_chunked/3">send_chunked(payload, status, headers)<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn/adapter.ex#L91" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback send_chunked(
  payload(),
  status :: Plug.Conn.status(),
  headers :: Plug.Conn.headers()
) ::
  {:ok, sent_body :: binary() | nil, payload()}</pre> </div> <p>Sends the given status, headers as the beginning of a chunked response to the client.</p>
<p>Webservers are advised to return <code class="inline">nil</code> as the sent_body, as the body can no longer be manipulated. However, the test implementation returns the actual body so it can be used during testing.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:send_file/6">send_file( payload, status, headers, file, offset, length )<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn/adapter.ex#L80" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback send_file(
  payload(),
  status :: Plug.Conn.status(),
  headers :: Plug.Conn.headers(),
  file :: binary(),
  offset :: integer(),
  length :: integer() | :all
) :: {:ok, sent_body :: binary() | nil, payload()}</pre> </div> <p>Sends the given status, headers and file as a response back to the client.</p>
<p>If the request has method <code class="inline">"HEAD"</code>, the adapter should not send the response to the client.</p>
<p>Webservers are advised to return <code class="inline">nil</code> as the sent_body, as the body can no longer be manipulated. However, the test implementation returns the actual body so it can be used during testing.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:send_resp/4">send_resp( payload, status, headers, body )<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn/adapter.ex#L58" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback send_resp(
  payload(),
  status :: Plug.Conn.status(),
  headers :: Plug.Conn.headers(),
  body :: Plug.Conn.body()
) :: {:ok, sent_body :: binary() | nil, payload()}</pre> </div> <p>Sends the given status, headers and body as a response back to the client.</p>
<p>If the request has method <code class="inline">"HEAD"</code>, the adapter should not send the response to the client.</p>
<p>Webservers are advised to return <code class="inline">nil</code> as the sent_body, as the body can no longer be manipulated. However, the test implementation returns the actual body so it can be used during testing.</p> </section> </section> </div> </section> <section id="functions" class="details-list"> <h1 class="section-heading">  Functions </h1> <div class="functions-list"> <section class="detail"> <h3 class="detail-header" id="conn/5">conn(adapter, method, uri, remote_ip, req_headers)<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn/adapter.ex#L18" class="source">Source</a>
</h3> <section class="docstring"> <p>Function used by adapters to create a new connection.</p> </section> </section> </div> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2013 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/plug/Plug.Conn.Adapter.html" class="_attribution-link">https://hexdocs.pm/plug/Plug.Conn.Adapter.html</a>
  </p>
</div>
