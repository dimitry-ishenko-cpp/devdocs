<h1>   <span translate="no">Plug.Conn</span>  </h1> <section id="moduledoc"> <p>The Plug connection.</p>
<p>This module defines a struct and the main functions for working with requests and responses in an HTTP connection.</p>
<p>Note request headers are normalized to lowercase and response headers are expected to have lowercase keys.</p>
<h2 id="module-request-fields" class="section-heading">  Request fields </h2> <p>These fields contain request information:</p>
<ul>
<li>
<code class="inline">host</code> - the requested host as a binary, example: <code class="inline">"www.example.com"</code>
</li>
<li>
<code class="inline">method</code> - the request method as a binary, example: <code class="inline">"GET"</code>
</li>
<li>
<code class="inline">path_info</code> - the path split into segments, example: <code class="inline">["hello", "world"]</code>
</li>
<li>
<code class="inline">script_name</code> - the initial portion of the URL's path that corresponds to the application routing, as segments, example: <code class="inline">["sub","app"]</code>
</li>
<li>
<code class="inline">request_path</code> - the requested path, example: <code class="inline">/trailing/and//double//slashes/</code>
</li>
<li>
<code class="inline">port</code> - the requested port as an integer, example: <code class="inline">80</code>
</li>
<li>
<code class="inline">remote_ip</code> - the IP of the client, example: <code class="inline">{151, 236, 219, 228}</code>. This field is meant to be overwritten by plugs that understand e.g. the <code class="inline">X-Forwarded-For</code> header or HAProxy's PROXY protocol. It defaults to peer's IP</li>
<li>
<code class="inline">req_headers</code> - the request headers as a list, example: <code class="inline">[{"content-type", "text/plain"}]</code>. Note all headers will be downcased</li>
<li>
<code class="inline">scheme</code> - the request scheme as an atom, example: <code class="inline">:http</code>
</li>
<li>
<code class="inline">query_string</code> - the request query string as a binary, example: <code class="inline">"foo=bar"</code>
</li>
</ul>
<h2 id="module-fetchable-fields" class="section-heading">  Fetchable fields </h2> <p>The request information in these fields is not populated until it is fetched using the associated <code class="inline">fetch_</code> function. For example, the <code class="inline">cookies</code> field uses <a href="#fetch_cookies/2"><code class="inline">fetch_cookies/2</code></a>.</p>
<p>If you access these fields before fetching them, they will be returned as <a href="plug.conn.unfetched.html"><code class="inline">Plug.Conn.Unfetched</code></a> structs.</p>
<ul>
<li>
<code class="inline">cookies</code>- the request cookies with the response cookies</li>
<li>
<code class="inline">body_params</code> - the request body params, populated through a <a href="plug.parsers.html"><code class="inline">Plug.Parsers</code></a> parser.</li>
<li>
<code class="inline">query_params</code> - the request query params, populated through <a href="#fetch_query_params/2"><code class="inline">fetch_query_params/2</code></a>
</li>
<li>
<code class="inline">path_params</code> - the request path params, populated by routers such as <a href="plug.router.html"><code class="inline">Plug.Router</code></a>
</li>
<li>
<code class="inline">params</code> - the request params, the result of merging the <code class="inline">:path_params</code> on top of <code class="inline">:body_params</code> on top of <code class="inline">:query_params</code>
</li>
<li>
<code class="inline">req_cookies</code> - the request cookies (without the response ones)</li>
</ul>
<h2 id="module-response-fields" class="section-heading">  Response fields </h2> <p>These fields contain response information:</p>
<ul>
<li>
<code class="inline">resp_body</code> - the response body, by default is an empty string. It is set to nil after the response is sent, except for test connections. The response charset used defaults to "utf-8".</li>
<li>
<code class="inline">resp_cookies</code> - the response cookies with their name and options</li>
<li>
<code class="inline">resp_headers</code> - the response headers as a list of tuples, by default <code class="inline">cache-control</code> is set to <code class="inline">"max-age=0, private, must-revalidate"</code>. Note, response headers are expected to have lowercase keys.</li>
<li>
<code class="inline">status</code> - the response status</li>
</ul>
<h2 id="module-connection-fields" class="section-heading">  Connection fields </h2> <ul>
<li>
<code class="inline">assigns</code> - shared user data as a map</li>
<li>
<code class="inline">owner</code> - the Elixir process that owns the connection</li>
<li>
<code class="inline">halted</code> - the boolean status on whether the pipeline was halted</li>
<li>
<code class="inline">secret_key_base</code> - a secret key used to verify and encrypt cookies. the field must be set manually whenever one of those features are used. This data must be kept in the connection and never used directly, always use <a href="https://hexdocs.pm/plug_crypto/1.2.1/Plug.Crypto.KeyGenerator.html#generate/3"><code class="inline">Plug.Crypto.KeyGenerator.generate/3</code></a> to derive keys from it</li>
<li>
<code class="inline">state</code> - the connection state</li>
</ul>
<p>The connection state is used to track the connection lifecycle. It starts as <code class="inline">:unset</code> but is changed to <code class="inline">:set</code> (via <a href="#resp/3"><code class="inline">resp/3</code></a>) or <code class="inline">:set_chunked</code> (used only for <code class="inline">before_send</code> callbacks by <a href="#send_chunked/2"><code class="inline">send_chunked/2</code></a>) or <code class="inline">:file</code> (when invoked via <a href="#send_file/3"><code class="inline">send_file/3</code></a>). Its final result is <code class="inline">:sent</code>, <code class="inline">:file</code> or <code class="inline">:chunked</code> depending on the response model.</p>
<h2 id="module-private-fields" class="section-heading">  Private fields </h2> <p>These fields are reserved for libraries/framework usage.</p>
<ul>
<li>
<code class="inline">adapter</code> - holds the adapter information in a tuple</li>
<li>
<code class="inline">private</code> - shared library data as a map</li>
</ul>
<h2 id="module-custom-status-codes" class="section-heading">  Custom status codes </h2> <p>Plug allows status codes to be overridden or added in order to allow new codes not directly specified by Plug or its adapters. Adding or overriding a status code is done through the Mix configuration of the <code class="inline">:plug</code> application. For example, to override the existing 404 reason phrase for the 404 status code ("Not Found" by default) and add a new 998 status code, the following config can be specified:</p>
<pre data-language="elixir">config :plug, :statuses, %{
  404 =&gt; "Actually This Was Found",
  998 =&gt; "Not An RFC Status Code"
}</pre>
<p>As this configuration is Plug specific, Plug will need to be recompiled for the changes to take place: this will not happen automatically as dependencies are not automatically recompiled when their configuration changes. To recompile Plug:</p>
<pre data-language="elixir">mix deps.clean --build plug</pre>
<p>The atoms that can be used in place of the status code in many functions are inflected from the reason phrase of the status code. With the above configuration, the following will all work:</p>
<pre data-language="elixir">put_status(conn, :not_found)                     # 404
put_status(conn, :actually_this_was_found)       # 404
put_status(conn, :not_an_rfc_status_code)        # 998</pre>
<p>Even though 404 has been overridden, the <code class="inline">:not_found</code> atom can still be used to set the status to 404 as well as the new atom <code class="inline">:actually_this_was_found</code> inflected from the reason phrase "Actually This Was Found".</p> </section> <section id="summary" class="details-list"> <h1 class="section-heading">  Summary </h1> <h2> Types </h2>
<dl class="summary-types summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#t:adapter/0" translate="no">adapter()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:assigns/0" translate="no">assigns()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:body/0" translate="no">body()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:cookies/0" translate="no">cookies()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:halted/0" translate="no">halted()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:headers/0" translate="no">headers()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:host/0" translate="no">host()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:int_status/0" translate="no">int_status()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:method/0" translate="no">method()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:owner/0" translate="no">owner()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:params/0" translate="no">params()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:port_number/0" translate="no">port_number()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:query_param/0" translate="no">query_param()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:query_params/0" translate="no">query_params()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:query_string/0" translate="no">query_string()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:req_cookies/0" translate="no">req_cookies()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:resp_cookies/0" translate="no">resp_cookies()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:scheme/0" translate="no">scheme()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:secret_key_base/0" translate="no">secret_key_base()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:segments/0" translate="no">segments()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:state/0" translate="no">state()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:status/0" translate="no">status()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:t/0" translate="no">t()</a> </dt> </div> </dl> <h2> Functions </h2>
<dl class="summary-functions summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#assign/3" translate="no">assign(conn, key, value)</a> </dt> <dd class="summary-synopsis"><p>Assigns a value to a key in the connection.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#chunk/2" translate="no">chunk(conn, chunk)</a> </dt> <dd class="summary-synopsis"><p>Sends a chunk as part of a chunked response.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#clear_session/1" translate="no">clear_session(conn)</a> </dt> <dd class="summary-synopsis"><p>Clears the entire session.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#configure_session/2" translate="no">configure_session(conn, opts)</a> </dt> <dd class="summary-synopsis"><p>Configures the session.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#delete_req_header/2" translate="no">delete_req_header(conn, key)</a> </dt> <dd class="summary-synopsis"><p>Deletes a request header if present.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#delete_resp_cookie/3" translate="no">delete_resp_cookie(conn, key, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Deletes a response cookie.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#delete_resp_header/2" translate="no">delete_resp_header(conn, key)</a> </dt> <dd class="summary-synopsis"><p>Deletes a response header if present.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#delete_session/2" translate="no">delete_session(conn, key)</a> </dt> <dd class="summary-synopsis"><p>Deletes <code class="inline">key</code> from session.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#fetch_cookies/2" translate="no">fetch_cookies(conn, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Fetches cookies from the request headers.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#fetch_query_params/2" translate="no">fetch_query_params(conn, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Fetches query parameters from the query string.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#fetch_session/2" translate="no">fetch_session(conn, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Fetches the session from the session store. Will also fetch cookies.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#get_http_protocol/1" translate="no">get_http_protocol(conn)</a> </dt> <dd class="summary-synopsis"><p>Returns the HTTP protocol and version.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#get_peer_data/1" translate="no">get_peer_data(conn)</a> </dt> <dd class="summary-synopsis"><p>Returns the request peer data if one is present.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#get_req_header/2" translate="no">get_req_header(conn, key)</a> </dt> <dd class="summary-synopsis"><p>Returns the values of the request header specified by <code class="inline">key</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#get_resp_header/2" translate="no">get_resp_header(conn, key)</a> </dt> <dd class="summary-synopsis"><p>Returns the values of the response header specified by <code class="inline">key</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#get_session/1" translate="no">get_session(conn)</a> </dt> <dd class="summary-synopsis"><p>Returns the whole session.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#get_session/2" translate="no">get_session(conn, key)</a> </dt> <dd class="summary-synopsis"><p>Returns session value for the given <code class="inline">key</code>. If <code class="inline">key</code> is not set, <code class="inline">nil</code> is returned.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#halt/1" translate="no">halt(conn)</a> </dt> <dd class="summary-synopsis"><p>Halts the Plug pipeline by preventing further plugs downstream from being invoked. See the docs for <a href="plug.builder.html"><code class="inline">Plug.Builder</code></a> for more information on halting a Plug pipeline.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#inform!/3" translate="no">inform!(conn, status, headers \\ [])</a> </dt> <dd class="summary-synopsis"><p>Sends an information response to a client but raises if the adapter does not support inform.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#inform/3" translate="no">inform(conn, status, headers \\ [])</a> </dt> <dd class="summary-synopsis"><p>Sends an informational response to the client.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#merge_assigns/2" translate="no">merge_assigns(conn, keyword)</a> </dt> <dd class="summary-synopsis"><p>Assigns multiple values to keys in the connection.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#merge_private/2" translate="no">merge_private(conn, keyword)</a> </dt> <dd class="summary-synopsis"><p>Assigns multiple <strong>private</strong> keys and values in the connection.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#merge_resp_headers/2" translate="no">merge_resp_headers(conn, headers)</a> </dt> <dd class="summary-synopsis"><p>Merges a series of response headers into the connection.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#prepend_resp_headers/2" translate="no">prepend_resp_headers(conn, headers)</a> </dt> <dd class="summary-synopsis"><p>Prepends the list of headers to the connection response headers.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#push!/3" translate="no">push!(conn, path, headers \\ [])</a> </dt> <dd class="summary-synopsis"><p>Pushes a resource to the client but raises if the adapter does not support server push.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#push/3" translate="no">push(conn, path, headers \\ [])</a> </dt> <dd class="summary-synopsis"><p>Pushes a resource to the client.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#put_private/3" translate="no">put_private(conn, key, value)</a> </dt> <dd class="summary-synopsis"><p>Assigns a new <strong>private</strong> key and value in the connection.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#put_req_header/3" translate="no">put_req_header(conn, key, value)</a> </dt> <dd class="summary-synopsis"><p>Adds a new request header (<code class="inline">key</code>) if not present, otherwise replaces the previous value of that header with <code class="inline">value</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#put_resp_content_type/3" translate="no">put_resp_content_type(conn, content_type, charset \\ "utf-8")</a> </dt> <dd class="summary-synopsis"><p>Sets the value of the <code class="inline">"content-type"</code> response header taking into account the <code class="inline">charset</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#put_resp_cookie/4" translate="no">put_resp_cookie(conn, key, value, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Puts a response cookie in the connection.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#put_resp_header/3" translate="no">put_resp_header(conn, key, value)</a> </dt> <dd class="summary-synopsis"><p>Adds a new response header (<code class="inline">key</code>) if not present, otherwise replaces the previous value of that header with <code class="inline">value</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#put_session/3" translate="no">put_session(conn, key, value)</a> </dt> <dd class="summary-synopsis"><p>Puts the specified <code class="inline">value</code> in the session for the given <code class="inline">key</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#put_status/2" translate="no">put_status(conn, status)</a> </dt> <dd class="summary-synopsis"><p>Stores the given status code in the connection.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#read_body/2" translate="no">read_body(conn, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Reads the request body.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#read_part_body/2" translate="no">read_part_body(conn, opts)</a> </dt> <dd class="summary-synopsis"><p>Reads the body of a multipart request.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#read_part_headers/2" translate="no">read_part_headers(conn, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Reads the headers of a multipart request.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#register_before_send/2" translate="no">register_before_send(conn, callback)</a> </dt> <dd class="summary-synopsis"><p>Registers a callback to be invoked before the response is sent.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#request_url/1" translate="no">request_url(conn)</a> </dt> <dd class="summary-synopsis"><p>Returns the full request URL.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#resp/3" translate="no">resp(conn, status, body)</a> </dt> <dd class="summary-synopsis"><p>Sets the response to the given <code class="inline">status</code> and <code class="inline">body</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#send_chunked/2" translate="no">send_chunked(conn, status)</a> </dt> <dd class="summary-synopsis"><p>Sends the response headers as a chunked response.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#send_file/5" translate="no">send_file(conn, status, file, offset \\ 0, length \\ :all)</a> </dt> <dd class="summary-synopsis"><p>Sends a file as the response body with the given <code class="inline">status</code> and optionally starting at the given offset until the given length.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#send_resp/1" translate="no">send_resp(conn)</a> </dt> <dd class="summary-synopsis"><p>Sends a response to the client.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#send_resp/3" translate="no">send_resp(conn, status, body)</a> </dt> <dd class="summary-synopsis"><p>Sends a response with the given status and body.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#update_req_header/4" translate="no">update_req_header(conn, key, initial, fun)</a> </dt> <dd class="summary-synopsis"><p>Updates a request header if present, otherwise it sets it to an initial value.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#update_resp_header/4" translate="no">update_resp_header(conn, key, initial, fun)</a> </dt> <dd class="summary-synopsis"><p>Updates a response header if present, otherwise it sets it to an initial value.</p></dd> </div> </dl> </section> <section id="types" class="details-list"> <h1 class="section-heading">  Types </h1> <div class="types-list"> <section class="detail"> <h3 class="detail-header" id="t:adapter/0">adapter()<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L120" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type adapter() :: {module(), term()}</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:assigns/0">assigns()<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L121" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type assigns() :: %{optional(atom()) =&gt; any()}</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:body/0">body()<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L122" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type body() :: iodata()</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:cookies/0">cookies()<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L124" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type cookies() :: %{optional(binary()) =&gt; term()}</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:halted/0">halted()<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L125" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type halted() :: boolean()</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:headers/0">headers()<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L126" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type headers() :: [{binary(), binary()}]</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:host/0">host()<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L127" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type host() :: binary()</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:int_status/0">int_status()<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L128" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type int_status() :: non_neg_integer() | nil</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:method/0">method()<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L130" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type method() :: binary()</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:owner/0">owner()<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L129" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type owner() :: pid()</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:params/0">params()<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L133" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type params() :: %{optional(binary()) =&gt; term()}</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:port_number/0">port_number()<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L134" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type port_number() :: :inet.port_number()</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:query_param/0">query_param()<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L131" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type query_param() ::
  binary() | %{optional(binary()) =&gt; query_param()} | [query_param()]</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:query_params/0">query_params()<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L132" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type query_params() :: %{optional(binary()) =&gt; query_param()}</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:query_string/0">query_string()<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L135" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type query_string() :: String.t()</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:req_cookies/0">req_cookies()<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L123" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type req_cookies() :: %{optional(binary()) =&gt; binary()}</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:resp_cookies/0">resp_cookies()<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L136" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type resp_cookies() :: %{optional(binary()) =&gt; map()}</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:scheme/0">scheme()<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L137" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type scheme() :: :http | :https</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:secret_key_base/0">secret_key_base()<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L138" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type secret_key_base() :: binary() | nil</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:segments/0">segments()<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L139" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type segments() :: [binary()]</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:state/0">state()<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L140" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type state() :: :unset | :set | :set_chunked | :set_file | :file | :chunked | :sent</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:status/0">status()<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L141" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type status() :: atom() | int_status()</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:t/0">t()<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L143" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type t() :: %Plug.Conn{
  adapter: adapter(),
  assigns: assigns(),
  body_params: params() | Plug.Conn.Unfetched.t(),
  cookies: cookies() | Plug.Conn.Unfetched.t(),
  halted: halted(),
  host: host(),
  method: method(),
  owner: owner(),
  params: params() | Plug.Conn.Unfetched.t(),
  path_info: segments(),
  path_params: query_params(),
  port: :inet.port_number(),
  private: assigns(),
  query_params: query_params() | Plug.Conn.Unfetched.t(),
  query_string: query_string(),
  remote_ip: :inet.ip_address(),
  req_cookies: req_cookies() | Plug.Conn.Unfetched.t(),
  req_headers: headers(),
  request_path: binary(),
  resp_body: body() | nil,
  resp_cookies: resp_cookies(),
  resp_headers: headers(),
  scheme: scheme(),
  script_name: segments(),
  secret_key_base: secret_key_base(),
  state: state(),
  status: int_status()
}</pre> </div> </section> </section> </div> </section> <section id="functions" class="details-list"> <h1 class="section-heading">  Functions </h1> <div class="functions-list"> <section class="detail"> <h3 class="detail-header" id="assign/3">assign(conn, key, value)<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L269" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec assign(t(), atom(), term()) :: t()</pre> </div> <p>Assigns a value to a key in the connection.</p>
<p>The "assigns" storage is meant to be used to store values in the connection so that other plugs in your plug pipeline can access them. The assigns storage is a map.</p>
<h4 id="assign/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; conn.assigns[:hello]
nil
iex&gt; conn = assign(conn, :hello, :world)
iex&gt; conn.assigns[:hello]
:world</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="chunk/2">chunk(conn, chunk)<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L511" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec chunk(t(), body()) :: {:ok, t()} | {:error, term()} | no_return()</pre> </div> <p>Sends a chunk as part of a chunked response.</p>
<p>It expects a connection with state <code class="inline">:chunked</code> as set by <a href="#send_chunked/2"><code class="inline">send_chunked/2</code></a>. It returns <code class="inline">{:ok, conn}</code> in case of success, otherwise <code class="inline">{:error, reason}</code>.</p>
<p>To stream data use <a href="https://hexdocs.pm/elixir/Enum.html#reduce_while/3"><code class="inline">Enum.reduce_while/3</code></a> instead of <a href="https://hexdocs.pm/elixir/Enum.html#into/2"><code class="inline">Enum.into/2</code></a>. <a href="https://hexdocs.pm/elixir/Enum.html#reduce_while/3"><code class="inline">Enum.reduce_while/3</code></a> allows aborting the execution if <a href="#chunk/2"><code class="inline">chunk/2</code></a> fails to deliver the chunk of data.</p>
<h4 id="chunk/2-example" class="section-heading">  Example </h4> <pre data-language="elixir">Enum.reduce_while(~w(each chunk as a word), conn, fn (chunk, conn) -&gt;
  case Plug.Conn.chunk(conn, chunk) do
    {:ok, conn} -&gt;
      {:cont, conn}
    {:error, :closed} -&gt;
      {:halt, conn}
  end
end)</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="clear_session/1">clear_session(conn)<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L1595" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec clear_session(t()) :: t()</pre> </div> <p>Clears the entire session.</p>
<p>This function removes every key from the session, clearing the session.</p>
<p>Note that, even if <a href="#clear_session/1"><code class="inline">clear_session/1</code></a> is used, the session is still sent to the client. If the session should be effectively <em>dropped</em>, <a href="#configure_session/2"><code class="inline">configure_session/2</code></a> should be used with the <code class="inline">:drop</code> option set to <code class="inline">true</code>.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="configure_session/2">configure_session(conn, opts)<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L1615" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec configure_session(t(), Keyword.t()) :: t()</pre> </div> <p>Configures the session.</p>
<h4 id="configure_session/2-options" class="section-heading">  Options </h4> <ul>
<li>
<code class="inline">:renew</code> - When <code class="inline">true</code>, generates a new session id for the cookie</li>
<li>
<code class="inline">:drop</code> - When <code class="inline">true</code>, drops the session, a session cookie will not be included in the response</li>
<li>
<code class="inline">:ignore</code> - When <code class="inline">true</code>, ignores all changes made to the session in this request cycle</li>
</ul>
<h4 id="configure_session/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">configure_session(conn, renew: true)</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="delete_req_header/2">delete_req_header(conn, key)<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L668" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec delete_req_header(t(), binary()) :: t()</pre> </div> <p>Deletes a request header if present.</p>
<p>Raises a <a href="plug.conn.alreadysenterror.html"><code class="inline">Plug.Conn.AlreadySentError</code></a> if the connection has already been <code class="inline">:sent</code> or <code class="inline">:chunked</code>.</p>
<h4 id="delete_req_header/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">Plug.Conn.delete_req_header(conn, "content-type")</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="delete_resp_cookie/3">delete_resp_cookie(conn, key, opts \\ [])<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L1503" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec delete_resp_cookie(t(), binary(), Keyword.t()) :: t()</pre> </div> <p>Deletes a response cookie.</p>
<p>Deleting a cookie requires the same options as to when the cookie was put. Check <a href="#put_resp_cookie/4"><code class="inline">put_resp_cookie/4</code></a> for more information.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="delete_resp_header/2">delete_resp_header(conn, key)<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L875" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec delete_resp_header(t(), binary()) :: t()</pre> </div> <p>Deletes a response header if present.</p>
<p>Raises a <a href="plug.conn.alreadysenterror.html"><code class="inline">Plug.Conn.AlreadySentError</code></a> if the connection has already been <code class="inline">:sent</code> or <code class="inline">:chunked</code>.</p>
<h4 id="delete_resp_header/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">Plug.Conn.delete_resp_header(conn, "content-type")</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="delete_session/2">delete_session(conn, key)<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L1578" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec delete_session(t(), String.t() | atom()) :: t()</pre> </div> <p>Deletes <code class="inline">key</code> from session.</p>
<p>The key can be a string or an atom, where atoms are automatically converted to strings.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="fetch_cookies/2">fetch_cookies(conn, opts \\ [])<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L1327" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec fetch_cookies(t(), Keyword.t()) :: t()</pre> </div> <p>Fetches cookies from the request headers.</p>
<h4 id="fetch_cookies/2-options" class="section-heading">  Options </h4> <ul>
<li><p><code class="inline">:signed</code> - a list of one or more cookies that are signed and must be verified accordingly</p></li>
<li><p><code class="inline">:encrypted</code> - a list of one or more cookies that are encrypted and must be decrypted accordingly</p></li>
</ul>
<p>See <a href="#put_resp_cookie/4"><code class="inline">put_resp_cookie/4</code></a> for more information.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="fetch_query_params/2">fetch_query_params(conn, opts \\ [])<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L972" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec fetch_query_params(t(), Keyword.t()) :: t()</pre> </div> <p>Fetches query parameters from the query string.</p>
<p>Params are decoded as <code class="inline">"x-www-form-urlencoded"</code> in which key/value pairs are separated by <code class="inline">&amp;</code> and keys are separated from values by <code class="inline">=</code>.</p>
<p>This function does not fetch parameters from the body. To fetch parameters from the body, use the <a href="plug.parsers.html"><code class="inline">Plug.Parsers</code></a> plug.</p>
<h4 id="fetch_query_params/2-options" class="section-heading">  Options </h4> <ul>
<li><p><code class="inline">:length</code> - the maximum query string length. Defaults to <code class="inline">1_000_000</code> bytes. Keep in mind the webserver you are using may have a more strict limit. For example, for the Cowboy webserver, <a href="https://hexdocs.pm/plug_cowboy/Plug.Cowboy.html#module-safety-limits">please read</a>.</p></li>
<li><p><code class="inline">:validate_utf8</code> - boolean that tells whether or not to validate the keys and values of the decoded query string are UTF-8 encoded. Defaults to <code class="inline">true</code>.</p></li>
</ul> </section> </section> <section class="detail">  <h3 class="detail-header" id="fetch_session/2">fetch_session(conn, opts \\ [])<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L1516" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec fetch_session(t(), Keyword.t()) :: t()</pre> </div> <p>Fetches the session from the session store. Will also fetch cookies.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="get_http_protocol/1">get_http_protocol(conn)<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L605" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec get_http_protocol(t()) :: Plug.Conn.Adapter.http_protocol()</pre> </div> <p>Returns the HTTP protocol and version.</p>
<h4 id="get_http_protocol/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; get_http_protocol(conn)
:"HTTP/1.1"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="get_peer_data/1">get_peer_data(conn)<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L591" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec get_peer_data(t()) :: Plug.Conn.Adapter.peer_data()</pre> </div> <p>Returns the request peer data if one is present.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="get_req_header/2">get_req_header(conn, key)<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L619" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec get_req_header(t(), binary()) :: [binary()]</pre> </div> <p>Returns the values of the request header specified by <code class="inline">key</code>.</p>
<h4 id="get_req_header/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; get_req_header(conn, "accept")
["application/json"]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="get_resp_header/2">get_resp_header(conn, key)<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L732" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec get_resp_header(t(), binary()) :: [binary()]</pre> </div> <p>Returns the values of the response header specified by <code class="inline">key</code>.</p>
<h4 id="get_resp_header/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; conn = %{conn | resp_headers: [{"content-type", "text/plain"}]}
iex&gt; get_resp_header(conn, "content-type")
["text/plain"]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="get_session/1">get_session(conn)<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L1563" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec get_session(t()) :: %{optional(String.t()) =&gt; any()}</pre> </div> <p>Returns the whole session.</p>
<p>Although <a href="#get_session/2"><code class="inline">get_session/2</code></a> and <a href="#put_session/3"><code class="inline">put_session/3</code></a> allow atom keys, they are always normalized to strings. So this function always returns a map with string keys.</p>
<p>Raises if the session was not yet fetched.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="get_session/2">get_session(conn, key)<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L1549" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec get_session(t(), String.t() | atom()) :: any()</pre> </div> <p>Returns session value for the given <code class="inline">key</code>. If <code class="inline">key</code> is not set, <code class="inline">nil</code> is returned.</p>
<p>The key can be a string or an atom, where atoms are automatically converted to strings.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="halt/1">halt(conn)<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L1669" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec halt(t()) :: t()</pre> </div> <p>Halts the Plug pipeline by preventing further plugs downstream from being invoked. See the docs for <a href="plug.builder.html"><code class="inline">Plug.Builder</code></a> for more information on halting a Plug pipeline.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="inform!/3">inform!(conn, status, headers \\ [])<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L1235" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec inform!(t(), status(), Keyword.t()) :: t()</pre> </div> <p>Sends an information response to a client but raises if the adapter does not support inform.</p>
<p>See <code class="inline">inform/1</code> for more information.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="inform/3">inform(conn, status, headers \\ [])<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L1223" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec inform(t(), status(), Keyword.t()) :: t()</pre> </div> <p>Sends an informational response to the client.</p>
<p>An informational response, such as an early hint, must happen prior to a response being sent. If an informational request is attempted after a response is sent then a <a href="plug.conn.alreadysenterror.html"><code class="inline">Plug.Conn.AlreadySentError</code></a> will be raised. Only status codes from 100-199 are valid.</p>
<p>To use inform for early hints send one or more informs with a status of 103.</p>
<p>If the adapter does not support informational responses then this is a noop.</p>
<p>Most HTTP/1.1 clients do not properly support informational responses but some proxies require it to support server push for HTTP/2. You can call <a href="#get_http_protocol/1"><code class="inline">get_http_protocol/1</code></a> to retrieve the protocol and version.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="merge_assigns/2">merge_assigns(conn, keyword)<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L288" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec merge_assigns(t(), Keyword.t()) :: t()</pre> </div> <p>Assigns multiple values to keys in the connection.</p>
<p>Equivalent to multiple calls to <a href="#assign/3"><code class="inline">assign/3</code></a>.</p>
<h4 id="merge_assigns/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; conn.assigns[:hello]
nil
iex&gt; conn = merge_assigns(conn, hello: :world)
iex&gt; conn.assigns[:hello]
:world</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="merge_private/2">merge_private(conn, keyword)<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L347" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec merge_private(t(), Keyword.t()) :: t()</pre> </div> <p>Assigns multiple <strong>private</strong> keys and values in the connection.</p>
<p>Equivalent to multiple <a href="#put_private/3"><code class="inline">put_private/3</code></a> calls.</p>
<h4 id="merge_private/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; conn.private[:my_plug_hello]
nil
iex&gt; conn = merge_private(conn, my_plug_hello: :world)
iex&gt; conn.private[:my_plug_hello]
:world</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="merge_resp_headers/2">merge_resp_headers(conn, headers)<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L837" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec merge_resp_headers(t(), Enum.t()) :: t()</pre> </div> <p>Merges a series of response headers into the connection.</p>
<p>It is recommended for header keys to be in lowercase, to avoid sending duplicate keys in a request. Additionally, responses with mixed-case headers served over HTTP/2 are not considered valid by common clients, resulting in dropped responses. As a convenience, when using the <code class="inline">Plug.Adapters.Conn.Test</code> adapter, any headers that aren't lowercase will raise a <a href="plug.conn.invalidheadererror.html"><code class="inline">Plug.Conn.InvalidHeaderError</code></a>.</p>
<h4 id="merge_resp_headers/2-example" class="section-heading">  Example </h4> <pre data-language="elixir">Plug.Conn.merge_resp_headers(conn, [{"content-type", "text/plain"}, {"X-1337", "5P34K"}])</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="prepend_resp_headers/2">prepend_resp_headers(conn, headers)<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L801" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec prepend_resp_headers(t(), headers()) :: t()</pre> </div> <p>Prepends the list of headers to the connection response headers.</p>
<p>Similar to <code class="inline">put_resp_header</code> this functions adds a new response header (<code class="inline">key</code>) but rather then replacing the existing one it prepends another header with the same <code class="inline">key</code>.</p>
<p>It is recommended for header keys to be in lowercase, to avoid sending duplicate keys in a request. Additionally, responses with mixed-case headers served over HTTP/2 are not considered valid by common clients, resulting in dropped responses. As a convenience, when using the <code class="inline">Plug.Adapters.Conn.Test</code> adapter, any headers that aren't lowercase will raise a <a href="plug.conn.invalidheadererror.html"><code class="inline">Plug.Conn.InvalidHeaderError</code></a>.</p>
<p>Raises a <a href="plug.conn.alreadysenterror.html"><code class="inline">Plug.Conn.AlreadySentError</code></a> if the connection has already been <code class="inline">:sent</code> or <code class="inline">:chunked</code>.</p>
<p>Raises a <a href="plug.conn.invalidheadererror.html"><code class="inline">Plug.Conn.InvalidHeaderError</code></a> if the header value contains control feed (<code class="inline">\r</code>) or newline (<code class="inline">\n</code>) characters.</p>
<h4 id="prepend_resp_headers/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">Plug.Conn.prepend_resp_headers(conn, [{"content-type", "application/json"}])</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="push!/3">push!(conn, path, headers \\ [])<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L1286" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec push!(t(), String.t(), Keyword.t()) :: t()</pre> </div> <p>Pushes a resource to the client but raises if the adapter does not support server push.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="push/3">push(conn, path, headers \\ [])<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L1276" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec push(t(), String.t(), Keyword.t()) :: t()</pre> </div> <p>Pushes a resource to the client.</p>
<p>Server pushes must happen prior to a response being sent. If a server push is attempted after a response is sent then a <a href="plug.conn.alreadysenterror.html"><code class="inline">Plug.Conn.AlreadySentError</code></a> will be raised.</p>
<p>If the adapter does not support server push then this is a noop.</p>
<p>Note that certain browsers (such as Google Chrome) will not accept a pushed resource if your certificate is not trusted. In the case of Chrome this means a valid cert with a SAN. See <a href="https://www.chromestatus.com/feature/4981025180483584">https://www.chromestatus.com/feature/4981025180483584</a></p> </section> </section> <section class="detail"> <h3 class="detail-header" id="put_private/3">put_private(conn, key, value)<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L328" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec put_private(t(), atom(), term()) :: t()</pre> </div> <p>Assigns a new <strong>private</strong> key and value in the connection.</p>
<p>This storage is meant to be used by libraries and frameworks to avoid writing to the user storage (the <code class="inline">:assigns</code> field). It is recommended for libraries/frameworks to prefix the keys with the library name.</p>
<p>For example, if a plug called <code class="inline">my_plug</code> needs to store a <code class="inline">:hello</code> key, it would store it as <code class="inline">:my_plug_hello</code>:</p>
<pre data-language="elixir">iex&gt; conn.private[:my_plug_hello]
nil
iex&gt; conn = put_private(conn, :my_plug_hello, :world)
iex&gt; conn.private[:my_plug_hello]
:world</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="put_req_header/3">put_req_header(conn, key, value)<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L644" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec put_req_header(t(), binary(), binary()) :: t()</pre> </div> <p>Adds a new request header (<code class="inline">key</code>) if not present, otherwise replaces the previous value of that header with <code class="inline">value</code>.</p>
<p>Because header keys are case-insensitive in both HTTP/1.1 and HTTP/2, it is recommended for header keys to be in lowercase, to avoid sending duplicate keys in a request. Additionally, requests with mixed-case headers served over HTTP/2 are not considered valid by common clients, resulting in dropped requests. As a convenience, when using the <code class="inline">Plug.Adapters.Conn.Test</code> adapter, any headers that aren't lowercase will raise a <a href="plug.conn.invalidheadererror.html"><code class="inline">Plug.Conn.InvalidHeaderError</code></a>.</p>
<p>Raises a <a href="plug.conn.alreadysenterror.html"><code class="inline">Plug.Conn.AlreadySentError</code></a> if the connection has already been <code class="inline">:sent</code> or <code class="inline">:chunked</code>.</p>
<h4 id="put_req_header/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">Plug.Conn.put_req_header(conn, "accept", "application/json")</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="put_resp_content_type/3">put_resp_content_type(conn, content_type, charset \\ "utf-8")<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L941" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec put_resp_content_type(t(), binary(), binary() | nil) :: t()</pre> </div> <p>Sets the value of the <code class="inline">"content-type"</code> response header taking into account the <code class="inline">charset</code>.</p>
<p>If <code class="inline">charset</code> is <code class="inline">nil</code>, the value of the <code class="inline">"content-type"</code> response header won't specify a charset.</p>
<h4 id="put_resp_content_type/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; conn = put_resp_content_type(conn, "application/json")
iex&gt; get_resp_header(conn, "content-type")
["application/json; charset=utf-8"]</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="put_resp_cookie/4">put_resp_cookie(conn, key, value, opts \\ [])<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L1457" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec put_resp_cookie(t(), binary(), any(), Keyword.t()) :: t()</pre> </div> <p>Puts a response cookie in the connection.</p>
<p>If the <code class="inline">:sign</code> or <code class="inline">:encrypt</code> flag are given, then the cookie value can be any term.</p>
<p>If the cookie is not signed nor encrypted, then the value must be a binary. Note the value is not automatically escaped. Therefore if you want to store values with non-alphanumeric characters, you must either sign or encrypt the cookie or consider explicitly escaping the cookie value by using a function such as <code class="inline">Base.encode64(value, padding: false)</code> when writing and <code class="inline">Base.decode64(encoded, padding: false)</code> when reading the cookie. It is important for padding to be disabled since <code class="inline">=</code> is not a valid character in cookie values.</p>
<h4 id="put_resp_cookie/4-signing-and-encrypting-cookies" class="section-heading">  Signing and encrypting cookies </h4> <p>This function allows you to automatically sign and encrypt cookies. When signing or encryption is enabled, then any Elixir value can be stored in the cookie (except anonymous functions for security reasons). Once a value is signed or encrypted, you must also call <a href="#fetch_cookies/2"><code class="inline">fetch_cookies/2</code></a> with the name of the cookies that are either signed or encrypted.</p>
<p>To sign, you would do:</p>
<pre data-language="elixir">put_resp_cookie(conn, "my-cookie", %{user_id: user.id}, sign: true)</pre>
<p>and then:</p>
<pre data-language="elixir">fetch_cookies(conn, signed: ~w(my-cookie))</pre>
<p>To encrypt, you would do:</p>
<pre data-language="elixir">put_resp_cookie(conn, "my-cookie", %{user_id: user.id}, encrypt: true)</pre>
<p>and then:</p>
<pre data-language="elixir">fetch_cookies(conn, encrypted: ~w(my-cookie))</pre>
<p>By default a signed or encrypted cookie is only valid for a day, unless a <code class="inline">:max_age</code> is specified.</p>
<p>The signing and encryption keys are derived from the connection's <code class="inline">secret_key_base</code> using a salt that is built by appending "_cookie" to the cookie name. Care should be taken not to derive other keys using this value as the salt. Similarly do not use the same cookie name to store different values with distinct purposes.</p>
<h4 id="put_resp_cookie/4-options" class="section-heading">  Options </h4> <ul>
<li>
<code class="inline">:domain</code> - the domain the cookie applies to</li>
<li>
<code class="inline">:max_age</code> - the cookie max-age, in seconds. Providing a value for this option will set both the <em>max-age</em> and <em>expires</em> cookie attributes.</li>
<li>
<code class="inline">:path</code> - the path the cookie applies to</li>
<li>
<code class="inline">:http_only</code> - when <code class="inline">false</code>, the cookie is accessible beyond HTTP</li>
<li>
<code class="inline">:secure</code> - if the cookie must be sent only over https. Defaults to true when the connection is HTTPS</li>
<li>
<code class="inline">:extra</code> - string to append to cookie. Use this to take advantage of non-standard cookie attributes.</li>
<li>
<code class="inline">:sign</code> - when true, signs the cookie</li>
<li>
<code class="inline">:encrypt</code> - when true, encrypts the cookie</li>
<li>
<code class="inline">:same_site</code> - set the cookie SameSite attribute to a string value. If no string value is set, the attribute is omitted.</li>
</ul> </section> </section> <section class="detail"> <h3 class="detail-header" id="put_resp_header/3">put_resp_header(conn, key, value)<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L760" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec put_resp_header(t(), binary(), binary()) :: t()</pre> </div> <p>Adds a new response header (<code class="inline">key</code>) if not present, otherwise replaces the previous value of that header with <code class="inline">value</code>.</p>
<p>Because header keys are case-insensitive in both HTTP/1.1 and HTTP/2, it is recommended for header keys to be in lowercase, to avoid sending duplicate keys in a request. Additionally, responses with mixed-case headers served over HTTP/2 are not considered valid by common clients, resulting in dropped responses. As a convenience, when using the <code class="inline">Plug.Adapters.Conn.Test</code> adapter, any headers that aren't lowercase will raise a <a href="plug.conn.invalidheadererror.html"><code class="inline">Plug.Conn.InvalidHeaderError</code></a>.</p>
<p>Raises a <a href="plug.conn.alreadysenterror.html"><code class="inline">Plug.Conn.AlreadySentError</code></a> if the connection has already been <code class="inline">:sent</code> or <code class="inline">:chunked</code>.</p>
<p>Raises a <a href="plug.conn.invalidheadererror.html"><code class="inline">Plug.Conn.InvalidHeaderError</code></a> if the header value contains control feed (<code class="inline">\r</code>) or newline (<code class="inline">\n</code>) characters.</p>
<h4 id="put_resp_header/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">Plug.Conn.put_resp_header(conn, "content-type", "application/json")</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="put_session/3">put_session(conn, key, value)<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L1534" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec put_session(t(), String.t() | atom(), any()) :: t()</pre> </div> <p>Puts the specified <code class="inline">value</code> in the session for the given <code class="inline">key</code>.</p>
<p>The key can be a string or an atom, where atoms are automatically converted to strings. Can only be invoked on unsent <code class="inline">conn</code>s. Will raise otherwise.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="put_status/2">put_status(conn, status)<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L367" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec put_status(t(), status()) :: t()</pre> </div> <p>Stores the given status code in the connection.</p>
<p>The status code can be <code class="inline">nil</code>, an integer, or an atom. The list of allowed atoms is available in <a href="plug.conn.status.html"><code class="inline">Plug.Conn.Status</code></a>.</p>
<p>Raises a <a href="plug.conn.alreadysenterror.html"><code class="inline">Plug.Conn.AlreadySentError</code></a> if the connection has already been <code class="inline">:sent</code> or <code class="inline">:chunked</code>.</p>
<h4 id="put_status/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">Plug.Conn.put_status(conn, :not_found)
Plug.Conn.put_status(conn, 200)</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="read_body/2">read_body(conn, opts \\ [])<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L1050" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec read_body(t(), Keyword.t()) ::
  {:ok, binary(), t()} | {:more, binary(), t()} | {:error, term()}</pre> </div> <p>Reads the request body.</p>
<p>This function reads a chunk of the request body up to a given length (specified by the <code class="inline">:length</code> option). If there is more data to be read, then <code class="inline">{:more, partial_body, conn}</code> is returned. Otherwise <code class="inline">{:ok, body, conn}</code> is returned. In case of an error reading the socket, <code class="inline">{:error, reason}</code> is returned as per <a href="https://www.erlang.org/doc/man/gen_tcp.html#recv-2"><code class="inline">:gen_tcp.recv/2</code></a>.</p>
<p>Like all functions in this module, the <code class="inline">conn</code> returned by <code class="inline">read_body</code> must be passed to the next stage of your pipeline and should not be ignored.</p>
<p>In order to, for instance, support slower clients you can tune the <code class="inline">:read_length</code> and <code class="inline">:read_timeout</code> options. These specify how much time should be allowed to pass for each read from the underlying socket.</p>
<p>Because the request body can be of any size, reading the body will only work once, as Plug will not cache the result of these operations. If you need to access the body multiple times, it is your responsibility to store it. Finally keep in mind some plugs like <a href="plug.parsers.html"><code class="inline">Plug.Parsers</code></a> may read the body, so the body may be unavailable after being accessed by such plugs.</p>
<p>This function is able to handle both chunked and identity transfer-encoding by default.</p>
<h4 id="read_body/2-options" class="section-heading">  Options </h4> <ul>
<li>
<code class="inline">:length</code> - sets the maximum number of bytes to read from the body on every call, defaults to <code class="inline">8_000_000</code> bytes</li>
<li>
<code class="inline">:read_length</code> - sets the amount of bytes to read at one time from the underlying socket to fill the chunk, defaults to <code class="inline">1_000_000</code> bytes</li>
<li>
<code class="inline">:read_timeout</code> - sets the timeout for each socket read, defaults to <code class="inline">15_000</code> milliseconds</li>
</ul>
<p>The values above are not meant to be exact. For example, setting the length to <code class="inline">8_000_000</code> may end up reading some hundred bytes more from the socket until we halt.</p>
<h4 id="read_body/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">{:ok, body, conn} = Plug.Conn.read_body(conn, length: 1_000_000)</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="read_part_body/2">read_part_body(conn, opts)<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L1126" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec read_part_body(t(), Keyword.t()) ::
  {:ok, binary(), t()} | {:more, binary(), t()} | {:done, t()}</pre> </div> <p>Reads the body of a multipart request.</p>
<p>Returns <code class="inline">{:ok, body, conn}</code> if all body has been read, <code class="inline">{:more, binary, conn}</code> otherwise, and <code class="inline">{:done, conn}</code> if there is no more body.</p>
<p>It accepts the same options as <a href="#read_body/2"><code class="inline">read_body/2</code></a>.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="read_part_headers/2">read_part_headers(conn, opts \\ [])<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L1085" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec read_part_headers(t(), Keyword.t()) :: {:ok, headers(), t()} | {:done, t()}</pre> </div> <p>Reads the headers of a multipart request.</p>
<p>It returns <code class="inline">{:ok, headers, conn}</code> with the headers or <code class="inline">{:done, conn}</code> if there are no more parts.</p>
<p>Once <a href="#read_part_headers/2"><code class="inline">read_part_headers/2</code></a> is invoked, you may call <a href="#read_part_body/2"><code class="inline">read_part_body/2</code></a> to read the body associated to the headers. If <a href="#read_part_headers/2"><code class="inline">read_part_headers/2</code></a> is called instead, the body is automatically skipped until the next part headers.</p>
<h4 id="read_part_headers/2-options" class="section-heading">  Options </h4> <ul>
<li>
<code class="inline">:length</code> - sets the maximum number of bytes to read from the body for each chunk, defaults to <code class="inline">64_000</code> bytes</li>
<li>
<code class="inline">:read_length</code> - sets the amount of bytes to read at one time from the underlying socket to fill the chunk, defaults to <code class="inline">64_000</code> bytes</li>
<li>
<code class="inline">:read_timeout</code> - sets the timeout for each socket read, defaults to <code class="inline">5_000</code> milliseconds</li>
</ul> </section> </section> <section class="detail"> <h3 class="detail-header" id="register_before_send/2">register_before_send(conn, callback)<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L1651" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec register_before_send(t(), (t() -&gt; t())) :: t()</pre> </div> <p>Registers a callback to be invoked before the response is sent.</p>
<p>Callbacks are invoked in the reverse order they are defined (callbacks defined first are invoked last).</p>
<h4 id="register_before_send/2-examples" class="section-heading">  Examples </h4> <p>To log the status of response being sent:</p>
<pre data-language="elixir">require Logger

Plug.Conn.register_before_send(conn, fn conn -&gt;
  Logger.info("Sent a #{conn.status} response")
  conn
end)</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="request_url/1">request_url(conn)<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L1676" class="source">Source</a>
</h3> <section class="docstring"> <p>Returns the full request URL.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="resp/3">resp(conn, status, body)<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L572" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec resp(t(), status(), body()) :: t()</pre> </div> <p>Sets the response to the given <code class="inline">status</code> and <code class="inline">body</code>.</p>
<p>It sets the connection state to <code class="inline">:set</code> (if not already <code class="inline">:set</code>) and raises <a href="plug.conn.alreadysenterror.html"><code class="inline">Plug.Conn.AlreadySentError</code></a> if it was already <code class="inline">:sent</code>.</p>
<p>If you also want to send the response, use <a href="#send_resp/1"><code class="inline">send_resp/1</code></a> after this or use <a href="#send_resp/3"><code class="inline">send_resp/3</code></a>.</p>
<p>The status can be an integer, an atom, or <code class="inline">nil</code>. See <a href="plug.conn.status.html"><code class="inline">Plug.Conn.Status</code></a> for more information.</p>
<h4 id="resp/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">Plug.Conn.resp(conn, 404, "Not found")</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="send_chunked/2">send_chunked(conn, status)<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L473" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec send_chunked(t(), status()) :: t() | no_return()</pre> </div> <p>Sends the response headers as a chunked response.</p>
<p>It expects a connection that has not been <code class="inline">:sent</code> yet and sets its state to <code class="inline">:chunked</code> afterwards. Otherwise, raises <a href="plug.conn.alreadysenterror.html"><code class="inline">Plug.Conn.AlreadySentError</code></a>. After <a href="#send_chunked/2"><code class="inline">send_chunked/2</code></a> is called, chunks can be sent to the client via the <a href="#chunk/2"><code class="inline">chunk/2</code></a> function.</p>
<p>HTTP/2 does not support chunking and will instead stream the response without a transfer encoding. When using HTTP/1.1, the Cowboy adapter will stream the response instead of emitting chunks if the <code class="inline">content-length</code> header has been set before calling <a href="#send_chunked/2"><code class="inline">send_chunked/2</code></a>.</p> </section> </section> <section class="detail">   <h3 class="detail-header" id="send_file/5">send_file(conn, status, file, offset \\ 0, length \\ :all)<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L429" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec send_file(
  t(),
  status(),
  filename :: binary(),
  offset :: integer(),
  length :: integer() | :all
) ::
  t() | no_return()</pre> </div> <p>Sends a file as the response body with the given <code class="inline">status</code> and optionally starting at the given offset until the given length.</p>
<p>If available, the file is sent directly over the socket using the operating system <code class="inline">sendfile</code> operation.</p>
<p>It expects a connection that has not been <code class="inline">:sent</code> yet and sets its state to <code class="inline">:file</code> afterwards. Otherwise raises <a href="plug.conn.alreadysenterror.html"><code class="inline">Plug.Conn.AlreadySentError</code></a>.</p>
<h4 id="send_file/5-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">Plug.Conn.send_file(conn, 200, "README.md")</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="send_resp/1">send_resp(conn)<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L392" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec send_resp(t()) :: t() | no_return()</pre> </div> <p>Sends a response to the client.</p>
<p>It expects the connection state to be <code class="inline">:set</code>, otherwise raises an <a href="https://hexdocs.pm/elixir/ArgumentError.html"><code class="inline">ArgumentError</code></a> for <code class="inline">:unset</code> connections or a <a href="plug.conn.alreadysenterror.html"><code class="inline">Plug.Conn.AlreadySentError</code></a> for already <code class="inline">:sent</code> connections.</p>
<p>At the end sets the connection state to <code class="inline">:sent</code>.</p>
<p>Note that this function does not halt the connection, so if subsequent plugs try to send another response, it will error out. Use <a href="#halt/1"><code class="inline">halt/1</code></a> after this function if you want to halt the plug pipeline.</p>
<h4 id="send_resp/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">conn
|&gt; Plug.Conn.resp(404, "Not found")
|&gt; Plug.Conn.send_resp()</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="send_resp/3">send_resp(conn, status, body)<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L550" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec send_resp(t(), status(), body()) :: t() | no_return()</pre> </div> <p>Sends a response with the given status and body.</p>
<p>This is equivalent to setting the status and the body and then calling <a href="#send_resp/1"><code class="inline">send_resp/1</code></a>.</p>
<p>Note that this function does not halt the connection, so if subsequent plugs try to send another response, it will error out. Use <a href="#halt/1"><code class="inline">halt/1</code></a> after this function if you want to halt the plug pipeline.</p>
<h4 id="send_resp/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">Plug.Conn.send_resp(conn, 404, "Not found")</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="update_req_header/4">update_req_header(conn, key, initial, fun)<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L703" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec update_req_header(t(), binary(), binary(), (binary() -&gt; binary())) :: t()</pre> </div> <p>Updates a request header if present, otherwise it sets it to an initial value.</p>
<p>Raises a <a href="plug.conn.alreadysenterror.html"><code class="inline">Plug.Conn.AlreadySentError</code></a> if the connection has already been <code class="inline">:sent</code> or <code class="inline">:chunked</code>.</p>
<p>Only the first value of the header <code class="inline">key</code> is updated if present.</p>
<h4 id="update_req_header/4-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">Plug.Conn.update_req_header(
  conn,
  "accept",
  "application/json; charset=utf-8",
  &amp;(&amp;1 &lt;&gt; "; charset=utf-8")
)</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="update_resp_header/4">update_resp_header(conn, key, initial, fun)<a href="https://github.com/elixir-plug/plug/blob/v1.13.6/lib/plug/conn.ex#L908" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec update_resp_header(t(), binary(), binary(), (binary() -&gt; binary())) :: t()</pre> </div> <p>Updates a response header if present, otherwise it sets it to an initial value.</p>
<p>Raises a <a href="plug.conn.alreadysenterror.html"><code class="inline">Plug.Conn.AlreadySentError</code></a> if the connection has already been <code class="inline">:sent</code> or <code class="inline">:chunked</code>.</p>
<p>Only the first value of the header <code class="inline">key</code> is updated if present.</p>
<h4 id="update_resp_header/4-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">Plug.Conn.update_resp_header(
  conn,
  "content-type",
  "application/json; charset=utf-8",
  &amp;(&amp;1 &lt;&gt; "; charset=utf-8")
)</pre> </section> </section> </div> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2013 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/plug/Plug.Conn.html" class="_attribution-link">https://hexdocs.pm/plug/Plug.Conn.html</a>
  </p>
</div>
