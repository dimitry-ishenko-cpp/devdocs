<h1>   <span translate="no">Ecto.Query</span>  </h1> <section id="moduledoc"> <p>Provides the Query DSL.</p>
<p>Queries are used to retrieve and manipulate data from a repository (see <a href="ecto.repo.html"><code class="inline">Ecto.Repo</code></a>). Ecto queries come in two flavors: keyword-based and macro-based. Most examples will use the keyword-based syntax, the macro one will be explored in later sections.</p>
<p>Let's see a sample query:</p>
<pre data-language="elixir"># Imports only from/2 of Ecto.Query
import Ecto.Query, only: [from: 2]

# Create a query
query = from u in "users",
          where: u.age &gt; 18,
          select: u.name

# Send the query to the repository
Repo.all(query)</pre>
<p>In the example above, we are directly querying the "users" table from the database.</p>
<h2 id="module-query-expressions" class="section-heading">  Query expressions </h2> <p>Ecto allows a limited set of expressions inside queries. In the query below, for example, we use <code class="inline">u.age</code> to access a field, the <code class="inline">&gt;</code> comparison operator and the literal <code class="inline">0</code>:</p>
<pre data-language="elixir">query = from u in "users", where: u.age &gt; 0, select: u.name</pre>
<p>You can find the full list of operations in <a href="ecto.query.api.html"><code class="inline">Ecto.Query.API</code></a>. Besides the operations listed there, the following literals are supported in queries:</p>
<ul>
<li>Integers: <code class="inline">1</code>, <code class="inline">2</code>, <code class="inline">3</code>
</li>
<li>Floats: <code class="inline">1.0</code>, <code class="inline">2.0</code>, <code class="inline">3.0</code>
</li>
<li>Booleans: <code class="inline">true</code>, <code class="inline">false</code>
</li>
<li>Binaries: <code class="inline">&lt;&lt;1, 2, 3&gt;&gt;</code>
</li>
<li>Strings: <code class="inline">"foo bar"</code>, <code class="inline">~s(this is a string)</code>
</li>
<li>Atoms (other than booleans and <code class="inline">nil</code>): <code class="inline">:foo</code>, <code class="inline">:bar</code>
</li>
<li>Arrays: <code class="inline">[1, 2, 3]</code>, <code class="inline">~w(interpolate words)</code>
</li>
</ul>
<p>All other types and dynamic values must be passed as a parameter using interpolation as explained below.</p>
<h2 id="module-interpolation-and-casting" class="section-heading">  Interpolation and casting </h2> <p>External values and Elixir expressions can be injected into a query expression with <code class="inline">^</code>:</p>
<pre data-language="elixir">def with_minimum(age, height_ft) do
  from u in "users",
    where: u.age &gt; ^age and u.height &gt; ^(height_ft * 3.28),
    select: u.name
end

with_minimum(18, 5.0)</pre>
<p>When interpolating values, you may want to explicitly tell Ecto what is the expected type of the value being interpolated:</p>
<pre data-language="elixir">age = "18"
Repo.all(from u in "users",
          where: u.age &gt; type(^age, :integer),
          select: u.name)</pre>
<p>In the example above, Ecto will cast the age to type integer. When a value cannot be cast, <a href="ecto.query.casterror.html"><code class="inline">Ecto.Query.CastError</code></a> is raised.</p>
<p>To avoid the repetition of always specifying the types, you may define an <a href="ecto.schema.html"><code class="inline">Ecto.Schema</code></a>. In such cases, Ecto will analyze your queries and automatically cast the interpolated "age" when compared to the <code class="inline">u.age</code> field, as long as the age field is defined with type <code class="inline">:integer</code> in your schema:</p>
<pre data-language="elixir">age = "18"
Repo.all(from u in User, where: u.age &gt; ^age, select: u.name)</pre>
<p>Another advantage of using schemas is that we no longer need to specify the select option in queries, as by default Ecto will retrieve all fields specified in the schema:</p>
<pre data-language="elixir">age = "18"
Repo.all(from u in User, where: u.age &gt; ^age)</pre>
<p>For this reason, we will use schemas on the remaining examples but remember Ecto does not require them in order to write queries.</p>
<h2 id="module-nil-comparison" class="section-heading">  <code class="inline">nil</code> comparison </h2> <p><code class="inline">nil</code> comparison in filters, such as where and having, is forbidden and it will raise an error:</p>
<pre data-language="elixir"># Raises if age is nil
from u in User, where: u.age == ^age</pre>
<p>This is done as a security measure to avoid attacks that attempt to traverse entries with nil columns. To check that value is <code class="inline">nil</code>, use <a href="https://hexdocs.pm/elixir/Kernel.html#is_nil/1"><code class="inline">is_nil/1</code></a> instead:</p>
<pre data-language="elixir">from u in User, where: is_nil(u.age)</pre>
<h2 id="module-composition" class="section-heading">  Composition </h2> <p>Ecto queries are composable. For example, the query above can actually be defined in two parts:</p>
<pre data-language="elixir"># Create a query
query = from u in User, where: u.age &gt; 18

# Extend the query
query = from u in query, select: u.name</pre>
<p>Composing queries uses the same syntax as creating a query. The difference is that, instead of passing a schema like <code class="inline">User</code> on the right-hand side of <code class="inline">in</code>, we passed the query itself.</p>
<p>Any value can be used on the right-hand side of <code class="inline">in</code> as long as it implements the <a href="ecto.queryable.html"><code class="inline">Ecto.Queryable</code></a> protocol. For now, we know the protocol is implemented for both atoms (like <code class="inline">User</code>) and strings (like "users").</p>
<p>In any case, regardless if a schema has been given or not, Ecto queries are always composable thanks to its binding system.</p>
<h3 id="module-positional-bindings" class="section-heading">  Positional bindings </h3> <p>On the left-hand side of <code class="inline">in</code> we specify the query bindings. This is done inside <code class="inline">from</code> and <code class="inline">join</code> clauses. In the query below <code class="inline">u</code> is a binding and <code class="inline">u.age</code> is a field access using this binding.</p>
<pre data-language="elixir">query = from u in User, where: u.age &gt; 18</pre>
<p>Bindings are not exposed from the query. When composing queries, you must specify bindings again for each refinement query. For example, to further narrow down the above query, we again need to tell Ecto what bindings to expect:</p>
<pre data-language="elixir">query = from u in query, select: u.city</pre>
<p>Bindings in Ecto are positional, and the names do not have to be consistent between input and refinement queries. For example, the query above could also be written as:</p>
<pre data-language="elixir">query = from q in query, select: q.city</pre>
<p>It would make no difference to Ecto. This is important because it allows developers to compose queries without caring about the bindings used in the initial query.</p>
<p>When using joins, the bindings should be matched in the order they are specified:</p>
<pre data-language="elixir"># Create a query
query = from p in Post,
          join: c in Comment, on: c.post_id == p.id

# Extend the query
query = from [p, c] in query,
          select: {p.title, c.body}</pre>
<p>You are not required to specify all bindings when composing. For example, if we would like to order the results above by post insertion date, we could further extend it as:</p>
<pre data-language="elixir">query = from q in query, order_by: q.inserted_at</pre>
<p>The example above will work if the input query has 1 or 10 bindings. As long as the number of bindings is less than the number of <code class="inline">from</code>s + <code class="inline">join</code>s, Ecto will match only what you have specified. The first binding always matches the source given in <code class="inline">from</code>.</p>
<p>Similarly, if you are interested only in the last binding (or the last bindings) in a query, you can use <code class="inline">...</code> to specify "all bindings before" and match on the last one.</p>
<p>For instance, imagine you wrote:</p>
<pre data-language="elixir">posts_with_comments =
  from p in query, join: c in Comment, on: c.post_id == p.id</pre>
<p>And now we want to make sure to return both the post title and the comment body. Although we may not know how many bindings there are in the query, we are sure posts is the first binding and comments are the last one, so we can write:</p>
<pre data-language="elixir">from [p, ..., c] in posts_with_comments, select: {p.title, c.body}</pre>
<p>In other words, <code class="inline">...</code> will include all the bindings between the first and the last, which may be one, many or no bindings at all.</p>
<h3 id="module-named-bindings" class="section-heading">  Named bindings </h3> <p>Another option for flexibly building queries with joins are named bindings. Coming back to the previous example, we can use the <code class="inline">as: :comment</code> option to bind the comments join to a concrete name:</p>
<pre data-language="elixir">posts_with_comments =
  from p in Post,
    join: c in Comment, as: :comment, on: c.post_id == p.id</pre>
<p>Now we can refer to it using the following form of a bindings list:</p>
<pre data-language="elixir">from [p, comment: c] in posts_with_comments, select: {p.title, c.body}</pre>
<p>This approach lets us not worry about keeping track of the position of the bindings when composing the query. The <code class="inline">:as</code> option can be given both on joins and on <code class="inline">from</code>:</p>
<pre data-language="elixir">from p in Post, as: :post</pre>
<p>Only atoms are accepted for binding names. Named binding references must always be placed at the end of the bindings list:</p>
<pre data-language="elixir">[positional_binding_1, positional_binding_2, named_1: binding, named_2: binding]</pre>
<p>Named bindings can also be used for late binding with the <code class="inline">as/1</code> construct, allowing you to refer to a binding that has not been defined yet:</p>
<pre data-language="elixir">from c in Comment, where: as(:posts).id == c.post_id</pre>
<p>This is especially useful when working with subqueries, where you may need to refer to a parent binding with <code class="inline">parent_as</code>, which is not known when writing the subquery:</p>
<pre data-language="elixir">child_query = from c in Comment, where: parent_as(:posts).id == c.post_id
from p in Post, as: :posts, inner_lateral_join: c in subquery(child_query)</pre>
<p>You can also match on a specific binding when building queries. For example, let's suppose you want to create a generic sort function that will order by a given <code class="inline">field</code> with a given <code class="inline">as</code> in <code class="inline">query</code>:</p>
<pre data-language="elixir"># Knowing the name of the binding
def sort(query, as, field) do
  from [{^as, x}] in query, order_by: field(x, ^field)
end</pre>
<h3 id="module-bindingless-operations" class="section-heading">  Bindingless operations </h3> <p>Although bindings are extremely useful when working with joins, they are not necessary when the query has only the <code class="inline">from</code> clause. For such cases, Ecto supports a way for building queries without specifying the binding:</p>
<pre data-language="elixir">from Post,
  where: [category: "fresh and new"],
  order_by: [desc: :published_at],
  select: [:id, :title, :body]</pre>
<p>The query above will select all posts with category "fresh and new", order by the most recently published, and return Post structs with only the id, title and body fields set. It is equivalent to:</p>
<pre data-language="elixir">from p in Post,
  where: p.category == "fresh and new",
  order_by: [desc: p.published_at],
  select: struct(p, [:id, :title, :body])</pre>
<p>One advantage of bindingless queries is that they are data-driven and therefore useful for dynamically building queries. For example, the query above could also be written as:</p>
<pre data-language="elixir">where = [category: "fresh and new"]
order_by = [desc: :published_at]
select = [:id, :title, :body]
from Post, where: ^where, order_by: ^order_by, select: ^select</pre>
<p>This feature is very useful when queries need to be built based on some user input, like web search forms, CLIs and so on.</p>
<h2 id="module-fragments" class="section-heading">  Fragments </h2> <p>If you need an escape hatch, Ecto provides fragments (see <a href="ecto.query.api.html#fragment/1"><code class="inline">Ecto.Query.API.fragment/1</code></a>) to inject SQL (and non-SQL) fragments into queries.</p>
<p>For example, to get all posts while running the "lower(?)" function in the database where <code class="inline">p.title</code> is interpolated in place of <code class="inline">?</code>, one can write:</p>
<pre data-language="elixir">from p in Post,
  where: is_nil(p.published_at) and
         fragment("lower(?)", p.title) == ^title</pre>
<p>Also, most adapters provide direct APIs for queries, like <code class="inline">Ecto.Adapters.SQL.query/4</code>, allowing developers to completely bypass Ecto queries.</p>
<h2 id="module-macro-api" class="section-heading">  Macro API </h2> <p>In all examples so far we have used the <strong>keywords query syntax</strong> to create a query:</p>
<pre data-language="elixir">import Ecto.Query
from u in "users", where: u.age &gt; 18, select: u.name</pre>
<p>Due to the prevalence of the pipe operator in Elixir, Ecto also supports a pipe-based syntax:</p>
<pre data-language="elixir">"users"
|&gt; where([u], u.age &gt; 18)
|&gt; select([u], u.name)</pre>
<p>The keyword-based and pipe-based examples are equivalent. The downside of using macros is that the binding must be specified for every operation. However, since keyword-based and pipe-based examples are equivalent, the bindingless syntax also works for macros:</p>
<pre data-language="elixir">"users"
|&gt; where([u], u.age &gt; 18)
|&gt; select([:name])</pre>
<p>Such a syntax allows developers to write queries using bindings only in more complex query expressions.</p>
<p>This module documents each of those macros, providing examples in both the keywords query and pipe expression formats.</p>
<h2 id="module-query-prefix" class="section-heading">  Query prefix </h2> <p>It is possible to set a prefix for the queries. For Postgres users, this will specify the schema where the table is located, while for MySQL users this will specify the database where the table is located. When no prefix is set, Postgres queries are assumed to be in the public schema, while MySQL queries are assumed to be in the database set in the config for the repo.</p>
<p>The query prefix may be set either for the whole query or on each individual <code class="inline">from</code> and <code class="inline">join</code> expression. If a <code class="inline">prefix</code> is not given to a <code class="inline">from</code> or a <code class="inline">join</code>, the prefix of the schema given to the <code class="inline">from</code> or <code class="inline">join</code> is used. The query prefix is used only if none of the above are declared.</p>
<p>Let's see some examples. To see the query prefix globally, the simplest mechanism is to pass an option to the repository operation:</p>
<pre data-language="elixir">results = Repo.all(query, prefix: "accounts")</pre>
<p>You may also set the prefix for the whole query by setting the prefix field:</p>
<pre data-language="elixir">results =
  query # May be User or an Ecto.Query itself
  |&gt; Ecto.Query.put_query_prefix("accounts")
  |&gt; Repo.all()</pre>
<p>Setting the prefix in the query changes the default prefix of all <code class="inline">from</code> and <code class="inline">join</code> expressions. You can override the query prefix by either setting the <code class="inline">@schema_prefix</code> in your schema definitions or by passing the prefix option:</p>
<pre data-language="elixir">from u in User,
  prefix: "accounts",
  join: p in assoc(u, :posts),
  prefix: "public"</pre>
<p>Overall, here is the prefix lookup precedence:</p>
<ol>
<li>The <code class="inline">:prefix</code> option given to <code class="inline">from</code>/<code class="inline">join</code> has the highest precedence</li>
<li>Then it falls back to the <code class="inline">@schema_prefix</code> attribute declared in the schema given to <code class="inline">from</code>/<code class="inline">join</code>
</li>
<li>Then it falls back to the query prefix</li>
</ol>
<p>The prefixes set in the query will be preserved when loading data.</p> </section> <section id="summary" class="details-list"> <h1 class="section-heading">  Summary </h1> <h2> Types </h2>
<dl class="summary-types summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#t:dynamic/0" translate="no">dynamic()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:t/0" translate="no">t()</a> </dt> </div> </dl> <h2> Functions </h2>
<dl class="summary-functions summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#distinct/3" translate="no">distinct(query, binding \\ [], expr)</a> </dt> <dd class="summary-synopsis"><p>A distinct query expression.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#dynamic/2" translate="no">dynamic(binding \\ [], expr)</a> </dt> <dd class="summary-synopsis"><p>Builds a dynamic query expression.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#except/2" translate="no">except(query, other_query)</a> </dt> <dd class="summary-synopsis"><p>An except (set difference) query expression.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#except_all/2" translate="no">except_all(query, other_query)</a> </dt> <dd class="summary-synopsis"><p>An except (set difference) query expression.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#exclude/2" translate="no">exclude(query, field)</a> </dt> <dd class="summary-synopsis"><p>Resets a previously set field on a query.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#first/2" translate="no">first(queryable, order_by \\ nil)</a> </dt> <dd class="summary-synopsis"><p>Restricts the query to return the first result ordered by primary key.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#from/2" translate="no">from(expr, kw \\ [])</a> </dt> <dd class="summary-synopsis"><p>Creates a query.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#group_by/3" translate="no">group_by(query, binding \\ [], expr)</a> </dt> <dd class="summary-synopsis"><p>A group by query expression.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#has_named_binding?/2" translate="no">has_named_binding?(queryable, key)</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if the query has a binding with the given name, otherwise <code class="inline">false</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#having/3" translate="no">having(query, binding \\ [], expr)</a> </dt> <dd class="summary-synopsis"><p>An AND having query expression.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#intersect/2" translate="no">intersect(query, other_query)</a> </dt> <dd class="summary-synopsis"><p>An intersect query expression.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#intersect_all/2" translate="no">intersect_all(query, other_query)</a> </dt> <dd class="summary-synopsis"><p>An intersect query expression.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#join/5" translate="no">join(query, qual, binding \\ [], expr, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>A join query expression.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#last/2" translate="no">last(queryable, order_by \\ nil)</a> </dt> <dd class="summary-synopsis"><p>Restricts the query to return the last result ordered by primary key.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#limit/3" translate="no">limit(query, binding \\ [], expr)</a> </dt> <dd class="summary-synopsis"><p>A limit query expression.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#lock/3" translate="no">lock(query, binding \\ [], expr)</a> </dt> <dd class="summary-synopsis"><p>A lock query expression.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#offset/3" translate="no">offset(query, binding \\ [], expr)</a> </dt> <dd class="summary-synopsis"><p>An offset query expression.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#or_having/3" translate="no">or_having(query, binding \\ [], expr)</a> </dt> <dd class="summary-synopsis"><p>An OR having query expression.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#or_where/3" translate="no">or_where(query, binding \\ [], expr)</a> </dt> <dd class="summary-synopsis"><p>An OR where query expression.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#order_by/3" translate="no">order_by(query, binding \\ [], expr)</a> </dt> <dd class="summary-synopsis"><p>An order by query expression.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#preload/3" translate="no">preload(query, bindings \\ [], expr)</a> </dt> <dd class="summary-synopsis"><p>Preloads the associations into the result set.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#put_query_prefix/2" translate="no">put_query_prefix(query, prefix)</a> </dt> <dd class="summary-synopsis"><p>Puts the given prefix in a query.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#recursive_ctes/2" translate="no">recursive_ctes(query, value)</a> </dt> <dd class="summary-synopsis"><p>Enables or disables recursive mode for CTEs.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#reverse_order/1" translate="no">reverse_order(query)</a> </dt> <dd class="summary-synopsis"><p>Reverses the ordering of the query.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#select/3" translate="no">select(query, binding \\ [], expr)</a> </dt> <dd class="summary-synopsis"><p>A select query expression.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#select_merge/3" translate="no">select_merge(query, binding \\ [], expr)</a> </dt> <dd class="summary-synopsis"><p>Mergeable select query expression.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#subquery/2" translate="no">subquery(query, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Converts a query into a subquery.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#union/2" translate="no">union(query, other_query)</a> </dt> <dd class="summary-synopsis"><p>A union query expression.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#union_all/2" translate="no">union_all(query, other_query)</a> </dt> <dd class="summary-synopsis"><p>A union all query expression.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#update/3" translate="no">update(query, binding \\ [], expr)</a> </dt> <dd class="summary-synopsis"><p>An update query expression.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#where/3" translate="no">where(query, binding \\ [], expr)</a> </dt> <dd class="summary-synopsis"><p>An AND where query expression.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#windows/3" translate="no">windows(query, binding \\ [], expr)</a> </dt> <dd class="summary-synopsis"><p>Defines windows which can be used with <a href="ecto.query.windowapi.html"><code class="inline">Ecto.Query.WindowAPI</code></a>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#with_cte/3" translate="no">with_cte(query, name, list)</a> </dt> <dd class="summary-synopsis"><p>A common table expression (CTE) also known as WITH expression.</p></dd> </div> </dl> </section> <section id="types" class="details-list"> <h1 class="section-heading">  Types </h1> <div class="types-list"> <section class="detail"> <h3 class="detail-header" id="t:dynamic/0">dynamic()<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/query.ex#L430" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@opaque dynamic()</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:t/0">t()<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/query.ex#L429" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type t() :: %Ecto.Query{
  aliases: term(),
  assocs: term(),
  combinations: term(),
  distinct: term(),
  from: term(),
  group_bys: term(),
  havings: term(),
  joins: term(),
  limit: term(),
  lock: term(),
  offset: term(),
  order_bys: term(),
  prefix: term(),
  preloads: term(),
  select: term(),
  sources: term(),
  updates: term(),
  wheres: term(),
  windows: term(),
  with_ctes: term()
}</pre> </div> </section> </section> </div> </section> <section id="functions" class="details-list"> <h1 class="section-heading">  Functions </h1> <div class="functions-list"> <section class="detail">  <h3 class="detail-header" id="distinct/3">distinct(query, binding \\ [], expr)<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/query.ex#L1356" class="source">Source</a>
</h3> <section class="docstring"> <p>A distinct query expression.</p>
<p>When true, only keeps distinct values from the resulting select expression.</p>
<p>If supported by your database, you can also pass query expressions to distinct and it will generate a query with DISTINCT ON. In such cases, <code class="inline">distinct</code> accepts exactly the same expressions as <code class="inline">order_by</code> and any <code class="inline">distinct</code> expression will be automatically prepended to the <code class="inline">order_by</code> expressions in case there is any <code class="inline">order_by</code> expression.</p>
<h4 id="distinct/3-keywords-examples" class="section-heading">  Keywords examples </h4> <pre data-language="elixir"># Returns the list of different categories in the Post schema
from(p in Post, distinct: true, select: p.category)

# If your database supports DISTINCT ON(),
# you can pass expressions to distinct too
from(p in Post,
   distinct: p.category,
   order_by: [p.date])

# The DISTINCT ON() also supports ordering similar to ORDER BY.
from(p in Post,
   distinct: [desc: p.category],
   order_by: [p.date])

# Using atoms
from(p in Post, distinct: :category, order_by: :date)</pre>
<h4 id="distinct/3-expressions-example" class="section-heading">  Expressions example </h4> <pre data-language="elixir">Post
|&gt; distinct(true)
|&gt; order_by([p], [p.category, p.author])</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="dynamic/2">dynamic(binding \\ [], expr)<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/query.ex#L542" class="source">Source</a>
</h3> <section class="docstring"> <p>Builds a dynamic query expression.</p>
<p>Dynamic query expressions allow developers to compose query expressions bit by bit, so that they can be interpolated into parts of a query or another dynamic expression later on.</p>
<h4 id="dynamic/2-examples" class="section-heading">  Examples </h4> <p>Imagine you have a set of conditions you want to build your query on:</p>
<pre data-language="elixir">conditions = false

conditions =
  if params["is_public"] do
    dynamic([p], p.is_public or ^conditions)
  else
    conditions
  end

conditions =
  if params["allow_reviewers"] do
    dynamic([p, a], a.reviewer == true or ^conditions)
  else
    conditions
  end

from query, where: ^conditions</pre>
<p>In the example above, we were able to build the query expressions bit by bit, using different bindings, and later interpolate it all at once into the actual query.</p>
<p>A dynamic expression can always be interpolated inside another dynamic expression and into the constructs described below.</p>
<h4 id="dynamic/2-where-having-and-a-join-s-on" class="section-heading">  <code class="inline">where</code>, <code class="inline">having</code> and a <code class="inline">join</code>'s <code class="inline">on</code> </h4> <p>The <code class="inline">dynamic</code> macro can be interpolated at the root of a <code class="inline">where</code>, <code class="inline">having</code> or a <code class="inline">join</code>'s <code class="inline">on</code>.</p>
<p>For example, assuming the <code class="inline">conditions</code> variable defined in the previous section, the following is forbidden because it is not at the root of a <code class="inline">where</code>:</p>
<pre data-language="elixir">from q in query, where: q.some_condition and ^conditions</pre>
<p>Fortunately that's easily solved by simply rewriting it to:</p>
<pre data-language="elixir">conditions = dynamic([q], q.some_condition and ^conditions)
from query, where: ^conditions</pre>
<h4 id="dynamic/2-order_by" class="section-heading">  <code class="inline">order_by</code> </h4> <p>Dynamics can be interpolated inside keyword lists at the root of <code class="inline">order_by</code>. For example, you can write:</p>
<pre data-language="elixir">order_by = [
  asc: :some_field,
  desc: dynamic([p], fragment("?&gt;&gt;?", p.another_field, "json_key"))
]

from query, order_by: ^order_by</pre>
<p>Dynamics are also supported in <a href="#order_by/2"><code class="inline">order_by/2</code></a> clauses inside <a href="#windows/2"><code class="inline">windows/2</code></a>.</p>
<p>As with <code class="inline">where</code> and friends, it is not possible to pass dynamics outside of a root. For example, this won't work:</p>
<pre data-language="elixir">from query, order_by: [asc: ^dynamic(...)]</pre>
<p>But this will:</p>
<pre data-language="elixir">from query, order_by: ^[asc: dynamic(...)]</pre>
<h4 id="dynamic/2-group_by" class="section-heading">  <code class="inline">group_by</code> </h4> <p>Dynamics can be interpolated inside keyword lists at the root of <code class="inline">group_by</code>. For example, you can write:</p>
<pre data-language="elixir">group_by = [
  :some_field,
  dynamic([p], fragment("?&gt;&gt;?", p.another_field, "json_key"))
]

from query, group_by: ^group_by</pre>
<p>Dynamics are also supported in <code class="inline">partition_by/2</code> clauses inside <a href="#windows/2"><code class="inline">windows/2</code></a>.</p>
<p>As with <code class="inline">where</code> and friends, it is not possible to pass dynamics outside of a root. For example, this won't work:</p>
<pre data-language="elixir">from query, group_by: [:some_field, ^dynamic(...)]</pre>
<p>But this will:</p>
<pre data-language="elixir">from query, group_by: ^[:some_field, dynamic(...)]</pre>
<h4 id="dynamic/2-updates" class="section-heading">  Updates </h4> <p>A <code class="inline">dynamic</code> is also supported inside updates, for example:</p>
<pre data-language="elixir">updates = [
  set: [average: dynamic([p], p.sum / p.count)]
]

from query, update: ^updates</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="except/2">except(query, other_query)<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/query.ex#L1594" class="source">Source</a>
</h3> <section class="docstring"> <p>An except (set difference) query expression.</p>
<p>Takes the difference of the result sets of multiple queries. The <code class="inline">select</code> of each query must be exactly the same, with the same types in the same order.</p>
<p>Except expression returns only unique rows as if each query returned distinct results. This may cause a performance penalty. If you need to take the difference of multiple result sets without removing duplicate rows consider using <a href="#except_all/2"><code class="inline">except_all/2</code></a>.</p>
<p>Note that the operations <code class="inline">order_by</code>, <code class="inline">limit</code> and <code class="inline">offset</code> of the current <code class="inline">query</code> apply to the result of the set difference.</p>
<h4 id="except/2-keywords-example" class="section-heading">  Keywords example </h4> <pre data-language="elixir">supplier_query = from s in Supplier, select: s.city
from c in Customer, select: c.city, except: ^supplier_query</pre>
<h4 id="except/2-expressions-example" class="section-heading">  Expressions example </h4> <pre data-language="elixir">supplier_query = Supplier |&gt; select([s], s.city)
Customer |&gt; select([c], c.city) |&gt; except(^supplier_query)</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="except_all/2">except_all(query, other_query)<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/query.ex#L1618" class="source">Source</a>
</h3> <section class="docstring"> <p>An except (set difference) query expression.</p>
<p>Takes the difference of the result sets of multiple queries. The <code class="inline">select</code> of each query must be exactly the same, with the same types in the same order.</p>
<p>Note that the operations <code class="inline">order_by</code>, <code class="inline">limit</code> and <code class="inline">offset</code> of the current <code class="inline">query</code> apply to the result of the set difference.</p>
<h4 id="except_all/2-keywords-example" class="section-heading">  Keywords example </h4> <pre data-language="elixir">supplier_query = from s in Supplier, select: s.city
from c in Customer, select: c.city, except_all: ^supplier_query</pre>
<h4 id="except_all/2-expressions-example" class="section-heading">  Expressions example </h4> <pre data-language="elixir">supplier_query = Supplier |&gt; select([s], s.city)
Customer |&gt; select([c], c.city) |&gt; except_all(^supplier_query)</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="exclude/2">exclude(query, field)<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/query.ex#L723" class="source">Source</a>
</h3> <section class="docstring"> <p>Resets a previously set field on a query.</p>
<p>It can reset many fields except the query source (<code class="inline">from</code>). When excluding a <code class="inline">:join</code>, it will remove <em>all</em> types of joins. If you prefer to remove a single type of join, please see paragraph below.</p>
<h4 id="exclude/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">Ecto.Query.exclude(query, :join)
Ecto.Query.exclude(query, :where)
Ecto.Query.exclude(query, :order_by)
Ecto.Query.exclude(query, :group_by)
Ecto.Query.exclude(query, :having)
Ecto.Query.exclude(query, :distinct)
Ecto.Query.exclude(query, :select)
Ecto.Query.exclude(query, :combinations)
Ecto.Query.exclude(query, :with_ctes)
Ecto.Query.exclude(query, :limit)
Ecto.Query.exclude(query, :offset)
Ecto.Query.exclude(query, :lock)
Ecto.Query.exclude(query, :preload)</pre>
<p>You can also remove specific joins as well such as <code class="inline">left_join</code> and <code class="inline">inner_join</code>:</p>
<pre data-language="elixir">Ecto.Query.exclude(query, :inner_join)
Ecto.Query.exclude(query, :cross_join)
Ecto.Query.exclude(query, :left_join)
Ecto.Query.exclude(query, :right_join)
Ecto.Query.exclude(query, :full_join)
Ecto.Query.exclude(query, :inner_lateral_join)
Ecto.Query.exclude(query, :left_lateral_join)</pre>
<p>However, keep in mind that if a join is removed and its bindings were referenced elsewhere, the bindings won't be removed, leading to a query that won't compile.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="first/2">first(queryable, order_by \\ nil)<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/query.ex#L2047" class="source">Source</a>
</h3> <section class="docstring"> <p>Restricts the query to return the first result ordered by primary key.</p>
<p>The query will be automatically ordered by the primary key unless <code class="inline">order_by</code> is given or <code class="inline">order_by</code> is set in the query. Limit is always set to 1.</p>
<h4 id="first/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">Post |&gt; first |&gt; Repo.one
query |&gt; first(:inserted_at) |&gt; Repo.one</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="from/2">from(expr, kw \\ [])<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/query.ex#L803" class="source">Source</a>
</h3> <section class="docstring"> <p>Creates a query.</p>
<p>It can either be a keyword query or a query expression.</p>
<p>If it is a keyword query the first argument must be either an <code class="inline">in</code> expression, or a value that implements the <a href="ecto.queryable.html"><code class="inline">Ecto.Queryable</code></a> protocol. If the query needs a reference to the data source in any other part of the expression, then an <code class="inline">in</code> must be used to create a reference variable. The second argument should be a keyword query where the keys are expression types and the values are expressions.</p>
<p>If it is a query expression the first argument must be a value that implements the <a href="ecto.queryable.html"><code class="inline">Ecto.Queryable</code></a> protocol and the second argument the expression.</p>
<h4 id="from/2-keywords-example" class="section-heading">  Keywords example </h4> <pre data-language="elixir">from(c in City, select: c)</pre>
<h4 id="from/2-expressions-example" class="section-heading">  Expressions example </h4> <pre data-language="elixir">City |&gt; select([c], c)</pre>
<h4 id="from/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">def paginate(query, page, size) do
  from query,
    limit: ^size,
    offset: ^((page-1) * size)
end</pre>
<p>The example above does not use <code class="inline">in</code> because <code class="inline">limit</code> and <code class="inline">offset</code> do not require a reference to the data source. However, extending the query with a where expression would require the use of <code class="inline">in</code>:</p>
<pre data-language="elixir">def published(query) do
  from p in query, where: not(is_nil(p.published_at))
end</pre>
<p>Notice we have created a <code class="inline">p</code> variable to reference the query's original data source. This assumes that the original query only had one source. When the given query has more than one source, positional or named bindings may be used to access the additional sources.</p>
<pre data-language="elixir">def published_multi(query) do
  from [p,o] in query,
  where: not(is_nil(p.published_at)) and not(is_nil(o.published_at))
end</pre>
<p>Note that the variables <code class="inline">p</code> and <code class="inline">o</code> can be named whatever you like as they have no importance in the query sent to the database.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="group_by/3">group_by(query, binding \\ [], expr)<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/query.ex#L1827" class="source">Source</a>
</h3> <section class="docstring"> <p>A group by query expression.</p>
<p>Groups together rows from the schema that have the same values in the given fields. Using <code class="inline">group_by</code> "groups" the query giving it different semantics in the <code class="inline">select</code> expression. If a query is grouped, only fields that were referenced in the <code class="inline">group_by</code> can be used in the <code class="inline">select</code> or if the field is given as an argument to an aggregate function.</p>
<p><code class="inline">group_by</code> also accepts a list of atoms where each atom refers to a field in source. For more complicated queries you can access fields directly instead of atoms.</p>
<h4 id="group_by/3-keywords-examples" class="section-heading">  Keywords examples </h4> <pre data-language="elixir"># Returns the number of posts in each category
from(p in Post,
  group_by: p.category,
  select: {p.category, count(p.id)})

# Using atoms
from(p in Post, group_by: :category, select: {p.category, count(p.id)})

# Using direct fields access
from(p in Post,
  join: c in assoc(p, :category),
  group_by: [p.id, c.name])</pre>
<h4 id="group_by/3-expressions-example" class="section-heading">  Expressions example </h4> <pre data-language="elixir">Post |&gt; group_by([p], p.category) |&gt; select([p], count(p.id))</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="has_named_binding?/2">has_named_binding?(queryable, key)<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/query.ex#L2103" class="source">Source</a>
</h3> <section class="docstring"> <p>Returns <code class="inline">true</code> if the query has a binding with the given name, otherwise <code class="inline">false</code>.</p>
<p>For more information on named bindings see "Named bindings" in this module doc.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="having/3">having(query, binding \\ [], expr)<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/query.ex#L1855" class="source">Source</a>
</h3> <section class="docstring"> <p>An AND having query expression.</p>
<p>Like <code class="inline">where</code>, <code class="inline">having</code> filters rows from the schema, but after the grouping is performed giving it the same semantics as <code class="inline">select</code> for a grouped query (see <a href="#group_by/3"><code class="inline">group_by/3</code></a>). <code class="inline">having</code> groups the query even if the query has no <code class="inline">group_by</code> expression.</p>
<h4 id="having/3-keywords-example" class="section-heading">  Keywords example </h4> <pre data-language="elixir"># Returns the number of posts in each category where the
# average number of comments is above ten
from(p in Post,
  group_by: p.category,
  having: avg(p.num_comments) &gt; 10,
  select: {p.category, count(p.id)})</pre>
<h4 id="having/3-expressions-example" class="section-heading">  Expressions example </h4> <pre data-language="elixir">Post
|&gt; group_by([p], p.category)
|&gt; having([p], avg(p.num_comments) &gt; 10)
|&gt; select([p], count(p.id))</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="intersect/2">intersect(query, other_query)<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/query.ex#L1647" class="source">Source</a>
</h3> <section class="docstring"> <p>An intersect query expression.</p>
<p>Takes the overlap of the result sets of multiple queries. The <code class="inline">select</code> of each query must be exactly the same, with the same types in the same order.</p>
<p>Intersect expression returns only unique rows as if each query returned distinct results. This may cause a performance penalty. If you need to take the intersection of multiple result sets without removing duplicate rows consider using <a href="#intersect_all/2"><code class="inline">intersect_all/2</code></a>.</p>
<p>Note that the operations <code class="inline">order_by</code>, <code class="inline">limit</code> and <code class="inline">offset</code> of the current <code class="inline">query</code> apply to the result of the set difference.</p>
<h4 id="intersect/2-keywords-example" class="section-heading">  Keywords example </h4> <pre data-language="elixir">supplier_query = from s in Supplier, select: s.city
from c in Customer, select: c.city, intersect: ^supplier_query</pre>
<h4 id="intersect/2-expressions-example" class="section-heading">  Expressions example </h4> <pre data-language="elixir">supplier_query = Supplier |&gt; select([s], s.city)
Customer |&gt; select([c], c.city) |&gt; intersect(^supplier_query)</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="intersect_all/2">intersect_all(query, other_query)<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/query.ex#L1671" class="source">Source</a>
</h3> <section class="docstring"> <p>An intersect query expression.</p>
<p>Takes the overlap of the result sets of multiple queries. The <code class="inline">select</code> of each query must be exactly the same, with the same types in the same order.</p>
<p>Note that the operations <code class="inline">order_by</code>, <code class="inline">limit</code> and <code class="inline">offset</code> of the current <code class="inline">query</code> apply to the result of the set difference.</p>
<h4 id="intersect_all/2-keywords-example" class="section-heading">  Keywords example </h4> <pre data-language="elixir">supplier_query = from s in Supplier, select: s.city
from c in Customer, select: c.city, intersect_all: ^supplier_query</pre>
<h4 id="intersect_all/2-expressions-example" class="section-heading">  Expressions example </h4> <pre data-language="elixir">supplier_query = Supplier |&gt; select([s], s.city)
Customer |&gt; select([c], c.city) |&gt; intersect_all(^supplier_query)</pre> </section> </section> <section class="detail">   <h3 class="detail-header" id="join/5">join(query, qual, binding \\ [], expr, opts \\ [])<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/query.ex#L1057" class="source">Source</a>
</h3> <section class="docstring"> <p>A join query expression.</p>
<p>Receives a source that is to be joined to the query and a condition for the join. The join condition can be any expression that evaluates to a boolean value. The qualifier must be one of <code class="inline">:inner</code>, <code class="inline">:left</code>, <code class="inline">:right</code>, <code class="inline">:cross</code>, <code class="inline">:full</code>, <code class="inline">:inner_lateral</code> or <code class="inline">:left_lateral</code>.</p>
<p>For a keyword query the <code class="inline">:join</code> keyword can be changed to <code class="inline">:inner_join</code>, <code class="inline">:left_join</code>, <code class="inline">:right_join</code>, <code class="inline">:cross_join</code>, <code class="inline">:full_join</code>, <code class="inline">:inner_lateral_join</code> or <code class="inline">:left_lateral_join</code>. <code class="inline">:join</code> is equivalent to <code class="inline">:inner_join</code>.</p>
<p>Currently it is possible to join on:</p>
<ul>
<li>an <a href="ecto.schema.html"><code class="inline">Ecto.Schema</code></a>, such as <code class="inline">p in Post</code>
</li>
<li>an interpolated Ecto query with zero or more <code class="inline">where</code> clauses, such as <code class="inline">c in ^(from "posts", where: [public: true])</code>
</li>
<li>an association, such as <code class="inline">c in assoc(post, :comments)</code>
</li>
<li>a subquery, such as <code class="inline">c in subquery(another_query)</code>
</li>
<li>a query fragment, such as <code class="inline">c in fragment("SOME COMPLEX QUERY")</code>, see "Joining with fragments" below.</li>
</ul>
<h4 id="join/5-options" class="section-heading">  Options </h4> <p>Each join accepts the following options:</p>
<ul>
<li>
<code class="inline">:on</code> - a query expression or keyword list to filter the join</li>
<li>
<code class="inline">:as</code> - a named binding for the join</li>
<li>
<code class="inline">:prefix</code> - the prefix to be used for the join when issuing a database query</li>
<li>
<code class="inline">:hints</code> - a string or a list of strings to be used as database hints</li>
</ul>
<p>In the keyword query syntax, those options must be given immediately after the join. In the expression syntax, the options are given as the fifth argument.</p>
<h4 id="join/5-keywords-examples" class="section-heading">  Keywords examples </h4> <pre data-language="elixir">from c in Comment,
  join: p in Post,
  on: p.id == c.post_id,
  select: {p.title, c.text}

from p in Post,
  left_join: c in assoc(p, :comments),
  select: {p, c}</pre>
<p>Keywords can also be given or interpolated as part of <code class="inline">on</code>:</p>
<pre data-language="elixir">from c in Comment,
  join: p in Post,
  on: [id: c.post_id],
  select: {p.title, c.text}</pre>
<p>Any key in <code class="inline">on</code> will apply to the currently joined expression.</p>
<p>It is also possible to interpolate an Ecto query on the right-hand side of <code class="inline">in</code>. For example, the query above can also be written as:</p>
<pre data-language="elixir">posts = Post
from c in Comment,
  join: p in ^posts,
  on: [id: c.post_id],
  select: {p.title, c.text}</pre>
<p>The above is specially useful to dynamically join on existing queries, for example, to dynamically choose a source, or by choosing between public posts or posts that have been recently published:</p>
<pre data-language="elixir">posts =
  if params["drafts"] do
    from p in Post, where: [drafts: true]
  else
    from p in Post, where: [public: true]
  end

from c in Comment,
  join: p in ^posts, on: [id: c.post_id],
  select: {p.title, c.text}</pre>
<p>Only simple queries with <code class="inline">where</code> expressions can be interpolated in a join.</p>
<h4 id="join/5-expressions-examples" class="section-heading">  Expressions examples </h4> <pre data-language="elixir">Comment
|&gt; join(:inner, [c], p in Post, on: c.post_id == p.id)
|&gt; select([c, p], {p.title, c.text})

Post
|&gt; join(:left, [p], c in assoc(p, :comments))
|&gt; select([p, c], {p, c})

Post
|&gt; join(:left, [p], c in Comment, on: c.post_id == p.id and c.is_visible == true)
|&gt; select([p, c], {p, c})</pre>
<h4 id="join/5-joining-with-fragments" class="section-heading">  Joining with fragments </h4> <p>When you need to join on a complex query, Ecto supports fragments in joins:</p>
<pre data-language="elixir">Comment
|&gt; join(:inner, [c], p in fragment("SOME COMPLEX QUERY", c.id, ^some_param))</pre>
<p>Although using fragments in joins is discouraged in favor of Ecto Query syntax, they are necessary when writing lateral joins as lateral joins require a subquery that refer to previous bindings:</p>
<pre data-language="elixir">Game
|&gt; join(:inner_lateral, [g], gs in fragment("SELECT * FROM games_sold AS gs WHERE gs.game_id = ? ORDER BY gs.sold_on LIMIT 2", g.id))
|&gt; select([g, gs], {g.name, gs.sold_on})</pre>
<p>Note that the <code class="inline">join</code> does not automatically wrap the fragment in parentheses, since some expressions require parens and others require no parens. Therefore, in cases such as common table expressions, you will have to explicitly wrap the fragment content in parens.</p>
<h4 id="join/5-hints" class="section-heading">  Hints </h4> <p><code class="inline">from</code> and <code class="inline">join</code> also support index hints, as found in databases such as <a href="https://dev.mysql.com/doc/refman/8.0/en/index-hints.html">MySQL</a>, <a href="https://docs.microsoft.com/en-us/sql/t-sql/queries/hints-transact-sql-table?view=sql-server-2017">MSSQL</a> and <a href="https://clickhouse.tech/docs/en/sql-reference/statements/select/sample/">Clickhouse</a>.</p>
<p>For example, a developer using MySQL may write:</p>
<pre data-language="elixir">from p in Post,
  join: c in Comment,
  hints: ["USE INDEX FOO", "USE INDEX BAR"],
  where: p.id == c.post_id,
  select: c</pre>
<p>Keep in mind you want to use hints rarely, so don't forget to read the database disclaimers about such functionality.</p>
<p>Hints must be static compile-time strings when they are specified as (list of) strings. Certain Ecto adapters may also accept dynamic hints using the tuple form:</p>
<pre data-language="elixir">from e in Event,
  hints: [sample: sample_threshold()],
  select: e</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="last/2">last(queryable, order_by \\ nil)<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/query.ex#L2074" class="source">Source</a>
</h3> <section class="docstring"> <p>Restricts the query to return the last result ordered by primary key.</p>
<p>The query ordering will be automatically reversed, with ASC columns becoming DESC columns (and vice-versa) and limit is set to 1. If there is no ordering, the query will be automatically ordered decreasingly by primary key.</p>
<h4 id="last/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">Post |&gt; last |&gt; Repo.one
query |&gt; last(:inserted_at) |&gt; Repo.one</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="limit/3">limit(query, binding \\ [], expr)<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/query.ex#L1692" class="source">Source</a>
</h3> <section class="docstring"> <p>A limit query expression.</p>
<p>Limits the number of rows returned from the result. Can be any expression but has to evaluate to an integer value and it can't include any field.</p>
<p>If <code class="inline">limit</code> is given twice, it overrides the previous value.</p>
<h4 id="limit/3-keywords-example" class="section-heading">  Keywords example </h4> <pre data-language="elixir">from(u in User, where: u.id == ^current_user, limit: 1)</pre>
<h4 id="limit/3-expressions-example" class="section-heading">  Expressions example </h4> <pre data-language="elixir">User |&gt; where([u], u.id == ^current_user) |&gt; limit(1)</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="lock/3">lock(query, binding \\ [], expr)<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/query.ex#L1742" class="source">Source</a>
</h3> <section class="docstring"> <p>A lock query expression.</p>
<p>Provides support for row-level pessimistic locking using <code class="inline">SELECT ... FOR UPDATE</code> or other, database-specific, locking clauses. <code class="inline">expr</code> can be any expression but has to evaluate to a boolean value or to a string and it can't include any fields.</p>
<p>If <code class="inline">lock</code> is used more than once, the last one used takes precedence.</p>
<p>Ecto also supports <a href="https://en.wikipedia.org/wiki/Optimistic_concurrency_control">optimistic locking</a> but not through queries. For more information on optimistic locking, have a look at the <a href="ecto.changeset.html#optimistic_lock/3"><code class="inline">Ecto.Changeset.optimistic_lock/3</code></a> function.</p>
<h4 id="lock/3-keywords-example" class="section-heading">  Keywords example </h4> <pre data-language="elixir">from(u in User, where: u.id == ^current_user, lock: "FOR SHARE NOWAIT")</pre>
<h4 id="lock/3-expressions-example" class="section-heading">  Expressions example </h4> <pre data-language="elixir">User |&gt; where([u], u.id == ^current_user) |&gt; lock("FOR SHARE NOWAIT")</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="offset/3">offset(query, binding \\ [], expr)<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/query.ex#L1714" class="source">Source</a>
</h3> <section class="docstring"> <p>An offset query expression.</p>
<p>Offsets the number of rows selected from the result. Can be any expression but it must evaluate to an integer value and it can't include any field.</p>
<p>If <code class="inline">offset</code> is given twice, it overrides the previous value.</p>
<h4 id="offset/3-keywords-example" class="section-heading">  Keywords example </h4> <pre data-language="elixir"># Get all posts on page 4
from(p in Post, limit: 10, offset: 30)</pre>
<h4 id="offset/3-expressions-example" class="section-heading">  Expressions example </h4> <pre data-language="elixir">Post |&gt; limit(10) |&gt; offset(30)</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="or_having/3">or_having(query, binding \\ [], expr)<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/query.ex#L1877" class="source">Source</a>
</h3> <section class="docstring"> <p>An OR having query expression.</p>
<p>Like <code class="inline">having</code> but combines with the previous expression by using <code class="inline">OR</code>. <code class="inline">or_having</code> behaves for <code class="inline">having</code> the same way <code class="inline">or_where</code> behaves for <code class="inline">where</code>.</p>
<h4 id="or_having/3-keywords-example" class="section-heading">  Keywords example </h4> <pre data-language="elixir"># Augment a previous group_by with a having condition.
from(p in query, or_having: avg(p.num_comments) &gt; 10)</pre>
<h4 id="or_having/3-expressions-example" class="section-heading">  Expressions example </h4> <pre data-language="elixir"># Augment a previous group_by with a having condition.
Post |&gt; or_having([p], avg(p.num_comments) &gt; 10)</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="or_where/3">or_where(query, binding \\ [], expr)<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/query.ex#L1437" class="source">Source</a>
</h3> <section class="docstring"> <p>An OR where query expression.</p>
<p>Behaves exactly the same as <code class="inline">where</code> except it combines with any previous expression by using an <code class="inline">OR</code>. All expressions have to evaluate to a boolean value.</p>
<p><code class="inline">or_where</code> also accepts a keyword list where each key is a field to be compared with the given value. Each key-value pair will be combined using <code class="inline">AND</code>, exactly as in <code class="inline">where</code>.</p>
<h4 id="or_where/3-keywords-example" class="section-heading">  Keywords example </h4> <pre data-language="elixir">from(c in City, where: [country: "Sweden"], or_where: [country: "Brazil"])</pre>
<p>If interpolating keyword lists, the keyword list entries are combined using ANDs and joined to any existing expression with an OR:</p>
<pre data-language="elixir">filters = [country: "USA", name: "New York"]
from(c in City, where: [country: "Sweden"], or_where: ^filters)</pre>
<p>is equivalent to:</p>
<pre data-language="elixir">from c in City, where: (c.country == "Sweden") or
                       (c.country == "USA" and c.name == "New York")</pre>
<p>The behaviour above is by design to keep the changes between <code class="inline">where</code> and <code class="inline">or_where</code> minimal. Plus, if you have a keyword list and you would like each pair to be combined using <code class="inline">or</code>, it can be easily done with <a href="https://hexdocs.pm/elixir/Enum.html#reduce/3"><code class="inline">Enum.reduce/3</code></a>:</p>
<pre data-language="elixir">filters = [country: "USA", is_tax_exempt: true]
Enum.reduce(filters, City, fn {key, value}, query -&gt;
  from q in query, or_where: field(q, ^key) == ^value
end)</pre>
<p>which will be equivalent to:</p>
<pre data-language="elixir">from c in City, or_where: (c.country == "USA"), or_where: c.is_tax_exempt == true</pre>
<h4 id="or_where/3-expressions-example" class="section-heading">  Expressions example </h4> <pre data-language="elixir">City |&gt; where([c], c.country == "Sweden") |&gt; or_where([c], c.country == "Brazil")</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="order_by/3">order_by(query, binding \\ [], expr)<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/query.ex#L1513" class="source">Source</a>
</h3> <section class="docstring"> <p>An order by query expression.</p>
<p>Orders the fields based on one or more fields. It accepts a single field or a list of fields. The default direction is ascending (<code class="inline">:asc</code>) and can be customized in a keyword list as one of the following:</p>
<ul>
<li><code class="inline">:asc</code></li>
<li><code class="inline">:asc_nulls_last</code></li>
<li><code class="inline">:asc_nulls_first</code></li>
<li><code class="inline">:desc</code></li>
<li><code class="inline">:desc_nulls_last</code></li>
<li><code class="inline">:desc_nulls_first</code></li>
</ul>
<p>The <code class="inline">*_nulls_first</code> and <code class="inline">*_nulls_last</code> variants are not supported by all databases. While all databases default to ascending order, the choice of "nulls first" or "nulls last" is specific to each database implementation.</p>
<p><code class="inline">order_by</code> may be invoked or listed in a query many times. New expressions are always appended to the previous ones.</p>
<p><code class="inline">order_by</code> also accepts a list of atoms where each atom refers to a field in source or a keyword list where the direction is given as key and the field to order as value.</p>
<h4 id="order_by/3-keywords-examples" class="section-heading">  Keywords examples </h4> <pre data-language="elixir">from(c in City, order_by: c.name, order_by: c.population)
from(c in City, order_by: [c.name, c.population])
from(c in City, order_by: [asc: c.name, desc: c.population])

from(c in City, order_by: [:name, :population])
from(c in City, order_by: [asc: :name, desc_nulls_first: :population])</pre>
<p>A keyword list can also be interpolated:</p>
<pre data-language="elixir">values = [asc: :name, desc_nulls_first: :population]
from(c in City, order_by: ^values)</pre>
<p>A fragment can also be used:</p>
<pre data-language="elixir">from c in City, order_by: [
  # A deterministic shuffled order
  fragment("? % ? DESC", c.id, ^modulus),
  desc: c.id,
]</pre>
<p>It's also possible to order by an aliased or calculated column:</p>
<p> from(c in City,</p>
<pre data-language="elixir">select: %{
  name: c.name,
  total_population:
    fragment(
      "COALESCE(?, ?) + ? AS total_population",
      c.animal_population,
      0,
      c.human_population
    )
},
order_by: [
  # based on `AS total_population` in the previous fragment
  {:desc, fragment("total_population")}
]</pre>
<p> )</p>
<h4 id="order_by/3-expressions-examples" class="section-heading">  Expressions examples </h4> <pre data-language="elixir">City |&gt; order_by([c], asc: c.name, desc: c.population)
City |&gt; order_by(asc: :name) # Sorts by the cities name</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="preload/3">preload(query, bindings \\ [], expr)<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/query.ex#L2031" class="source">Source</a>
</h3> <section class="docstring"> <p>Preloads the associations into the result set.</p>
<p>Imagine you have a schema <code class="inline">Post</code> with a <code class="inline">has_many :comments</code> association and you execute the following query:</p>
<pre data-language="elixir">Repo.all from p in Post, preload: [:comments]</pre>
<p>The example above will fetch all posts from the database and then do a separate query returning all comments associated with the given posts. The comments are then processed and associated to each returned <code class="inline">post</code> under the <code class="inline">comments</code> field.</p>
<p>Often times, you may want posts and comments to be selected and filtered in the same query. For such cases, you can explicitly tell an existing join to be preloaded into the result set:</p>
<pre data-language="elixir">Repo.all from p in Post,
           join: c in assoc(p, :comments),
           where: c.published_at &gt; p.updated_at,
           preload: [comments: c]</pre>
<p>In the example above, instead of issuing a separate query to fetch comments, Ecto will fetch posts and comments in a single query and then do a separate pass associating each comment to its parent post. Therefore, instead of returning <code class="inline">number_of_posts * number_of_comments</code> results, like a <code class="inline">join</code> would, it returns only posts with the <code class="inline">comments</code> fields properly filled in.</p>
<p>Nested associations can also be preloaded in both formats:</p>
<pre data-language="elixir">Repo.all from p in Post,
           preload: [comments: :likes]

Repo.all from p in Post,
           join: c in assoc(p, :comments),
           join: l in assoc(c, :likes),
           where: l.inserted_at &gt; c.updated_at,
           preload: [comments: {c, likes: l}]</pre>
<p>Applying a limit to the association can be achieved with <code class="inline">inner_lateral_join</code>:</p>
<pre data-language="elixir">Repo.all from p in Post, as: :post,
           join: c in assoc(p, :comments),
           inner_lateral_join: top_five in subquery(
             from Comment,
             where: [post_id: parent_as(:post).id],
             order_by: :popularity,
             limit: 5,
             select: [:id]
           ), on: top_five.id == c.id,
           preload: [comments: c]</pre>
<h4 id="preload/3-preload-queries" class="section-heading">  Preload queries </h4> <p>Preload also allows queries to be given, allowing you to filter or customize how the preloads are fetched:</p>
<pre data-language="elixir">comments_query = from c in Comment, order_by: c.published_at
Repo.all from p in Post, preload: [comments: ^comments_query]</pre>
<p>The example above will issue two queries, one for loading posts and then another for loading the comments associated with the posts. Comments will be ordered by <code class="inline">published_at</code>.</p>
<p>When specifying a preload query, you can still preload the associations of those records. For instance, you could preload an author's published posts and the comments on those posts:</p>
<pre data-language="elixir">posts_query = from p in Post, where: p.state == :published
Repo.all from a in Author, preload: [posts: ^{posts_query, [:comments]}]</pre>
<p>Note: keep in mind operations like limit and offset in the preload query will affect the whole result set and not each association. For example, the query below:</p>
<pre data-language="elixir">comments_query = from c in Comment, order_by: c.popularity, limit: 5
Repo.all from p in Post, preload: [comments: ^comments_query]</pre>
<p>won't bring the top of comments per post. Rather, it will only bring the 5 top comments across all posts. Instead, use a window:</p>
<pre data-language="elixir">ranking_query =
  from c in Comment,
  select: %{id: c.id, row_number: over(row_number(), :posts_partition)},
  windows: [posts_partition: [partition_by: :post_id, order_by: :popularity]]

comments_query =
  from c in Comment,
  join: r in subquery(ranking_query),
  on: c.id == r.id and r.row_number &lt;= 5

Repo.all from p in Post, preload: [comments: ^comments_query]</pre>
<h4 id="preload/3-preload-functions" class="section-heading">  Preload functions </h4> <p>Preload also allows functions to be given. In such cases, the function receives the IDs of the parent association and it must return the associated data. Ecto then will map this data and sort it by the relationship key:</p>
<pre data-language="elixir">comment_preloader = fn post_ids -&gt; fetch_comments_by_post_ids(post_ids) end
Repo.all from p in Post, preload: [comments: ^comment_preloader]</pre>
<p>This is useful when the whole dataset was already loaded or must be explicitly fetched from elsewhere. The IDs received by the preloading function and the result returned depends on the association type:</p>
<ul>
<li><p>For <code class="inline">has_many</code> and <code class="inline">belongs_to</code> - the function receives the IDs of the parent association and it must return a list of maps or structs with the associated entries. The associated map/struct must contain the "foreign_key" field. For example, if a post has many comments, when preloading the comments with a custom function, the function will receive a list of "post_ids" as the argument and it must return maps or structs representing the comments. The maps/structs must include the <code class="inline">:post_id</code> field</p></li>
<li><p>For <code class="inline">has_many :through</code> - it behaves similarly to a regular <code class="inline">has_many</code> but note that the IDs received are of the last association. Imagine, for example, a post has many comments and each comment has an author. Therefore, a post may have many comments_authors, written as <code class="inline">has_many :comments_authors, through: [:comments, :author]</code>. When preloading authors with a custom function via <code class="inline">:comments_authors</code>, the function will receive the IDs of the authors as the last step</p></li>
<li><p>For <code class="inline">many_to_many</code> - the function receives the IDs of the parent association and it must return a tuple with the parent id as the first element and the association map or struct as the second. For example, if a post has many tags, when preloading the tags with a custom function, the function will receive a list of "post_ids" as the argument and it must return a tuple in the format of <code class="inline">{post_id, tag}</code></p></li>
</ul>
<h4 id="preload/3-keywords-example" class="section-heading">  Keywords example </h4> <pre data-language="elixir"># Returns all posts, their associated comments, and the associated
# likes for those comments.
from(p in Post,
  preload: [comments: :likes],
  select: p
)</pre>
<h4 id="preload/3-expressions-examples" class="section-heading">  Expressions examples </h4> <pre data-language="elixir">Post |&gt; preload(:comments) |&gt; select([p], p)

Post
|&gt; join(:left, [p], c in assoc(p, :comments))
|&gt; preload([p, c], [:user, comments: c])
|&gt; select([p], p)</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="put_query_prefix/2">put_query_prefix(query, prefix)<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/query.ex#L677" class="source">Source</a>
</h3> <section class="docstring"> <p>Puts the given prefix in a query.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="recursive_ctes/2">recursive_ctes(query, value)<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/query.ex#L1188" class="source">Source</a>
</h3> <section class="docstring"> <p>Enables or disables recursive mode for CTEs.</p>
<p>According to the SQL standard it affects all CTEs in the query, not individual ones.</p>
<p>See <a href="#with_cte/3"><code class="inline">with_cte/3</code></a> on example of how to build a query with a recursive CTE.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="reverse_order/1">reverse_order(query)<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/query.ex#L2127" class="source">Source</a>
</h3> <section class="docstring"> <p>Reverses the ordering of the query.</p>
<p>ASC columns become DESC columns (and vice-versa). If the query has no <code class="inline">order_by</code>s, it orders by the inverse of the primary key.</p>
<h4 id="reverse_order/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">query |&gt; reverse_order() |&gt; Repo.one()
Post |&gt; order(asc: :id) |&gt; reverse_order() == Post |&gt; order(desc: :id)</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="select/3">select(query, binding \\ [], expr)<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/query.ex#L1255" class="source">Source</a>
</h3> <section class="docstring"> <p>A select query expression.</p>
<p>Selects which fields will be selected from the schema and any transformations that should be performed on the fields. Any expression that is accepted in a query can be a select field.</p>
<p>Select also allows each expression to be wrapped in lists, tuples or maps as shown in the examples below. A full schema can also be selected.</p>
<p>There can only be one select expression in a query, if the select expression is omitted, the query will by default select the full schema. If <code class="inline">select</code> is given more than once, an error is raised. Use <a href="#exclude/2"><code class="inline">exclude/2</code></a> if you would like to remove a previous select for overriding or see <a href="#select_merge/3"><code class="inline">select_merge/3</code></a> for a limited version of <code class="inline">select</code> that is composable and can be called multiple times.</p>
<p><code class="inline">select</code> also accepts a list of atoms where each atom refers to a field in the source to be selected.</p>
<h4 id="select/3-keywords-examples" class="section-heading">  Keywords examples </h4> <pre data-language="elixir">from(c in City, select: c) # returns the schema as a struct
from(c in City, select: {c.name, c.population})
from(c in City, select: [c.name, c.county])
from(c in City, select: %{n: c.name, answer: 42})
from(c in City, select: %{c | alternative_name: c.name})
from(c in City, select: %Data{name: c.name})</pre>
<p>It is also possible to select a struct and limit the returned fields at the same time:</p>
<pre data-language="elixir">from(City, select: [:name])</pre>
<p>The syntax above is equivalent to:</p>
<pre data-language="elixir">from(city in City, select: struct(city, [:name]))</pre>
<p>You can also write:</p>
<pre data-language="elixir">from(city in City, select: map(city, [:name]))</pre>
<p>If you want a map with only the selected fields to be returned.</p>
<p>For more information, read the docs for <a href="ecto.query.api.html#struct/2"><code class="inline">Ecto.Query.API.struct/2</code></a> and <a href="ecto.query.api.html#map/2"><code class="inline">Ecto.Query.API.map/2</code></a>.</p>
<h4 id="select/3-expressions-examples" class="section-heading">  Expressions examples </h4> <pre data-language="elixir">City |&gt; select([c], c)
City |&gt; select([c], {c.name, c.country})
City |&gt; select([c], %{"name" =&gt; c.name})
City |&gt; select([:name])
City |&gt; select([c], struct(c, [:name]))
City |&gt; select([c], map(c, [:name]))</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="select_merge/3">select_merge(query, binding \\ [], expr)<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/query.ex#L1314" class="source">Source</a>
</h3> <section class="docstring"> <p>Mergeable select query expression.</p>
<p>This macro is similar to <a href="#select/3"><code class="inline">select/3</code></a> except it may be specified multiple times as long as every entry is a map. This is useful for merging and composing selects. For example:</p>
<pre data-language="elixir">query = from p in Post, select: %{}

query =
  if include_title? do
    from p in query, select_merge: %{title: p.title}
  else
    query
  end

query =
  if include_visits? do
    from p in query, select_merge: %{visits: p.visits}
  else
    query
  end</pre>
<p>In the example above, the query is built little by little by merging into a final map. If both conditions above are true, the final query would be equivalent to:</p>
<pre data-language="elixir">from p in Post, select: %{title: p.title, visits: p.visits}</pre>
<p>If <code class="inline">:select_merge</code> is called and there is no value selected previously, it will default to the source, <code class="inline">p</code> in the example above.</p>
<p>The argument given to <code class="inline">:select_merge</code> must always be a map. The value being merged on must be a struct or a map. If it is a struct, the fields merged later on must be part of the struct, otherwise an error is raised.</p>
<p>If the argument to <code class="inline">:select_merge</code> is a constructed struct (<a href="ecto.query.api.html#struct/2"><code class="inline">Ecto.Query.API.struct/2</code></a>) or map (<a href="ecto.query.api.html#map/2"><code class="inline">Ecto.Query.API.map/2</code></a>) where the source to struct or map may be a <code class="inline">nil</code> value (as in an outer join), the source will be returned unmodified.</p>
<pre data-language="elixir">query =
  Post
  |&gt; join(:left, [p], t in Post.Translation,
    on: t.post_id == p.id and t.locale == ^"en"
  )
  |&gt; select_merge([_p, t], map(t, ^~w(title summary)a))</pre>
<p>If there is no English translation for the post, the untranslated post <code class="inline">title</code> will be returned and <code class="inline">summary</code> will be <code class="inline">nil</code>. If there is, both <code class="inline">title</code> and <code class="inline">summary</code> will be the value from <code class="inline">Post.Translation</code>.</p>
<p><code class="inline">select_merge</code> cannot be used to set fields in associations, as associations are always loaded later, overriding any previous value.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="subquery/2">subquery(query, opts \\ [])<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/query.ex#L659" class="source">Source</a>
</h3> <section class="docstring"> <p>Converts a query into a subquery.</p>
<p>If a subquery is given, returns the subquery itself. If any other value is given, it is converted to a query via <a href="ecto.queryable.html"><code class="inline">Ecto.Queryable</code></a> and wrapped in the <a href="ecto.subquery.html"><code class="inline">Ecto.SubQuery</code></a> struct.</p>
<p><code class="inline">subquery</code> is supported in <code class="inline">from</code>, <code class="inline">join</code>, and <code class="inline">where</code>, in the form <code class="inline">p.x in subquery(q)</code>.</p>
<h4 id="subquery/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"># Get the average salary of the top 10 highest salaries
query = from Employee, order_by: [desc: :salary], limit: 10
from e in subquery(query), select: avg(e.salary)</pre>
<p>A prefix can be specified for a subquery, similar to standard repo operations:</p>
<pre data-language="elixir">query = from Employee, order_by: [desc: :salary], limit: 10
from e in subquery(query, prefix: "my_prefix"), select: avg(e.salary)</pre>
<p>Subquery can also be used in a <code class="inline">join</code> expression.</p>
<pre data-language="elixir">UPDATE posts
  SET sync_started_at = $1
  WHERE id IN (
    SELECT id FROM posts
      WHERE synced = false AND (sync_started_at IS NULL OR sync_started_at &lt; $1)
      LIMIT $2
  )</pre>
<p>We can write it as a join expression:</p>
<pre data-language="elixir">subset = from(p in Post,
  where: p.synced == false and
           (is_nil(p.sync_started_at) or p.sync_started_at &lt; ^min_sync_started_at),
  limit: ^batch_size
)

Repo.update_all(
  from(p in Post, join: s in subquery(subset), on: s.id == p.id),
  set: [sync_started_at: NaiveDateTime.utc_now()]
)</pre>
<p>Or as a <code class="inline">where</code> condition:</p>
<pre data-language="elixir">subset_ids = from(p in subset, select: p.id)
Repo.update_all(
  from(p in Post, where: p.id in subquery(subset_ids)),
  set: [sync_started_at: NaiveDateTime.utc_now()]
)</pre>
<p>If you need to refer to a parent binding which is not known when writing the subquery, you can use <code class="inline">parent_as</code> as shown in the examples under "Named bindings" in this module doc.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="union/2">union(query, other_query)<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/query.ex#L1542" class="source">Source</a>
</h3> <section class="docstring"> <p>A union query expression.</p>
<p>Combines result sets of multiple queries. The <code class="inline">select</code> of each query must be exactly the same, with the same types in the same order.</p>
<p>Union expression returns only unique rows as if each query returned distinct results. This may cause a performance penalty. If you need to combine multiple result sets without removing duplicate rows consider using <a href="#union_all/2"><code class="inline">union_all/2</code></a>.</p>
<p>Note that the operations <code class="inline">order_by</code>, <code class="inline">limit</code> and <code class="inline">offset</code> of the current <code class="inline">query</code> apply to the result of the union.</p>
<h4 id="union/2-keywords-example" class="section-heading">  Keywords example </h4> <pre data-language="elixir">supplier_query = from s in Supplier, select: s.city
from c in Customer, select: c.city, union: ^supplier_query</pre>
<h4 id="union/2-expressions-example" class="section-heading">  Expressions example </h4> <pre data-language="elixir">supplier_query = Supplier |&gt; select([s], s.city)
Customer |&gt; select([c], c.city) |&gt; union(^supplier_query)</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="union_all/2">union_all(query, other_query)<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/query.ex#L1565" class="source">Source</a>
</h3> <section class="docstring"> <p>A union all query expression.</p>
<p>Combines result sets of multiple queries. The <code class="inline">select</code> of each query must be exactly the same, with the same types in the same order.</p>
<p>Note that the operations <code class="inline">order_by</code>, <code class="inline">limit</code> and <code class="inline">offset</code> of the current <code class="inline">query</code> apply to the result of the union.</p>
<h4 id="union_all/2-keywords-example" class="section-heading">  Keywords example </h4> <pre data-language="elixir">supplier_query = from s in Supplier, select: s.city
from c in Customer, select: c.city, union_all: ^supplier_query</pre>
<h4 id="union_all/2-expressions-example" class="section-heading">  Expressions example </h4> <pre data-language="elixir">supplier_query = Supplier |&gt; select([s], s.city)
Customer |&gt; select([c], c.city) |&gt; union_all(^supplier_query)</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="update/3">update(query, binding \\ [], expr)<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/query.ex#L1790" class="source">Source</a>
</h3> <section class="docstring"> <p>An update query expression.</p>
<p>Updates are used to update the filtered entries. In order for updates to be applied, <a href="ecto.repo.html#c:update_all/3"><code class="inline">Ecto.Repo.update_all/3</code></a> must be invoked.</p>
<h4 id="update/3-keywords-example" class="section-heading">  Keywords example </h4> <pre data-language="elixir">from(u in User, update: [set: [name: "new name"]])</pre>
<h4 id="update/3-expressions-examples" class="section-heading">  Expressions examples </h4> <pre data-language="elixir">User |&gt; update([u], set: [name: "new name"])
User |&gt; update(set: [name: "new name"])</pre>
<h4 id="update/3-interpolation" class="section-heading">  Interpolation </h4> <pre data-language="elixir">new_name = "new name"
from(u in User, update: [set: [name: ^new_name]])

new_name = "new name"
from(u in User, update: [set: [name: fragment("upper(?)", ^new_name)]])</pre>
<h4 id="update/3-operators" class="section-heading">  Operators </h4> <p>The update expression in Ecto supports the following operators:</p>
<ul>
<li>
<p><code class="inline">set</code> - sets the given field in the table to the given value</p>
<pre data-language="elixir">from(u in User, update: [set: [name: "new name"]])</pre>
</li>
<li>
<p><code class="inline">inc</code> - increments (or decrements if the value is negative) the given field in the table by the given value</p>
<pre data-language="elixir">from(u in User, update: [inc: [accesses: 1]])</pre>
</li>
<li>
<p><code class="inline">push</code> - pushes (appends) the given value to the end of the array field</p>
<pre data-language="elixir">from(u in User, update: [push: [tags: "cool"]])</pre>
</li>
<li>
<p><code class="inline">pull</code> - pulls (removes) the given value from the array field</p>
<pre data-language="elixir">from(u in User, update: [pull: [tags: "not cool"]])</pre>
</li>
</ul> </section> </section> <section class="detail">  <h3 class="detail-header" id="where/3">where(query, binding \\ [], expr)<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/query.ex#L1388" class="source">Source</a>
</h3> <section class="docstring"> <p>An AND where query expression.</p>
<p><code class="inline">where</code> expressions are used to filter the result set. If there is more than one where expression, they are combined with an <code class="inline">and</code> operator. All where expressions have to evaluate to a boolean value.</p>
<p><code class="inline">where</code> also accepts a keyword list where the field given as key is going to be compared with the given value. The fields will always refer to the source given in <code class="inline">from</code>.</p>
<h4 id="where/3-keywords-example" class="section-heading">  Keywords example </h4> <pre data-language="elixir">from(c in City, where: c.country == "Sweden")
from(c in City, where: [country: "Sweden"])</pre>
<p>It is also possible to interpolate the whole keyword list, allowing you to dynamically filter the source:</p>
<pre data-language="elixir">filters = [country: "Sweden"]
from(c in City, where: ^filters)</pre>
<h4 id="where/3-expressions-examples" class="section-heading">  Expressions examples </h4> <pre data-language="elixir">City |&gt; where([c], c.country == "Sweden")
City |&gt; where(country: "Sweden")</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="windows/3">windows(query, binding \\ [], expr)<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/query.ex#L599" class="source">Source</a>
</h3> <section class="docstring"> <p>Defines windows which can be used with <a href="ecto.query.windowapi.html"><code class="inline">Ecto.Query.WindowAPI</code></a>.</p>
<p>Receives a keyword list where keys are names of the windows and values are a keyword list with window expressions.</p>
<h4 id="windows/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"># Compare each employee's salary with the average salary in his or her department
from e in Employee,
  select: {e.depname, e.empno, e.salary, over(avg(e.salary), :department)},
  windows: [department: [partition_by: e.depname]]</pre>
<p>In the example above, we get the average salary per department. <code class="inline">:department</code> is the window name, partitioned by <code class="inline">e.depname</code> and <code class="inline">avg/1</code> is the window function. For more information on windows functions, see <a href="ecto.query.windowapi.html"><code class="inline">Ecto.Query.WindowAPI</code></a>.</p>
<h4 id="windows/3-window-expressions" class="section-heading">  Window expressions </h4> <p>The following keys are allowed when specifying a window.</p>
<h3 id="windows/3-partition_by" class="section-heading">  :partition_by </h3> <p>A list of fields to partition the window by, for example:</p>
<pre data-language="elixir">windows: [department: [partition_by: e.depname]]</pre>
<p>A list of atoms can also be interpolated for dynamic partitioning:</p>
<pre data-language="elixir">fields = [:depname, :year]
windows: [dynamic_window: [partition_by: ^fields]]</pre>
<h3 id="windows/3-order_by" class="section-heading">  :order_by </h3> <p>A list of fields to order the window by, for example:</p>
<pre data-language="elixir">windows: [ordered_names: [order_by: e.name]]</pre>
<p>It works exactly as the keyword query version of <a href="#order_by/3"><code class="inline">order_by/3</code></a>.</p>
<h3 id="windows/3-frame" class="section-heading">  :frame </h3> <p>A fragment which defines the frame for window functions.</p>
<h4 id="windows/3-examples-1" class="section-heading">  Examples </h4> <pre data-language="elixir"># Compare each employee's salary for each month with his average salary for previous 3 months
from p in Payroll,
  select: {p.empno, p.date, p.salary, over(avg(p.salary), :prev_months)},
  windows: [prev_months: [partition_by: p.empno, order_by: p.date, frame: fragment("ROWS 3 PRECEDING EXCLUDE CURRENT ROW")]]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="with_cte/3">with_cte(query, name, list)<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/query.ex#L1177" class="source">Source</a>
</h3> <section class="docstring"> <p>A common table expression (CTE) also known as WITH expression.</p>
<p><code class="inline">name</code> must be a compile-time literal string that is being used as the table name to join the CTE in the main query or in the recursive CTE.</p>
<p><strong>IMPORTANT!</strong> Beware of using CTEs. In raw SQL, CTEs can be used as a mechanism to organize queries, but said mechanism has no purpose in Ecto since Ecto queries are composable by definition. In other words, if you need to break a large query into parts, use all of the functionality in Elixir and in this module to structure your code. Furthermore, breaking a query into CTEs can negatively impact performance, as the database may not optimize efficiently across CTEs. The main use case for CTEs in Ecto is to provide recursive definitions, which we outline in the following section. Non-recursive CTEs can often be written as joins or subqueries, which provide better performance.</p>
<h4 id="with_cte/3-options" class="section-heading">  Options </h4> <ul><li>
<code class="inline">:as</code> - the CTE query itself or a fragment</li></ul>
<h4 id="with_cte/3-recursive-ctes" class="section-heading">  Recursive CTEs </h4> <p>Use <a href="#recursive_ctes/2"><code class="inline">recursive_ctes/2</code></a> to enable recursive mode for CTEs.</p>
<p>In the CTE query itself use the same table name to leverage recursion that has been passed to the <code class="inline">name</code> argument. Make sure to write a stop condition to avoid an infinite recursion loop. Generally speaking, you should only use CTEs in Ecto for writing recursive queries.</p>
<h4 id="with_cte/3-expression-examples" class="section-heading">  Expression examples </h4> <p>Products and their category names for breadcrumbs:</p>
<pre data-language="elixir">category_tree_initial_query =
  Category
  |&gt; where([c], is_nil(c.parent_id))

category_tree_recursion_query =
  Category
  |&gt; join(:inner, [c], ct in "category_tree", on: c.parent_id == ct.id)

category_tree_query =
  category_tree_initial_query
  |&gt; union_all(^category_tree_recursion_query)

Product
|&gt; recursive_ctes(true)
|&gt; with_cte("category_tree", as: ^category_tree_query)
|&gt; join(:left, [p], c in "category_tree", on: c.id == p.category_id)
|&gt; group_by([p], p.id)
|&gt; select([p, c], %{p | category_names: fragment("ARRAY_AGG(?)", c.name)})</pre>
<p>It's also possible to pass a raw SQL fragment:</p>
<pre data-language="elixir">@raw_sql_category_tree """
SELECT * FROM categories WHERE c.parent_id IS NULL
UNION ALL
SELECT * FROM categories AS c, category_tree AS ct WHERE ct.id = c.parent_id
"""

Product
|&gt; recursive_ctes(true)
|&gt; with_cte("category_tree", as: fragment(@raw_sql_category_tree))
|&gt; join(:inner, [p], c in "category_tree", on: c.id == p.category_id)</pre>
<p>If you don't have any Ecto schema pointing to the CTE table, you can pass a tuple with the CTE table name as the first element and an Ecto schema as the second element. This will cast the result rows to Ecto structs as long as the Ecto schema maps to the same fields in the CTE table:</p>
<pre data-language="elixir">{"category_tree", Category}
|&gt; recursive_ctes(true)
|&gt; with_cte("category_tree", as: ^category_tree_query)
|&gt; join(:left, [c], p in assoc(c, :products))
|&gt; group_by([c], c.id)
|&gt; select([c, p], %{c | products_count: count(p.id)})</pre>
<p>Keyword syntax is not supported for this feature.</p>
<h4 id="with_cte/3-limitation-ctes-on-schemas-with-source-fields" class="section-heading">  Limitation: CTEs on schemas with source fields </h4> <p>Ecto allows developers to say that a table in their Ecto schema maps to a different column in their database:</p>
<pre data-language="elixir">field :group_id, :integer, source: :iGroupId</pre>
<p>At the moment, using a schema with source fields in CTE may emit invalid queries. If you are running into such scenarios, your best option is to use a fragment as your CTE.</p> </section> </section> </div> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2013 Plataformatec<br>&copy; 2020 Dashbit<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/ecto/Ecto.Query.html" class="_attribution-link">https://hexdocs.pm/ecto/Ecto.Query.html</a>
  </p>
</div>
