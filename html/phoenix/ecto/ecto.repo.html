<h1>   <span translate="no">Ecto.Repo</span> <small>behaviour</small>  </h1> <section id="moduledoc"> <p>Defines a repository.</p>
<p>A repository maps to an underlying data store, controlled by the adapter. For example, Ecto ships with a Postgres adapter that stores data into a PostgreSQL database.</p>
<p>When used, the repository expects the <code class="inline">:otp_app</code> and <code class="inline">:adapter</code> as option. The <code class="inline">:otp_app</code> should point to an OTP application that has the repository configuration. For example, the repository:</p>
<pre data-language="elixir">defmodule Repo do
  use Ecto.Repo,
    otp_app: :my_app,
    adapter: Ecto.Adapters.Postgres
end</pre>
<p>Could be configured with:</p>
<pre data-language="elixir">config :my_app, Repo,
  database: "ecto_simple",
  username: "postgres",
  password: "postgres",
  hostname: "localhost"</pre>
<p>Most of the configuration that goes into the <code class="inline">config</code> is specific to the adapter. For this particular example, you can check <a href="https://hexdocs.pm/ecto_sql/Ecto.Adapters.Postgres.html"><code class="inline">Ecto.Adapters.Postgres</code></a> for more information. In spite of this, the following configuration values are shared across all adapters:</p>
<ul>
<li><p><code class="inline">:name</code>- The name of the Repo supervisor process</p></li>
<li><p><code class="inline">:priv</code> - the directory where to keep repository data, like migrations, schema and more. Defaults to "priv/YOUR_REPO". It must always point to a subdirectory inside the priv directory</p></li>
<li><p><code class="inline">:url</code> - an URL that specifies storage information. Read below for more information</p></li>
<li><p><code class="inline">:log</code> - the log level used when logging the query with Elixir's Logger. If false, disables logging for that repository. Defaults to <code class="inline">:debug</code></p></li>
<li><p><code class="inline">:pool_size</code> - the size of the pool used by the connection module. Defaults to <code class="inline">10</code></p></li>
<li><p><code class="inline">:telemetry_prefix</code> - we recommend adapters to publish events using the <code class="inline">Telemetry</code> library. By default, the telemetry prefix is based on the module name, so if your module is called <code class="inline">MyApp.Repo</code>, the prefix will be <code class="inline">[:my_app, :repo]</code>. See the "Telemetry Events" section to see which events we recommend adapters to publish. Note that if you have multiple databases, you should keep the <code class="inline">:telemetry_prefix</code> consistent for each repo and use the <code class="inline">:repo</code> property in the event metadata for distinguishing between repos.</p></li>
<li><p><code class="inline">:stacktrace</code>- when true, publishes the stacktrace in telemetry events and allows more advanced logging.</p></li>
</ul>
<h2 id="module-urls" class="section-heading">  URLs </h2> <p>Repositories by default support URLs. For example, the configuration above could be rewritten to:</p>
<pre data-language="elixir">config :my_app, Repo,
  url: "ecto://postgres:postgres@localhost/ecto_simple"</pre>
<p>The schema can be of any value. The path represents the database name while options are simply merged in.</p>
<p>URL can include query parameters to override shared and adapter-specific options, like <code class="inline">ssl</code>, <code class="inline">timeout</code> and <code class="inline">pool_size</code>. The following example shows how to pass these configuration values:</p>
<pre data-language="elixir">config :my_app, Repo,
  url: "ecto://postgres:postgres@localhost/ecto_simple?ssl=true&amp;pool_size=10"</pre>
<p>In case the URL needs to be dynamically configured, for example by reading a system environment variable, such can be done via the <a href="#c:init/2"><code class="inline">init/2</code></a> repository callback:</p>
<pre data-language="elixir">def init(_type, config) do
  {:ok, Keyword.put(config, :url, System.get_env("DATABASE_URL"))}
end</pre>
<h2 id="module-shared-options" class="section-heading">  Shared options </h2> <p>Almost all of the repository functions outlined in this module accept the following options:</p>
<ul>
<li>
<code class="inline">:timeout</code> - The time in milliseconds (as an integer) to wait for the query call to finish. <code class="inline">:infinity</code> will wait indefinitely (default: <code class="inline">15_000</code>)</li>
<li>
<code class="inline">:log</code> - When false, does not log the query</li>
<li>
<code class="inline">:telemetry_event</code> - The telemetry event name to dispatch the event under. See the next section for more information</li>
<li>
<code class="inline">:telemetry_options</code> - Extra options to attach to telemetry event name. See the next section for more information</li>
</ul>
<h2 id="module-telemetry-events" class="section-heading">  Telemetry events </h2> <p>There are two types of telemetry events. The ones emitted by Ecto and the ones that are adapter specific.</p>
<h3 id="module-ecto-telemetry-events" class="section-heading">  Ecto telemetry events </h3> <p>The following events are emitted by all Ecto repositories:</p>
<ul><li>
<code class="inline">[:ecto, :repo, :init]</code> - it is invoked whenever a repository starts. The measurement is a single <code class="inline">system_time</code> entry in native unit. The metadata is the <code class="inline">:repo</code> and all initialization options under <code class="inline">:opts</code>.</li></ul>
<h3 id="module-adapter-specific-events" class="section-heading">  Adapter-specific events </h3> <p>We recommend adapters to publish certain <code class="inline">Telemetry</code> events listed below. Those events will use the <code class="inline">:telemetry_prefix</code> outlined above which defaults to <code class="inline">[:my_app, :repo]</code>.</p>
<p>For instance, to receive all query events published by a repository called <code class="inline">MyApp.Repo</code>, one would define a module:</p>
<pre data-language="elixir">defmodule MyApp.Telemetry do
  def handle_event([:my_app, :repo, :query], measurements, metadata, config) do
    IO.inspect binding()
  end
end</pre>
<p>Then, in the <a href="https://hexdocs.pm/elixir/Application.html#start/2"><code class="inline">Application.start/2</code></a> callback, attach the handler to this event using a unique handler id:</p>
<pre data-language="elixir">:ok = :telemetry.attach("my-app-handler-id", [:my_app, :repo, :query], &amp;MyApp.Telemetry.handle_event/4, %{})</pre>
<p>For details, see <a href="https://hexdocs.pm/telemetry/">the telemetry documentation</a>.</p>
<p>Below we list all events developers should expect from Ecto. All examples below consider a repository named <code class="inline">MyApp.Repo</code>:</p>
<h4><code class="inline">[:my_app, :repo, :query]</code></h4>
<p>This event should be invoked on every query sent to the adapter, including queries that are related to the transaction management.</p>
<p>The <code class="inline">:measurements</code> map will include the following, all given in the <code class="inline">:native</code> time unit:</p>
<ul>
<li>
<code class="inline">:idle_time</code> - the time the connection spent waiting before being checked out for the query</li>
<li>
<code class="inline">:queue_time</code> - the time spent waiting to check out a database connection</li>
<li>
<code class="inline">:query_time</code> - the time spent executing the query</li>
<li>
<code class="inline">:decode_time</code> - the time spent decoding the data received from the database</li>
<li>
<code class="inline">:total_time</code> - the sum of (<code class="inline">queue_time</code>, <code class="inline">query_time</code>, and <code class="inline">decode_time</code>)Ô∏è</li>
</ul>
<p>All measurements are given in the <code class="inline">:native</code> time unit. You can read more about it in the docs for <a href="https://hexdocs.pm/elixir/System.html#convert_time_unit/3"><code class="inline">System.convert_time_unit/3</code></a>.</p>
<p>A telemetry <code class="inline">:metadata</code> map including the following fields. Each database adapter may emit different information here. For Ecto.SQL databases, it will look like this:</p>
<ul>
<li>
<code class="inline">:type</code> - the type of the Ecto query. For example, for Ecto.SQL databases, it would be <code class="inline">:ecto_sql_query</code>
</li>
<li>
<code class="inline">:repo</code> - the Ecto repository</li>
<li>
<code class="inline">:result</code> - the query result</li>
<li>
<code class="inline">:params</code> - the query parameters</li>
<li>
<code class="inline">:query</code> - the query sent to the database as a string</li>
<li>
<code class="inline">:source</code> - the source the query was made on (may be nil)</li>
<li>
<code class="inline">:options</code> - extra options given to the repo operation under <code class="inline">:telemetry_options</code>
</li>
</ul>
<h2 id="module-read-only-repositories" class="section-heading">  Read-only repositories </h2> <p>You can mark a repository as read-only by passing the <code class="inline">:read_only</code> flag on <code class="inline">use</code>:</p>
<pre data-language="elixir">use Ecto.Repo, otp_app: ..., adapter: ..., read_only: true</pre>
<p>By passing the <code class="inline">:read_only</code> option, none of the functions that perform write operations, such as <a href="#c:insert/2"><code class="inline">insert/2</code></a>, <a href="#c:insert_all/3"><code class="inline">insert_all/3</code></a>, <a href="#c:update_all/3"><code class="inline">update_all/3</code></a>, and friends will be defined.</p> </section> <section id="summary" class="details-list"> <h1 class="section-heading">  Summary </h1> <h2> Types </h2>
<dl class="summary-types summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#t:t/0" translate="no">t()</a> </dt> </div> </dl> <h2> Query API </h2>
<dl class="summary-query-api summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#c:aggregate/3" translate="no">aggregate( queryable, aggregate, opts )</a> </dt> <dd class="summary-synopsis"><p>Calculate the given <code class="inline">aggregate</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:aggregate/4" translate="no">aggregate( queryable, aggregate, field, opts )</a> </dt> <dd class="summary-synopsis"><p>Calculate the given <code class="inline">aggregate</code> over the given <code class="inline">field</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:all/2" translate="no">all(queryable, opts)</a> </dt> <dd class="summary-synopsis"><p>Fetches all entries from the data store matching the given query.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:delete_all/2" translate="no">delete_all(queryable, opts)</a> </dt> <dd class="summary-synopsis"><p>Deletes all entries matching the given query.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:exists?/2" translate="no">exists?(queryable, opts)</a> </dt> <dd class="summary-synopsis"><p>Checks if there exists an entry that matches the given query.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:get!/3" translate="no">get!(queryable, id, opts)</a> </dt> <dd class="summary-synopsis"><p>Similar to <a href="#c:get/3"><code class="inline">get/3</code></a> but raises <a href="ecto.noresultserror.html"><code class="inline">Ecto.NoResultsError</code></a> if no record was found.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:get/3" translate="no">get(queryable, id, opts)</a> </dt> <dd class="summary-synopsis"><p>Fetches a single struct from the data store where the primary key matches the given id.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:get_by!/3" translate="no">get_by!( queryable, clauses, opts )</a> </dt> <dd class="summary-synopsis"><p>Similar to <a href="#c:get_by/3"><code class="inline">get_by/3</code></a> but raises <a href="ecto.noresultserror.html"><code class="inline">Ecto.NoResultsError</code></a> if no record was found.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:get_by/3" translate="no">get_by( queryable, clauses, opts )</a> </dt> <dd class="summary-synopsis"><p>Fetches a single result from the query.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:one!/2" translate="no">one!(queryable, opts)</a> </dt> <dd class="summary-synopsis"><p>Similar to <a href="#c:one/2"><code class="inline">one/2</code></a> but raises <a href="ecto.noresultserror.html"><code class="inline">Ecto.NoResultsError</code></a> if no record was found.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:one/2" translate="no">one(queryable, opts)</a> </dt> <dd class="summary-synopsis"><p>Fetches a single result from the query.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:stream/2" translate="no">stream(queryable, opts)</a> </dt> <dd class="summary-synopsis"><p>Returns a lazy enumerable that emits all entries from the data store matching the given query.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:update_all/3" translate="no">update_all( queryable, updates, opts )</a> </dt> <dd class="summary-synopsis"><p>Updates all entries matching the given query with the given values.</p></dd> </div> </dl> <h2> Schema API </h2>
<dl class="summary-schema-api summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#c:delete!/2" translate="no">delete!( struct_or_changeset, opts )</a> </dt> <dd class="summary-synopsis"><p>Same as <a href="#c:delete/2"><code class="inline">delete/2</code></a> but returns the struct or raises if the changeset is invalid.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:delete/2" translate="no">delete( struct_or_changeset, opts )</a> </dt> <dd class="summary-synopsis"><p>Deletes a struct using its primary key.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:insert!/2" translate="no">insert!( struct_or_changeset, opts )</a> </dt> <dd class="summary-synopsis"><p>Same as <a href="#c:insert/2"><code class="inline">insert/2</code></a> but returns the struct or raises if the changeset is invalid.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:insert/2" translate="no">insert( struct_or_changeset, opts )</a> </dt> <dd class="summary-synopsis"><p>Inserts a struct defined via <a href="ecto.schema.html"><code class="inline">Ecto.Schema</code></a> or a changeset.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:insert_all/3" translate="no">insert_all( schema_or_source, entries_or_query, opts )</a> </dt> <dd class="summary-synopsis"><p>Inserts all entries into the repository.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:insert_or_update!/2" translate="no">insert_or_update!(changeset, opts)</a> </dt> <dd class="summary-synopsis"><p>Same as <a href="#c:insert_or_update/2"><code class="inline">insert_or_update/2</code></a> but returns the struct or raises if the changeset is invalid.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:insert_or_update/2" translate="no">insert_or_update(changeset, opts)</a> </dt> <dd class="summary-synopsis"><p>Inserts or updates a changeset depending on whether the struct is persisted or not.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:load/2" translate="no">load( schema_or_map, data )</a> </dt> <dd class="summary-synopsis"><p>Loads <code class="inline">data</code> into a schema or a map.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:preload/3" translate="no">preload(structs_or_struct_or_nil, preloads, opts)</a> </dt> <dd class="summary-synopsis"><p>Preloads all associations on the given struct or structs.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:reload!/2" translate="no">reload!(struct_or_structs, opts)</a> </dt> <dd class="summary-synopsis"><p>Similar to <a href="#c:reload/2"><code class="inline">reload/2</code></a>, but raises when something is not found.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:reload/2" translate="no">reload( struct_or_structs, opts )</a> </dt> <dd class="summary-synopsis"><p>Reloads a given schema or schema list from the database.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:update!/2" translate="no">update!(changeset, opts)</a> </dt> <dd class="summary-synopsis"><p>Same as <a href="#c:update/2"><code class="inline">update/2</code></a> but returns the struct or raises if the changeset is invalid.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:update/2" translate="no">update(changeset, opts)</a> </dt> <dd class="summary-synopsis"><p>Updates a changeset using its primary key.</p></dd> </div> </dl> <h2> Transaction API </h2>
<dl class="summary-transaction-api summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#c:checked_out?/0" translate="no">checked_out?()</a> </dt> <dd class="summary-synopsis"><p>Returns true if a connection has been checked out.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:checkout/2" translate="no">checkout(function, opts)</a> </dt> <dd class="summary-synopsis"><p>Checks out a connection for the duration of the function.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:in_transaction?/0" translate="no">in_transaction?()</a> </dt> <dd class="summary-synopsis"><p>Returns true if the current process is inside a transaction.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:rollback/1" translate="no">rollback(value)</a> </dt> <dd class="summary-synopsis"><p>Rolls back the current transaction.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:transaction/2" translate="no">transaction(fun_or_multi, opts)</a> </dt> <dd class="summary-synopsis"><p>Runs the given function or <a href="ecto.multi.html"><code class="inline">Ecto.Multi</code></a> inside a transaction.</p></dd> </div> </dl> <h2> Runtime API </h2>
<dl class="summary-runtime-api summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#c:__adapter__/0" translate="no">__adapter__()</a> </dt> <dd class="summary-synopsis"><p>Returns the adapter tied to the repository.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:config/0" translate="no">config()</a> </dt> <dd class="summary-synopsis"><p>Returns the adapter configuration stored in the <code class="inline">:otp_app</code> environment.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:get_dynamic_repo/0" translate="no">get_dynamic_repo()</a> </dt> <dd class="summary-synopsis"><p>Returns the atom name or pid of the current repository.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:put_dynamic_repo/1" translate="no">put_dynamic_repo(name_or_pid)</a> </dt> <dd class="summary-synopsis"><p>Sets the dynamic repository to be used in further interactions.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:start_link/1" translate="no">start_link(opts)</a> </dt> <dd class="summary-synopsis"><p>Starts any connection pooling or supervision and return <code class="inline">{:ok, pid}</code> or just <code class="inline">:ok</code> if nothing needs to be done.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:stop/1" translate="no">stop(timeout)</a> </dt> <dd class="summary-synopsis"><p>Shuts down the repository.</p></dd> </div> </dl> <h2> User callbacks </h2>
<dl class="summary-user-callbacks summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#c:default_options/1" translate="no">default_options(operation)</a> </dt> <dd class="summary-synopsis"><p>A user customizable callback invoked to retrieve default options for operations.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:init/2" translate="no">init(context, config)</a> </dt> <dd class="summary-synopsis"><p>A callback executed when the repo starts or when configuration is read.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:prepare_query/3" translate="no">prepare_query(operation, query, opts)</a> </dt> <dd class="summary-synopsis"><p>A user customizable callback invoked for query-based operations.</p></dd> </div> </dl> <h2> Functions </h2>
<dl class="summary-functions summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#all_running/0" translate="no">all_running()</a> </dt> <dd class="summary-synopsis"><p>Returns all running Ecto repositories.</p></dd> </div> </dl> </section> <section id="types" class="details-list"> <h1 class="section-heading">  Types </h1> <div class="types-list"> <section class="detail"> <h3 class="detail-header" id="t:t/0">t()<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/repo.ex#L182" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type t() :: module()</pre> </div> </section> </section> </div> </section> <section id="query-api" class="details-list"> <h1 class="section-heading">  Query API </h1> <div class="query-api-list"> <section class="detail"> <h3 class="detail-header" id="c:aggregate/3">aggregate( queryable, aggregate, opts )<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/repo.ex#L833" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback aggregate(
  queryable :: Ecto.Queryable.t(),
  aggregate :: :count,
  opts :: Keyword.t()
) :: term() | nil</pre> </div> <p>Calculate the given <code class="inline">aggregate</code>.</p>
<p>If the query has a limit, offset, distinct or combination set, it will be automatically wrapped in a subquery in order to return the proper result.</p>
<p>Any preload or select in the query will be ignored in favor of the column being aggregated.</p>
<p>The aggregation will fail if any <code class="inline">group_by</code> field is set.</p>
<h4 id="c:aggregate/3-options" class="section-heading">  Options </h4> <ul><li>
<code class="inline">:prefix</code> - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This will be applied to all <code class="inline">from</code> and <code class="inline">join</code>s in the query that did not have a prefix previously given either via the <code class="inline">:prefix</code> option on <code class="inline">join</code>/<code class="inline">from</code> or via <code class="inline">@schema_prefix</code> in the schema. For more information see the "Query Prefix" section of the <a href="ecto.query.html"><code class="inline">Ecto.Query</code></a> documentation.</li></ul>
<p>See the <a href="#module-shared-options">"Shared options"</a> section at the module documentation for more options.</p>
<h4 id="c:aggregate/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"># Returns the number of blog posts
Repo.aggregate(Post, :count)

# Returns the number of blog posts in the "private" schema path
# (in Postgres) or database (in MySQL)
Repo.aggregate(Post, :count, prefix: "private")</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:aggregate/4">aggregate( queryable, aggregate, field, opts )<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/repo.ex#L859" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback aggregate(
  queryable :: Ecto.Queryable.t(),
  aggregate :: :avg | :count | :max | :min | :sum,
  field :: atom(),
  opts :: Keyword.t()
) :: term() | nil</pre> </div> <p>Calculate the given <code class="inline">aggregate</code> over the given <code class="inline">field</code>.</p>
<p>See <a href="#c:aggregate/3"><code class="inline">aggregate/3</code></a> for general considerations and options.</p>
<h4 id="c:aggregate/4-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"># Returns the number of visits per blog post
Repo.aggregate(Post, :count, :visits)

# Returns the number of visits per blog post in the "private" schema path
# (in Postgres) or database (in MySQL)
Repo.aggregate(Post, :count, :visits, prefix: "private")

# Returns the average number of visits for the top 10
query = from Post, limit: 10
Repo.aggregate(query, :avg, :visits)</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:all/2">all(queryable, opts)<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/repo.ex#L1080" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback all(queryable :: Ecto.Queryable.t(), opts :: Keyword.t()) :: [Ecto.Schema.t()]</pre> </div> <p>Fetches all entries from the data store matching the given query.</p>
<p>May raise <a href="ecto.queryerror.html"><code class="inline">Ecto.QueryError</code></a> if query validation fails.</p>
<h4 id="c:all/2-options" class="section-heading">  Options </h4> <ul><li>
<code class="inline">:prefix</code> - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This will be applied to all <code class="inline">from</code> and <code class="inline">join</code>s in the query that did not have a prefix previously given either via the <code class="inline">:prefix</code> option on <code class="inline">join</code>/<code class="inline">from</code> or via <code class="inline">@schema_prefix</code> in the schema. For more information see the "Query Prefix" section of the <a href="ecto.query.html"><code class="inline">Ecto.Query</code></a> documentation.</li></ul>
<p>See the <a href="#module-shared-options">"Shared options"</a> section at the module documentation for more options.</p>
<h4 id="c:all/2-example" class="section-heading">  Example </h4> <pre data-language="elixir"># Fetch all post titles
query = from p in Post,
     select: p.title
MyRepo.all(query)</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:delete_all/2">delete_all(queryable, opts)<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/repo.ex#L1192" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback delete_all(queryable :: Ecto.Queryable.t(), opts :: Keyword.t()) ::
  {non_neg_integer(), nil | [term()]}</pre> </div> <p>Deletes all entries matching the given query.</p>
<p>It returns a tuple containing the number of entries and any returned result as second element. The second element is <code class="inline">nil</code> by default unless a <code class="inline">select</code> is supplied in the delete query. Note, however, not all databases support returning data from DELETEs.</p>
<h4 id="c:delete_all/2-options" class="section-heading">  Options </h4> <ul><li>
<code class="inline">:prefix</code> - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This overrides the prefix set in the query and any <code class="inline">@schema_prefix</code> set in the schema.</li></ul>
<p>See the <a href="#module-shared-options">"Shared options"</a> section at the module documentation for remaining options.</p>
<h4 id="c:delete_all/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">MyRepo.delete_all(Post)

from(p in Post, where: p.id &lt; 10) |&gt; MyRepo.delete_all</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:exists?/2">exists?(queryable, opts)<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/repo.ex#L892" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback exists?(queryable :: Ecto.Queryable.t(), opts :: Keyword.t()) :: boolean()</pre> </div> <p>Checks if there exists an entry that matches the given query.</p>
<p>Returns a boolean.</p>
<h4 id="c:exists?/2-options" class="section-heading">  Options </h4> <ul><li>
<code class="inline">:prefix</code> - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This will be applied to all <code class="inline">from</code> and <code class="inline">join</code>s in the query that did not have a prefix previously given either via the <code class="inline">:prefix</code> option on <code class="inline">join</code>/<code class="inline">from</code> or via <code class="inline">@schema_prefix</code> in the schema. For more information see the "Query Prefix" section of the <a href="ecto.query.html"><code class="inline">Ecto.Query</code></a> documentation.</li></ul>
<p>See the <a href="#module-shared-options">"Shared options"</a> section at the module documentation for more options.</p>
<h4 id="c:exists?/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"># checks if any posts exist
Repo.exists?(Post)

# checks if any posts exist in the "private" schema path (in Postgres) or
# database (in MySQL)
Repo.exists?(Post, schema: "private")

# checks if any post with a like count greater than 10 exists
query = from p in Post, where: p.like_count &gt; 10
Repo.exists?(query)</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:get!/3">get!(queryable, id, opts)<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/repo.ex#L688" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback get!(queryable :: Ecto.Queryable.t(), id :: term(), opts :: Keyword.t()) ::
  Ecto.Schema.t()</pre> </div> <p>Similar to <a href="#c:get/3"><code class="inline">get/3</code></a> but raises <a href="ecto.noresultserror.html"><code class="inline">Ecto.NoResultsError</code></a> if no record was found.</p>
<h4 id="c:get!/3-options" class="section-heading">  Options </h4> <ul><li>
<code class="inline">:prefix</code> - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This will be applied to all <code class="inline">from</code> and <code class="inline">join</code>s in the query that did not have a prefix previously given either via the <code class="inline">:prefix</code> option on <code class="inline">join</code>/<code class="inline">from</code> or via <code class="inline">@schema_prefix</code> in the schema. For more information see the "Query Prefix" section of the <a href="ecto.query.html"><code class="inline">Ecto.Query</code></a> documentation.</li></ul>
<p>See the <a href="#module-shared-options">"Shared options"</a> section at the module documentation for more options.</p>
<h4 id="c:get!/3-example" class="section-heading">  Example </h4> <pre data-language="elixir">MyRepo.get!(Post, 42)

MyRepo.get!(Post, 42, prefix: "public")</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:get/3">get(queryable, id, opts)<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/repo.ex#L662" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback get(queryable :: Ecto.Queryable.t(), id :: term(), opts :: Keyword.t()) ::
  Ecto.Schema.t() | nil</pre> </div> <p>Fetches a single struct from the data store where the primary key matches the given id.</p>
<p>Returns <code class="inline">nil</code> if no result was found. If the struct in the queryable has no or more than one primary key, it will raise an argument error.</p>
<h4 id="c:get/3-options" class="section-heading">  Options </h4> <ul><li>
<code class="inline">:prefix</code> - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This will be applied to all <code class="inline">from</code> and <code class="inline">join</code>s in the query that did not have a prefix previously given either via the <code class="inline">:prefix</code> option on <code class="inline">join</code>/<code class="inline">from</code> or via <code class="inline">@schema_prefix</code> in the schema. For more information see the "Query Prefix" section of the <a href="ecto.query.html"><code class="inline">Ecto.Query</code></a> documentation.</li></ul>
<p>See the <a href="#module-shared-options">"Shared options"</a> section at the module documentation for more options.</p>
<h4 id="c:get/3-example" class="section-heading">  Example </h4> <pre data-language="elixir">MyRepo.get(Post, 42)

MyRepo.get(Post, 42, prefix: "public")</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:get_by!/3">get_by!( queryable, clauses, opts )<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/repo.ex#L751" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback get_by!(
  queryable :: Ecto.Queryable.t(),
  clauses :: Keyword.t() | map(),
  opts :: Keyword.t()
) :: Ecto.Schema.t()</pre> </div> <p>Similar to <a href="#c:get_by/3"><code class="inline">get_by/3</code></a> but raises <a href="ecto.noresultserror.html"><code class="inline">Ecto.NoResultsError</code></a> if no record was found.</p>
<p>Raises if more than one entry.</p>
<h4 id="c:get_by!/3-options" class="section-heading">  Options </h4> <ul><li>
<code class="inline">:prefix</code> - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This will be applied to all <code class="inline">from</code> and <code class="inline">join</code>s in the query that did not have a prefix previously given either via the <code class="inline">:prefix</code> option on <code class="inline">join</code>/<code class="inline">from</code> or via <code class="inline">@schema_prefix</code> in the schema. For more information see the "Query Prefix" section of the <a href="ecto.query.html"><code class="inline">Ecto.Query</code></a> documentation.</li></ul>
<p>See the <a href="#module-shared-options">"Shared options"</a> section at the module documentation for more options.</p>
<h4 id="c:get_by!/3-example" class="section-heading">  Example </h4> <pre data-language="elixir">MyRepo.get_by!(Post, title: "My post")

MyRepo.get_by!(Post, [title: "My post"], prefix: "public")</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:get_by/3">get_by( queryable, clauses, opts )<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/repo.ex#L720" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback get_by(
  queryable :: Ecto.Queryable.t(),
  clauses :: Keyword.t() | map(),
  opts :: Keyword.t()
) :: Ecto.Schema.t() | nil</pre> </div> <p>Fetches a single result from the query.</p>
<p>Returns <code class="inline">nil</code> if no result was found. Raises if more than one entry.</p>
<h4 id="c:get_by/3-options" class="section-heading">  Options </h4> <ul><li>
<code class="inline">:prefix</code> - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This will be applied to all <code class="inline">from</code> and <code class="inline">join</code>s in the query that did not have a prefix previously given either via the <code class="inline">:prefix</code> option on <code class="inline">join</code>/<code class="inline">from</code> or via <code class="inline">@schema_prefix</code> in the schema. For more information see the "Query Prefix" section of the <a href="ecto.query.html"><code class="inline">Ecto.Query</code></a> documentation.</li></ul>
<p>See the <a href="#module-shared-options">"Shared options"</a> section at the module documentation for more options.</p>
<h4 id="c:get_by/3-example" class="section-heading">  Example </h4> <pre data-language="elixir">MyRepo.get_by(Post, title: "My post")

MyRepo.get_by(Post, [title: "My post"], prefix: "public")</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:one!/2">one!(queryable, opts)<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/repo.ex#L940" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback one!(queryable :: Ecto.Queryable.t(), opts :: Keyword.t()) :: Ecto.Schema.t()</pre> </div> <p>Similar to <a href="#c:one/2"><code class="inline">one/2</code></a> but raises <a href="ecto.noresultserror.html"><code class="inline">Ecto.NoResultsError</code></a> if no record was found.</p>
<p>Raises if more than one entry.</p>
<h4 id="c:one!/2-options" class="section-heading">  Options </h4> <ul><li>
<code class="inline">:prefix</code> - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This will be applied to all <code class="inline">from</code> and <code class="inline">join</code>s in the query that did not have a prefix previously given either via the <code class="inline">:prefix</code> option on <code class="inline">join</code>/<code class="inline">from</code> or via <code class="inline">@schema_prefix</code> in the schema. For more information see the "Query Prefix" section of the <a href="ecto.query.html"><code class="inline">Ecto.Query</code></a> documentation.</li></ul>
<p>See the <a href="#module-shared-options">"Shared options"</a> section at the module documentation for more options.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:one/2">one(queryable, opts)<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/repo.ex#L919" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback one(queryable :: Ecto.Queryable.t(), opts :: Keyword.t()) ::
  Ecto.Schema.t() | nil</pre> </div> <p>Fetches a single result from the query.</p>
<p>Returns <code class="inline">nil</code> if no result was found. Raises if more than one entry.</p>
<h4 id="c:one/2-options" class="section-heading">  Options </h4> <ul><li>
<code class="inline">:prefix</code> - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This will be applied to all <code class="inline">from</code> and <code class="inline">join</code>s in the query that did not have a prefix previously given either via the <code class="inline">:prefix</code> option on <code class="inline">join</code>/<code class="inline">from</code> or via <code class="inline">@schema_prefix</code> in the schema. For more information see the "Query Prefix" section of the <a href="ecto.query.html"><code class="inline">Ecto.Query</code></a> documentation.</li></ul>
<p>See the <a href="#module-shared-options">"Shared options"</a> section at the module documentation for more options.</p>
<h4 id="c:one/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">Repo.one(from p in Post, join: c in assoc(p, :comments), where: p.id == ^post_id)

query = from p in Post, join: c in assoc(p, :comments), where: p.id == ^post_id
Repo.one(query, prefix: "private")</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:stream/2">stream(queryable, opts)<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/repo.ex#L1117" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback stream(queryable :: Ecto.Queryable.t(), opts :: Keyword.t()) :: Enum.t()</pre> </div> <p>Returns a lazy enumerable that emits all entries from the data store matching the given query.</p>
<p>SQL adapters, such as Postgres and MySQL, can only enumerate a stream inside a transaction.</p>
<p>May raise <a href="ecto.queryerror.html"><code class="inline">Ecto.QueryError</code></a> if query validation fails.</p>
<h4 id="c:stream/2-options" class="section-heading">  Options </h4> <ul>
<li><p><code class="inline">:prefix</code> - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This will be applied to all <code class="inline">from</code> and <code class="inline">join</code>s in the query that did not have a prefix previously given either via the <code class="inline">:prefix</code> option on <code class="inline">join</code>/<code class="inline">from</code> or via <code class="inline">@schema_prefix</code> in the schema. For more information see the "Query Prefix" section of the <a href="ecto.query.html"><code class="inline">Ecto.Query</code></a> documentation.</p></li>
<li><p><code class="inline">:max_rows</code> - The number of rows to load from the database as we stream. It is supported at least by Postgres and MySQL and defaults to 500.</p></li>
</ul>
<p>See the <a href="#module-shared-options">"Shared options"</a> section at the module documentation for more options.</p>
<h4 id="c:stream/2-example" class="section-heading">  Example </h4> <pre data-language="elixir"># Fetch all post titles
query = from p in Post,
     select: p.title
stream = MyRepo.stream(query)
MyRepo.transaction(fn -&gt;
  Enum.to_list(stream)
end)</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:update_all/3">update_all( queryable, updates, opts )<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/repo.ex#L1166" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback update_all(
  queryable :: Ecto.Queryable.t(),
  updates :: Keyword.t(),
  opts :: Keyword.t()
) :: {non_neg_integer(), nil | [term()]}</pre> </div> <p>Updates all entries matching the given query with the given values.</p>
<p>It returns a tuple containing the number of entries and any returned result as second element. The second element is <code class="inline">nil</code> by default unless a <code class="inline">select</code> is supplied in the update query. Note, however, not all databases support returning data from UPDATEs.</p>
<p>Keep in mind this <code class="inline">update_all</code> will not update autogenerated fields like the <code class="inline">updated_at</code> columns.</p>
<p>See <a href="ecto.query.html#update/3"><code class="inline">Ecto.Query.update/3</code></a> for update operations that can be performed on fields.</p>
<h4 id="c:update_all/3-options" class="section-heading">  Options </h4> <ul><li>
<code class="inline">:prefix</code> - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This overrides the prefix set in the query and any <code class="inline">@schema_prefix</code> set in the schema.</li></ul>
<p>See the <a href="#module-shared-options">"Shared options"</a> section at the module documentation for remaining options.</p>
<h4 id="c:update_all/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">MyRepo.update_all(Post, set: [title: "New title"])

MyRepo.update_all(Post, inc: [visits: 1])

from(p in Post, where: p.id &lt; 10, select: p.visits)
|&gt; MyRepo.update_all(set: [title: "New title"])

from(p in Post, where: p.id &lt; 10, update: [set: [title: "New title"]])
|&gt; MyRepo.update_all([])

from(p in Post, where: p.id &lt; 10, update: [set: [title: ^new_title]])
|&gt; MyRepo.update_all([])

from(p in Post, where: p.id &lt; 10, update: [set: [title: fragment("upper(?)", ^new_title)]])
|&gt; MyRepo.update_all([])</pre> </section> </section> </div> </section> <section id="schema-api" class="details-list"> <h1 class="section-heading">  Schema API </h1> <div class="schema-api-list"> <section class="detail"> <h3 class="detail-header" id="c:delete!/2">delete!( struct_or_changeset, opts )<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/repo.ex#L1734" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback delete!(
  struct_or_changeset :: Ecto.Schema.t() | Ecto.Changeset.t(),
  opts :: Keyword.t()
) :: Ecto.Schema.t()</pre> </div> <p>Same as <a href="#c:delete/2"><code class="inline">delete/2</code></a> but returns the struct or raises if the changeset is invalid.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:delete/2">delete( struct_or_changeset, opts )<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/repo.ex#L1701" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback delete(
  struct_or_changeset :: Ecto.Schema.t() | Ecto.Changeset.t(),
  opts :: Keyword.t()
) :: {:ok, Ecto.Schema.t()} | {:error, Ecto.Changeset.t()}</pre> </div> <p>Deletes a struct using its primary key.</p>
<p>If the struct has no primary key, <a href="ecto.noprimarykeyfielderror.html"><code class="inline">Ecto.NoPrimaryKeyFieldError</code></a> will be raised. If the struct has been removed prior to the call, <a href="ecto.staleentryerror.html"><code class="inline">Ecto.StaleEntryError</code></a> will be raised. If more than one database operation is required, they're automatically wrapped in a transaction.</p>
<p>It returns <code class="inline">{:ok, struct}</code> if the struct has been successfully deleted or <code class="inline">{:error, changeset}</code> if there was a validation or a known constraint error. By default, constraint errors will raise the <a href="ecto.constrainterror.html"><code class="inline">Ecto.ConstraintError</code></a> exception, unless a changeset is given as the first argument with the relevant constraints declared in it (see <a href="ecto.changeset.html"><code class="inline">Ecto.Changeset</code></a>).</p>
<h4 id="c:delete/2-options" class="section-heading">  Options </h4> <ul>
<li><p><code class="inline">:prefix</code> - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This overrides the prefix set in the query and any <code class="inline">@schema_prefix</code> set in the schema.</p></li>
<li><p><code class="inline">:stale_error_field</code> - The field where stale errors will be added in the returning changeset. This option can be used to avoid raising <a href="ecto.staleentryerror.html"><code class="inline">Ecto.StaleEntryError</code></a>.</p></li>
<li><p><code class="inline">:stale_error_message</code> - The message to add to the configured <code class="inline">:stale_error_field</code> when stale errors happen, defaults to "is stale".</p></li>
</ul>
<p>See the <a href="#module-shared-options">"Shared options"</a> section at the module documentation for more options.</p>
<h4 id="c:delete/2-example" class="section-heading">  Example </h4> <pre data-language="elixir">post = MyRepo.get!(Post, 42)
case MyRepo.delete post do
  {:ok, struct}       -&gt; # Deleted with success
  {:error, changeset} -&gt; # Something went wrong
end</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:insert!/2">insert!( struct_or_changeset, opts )<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/repo.ex#L1710" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback insert!(
  struct_or_changeset :: Ecto.Schema.t() | Ecto.Changeset.t(),
  opts :: Keyword.t()
) :: Ecto.Schema.t()</pre> </div> <p>Same as <a href="#c:insert/2"><code class="inline">insert/2</code></a> but returns the struct or raises if the changeset is invalid.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:insert/2">insert( struct_or_changeset, opts )<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/repo.ex#L1544" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback insert(
  struct_or_changeset :: Ecto.Schema.t() | Ecto.Changeset.t(),
  opts :: Keyword.t()
) :: {:ok, Ecto.Schema.t()} | {:error, Ecto.Changeset.t()}</pre> </div> <p>Inserts a struct defined via <a href="ecto.schema.html"><code class="inline">Ecto.Schema</code></a> or a changeset.</p>
<p>In case a struct is given, the struct is converted into a changeset with all non-nil fields as part of the changeset.</p>
<p>In case a changeset is given, the changes in the changeset are merged with the struct fields, and all of them are sent to the database. If more than one database operation is required, they're automatically wrapped in a transaction.</p>
<p>It returns <code class="inline">{:ok, struct}</code> if the struct has been successfully inserted or <code class="inline">{:error, changeset}</code> if there was a validation or a known constraint error.</p>
<h4 id="c:insert/2-options" class="section-heading">  Options </h4> <ul>
<li><p><code class="inline">:returning</code> - selects which fields to return. It accepts a list of fields to be returned from the database. When <code class="inline">true</code>, returns all fields. When <code class="inline">false</code>, no extra fields are returned. It will always include all fields in <code class="inline">read_after_writes</code> as well as any autogenerated id. Not all databases support this option and it may not be available during upserts. See the "Upserts" section for more information.</p></li>
<li><p><code class="inline">:prefix</code> - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This overrides the prefix set in the query and any <code class="inline">@schema_prefix</code> set any schemas. Also, the <code class="inline">@schema_prefix</code> for the parent record will override all default <code class="inline">@schema_prefix</code>s set in any child schemas for associations.</p></li>
<li><p><code class="inline">:on_conflict</code> - It may be one of <code class="inline">:raise</code> (the default), <code class="inline">:nothing</code>, <code class="inline">:replace_all</code>, <code class="inline">{:replace_all_except, fields}</code>, <code class="inline">{:replace, fields}</code>, a keyword list of update instructions or an <a href="ecto.query.html"><code class="inline">Ecto.Query</code></a> query for updates. See the "Upserts" section for more information.</p></li>
<li><p><code class="inline">:conflict_target</code> - A list of column names to verify for conflicts. It is expected those columns to have unique indexes on them that may conflict. If none is specified, the conflict target is left up to the database. It may also be <code class="inline">{:unsafe_fragment, binary_fragment}</code> to pass any expression to the database without any sanitization, this is useful for partial index or index with expressions, such as <code class="inline">{:unsafe_fragment, "(coalesce(firstname, ""), coalesce(lastname, "")) WHERE middlename IS NULL"}</code> for <code class="inline">ON CONFLICT (coalesce(firstname, ""), coalesce(lastname, "")) WHERE middlename IS NULL</code> SQL query.</p></li>
<li><p><code class="inline">:stale_error_field</code> - The field where stale errors will be added in the returning changeset. This option can be used to avoid raising <a href="ecto.staleentryerror.html"><code class="inline">Ecto.StaleEntryError</code></a>.</p></li>
<li><p><code class="inline">:stale_error_message</code> - The message to add to the configured <code class="inline">:stale_error_field</code> when stale errors happen, defaults to "is stale".</p></li>
</ul>
<p>See the <a href="#module-shared-options">"Shared options"</a> section at the module documentation for more options.</p>
<h4 id="c:insert/2-examples" class="section-heading">  Examples </h4> <p>A typical example is calling <code class="inline">MyRepo.insert/1</code> with a struct and acting on the return value:</p>
<pre data-language="elixir">case MyRepo.insert %Post{title: "Ecto is great"} do
  {:ok, struct}       -&gt; # Inserted with success
  {:error, changeset} -&gt; # Something went wrong
end</pre>
<h4 id="c:insert/2-upserts" class="section-heading">  Upserts </h4> <p><a href="#c:insert/2"><code class="inline">insert/2</code></a> provides upserts (update or inserts) via the <code class="inline">:on_conflict</code> option. The <code class="inline">:on_conflict</code> option supports the following values:</p>
<ul>
<li><p><code class="inline">:raise</code> - raises if there is a conflicting primary key or unique index</p></li>
<li><p><code class="inline">:nothing</code> - ignores the error in case of conflicts</p></li>
<li><p><code class="inline">:replace_all</code> - replace <strong>all</strong> values on the existing row with the values in the schema/changeset, including fields not explicitly set in the changeset, such as IDs and autogenerated timestamps (<code class="inline">inserted_at</code> and <code class="inline">updated_at</code>). Do not use this option if you have auto-incrementing primary keys, as they will also be replaced. You most likely want to use <code class="inline">{:replace_all_except, [:id]}</code> or <code class="inline">{:replace, fields}</code> explicitly instead. This option requires a schema</p></li>
<li><p><code class="inline">{:replace_all_except, fields}</code> - same as above except the given fields are not replaced. This option requires a schema</p></li>
<li><p><code class="inline">{:replace, fields}</code> - replace only specific columns. This option requires <code class="inline">:conflict_target</code></p></li>
<li><p>a keyword list of update instructions - such as the one given to <a href="#c:update_all/3"><code class="inline">update_all/3</code></a>, for example: <code class="inline">[set: [title: "new title"]]</code></p></li>
<li><p>an <a href="ecto.query.html"><code class="inline">Ecto.Query</code></a> that will act as an <code class="inline">UPDATE</code> statement, such as the one given to <a href="#c:update_all/3"><code class="inline">update_all/3</code></a>. Similarly to <a href="#c:update_all/3"><code class="inline">update_all/3</code></a>, auto generated values, such as timestamps are not automatically updated. If the struct cannot be found, <a href="ecto.staleentryerror.html"><code class="inline">Ecto.StaleEntryError</code></a> will be raised.</p></li>
</ul>
<p>Upserts map to "ON CONFLICT" on databases like Postgres and "ON DUPLICATE KEY" on databases such as MySQL.</p>
<p>As an example, imagine <code class="inline">:title</code> is marked as a unique column in the database:</p>
<pre data-language="elixir">{:ok, inserted} = MyRepo.insert(%Post{title: "this is unique"})</pre>
<p>Now we can insert with the same title but do nothing on conflicts:</p>
<pre data-language="elixir">{:ok, ignored} = MyRepo.insert(%Post{title: "this is unique"}, on_conflict: :nothing)</pre>
<p>Because we used <code class="inline">on_conflict: :nothing</code>, instead of getting an error, we got <code class="inline">{:ok, struct}</code>. However the returned struct does not reflect the data in the database. If the primary key is auto-generated by the database, the primary key in the <code class="inline">ignored</code> record will be nil if there was no insertion. For example, if you use the default primary key (which has name <code class="inline">:id</code> and a type of <code class="inline">:id</code>), then <code class="inline">ignored.id</code> above will be nil if there was no insertion.</p>
<p>If your id is generated by your application (typically the case for <code class="inline">:binary_id</code>) or if you pass another value for <code class="inline">:on_conflict</code>, detecting if an insert or update happened is slightly more complex, as the database does not actually inform us what happened. Let's insert a post with the same title but use a query to update the body column in case of conflicts:</p>
<pre data-language="elixir"># In Postgres (it requires the conflict target for updates):
on_conflict = [set: [body: "updated"]]
{:ok, updated} = MyRepo.insert(%Post{title: "this is unique"},
                               on_conflict: on_conflict, conflict_target: :title)

# In MySQL (conflict target is not supported):
on_conflict = [set: [title: "updated"]]
{:ok, updated} = MyRepo.insert(%Post{id: inserted.id, title: "updated"},
                               on_conflict: on_conflict)</pre>
<p>In the examples above, even though it returned <code class="inline">:ok</code>, we do not know if we inserted new data or if we updated only the <code class="inline">:on_conflict</code> fields. In case an update happened, the data in the struct most likely does not match the data in the database. For example, autogenerated fields such as <code class="inline">inserted_at</code> will point to now rather than the time the struct was actually inserted.</p>
<p>If you need to guarantee the data in the returned struct mirrors the database, you have three options:</p>
<ul>
<li>
<p>Use <code class="inline">on_conflict: :replace_all</code>, although that will replace all fields in the database with the ones in the struct/changeset, including autogenerated fields such as <code class="inline">inserted_at</code> and <code class="inline">updated_at</code>:</p>
<pre data-language="elixir">MyRepo.insert(%Post{title: "this is unique"},
              on_conflict: :replace_all, conflict_target: :title)</pre>
</li>
<li>
<p>Specify <code class="inline">read_after_writes: true</code> in your schema for choosing fields that are read from the database after every operation. Or pass <code class="inline">returning: true</code> to <code class="inline">insert</code> to read all fields back:</p>
<pre data-language="elixir">MyRepo.insert(%Post{title: "this is unique"}, returning: true,
              on_conflict: on_conflict, conflict_target: :title)</pre>
</li>
<li>
<p>Alternatively, read the data again from the database in a separate query. This option requires the primary key to be generated by the database:</p>
<pre data-language="elixir">{:ok, updated} = MyRepo.insert(%Post{title: "this is unique"}, on_conflict: on_conflict)
Repo.get(Post, updated.id)</pre>
</li>
</ul>
<p>Because of the inability to know if the struct is up to date or not, inserting a struct with associations and using the <code class="inline">:on_conflict</code> option at the same time is not recommended, as Ecto will be unable to actually track the proper status of the association.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:insert_all/3">insert_all( schema_or_source, entries_or_query, opts )<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/repo.ex#L1371" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback insert_all(
  schema_or_source :: binary() | {binary(), module()} | module(),
  entries_or_query ::
    [%{required(atom()) =&gt; value} | Keyword.t(value)] | Ecto.Query.t(),
  opts :: Keyword.t()
) :: {non_neg_integer(), nil | [term()]}
when value: term() | Ecto.Query.t()</pre> </div> <p>Inserts all entries into the repository.</p>
<p>It expects a schema module (<code class="inline">MyApp.User</code>) or a source (<code class="inline">"users"</code>) or both (<code class="inline">{"users", MyApp.User}</code>) as the first argument. The second argument is a list of entries to be inserted, either as keyword lists or as maps. The keys of the entries are the field names as atoms and the value should be the respective value for the field type or, optionally, an <a href="ecto.query.html"><code class="inline">Ecto.Query</code></a> that returns a single entry with a single value.</p>
<p>It returns a tuple containing the number of entries and any returned result as second element. If the database does not support RETURNING in INSERT statements or no return result was selected, the second element will be <code class="inline">nil</code>.</p>
<p>When a schema module is given, the entries given will be properly dumped before being sent to the database. If the schema primary key has type <code class="inline">:id</code> or <code class="inline">:binary_id</code>, it will be handled either at the adapter or the storage layer. However any other primary key type or autogenerated value, like <a href="ecto.uuid.html"><code class="inline">Ecto.UUID</code></a> and timestamps, won't be autogenerated when using <a href="#c:insert_all/3"><code class="inline">insert_all/3</code></a>. You must set those fields explicitly. This is by design as this function aims to be a more direct way to insert data into the database without the conveniences of <a href="#c:insert/2"><code class="inline">insert/2</code></a>. This is also consistent with <a href="#c:update_all/3"><code class="inline">update_all/3</code></a> that does not handle auto generated values as well.</p>
<p>It is also not possible to use <code class="inline">insert_all</code> to insert across multiple tables, therefore associations are not supported.</p>
<p>If a source is given, without a schema module, the given fields are passed as is to the adapter.</p>
<h4 id="c:insert_all/3-options" class="section-heading">  Options </h4> <ul>
<li><p><code class="inline">:returning</code> - selects which fields to return. When <code class="inline">true</code>, returns all fields in the given schema. May be a list of fields, where a struct is still returned but only with the given fields. Or <code class="inline">false</code>, where nothing is returned (the default). This option is not supported by all databases.</p></li>
<li><p><code class="inline">:prefix</code> - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This overrides the prefix set in the query and any <code class="inline">@schema_prefix</code> set in the schema.</p></li>
<li><p><code class="inline">:on_conflict</code> - It may be one of <code class="inline">:raise</code> (the default), <code class="inline">:nothing</code>, <code class="inline">:replace_all</code>, <code class="inline">{:replace_all_except, fields}</code>, <code class="inline">{:replace, fields}</code>, a keyword list of update instructions or an <a href="ecto.query.html"><code class="inline">Ecto.Query</code></a> query for updates. See the "Upserts" section for more information.</p></li>
<li><p><code class="inline">:conflict_target</code> - A list of column names to verify for conflicts. It is expected those columns to have unique indexes on them that may conflict. If none is specified, the conflict target is left up to the database. It may also be <code class="inline">{:unsafe_fragment, binary_fragment}</code> to pass any expression to the database without any sanitization, this is useful for partial index or index with expressions, such as <code class="inline">{:unsafe_fragment, "(coalesce(firstname, ""), coalesce(lastname, "")) WHERE middlename IS NULL"}</code> for <code class="inline">ON CONFLICT (coalesce(firstname, ""), coalesce(lastname, "")) WHERE middlename IS NULL</code> SQL query.</p></li>
<li><p><code class="inline">:placeholders</code> - A map with placeholders. This feature is not supported by all databases. See the "Placeholders" section for more information.</p></li>
</ul>
<p>See the <a href="#module-shared-options">"Shared options"</a> section at the module documentation for remaining options.</p>
<h4 id="c:insert_all/3-source-query" class="section-heading">  Source query </h4> <p>A query can be given instead of a list with entries. This query needs to select into a map containing only keys that are available as writeable columns in the schema.</p>
<h4 id="c:insert_all/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">MyRepo.insert_all(Post, [[title: "My first post"], [title: "My second post"]])

MyRepo.insert_all(Post, [%{title: "My first post"}, %{title: "My second post"}])

query = from p in Post,
  join: c in assoc(p, :comments),
  select: %{
    author_id: p.author_id,
    posts: count(p.id, :distinct),
    interactions: sum(p.likes) + count(c.id)
  },
  group_by: p.author_id
MyRepo.insert_all(AuthorStats, query)</pre>
<h4 id="c:insert_all/3-upserts" class="section-heading">  Upserts </h4> <p><a href="#c:insert_all/3"><code class="inline">insert_all/3</code></a> provides upserts (update or inserts) via the <code class="inline">:on_conflict</code> option. The <code class="inline">:on_conflict</code> option supports the following values:</p>
<ul>
<li><p><code class="inline">:raise</code> - raises if there is a conflicting primary key or unique index</p></li>
<li><p><code class="inline">:nothing</code> - ignores the error in case of conflicts</p></li>
<li><p><code class="inline">:replace_all</code> - replace <strong>all</strong> values on the existing row with the values in the schema/changeset, including fields not explicitly set in the changeset, such as IDs and autogenerated timestamps (<code class="inline">inserted_at</code> and <code class="inline">updated_at</code>). Do not use this option if you have auto-incrementing primary keys, as they will also be replaced. You most likely want to use <code class="inline">{:replace_all_except, [:id]}</code> or <code class="inline">{:replace, fields}</code> explicitly instead. This option requires a schema</p></li>
<li><p><code class="inline">{:replace_all_except, fields}</code> - same as above except the given fields are not replaced. This option requires a schema</p></li>
<li><p><code class="inline">{:replace, fields}</code> - replace only specific columns. This option requires <code class="inline">:conflict_target</code></p></li>
<li><p>a keyword list of update instructions - such as the one given to <a href="#c:update_all/3"><code class="inline">update_all/3</code></a>, for example: <code class="inline">[set: [title: "new title"]]</code></p></li>
<li><p>an <a href="ecto.query.html"><code class="inline">Ecto.Query</code></a> that will act as an <code class="inline">UPDATE</code> statement, such as the one given to <a href="#c:update_all/3"><code class="inline">update_all/3</code></a></p></li>
</ul>
<p>Upserts map to "ON CONFLICT" on databases like Postgres and "ON DUPLICATE KEY" on databases such as MySQL.</p>
<h4 id="c:insert_all/3-return-values" class="section-heading">  Return values </h4> <p>By default, both Postgres and MySQL will return the number of entries inserted on <a href="#c:insert_all/3"><code class="inline">insert_all/3</code></a>. However, when the <code class="inline">:on_conflict</code> option is specified, Postgres and MySQL will return different results.</p>
<p>Postgres will only count a row if it was affected and will return 0 if no new entry was added.</p>
<p>MySQL will return, at a minimum, the number of entries attempted. For example, if <code class="inline">:on_conflict</code> is set to <code class="inline">:nothing</code>, MySQL will return the number of entries attempted to be inserted, even when no entry was added.</p>
<p>Also note that if <code class="inline">:on_conflict</code> is a query, MySQL will return the number of attempted entries plus the number of entries modified by the UPDATE query.</p>
<h4 id="c:insert_all/3-placeholders" class="section-heading">  Placeholders </h4> <p>Passing in a map for the <code class="inline">:placeholders</code> allows you to send less data over the wire when you have many entries with the same value for a field. To use a placeholder, replace its value in each of your entries with <code class="inline">{:placeholder, key}</code>, where <code class="inline">key</code> is the key you are using in the <code class="inline">:placeholders</code> option map. For example:</p>
<pre data-language="elixir">placeholders = %{blob: large_blob_of_text(...)}

entries = [
  %{title: "v1", body: {:placeholder, :blob}},
  %{title: "v2", body: {:placeholder, :blob}}
]

Repo.insert_all(Post, entries, placeholders: placeholders)</pre>
<p>Keep in mind that:</p>
<ul>
<li><p>placeholders cannot be nested in other values. For example, you cannot put a placeholder inside an array. Instead, the whole array has to be the placeholder</p></li>
<li><p>a placeholder key can only be used with columns of the same type</p></li>
<li><p>placeholders require a database that supports index parameters, so they are not currently compatible with MySQL</p></li>
</ul> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:insert_or_update!/2">insert_or_update!(changeset, opts)<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/repo.ex#L1724" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback insert_or_update!(changeset :: Ecto.Changeset.t(), opts :: Keyword.t()) ::
  Ecto.Schema.t()</pre> </div> <p>Same as <a href="#c:insert_or_update/2"><code class="inline">insert_or_update/2</code></a> but returns the struct or raises if the changeset is invalid.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:insert_or_update/2">insert_or_update(changeset, opts)<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/repo.ex#L1654" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback insert_or_update(changeset :: Ecto.Changeset.t(), opts :: Keyword.t()) ::
  {:ok, Ecto.Schema.t()} | {:error, Ecto.Changeset.t()}</pre> </div> <p>Inserts or updates a changeset depending on whether the struct is persisted or not.</p>
<p>The distinction whether to insert or update will be made on the <a href="ecto.schema.metadata.html"><code class="inline">Ecto.Schema.Metadata</code></a> field <code class="inline">:state</code>. The <code class="inline">:state</code> is automatically set by Ecto when loading or building a schema.</p>
<p>Please note that for this to work, you will have to load existing structs from the database. So even if the struct exists, this won't work:</p>
<pre data-language="elixir">struct = %Post{id: "existing_id", ...}
MyRepo.insert_or_update changeset
# =&gt; {:error, changeset} # id already exists</pre>
<h4 id="c:insert_or_update/2-options" class="section-heading">  Options </h4> <ul>
<li>
<code class="inline">:prefix</code> - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This overrides the prefix set in the query and any <code class="inline">@schema_prefix</code> set any schemas. Also, the <code class="inline">@schema_prefix</code> for the parent record will override all default <code class="inline">@schema_prefix</code>s set in any child schemas for associations.</li>
<li>
<code class="inline">:stale_error_field</code> - The field where stale errors will be added in the returning changeset. This option can be used to avoid raising <a href="ecto.staleentryerror.html"><code class="inline">Ecto.StaleEntryError</code></a>. Only applies to updates.</li>
<li>
<code class="inline">:stale_error_message</code> - The message to add to the configured <code class="inline">:stale_error_field</code> when stale errors happen, defaults to "is stale". Only applies to updates.</li>
</ul>
<p>See the <a href="#module-shared-options">"Shared options"</a> section at the module documentation for more options.</p>
<h4 id="c:insert_or_update/2-example" class="section-heading">  Example </h4> <pre data-language="elixir">result =
  case MyRepo.get(Post, id) do
    nil  -&gt; %Post{id: id} # Post not found, we build one
    post -&gt; post          # Post exists, let's use it
  end
  |&gt; Post.changeset(changes)
  |&gt; MyRepo.insert_or_update

case result do
  {:ok, struct}       -&gt; # Inserted or updated with success
  {:error, changeset} -&gt; # Something went wrong
end</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:load/2">load( schema_or_map, data )<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/repo.ex#L586" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback load(
  schema_or_map :: module() | map(),
  data :: map() | Keyword.t() | {list(), list()}
) :: Ecto.Schema.t() | map()</pre> </div> <p>Loads <code class="inline">data</code> into a schema or a map.</p>
<p>The first argument can be a a schema module or a map (of types). The first argument determines the return value: a struct or a map, respectively.</p>
<p>The second argument <code class="inline">data</code> specifies fields and values that are to be loaded. It can be a map, a keyword list, or a <code class="inline">{fields, values}</code> tuple. Fields can be atoms or strings.</p>
<p>Fields that are not present in the schema (or <code class="inline">types</code> map) are ignored. If any of the values has invalid type, an error is raised.</p>
<p>To load data from non-database sources, use <a href="ecto.html#embedded_load/3"><code class="inline">Ecto.embedded_load/3</code></a>.</p>
<h4 id="c:load/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">iex&gt; MyRepo.load(User, %{name: "Alice", age: 25})
%User{name: "Alice", age: 25}

iex&gt; MyRepo.load(User, [name: "Alice", age: 25])
%User{name: "Alice", age: 25}</pre>
<p><code class="inline">data</code> can also take form of <code class="inline">{fields, values}</code>:</p>
<pre data-language="elixir">iex&gt; MyRepo.load(User, {[:name, :age], ["Alice", 25]})
%User{name: "Alice", age: 25, ...}</pre>
<p>The first argument can also be a <code class="inline">types</code> map:</p>
<pre data-language="elixir">iex&gt; types = %{name: :string, age: :integer}
iex&gt; MyRepo.load(types, %{name: "Alice", age: 25})
%{name: "Alice", age: 25}</pre>
<p>This function is especially useful when parsing raw query results:</p>
<pre data-language="elixir">iex&gt; result = Ecto.Adapters.SQL.query!(MyRepo, "SELECT * FROM users", [])
iex&gt; Enum.map(result.rows, &amp;MyRepo.load(User, {result.columns, &amp;1}))
[%User{...}, ...]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:preload/3">preload(structs_or_struct_or_nil, preloads, opts)<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/repo.ex#L992" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback preload(structs_or_struct_or_nil, preloads :: term(), opts :: Keyword.t()) ::
  structs_or_struct_or_nil
when structs_or_struct_or_nil: [Ecto.Schema.t()] | Ecto.Schema.t() | nil</pre> </div> <p>Preloads all associations on the given struct or structs.</p>
<p>This is similar to <a href="ecto.query.html#preload/3"><code class="inline">Ecto.Query.preload/3</code></a> except it allows you to preload structs after they have been fetched from the database.</p>
<p>In case the association was already loaded, preload won't attempt to reload it.</p>
<h4 id="c:preload/3-options" class="section-heading">  Options </h4> <ul>
<li>
<code class="inline">:force</code> - By default, Ecto won't preload associations that are already loaded. By setting this option to true, any existing association will be discarded and reloaded.</li>
<li>
<code class="inline">:in_parallel</code> - If the preloads must be done in parallel. It can only be performed when we have more than one preload and the repository is not in a transaction. Defaults to <code class="inline">true</code>.</li>
<li>
<code class="inline">:prefix</code> - the prefix to fetch preloads from. By default, queries will use the same prefix as the first struct in the given collection. This option allows the prefix to be changed.</li>
</ul>
<p>See the <a href="#module-shared-options">"Shared options"</a> section at the module documentation for more options.</p>
<h4 id="c:preload/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"># Use a single atom to preload an association
posts = Repo.preload posts, :comments

# Use a list of atoms to preload multiple associations
posts = Repo.preload posts, [:comments, :authors]

# Use a keyword list to preload nested associations as well
posts = Repo.preload posts, [comments: [:replies, :likes], authors: []]

# You can mix atoms and keywords, but the atoms must come first
posts = Repo.preload posts, [:authors, comments: [:likes, replies: [:reactions]]]

# Use a keyword list to customize how associations are queried
posts = Repo.preload posts, [comments: from(c in Comment, order_by: c.published_at)]

# Use a two-element tuple for a custom query and nested association definition
query = from c in Comment, order_by: c.published_at
posts = Repo.preload posts, [comments: {query, [:replies, :likes]}]</pre>
<p>The query given to preload may also preload its own associations.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:reload!/2">reload!(struct_or_structs, opts)<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/repo.ex#L791" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback reload!(struct_or_structs, opts :: Keyword.t()) :: struct_or_structs
when struct_or_structs: Ecto.Schema.t() | [Ecto.Schema.t()]</pre> </div> <p>Similar to <a href="#c:reload/2"><code class="inline">reload/2</code></a>, but raises when something is not found.</p>
<p>When using with lists, ordering is guaranteed to be kept.</p>
<h4 id="c:reload!/2-example" class="section-heading">  Example </h4> <pre data-language="elixir">MyRepo.reload!(post)
%Post{}

MyRepo.reload!([post1, post2])
[%Post{}, %Post{}]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:reload/2">reload( struct_or_structs, opts )<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/repo.ex#L775" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback reload(
  struct_or_structs :: Ecto.Schema.t() | [Ecto.Schema.t()],
  opts :: Keyword.t()
) :: Ecto.Schema.t() | [Ecto.Schema.t() | nil] | nil</pre> </div> <p>Reloads a given schema or schema list from the database.</p>
<p>When using with lists, it is expected that all of the structs in the list belong to the same schema. Ordering is guaranteed to be kept. Results not found in the database will be returned as <code class="inline">nil</code>.</p>
<h4 id="c:reload/2-example" class="section-heading">  Example </h4> <pre data-language="elixir">MyRepo.reload(post)
%Post{}

MyRepo.reload([post1, post2])
[%Post{}, %Post{}]

MyRepo.reload([deleted_post, post1])
[nil, %Post{}]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:update!/2">update!(changeset, opts)<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/repo.ex#L1716" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback update!(changeset :: Ecto.Changeset.t(), opts :: Keyword.t()) :: Ecto.Schema.t()</pre> </div> <p>Same as <a href="#c:update/2"><code class="inline">update/2</code></a> but returns the struct or raises if the changeset is invalid.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:update/2">update(changeset, opts)<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/repo.ex#L1603" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback update(changeset :: Ecto.Changeset.t(), opts :: Keyword.t()) ::
  {:ok, Ecto.Schema.t()} | {:error, Ecto.Changeset.t()}</pre> </div> <p>Updates a changeset using its primary key.</p>
<p>A changeset is required as it is the only mechanism for tracking dirty changes. Only the fields present in the <code class="inline">changes</code> part of the changeset are sent to the database. Any other, in-memory changes done to the schema are ignored. If more than one database operation is required, they're automatically wrapped in a transaction.</p>
<p>If the struct has no primary key, <a href="ecto.noprimarykeyfielderror.html"><code class="inline">Ecto.NoPrimaryKeyFieldError</code></a> will be raised.</p>
<p>If the struct cannot be found, <a href="ecto.staleentryerror.html"><code class="inline">Ecto.StaleEntryError</code></a> will be raised.</p>
<p>It returns <code class="inline">{:ok, struct}</code> if the struct has been successfully updated or <code class="inline">{:error, changeset}</code> if there was a validation or a known constraint error.</p>
<h4 id="c:update/2-options" class="section-heading">  Options </h4> <ul>
<li><p><code class="inline">:returning</code> - selects which fields to return. It accepts a list of fields to be returned from the database. When <code class="inline">true</code>, returns all fields. When <code class="inline">false</code>, no extra fields are returned. It will always include all fields in <code class="inline">read_after_writes</code>. Not all databases support this option.</p></li>
<li><p><code class="inline">:force</code> - By default, if there are no changes in the changeset, <a href="#c:update/2"><code class="inline">update/2</code></a> is a no-op. By setting this option to true, update callbacks will always be executed, even if there are no changes (including timestamps).</p></li>
<li><p><code class="inline">:prefix</code> - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This overrides the prefix set in the query and any <code class="inline">@schema_prefix</code> set any schemas. Also, the <code class="inline">@schema_prefix</code> for the parent record will override all default <code class="inline">@schema_prefix</code>s set in any child schemas for associations.</p></li>
<li><p><code class="inline">:stale_error_field</code> - The field where stale errors will be added in the returning changeset. This option can be used to avoid raising <a href="ecto.staleentryerror.html"><code class="inline">Ecto.StaleEntryError</code></a>.</p></li>
<li><p><code class="inline">:stale_error_message</code> - The message to add to the configured <code class="inline">:stale_error_field</code> when stale errors happen, defaults to "is stale".</p></li>
</ul>
<p>See the <a href="#module-shared-options">"Shared options"</a> section at the module documentation for more options.</p>
<h4 id="c:update/2-example" class="section-heading">  Example </h4> <pre data-language="elixir">post = MyRepo.get!(Post, 42)
post = Ecto.Changeset.change post, title: "New title"
case MyRepo.update post do
  {:ok, struct}       -&gt; # Updated with success
  {:error, changeset} -&gt; # Something went wrong
end</pre> </section> </section> </div> </section> <section id="transaction-api" class="details-list"> <h1 class="section-heading">  Transaction API </h1> <div class="transaction-api-list"> <section class="detail"> <h3 class="detail-header" id="c:checked_out?/0">checked_out?()<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/repo.ex#L538" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback checked_out?() :: boolean()</pre> </div> <p>Returns true if a connection has been checked out.</p>
<p>This is true if inside a <a href="#c:checkout/2"><code class="inline">Ecto.Repo.checkout/2</code></a> or <a href="#c:transaction/2"><code class="inline">Ecto.Repo.transaction/2</code></a>.</p>
<h4 id="c:checked_out?/0-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">MyRepo.checked_out?
#=&gt; false

MyRepo.transaction(fn -&gt;
  MyRepo.checked_out? #=&gt; true
end)

MyRepo.checkout(fn -&gt;
  MyRepo.checked_out? #=&gt; true
end)</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:checkout/2">checkout(function, opts)<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/repo.ex#L515" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback checkout((() -&gt; result), opts :: Keyword.t()) :: result when result: var</pre> </div> <p>Checks out a connection for the duration of the function.</p>
<p>It returns the result of the function. This is useful when you need to perform multiple operations against the repository in a row and you want to avoid checking out the connection multiple times.</p>
<p><code class="inline">checkout/2</code> and <code class="inline">transaction/2</code> can be combined and nested multiple times. If <code class="inline">checkout/2</code> is called inside the function of another <code class="inline">checkout/2</code> call, the function is simply executed, without checking out a new connection.</p>
<h4 id="c:checkout/2-options" class="section-heading">  Options </h4> <p>See the <a href="#module-shared-options">"Shared options"</a> section at the module documentation for more options.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:in_transaction?/0">in_transaction?()<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/repo.ex#L1864" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback in_transaction?() :: boolean()</pre> </div> <p>Returns true if the current process is inside a transaction.</p>
<p>If you are using the <code class="inline">Ecto.Adapters.SQL.Sandbox</code> in tests, note that even though each test is inside a transaction, <code class="inline">in_transaction?/0</code> will only return true inside transactions explicitly created with <code class="inline">transaction/2</code>. This is done so the test environment mimics dev and prod.</p>
<h4 id="c:in_transaction?/0-examples" class="section-heading">  Examples </h4> <pre data-language="elixir">MyRepo.in_transaction?
#=&gt; false

MyRepo.transaction(fn -&gt;
  MyRepo.in_transaction? #=&gt; true
end)</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:rollback/1">rollback(value)<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/repo.ex#L1874" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback rollback(value :: any()) :: no_return()</pre> </div> <p>Rolls back the current transaction.</p>
<p>The transaction will return the value given as <code class="inline">{:error, value}</code>.</p>
<p>Note that calling <code class="inline">rollback</code> causes the code in the transaction to stop executing.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:transaction/2">transaction(fun_or_multi, opts)<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/repo.ex#L1840" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback transaction(
  fun_or_multi :: (... -&gt; any()) | Ecto.Multi.t(),
  opts :: Keyword.t()
) ::
  {:ok, any()}
  | {:error, any()}
  | {:error, Ecto.Multi.name(), any(), %{required(Ecto.Multi.name()) =&gt; any()}}</pre> </div> <p>Runs the given function or <a href="ecto.multi.html"><code class="inline">Ecto.Multi</code></a> inside a transaction.</p>
<h4 id="c:transaction/2-use-with-function" class="section-heading">  Use with function </h4> <p><a href="#c:transaction/2"><code class="inline">transaction/2</code></a> can be called with both a function of arity zero or one. The arity zero function will just be executed as is:</p>
<pre data-language="elixir">import Ecto.Changeset, only: [change: 2]

MyRepo.transaction(fn -&gt;
  MyRepo.update!(change(alice, balance: alice.balance - 10))
  MyRepo.update!(change(bob, balance: bob.balance + 10))
end)</pre>
<p>While the arity one function will receive the repo of the transaction as its first argument:</p>
<pre data-language="elixir">MyRepo.transaction(fn repo -&gt;
  repo.insert!(%Post{})
end)</pre>
<p>If an unhandled error occurs the transaction will be rolled back and the error will bubble up from the transaction function. If no error occurred the transaction will be committed when the function returns. A transaction can be explicitly rolled back by calling <a href="#c:rollback/1"><code class="inline">rollback/1</code></a>, this will immediately leave the function and return the value given to <code class="inline">rollback</code> as <code class="inline">{:error, value}</code>.</p>
<p>A successful transaction returns the value returned by the function wrapped in a tuple as <code class="inline">{:ok, value}</code>.</p>
<p>If <a href="#c:transaction/2"><code class="inline">transaction/2</code></a> is called inside another transaction, the function is simply executed, without wrapping the new transaction call in any way. If there is an error in the inner transaction and the error is rescued, or the inner transaction is rolled back, the whole outer transaction is marked as tainted, guaranteeing nothing will be committed.</p>
<p>Below is an example of how rollbacks work with nested transactions:</p>
<pre data-language="elixir">{:error, :rollback} =
  MyRepo.transaction(fn -&gt;
    {:error, :posting_not_allowed} =
      MyRepo.transaction(fn -&gt;
        # This function call causes the following to happen:
        #
        #   * the transaction is rolled back in the database,
        #   * code execution is stopped within the current function,
        #   * and the value, passed to `rollback/1` is returned from
        #     `MyRepo.transaction/1` as the second element in the error
        #     tuple.
        #
        MyRepo.rollback(:posting_not_allowed)

        # `rollback/1` stops execution, so code here won't be run
      end)

    # When the inner transaction was rolled back, execution in this outer
    # transaction is also stopped immediately. When this occurs, the
    # outer transaction(s) return `{:error, :rollback}`.
  end)</pre>
<h4 id="c:transaction/2-use-with-ecto-multi" class="section-heading">  Use with Ecto.Multi </h4> <p>Besides functions, transactions can be used with an <a href="ecto.multi.html"><code class="inline">Ecto.Multi</code></a> struct. A transaction will be started, all operations applied and in case of success committed returning <code class="inline">{:ok, changes}</code>:</p>
<pre data-language="elixir"># With Ecto.Multi
Ecto.Multi.new()
|&gt; Ecto.Multi.insert(:post, %Post{})
|&gt; MyRepo.transaction</pre>
<p>In case of any errors the transaction will be rolled back and <code class="inline">{:error, failed_operation, failed_value, changes_so_far}</code> will be returned.</p>
<p>You can read more about using transactions with <a href="ecto.multi.html"><code class="inline">Ecto.Multi</code></a> as well as see some examples in the <a href="ecto.multi.html"><code class="inline">Ecto.Multi</code></a> documentation.</p>
<h4 id="c:transaction/2-working-with-processes" class="section-heading">  Working with processes </h4> <p>The transaction is per process. A separate process started inside a transaction won't be part of the same transaction and will use a separate connection altogether.</p>
<p>When using the the <code class="inline">Ecto.Adapters.SQL.Sandbox</code> in tests, while it may be possible to share the connection between processes, the parent process will typically hold the connection until the transaction completes. This may lead to a deadlock if the child process attempts to use the same connection. See the docs for <a href="https://hexdocs.pm/ecto_sql/Ecto.Adapters.SQL.Sandbox.html"><code class="inline">Ecto.Adapters.SQL.Sandbox</code></a> for more information.</p>
<h4 id="c:transaction/2-options" class="section-heading">  Options </h4> <p>See the <a href="#module-shared-options">"Shared options"</a> section at the module documentation for more options.</p> </section> </section> </div> </section> <section id="runtime-api" class="details-list"> <h1 class="section-heading">  Runtime API </h1> <div class="runtime-api-list"> <section class="detail"> <h3 class="detail-header" id="c:__adapter__/0">__adapter__()<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/repo.ex#L461" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback __adapter__() :: Ecto.Adapter.t()</pre> </div> <p>Returns the adapter tied to the repository.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:config/0">config()<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/repo.ex#L470" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback config() :: Keyword.t()</pre> </div> <p>Returns the adapter configuration stored in the <code class="inline">:otp_app</code> environment.</p>
<p>If the <a href="#c:init/2"><code class="inline">init/2</code></a> callback is implemented in the repository, it will be invoked with the first argument set to <code class="inline">:runtime</code>.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:get_dynamic_repo/0">get_dynamic_repo()<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/repo.ex#L594" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback get_dynamic_repo() :: atom() | pid()</pre> </div> <p>Returns the atom name or pid of the current repository.</p>
<p>See <a href="#c:put_dynamic_repo/1"><code class="inline">put_dynamic_repo/1</code></a> for more information.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:put_dynamic_repo/1">put_dynamic_repo(name_or_pid)<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/repo.ex#L627" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback put_dynamic_repo(name_or_pid :: atom() | pid()) :: atom() | pid()</pre> </div> <p>Sets the dynamic repository to be used in further interactions.</p>
<p>Sometimes you may want a single Ecto repository to talk to many different database instances. By default, when you call <code class="inline">MyApp.Repo.start_link/1</code>, it will start a repository with name <code class="inline">MyApp.Repo</code>. But if you want to start multiple repositories, you can give each of them a different name:</p>
<pre data-language="elixir">MyApp.Repo.start_link(name: :tenant_foo, hostname: "foo.example.com")
MyApp.Repo.start_link(name: :tenant_bar, hostname: "bar.example.com")</pre>
<p>You can also start repositories without names by explicitly setting the name to nil:</p>
<pre data-language="elixir">MyApp.Repo.start_link(name: nil, hostname: "temp.example.com")</pre>
<p>However, once the repository is started, you can't directly interact with it, since all operations in <code class="inline">MyApp.Repo</code> are sent by default to the repository named <code class="inline">MyApp.Repo</code>. You can change the default repo at compile time with:</p>
<pre data-language="elixir">use Ecto.Repo, default_dynamic_repo: :name_of_repo</pre>
<p>Or you can change it anytime at runtime by calling <code class="inline">put_dynamic_repo/1</code>:</p>
<pre data-language="elixir">MyApp.Repo.put_dynamic_repo(:tenant_foo)</pre>
<p>From this moment on, all future queries done by the current process will run on <code class="inline">:tenant_foo</code>.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:start_link/1">start_link(opts)<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/repo.ex#L485" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback start_link(opts :: Keyword.t()) ::
  {:ok, pid()} | {:error, {:already_started, pid()}} | {:error, term()}</pre> </div> <p>Starts any connection pooling or supervision and return <code class="inline">{:ok, pid}</code> or just <code class="inline">:ok</code> if nothing needs to be done.</p>
<p>Returns <code class="inline">{:error, {:already_started, pid}}</code> if the repo is already started or <code class="inline">{:error, term}</code> in case anything else goes wrong.</p>
<h4 id="c:start_link/1-options" class="section-heading">  Options </h4> <p>See the configuration in the moduledoc for options shared between adapters, for adapter-specific configuration see the adapter's documentation.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:stop/1">stop(timeout)<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/repo.ex#L494" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback stop(timeout()) :: :ok</pre> </div> <p>Shuts down the repository.</p> </section> </section> </div> </section> <section id="user-callbacks" class="details-list"> <h1 class="section-heading">  User callbacks </h1> <div class="user-callbacks-list"> <section class="detail"> <h3 class="detail-header" id="c:default_options/1">default_options(operation)<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/repo.ex#L1051" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback default_options(operation) :: Keyword.t()
when operation:
       :all
       | :insert_all
       | :update_all
       | :delete_all
       | :stream
       | :transaction
       | :insert
       | :update
       | :delete
       | :insert_or_update</pre> </div> <p>A user customizable callback invoked to retrieve default options for operations.</p>
<p>This can be used to provide default values per operation that have higher precedence than the values given on configuration or when starting the repository. It can also be used to set query specific options, such as <code class="inline">:prefix</code>.</p>
<p>This callback is invoked as the entry point for all repository operations. For example, if you are executing a query with preloads, this callback will be invoked once at the beginning, but the options returned here will be passed to all following operations.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:init/2">init(context, config)<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/repo.ex#L452" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback init(context :: :supervisor | :runtime, config :: Keyword.t()) ::
  {:ok, Keyword.t()} | :ignore</pre> </div> <p>A callback executed when the repo starts or when configuration is read.</p>
<p>The first argument is the context the callback is being invoked. If it is called because the Repo supervisor is starting, it will be <code class="inline">:supervisor</code>. It will be <code class="inline">:runtime</code> if it is called for reading configuration without actually starting a process.</p>
<p>The second argument is the repository configuration as stored in the application environment. It must return <code class="inline">{:ok, keyword}</code> with the updated list of configuration or <code class="inline">:ignore</code> (only in the <code class="inline">:supervisor</code> case).</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:prepare_query/3">prepare_query(operation, query, opts)<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/repo.ex#L1032" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback prepare_query(operation, query :: Ecto.Query.t(), opts :: Keyword.t()) ::
  {Ecto.Query.t(), Keyword.t()}
when operation: :all | :update_all | :delete_all | :stream | :insert_all</pre> </div> <p>A user customizable callback invoked for query-based operations.</p>
<p>This callback can be used to further modify the query and options before it is transformed and sent to the database.</p>
<p>This callback is invoked for all query APIs, including the <code class="inline">stream</code> functions. It is also invoked for <code class="inline">insert_all</code> if a source query is given. It is not invoked for any of the other schema functions.</p>
<h4 id="c:prepare_query/3-examples" class="section-heading">  Examples </h4> <p>Let's say you want to filter out records that were "soft-deleted" (have <code class="inline">deleted_at</code> column set) from all operations unless an admin is running the query; you can define the callback like this:</p>
<pre data-language="elixir">@impl true
def prepare_query(_operation, query, opts) do
  if opts[:admin] do
    {query, opts}
  else
    query = from(x in query, where: is_nil(x.deleted_at))
    {query, opts}
  end
end</pre>
<p>And then execute the query:</p>
<pre data-language="elixir">Repo.all(query)              # only non-deleted records are returned
Repo.all(query, admin: true) # all records are returned</pre>
<p>The callback will be invoked for all queries, including queries made from associations and preloads. It is not invoked for each individual join inside a query.</p> </section> </section> </div> </section> <section id="functions" class="details-list"> <h1 class="section-heading">  Functions </h1> <div class="functions-list"> <section class="detail"> <h3 class="detail-header" id="all_running/0">all_running()<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/repo.ex#L192" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec all_running() :: [atom() | pid()]</pre> </div> <p>Returns all running Ecto repositories.</p>
<p>The list is returned in no particular order. The list contains either atoms, for named Ecto repositories, or PIDs.</p> </section> </section> </div> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2013 Plataformatec<br>&copy; 2020 Dashbit<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/ecto/Ecto.Repo.html" class="_attribution-link">https://hexdocs.pm/ecto/Ecto.Repo.html</a>
  </p>
</div>
