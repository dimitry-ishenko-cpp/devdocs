<h1>   <span translate="no">Ecto.Adapter.Schema</span> <small>behaviour</small>  </h1> <section id="moduledoc"> <p>Specifies the schema API required from adapters.</p> </section> <section id="summary" class="details-list"> <h1 class="section-heading">  Summary </h1> <h2> Types </h2>
<dl class="summary-types summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#t:adapter_meta/0" translate="no">adapter_meta()</a> </dt> <dd class="summary-synopsis"><p>Proxy type to the adapter meta</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:constraints/0" translate="no">constraints()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:fields/0" translate="no">fields()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:filters/0" translate="no">filters()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:on_conflict/0" translate="no">on_conflict()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:options/0" translate="no">options()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:placeholders/0" translate="no">placeholders()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:returning/0" translate="no">returning()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:schema_meta/0" translate="no">schema_meta()</a> </dt> <dd class="summary-synopsis"><p>Ecto.Schema metadata fields</p></dd> </div> </dl> <h2> Callbacks </h2>
<dl class="summary-callbacks summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#c:autogenerate/1" translate="no">autogenerate(field_type)</a> </dt> <dd class="summary-synopsis"><p>Called to autogenerate a value for id/embed_id/binary_id.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:delete/4" translate="no">delete(adapter_meta, schema_meta, filters, options)</a> </dt> <dd class="summary-synopsis"><p>Deletes a single struct with the given filters.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:insert/6" translate="no">insert(adapter_meta, schema_meta, fields, on_conflict, returning, options)</a> </dt> <dd class="summary-synopsis"><p>Inserts a single new struct in the data store.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:insert_all/8" translate="no">insert_all( adapter_meta, schema_meta, header, list, on_conflict, returning, placeholders, options )</a> </dt> <dd class="summary-synopsis"><p>Inserts multiple entries into the data store.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:update/6" translate="no">update(adapter_meta, schema_meta, fields, filters, returning, options)</a> </dt> <dd class="summary-synopsis"><p>Updates a single struct with the given filters.</p></dd> </div> </dl> </section> <section id="types" class="details-list"> <h1 class="section-heading">  Types </h1> <div class="types-list"> <section class="detail"> <h3 class="detail-header" id="t:adapter_meta/0">adapter_meta()<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/adapter/schema.ex#L7" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type adapter_meta() :: Ecto.Adapter.adapter_meta()</pre> </div> <p>Proxy type to the adapter meta</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:constraints/0">constraints()<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/adapter/schema.ex#L20" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type constraints() :: Keyword.t()</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:fields/0">fields()<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/adapter/schema.ex#L18" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type fields() :: Keyword.t()</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:filters/0">filters()<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/adapter/schema.ex#L19" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type filters() :: Keyword.t()</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:on_conflict/0">on_conflict()<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/adapter/schema.ex#L25" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type on_conflict() ::
  {:raise, list(), []}
  | {:nothing, list(), [atom()]}
  | {[atom()], list(), [atom()]}
  | {Ecto.Query.t(), list(), [atom()]}</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:options/0">options()<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/adapter/schema.ex#L23" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type options() :: Keyword.t()</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:placeholders/0">placeholders()<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/adapter/schema.ex#L22" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type placeholders() :: [term()]</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:returning/0">returning()<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/adapter/schema.ex#L21" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type returning() :: [atom()]</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:schema_meta/0">schema_meta()<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/adapter/schema.ex#L10" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type schema_meta() :: %{
  autogenerate_id:
    {schema_field :: atom(), source_field :: atom(), Ecto.Type.t()},
  context: term(),
  prefix: binary() | nil,
  schema: atom(),
  source: binary()
}</pre> </div> <p>Ecto.Schema metadata fields</p> </section> </section> </div> </section> <section id="callbacks" class="details-list"> <h1 class="section-heading">  Callbacks </h1> <div class="callbacks-list"> <section class="detail"> <h3 class="detail-header" id="c:autogenerate/1">autogenerate(field_type)<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/adapter/schema.ex#L37" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback autogenerate(field_type :: :id | :binary_id | :embed_id) :: term() | nil</pre> </div> <p>Called to autogenerate a value for id/embed_id/binary_id.</p>
<p>Returns the autogenerated value, or nil if it must be autogenerated inside the storage or raise if not supported.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:delete/4">delete(adapter_meta, schema_meta, filters, options)<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/adapter/schema.ex#L90" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback delete(adapter_meta(), schema_meta(), filters(), options()) ::
  {:ok, fields()} | {:invalid, constraints()} | {:error, :stale}</pre> </div> <p>Deletes a single struct with the given filters.</p>
<p>While <code class="inline">filters</code> can be any record column, it is expected that at least the primary key (or any other key that uniquely identifies an existing record) be given as a filter. Therefore, in case there is no record matching the given filters, <code class="inline">{:error, :stale}</code> is returned.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:insert/6">insert(adapter_meta, schema_meta, fields, on_conflict, returning, options)<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/adapter/schema.ex#L66" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback insert(
  adapter_meta(),
  schema_meta(),
  fields(),
  on_conflict(),
  returning(),
  options()
) ::
  {:ok, fields()} | {:invalid, constraints()}</pre> </div> <p>Inserts a single new struct in the data store.</p>
<h4 id="c:insert/6-autogenerate" class="section-heading">  Autogenerate </h4> <p>The primary key will be automatically included in <code class="inline">returning</code> if the field has type <code class="inline">:id</code> or <code class="inline">:binary_id</code> and no value was set by the developer or none was autogenerated by the adapter.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:insert_all/8">insert_all( adapter_meta, schema_meta, header, list, on_conflict, returning, placeholders, options )<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/adapter/schema.ex#L55" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback insert_all(
  adapter_meta(),
  schema_meta(),
  header :: [atom()],
  [[{atom(), term() | {Ecto.Query.t(), list()}}]],
  on_conflict(),
  returning(),
  placeholders(),
  options()
) :: {non_neg_integer(), [[term()]] | nil}</pre> </div> <p>Inserts multiple entries into the data store.</p>
<p>In case an <a href="ecto.query.html"><code class="inline">Ecto.Query</code></a> given as any of the field values by the user, it will be sent to the adapter as a tuple with in the shape of <code class="inline">{query, params}</code>.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:update/6">update(adapter_meta, schema_meta, fields, filters, returning, options)<a href="https://github.com/elixir-ecto/ecto/blob/v3.8.4/lib/ecto/adapter/schema.ex#L78" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback update(
  adapter_meta(),
  schema_meta(),
  fields(),
  filters(),
  returning(),
  options()
) ::
  {:ok, fields()} | {:invalid, constraints()} | {:error, :stale}</pre> </div> <p>Updates a single struct with the given filters.</p>
<p>While <code class="inline">filters</code> can be any record column, it is expected that at least the primary key (or any other key that uniquely identifies an existing record) be given as a filter. Therefore, in case there is no record matching the given filters, <code class="inline">{:error, :stale}</code> is returned.</p> </section> </section> </div> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2013 Plataformatec<br>&copy; 2020 Dashbit<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/ecto/Ecto.Adapter.Schema.html" class="_attribution-link">https://hexdocs.pm/ecto/Ecto.Adapter.Schema.html</a>
  </p>
</div>
