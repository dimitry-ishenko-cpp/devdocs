<h1 id="cmd-abbr">abbr - manage fish abbreviations</h1> <section id="synopsis"> <h2>Synopsis</h2> <pre data-language="shell">abbr --add NAME [--position command | anywhere] [-r | --regex PATTERN]
                [--set-cursor[=MARKER]] ([-f | --function FUNCTION] | EXPANSION)
abbr --erase NAME ...
abbr --rename OLD_WORD NEW_WORD
abbr --show
abbr --list
abbr --query NAME ...
</pre> </section> <section id="description"> <h2>Description</h2> <p><code>abbr</code> manages abbreviations - user-defined words that are replaced with longer phrases when entered.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Only typed-in commands use abbreviations. Abbreviations are not expanded in scripts.</p> </div> <p>For example, a frequently-run command like <code>git checkout</code> can be abbreviated to <code>gco</code>. After entering <code>gco</code> and pressing <kbd class="kbd docutils literal notranslate">Space</kbd> or <kbd class="kbd docutils literal notranslate">Enter</kbd>, the full text <code>git checkout</code> will appear in the command line. To avoid expanding something that looks like an abbreviation, the default <kbd class="kbd docutils literal notranslate">Control</kbd>+<kbd class="kbd docutils literal notranslate">Space</kbd> binding inserts a space without expanding.</p> <p>An abbreviation may match a literal word, or it may match a pattern given by a regular expression. When an abbreviation matches a word, that word is replaced by new text, called its <em>expansion</em>. This expansion may be a fixed new phrase, or it can be dynamically created via a fish function. This expansion occurs after pressing space or enter.</p> <p>Combining these features, it is possible to create custom syntaxes, where a regular expression recognizes matching tokens, and the expansion function interprets them. See the <a class="reference internal" href="#examples">Examples</a> section.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.6.0: </span>Previous versions of this allowed saving abbreviations in universal variables. That’s no longer possible. Existing variables will still be imported and <code>abbr --erase</code> will also erase the variables. We recommend adding abbreviations to <a class="reference internal" href="../language.html#configuration"><span class="std std-ref">config.fish</span></a> by just adding the <code>abbr --add</code> command. When you run <code>abbr</code>, you will see output like this</p> <pre data-language="shell">&gt; abbr
abbr -a -- foo bar # imported from a universal variable, see `help abbr`
</pre> <p>In that case you should take the part before the <code>#</code> comment and save it in <a class="reference internal" href="../language.html#configuration"><span class="std std-ref">config.fish</span></a>, then you can run <code>abbr --erase</code> to remove the universal variable:</p> <pre data-language="shell">&gt; abbr &gt;&gt; ~/.config/fish/config.fish
&gt; abbr --erase (abbr --list)
</pre> </div> </section> <section id="add-subcommand"> <h2>“add” subcommand</h2> <pre data-language="shell">abbr [-a | --add] NAME [--position command | anywhere] [-r | --regex PATTERN]
     [--set-cursor[=MARKER]] ([-f | --function FUNCTION] | EXPANSION)
</pre> <p><code>abbr --add</code> creates a new abbreviation. With no other options, the string <strong>NAME</strong> is replaced by <strong>EXPANSION</strong>.</p> <p>With <strong>--position command</strong>, the abbreviation will only expand when it is positioned as a command, not as an argument to another command. With <strong>--position anywhere</strong> the abbreviation may expand anywhere in the command line. The default is <strong>command</strong>.</p> <p>With <strong>--regex</strong>, the abbreviation matches using the regular expression given by <strong>PATTERN</strong>, instead of the literal <strong>NAME</strong>. The pattern is interpreted using PCRE2 syntax and must match the entire token. If multiple abbreviations match the same token, the last abbreviation added is used.</p> <p>With <strong>--set-cursor=MARKER</strong>, the cursor is moved to the first occurrence of <strong>MARKER</strong> in the expansion. The <strong>MARKER</strong> value is erased. The <strong>MARKER</strong> may be omitted (i.e. simply <code>--set-cursor</code>), in which case it defaults to <code>%</code>.</p> <p>With <strong>-f FUNCTION</strong> or <strong>--function FUNCTION</strong>, <strong>FUNCTION</strong> is treated as the name of a fish function instead of a literal replacement. When the abbreviation matches, the function will be called with the matching token as an argument. If the function’s exit status is 0 (success), the token will be replaced by the function’s output; otherwise the token will be left unchanged. No <strong>EXPANSION</strong> may be given separately.</p> <section id="examples"> <h3>Examples</h3> <pre data-language="shell">abbr --add gco git checkout
</pre> <p>Add a new abbreviation where <code>gco</code> will be replaced with <code>git checkout</code>.</p> <pre data-language="shell">abbr -a --position anywhere -- -C --color
</pre> <p>Add a new abbreviation where <code>-C</code> will be replaced with <code>--color</code>. The <code>--</code> allows <code>-C</code> to be treated as the name of the abbreviation, instead of an option.</p> <pre data-language="shell">abbr -a L --position anywhere --set-cursor "% | less"
</pre> <p>Add a new abbreviation where <code>L</code> will be replaced with <code>| less</code>, placing the cursor before the pipe.</p> <pre data-language="shell">function last_history_item
    echo $history[1]
end
abbr -a !! --position anywhere --function last_history_item
</pre> <p>This first creates a function <code>last_history_item</code> which outputs the last entered command. It then adds an abbreviation which replaces <code>!!</code> with the result of calling this function. Taken together, this is similar to the <code>!!</code> history expansion feature of bash.</p> <pre data-language="shell">function vim_edit
    echo vim $argv
end
abbr -a vim_edit_texts --position command --regex ".+\.txt" --function vim_edit
</pre> <p>This first creates a function <code>vim_edit</code> which prepends <code>vim</code> before its argument. It then adds an abbreviation which matches commands ending in <code>.txt</code>, and replaces the command with the result of calling this function. This allows text files to be “executed” as a command to open them in vim, similar to the “suffix alias” feature in zsh.</p> <pre data-language="shell">abbr 4DIRS --set-cursor=! "$(string join \n -- 'for dir in */' 'cd $dir' '!' 'cd ..' 'end')"
</pre> <p>This creates an abbreviation “4DIRS” which expands to a multi-line loop “template.” The template enters each directory and then leaves it. The cursor is positioned ready to enter the command to run in each directory, at the location of the <code>!</code>, which is itself erased.</p> </section> </section> <section id="other-subcommands"> <h2>Other subcommands</h2> <pre data-language="shell">abbr --rename OLD_NAME NEW_NAME
</pre> <p>Renames an abbreviation, from <em>OLD_NAME</em> to <em>NEW_NAME</em></p> <pre data-language="shell">abbr [-s | --show]
</pre> <p>Show all abbreviations in a manner suitable for import and export</p> <pre data-language="shell">abbr [-l | --list]
</pre> <p>Prints the names of all abbreviation</p> <pre data-language="shell">abbr [-e | --erase] NAME
</pre> <p>Erases the abbreviation with the given name</p> <pre data-language="shell">abbr -q or --query [NAME...]
</pre> <p>Return 0 (true) if one of the <em>NAME</em> is an abbreviation.</p> <pre data-language="shell">abbr -h or --help
</pre> <p>Displays help for the <code>abbr</code> command.</p> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005-2009 Axel Liljencrantz, 2009-2023 fish-shell contributors<br>Licensed under the GNU General Public License, version 2.<br>
    <a href="https://fishshell.com/docs/3.7/cmds/abbr.html" class="_attribution-link">https://fishshell.com/docs/3.7/cmds/abbr.html</a>
  </p>
</div>
