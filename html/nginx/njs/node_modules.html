<h1>Using node modules with njs</h1>
<ul>
<li><a href="#environment">Environment</a></li>
<li><a href="#protobuf">Protobufjs</a></li>
<li><a href="#dnspacket">DNS-packet</a></li>
</ul>
<p id="intro"> Often, a developer wants to use 3rd-party code, usually available as a library of some kind. In the JavaScript world, the concept of a module is relatively new, so there was no standard until recently. Many platforms (browsers) still don't support modules, which makes code reuse harder. This article describes ways to reuse <a href="https://nodejs.org/">Node.js</a> code in njs. </p>
<blockquote class="note"> Examples in this article use features that appeared in <a href="index.html">njs</a> <a href="changes.html#njs0.3.8">0.3.8</a> </blockquote>
<p> There is a number of issues that may arise when 3rd-party code is added to njs: </p> <ul class="compact"> <li> Multiple files that reference each other and their dependencies </li> <li> Platform-specific APIs </li> <li> Modern standard language constructions </li> </ul>

<p> The good news is that such problems are not something new or specific to njs. JavaScript developers face them daily when trying to support multiple disparate platforms with very different properties. There are instruments designed to resolve the above-mentioned issues. </p> <ul class="compact"> <li> Multiple files that reference each other, and their dependencies <p> This can be solved by merging all the interdependent code into a single file. Tools like <a href="http://browserify.org/">browserify</a> or <a href="https://webpack.js.org/">webpack</a> accept an entire project and produce a single file containing your code and all the dependencies. </p> </li> <li> Platform-specific APIs <p> You can use multiple libraries that implement such APIs in a platform-agnostic manner (at the expense of performance, though). Particular features can also be implemented using the <a href="https://polyfill.io/v3/">polyfill</a> approach. </p> </li> <li> Modern standard language constructions <p> Such code can be transpiled: this means performing a number of transformations that rewrite newer language features in accordance with an older standard. For example, <a href="https://babeljs.io/"> babel</a> project can be used to this purpose. </p> </li> </ul>

<p> In this guide, we will use two relatively large npm-hosted libraries: </p> <ul class="compact"> <li> <a href="https://www.npmjs.com/package/protobufjs">protobufjs</a> — a library for creating and parsing protobuf messages used by the <a href="https://grpc.io/">gRPC</a> protocol </li> <li> <a href="https://www.npmjs.com/package/dns-packet">dns-packet</a> — a library for processing DNS protocol packets </li> </ul>

<h4 id="environment">Environment</h4>
 <blockquote class="note"> This document mostly employs a generic approach and avoids specific best practice advices concerning Node.js and JavaScript. Make sure to consult the corresponding package's manual before following the steps suggested here. </blockquote>
<p> First (assuming Node.js is installed and operational), let's create an empty project and install some dependencies; the commands below assume we are in the working directory: </p> <pre data-language="nginx">
$ mkdir my_project &amp;&amp; cd my_project
$ npx license choose_your_license_here &gt; LICENSE
$ npx gitignore node

$ cat &gt; package.json &lt;&lt;EOF
{
  "name":        "foobar",
  "version":     "0.0.1",
  "description": "",
  "main":        "index.js",
  "keywords":    [],
  "author":      "somename &lt;some.email@example.com&gt; (https://example.com)",
  "license":     "some_license_here",
  "private":     true,
  "scripts": {
    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"
  }
}
EOF
$ npm init -y
$ npm install browserify
</pre>

<h4 id="protobuf">Protobufjs</h4>
<p> The library provides a parser for the <code>.proto</code> interface definitions and a code generator for message parsing and generation. </p>
<p> In this example, we will use the <a href="https://github.com/grpc/grpc/blob/master/examples/protos/helloworld.proto">helloworld.proto</a> file from the gRPC examples. Our goal is to create two messages: <code>HelloRequest</code> and <code>HelloResponse</code>. We will use the <a href="https://github.com/protobufjs/protobuf.js/blob/master/README.md#reflection-vs-static-code">static</a> mode of protobufjs instead of dynamically generating classes, because njs doesn't support adding new functions dynamically due to security considerations. </p>
<p> Next, the library is installed and the JavaScript code implementing message marshalling is generated from the protocol definition: </p> <pre data-language="nginx">
$ npm install protobufjs
$ npx pbjs -t static-module helloworld.proto &gt; static.js
</pre>

<p> Thus, the <code>static.js</code> file becomes our new dependency, storing all the code we need to implement message processing. The <code>set_buffer()</code> function contains code that uses the library to create a buffer with the serialized <code>HelloRequest</code> message. The code resides in the <code>code.js</code> file: </p> <pre data-language="nginx">
var pb = require('./static.js');

// Example usage of protobuf library: prepare a buffer to send
function set_buffer(pb)
{
    // set fields of gRPC payload
    var payload = { name: "TestString" };

    // create an object
    var message = pb.helloworld.HelloRequest.create(payload);

    // serialize object to buffer
    var buffer = pb.helloworld.HelloRequest.encode(message).finish();

    var n = buffer.length;

    var frame = new Uint8Array(5 + buffer.length);

    frame[0] = 0;                        // 'compressed' flag
    frame[1] = (n &amp; 0xFF000000) &gt;&gt;&gt; 24;  // length: uint32 in network byte order
    frame[2] = (n &amp; 0x00FF0000) &gt;&gt;&gt; 16;
    frame[3] = (n &amp; 0x0000FF00) &gt;&gt;&gt;  8;
    frame[4] = (n &amp; 0x000000FF) &gt;&gt;&gt;  0;

    frame.set(buffer, 5);

    return frame;
}

var frame = set_buffer(pb);
</pre>

<p> To ensure it works, we execute the code using node: </p> <pre data-language="nginx">
$ node ./code.js
Uint8Array [
    0,   0,   0,   0,  12, 10,
   10,  84, 101, 115, 116, 83,
  116, 114, 105, 110, 103
]
</pre>
<p> You can see that this got us a properly encoded <code>gRPC</code> frame. Now let's run it with njs: </p> <pre data-language="nginx">
$ njs ./code.js
Thrown:
Error: Cannot find module "./static.js"
    at require (native)
    at main (native)
</pre>

<p> Modules are not supported, so we've received an exception. To overcome this issue, let's use <code>browserify</code> or other similar tool. </p>
<p> An attempt to process our existing <code>code.js</code> file will result in a bunch of JS code that is supposed to run in a browser, i.e. immediately upon loading. This isn't something we actually want. Instead, we want to have an exported function that can be referenced from the nginx configuration. This requires some wrapper code. </p> <blockquote class="note"> In this guide, we use njs <a href="cli.html">cli</a> in all examples for the sake of simplicity. In real life, you will be using nginx njs module to run your code. </blockquote>

<p> The <code>load.js</code> file contains the library-loading code that stores its handle in the global namespace: </p> <pre data-language="nginx">
global.hello = require('./static.js');
</pre>
<p> This code will be replaced with merged content. Our code will be using the "<code>global.hello</code>" handle to access the library. </p>
<p> Next, we process it with <code>browserify</code> to get all dependencies into a single file: </p> <pre data-language="nginx">
$ npx browserify load.js -o bundle.js -d
</pre>
<p> The result is a huge file that contains all our dependencies: </p> <pre data-language="nginx">
(function(){function......
...
...
},{"protobufjs/minimal":9}]},{},[1])
//# sourceMappingURL..............
</pre>
<p> To get final "<code>njs_bundle.js</code>" file we concatenate "<code>bundle.js</code>" and the following code: </p> <pre data-language="nginx">
// Example usage of protobuf library: prepare a buffer to send
function set_buffer(pb)
{
    // set fields of gRPC payload
    var payload = { name: "TestString" };

    // create an object
    var message = pb.helloworld.HelloRequest.create(payload);

    // serialize object to buffer
    var buffer = pb.helloworld.HelloRequest.encode(message).finish();

    var n = buffer.length;

    var frame = new Uint8Array(5 + buffer.length);

    frame[0] = 0;                        // 'compressed' flag
    frame[1] = (n &amp; 0xFF000000) &gt;&gt;&gt; 24;  // length: uint32 in network byte order
    frame[2] = (n &amp; 0x00FF0000) &gt;&gt;&gt; 16;
    frame[3] = (n &amp; 0x0000FF00) &gt;&gt;&gt;  8;
    frame[4] = (n &amp; 0x000000FF) &gt;&gt;&gt;  0;

    frame.set(buffer, 5);

    return frame;
}

// functions to be called from outside
function setbuf()
{
    return set_buffer(global.hello);
}

// call the code
var frame = setbuf();
console.log(frame);
</pre>
<p> Let's run the file using node to make sure things still work: </p> <pre data-language="nginx">
$ node ./njs_bundle.js
Uint8Array [
    0,   0,   0,   0,  12, 10,
   10,  84, 101, 115, 116, 83,
  116, 114, 105, 110, 103
]
</pre>
<p> Now let's proceed further with njs: </p> <pre data-language="nginx">
$ njs ./njs_bundle.js
Uint8Array [0,0,0,0,12,10,10,84,101,115,116,83,116,114,105,110,103]
</pre>
<p> The last thing will be to use njs-specific API to convert array into byte string, so it could be usable by nginx module. We can add the following snippet before the line <code>return frame; }</code>: </p> <pre data-language="nginx">
if (global.njs) {
    return String.bytesFrom(frame)
}
</pre>
<p> Finally, we got it working: </p> <pre data-language="nginx">
$ njs ./njs_bundle.js |hexdump -C
00000000  00 00 00 00 0c 0a 0a 54  65 73 74 53 74 72 69 6e  |.......TestStrin|
00000010  67 0a                                             |g.|
00000012
</pre>
<p> This is the intended result. Response parsing can be implemented similarly: </p> <pre data-language="nginx">
function parse_msg(pb, msg)
{
    // convert byte string into integer array
    var bytes = msg.split('').map(v=&gt;v.charCodeAt(0));

    if (bytes.length &lt; 5) {
        throw 'message too short';
    }

    // first 5 bytes is gRPC frame (compression + length)
    var head = bytes.splice(0, 5);

    // ensure we have proper message length
    var len = (head[1] &lt;&lt; 24)
              + (head[2] &lt;&lt; 16)
              + (head[3] &lt;&lt; 8)
              + head[4];

    if (len != bytes.length) {
        throw 'header length mismatch';
    }

    // invoke protobufjs to decode message
    var response = pb.helloworld.HelloReply.decode(bytes);

    console.log('Reply is:' + response.message);
}
</pre>

<h4 id="dnspacket">DNS-packet</h4>
<p> This example uses a library for generation and parsing of DNS packets. This a case worth considering because the library and its dependencies use modern language constructions not yet supported by njs. In turn, this requires from us an extra step: transpiling the source code. </p>
<p> Additional node packages are needed: </p> <pre data-language="nginx">
$ npm install @babel/core @babel/cli @babel/preset-env babel-loader
$ npm install webpack webpack-cli
$ npm install buffer
$ npm install dns-packet
</pre>
<p> The configuration file, webpack.config.js: </p> <pre data-language="nginx">
const path = require('path');

module.exports = {
    entry: './load.js',
    mode: 'production',
    output: {
        filename: 'wp_out.js',
        path: path.resolve(__dirname, 'dist'),
    },
    optimization: {
        minimize: false
    },
    node: {
        global: true,
    },
    module : {
        rules: [{
            test: /\.m?js$$/,
            exclude: /(bower_components)/,
            use: {
                loader: 'babel-loader',
                options: {
                    presets: ['@babel/preset-env']
                }
            }
        }]
    }
};
</pre>
<p> Note we are using "<code>production</code>" mode. In this mode webpack does not use "<code>eval</code>" construction not supported by njs. The referenced <code>load.js</code> file is our entry point: </p> <pre data-language="nginx">
global.dns = require('dns-packet')
global.Buffer = require('buffer/').Buffer
</pre>
<p> We start the same way, by producing a single file for the libraries: </p> <pre data-language="nginx">
$ npx browserify load.js -o bundle.js -d
</pre>
<p> Next, we process the file with webpack, which itself invokes babel: </p> <pre data-language="nginx">
$ npx webpack --config webpack.config.js
</pre>
<p> This command produces the <code>dist/wp_out.js</code> file, which is a transpiled version of <code>bundle.js</code>. We need to concatenate it with <code>code.js</code> that stores our code: </p> <pre data-language="nginx">
function set_buffer(dnsPacket)
{
    // create DNS packet bytes
    var buf = dnsPacket.encode({
        type: 'query',
        id: 1,
        flags: dnsPacket.RECURSION_DESIRED,
        questions: [{
            type: 'A',
            name: 'google.com'
        }]
    })

    return buf;
}
</pre>
<p> Note that in this example generated code is not wrapped into function and we do not need to call it explicitly. The result is in the "<code>dist</code>" directory: </p> <pre data-language="nginx">
$ cat dist/wp_out.js code.js &gt; njs_dns_bundle.js
</pre>
<p> Let's call our code at the end of a file: </p> <pre data-language="nginx">
var b = set_buffer(global.dns);
console.log(b);
</pre>
<p> And execute it using node: </p> <pre data-language="nginx">
$ node ./njs_dns_bundle_final.js
Buffer [Uint8Array] [
    0,   1,   1, 0,  0,   1,   0,   0,
    0,   0,   0, 0,  6, 103, 111, 111,
  103, 108, 101, 3, 99, 111, 109,   0,
    0,   1,   0, 1
]
</pre>
<p> Make sure this works as expected, and then run it with njs: </p> <pre data-language="nginx">
$ njs ./njs_dns_bundle_final.js
Uint8Array [0,1,1,0,0,1,0,0,0,0,0,0,6,103,111,111,103,108,101,3,99,111,109,0,0,1,0,1]
</pre>

<p> The response can be parsed as follows: </p> <pre data-language="nginx">
function parse_response(buf)
{
    var bytes = buf.split('').map(v=&gt;v.charCodeAt(0));

    var b = global.Buffer.from(bytes);

    var packet = dnsPacket.decode(b);

    var resolved_name = packet.answers[0].name;

    // expected name is 'google.com', according to our request above
}
</pre>
<div class="_attribution">
  <p class="_attribution-p">
    &copy; 2002-2021 Igor Sysoev<br>&copy; 2011-2023 Nginx, Inc.<br>Licensed under the BSD License.<br>
    <a href="https://nginx.org/en/docs/njs/node_modules.html" class="_attribution-link">https://nginx.org/en/docs/njs/node_modules.html</a>
  </p>
</div>
