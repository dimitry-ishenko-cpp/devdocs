<h1>Object Future.Future</h1>
<div class="links">
<a href="future.html">Companion class</a> â€¢ <a href="https://github.com/scala/scala/blob/v2.13.8/src/library/scala/concurrent/Future.scala#L520">Source code</a>
</div>
<h2 id="signature">
<div class="signature">
object <a href="future%24.html">Future</a>
</div>
</h2>
<p>Future companion object.</p>
<table class="attributes">
<tr>
<th>Supertypes</th>
<td><div class="related-types">
<div class="member">class <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html">Object</a>
</div>
<div class="member">trait <a href="../matchable.html">Matchable</a>
</div>
<div class="member">class <a href="../any.html">Any</a>
</div>
</div></td>
</tr>
<tr>
<th>Self type</th>
<td><div class="related-types"><div class="member">
<a href="future%24.html">Future</a>.type</div></div></td>
</tr>
</table>
<h2>Classlikes</h2>
<h3>
<a href="https://github.com/scala/scala/blob/v2.13.8/src/library/scala/concurrent/Future.scala#L572" class="source-link">Source</a><div class="signature">
object <a href="future%24%24never%24.html">never</a> extends <a href="future.html">Future</a>[<a href="../nothing.html">Nothing</a>]
</div>
</h3>



<p>A Future which is never completed. </p>



<h2>Concrete methods</h2>
<h3 id="apply-18b">
<a href="https://github.com/scala/scala/blob/v2.13.8/src/library/scala/concurrent/Future.scala#L677" class="source-link">Source</a><div class="signature">
final def <a href="future%24.html#apply-18b">apply</a>[T](body: =&gt; T)(implicit executor: <a href="executioncontext.html">ExecutionContext</a>): <a href="future.html">Future</a>[T]
</div>
</h3>




<p>Starts an asynchronous computation and returns a <code>Future</code> instance with the result of that computation.</p>
<p>The following expressions are equivalent:</p>
<pre data-language="scala">val f1 = Future(expr)
val f2 = Future.unit.map(_ =&gt; expr)
val f3 = Future.unit.transform(_ =&gt; Success(expr))</pre>
<p>The result becomes available once the asynchronous computation is completed. </p>

<table class="attributes">
<tr>
<th>Type parameters</th>
<td><dl class="attributes">
<dt>T</dt>
<dd><p>the type of the result</p></dd>
</dl></td>
</tr>
<tr>
<th>Value parameters</th>
<td><dl class="attributes">
<dt>body</dt>
<dd><p>the asynchronous computation</p></dd>
<dt>executor</dt>
<dd><p>the execution context on which the future is run</p></dd>
</dl></td>
</tr>
<tr>
<th>Returns</th>
<td><p>the <code>Future</code> holding the result of the computation</p></td>
</tr>
</table>


<h3 id="delegate-18b">
<a href="https://github.com/scala/scala/blob/v2.13.8/src/library/scala/concurrent/Future.scala#L697" class="source-link">Source</a><div class="signature">
final def <a href="future%24.html#delegate-18b">delegate</a>[T](body: =&gt; <a href="future.html">Future</a>[T])(implicit executor: <a href="executioncontext.html">ExecutionContext</a>): <a href="future.html">Future</a>[T]
</div>
</h3>




<p>Starts an asynchronous computation and returns a <code>Future</code> instance with the result of that computation once it completes.</p>
<p>The following expressions are semantically equivalent:</p>
<pre data-language="scala">val f1 = Future(expr).flatten
val f2 = Future.delegate(expr)
val f3 = Future.unit.flatMap(_ =&gt; expr)</pre>
<p>The result becomes available once the resulting Future of the asynchronous computation is completed. </p>

<table class="attributes">
<tr>
<th>Type parameters</th>
<td><dl class="attributes">
<dt>T</dt>
<dd><p>the type of the result</p></dd>
</dl></td>
</tr>
<tr>
<th>Value parameters</th>
<td><dl class="attributes">
<dt>body</dt>
<dd><p>the asynchronous computation, returning a Future</p></dd>
<dt>executor</dt>
<dd><p>the execution context on which the <code>body</code> is evaluated in</p></dd>
</dl></td>
</tr>
<tr>
<th>Returns</th>
<td><p>the <code>Future</code> holding the result of the computation</p></td>
</tr>
</table>


<h3 id="failed-fffffa57">
<a href="https://github.com/scala/scala/blob/v2.13.8/src/library/scala/concurrent/Future.scala#L642" class="source-link">Source</a><div class="signature">
final def <a href="future%24.html#failed-fffffa57">failed</a>[T](exception: <a href="../../scala.html#Throwable-0">Throwable</a>): <a href="future.html">Future</a>[T]
</div>
</h3>



<p>Creates an already completed Future with the specified exception. </p>
<table class="attributes">
<tr>
<th>Type parameters</th>
<td><dl class="attributes">
<dt>T</dt>
<dd><p>the type of the value in the future</p></dd>
</dl></td>
</tr>
<tr>
<th>Value parameters</th>
<td><dl class="attributes">
<dt>exception</dt>
<dd><p>the non-null instance of <code>Throwable</code></p></dd>
</dl></td>
</tr>
<tr>
<th>Returns</th>
<td><p>the newly created <code>Future</code> instance</p></td>
</tr>
</table>


<h3 id="find-fffff9e8">
<a href="https://github.com/scala/scala/blob/v2.13.8/src/library/scala/concurrent/Future.scala#L747" class="source-link">Source</a><div class="signature">
final def <a href="future%24.html#find-fffff9e8">find</a>[T](futures: <a href="../collection/immutable/iterable.html">Iterable</a>[<a href="future.html">Future</a>[T]])(p: T =&gt; <a href="../boolean.html">Boolean</a>)(implicit executor: <a href="executioncontext.html">ExecutionContext</a>): <a href="future.html">Future</a>[<a href="../option.html">Option</a>[T]]
</div>
</h3>



<p>Asynchronously and non-blockingly returns a <code>Future</code> that will hold the optional result of the first <code>Future</code> with a result that matches the predicate, failed <code>Future</code>s will be ignored. </p>
<table class="attributes">
<tr>
<th>Type parameters</th>
<td><dl class="attributes">
<dt>T</dt>
<dd><p>the type of the value in the future</p></dd>
</dl></td>
</tr>
<tr>
<th>Value parameters</th>
<td><dl class="attributes">
<dt>futures</dt>
<dd><p>the <code>scala.collection.immutable.Iterable</code> of Futures to search</p></dd>
<dt>p</dt>
<dd><p>the predicate which indicates if it's a match</p></dd>
</dl></td>
</tr>
<tr>
<th>Returns</th>
<td><p>the <code>Future</code> holding the optional result of the search</p></td>
</tr>
</table>


<h3 id="firstCompletedOf-496">
<a href="https://github.com/scala/scala/blob/v2.13.8/src/library/scala/concurrent/Future.scala#L721" class="source-link">Source</a><div class="signature">
final def <a href="future%24.html#firstCompletedOf-496">firstCompletedOf</a>[T](futures: <a href="../collection/iterableonce.html">IterableOnce</a>[<a href="future.html">Future</a>[T]])(implicit executor: <a href="executioncontext.html">ExecutionContext</a>): <a href="future.html">Future</a>[T]
</div>
</h3>



<p>Asynchronously and non-blockingly returns a new <code>Future</code> to the result of the first future in the list that is completed. This means no matter if it is completed as a success or as a failure. </p>
<table class="attributes">
<tr>
<th>Type parameters</th>
<td><dl class="attributes">
<dt>T</dt>
<dd><p>the type of the value in the future</p></dd>
</dl></td>
</tr>
<tr>
<th>Value parameters</th>
<td><dl class="attributes">
<dt>futures</dt>
<dd><p>the <code>IterableOnce</code> of Futures in which to find the first completed</p></dd>
</dl></td>
</tr>
<tr>
<th>Returns</th>
<td><p>the <code>Future</code> holding the result of the future that is first to be completed</p></td>
</tr>
</table>


<h3 id="foldLeft-4b7">
<a href="https://github.com/scala/scala/blob/v2.13.8/src/library/scala/concurrent/Future.scala#L776" class="source-link">Source</a><div class="signature">
final def <a href="future%24.html#foldLeft-4b7">foldLeft</a>[T, R](futures: <a href="../collection/immutable/iterable.html">Iterable</a>[<a href="future.html">Future</a>[T]])(zero: R)(op: (R, T) =&gt; R)(implicit executor: <a href="executioncontext.html">ExecutionContext</a>): <a href="future.html">Future</a>[R]
</div>
</h3>




<p>A non-blocking, asynchronous left fold over the specified futures, with the start value of the given zero. The fold is performed asynchronously in left-to-right order as the futures become completed. The result will be the first failure of any of the futures, or any failure in the actual fold, or the result of the fold.</p>
<p>Example:</p>
<pre data-language="scala">val futureSum = Future.foldLeft(futures)(0)(_ + _)</pre>

<table class="attributes">
<tr>
<th>Type parameters</th>
<td><dl class="attributes">
<dt>R</dt>
<dd><p>the type of the value of the returned <code>Future</code></p></dd>
<dt>T</dt>
<dd><p>the type of the value of the input Futures</p></dd>
</dl></td>
</tr>
<tr>
<th>Value parameters</th>
<td><dl class="attributes">
<dt>futures</dt>
<dd><p>the <code>scala.collection.immutable.Iterable</code> of Futures to be folded</p></dd>
<dt>op</dt>
<dd><p>the fold operation to be applied to the zero and futures</p></dd>
<dt>zero</dt>
<dd><p>the start value of the fold</p></dd>
</dl></td>
</tr>
<tr>
<th>Returns</th>
<td><p>the <code>Future</code> holding the result of the fold</p></td>
</tr>
</table>


<h3 id="fromTry-fffff28a">
<a href="https://github.com/scala/scala/blob/v2.13.8/src/library/scala/concurrent/Future.scala#L658" class="source-link">Source</a><div class="signature">
final def <a href="future%24.html#fromTry-fffff28a">fromTry</a>[T](result: <a href="../util/try.html">Try</a>[T]): <a href="future.html">Future</a>[T]
</div>
</h3>



<p>Creates an already completed Future with the specified result or exception. </p>
<table class="attributes">
<tr>
<th>Type parameters</th>
<td><dl class="attributes">
<dt>T</dt>
<dd><p>the type of the value in the <code>Future</code></p></dd>
</dl></td>
</tr>
<tr>
<th>Value parameters</th>
<td><dl class="attributes">
<dt>result</dt>
<dd><p>the result of the returned <code>Future</code> instance</p></dd>
</dl></td>
</tr>
<tr>
<th>Returns</th>
<td><p>the newly created <code>Future</code> instance</p></td>
</tr>
</table>


<h3 id="reduceLeft-9aa">
<a href="https://github.com/scala/scala/blob/v2.13.8/src/library/scala/concurrent/Future.scala#L838" class="source-link">Source</a><div class="signature">
final def <a href="future%24.html#reduceLeft-9aa">reduceLeft</a>[T, R &gt;: T](futures: <a href="../collection/immutable/iterable.html">Iterable</a>[<a href="future.html">Future</a>[T]])(op: (R, T) =&gt; R)(implicit executor: <a href="executioncontext.html">ExecutionContext</a>): <a href="future.html">Future</a>[R]
</div>
</h3>




<p>Initiates a non-blocking, asynchronous, left reduction over the supplied futures where the zero is the result value of the first <code>Future</code>.</p>
<p>Example:</p>
<pre data-language="scala">val futureSum = Future.reduceLeft(futures)(_ + _)</pre>

<table class="attributes">
<tr>
<th>Type parameters</th>
<td><dl class="attributes">
<dt>R</dt>
<dd><p>the type of the value of the returned <code>Future</code></p></dd>
<dt>T</dt>
<dd><p>the type of the value of the input Futures</p></dd>
</dl></td>
</tr>
<tr>
<th>Value parameters</th>
<td><dl class="attributes">
<dt>futures</dt>
<dd><p>the <code>scala.collection.immutable.Iterable</code> of Futures to be reduced</p></dd>
<dt>op</dt>
<dd><p>the reduce operation which is applied to the results of the futures</p></dd>
</dl></td>
</tr>
<tr>
<th>Returns</th>
<td><p>the <code>Future</code> holding the result of the reduce</p></td>
</tr>
</table>


<h3 id="sequence-fffffb44">
<a href="https://github.com/scala/scala/blob/v2.13.8/src/library/scala/concurrent/Future.scala#L709" class="source-link">Source</a><div class="signature">
final def <a href="future%24.html#sequence-fffffb44">sequence</a>[A, CC &lt;: (<a href="../collection/iterableonce.html">IterableOnce</a>), To](in: CC[<a href="future.html">Future</a>[A]])(implicit bf: <a href="../collection/buildfrom.html">BuildFrom</a>[CC[<a href="future.html">Future</a>[A]], A, To], executor: <a href="executioncontext.html">ExecutionContext</a>): <a href="future.html">Future</a>[To]
</div>
</h3>



<p>Simple version of <code>Future.traverse</code>. Asynchronously and non-blockingly transforms, in essence, a <code>IterableOnce[Future[A]]</code> into a <code>Future[IterableOnce[A]]</code>. Useful for reducing many <code>Future</code>s into a single <code>Future</code>. </p>
<table class="attributes">
<tr>
<th>Type parameters</th>
<td><dl class="attributes">
<dt>A</dt>
<dd><p>the type of the value inside the Futures</p></dd>
<dt>CC</dt>
<dd><p>the type of the <code>IterableOnce</code> of Futures</p></dd>
<dt>To</dt>
<dd><p>the type of the resulting collection</p></dd>
</dl></td>
</tr>
<tr>
<th>Value parameters</th>
<td><dl class="attributes">
<dt>in</dt>
<dd><p>the <code>IterableOnce</code> of Futures which will be sequenced</p></dd>
</dl></td>
</tr>
<tr>
<th>Returns</th>
<td><p>the <code>Future</code> of the resulting collection</p></td>
</tr>
</table>


<h3 id="successful-ffffff0e">
<a href="https://github.com/scala/scala/blob/v2.13.8/src/library/scala/concurrent/Future.scala#L650" class="source-link">Source</a><div class="signature">
final def <a href="future%24.html#successful-ffffff0e">successful</a>[T](result: T): <a href="future.html">Future</a>[T]
</div>
</h3>



<p>Creates an already completed Future with the specified result. </p>
<table class="attributes">
<tr>
<th>Type parameters</th>
<td><dl class="attributes">
<dt>T</dt>
<dd><p>the type of the value in the future</p></dd>
</dl></td>
</tr>
<tr>
<th>Value parameters</th>
<td><dl class="attributes">
<dt>result</dt>
<dd><p>the given successful value</p></dd>
</dl></td>
</tr>
<tr>
<th>Returns</th>
<td><p>the newly created <code>Future</code> instance</p></td>
</tr>
</table>


<h3 id="traverse-fffff185">
<a href="https://github.com/scala/scala/blob/v2.13.8/src/library/scala/concurrent/Future.scala#L859" class="source-link">Source</a><div class="signature">
final def <a href="future%24.html#traverse-fffff185">traverse</a>[A, B, M &lt;: (<a href="../collection/iterableonce.html">IterableOnce</a>)](in: M[A])(fn: A =&gt; <a href="future.html">Future</a>[B])(implicit bf: <a href="../collection/buildfrom.html">BuildFrom</a>[M[A], B, M[B]], executor: <a href="executioncontext.html">ExecutionContext</a>): <a href="future.html">Future</a>[M[B]]
</div>
</h3>




<p>Asynchronously and non-blockingly transforms a <code>IterableOnce[A]</code> into a <code>Future[IterableOnce[B]]</code> using the provided function <code>A =&gt; Future[B]</code>. This is useful for performing a parallel map. For example, to apply a function to all items of a list in parallel:</p>
<pre data-language="scala">val myFutureList = Future.traverse(myList)(x =&gt; Future(myFunc(x)))</pre>

<table class="attributes">
<tr>
<th>Type parameters</th>
<td><dl class="attributes">
<dt>A</dt>
<dd><p>the type of the value inside the Futures in the collection</p></dd>
<dt>B</dt>
<dd><p>the type of the value of the returned <code>Future</code></p></dd>
<dt>M</dt>
<dd><p>the type of the collection of Futures</p></dd>
</dl></td>
</tr>
<tr>
<th>Value parameters</th>
<td><dl class="attributes">
<dt>fn</dt>
<dd><p>the function to be mapped over the collection to produce a collection of Futures</p></dd>
<dt>in</dt>
<dd><p>the collection to be mapped over with the provided function to produce a collection of Futures that is then sequenced into a Future collection</p></dd>
</dl></td>
</tr>
<tr>
<th>Returns</th>
<td><p>the <code>Future</code> of the collection of results</p></td>
</tr>
</table>


<h2>Concrete fields</h2>
<h3 id="unit-0">
<a href="https://github.com/scala/scala/blob/v2.13.8/src/library/scala/concurrent/Future.scala#L634" class="source-link">Source</a><div class="signature">
final val <a href="future%24.html#unit-0">unit</a>: <a href="future.html">Future</a>[<a href="../unit.html">Unit</a>]
</div>
</h3>



<p>A Future which is completed with the Unit value. </p>
<div class="_attribution">
  <p class="_attribution-p">
    &copy; 2002-2022 EPFL, with contributions from Lightbend.<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://scala-lang.org/api/3.2.0/scala/concurrent/Future$.html" class="_attribution-link">https://scala-lang.org/api/3.2.0/scala/concurrent/Future$.html</a>
  </p>
</div>
