<h1>Post-installation steps for Linux</h1>

<p>This section contains optional procedures for configuring Linux hosts to work better with Docker.</p> <h2 id="manage-docker-as-a-non-root-user">Manage Docker as a non-root user</h2> <p>The Docker daemon binds to a Unix socket instead of a TCP port. By default that Unix socket is owned by the user <code class="language-plaintext highlighter-rouge">root</code> and other users can only access it using <code class="language-plaintext highlighter-rouge">sudo</code>. The Docker daemon always runs as the <code class="language-plaintext highlighter-rouge">root</code> user.</p> <p>If you don’t want to preface the <code class="language-plaintext highlighter-rouge">docker</code> command with <code class="language-plaintext highlighter-rouge">sudo</code>, create a Unix group called <code class="language-plaintext highlighter-rouge">docker</code> and add users to it. When the Docker daemon starts, it creates a Unix socket accessible by members of the <code class="language-plaintext highlighter-rouge">docker</code> group.</p> <blockquote class="warning"> <p>Warning</p> <p>The <code class="language-plaintext highlighter-rouge">docker</code> group grants privileges equivalent to the <code class="language-plaintext highlighter-rouge">root</code> user. For details on how this impacts security in your system, see <a href="../../security/index.html#docker-daemon-attack-surface"><em>Docker Daemon Attack Surface</em></a>.</p> </blockquote> <blockquote> <p><strong>Note</strong>:</p> <p>To run Docker without root privileges, see <a href="../../security/rootless/index.html">Run the Docker daemon as a non-root user (Rootless mode)</a>.</p> </blockquote> <p>To create the <code class="language-plaintext highlighter-rouge">docker</code> group and add your user:</p> <ol> <li> <p>Create the <code class="language-plaintext highlighter-rouge">docker</code> group.</p> <div class="highlight"><pre class="highlight" data-language="">$ sudo groupadd docker
</pre></div>  </li> <li> <p>Add your user to the <code class="language-plaintext highlighter-rouge">docker</code> group.</p> <div class="highlight"><pre class="highlight" data-language="">$ sudo usermod -aG docker $USER
</pre></div>  </li> <li> <p>Log out and log back in so that your group membership is re-evaluated.</p> <p>If testing on a virtual machine, it may be necessary to restart the virtual machine for changes to take effect.</p> <p>On a desktop Linux environment such as X Windows, log out of your session completely and then log back in.</p> <p>On Linux, you can also run the following command to activate the changes to groups:</p> <div class="highlight"><pre class="highlight" data-language="">$ newgrp docker 
</pre></div>  </li> <li> <p>Verify that you can run <code class="language-plaintext highlighter-rouge">docker</code> commands without <code class="language-plaintext highlighter-rouge">sudo</code>.</p> <div class="highlight"><pre class="highlight" data-language="">$ docker run hello-world
</pre></div>  <p>This command downloads a test image and runs it in a container. When the container runs, it prints a message and exits.</p> <p>If you initially ran Docker CLI commands using <code class="language-plaintext highlighter-rouge">sudo</code> before adding your user to the <code class="language-plaintext highlighter-rouge">docker</code> group, you may see the following error, which indicates that your <code class="language-plaintext highlighter-rouge">~/.docker/</code> directory was created with incorrect permissions due to the <code class="language-plaintext highlighter-rouge">sudo</code> commands.</p> <pre>WARNING: Error loading config file: /home/user/.docker/config.json -
stat /home/user/.docker/config.json: permission denied
</pre> <p>To fix this problem, either remove the <code class="language-plaintext highlighter-rouge">~/.docker/</code> directory (it is recreated automatically, but any custom settings are lost), or change its ownership and permissions using the following commands:</p> <div class="highlight"><pre class="highlight" data-language="">$ sudo chown "$USER":"$USER" /home/"$USER"/.docker -R
$ sudo chmod g+rwx "$HOME/.docker" -R
</pre></div>  </li> </ol> <h2 id="configure-docker-to-start-on-boot">Configure Docker to start on boot</h2> <p>Most current Linux distributions (RHEL, CentOS, Fedora, Debian, Ubuntu 16.04 and higher) use <a href="https://docs.docker.com/config/daemon/systemd/"><code class="language-plaintext highlighter-rouge">systemd</code></a> to manage which services start when the system boots. On Debian and Ubuntu, the Docker service is configured to start on boot by default. To automatically start Docker and Containerd on boot for other distros, use the commands below:</p> <div class="highlight"><pre class="highlight" data-language="">$ sudo systemctl enable docker.service
$ sudo systemctl enable containerd.service
</pre></div> <p>To disable this behavior, use <code class="language-plaintext highlighter-rouge">disable</code> instead.</p> <div class="highlight"><pre class="highlight" data-language="">$ sudo systemctl disable docker.service
$ sudo systemctl disable containerd.service
</pre></div> <p>If you need to add an HTTP Proxy, set a different directory or partition for the Docker runtime files, or make other customizations, see <a href="https://docs.docker.com/config/daemon/systemd/">customize your systemd Docker daemon options</a>.</p> <h2 id="use-a-different-storage-engine">Use a different storage engine</h2> <p>For information about the different storage engines, see <a href="https://docs.docker.com/storage/storagedriver/">Storage drivers</a>. The default storage engine and the list of supported storage engines depend on your host’s Linux distribution and available kernel drivers.</p> <h2 id="configure-default-logging-driver">Configure default logging driver</h2> <p>Docker provides the <a href="https://docs.docker.com/config/containers/logging/">capability</a> to collect and view log data from all containers running on a host via a series of logging drivers. The default logging driver, <code class="language-plaintext highlighter-rouge">json-file</code>, writes log data to JSON-formatted files on the host filesystem. Over time, these log files expand in size, leading to potential exhaustion of disk resources.</p> <p>To alleviate such issues, either configure the <code class="language-plaintext highlighter-rouge">json-file</code> logging driver to enable <a href="https://docs.docker.com/config/containers/logging/json-file/">log rotation</a>, use an <a href="https://docs.docker.com/config/containers/logging/configure/#configure-the-default-logging-driver">alternative logging driver</a> such as the <a href="https://docs.docker.com/config/containers/logging/local/">“local” logging driver</a> that performs log rotation by default, or use a logging driver that sends logs to a remote logging aggregator.</p> <h2 id="configure-where-the-docker-daemon-listens-for-connections">Configure where the Docker daemon listens for connections</h2> <p>By default, the Docker daemon listens for connections on a UNIX socket to accept requests from local clients. It is possible to allow Docker to accept requests from remote hosts by configuring it to listen on an IP address and port as well as the UNIX socket. For more detailed information on this configuration option take a look at “Bind Docker to another host/port or a unix socket” section of the <a href="../../reference/commandline/dockerd/index.html">Docker CLI Reference</a> article.</p> <blockquote class="warning"> <p>Secure your connection</p> <p>Before configuring Docker to accept connections from remote hosts it is critically important that you understand the security implications of opening docker to the network. If steps are not taken to secure the connection, it is possible for remote non-root users to gain root access on the host. For more information on how to use TLS certificates to secure this connection, check this article on <a href="../../security/protect-access/index.html">how to protect the Docker daemon socket</a>.</p> </blockquote> <p>Configuring Docker to accept remote connections can be done with the <code class="language-plaintext highlighter-rouge">docker.service</code> systemd unit file for Linux distributions using systemd, such as recent versions of RedHat, CentOS, Ubuntu and SLES, or with the <code class="language-plaintext highlighter-rouge">daemon.json</code> file which is recommended for Linux distributions that do not use systemd.</p> <blockquote> <p>systemd vs daemon.json</p> <p>Configuring Docker to listen for connections using both the <code class="language-plaintext highlighter-rouge">systemd</code> unit file and the <code class="language-plaintext highlighter-rouge">daemon.json</code> file causes a conflict that prevents Docker from starting.</p> </blockquote> <h3 id="configuring-remote-access-with-systemd-unit-file">Configuring remote access with <code class="language-plaintext highlighter-rouge">systemd</code> unit file</h3> <ol> <li> <p>Use the command <code class="language-plaintext highlighter-rouge">sudo systemctl edit docker.service</code> to open an override file for <code class="language-plaintext highlighter-rouge">docker.service</code> in a text editor.</p> </li> <li> <p>Add or modify the following lines, substituting your own values.</p> <div class="highlight"><pre class="highlight" data-language="">[Service]
ExecStart=
ExecStart=/usr/bin/dockerd -H fd:// -H tcp://127.0.0.1:2375
</pre></div>  </li> <li> <p>Save the file.</p> </li> <li> <p>Reload the <code class="language-plaintext highlighter-rouge">systemctl</code> configuration.</p> <div class="highlight"><pre class="highlight" data-language=""> $ sudo systemctl daemon-reload
</pre></div>  </li> <li> <p>Restart Docker.</p> <div class="highlight"><pre class="highlight" data-language="">$ sudo systemctl restart docker.service
</pre></div>  </li> <li> <p>Check to see whether the change was honored by reviewing the output of <code class="language-plaintext highlighter-rouge">netstat</code> to confirm <code class="language-plaintext highlighter-rouge">dockerd</code> is listening on the configured port.</p> <div class="highlight"><pre class="highlight" data-language="">$ sudo netstat -lntp | grep dockerd
tcp        0      0 127.0.0.1:2375          0.0.0.0:*               LISTEN      3758/dockerd
</pre></div>  </li> </ol> <h3 id="configuring-remote-access-with-daemonjson">Configuring remote access with <code class="language-plaintext highlighter-rouge">daemon.json</code>
</h3> <ol> <li> <p>Set the <code class="language-plaintext highlighter-rouge">hosts</code> array in the <code class="language-plaintext highlighter-rouge">/etc/docker/daemon.json</code> to connect to the UNIX socket and an IP address, as follows:</p> <div class="highlight"><pre class="highlight" data-language="">{
  "hosts": ["unix:///var/run/docker.sock", "tcp://127.0.0.1:2375"]
}
</pre></div>  </li> <li> <p>Restart Docker.</p> </li> <li> <p>Check to see whether the change was honored by reviewing the output of <code class="language-plaintext highlighter-rouge">netstat</code> to confirm <code class="language-plaintext highlighter-rouge">dockerd</code> is listening on the configured port.</p> <div class="highlight"><pre class="highlight" data-language="">$ sudo netstat -lntp | grep dockerd
tcp        0      0 127.0.0.1:2375          0.0.0.0:*               LISTEN      3758/dockerd
</pre></div>  </li> </ol> <h2 id="enable-ipv6-on-the-docker-daemon">Enable IPv6 on the Docker daemon</h2> <p>To enable IPv6 on the Docker daemon, see <a href="https://docs.docker.com/config/daemon/ipv6/">Enable IPv6 support</a>.</p> <h2 id="troubleshooting">Troubleshooting</h2> <h3 id="kernel-compatibility">Kernel compatibility</h3> <p>Docker cannot run correctly if your kernel is older than version 3.10 or if it is missing some modules. To check kernel compatibility, you can download and run the <a href="https://raw.githubusercontent.com/docker/docker/master/contrib/check-config.sh"><code class="language-plaintext highlighter-rouge">check-config.sh</code></a> script.</p> <div class="highlight"><pre class="highlight" data-language="">$ curl https://raw.githubusercontent.com/docker/docker/master/contrib/check-config.sh &gt; check-config.sh

$ bash ./check-config.sh
</pre></div> <p>The script only works on Linux, not macOS.</p> <h3 id="cannot-connect-to-the-docker-daemon"><code class="language-plaintext highlighter-rouge">Cannot connect to the Docker daemon</code></h3> <p>If you see an error such as the following, your Docker client may be configured to connect to a Docker daemon on a different host, and that host may not be reachable.</p> <pre data-language="">Cannot connect to the Docker daemon. Is 'docker daemon' running on this host?
</pre> <p>To see which host your client is configured to connect to, check the value of the <code class="language-plaintext highlighter-rouge">DOCKER_HOST</code> variable in your environment.</p> <div class="highlight"><pre class="highlight" data-language="">$ env | grep DOCKER_HOST
</pre></div> <p>If this command returns a value, the Docker client is set to connect to a Docker daemon running on that host. If it is unset, the Docker client is set to connect to the Docker daemon running on the local host. If it is set in error, use the following command to unset it:</p> <div class="highlight"><pre class="highlight" data-language="">$ unset DOCKER_HOST
</pre></div> <p>You may need to edit your environment in files such as <code class="language-plaintext highlighter-rouge">~/.bashrc</code> or <code class="language-plaintext highlighter-rouge">~/.profile</code> to prevent the <code class="language-plaintext highlighter-rouge">DOCKER_HOST</code> variable from being set erroneously.</p> <p>If <code class="language-plaintext highlighter-rouge">DOCKER_HOST</code> is set as intended, verify that the Docker daemon is running on the remote host and that a firewall or network outage is not preventing you from connecting.</p> <h3 id="ip-forwarding-problems">IP forwarding problems</h3> <p>If you manually configure your network using <code class="language-plaintext highlighter-rouge">systemd-network</code> with <code class="language-plaintext highlighter-rouge">systemd</code> version 219 or higher, Docker containers may not be able to access your network. Beginning with <code class="language-plaintext highlighter-rouge">systemd</code> version 220, the forwarding setting for a given network (<code class="language-plaintext highlighter-rouge">net.ipv4.conf.&lt;interface&gt;.forwarding</code>) defaults to <em>off</em>. This setting prevents IP forwarding. It also conflicts with Docker’s behavior of enabling the <code class="language-plaintext highlighter-rouge">net.ipv4.conf.all.forwarding</code> setting within containers.</p> <p>To work around this on RHEL, CentOS, or Fedora, edit the <code class="language-plaintext highlighter-rouge">&lt;interface&gt;.network</code> file in <code class="language-plaintext highlighter-rouge">/usr/lib/systemd/network/</code> on your Docker host (ex: <code class="language-plaintext highlighter-rouge">/usr/lib/systemd/network/80-container-host0.network</code>) and add the following block within the <code class="language-plaintext highlighter-rouge">[Network]</code> section.</p> <div class="highlight"><pre class="highlight" data-language="">[Network]
...
IPForward=kernel
# OR
IPForward=true
</pre></div> <p>This configuration allows IP forwarding from the container as expected.</p> <h3 id="dns-resolver-found-in-resolvconf-and-containers-cant-use-it"><code class="language-plaintext highlighter-rouge">DNS resolver found in resolv.conf and containers can't use it</code></h3> <p>Linux systems which use a GUI often have a network manager running, which uses a <code class="language-plaintext highlighter-rouge">dnsmasq</code> instance running on a loopback address such as <code class="language-plaintext highlighter-rouge">127.0.0.1</code> or <code class="language-plaintext highlighter-rouge">127.0.1.1</code> to cache DNS requests, and adds this entry to <code class="language-plaintext highlighter-rouge">/etc/resolv.conf</code>. The <code class="language-plaintext highlighter-rouge">dnsmasq</code> service speeds up DNS look-ups and also provides DHCP services. This configuration does not work within a Docker container which has its own network namespace, because the Docker container resolves loopback addresses such as <code class="language-plaintext highlighter-rouge">127.0.0.1</code> to <strong>itself</strong>, and it is very unlikely to be running a DNS server on its own loopback address.</p> <p>If Docker detects that no DNS server referenced in <code class="language-plaintext highlighter-rouge">/etc/resolv.conf</code> is a fully functional DNS server, the following warning occurs and Docker uses the public DNS servers provided by Google at <code class="language-plaintext highlighter-rouge">8.8.8.8</code> and <code class="language-plaintext highlighter-rouge">8.8.4.4</code> for DNS resolution.</p> <pre data-language="">WARNING: Local (127.0.0.1) DNS resolver found in resolv.conf and containers
can't use it. Using default external servers : [8.8.8.8 8.8.4.4]
</pre> <p>If you see this warning, first check to see if you use <code class="language-plaintext highlighter-rouge">dnsmasq</code>:</p> <div class="highlight"><pre class="highlight" data-language="">$ ps aux |grep dnsmasq
</pre></div> <p>If your container needs to resolve hosts which are internal to your network, the public nameservers are not adequate. You have two choices:</p> <ul> <li>You can specify a DNS server for Docker to use, <strong>or</strong>
</li> <li>You can disable <code class="language-plaintext highlighter-rouge">dnsmasq</code> in NetworkManager. If you do this, NetworkManager adds your true DNS nameserver to <code class="language-plaintext highlighter-rouge">/etc/resolv.conf</code>, but you lose the possible benefits of <code class="language-plaintext highlighter-rouge">dnsmasq</code>.</li> </ul> <p><strong>You only need to use one of these methods.</strong></p> <h3 id="specify-dns-servers-for-docker">Specify DNS servers for Docker</h3> <p>The default location of the configuration file is <code class="language-plaintext highlighter-rouge">/etc/docker/daemon.json</code>. You can change the location of the configuration file using the <code class="language-plaintext highlighter-rouge">--config-file</code> daemon flag. The documentation below assumes the configuration file is located at <code class="language-plaintext highlighter-rouge">/etc/docker/daemon.json</code>.</p> <ol> <li> <p>Create or edit the Docker daemon configuration file, which defaults to <code class="language-plaintext highlighter-rouge">/etc/docker/daemon.json</code> file, which controls the Docker daemon configuration.</p> <div class="highlight"><pre class="highlight" data-language="">$ sudo nano /etc/docker/daemon.json
</pre></div>  </li> <li> <p>Add a <code class="language-plaintext highlighter-rouge">dns</code> key with one or more IP addresses as values. If the file has existing contents, you only need to add or edit the <code class="language-plaintext highlighter-rouge">dns</code> line.</p> <div class="highlight"><pre class="highlight" data-language="">{
  "dns": ["8.8.8.8", "8.8.4.4"]
}
</pre></div>  <p>If your internal DNS server cannot resolve public IP addresses, include at least one DNS server which can, so that you can connect to Docker Hub and so that your containers can resolve internet domain names.</p> <p>Save and close the file.</p> </li> <li> <p>Restart the Docker daemon.</p> <div class="highlight"><pre class="highlight" data-language="">$ sudo service docker restart
</pre></div>  </li> <li> <p>Verify that Docker can resolve external IP addresses by trying to pull an image:</p> <div class="highlight"><pre class="highlight" data-language="">$ docker pull hello-world
</pre></div>  </li> <li> <p>If necessary, verify that Docker containers can resolve an internal hostname by pinging it.</p> <div class="highlight"><pre class="highlight" data-language="">$ docker run --rm -it alpine ping -c4 &lt;my_internal_host&gt;

PING google.com (192.168.1.2): 56 data bytes
64 bytes from 192.168.1.2: seq=0 ttl=41 time=7.597 ms
64 bytes from 192.168.1.2: seq=1 ttl=41 time=7.635 ms
64 bytes from 192.168.1.2: seq=2 ttl=41 time=7.660 ms
64 bytes from 192.168.1.2: seq=3 ttl=41 time=7.677 ms
</pre></div>  </li> </ol> <h4 id="disable-dnsmasq">Disable <code class="language-plaintext highlighter-rouge">dnsmasq</code>
</h4> <h5 id="ubuntu">Ubuntu</h5> <p>If you prefer not to change the Docker daemon’s configuration to use a specific IP address, follow these instructions to disable <code class="language-plaintext highlighter-rouge">dnsmasq</code> in NetworkManager.</p> <ol> <li> <p>Edit the <code class="language-plaintext highlighter-rouge">/etc/NetworkManager/NetworkManager.conf</code> file.</p> </li> <li> <p>Comment out the <code class="language-plaintext highlighter-rouge">dns=dnsmasq</code> line by adding a <code class="language-plaintext highlighter-rouge">#</code> character to the beginning of the line.</p> <pre># dns=dnsmasq
</pre> <p>Save and close the file.</p> </li> <li> <p>Restart both NetworkManager and Docker. As an alternative, you can reboot your system.</p> <div class="highlight"><pre class="highlight" data-language="">$ sudo systemctl restart network-manager
$ sudo systemctl restart docker
</pre></div>  </li> </ol> <h5 id="rhel-centos-or-fedora">RHEL, CentOS, or Fedora</h5> <p>To disable <code class="language-plaintext highlighter-rouge">dnsmasq</code> on RHEL, CentOS, or Fedora:</p> <ol> <li> <p>Disable the <code class="language-plaintext highlighter-rouge">dnsmasq</code> service:</p> <div class="highlight"><pre class="highlight" data-language="">$ sudo systemctl stop dnsmasq
$ sudo systemctl disable dnsmasq
</pre></div>  </li> <li> <p>Configure the DNS servers manually using the <a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Deployment_Guide/s1-networkscripts-interfaces.html" target="_blank" rel="noopener" class="_">Red Hat documentation</a>.</p> </li> </ol> <h3 id="allow-access-to-the-remote-api-through-a-firewall">Allow access to the remote API through a firewall</h3> <p>If you run a firewall on the same host as you run Docker and you want to access the Docker Remote API from another host and remote access is enabled, you need to configure your firewall to allow incoming connections on the Docker port, which defaults to <code class="language-plaintext highlighter-rouge">2376</code> if TLS encrypted transport is enabled or <code class="language-plaintext highlighter-rouge">2375</code> otherwise.</p> <p>Two common firewall daemons are <a href="https://help.ubuntu.com/community/UFW">UFW (Uncomplicated Firewall)</a> (often used for Ubuntu systems) and <a href="https://firewalld.org">firewalld</a> (often used for RPM-based systems). Consult the documentation for your OS and firewall, but the following information might help you get started. These options are fairly permissive and you may want to use a different configuration that locks your system down more.</p> <ul> <li> <p><strong>UFW</strong>: Set <code class="language-plaintext highlighter-rouge">DEFAULT_FORWARD_POLICY="ACCEPT"</code> in your configuration.</p> </li> <li> <p><strong>firewalld</strong>: Add rules similar to the following to your policy (one for incoming requests and one for outgoing requests). Be sure the interface names and chain names are correct.</p> <div class="highlight"><pre class="highlight" data-language="">&lt;direct&gt;
  [ &lt;rule ipv="ipv6" table="filter" chain="FORWARD_direct" priority="0"&gt; -i zt0 -j ACCEPT &lt;/rule&gt; ]
  [ &lt;rule ipv="ipv6" table="filter" chain="FORWARD_direct" priority="0"&gt; -o zt0 -j ACCEPT &lt;/rule&gt; ]
&lt;/direct&gt;
</pre></div>  </li> </ul> <h3 id="your-kernel-does-not-support-cgroup-swap-limit-capabilities"><code class="language-plaintext highlighter-rouge">Your kernel does not support cgroup swap limit capabilities</code></h3> <p>On Ubuntu or Debian hosts, You may see messages similar to the following when working with an image.</p> <pre data-language="">WARNING: Your kernel does not support swap limit capabilities. Limitation discarded.
</pre> <p>This warning does not occur on RPM-based systems, which enable these capabilities by default.</p> <p>If you don’t need these capabilities, you can ignore the warning. You can enable these capabilities on Ubuntu or Debian by following these instructions. Memory and swap accounting incur an overhead of about 1% of the total available memory and a 10% overall performance degradation, even if Docker is not running.</p> <ol> <li> <p>Log into the Ubuntu or Debian host as a user with <code class="language-plaintext highlighter-rouge">sudo</code> privileges.</p> </li> <li> <p>Edit the <code class="language-plaintext highlighter-rouge">/etc/default/grub</code> file. Add or edit the <code class="language-plaintext highlighter-rouge">GRUB_CMDLINE_LINUX</code> line to add the following two key-value pairs:</p> <pre>GRUB_CMDLINE_LINUX="cgroup_enable=memory swapaccount=1"
</pre> <p>Save and close the file.</p> </li> <li> <p>Update GRUB.</p> <div class="highlight"><pre class="highlight" data-language="">$ sudo update-grub
</pre></div>  <p>If your GRUB configuration file has incorrect syntax, an error occurs. In this case, repeat steps 2 and 3.</p> <p>The changes take effect when the system is rebooted.</p> </li> </ol> <h2 id="next-steps">Next steps</h2> <ul> <li>Take a look at the <a href="../../../get-started/index.html">Get started</a> training modules to learn how to build an image and run it as a containerized application.</li> <li>Review the topics in <a href="https://docs.docker.com/develop/">Develop with Docker</a> to learn how to build new applications using Docker.</li> </ul> 
<p><a href="https://docs.docker.com/search/?q=Docker">Docker</a>, <a href="https://docs.docker.com/search/?q=Docker%20documentation">Docker documentation</a>, <a href="https://docs.docker.com/search/?q=requirements">requirements</a>, <a href="https://docs.docker.com/search/?q=apt">apt</a>, <a href="https://docs.docker.com/search/?q=installation">installation</a>, <a href="https://docs.docker.com/search/?q=ubuntu">ubuntu</a>, <a href="https://docs.docker.com/search/?q=install">install</a>, <a href="https://docs.docker.com/search/?q=uninstall">uninstall</a>, <a href="https://docs.docker.com/search/?q=upgrade">upgrade</a>, <a href="https://docs.docker.com/search/?q=update">update</a></p>
<div class="_attribution">
  <p class="_attribution-p">
    &copy; 2019 Docker, Inc.<br>Licensed under the Apache License, Version 2.0.<br>Docker and the Docker logo are trademarks or registered trademarks of Docker, Inc. in the United States and/or other countries.<br>Docker, Inc. and other parties may also have trademark rights in other terms used herein.<br>
    <a href="https://docs.docker.com/engine/install/linux-postinstall/" class="_attribution-link">https://docs.docker.com/engine/install/linux-postinstall/</a>
  </p>
</div>
