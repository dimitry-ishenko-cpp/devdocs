<h1>64.2. GiST Indexes </h1>    <div class="toc"> <dl class="toc"> <dt><a href="gist.html#GIST-INTRO">64.2.1. Introduction</a></dt> <dt><a href="gist.html#GIST-BUILTIN-OPCLASSES">64.2.2. Built-in Operator Classes</a></dt> <dt><a href="gist.html#GIST-EXTENSIBILITY">64.2.3. Extensibility</a></dt> <dt><a href="gist.html#GIST-IMPLEMENTATION">64.2.4. Implementation</a></dt> <dt><a href="gist.html#GIST-EXAMPLES">64.2.5. Examples</a></dt> </dl> </div> <div class="sect2" id="GIST-INTRO">    <h2 class="title">64.2.1. Introduction </h2>    <p>GiST stands for Generalized Search Tree. It is a balanced, tree-structured access method, that acts as a base template in which to implement arbitrary indexing schemes. B-trees, R-trees and many other indexing schemes can be implemented in GiST.</p> <p>One advantage of GiST is that it allows the development of custom data types with the appropriate access methods, by an expert in the domain of the data type, rather than a database expert.</p> <p>Some of the information here is derived from the University of California at Berkeley's GiST Indexing Project <a class="ulink" href="http://gist.cs.berkeley.edu/" target="_top">web site</a> and Marcel Kornacker's thesis, <a class="ulink" href="http://www.sai.msu.su/~megera/postgres/gist/papers/concurrency/access-methods-for-next-generation.pdf.gz" target="_top">Access Methods for Next-Generation Database Systems</a>. The GiST implementation in PostgreSQL is primarily maintained by Teodor Sigaev and Oleg Bartunov, and there is more information on their <a class="ulink" href="http://www.sai.msu.su/~megera/postgres/gist/" target="_top">web site</a>.</p> </div> <div class="sect2" id="GIST-BUILTIN-OPCLASSES">    <h2 class="title">64.2.2. Built-in Operator Classes </h2>    <p>The core PostgreSQL distribution includes the GiST operator classes shown in <a class="xref" href="gist.html#GIST-BUILTIN-OPCLASSES-TABLE" title="Table 64.1. Built-in GiST Operator Classes">Table 64.1</a>. (Some of the optional modules described in <a class="xref" href="https://www.postgresql.org/docs/17/contrib.html" title="Appendix F. Additional Supplied Modules and Extensions">Appendix F</a> provide additional GiST operator classes.)</p> <div class="table" id="GIST-BUILTIN-OPCLASSES-TABLE"> <p class="title"><strong>Table 64.1. Built-in GiST Operator Classes</strong></p> <div class="table-contents"> <table class="table" summary="Built-in GiST Operator Classes"> <colgroup> <col class="col1"> <col class="col2"> <col class="col3"> </colgroup> <thead> <tr> <th>Name</th> <th>Indexable Operators</th> <th>Ordering Operators</th> </tr> </thead> <tbody> <tr> <td rowspan="12"><code class="literal">box_ops</code></td> <td><code class="literal">&lt;&lt; (box, box)</code></td> <td rowspan="12"><code class="literal">&lt;-&gt; (box, point)</code></td> </tr> <tr> <td><code class="literal">&amp;&lt; (box, box)</code></td> </tr> <tr> <td><code class="literal">&amp;&amp; (box, box)</code></td> </tr> <tr> <td><code class="literal">&amp;&gt; (box, box)</code></td> </tr> <tr> <td><code class="literal">&gt;&gt; (box, box)</code></td> </tr> <tr> <td><code class="literal">~= (box, box)</code></td> </tr> <tr> <td><code class="literal">@&gt; (box, box)</code></td> </tr> <tr> <td><code class="literal">&lt;@ (box, box)</code></td> </tr> <tr> <td><code class="literal">&amp;&lt;| (box, box)</code></td> </tr> <tr> <td><code class="literal">&lt;&lt;| (box, box)</code></td> </tr> <tr> <td><code class="literal">|&gt;&gt; (box, box)</code></td> </tr> <tr> <td><code class="literal">|&amp;&gt; (box, box)</code></td> </tr> <tr> <td rowspan="12"><code class="literal">circle_ops</code></td> <td><code class="literal">&lt;&lt; (circle, circle)</code></td> <td rowspan="12"><code class="literal">&lt;-&gt; (circle, point)</code></td> </tr> <tr> <td><code class="literal">&amp;&lt; (circle, circle)</code></td> </tr> <tr> <td><code class="literal">&amp;&gt; (circle, circle)</code></td> </tr> <tr> <td><code class="literal">&gt;&gt; (circle, circle)</code></td> </tr> <tr> <td><code class="literal">&lt;@ (circle, circle)</code></td> </tr> <tr> <td><code class="literal">@&gt; (circle, circle)</code></td> </tr> <tr> <td><code class="literal">~= (circle, circle)</code></td> </tr> <tr> <td><code class="literal">&amp;&amp; (circle, circle)</code></td> </tr> <tr> <td><code class="literal">|&gt;&gt; (circle, circle)</code></td> </tr> <tr> <td><code class="literal">&lt;&lt;| (circle, circle)</code></td> </tr> <tr> <td><code class="literal">&amp;&lt;| (circle, circle)</code></td> </tr> <tr> <td><code class="literal">|&amp;&gt; (circle, circle)</code></td> </tr> <tr> <td rowspan="11"><code class="literal">inet_ops</code></td> <td><code class="literal">&lt;&lt; (inet, inet)</code></td> <td rowspan="11"> </td> </tr> <tr> <td><code class="literal">&lt;&lt;= (inet, inet)</code></td> </tr> <tr> <td><code class="literal">&gt;&gt; (inet, inet)</code></td> </tr> <tr> <td><code class="literal">&gt;&gt;= (inet, inet)</code></td> </tr> <tr> <td><code class="literal">= (inet, inet)</code></td> </tr> <tr> <td><code class="literal">&lt;&gt; (inet, inet)</code></td> </tr> <tr> <td><code class="literal">&lt; (inet, inet)</code></td> </tr> <tr> <td><code class="literal">&lt;= (inet, inet)</code></td> </tr> <tr> <td><code class="literal">&gt; (inet, inet)</code></td> </tr> <tr> <td><code class="literal">&gt;= (inet, inet)</code></td> </tr> <tr> <td><code class="literal">&amp;&amp; (inet, inet)</code></td> </tr> <tr> <td rowspan="18"><code class="literal">multirange_ops</code></td> <td><code class="literal">= (anymultirange, anymultirange)</code></td> <td rowspan="18"> </td> </tr> <tr> <td><code class="literal">&amp;&amp; (anymultirange, anymultirange)</code></td> </tr> <tr> <td><code class="literal">&amp;&amp; (anymultirange, anyrange)</code></td> </tr> <tr> <td><code class="literal">@&gt; (anymultirange, anyelement)</code></td> </tr> <tr> <td><code class="literal">@&gt; (anymultirange, anymultirange)</code></td> </tr> <tr> <td><code class="literal">@&gt; (anymultirange, anyrange)</code></td> </tr> <tr> <td><code class="literal">&lt;@ (anymultirange, anymultirange)</code></td> </tr> <tr> <td><code class="literal">&lt;@ (anymultirange, anyrange)</code></td> </tr> <tr> <td><code class="literal">&lt;&lt; (anymultirange, anymultirange)</code></td> </tr> <tr> <td><code class="literal">&lt;&lt; (anymultirange, anyrange)</code></td> </tr> <tr> <td><code class="literal">&gt;&gt; (anymultirange, anymultirange)</code></td> </tr> <tr> <td><code class="literal">&gt;&gt; (anymultirange, anyrange)</code></td> </tr> <tr> <td><code class="literal">&amp;&lt; (anymultirange, anymultirange)</code></td> </tr> <tr> <td><code class="literal">&amp;&lt; (anymultirange, anyrange)</code></td> </tr> <tr> <td><code class="literal">&amp;&gt; (anymultirange, anymultirange)</code></td> </tr> <tr> <td><code class="literal">&amp;&gt; (anymultirange, anyrange)</code></td> </tr> <tr> <td><code class="literal">-|- (anymultirange, anymultirange)</code></td> </tr> <tr> <td><code class="literal">-|- (anymultirange, anyrange)</code></td> </tr> <tr> <td rowspan="8"><code class="literal">point_ops</code></td> <td><code class="literal">|&gt;&gt; (point, point)</code></td> <td rowspan="8"><code class="literal">&lt;-&gt; (point, point)</code></td> </tr> <tr> <td><code class="literal">&lt;&lt; (point, point)</code></td> </tr> <tr> <td><code class="literal">&gt;&gt; (point, point)</code></td> </tr> <tr> <td><code class="literal">&lt;&lt;| (point, point)</code></td> </tr> <tr> <td><code class="literal">~= (point, point)</code></td> </tr> <tr> <td><code class="literal">&lt;@ (point, box)</code></td> </tr> <tr> <td><code class="literal">&lt;@ (point, polygon)</code></td> </tr> <tr> <td><code class="literal">&lt;@ (point, circle)</code></td> </tr> <tr> <td rowspan="12"><code class="literal">poly_ops</code></td> <td><code class="literal">&lt;&lt; (polygon, polygon)</code></td> <td rowspan="12"><code class="literal">&lt;-&gt; (polygon, point)</code></td> </tr> <tr> <td><code class="literal">&amp;&lt; (polygon, polygon)</code></td> </tr> <tr> <td><code class="literal">&amp;&gt; (polygon, polygon)</code></td> </tr> <tr> <td><code class="literal">&gt;&gt; (polygon, polygon)</code></td> </tr> <tr> <td><code class="literal">&lt;@ (polygon, polygon)</code></td> </tr> <tr> <td><code class="literal">@&gt; (polygon, polygon)</code></td> </tr> <tr> <td><code class="literal">~= (polygon, polygon)</code></td> </tr> <tr> <td><code class="literal">&amp;&amp; (polygon, polygon)</code></td> </tr> <tr> <td><code class="literal">&lt;&lt;| (polygon, polygon)</code></td> </tr> <tr> <td><code class="literal">&amp;&lt;| (polygon, polygon)</code></td> </tr> <tr> <td><code class="literal">|&amp;&gt; (polygon, polygon)</code></td> </tr> <tr> <td><code class="literal">|&gt;&gt; (polygon, polygon)</code></td> </tr> <tr> <td rowspan="18"><code class="literal">range_ops</code></td> <td><code class="literal">= (anyrange, anyrange)</code></td> <td rowspan="18"> </td> </tr> <tr> <td><code class="literal">&amp;&amp; (anyrange, anyrange)</code></td> </tr> <tr> <td><code class="literal">&amp;&amp; (anyrange, anymultirange)</code></td> </tr> <tr> <td><code class="literal">@&gt; (anyrange, anyelement)</code></td> </tr> <tr> <td><code class="literal">@&gt; (anyrange, anyrange)</code></td> </tr> <tr> <td><code class="literal">@&gt; (anyrange, anymultirange)</code></td> </tr> <tr> <td><code class="literal">&lt;@ (anyrange, anyrange)</code></td> </tr> <tr> <td><code class="literal">&lt;@ (anyrange, anymultirange)</code></td> </tr> <tr> <td><code class="literal">&lt;&lt; (anyrange, anyrange)</code></td> </tr> <tr> <td><code class="literal">&lt;&lt; (anyrange, anymultirange)</code></td> </tr> <tr> <td><code class="literal">&gt;&gt; (anyrange, anyrange)</code></td> </tr> <tr> <td><code class="literal">&gt;&gt; (anyrange, anymultirange)</code></td> </tr> <tr> <td><code class="literal">&amp;&lt; (anyrange, anyrange)</code></td> </tr> <tr> <td><code class="literal">&amp;&lt; (anyrange, anymultirange)</code></td> </tr> <tr> <td><code class="literal">&amp;&gt; (anyrange, anyrange)</code></td> </tr> <tr> <td><code class="literal">&amp;&gt; (anyrange, anymultirange)</code></td> </tr> <tr> <td><code class="literal">-|- (anyrange, anyrange)</code></td> </tr> <tr> <td><code class="literal">-|- (anyrange, anymultirange)</code></td> </tr> <tr> <td rowspan="2"><code class="literal">tsquery_ops</code></td> <td><code class="literal">&lt;@ (tsquery, tsquery)</code></td> <td rowspan="2"> </td> </tr> <tr> <td><code class="literal">@&gt; (tsquery, tsquery)</code></td> </tr> <tr> <td><code class="literal">tsvector_ops</code></td> <td><code class="literal">@@ (tsvector, tsquery)</code></td> <td> </td> </tr> </tbody> </table> </div> </div> <p>For historical reasons, the <code class="literal">inet_ops</code> operator class is not the default class for types <code class="type">inet</code> and <code class="type">cidr</code>. To use it, mention the class name in <code class="command">CREATE INDEX</code>, for example</p> <pre data-language="sql">
CREATE INDEX ON my_table USING GIST (my_inet_column inet_ops);
</pre> </div> <div class="sect2" id="GIST-EXTENSIBILITY">    <h2 class="title">64.2.3. Extensibility </h2>    <p>Traditionally, implementing a new index access method meant a lot of difficult work. It was necessary to understand the inner workings of the database, such as the lock manager and Write-Ahead Log. The GiST interface has a high level of abstraction, requiring the access method implementer only to implement the semantics of the data type being accessed. The GiST layer itself takes care of concurrency, logging and searching the tree structure.</p> <p>This extensibility should not be confused with the extensibility of the other standard search trees in terms of the data they can handle. For example, PostgreSQL supports extensible B-trees and hash indexes. That means that you can use PostgreSQL to build a B-tree or hash over any data type you want. But B-trees only support range predicates (<code class="literal">&lt;</code>, <code class="literal">=</code>, <code class="literal">&gt;</code>), and hash indexes only support equality queries.</p> <p>So if you index, say, an image collection with a PostgreSQL B-tree, you can only issue queries such as <span class="quote">“<span class="quote">is imagex equal to imagey</span>”</span>, <span class="quote">“<span class="quote">is imagex less than imagey</span>”</span> and <span class="quote">“<span class="quote">is imagex greater than imagey</span>”</span>. Depending on how you define <span class="quote">“<span class="quote">equals</span>”</span>, <span class="quote">“<span class="quote">less than</span>”</span> and <span class="quote">“<span class="quote">greater than</span>”</span> in this context, this could be useful. However, by using a GiST based index, you could create ways to ask domain-specific questions, perhaps <span class="quote">“<span class="quote">find all images of horses</span>”</span> or <span class="quote">“<span class="quote">find all over-exposed images</span>”</span>.</p> <p>All it takes to get a GiST access method up and running is to implement several user-defined methods, which define the behavior of keys in the tree. Of course these methods have to be pretty fancy to support fancy queries, but for all the standard queries (B-trees, R-trees, etc.) they're relatively straightforward. In short, GiST combines extensibility along with generality, code reuse, and a clean interface.</p> <p>There are five methods that an index operator class for GiST must provide, and six that are optional. Correctness of the index is ensured by proper implementation of the <code class="function">same</code>, <code class="function">consistent</code> and <code class="function">union</code> methods, while efficiency (size and speed) of the index will depend on the <code class="function">penalty</code> and <code class="function">picksplit</code> methods. Two optional methods are <code class="function">compress</code> and <code class="function">decompress</code>, which allow an index to have internal tree data of a different type than the data it indexes. The leaves are to be of the indexed data type, while the other tree nodes can be of any C struct (but you still have to follow PostgreSQL data type rules here, see about <code class="literal">varlena</code> for variable sized data). If the tree's internal data type exists at the SQL level, the <code class="literal">STORAGE</code> option of the <code class="command">CREATE OPERATOR CLASS</code> command can be used. The optional eighth method is <code class="function">distance</code>, which is needed if the operator class wishes to support ordered scans (nearest-neighbor searches). The optional ninth method <code class="function">fetch</code> is needed if the operator class wishes to support index-only scans, except when the <code class="function">compress</code> method is omitted. The optional tenth method <code class="function">options</code> is needed if the operator class has user-specified parameters. The optional eleventh method <code class="function">sortsupport</code> is used to speed up building a GiST index.</p> <div class="variablelist"> <dl class="variablelist"> <dt><code class="function">consistent</code></dt> <dd> <p>Given an index entry <code class="literal">p</code> and a query value <code class="literal">q</code>, this function determines whether the index entry is <span class="quote">“<span class="quote">consistent</span>”</span> with the query; that is, could the predicate <span class="quote">“<span class="quote"><code>indexed_column</code> <code>indexable_operator</code> <code class="literal">q</code></span>”</span> be true for any row represented by the index entry? For a leaf index entry this is equivalent to testing the indexable condition, while for an internal tree node this determines whether it is necessary to scan the subtree of the index represented by the tree node. When the result is <code class="literal">true</code>, a <code class="literal">recheck</code> flag must also be returned. This indicates whether the predicate is certainly true or only possibly true. If <code class="literal">recheck</code> = <code class="literal">false</code> then the index has tested the predicate condition exactly, whereas if <code class="literal">recheck</code> = <code class="literal">true</code> the row is only a candidate match. In that case the system will automatically evaluate the <code>indexable_operator</code> against the actual row value to see if it is really a match. This convention allows GiST to support both lossless and lossy index structures.</p> <p>The SQL declaration of the function must look like this:</p> <pre data-language="sql">
CREATE OR REPLACE FUNCTION my_consistent(internal, data_type, smallint, oid, internal)
RETURNS bool
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</pre> <p>And the matching code in the C module could then follow this skeleton:</p> <pre data-language="sql">
PG_FUNCTION_INFO_V1(my_consistent);

Datum
my_consistent(PG_FUNCTION_ARGS)
{
    GISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0);
    data_type  *query = PG_GETARG_DATA_TYPE_P(1);
    StrategyNumber strategy = (StrategyNumber) PG_GETARG_UINT16(2);
    /* Oid subtype = PG_GETARG_OID(3); */
    bool       *recheck = (bool *) PG_GETARG_POINTER(4);
    data_type  *key = DatumGetDataType(entry-&gt;key);
    bool        retval;

    /*
     * determine return value as a function of strategy, key and query.
     *
     * Use GIST_LEAF(entry) to know where you're called in the index tree,
     * which comes handy when supporting the = operator for example (you could
     * check for non empty union() in non-leaf nodes and equality in leaf
     * nodes).
     */

    *recheck = true;        /* or false if check is exact */

    PG_RETURN_BOOL(retval);
}
</pre> <p>Here, <code class="varname">key</code> is an element in the index and <code class="varname">query</code> the value being looked up in the index. The <code class="literal">StrategyNumber</code> parameter indicates which operator of your operator class is being applied — it matches one of the operator numbers in the <code class="command">CREATE OPERATOR CLASS</code> command.</p> <p>Depending on which operators you have included in the class, the data type of <code class="varname">query</code> could vary with the operator, since it will be whatever type is on the right-hand side of the operator, which might be different from the indexed data type appearing on the left-hand side. (The above code skeleton assumes that only one type is possible; if not, fetching the <code class="varname">query</code> argument value would have to depend on the operator.) It is recommended that the SQL declaration of the <code class="function">consistent</code> function use the opclass's indexed data type for the <code class="varname">query</code> argument, even though the actual type might be something else depending on the operator.</p> </dd> <dt><code class="function">union</code></dt> <dd> <p>This method consolidates information in the tree. Given a set of entries, this function generates a new index entry that represents all the given entries.</p> <p>The SQL declaration of the function must look like this:</p> <pre data-language="sql">
CREATE OR REPLACE FUNCTION my_union(internal, internal)
RETURNS storage_type
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</pre> <p>And the matching code in the C module could then follow this skeleton:</p> <pre data-language="sql">
PG_FUNCTION_INFO_V1(my_union);

Datum
my_union(PG_FUNCTION_ARGS)
{
    GistEntryVector *entryvec = (GistEntryVector *) PG_GETARG_POINTER(0);
    GISTENTRY  *ent = entryvec-&gt;vector;
    data_type  *out,
               *tmp,
               *old;
    int         numranges,
                i = 0;

    numranges = entryvec-&gt;n;
    tmp = DatumGetDataType(ent[0].key);
    out = tmp;

    if (numranges == 1)
    {
        out = data_type_deep_copy(tmp);

        PG_RETURN_DATA_TYPE_P(out);
    }

    for (i = 1; i &lt; numranges; i++)
    {
        old = out;
        tmp = DatumGetDataType(ent[i].key);
        out = my_union_implementation(out, tmp);
    }

    PG_RETURN_DATA_TYPE_P(out);
}
</pre> <p>As you can see, in this skeleton we're dealing with a data type where <code class="literal">union(X, Y, Z) = union(union(X, Y), Z)</code>. It's easy enough to support data types where this is not the case, by implementing the proper union algorithm in this GiST support method.</p> <p>The result of the <code class="function">union</code> function must be a value of the index's storage type, whatever that is (it might or might not be different from the indexed column's type). The <code class="function">union</code> function should return a pointer to newly <code class="function">palloc()</code>ed memory. You can't just return the input value as-is, even if there is no type change.</p> <p>As shown above, the <code class="function">union</code> function's first <code class="type">internal</code> argument is actually a <code class="structname">GistEntryVector</code> pointer. The second argument is a pointer to an integer variable, which can be ignored. (It used to be required that the <code class="function">union</code> function store the size of its result value into that variable, but this is no longer necessary.)</p> </dd> <dt><code class="function">compress</code></dt> <dd> <p>Converts a data item into a format suitable for physical storage in an index page. If the <code class="function">compress</code> method is omitted, data items are stored in the index without modification.</p> <p>The SQL declaration of the function must look like this:</p> <pre data-language="sql">
CREATE OR REPLACE FUNCTION my_compress(internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</pre> <p>And the matching code in the C module could then follow this skeleton:</p> <pre data-language="sql">
PG_FUNCTION_INFO_V1(my_compress);

Datum
my_compress(PG_FUNCTION_ARGS)
{
    GISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0);
    GISTENTRY  *retval;

    if (entry-&gt;leafkey)
    {
        /* replace entry-&gt;key with a compressed version */
        compressed_data_type *compressed_data = palloc(sizeof(compressed_data_type));

        /* fill *compressed_data from entry-&gt;key ... */

        retval = palloc(sizeof(GISTENTRY));
        gistentryinit(*retval, PointerGetDatum(compressed_data),
                      entry-&gt;rel, entry-&gt;page, entry-&gt;offset, FALSE);
    }
    else
    {
        /* typically we needn't do anything with non-leaf entries */
        retval = entry;
    }

    PG_RETURN_POINTER(retval);
}
</pre> <p>You have to adapt <code>compressed_data_type</code> to the specific type you're converting to in order to compress your leaf nodes, of course.</p> </dd> <dt><code class="function">decompress</code></dt> <dd> <p>Converts the stored representation of a data item into a format that can be manipulated by the other GiST methods in the operator class. If the <code class="function">decompress</code> method is omitted, it is assumed that the other GiST methods can work directly on the stored data format. (<code class="function">decompress</code> is not necessarily the reverse of the <code class="function">compress</code> method; in particular, if <code class="function">compress</code> is lossy then it's impossible for <code class="function">decompress</code> to exactly reconstruct the original data. <code class="function">decompress</code> is not necessarily equivalent to <code class="function">fetch</code>, either, since the other GiST methods might not require full reconstruction of the data.)</p> <p>The SQL declaration of the function must look like this:</p> <pre data-language="sql">
CREATE OR REPLACE FUNCTION my_decompress(internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</pre> <p>And the matching code in the C module could then follow this skeleton:</p> <pre data-language="sql">
PG_FUNCTION_INFO_V1(my_decompress);

Datum
my_decompress(PG_FUNCTION_ARGS)
{
    PG_RETURN_POINTER(PG_GETARG_POINTER(0));
}
</pre> <p>The above skeleton is suitable for the case where no decompression is needed. (But, of course, omitting the method altogether is even easier, and is recommended in such cases.)</p> </dd> <dt><code class="function">penalty</code></dt> <dd> <p>Returns a value indicating the <span class="quote">“<span class="quote">cost</span>”</span> of inserting the new entry into a particular branch of the tree. Items will be inserted down the path of least <code class="function">penalty</code> in the tree. Values returned by <code class="function">penalty</code> should be non-negative. If a negative value is returned, it will be treated as zero.</p> <p>The SQL declaration of the function must look like this:</p> <pre data-language="sql">
CREATE OR REPLACE FUNCTION my_penalty(internal, internal, internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;  -- in some cases penalty functions need not be strict
</pre> <p>And the matching code in the C module could then follow this skeleton:</p> <pre data-language="sql">
PG_FUNCTION_INFO_V1(my_penalty);

Datum
my_penalty(PG_FUNCTION_ARGS)
{
    GISTENTRY  *origentry = (GISTENTRY *) PG_GETARG_POINTER(0);
    GISTENTRY  *newentry = (GISTENTRY *) PG_GETARG_POINTER(1);
    float      *penalty = (float *) PG_GETARG_POINTER(2);
    data_type  *orig = DatumGetDataType(origentry-&gt;key);
    data_type  *new = DatumGetDataType(newentry-&gt;key);

    *penalty = my_penalty_implementation(orig, new);
    PG_RETURN_POINTER(penalty);
}
</pre> <p>For historical reasons, the <code class="function">penalty</code> function doesn't just return a <code class="type">float</code> result; instead it has to store the value at the location indicated by the third argument. The return value per se is ignored, though it's conventional to pass back the address of that argument.</p> <p>The <code class="function">penalty</code> function is crucial to good performance of the index. It'll get used at insertion time to determine which branch to follow when choosing where to add the new entry in the tree. At query time, the more balanced the index, the quicker the lookup.</p> </dd> <dt><code class="function">picksplit</code></dt> <dd> <p>When an index page split is necessary, this function decides which entries on the page are to stay on the old page, and which are to move to the new page.</p> <p>The SQL declaration of the function must look like this:</p> <pre data-language="sql">
CREATE OR REPLACE FUNCTION my_picksplit(internal, internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</pre> <p>And the matching code in the C module could then follow this skeleton:</p> <pre data-language="sql">
PG_FUNCTION_INFO_V1(my_picksplit);

Datum
my_picksplit(PG_FUNCTION_ARGS)
{
    GistEntryVector *entryvec = (GistEntryVector *) PG_GETARG_POINTER(0);
    GIST_SPLITVEC *v = (GIST_SPLITVEC *) PG_GETARG_POINTER(1);
    OffsetNumber maxoff = entryvec-&gt;n - 1;
    GISTENTRY  *ent = entryvec-&gt;vector;
    int         i,
                nbytes;
    OffsetNumber *left,
               *right;
    data_type  *tmp_union;
    data_type  *unionL;
    data_type  *unionR;
    GISTENTRY **raw_entryvec;

    maxoff = entryvec-&gt;n - 1;
    nbytes = (maxoff + 1) * sizeof(OffsetNumber);

    v-&gt;spl_left = (OffsetNumber *) palloc(nbytes);
    left = v-&gt;spl_left;
    v-&gt;spl_nleft = 0;

    v-&gt;spl_right = (OffsetNumber *) palloc(nbytes);
    right = v-&gt;spl_right;
    v-&gt;spl_nright = 0;

    unionL = NULL;
    unionR = NULL;

    /* Initialize the raw entry vector. */
    raw_entryvec = (GISTENTRY **) malloc(entryvec-&gt;n * sizeof(void *));
    for (i = FirstOffsetNumber; i &lt;= maxoff; i = OffsetNumberNext(i))
        raw_entryvec[i] = &amp;(entryvec-&gt;vector[i]);

    for (i = FirstOffsetNumber; i &lt;= maxoff; i = OffsetNumberNext(i))
    {
        int         real_index = raw_entryvec[i] - entryvec-&gt;vector;

        tmp_union = DatumGetDataType(entryvec-&gt;vector[real_index].key);
        Assert(tmp_union != NULL);

        /*
         * Choose where to put the index entries and update unionL and unionR
         * accordingly. Append the entries to either v-&gt;spl_left or
         * v-&gt;spl_right, and care about the counters.
         */

        if (my_choice_is_left(unionL, curl, unionR, curr))
        {
            if (unionL == NULL)
                unionL = tmp_union;
            else
                unionL = my_union_implementation(unionL, tmp_union);

            *left = real_index;
            ++left;
            ++(v-&gt;spl_nleft);
        }
        else
        {
            /*
             * Same on the right
             */
        }
    }

    v-&gt;spl_ldatum = DataTypeGetDatum(unionL);
    v-&gt;spl_rdatum = DataTypeGetDatum(unionR);
    PG_RETURN_POINTER(v);
}
</pre> <p>Notice that the <code class="function">picksplit</code> function's result is delivered by modifying the passed-in <code class="structname">v</code> structure. The return value per se is ignored, though it's conventional to pass back the address of <code class="structname">v</code>.</p> <p>Like <code class="function">penalty</code>, the <code class="function">picksplit</code> function is crucial to good performance of the index. Designing suitable <code class="function">penalty</code> and <code class="function">picksplit</code> implementations is where the challenge of implementing well-performing GiST indexes lies.</p> </dd> <dt><code class="function">same</code></dt> <dd> <p>Returns true if two index entries are identical, false otherwise. (An <span class="quote">“<span class="quote">index entry</span>”</span> is a value of the index's storage type, not necessarily the original indexed column's type.)</p> <p>The SQL declaration of the function must look like this:</p> <pre data-language="sql">
CREATE OR REPLACE FUNCTION my_same(storage_type, storage_type, internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</pre> <p>And the matching code in the C module could then follow this skeleton:</p> <pre data-language="sql">
PG_FUNCTION_INFO_V1(my_same);

Datum
my_same(PG_FUNCTION_ARGS)
{
    prefix_range *v1 = PG_GETARG_PREFIX_RANGE_P(0);
    prefix_range *v2 = PG_GETARG_PREFIX_RANGE_P(1);
    bool       *result = (bool *) PG_GETARG_POINTER(2);

    *result = my_eq(v1, v2);
    PG_RETURN_POINTER(result);
}
</pre> <p>For historical reasons, the <code class="function">same</code> function doesn't just return a Boolean result; instead it has to store the flag at the location indicated by the third argument. The return value per se is ignored, though it's conventional to pass back the address of that argument.</p> </dd> <dt><code class="function">distance</code></dt> <dd> <p>Given an index entry <code class="literal">p</code> and a query value <code class="literal">q</code>, this function determines the index entry's <span class="quote">“<span class="quote">distance</span>”</span> from the query value. This function must be supplied if the operator class contains any ordering operators. A query using the ordering operator will be implemented by returning index entries with the smallest <span class="quote">“<span class="quote">distance</span>”</span> values first, so the results must be consistent with the operator's semantics. For a leaf index entry the result just represents the distance to the index entry; for an internal tree node, the result must be the smallest distance that any child entry could have.</p> <p>The SQL declaration of the function must look like this:</p> <pre data-language="sql">
CREATE OR REPLACE FUNCTION my_distance(internal, data_type, smallint, oid, internal)
RETURNS float8
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</pre> <p>And the matching code in the C module could then follow this skeleton:</p> <pre data-language="sql">
PG_FUNCTION_INFO_V1(my_distance);

Datum
my_distance(PG_FUNCTION_ARGS)
{
    GISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0);
    data_type  *query = PG_GETARG_DATA_TYPE_P(1);
    StrategyNumber strategy = (StrategyNumber) PG_GETARG_UINT16(2);
    /* Oid subtype = PG_GETARG_OID(3); */
    /* bool *recheck = (bool *) PG_GETARG_POINTER(4); */
    data_type  *key = DatumGetDataType(entry-&gt;key);
    double      retval;

    /*
     * determine return value as a function of strategy, key and query.
     */

    PG_RETURN_FLOAT8(retval);
}
</pre> <p>The arguments to the <code class="function">distance</code> function are identical to the arguments of the <code class="function">consistent</code> function.</p> <p>Some approximation is allowed when determining the distance, so long as the result is never greater than the entry's actual distance. Thus, for example, distance to a bounding box is usually sufficient in geometric applications. For an internal tree node, the distance returned must not be greater than the distance to any of the child nodes. If the returned distance is not exact, the function must set <code class="literal">*recheck</code> to true. (This is not necessary for internal tree nodes; for them, the calculation is always assumed to be inexact.) In this case the executor will calculate the accurate distance after fetching the tuple from the heap, and reorder the tuples if necessary.</p> <p>If the distance function returns <code class="literal">*recheck = true</code> for any leaf node, the original ordering operator's return type must be <code class="type">float8</code> or <code class="type">float4</code>, and the distance function's result values must be comparable to those of the original ordering operator, since the executor will sort using both distance function results and recalculated ordering-operator results. Otherwise, the distance function's result values can be any finite <code class="type">float8</code> values, so long as the relative order of the result values matches the order returned by the ordering operator. (Infinity and minus infinity are used internally to handle cases such as nulls, so it is not recommended that <code class="function">distance</code> functions return these values.)</p> </dd> <dt><code class="function">fetch</code></dt> <dd> <p>Converts the compressed index representation of a data item into the original data type, for index-only scans. The returned data must be an exact, non-lossy copy of the originally indexed value.</p> <p>The SQL declaration of the function must look like this:</p> <pre data-language="sql">
CREATE OR REPLACE FUNCTION my_fetch(internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</pre> <p>The argument is a pointer to a <code class="structname">GISTENTRY</code> struct. On entry, its <code class="structfield">key</code> field contains a non-NULL leaf datum in compressed form. The return value is another <code class="structname">GISTENTRY</code> struct, whose <code class="structfield">key</code> field contains the same datum in its original, uncompressed form. If the opclass's compress function does nothing for leaf entries, the <code class="function">fetch</code> method can return the argument as-is. Or, if the opclass does not have a compress function, the <code class="function">fetch</code> method can be omitted as well, since it would necessarily be a no-op.</p> <p>The matching code in the C module could then follow this skeleton:</p> <pre data-language="sql">
PG_FUNCTION_INFO_V1(my_fetch);

Datum
my_fetch(PG_FUNCTION_ARGS)
{
    GISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0);
    input_data_type *in = DatumGetPointer(entry-&gt;key);
    fetched_data_type *fetched_data;
    GISTENTRY  *retval;

    retval = palloc(sizeof(GISTENTRY));
    fetched_data = palloc(sizeof(fetched_data_type));

    /*
     * Convert 'fetched_data' into the a Datum of the original datatype.
     */

    /* fill *retval from fetched_data. */
    gistentryinit(*retval, PointerGetDatum(converted_datum),
                  entry-&gt;rel, entry-&gt;page, entry-&gt;offset, FALSE);

    PG_RETURN_POINTER(retval);
}
</pre> <p>If the compress method is lossy for leaf entries, the operator class cannot support index-only scans, and must not define a <code class="function">fetch</code> function.</p> </dd> <dt><code class="function">options</code></dt> <dd> <p>Allows definition of user-visible parameters that control operator class behavior.</p> <p>The SQL declaration of the function must look like this:</p> <pre data-language="sql">
CREATE OR REPLACE FUNCTION my_options(internal)
RETURNS void
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</pre> <p>The function is passed a pointer to a <code class="structname">local_relopts</code> struct, which needs to be filled with a set of operator class specific options. The options can be accessed from other support functions using the <code class="literal">PG_HAS_OPCLASS_OPTIONS()</code> and <code class="literal">PG_GET_OPCLASS_OPTIONS()</code> macros.</p> <p>An example implementation of my_options() and parameters use from other support functions are given below:</p> <pre data-language="sql">
typedef enum MyEnumType
{
    MY_ENUM_ON,
    MY_ENUM_OFF,
    MY_ENUM_AUTO
} MyEnumType;

typedef struct
{
    int32   vl_len_;    /* varlena header (do not touch directly!) */
    int     int_param;  /* integer parameter */
    double  real_param; /* real parameter */
    MyEnumType enum_param; /* enum parameter */
    int     str_param;  /* string parameter */
} MyOptionsStruct;

/* String representation of enum values */
static relopt_enum_elt_def myEnumValues[] =
{
    {"on", MY_ENUM_ON},
    {"off", MY_ENUM_OFF},
    {"auto", MY_ENUM_AUTO},
    {(const char *) NULL}   /* list terminator */
};

static char *str_param_default = "default";

/*
 * Sample validator: checks that string is not longer than 8 bytes.
 */
static void
validate_my_string_relopt(const char *value)
{
    if (strlen(value) &gt; 8)
        ereport(ERROR,
                (errcode(ERRCODE_INVALID_PARAMETER_VALUE),
                 errmsg("str_param must be at most 8 bytes")));
}

/*
 * Sample filler: switches characters to lower case.
 */
static Size
fill_my_string_relopt(const char *value, void *ptr)
{
    char   *tmp = str_tolower(value, strlen(value), DEFAULT_COLLATION_OID);
    int     len = strlen(tmp);

    if (ptr)
        strcpy((char *) ptr, tmp);

    pfree(tmp);
    return len + 1;
}

PG_FUNCTION_INFO_V1(my_options);

Datum
my_options(PG_FUNCTION_ARGS)
{
    local_relopts *relopts = (local_relopts *) PG_GETARG_POINTER(0);

    init_local_reloptions(relopts, sizeof(MyOptionsStruct));
    add_local_int_reloption(relopts, "int_param", "integer parameter",
                            100, 0, 1000000,
                            offsetof(MyOptionsStruct, int_param));
    add_local_real_reloption(relopts, "real_param", "real parameter",
                             1.0, 0.0, 1000000.0,
                             offsetof(MyOptionsStruct, real_param));
    add_local_enum_reloption(relopts, "enum_param", "enum parameter",
                             myEnumValues, MY_ENUM_ON,
                             "Valid values are: \"on\", \"off\" and \"auto\".",
                             offsetof(MyOptionsStruct, enum_param));
    add_local_string_reloption(relopts, "str_param", "string parameter",
                               str_param_default,
                               &amp;validate_my_string_relopt,
                               &amp;fill_my_string_relopt,
                               offsetof(MyOptionsStruct, str_param));

    PG_RETURN_VOID();
}

PG_FUNCTION_INFO_V1(my_compress);

Datum
my_compress(PG_FUNCTION_ARGS)
{
    int     int_param = 100;
    double  real_param = 1.0;
    MyEnumType enum_param = MY_ENUM_ON;
    char   *str_param = str_param_default;

    /*
     * Normally, when opclass contains 'options' method, then options are always
     * passed to support functions.  However, if you add 'options' method to
     * existing opclass, previously defined indexes have no options, so the
     * check is required.
     */
    if (PG_HAS_OPCLASS_OPTIONS())
    {
        MyOptionsStruct *options = (MyOptionsStruct *) PG_GET_OPCLASS_OPTIONS();

        int_param = options-&gt;int_param;
        real_param = options-&gt;real_param;
        enum_param = options-&gt;enum_param;
        str_param = GET_STRING_RELOPTION(options, str_param);
    }

    /* the rest implementation of support function */
}

</pre> <p>Since the representation of the key in GiST is flexible, it may depend on user-specified parameters. For instance, the length of key signature may be specified. See <code class="literal">gtsvector_options()</code> for example.</p> </dd> <dt><code class="function">sortsupport</code></dt> <dd> <p>Returns a comparator function to sort data in a way that preserves locality. It is used by <code class="command">CREATE INDEX</code> and <code class="command">REINDEX</code> commands. The quality of the created index depends on how well the sort order determined by the comparator function preserves locality of the inputs.</p> <p>The <code class="function">sortsupport</code> method is optional. If it is not provided, <code class="command">CREATE INDEX</code> builds the index by inserting each tuple to the tree using the <code class="function">penalty</code> and <code class="function">picksplit</code> functions, which is much slower.</p> <p>The SQL declaration of the function must look like this:</p> <pre data-language="sql">
CREATE OR REPLACE FUNCTION my_sortsupport(internal)
RETURNS void
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</pre> <p>The argument is a pointer to a <code class="structname">SortSupport</code> struct. At a minimum, the function must fill in its comparator field. The comparator takes three arguments: two Datums to compare, and a pointer to the <code class="structname">SortSupport</code> struct. The Datums are the two indexed values in the format that they are stored in the index; that is, in the format returned by the <code class="function">compress</code> method. The full API is defined in <code class="filename">src/include/utils/sortsupport.h</code>.</p> <p>The matching code in the C module could then follow this skeleton:</p> <pre data-language="sql">
PG_FUNCTION_INFO_V1(my_sortsupport);

static int
my_fastcmp(Datum x, Datum y, SortSupport ssup)
{
  /* establish order between x and y by computing some sorting value z */

  int z1 = ComputeSpatialCode(x);
  int z2 = ComputeSpatialCode(y);

  return z1 == z2 ? 0 : z1 &gt; z2 ? 1 : -1;
}

Datum
my_sortsupport(PG_FUNCTION_ARGS)
{
  SortSupport ssup = (SortSupport) PG_GETARG_POINTER(0);

  ssup-&gt;comparator = my_fastcmp;
  PG_RETURN_VOID();
}
</pre> </dd> </dl> </div> <p>All the GiST support methods are normally called in short-lived memory contexts; that is, <code class="varname">CurrentMemoryContext</code> will get reset after each tuple is processed. It is therefore not very important to worry about pfree'ing everything you palloc. However, in some cases it's useful for a support method to cache data across repeated calls. To do that, allocate the longer-lived data in <code class="literal">fcinfo-&gt;flinfo-&gt;fn_mcxt</code>, and keep a pointer to it in <code class="literal">fcinfo-&gt;flinfo-&gt;fn_extra</code>. Such data will survive for the life of the index operation (e.g., a single GiST index scan, index build, or index tuple insertion). Be careful to pfree the previous value when replacing a <code class="literal">fn_extra</code> value, or the leak will accumulate for the duration of the operation.</p> </div> <div class="sect2" id="GIST-IMPLEMENTATION">    <h2 class="title">64.2.4. Implementation </h2>    <div class="sect3" id="GIST-BUFFERING-BUILD">    <h3 class="title">64.2.4.1. GiST Index Build Methods </h3>    <p>The simplest way to build a GiST index is just to insert all the entries, one by one. This tends to be slow for large indexes, because if the index tuples are scattered across the index and the index is large enough to not fit in cache, a lot of random I/O will be needed. PostgreSQL supports two alternative methods for initial build of a GiST index: <em class="firstterm">sorted</em> and <em class="firstterm">buffered</em> modes.</p> <p>The sorted method is only available if each of the opclasses used by the index provides a <code class="function">sortsupport</code> function, as described in <a class="xref" href="gist.html#GIST-EXTENSIBILITY" title="64.2.3. Extensibility">Section 64.2.3</a>. If they do, this method is usually the best, so it is used by default.</p> <p>The buffered method works by not inserting tuples directly into the index right away. It can dramatically reduce the amount of random I/O needed for non-ordered data sets. For well-ordered data sets the benefit is smaller or non-existent, because only a small number of pages receive new tuples at a time, and those pages fit in cache even if the index as a whole does not.</p> <p>The buffered method needs to call the <code class="function">penalty</code> function more often than the simple method does, which consumes some extra CPU resources. Also, the buffers need temporary disk space, up to the size of the resulting index. Buffering can also influence the quality of the resulting index, in both positive and negative directions. That influence depends on various factors, like the distribution of the input data and the operator class implementation.</p> <p>If sorting is not possible, then by default a GiST index build switches to the buffering method when the index size reaches <a class="xref" href="runtime-config-query.html#GUC-EFFECTIVE-CACHE-SIZE">effective_cache_size</a>. Buffering can be manually forced or prevented by the <code class="literal">buffering</code> parameter to the CREATE INDEX command. The default behavior is good for most cases, but turning buffering off might speed up the build somewhat if the input data is ordered.</p> </div> </div> <div class="sect2" id="GIST-EXAMPLES">    <h2 class="title">64.2.5. Examples </h2>    <p>The PostgreSQL source distribution includes several examples of index methods implemented using GiST. The core system currently provides text search support (indexing for <code class="type">tsvector</code> and <code class="type">tsquery</code>) as well as R-Tree equivalent functionality for some of the built-in geometric data types (see <code class="filename">src/backend/access/gist/gistproc.c</code>). The following <code class="filename">contrib</code> modules also contain GiST operator classes:</p> <div class="variablelist"> <dl class="variablelist"> <dt><code class="filename">btree_gist</code></dt> <dd> <p>B-tree equivalent functionality for several data types</p> </dd> <dt><code class="filename">cube</code></dt> <dd> <p>Indexing for multidimensional cubes</p> </dd> <dt><code class="filename">hstore</code></dt> <dd> <p>Module for storing (key, value) pairs</p> </dd> <dt><code class="filename">intarray</code></dt> <dd> <p>RD-Tree for one-dimensional array of int4 values</p> </dd> <dt><code class="filename">ltree</code></dt> <dd> <p>Indexing for tree-like structures</p> </dd> <dt><code class="filename">pg_trgm</code></dt> <dd> <p>Text similarity using trigram matching</p> </dd> <dt><code class="filename">seg</code></dt> <dd> <p>Indexing for <span class="quote">“<span class="quote">float ranges</span>”</span></p> </dd> </dl> </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996&ndash;2024 The PostgreSQL Global Development Group<br>Licensed under the PostgreSQL License.<br>
    <a href="https://www.postgresql.org/docs/17/gist.html" class="_attribution-link">https://www.postgresql.org/docs/17/gist.html</a>
  </p>
</div>
