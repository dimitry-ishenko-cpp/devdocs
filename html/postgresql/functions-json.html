<h1>9.16. JSON Functions and Operators </h1>    <div class="toc"> <dl class="toc"> <dt><a href="functions-json.html#FUNCTIONS-JSON-PROCESSING">9.16.1. Processing and Creating JSON Data</a></dt> <dt><a href="functions-json.html#FUNCTIONS-SQLJSON-PATH">9.16.2. The SQL/JSON Path Language</a></dt> <dt><a href="functions-json.html#SQLJSON-QUERY-FUNCTIONS">9.16.3. SQL/JSON Query Functions</a></dt> <dt><a href="functions-json.html#FUNCTIONS-SQLJSON-TABLE">9.16.4. JSON_TABLE</a></dt> </dl> </div> <p>This section describes:</p>  <ul> <li> <p>functions and operators for processing and creating JSON data</p> </li> <li> <p>the SQL/JSON path language</p> </li> <li> <p>the SQL/JSON query functions</p> </li> </ul>  <p>To provide native support for JSON data types within the SQL environment, PostgreSQL implements the <em class="firstterm">SQL/JSON data model</em>. This model comprises sequences of items. Each item can hold SQL scalar values, with an additional SQL/JSON null value, and composite data structures that use JSON arrays and objects. The model is a formalization of the implied data model in the JSON specification <a class="ulink" href="https://datatracker.ietf.org/doc/html/rfc7159" target="_top">RFC 7159</a>.</p> <p>SQL/JSON allows you to handle JSON data alongside regular SQL data, with transaction support, including:</p>  <ul> <li> <p>Uploading JSON data into the database and storing it in regular SQL columns as character or binary strings.</p> </li> <li> <p>Generating JSON objects and arrays from relational data.</p> </li> <li> <p>Querying JSON data using SQL/JSON query functions and SQL/JSON path language expressions.</p> </li> </ul>  <p>To learn more about the SQL/JSON standard, see <a class="xref" href="https://www.postgresql.org/docs/17/biblio.html#SQLTR-19075-6" title="SQL Technical Report">[sqltr-19075-6]</a>. For details on JSON types supported in PostgreSQL, see <a class="xref" href="datatype-json.html" title="8.14. JSON Types">Section 8.14</a>.</p> <div class="sect2" id="FUNCTIONS-JSON-PROCESSING">    <h2 class="title">9.16.1. Processing and Creating JSON Data </h2>    <p><a class="xref" href="functions-json.html#FUNCTIONS-JSON-OP-TABLE" title="Table 9.45. json and jsonb Operators">Table 9.45</a> shows the operators that are available for use with JSON data types (see <a class="xref" href="datatype-json.html" title="8.14. JSON Types">Section 8.14</a>). In addition, the usual comparison operators shown in <a class="xref" href="functions-comparison.html#FUNCTIONS-COMPARISON-OP-TABLE" title="Table 9.1. Comparison Operators">Table 9.1</a> are available for <code class="type">jsonb</code>, though not for <code class="type">json</code>. The comparison operators follow the ordering rules for B-tree operations outlined in <a class="xref" href="datatype-json.html#JSON-INDEXING" title="8.14.4. jsonb Indexing">Section 8.14.4</a>. See also <a class="xref" href="functions-aggregate.html" title="9.21. Aggregate Functions">Section 9.21</a> for the aggregate function <code class="function">json_agg</code> which aggregates record values as JSON, the aggregate function <code class="function">json_object_agg</code> which aggregates pairs of values into a JSON object, and their <code class="type">jsonb</code> equivalents, <code class="function">jsonb_agg</code> and <code class="function">jsonb_object_agg</code>.</p> <div class="table" id="FUNCTIONS-JSON-OP-TABLE"> <p class="title"><strong>Table 9.45. <code class="type">json</code> and <code class="type">jsonb</code> Operators</strong></p> <div class="table-contents"> <table class="table" summary="json and jsonb Operators"> <colgroup> <col> </colgroup> <thead> <tr> <th class="func_table_entry"> <p class="func_signature">Operator</p> <p>Description</p> <p>Example(s)</p> </th> </tr> </thead> <tbody> <tr> <td class="func_table_entry"> <p class="func_signature"><code class="type">json</code> <code class="literal">-&gt;</code> <code class="type">integer</code> → <code class="returnvalue">json</code></p> <p class="func_signature"><code class="type">jsonb</code> <code class="literal">-&gt;</code> <code class="type">integer</code> → <code class="returnvalue">jsonb</code></p> <p>Extracts <em class="parameter"><code>n</code></em>'th element of JSON array (array elements are indexed from zero, but negative integers count from the end).</p> <p><code class="literal">'[{"a":"foo"},{"b":"bar"},{"c":"baz"}]'::json -&gt; 2</code> → <code class="returnvalue">{"c":"baz"}</code></p> <p><code class="literal">'[{"a":"foo"},{"b":"bar"},{"c":"baz"}]'::json -&gt; -3</code> → <code class="returnvalue">{"a":"foo"}</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code class="type">json</code> <code class="literal">-&gt;</code> <code class="type">text</code> → <code class="returnvalue">json</code></p> <p class="func_signature"><code class="type">jsonb</code> <code class="literal">-&gt;</code> <code class="type">text</code> → <code class="returnvalue">jsonb</code></p> <p>Extracts JSON object field with the given key.</p> <p><code class="literal">'{"a": {"b":"foo"}}'::json -&gt; 'a'</code> → <code class="returnvalue">{"b":"foo"}</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code class="type">json</code> <code class="literal">-&gt;&gt;</code> <code class="type">integer</code> → <code class="returnvalue">text</code></p> <p class="func_signature"><code class="type">jsonb</code> <code class="literal">-&gt;&gt;</code> <code class="type">integer</code> → <code class="returnvalue">text</code></p> <p>Extracts <em class="parameter"><code>n</code></em>'th element of JSON array, as <code class="type">text</code>.</p> <p><code class="literal">'[1,2,3]'::json -&gt;&gt; 2</code> → <code class="returnvalue">3</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code class="type">json</code> <code class="literal">-&gt;&gt;</code> <code class="type">text</code> → <code class="returnvalue">text</code></p> <p class="func_signature"><code class="type">jsonb</code> <code class="literal">-&gt;&gt;</code> <code class="type">text</code> → <code class="returnvalue">text</code></p> <p>Extracts JSON object field with the given key, as <code class="type">text</code>.</p> <p><code class="literal">'{"a":1,"b":2}'::json -&gt;&gt; 'b'</code> → <code class="returnvalue">2</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code class="type">json</code> <code class="literal">#&gt;</code> <code class="type">text[]</code> → <code class="returnvalue">json</code></p> <p class="func_signature"><code class="type">jsonb</code> <code class="literal">#&gt;</code> <code class="type">text[]</code> → <code class="returnvalue">jsonb</code></p> <p>Extracts JSON sub-object at the specified path, where path elements can be either field keys or array indexes.</p> <p><code class="literal">'{"a": {"b": ["foo","bar"]}}'::json #&gt; '{a,b,1}'</code> → <code class="returnvalue">"bar"</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code class="type">json</code> <code class="literal">#&gt;&gt;</code> <code class="type">text[]</code> → <code class="returnvalue">text</code></p> <p class="func_signature"><code class="type">jsonb</code> <code class="literal">#&gt;&gt;</code> <code class="type">text[]</code> → <code class="returnvalue">text</code></p> <p>Extracts JSON sub-object at the specified path as <code class="type">text</code>.</p> <p><code class="literal">'{"a": {"b": ["foo","bar"]}}'::json #&gt;&gt; '{a,b,1}'</code> → <code class="returnvalue">bar</code></p> </td> </tr> </tbody> </table> </div> </div> <blockquote class="note"> <h3 class="title">Note</h3> <p>The field/element/path extraction operators return NULL, rather than failing, if the JSON input does not have the right structure to match the request; for example if no such key or array element exists.</p> </blockquote> <p>Some further operators exist only for <code class="type">jsonb</code>, as shown in <a class="xref" href="functions-json.html#FUNCTIONS-JSONB-OP-TABLE" title="Table 9.46. Additional jsonb Operators">Table 9.46</a>. <a class="xref" href="datatype-json.html#JSON-INDEXING" title="8.14.4. jsonb Indexing">Section 8.14.4</a> describes how these operators can be used to effectively search indexed <code class="type">jsonb</code> data.</p> <div class="table" id="FUNCTIONS-JSONB-OP-TABLE"> <p class="title"><strong>Table 9.46. Additional <code class="type">jsonb</code> Operators</strong></p> <div class="table-contents"> <table class="table" summary="Additional jsonb Operators"> <colgroup> <col> </colgroup> <thead> <tr> <th class="func_table_entry"> <p class="func_signature">Operator</p> <p>Description</p> <p>Example(s)</p> </th> </tr> </thead> <tbody> <tr> <td class="func_table_entry"> <p class="func_signature"><code class="type">jsonb</code> <code class="literal">@&gt;</code> <code class="type">jsonb</code> → <code class="returnvalue">boolean</code></p> <p>Does the first JSON value contain the second? (See <a class="xref" href="datatype-json.html#JSON-CONTAINMENT" title="8.14.3. jsonb Containment and Existence">Section 8.14.3</a> for details about containment.)</p> <p><code class="literal">'{"a":1, "b":2}'::jsonb @&gt; '{"b":2}'::jsonb</code> → <code class="returnvalue">t</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code class="type">jsonb</code> <code class="literal">&lt;@</code> <code class="type">jsonb</code> → <code class="returnvalue">boolean</code></p> <p>Is the first JSON value contained in the second?</p> <p><code class="literal">'{"b":2}'::jsonb &lt;@ '{"a":1, "b":2}'::jsonb</code> → <code class="returnvalue">t</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code class="type">jsonb</code> <code class="literal">?</code> <code class="type">text</code> → <code class="returnvalue">boolean</code></p> <p>Does the text string exist as a top-level key or array element within the JSON value?</p> <p><code class="literal">'{"a":1, "b":2}'::jsonb ? 'b'</code> → <code class="returnvalue">t</code></p> <p><code class="literal">'["a", "b", "c"]'::jsonb ? 'b'</code> → <code class="returnvalue">t</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code class="type">jsonb</code> <code class="literal">?|</code> <code class="type">text[]</code> → <code class="returnvalue">boolean</code></p> <p>Do any of the strings in the text array exist as top-level keys or array elements?</p> <p><code class="literal">'{"a":1, "b":2, "c":3}'::jsonb ?| array['b', 'd']</code> → <code class="returnvalue">t</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code class="type">jsonb</code> <code class="literal">?&amp;</code> <code class="type">text[]</code> → <code class="returnvalue">boolean</code></p> <p>Do all of the strings in the text array exist as top-level keys or array elements?</p> <p><code class="literal">'["a", "b", "c"]'::jsonb ?&amp; array['a', 'b']</code> → <code class="returnvalue">t</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code class="type">jsonb</code> <code class="literal">||</code> <code class="type">jsonb</code> → <code class="returnvalue">jsonb</code></p> <p>Concatenates two <code class="type">jsonb</code> values. Concatenating two arrays generates an array containing all the elements of each input. Concatenating two objects generates an object containing the union of their keys, taking the second object's value when there are duplicate keys. All other cases are treated by converting a non-array input into a single-element array, and then proceeding as for two arrays. Does not operate recursively: only the top-level array or object structure is merged.</p> <p><code class="literal">'["a", "b"]'::jsonb || '["a", "d"]'::jsonb</code> → <code class="returnvalue">["a", "b", "a", "d"]</code></p> <p><code class="literal">'{"a": "b"}'::jsonb || '{"c": "d"}'::jsonb</code> → <code class="returnvalue">{"a": "b", "c": "d"}</code></p> <p><code class="literal">'[1, 2]'::jsonb || '3'::jsonb</code> → <code class="returnvalue">[1, 2, 3]</code></p> <p><code class="literal">'{"a": "b"}'::jsonb || '42'::jsonb</code> → <code class="returnvalue">[{"a": "b"}, 42]</code></p> <p>To append an array to another array as a single entry, wrap it in an additional layer of array, for example:</p> <p><code class="literal">'[1, 2]'::jsonb || jsonb_build_array('[3, 4]'::jsonb)</code> → <code class="returnvalue">[1, 2, [3, 4]]</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code class="type">jsonb</code> <code class="literal">-</code> <code class="type">text</code> → <code class="returnvalue">jsonb</code></p> <p>Deletes a key (and its value) from a JSON object, or matching string value(s) from a JSON array.</p> <p><code class="literal">'{"a": "b", "c": "d"}'::jsonb - 'a'</code> → <code class="returnvalue">{"c": "d"}</code></p> <p><code class="literal">'["a", "b", "c", "b"]'::jsonb - 'b'</code> → <code class="returnvalue">["a", "c"]</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code class="type">jsonb</code> <code class="literal">-</code> <code class="type">text[]</code> → <code class="returnvalue">jsonb</code></p> <p>Deletes all matching keys or array elements from the left operand.</p> <p><code class="literal">'{"a": "b", "c": "d"}'::jsonb - '{a,c}'::text[]</code> → <code class="returnvalue">{}</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code class="type">jsonb</code> <code class="literal">-</code> <code class="type">integer</code> → <code class="returnvalue">jsonb</code></p> <p>Deletes the array element with specified index (negative integers count from the end). Throws an error if JSON value is not an array.</p> <p><code class="literal">'["a", "b"]'::jsonb - 1</code> → <code class="returnvalue">["a"]</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code class="type">jsonb</code> <code class="literal">#-</code> <code class="type">text[]</code> → <code class="returnvalue">jsonb</code></p> <p>Deletes the field or array element at the specified path, where path elements can be either field keys or array indexes.</p> <p><code class="literal">'["a", {"b":1}]'::jsonb #- '{1,b}'</code> → <code class="returnvalue">["a", {}]</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code class="type">jsonb</code> <code class="literal">@?</code> <code class="type">jsonpath</code> → <code class="returnvalue">boolean</code></p> <p>Does JSON path return any item for the specified JSON value? (This is useful only with SQL-standard JSON path expressions, not <a class="link" href="functions-json.html#FUNCTIONS-SQLJSON-CHECK-EXPRESSIONS" title="9.16.2.1.1. Boolean Predicate Check Expressions">predicate check expressions</a>, since those always return a value.)</p> <p><code class="literal">'{"a":[1,2,3,4,5]}'::jsonb @? '$.a[*] ? (@ &gt; 2)'</code> → <code class="returnvalue">t</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code class="type">jsonb</code> <code class="literal">@@</code> <code class="type">jsonpath</code> → <code class="returnvalue">boolean</code></p> <p>Returns the result of a JSON path predicate check for the specified JSON value. (This is useful only with <a class="link" href="functions-json.html#FUNCTIONS-SQLJSON-CHECK-EXPRESSIONS" title="9.16.2.1.1. Boolean Predicate Check Expressions">predicate check expressions</a>, not SQL-standard JSON path expressions, since it will return <code class="literal">NULL</code> if the path result is not a single boolean value.)</p> <p><code class="literal">'{"a":[1,2,3,4,5]}'::jsonb @@ '$.a[*] &gt; 2'</code> → <code class="returnvalue">t</code></p> </td> </tr> </tbody> </table> </div> </div> <blockquote class="note"> <h3 class="title">Note</h3> <p>The <code class="type">jsonpath</code> operators <code class="literal">@?</code> and <code class="literal">@@</code> suppress the following errors: missing object field or array element, unexpected JSON item type, datetime and numeric errors. The <code class="type">jsonpath</code>-related functions described below can also be told to suppress these types of errors. This behavior might be helpful when searching JSON document collections of varying structure.</p> </blockquote> <p><a class="xref" href="functions-json.html#FUNCTIONS-JSON-CREATION-TABLE" title="Table 9.47. JSON Creation Functions">Table 9.47</a> shows the functions that are available for constructing <code class="type">json</code> and <code class="type">jsonb</code> values. Some functions in this table have a <code class="literal">RETURNING</code> clause, which specifies the data type returned. It must be one of <code class="type">json</code>, <code class="type">jsonb</code>, <code class="type">bytea</code>, a character string type (<code class="type">text</code>, <code class="type">char</code>, or <code class="type">varchar</code>), or a type that can be cast to <code class="type">json</code>. By default, the <code class="type">json</code> type is returned.</p> <div class="table" id="FUNCTIONS-JSON-CREATION-TABLE"> <p class="title"><strong>Table 9.47. JSON Creation Functions</strong></p> <div class="table-contents"> <table class="table" summary="JSON Creation Functions"> <colgroup> <col> </colgroup> <thead> <tr> <th class="func_table_entry"> <p class="func_signature">Function</p> <p>Description</p> <p>Example(s)</p> </th> </tr> </thead> <tbody> <tr> <td class="func_table_entry"> <p class="func_signature" id="id-1.5.8.22.8.9.2.2.1.1.1.1"> <code class="function">to_json</code> ( <code class="type">anyelement</code> ) → <code class="returnvalue">json</code></p> <p class="func_signature" id="id-1.5.8.22.8.9.2.2.1.1.2.1"> <code class="function">to_jsonb</code> ( <code class="type">anyelement</code> ) → <code class="returnvalue">jsonb</code></p> <p>Converts any SQL value to <code class="type">json</code> or <code class="type">jsonb</code>. Arrays and composites are converted recursively to arrays and objects (multidimensional arrays become arrays of arrays in JSON). Otherwise, if there is a cast from the SQL data type to <code class="type">json</code>, the cast function will be used to perform the conversion;<a href="#ftn.id-1.5.8.22.8.9.2.2.1.1.3.4" class="footnote"><sup class="footnote" id="id-1.5.8.22.8.9.2.2.1.1.3.4">[a]</sup></a> otherwise, a scalar JSON value is produced. For any scalar other than a number, a Boolean, or a null value, the text representation will be used, with escaping as necessary to make it a valid JSON string value.</p> <p><code class="literal">to_json('Fred said "Hi."'::text)</code> → <code class="returnvalue">"Fred said \"Hi.\""</code></p> <p><code class="literal">to_jsonb(row(42, 'Fred said "Hi."'::text))</code> → <code class="returnvalue">{"f1": 42, "f2": "Fred said \"Hi.\""}</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature" id="id-1.5.8.22.8.9.2.2.2.1.1.1"> <code class="function">array_to_json</code> ( <code class="type">anyarray</code> [<span class="optional">, <code class="type">boolean</code></span> ] ) → <code class="returnvalue">json</code></p> <p>Converts an SQL array to a JSON array. The behavior is the same as <code class="function">to_json</code> except that line feeds will be added between top-level array elements if the optional boolean parameter is true.</p> <p><code class="literal">array_to_json('{{1,5},{99,100}}'::int[])</code> → <code class="returnvalue">[[1,5],[99,100]]</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature" id="id-1.5.8.22.8.9.2.2.3.1.1.1"> <code class="function">json_array</code> ( [ <span class="optional">{ <code>value_expression</code> [ <span class="optional"><code class="literal">FORMAT JSON</code></span> ] } [<span class="optional">, ...</span>]</span> ] [ <span class="optional">{ <code class="literal">NULL</code> | <code class="literal">ABSENT</code> } <code class="literal">ON NULL</code></span> ] [ <span class="optional"><code class="literal">RETURNING</code> <code>data_type</code> [ <span class="optional"><code class="literal">FORMAT JSON</code> [ <span class="optional"><code class="literal">ENCODING UTF8</code></span> ]</span> ]</span> ])</p> <p class="func_signature"><code class="function">json_array</code> ( [ <span class="optional"><code>query_expression</code></span> ] [ <span class="optional"><code class="literal">RETURNING</code> <code>data_type</code> [ <span class="optional"><code class="literal">FORMAT JSON</code> [ <span class="optional"><code class="literal">ENCODING UTF8</code></span> ]</span> ]</span> ])</p> <p>Constructs a JSON array from either a series of <code>value_expression</code> parameters or from the results of <code>query_expression</code>, which must be a SELECT query returning a single column. If <code class="literal">ABSENT ON NULL</code> is specified, NULL values are ignored. This is always the case if a <code>query_expression</code> is used.</p> <p><code class="literal">json_array(1,true,json '{"a":null}')</code> → <code class="returnvalue">[1, true, {"a":null}]</code></p> <p><code class="literal">json_array(SELECT * FROM (VALUES(1),(2)) t)</code> → <code class="returnvalue">[1, 2]</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature" id="id-1.5.8.22.8.9.2.2.4.1.1.1"> <code class="function">row_to_json</code> ( <code class="type">record</code> [<span class="optional">, <code class="type">boolean</code></span> ] ) → <code class="returnvalue">json</code></p> <p>Converts an SQL composite value to a JSON object. The behavior is the same as <code class="function">to_json</code> except that line feeds will be added between top-level elements if the optional boolean parameter is true.</p> <p><code class="literal">row_to_json(row(1,'foo'))</code> → <code class="returnvalue">{"f1":1,"f2":"foo"}</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature" id="id-1.5.8.22.8.9.2.2.5.1.1.1"> <code class="function">json_build_array</code> ( <code class="literal">VARIADIC</code> <code class="type">"any"</code> ) → <code class="returnvalue">json</code></p> <p class="func_signature" id="id-1.5.8.22.8.9.2.2.5.1.2.1"> <code class="function">jsonb_build_array</code> ( <code class="literal">VARIADIC</code> <code class="type">"any"</code> ) → <code class="returnvalue">jsonb</code></p> <p>Builds a possibly-heterogeneously-typed JSON array out of a variadic argument list. Each argument is converted as per <code class="function">to_json</code> or <code class="function">to_jsonb</code>.</p> <p><code class="literal">json_build_array(1, 2, 'foo', 4, 5)</code> → <code class="returnvalue">[1, 2, "foo", 4, 5]</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature" id="id-1.5.8.22.8.9.2.2.6.1.1.1"> <code class="function">json_build_object</code> ( <code class="literal">VARIADIC</code> <code class="type">"any"</code> ) → <code class="returnvalue">json</code></p> <p class="func_signature" id="id-1.5.8.22.8.9.2.2.6.1.2.1"> <code class="function">jsonb_build_object</code> ( <code class="literal">VARIADIC</code> <code class="type">"any"</code> ) → <code class="returnvalue">jsonb</code></p> <p>Builds a JSON object out of a variadic argument list. By convention, the argument list consists of alternating keys and values. Key arguments are coerced to text; value arguments are converted as per <code class="function">to_json</code> or <code class="function">to_jsonb</code>.</p> <p><code class="literal">json_build_object('foo', 1, 2, row(3,'bar'))</code> → <code class="returnvalue">{"foo" : 1, "2" : {"f1":3,"f2":"bar"}}</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature" id="id-1.5.8.22.8.9.2.2.7.1.1.1"> <code class="function">json_object</code> ( [ <span class="optional">{ <code>key_expression</code> { <code class="literal">VALUE</code> | ':' } <code>value_expression</code> [ <span class="optional"><code class="literal">FORMAT JSON</code> [ <span class="optional"><code class="literal">ENCODING UTF8</code></span> ]</span> ] }[<span class="optional">, ...</span>]</span> ] [ <span class="optional">{ <code class="literal">NULL</code> | <code class="literal">ABSENT</code> } <code class="literal">ON NULL</code></span> ] [ <span class="optional">{ <code class="literal">WITH</code> | <code class="literal">WITHOUT</code> } <code class="literal">UNIQUE</code> [ <span class="optional"><code class="literal">KEYS</code></span> ]</span> ] [ <span class="optional"><code class="literal">RETURNING</code> <code>data_type</code> [ <span class="optional"><code class="literal">FORMAT JSON</code> [ <span class="optional"><code class="literal">ENCODING UTF8</code></span> ]</span> ]</span> ])</p> <p>Constructs a JSON object of all the key/value pairs given, or an empty object if none are given. <code>key_expression</code> is a scalar expression defining the JSON key, which is converted to the <code class="type">text</code> type. It cannot be <code class="literal">NULL</code> nor can it belong to a type that has a cast to the <code class="type">json</code> type. If <code class="literal">WITH UNIQUE KEYS</code> is specified, there must not be any duplicate <code>key_expression</code>. Any pair for which the <code>value_expression</code> evaluates to <code class="literal">NULL</code> is omitted from the output if <code class="literal">ABSENT ON NULL</code> is specified; if <code class="literal">NULL ON NULL</code> is specified or the clause omitted, the key is included with value <code class="literal">NULL</code>.</p> <p><code class="literal">json_object('code' VALUE 'P123', 'title': 'Jaws')</code> → <code class="returnvalue">{"code" : "P123", "title" : "Jaws"}</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature" id="id-1.5.8.22.8.9.2.2.8.1.1.1"> <code class="function">json_object</code> ( <code class="type">text[]</code> ) → <code class="returnvalue">json</code></p> <p class="func_signature" id="id-1.5.8.22.8.9.2.2.8.1.2.1"> <code class="function">jsonb_object</code> ( <code class="type">text[]</code> ) → <code class="returnvalue">jsonb</code></p> <p>Builds a JSON object out of a text array. The array must have either exactly one dimension with an even number of members, in which case they are taken as alternating key/value pairs, or two dimensions such that each inner array has exactly two elements, which are taken as a key/value pair. All values are converted to JSON strings.</p> <p><code class="literal">json_object('{a, 1, b, "def", c, 3.5}')</code> → <code class="returnvalue">{"a" : "1", "b" : "def", "c" : "3.5"}</code></p> <p><code class="literal">json_object('{{a, 1}, {b, "def"}, {c, 3.5}}')</code> → <code class="returnvalue">{"a" : "1", "b" : "def", "c" : "3.5"}</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code class="function">json_object</code> ( <em class="parameter"><code>keys</code></em> <code class="type">text[]</code>, <em class="parameter"><code>values</code></em> <code class="type">text[]</code> ) → <code class="returnvalue">json</code></p> <p class="func_signature"><code class="function">jsonb_object</code> ( <em class="parameter"><code>keys</code></em> <code class="type">text[]</code>, <em class="parameter"><code>values</code></em> <code class="type">text[]</code> ) → <code class="returnvalue">jsonb</code></p> <p>This form of <code class="function">json_object</code> takes keys and values pairwise from separate text arrays. Otherwise it is identical to the one-argument form.</p> <p><code class="literal">json_object('{a,b}', '{1,2}')</code> → <code class="returnvalue">{"a": "1", "b": "2"}</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature" id="id-1.5.8.22.8.9.2.2.10.1.1.1"> <code class="function">json</code> ( <code>expression</code> [ <span class="optional"><code class="literal">FORMAT JSON</code> [ <span class="optional"><code class="literal">ENCODING UTF8</code></span> ]</span>] [ <span class="optional">{ <code class="literal">WITH</code> | <code class="literal">WITHOUT</code> } <code class="literal">UNIQUE</code> [ <span class="optional"><code class="literal">KEYS</code></span> ]</span>] ) → <code class="returnvalue">json</code></p> <p>Converts a given expression specified as <code class="type">text</code> or <code class="type">bytea</code> string (in UTF8 encoding) into a JSON value. If <code>expression</code> is NULL, an SQL null value is returned. If <code class="literal">WITH UNIQUE</code> is specified, the <code>expression</code> must not contain any duplicate object keys.</p> <p><code class="literal">json('{"a":123, "b":[true,"foo"], "a":"bar"}')</code> → <code class="returnvalue">{"a":123, "b":[true,"foo"], "a":"bar"}</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature" id="id-1.5.8.22.8.9.2.2.11.1.1.1"> <code class="function">json_scalar</code> ( <code>expression</code> )</p> <p>Converts a given SQL scalar value into a JSON scalar value. If the input is NULL, an SQL null is returned. If the input is number or a boolean value, a corresponding JSON number or boolean value is returned. For any other value, a JSON string is returned.</p> <p><code class="literal">json_scalar(123.45)</code> → <code class="returnvalue">123.45</code></p> <p><code class="literal">json_scalar(CURRENT_TIMESTAMP)</code> → <code class="returnvalue">"2022-05-10T10:51:04.62128-04:00"</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code class="function">json_serialize</code> ( <code>expression</code> [ <span class="optional"><code class="literal">FORMAT JSON</code> [ <span class="optional"><code class="literal">ENCODING UTF8</code></span> ]</span> ] [ <span class="optional"><code class="literal">RETURNING</code> <code>data_type</code> [ <span class="optional"><code class="literal">FORMAT JSON</code> [ <span class="optional"><code class="literal">ENCODING UTF8</code></span> ]</span> ]</span> ] )</p> <p>Converts an SQL/JSON expression into a character or binary string. The <code>expression</code> can be of any JSON type, any character string type, or <code class="type">bytea</code> in UTF8 encoding. The returned type used in <code class="literal">RETURNING</code> can be any character string type or <code class="type">bytea</code>. The default is <code class="type">text</code>.</p> <p><code class="literal">json_serialize('{ "a" : 1 } ' RETURNING bytea)</code> → <code class="returnvalue">\x7b20226122203a2031207d20</code></p> </td> </tr> </tbody> <tbody class="footnotes"> <tr> <td colspan="1"> <div id="ftn.id-1.5.8.22.8.9.2.2.1.1.3.4" class="footnote"> <p><a href="#id-1.5.8.22.8.9.2.2.1.1.3.4" class="para"><sup class="para">[a]</sup></a> For example, the <a class="xref" href="hstore.html" title="F.17. hstore — hstore key/value datatype">hstore</a> extension has a cast from <code class="type">hstore</code> to <code class="type">json</code>, so that <code class="type">hstore</code> values converted via the JSON creation functions will be represented as JSON objects, not as primitive string values.</p> </div> </td> </tr> </tbody> </table> </div> </div> <p><a class="xref" href="functions-json.html#FUNCTIONS-SQLJSON-MISC" title="Table 9.48. SQL/JSON Testing Functions">Table 9.48</a> details SQL/JSON facilities for testing JSON.</p> <div class="table" id="FUNCTIONS-SQLJSON-MISC"> <p class="title"><strong>Table 9.48. SQL/JSON Testing Functions</strong></p> <div class="table-contents"> <table class="table" summary="SQL/JSON Testing Functions"> <colgroup> <col> </colgroup> <thead> <tr> <th class="func_table_entry"> <p class="func_signature">Function signature</p> <p>Description</p> <p>Example(s)</p> </th> </tr> </thead> <tbody> <tr> <td class="func_table_entry"> <p class="func_signature" id="id-1.5.8.22.8.11.2.2.1.1.1.1"> <code>expression</code> <code class="literal">IS</code> [ <span class="optional"><code class="literal">NOT</code></span> ] <code class="literal">JSON</code> [ <span class="optional">{ <code class="literal">VALUE</code> | <code class="literal">SCALAR</code> | <code class="literal">ARRAY</code> | <code class="literal">OBJECT</code> }</span> ] [ <span class="optional">{ <code class="literal">WITH</code> | <code class="literal">WITHOUT</code> } <code class="literal">UNIQUE</code> [ <span class="optional"><code class="literal">KEYS</code></span> ]</span> ]</p> <p>This predicate tests whether <code>expression</code> can be parsed as JSON, possibly of a specified type. If <code class="literal">SCALAR</code> or <code class="literal">ARRAY</code> or <code class="literal">OBJECT</code> is specified, the test is whether or not the JSON is of that particular type. If <code class="literal">WITH UNIQUE KEYS</code> is specified, then any object in the <code>expression</code> is also tested to see if it has duplicate keys.</p> <pre data-language="sql">
SELECT js,
  js IS JSON "json?",
  js IS JSON SCALAR "scalar?",
  js IS JSON OBJECT "object?",
  js IS JSON ARRAY "array?"
FROM (VALUES
      ('123'), ('"abc"'), ('{"a": "b"}'), ('[1,2]'),('abc')) foo(js);
     js     | json? | scalar? | object? | array?
------------+-------+---------+---------+--------
 123        | t     | t       | f       | f
 "abc"      | t     | t       | f       | f
 {"a": "b"} | t     | f       | t       | f
 [1,2]      | t     | f       | f       | t
 abc        | f     | f       | f       | f
</pre> <pre data-language="sql">
SELECT js,
  js IS JSON OBJECT "object?",
  js IS JSON ARRAY "array?",
  js IS JSON ARRAY WITH UNIQUE KEYS "array w. UK?",
  js IS JSON ARRAY WITHOUT UNIQUE KEYS "array w/o UK?"
FROM (VALUES ('[{"a":"1"},
 {"b":"2","b":"3"}]')) foo(js);
-[ RECORD 1 ]-+--------------------
js            | [{"a":"1"},        +
              |  {"b":"2","b":"3"}]
object?       | f
array?        | t
array w. UK?  | f
array w/o UK? | t
</pre> </td> </tr> </tbody> </table> </div> </div> <p><a class="xref" href="functions-json.html#FUNCTIONS-JSON-PROCESSING-TABLE" title="Table 9.49. JSON Processing Functions">Table 9.49</a> shows the functions that are available for processing <code class="type">json</code> and <code class="type">jsonb</code> values.</p> <div class="table" id="FUNCTIONS-JSON-PROCESSING-TABLE"> <p class="title"><strong>Table 9.49. JSON Processing Functions</strong></p> <div class="table-contents"> <table class="table" summary="JSON Processing Functions"> <colgroup> <col> </colgroup> <thead> <tr> <th class="func_table_entry"> <p class="func_signature">Function</p> <p>Description</p> <p>Example(s)</p> </th> </tr> </thead> <tbody> <tr> <td class="func_table_entry"> <p class="func_signature" id="id-1.5.8.22.8.13.2.2.1.1.1.1"> <code class="function">json_array_elements</code> ( <code class="type">json</code> ) → <code class="returnvalue">setof json</code></p> <p class="func_signature" id="id-1.5.8.22.8.13.2.2.1.1.2.1"> <code class="function">jsonb_array_elements</code> ( <code class="type">jsonb</code> ) → <code class="returnvalue">setof jsonb</code></p> <p>Expands the top-level JSON array into a set of JSON values.</p> <p><code class="literal">select * from json_array_elements('[1,true, [2,false]]')</code> →</p> <pre data-language="sql">
   value
-----------
 1
 true
 [2,false]
</pre> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature" id="id-1.5.8.22.8.13.2.2.2.1.1.1"> <code class="function">json_array_elements_text</code> ( <code class="type">json</code> ) → <code class="returnvalue">setof text</code></p> <p class="func_signature" id="id-1.5.8.22.8.13.2.2.2.1.2.1"> <code class="function">jsonb_array_elements_text</code> ( <code class="type">jsonb</code> ) → <code class="returnvalue">setof text</code></p> <p>Expands the top-level JSON array into a set of <code class="type">text</code> values.</p> <p><code class="literal">select * from json_array_elements_text('["foo", "bar"]')</code> →</p> <pre data-language="sql">
   value
-----------
 foo
 bar
</pre> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature" id="id-1.5.8.22.8.13.2.2.3.1.1.1"> <code class="function">json_array_length</code> ( <code class="type">json</code> ) → <code class="returnvalue">integer</code></p> <p class="func_signature" id="id-1.5.8.22.8.13.2.2.3.1.2.1"> <code class="function">jsonb_array_length</code> ( <code class="type">jsonb</code> ) → <code class="returnvalue">integer</code></p> <p>Returns the number of elements in the top-level JSON array.</p> <p><code class="literal">json_array_length('[1,2,3,{"f1":1,"f2":[5,6]},4]')</code> → <code class="returnvalue">5</code></p> <p><code class="literal">jsonb_array_length('[]')</code> → <code class="returnvalue">0</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature" id="id-1.5.8.22.8.13.2.2.4.1.1.1"> <code class="function">json_each</code> ( <code class="type">json</code> ) → <code class="returnvalue">setof record</code> ( <em class="parameter"><code>key</code></em> <code class="type">text</code>, <em class="parameter"><code>value</code></em> <code class="type">json</code> )</p> <p class="func_signature" id="id-1.5.8.22.8.13.2.2.4.1.2.1"> <code class="function">jsonb_each</code> ( <code class="type">jsonb</code> ) → <code class="returnvalue">setof record</code> ( <em class="parameter"><code>key</code></em> <code class="type">text</code>, <em class="parameter"><code>value</code></em> <code class="type">jsonb</code> )</p> <p>Expands the top-level JSON object into a set of key/value pairs.</p> <p><code class="literal">select * from json_each('{"a":"foo", "b":"bar"}')</code> →</p> <pre data-language="sql">
 key | value
-----+-------
 a   | "foo"
 b   | "bar"
</pre> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature" id="id-1.5.8.22.8.13.2.2.5.1.1.1"> <code class="function">json_each_text</code> ( <code class="type">json</code> ) → <code class="returnvalue">setof record</code> ( <em class="parameter"><code>key</code></em> <code class="type">text</code>, <em class="parameter"><code>value</code></em> <code class="type">text</code> )</p> <p class="func_signature" id="id-1.5.8.22.8.13.2.2.5.1.2.1"> <code class="function">jsonb_each_text</code> ( <code class="type">jsonb</code> ) → <code class="returnvalue">setof record</code> ( <em class="parameter"><code>key</code></em> <code class="type">text</code>, <em class="parameter"><code>value</code></em> <code class="type">text</code> )</p> <p>Expands the top-level JSON object into a set of key/value pairs. The returned <em class="parameter"><code>value</code></em>s will be of type <code class="type">text</code>.</p> <p><code class="literal">select * from json_each_text('{"a":"foo", "b":"bar"}')</code> →</p> <pre data-language="sql">
 key | value
-----+-------
 a   | foo
 b   | bar
</pre> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature" id="id-1.5.8.22.8.13.2.2.6.1.1.1"> <code class="function">json_extract_path</code> ( <em class="parameter"><code>from_json</code></em> <code class="type">json</code>, <code class="literal">VARIADIC</code> <em class="parameter"><code>path_elems</code></em> <code class="type">text[]</code> ) → <code class="returnvalue">json</code></p> <p class="func_signature" id="id-1.5.8.22.8.13.2.2.6.1.2.1"> <code class="function">jsonb_extract_path</code> ( <em class="parameter"><code>from_json</code></em> <code class="type">jsonb</code>, <code class="literal">VARIADIC</code> <em class="parameter"><code>path_elems</code></em> <code class="type">text[]</code> ) → <code class="returnvalue">jsonb</code></p> <p>Extracts JSON sub-object at the specified path. (This is functionally equivalent to the <code class="literal">#&gt;</code> operator, but writing the path out as a variadic list can be more convenient in some cases.)</p> <p><code class="literal">json_extract_path('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}', 'f4', 'f6')</code> → <code class="returnvalue">"foo"</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature" id="id-1.5.8.22.8.13.2.2.7.1.1.1"> <code class="function">json_extract_path_text</code> ( <em class="parameter"><code>from_json</code></em> <code class="type">json</code>, <code class="literal">VARIADIC</code> <em class="parameter"><code>path_elems</code></em> <code class="type">text[]</code> ) → <code class="returnvalue">text</code></p> <p class="func_signature" id="id-1.5.8.22.8.13.2.2.7.1.2.1"> <code class="function">jsonb_extract_path_text</code> ( <em class="parameter"><code>from_json</code></em> <code class="type">jsonb</code>, <code class="literal">VARIADIC</code> <em class="parameter"><code>path_elems</code></em> <code class="type">text[]</code> ) → <code class="returnvalue">text</code></p> <p>Extracts JSON sub-object at the specified path as <code class="type">text</code>. (This is functionally equivalent to the <code class="literal">#&gt;&gt;</code> operator.)</p> <p><code class="literal">json_extract_path_text('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}', 'f4', 'f6')</code> → <code class="returnvalue">foo</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature" id="id-1.5.8.22.8.13.2.2.8.1.1.1"> <code class="function">json_object_keys</code> ( <code class="type">json</code> ) → <code class="returnvalue">setof text</code></p> <p class="func_signature" id="id-1.5.8.22.8.13.2.2.8.1.2.1"> <code class="function">jsonb_object_keys</code> ( <code class="type">jsonb</code> ) → <code class="returnvalue">setof text</code></p> <p>Returns the set of keys in the top-level JSON object.</p> <p><code class="literal">select * from json_object_keys('{"f1":"abc","f2":{"f3":"a", "f4":"b"}}')</code> →</p> <pre data-language="sql">
 json_object_keys
------------------
 f1
 f2
</pre> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature" id="id-1.5.8.22.8.13.2.2.9.1.1.1"> <code class="function">json_populate_record</code> ( <em class="parameter"><code>base</code></em> <code class="type">anyelement</code>, <em class="parameter"><code>from_json</code></em> <code class="type">json</code> ) → <code class="returnvalue">anyelement</code></p> <p class="func_signature" id="id-1.5.8.22.8.13.2.2.9.1.2.1"> <code class="function">jsonb_populate_record</code> ( <em class="parameter"><code>base</code></em> <code class="type">anyelement</code>, <em class="parameter"><code>from_json</code></em> <code class="type">jsonb</code> ) → <code class="returnvalue">anyelement</code></p> <p>Expands the top-level JSON object to a row having the composite type of the <em class="parameter"><code>base</code></em> argument. The JSON object is scanned for fields whose names match column names of the output row type, and their values are inserted into those columns of the output. (Fields that do not correspond to any output column name are ignored.) In typical use, the value of <em class="parameter"><code>base</code></em> is just <code class="literal">NULL</code>, which means that any output columns that do not match any object field will be filled with nulls. However, if <em class="parameter"><code>base</code></em> isn't <code class="literal">NULL</code> then the values it contains will be used for unmatched columns.</p> <p>To convert a JSON value to the SQL type of an output column, the following rules are applied in sequence:</p>  <ul> <li> <p>A JSON null value is converted to an SQL null in all cases.</p> </li> <li> <p>If the output column is of type <code class="type">json</code> or <code class="type">jsonb</code>, the JSON value is just reproduced exactly.</p> </li> <li> <p>If the output column is a composite (row) type, and the JSON value is a JSON object, the fields of the object are converted to columns of the output row type by recursive application of these rules.</p> </li> <li> <p>Likewise, if the output column is an array type and the JSON value is a JSON array, the elements of the JSON array are converted to elements of the output array by recursive application of these rules.</p> </li> <li> <p>Otherwise, if the JSON value is a string, the contents of the string are fed to the input conversion function for the column's data type.</p> </li> <li> <p>Otherwise, the ordinary text representation of the JSON value is fed to the input conversion function for the column's data type.</p> </li> </ul>  <p>While the example below uses a constant JSON value, typical use would be to reference a <code class="type">json</code> or <code class="type">jsonb</code> column laterally from another table in the query's <code class="literal">FROM</code> clause. Writing <code class="function">json_populate_record</code> in the <code class="literal">FROM</code> clause is good practice, since all of the extracted columns are available for use without duplicate function calls.</p> <p><code class="literal">create type subrowtype as (d int, e text);</code> <code class="literal">create type myrowtype as (a int, b text[], c subrowtype);</code></p> <p><code class="literal">select * from json_populate_record(null::myrowtype, '{"a": 1, "b": ["2", "a b"], "c": {"d": 4, "e": "a b c"}, "x": "foo"}')</code> →</p> <pre data-language="sql">
 a |   b       |      c
---+-----------+-------------
 1 | {2,"a b"} | (4,"a b c")
</pre> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature" id="id-1.5.8.22.8.13.2.2.10.1.1.1"> <code class="function">jsonb_populate_record_valid</code> ( <em class="parameter"><code>base</code></em> <code class="type">anyelement</code>, <em class="parameter"><code>from_json</code></em> <code class="type">json</code> ) → <code class="returnvalue">boolean</code></p> <p>Function for testing <code class="function">jsonb_populate_record</code>. Returns <code class="literal">true</code> if the input <code class="function">jsonb_populate_record</code> would finish without an error for the given input JSON object; that is, it's valid input, <code class="literal">false</code> otherwise.</p> <p><code class="literal">create type jsb_char2 as (a char(2));</code></p> <p><code class="literal">select jsonb_populate_record_valid(NULL::jsb_char2, '{"a": "aaa"}');</code> →</p> <pre data-language="sql">
 jsonb_populate_record_valid
-----------------------------
 f
(1 row)
</pre> <p><code class="literal">select * from jsonb_populate_record(NULL::jsb_char2, '{"a": "aaa"}') q;</code> →</p> <pre data-language="sql">
ERROR:  value too long for type character(2)
</pre> <p><code class="literal">select jsonb_populate_record_valid(NULL::jsb_char2, '{"a": "aa"}');</code> →</p> <pre data-language="sql">
 jsonb_populate_record_valid
-----------------------------
 t
(1 row)
</pre> <p><code class="literal">select * from jsonb_populate_record(NULL::jsb_char2, '{"a": "aa"}') q;</code> →</p> <pre data-language="sql">
 a
----
 aa
(1 row)
</pre> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature" id="id-1.5.8.22.8.13.2.2.11.1.1.1"> <code class="function">json_populate_recordset</code> ( <em class="parameter"><code>base</code></em> <code class="type">anyelement</code>, <em class="parameter"><code>from_json</code></em> <code class="type">json</code> ) → <code class="returnvalue">setof anyelement</code></p> <p class="func_signature" id="id-1.5.8.22.8.13.2.2.11.1.2.1"> <code class="function">jsonb_populate_recordset</code> ( <em class="parameter"><code>base</code></em> <code class="type">anyelement</code>, <em class="parameter"><code>from_json</code></em> <code class="type">jsonb</code> ) → <code class="returnvalue">setof anyelement</code></p> <p>Expands the top-level JSON array of objects to a set of rows having the composite type of the <em class="parameter"><code>base</code></em> argument. Each element of the JSON array is processed as described above for <code class="function">json[b]_populate_record</code>.</p> <p><code class="literal">create type twoints as (a int, b int);</code></p> <p><code class="literal">select * from json_populate_recordset(null::twoints, '[{"a":1,"b":2}, {"a":3,"b":4}]')</code> →</p> <pre data-language="sql">
 a | b
---+---
 1 | 2
 3 | 4
</pre> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature" id="id-1.5.8.22.8.13.2.2.12.1.1.1"> <code class="function">json_to_record</code> ( <code class="type">json</code> ) → <code class="returnvalue">record</code></p> <p class="func_signature" id="id-1.5.8.22.8.13.2.2.12.1.2.1"> <code class="function">jsonb_to_record</code> ( <code class="type">jsonb</code> ) → <code class="returnvalue">record</code></p> <p>Expands the top-level JSON object to a row having the composite type defined by an <code class="literal">AS</code> clause. (As with all functions returning <code class="type">record</code>, the calling query must explicitly define the structure of the record with an <code class="literal">AS</code> clause.) The output record is filled from fields of the JSON object, in the same way as described above for <code class="function">json[b]_populate_record</code>. Since there is no input record value, unmatched columns are always filled with nulls.</p> <p><code class="literal">create type myrowtype as (a int, b text);</code></p> <p><code class="literal">select * from json_to_record('{"a":1,"b":[1,2,3],"c":[1,2,3],"e":"bar","r": {"a": 123, "b": "a b c"}}') as x(a int, b text, c int[], d text, r myrowtype)</code> →</p> <pre data-language="sql">
 a |    b    |    c    | d |       r
---+---------+---------+---+---------------
 1 | [1,2,3] | {1,2,3} |   | (123,"a b c")
</pre> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature" id="id-1.5.8.22.8.13.2.2.13.1.1.1"> <code class="function">json_to_recordset</code> ( <code class="type">json</code> ) → <code class="returnvalue">setof record</code></p> <p class="func_signature" id="id-1.5.8.22.8.13.2.2.13.1.2.1"> <code class="function">jsonb_to_recordset</code> ( <code class="type">jsonb</code> ) → <code class="returnvalue">setof record</code></p> <p>Expands the top-level JSON array of objects to a set of rows having the composite type defined by an <code class="literal">AS</code> clause. (As with all functions returning <code class="type">record</code>, the calling query must explicitly define the structure of the record with an <code class="literal">AS</code> clause.) Each element of the JSON array is processed as described above for <code class="function">json[b]_populate_record</code>.</p> <p><code class="literal">select * from json_to_recordset('[{"a":1,"b":"foo"}, {"a":"2","c":"bar"}]') as x(a int, b text)</code> →</p> <pre data-language="sql">
 a |  b
---+-----
 1 | foo
 2 |
</pre> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature" id="id-1.5.8.22.8.13.2.2.14.1.1.1"> <code class="function">jsonb_set</code> ( <em class="parameter"><code>target</code></em> <code class="type">jsonb</code>, <em class="parameter"><code>path</code></em> <code class="type">text[]</code>, <em class="parameter"><code>new_value</code></em> <code class="type">jsonb</code> [<span class="optional">, <em class="parameter"><code>create_if_missing</code></em> <code class="type">boolean</code></span> ] ) → <code class="returnvalue">jsonb</code></p> <p>Returns <em class="parameter"><code>target</code></em> with the item designated by <em class="parameter"><code>path</code></em> replaced by <em class="parameter"><code>new_value</code></em>, or with <em class="parameter"><code>new_value</code></em> added if <em class="parameter"><code>create_if_missing</code></em> is true (which is the default) and the item designated by <em class="parameter"><code>path</code></em> does not exist. All earlier steps in the path must exist, or the <em class="parameter"><code>target</code></em> is returned unchanged. As with the path oriented operators, negative integers that appear in the <em class="parameter"><code>path</code></em> count from the end of JSON arrays. If the last path step is an array index that is out of range, and <em class="parameter"><code>create_if_missing</code></em> is true, the new value is added at the beginning of the array if the index is negative, or at the end of the array if it is positive.</p> <p><code class="literal">jsonb_set('[{"f1":1,"f2":null},2,null,3]', '{0,f1}', '[2,3,4]', false)</code> → <code class="returnvalue">[{"f1": [2, 3, 4], "f2": null}, 2, null, 3]</code></p> <p><code class="literal">jsonb_set('[{"f1":1,"f2":null},2]', '{0,f3}', '[2,3,4]')</code> → <code class="returnvalue">[{"f1": 1, "f2": null, "f3": [2, 3, 4]}, 2]</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature" id="id-1.5.8.22.8.13.2.2.15.1.1.1"> <code class="function">jsonb_set_lax</code> ( <em class="parameter"><code>target</code></em> <code class="type">jsonb</code>, <em class="parameter"><code>path</code></em> <code class="type">text[]</code>, <em class="parameter"><code>new_value</code></em> <code class="type">jsonb</code> [<span class="optional">, <em class="parameter"><code>create_if_missing</code></em> <code class="type">boolean</code> [<span class="optional">, <em class="parameter"><code>null_value_treatment</code></em> <code class="type">text</code></span> ]</span>] ) → <code class="returnvalue">jsonb</code></p> <p>If <em class="parameter"><code>new_value</code></em> is not <code class="literal">NULL</code>, behaves identically to <code class="literal">jsonb_set</code>. Otherwise behaves according to the value of <em class="parameter"><code>null_value_treatment</code></em> which must be one of <code class="literal">'raise_exception'</code>, <code class="literal">'use_json_null'</code>, <code class="literal">'delete_key'</code>, or <code class="literal">'return_target'</code>. The default is <code class="literal">'use_json_null'</code>.</p> <p><code class="literal">jsonb_set_lax('[{"f1":1,"f2":null},2,null,3]', '{0,f1}', null)</code> → <code class="returnvalue">[{"f1": null, "f2": null}, 2, null, 3]</code></p> <p><code class="literal">jsonb_set_lax('[{"f1":99,"f2":null},2]', '{0,f3}', null, true, 'return_target')</code> → <code class="returnvalue">[{"f1": 99, "f2": null}, 2]</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature" id="id-1.5.8.22.8.13.2.2.16.1.1.1"> <code class="function">jsonb_insert</code> ( <em class="parameter"><code>target</code></em> <code class="type">jsonb</code>, <em class="parameter"><code>path</code></em> <code class="type">text[]</code>, <em class="parameter"><code>new_value</code></em> <code class="type">jsonb</code> [<span class="optional">, <em class="parameter"><code>insert_after</code></em> <code class="type">boolean</code></span> ] ) → <code class="returnvalue">jsonb</code></p> <p>Returns <em class="parameter"><code>target</code></em> with <em class="parameter"><code>new_value</code></em> inserted. If the item designated by the <em class="parameter"><code>path</code></em> is an array element, <em class="parameter"><code>new_value</code></em> will be inserted before that item if <em class="parameter"><code>insert_after</code></em> is false (which is the default), or after it if <em class="parameter"><code>insert_after</code></em> is true. If the item designated by the <em class="parameter"><code>path</code></em> is an object field, <em class="parameter"><code>new_value</code></em> will be inserted only if the object does not already contain that key. All earlier steps in the path must exist, or the <em class="parameter"><code>target</code></em> is returned unchanged. As with the path oriented operators, negative integers that appear in the <em class="parameter"><code>path</code></em> count from the end of JSON arrays. If the last path step is an array index that is out of range, the new value is added at the beginning of the array if the index is negative, or at the end of the array if it is positive.</p> <p><code class="literal">jsonb_insert('{"a": [0,1,2]}', '{a, 1}', '"new_value"')</code> → <code class="returnvalue">{"a": [0, "new_value", 1, 2]}</code></p> <p><code class="literal">jsonb_insert('{"a": [0,1,2]}', '{a, 1}', '"new_value"', true)</code> → <code class="returnvalue">{"a": [0, 1, "new_value", 2]}</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature" id="id-1.5.8.22.8.13.2.2.17.1.1.1"> <code class="function">json_strip_nulls</code> ( <code class="type">json</code> ) → <code class="returnvalue">json</code></p> <p class="func_signature" id="id-1.5.8.22.8.13.2.2.17.1.2.1"> <code class="function">jsonb_strip_nulls</code> ( <code class="type">jsonb</code> ) → <code class="returnvalue">jsonb</code></p> <p>Deletes all object fields that have null values from the given JSON value, recursively. Null values that are not object fields are untouched.</p> <p><code class="literal">json_strip_nulls('[{"f1":1, "f2":null}, 2, null, 3]')</code> → <code class="returnvalue">[{"f1":1},2,null,3]</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature" id="id-1.5.8.22.8.13.2.2.18.1.1.1"> <code class="function">jsonb_path_exists</code> ( <em class="parameter"><code>target</code></em> <code class="type">jsonb</code>, <em class="parameter"><code>path</code></em> <code class="type">jsonpath</code> [<span class="optional">, <em class="parameter"><code>vars</code></em> <code class="type">jsonb</code> [<span class="optional">, <em class="parameter"><code>silent</code></em> <code class="type">boolean</code></span> ]</span>] ) → <code class="returnvalue">boolean</code></p> <p>Checks whether the JSON path returns any item for the specified JSON value. (This is useful only with SQL-standard JSON path expressions, not <a class="link" href="functions-json.html#FUNCTIONS-SQLJSON-CHECK-EXPRESSIONS" title="9.16.2.1.1. Boolean Predicate Check Expressions">predicate check expressions</a>, since those always return a value.) If the <em class="parameter"><code>vars</code></em> argument is specified, it must be a JSON object, and its fields provide named values to be substituted into the <code class="type">jsonpath</code> expression. If the <em class="parameter"><code>silent</code></em> argument is specified and is <code class="literal">true</code>, the function suppresses the same errors as the <code class="literal">@?</code> and <code class="literal">@@</code> operators do.</p> <p><code class="literal">jsonb_path_exists('{"a":[1,2,3,4,5]}', '$.a[*] ? (@ &gt;= $min &amp;&amp; @ &lt;= $max)', '{"min":2, "max":4}')</code> → <code class="returnvalue">t</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature" id="id-1.5.8.22.8.13.2.2.19.1.1.1"> <code class="function">jsonb_path_match</code> ( <em class="parameter"><code>target</code></em> <code class="type">jsonb</code>, <em class="parameter"><code>path</code></em> <code class="type">jsonpath</code> [<span class="optional">, <em class="parameter"><code>vars</code></em> <code class="type">jsonb</code> [<span class="optional">, <em class="parameter"><code>silent</code></em> <code class="type">boolean</code></span> ]</span>] ) → <code class="returnvalue">boolean</code></p> <p>Returns the result of a JSON path predicate check for the specified JSON value. (This is useful only with <a class="link" href="functions-json.html#FUNCTIONS-SQLJSON-CHECK-EXPRESSIONS" title="9.16.2.1.1. Boolean Predicate Check Expressions">predicate check expressions</a>, not SQL-standard JSON path expressions, since it will either fail or return <code class="literal">NULL</code> if the path result is not a single boolean value.) The optional <em class="parameter"><code>vars</code></em> and <em class="parameter"><code>silent</code></em> arguments act the same as for <code class="function">jsonb_path_exists</code>.</p> <p><code class="literal">jsonb_path_match('{"a":[1,2,3,4,5]}', 'exists($.a[*] ? (@ &gt;= $min &amp;&amp; @ &lt;= $max))', '{"min":2, "max":4}')</code> → <code class="returnvalue">t</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature" id="id-1.5.8.22.8.13.2.2.20.1.1.1"> <code class="function">jsonb_path_query</code> ( <em class="parameter"><code>target</code></em> <code class="type">jsonb</code>, <em class="parameter"><code>path</code></em> <code class="type">jsonpath</code> [<span class="optional">, <em class="parameter"><code>vars</code></em> <code class="type">jsonb</code> [<span class="optional">, <em class="parameter"><code>silent</code></em> <code class="type">boolean</code></span> ]</span>] ) → <code class="returnvalue">setof jsonb</code></p> <p>Returns all JSON items returned by the JSON path for the specified JSON value. For SQL-standard JSON path expressions it returns the JSON values selected from <em class="parameter"><code>target</code></em>. For <a class="link" href="functions-json.html#FUNCTIONS-SQLJSON-CHECK-EXPRESSIONS" title="9.16.2.1.1. Boolean Predicate Check Expressions">predicate check expressions</a> it returns the result of the predicate check: <code class="literal">true</code>, <code class="literal">false</code>, or <code class="literal">null</code>. The optional <em class="parameter"><code>vars</code></em> and <em class="parameter"><code>silent</code></em> arguments act the same as for <code class="function">jsonb_path_exists</code>.</p> <p><code class="literal">select * from jsonb_path_query('{"a":[1,2,3,4,5]}', '$.a[*] ? (@ &gt;= $min &amp;&amp; @ &lt;= $max)', '{"min":2, "max":4}')</code> →</p> <pre data-language="sql">
 jsonb_path_query
------------------
 2
 3
 4
</pre> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature" id="id-1.5.8.22.8.13.2.2.21.1.1.1"> <code class="function">jsonb_path_query_array</code> ( <em class="parameter"><code>target</code></em> <code class="type">jsonb</code>, <em class="parameter"><code>path</code></em> <code class="type">jsonpath</code> [<span class="optional">, <em class="parameter"><code>vars</code></em> <code class="type">jsonb</code> [<span class="optional">, <em class="parameter"><code>silent</code></em> <code class="type">boolean</code></span> ]</span>] ) → <code class="returnvalue">jsonb</code></p> <p>Returns all JSON items returned by the JSON path for the specified JSON value, as a JSON array. The parameters are the same as for <code class="function">jsonb_path_query</code>.</p> <p><code class="literal">jsonb_path_query_array('{"a":[1,2,3,4,5]}', '$.a[*] ? (@ &gt;= $min &amp;&amp; @ &lt;= $max)', '{"min":2, "max":4}')</code> → <code class="returnvalue">[2, 3, 4]</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature" id="id-1.5.8.22.8.13.2.2.22.1.1.1"> <code class="function">jsonb_path_query_first</code> ( <em class="parameter"><code>target</code></em> <code class="type">jsonb</code>, <em class="parameter"><code>path</code></em> <code class="type">jsonpath</code> [<span class="optional">, <em class="parameter"><code>vars</code></em> <code class="type">jsonb</code> [<span class="optional">, <em class="parameter"><code>silent</code></em> <code class="type">boolean</code></span> ]</span>] ) → <code class="returnvalue">jsonb</code></p> <p>Returns the first JSON item returned by the JSON path for the specified JSON value, or <code class="literal">NULL</code> if there are no results. The parameters are the same as for <code class="function">jsonb_path_query</code>.</p> <p><code class="literal">jsonb_path_query_first('{"a":[1,2,3,4,5]}', '$.a[*] ? (@ &gt;= $min &amp;&amp; @ &lt;= $max)', '{"min":2, "max":4}')</code> → <code class="returnvalue">2</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature" id="id-1.5.8.22.8.13.2.2.23.1.1.1"> <code class="function">jsonb_path_exists_tz</code> ( <em class="parameter"><code>target</code></em> <code class="type">jsonb</code>, <em class="parameter"><code>path</code></em> <code class="type">jsonpath</code> [<span class="optional">, <em class="parameter"><code>vars</code></em> <code class="type">jsonb</code> [<span class="optional">, <em class="parameter"><code>silent</code></em> <code class="type">boolean</code></span> ]</span>] ) → <code class="returnvalue">boolean</code></p> <p class="func_signature" id="id-1.5.8.22.8.13.2.2.23.1.2.1"> <code class="function">jsonb_path_match_tz</code> ( <em class="parameter"><code>target</code></em> <code class="type">jsonb</code>, <em class="parameter"><code>path</code></em> <code class="type">jsonpath</code> [<span class="optional">, <em class="parameter"><code>vars</code></em> <code class="type">jsonb</code> [<span class="optional">, <em class="parameter"><code>silent</code></em> <code class="type">boolean</code></span> ]</span>] ) → <code class="returnvalue">boolean</code></p> <p class="func_signature" id="id-1.5.8.22.8.13.2.2.23.1.3.1"> <code class="function">jsonb_path_query_tz</code> ( <em class="parameter"><code>target</code></em> <code class="type">jsonb</code>, <em class="parameter"><code>path</code></em> <code class="type">jsonpath</code> [<span class="optional">, <em class="parameter"><code>vars</code></em> <code class="type">jsonb</code> [<span class="optional">, <em class="parameter"><code>silent</code></em> <code class="type">boolean</code></span> ]</span>] ) → <code class="returnvalue">setof jsonb</code></p> <p class="func_signature" id="id-1.5.8.22.8.13.2.2.23.1.4.1"> <code class="function">jsonb_path_query_array_tz</code> ( <em class="parameter"><code>target</code></em> <code class="type">jsonb</code>, <em class="parameter"><code>path</code></em> <code class="type">jsonpath</code> [<span class="optional">, <em class="parameter"><code>vars</code></em> <code class="type">jsonb</code> [<span class="optional">, <em class="parameter"><code>silent</code></em> <code class="type">boolean</code></span> ]</span>] ) → <code class="returnvalue">jsonb</code></p> <p class="func_signature" id="id-1.5.8.22.8.13.2.2.23.1.5.1"> <code class="function">jsonb_path_query_first_tz</code> ( <em class="parameter"><code>target</code></em> <code class="type">jsonb</code>, <em class="parameter"><code>path</code></em> <code class="type">jsonpath</code> [<span class="optional">, <em class="parameter"><code>vars</code></em> <code class="type">jsonb</code> [<span class="optional">, <em class="parameter"><code>silent</code></em> <code class="type">boolean</code></span> ]</span>] ) → <code class="returnvalue">jsonb</code></p> <p>These functions act like their counterparts described above without the <code class="literal">_tz</code> suffix, except that these functions support comparisons of date/time values that require timezone-aware conversions. The example below requires interpretation of the date-only value <code class="literal">2015-08-02</code> as a timestamp with time zone, so the result depends on the current <a class="xref" href="runtime-config-client.html#GUC-TIMEZONE">TimeZone</a> setting. Due to this dependency, these functions are marked as stable, which means these functions cannot be used in indexes. Their counterparts are immutable, and so can be used in indexes; but they will throw errors if asked to make such comparisons.</p> <p><code class="literal">jsonb_path_exists_tz('["2015-08-01 12:00:00-05"]', '$[*] ? (@.datetime() &lt; "2015-08-02".datetime())')</code> → <code class="returnvalue">t</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature" id="id-1.5.8.22.8.13.2.2.24.1.1.1"> <code class="function">jsonb_pretty</code> ( <code class="type">jsonb</code> ) → <code class="returnvalue">text</code></p> <p>Converts the given JSON value to pretty-printed, indented text.</p> <p><code class="literal">jsonb_pretty('[{"f1":1,"f2":null}, 2]')</code> →</p> <pre data-language="sql">
[
    {
        "f1": 1,
        "f2": null
    },
    2
]
</pre> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature" id="id-1.5.8.22.8.13.2.2.25.1.1.1"> <code class="function">json_typeof</code> ( <code class="type">json</code> ) → <code class="returnvalue">text</code></p> <p class="func_signature" id="id-1.5.8.22.8.13.2.2.25.1.2.1"> <code class="function">jsonb_typeof</code> ( <code class="type">jsonb</code> ) → <code class="returnvalue">text</code></p> <p>Returns the type of the top-level JSON value as a text string. Possible types are <code class="literal">object</code>, <code class="literal">array</code>, <code class="literal">string</code>, <code class="literal">number</code>, <code class="literal">boolean</code>, and <code class="literal">null</code>. (The <code class="literal">null</code> result should not be confused with an SQL NULL; see the examples.)</p> <p><code class="literal">json_typeof('-123.4')</code> → <code class="returnvalue">number</code></p> <p><code class="literal">json_typeof('null'::json)</code> → <code class="returnvalue">null</code></p> <p><code class="literal">json_typeof(NULL::json) IS NULL</code> → <code class="returnvalue">t</code></p> </td> </tr> </tbody> </table> </div> </div> </div> <div class="sect2" id="id-1.5.8.22.9.2">    <h2 class="title">9.16.2. The SQL/JSON Path Language </h2>    <p>SQL/JSON path expressions specify item(s) to be retrieved from a JSON value, similarly to XPath expressions used for access to XML content. In PostgreSQL, path expressions are implemented as the <code class="type">jsonpath</code> data type and can use any elements described in <a class="xref" href="datatype-json.html#DATATYPE-JSONPATH" title="8.14.7. jsonpath Type">Section 8.14.7</a>.</p> <p>JSON query functions and operators pass the provided path expression to the <em class="firstterm">path engine</em> for evaluation. If the expression matches the queried JSON data, the corresponding JSON item, or set of items, is returned. If there is no match, the result will be <code class="literal">NULL</code>, <code class="literal">false</code>, or an error, depending on the function. Path expressions are written in the SQL/JSON path language and can include arithmetic expressions and functions.</p> <p>A path expression consists of a sequence of elements allowed by the <code class="type">jsonpath</code> data type. The path expression is normally evaluated from left to right, but you can use parentheses to change the order of operations. If the evaluation is successful, a sequence of JSON items is produced, and the evaluation result is returned to the JSON query function that completes the specified computation.</p> <p>To refer to the JSON value being queried (the <em class="firstterm">context item</em>), use the <code class="literal">$</code> variable in the path expression. The first element of a path must always be <code class="literal">$</code>. It can be followed by one or more <a class="link" href="datatype-json.html#TYPE-JSONPATH-ACCESSORS" title="Table 8.25. jsonpath Accessors">accessor operators</a>, which go down the JSON structure level by level to retrieve sub-items of the context item. Each accessor operator acts on the result(s) of the previous evaluation step, producing zero, one, or more output items from each input item.</p> <p>For example, suppose you have some JSON data from a GPS tracker that you would like to parse, such as:</p> <pre data-language="sql">
SELECT '{
  "track": {
    "segments": [
      {
        "location":   [ 47.763, 13.4034 ],
        "start time": "2018-10-14 10:05:14",
        "HR": 73
      },
      {
        "location":   [ 47.706, 13.2635 ],
        "start time": "2018-10-14 10:39:21",
        "HR": 135
      }
    ]
  }
}' AS json \gset
</pre> <p>(The above example can be copied-and-pasted into psql to set things up for the following examples. Then psql will expand <code class="literal">:'json'</code> into a suitably-quoted string constant containing the JSON value.)</p> <p>To retrieve the available track segments, you need to use the <code class="literal">.key</code> accessor operator to descend through surrounding JSON objects, for example:</p> <pre>
=&gt; <strong class="userinput">select jsonb_path_query(:'json', '$.track.segments');</strong>
                                                                         jsonb_path_query
-----------------------------------------------------------​-----------------------------------------------------------​---------------------------------------------
 [{"HR": 73, "location": [47.763, 13.4034], "start time": "2018-10-14 10:05:14"}, {"HR": 135, "location": [47.706, 13.2635], "start time": "2018-10-14 10:39:21"}]
</pre> <p>To retrieve the contents of an array, you typically use the <code class="literal">[*]</code> operator. The following example will return the location coordinates for all the available track segments:</p> <pre>
=&gt; <strong class="userinput">select jsonb_path_query(:'json', '$.track.segments[*].location');</strong>
 jsonb_path_query
-------------------
 [47.763, 13.4034]
 [47.706, 13.2635]
</pre> <p>Here we started with the whole JSON input value (<code class="literal">$</code>), then the <code class="literal">.track</code> accessor selected the JSON object associated with the <code class="literal">"track"</code> object key, then the <code class="literal">.segments</code> accessor selected the JSON array associated with the <code class="literal">"segments"</code> key within that object, then the <code class="literal">[*]</code> accessor selected each element of that array (producing a series of items), then the <code class="literal">.location</code> accessor selected the JSON array associated with the <code class="literal">"location"</code> key within each of those objects. In this example, each of those objects had a <code class="literal">"location"</code> key; but if any of them did not, the <code class="literal">.location</code> accessor would have simply produced no output for that input item.</p> <p>To return the coordinates of the first segment only, you can specify the corresponding subscript in the <code class="literal">[]</code> accessor operator. Recall that JSON array indexes are 0-relative:</p> <pre>
=&gt; <strong class="userinput">select jsonb_path_query(:'json', '$.track.segments[0].location');</strong>
 jsonb_path_query
-------------------
 [47.763, 13.4034]
</pre> <p>The result of each path evaluation step can be processed by one or more of the <code class="type">jsonpath</code> operators and methods listed in <a class="xref" href="functions-json.html#FUNCTIONS-SQLJSON-PATH-OPERATORS" title="9.16.2.3. SQL/JSON Path Operators and Methods">Section 9.16.2.3</a>. Each method name must be preceded by a dot. For example, you can get the size of an array:</p> <pre>
=&gt; <strong class="userinput">select jsonb_path_query(:'json', '$.track.segments.size()');</strong>
 jsonb_path_query
------------------
 2
</pre> <p>More examples of using <code class="type">jsonpath</code> operators and methods within path expressions appear below in <a class="xref" href="functions-json.html#FUNCTIONS-SQLJSON-PATH-OPERATORS" title="9.16.2.3. SQL/JSON Path Operators and Methods">Section 9.16.2.3</a>.</p> <p>A path can also contain <em class="firstterm">filter expressions</em> that work similarly to the <code class="literal">WHERE</code> clause in SQL. A filter expression begins with a question mark and provides a condition in parentheses:</p> <pre data-language="sql">
? (condition)
</pre> <p>Filter expressions must be written just after the path evaluation step to which they should apply. The result of that step is filtered to include only those items that satisfy the provided condition. SQL/JSON defines three-valued logic, so the condition can produce <code class="literal">true</code>, <code class="literal">false</code>, or <code class="literal">unknown</code>. The <code class="literal">unknown</code> value plays the same role as SQL <code class="literal">NULL</code> and can be tested for with the <code class="literal">is unknown</code> predicate. Further path evaluation steps use only those items for which the filter expression returned <code class="literal">true</code>.</p> <p>The functions and operators that can be used in filter expressions are listed in <a class="xref" href="functions-json.html#FUNCTIONS-SQLJSON-FILTER-EX-TABLE" title="Table 9.51. jsonpath Filter Expression Elements">Table 9.51</a>. Within a filter expression, the <code class="literal">@</code> variable denotes the value being considered (i.e., one result of the preceding path step). You can write accessor operators after <code class="literal">@</code> to retrieve component items.</p> <p>For example, suppose you would like to retrieve all heart rate values higher than 130. You can achieve this as follows:</p> <pre>
=&gt; <strong class="userinput">select jsonb_path_query(:'json', '$.track.segments[*].HR ? (@ &gt; 130)');</strong>
 jsonb_path_query
------------------
 135
</pre> <p>To get the start times of segments with such values, you have to filter out irrelevant segments before selecting the start times, so the filter expression is applied to the previous step, and the path used in the condition is different:</p> <pre>
=&gt; <strong class="userinput">select jsonb_path_query(:'json', '$.track.segments[*] ? (@.HR &gt; 130)."start time"');</strong>
   jsonb_path_query
-----------------------
 "2018-10-14 10:39:21"
</pre> <p>You can use several filter expressions in sequence, if required. The following example selects start times of all segments that contain locations with relevant coordinates and high heart rate values:</p> <pre>
=&gt; <strong class="userinput">select jsonb_path_query(:'json', '$.track.segments[*] ? (@.location[1] &lt; 13.4) ? (@.HR &gt; 130)."start time"');</strong>
   jsonb_path_query
-----------------------
 "2018-10-14 10:39:21"
</pre> <p>Using filter expressions at different nesting levels is also allowed. The following example first filters all segments by location, and then returns high heart rate values for these segments, if available:</p> <pre>
=&gt; <strong class="userinput">select jsonb_path_query(:'json', '$.track.segments[*] ? (@.location[1] &lt; 13.4).HR ? (@ &gt; 130)');</strong>
 jsonb_path_query
------------------
 135
</pre> <p>You can also nest filter expressions within each other. This example returns the size of the track if it contains any segments with high heart rate values, or an empty sequence otherwise:</p> <pre>
=&gt; <strong class="userinput">select jsonb_path_query(:'json', '$.track ? (exists(@.segments[*] ? (@.HR &gt; 130))).segments.size()');</strong>
 jsonb_path_query
------------------
 2
</pre> <div class="sect3" id="FUNCTIONS-SQLJSON-DEVIATIONS">    <h3 class="title">9.16.2.1. Deviations from the SQL Standard </h3>    <p>PostgreSQL's implementation of the SQL/JSON path language has the following deviations from the SQL/JSON standard.</p> <div class="sect4" id="FUNCTIONS-SQLJSON-CHECK-EXPRESSIONS">    <h5 class="title">9.16.2.1.1. Boolean Predicate Check Expressions </h5>    <p>As an extension to the SQL standard, a PostgreSQL path expression can be a Boolean predicate, whereas the SQL standard allows predicates only within filters. While SQL-standard path expressions return the relevant element(s) of the queried JSON value, predicate check expressions return the single three-valued result of the predicate: <code class="literal">true</code>, <code class="literal">false</code>, or <code class="literal">unknown</code>. For example, we could write this SQL-standard filter expression:</p> <pre>
=&gt; <strong class="userinput">select jsonb_path_query(:'json', '$.track.segments ?(@[*].HR &gt; 130)');</strong>
                                jsonb_path_query
-----------------------------------------------------------​----------------------
 {"HR": 135, "location": [47.706, 13.2635], "start time": "2018-10-14 10:39:21"}
</pre> <p>The similar predicate check expression simply returns <code class="literal">true</code>, indicating that a match exists:</p> <pre>
=&gt; <strong class="userinput">select jsonb_path_query(:'json', '$.track.segments[*].HR &gt; 130');</strong>
 jsonb_path_query
------------------
 true
</pre> <blockquote class="note"> <h3 class="title">Note</h3> <p>Predicate check expressions are required in the <code class="literal">@@</code> operator (and the <code class="function">jsonb_path_match</code> function), and should not be used with the <code class="literal">@?</code> operator (or the <code class="function">jsonb_path_exists</code> function).</p> </blockquote> </div> <div class="sect4" id="FUNCTIONS-SQLJSON-REGULAR-EXPRESSION-DEVIATION">    <h5 class="title">9.16.2.1.2. Regular Expression Interpretation </h5>    <p>There are minor differences in the interpretation of regular expression patterns used in <code class="literal">like_regex</code> filters, as described in <a class="xref" href="functions-json.html#JSONPATH-REGULAR-EXPRESSIONS" title="9.16.2.4. SQL/JSON Regular Expressions">Section 9.16.2.4</a>.</p> </div> </div> <div class="sect3" id="FUNCTIONS-SQLJSON-STRICT-AND-LAX-MODES">    <h3 class="title">9.16.2.2. Strict and Lax Modes </h3>    <p>When you query JSON data, the path expression may not match the actual JSON data structure. An attempt to access a non-existent member of an object or element of an array is defined as a structural error. SQL/JSON path expressions have two modes of handling structural errors:</p>  <ul> <li> <p>lax (default) — the path engine implicitly adapts the queried data to the specified path. Any structural errors that cannot be fixed as described below are suppressed, producing no match.</p> </li> <li> <p>strict — if a structural error occurs, an error is raised.</p> </li> </ul>  <p>Lax mode facilitates matching of a JSON document and path expression when the JSON data does not conform to the expected schema. If an operand does not match the requirements of a particular operation, it can be automatically wrapped as an SQL/JSON array, or unwrapped by converting its elements into an SQL/JSON sequence before performing the operation. Also, comparison operators automatically unwrap their operands in lax mode, so you can compare SQL/JSON arrays out-of-the-box. An array of size 1 is considered equal to its sole element. Automatic unwrapping is not performed when:</p>  <ul> <li> <p>The path expression contains <code class="literal">type()</code> or <code class="literal">size()</code> methods that return the type and the number of elements in the array, respectively.</p> </li> <li> <p>The queried JSON data contain nested arrays. In this case, only the outermost array is unwrapped, while all the inner arrays remain unchanged. Thus, implicit unwrapping can only go one level down within each path evaluation step.</p> </li> </ul>  <p>For example, when querying the GPS data listed above, you can abstract from the fact that it stores an array of segments when using lax mode:</p> <pre>
=&gt; <strong class="userinput">select jsonb_path_query(:'json', 'lax $.track.segments.location');</strong>
 jsonb_path_query
-------------------
 [47.763, 13.4034]
 [47.706, 13.2635]
</pre> <p>In strict mode, the specified path must exactly match the structure of the queried JSON document, so using this path expression will cause an error:</p> <pre>
=&gt; <strong class="userinput">select jsonb_path_query(:'json', 'strict $.track.segments.location');</strong>
ERROR:  jsonpath member accessor can only be applied to an object
</pre> <p>To get the same result as in lax mode, you have to explicitly unwrap the <code class="literal">segments</code> array:</p> <pre>
=&gt; <strong class="userinput">select jsonb_path_query(:'json', 'strict $.track.segments[*].location');</strong>
 jsonb_path_query
-------------------
 [47.763, 13.4034]
 [47.706, 13.2635]
</pre> <p>The unwrapping behavior of lax mode can lead to surprising results. For instance, the following query using the <code class="literal">.**</code> accessor selects every <code class="literal">HR</code> value twice:</p> <pre>
=&gt; <strong class="userinput">select jsonb_path_query(:'json', 'lax $.**.HR');</strong>
 jsonb_path_query
------------------
 73
 135
 73
 135
</pre> <p>This happens because the <code class="literal">.**</code> accessor selects both the <code class="literal">segments</code> array and each of its elements, while the <code class="literal">.HR</code> accessor automatically unwraps arrays when using lax mode. To avoid surprising results, we recommend using the <code class="literal">.**</code> accessor only in strict mode. The following query selects each <code class="literal">HR</code> value just once:</p> <pre>
=&gt; <strong class="userinput">select jsonb_path_query(:'json', 'strict $.**.HR');</strong>
 jsonb_path_query
------------------
 73
 135
</pre> <p>The unwrapping of arrays can also lead to unexpected results. Consider this example, which selects all the <code class="literal">location</code> arrays:</p> <pre>
=&gt; <strong class="userinput">select jsonb_path_query(:'json', 'lax $.track.segments[*].location');</strong>
 jsonb_path_query
-------------------
 [47.763, 13.4034]
 [47.706, 13.2635]
(2 rows)
</pre> <p>As expected it returns the full arrays. But applying a filter expression causes the arrays to be unwrapped to evaluate each item, returning only the items that match the expression:</p> <pre>
=&gt; <strong class="userinput">select jsonb_path_query(:'json', 'lax $.track.segments[*].location ?(@[*] &gt; 15)');</strong>
 jsonb_path_query
------------------
 47.763
 47.706
(2 rows)
</pre> <p>This despite the fact that the full arrays are selected by the path expression. Use strict mode to restore selecting the arrays:</p> <pre>
=&gt; <strong class="userinput">select jsonb_path_query(:'json', 'strict $.track.segments[*].location ?(@[*] &gt; 15)');</strong>
 jsonb_path_query
-------------------
 [47.763, 13.4034]
 [47.706, 13.2635]
(2 rows)
</pre> </div> <div class="sect3" id="FUNCTIONS-SQLJSON-PATH-OPERATORS">    <h3 class="title">9.16.2.3. SQL/JSON Path Operators and Methods </h3>    <p><a class="xref" href="functions-json.html#FUNCTIONS-SQLJSON-OP-TABLE" title="Table 9.50. jsonpath Operators and Methods">Table 9.50</a> shows the operators and methods available in <code class="type">jsonpath</code>. Note that while the unary operators and methods can be applied to multiple values resulting from a preceding path step, the binary operators (addition etc.) can only be applied to single values. In lax mode, methods applied to an array will be executed for each value in the array. The exceptions are <code class="literal">.type()</code> and <code class="literal">.size()</code>, which apply to the array itself.</p> <div class="table" id="FUNCTIONS-SQLJSON-OP-TABLE"> <p class="title"><strong>Table 9.50. <code class="type">jsonpath</code> Operators and Methods</strong></p> <div class="table-contents"> <table class="table" summary="jsonpath Operators and Methods"> <colgroup> <col> </colgroup> <thead> <tr> <th class="func_table_entry"> <p class="func_signature">Operator/Method</p> <p>Description</p> <p>Example(s)</p> </th> </tr> </thead> <tbody> <tr> <td class="func_table_entry"> <p class="func_signature"><code>number</code> <code class="literal">+</code> <code>number</code> → <code class="returnvalue">number</code></p> <p>Addition</p> <p><code class="literal">jsonb_path_query('[2]', '$[0] + 3')</code> → <code class="returnvalue">5</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code class="literal">+</code> <code>number</code> → <code class="returnvalue">number</code></p> <p>Unary plus (no operation); unlike addition, this can iterate over multiple values</p> <p><code class="literal">jsonb_path_query_array('{"x": [2,3,4]}', '+ $.x')</code> → <code class="returnvalue">[2, 3, 4]</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code>number</code> <code class="literal">-</code> <code>number</code> → <code class="returnvalue">number</code></p> <p>Subtraction</p> <p><code class="literal">jsonb_path_query('[2]', '7 - $[0]')</code> → <code class="returnvalue">5</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code class="literal">-</code> <code>number</code> → <code class="returnvalue">number</code></p> <p>Negation; unlike subtraction, this can iterate over multiple values</p> <p><code class="literal">jsonb_path_query_array('{"x": [2,3,4]}', '- $.x')</code> → <code class="returnvalue">[-2, -3, -4]</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code>number</code> <code class="literal">*</code> <code>number</code> → <code class="returnvalue">number</code></p> <p>Multiplication</p> <p><code class="literal">jsonb_path_query('[4]', '2 * $[0]')</code> → <code class="returnvalue">8</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code>number</code> <code class="literal">/</code> <code>number</code> → <code class="returnvalue">number</code></p> <p>Division</p> <p><code class="literal">jsonb_path_query('[8.5]', '$[0] / 2')</code> → <code class="returnvalue">4.2500000000000000</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code>number</code> <code class="literal">%</code> <code>number</code> → <code class="returnvalue">number</code></p> <p>Modulo (remainder)</p> <p><code class="literal">jsonb_path_query('[32]', '$[0] % 10')</code> → <code class="returnvalue">2</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code>value</code> <code class="literal">.</code> <code class="literal">type()</code> → <code class="returnvalue">string</code></p> <p>Type of the JSON item (see <code class="function">json_typeof</code>)</p> <p><code class="literal">jsonb_path_query_array('[1, "2", {}]', '$[*].type()')</code> → <code class="returnvalue">["number", "string", "object"]</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code>value</code> <code class="literal">.</code> <code class="literal">size()</code> → <code class="returnvalue">number</code></p> <p>Size of the JSON item (number of array elements, or 1 if not an array)</p> <p><code class="literal">jsonb_path_query('{"m": [11, 15]}', '$.m.size()')</code> → <code class="returnvalue">2</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code>value</code> <code class="literal">.</code> <code class="literal">boolean()</code> → <code class="returnvalue">boolean</code></p> <p>Boolean value converted from a JSON boolean, number, or string</p> <p><code class="literal">jsonb_path_query_array('[1, "yes", false]', '$[*].boolean()')</code> → <code class="returnvalue">[true, true, false]</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code>value</code> <code class="literal">.</code> <code class="literal">string()</code> → <code class="returnvalue">string</code></p> <p>String value converted from a JSON boolean, number, string, or datetime</p> <p><code class="literal">jsonb_path_query_array('[1.23, "xyz", false]', '$[*].string()')</code> → <code class="returnvalue">["1.23", "xyz", "false"]</code></p> <p><code class="literal">jsonb_path_query('"2023-08-15 12:34:56"', '$.timestamp().string()')</code> → <code class="returnvalue">"2023-08-15T12:34:56"</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code>value</code> <code class="literal">.</code> <code class="literal">double()</code> → <code class="returnvalue">number</code></p> <p>Approximate floating-point number converted from a JSON number or string</p> <p><code class="literal">jsonb_path_query('{"len": "1.9"}', '$.len.double() * 2')</code> → <code class="returnvalue">3.8</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code>number</code> <code class="literal">.</code> <code class="literal">ceiling()</code> → <code class="returnvalue">number</code></p> <p>Nearest integer greater than or equal to the given number</p> <p><code class="literal">jsonb_path_query('{"h": 1.3}', '$.h.ceiling()')</code> → <code class="returnvalue">2</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code>number</code> <code class="literal">.</code> <code class="literal">floor()</code> → <code class="returnvalue">number</code></p> <p>Nearest integer less than or equal to the given number</p> <p><code class="literal">jsonb_path_query('{"h": 1.7}', '$.h.floor()')</code> → <code class="returnvalue">1</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code>number</code> <code class="literal">.</code> <code class="literal">abs()</code> → <code class="returnvalue">number</code></p> <p>Absolute value of the given number</p> <p><code class="literal">jsonb_path_query('{"z": -0.3}', '$.z.abs()')</code> → <code class="returnvalue">0.3</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code>value</code> <code class="literal">.</code> <code class="literal">bigint()</code> → <code class="returnvalue">bigint</code></p> <p>Big integer value converted from a JSON number or string</p> <p><code class="literal">jsonb_path_query('{"len": "9876543219"}', '$.len.bigint()')</code> → <code class="returnvalue">9876543219</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code>value</code> <code class="literal">.</code> <code class="literal">decimal( [ precision [ , scale ] ] )</code> → <code class="returnvalue">decimal</code></p> <p>Rounded decimal value converted from a JSON number or string (<code class="literal">precision</code> and <code class="literal">scale</code> must be integer values)</p> <p><code class="literal">jsonb_path_query('1234.5678', '$.decimal(6, 2)')</code> → <code class="returnvalue">1234.57</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code>value</code> <code class="literal">.</code> <code class="literal">integer()</code> → <code class="returnvalue">integer</code></p> <p>Integer value converted from a JSON number or string</p> <p><code class="literal">jsonb_path_query('{"len": "12345"}', '$.len.integer()')</code> → <code class="returnvalue">12345</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code>value</code> <code class="literal">.</code> <code class="literal">number()</code> → <code class="returnvalue">numeric</code></p> <p>Numeric value converted from a JSON number or string</p> <p><code class="literal">jsonb_path_query('{"len": "123.45"}', '$.len.number()')</code> → <code class="returnvalue">123.45</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code>string</code> <code class="literal">.</code> <code class="literal">datetime()</code> → <code class="returnvalue">datetime_type</code> (see note)</p> <p>Date/time value converted from a string</p> <p><code class="literal">jsonb_path_query('["2015-8-1", "2015-08-12"]', '$[*] ? (@.datetime() &lt; "2015-08-2".datetime())')</code> → <code class="returnvalue">"2015-8-1"</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code>string</code> <code class="literal">.</code> <code class="literal">datetime(template)</code> → <code class="returnvalue">datetime_type</code> (see note)</p> <p>Date/time value converted from a string using the specified <code class="function">to_timestamp</code> template</p> <p><code class="literal">jsonb_path_query_array('["12:30", "18:40"]', '$[*].datetime("HH24:MI")')</code> → <code class="returnvalue">["12:30:00", "18:40:00"]</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code>string</code> <code class="literal">.</code> <code class="literal">date()</code> → <code class="returnvalue">date</code></p> <p>Date value converted from a string</p> <p><code class="literal">jsonb_path_query('"2023-08-15"', '$.date()')</code> → <code class="returnvalue">"2023-08-15"</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code>string</code> <code class="literal">.</code> <code class="literal">time()</code> → <code class="returnvalue">time without time zone</code></p> <p>Time without time zone value converted from a string</p> <p><code class="literal">jsonb_path_query('"12:34:56"', '$.time()')</code> → <code class="returnvalue">"12:34:56"</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code>string</code> <code class="literal">.</code> <code class="literal">time(precision)</code> → <code class="returnvalue">time without time zone</code></p> <p>Time without time zone value converted from a string, with fractional seconds adjusted to the given precision</p> <p><code class="literal">jsonb_path_query('"12:34:56.789"', '$.time(2)')</code> → <code class="returnvalue">"12:34:56.79"</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code>string</code> <code class="literal">.</code> <code class="literal">time_tz()</code> → <code class="returnvalue">time with time zone</code></p> <p>Time with time zone value converted from a string</p> <p><code class="literal">jsonb_path_query('"12:34:56 +05:30"', '$.time_tz()')</code> → <code class="returnvalue">"12:34:56+05:30"</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code>string</code> <code class="literal">.</code> <code class="literal">time_tz(precision)</code> → <code class="returnvalue">time with time zone</code></p> <p>Time with time zone value converted from a string, with fractional seconds adjusted to the given precision</p> <p><code class="literal">jsonb_path_query('"12:34:56.789 +05:30"', '$.time_tz(2)')</code> → <code class="returnvalue">"12:34:56.79+05:30"</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code>string</code> <code class="literal">.</code> <code class="literal">timestamp()</code> → <code class="returnvalue">timestamp without time zone</code></p> <p>Timestamp without time zone value converted from a string</p> <p><code class="literal">jsonb_path_query('"2023-08-15 12:34:56"', '$.timestamp()')</code> → <code class="returnvalue">"2023-08-15T12:34:56"</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code>string</code> <code class="literal">.</code> <code class="literal">timestamp(precision)</code> → <code class="returnvalue">timestamp without time zone</code></p> <p>Timestamp without time zone value converted from a string, with fractional seconds adjusted to the given precision</p> <p><code class="literal">jsonb_path_query('"2023-08-15 12:34:56.789"', '$.timestamp(2)')</code> → <code class="returnvalue">"2023-08-15T12:34:56.79"</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code>string</code> <code class="literal">.</code> <code class="literal">timestamp_tz()</code> → <code class="returnvalue">timestamp with time zone</code></p> <p>Timestamp with time zone value converted from a string</p> <p><code class="literal">jsonb_path_query('"2023-08-15 12:34:56 +05:30"', '$.timestamp_tz()')</code> → <code class="returnvalue">"2023-08-15T12:34:56+05:30"</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code>string</code> <code class="literal">.</code> <code class="literal">timestamp_tz(precision)</code> → <code class="returnvalue">timestamp with time zone</code></p> <p>Timestamp with time zone value converted from a string, with fractional seconds adjusted to the given precision</p> <p><code class="literal">jsonb_path_query('"2023-08-15 12:34:56.789 +05:30"', '$.timestamp_tz(2)')</code> → <code class="returnvalue">"2023-08-15T12:34:56.79+05:30"</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code>object</code> <code class="literal">.</code> <code class="literal">keyvalue()</code> → <code class="returnvalue">array</code></p> <p>The object's key-value pairs, represented as an array of objects containing three fields: <code class="literal">"key"</code>, <code class="literal">"value"</code>, and <code class="literal">"id"</code>; <code class="literal">"id"</code> is a unique identifier of the object the key-value pair belongs to</p> <p><code class="literal">jsonb_path_query_array('{"x": "20", "y": 32}', '$.keyvalue()')</code> → <code class="returnvalue">[{"id": 0, "key": "x", "value": "20"}, {"id": 0, "key": "y", "value": 32}]</code></p> </td> </tr> </tbody> </table> </div> </div> <blockquote class="note"> <h3 class="title">Note</h3> <p>The result type of the <code class="literal">datetime()</code> and <code class="literal">datetime(template)</code> methods can be <code class="type">date</code>, <code class="type">timetz</code>, <code class="type">time</code>, <code class="type">timestamptz</code>, or <code class="type">timestamp</code>. Both methods determine their result type dynamically.</p> <p>The <code class="literal">datetime()</code> method sequentially tries to match its input string to the ISO formats for <code class="type">date</code>, <code class="type">timetz</code>, <code class="type">time</code>, <code class="type">timestamptz</code>, and <code class="type">timestamp</code>. It stops on the first matching format and emits the corresponding data type.</p> <p>The <code class="literal">datetime(template)</code> method determines the result type according to the fields used in the provided template string.</p> <p>The <code class="literal">datetime()</code> and <code class="literal">datetime(template)</code> methods use the same parsing rules as the <code class="literal">to_timestamp</code> SQL function does (see <a class="xref" href="functions-formatting.html" title="9.8. Data Type Formatting Functions">Section 9.8</a>), with three exceptions. First, these methods don't allow unmatched template patterns. Second, only the following separators are allowed in the template string: minus sign, period, solidus (slash), comma, apostrophe, semicolon, colon and space. Third, separators in the template string must exactly match the input string.</p> <p>If different date/time types need to be compared, an implicit cast is applied. A <code class="type">date</code> value can be cast to <code class="type">timestamp</code> or <code class="type">timestamptz</code>, <code class="type">timestamp</code> can be cast to <code class="type">timestamptz</code>, and <code class="type">time</code> to <code class="type">timetz</code>. However, all but the first of these conversions depend on the current <a class="xref" href="runtime-config-client.html#GUC-TIMEZONE">TimeZone</a> setting, and thus can only be performed within timezone-aware <code class="type">jsonpath</code> functions. Similarly, other date/time-related methods that convert strings to date/time types also do this casting, which may involve the current <a class="xref" href="runtime-config-client.html#GUC-TIMEZONE">TimeZone</a> setting. Therefore, these conversions can also only be performed within timezone-aware <code class="type">jsonpath</code> functions.</p> </blockquote> <p><a class="xref" href="functions-json.html#FUNCTIONS-SQLJSON-FILTER-EX-TABLE" title="Table 9.51. jsonpath Filter Expression Elements">Table 9.51</a> shows the available filter expression elements.</p> <div class="table" id="FUNCTIONS-SQLJSON-FILTER-EX-TABLE"> <p class="title"><strong>Table 9.51. <code class="type">jsonpath</code> Filter Expression Elements</strong></p> <div class="table-contents"> <table class="table" summary="jsonpath Filter Expression Elements"> <colgroup> <col> </colgroup> <thead> <tr> <th class="func_table_entry"> <p class="func_signature">Predicate/Value</p> <p>Description</p> <p>Example(s)</p> </th> </tr> </thead> <tbody> <tr> <td class="func_table_entry"> <p class="func_signature"><code>value</code> <code class="literal">==</code> <code>value</code> → <code class="returnvalue">boolean</code></p> <p>Equality comparison (this, and the other comparison operators, work on all JSON scalar values)</p> <p><code class="literal">jsonb_path_query_array('[1, "a", 1, 3]', '$[*] ? (@ == 1)')</code> → <code class="returnvalue">[1, 1]</code></p> <p><code class="literal">jsonb_path_query_array('[1, "a", 1, 3]', '$[*] ? (@ == "a")')</code> → <code class="returnvalue">["a"]</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code>value</code> <code class="literal">!=</code> <code>value</code> → <code class="returnvalue">boolean</code></p> <p class="func_signature"><code>value</code> <code class="literal">&lt;&gt;</code> <code>value</code> → <code class="returnvalue">boolean</code></p> <p>Non-equality comparison</p> <p><code class="literal">jsonb_path_query_array('[1, 2, 1, 3]', '$[*] ? (@ != 1)')</code> → <code class="returnvalue">[2, 3]</code></p> <p><code class="literal">jsonb_path_query_array('["a", "b", "c"]', '$[*] ? (@ &lt;&gt; "b")')</code> → <code class="returnvalue">["a", "c"]</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code>value</code> <code class="literal">&lt;</code> <code>value</code> → <code class="returnvalue">boolean</code></p> <p>Less-than comparison</p> <p><code class="literal">jsonb_path_query_array('[1, 2, 3]', '$[*] ? (@ &lt; 2)')</code> → <code class="returnvalue">[1]</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code>value</code> <code class="literal">&lt;=</code> <code>value</code> → <code class="returnvalue">boolean</code></p> <p>Less-than-or-equal-to comparison</p> <p><code class="literal">jsonb_path_query_array('["a", "b", "c"]', '$[*] ? (@ &lt;= "b")')</code> → <code class="returnvalue">["a", "b"]</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code>value</code> <code class="literal">&gt;</code> <code>value</code> → <code class="returnvalue">boolean</code></p> <p>Greater-than comparison</p> <p><code class="literal">jsonb_path_query_array('[1, 2, 3]', '$[*] ? (@ &gt; 2)')</code> → <code class="returnvalue">[3]</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code>value</code> <code class="literal">&gt;=</code> <code>value</code> → <code class="returnvalue">boolean</code></p> <p>Greater-than-or-equal-to comparison</p> <p><code class="literal">jsonb_path_query_array('[1, 2, 3]', '$[*] ? (@ &gt;= 2)')</code> → <code class="returnvalue">[2, 3]</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code class="literal">true</code> → <code class="returnvalue">boolean</code></p> <p>JSON constant <code class="literal">true</code></p> <p><code class="literal">jsonb_path_query('[{"name": "John", "parent": false}, {"name": "Chris", "parent": true}]', '$[*] ? (@.parent == true)')</code> → <code class="returnvalue">{"name": "Chris", "parent": true}</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code class="literal">false</code> → <code class="returnvalue">boolean</code></p> <p>JSON constant <code class="literal">false</code></p> <p><code class="literal">jsonb_path_query('[{"name": "John", "parent": false}, {"name": "Chris", "parent": true}]', '$[*] ? (@.parent == false)')</code> → <code class="returnvalue">{"name": "John", "parent": false}</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code class="literal">null</code> → <code class="returnvalue">value</code></p> <p>JSON constant <code class="literal">null</code> (note that, unlike in SQL, comparison to <code class="literal">null</code> works normally)</p> <p><code class="literal">jsonb_path_query('[{"name": "Mary", "job": null}, {"name": "Michael", "job": "driver"}]', '$[*] ? (@.job == null) .name')</code> → <code class="returnvalue">"Mary"</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code>boolean</code> <code class="literal">&amp;&amp;</code> <code>boolean</code> → <code class="returnvalue">boolean</code></p> <p>Boolean AND</p> <p><code class="literal">jsonb_path_query('[1, 3, 7]', '$[*] ? (@ &gt; 1 &amp;&amp; @ &lt; 5)')</code> → <code class="returnvalue">3</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code>boolean</code> <code class="literal">||</code> <code>boolean</code> → <code class="returnvalue">boolean</code></p> <p>Boolean OR</p> <p><code class="literal">jsonb_path_query('[1, 3, 7]', '$[*] ? (@ &lt; 1 || @ &gt; 5)')</code> → <code class="returnvalue">7</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code class="literal">!</code> <code>boolean</code> → <code class="returnvalue">boolean</code></p> <p>Boolean NOT</p> <p><code class="literal">jsonb_path_query('[1, 3, 7]', '$[*] ? (!(@ &lt; 5))')</code> → <code class="returnvalue">7</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code>boolean</code> <code class="literal">is unknown</code> → <code class="returnvalue">boolean</code></p> <p>Tests whether a Boolean condition is <code class="literal">unknown</code>.</p> <p><code class="literal">jsonb_path_query('[-1, 2, 7, "foo"]', '$[*] ? ((@ &gt; 0) is unknown)')</code> → <code class="returnvalue">"foo"</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code>string</code> <code class="literal">like_regex</code> <code>string</code> [ <span class="optional"><code class="literal">flag</code> <code>string</code></span> ] → <code class="returnvalue">boolean</code></p> <p>Tests whether the first operand matches the regular expression given by the second operand, optionally with modifications described by a string of <code class="literal">flag</code> characters (see <a class="xref" href="functions-json.html#JSONPATH-REGULAR-EXPRESSIONS" title="9.16.2.4. SQL/JSON Regular Expressions">Section 9.16.2.4</a>).</p> <p><code class="literal">jsonb_path_query_array('["abc", "abd", "aBdC", "abdacb", "babc"]', '$[*] ? (@ like_regex "^ab.*c")')</code> → <code class="returnvalue">["abc", "abdacb"]</code></p> <p><code class="literal">jsonb_path_query_array('["abc", "abd", "aBdC", "abdacb", "babc"]', '$[*] ? (@ like_regex "^ab.*c" flag "i")')</code> → <code class="returnvalue">["abc", "aBdC", "abdacb"]</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code>string</code> <code class="literal">starts with</code> <code>string</code> → <code class="returnvalue">boolean</code></p> <p>Tests whether the second operand is an initial substring of the first operand.</p> <p><code class="literal">jsonb_path_query('["John Smith", "Mary Stone", "Bob Johnson"]', '$[*] ? (@ starts with "John")')</code> → <code class="returnvalue">"John Smith"</code></p> </td> </tr> <tr> <td class="func_table_entry"> <p class="func_signature"><code class="literal">exists</code> <code class="literal">(</code> <code>path_expression</code> <code class="literal">)</code> → <code class="returnvalue">boolean</code></p> <p>Tests whether a path expression matches at least one SQL/JSON item. Returns <code class="literal">unknown</code> if the path expression would result in an error; the second example uses this to avoid a no-such-key error in strict mode.</p> <p><code class="literal">jsonb_path_query('{"x": [1, 2], "y": [2, 4]}', 'strict $.* ? (exists (@ ? (@[*] &gt; 2)))')</code> → <code class="returnvalue">[2, 4]</code></p> <p><code class="literal">jsonb_path_query_array('{"value": 41}', 'strict $ ? (exists (@.name)) .name')</code> → <code class="returnvalue">[]</code></p> </td> </tr> </tbody> </table> </div> </div> </div> <div class="sect3" id="id-1.5.8.22.9.23.2">    <h3 class="title">9.16.2.4. SQL/JSON Regular Expressions </h3>    <p>SQL/JSON path expressions allow matching text to a regular expression with the <code class="literal">like_regex</code> filter. For example, the following SQL/JSON path query would case-insensitively match all strings in an array that start with an English vowel:</p> <pre data-language="sql">
$[*] ? (@ like_regex "^[aeiou]" flag "i")
</pre> <p>The optional <code class="literal">flag</code> string may include one or more of the characters <code class="literal">i</code> for case-insensitive match, <code class="literal">m</code> to allow <code class="literal">^</code> and <code class="literal">$</code> to match at newlines, <code class="literal">s</code> to allow <code class="literal">.</code> to match a newline, and <code class="literal">q</code> to quote the whole pattern (reducing the behavior to a simple substring match).</p> <p>The SQL/JSON standard borrows its definition for regular expressions from the <code class="literal">LIKE_REGEX</code> operator, which in turn uses the XQuery standard. PostgreSQL does not currently support the <code class="literal">LIKE_REGEX</code> operator. Therefore, the <code class="literal">like_regex</code> filter is implemented using the POSIX regular expression engine described in <a class="xref" href="functions-matching.html#FUNCTIONS-POSIX-REGEXP" title="9.7.3. POSIX Regular Expressions">Section 9.7.3</a>. This leads to various minor discrepancies from standard SQL/JSON behavior, which are cataloged in <a class="xref" href="functions-matching.html#POSIX-VS-XQUERY" title="9.7.3.8. Differences from SQL Standard and XQuery">Section 9.7.3.8</a>. Note, however, that the flag-letter incompatibilities described there do not apply to SQL/JSON, as it translates the XQuery flag letters to match what the POSIX engine expects.</p> <p>Keep in mind that the pattern argument of <code class="literal">like_regex</code> is a JSON path string literal, written according to the rules given in <a class="xref" href="datatype-json.html#DATATYPE-JSONPATH" title="8.14.7. jsonpath Type">Section 8.14.7</a>. This means in particular that any backslashes you want to use in the regular expression must be doubled. For example, to match string values of the root document that contain only digits:</p> <pre data-language="sql">
$.* ? (@ like_regex "^\\d+$")
</pre> </div> </div> <div class="sect2" id="SQLJSON-QUERY-FUNCTIONS">    <h2 class="title">9.16.3. SQL/JSON Query Functions </h2>    <p>SQL/JSON functions <code class="literal">JSON_EXISTS()</code>, <code class="literal">JSON_QUERY()</code>, and <code class="literal">JSON_VALUE()</code> described in <a class="xref" href="functions-json.html#FUNCTIONS-SQLJSON-QUERYING" title="Table 9.52. SQL/JSON Query Functions">Table 9.52</a> can be used to query JSON documents. Each of these functions apply a <code>path_expression</code> (an SQL/JSON path query) to a <code>context_item</code> (the document). See <a class="xref" href="functions-json.html#FUNCTIONS-SQLJSON-PATH" title="9.16.2. The SQL/JSON Path Language">Section 9.16.2</a> for more details on what the <code>path_expression</code> can contain. The <code>path_expression</code> can also reference variables, whose values are specified with their respective names in the <code class="literal">PASSING</code> clause that is supported by each function. <code>context_item</code> can be a <code class="type">jsonb</code> value or a character string that can be successfully cast to <code class="type">jsonb</code>.</p> <div class="table" id="FUNCTIONS-SQLJSON-QUERYING"> <p class="title"><strong>Table 9.52. SQL/JSON Query Functions</strong></p> <div class="table-contents"> <table class="table" summary="SQL/JSON Query Functions"> <colgroup> <col> </colgroup> <thead> <tr> <th class="func_table_entry"> <p class="func_signature">Function signature</p> <p>Description</p> <p>Example(s)</p> </th> </tr> </thead> <tbody> <tr> <td class="func_table_entry">  <pre data-language="sql">
JSON_EXISTS (
context_item, path_expression
[ PASSING { value AS varname } [, ...]]
[{ TRUE | FALSE | UNKNOWN | ERROR } ON ERROR ]) → boolean
</pre>   <ul> <li> <p>Returns true if the SQL/JSON <code>path_expression</code> applied to the <code>context_item</code> yields any items, false otherwise.</p> </li> <li> <p>The <code class="literal">ON ERROR</code> clause specifies the behavior if an error occurs during <code>path_expression</code> evaluation. Specifying <code class="literal">ERROR</code> will cause an error to be thrown with the appropriate message. Other options include returning <code class="type">boolean</code> values <code class="literal">FALSE</code> or <code class="literal">TRUE</code> or the value <code class="literal">UNKNOWN</code> which is actually an SQL NULL. The default when no <code class="literal">ON ERROR</code> clause is specified is to return the <code class="type">boolean</code> value <code class="literal">FALSE</code>.</p> </li> </ul>  <p>Examples:</p> <p><code class="literal">JSON_EXISTS(jsonb '{"key1": [1,2,3]}', 'strict $.key1[*] ? (@ &gt; $x)' PASSING 2 AS x)</code> → <code class="returnvalue">t</code></p> <p><code class="literal">JSON_EXISTS(jsonb '{"a": [1,2,3]}', 'lax $.a[5]' ERROR ON ERROR)</code> → <code class="returnvalue">f</code></p> <p><code class="literal">JSON_EXISTS(jsonb '{"a": [1,2,3]}', 'strict $.a[5]' ERROR ON ERROR)</code> →</p> <pre data-language="sql">
ERROR:  jsonpath array subscript is out of bounds
</pre> </td> </tr> <tr> <td class="func_table_entry">  <pre data-language="sql">
JSON_QUERY (
context_item, path_expression
[ PASSING { value AS varname } [, ...]]
[ RETURNING data_type [ FORMAT JSON [ ENCODING UTF8 ] ] ]
[ { WITHOUT | WITH { CONDITIONAL | [UNCONDITIONAL] } } [ ARRAY ] WRAPPER ]
[ { KEEP | OMIT } QUOTES [ ON SCALAR STRING ] ]
[ { ERROR | NULL | EMPTY { [ ARRAY ] | OBJECT } | DEFAULT expression } ON EMPTY ]
[ { ERROR | NULL | EMPTY { [ ARRAY ] | OBJECT } | DEFAULT expression } ON ERROR ]) → jsonb
</pre>   <ul> <li> <p>Returns the result of applying the SQL/JSON <code>path_expression</code> to the <code>context_item</code>.</p> </li> <li> <p>By default, the result is returned as a value of type <code class="type">jsonb</code>, though the <code class="literal">RETURNING</code> clause can be used to return as some other type to which it can be successfully coerced.</p> </li> <li> <p>If the path expression may return multiple values, it might be necessary to wrap those values using the <code class="literal">WITH WRAPPER</code> clause to make it a valid JSON string, because the default behavior is to not wrap them, as if <code class="literal">WITHOUT WRAPPER</code> were specified. The <code class="literal">WITH WRAPPER</code> clause is by default taken to mean <code class="literal">WITH UNCONDITIONAL WRAPPER</code>, which means that even a single result value will be wrapped. To apply the wrapper only when multiple values are present, specify <code class="literal">WITH CONDITIONAL WRAPPER</code>. Getting multiple values in result will be treated as an error if <code class="literal">WITHOUT WRAPPER</code> is specified.</p> </li> <li> <p>If the result is a scalar string, by default, the returned value will be surrounded by quotes, making it a valid JSON value. It can be made explicit by specifying <code class="literal">KEEP QUOTES</code>. Conversely, quotes can be omitted by specifying <code class="literal">OMIT QUOTES</code>. To ensure that the result is a valid JSON value, <code class="literal">OMIT QUOTES</code> cannot be specified when <code class="literal">WITH WRAPPER</code> is also specified.</p> </li> <li> <p>The <code class="literal">ON EMPTY</code> clause specifies the behavior if evaluating <code>path_expression</code> yields an empty set. The <code class="literal">ON ERROR</code> clause specifies the behavior if an error occurs when evaluating <code>path_expression</code>, when coercing the result value to the <code class="literal">RETURNING</code> type, or when evaluating the <code class="literal">ON EMPTY</code> expression if the <code>path_expression</code> evaluation returns an empty set.</p> </li> <li> <p>For both <code class="literal">ON EMPTY</code> and <code class="literal">ON ERROR</code>, specifying <code class="literal">ERROR</code> will cause an error to be thrown with the appropriate message. Other options include returning an SQL NULL, an empty array (<code class="literal">EMPTY [ARRAY]</code>), an empty object (<code class="literal">EMPTY OBJECT</code>), or a user-specified expression (<code class="literal">DEFAULT</code> <code>expression</code>) that can be coerced to jsonb or the type specified in <code class="literal">RETURNING</code>. The default when <code class="literal">ON EMPTY</code> or <code class="literal">ON ERROR</code> is not specified is to return an SQL NULL value.</p> </li> </ul>  <p>Examples:</p> <p><code class="literal">JSON_QUERY(jsonb '[1,[2,3],null]', 'lax $[*][$off]' PASSING 1 AS off WITH CONDITIONAL WRAPPER)</code> → <code class="returnvalue">3</code></p> <p><code class="literal">JSON_QUERY(jsonb '{"a": "[1, 2]"}', 'lax $.a' OMIT QUOTES)</code> → <code class="returnvalue">[1, 2]</code></p> <p><code class="literal">JSON_QUERY(jsonb '{"a": "[1, 2]"}', 'lax $.a' RETURNING int[] OMIT QUOTES ERROR ON ERROR)</code> →</p> <pre data-language="sql">
ERROR:  malformed array literal: "[1, 2]"
DETAIL:  Missing "]" after array dimensions.
</pre> </td> </tr> <tr> <td class="func_table_entry">  <pre data-language="sql">
JSON_VALUE (
context_item, path_expression
[ PASSING { value AS varname } [, ...]]
[ RETURNING data_type ]
[ { ERROR | NULL | DEFAULT expression } ON EMPTY ]
[ { ERROR | NULL | DEFAULT expression } ON ERROR ]) → text
</pre>   <ul> <li> <p>Returns the result of applying the SQL/JSON <code>path_expression</code> to the <code>context_item</code>.</p> </li> <li> <p>Only use <code class="function">JSON_VALUE()</code> if the extracted value is expected to be a single SQL/JSON scalar item; getting multiple values will be treated as an error. If you expect that extracted value might be an object or an array, use the <code class="function">JSON_QUERY</code> function instead.</p> </li> <li> <p>By default, the result, which must be a single scalar value, is returned as a value of type <code class="type">text</code>, though the <code class="literal">RETURNING</code> clause can be used to return as some other type to which it can be successfully coerced.</p> </li> <li> <p>The <code class="literal">ON ERROR</code> and <code class="literal">ON EMPTY</code> clauses have similar semantics as mentioned in the description of <code class="function">JSON_QUERY</code>, except the set of values returned in lieu of throwing an error is different.</p> </li> <li> <p>Note that scalar strings returned by <code class="function">JSON_VALUE</code> always have their quotes removed, equivalent to specifying <code class="literal">OMIT QUOTES</code> in <code class="function">JSON_QUERY</code>.</p> </li> </ul>  <p>Examples:</p> <p><code class="literal">JSON_VALUE(jsonb '"123.45"', '$' RETURNING float)</code> → <code class="returnvalue">123.45</code></p> <p><code class="literal">JSON_VALUE(jsonb '"03:04 2015-02-01"', '$.datetime("HH24:MI YYYY-MM-DD")' RETURNING date)</code> → <code class="returnvalue">2015-02-01</code></p> <p><code class="literal">JSON_VALUE(jsonb '[1,2]', 'strict $[$off]' PASSING 1 as off)</code> → <code class="returnvalue">2</code></p> <p><code class="literal">JSON_VALUE(jsonb '[1,2]', 'strict $[*]' DEFAULT 9 ON ERROR)</code> → <code class="returnvalue">9</code></p> </td> </tr> </tbody> </table> </div> </div> <blockquote class="note"> <h3 class="title">Note</h3> <p>The <code>context_item</code> expression is converted to <code class="type">jsonb</code> by an implicit cast if the expression is not already of type <code class="type">jsonb</code>. Note, however, that any parsing errors that occur during that conversion are thrown unconditionally, that is, are not handled according to the (specified or implicit) <code class="literal">ON ERROR</code> clause.</p> </blockquote> <blockquote class="note"> <h3 class="title">Note</h3> <p><code class="function">JSON_VALUE()</code> returns an SQL NULL if <code>path_expression</code> returns a JSON <code class="literal">null</code>, whereas <code class="function">JSON_QUERY()</code> returns the JSON <code class="literal">null</code> as is.</p> </blockquote> </div> <div class="sect2" id="id-1.5.8.22.11.2">    <h2 class="title">9.16.4. JSON_TABLE </h2>    <p><code class="function">JSON_TABLE</code> is an SQL/JSON function which queries JSON data and presents the results as a relational view, which can be accessed as a regular SQL table. You can use <code class="function">JSON_TABLE</code> inside the <code class="literal">FROM</code> clause of a <code class="literal">SELECT</code>, <code class="literal">UPDATE</code>, or <code class="literal">DELETE</code> and as data source in a <code class="literal">MERGE</code> statement.</p> <p>Taking JSON data as input, <code class="function">JSON_TABLE</code> uses a JSON path expression to extract a part of the provided data to use as a <em class="firstterm">row pattern</em> for the constructed view. Each SQL/JSON value given by the row pattern serves as source for a separate row in the constructed view.</p> <p>To split the row pattern into columns, <code class="function">JSON_TABLE</code> provides the <code class="literal">COLUMNS</code> clause that defines the schema of the created view. For each column, a separate JSON path expression can be specified to be evaluated against the row pattern to get an SQL/JSON value that will become the value for the specified column in a given output row.</p> <p>JSON data stored at a nested level of the row pattern can be extracted using the <code class="literal">NESTED PATH</code> clause. Each <code class="literal">NESTED PATH</code> clause can be used to generate one or more columns using the data from a nested level of the row pattern. Those columns can be specified using a <code class="literal">COLUMNS</code> clause that looks similar to the top-level COLUMNS clause. Rows constructed from NESTED COLUMNS are called <em class="firstterm">child rows</em> and are joined against the row constructed from the columns specified in the parent <code class="literal">COLUMNS</code> clause to get the row in the final view. Child columns themselves may contain a <code class="literal">NESTED PATH</code> specification thus allowing to extract data located at arbitrary nesting levels. Columns produced by multiple <code class="literal">NESTED PATH</code>s at the same level are considered to be <em class="firstterm">siblings</em> of each other and their rows after joining with the parent row are combined using UNION.</p> <p>The rows produced by <code class="function">JSON_TABLE</code> are laterally joined to the row that generated them, so you do not have to explicitly join the constructed view with the original table holding JSON data.</p> <p>The syntax is:</p> <pre data-language="sql">
JSON_TABLE (
    context_item, path_expression [ AS json_path_name ] [ PASSING { value AS varname } [, ...] ]
    COLUMNS ( json_table_column [, ...] )
    [ { ERROR | EMPTY [ARRAY]} ON ERROR ]
)


where json_table_column is:

  name FOR ORDINALITY
  | name type
        [ FORMAT JSON [ENCODING UTF8]]
        [ PATH path_expression ]
        [ { WITHOUT | WITH { CONDITIONAL | [UNCONDITIONAL] } } [ ARRAY ] WRAPPER ]
        [ { KEEP | OMIT } QUOTES [ ON SCALAR STRING ] ]
        [ { ERROR | NULL | EMPTY { [ARRAY] | OBJECT } | DEFAULT expression } ON EMPTY ]
        [ { ERROR | NULL | EMPTY { [ARRAY] | OBJECT } | DEFAULT expression } ON ERROR ]
  | name type EXISTS [ PATH path_expression ]
        [ { ERROR | TRUE | FALSE | UNKNOWN } ON ERROR ]
  | NESTED [ PATH ] path_expression [ AS json_path_name ] COLUMNS ( json_table_column [, ...] )
</pre> <p>Each syntax element is described below in more detail.</p> <div class="variablelist"> <dl class="variablelist"> <dt><code class="literal">context_item, path_expression [ AS json_path_name ] [ PASSING { value AS varname } [, ...]]</code></dt> <dd> <p>The <code>context_item</code> specifies the input document to query, the <code>path_expression</code> is an SQL/JSON path expression defining the query, and <code>json_path_name</code> is an optional name for the <code>path_expression</code>. The optional <code class="literal">PASSING</code> clause provides data values for the variables mentioned in the <code>path_expression</code>. The result of the input data evaluation using the aforementioned elements is called the <em class="firstterm">row pattern</em>, which is used as the source for row values in the constructed view.</p> </dd> <dt>
<code class="literal">COLUMNS</code> ( <code>json_table_column</code> [<span class="optional">, ...</span>] )</dt> <dd> <p>The <code class="literal">COLUMNS</code> clause defining the schema of the constructed view. In this clause, you can specify each column to be filled with an SQL/JSON value obtained by applying a JSON path expression against the row pattern. <code>json_table_column</code> has the following variants:</p> <div class="variablelist"> <dl class="variablelist"> <dt>
<code>name</code> <code class="literal">FOR ORDINALITY</code>
</dt> <dd> <p>Adds an ordinality column that provides sequential row numbering starting from 1. Each <code class="literal">NESTED PATH</code> (see below) gets its own counter for any nested ordinality columns.</p> </dd> <dt><code class="literal">name type [FORMAT JSON [ENCODING UTF8]] [ PATH path_expression ]</code></dt> <dd> <p>Inserts an SQL/JSON value obtained by applying <code>path_expression</code> against the row pattern into the view's output row after coercing it to specified <code>type</code>.</p> <p>Specifying <code class="literal">FORMAT JSON</code> makes it explicit that you expect the value to be a valid <code class="type">json</code> object. It only makes sense to specify <code class="literal">FORMAT JSON</code> if <code>type</code> is one of <code class="type">bpchar</code>, <code class="type">bytea</code>, <code class="type">character varying</code>, <code class="type">name</code>, <code class="type">json</code>, <code class="type">jsonb</code>, <code class="type">text</code>, or a domain over these types.</p> <p>Optionally, you can specify <code class="literal">WRAPPER</code> and <code class="literal">QUOTES</code> clauses to format the output. Note that specifying <code class="literal">OMIT QUOTES</code> overrides <code class="literal">FORMAT JSON</code> if also specified, because unquoted literals do not constitute valid <code class="type">json</code> values.</p> <p>Optionally, you can use <code class="literal">ON EMPTY</code> and <code class="literal">ON ERROR</code> clauses to specify whether to throw the error or return the specified value when the result of JSON path evaluation is empty and when an error occurs during JSON path evaluation or when coercing the SQL/JSON value to the specified type, respectively. The default for both is to return a <code class="literal">NULL</code> value.</p> <blockquote class="note"> <h3 class="title">Note</h3> <p>This clause is internally turned into and has the same semantics as <code class="function">JSON_VALUE</code> or <code class="function">JSON_QUERY</code>. The latter if the specified type is not a scalar type or if either of <code class="literal">FORMAT JSON</code>, <code class="literal">WRAPPER</code>, or <code class="literal">QUOTES</code> clause is present.</p> </blockquote> </dd> <dt>
<code>name</code> <code>type</code> <code class="literal">EXISTS</code> [ <span class="optional"><code class="literal">PATH</code> <code>path_expression</code></span> ]</dt> <dd> <p>Inserts a boolean value obtained by applying <code>path_expression</code> against the row pattern into the view's output row after coercing it to specified <code>type</code>.</p> <p>The value corresponds to whether applying the <code class="literal">PATH</code> expression to the row pattern yields any values.</p> <p>The specified <code>type</code> should have a cast from the <code class="type">boolean</code> type.</p> <p>Optionally, you can use <code class="literal">ON ERROR</code> to specify whether to throw the error or return the specified value when an error occurs during JSON path evaluation or when coercing SQL/JSON value to the specified type. The default is to return a boolean value <code class="literal">FALSE</code>.</p> <blockquote class="note"> <h3 class="title">Note</h3> <p>This clause is internally turned into and has the same semantics as <code class="function">JSON_EXISTS</code>.</p> </blockquote> </dd> <dt>
<code class="literal">NESTED [ PATH ]</code> <code>path_expression</code> [ <span class="optional"><code class="literal">AS</code> <code>json_path_name</code></span> ] <code class="literal">COLUMNS</code> ( <code>json_table_column</code> [<span class="optional">, ...</span>] )</dt> <dd> <p>Extracts SQL/JSON values from nested levels of the row pattern, generates one or more columns as defined by the <code class="literal">COLUMNS</code> subclause, and inserts the extracted SQL/JSON values into those columns. The <code>json_table_column</code> expression in the <code class="literal">COLUMNS</code> subclause uses the same syntax as in the parent <code class="literal">COLUMNS</code> clause.</p> <p>The <code class="literal">NESTED PATH</code> syntax is recursive, so you can go down multiple nested levels by specifying several <code class="literal">NESTED PATH</code> subclauses within each other. It allows to unnest the hierarchy of JSON objects and arrays in a single function invocation rather than chaining several <code class="function">JSON_TABLE</code> expressions in an SQL statement.</p> </dd> </dl> </div> <blockquote class="note"> <h3 class="title">Note</h3> <p>In each variant of <code>json_table_column</code> described above, if the <code class="literal">PATH</code> clause is omitted, path expression <code class="literal">$.name</code> is used, where <code>name</code> is the provided column name.</p> </blockquote> </dd> <dt>
<code class="literal">AS</code> <code>json_path_name</code>
</dt> <dd> <p>The optional <code>json_path_name</code> serves as an identifier of the provided <code>path_expression</code>. The name must be unique and distinct from the column names.</p> </dd> <dt>{ <code class="literal">ERROR</code> | <code class="literal">EMPTY</code> } <code class="literal">ON ERROR</code>
</dt> <dd> <p>The optional <code class="literal">ON ERROR</code> can be used to specify how to handle errors when evaluating the top-level <code>path_expression</code>. Use <code class="literal">ERROR</code> if you want the errors to be thrown and <code class="literal">EMPTY</code> to return an empty table, that is, a table containing 0 rows. Note that this clause does not affect the errors that occur when evaluating columns, for which the behavior depends on whether the <code class="literal">ON ERROR</code> clause is specified against a given column.</p> </dd> </dl> </div> <p>Examples</p> <p>In the examples that follow, the following table containing JSON data will be used:</p> <pre data-language="sql">
CREATE TABLE my_films ( js jsonb );

INSERT INTO my_films VALUES (
'{ "favorites" : [
   { "kind" : "comedy", "films" : [
     { "title" : "Bananas",
       "director" : "Woody Allen"},
     { "title" : "The Dinner Game",
       "director" : "Francis Veber" } ] },
   { "kind" : "horror", "films" : [
     { "title" : "Psycho",
       "director" : "Alfred Hitchcock" } ] },
   { "kind" : "thriller", "films" : [
     { "title" : "Vertigo",
       "director" : "Alfred Hitchcock" } ] },
   { "kind" : "drama", "films" : [
     { "title" : "Yojimbo",
       "director" : "Akira Kurosawa" } ] }
  ] }');
</pre> <p>The following query shows how to use <code class="function">JSON_TABLE</code> to turn the JSON objects in the <code class="structname">my_films</code> table to a view containing columns for the keys <code class="literal">kind</code>, <code class="literal">title</code>, and <code class="literal">director</code> contained in the original JSON along with an ordinality column:</p> <pre data-language="sql">
SELECT jt.* FROM
 my_films,
 JSON_TABLE (js, '$.favorites[*]' COLUMNS (
   id FOR ORDINALITY,
   kind text PATH '$.kind',
   title text PATH '$.films[*].title' WITH WRAPPER,
   director text PATH '$.films[*].director' WITH WRAPPER)) AS jt;
</pre> <pre>
 id |   kind   |             title              |             director
----+----------+--------------------------------+----------------------------------
  1 | comedy   | ["Bananas", "The Dinner Game"] | ["Woody Allen", "Francis Veber"]
  2 | horror   | ["Psycho"]                     | ["Alfred Hitchcock"]
  3 | thriller | ["Vertigo"]                    | ["Alfred Hitchcock"]
  4 | drama    | ["Yojimbo"]                    | ["Akira Kurosawa"]
(4 rows)
</pre> <p>The following is a modified version of the above query to show the usage of <code class="literal">PASSING</code> arguments in the filter specified in the top-level JSON path expression and the various options for the individual columns:</p> <pre data-language="sql">
SELECT jt.* FROM
 my_films,
 JSON_TABLE (js, '$.favorites[*] ? (@.films[*].director == $filter)'
   PASSING 'Alfred Hitchcock' AS filter, 'Vertigo' AS filter2
     COLUMNS (
     id FOR ORDINALITY,
     kind text PATH '$.kind',
     title text FORMAT JSON PATH '$.films[*].title' OMIT QUOTES,
     director text PATH '$.films[*].director' KEEP QUOTES)) AS jt;
</pre> <pre>
 id |   kind   |  title  |      director
----+----------+---------+--------------------
  1 | horror   | Psycho  | "Alfred Hitchcock"
  2 | thriller | Vertigo | "Alfred Hitchcock"
(2 rows)
</pre> <p>The following is a modified version of the above query to show the usage of <code class="literal">NESTED PATH</code> for populating title and director columns, illustrating how they are joined to the parent columns id and kind:</p> <pre data-language="sql">
SELECT jt.* FROM
 my_films,
 JSON_TABLE ( js, '$.favorites[*] ? (@.films[*].director == $filter)'
   PASSING 'Alfred Hitchcock' AS filter
   COLUMNS (
    id FOR ORDINALITY,
    kind text PATH '$.kind',
    NESTED PATH '$.films[*]' COLUMNS (
      title text FORMAT JSON PATH '$.title' OMIT QUOTES,
      director text PATH '$.director' KEEP QUOTES))) AS jt;
</pre> <pre>
 id |   kind   |  title  |      director
----+----------+---------+--------------------
  1 | horror   | Psycho  | "Alfred Hitchcock"
  2 | thriller | Vertigo | "Alfred Hitchcock"
(2 rows)
</pre> <p>The following is the same query but without the filter in the root path:</p> <pre data-language="sql">
SELECT jt.* FROM
 my_films,
 JSON_TABLE ( js, '$.favorites[*]'
   COLUMNS (
    id FOR ORDINALITY,
    kind text PATH '$.kind',
    NESTED PATH '$.films[*]' COLUMNS (
      title text FORMAT JSON PATH '$.title' OMIT QUOTES,
      director text PATH '$.director' KEEP QUOTES))) AS jt;
</pre> <pre>
 id |   kind   |      title      |      director
----+----------+-----------------+--------------------
  1 | comedy   | Bananas         | "Woody Allen"
  1 | comedy   | The Dinner Game | "Francis Veber"
  2 | horror   | Psycho          | "Alfred Hitchcock"
  3 | thriller | Vertigo         | "Alfred Hitchcock"
  4 | drama    | Yojimbo         | "Akira Kurosawa"
(5 rows)
</pre> <p>The following shows another query using a different <code class="type">JSON</code> object as input. It shows the UNION "sibling join" between <code class="literal">NESTED</code> paths <code class="literal">$.movies[*]</code> and <code class="literal">$.books[*]</code> and also the usage of <code class="literal">FOR ORDINALITY</code> column at <code class="literal">NESTED</code> levels (columns <code class="literal">movie_id</code>, <code class="literal">book_id</code>, and <code class="literal">author_id</code>):</p> <pre data-language="sql">
SELECT * FROM JSON_TABLE (
'{"favorites":
    {"movies":
      [{"name": "One", "director": "John Doe"},
       {"name": "Two", "director": "Don Joe"}],
     "books":
      [{"name": "Mystery", "authors": [{"name": "Brown Dan"}]},
       {"name": "Wonder", "authors": [{"name": "Jun Murakami"}, {"name":"Craig Doe"}]}]
}}'::json, '$.favorites[*]'
COLUMNS (
  user_id FOR ORDINALITY,
  NESTED '$.movies[*]'
    COLUMNS (
    movie_id FOR ORDINALITY,
    mname text PATH '$.name',
    director text),
  NESTED '$.books[*]'
    COLUMNS (
      book_id FOR ORDINALITY,
      bname text PATH '$.name',
      NESTED '$.authors[*]'
        COLUMNS (
          author_id FOR ORDINALITY,
          author_name text PATH '$.name'))));
</pre> <pre>
 user_id | movie_id | mname | director | book_id |  bname  | author_id | author_name
---------+----------+-------+----------+---------+---------+-----------+--------------
       1 |        1 | One   | John Doe |         |         |           |
       1 |        2 | Two   | Don Joe  |         |         |           |
       1 |          |       |          |       1 | Mystery |         1 | Brown Dan
       1 |          |       |          |       2 | Wonder  |         1 | Jun Murakami
       1 |          |       |          |       2 | Wonder  |         2 | Craig Doe
(5 rows)
</pre> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996&ndash;2024 The PostgreSQL Global Development Group<br>Licensed under the PostgreSQL License.<br>
    <a href="https://www.postgresql.org/docs/17/functions-json.html" class="_attribution-link">https://www.postgresql.org/docs/17/functions-json.html</a>
  </p>
</div>
