<h1>64.3. SP-GiST Indexes </h1>    <div class="toc"> <dl class="toc"> <dt><a href="spgist.html#SPGIST-INTRO">64.3.1. Introduction</a></dt> <dt><a href="spgist.html#SPGIST-BUILTIN-OPCLASSES">64.3.2. Built-in Operator Classes</a></dt> <dt><a href="spgist.html#SPGIST-EXTENSIBILITY">64.3.3. Extensibility</a></dt> <dt><a href="spgist.html#SPGIST-IMPLEMENTATION">64.3.4. Implementation</a></dt> <dt><a href="spgist.html#SPGIST-EXAMPLES">64.3.5. Examples</a></dt> </dl> </div> <div class="sect2" id="SPGIST-INTRO">    <h2 class="title">64.3.1. Introduction </h2>    <p>SP-GiST is an abbreviation for space-partitioned GiST. SP-GiST supports partitioned search trees, which facilitate development of a wide range of different non-balanced data structures, such as quad-trees, k-d trees, and radix trees (tries). The common feature of these structures is that they repeatedly divide the search space into partitions that need not be of equal size. Searches that are well matched to the partitioning rule can be very fast.</p> <p>These popular data structures were originally developed for in-memory usage. In main memory, they are usually designed as a set of dynamically allocated nodes linked by pointers. This is not suitable for direct storing on disk, since these chains of pointers can be rather long which would require too many disk accesses. In contrast, disk-based data structures should have a high fanout to minimize I/O. The challenge addressed by SP-GiST is to map search tree nodes to disk pages in such a way that a search need access only a few disk pages, even if it traverses many nodes.</p> <p>Like GiST, SP-GiST is meant to allow the development of custom data types with the appropriate access methods, by an expert in the domain of the data type, rather than a database expert.</p> <p>Some of the information here is derived from Purdue University's SP-GiST Indexing Project <a class="ulink" href="https://www.cs.purdue.edu/spgist/" target="_top">web site</a>. The SP-GiST implementation in PostgreSQL is primarily maintained by Teodor Sigaev and Oleg Bartunov, and there is more information on their <a class="ulink" href="http://www.sai.msu.su/~megera/wiki/spgist_dev" target="_top">web site</a>.</p> </div> <div class="sect2" id="SPGIST-BUILTIN-OPCLASSES">    <h2 class="title">64.3.2. Built-in Operator Classes </h2>    <p>The core PostgreSQL distribution includes the SP-GiST operator classes shown in <a class="xref" href="spgist.html#SPGIST-BUILTIN-OPCLASSES-TABLE" title="Table 64.2. Built-in SP-GiST Operator Classes">Table 64.2</a>.</p> <div class="table" id="SPGIST-BUILTIN-OPCLASSES-TABLE"> <p class="title"><strong>Table 64.2. Built-in SP-GiST Operator Classes</strong></p> <div class="table-contents"> <table class="table" summary="Built-in SP-GiST Operator Classes"> <colgroup> <col> <col> <col> </colgroup> <thead> <tr> <th>Name</th> <th>Indexable Operators</th> <th>Ordering Operators</th> </tr> </thead> <tbody> <tr> <td rowspan="12"><code class="literal">box_ops</code></td> <td><code class="literal">&lt;&lt; (box,box)</code></td> <td rowspan="12"><code class="literal">&lt;-&gt; (box,point)</code></td> </tr> <tr> <td><code class="literal">&amp;&lt; (box,box)</code></td> </tr> <tr> <td><code class="literal">&amp;&gt; (box,box)</code></td> </tr> <tr> <td><code class="literal">&gt;&gt; (box,box)</code></td> </tr> <tr> <td><code class="literal">&lt;@ (box,box)</code></td> </tr> <tr> <td><code class="literal">@&gt; (box,box)</code></td> </tr> <tr> <td><code class="literal">~= (box,box)</code></td> </tr> <tr> <td><code class="literal">&amp;&amp; (box,box)</code></td> </tr> <tr> <td><code class="literal">&lt;&lt;| (box,box)</code></td> </tr> <tr> <td><code class="literal">&amp;&lt;| (box,box)</code></td> </tr> <tr> <td><code class="literal">|&amp;&gt; (box,box)</code></td> </tr> <tr> <td><code class="literal">|&gt;&gt; (box,box)</code></td> </tr> <tr> <td rowspan="11"><code class="literal">inet_ops</code></td> <td><code class="literal">&lt;&lt; (inet,inet)</code></td> <td rowspan="11"> </td> </tr> <tr> <td><code class="literal">&lt;&lt;= (inet,inet)</code></td> </tr> <tr> <td><code class="literal">&gt;&gt; (inet,inet)</code></td> </tr> <tr> <td><code class="literal">&gt;&gt;= (inet,inet)</code></td> </tr> <tr> <td><code class="literal">= (inet,inet)</code></td> </tr> <tr> <td><code class="literal">&lt;&gt; (inet,inet)</code></td> </tr> <tr> <td><code class="literal">&lt; (inet,inet)</code></td> </tr> <tr> <td><code class="literal">&lt;= (inet,inet)</code></td> </tr> <tr> <td><code class="literal">&gt; (inet,inet)</code></td> </tr> <tr> <td><code class="literal">&gt;= (inet,inet)</code></td> </tr> <tr> <td><code class="literal">&amp;&amp; (inet,inet)</code></td> </tr> <tr> <td rowspan="6"><code class="literal">kd_point_ops</code></td> <td><code class="literal">|&gt;&gt; (point,point)</code></td> <td rowspan="6"><code class="literal">&lt;-&gt; (point,point)</code></td> </tr> <tr> <td><code class="literal">&lt;&lt; (point,point)</code></td> </tr> <tr> <td><code class="literal">&gt;&gt; (point,point)</code></td> </tr> <tr> <td><code class="literal">&lt;&lt;| (point,point)</code></td> </tr> <tr> <td><code class="literal">~= (point,point)</code></td> </tr> <tr> <td><code class="literal">&lt;@ (point,box)</code></td> </tr> <tr> <td rowspan="12"><code class="literal">poly_ops</code></td> <td><code class="literal">&lt;&lt; (polygon,polygon)</code></td> <td rowspan="12"><code class="literal">&lt;-&gt; (polygon,point)</code></td> </tr> <tr> <td><code class="literal">&amp;&lt; (polygon,polygon)</code></td> </tr> <tr> <td><code class="literal">&amp;&gt; (polygon,polygon)</code></td> </tr> <tr> <td><code class="literal">&gt;&gt; (polygon,polygon)</code></td> </tr> <tr> <td><code class="literal">&lt;@ (polygon,polygon)</code></td> </tr> <tr> <td><code class="literal">@&gt; (polygon,polygon)</code></td> </tr> <tr> <td><code class="literal">~= (polygon,polygon)</code></td> </tr> <tr> <td><code class="literal">&amp;&amp; (polygon,polygon)</code></td> </tr> <tr> <td><code class="literal">&lt;&lt;| (polygon,polygon)</code></td> </tr> <tr> <td><code class="literal">&amp;&lt;| (polygon,polygon)</code></td> </tr> <tr> <td><code class="literal">|&gt;&gt; (polygon,polygon)</code></td> </tr> <tr> <td><code class="literal">|&amp;&gt; (polygon,polygon)</code></td> </tr> <tr> <td rowspan="6"><code class="literal">quad_point_ops</code></td> <td><code class="literal">|&gt;&gt; (point,point)</code></td> <td rowspan="6"><code class="literal">&lt;-&gt; (point,point)</code></td> </tr> <tr> <td><code class="literal">&lt;&lt; (point,point)</code></td> </tr> <tr> <td><code class="literal">&gt;&gt; (point,point)</code></td> </tr> <tr> <td><code class="literal">&lt;&lt;| (point,point)</code></td> </tr> <tr> <td><code class="literal">~= (point,point)</code></td> </tr> <tr> <td><code class="literal">&lt;@ (point,box)</code></td> </tr> <tr> <td rowspan="10"><code class="literal">range_ops</code></td> <td><code class="literal">= (anyrange,anyrange)</code></td> <td rowspan="10"> </td> </tr> <tr> <td><code class="literal">&amp;&amp; (anyrange,anyrange)</code></td> </tr> <tr> <td><code class="literal">@&gt; (anyrange,anyelement)</code></td> </tr> <tr> <td><code class="literal">@&gt; (anyrange,anyrange)</code></td> </tr> <tr> <td><code class="literal">&lt;@ (anyrange,anyrange)</code></td> </tr> <tr> <td><code class="literal">&lt;&lt; (anyrange,anyrange)</code></td> </tr> <tr> <td><code class="literal">&gt;&gt; (anyrange,anyrange)</code></td> </tr> <tr> <td><code class="literal">&amp;&lt; (anyrange,anyrange)</code></td> </tr> <tr> <td><code class="literal">&amp;&gt; (anyrange,anyrange)</code></td> </tr> <tr> <td><code class="literal">-|- (anyrange,anyrange)</code></td> </tr> <tr> <td rowspan="10"><code class="literal">text_ops</code></td> <td><code class="literal">= (text,text)</code></td> <td rowspan="10"> </td> </tr> <tr> <td><code class="literal">&lt; (text,text)</code></td> </tr> <tr> <td><code class="literal">&lt;= (text,text)</code></td> </tr> <tr> <td><code class="literal">&gt; (text,text)</code></td> </tr> <tr> <td><code class="literal">&gt;= (text,text)</code></td> </tr> <tr> <td><code class="literal">~&lt;~ (text,text)</code></td> </tr> <tr> <td><code class="literal">~&lt;=~ (text,text)</code></td> </tr> <tr> <td><code class="literal">~&gt;=~ (text,text)</code></td> </tr> <tr> <td><code class="literal">~&gt;~ (text,text)</code></td> </tr> <tr> <td><code class="literal">^@ (text,text)</code></td> </tr> </tbody> </table> </div> </div> <p>Of the two operator classes for type <code class="type">point</code>, <code class="literal">quad_point_ops</code> is the default. <code class="literal">kd_point_ops</code> supports the same operators but uses a different index data structure that may offer better performance in some applications.</p> <p>The <code class="literal">quad_point_ops</code>, <code class="literal">kd_point_ops</code> and <code class="literal">poly_ops</code> operator classes support the <code class="literal">&lt;-&gt;</code> ordering operator, which enables the k-nearest neighbor (<code class="literal">k-NN</code>) search over indexed point or polygon data sets.</p> </div> <div class="sect2" id="SPGIST-EXTENSIBILITY">    <h2 class="title">64.3.3. Extensibility </h2>    <p>SP-GiST offers an interface with a high level of abstraction, requiring the access method developer to implement only methods specific to a given data type. The SP-GiST core is responsible for efficient disk mapping and searching the tree structure. It also takes care of concurrency and logging considerations.</p> <p>Leaf tuples of an SP-GiST tree usually contain values of the same data type as the indexed column, although it is also possible for them to contain lossy representations of the indexed column. Leaf tuples stored at the root level will directly represent the original indexed data value, but leaf tuples at lower levels might contain only a partial value, such as a suffix. In that case the operator class support functions must be able to reconstruct the original value using information accumulated from the inner tuples that are passed through to reach the leaf level.</p> <p>When an SP-GiST index is created with <code class="literal">INCLUDE</code> columns, the values of those columns are also stored in leaf tuples. The <code class="literal">INCLUDE</code> columns are of no concern to the SP-GiST operator class, so they are not discussed further here.</p> <p>Inner tuples are more complex, since they are branching points in the search tree. Each inner tuple contains a set of one or more <em class="firstterm">nodes</em>, which represent groups of similar leaf values. A node contains a downlink that leads either to another, lower-level inner tuple, or to a short list of leaf tuples that all lie on the same index page. Each node normally has a <em class="firstterm">label</em> that describes it; for example, in a radix tree the node label could be the next character of the string value. (Alternatively, an operator class can omit the node labels, if it works with a fixed set of nodes for all inner tuples; see <a class="xref" href="spgist.html#SPGIST-NULL-LABELS" title="64.3.4.2. SP-GiST Without Node Labels">Section 64.3.4.2</a>.) Optionally, an inner tuple can have a <em class="firstterm">prefix</em> value that describes all its members. In a radix tree this could be the common prefix of the represented strings. The prefix value is not necessarily really a prefix, but can be any data needed by the operator class; for example, in a quad-tree it can store the central point that the four quadrants are measured with respect to. A quad-tree inner tuple would then also contain four nodes corresponding to the quadrants around this central point.</p> <p>Some tree algorithms require knowledge of level (or depth) of the current tuple, so the SP-GiST core provides the possibility for operator classes to manage level counting while descending the tree. There is also support for incrementally reconstructing the represented value when that is needed, and for passing down additional data (called <em class="firstterm">traverse values</em>) during a tree descent.</p> <blockquote class="note"> <h3 class="title">Note</h3> <p>The SP-GiST core code takes care of null entries. Although SP-GiST indexes do store entries for nulls in indexed columns, this is hidden from the index operator class code: no null index entries or search conditions will ever be passed to the operator class methods. (It is assumed that SP-GiST operators are strict and so cannot succeed for null values.) Null values are therefore not discussed further here.</p> </blockquote> <p>There are five user-defined methods that an index operator class for SP-GiST must provide, and two are optional. All five mandatory methods follow the convention of accepting two <code class="type">internal</code> arguments, the first of which is a pointer to a C struct containing input values for the support method, while the second argument is a pointer to a C struct where output values must be placed. Four of the mandatory methods just return <code class="type">void</code>, since all their results appear in the output struct; but <code class="function">leaf_consistent</code> returns a <code class="type">boolean</code> result. The methods must not modify any fields of their input structs. In all cases, the output struct is initialized to zeroes before calling the user-defined method. The optional sixth method <code class="function">compress</code> accepts a <code class="type">datum</code> to be indexed as the only argument and returns a value suitable for physical storage in a leaf tuple. The optional seventh method <code class="function">options</code> accepts an <code class="type">internal</code> pointer to a C struct, where opclass-specific parameters should be placed, and returns <code class="type">void</code>.</p> <p>The five mandatory user-defined methods are:</p> <div class="variablelist"> <dl class="variablelist"> <dt><code class="function">config</code></dt> <dd> <p>Returns static information about the index implementation, including the data type OIDs of the prefix and node label data types.</p> <p>The SQL declaration of the function must look like this:</p> <pre data-language="sql">
CREATE FUNCTION my_config(internal, internal) RETURNS void ...
</pre> <p>The first argument is a pointer to a <code class="structname">spgConfigIn</code> C struct, containing input data for the function. The second argument is a pointer to a <code class="structname">spgConfigOut</code> C struct, which the function must fill with result data.</p> <pre data-language="sql">
typedef struct spgConfigIn
{
    Oid         attType;        /* Data type to be indexed */
} spgConfigIn;

typedef struct spgConfigOut
{
    Oid         prefixType;     /* Data type of inner-tuple prefixes */
    Oid         labelType;      /* Data type of inner-tuple node labels */
    Oid         leafType;       /* Data type of leaf-tuple values */
    bool        canReturnData;  /* Opclass can reconstruct original data */
    bool        longValuesOK;   /* Opclass can cope with values &gt; 1 page */
} spgConfigOut;
</pre> <p><code class="structfield">attType</code> is passed in order to support polymorphic index operator classes; for ordinary fixed-data-type operator classes, it will always have the same value and so can be ignored.</p> <p>For operator classes that do not use prefixes, <code class="structfield">prefixType</code> can be set to <code class="literal">VOIDOID</code>. Likewise, for operator classes that do not use node labels, <code class="structfield">labelType</code> can be set to <code class="literal">VOIDOID</code>. <code class="structfield">canReturnData</code> should be set true if the operator class is capable of reconstructing the originally-supplied index value. <code class="structfield">longValuesOK</code> should be set true only when the <code class="structfield">attType</code> is of variable length and the operator class is capable of segmenting long values by repeated suffixing (see <a class="xref" href="spgist.html#SPGIST-LIMITS" title="64.3.4.1. SP-GiST Limits">Section 64.3.4.1</a>).</p> <p><code class="structfield">leafType</code> should match the index storage type defined by the operator class's <code class="structfield">opckeytype</code> catalog entry. (Note that <code class="structfield">opckeytype</code> can be zero, implying the storage type is the same as the operator class's input type, which is the most common situation.) For reasons of backward compatibility, the <code class="function">config</code> method can set <code class="structfield">leafType</code> to some other value, and that value will be used; but this is deprecated since the index contents are then incorrectly identified in the catalogs. Also, it's permissible to leave <code class="structfield">leafType</code> uninitialized (zero); that is interpreted as meaning the index storage type derived from <code class="structfield">opckeytype</code>.</p> <p>When <code class="structfield">attType</code> and <code class="structfield">leafType</code> are different, the optional method <code class="function">compress</code> must be provided. Method <code class="function">compress</code> is responsible for transformation of datums to be indexed from <code class="structfield">attType</code> to <code class="structfield">leafType</code>.</p> </dd> <dt><code class="function">choose</code></dt> <dd> <p>Chooses a method for inserting a new value into an inner tuple.</p> <p>The SQL declaration of the function must look like this:</p> <pre data-language="sql">
CREATE FUNCTION my_choose(internal, internal) RETURNS void ...
</pre> <p>The first argument is a pointer to a <code class="structname">spgChooseIn</code> C struct, containing input data for the function. The second argument is a pointer to a <code class="structname">spgChooseOut</code> C struct, which the function must fill with result data.</p> <pre data-language="sql">
typedef struct spgChooseIn
{
    Datum       datum;          /* original datum to be indexed */
    Datum       leafDatum;      /* current datum to be stored at leaf */
    int         level;          /* current level (counting from zero) */

    /* Data from current inner tuple */
    bool        allTheSame;     /* tuple is marked all-the-same? */
    bool        hasPrefix;      /* tuple has a prefix? */
    Datum       prefixDatum;    /* if so, the prefix value */
    int         nNodes;         /* number of nodes in the inner tuple */
    Datum      *nodeLabels;     /* node label values (NULL if none) */
} spgChooseIn;

typedef enum spgChooseResultType
{
    spgMatchNode = 1,           /* descend into existing node */
    spgAddNode,                 /* add a node to the inner tuple */
    spgSplitTuple               /* split inner tuple (change its prefix) */
} spgChooseResultType;

typedef struct spgChooseOut
{
    spgChooseResultType resultType;     /* action code, see above */
    union
    {
        struct                  /* results for spgMatchNode */
        {
            int         nodeN;      /* descend to this node (index from 0) */
            int         levelAdd;   /* increment level by this much */
            Datum       restDatum;  /* new leaf datum */
        }           matchNode;
        struct                  /* results for spgAddNode */
        {
            Datum       nodeLabel;  /* new node's label */
            int         nodeN;      /* where to insert it (index from 0) */
        }           addNode;
        struct                  /* results for spgSplitTuple */
        {
            /* Info to form new upper-level inner tuple with one child tuple */
            bool        prefixHasPrefix;    /* tuple should have a prefix? */
            Datum       prefixPrefixDatum;  /* if so, its value */
            int         prefixNNodes;       /* number of nodes */
            Datum      *prefixNodeLabels;   /* their labels (or NULL for
                                             * no labels) */
            int         childNodeN;         /* which node gets child tuple */

            /* Info to form new lower-level inner tuple with all old nodes */
            bool        postfixHasPrefix;   /* tuple should have a prefix? */
            Datum       postfixPrefixDatum; /* if so, its value */
        }           splitTuple;
    }           result;
} spgChooseOut;
</pre> <p><code class="structfield">datum</code> is the original datum of <code class="structname">spgConfigIn</code>.<code class="structfield">attType</code> type that was to be inserted into the index. <code class="structfield">leafDatum</code> is a value of <code class="structname">spgConfigOut</code>.<code class="structfield">leafType</code> type, which is initially a result of method <code class="function">compress</code> applied to <code class="structfield">datum</code> when method <code class="function">compress</code> is provided, or the same value as <code class="structfield">datum</code> otherwise. <code class="structfield">leafDatum</code> can change at lower levels of the tree if the <code class="function">choose</code> or <code class="function">picksplit</code> methods change it. When the insertion search reaches a leaf page, the current value of <code class="structfield">leafDatum</code> is what will be stored in the newly created leaf tuple. <code class="structfield">level</code> is the current inner tuple's level, starting at zero for the root level. <code class="structfield">allTheSame</code> is true if the current inner tuple is marked as containing multiple equivalent nodes (see <a class="xref" href="spgist.html#SPGIST-ALL-THE-SAME" title="64.3.4.3. “All-the-Same” Inner Tuples">Section 64.3.4.3</a>). <code class="structfield">hasPrefix</code> is true if the current inner tuple contains a prefix; if so, <code class="structfield">prefixDatum</code> is its value. <code class="structfield">nNodes</code> is the number of child nodes contained in the inner tuple, and <code class="structfield">nodeLabels</code> is an array of their label values, or NULL if there are no labels.</p> <p>The <code class="function">choose</code> function can determine either that the new value matches one of the existing child nodes, or that a new child node must be added, or that the new value is inconsistent with the tuple prefix and so the inner tuple must be split to create a less restrictive prefix.</p> <p>If the new value matches one of the existing child nodes, set <code class="structfield">resultType</code> to <code class="literal">spgMatchNode</code>. Set <code class="structfield">nodeN</code> to the index (from zero) of that node in the node array. Set <code class="structfield">levelAdd</code> to the increment in <code class="structfield">level</code> caused by descending through that node, or leave it as zero if the operator class does not use levels. Set <code class="structfield">restDatum</code> to equal <code class="structfield">leafDatum</code> if the operator class does not modify datums from one level to the next, or otherwise set it to the modified value to be used as <code class="structfield">leafDatum</code> at the next level.</p> <p>If a new child node must be added, set <code class="structfield">resultType</code> to <code class="literal">spgAddNode</code>. Set <code class="structfield">nodeLabel</code> to the label to be used for the new node, and set <code class="structfield">nodeN</code> to the index (from zero) at which to insert the node in the node array. After the node has been added, the <code class="function">choose</code> function will be called again with the modified inner tuple; that call should result in an <code class="literal">spgMatchNode</code> result.</p> <p>If the new value is inconsistent with the tuple prefix, set <code class="structfield">resultType</code> to <code class="literal">spgSplitTuple</code>. This action moves all the existing nodes into a new lower-level inner tuple, and replaces the existing inner tuple with a tuple having a single downlink pointing to the new lower-level inner tuple. Set <code class="structfield">prefixHasPrefix</code> to indicate whether the new upper tuple should have a prefix, and if so set <code class="structfield">prefixPrefixDatum</code> to the prefix value. This new prefix value must be sufficiently less restrictive than the original to accept the new value to be indexed. Set <code class="structfield">prefixNNodes</code> to the number of nodes needed in the new tuple, and set <code class="structfield">prefixNodeLabels</code> to a palloc'd array holding their labels, or to NULL if node labels are not required. Note that the total size of the new upper tuple must be no more than the total size of the tuple it is replacing; this constrains the lengths of the new prefix and new labels. Set <code class="structfield">childNodeN</code> to the index (from zero) of the node that will downlink to the new lower-level inner tuple. Set <code class="structfield">postfixHasPrefix</code> to indicate whether the new lower-level inner tuple should have a prefix, and if so set <code class="structfield">postfixPrefixDatum</code> to the prefix value. The combination of these two prefixes and the downlink node's label (if any) must have the same meaning as the original prefix, because there is no opportunity to alter the node labels that are moved to the new lower-level tuple, nor to change any child index entries. After the node has been split, the <code class="function">choose</code> function will be called again with the replacement inner tuple. That call may return an <code class="literal">spgAddNode</code> result, if no suitable node was created by the <code class="literal">spgSplitTuple</code> action. Eventually <code class="function">choose</code> must return <code class="literal">spgMatchNode</code> to allow the insertion to descend to the next level.</p> </dd> <dt><code class="function">picksplit</code></dt> <dd> <p>Decides how to create a new inner tuple over a set of leaf tuples.</p> <p>The SQL declaration of the function must look like this:</p> <pre data-language="sql">
CREATE FUNCTION my_picksplit(internal, internal) RETURNS void ...
</pre> <p>The first argument is a pointer to a <code class="structname">spgPickSplitIn</code> C struct, containing input data for the function. The second argument is a pointer to a <code class="structname">spgPickSplitOut</code> C struct, which the function must fill with result data.</p> <pre data-language="sql">
typedef struct spgPickSplitIn
{
    int         nTuples;        /* number of leaf tuples */
    Datum      *datums;         /* their datums (array of length nTuples) */
    int         level;          /* current level (counting from zero) */
} spgPickSplitIn;

typedef struct spgPickSplitOut
{
    bool        hasPrefix;      /* new inner tuple should have a prefix? */
    Datum       prefixDatum;    /* if so, its value */

    int         nNodes;         /* number of nodes for new inner tuple */
    Datum      *nodeLabels;     /* their labels (or NULL for no labels) */

    int        *mapTuplesToNodes;   /* node index for each leaf tuple */
    Datum      *leafTupleDatums;    /* datum to store in each new leaf tuple */
} spgPickSplitOut;
</pre> <p><code class="structfield">nTuples</code> is the number of leaf tuples provided. <code class="structfield">datums</code> is an array of their datum values of <code class="structname">spgConfigOut</code>.<code class="structfield">leafType</code> type. <code class="structfield">level</code> is the current level that all the leaf tuples share, which will become the level of the new inner tuple.</p> <p>Set <code class="structfield">hasPrefix</code> to indicate whether the new inner tuple should have a prefix, and if so set <code class="structfield">prefixDatum</code> to the prefix value. Set <code class="structfield">nNodes</code> to indicate the number of nodes that the new inner tuple will contain, and set <code class="structfield">nodeLabels</code> to an array of their label values, or to NULL if node labels are not required. Set <code class="structfield">mapTuplesToNodes</code> to an array that gives the index (from zero) of the node that each leaf tuple should be assigned to. Set <code class="structfield">leafTupleDatums</code> to an array of the values to be stored in the new leaf tuples (these will be the same as the input <code class="structfield">datums</code> if the operator class does not modify datums from one level to the next). Note that the <code class="function">picksplit</code> function is responsible for palloc'ing the <code class="structfield">nodeLabels</code>, <code class="structfield">mapTuplesToNodes</code> and <code class="structfield">leafTupleDatums</code> arrays.</p> <p>If more than one leaf tuple is supplied, it is expected that the <code class="function">picksplit</code> function will classify them into more than one node; otherwise it is not possible to split the leaf tuples across multiple pages, which is the ultimate purpose of this operation. Therefore, if the <code class="function">picksplit</code> function ends up placing all the leaf tuples in the same node, the core SP-GiST code will override that decision and generate an inner tuple in which the leaf tuples are assigned at random to several identically-labeled nodes. Such a tuple is marked <code class="literal">allTheSame</code> to signify that this has happened. The <code class="function">choose</code> and <code class="function">inner_consistent</code> functions must take suitable care with such inner tuples. See <a class="xref" href="spgist.html#SPGIST-ALL-THE-SAME" title="64.3.4.3. “All-the-Same” Inner Tuples">Section 64.3.4.3</a> for more information.</p> <p><code class="function">picksplit</code> can be applied to a single leaf tuple only in the case that the <code class="function">config</code> function set <code class="structfield">longValuesOK</code> to true and a larger-than-a-page input value has been supplied. In this case the point of the operation is to strip off a prefix and produce a new, shorter leaf datum value. The call will be repeated until a leaf datum short enough to fit on a page has been produced. See <a class="xref" href="spgist.html#SPGIST-LIMITS" title="64.3.4.1. SP-GiST Limits">Section 64.3.4.1</a> for more information.</p> </dd> <dt><code class="function">inner_consistent</code></dt> <dd> <p>Returns set of nodes (branches) to follow during tree search.</p> <p>The SQL declaration of the function must look like this:</p> <pre data-language="sql">
CREATE FUNCTION my_inner_consistent(internal, internal) RETURNS void ...
</pre> <p>The first argument is a pointer to a <code class="structname">spgInnerConsistentIn</code> C struct, containing input data for the function. The second argument is a pointer to a <code class="structname">spgInnerConsistentOut</code> C struct, which the function must fill with result data.</p> <pre data-language="sql">
typedef struct spgInnerConsistentIn
{
    ScanKey     scankeys;       /* array of operators and comparison values */
    ScanKey     orderbys;       /* array of ordering operators and comparison
                                 * values */
    int         nkeys;          /* length of scankeys array */
    int         norderbys;      /* length of orderbys array */

    Datum       reconstructedValue;     /* value reconstructed at parent */
    void       *traversalValue; /* opclass-specific traverse value */
    MemoryContext traversalMemoryContext;   /* put new traverse values here */
    int         level;          /* current level (counting from zero) */
    bool        returnData;     /* original data must be returned? */

    /* Data from current inner tuple */
    bool        allTheSame;     /* tuple is marked all-the-same? */
    bool        hasPrefix;      /* tuple has a prefix? */
    Datum       prefixDatum;    /* if so, the prefix value */
    int         nNodes;         /* number of nodes in the inner tuple */
    Datum      *nodeLabels;     /* node label values (NULL if none) */
} spgInnerConsistentIn;

typedef struct spgInnerConsistentOut
{
    int         nNodes;         /* number of child nodes to be visited */
    int        *nodeNumbers;    /* their indexes in the node array */
    int        *levelAdds;      /* increment level by this much for each */
    Datum      *reconstructedValues;    /* associated reconstructed values */
    void      **traversalValues;        /* opclass-specific traverse values */
    double    **distances;              /* associated distances */
} spgInnerConsistentOut;
</pre> <p>The array <code class="structfield">scankeys</code>, of length <code class="structfield">nkeys</code>, describes the index search condition(s). These conditions are combined with AND — only index entries that satisfy all of them are interesting. (Note that <code class="structfield">nkeys</code> = 0 implies that all index entries satisfy the query.) Usually the consistent function only cares about the <code class="structfield">sk_strategy</code> and <code class="structfield">sk_argument</code> fields of each array entry, which respectively give the indexable operator and comparison value. In particular it is not necessary to check <code class="structfield">sk_flags</code> to see if the comparison value is NULL, because the SP-GiST core code will filter out such conditions. The array <code class="structfield">orderbys</code>, of length <code class="structfield">norderbys</code>, describes ordering operators (if any) in the same manner. <code class="structfield">reconstructedValue</code> is the value reconstructed for the parent tuple; it is <code class="literal">(Datum) 0</code> at the root level or if the <code class="function">inner_consistent</code> function did not provide a value at the parent level. <code class="structfield">traversalValue</code> is a pointer to any traverse data passed down from the previous call of <code class="function">inner_consistent</code> on the parent index tuple, or NULL at the root level. <code class="structfield">traversalMemoryContext</code> is the memory context in which to store output traverse values (see below). <code class="structfield">level</code> is the current inner tuple's level, starting at zero for the root level. <code class="structfield">returnData</code> is <code class="literal">true</code> if reconstructed data is required for this query; this will only be so if the <code class="function">config</code> function asserted <code class="structfield">canReturnData</code>. <code class="structfield">allTheSame</code> is true if the current inner tuple is marked <span class="quote">“<span class="quote">all-the-same</span>”</span>; in this case all the nodes have the same label (if any) and so either all or none of them match the query (see <a class="xref" href="spgist.html#SPGIST-ALL-THE-SAME" title="64.3.4.3. “All-the-Same” Inner Tuples">Section 64.3.4.3</a>). <code class="structfield">hasPrefix</code> is true if the current inner tuple contains a prefix; if so, <code class="structfield">prefixDatum</code> is its value. <code class="structfield">nNodes</code> is the number of child nodes contained in the inner tuple, and <code class="structfield">nodeLabels</code> is an array of their label values, or NULL if the nodes do not have labels.</p> <p><code class="structfield">nNodes</code> must be set to the number of child nodes that need to be visited by the search, and <code class="structfield">nodeNumbers</code> must be set to an array of their indexes. If the operator class keeps track of levels, set <code class="structfield">levelAdds</code> to an array of the level increments required when descending to each node to be visited. (Often these increments will be the same for all the nodes, but that's not necessarily so, so an array is used.) If value reconstruction is needed, set <code class="structfield">reconstructedValues</code> to an array of the values reconstructed for each child node to be visited; otherwise, leave <code class="structfield">reconstructedValues</code> as NULL. The reconstructed values are assumed to be of type <code class="structname">spgConfigOut</code>.<code class="structfield">leafType</code>. (However, since the core system will do nothing with them except possibly copy them, it is sufficient for them to have the same <code class="literal">typlen</code> and <code class="literal">typbyval</code> properties as <code class="structfield">leafType</code>.) If ordered search is performed, set <code class="structfield">distances</code> to an array of distance values according to <code class="structfield">orderbys</code> array (nodes with lowest distances will be processed first). Leave it NULL otherwise. If it is desired to pass down additional out-of-band information (<span class="quote">“<span class="quote">traverse values</span>”</span>) to lower levels of the tree search, set <code class="structfield">traversalValues</code> to an array of the appropriate traverse values, one for each child node to be visited; otherwise, leave <code class="structfield">traversalValues</code> as NULL. Note that the <code class="function">inner_consistent</code> function is responsible for palloc'ing the <code class="structfield">nodeNumbers</code>, <code class="structfield">levelAdds</code>, <code class="structfield">distances</code>, <code class="structfield">reconstructedValues</code>, and <code class="structfield">traversalValues</code> arrays in the current memory context. However, any output traverse values pointed to by the <code class="structfield">traversalValues</code> array should be allocated in <code class="structfield">traversalMemoryContext</code>. Each traverse value must be a single palloc'd chunk.</p> </dd> <dt><code class="function">leaf_consistent</code></dt> <dd> <p>Returns true if a leaf tuple satisfies a query.</p> <p>The SQL declaration of the function must look like this:</p> <pre data-language="sql">
CREATE FUNCTION my_leaf_consistent(internal, internal) RETURNS bool ...
</pre> <p>The first argument is a pointer to a <code class="structname">spgLeafConsistentIn</code> C struct, containing input data for the function. The second argument is a pointer to a <code class="structname">spgLeafConsistentOut</code> C struct, which the function must fill with result data.</p> <pre data-language="sql">
typedef struct spgLeafConsistentIn
{
    ScanKey     scankeys;       /* array of operators and comparison values */
    ScanKey     orderbys;       /* array of ordering operators and comparison
                                 * values */
    int         nkeys;          /* length of scankeys array */
    int         norderbys;      /* length of orderbys array */

    Datum       reconstructedValue;     /* value reconstructed at parent */
    void       *traversalValue; /* opclass-specific traverse value */
    int         level;          /* current level (counting from zero) */
    bool        returnData;     /* original data must be returned? */

    Datum       leafDatum;      /* datum in leaf tuple */
} spgLeafConsistentIn;

typedef struct spgLeafConsistentOut
{
    Datum       leafValue;        /* reconstructed original data, if any */
    bool        recheck;          /* set true if operator must be rechecked */
    bool        recheckDistances; /* set true if distances must be rechecked */
    double     *distances;        /* associated distances */
} spgLeafConsistentOut;
</pre> <p>The array <code class="structfield">scankeys</code>, of length <code class="structfield">nkeys</code>, describes the index search condition(s). These conditions are combined with AND — only index entries that satisfy all of them satisfy the query. (Note that <code class="structfield">nkeys</code> = 0 implies that all index entries satisfy the query.) Usually the consistent function only cares about the <code class="structfield">sk_strategy</code> and <code class="structfield">sk_argument</code> fields of each array entry, which respectively give the indexable operator and comparison value. In particular it is not necessary to check <code class="structfield">sk_flags</code> to see if the comparison value is NULL, because the SP-GiST core code will filter out such conditions. The array <code class="structfield">orderbys</code>, of length <code class="structfield">norderbys</code>, describes the ordering operators in the same manner. <code class="structfield">reconstructedValue</code> is the value reconstructed for the parent tuple; it is <code class="literal">(Datum) 0</code> at the root level or if the <code class="function">inner_consistent</code> function did not provide a value at the parent level. <code class="structfield">traversalValue</code> is a pointer to any traverse data passed down from the previous call of <code class="function">inner_consistent</code> on the parent index tuple, or NULL at the root level. <code class="structfield">level</code> is the current leaf tuple's level, starting at zero for the root level. <code class="structfield">returnData</code> is <code class="literal">true</code> if reconstructed data is required for this query; this will only be so if the <code class="function">config</code> function asserted <code class="structfield">canReturnData</code>. <code class="structfield">leafDatum</code> is the key value of <code class="structname">spgConfigOut</code>.<code class="structfield">leafType</code> stored in the current leaf tuple.</p> <p>The function must return <code class="literal">true</code> if the leaf tuple matches the query, or <code class="literal">false</code> if not. In the <code class="literal">true</code> case, if <code class="structfield">returnData</code> is <code class="literal">true</code> then <code class="structfield">leafValue</code> must be set to the value (of type <code class="structname">spgConfigIn</code>.<code class="structfield">attType</code>) originally supplied to be indexed for this leaf tuple. Also, <code class="structfield">recheck</code> may be set to <code class="literal">true</code> if the match is uncertain and so the operator(s) must be re-applied to the actual heap tuple to verify the match. If ordered search is performed, set <code class="structfield">distances</code> to an array of distance values according to <code class="structfield">orderbys</code> array. Leave it NULL otherwise. If at least one of returned distances is not exact, set <code class="structfield">recheckDistances</code> to true. In this case, the executor will calculate the exact distances after fetching the tuple from the heap, and will reorder the tuples if needed.</p> </dd> </dl> </div> <p>The optional user-defined methods are:</p> <div class="variablelist"> <dl class="variablelist"> <dt><code class="function">Datum compress(Datum in)</code></dt> <dd> <p>Converts a data item into a format suitable for physical storage in a leaf tuple of the index. It accepts a value of type <code class="structname">spgConfigIn</code>.<code class="structfield">attType</code> and returns a value of type <code class="structname">spgConfigOut</code>.<code class="structfield">leafType</code>. The output value must not contain an out-of-line TOAST pointer.</p> <p>Note: the <code class="function">compress</code> method is only applied to values to be stored. The consistent methods receive query <code class="structfield">scankeys</code> unchanged, without transformation using <code class="function">compress</code>.</p> </dd> <dt><code class="function">options</code></dt> <dd> <p>Defines a set of user-visible parameters that control operator class behavior.</p> <p>The SQL declaration of the function must look like this:</p> <pre data-language="sql">
CREATE OR REPLACE FUNCTION my_options(internal)
RETURNS void
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;
</pre> <p>The function is passed a pointer to a <code class="structname">local_relopts</code> struct, which needs to be filled with a set of operator class specific options. The options can be accessed from other support functions using the <code class="literal">PG_HAS_OPCLASS_OPTIONS()</code> and <code class="literal">PG_GET_OPCLASS_OPTIONS()</code> macros.</p> <p>Since the representation of the key in SP-GiST is flexible, it may depend on user-specified parameters.</p> </dd> </dl> </div> <p>All the SP-GiST support methods are normally called in a short-lived memory context; that is, <code class="varname">CurrentMemoryContext</code> will be reset after processing of each tuple. It is therefore not very important to worry about pfree'ing everything you palloc. (The <code class="function">config</code> method is an exception: it should try to avoid leaking memory. But usually the <code class="function">config</code> method need do nothing but assign constants into the passed parameter struct.)</p> <p>If the indexed column is of a collatable data type, the index collation will be passed to all the support methods, using the standard <code class="function">PG_GET_COLLATION()</code> mechanism.</p> </div> <div class="sect2" id="SPGIST-IMPLEMENTATION">    <h2 class="title">64.3.4. Implementation </h2>    <p>This section covers implementation details and other tricks that are useful for implementers of SP-GiST operator classes to know.</p> <div class="sect3" id="SPGIST-LIMITS">    <h3 class="title">64.3.4.1. SP-GiST Limits </h3>    <p>Individual leaf tuples and inner tuples must fit on a single index page (8kB by default). Therefore, when indexing values of variable-length data types, long values can only be supported by methods such as radix trees, in which each level of the tree includes a prefix that is short enough to fit on a page, and the final leaf level includes a suffix also short enough to fit on a page. The operator class should set <code class="structfield">longValuesOK</code> to true only if it is prepared to arrange for this to happen. Otherwise, the SP-GiST core will reject any request to index a value that is too large to fit on an index page.</p> <p>Likewise, it is the operator class's responsibility that inner tuples do not grow too large to fit on an index page; this limits the number of child nodes that can be used in one inner tuple, as well as the maximum size of a prefix value.</p> <p>Another limitation is that when an inner tuple's node points to a set of leaf tuples, those tuples must all be in the same index page. (This is a design decision to reduce seeking and save space in the links that chain such tuples together.) If the set of leaf tuples grows too large for a page, a split is performed and an intermediate inner tuple is inserted. For this to fix the problem, the new inner tuple <span class="emphasis"><em>must</em></span> divide the set of leaf values into more than one node group. If the operator class's <code class="function">picksplit</code> function fails to do that, the SP-GiST core resorts to extraordinary measures described in <a class="xref" href="spgist.html#SPGIST-ALL-THE-SAME" title="64.3.4.3. “All-the-Same” Inner Tuples">Section 64.3.4.3</a>.</p> <p>When <code class="structfield">longValuesOK</code> is true, it is expected that successive levels of the SP-GiST tree will absorb more and more information into the prefixes and node labels of the inner tuples, making the required leaf datum smaller and smaller, so that eventually it will fit on a page. To prevent bugs in operator classes from causing infinite insertion loops, the SP-GiST core will raise an error if the leaf datum does not become any smaller within ten cycles of <code class="function">choose</code> method calls.</p> </div> <div class="sect3" id="SPGIST-NULL-LABELS">    <h3 class="title">64.3.4.2. SP-GiST Without Node Labels </h3>    <p>Some tree algorithms use a fixed set of nodes for each inner tuple; for example, in a quad-tree there are always exactly four nodes corresponding to the four quadrants around the inner tuple's centroid point. In such a case the code typically works with the nodes by number, and there is no need for explicit node labels. To suppress node labels (and thereby save some space), the <code class="function">picksplit</code> function can return NULL for the <code class="structfield">nodeLabels</code> array, and likewise the <code class="function">choose</code> function can return NULL for the <code class="structfield">prefixNodeLabels</code> array during a <code class="literal">spgSplitTuple</code> action. This will in turn result in <code class="structfield">nodeLabels</code> being NULL during subsequent calls to <code class="function">choose</code> and <code class="function">inner_consistent</code>. In principle, node labels could be used for some inner tuples and omitted for others in the same index.</p> <p>When working with an inner tuple having unlabeled nodes, it is an error for <code class="function">choose</code> to return <code class="literal">spgAddNode</code>, since the set of nodes is supposed to be fixed in such cases.</p> </div> <div class="sect3" id="SPGIST-ALL-THE-SAME">    <h3 class="title">64.3.4.3. <span class="quote">“<span class="quote">All-the-Same</span>”</span> Inner Tuples </h3>    <p>The SP-GiST core can override the results of the operator class's <code class="function">picksplit</code> function when <code class="function">picksplit</code> fails to divide the supplied leaf values into at least two node categories. When this happens, the new inner tuple is created with multiple nodes that each have the same label (if any) that <code class="function">picksplit</code> gave to the one node it did use, and the leaf values are divided at random among these equivalent nodes. The <code class="literal">allTheSame</code> flag is set on the inner tuple to warn the <code class="function">choose</code> and <code class="function">inner_consistent</code> functions that the tuple does not have the node set that they might otherwise expect.</p> <p>When dealing with an <code class="literal">allTheSame</code> tuple, a <code class="function">choose</code> result of <code class="literal">spgMatchNode</code> is interpreted to mean that the new value can be assigned to any of the equivalent nodes; the core code will ignore the supplied <code class="structfield">nodeN</code> value and descend into one of the nodes at random (so as to keep the tree balanced). It is an error for <code class="function">choose</code> to return <code class="literal">spgAddNode</code>, since that would make the nodes not all equivalent; the <code class="literal">spgSplitTuple</code> action must be used if the value to be inserted doesn't match the existing nodes.</p> <p>When dealing with an <code class="literal">allTheSame</code> tuple, the <code class="function">inner_consistent</code> function should return either all or none of the nodes as targets for continuing the index search, since they are all equivalent. This may or may not require any special-case code, depending on how much the <code class="function">inner_consistent</code> function normally assumes about the meaning of the nodes.</p> </div> </div> <div class="sect2" id="SPGIST-EXAMPLES">    <h2 class="title">64.3.5. Examples </h2>    <p>The PostgreSQL source distribution includes several examples of index operator classes for SP-GiST, as described in <a class="xref" href="spgist.html#SPGIST-BUILTIN-OPCLASSES-TABLE" title="Table 64.2. Built-in SP-GiST Operator Classes">Table 64.2</a>. Look into <code class="filename">src/backend/access/spgist/</code> and <code class="filename">src/backend/utils/adt/</code> to see the code.</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996&ndash;2024 The PostgreSQL Global Development Group<br>Licensed under the PostgreSQL License.<br>
    <a href="https://www.postgresql.org/docs/17/spgist.html" class="_attribution-link">https://www.postgresql.org/docs/17/spgist.html</a>
  </p>
</div>
