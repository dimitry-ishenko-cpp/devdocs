<h1>Observable Arrays</h1> <p>If you want to detect and respond to changes on one object, you’d use <a href="observables.html">observables</a>. If you want to detect and respond to changes of a <em>collection of things</em>, use an observableArray. This is useful in many scenarios where you’re displaying or editing multiple values and need repeated sections of UI to appear and disappear as items are added and removed.</p> <h3 id="example">Example</h3> <div class="highlight"><pre class="highlight" data-language="javascript">var myObservableArray = ko.observableArray();    // Initially an empty array
myObservableArray.push('Some value');            // Adds the value and notifies observers
</pre></div> <p>To see how you can bind the observableArray to a UI and let the user modify it, see <a href="https://knockoutjs.com/examples/simpleList.html">the simple list example</a>.</p> <h3 id="key-point-an-observablearray-tracks-which-objects-are-in-the-array-not-the-state-of-those-objects">Key point: An observableArray tracks which objects are <em>in</em> the array, <em>not</em> the state of those objects</h3> <p>Simply putting an object into an observableArray doesn’t make all of that object’s properties themselves observable. Of course, you can make those properties observable if you wish, but that’s an independent choice. An observableArray just tracks which objects it holds, and notifies listeners when objects are added or removed.</p> <h2 id="prepopulating-an-observablearray">Prepopulating an observableArray</h2> <p>If you want your observable array <strong>not</strong> to start empty, but to contain some initial items, pass those items as an array to the constructor. For example,</p> <div class="highlight"><pre class="highlight" data-language="javascript">// This observable array initially contains three objects
var anotherObservableArray = ko.observableArray([
    { name: "Bungle", type: "Bear" },
    { name: "George", type: "Hippo" },
    { name: "Zippy", type: "Unknown" }
]);
</pre></div> <h2 id="reading-information-from-an-observablearray">Reading information from an observableArray</h2> <p>Behind the scenes, an observableArray is actually an <a href="observables.html">observable</a> whose value is an array (plus, observableArray adds some additional features described below). So, you can get the underlying JavaScript array by invoking the observableArray as a function with no parameters, just like any other observable. Then you can read information from that underlying array. For example,</p> <div class="highlight"><pre class="highlight" data-language="javascript">alert('The length of the array is ' + myObservableArray().length);
alert('The first element is ' + myObservableArray()[0]);
</pre></div> <p>Technically you can use any of the native JavaScript array functions to operate on that underlying array, but normally there’s a better alternative. KO’s observableArray has equivalent functions of its own, and they’re more useful because:</p> <ol> <li>They work on all targeted browsers. (For example, the native JavaScript indexOf function doesn’t work on IE 8 or earlier, but KO’s indexOf works everywhere.)</li> <li>For functions that modify the contents of the array, such as push and splice, KO’s methods automatically trigger the dependency tracking mechanism so that all registered listeners are notified of the change, and your UI is automatically updated which means there is a significant difference between using KO’s methods (i.e., observableArray.push(...) ) and JavaScript native array methods (i.e., observableArray().push(...)) as the latter don’t send any notification to the array’s subscribers that its content has changed.</li> </ol> <p>The rest of this page describes observableArray’s functions for reading and writing array information.</p> <h3 id="indexof">indexOf</h3> <p>The indexOf function returns the index of the first array item that equals your parameter. For example, myObservableArray.indexOf('Blah') will return the zero-based index of the first array entry that equals Blah, or the value -1 if no matching value was found.</p> <h3 id="slice">slice</h3> <p>The slice function is the observableArray equivalent of the native JavaScript slice function (i.e., it returns the entries of your array from a given start index up to a given end index). Calling myObservableArray.slice(...) is equivalent to calling the same method on the underlying array (i.e., myObservableArray().slice(...)).</p> <h2 id="manipulating-an-observablearray">Manipulating an observableArray</h2> <p>observableArray exposes a familiar set of functions for modifying the contents of the array and notifying listeners.</p> <h3 id="pop-push-shift-unshift-reverse-sort-splice">pop, push, shift, unshift, reverse, sort, splice</h3> <p>All of these functions are equivalent to running the native JavaScript array functions on the underlying array, and then notifying listeners about the change:</p> <ul> <li>push( value ) — Adds a new item to the end of array.</li> <li>pop() — Removes the last value from the array and returns it.</li> <li>unshift( value ) — Inserts a new item at the beginning of the array.</li> <li>shift() — Removes the first value from the array and returns it.</li> <li>reverse() — Reverses the order of the array and returns the observableArray (not the underlying array).</li> <li>sort() — Sorts the array contents and returns the observableArray. The default sort is alphabetical, but you can optionally pass a function to control how the array should be sorted. See the example under sorted below.</li> <li>splice() — Removes and returns a given number of elements starting from a given index. For example, myObservableArray.splice(1, 3) removes three elements starting from index position 1 (i.e., the 2nd, 3rd, and 4th elements) and returns them as an array.</li> </ul> <p>For more details about these observableArray functions, see the equivalent documentation of the <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array#Methods_2">standard JavaScript array functions</a>.</p> <h3 id="sorted-and-reversed">sorted and reversed</h3> <ul> <li> <p>sorted() — Returns a sorted <strong>copy</strong> of the array. This is preferable to sort if you want to leave the observable array in its original order but need to display it in a specific order.</p> <p>The default sort is alphabetical, but you can optionally pass a function to control how the array should be sorted. Your function should accept any two objects from the array and return a negative value if the first argument is smaller, a positive value is the second is smaller, or zero to treat them as equal. For example, to sort an array of ‘person’ objects by last name, you could write:</p> <div class="highlight"><pre class="highlight" data-language="javascript">var mySortedArray = ko.pureComputed(function () {
    return myObservableArray.sorted(function (left, right) {
        return left.lastName === right.lastName ? 0
             : left.lastName &lt; right.lastName ? -1
             : 1;
    });
});
</pre></div>  </li> <li> <p>reversed() — Returns a reversed <strong>copy</strong> of the array.</p> </li> </ul> <h3 id="replace-remove-and-removeall">replace, remove and removeAll</h3> <p>observableArray adds some more useful methods that aren’t found on JavaScript arrays by default:</p> <ul> <li>replace( oldItem, newItem ) — Replaces the first value that equals oldItem with newItem.</li> <li>remove( someItem ) — Removes all values that equal someItem and returns them as an array.</li> <li>remove( function (item) { return item.age &lt; 18; } ) — Removes all values whose age property is less than 18, and returns them as an array.</li> <li>removeAll( ['Chad', 132, undefined] ) — Removes all values that equal 'Chad', 123, or undefined and returns them as an array.</li> <li>removeAll() — Removes all values and returns them as an array.</li> </ul> <h3 id="destroy-and-destroyall">destroy and destroyAll (Note: Usually relevant to Ruby on Rails developers only)</h3> <p>The destroy and destroyAll functions are mainly intended as a convenience for developers using Ruby on Rails:</p> <ul> <li>destroy( someItem ) — Finds any objects in the array that equal someItem and gives them a special property called _destroy with value true.</li> <li>destroy( function (someItem) { return someItem.age &lt; 18; } ) — Finds any objects in the array whose age property is less than 18, and gives those objects a special property called _destroy with value true.</li> <li>destroyAll( ['Chad', 132, undefined] ) — Finds any objects in the array that equal 'Chad', 123, or undefined and gives them a special property called _destroy with value true.</li> <li>destroyAll() — Gives a special property called _destroy with value true to all objects in the array.</li> </ul> <p>So, what’s this _destroy thing all about? It’s only really interesting to Rails developers. The convention in Rails is that, when you pass into an action a JSON object graph, the framework can automatically convert it to an ActiveRecord object graph and then save it to your database. It knows which of the objects are already in your database, and issues the correct INSERT or UPDATE statements. To tell the framework to DELETE a record, you just mark it with _destroy set to true.</p> <p>When Knockout renders a foreach binding with the parameter includeDestroyed: false set, it will hide any objects marked with _destroy equal to true. So, you can have some kind of “delete” button that invokes the destroy(someItem) method on the array, and this will immediately cause the specified item to vanish from the visible UI. Later, when you submit the JSON object graph to Rails, that item will also be deleted from the database (while the other array items will be inserted or updated as usual).</p> <h2 id="determining-if-a-property-is-an-observablearray">Determining if a property is an observableArray</h2> <p>In some scenarios, it is useful to programmatically determine if you are dealing with an observableArray. Knockout provides a utility function, ko.isObservableArray to help with this situation.</p> <h2 id="delaying-andor-suppressing-change-notifications">Delaying and/or suppressing change notifications</h2> <p>Normally, an observableArray notifies its subscribers immediately, as soon as it’s changed. But if an observableArray is changed repeatedly or triggers expensive updates, you may get better performance by limiting or delaying change notifications. This is accomplished using the <a href="ratelimit-observable.html">rateLimit extender</a> like this:</p> <div class="highlight"><pre class="highlight" data-language="javascript">// Ensure it notifies about changes no more than once per 50-millisecond period
myViewModel.myObservableArray.extend({ rateLimit: 50 });
</pre></div> <h2 id="tracking-array-changes">Tracking array changes</h2> <p>Although you can subscribe to and access an observableArray just like any other observable, Knockout also provides a super-fast method to find out how an observable array has changed (i.e., which items were just added, deleted, or moved). You subscribe to array changes as follows:</p> <div class="highlight"><pre class="highlight" data-language="javascript">obsArray.subscribe(fn, thisArg, "arrayChange");
</pre></div> <p>The main advantages of subscribing to changes:</p> <ul> <li> <p>Performance is O(1) in most cases, i.e., there’s basically no performance implication at all, because for straightforward operations, (push, splice, etc.) Knockout supplies the change log without running any difference algorithm. Knockout only falls back on an algorithm if you’ve made an arbitrary change without using a typical array mutation function.</p> </li> <li> <p>The change log just gives you the items that actually changed.</p> </li> </ul> <p>Here are examples of how the changes are reported:</p> <div class="highlight"><pre class="highlight" data-language="javascript">var myArray = ko.observableArray(["Alpha", "Beta", "Gamma"]);

myArray.push("Delta");
// Changes: [{ index: 3, status: 'added', value: 'Delta' }]
// New value: ["Alpha", "Beta", "Gamma", "Delta"]

myArray.pop();
// Changes: [{ index: 3, status: 'deleted', value: 'Delta' }]
// New value: ["Alpha", "Beta", "Gamma"]

myArray.splice(1, 2, "Omega");
// Changes:
// [{ index: 1, status: 'deleted', value: 'Beta' },
//  { index: 1, status: 'added', value: 'Omega' },
//  { index: 2, status: 'deleted', value: 'Gamma' }]
// New value: ["Alpha", "Omega"]

myArray.reverse();
// Changes:
// [{ index: 0, moved: 1, status: 'deleted', value: 'Alpha' },
//  { index: 1, moved: 0, status: 'added', value: 'Alpha' }]
// New value: ["Omega", "Alpha"]
</pre></div> <p>As shown above, the changes are reported as a list of <em>added</em> and <em>deleted</em> values. The indexes for <em>deleted</em> items refer to the original array, and the indexes for <em>added</em> items refer to the new array.</p> <p>When items are re-ordered, as shown in the last example above, you will also get <em>moved</em> information. You can choose to ignore the <em>moved</em> information and just interpret it as the original Alpha being deleted and a different Alpha being added to the array’s end. Or you can recognize that the <em>moved</em> information tells you that you can think of the <em>added</em> and <em>deleted</em> values being the same item that just changes position (by matching up the indexes).</p> <p>An observableArray has array tracking enabled at construction, but you can extend any other subscribable (i.e. ko.observable and ko.computed) as follows:</p> <div class="highlight"><pre class="highlight" data-language="javascript">trackable = ko.observable().extend({trackArrayChanges: true});
</pre></div><div class="_attribution">
  <p class="_attribution-p">
    &copy; Steven Sanderson, the Knockout.js team, and other contributors<br>Licensed under the MIT License.<br>
    <a href="https://knockoutjs.com/documentation/observableArrays.html" class="_attribution-link">https://knockoutjs.com/documentation/observableArrays.html</a>
  </p>
</div>
