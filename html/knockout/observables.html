<h1>Observables</h1> <p>Knockout is built around three core features:</p> <ol> <li>Observables and dependency tracking</li> <li>Declarative bindings</li> <li>Templating</li> </ol> <p>On this page, you’ll learn about the first of these three. But before that, let’s examine the MVVM pattern and the concept of a <em>view model</em>.</p> <h2 id="mvvm-and-view-models">MVVM and View Models</h2> <p><em>Model-View-View Model (MVVM)</em> is a design pattern for building user interfaces. It describes how you can keep a potentially sophisticated UI simple by splitting it into three parts:</p> <ul> <li> <p>A <em>model</em>: your application’s stored data. This data represents objects and operations in your business domain (e.g., bank accounts that can perform money transfers) and is independent of any UI. When using KO, you will usually make Ajax calls to some server-side code to read and write this stored model data.</p> </li> <li> <p>A <em>view model</em>: a pure-code representation of the data and operations on a UI. For example, if you’re implementing a list editor, your view model would be an object holding a list of items, and exposing methods to add and remove items.</p> <p>Note that this is not the UI itself: it doesn’t have any concept of buttons or display styles. It’s not the persisted data model either - it holds the unsaved data the user is working with. When using KO, your view models are pure JavaScript objects that hold no knowledge of HTML. Keeping the view model abstract in this way lets it stay simple, so you can manage more sophisticated behaviors without getting lost.</p> </li> <li> <p>A <em>view</em>: a visible, interactive UI representing the state of the view model. It displays information from the view model, sends commands to the view model (e.g., when the user clicks buttons), and updates whenever the state of the view model changes.</p> <p>When using KO, your view is simply your HTML document with declarative bindings to link it to the view model. Alternatively, you can use templates that generate HTML using data from your view model.</p> </li> </ul> <p>To create a view model with KO, just declare any JavaScript object. For example,</p> <div class="highlight"><pre class="highlight" data-language="javascript">var myViewModel = {
    personName: 'Bob',
    personAge: 123
};
</pre></div> <p>You can then create a very simple <em>view</em> of this view model using a declarative binding. For example, the following markup displays the personName value:</p> <div class="highlight"><pre class="highlight" data-language="markup">The name is &lt;span data-bind="text: personName"&gt;&lt;/span&gt;
</pre></div> <h2 id="activating-knockout">Activating Knockout</h2> <p>The data-bind attribute isn’t native to HTML, though it is perfectly OK (it’s strictly compliant in HTML 5, and causes no problems with HTML 4 even though a validator will point out that it’s an unrecognized attribute). But since the browser doesn’t know what it means, you need to activate Knockout to make it take effect.</p> <p>To activate Knockout, add the following line to a &lt;script&gt; block:</p> <div class="highlight"><pre class="highlight" data-language="javascript">ko.applyBindings(myViewModel);
</pre></div> <p>You can either put the script block at the bottom of your HTML document, or you can put it at the top and wrap the contents in a DOM-ready handler such as <a href="http://api.jquery.com/jQuery/#jQuery3">jQuery’s $ function</a>.</p> <p>That does it! Now, your view will display as if you’d written the following HTML:</p> <div class="highlight"><pre class="highlight" data-language="javascript">The name is &lt;span&gt;Bob&lt;/span&gt;
</pre></div> <p>In case you’re wondering what the parameters to ko.applyBindings do,</p> <ul> <li> <p>The first parameter says what view model object you want to use with the declarative bindings it activates</p> </li> <li> <p>Optionally, you can pass a second parameter to define which part of the document you want to search for data-bind attributes. For example, ko.applyBindings(myViewModel, document.getElementById('someElementId')). This restricts the activation to the element with ID someElementId and its descendants, which is useful if you want to have multiple view models and associate each with a different region of the page.</p> </li> </ul> <p>Pretty simple, really.</p> <h2 id="observables">Observables</h2> <p>OK, you’ve seen how to create a basic view model and how to display one of its properties using a binding. But one of the key benefits of KO is that it updates your UI automatically when the view model changes. How can KO know when parts of your view model change? Answer: you need to declare your model properties as <em>observables</em>, because these are special JavaScript objects that can notify subscribers about changes, and can automatically detect dependencies.</p> <p>For example, rewrite the preceding view model object as follows:</p> <div class="highlight"><pre class="highlight" data-language="javascript">var myViewModel = {
    personName: ko.observable('Bob'),
    personAge: ko.observable(123)
};
</pre></div> <p>You don’t have to change the view at all - the same data-bind syntax will keep working. The difference is that it’s now capable of detecting changes, and when it does, it will update the view automatically.</p> <h2 id="reading-and-writing-observables">Reading and writing observables</h2> <p>Not all browsers support JavaScript getters and setters (* cough * IE * cough *), so for compatibility, ko.observable objects are actually <em>functions</em>.</p> <ul> <li> <p>To <strong>read</strong> the observable’s current value, just call the observable with no parameters. In this example, myViewModel.personName() will return 'Bob', and myViewModel.personAge() will return 123.</p> </li> <li> <p>To <strong>write</strong> a new value to the observable, call the observable and pass the new value as a parameter. For example, calling myViewModel.personName('Mary') will change the name value to 'Mary'.</p> </li> <li> <p>To write values to <strong>multiple observable properties</strong> on a model object, you can use <em>chaining syntax</em>. For example, myViewModel.personName('Mary').personAge(50) will change the name value to 'Mary' <em>and</em> the age value to 50.</p> </li> </ul> <p>The whole point of observables is that they can be observed, i.e., other code can say that it wants to be notified of changes. That’s what many of KO’s built-in bindings do internally. So, when you wrote data-bind="text: personName", the text binding registered itself to be notified when personName changes (assuming it’s an observable value, which it is now).</p> <p>When you change the name value to 'Mary' by calling myViewModel.personName('Mary'), the text binding will automatically update the text contents of the associated DOM element. That’s how changes to the view model automatically propagate to the view.</p> <h2 id="explicitly-subscribing-to-observables">Explicitly subscribing to observables</h2> <p><em>You won’t normally need to set up subscriptions manually, so beginners should skip this section.</em></p> <p>For advanced users, if you want to register your own subscriptions to be notified of changes to observables, you can call their subscribe function. For example:</p> <div class="highlight"><pre class="highlight" data-language="javascript">myViewModel.personName.subscribe(function(newValue) {
    alert("The person's new name is " + newValue);
});
</pre></div> <p>The subscribe function is how many parts of KO work internally. Most of the time you don’t need to use this, because the built-in bindings and templating system take care of managing subscriptions.</p> <p>The subscribe function accepts three parameters: callback is the function that is called whenever the notification happens, target (optional) defines the value of this in the callback function, and event (optional; default is "change") is the name of the event to receive notification for.</p> <p>You can also terminate a subscription if you wish: first capture the return value as a variable, then you can call its dispose function, e.g.:</p> <div class="highlight"><pre class="highlight" data-language="javascript">var subscription = myViewModel.personName.subscribe(function(newValue) { /* do stuff */ });
// ...then later...
subscription.dispose(); // I no longer want notifications
</pre></div> <p>If you want to be notified of the value of an observable before it is about to be changed, you can subscribe to the beforeChange event. For example:</p> <div class="highlight"><pre class="highlight" data-language="javascript">myViewModel.personName.subscribe(function(oldValue) {
    alert("The person's previous name is " + oldValue);
}, null, "beforeChange");
</pre></div> <p>Note: Knockout does not guarantee that the beforeChange and change events will occur in pairs, since other parts of your code might raise either event individually. If you need to track the previous value of an observable, it’s up to you to use a subscription to capture and track it.</p> <h2 id="reacting-to-a-specific-observable-event-with-kowhen">Reacting to a specific observable event with “ko.when”</h2> <p><em>This advanced technique for working with observables was added in Knockout 3.5.</em></p> <p>Sometimes, rather than reacting to every change to an observable, you just need to know when the observable arrives at a specific value. This is what ko.when makes easy. For example:</p> <div class="highlight"><pre class="highlight" data-language="javascript">ko.when(function () {
    return myViewModel.personName() !== undefined;
}, function (result) {
    myViewModel.isInitialized(true);
});
</pre></div> <p>ko.when waits until the first function (predicate) returns true or a true-ish value, at which time it runs the second function (callback), passing the predicate result. You can optionally pass in a third parameter (context) that defines the value of this for the predicate and callback functions. ko.when returns a subscription object that you can use the cancel the action.</p> <p>ko.when can also be called with just the predicate function. In that case, it returns a Promise that will be resolved with the predicate result once the predicate returns a true-ish value.</p> <h2 id="forcing-observables-to-always-notify-subscribers">Forcing observables to always notify subscribers</h2> <p>When writing to an observable that contains a primitive value (a number, string, boolean, or null), the dependencies of the observable are normally only notified if the value actually changed. However, it is possible to use the built-in notify <a href="extenders.html">extender</a> to ensure that an observable’s subscribers are always notified on a write, even if the value is the same. You would apply the extender to an observable like this:</p> <div class="highlight"><pre class="highlight" data-language="javascript">myViewModel.personName.extend({ notify: 'always' });
</pre></div> <h2 id="delaying-andor-suppressing-change-notifications">Delaying and/or suppressing change notifications</h2> <p>Normally, an observable notifies its subscribers immediately, as soon as it’s changed. But if an observable is changed repeatedly or triggers expensive updates, you may get better performance by limiting or delaying the observable’s change notifications. This is accomplished using the <a href="ratelimit-observable.html">rateLimit extender</a> like this:</p> <div class="highlight"><pre class="highlight" data-language="javascript">// Ensure it notifies about changes no more than once per 50-millisecond period
myViewModel.personName.extend({ rateLimit: 50 });
</pre></div><div class="_attribution">
  <p class="_attribution-p">
    &copy; Steven Sanderson, the Knockout.js team, and other contributors<br>Licensed under the MIT License.<br>
    <a href="https://knockoutjs.com/documentation/observables.html" class="_attribution-link">https://knockoutjs.com/documentation/observables.html</a>
  </p>
</div>
