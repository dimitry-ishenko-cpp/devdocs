<h1>The "selectedOptions" binding</h1> <h3 id="purpose">Purpose</h3> <p>The selectedOptions binding controls which elements in a multi-select list are currently selected. This is intended to be used in conjunction with a &lt;select&gt; element and the options binding.</p> <p>When the user selects or de-selects an item in the multi-select list, this adds or removes the corresponding value to an array on your view model. Likewise, assuming it’s an <em>observable</em> array on your view model, then whenever you add or remove (e.g., via push or splice) items to this array, the corresponding items in the UI become selected or deselected. It’s a 2-way binding.</p> <p>Note: To control which element in a single-select drop-down list is selected, you can use <a href="value-binding.html">the value binding</a> instead.</p> <h3 id="example">Example</h3> <div class="highlight"><pre class="highlight" data-language="markup">&lt;p&gt;
    Choose some countries you'd like to visit: 
    &lt;select data-bind="options: availableCountries, selectedOptions: chosenCountries" size="5" multiple="true"&gt;&lt;/select&gt;
&lt;/p&gt;

&lt;script type="text/javascript"&gt;
    var viewModel = {
        availableCountries : ko.observableArray(['France', 'Germany', 'Spain']),
        chosenCountries : ko.observableArray(['Germany']) // Initially, only Germany is selected
    };
    
    // ... then later ...
    viewModel.chosenCountries.push('France'); // Now France is selected too
&lt;/script&gt;
</pre></div> <h3 id="parameters">Parameters</h3> <ul> <li> <p>Main parameter</p> <p>This should be an array (or an observable array). KO sets the element’s selected options to match the contents of the array. Any previous selection state will be overwritten.</p> <p>If your parameter is an observable array, the binding will update the element’s selection whenever the array changes (e.g., via push, pop or <a href="observablearrays.html">other observable array methods</a>). If the parameter isn’t observable, it will only set the element’s selection state once and will not update it again later.</p> <p>Whether or not the parameter is an observable array, KO will detect when the user selects or deselects an item in the multi-select list, and will update the array to match. This is how you can read which of the options is selected.</p> </li> <li> <p>Additional parameters</p> <ul> <li>None</li> </ul> </li> </ul> <h3 id="note-letting-the-user-select-from-arbitrary-javascript-objects">Note: Letting the user select from arbitrary JavaScript objects</h3> <p>In the example code above, the user can choose from an array of string values. You’re <em>not</em> limited to providing strings - your options array can contain arbitrary JavaScript objects if you wish. See <a href="options-binding.html">the options binding</a> for details on how to control how arbitrary objects should be displayed in the list.</p> <p>In this scenario, the values you can read and write using selectedOptions are those objects themselves, <em>not</em> their textual representations. This leads to much cleaner and more elegant code in most cases. Your view model can imagine that the user chooses from an array of arbitrary objects, without having to care how those objects are mapped to an on-screen representation.</p> <h3 id="dependencies">Dependencies</h3> <p>None, other than the core Knockout library.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; Steven Sanderson, the Knockout.js team, and other contributors<br>Licensed under the MIT License.<br>
    <a href="https://knockoutjs.com/documentation/selectedOptions-binding.html" class="_attribution-link">https://knockoutjs.com/documentation/selectedOptions-binding.html</a>
  </p>
</div>
