<h1>Computed Observable Reference</h1> <p>The following documentation describes how to construct and work with computed observables.</p> <h2 id="constructing-a-computed-observable">Constructing a computed observable</h2> <p>A computed observable can be constructed using one of the following forms:</p> <ol> <li>ko.computed( evaluator [, targetObject, options] ) — This form supports the most common case of creating a computed observable. <ul> <li>evaluator — A function that is used to evaluate the computed observable’s current value.</li> <li>targetObject — If given, defines the value of this whenever KO invokes your callback functions. See the section on <a href="computedobservables.html#managing-this">managing this</a> for more information.</li> <li>options — An object with further properties for the computed observable. See the full list below.</li> </ul> </li> <li>ko.computed( options ) — This single parameter form for creating a computed observable accepts a JavaScript object with any of the following properties. <ul> <li>read — Required. A function that is used to evaluate the computed observable’s current value.</li> <li>write — Optional. If given, makes the computed observable <em>writable</em>. This is a function that receives values that other code is trying to write to your computed observable. It’s up to you to supply custom logic to handle the incoming values, typically by writing the values to some underlying observable(s).</li> <li>owner — Optional. If given, defines the value of this whenever KO invokes your read or write callbacks.</li> <li>pure — Optional. If this option is true, the computed observable will be set up as a <a href="computed-pure.html"><em>pure</em> computed observable</a>. This option is an alternative to the ko.pureComputed constructor.</li> <li>deferEvaluation — Optional. If this option is true, then the value of the computed observable will not be evaluated until something actually attempts to access its value or manually subscribes to it. By default, a computed observable has its value determined immediately during creation.</li> <li>disposeWhen — Optional. If given, this function is executed before each re-evaluation to determine if the computed observable should be disposed. A true-ish result will trigger disposal of the computed observable.</li> <li>disposeWhenNodeIsRemoved — Optional. If given, disposal of the computed observable will be triggered when the specified DOM node is removed by KO. This feature is used to dispose computed observables used in bindings when nodes are removed by the template and control-flow bindings.</li> </ul> </li> <li> <p>ko.pureComputed( evaluator [, targetObject] ) — Constructs a <a href="computed-pure.html"><em>pure</em> computed observable</a> using the given evaluator function and optional object to use for this. Unlike ko.computed, this method doesn’t accept an options parameter.</p> </li> <li>ko.pureComputed( options ) — Constructs a <em>pure</em> computed observable using an options object. This accepts the read, write, and owner options described above.</li> </ol> <h2 id="using-a-computed-observable">Using a computed observable</h2> <p>A computed observable provides the following functions:</p> <ul> <li>dispose() — Manually disposes the computed observable, clearing all subscriptions to dependencies. This function is useful if you want to stop a computed observable from being updated or want to clean up memory for a computed observable that has dependencies on observables that won’t be cleaned.</li> <li>extend(extenders) — Applies the given <a href="extenders.html">extenders</a> to the computed observable.</li> <li>getDependenciesCount() — Returns the current number of dependencies of the computed observable.</li> <li>getDependencies() — Returns an array of the current dependencies of the computed observable. The dependencies will be returned in the order that they were accessed while evaluating the computed observable.</li> <li>getSubscriptionsCount( [event] ) — Returns the current number of subscriptions (either from other computed observables or manual subscriptions) of the computed observable. Optionally, pass an event name (like "change") to return just the count of subscriptions for that event.</li> <li>isActive() — Returns whether the computed observable may be updated in the future. A computed observable is inactive if it has no dependencies.</li> <li>peek() — Returns the current value of the computed observable without creating a dependency (see the section on <a href="computed-dependency-tracking.html#controlling-dependencies-using-peek">peek</a>).</li> <li>subscribe( callback [,callbackTarget, event] ) — Registers a <a href="observables.html#explicitly-subscribing-to-observables">manual subscription</a> to be notified of changes to the computed observable.</li> </ul> <h2 id="determining-the-observable-type">Determining the observable type</h2> <p>To check if a property is observable, computed, etc., use the following set of functions:</p> <ul> <li>ko.isObservable — returns true for observables, observable arrays, and all computed observables.</li> <li>ko.isWritableObservable — returns true for observables, observable arrays, and <em>writable</em> computed observables (also aliased as ko.isWriteableObservable).</li> <li>ko.isComputed — returns true for all computed observables.</li> <li>ko.isPureComputed — returns true for <em>pure</em> computed observables.</li> </ul> <h2 id="using-the-computed-context">Using the computed context</h2> <p>During the execution of a computed observable’s evaluator function, you can access ko.computedContext to get information about the current computed property. It provides the following functions:</p> <ul> <li> <p>isInitial() — A function that returns true if called during the first ever evaluation of the current computed observable, or false otherwise. For <em>pure</em> computed observables, isInitial() is always undefined.</p> </li> <li>getDependenciesCount() — Returns the number of dependencies of the computed observable detected so far during the current evaluation. <ul> <li>Note: ko.computedContext.getDependenciesCount() is equivalent to calling getDependenciesCount() on the computed observable itself. The reason that it also exists on ko.computedContext is to provide a way of counting the dependencies during the first ever evaluation, before the computed observable has even finished being constructed.</li> </ul> </li> <li>getDependencies() — Returns an array of the dependencies of the computed observable detected so far during the current evaluation. The dependencies will be returned in the order that they were accessed while evaluating the computed observable.</li> </ul> <p>Example:</p> <div class="highlight"><pre class="highlight" data-language="javascript">var myComputed = ko.computed(function() {
    // ... Omitted: read some data that might be observable ...

    // Now let's inspect ko.computedContext
    var isFirstEvaluation = ko.computedContext.isInitial(),
        dependencyCount = ko.computedContext.getDependenciesCount(),
    console.log("Evaluating " + (isFirstEvaluation ? "for the first time" : "again"));
    console.log("By now, this computed has " + dependencyCount + " dependencies");

    // ... Omitted: return the result ...
});
</pre></div> <p>These facilities are typically useful only in advanced scenarios, for example when your computed observable’s primary purpose is to trigger some side-effect during its evaluator, and you want to perform some setup logic only during the first run, or only if it has at least one dependency (and hence might re-evaluate in the future). Most computed properties do not need to care whether they have been evaluated before, or how many dependencies they have.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; Steven Sanderson, the Knockout.js team, and other contributors<br>Licensed under the MIT License.<br>
    <a href="https://knockoutjs.com/documentation/computed-reference.html" class="_attribution-link">https://knockoutjs.com/documentation/computed-reference.html</a>
  </p>
</div>
