<h1 id="itera-a">Iter[A: A]</h1> <p><span class="source-link"><a href="https://stdlib.ponylang.io/src/itertools/iter/#L3">[Source]</a></span></p> <p>Wrapper class containing methods to modify iterators.</p> <pre data-language="pony">class ref Iter[A: A] is
  Iterator[A] ref
</pre> <h4 id="implements">Implements</h4> <ul> <li>
<a href="builtin-iterator.html">Iterator</a>[A] ref</li> </ul>  <h2 id="constructors">Constructors</h2> <h3 id="create">create</h3> <p><span class="source-link"><a href="https://stdlib.ponylang.io/src/itertools/iter/#L9">[Source]</a></span></p> <pre data-language="pony">new ref create(
  iter: Iterator[A] ref)
: Iter[A] ref^
</pre> <h4 id="parameters">Parameters</h4> <ul> <li>iter: <a href="builtin-iterator.html">Iterator</a>[A] ref</li> </ul> <h4 id="returns">Returns</h4> <ul> <li>
<a href="index.html">Iter</a>[A] ref^</li> </ul>  <h3 id="maybe">maybe</h3> <p><span class="source-link"><a href="https://stdlib.ponylang.io/src/itertools/iter/#L18">[Source]</a></span></p> <pre data-language="pony">new ref maybe(
  value: (A | None val))
: Iter[A] ref^
</pre> <h4 id="parameters_1">Parameters</h4> <ul> <li>value: (A | <a href="builtin-none.html">None</a> val)</li> </ul> <h4 id="returns_1">Returns</h4> <ul> <li>
<a href="index.html">Iter</a>[A] ref^</li> </ul>  <h3 id="chain">chain</h3> <p><span class="source-link"><a href="https://stdlib.ponylang.io/src/itertools/iter/#L28">[Source]</a></span></p> <p>Take an iterator of iterators and return an Iter containing the items of the first one, then the second one, and so on.</p> <h2 id="example">Example</h2> <pre data-language="pony">let xs = [as I64: 1; 2].values()
let ys = [as I64: 3; 4].values()

Iter[I64].chain([xs; ys].values())
</pre> <p><code>1 2 3 4</code></p> <pre data-language="pony">new ref chain(
  outer_iterator: Iterator[Iterator[A] ref] ref)
: Iter[A] ref^
</pre> <h4 id="parameters_2">Parameters</h4> <ul> <li>outer_iterator: <a href="builtin-iterator.html">Iterator</a>[<a href="builtin-iterator.html">Iterator</a>[A] ref] ref</li> </ul> <h4 id="returns_2">Returns</h4> <ul> <li>
<a href="index.html">Iter</a>[A] ref^</li> </ul>  <h3 id="repeat_value">repeat_value</h3> <p><span class="source-link"><a href="https://stdlib.ponylang.io/src/itertools/iter/#L82">[Source]</a></span></p> <p>Create an iterator that returns the given value forever.</p> <h2 id="example_1">Example</h2> <pre data-language="pony">Iter[U32].repeat_value(7)
</pre> <p><code>7 7 7 7 7 7 7 7 7 ...</code></p> <pre data-language="pony">new ref repeat_value(
  value: A)
: Iter[A] ref^
</pre> <h4 id="parameters_3">Parameters</h4> <ul> <li>value: A</li> </ul> <h4 id="returns_3">Returns</h4> <ul> <li>
<a href="index.html">Iter</a>[A] ref^</li> </ul>  <h2 id="public-functions">Public Functions</h2> <h3 id="has_next">has_next</h3> <p><span class="source-link"><a href="https://stdlib.ponylang.io/src/itertools/iter/#L12">[Source]</a></span></p> <pre data-language="pony">fun ref has_next()
: Bool val
</pre> <h4 id="returns_4">Returns</h4> <ul> <li>
<a href="builtin-bool.html">Bool</a> val</li> </ul>  <h3 id="next">next</h3> <p><span class="source-link"><a href="https://stdlib.ponylang.io/src/itertools/iter/#L15">[Source]</a></span></p> <pre data-language="pony">fun ref next()
: A ?
</pre> <h4 id="returns_5">Returns</h4> <ul> <li>A ?</li> </ul>  <h3 id="next_or">next_or</h3> <p><span class="source-link"><a href="https://stdlib.ponylang.io/src/itertools/iter/#L102">[Source]</a></span></p> <p>Return the next value, or the given default.</p> <h2 id="example_2">Example</h2> <pre data-language="pony">let x: (U64 | None) = 42
Iter[U64].maybe(x).next_or(0)
</pre> <p><code>42</code></p> <pre data-language="pony">fun ref next_or(
  default: A)
: A
</pre> <h4 id="parameters_4">Parameters</h4> <ul> <li>default: A</li> </ul> <h4 id="returns_6">Returns</h4> <ul> <li>A</li> </ul>  <h3 id="map_statefulb-b">map_stateful[B: B]</h3> <p><span class="source-link"><a href="https://stdlib.ponylang.io/src/itertools/iter/#L120">[Source]</a></span></p> <p>Allows stateful transformation of each element from the iterator, similar to <code>map</code>.</p> <pre data-language="pony">fun ref map_stateful[B: B](
  f: {ref(A!): B^ ?}[A, B] ref)
: Iter[B] ref^
</pre> <h4 id="parameters_5">Parameters</h4> <ul> <li>f: {ref(A!): B^ ?}[A, B] ref</li> </ul> <h4 id="returns_7">Returns</h4> <ul> <li>
<a href="index.html">Iter</a>[B] ref^</li> </ul>  <h3 id="filter_stateful">filter_stateful</h3> <p><span class="source-link"><a href="https://stdlib.ponylang.io/src/itertools/iter/#L134">[Source]</a></span></p> <p>Allows filtering of elements based on a stateful adapter, similar to <code>filter</code>.</p> <pre data-language="pony">fun ref filter_stateful(
  f: {ref(A!): Bool ?}[A] ref)
: Iter[A!] ref^
</pre> <h4 id="parameters_6">Parameters</h4> <ul> <li>f: {ref(A!): Bool ?}[A] ref</li> </ul> <h4 id="returns_8">Returns</h4> <ul> <li>
<a href="index.html">Iter</a>[A!] ref^</li> </ul>  <h3 id="filter_map_statefulb-b">filter_map_stateful[B: B]</h3> <p><span class="source-link"><a href="https://stdlib.ponylang.io/src/itertools/iter/#L184">[Source]</a></span></p> <p>Allows stateful modification to the stream of elements from an iterator, similar to <code>filter_map</code>.</p> <pre data-language="pony">fun ref filter_map_stateful[B: B](
  f: {ref(A!): (B^ | None) ?}[A, B] ref)
: Iter[B] ref^
</pre> <h4 id="parameters_7">Parameters</h4> <ul> <li>f: {ref(A!): (B^ | None) ?}[A, B] ref</li> </ul> <h4 id="returns_9">Returns</h4> <ul> <li>
<a href="index.html">Iter</a>[B] ref^</li> </ul>  <h3 id="all">all</h3> <p><span class="source-link"><a href="https://stdlib.ponylang.io/src/itertools/iter/#L233">[Source]</a></span></p> <p>Return false if at least one value of the iterator fails to match the predicate <code>f</code>. This method short-circuits at the first value where the predicate returns false, otherwise true is returned.</p> <h2 id="examples">Examples</h2> <pre data-language="pony">Iter[I64]([2; 4; 6].values())
  .all({(x) =&gt; (x % 2) == 0 })
</pre> <p><code>true</code></p> <pre data-language="pony">Iter[I64]([2; 3; 4].values())
  .all({(x) =&gt; (x % 2) == 0 })
</pre> <p><code>false</code></p> <pre data-language="pony">fun ref all(
  f: {(A!): Bool ?}[A] box)
: Bool val
</pre> <h4 id="parameters_8">Parameters</h4> <ul> <li>f: {(A!): Bool ?}[A] box</li> </ul> <h4 id="returns_10">Returns</h4> <ul> <li>
<a href="builtin-bool.html">Bool</a> val</li> </ul>  <h3 id="any">any</h3> <p><span class="source-link"><a href="https://stdlib.ponylang.io/src/itertools/iter/#L260">[Source]</a></span></p> <p>Return true if at least one value of the iterator matches the predicate <code>f</code>. This method short-circuits at the first value where the predicate returns true, otherwise false is returned.</p> <h2 id="examples_1">Examples</h2> <pre data-language="pony">Iter[I64]([2; 4; 6].values())
  .any({(I64) =&gt; (x % 2) == 1 })
</pre> <p><code>false</code></p> <pre data-language="pony">Iter[I64]([2; 3; 4].values())
  .any({(I64) =&gt; (x % 2) == 1 })
</pre> <p><code>true</code></p> <pre data-language="pony">fun ref any(
  f: {(A!): Bool ?}[A] box)
: Bool val
</pre> <h4 id="parameters_9">Parameters</h4> <ul> <li>f: {(A!): Bool ?}[A] box</li> </ul> <h4 id="returns_11">Returns</h4> <ul> <li>
<a href="builtin-bool.html">Bool</a> val</li> </ul>  <h3 id="collectoptional-b-seqa-ref">collect[optional B: <a href="builtin-seq.html">Seq</a>[A!] ref]</h3> <p><span class="source-link"><a href="https://stdlib.ponylang.io/src/itertools/iter/#L287">[Source]</a></span></p> <p>Push each value from the iterator into the collection <code>coll</code>.</p> <h2 id="example_3">Example</h2> <pre data-language="pony">Iter[I64]([1; 2; 3].values())
  .collect(Array[I64](3))
</pre> <p><code>[1, 2, 3]</code></p> <pre data-language="pony">fun ref collect[optional B: Seq[A!] ref](
  coll: B)
: B^
</pre> <h4 id="parameters_10">Parameters</h4> <ul> <li>coll: B</li> </ul> <h4 id="returns_12">Returns</h4> <ul> <li>B^</li> </ul>  <h3 id="count">count</h3> <p><span class="source-link"><a href="https://stdlib.ponylang.io/src/itertools/iter/#L304">[Source]</a></span></p> <p>Return the number of values in the iterator.</p> <h2 id="example_4">Example</h2> <pre data-language="pony">Iter[I64]([1; 2; 3].values())
  .count()
</pre> <p><code>3</code></p> <pre data-language="pony">fun ref count()
: USize val
</pre> <h4 id="returns_13">Returns</h4> <ul> <li>
<a href="builtin-usize.html">USize</a> val</li> </ul>  <h3 id="cycle">cycle</h3> <p><span class="source-link"><a href="https://stdlib.ponylang.io/src/itertools/iter/#L322">[Source]</a></span></p> <p>Repeatedly cycle through the values from the iterator.</p> <p>WARNING: The values returned by the original iterator are cached, so the input iterator should be finite.</p> <h2 id="example_5">Example</h2> <pre data-language="pony">Iter[I64]([1; 2; 3].values())
  .cycle()
</pre> <p><code>1 2 3 1 2 3 1 2 3 ...</code></p> <pre data-language="pony">fun ref cycle()
: Iter[A!] ref^
</pre> <h4 id="returns_14">Returns</h4> <ul> <li>
<a href="index.html">Iter</a>[A!] ref^</li> </ul>  <h3 id="enumoptional-b-realb-val-i8-val-i16-val-i32-val-i64-val-i128-val-ilong-val-isize-val-u8-val-u16-val-u32-val-u64-val-u128-val-ulong-val-usize-val-f32-val-f64-val">enum[optional B: (<a href="builtin-real.html">Real</a>[B] val &amp; (<a href="builtin-i8.html">I8</a> val | <a href="builtin-i16.html">I16</a> val | <a href="builtin-i32.html">I32</a> val | <a href="builtin-i64.html">I64</a> val | <a href="builtin-i128.html">I128</a> val | <a href="builtin-ilong.html">ILong</a> val | <a href="builtin-isize.html">ISize</a> val | <a href="builtin-u8.html">U8</a> val | <a href="builtin-u16.html">U16</a> val | <a href="builtin-u32.html">U32</a> val | <a href="builtin-u64.html">U64</a> val | <a href="builtin-u128.html">U128</a> val | <a href="builtin-ulong.html">ULong</a> val | <a href="builtin-usize.html">USize</a> val | <a href="builtin-f32.html">F32</a> val | <a href="builtin-f64.html">F64</a> val))]</h3> <p><span class="source-link"><a href="https://stdlib.ponylang.io/src/itertools/iter/#L379">[Source]</a></span></p> <p>An iterator which yields the current iteration count as well as the next value from the iterator.</p> <h2 id="example_6">Example</h2> <pre data-language="pony">Iter[I64]([1; 2; 3].values())
  .enum()
</pre> <p><code>(0, 1) (1, 2) (2, 3)</code></p> <pre data-language="pony">fun ref enum[optional B: (Real[B] val &amp; (I8 val | I16 val | I32 val | 
    I64 val | I128 val | ILong val | 
    ISize val | U8 val | U16 val | 
    U32 val | U64 val | U128 val | 
    ULong val | USize val | F32 val | 
    F64 val))]()
: Iter[(B , A)] ref^
</pre> <h4 id="returns_15">Returns</h4> <ul> <li>
<a href="index.html">Iter</a>[(B , A)] ref^</li> </ul>  <h3 id="filter">filter</h3> <p><span class="source-link"><a href="https://stdlib.ponylang.io/src/itertools/iter/#L402">[Source]</a></span></p> <p>Return an iterator that only returns items that match the predicate <code>f</code>.</p> <h2 id="example_7">Example</h2> <pre data-language="pony">Iter[I64]([1; 2; 3; 4; 5; 6].values())
  .filter({(x) =&gt; (x % 2) == 0 })
</pre> <p><code>2 4 6</code></p> <pre data-language="pony">fun ref filter(
  f: {(A!): Bool ?}[A] box)
: Iter[A!] ref^
</pre> <h4 id="parameters_11">Parameters</h4> <ul> <li>f: {(A!): Bool ?}[A] box</li> </ul> <h4 id="returns_16">Returns</h4> <ul> <li>
<a href="index.html">Iter</a>[A!] ref^</li> </ul>  <h3 id="find">find</h3> <p><span class="source-link"><a href="https://stdlib.ponylang.io/src/itertools/iter/#L416">[Source]</a></span></p> <p>Return the nth value in the iterator that satisfies the predicate <code>f</code>.</p> <h2 id="examples_2">Examples</h2> <pre data-language="pony">Iter[I64]([1; 2; 3].values())
  .find({(x) =&gt; (x % 2) == 0 })
</pre> <p><code>2</code></p> <pre data-language="pony">Iter[I64]([1; 2; 3; 4].values())
  .find({(x) =&gt; (x % 2) == 0 }, 2)
</pre> <p><code>4</code></p> <pre data-language="pony">fun ref find(
  f: {(A!): Bool ?}[A] box,
  n: USize val = 1)
: A! ?
</pre> <h4 id="parameters_12">Parameters</h4> <ul> <li>f: {(A!): Bool ?}[A] box</li> <li>n: <a href="builtin-usize.html">USize</a> val = 1</li> </ul> <h4 id="returns_17">Returns</h4> <ul> <li>A! ?</li> </ul>  <h3 id="filter_mapb-b">filter_map[B: B]</h3> <p><span class="source-link"><a href="https://stdlib.ponylang.io/src/itertools/iter/#L446">[Source]</a></span></p> <p>Return an iterator which applies <code>f</code> to each element. If <code>None</code> is returned, then the iterator will try again by applying <code>f</code> to the next element. Otherwise, the value of type <code>B</code> is returned.</p> <h2 id="example_8">Example</h2> <pre data-language="pony">Iter[I64]([as I64: 1; -2; 4; 7; -5])
  .filter_map[USize](
    {(i: I64): (USize | None) =&gt; if i &gt;= 0 then i.usize() end })
</pre> <p><code>1 4 7</code></p> <pre data-language="pony">

```pony
fun ref filter_map[B: B](
  f: {(A!): (B^ | None) ?}[A, B] box)
: Iter[B] ref^
</pre> <h4 id="parameters_13">Parameters</h4> <ul> <li>f: {(A!): (B^ | None) ?}[A, B] box</li> </ul> <h4 id="returns_18">Returns</h4> <ul> <li>
<a href="index.html">Iter</a>[B] ref^</li> </ul>  <h3 id="flat_mapb-b">flat_map[B: B]</h3> <p><span class="source-link"><a href="https://stdlib.ponylang.io/src/itertools/iter/#L463">[Source]</a></span></p> <p>Return an iterator over the values of the iterators produced from the application of the given function.</p> <h2 id="example_9">Example</h2> <pre data-language="pony">Iter[String](["alpha"; "beta"; "gamma"])
  .flat_map[U8]({(s: String): Iterator[U8] =&gt; s.values() })
</pre> <p><code>a l p h a b e t a g a m m a</code></p> <pre data-language="pony">fun ref flat_map[B: B](
  f: {(A!): Iterator[B] ?}[A, B] box)
: Iter[B] ref^
</pre> <h4 id="parameters_14">Parameters</h4> <ul> <li>f: {(A!): Iterator[B] ?}[A, B] box</li> </ul> <h4 id="returns_19">Returns</h4> <ul> <li>
<a href="index.html">Iter</a>[B] ref^</li> </ul>  <h3 id="foldb-b">fold[B: B]</h3> <p><span class="source-link"><a href="https://stdlib.ponylang.io/src/itertools/iter/#L505">[Source]</a></span></p> <p>Apply a function to every element, producing an accumulated value.</p> <h2 id="example_10">Example</h2> <pre data-language="pony">Iter[I64]([1; 2; 3].values())
  .fold[I64](0, {(sum, x) =&gt; sum + x })
</pre> <p><code>6</code></p> <pre data-language="pony">fun ref fold[B: B](
  acc: B,
  f: {(B, A!): B^}[A, B] box)
: B^
</pre> <h4 id="parameters_15">Parameters</h4> <ul> <li>acc: B</li> <li>f: {(B, A!): B^}[A, B] box</li> </ul> <h4 id="returns_20">Returns</h4> <ul> <li>B^</li> </ul>  <h3 id="fold_partialb-b">fold_partial[B: B]</h3> <p><span class="source-link"><a href="https://stdlib.ponylang.io/src/itertools/iter/#L523">[Source]</a></span></p> <p>A partial version of <code>fold</code>.</p> <pre data-language="pony">fun ref fold_partial[B: B](
  acc: B,
  f: {(B, A!): B^ ?}[A, B] box)
: B^ ?
</pre> <h4 id="parameters_16">Parameters</h4> <ul> <li>acc: B</li> <li>f: {(B, A!): B^ ?}[A, B] box</li> </ul> <h4 id="returns_21">Returns</h4> <ul> <li>B^ ?</li> </ul>  <h3 id="last">last</h3> <p><span class="source-link"><a href="https://stdlib.ponylang.io/src/itertools/iter/#L576">[Source]</a></span></p> <p>Return the last value of the iterator.</p> <h2 id="example_11">Example</h2> <pre data-language="pony">Iter[I64]([1; 2; 3].values())
  .last()
</pre> <p><code>3</code></p> <pre data-language="pony">fun ref last()
: A ?
</pre> <h4 id="returns_22">Returns</h4> <ul> <li>A ?</li> </ul>  <h3 id="mapb-b">map[B: B]</h3> <p><span class="source-link"><a href="https://stdlib.ponylang.io/src/itertools/iter/#L592">[Source]</a></span></p> <p>Return an iterator where each item's value is the application of the given function to the value in the original iterator.</p> <h2 id="example_12">Example</h2> <pre data-language="pony">Iter[I64]([1; 2; 3].values())
  .map[I64]({(x) =&gt; x * x })
</pre> <p><code>1 4 9</code></p> <pre data-language="pony">fun ref map[B: B](
  f: {(A!): B^ ?}[A, B] box)
: Iter[B] ref^
</pre> <h4 id="parameters_17">Parameters</h4> <ul> <li>f: {(A!): B^ ?}[A, B] box</li> </ul> <h4 id="returns_23">Returns</h4> <ul> <li>
<a href="index.html">Iter</a>[B] ref^</li> </ul>  <h3 id="nth">nth</h3> <p><span class="source-link"><a href="https://stdlib.ponylang.io/src/itertools/iter/#L607">[Source]</a></span></p> <p>Return the nth value of the iterator.</p> <h2 id="example_13">Example</h2> <pre data-language="pony">Iter[I64]([1; 2; 3].values())
  .nth(2)
</pre> <p><code>2</code></p> <pre data-language="pony">fun ref nth(
  n: USize val)
: A ?
</pre> <h4 id="parameters_18">Parameters</h4> <ul> <li>n: <a href="builtin-usize.html">USize</a> val</li> </ul> <h4 id="returns_24">Returns</h4> <ul> <li>A ?</li> </ul>  <h3 id="run">run</h3> <p><span class="source-link"><a href="https://stdlib.ponylang.io/src/itertools/iter/#L630">[Source]</a></span></p> <p>Iterate through the values of the iterator without a for loop. The function <code>on_error</code> will be called if the iterator's <code>has_next</code> method returns true but its <code>next</code> method throws an error.</p> <h2 id="example_14">Example</h2> <pre data-language="pony">Iter[I64]([1; 2; 3].values())
  .map[None]({(x) =&gt; env.out.print(x.string()) })
  .run()
</pre> <pre data-language="pony">1
2
3
</pre> <pre data-language="pony">fun ref run(
  on_error: {ref()}[A] ref = lambda)
: None val
</pre> <h4 id="parameters_19">Parameters</h4> <ul> <li>on_error: {ref()}[A] ref = lambda</li> </ul> <h4 id="returns_25">Returns</h4> <ul> <li>
<a href="builtin-none.html">None</a> val</li> </ul>  <h3 id="skip">skip</h3> <p><span class="source-link"><a href="https://stdlib.ponylang.io/src/itertools/iter/#L657">[Source]</a></span></p> <p>Skip the first n values of the iterator.</p> <h2 id="example_15">Example</h2> <pre data-language="pony">Iter[I64]([1; 2; 3; 4; 5; 6].values())
  .skip(3)
</pre> <p><code>4 5 6</code></p> <pre data-language="pony">Iter[I64]([1; 2; 3].values())
  .skip(3)
  .has_next()
</pre> <p><code>false</code></p> <pre data-language="pony">fun ref skip(
  n: USize val)
: Iter[A] ref^
</pre> <h4 id="parameters_20">Parameters</h4> <ul> <li>n: <a href="builtin-usize.html">USize</a> val</li> </ul> <h4 id="returns_26">Returns</h4> <ul> <li>
<a href="index.html">Iter</a>[A] ref^</li> </ul>  <h3 id="skip_while">skip_while</h3> <p><span class="source-link"><a href="https://stdlib.ponylang.io/src/itertools/iter/#L685">[Source]</a></span></p> <p>Skip values of the iterator while the predicate <code>f</code> returns true.</p> <h2 id="example_16">Example</h2> <pre data-language="pony">Iter[I64]([1; 2; 3; 4; 5; 6].values())
  .skip_while({(x) =&gt; x &lt; 4 })
</pre> <p><code>4 5 6</code></p> <pre data-language="pony">fun ref skip_while(
  f: {(A!): Bool ?}[A] box)
: Iter[A!] ref^
</pre> <h4 id="parameters_21">Parameters</h4> <ul> <li>f: {(A!): Bool ?}[A] box</li> </ul> <h4 id="returns_27">Returns</h4> <ul> <li>
<a href="index.html">Iter</a>[A!] ref^</li> </ul>  <h3 id="take">take</h3> <p><span class="source-link"><a href="https://stdlib.ponylang.io/src/itertools/iter/#L711">[Source]</a></span></p> <p>Return an iterator for the first n elements.</p> <h2 id="example_17">Example</h2> <pre data-language="pony">Iter[I64]([1; 2; 3; 4; 5; 6].values())
  .take(3)
</pre> <p><code>1 2 3</code></p> <pre data-language="pony">fun ref take(
  n: USize val)
: Iter[A] ref^
</pre> <h4 id="parameters_22">Parameters</h4> <ul> <li>n: <a href="builtin-usize.html">USize</a> val</li> </ul> <h4 id="returns_28">Returns</h4> <ul> <li>
<a href="index.html">Iter</a>[A] ref^</li> </ul>  <h3 id="take_while">take_while</h3> <p><span class="source-link"><a href="https://stdlib.ponylang.io/src/itertools/iter/#L739">[Source]</a></span></p> <p>Return an iterator that returns values while the predicate <code>f</code> returns true. This iterator short-circuits the first time that <code>f</code> returns false or raises an error.</p> <h2 id="example_18">Example</h2> <pre data-language="pony">Iter[I64]([1; 2; 3; 4; 5; 6].values())
  .take_while({(x) =&gt; x &lt; 4 })
</pre> <p><code>1 2 3</code></p> <pre data-language="pony">fun ref take_while(
  f: {(A!): Bool ?}[A] box)
: Iter[A!] ref^
</pre> <h4 id="parameters_23">Parameters</h4> <ul> <li>f: {(A!): Bool ?}[A] box</li> </ul> <h4 id="returns_29">Returns</h4> <ul> <li>
<a href="index.html">Iter</a>[A!] ref^</li> </ul>  <h3 id="zipb-b">zip[B: B]</h3> <p><span class="source-link"><a href="https://stdlib.ponylang.io/src/itertools/iter/#L802">[Source]</a></span></p> <p>Zip two iterators together so that each call to next() results in a tuple with the next value of the first iterator and the next value of the second iterator. The number of items returned is the minimum of the number of items returned by the two iterators.</p> <h2 id="example_19">Example</h2> <pre data-language="pony">Iter[I64]([1; 2].values())
  .zip[I64]([3; 4].values())
</pre> <p><code>(1, 3) (2, 4)</code></p> <pre data-language="pony">fun ref zip[B: B](
  i2: Iterator[B] ref)
: Iter[(A , B)] ref^
</pre> <h4 id="parameters_24">Parameters</h4> <ul> <li>i2: <a href="builtin-iterator.html">Iterator</a>[B] ref</li> </ul> <h4 id="returns_30">Returns</h4> <ul> <li>
<a href="index.html">Iter</a>[(A , B)] ref^</li> </ul>  <h3 id="zip2b-b-c-c">zip2[B: B, C: C]</h3> <p><span class="source-link"><a href="https://stdlib.ponylang.io/src/itertools/iter/#L829">[Source]</a></span></p> <p>Zip three iterators together so that each call to next() results in a tuple with the next value of the first iterator, the next value of the second iterator, and the value of the third iterator. The number of items returned is the minimum of the number of items returned by the three iterators.</p> <pre data-language="pony">fun ref zip2[B: B, C: C](
  i2: Iterator[B] ref,
  i3: Iterator[C] ref)
: Iter[(A , B , C)] ref^
</pre> <h4 id="parameters_25">Parameters</h4> <ul> <li>i2: <a href="builtin-iterator.html">Iterator</a>[B] ref</li> <li>i3: <a href="builtin-iterator.html">Iterator</a>[C] ref</li> </ul> <h4 id="returns_31">Returns</h4> <ul> <li>
<a href="index.html">Iter</a>[(A , B , C)] ref^</li> </ul>  <h3 id="zip3b-b-c-c-d-d">zip3[B: B, C: C, D: D]</h3> <p><span class="source-link"><a href="https://stdlib.ponylang.io/src/itertools/iter/#L850">[Source]</a></span></p> <p>Zip four iterators together so that each call to next() results in a tuple with the next value of each of the iterators. The number of items returned is the minimum of the number of items returned by the iterators.</p> <pre data-language="pony">fun ref zip3[B: B, C: C, D: D](
  i2: Iterator[B] ref,
  i3: Iterator[C] ref,
  i4: Iterator[D] ref)
: Iter[(A , B , C , D)] ref^
</pre> <h4 id="parameters_26">Parameters</h4> <ul> <li>i2: <a href="builtin-iterator.html">Iterator</a>[B] ref</li> <li>i3: <a href="builtin-iterator.html">Iterator</a>[C] ref</li> <li>i4: <a href="builtin-iterator.html">Iterator</a>[D] ref</li> </ul> <h4 id="returns_32">Returns</h4> <ul> <li>
<a href="index.html">Iter</a>[(A , B , C , D)] ref^</li> </ul>  <h3 id="zip4b-b-c-c-d-d-e-e">zip4[B: B, C: C, D: D, E: E]</h3> <p><span class="source-link"><a href="https://stdlib.ponylang.io/src/itertools/iter/#L876">[Source]</a></span></p> <p>Zip five iterators together so that each call to next() results in a tuple with the next value of each of the iterators. The number of items returned is the minimum of the number of items returned by the iterators.</p> <pre data-language="pony">fun ref zip4[B: B, C: C, D: D, E: E](
  i2: Iterator[B] ref,
  i3: Iterator[C] ref,
  i4: Iterator[D] ref,
  i5: Iterator[E] ref)
: Iter[(A , B , C , D , E)] ref^
</pre> <h4 id="parameters_27">Parameters</h4> <ul> <li>i2: <a href="builtin-iterator.html">Iterator</a>[B] ref</li> <li>i3: <a href="builtin-iterator.html">Iterator</a>[C] ref</li> <li>i4: <a href="builtin-iterator.html">Iterator</a>[D] ref</li> <li>i5: <a href="builtin-iterator.html">Iterator</a>[E] ref</li> </ul> <h4 id="returns_33">Returns</h4> <ul> <li>
<a href="index.html">Iter</a>[(A , B , C , D , E)] ref^</li> </ul><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2016-2020, The Pony Developers<br>&copy; 2014-2015, Causality Ltd.<br>Licensed under the BSD 2-Clause License.<br>
    <a href="https://stdlib.ponylang.io/itertools-Iter" class="_attribution-link">https://stdlib.ponylang.io/itertools-Iter</a>
  </p>
</div>
