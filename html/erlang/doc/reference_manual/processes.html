<div class="innertube"> <h1 id="Processes">14 Processes</h1> <h2 id="processes" class="title-link"> <div class="title-name">14.1 Processes</div>  </h2> <p>Erlang is designed for massive concurrency. Erlang processes are lightweight (grow and shrink dynamically) with small memory footprint, fast to create and terminate, and the scheduling overhead is low.</p> <h2 id="process-creation" class="title-link"> <div class="title-name">14.2 Process Creation</div>  </h2> <p>A process is created by calling <code>spawn()</code>:</p> <pre data-language="erlang">
spawn(Module, Name, Args) -&gt; pid()
  Module = Name = atom()
  Args = [Arg1,...,ArgN]
    ArgI = term()</pre> <p><code>spawn()</code> creates a new process and returns the pid.</p> <p>The new process starts executing in <code>Module:Name(Arg1,...,ArgN)</code> where the arguments are the elements of the (possible empty) <code>Args</code> argument list.</p> <p>There exist a number of different <code>spawn</code> BIFs:</p> <ul> <li><code>spawn/1,2,3,4</code></li> <li><code>spawn_link/1,2,3,4</code></li> <li><code>spawn_monitor/1,2,3,4</code></li> <li><code>spawn_opt/2,3,4,5</code></li> <li><code>spawn_request/1,2,3,4,5</code></li> </ul> <h2 id="registered-processes" class="title-link"> <div class="title-name">14.3 Registered Processes</div>  </h2> <p>Besides addressing a process by using its pid, there are also BIFs for registering a process under a name. The name must be an atom and is automatically unregistered if the process terminates:</p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td><strong>BIF</strong></td> <td><strong>Description</strong></td> </tr> <tr> <td><code>register(Name, Pid)</code></td> <td>Associates the name <code>Name</code>, an atom, with the process <code>Pid</code>.</td> </tr> <tr> <td><code>registered()</code></td> <td>Returns a list of names that have been registered using <code>register/2</code>.</td> </tr> <tr> <td><code>whereis(Name)</code></td> <td>Returns the pid registered under <code>Name</code>, or <code>undefined</code>if the name is not registered.</td> </tr> </table> <p class="doc-table-caption">Table 14.1: Name Registration BIFs</p> </div> <h2 id="process-aliases" class="title-link"> <div class="title-name">14.4 Process Aliases</div>  </h2> <p> When sending a message to a process, the receiving process can be identified by a <code><a href="data_types.html#pid">PID</a></code>, a <code><a href="#registered-processes">registered name</a></code>, or a <i>process alias</i> which is a term of the type <code><a href="data_types.html#reference">reference</a></code>. The typical use case that process aliases were designed for is a request/reply scenario. Using a process alias when sending the reply makes it possible for the receiver of the reply to prevent the reply from reaching its message queue if the operation times out or if the connection between the processes is lost. </p> <p> A process alias can be used as identifier of the receiver when sending a message using the <code><a href="expressions.html#send">send operator !</a></code> or send BIFs such as <code>erlang:send/2</code>. As long as the process alias is active, messages will be delivered the same way as if the process identifier of the process that created the alias had been used. When the alias has been deactivated, messages sent using the alias will be dropped before entering the message queue of the receiver. Note that messages that at deactivation time already have entered the message queue will <strong>not</strong> be removed. </p> <p> A process alias is created either by calling one of the <code>alias/0,1</code> BIFs or by creating an alias and a monitor simultaneously. If the alias is created together with a monitor, the same reference will be used both as monitor reference and alias. Creating a monitor and an alias at the same time is done by passing the <code>{alias, _}</code> option to the <code>monitor/3</code> BIF. The <code>{alias, _}</code> option can also be passed when creating a monitor via <code>spawn_opt()</code>, or <code>spawn_request()</code>. </p> <p> A process alias can be deactivated by the process that created it by calling the <code>unalias/1</code> BIF. It is also possible to automatically deactivate an alias on certain events. See the documentation of the <code>alias/1</code> BIF, and the <code>{alias, _}</code> option of the <code>monitor/3</code> BIF for more information about automatic deactivation of aliases. </p> <p> It is <strong>not</strong> possible to: </p> <ul> <li>create an alias identifying another process than the caller.</li> <li>deactivate an alias unless it identifies the caller.</li> <li>look up an alias.</li> <li>look up the process identified by an alias.</li> <li>check if an alias is active or not.</li> <li>check if a reference is an alias.</li> </ul> <p> These are all intentional design decisions relating to performance, scalability, and distribution transparency. </p> <h2 id="process-termination" class="title-link"> <div class="title-name">14.5 Process Termination</div>  </h2> <p>When a process terminates, it always terminates with an <strong>exit reason</strong>. The reason can be any term.</p> <p>A process is said to terminate <strong>normally</strong>, if the exit reason is the atom <code>normal</code>. A process with no more code to execute terminates normally.</p> <p>A process terminates with an exit reason <code>{Reason,Stack}</code> when a run-time error occurs. See <code><a href="errors.html#exit_reasons">Exit Reasons</a></code>.</p> <p>A process can terminate itself by calling one of the following BIFs:</p> <ul> <li><code>exit(Reason)</code></li> <li><code>erlang:error(Reason)</code></li> <li><code>erlang:error(Reason, Args)</code></li> </ul> <p>The process then terminates with reason <code>Reason</code> for <code>exit/1</code> or <code>{Reason,Stack}</code> for the others.</p> <p>A process can also be terminated if it receives an exit signal with another exit reason than <code>normal</code>, see <code><a href="#errors">Error Handling</a></code>.</p> <h2 id="signals" class="title-link"> <div class="title-name">14.6 Signals</div>  </h2> <h3 id="message-sending">  All communication between Erlang processes and Erlang ports is done by sending and receiving asynchronous signals. The most common signals are Erlang message signals. A message signal can be sent using the <code id="message-sending"><a href="expressions.html#send">send operator !</a></code>. A received message can be fetched from the message queue by the receiving process using the <code><a href="expressions.html#receive">receive</a></code> expression. </h3>  <p id="sync-comm"> Synchronous communication can be broken down into multiple asynchronous signals. An example of such a synchronous communication is a call to the <code>erlang:process_info/2</code> BIF when the first argument does not equal the process identifier of the calling process. The caller sends an asynchronous signal requesting information, and then blocks waiting for the reply signal containing the requested information. When the request signal reaches its destination, the destination process replies with the requested information. </p> <h3 id="sending-signals" class="title-link"> <div class="title-name">Sending Signals</div>  </h3> <p> There are many signals that processes and ports use to communicate. The list below contains the most important signals. In all the cases of request/reply signal pairs, the request signal is sent by the process calling the specific BIF, and the reply signal is sent back to it when the requested operation has been performed. </p> <dl> <dt class="title-link"><strong><code>message</code></strong></dt> <dd> Sent when using the <code><a href="expressions.html#send">send operator !</a></code>, or when calling one of the <code>erlang:send/2,3</code> or <code>erlang:send_nosuspend/2,3</code> BIFs. </dd> <dt class="title-link"><strong><code>link</code></strong></dt> <dd> Sent when calling the <code>link/1</code> BIF. </dd> <dt class="title-link"><strong><code>unlink</code></strong></dt> <dd> Sent when calling the <code>unlink/1</code> BIF. </dd> <dt class="title-link"><strong><code>exit</code></strong></dt> <dd> Sent either when explicitly sending an <code>exit</code> signal by calling the <code>exit/2</code> BIF, or when a <code><a href="#sending_exit_signals">linked process terminates</a></code>. If the signal is sent due to a link, the signal is sent after all <code><a href="#visible-resources"> <i>directly visible Erlang resources</i></a></code> used by the process have been released. </dd> <dt class="title-link"><strong><code>monitor</code></strong></dt> <dd> Sent when calling one of the <code>monitor/2,3</code> BIFs. </dd> <dt class="title-link"><strong><code>demonitor</code></strong></dt> <dd> Sent when calling one of the <code>demonitor/1,2</code> BIFs, or when a process monitoring another process terminates. </dd> <dt class="title-link"><strong><code>down</code></strong></dt> <dd> Sent by a <code><a href="#monitors">monitored process or port that terminates</a></code>. The signal is sent after all <code><a href="#visible-resources"><i>directly visible Erlang resources</i></a></code> used by the process or the port have been released. </dd> <dt class="title-link"><strong><code>change</code></strong></dt> <dd> Sent by the <code><a href="#runtime-service">clock service</a></code> on the local runtime system, when the <code>time offset</code> changes, to processes which have <code>monitored the time_offset</code>. </dd> <dt class="title-link"><strong><code>group_leader</code></strong></dt> <dd> Sent when calling the <code>group_leader/2</code> BIF. </dd> <dt class="title-link"><strong> <code>spawn_request</code>/<code>spawn_reply</code>, <code>open_port_request</code>/<code>open_port_reply</code> </strong></dt> <dd> Sent due to a call to one of the <code>spawn/1,2,3,4</code>, <code>spawn_link/1,2,3,4</code>, <code>spawn_monitor/1,2,3,4</code>, <code>spawn_opt/2,3,4,5</code>, <code>spawn_request/1,2,3,4,5</code>, or <code>erlang:open_port/2</code> BIFs. The request signal is sent to the <code><a href="#runtime-service">spawn service</a></code> which responds with the reply signal. </dd> <dt class="title-link"><strong><code>alive_request</code>/<code>alive_reply</code></strong></dt> <dd> Sent due to a call to the <code>is_process_alive/1</code> BIF. </dd> <dt class="title-link"><strong> <code>garbage_collect_request</code>/<code>garbage_collect_reply</code>, <code>check_process_code_request</code>/<code>check_process_code_reply</code>, <code>process_info_request</code>/<code>process_info_reply</code> </strong></dt> <dd> Sent due to a call to one of the <code>garbage_collect/1,2</code>, <code>erlang:check_process_code/2,3</code>, or <code>process_info/1,2</code> BIFs. Note that if the request is directed towards the caller itself and it is a synchronous request, no signaling will be performed and the caller will instead synchronously perform the request before returning from the BIF. </dd> <dt class="title-link"><strong><code>port_command</code>, <code>port_connect</code>, <code>port_close</code></strong></dt> <dd> Sent by a process to a port on the local node using the <code><a href="expressions.html#send">send operator !</a></code>, or by calling one of the <code>send()</code> BIFs. The signal is sent by passing a term on the format <code>{Owner, {command, Data}}</code>, <code>{Owner, {connect, Pid}}</code>, or <code>{Owner, close}</code> as message. </dd> <dt class="title-link"><strong> <code>port_command_request</code>/<code>port_command_reply</code>, <code>port_connect_request</code>/<code>port_connect_reply</code>, <code>port_close_request</code>/<code>port_close_reply</code>, <code>port_control_request</code>/<code>port_control_reply</code>, <code>port_call_request</code>/<code>port_call_reply</code>, <code>port_info_request</code>/<code>port_info_reply</code> </strong></dt> <dd> Sent due to a call to one of the <code>erlang:port_command/2,3</code>, <code>erlang:port_connect/2</code>, <code>erlang:port_close/1</code>, <code>erlang:port_control/3</code>, <code>erlang:port_call/3</code>, <code>erlang:port_info/1,2</code> BIFs. The request signal is sent to a port on the local node which responds with the reply signal. </dd> <dt class="title-link"><strong> <code>register_name_request</code>/<code>register_name_reply</code>, <code>unregister_name_request</code>/<code>unregister_name_reply</code>, <code>whereis_name_request</code>/<code>whereis_name_reply</code> </strong></dt> <dd> Sent due to a call to one of the <code>register/2</code>, <code>unregister/1</code>, or <code>whereis/1</code> BIFs. The request signal is sent to the <code><a href="#runtime-service">name service</a></code>, which responds with the reply signal. </dd> <dt class="title-link"><strong> <code>timer_start_request</code>/<code>timer_start_reply</code>, <code>timer_cancel_request</code>/<code>timer_cancel_reply</code> </strong></dt> <dd> Sent due to a call to one of the <code>erlang:send_after/3,4</code>, <code>erlang:start_timer/3,4</code>, or <code>erlang:cancel_timer/1,2</code> BIFs. The request signal is sent to the <code><a href="#runtime-service">timer service</a></code> which responds with the reply signal. </dd> </dl> <h3 id="runtime-service">
 The clock service, the name service, the timer service, and the spawn service mentioned previously are services provided by the runtime system. Each of these services consists of multiple independently executing entities. Such a service can be viewed as a group of processes, and could actually be implemented like that. Since each service consists of multiple independently executing entities, the order between multiple signals sent from one service to one process is <strong id="runtime-service">not</strong> preserved. Note that this does <strong>not</strong> violate the <code><a href="#signal-delivery">signal ordering guarantee</a></code> of the language. </h3> <p> The realization of the signals described above may change both at runtime and due to changes in implementation. You may be able to detect such changes using <code>receive</code> tracing or by inspecting message queues. However, these are internal implementation details of the runtime system that you should <strong>not</strong> rely on. As an example, many of the reply signals above are ordinary message signals. When the operation is synchronous, the reply signals do not have to be message signals. The current implementation takes advantage of this and, depending on the state of the system, use alternative ways of delivering the reply signals. The implementation of these reply signals may also, at any time, be changed to not use message signals where it previously did. </p> <h3 id="receiving-signals" class="title-link"> <div class="title-name">Receiving Signals</div>  </h3> <p> Signals are received asynchronously and automatically. There is nothing a process must do to handle the reception of signals, or can do to prevent it. In particular, signal reception is <strong>not</strong> tied to the execution of a <code><a href="expressions.html#receive">receive</a></code> expression, but can happen anywhere in the execution flow of a process. </p> <p> When a signal is received by a process, some kind of action is taken. The specific action taken depends on the signal type, contents of the signal, and the state of the receiving process. Actions taken for the most common signals: </p> <dl> <dt class="title-link"><strong><code>message</code></strong></dt> <dd> If the message signal was sent using a <code><a href="#process-aliases">process alias</a></code> that is no longer active, the message signal will be dropped; otherwise, if the alias is still active or the message signal was sent by other means, the message is added to the end of the message queue. When the message has been added to the message queue, the receiving process can fetch the message from the message queue using the <code><a href="expressions.html#receive">receive</a></code> expression. </dd> <dt class="title-link"><strong><code>link</code>, <code>unlink</code></strong></dt> <dd> Very simplified it can be viewed as updating process local information about the link. A detailed description of the <code>link protocol</code> can be found in the <i>Distribution Protocol</i> chapter of the <i>ERTS User's Guide</i>. </dd> <dt class="title-link"><strong><code>exit</code></strong></dt> <dd> Set the receiver in an exiting state, drop the signal, or convert the signal into a message and add it to the end of the message queue. If the receiver is set in an exiting state, no more Erlang code will be executed and the process is scheduled for termination. The section <code><a href="#receiving_exit_signals"><i>Receiving Exit Signals</i></a></code> below gives more details on the action taken when an <code>exit</code> signal is received. </dd> <dt class="title-link"><strong><code>monitor</code>, <code>demonitor</code></strong></dt> <dd> Update process local information about the monitor. </dd> <dt class="title-link"><strong><code>down</code>, <code>change</code></strong></dt> <dd> Convert into a message if the corresponding monitor is still active; otherwise, drop the signal. If the signal is converted into a message, it is also added to the end of the message queue. </dd> <dt class="title-link"><strong><code>group_leader</code></strong></dt> <dd> Change the group leader of the process. </dd> <dt class="title-link"><strong><code>spawn_reply</code></strong></dt> <dd> Convert into a message, or drop the signal depending on the reply and how the <code>spawn_request</code> signal was configured. If the signal is converted into a message it is also added to the end of the message queue. For more information see the <code>spawn_request()</code> BIF. </dd> <dt class="title-link"><strong><code>alive_request</code></strong></dt> <dd> Schedule execution of the <i>is alive</i> test. If the process is in an exiting state, the <i>is alive</i> test will not be executed until after all <code><a href="#visible-resources"><i>directly visible Erlang resources</i></a></code> used by the process have been released. The <code>alive_reply</code> will be sent after the <i>is alive</i> test has executed. </dd> <dt class="title-link"><strong> <code>process_info_request</code>, <code>garbage_collect_request</code>, <code>check_process_code_request</code> </strong></dt> <dd> Schedule execution of the requested operation. The reply signal will be sent when the operation has been executed. </dd> </dl> <p> Note that some actions taken when a signal is received involves <strong>scheduling</strong> further actions which will result in a reply signal when these scheduled actions have completed. This implies that the reply signals may be sent in a different order than the order of the incoming signals that triggered these operations. This does, however, <strong>not</strong> violate the <code><a href="#signal-delivery">signal ordering guarantee</a></code> of the language. </p>  <p id="message-queue-order"> The order of messages in the message queue of a process reflects the order in which the signals corresponding to the messages has been received since <code><a href="processes.html#receiving-signals">all signals that add messages to the message queue add them at the end of the message queue</a></code>. Messages corresponding to signals from the same sender are also ordered in the same order as the signals were sent due to the <code><a href="processes.html#signal-delivery">signal ordering guarantee</a></code> of the language. </p> <h3 id="directly-visible-erlang-resources" class="title-link"> <div class="title-name">Directly Visible Erlang Resources</div>  </h3> <p> As described above, <code>exit</code> signals due to links, <code>down</code> signals, and reply signals from an exiting process due to <code>alive_request</code>s are not sent until all <i>directly visible Erlang resources</i> held by the terminating process have been released. With <i>directly visible Erlang resources</i> we here mean all resources made available by the language excluding resources held by heap data, dirty native code execution and the process identifier of the terminating process. Examples of <i>directly visible Erlang resources</i> are <code><a href="#registered-processes">registered name</a></code> and <code>ETS</code> tables. </p> <h4>The Excluded Resources</h4> <p> The process identifier of the process cannot be released for reuse until everything regarding the process has been released. </p> <p> A process executing dirty native code in a NIF when it receives an exit signal will be set into an exiting state even if it is still executing dirty native code. <i>Directly visible Erlang resources</i> will be released, but the runtime system cannot force the native code to stop executing. The runtime system tries to prevent the execution of the dirty native code from effecting other processes by, for example, disabling functionality such as <code>enif_send()</code> when used from a terminated process, but if the NIF is not well behaved it can still effect other processes. A well behaved dirty NIF should test if <code>the process it is executing in has exited</code>, and if so stop executing. </p> <p> In the general case, the heap of a process cannot be removed before all signals that it needs to send have been sent. Resources held by heap data are the memory blocks containing the heap, but also include things referred to from the heap such as off heap binaries, and resources held via NIF <code>resource objects</code> on the heap. </p> <h3 id="delivery-of-signals" class="title-link"> <div class="title-name">Delivery of Signals</div>  </h3> <p> The amount of time that passes between the time a signal is sent and the arrival of the signal at the destination is unspecified but positive. If the receiver has terminated, the signal does not arrive, but it can trigger another signal. For example, a <code>link</code> signal sent to a non-existing process triggers an <code>exit</code> signal, which is sent back to where the <code>link</code> signal originated from. When communicating over the distribution, signals can be lost if the distribution channel goes down. </p> <p> The only signal ordering guarantee given is the following: if an entity sends multiple signals to the same destination entity, the order is preserved; that is, if <code>A</code> sends a signal <code>S1</code> to <code>B</code>, and later sends signal <code>S2</code> to <code>B</code>, <code>S1</code> is guaranteed not to arrive after <code>S2</code>. Note that <code>S1</code> may, or may not have been lost. </p> <h3 id="irregularities" class="title-link"> <div class="title-name">Irregularities</div>  </h3> <dl> <dt class="title-link"><strong>Synchronous Error Checking</strong></dt> <dd> <p> Some functionality that send signals have synchronous error checking when sending locally on a node and fail if the receiver is not present at the time when the signal is sent: </p> <ul> <li> The <code><a href="expressions.html#send">send operator !</a></code>, <code>erlang:send/2,3</code>, BIFs and <code>erlang:send_nosuspend/2,3</code> BIFs when the receiver is identified by a name that is expected to be registered locally. </li> <li> <code>erlang:link/1</code> </li> <li> <code>erlang:group_leader/2</code> </li> </ul>  </dd> <dt class="title-link"><strong>Unexpected Behaviours of Exit Signals</strong></dt> <dd> <p> When a process sends an exit signal with exit reason <code>normal</code> to itself by calling <code>erlang:exit(self(), normal)</code> it will be terminated <code><a href="#receiving_exit_signals">when the exit signal is received</a></code>. In all other cases when an exit signal with exit reason <code>normal</code> is received, it is dropped. </p> <p> When an <code><a href="#receiving_exit_signals">exit signal with exit reason kill is received</a></code>, the action taken is different depending on whether the signal was sent due to a linked process terminating, or the signal was explicitly sent using the <code>exit/2</code> BIF. When sent using the <code>exit/2</code> BIF, the signal cannot be <code>trapped</code>, while it can be trapped if the signal was sent due to a link. </p> </dd> <dt class="title-link"><strong id="blocking-signaling-over-distribution"> Blocking Signaling Over Distribution  </strong></dt> <dd> <p> When sending a signal over a distribution channel, the sending process may be suspended even though the signal is supposed to be sent asynchronously. This is due to the built in flow control over the channel that has been present more or less for ever. When the size of the output buffer for the channel reach the <i>distribution buffer busy limit</i>, processes sending on the channel will be suspended until the size of the buffer shrinks below the limit. </p> <p> Depending on the reason for why the buffer got full, the time it takes before suspended processes are resumed can vary <strong>very much</strong>. A consequence of this can, for example, be that a timeout in a call to <code>erpc:call()</code> is significantly delayed. </p> <p> Since this functionality has been present for so long, it is not possible to remove it, but it is possible to enable <i>fully asynchronous distributed signaling</i> on a per process level using <code> process_flag(async_dist, Bool)</code> which can be used to solve problems occuring due to blocking signaling. However, note that you need to make sure that flow control for data sent using <i>fully asynchronous distributed signaling</i> is implemented, or that the amount of such data is known to always be limited; otherwise, you may get into a situation with excessive memory usage. </p> <p> The size of the <i>distribution buffer busy limit</i> can be inspected by calling <code> erlang:system_info(dist_buf_busy_limit)</code>. </p> </dd> </dl> <p> The irregularities mentioned above cannot be fixed as they have been part of Erlang too long and it would break a lot of existing code. </p> <h2 id="links" class="title-link"> <div class="title-name">14.7 Links</div>  </h2> <p> Two processes can be <strong>linked</strong> to each other. Also a process and a port that reside on the same node can be linked to each other. A link between two processes can be created if one of them calls the <code>link/1</code> BIF with the process identifier of the other process as argument. Links can also be created using one the following spawn BIFs <code>spawn_link()</code>, <code>spawn_opt()</code>, or <code>spawn_request()</code>. The spawn operation and the link operation will be performed atomically, in these cases. </p> <p> If one of the participants of a link terminates, it will <code>send an exit signal</code> to the other participant. The exit signal will contain the <code>exit reason</code> of the terminated participant. </p> <p> A link can be removed by calling the <code>unlink/1</code> BIF. </p> <p> Links are bidirectional and there can only be one link between two processes. Repeated calls to <code>link()</code> have no effect. Either one of the involved processes may create or remove a link. </p> <p>Links are used to monitor the behavior of other processes, see <code><a href="#errors">Error Handling</a></code>.</p> <h2 id="error-handling" class="title-link"> <div class="title-name">14.8 Error Handling</div>  </h2> <p>Erlang has a built-in feature for error handling between processes. Terminating processes emit exit signals to all linked processes, which can terminate as well or handle the exit in some way. This feature can be used to build hierarchical program structures where some processes are supervising other processes, for example, restarting them if they terminate abnormally.</p> <p>See <code> OTP Design Principles</code> for more information about OTP supervision trees, which use this feature.</p> <h3 id="sending-exit-signals" class="title-link"> <div class="title-name">Sending Exit Signals</div>  </h3> <p> When a process or port <code><a href="#term">terminates</a></code> it will send exit signals to all processes and ports that it is <code><a href="#links">linked</a></code> to. The exit signal will contain the following information: </p> <dl> <dt class="title-link"><strong>Sender identifier</strong></dt> <dd><p> The process or port identifier of the process or port that terminated. </p></dd> <dt class="title-link"><strong>Receiver identifier</strong></dt> <dd><p> The process or port identifier of the process or port which the exit signal is sent to. </p></dd> <dt class="title-link"><strong>The <code>link</code> flag</strong></dt> <dd><p> This flag will be set indicating that the exit signal was sent due to a link. </p></dd> <dt class="title-link"><strong id="link_exit_signal_reason">Exit reason</strong></dt> <dd> <p> The exit reason of the process or port that terminated or the atom:</p> <ul> <li><p> <code>noproc</code> in case no process or port was found when setting up a link in a preceding call to the <code>link(PidOrPort)</code> BIF. The process or port identified as sender of the exit signal will equal the <code>PidOrPort</code> argument passed to <code>link/1</code>. </p></li> <li><p> <code>noconnection</code> in case the linked processes resides on different nodes and the connection between the nodes was lost or could not be established. The process or port identified as sender of the exit signal might in this case still be alive. </p></li> </ul> </dd> </dl> <p> Exit signals can also be sent explicitly by calling the <code>exit(PidOrPort, Reason)</code> BIF. The exit signal is sent to the process or port identified by the <code>PidOrPort</code> argument. The exit signal sent will contain the following information: </p> <dl> <dt class="title-link"><strong>Sender identifier</strong></dt> <dd><p> The process identifier of the process that called <code>exit/2</code>. </p></dd> <dt class="title-link"><strong>Receiver identifier</strong></dt> <dd><p> The process or port identifier of the process or port which the exit signal is sent to. </p></dd> <dt class="title-link"><strong>The <code>link</code> flag</strong></dt> <dd><p> This flag will not be set, indicating that this exit signal was not sent due to a link. </p></dd> <dt class="title-link"><strong>Exit reason</strong></dt> <dd><p> The term passed as <code>Reason</code> in the call to <code>exit/2</code>. If <code>Reason</code> is the atom <code>kill</code>, the receiver cannot <code>trap the exit</code> signal and will unconditionally terminate when it receives the signal. </p></dd> </dl> <h3 id="receiving-exit-signals" class="title-link"> <div class="title-name">Receiving Exit Signals</div>  </h3> <p>What happens when a process receives an exit signal depends on:</p> <ul> <li><p> The <code>trap exit</code> state of the receiver at the time when the exit signal is received. </p></li> <li><p> The exit reason of the exit signal. </p></li> <li><p> The sender of the exit signal. </p></li> <li><p> The state of the <code>link</code> flag of the exit signal. If the <code>link</code> flag is set, the exit signal was sent due to a link; otherwise, the exit signal was sent by a call to the <code>exit/2</code> BIF. </p></li> <li><p> If the <code>link</code> flag is set, what happens also depends on whether the <code>link is still active or not</code> when the exit signal is received. </p></li> </ul> <p> Based on the above states, the following will happen when an exit signal is received by a process: </p> <ul> <li> <p>The exit signal is silently dropped if:</p> <ul> <li><p> the <code>link</code> flag of the exit signal is set and the corresponding link has been deactivated. </p></li> <li><p> the exit reason of the exit signal is the atom <code>normal</code>, the receiver is not trapping exits, and the receiver and sender are not the same process. </p></li> </ul> </li> <li> <p>The receiving process is terminated if:</p> <ul> <li><p> the <code>link</code> flag of the exit signal is not set, and the exit reason of the exit signal is the atom <code>kill</code>. The receiving process will terminate with the atom <code>killed</code> as exit reason. </p></li> <li><p> the receiver is not trapping exits, and the exit reason is something other than the atom <code>normal</code>. Also, if the <code>link</code> flag of the exit signal is set, the link also needs to be active otherwise the exit signal will be dropped. The exit reason of the receiving process will equal the exit reason of the exit signal. Note that if the <code>link</code> flag is set, an exit reason of <code>kill</code> will <strong>not</strong> be converted to <code>killed</code>. </p></li> <li><p> the exit reason of the exit signal is the atom <code>normal</code> and the sender of the exit signal is the same process as the receiver. The <code>link</code> flag cannot be set in this case. The exit reason of the receiving process will be the atom <code>normal</code>. </p></li> </ul> </li> <li> <p> The exit signal is converted to a message signal and added to the end of the message queue of the receiver, if the receiver is trapping exits, the <code>link</code> flag of the exit signal is: </p> <ul> <li><p> not set, and the exit reason of the signal is not the atom <code>kill</code>. </p></li> <li><p> set, and the corresponding link is active. Note that an exit reason of <code>kill</code> will <strong>not</strong> terminate the process in this case and it will not be converted to <code>killed</code>. </p></li> </ul> <p> The converted message will be on the form <code>{'EXIT', SenderID, Reason}</code> where <code>Reason</code> equals the exit reason of the exit signal and <code>SenderID</code> is the identifier of the process or port that sent the exit signal. </p> </li> </ul> <h2 id="monitors" class="title-link"> <div class="title-name">14.9 Monitors</div>  </h2> <p>An alternative to links are <strong>monitors</strong>. A process <code>Pid1</code> can create a monitor for <code>Pid2</code> by calling the BIF <code>erlang:monitor(process, Pid2)</code>. The function returns a reference <code>Ref</code>.</p> <p>If <code>Pid2</code> terminates with exit reason <code>Reason</code>, a 'DOWN' message is sent to <code>Pid1</code>:</p> <pre data-language="erlang">{'DOWN', Ref, process, Pid2, Reason}</pre> <p>If <code>Pid2</code> does not exist, the 'DOWN' message is sent immediately with <code>Reason</code> set to <code>noproc</code>.</p> <p>Monitors are unidirectional. Repeated calls to <code>erlang:monitor(process, Pid)</code> creates several independent monitors, and each one sends a 'DOWN' message when <code>Pid</code> terminates.</p> <p>A monitor can be removed by calling <code>erlang:demonitor(Ref)</code>.</p> <p>Monitors can be created for processes with registered names, also at other nodes.</p> <h2 id="process-dictionary" class="title-link"> <div class="title-name">14.10 Process Dictionary</div>  </h2> <p>Each process has its own process dictionary, accessed by calling the following BIFs:</p> <pre data-language="erlang">
put(Key, Value)
get(Key)
get()
get_keys(Value)
erase(Key)
erase()</pre> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2023 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
