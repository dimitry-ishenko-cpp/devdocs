<div class="innertube"> <h1 id="Opaques">8 Opaques</h1> <h2 id="opaque-type-aliases" class="title-link"> <div class="title-name">8.1 Opaque Type Aliases</div>  </h2> <p>The main use case for opacity in Erlang is to hide the implementation of a data type, enabling evolving the API while minimizing the risk of breaking consumers. The runtime does not check opacity. Dialyzer provides some opacity-checking, but the rest is up to convention. </p> <p> This document explains what Erlang opacity is (and the trade-offs involved) via the example of the <code>sets:set()</code> data type. This type <strong>was</strong> defined in the <code>sets</code> module like this: </p> <pre data-language="erlang">-opaque set(Element) :: #set{segs :: segs(Element)}.</pre> <p>OTP 24 changed the definition to the following in <code><a href="https://github.com/erlang/otp/commit/e66941e8d7c47b973dff94c0308ea85a6be1958e">this commit</a></code>. </p> <pre data-language="erlang">-opaque set(Element) :: #set{segs :: segs(Element)} | #{Element =&gt; ?VALUE}.</pre> <p> And this change was safer and more backwards-compatible than if the type had been defined with <code>-type</code> instead of <code>-opaque</code>. Here is why: when a module defines an <code>-opaque</code>, the contract is that only the defining module should rely on the definition of the type: no other modules should rely on the definition. </p> <p> This means that code that pattern-matched on <code>set</code> as a record/tuple technically broke the contract, and opted in to being potentially broken when the definition of <code>set()</code> changed. Before OTP 24, this code printed <code>ok</code>. In OTP 24 it may error: </p> <pre data-language="erlang">case sets:new() of
    Set when is_tuple(Set) -&gt;
        io:format("ok")
end.</pre> <p> <strong>When working with an opaque defined in another module, here are some recommendations:</strong> </p> <ul> <li> Don't examine the underlying type using pattern-matching, guards, or functions that reveal the type, such as <code>tuple_size/1</code> . </li> <li> Instead, use functions provided by the module for working with the type. For example, <code>sets</code> module provides <code>sets:new/0</code>, <code>sets:add/2</code>, <code>sets:is_element/2</code>, and so on. </li> <li> <code>sets:set(a)</code> is a subtype of <code>sets:set(a | b)</code> and not the other way around. Generally, you can rely on the property that <code>the_opaque(T)</code> is a subtype of <code>the_opaque(U)</code> when T is a subtype of U. </li> </ul> <p> <strong>When defining your own opaques, here are some recommendations:</strong> </p> <ul> <li> Since consumers are expected to not rely on the definition of the opaque type, you must provide functions for constructing, querying, and deconstructing instances of your opaque type. For example, sets can be constructed with <code>sets:new/0</code>, <code>sets:from_list/1</code>, <code>sets:add/2</code>, queried with <code>sets:is_element/2</code>, and deconstructed with<code>sets:to_list/1</code>. </li> <li> Don't define an opaque with a type variable in parameter position. This breaks the normal and expected behavior that (for example) <code>my_type(a)</code> is a subtype of <code>my_type(a | b)</code> </li> <li> Add <code><a href="typespec.html">specs</a></code> to exported functions that use the opaque type </li> </ul> <p>Note that opaques can be harder to work with for consumers, since the consumer is expected not to pattern-match and must instead use functions that the author of the opaque type provides to use instances of the type.</p> <p> Also, opacity in Erlang is skin-deep: the runtime does not enforce opacity-checking. So now that sets are implemented in terms of maps, an <code>is_map/1</code> check on a set <strong>will</strong> pass. The opacity rules are only enforced by convention and by additional tooling such as Dialyzer, and this enforcement is not total. A determined consumer of <code>sets</code> can still reveal the structure of the set, for example by printing, serializing, or using a set as a <code>term()</code> and inspecting it via functions like <code>is_map/1</code> or <code>maps:get/2</code>. Also, Dialyzer must make some <code><a href="https://github.com/erlang/otp/issues/5118">approximations</a></code>. </p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2023 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
