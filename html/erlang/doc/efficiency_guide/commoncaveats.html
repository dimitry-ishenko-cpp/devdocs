<div class="innertube"> <h1 id="Common Caveats">3 Common Caveats</h1> <p>This section lists a few modules and BIFs to watch out for, not only from a performance point of view.</p> <h2 id="timer-module" class="title-link"> <div class="title-name">3.1 Timer Module</div>  </h2> <p>Creating timers using <code>erlang:send_after/3</code> and <code>erlang:start_timer/3</code>, is more efficient than using the timers provided by the <code>timer</code> module in STDLIB.</p> <p>The <code>timer</code> module uses a separate process to manage the timers. Before OTP 25, this management overhead was substantial and increasing with the number of timers, especially when they were short-lived, so the timer server process could easily become overloaded and unresponsive. In OTP 25, the timer module was improved by removing most of the management overhead and the resulting performance penalty. Still, the timer server remains a single process, and it may at some point become a bottleneck of an application.</p> <p>The functions in the <code>timer</code> module that do not manage timers (such as <code>timer:tc/3</code> or <code>timer:sleep/1</code>), do not call the timer-server process and are therefore harmless.</p> <h2 id="accidental-copying-and-loss-of-sharing" class="title-link"> <div class="title-name">3.2 Accidental Copying and Loss of Sharing</div>  </h2> <p>When spawning a new process using a fun, one can accidentally copy more data to the process than intended. For example:</p> <p><strong>DO NOT</strong></p> <pre data-language="erlang">accidental1(State) -&gt;
    spawn(fun() -&gt;
                  io:format("~p\n", [State#state.info])
          end).</pre> <p>The code in the fun will extract one element from the record and print it. The rest of the <code>state</code> record is not used. However, when the <code>spawn/1</code> function is executed, the entire record is copied to the newly created process.</p> <p>The same kind of problem can happen with a map:</p> <p><strong>DO NOT</strong></p> <pre data-language="erlang">accidental2(State) -&gt;
    spawn(fun() -&gt;
                  io:format("~p\n", [map_get(info, State)])
          end).</pre> <p>In the following example (part of a module implementing the <code>gen_server</code> behavior) the created fun is sent to another process:</p> <p><strong>DO NOT</strong></p> <pre data-language="erlang">handle_call(give_me_a_fun, _From, State) -&gt;
    Fun = fun() -&gt; State#state.size =:= 42 end,
    {reply, Fun, State}.</pre> <p>How bad that unnecessary copy is depends on the contents of the record or the map.</p> <p>For example, if the <code>state</code> record is initialized like this:</p> <pre data-language="erlang">init1() -&gt;
    #state{data=lists:seq(1, 10000)}.</pre> <p>a list with 10000 elements (or about 20000 heap words) will be copied to the newly created process.</p> <p>An unnecessary copy of 10000 element list can be bad enough, but it can get even worse if the <code>state</code> record contains <strong>shared subterms</strong>. Here is a simple example of a term with a shared subterm:</p> <pre data-language="erlang">{SubTerm, SubTerm}</pre> <p>When a term is copied to another process, sharing of subterms will be lost and the copied term can be many times larger than the original term. For example:</p> <pre data-language="erlang">init2() -&gt;
    SharedSubTerms = lists:foldl(fun(_, A) -&gt; [A|A] end, [0], lists:seq(1, 15)),
    #state{data=Shared}.</pre> <p>In the process that calls <code>init2/0</code>, the size of the <code>data</code> field in the <code>state</code> record will be 32 heap words. When the record is copied to the newly created process, sharing will be lost and the size of the copied <code>data</code> field will be 131070 heap words. More details about <code><a href="processes.html#loss-of-sharing">loss off sharing</a></code> are found in a later section.</p> <p>To avoid the problem, outside of the fun extract only the fields of the record that are actually used:</p> <p><strong>DO</strong></p> <pre data-language="erlang">fixed_accidental1(State) -&gt;
    Info = State#state.info,
    spawn(fun() -&gt;
                  io:format("~p\n", [Info])
          end).</pre> <p>Similarly, outside of the fun extract only the map elements that are actually used:</p> <p><strong>DO</strong></p> <pre data-language="erlang">fixed_accidental2(State) -&gt;
    Info = map_get(info, State),
    spawn(fun() -&gt;
                  io:format("~p\n", [Info])
          end).</pre> <h2 id="list_to_atom-1" class="title-link"> <div class="title-name">3.3 list_to_atom/1</div>  </h2> <p>Atoms are not garbage-collected. Once an atom is created, it is never removed. The emulator terminates if the limit for the number of atoms (1,048,576 by default) is reached.</p> <p>Therefore, converting arbitrary input strings to atoms can be dangerous in a system that runs continuously. If only certain well-defined atoms are allowed as input, <code>list_to_existing_atom/1</code> can be used to guard against a denial-of-service attack. (All atoms that are allowed must have been created earlier, for example, by simply using all of them in a module and loading that module.)</p> <p>Using <code>list_to_atom/1</code> to construct an atom that is passed to <code>apply/3</code> as follows, is quite expensive and not recommended in time-critical code:</p> <pre data-language="erlang">apply(list_to_atom("some_prefix"++Var), foo, Args)</pre> <h2 id="length-1" class="title-link"> <div class="title-name">3.4 length/1</div>  </h2> <p>The time for calculating the length of a list is proportional to the length of the list, as opposed to <code>tuple_size/1</code>, <code>byte_size/1</code>, and <code>bit_size/1</code>, which all execute in constant time.</p> <p>Normally, there is no need to worry about the speed of <code>length/1</code>, because it is efficiently implemented in C. In time-critical code, you might want to avoid it if the input list could potentially be very long.</p> <p>Some uses of <code>length/1</code> can be replaced by matching. For example, the following code:</p> <pre data-language="erlang">foo(L) when length(L) &gt;= 3 -&gt;
    ...</pre> <p>can be rewritten to:</p> <pre data-language="erlang">foo([_,_,_|_]=L) -&gt;
   ...</pre> <p>One slight difference is that <code>length(L)</code> fails if <code>L</code> is an improper list, while the pattern in the second code fragment accepts an improper list.</p> <h2 id="setelement-3" class="title-link"> <div class="title-name">3.5 setelement/3</div>  </h2> <p><code>setelement/3</code> copies the tuple it modifies. Therefore, updating a tuple in a loop using <code>setelement/3</code> creates a new copy of the tuple every time.</p> <p>There is one exception to the rule that the tuple is copied. If the compiler clearly can see that destructively updating the tuple would give the same result as if the tuple was copied, the call to <code>setelement/3</code> is replaced with a special destructive <code>setelement</code> instruction. In the following code sequence, the first <code>setelement/3</code> call copies the tuple and modifies the ninth element:</p> <pre data-language="erlang">multiple_setelement(T0) -&gt;
    T1 = setelement(9, T0, bar),
    T2 = setelement(7, T1, foobar),
    setelement(5, T2, new_value).</pre> <p>The two following <code>setelement/3</code> calls modify the tuple in place.</p> <p>For the optimization to be applied, <strong>all</strong> the following conditions must be true:</p> <ul> <li>The indices must be integer literals, not variables or expressions.</li> <li>The indices must be given in descending order.</li> <li>There must be no calls to another function in between the calls to <code>setelement/3</code>.</li> <li>The tuple returned from one <code>setelement/3</code> call must only be used in the subsequent call to <code>setelement/3</code>.</li> </ul> <p>If the code cannot be structured as in the <code>multiple_setelement/1</code> example, the best way to modify multiple elements in a large tuple is to convert the tuple to a list, modify the list, and convert it back to a tuple.</p> <h2 id="size-1" class="title-link"> <div class="title-name">3.6 size/1</div>  </h2> <p><code>size/1</code> returns the size for both tuples and binaries.</p> <p>Using the BIFs <code>tuple_size/1</code> and <code>byte_size/1</code> gives the compiler and the runtime system more opportunities for optimization. Another advantage is that the BIFs give Dialyzer more type information.</p> <h2 id="split_binary-2" class="title-link"> <div class="title-name">3.7 split_binary/2</div>  </h2> <p>It is usually more efficient to split a binary using matching instead of calling the <code>split_binary/2</code> function. Furthermore, mixing bit syntax matching and <code>split_binary/2</code> can prevent some optimizations of bit syntax matching.</p> <p><strong>DO</strong></p> <pre data-language="erlang">&lt;&lt;Bin1:Num/binary,Bin2/binary&gt;&gt; = Bin,</pre> <p><strong>DO NOT</strong></p> <pre data-language="erlang">{Bin1,Bin2} = split_binary(Bin, Num)</pre> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2023 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
