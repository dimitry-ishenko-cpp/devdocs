<div class="innertube"> <h1 id="The Seven Myths of Erlang Performance">2 The Seven Myths of Erlang Performance</h1>  <p id="myths">Some truths seem to live on well beyond their best-before date, perhaps because "information" spreads faster from person-to-person than a single release note that says, for example, that body-recursive calls have become faster.</p> <p>This section tries to kill the old truths (or semi-truths) that have become myths.</p> <h2 id="myth--tail-recursive-functions-are-much-faster-----than-recursive-functions" class="title-link"> <div class="title-name">2.1 Myth: Tail-Recursive Functions are Much Faster Than Recursive Functions</div>  </h2> <h3 id="tail_recursive">
According to the myth, using a tail-recursive function that builds a list in reverse followed by a call to <code id="tail_recursive">lists:reverse/1</code> is faster than a body-recursive function that builds the list in correct order; the reason being that body-recursive functions use more memory than tail-recursive functions.</h3> <p>That was true to some extent before R12B. It was even more true before R7B. Today, not so much. A body-recursive function generally uses the same amount of memory as a tail-recursive function. It is generally not possible to predict whether the tail-recursive or the body-recursive version will be faster. Therefore, use the version that makes your code cleaner (hint: it is usually the body-recursive version).</p> <p>For a more thorough discussion about tail and body recursion, see <code><a href="http://ferd.ca/erlang-s-tail-recursion-is-not-a-silver-bullet.html">Erlang's Tail Recursion is Not a Silver Bullet</a></code>.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>A tail-recursive function that does not need to reverse the list at the end is faster than a body-recursive function, as are tail-recursive functions that do not construct any terms at all (for example, a function that sums all integers in a list).</p>
</div> </div> <h2 id="myth--operator--++--is-always-bad" class="title-link"> <div class="title-name">2.2 Myth: Operator "++" is Always Bad</div>  </h2> <p>The <code>++</code> operator has, somewhat undeservedly, got a bad reputation. It probably has something to do with code like the following, which is the most inefficient way there is to reverse a list:</p> <p><strong>DO NOT</strong></p> <pre data-language="erlang">naive_reverse([H|T]) -&gt;
    naive_reverse(T)++[H];
naive_reverse([]) -&gt;
    [].</pre> <p>As the <code>++</code> operator copies its left operand, the result is copied repeatedly, leading to quadratic complexity.</p> <p>But using <code>++</code> as follows is not bad:</p> <p><strong>OK</strong></p> <pre data-language="erlang">naive_but_ok_reverse([H|T], Acc) -&gt;
    naive_but_ok_reverse(T, [H]++Acc);
naive_but_ok_reverse([], Acc) -&gt;
    Acc.</pre> <p>Each list element is copied only once. The growing result <code>Acc</code> is the right operand for the <code>++</code> operator, and it is <strong>not</strong> copied.</p> <p>Experienced Erlang programmers would write as follows:</p> <p><strong>DO</strong></p> <pre data-language="erlang">vanilla_reverse([H|T], Acc) -&gt;
    vanilla_reverse(T, [H|Acc]);
vanilla_reverse([], Acc) -&gt;
    Acc.</pre> <p>This is slightly more efficient because here you do not build a list element only to copy it directly. (Or it would be more efficient if the compiler did not automatically rewrite <code>[H]++Acc</code> to <code>[H|Acc]</code>.)</p> <h2 id="myth--strings-are-slow" class="title-link"> <div class="title-name">2.3 Myth: Strings are Slow</div>  </h2> <p>String handling can be slow if done improperly. In Erlang, you need to think a little more about how the strings are used and choose an appropriate representation. If you use regular expressions, use the <code>re</code> module in STDLIB instead of the obsolete <code>regexp</code> module.</p> <h2 id="myth--repairing-a-dets-file-is-very-slow" class="title-link"> <div class="title-name">2.4 Myth: Repairing a Dets File is Very Slow</div>  </h2> <p>The repair time is still proportional to the number of records in the file, but Dets repairs used to be much slower in the past. Dets has been massively rewritten and improved.</p> <h2 id="myth--beam-is-a-stack-based-byte-code-virtual-machine------and-therefore-slow-" class="title-link"> <div class="title-name">2.5 Myth: BEAM is a Stack-Based Byte-Code Virtual Machine (and Therefore Slow)</div>  </h2> <p>BEAM is a register-based virtual machine. It has 1024 virtual registers that are used for holding temporary values and for passing arguments when calling functions. Variables that need to survive a function call are saved to the stack.</p> <p>BEAM is a threaded-code interpreter. Each instruction is word pointing directly to executable C-code, making instruction dispatching very fast.</p> <h2 id="myth--use--_--to-speed-up-your-program-when-a-variable-----is-not-used" class="title-link"> <div class="title-name">2.6 Myth: Use "_" to Speed Up Your Program When a Variable is Not Used</div>  </h2> <p>That was once true, but from R6B the BEAM compiler can see that a variable is not used.</p> <p>Similarly, trivial transformations on the source-code level such as converting a <code>case</code> statement to clauses at the top-level of the function seldom makes any difference to the generated code.</p> <h2 id="myth--a-nif-always-speeds-up-your-program" class="title-link"> <div class="title-name">2.7 Myth: A NIF Always Speeds Up Your Program</div>  </h2> <p>Rewriting Erlang code to a NIF to make it faster should be seen as a last resort. It is only guaranteed to be dangerous, but not guaranteed to speed up the program.</p> <p>Doing too much work in each NIF call will <code>degrade responsiveness of the VM</code>. Doing too little work may mean that the gain of the faster processing in the NIF is eaten up by the overhead of calling the NIF and checking the arguments.</p> <p>Be sure to read about <code>Long-running NIFs</code> before writing a NIF.</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2023 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
