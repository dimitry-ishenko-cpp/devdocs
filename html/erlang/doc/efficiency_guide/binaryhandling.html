<div class="innertube"> <h1 id="Constructing and Matching Binaries">4 Constructing and Matching Binaries</h1> <p>This section gives a few examples on how to handle binaries in an efficient way. The sections that follow take an in-depth look at how binaries are implemented and how to best take advantages of the optimizations done by the compiler and runtime system.</p> <p>Binaries can be efficiently <strong>built</strong> in the following way:</p> <p><strong>DO</strong></p> <pre data-language="erlang">my_list_to_binary(List) -&gt;
    my_list_to_binary(List, &lt;&lt;&gt;&gt;).

my_list_to_binary([H|T], Acc) -&gt;
    my_list_to_binary(T, &lt;&lt;Acc/binary,H&gt;&gt;);
my_list_to_binary([], Acc) -&gt;
    Acc.</pre> <p>Appending data to a binary as in the example is efficient because it is specially optimized by the runtime system to avoid copying the <code>Acc</code> binary every time.</p> <p>Prepending data to a binary in a loop is not efficient:</p> <p><strong>DO NOT</strong></p> <pre data-language="erlang">rev_list_to_binary(List) -&gt;
    rev_list_to_binary(List, &lt;&lt;&gt;&gt;).

rev_list_to_binary([H|T], Acc) -&gt;
    rev_list_to_binary(T, &lt;&lt;H,Acc/binary&gt;&gt;);
rev_list_to_binary([], Acc) -&gt;
    Acc.</pre> <p>This is not efficient for long lists because the <code>Acc</code> binary is copied every time. One way to make the function more efficient is like this:</p> <p><strong>DO NOT</strong></p> <pre data-language="erlang">rev_list_to_binary(List) -&gt;
    rev_list_to_binary(lists:reverse(List), &lt;&lt;&gt;&gt;).

rev_list_to_binary([H|T], Acc) -&gt;
    rev_list_to_binary(T, &lt;&lt;Acc/binary,H&gt;&gt;);
rev_list_to_binary([], Acc) -&gt;
    Acc.</pre> <p>Another way to avoid copying the binary each time is like this:</p> <p><strong>DO</strong></p> <pre data-language="erlang">rev_list_to_binary([H|T]) -&gt;
    RevTail = rev_list_to_binary(T),
    &lt;&lt;RevTail/binary,H&gt;&gt;;
rev_list_to_binary([]) -&gt;
    &lt;&lt;&gt;&gt;.</pre> <p>Note that in each of the <strong>DO</strong> examples, the binary to be appended to is always given as the first segment.</p> <p>Binaries can be efficiently <strong>matched</strong> in the following way:</p> <p><strong>DO</strong></p> <pre data-language="erlang">my_binary_to_list(&lt;&lt;H,T/binary&gt;&gt;) -&gt;
    [H|my_binary_to_list(T)];
my_binary_to_list(&lt;&lt;&gt;&gt;) -&gt; [].</pre> <h2 id="how-binaries-are-implemented" class="title-link"> <div class="title-name">4.1 How Binaries are Implemented</div>  </h2> <p>Internally, binaries and bitstrings are implemented in the same way. In this section, they are called <strong>binaries</strong> because that is what they are called in the emulator source code.</p> <p>Four types of binary objects are available internally:</p> <ul> <li> <p>Two are containers for binary data and are called:</p> <ul> <li> <strong>Refc binaries</strong> (short for <strong>reference-counted binaries</strong>)</li> <li><strong>Heap binaries</strong></li> </ul> </li> <li> <p>Two are merely references to a part of a binary and are called:</p> <ul> <li><strong>sub binaries</strong></li> <li><strong>match contexts</strong></li> </ul> </li> </ul> <h3 id="refc-binaries" class="title-link"> <div class="title-name">Refc Binaries</div>  </h3> <p>Refc binaries consist of two parts:</p> <ul> <li>An object stored on the process heap, called a <strong>ProcBin</strong> </li> <li>The binary object itself, stored outside all process heaps</li> </ul> <p>The binary object can be referenced by any number of ProcBins from any number of processes. The object contains a reference counter to keep track of the number of references, so that it can be removed when the last reference disappears.</p> <p>All ProcBin objects in a process are part of a linked list, so that the garbage collector can keep track of them and decrement the reference counters in the binary when a ProcBin disappears.</p> <h3 id="heap-binaries" class="title-link"> <div class="title-name">Heap Binaries</div>  </h3> <p>Heap binaries are small binaries, up to 64 bytes, and are stored directly on the process heap. They are copied when the process is garbage-collected and when they are sent as a message. They do not require any special handling by the garbage collector.</p> <h3 id="sub-binaries" class="title-link"> <div class="title-name">Sub Binaries</div>  </h3> <p>The reference objects <strong>sub binaries</strong> and <strong>match contexts</strong> can reference part of a refc binary or heap binary.</p> <h3 id="sub_binary">
A <strong id="sub_binary">sub binary</strong> is created by <code>split_binary/2</code> and when a binary is matched out in a binary pattern. A sub binary is a reference into a part of another binary (refc or heap binary, but never into another sub binary). Therefore, matching out a binary is relatively cheap because the actual binary data is never copied.</h3> <h3 id="match-context" class="title-link"> <div class="title-name">Match Context</div>  </h3>  <p id="match_context">A <strong>match context</strong> is similar to a sub binary, but is optimized for binary matching. For example, it contains a direct pointer to the binary data. For each field that is matched out of a binary, the position in the match context is incremented.</p> <p>The compiler tries to avoid generating code that creates a sub binary, only to shortly afterwards create a new match context and discard the sub binary. Instead of creating a sub binary, the match context is kept.</p> <p>The compiler can only do this optimization if it knows that the match context will not be shared. If it would be shared, the functional properties (also called referential transparency) of Erlang would break.</p> <h2 id="constructing-binaries" class="title-link"> <div class="title-name">4.2 Constructing Binaries</div>  </h2> <p>Appending to a binary or bitstring in the following way is specially optimized to avoid copying the binary:</p> <pre data-language="erlang">&lt;&lt;Binary/binary, ...&gt;&gt;
%% - OR -
&lt;&lt;Binary/bitstring, ...&gt;&gt;</pre> <p>This optimization is applied by the runtime system in a way that makes it effective in most circumstances (for exceptions, see <code><a href="#forced_copying">Circumstances That Force Copying</a></code>). The optimization in its basic form does not need any help from the compiler. However, the compiler add hints to the runtime system when it is safe to apply the optimization in a more efficient way.</p> <div class="change"> <div class="label">Change</div> <div class="content">

<p>The compiler support for making the optimization more efficient was added in Erlang/OTP 26.</p>
</div> </div> <p>To explain how the basic optimization works, let us examine the following code line by line:</p> <pre data-language="erlang">Bin0 = &lt;&lt;0&gt;&gt;,                    %% 1
Bin1 = &lt;&lt;Bin0/binary,1,2,3&gt;&gt;,    %% 2
Bin2 = &lt;&lt;Bin1/binary,4,5,6&gt;&gt;,    %% 3
Bin3 = &lt;&lt;Bin2/binary,7,8,9&gt;&gt;,    %% 4
Bin4 = &lt;&lt;Bin1/binary,17&gt;&gt;,       %% 5 !!!
{Bin4,Bin3}                      %% 6</pre> <ul> <li><p>Line 1 (marked with the <code>%% 1</code> comment), assigns a <code><a href="#heap_binary">heap binary</a></code> to the <code>Bin0</code> variable.</p></li> <li><p>Line 2 is an append operation. As <code>Bin0</code> has not been involved in an append operation, a new <code><a href="#refc_binary">refc binary</a></code> is created and the contents of <code>Bin0</code> is copied into it. The <strong>ProcBin</strong> part of the refc binary has its size set to the size of the data stored in the binary, while the binary object has extra space allocated. The size of the binary object is either twice the size of <code>Bin1</code> or 256, whichever is larger. In this case it is 256.</p></li> <li><p>Line 3 is more interesting. <code>Bin1</code> <strong>has</strong> been used in an append operation, and it has 252 bytes of unused storage at the end, so the 3 new bytes are stored there.</p></li> <li><p>Line 4. The same applies here. There are 249 bytes left, so there is no problem storing another 3 bytes.</p></li> <li> <p>Line 5. Here something <strong>interesting</strong> happens. Notice that the result is not appended to the previous result in <code>Bin3</code>, but to <code>Bin1</code>. It is expected that <code>Bin4</code> will be assigned the value <code>&lt;&lt;0,1,2,3,17&gt;&gt;</code>. It is also expected that <code>Bin3</code> will retain its value (<code>&lt;&lt;0,1,2,3,4,5,6,7,8,9&gt;&gt;</code>). Clearly, the runtime system cannot write byte <code>17</code> into the binary, because that would change the value of <code>Bin3</code> to <code>&lt;&lt;0,1,2,3,4,17,6,7,8,9&gt;&gt;</code>.</p> <p>To ensure that the value of <code>Bin3</code> is retained, the runtime system <strong>copies</strong> the contents of <code>Bin1</code> to a new refc binary before storing the <code>17</code> byte.</p> <p>Here is not explained how the runtime system can know that it is not allowed to write into <code>Bin1</code>; it is left as an exercise to the curious reader to figure out how it is done by reading the emulator sources, primarily <code>erl_bits.c</code>.</p> </li> </ul> <h3 id="compiler-support-for-constructing-binaries" class="title-link"> <div class="title-name">Compiler Support For Constructing Binaries</div>  </h3> <div class="change"> <div class="label">Change</div> <div class="content">

<p>The compiler support for making the optimization more efficient was added in Erlang/OTP 26.</p>
</div> </div> <p>In the example in the previous section, it was shown that the runtime system can handle an append operation to a heap binary by copying it to a refc binary (line 2), and also handle an append operation to a previous version of the binary by copying it (line 5). The support for doing that does not come for free. For example, to make it possible to know when it is necessary to copy the binary, for every append operation, the runtime system must create a sub binary.</p> <p>When the compiler can determine that none of those situations need to be handled and that the append operation cannot possibly fail, the compiler generates code that causes the runtime system to apply a more efficient variant of the optimization.</p> <p><strong>Example:</strong></p> <pre data-language="erlang">-module(repack).
-export([repack/1]).

repack(Bin) when is_binary(Bin) -&gt;
    repack(Bin, &lt;&lt;&gt;&gt;).

repack(&lt;&lt;C:8,T/binary&gt;&gt;, Result) -&gt;
    repack(T, &lt;&lt;Result/binary,C:16&gt;&gt;);
repack(&lt;&lt;&gt;&gt;, Result) -&gt;
    Result.</pre> <p>The <code>repack/2</code> function only keeps a single version of the binary, so there is never any need to copy the binary. The compiler rewrites the creation of the empty binary in <code>repack/1</code> to instead create a refc binary with 256 bytes already reserved; thus, the append operation in <code>repack/2</code> never needs to handle a binary not prepared for appending.</p> <h3 id="circumstances-that-force-copying" class="title-link"> <div class="title-name">Circumstances That Force Copying</div>  </h3> <p>The optimization of the binary append operation requires that there is a <strong>single</strong> ProcBin and a <strong>single reference</strong> to the ProcBin for the binary. The reason is that the binary object can be moved (reallocated) during an append operation, and when that happens, the pointer in the ProcBin must be updated. If there would be more than one ProcBin pointing to the binary object, it would not be possible to find and update all of them.</p> <p>Therefore, certain operations on a binary mark it so that any future append operation will be forced to copy the binary. In most cases, the binary object will be shrunk at the same time to reclaim the extra space allocated for growing.</p> <p>When appending to a binary as follows, only the binary returned from the latest append operation will support further cheap append operations:</p> <pre data-language="erlang">Bin = &lt;&lt;Bin0,...&gt;&gt;</pre> <p>In the code fragment in the beginning of this section, appending to <code>Bin</code> will be cheap, while appending to <code>Bin0</code> will force the creation of a new binary and copying of the contents of <code>Bin0</code>.</p> <p>If a binary is sent as a message to a process or port, the binary will be shrunk and any further append operation will copy the binary data into a new binary. For example, in the following code fragment <code>Bin1</code> will be copied in the third line:</p> <pre data-language="erlang">Bin1 = &lt;&lt;Bin0,...&gt;&gt;,
PortOrPid ! Bin1,
Bin = &lt;&lt;Bin1,...&gt;&gt;  %% Bin1 will be COPIED</pre> <p>The same happens if you insert a binary into an Ets table, send it to a port using <code>erlang:port_command/2</code>, or pass it to <code>enif_inspect_binary</code> in a NIF.</p> <p>Matching a binary will also cause it to shrink and the next append operation will copy the binary data:</p> <pre data-language="erlang">Bin1 = &lt;&lt;Bin0,...&gt;&gt;,
&lt;&lt;X,Y,Z,T/binary&gt;&gt; = Bin1,
Bin = &lt;&lt;Bin1,...&gt;&gt;  %% Bin1 will be COPIED</pre> <p>The reason is that a <code><a href="#match_context">match context</a></code> contains a direct pointer to the binary data.</p> <p>If a process simply keeps binaries (either in "loop data" or in the process dictionary), the garbage collector can eventually shrink the binaries. If only one such binary is kept, it will not be shrunk. If the process later appends to a binary that has been shrunk, the binary object will be reallocated to make place for the data to be appended.</p> <h2 id="matching-binaries" class="title-link"> <div class="title-name">4.3 Matching Binaries</div>  </h2> <p>Let us revisit the example in the beginning of the previous section:</p> <p><strong>DO</strong></p> <pre data-language="erlang">my_binary_to_list(&lt;&lt;H,T/binary&gt;&gt;) -&gt;
    [H|my_binary_to_list(T)];
my_binary_to_list(&lt;&lt;&gt;&gt;) -&gt; [].</pre> <p>The first time <code>my_binary_to_list/1</code> is called, a <code><a href="#match_context">match context</a></code> is created. The match context points to the first byte of the binary. 1 byte is matched out and the match context is updated to point to the second byte in the binary.</p> <p>At this point it would make sense to create a <code><a href="#sub_binary">sub binary</a></code>, but in this particular example the compiler sees that there will soon be a call to a function (in this case, to <code>my_binary_to_list/1</code> itself) that immediately will create a new match context and discard the sub binary.</p> <p>Therefore <code>my_binary_to_list/1</code> calls itself with the match context instead of with a sub binary. The instruction that initializes the matching operation basically does nothing when it sees that it was passed a match context instead of a binary.</p> <p>When the end of the binary is reached and the second clause matches, the match context will simply be discarded (removed in the next garbage collection, as there is no longer any reference to it).</p> <p>To summarize, <code>my_binary_to_list/1</code> only needs to create <strong>one</strong> match context and no sub binaries.</p> <p>Notice that the match context in <code>my_binary_to_list/1</code> was discarded when the entire binary had been traversed. What happens if the iteration stops before it has reached the end of the binary? Will the optimization still work?</p> <pre data-language="erlang">after_zero(&lt;&lt;0,T/binary&gt;&gt;) -&gt;
    T;
after_zero(&lt;&lt;_,T/binary&gt;&gt;) -&gt;
    after_zero(T);
after_zero(&lt;&lt;&gt;&gt;) -&gt;
    &lt;&lt;&gt;&gt;.</pre> <p>Yes, it will. The compiler will remove the building of the sub binary in the second clause:</p> <pre data-language="erlang">...
after_zero(&lt;&lt;_,T/binary&gt;&gt;) -&gt;
    after_zero(T);
...</pre> <p>But it will generate code that builds a sub binary in the first clause:</p> <pre data-language="erlang">after_zero(&lt;&lt;0,T/binary&gt;&gt;) -&gt;
    T;
...</pre> <p>Therefore, <code>after_zero/1</code> builds one match context and one sub binary (assuming it is passed a binary that contains a zero byte).</p> <p>Code like the following will also be optimized:</p> <pre data-language="erlang">all_but_zeroes_to_list(Buffer, Acc, 0) -&gt;
    {lists:reverse(Acc),Buffer};
all_but_zeroes_to_list(&lt;&lt;0,T/binary&gt;&gt;, Acc, Remaining) -&gt;
    all_but_zeroes_to_list(T, Acc, Remaining-1);
all_but_zeroes_to_list(&lt;&lt;Byte,T/binary&gt;&gt;, Acc, Remaining) -&gt;
    all_but_zeroes_to_list(T, [Byte|Acc], Remaining-1).</pre> <p>The compiler removes building of sub binaries in the second and third clauses, and it adds an instruction to the first clause that converts <code>Buffer</code> from a match context to a sub binary (or do nothing if <code>Buffer</code> is a binary already).</p> <p>But in more complicated code, how can one know whether the optimization is applied or not?</p> <h3 id="option-bin_opt_info" class="title-link"> <div class="title-name">Option bin_opt_info</div>  </h3> <p>Use the <code>bin_opt_info</code> option to have the compiler print a lot of information about binary optimizations. It can be given either to the compiler or <code>erlc</code>:</p> <pre data-language="erlang">erlc +bin_opt_info Mod.erl</pre> <p>or passed through an environment variable:</p> <pre data-language="erlang">export ERL_COMPILER_OPTIONS=bin_opt_info</pre> <p>Notice that the <code>bin_opt_info</code> is not meant to be a permanent option added to your <code>Makefile</code>s, because all messages that it generates cannot be eliminated. Therefore, passing the option through the environment is in most cases the most practical approach.</p> <p>The warnings look as follows:</p> <pre data-language="erlang">./efficiency_guide.erl:60: Warning: NOT OPTIMIZED: binary is returned from the function
./efficiency_guide.erl:62: Warning: OPTIMIZED: match context reused</pre> <p>To make it clearer exactly what code the warnings refer to, the warnings in the following examples are inserted as comments after the clause they refer to, for example:</p> <pre data-language="erlang">after_zero(&lt;&lt;0,T/binary&gt;&gt;) -&gt;
         %% BINARY CREATED: binary is returned from the function
    T;
after_zero(&lt;&lt;_,T/binary&gt;&gt;) -&gt;
         %% OPTIMIZED: match context reused
    after_zero(T);
after_zero(&lt;&lt;&gt;&gt;) -&gt;
    &lt;&lt;&gt;&gt;.</pre> <p>The warning for the first clause says that the creation of a sub binary cannot be delayed, because it will be returned. The warning for the second clause says that a sub binary will not be created (yet).</p> <h3 id="unused-variables" class="title-link"> <div class="title-name">Unused Variables</div>  </h3> <p>The compiler figures out if a variable is unused. The same code is generated for each of the following functions:</p> <pre data-language="erlang">count1(&lt;&lt;_,T/binary&gt;&gt;, Count) -&gt; count1(T, Count+1);
count1(&lt;&lt;&gt;&gt;, Count) -&gt; Count.

count2(&lt;&lt;H,T/binary&gt;&gt;, Count) -&gt; count2(T, Count+1);
count2(&lt;&lt;&gt;&gt;, Count) -&gt; Count.

count3(&lt;&lt;_H,T/binary&gt;&gt;, Count) -&gt; count3(T, Count+1);
count3(&lt;&lt;&gt;&gt;, Count) -&gt; Count.</pre> <p>In each iteration, the first 8 bits in the binary will be skipped, not matched out.</p> <h2 id="historical-note" class="title-link"> <div class="title-name">4.4 Historical Note</div>  </h2> <p>Binary handling was significantly improved in R12B. Because code that was efficient in R11B might not be efficient in R12B, and vice versa, earlier revisions of this Efficiency Guide contained some information about binary handling in R11B.</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2023 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
