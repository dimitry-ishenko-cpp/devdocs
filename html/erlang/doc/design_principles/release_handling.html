<div class="innertube"> <h1 id="Release Handling">11 Release Handling</h1>  <h2 id="release-handling-principles" class="title-link"> <div class="title-name">11.1 Release Handling Principles</div>  </h2> <p>An important feature of the Erlang programming language is the ability to change module code in runtime, <strong>code replacement</strong>, as described in the Erlang Reference Manual.</p> <p>Based on this feature, the OTP application SASL provides a framework for upgrading and downgrading between different versions of an entire release in runtime. This is called <strong>release handling</strong>.</p> <p>The framework consists of:</p> <ul> <li>Offline support - <code>systools</code> for generating scripts and building release packages</li> <li>Online support - <code>release_handler</code> for unpacking and installing release packages</li> </ul> <p>The minimal system based on Erlang/OTP, enabling release handling, thus consists of the Kernel, STDLIB, and SASL applications.</p> <h3 id="release-handling-workflow" class="title-link"> <div class="title-name">Release Handling Workflow</div>  </h3> <p><strong>Step 1</strong>) A release is created as described in <code><a href="release_structure.html">Releases</a></code>.</p> <p><strong>Step 2</strong>) The release is transferred to and installed at target environment. For information of how to install the first target system, see <code>System Principles</code>.</p> <p><strong>Step 3</strong>) Modifications, for example, error corrections, are made to the code in the development environment.</p> <p><strong>Step 4</strong>) At some point, it is time to make a new version of release. The relevant <code>.app</code> files are updated and a new <code>.rel</code> file is written.</p> <p><strong>Step 5</strong>) For each modified application, an <code><a href="#appup">application upgrade file</a></code>, <code>.appup</code>, is created. In this file, it is described how to upgrade and/or downgrade between the old and new version of the application.</p> <p><strong>Step 6</strong>) Based on the <code>.appup</code> files, a <code><a href="#relup">release upgrade file</a></code> called <code>relup</code>, is created. This file describes how to upgrade and/or downgrade between the old and new version of the entire release.</p> <p><strong>Step 7</strong>) A new release package is made and transferred to the target system.</p> <p><strong>Step 8</strong>) The new release package is unpacked using the release handler.</p> <p><strong>Step 9</strong>) The new version of the release is installed, also using the release handler. This is done by evaluating the instructions in <code>relup</code>. Modules can be added, deleted, or reloaded, applications can be started, stopped, or restarted, and so on. In some cases, it is even necessary to restart the entire emulator.</p> <ul> <li>If the installation fails, the system can be rebooted. The old release version is then automatically used.</li> <li>If the installation succeeds, the new version is made the default version, which is to now be used if there is a system reboot.</li> </ul> <h3 id="release-handling-aspects" class="title-link"> <div class="title-name">Release Handling Aspects</div>  </h3> <p><code><a href="appup_cookbook.html">Appup Cookbook</a></code>, contains examples of <code>.appup</code> files for typical cases of upgrades/downgrades that are normally easy to handle in runtime. However, many aspects can make release handling complicated, for example:</p> <ul> <li> <p>Complicated or circular dependencies can make it difficult or even impossible to decide in which order things must be done without risking runtime errors during an upgrade or downgrade. Dependencies can be:</p> <ul> <li>Between nodes</li> <li>Between processes</li> <li>Between modules</li> </ul> </li> <li> <p>During release handling, non-affected processes continue normal execution. This can lead to time-outs or other problems. For example, new processes created in the time window between suspending processes using a certain module, and loading a new version of this module, can execute old code.</p> </li> </ul> <p>It is thus recommended that code is changed in as small steps as possible, and always kept backwards compatible.</p> <h2 id="requirements" class="title-link"> <div class="title-name">11.2 Requirements</div>  </h2> <p>For release handling to work properly, the runtime system must have knowledge about which release it is running. It must also be able to change (in runtime) which boot script and system configuration file to use if the system is rebooted, for example, by <code>heart</code> after a failure. Thus, Erlang must be started as an embedded system; for information on how to do this, see Embedded System.</p> <p>For system reboots to work properly, it is also required that the system is started with heartbeat monitoring, see the <code>erl(1)</code> manual page in ERTS and the <code>heart(3)</code> manual page in Kernel</p> <p>Other requirements:</p> <ul> <li> <p>The boot script included in a release package must be generated from the same <code>.rel</code> file as the release package itself.</p> <p>Information about applications is fetched from the script when an upgrade or downgrade is performed.</p> </li> <li> <p>The system must be configured using only one system configuration file, called <code>sys.config</code>.</p> <p>If found, this file is automatically included when a release package is created.</p> </li> <li> <p>All versions of a release, except the first one, must contain a <code>relup</code> file.</p> <p>If found, this file is automatically included when a release package is created.</p> </li> </ul> <h2 id="distributed-systems" class="title-link"> <div class="title-name">11.3 Distributed Systems</div>  </h2> <p>If the system consists of several Erlang nodes, each node can use its own version of the release. The release handler is a locally registered process and must be called at each node where an upgrade or downgrade is required. A release handling instruction, <code>sync_nodes</code>, can be used to synchronize the release handler processes at a number of nodes, see the <code>appup(4)</code> manual page in SASL.</p> <h2 id="release-handling-instructions" class="title-link"> <div class="title-name">11.4 Release Handling Instructions</div>  </h2> <p>OTP supports a set of <strong>release handling instructions</strong> that are used when creating <code>.appup</code> files. The release handler understands a subset of these, the <strong>low-level</strong> instructions. To make it easier for the user, there are also a number of <strong>high-level</strong> instructions, which are translated to low-level instructions by <code>systools:make_relup</code>.</p> <p>Some of the most frequently used instructions are described in this section. The complete list of instructions is included in the <code>appup(4)</code> manual page in SASL.</p> <p>First, some definitions:</p> <ul> <li> <strong>Residence module</strong> - The module where a process has its tail-recursive loop function(s). If these functions are implemented in several modules, all those modules are residence modules for the process.</li> <li> <strong>Functional module</strong> - A module that is not a residence module for any process.</li> </ul> <p>For a process implemented using an OTP behaviour, the behaviour module is the residence module for that process. The callback module is a functional module.</p> <h3 id="load_module" class="title-link"> <div class="title-name">load_module</div>  </h3> <p>If a simple extension has been made to a functional module, it is sufficient to load the new version of the module into the system, and remove the old version. This is called <strong>simple code replacement</strong> and for this the following instruction is used:</p> <pre data-language="erlang">{load_module, Module}</pre> <h3 id="update" class="title-link"> <div class="title-name">update</div>  </h3> <p>If a more complex change has been made, for example, a change to the format of the internal state of a <code>gen_server</code>, simple code replacement is not sufficient. Instead, it is necessary to:</p> <ul> <li>Suspend the processes using the module (to avoid that they try to handle any requests before the code replacement is completed).</li> <li>Ask them to transform the internal state format and switch to the new version of the module.</li> <li>Remove the old version.</li> <li>Resume the processes.</li> </ul> <p>This is called <strong>synchronized code replacement</strong> and for this the following instructions are used:</p> <pre data-language="erlang">{update, Module, {advanced, Extra}}
{update, Module, supervisor}</pre> <p><code>update</code> with argument <code>{advanced,Extra}</code> is used when changing the internal state of a behaviour as described above. It causes behaviour processes to call the callback function <code>code_change</code>, passing the term <code>Extra</code> and some other information as arguments. See the manual pages for the respective behaviours and <code><a href="appup_cookbook.html#int_state">Appup Cookbook</a></code>.</p> <p><code>update</code> with argument <code>supervisor</code> is used when changing the start specification of a supervisor. See <code><a href="appup_cookbook.html#sup">Appup Cookbook</a></code>.</p> <p>When a module is to be updated, the release handler finds which processes that are <strong>using</strong> the module by traversing the supervision tree of each running application and checking all the child specifications:</p> <pre data-language="erlang">{Id, StartFunc, Restart, Shutdown, Type, Modules}</pre> <p>A process uses a module if the name is listed in <code>Modules</code> in the child specification for the process.</p> <p>If <code>Modules=dynamic</code>, which is the case for event managers, the event manager process informs the release handler about the list of currently installed event handlers (<code>gen_event</code>), and it is checked if the module name is in this list instead.</p> <p>The release handler suspends, asks for code change, and resumes processes by calling the functions <code>sys:suspend/1,2</code>, <code>sys:change_code/4,5</code>, and <code>sys:resume/1,2</code>, respectively.</p> <h3 id="add_module-and-delete_module" class="title-link"> <div class="title-name">add_module and delete_module</div>  </h3> <p>If a new module is introduced, the following instruction is used:</p> <pre data-language="erlang">{add_module, Module}</pre> <p>The instruction loads the module and is necessary when running Erlang in embedded mode. It is not strictly required when running Erlang in interactive (default) mode, since the code server then automatically searches for and loads unloaded modules.</p> <p>The opposite of <code>add_module</code> is <code>delete_module</code>, which unloads a module:</p> <pre data-language="erlang">{delete_module, Module}</pre> <p>Any process, in any application, with <code>Module</code> as residence module, is killed when the instruction is evaluated. The user must therefore ensure that all such processes are terminated before deleting the module, to avoid a situation with failing supervisor restarts.</p> <h3 id="application-instructions" class="title-link"> <div class="title-name">Application Instructions</div>  </h3> <p>The following is the instruction for adding an application:</p> <pre data-language="erlang">{add_application, Application}</pre> <p>Adding an application means that the modules defined by the <code>modules</code> key in the <code>.app</code> file are loaded using a number of <code>add_module</code> instructions, and then the application is started.</p> <p>The following is the instruction for removing an application:</p> <pre data-language="erlang">{remove_application, Application}</pre> <p>Removing an application means that the application is stopped, the modules are unloaded using a number of <code>delete_module</code> instructions, and then the application specification is unloaded from the application controller.</p> <p>The following is the instruction for restarting an application:</p> <pre data-language="erlang">{restart_application, Application}</pre> <p>Restarting an application means that the application is stopped and then started again similar to using the instructions <code>remove_application</code> and <code>add_application</code> in sequence.</p> <h3 id="apply--low-level-" class="title-link"> <div class="title-name">apply (Low-Level)</div>  </h3> <p>To call an arbitrary function from the release handler, the following instruction is used:</p> <pre data-language="erlang">{apply, {M, F, A}}</pre> <p>The release handler evaluates <code>apply(M, F, A)</code>.</p> <h3 id="restart_new_emulator--low-level-" class="title-link"> <div class="title-name">restart_new_emulator (Low-Level)</div>  </h3> <p>This instruction is used when changing to a new emulator version, or when any of the core applications Kernel, STDLIB, or SASL is upgraded. If a system reboot is needed for another reason, the <code>restart_emulator</code> instruction is to be used instead.</p> <p>This instruction requires that the system is started with heartbeat monitoring, see the <code>erl(1)</code> manual page in ERTS and the <code>heart(3)</code> manual page in Kernel.</p> <p>The <code>restart_new_emulator</code> instruction must always be the first instruction in a relup. If the relup is generated by <code>systools:make_relup/3,4</code>, this is automatically ensured.</p> <p>When the release handler encounters the instruction, it first generates a temporary boot file, which starts the new versions of the emulator and the core applications, and the old version of all other applications. Then it shuts down the current emulator by calling <code>init:reboot()</code>, see the <code>init(3)</code> manual page in Kernel. All processes are terminated gracefully and the system is rebooted by the <code>heart</code> program, using the temporary boot file. After the reboot, the rest of the relup instructions are executed. This is done as a part of the temporary boot script.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>This mechanism causes the new versions of the emulator and core applications to run with the old version of other applications during startup. Thus, take extra care to avoid incompatibility. Incompatible changes in the core applications can in some situations be necessary. If possible, such changes are preceded by deprecation over two major releases before the actual change. To ensure the application is not crashed by an incompatible change, always remove any call to deprecated functions as soon as possible.</p> </div> </div> <p>An info report is written when the upgrade is completed. To programmatically find out if the upgrade is complete, call <code>release_handler:which_releases(current)</code> and check if it returns the expected (that is, the new) release.</p> <p>The new release version must be made permanent when the new emulator is operational. Otherwise, the old version will be used if there is a new system reboot.</p> <p>On UNIX, the release handler tells the <code>heart</code> program which command to use to reboot the system. The environment variable <code>HEART_COMMAND</code>, normally used by the <code>heart</code> program, is ignored in this case. The command instead defaults to <code>$ROOT/bin/start</code>. Another command can be set by using the SASL configuration parameter <code>start_prg</code>, see the <code>sasl(6)</code> manual page.</p> <h3 id="restart_emulator--low-level-" class="title-link"> <div class="title-name">restart_emulator (Low-Level)</div>  </h3> <p>This instruction is not related to upgrades of ERTS or any of the core applications. It can be used by any application to force a restart of the emulator after all upgrade instructions are executed.</p> <p>A relup script can only have one <code>restart_emulator</code> instruction and it must always be placed at the end. If the relup is generated by <code>systools:make_relup/3,4</code>, this is automatically ensured.</p> <p>When the release handler encounters the instruction, it shuts down the emulator by calling <code>init:reboot()</code>, see the <code>init(3)</code> manual page in Kernel. All processes are terminated gracefully and the system can then be rebooted by the <code>heart</code> program using the new release version. No more upgrade instruction is executed after the restart.</p> <h2 id="application-upgrade-file" class="title-link"> <div class="title-name">11.5 Application Upgrade File</div>  </h2> <p>To define how to upgrade/downgrade between the current version and previous versions of an application, an <strong>application upgrade file</strong>, or in short an <code>.appup</code> file is created. The file is to be called <code>Application.appup</code>, where <code>Application</code> is the application name:</p> <pre data-language="erlang">{Vsn,
 [{UpFromVsn1, InstructionsU1},
  ...,
  {UpFromVsnK, InstructionsUK}],
 [{DownToVsn1, InstructionsD1},
  ...,
  {DownToVsnK, InstructionsDK}]}.</pre> <ul> <li> <code>Vsn</code>, a string, is the current version of the application, as defined in the <code>.app</code> file.</li> <li>Each <code>UpFromVsn</code> is a previous version of the application to upgrade from.</li> <li>Each <code>DownToVsn</code> is a previous version of the application to downgrade to.</li> <li>Each <code>Instructions</code> is a list of release handling instructions.</li> </ul> <p>For information about the syntax and contents of the <code>.appup</code> file, see the <code>appup(4)</code> manual page in SASL.</p> <p><code><a href="appup_cookbook.html">Appup Cookbook</a></code> includes examples of <code>.appup</code> files for typical upgrade/downgrade cases.</p> <p><strong>Example:</strong> Consider the release <code>ch_rel-1</code> from <code><a href="release_structure.html#ch_rel">Releases</a></code>. Assume you want to add a function <code>available/0</code> to server <code>ch3</code>, which returns the number of available channels (when trying out the example, change in a copy of the original directory, so that the first versions are still available):</p> <pre data-language="erlang">-module(ch3).
-behaviour(gen_server).

-export([start_link/0]).
-export([alloc/0, free/1]).
-export([available/0]).
-export([init/1, handle_call/3, handle_cast/2]).

start_link() -&gt;
    gen_server:start_link({local, ch3}, ch3, [], []).

alloc() -&gt;
    gen_server:call(ch3, alloc).

free(Ch) -&gt;
    gen_server:cast(ch3, {free, Ch}).

available() -&gt;
    gen_server:call(ch3, available).

init(_Args) -&gt;
    {ok, channels()}.

handle_call(alloc, _From, Chs) -&gt;
    {Ch, Chs2} = alloc(Chs),
    {reply, Ch, Chs2};
handle_call(available, _From, Chs) -&gt;
    N = available(Chs),
    {reply, N, Chs}.

handle_cast({free, Ch}, Chs) -&gt;
    Chs2 = free(Ch, Chs),
    {noreply, Chs2}.</pre> <p>A new version of the <code>ch_app.app</code> file must now be created, where the version is updated:</p> <pre data-language="erlang">{application, ch_app,
 [{description, "Channel allocator"},
  {vsn, "2"},
  {modules, [ch_app, ch_sup, ch3]},
  {registered, [ch3]},
  {applications, [kernel, stdlib, sasl]},
  {mod, {ch_app,[]}}
 ]}.</pre> <p>To upgrade <code>ch_app</code> from <code>"1"</code> to <code>"2"</code> (and to downgrade from <code>"2"</code> to <code>"1"</code>), you only need to load the new (old) version of the <code>ch3</code> callback module. Create the application upgrade file <code>ch_app.appup</code> in the <code>ebin</code> directory:</p> <pre data-language="erlang">{"2",
 [{"1", [{load_module, ch3}]}],
 [{"1", [{load_module, ch3}]}]
}.</pre> <h2 id="release-upgrade-file" class="title-link"> <div class="title-name">11.6 Release Upgrade File</div>  </h2> <p>To define how to upgrade/downgrade between the new version and previous versions of a release, a <strong>release upgrade file</strong>, or in short <code>relup</code> file, is to be created.</p> <p>This file does not need to be created manually, it can be generated by <code>systools:make_relup/3,4</code>. The relevant versions of the <code>.rel</code> file, <code>.app</code> files, and <code>.appup</code> files are used as input. It is deduced which applications are to be added and deleted, and which applications that must be upgraded and/or downgraded. The instructions for this are fetched from the <code>.appup</code> files and transformed into a single list of low-level instructions in the right order.</p> <p>If the <code>relup</code> file is relatively simple, it can be created manually. It is only to contain low-level instructions.</p> <p>For details about the syntax and contents of the release upgrade file, see the <code>relup(4)</code> manual page in SASL.</p> <p><strong>Example, continued from the previous section:</strong> You have a new version "2" of <code>ch_app</code> and an <code>.appup</code> file. A new version of the <code>.rel</code> file is also needed. This time the file is called <code>ch_rel-2.rel</code> and the release version string is changed from "A" to "B":</p> <pre data-language="erlang">{release,
 {"ch_rel", "B"},
 {erts, "5.3"},
 [{kernel, "2.9"},
  {stdlib, "1.12"},
  {sasl, "1.10"},
  {ch_app, "2"}]
}.</pre> <p>Now the <code>relup</code> file can be generated:</p> <pre data-language="erlang">
1&gt; <code>systools:make_relup("ch_rel-2", ["ch_rel-1"], ["ch_rel-1"]).</code>
ok</pre> <p>This generates a <code>relup</code> file with instructions for how to upgrade from version "A" ("ch_rel-1") to version "B" ("ch_rel-2") and how to downgrade from version "B" to version "A".</p> <p>Both the old and new versions of the <code>.app</code> and <code>.rel</code> files must be in the code path, as well as the <code>.appup</code> and (new) <code>.beam</code> files. The code path can be extended by using the option <code>path</code>:</p> <pre data-language="erlang">
1&gt; <code>systools:make_relup("ch_rel-2", ["ch_rel-1"], ["ch_rel-1"],</code>
<code>[{path,["../ch_rel-1",</code>
<code>"../ch_rel-1/lib/ch_app-1/ebin"]}]).</code>
ok</pre> <h2 id="installing-a-release" class="title-link"> <div class="title-name">11.7 Installing a Release</div>  </h2> <p>When you have made a new version of a release, a release package can be created with this new version and transferred to the target environment.</p> <p>To install the new version of the release in runtime, the <strong>release handler</strong> is used. This is a process belonging to the SASL application, which handles unpacking, installation, and removal of release packages. It is communicated through the <code>release_handler</code> module. For details, see the <code>release_handler(3)</code> manual page in SASL.</p> <p>Assuming there is an operational target system with installation root directory <code>$ROOT</code>, the release package with the new version of the release is to be copied to <code>$ROOT/releases</code>.</p> <p>First, <strong>unpack</strong> the release package. The files are then extracted from the package:</p> <pre data-language="erlang">release_handler:unpack_release(ReleaseName) =&gt; {ok, Vsn}</pre> <ul> <li> <code>ReleaseName</code> is the name of the release package except the <code>.tar.gz</code> extension.</li> <li> <code>Vsn</code> is the version of the unpacked release, as defined in its <code>.rel</code> file.</li> </ul> <p>A directory <code>$ROOT/lib/releases/Vsn</code> is created, where the <code>.rel</code> file, the boot script <code>start.boot</code>, the system configuration file <code>sys.config</code>, and <code>relup</code> are placed. For applications with new version numbers, the application directories are placed under <code>$ROOT/lib</code>. Unchanged applications are not affected.</p> <p>An unpacked release can be <strong>installed</strong>. The release handler then evaluates the instructions in <code>relup</code>, step by step:</p> <pre data-language="erlang">release_handler:install_release(Vsn) =&gt; {ok, FromVsn, []}</pre> <p>If an error occurs during the installation, the system is rebooted using the old version of the release. If installation succeeds, the system is afterwards using the new version of the release, but if anything happens and the system is rebooted, it starts using the previous version again.</p> <p>To be made the default version, the newly installed release must be made <strong>permanent</strong>, which means the previous version becomes <strong>old</strong>:</p> <pre data-language="erlang">release_handler:make_permanent(Vsn) =&gt; ok</pre> <p>The system keeps information about which versions are old and permanent in the files <code>$ROOT/releases/RELEASES</code> and <code>$ROOT/releases/start_erl.data</code>.</p> <p>To downgrade from <code>Vsn</code> to <code>FromVsn</code>, <code>install_release</code> must be called again:</p> <pre data-language="erlang">release_handler:install_release(FromVsn) =&gt; {ok, Vsn, []}</pre> <p>An installed, but not permanent, release can be <strong>removed</strong>. Information about the release is then deleted from <code>$ROOT/releases/RELEASES</code> and the release-specific code, that is, the new application directories and the <code>$ROOT/releases/Vsn</code> directory, are removed.</p> <pre data-language="erlang">release_handler:remove_release(Vsn) =&gt; ok</pre> <h3 id="example--continued-from-the-previous-sections-" class="title-link"> <div class="title-name">Example (continued from the previous sections)</div>  </h3> <p><strong>Step 1)</strong> Create a target system as described in System Principles of the first version <code>"A"</code> of <code>ch_rel</code> from <code><a href="release_structure.html#ch_rel">Releases</a></code>. This time <code>sys.config</code> must be included in the release package. If no configuration is needed, the file is to contain the empty list:</p> <pre data-language="erlang">[].</pre> <p><strong>Step 2)</strong> Start the system as a simple target system. In reality, it is to be started as an embedded system. However, using <code>erl</code> with the correct boot script and config file is enough for illustration purposes:</p> <pre data-language="erlang">
% <code>cd $ROOT</code>
% <code>bin/erl -boot $ROOT/releases/A/start -config $ROOT/releases/A/sys</code>
...</pre> <p><code>$ROOT</code> is the installation directory of the target system.</p> <p><strong>Step 3)</strong> In another Erlang shell, generate start scripts and create a release package for the new version <code>"B"</code>. Remember to include (a possible updated) <code>sys.config</code> and the <code>relup</code> file, see <code><a href="#relup">Release Upgrade File</a></code>.</p> <pre data-language="erlang">
1&gt; <code>systools:make_script("ch_rel-2").</code>
ok
2&gt; <code>systools:make_tar("ch_rel-2").</code>
ok</pre> <p>The new release package now also contains version "2" of <code>ch_app</code> and the <code>relup</code> file:</p> <pre data-language="erlang">% tar tf ch_rel-2.tar
lib/kernel-2.9/ebin/kernel.app
lib/kernel-2.9/ebin/application.beam
...
lib/stdlib-1.12/ebin/stdlib.app
lib/stdlib-1.12/ebin/beam_lib.beam
...
lib/sasl-1.10/ebin/sasl.app
lib/sasl-1.10/ebin/sasl.beam
...
lib/ch_app-2/ebin/ch_app.app
lib/ch_app-2/ebin/ch_app.beam
lib/ch_app-2/ebin/ch_sup.beam
lib/ch_app-2/ebin/ch3.beam
releases/B/start.boot
releases/B/relup
releases/B/sys.config
releases/B/ch_rel-2.rel
releases/ch_rel-2.rel</pre> <p><strong>Step 4)</strong> Copy the release package <code>ch_rel-2.tar.gz</code> to the <code>$ROOT/releases</code> directory.</p> <p><strong>Step 5)</strong> In the running target system, unpack the release package:</p> <pre data-language="erlang">
1&gt; <code>release_handler:unpack_release("ch_rel-2").</code>
{ok,"B"}</pre> <p>The new application version <code>ch_app-2</code> is installed under <code>$ROOT/lib</code> next to <code>ch_app-1</code>. The <code>kernel</code>, <code>stdlib</code>, and <code>sasl</code> directories are not affected, as they have not changed.</p> <p>Under <code>$ROOT/releases</code>, a new directory <code>B</code> is created, containing <code>ch_rel-2.rel</code>, <code>start.boot</code>, <code>sys.config</code>, and <code>relup</code>.</p> <p><strong>Step 6)</strong> Check if the function <code>ch3:available/0</code> is available:</p> <pre data-language="erlang">
2&gt; <code>ch3:available().</code>
** exception error: undefined function ch3:available/0</pre> <p><strong>Step 7)</strong> Install the new release. The instructions in <code>$ROOT/releases/B/relup</code> are executed one by one, resulting in the new version of <code>ch3</code> being loaded. The function <code>ch3:available/0</code> is now available:</p> <pre data-language="erlang">
3&gt; <code>release_handler:install_release("B").</code>
{ok,"A",[]}
4&gt; <code>ch3:available().</code>
3
5&gt; <code>code:which(ch3).</code>
".../lib/ch_app-2/ebin/ch3.beam"
6&gt; <code>code:which(ch_sup).</code>
".../lib/ch_app-1/ebin/ch_sup.beam"</pre> <p>Processes in <code>ch_app</code> for which code have not been updated, for example, the supervisor, are still evaluating code from <code>ch_app-1</code>.</p> <p><strong>Step 8)</strong> If the target system is now rebooted, it uses version "A" again. The "B" version must be made permanent, to be used when the system is rebooted.</p> <pre data-language="erlang">
7&gt; <code>release_handler:make_permanent("B").</code>
ok</pre> <h2 id="updating-application-specifications" class="title-link"> <div class="title-name">11.8 Updating Application Specifications</div>  </h2> <p>When a new version of a release is installed, the application specifications are automatically updated for all loaded applications.</p> <div class="note"> <div class="label">Note</div> <div class="content">

<p>The information about the new application specifications is fetched from the boot script included in the release package. Thus, it is important that the boot script is generated from the same <code>.rel</code> file as is used to build the release package itself.</p> </div> </div> <p>Specifically, the application configuration parameters are automatically updated according to (in increasing priority order):</p> <ul> <li>The data in the boot script, fetched from the new application resource file <code>App.app</code> </li> <li>The new <code>sys.config</code> </li> <li>Command-line arguments <code>-App Par Val</code> </li> </ul> <p>This means that parameter values set in the other system configuration files and values set using <code>application:set_env/3</code> are disregarded.</p> <p>When an installed release is made permanent, the system process <code>init</code> is set to point out the new <code>sys.config</code>.</p> <p>After the installation, the application controller compares the old and new configuration parameters for all running applications and call the callback function:</p> <pre data-language="erlang">Module:config_change(Changed, New, Removed)</pre> <ul> <li> <code>Module</code> is the application callback module as defined by the <code>mod</code> key in the <code>.app</code> file.</li> <li> <code>Changed</code> and <code>New</code> are lists of <code>{Par,Val}</code> for all changed and added configuration parameters, respectively.</li> <li> <code>Removed</code> is a list of all parameters <code>Par</code> that have been removed.</li> </ul> <p>The function is optional and can be omitted when implementing an application callback module.</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2023 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>
